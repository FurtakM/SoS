// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60884 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 52181 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 52181 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 52181 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 52181 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4594 0 0
// PrepareRussian ;
 189: CALL 3007 0 0
// PrepareAlliance ;
 193: CALL 925 0 0
// MC_Start ( ) ;
 197: CALL 63064 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9382 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 85037 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 85482 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 85940 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 86217 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 85422 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 86120 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 85482 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 85940 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 86217 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 85266 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 86547 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 85422 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: IFFALSE 865
 850: PUSH
 851: LD_EXP 50
 855: PPUSH
 856: CALL_OW 255
 860: PUSH
 861: LD_INT 7
 863: EQUAL
 864: AND
 865: IFFALSE 878
 867: PUSH
 868: LD_EXP 51
 872: PPUSH
 873: CALL_OW 302
 877: AND
 878: IFFALSE 891
 880: PUSH
 881: LD_EXP 50
 885: PPUSH
 886: CALL_OW 302
 890: AND
 891: IFFALSE 903
 893: GO 895
 895: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 896: LD_STRING ACH_COMRADE
 898: PPUSH
 899: CALL_OW 543
 903: END
// every 0 0$1 trigger hack_counter >= 10 do
 904: LD_EXP 16
 908: PUSH
 909: LD_INT 10
 911: GREATEREQUAL
 912: IFFALSE 924
 914: GO 916
 916: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 917: LD_STRING ACH_HACK
 919: PPUSH
 920: CALL_OW 543
 924: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 925: LD_INT 0
 927: PPUSH
 928: PPUSH
 929: PPUSH
 930: PPUSH
// uc_side := 7 ;
 931: LD_ADDR_OWVAR 20
 935: PUSH
 936: LD_INT 7
 938: ST_TO_ADDR
// uc_nation := 1 ;
 939: LD_ADDR_OWVAR 21
 943: PUSH
 944: LD_INT 1
 946: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 947: LD_ADDR_EXP 17
 951: PUSH
 952: LD_STRING JMM
 954: PPUSH
 955: LD_EXP 1
 959: NOT
 960: PPUSH
 961: LD_STRING 12a_
 963: PPUSH
 964: CALL 17398 0 3
 968: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 71
 976: PPUSH
 977: LD_INT 23
 979: PPUSH
 980: LD_INT 0
 982: PPUSH
 983: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 987: LD_EXP 17
 991: PPUSH
 992: LD_INT 2
 994: PPUSH
 995: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 999: LD_ADDR_EXP 18
1003: PUSH
1004: LD_STRING Roth
1006: PPUSH
1007: LD_EXP 1
1011: NOT
1012: PPUSH
1013: LD_STRING 12a_
1015: PPUSH
1016: CALL 17398 0 3
1020: ST_TO_ADDR
// if Roth then
1021: LD_EXP 18
1025: IFFALSE 1045
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1027: LD_EXP 18
1031: PPUSH
1032: LD_INT 71
1034: PPUSH
1035: LD_INT 21
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 34
1049: PUSH
1050: LD_STRING Mike
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 17398 0 3
1066: ST_TO_ADDR
// if Mike then
1067: LD_EXP 34
1071: IFFALSE 1088
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1073: LD_EXP 34
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 19
1092: PUSH
1093: LD_STRING Lisa
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 17398 0 3
1109: ST_TO_ADDR
// if Lisa then
1110: LD_EXP 19
1114: IFFALSE 1131
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1116: LD_EXP 19
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 20
1135: PUSH
1136: LD_STRING Donaldson
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 17398 0 3
1152: ST_TO_ADDR
// if Donaldson then
1153: LD_EXP 20
1157: IFFALSE 1174
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1159: LD_EXP 20
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 21
1178: PUSH
1179: LD_STRING Bobby
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 17398 0 3
1195: ST_TO_ADDR
// if Bobby then
1196: LD_EXP 21
1200: IFFALSE 1217
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1202: LD_EXP 21
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 22
1221: PUSH
1222: LD_STRING Cyrus
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 17398 0 3
1238: ST_TO_ADDR
// if Cyrus then
1239: LD_EXP 22
1243: IFFALSE 1260
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1245: LD_EXP 22
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 23
1264: PUSH
1265: LD_STRING Denis
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 17398 0 3
1281: ST_TO_ADDR
// if Denis then
1282: LD_EXP 23
1286: IFFALSE 1303
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1288: LD_EXP 23
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 24
1307: PUSH
1308: LD_STRING Brown
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 17398 0 3
1324: ST_TO_ADDR
// if Brown then
1325: LD_EXP 24
1329: IFFALSE 1346
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1331: LD_EXP 24
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 25
1350: PUSH
1351: LD_STRING Gladstone
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 17398 0 3
1367: ST_TO_ADDR
// if Gladstone then
1368: LD_EXP 25
1372: IFFALSE 1389
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1374: LD_EXP 25
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 26
1393: PUSH
1394: LD_STRING Houten
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 17398 0 3
1410: ST_TO_ADDR
// if Houten then
1411: LD_EXP 26
1415: IFFALSE 1432
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1417: LD_EXP 26
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 27
1436: PUSH
1437: LD_STRING Cornell
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 17398 0 3
1453: ST_TO_ADDR
// if Cornel then
1454: LD_EXP 27
1458: IFFALSE 1475
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1460: LD_EXP 27
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1475: LD_ADDR_EXP 28
1479: PUSH
1480: LD_STRING Gary
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: LD_STRING 12a_
1491: PPUSH
1492: CALL 17398 0 3
1496: ST_TO_ADDR
// if Gary then
1497: LD_EXP 28
1501: IFFALSE 1518
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1503: LD_EXP 28
1507: PPUSH
1508: LD_INT 13
1510: PPUSH
1511: LD_INT 0
1513: PPUSH
1514: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1518: LD_ADDR_EXP 29
1522: PUSH
1523: LD_STRING Frank
1525: PPUSH
1526: LD_EXP 1
1530: NOT
1531: PPUSH
1532: LD_STRING 12a_
1534: PPUSH
1535: CALL 17398 0 3
1539: ST_TO_ADDR
// if Frank then
1540: LD_EXP 29
1544: IFFALSE 1561
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1546: LD_EXP 29
1550: PPUSH
1551: LD_INT 13
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1561: LD_ADDR_EXP 30
1565: PUSH
1566: LD_STRING Kikuchi
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 12a_
1577: PPUSH
1578: CALL 17398 0 3
1582: ST_TO_ADDR
// if Kikuchi then
1583: LD_EXP 30
1587: IFFALSE 1604
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1589: LD_EXP 30
1593: PPUSH
1594: LD_INT 13
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1604: LD_ADDR_EXP 31
1608: PUSH
1609: LD_STRING Simms
1611: PPUSH
1612: LD_EXP 1
1616: NOT
1617: PPUSH
1618: LD_STRING 12a_
1620: PPUSH
1621: CALL 17398 0 3
1625: ST_TO_ADDR
// if Simms then
1626: LD_EXP 31
1630: IFFALSE 1647
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1632: LD_EXP 31
1636: PPUSH
1637: LD_INT 13
1639: PPUSH
1640: LD_INT 0
1642: PPUSH
1643: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1647: LD_ADDR_EXP 32
1651: PUSH
1652: LD_STRING Joan
1654: PPUSH
1655: LD_EXP 1
1659: NOT
1660: PPUSH
1661: LD_STRING 12a_
1663: PPUSH
1664: CALL 17398 0 3
1668: ST_TO_ADDR
// if Joan then
1669: LD_EXP 32
1673: IFFALSE 1690
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1675: LD_EXP 32
1679: PPUSH
1680: LD_INT 13
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1690: LD_ADDR_EXP 33
1694: PUSH
1695: LD_STRING DeltaDoctor
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 12a_
1706: PPUSH
1707: CALL 17398 0 3
1711: ST_TO_ADDR
// if DeltaDoctor then
1712: LD_EXP 33
1716: IFFALSE 1733
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1718: LD_EXP 33
1722: PPUSH
1723: LD_INT 13
1725: PPUSH
1726: LD_INT 0
1728: PPUSH
1729: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1733: LD_ADDR_VAR 0 4
1737: PUSH
1738: LD_STRING 12a_others
1740: PPUSH
1741: CALL_OW 31
1745: ST_TO_ADDR
// if tmp then
1746: LD_VAR 0 4
1750: IFFALSE 1784
// for i in tmp do
1752: LD_ADDR_VAR 0 3
1756: PUSH
1757: LD_VAR 0 4
1761: PUSH
1762: FOR_IN
1763: IFFALSE 1782
// PlaceUnitArea ( i , alliance_start , false ) ;
1765: LD_VAR 0 3
1769: PPUSH
1770: LD_INT 13
1772: PPUSH
1773: LD_INT 0
1775: PPUSH
1776: CALL_OW 49
1780: GO 1762
1782: POP
1783: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 3
1789: PPUSH
1790: LD_INT 3
1792: PPUSH
1793: LD_INT 12
1795: PPUSH
1796: LD_INT 100
1798: PPUSH
1799: CALL 22360 0 5
// veh := CreateVehicle ;
1803: LD_ADDR_VAR 0 2
1807: PUSH
1808: CALL_OW 45
1812: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1813: LD_VAR 0 2
1817: PPUSH
1818: LD_INT 2
1820: PPUSH
1821: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1825: LD_VAR 0 2
1829: PPUSH
1830: LD_INT 60
1832: PPUSH
1833: LD_INT 6
1835: PPUSH
1836: LD_INT 0
1838: PPUSH
1839: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 4
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1858: LD_STRING 11_artifact_captured
1860: PPUSH
1861: LD_INT 0
1863: PPUSH
1864: CALL_OW 30
1868: IFFALSE 1944
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 3
1875: PPUSH
1876: LD_INT 3
1878: PPUSH
1879: LD_INT 12
1881: PPUSH
1882: LD_INT 100
1884: PPUSH
1885: CALL 22360 0 5
// veh := CreateVehicle ;
1889: LD_ADDR_VAR 0 2
1893: PUSH
1894: CALL_OW 45
1898: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1899: LD_VAR 0 2
1903: PPUSH
1904: LD_INT 3
1906: PPUSH
1907: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1911: LD_VAR 0 2
1915: PPUSH
1916: LD_INT 75
1918: PPUSH
1919: LD_INT 6
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1929: LD_VAR 0 2
1933: PPUSH
1934: LD_INT 4
1936: PPUSH
1937: LD_INT 50
1939: PPUSH
1940: CALL_OW 290
// end ; end ;
1944: LD_VAR 0 1
1948: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1949: LD_INT 0
1951: PPUSH
1952: PPUSH
1953: PPUSH
1954: PPUSH
// uc_side := 6 ;
1955: LD_ADDR_OWVAR 20
1959: PUSH
1960: LD_INT 6
1962: ST_TO_ADDR
// uc_nation := 3 ;
1963: LD_ADDR_OWVAR 21
1967: PUSH
1968: LD_INT 3
1970: ST_TO_ADDR
// InitHc ;
1971: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1975: LD_ADDR_EXP 35
1979: PUSH
1980: LD_STRING Gossudarov
1982: PPUSH
1983: CALL_OW 25
1987: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1988: LD_ADDR_EXP 36
1992: PUSH
1993: LD_STRING Kirilenkova
1995: PPUSH
1996: CALL_OW 25
2000: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
2001: LD_ADDR_EXP 37
2005: PUSH
2006: LD_STRING Titov
2008: PPUSH
2009: CALL_OW 25
2013: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2014: LD_ADDR_EXP 42
2018: PUSH
2019: LD_STRING Oblukov
2021: PPUSH
2022: CALL_OW 25
2026: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2027: LD_ADDR_EXP 39
2031: PUSH
2032: LD_STRING Dolgov
2034: PPUSH
2035: CALL_OW 25
2039: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2040: LD_ADDR_EXP 40
2044: PUSH
2045: LD_STRING Petrosyan
2047: PPUSH
2048: CALL_OW 25
2052: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2053: LD_ADDR_EXP 41
2057: PUSH
2058: LD_STRING Scholtze
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2066: LD_ADDR_EXP 43
2070: PUSH
2071: LD_STRING Kapitsova
2073: PPUSH
2074: CALL_OW 25
2078: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2079: LD_ADDR_VAR 0 2
2083: PUSH
2084: LD_EXP 35
2088: PUSH
2089: LD_EXP 36
2093: PUSH
2094: LD_EXP 37
2098: PUSH
2099: LD_EXP 42
2103: PUSH
2104: LD_EXP 39
2108: PUSH
2109: LD_EXP 40
2113: PUSH
2114: LD_EXP 41
2118: PUSH
2119: LD_EXP 43
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 4
2139: PPUSH
2140: LD_INT 8
2142: PPUSH
2143: CALL_OW 380
// un := CreateHuman ;
2147: LD_ADDR_VAR 0 4
2151: PUSH
2152: CALL_OW 44
2156: ST_TO_ADDR
// tmp := tmp ^ un ;
2157: LD_ADDR_VAR 0 2
2161: PUSH
2162: LD_VAR 0 2
2166: PUSH
2167: LD_VAR 0 4
2171: ADD
2172: ST_TO_ADDR
// for i in tmp do
2173: LD_ADDR_VAR 0 3
2177: PUSH
2178: LD_VAR 0 2
2182: PUSH
2183: FOR_IN
2184: IFFALSE 2203
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2186: LD_VAR 0 3
2190: PPUSH
2191: LD_INT 14
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
2201: GO 2183
2203: POP
2204: POP
// if freedom then
2205: LD_EXP 3
2209: IFFALSE 2242
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_EXP 3
2220: PPUSH
2221: CALL_OW 250
2225: PPUSH
2226: LD_EXP 3
2230: PPUSH
2231: CALL_OW 251
2235: PPUSH
2236: CALL_OW 111
2240: GO 2257
// ComMoveXY ( tmp , 70 , 48 ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 70
2249: PPUSH
2250: LD_INT 48
2252: PPUSH
2253: CALL_OW 111
// end ;
2257: LD_VAR 0 1
2261: RET
// export function PrepareBelkov ; begin
2262: LD_INT 0
2264: PPUSH
// uc_side := 4 ;
2265: LD_ADDR_OWVAR 20
2269: PUSH
2270: LD_INT 4
2272: ST_TO_ADDR
// uc_nation := 3 ;
2273: LD_ADDR_OWVAR 21
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// InitHc ;
2281: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2285: LD_ADDR_EXP 50
2289: PUSH
2290: LD_STRING Belkov
2292: PPUSH
2293: CALL_OW 25
2297: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2298: LD_EXP 50
2302: PPUSH
2303: LD_INT 14
2305: PPUSH
2306: LD_INT 0
2308: PPUSH
2309: CALL_OW 49
// end ;
2313: LD_VAR 0 1
2317: RET
// export function PrepareGnyevko ; begin
2318: LD_INT 0
2320: PPUSH
// uc_side := 4 ;
2321: LD_ADDR_OWVAR 20
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// uc_nation := 3 ;
2329: LD_ADDR_OWVAR 21
2333: PUSH
2334: LD_INT 3
2336: ST_TO_ADDR
// InitHc ;
2337: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2341: LD_ADDR_EXP 51
2345: PUSH
2346: LD_STRING Gnyevko
2348: PPUSH
2349: CALL_OW 25
2353: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2354: LD_EXP 51
2358: PPUSH
2359: LD_INT 14
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 49
// end ;
2369: LD_VAR 0 1
2373: RET
// export function PrepareBurlak ; var i , tmp ; begin
2374: LD_INT 0
2376: PPUSH
2377: PPUSH
2378: PPUSH
// uc_side := 4 ;
2379: LD_ADDR_OWVAR 20
2383: PUSH
2384: LD_INT 4
2386: ST_TO_ADDR
// uc_nation := 3 ;
2387: LD_ADDR_OWVAR 21
2391: PUSH
2392: LD_INT 3
2394: ST_TO_ADDR
// InitHc ;
2395: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2399: LD_ADDR_EXP 49
2403: PUSH
2404: LD_STRING Burlak
2406: PPUSH
2407: CALL_OW 25
2411: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2412: LD_INT 24
2414: PUSH
2415: LD_INT 23
2417: PUSH
2418: LD_INT 22
2420: PUSH
2421: LD_INT 22
2423: PUSH
2424: EMPTY
2425: LIST
2426: LIST
2427: LIST
2428: LIST
2429: PUSH
2430: LD_OWVAR 67
2434: ARRAY
2435: PPUSH
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 1
2441: PPUSH
2442: LD_INT 45
2444: PUSH
2445: LD_INT 44
2447: PUSH
2448: LD_INT 43
2450: PUSH
2451: LD_INT 42
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: PUSH
2460: LD_OWVAR 67
2464: ARRAY
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL 22360 0 5
// Masha := CreateVehicle ;
2473: LD_ADDR_EXP 52
2477: PUSH
2478: CALL_OW 45
2482: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2483: LD_EXP 52
2487: PUSH
2488: LD_EXP 49
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PPUSH
2497: LD_INT 499
2499: PPUSH
2500: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2504: LD_EXP 52
2508: PPUSH
2509: LD_INT 3
2511: PPUSH
2512: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2516: LD_EXP 52
2520: PPUSH
2521: LD_INT 1
2523: PPUSH
2524: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2528: LD_INT 1
2530: PPUSH
2531: LD_INT 18
2533: PPUSH
2534: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2538: LD_INT 35
2540: PPUSH
2541: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: LD_INT 18
2552: PPUSH
2553: EMPTY
2554: PPUSH
2555: CALL_OW 70
2559: ST_TO_ADDR
// if tmp then
2560: LD_VAR 0 3
2564: IFFALSE 2598
// for i in tmp do
2566: LD_ADDR_VAR 0 2
2570: PUSH
2571: LD_VAR 0 3
2575: PUSH
2576: FOR_IN
2577: IFFALSE 2596
// ComMoveXY ( i , 114 , 9 ) ;
2579: LD_VAR 0 2
2583: PPUSH
2584: LD_INT 114
2586: PPUSH
2587: LD_INT 9
2589: PPUSH
2590: CALL_OW 111
2594: GO 2576
2596: POP
2597: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2598: LD_INT 18
2600: PPUSH
2601: EMPTY
2602: PPUSH
2603: CALL_OW 70
2607: NOT
2608: IFFALSE 2626
2610: PUSH
2611: LD_INT 123
2613: PPUSH
2614: LD_INT 3
2616: PPUSH
2617: CALL_OW 428
2621: PUSH
2622: LD_INT 0
2624: EQUAL
2625: AND
2626: IFFALSE 2538
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2628: LD_EXP 52
2632: PPUSH
2633: LD_INT 123
2635: PPUSH
2636: LD_INT 3
2638: PPUSH
2639: LD_INT 0
2641: PPUSH
2642: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2646: LD_EXP 49
2650: PPUSH
2651: LD_INT 125
2653: PPUSH
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 0
2659: PPUSH
2660: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2664: LD_EXP 49
2668: PPUSH
2669: LD_EXP 52
2673: PPUSH
2674: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2678: LD_INT 10
2680: PPUSH
2681: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2685: LD_EXP 52
2689: PPUSH
2690: LD_INT 110
2692: PPUSH
2693: LD_INT 10
2695: PPUSH
2696: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2700: LD_ADDR_EXP 45
2704: PUSH
2705: LD_STRING Petrovova
2707: PPUSH
2708: CALL_OW 25
2712: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2713: LD_ADDR_EXP 47
2717: PUSH
2718: LD_STRING Kuzmov
2720: PPUSH
2721: CALL_OW 25
2725: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2726: LD_ADDR_EXP 46
2730: PUSH
2731: LD_STRING Kovalyuk
2733: PPUSH
2734: CALL_OW 25
2738: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2739: LD_ADDR_EXP 44
2743: PUSH
2744: LD_STRING Lipshchin
2746: PPUSH
2747: CALL_OW 25
2751: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2752: LD_ADDR_EXP 48
2756: PUSH
2757: LD_STRING Karamazov
2759: PPUSH
2760: CALL_OW 25
2764: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2765: LD_ADDR_VAR 0 3
2769: PUSH
2770: LD_EXP 45
2774: PUSH
2775: LD_EXP 47
2779: PUSH
2780: LD_EXP 46
2784: PUSH
2785: LD_EXP 44
2789: PUSH
2790: LD_EXP 48
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: ST_TO_ADDR
// for i in tmp do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 3
2811: PUSH
2812: FOR_IN
2813: IFFALSE 2852
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2815: LD_VAR 0 2
2819: PPUSH
2820: LD_INT 399
2822: PPUSH
2823: LD_INT 799
2825: PPUSH
2826: CALL_OW 12
2830: PPUSH
2831: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2835: LD_VAR 0 2
2839: PPUSH
2840: LD_INT 19
2842: PPUSH
2843: LD_INT 0
2845: PPUSH
2846: CALL_OW 49
// end ;
2850: GO 2812
2852: POP
2853: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2854: LD_VAR 0 3
2858: PPUSH
2859: LD_INT 112
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: CALL_OW 111
// AddComHold ( tmp ) ;
2869: LD_VAR 0 3
2873: PPUSH
2874: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2878: LD_ADDR_VAR 0 2
2882: PUSH
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 25
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PPUSH
2898: CALL_OW 72
2902: PUSH
2903: FOR_IN
2904: IFFALSE 2944
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2906: LD_VAR 0 2
2910: PPUSH
2911: LD_INT 20
2913: PPUSH
2914: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2918: LD_VAR 0 2
2922: PPUSH
2923: LD_INT 147
2925: PPUSH
2926: LD_INT 45
2928: PPUSH
2929: CALL_OW 178
// AddComCrawl ( i ) ;
2933: LD_VAR 0 2
2937: PPUSH
2938: CALL_OW 197
// end ;
2942: GO 2903
2944: POP
2945: POP
// repeat wait ( 0 0$1 ) ;
2946: LD_INT 35
2948: PPUSH
2949: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2953: LD_EXP 52
2957: PPUSH
2958: LD_INT 110
2960: PPUSH
2961: LD_INT 10
2963: PPUSH
2964: CALL_OW 307
2968: IFTRUE 2982
2970: PUSH
2971: LD_EXP 52
2975: PPUSH
2976: CALL_OW 305
2980: NOT
2981: OR
2982: IFFALSE 2946
// ComStop ( Burlak ) ;
2984: LD_EXP 49
2988: PPUSH
2989: CALL_OW 141
// AddComHold ( Burlak ) ;
2993: LD_EXP 49
2997: PPUSH
2998: CALL_OW 200
// end ; end_of_file
3002: LD_VAR 0 1
3006: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
3007: LD_INT 0
3009: PPUSH
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
// uc_side := 3 ;
3014: LD_ADDR_OWVAR 20
3018: PUSH
3019: LD_INT 3
3021: ST_TO_ADDR
// uc_nation := 3 ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 3
3029: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3030: LD_ADDR_EXP 53
3034: PUSH
3035: LD_INT 47
3037: PPUSH
3038: LD_INT 4
3040: PPUSH
3041: LD_STRING 
3043: PPUSH
3044: LD_INT 7
3046: PUSH
3047: LD_INT 8
3049: PUSH
3050: LD_INT 9
3052: PUSH
3053: LD_INT 10
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PUSH
3062: LD_OWVAR 67
3066: ARRAY
3067: PPUSH
3068: LD_INT 10000
3070: PUSH
3071: LD_INT 3000
3073: PUSH
3074: LD_INT 300
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: LD_INT 9
3084: PUSH
3085: LD_INT 5
3087: PUSH
3088: LD_INT 6
3090: PUSH
3091: LD_INT 6
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: LIST
3099: PPUSH
3100: CALL 26197 0 6
3104: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3105: LD_ADDR_EXP 63
3109: PUSH
3110: LD_EXP 63
3114: PPUSH
3115: LD_INT 2
3117: PPUSH
3118: LD_EXP 53
3122: PPUSH
3123: CALL_OW 1
3127: ST_TO_ADDR
// tmp := [ ] ;
3128: LD_ADDR_VAR 0 4
3132: PUSH
3133: EMPTY
3134: ST_TO_ADDR
// for i = 1 to 4 do
3135: LD_ADDR_VAR 0 2
3139: PUSH
3140: DOUBLE
3141: LD_INT 1
3143: DEC
3144: ST_TO_ADDR
3145: LD_INT 4
3147: PUSH
3148: FOR_TO
3149: IFFALSE 3242
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3151: LD_INT 22
3153: PPUSH
3154: LD_INT 3
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 43
3162: PUSH
3163: LD_INT 45
3165: PUSH
3166: LD_INT 45
3168: PUSH
3169: LD_INT 44
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: PUSH
3178: LD_VAR 0 2
3182: PUSH
3183: LD_INT 4
3185: MOD
3186: PUSH
3187: LD_INT 1
3189: PLUS
3190: ARRAY
3191: PPUSH
3192: LD_INT 100
3194: PPUSH
3195: CALL 22360 0 5
// veh := CreateVehicle ;
3199: LD_ADDR_VAR 0 3
3203: PUSH
3204: CALL_OW 45
3208: ST_TO_ADDR
// tmp := tmp ^ veh ;
3209: LD_ADDR_VAR 0 4
3213: PUSH
3214: LD_VAR 0 4
3218: PUSH
3219: LD_VAR 0 3
3223: ADD
3224: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3225: LD_VAR 0 3
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 49
// end ;
3240: GO 3148
3242: POP
3243: POP
// russian_guard := tmp ;
3244: LD_ADDR_EXP 54
3248: PUSH
3249: LD_VAR 0 4
3253: ST_TO_ADDR
// if Difficulty >= 3 then
3254: LD_OWVAR 67
3258: PUSH
3259: LD_INT 3
3261: GREATEREQUAL
3262: IFFALSE 3326
// begin bc_type := b_breastwork ;
3264: LD_ADDR_OWVAR 42
3268: PUSH
3269: LD_INT 31
3271: ST_TO_ADDR
// bc_level := 10 ;
3272: LD_ADDR_OWVAR 43
3276: PUSH
3277: LD_INT 10
3279: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3280: LD_ADDR_VAR 0 5
3284: PUSH
3285: LD_INT 96
3287: PPUSH
3288: LD_INT 105
3290: PPUSH
3291: LD_INT 3
3293: PPUSH
3294: CALL_OW 47
3298: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3299: LD_INT 0
3301: PPUSH
3302: LD_INT 9
3304: PPUSH
3305: LD_INT 10
3307: PPUSH
3308: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3312: CALL_OW 44
3316: PPUSH
3317: LD_VAR 0 5
3321: PPUSH
3322: CALL_OW 52
// end ; end ;
3326: LD_VAR 0 1
3330: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3331: LD_INT 47
3333: PPUSH
3334: CALL_OW 302
3338: IFFALSE 3346
3340: PUSH
3341: LD_EXP 7
3345: AND
3346: IFFALSE 4104
3348: GO 3350
3350: DISABLE
3351: LD_INT 0
3353: PPUSH
3354: PPUSH
3355: PPUSH
3356: PPUSH
3357: PPUSH
3358: PPUSH
3359: PPUSH
// begin enable ;
3360: ENABLE
// base := 2 ;
3361: LD_ADDR_VAR 0 3
3365: PUSH
3366: LD_INT 2
3368: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3369: LD_ADDR_VAR 0 4
3373: PUSH
3374: LD_INT 22
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 45
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 21
3394: PUSH
3395: LD_INT 1
3397: PUSH
3398: LD_INT 3
3400: PUSH
3401: LD_INT 45
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: PUSH
3410: LD_INT 22
3412: PUSH
3413: LD_INT 1
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 45
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: PUSH
3428: LD_INT 23
3430: PUSH
3431: LD_INT 1
3433: PUSH
3434: LD_INT 3
3436: PUSH
3437: LD_INT 46
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: LIST
3444: LIST
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: ST_TO_ADDR
// amount := Difficulty ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_OWVAR 67
3461: ST_TO_ADDR
// if tick > 30 30$00 then
3462: LD_OWVAR 1
3466: PUSH
3467: LD_INT 63000
3469: GREATER
3470: IFFALSE 3507
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3472: LD_ADDR_VAR 0 7
3476: PUSH
3477: LD_VAR 0 7
3481: PUSH
3482: LD_INT 2
3484: PUSH
3485: LD_INT 3
3487: PUSH
3488: LD_INT 4
3490: PUSH
3491: LD_INT 4
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: PUSH
3500: LD_OWVAR 67
3504: ARRAY
3505: PLUS
3506: ST_TO_ADDR
// for i = 1 to amount do
3507: LD_ADDR_VAR 0 1
3511: PUSH
3512: DOUBLE
3513: LD_INT 1
3515: DEC
3516: ST_TO_ADDR
3517: LD_VAR 0 7
3521: PUSH
3522: FOR_TO
3523: IFFALSE 3611
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3525: LD_ADDR_VAR 0 4
3529: PUSH
3530: LD_VAR 0 4
3534: PPUSH
3535: LD_VAR 0 4
3539: PUSH
3540: LD_INT 1
3542: PLUS
3543: PPUSH
3544: LD_INT 23
3546: PUSH
3547: LD_INT 24
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: PUSH
3554: LD_INT 1
3556: PPUSH
3557: LD_INT 2
3559: PPUSH
3560: CALL_OW 12
3564: ARRAY
3565: PUSH
3566: LD_INT 1
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: LD_INT 46
3574: PUSH
3575: LD_INT 47
3577: PUSH
3578: LD_INT 45
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 12
3596: ARRAY
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: PPUSH
3604: CALL_OW 2
3608: ST_TO_ADDR
3609: GO 3522
3611: POP
3612: POP
// p := 1 ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3621: LD_VAR 0 3
3625: PPUSH
3626: LD_VAR 0 4
3630: PPUSH
3631: CALL 85422 0 2
// repeat wait ( 0 0$1 ) ;
3635: LD_INT 35
3637: PPUSH
3638: CALL_OW 67
// p := Inc ( p ) ;
3642: LD_ADDR_VAR 0 2
3646: PUSH
3647: LD_VAR 0 2
3651: PPUSH
3652: CALL 56903 0 1
3656: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_INT 1
3664: PPUSH
3665: CALL 86878 0 2
3669: PUSH
3670: LD_VAR 0 7
3674: GREATEREQUAL
3675: IFTRUE 3687
3677: PUSH
3678: LD_VAR 0 2
3682: PUSH
3683: LD_INT 60
3685: GREATEREQUAL
3686: OR
3687: IFFALSE 3635
// wait ( 0 0$30 ) ;
3689: LD_INT 1050
3691: PPUSH
3692: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3696: LD_ADDR_VAR 0 5
3700: PUSH
3701: LD_INT 71
3703: PUSH
3704: LD_INT 19
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PUSH
3711: LD_INT 91
3713: PUSH
3714: LD_INT 67
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 52
3723: PUSH
3724: LD_INT 44
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 68
3733: PUSH
3734: LD_INT 48
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3747: LD_ADDR_VAR 0 6
3751: PUSH
3752: LD_INT 22
3754: PUSH
3755: LD_INT 3
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 21
3764: PUSH
3765: LD_INT 2
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 3
3774: PUSH
3775: LD_INT 2
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: LD_INT 52
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 34
3790: PUSH
3791: LD_INT 51
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: LIST
3811: PPUSH
3812: CALL_OW 69
3816: PUSH
3817: LD_EXP 85
3821: PUSH
3822: LD_VAR 0 3
3826: ARRAY
3827: DIFF
3828: ST_TO_ADDR
// if not attackers then
3829: LD_VAR 0 6
3833: NOT
3834: IFFALSE 3838
// exit ;
3836: GO 4104
// ru_attackers := attackers ;
3838: LD_ADDR_EXP 55
3842: PUSH
3843: LD_VAR 0 6
3847: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3848: LD_ADDR_EXP 82
3852: PUSH
3853: LD_EXP 82
3857: PPUSH
3858: LD_VAR 0 3
3862: PPUSH
3863: LD_EXP 82
3867: PUSH
3868: LD_VAR 0 3
3872: ARRAY
3873: PUSH
3874: LD_VAR 0 6
3878: DIFF
3879: PPUSH
3880: CALL_OW 1
3884: ST_TO_ADDR
// for i = 1 to attackers do
3885: LD_ADDR_VAR 0 1
3889: PUSH
3890: DOUBLE
3891: LD_INT 1
3893: DEC
3894: ST_TO_ADDR
3895: LD_VAR 0 6
3899: PUSH
3900: FOR_TO
3901: IFFALSE 3978
// begin case i mod 3 of 0 :
3903: LD_VAR 0 1
3907: PUSH
3908: LD_INT 3
3910: MOD
3911: PUSH
3912: LD_INT 0
3914: DOUBLE
3915: EQUAL
3916: IFTRUE 3920
3918: GO 3923
3920: POP
// ; 1 :
3921: GO 3976
3923: LD_INT 1
3925: DOUBLE
3926: EQUAL
3927: IFTRUE 3931
3929: GO 3949
3931: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3932: LD_VAR 0 1
3936: PPUSH
3937: LD_INT 32
3939: PPUSH
3940: LD_INT 49
3942: PPUSH
3943: CALL_OW 114
3947: GO 3976
3949: LD_INT 2
3951: DOUBLE
3952: EQUAL
3953: IFTRUE 3957
3955: GO 3975
3957: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3958: LD_VAR 0 1
3962: PPUSH
3963: LD_INT 117
3965: PPUSH
3966: LD_INT 107
3968: PPUSH
3969: CALL_OW 114
3973: GO 3976
3975: POP
// end ;
3976: GO 3900
3978: POP
3979: POP
// p := 0 ;
3980: LD_ADDR_VAR 0 2
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3988: LD_INT 35
3990: PPUSH
3991: CALL_OW 67
// p := Inc ( p ) ;
3995: LD_ADDR_VAR 0 2
3999: PUSH
4000: LD_VAR 0 2
4004: PPUSH
4005: CALL 56903 0 1
4009: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4010: LD_VAR 0 6
4014: PPUSH
4015: LD_INT 60
4017: PUSH
4018: EMPTY
4019: LIST
4020: PPUSH
4021: CALL_OW 72
4025: NOT
4026: IFTRUE 4038
4028: PUSH
4029: LD_VAR 0 2
4033: PUSH
4034: LD_INT 30
4036: GREATER
4037: OR
4038: IFFALSE 3988
// if not first_attack then
4040: LD_EXP 8
4044: NOT
4045: IFFALSE 4055
// first_attack := true ;
4047: LD_ADDR_EXP 8
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4055: LD_INT 35
4057: PPUSH
4058: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4062: LD_ADDR_VAR 0 6
4066: PUSH
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_INT 50
4074: PUSH
4075: EMPTY
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4083: LD_VAR 0 6
4087: PPUSH
4088: LD_VAR 0 5
4092: PPUSH
4093: CALL 58296 0 2
// until not attackers ;
4097: LD_VAR 0 6
4101: NOT
4102: IFFALSE 4055
// end ;
4104: PPOPN 7
4106: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4107: LD_INT 0
4109: PPUSH
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
// uc_side := 6 ;
4115: LD_ADDR_OWVAR 20
4119: PUSH
4120: LD_INT 6
4122: ST_TO_ADDR
// uc_nation := 3 ;
4123: LD_ADDR_OWVAR 21
4127: PUSH
4128: LD_INT 3
4130: ST_TO_ADDR
// InitHc ;
4131: CALL_OW 19
// InitVc ;
4135: CALL_OW 20
// tmp := [ ] ;
4139: LD_ADDR_VAR 0 3
4143: PUSH
4144: EMPTY
4145: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4146: LD_ADDR_VAR 0 2
4150: PUSH
4151: DOUBLE
4152: LD_INT 1
4154: DEC
4155: ST_TO_ADDR
4156: LD_INT 4
4158: PUSH
4159: LD_INT 5
4161: PUSH
4162: LD_INT 6
4164: PUSH
4165: LD_INT 7
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: PUSH
4174: LD_OWVAR 67
4178: ARRAY
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4435
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4183: LD_ADDR_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: PUSH
4191: LD_INT 22
4193: PUSH
4194: LD_INT 24
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4214: LD_VAR 0 5
4218: PUSH
4219: LD_INT 21
4221: DOUBLE
4222: EQUAL
4223: IFTRUE 4233
4225: LD_INT 22
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4267
4233: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4234: LD_ADDR_VAR 0 6
4238: PUSH
4239: LD_INT 45
4241: PUSH
4242: LD_INT 44
4244: PUSH
4245: LD_INT 43
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 3
4258: PPUSH
4259: CALL_OW 12
4263: ARRAY
4264: ST_TO_ADDR
4265: GO 4314
4267: LD_INT 24
4269: DOUBLE
4270: EQUAL
4271: IFTRUE 4275
4273: GO 4313
4275: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4276: LD_ADDR_VAR 0 6
4280: PUSH
4281: LD_INT 46
4283: PUSH
4284: LD_INT 47
4286: PUSH
4287: LD_INT 45
4289: PUSH
4290: LD_INT 46
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 1
4301: PPUSH
4302: LD_INT 4
4304: PPUSH
4305: CALL_OW 12
4309: ARRAY
4310: ST_TO_ADDR
4311: GO 4314
4313: POP
// uc_side := 6 ;
4314: LD_ADDR_OWVAR 20
4318: PUSH
4319: LD_INT 6
4321: ST_TO_ADDR
// uc_nation := 3 ;
4322: LD_ADDR_OWVAR 21
4326: PUSH
4327: LD_INT 3
4329: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4330: LD_VAR 0 5
4334: PPUSH
4335: LD_INT 1
4337: PUSH
4338: LD_INT 3
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: LD_INT 2
4350: PPUSH
4351: CALL_OW 12
4355: ARRAY
4356: PPUSH
4357: LD_INT 3
4359: PPUSH
4360: LD_VAR 0 6
4364: PPUSH
4365: LD_INT 70
4367: PPUSH
4368: LD_INT 90
4370: PPUSH
4371: CALL_OW 12
4375: PPUSH
4376: CALL 22360 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 4
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4390: LD_VAR 0 4
4394: PPUSH
4395: LD_INT 5
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4402: LD_VAR 0 4
4406: PPUSH
4407: LD_INT 16
4409: PPUSH
4410: LD_INT 0
4412: PPUSH
4413: CALL_OW 49
// tmp := tmp ^ veh ;
4417: LD_ADDR_VAR 0 3
4421: PUSH
4422: LD_VAR 0 3
4426: PUSH
4427: LD_VAR 0 4
4431: ADD
4432: ST_TO_ADDR
// end ;
4433: GO 4180
4435: POP
4436: POP
// if not tmp then
4437: LD_VAR 0 3
4441: NOT
4442: IFFALSE 4446
// exit ;
4444: GO 4540
// repeat wait ( 0 0$2 ) ;
4446: LD_INT 70
4448: PPUSH
4449: CALL_OW 67
// for i in tmp do
4453: LD_ADDR_VAR 0 2
4457: PUSH
4458: LD_VAR 0 3
4462: PUSH
4463: FOR_IN
4464: IFFALSE 4531
// if IsOk ( i ) then
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 302
4475: IFFALSE 4513
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4477: LD_VAR 0 2
4481: PPUSH
4482: LD_INT 22
4484: PUSH
4485: LD_INT 7
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PPUSH
4492: CALL_OW 69
4496: PPUSH
4497: LD_VAR 0 2
4501: PPUSH
4502: CALL_OW 74
4506: PPUSH
4507: CALL_OW 115
4511: GO 4529
// tmp := tmp diff i ;
4513: LD_ADDR_VAR 0 3
4517: PUSH
4518: LD_VAR 0 3
4522: PUSH
4523: LD_VAR 0 2
4527: DIFF
4528: ST_TO_ADDR
4529: GO 4463
4531: POP
4532: POP
// until not tmp ;
4533: LD_VAR 0 3
4537: NOT
4538: IFFALSE 4446
// end ;
4540: LD_VAR 0 1
4544: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4545: LD_EXP 8
4549: IFFALSE 4560
4551: PUSH
4552: LD_INT 47
4554: PPUSH
4555: CALL_OW 302
4559: AND
4560: IFFALSE 4575
4562: PUSH
4563: LD_INT 47
4565: PPUSH
4566: CALL_OW 255
4570: PUSH
4571: LD_INT 3
4573: EQUAL
4574: AND
4575: IFFALSE 4583
4577: PUSH
4578: LD_EXP 6
4582: AND
4583: IFFALSE 4593
4585: GO 4587
4587: DISABLE
// begin enable ;
4588: ENABLE
// PrepareRussianAttack ;
4589: CALL 4107 0 0
// end ; end_of_file
4593: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4594: LD_INT 0
4596: PPUSH
4597: PPUSH
4598: PPUSH
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
// uc_side := 2 ;
4605: LD_ADDR_OWVAR 20
4609: PUSH
4610: LD_INT 2
4612: ST_TO_ADDR
// uc_nation := 2 ;
4613: LD_ADDR_OWVAR 21
4617: PUSH
4618: LD_INT 2
4620: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4621: LD_INT 2
4623: PPUSH
4624: LD_INT 28
4626: PPUSH
4627: CALL 60651 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4631: LD_INT 25
4633: PPUSH
4634: LD_INT 0
4636: PUSH
4637: LD_INT 0
4639: PUSH
4640: LD_INT 6
4642: PUSH
4643: LD_INT 8
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: PPUSH
4658: CALL 8161 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4662: LD_INT 26
4664: PPUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 4
4670: PUSH
4671: LD_INT 8
4673: PUSH
4674: LD_INT 12
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_OWVAR 67
4687: ARRAY
4688: PPUSH
4689: CALL 8161 0 2
// if Difficulty > 2 then
4693: LD_OWVAR 67
4697: PUSH
4698: LD_INT 2
4700: GREATER
4701: IFFALSE 4871
// begin bc_type := b_breastwork ;
4703: LD_ADDR_OWVAR 42
4707: PUSH
4708: LD_INT 31
4710: ST_TO_ADDR
// bc_level := 8 ;
4711: LD_ADDR_OWVAR 43
4715: PUSH
4716: LD_INT 8
4718: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4719: LD_ADDR_VAR 0 5
4723: PUSH
4724: LD_INT 27
4726: PUSH
4727: LD_INT 29
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: FOR_IN
4735: IFFALSE 4869
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4737: LD_ADDR_VAR 0 6
4741: PUSH
4742: LD_VAR 0 5
4746: PPUSH
4747: LD_INT 1
4749: PPUSH
4750: CALL 60249 0 2
4754: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4755: LD_ADDR_VAR 0 3
4759: PUSH
4760: LD_VAR 0 6
4764: PUSH
4765: LD_INT 1
4767: ARRAY
4768: PPUSH
4769: LD_VAR 0 6
4773: PUSH
4774: LD_INT 2
4776: ARRAY
4777: PPUSH
4778: LD_VAR 0 6
4782: PUSH
4783: LD_INT 3
4785: ARRAY
4786: PPUSH
4787: CALL_OW 47
4791: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4792: LD_INT 0
4794: PPUSH
4795: LD_INT 5
4797: PUSH
4798: LD_OWVAR 67
4802: PLUS
4803: PPUSH
4804: CALL_OW 381
// un := CreateHuman ;
4808: LD_ADDR_VAR 0 8
4812: PUSH
4813: CALL_OW 44
4817: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4818: LD_VAR 0 8
4822: PPUSH
4823: LD_VAR 0 3
4827: PPUSH
4828: CALL_OW 254
4832: PUSH
4833: LD_INT 3
4835: MINUS
4836: PPUSH
4837: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4841: LD_VAR 0 8
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4853: LD_VAR 0 8
4857: PPUSH
4858: LD_VAR 0 3
4862: PPUSH
4863: CALL_OW 52
// end ;
4867: GO 4734
4869: POP
4870: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4871: LD_ADDR_EXP 58
4875: PUSH
4876: LD_STRING Abdul
4878: PPUSH
4879: CALL_OW 25
4883: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4884: LD_EXP 58
4888: PPUSH
4889: LD_INT 11
4891: PPUSH
4892: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4896: LD_EXP 58
4900: PPUSH
4901: LD_INT 1
4903: PPUSH
4904: CALL_OW 52
// vc_chassis := 31 ;
4908: LD_ADDR_OWVAR 37
4912: PUSH
4913: LD_INT 31
4915: ST_TO_ADDR
// vc_control := control_rider ;
4916: LD_ADDR_OWVAR 38
4920: PUSH
4921: LD_INT 4
4923: ST_TO_ADDR
// mastodont := CreateVehicle ;
4924: LD_ADDR_EXP 59
4928: PUSH
4929: CALL_OW 45
4933: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4934: LD_EXP 59
4938: PPUSH
4939: LD_INT 153
4941: PPUSH
4942: LD_INT 71
4944: PPUSH
4945: LD_INT 0
4947: PPUSH
4948: CALL_OW 48
// InitVc ;
4952: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4956: LD_ADDR_EXP 56
4960: PUSH
4961: LD_INT 1
4963: PPUSH
4964: LD_INT 3
4966: PPUSH
4967: LD_STRING kaba
4969: PPUSH
4970: LD_INT 7
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: LD_INT 9
4978: PUSH
4979: LD_INT 10
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: PPUSH
4994: LD_INT 5000
4996: PUSH
4997: LD_INT 1000
4999: PUSH
5000: LD_INT 300
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_INT 11
5010: PUSH
5011: LD_INT 5
5013: PUSH
5014: LD_INT 6
5016: PUSH
5017: LD_INT 7
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL 26197 0 6
5030: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5031: LD_ADDR_EXP 63
5035: PUSH
5036: LD_EXP 63
5040: PPUSH
5041: LD_INT 1
5043: PPUSH
5044: LD_EXP 56
5048: PPUSH
5049: CALL_OW 1
5053: ST_TO_ADDR
// tmp := [ ] ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: EMPTY
5060: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5061: LD_ADDR_OWVAR 37
5065: PUSH
5066: LD_INT 13
5068: ST_TO_ADDR
// vc_engine := engine_siberite ;
5069: LD_ADDR_OWVAR 39
5073: PUSH
5074: LD_INT 3
5076: ST_TO_ADDR
// vc_control := control_manual ;
5077: LD_ADDR_OWVAR 38
5081: PUSH
5082: LD_INT 1
5084: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5085: LD_ADDR_OWVAR 40
5089: PUSH
5090: LD_INT 31
5092: ST_TO_ADDR
// for i = 1 to 3 do
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: DOUBLE
5099: LD_INT 1
5101: DEC
5102: ST_TO_ADDR
5103: LD_INT 3
5105: PUSH
5106: FOR_TO
5107: IFFALSE 5355
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5109: LD_ADDR_VAR 0 7
5113: PUSH
5114: LD_INT 153
5116: PUSH
5117: LD_INT 71
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 155
5126: PUSH
5127: LD_INT 81
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_VAR 0 2
5142: PUSH
5143: LD_INT 2
5145: MOD
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ARRAY
5151: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 7
5160: PUSH
5161: LD_INT 8
5163: PUSH
5164: LD_INT 10
5166: PUSH
5167: LD_INT 10
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_OWVAR 67
5180: ARRAY
5181: PPUSH
5182: CALL_OW 380
// un := CreateVehicle ;
5186: LD_ADDR_VAR 0 8
5190: PUSH
5191: CALL_OW 45
5195: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5196: LD_VAR 0 8
5200: PPUSH
5201: LD_INT 0
5203: PPUSH
5204: LD_INT 5
5206: PPUSH
5207: CALL_OW 12
5211: PPUSH
5212: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5216: LD_VAR 0 8
5220: PPUSH
5221: LD_VAR 0 7
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PPUSH
5230: LD_VAR 0 7
5234: PUSH
5235: LD_INT 2
5237: ARRAY
5238: PPUSH
5239: LD_INT 6
5241: PPUSH
5242: LD_INT 0
5244: PPUSH
5245: CALL_OW 50
// un2 := CreateHuman ;
5249: LD_ADDR_VAR 0 9
5253: PUSH
5254: CALL_OW 44
5258: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5259: LD_VAR 0 9
5263: PPUSH
5264: LD_VAR 0 8
5268: PPUSH
5269: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5273: LD_ADDR_EXP 63
5277: PUSH
5278: LD_EXP 63
5282: PPUSH
5283: LD_INT 1
5285: PUSH
5286: LD_EXP 63
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: PUSH
5295: LD_INT 1
5297: PLUS
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PPUSH
5303: LD_VAR 0 8
5307: PPUSH
5308: CALL 22482 0 3
5312: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5313: LD_ADDR_EXP 63
5317: PUSH
5318: LD_EXP 63
5322: PPUSH
5323: LD_INT 1
5325: PUSH
5326: LD_EXP 63
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 1
5337: PLUS
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PPUSH
5343: LD_VAR 0 9
5347: PPUSH
5348: CALL 22482 0 3
5352: ST_TO_ADDR
// end ;
5353: GO 5106
5355: POP
5356: POP
// for i = 1 to 5 do
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: DOUBLE
5363: LD_INT 1
5365: DEC
5366: ST_TO_ADDR
5367: LD_INT 5
5369: PUSH
5370: FOR_TO
5371: IFFALSE 5464
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5373: LD_INT 13
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 1
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 28
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: LD_INT 26
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: LD_VAR 0 2
5404: PUSH
5405: LD_INT 4
5407: MOD
5408: PUSH
5409: LD_INT 1
5411: PLUS
5412: ARRAY
5413: PPUSH
5414: LD_INT 100
5416: PPUSH
5417: CALL 22360 0 5
// veh := CreateVehicle ;
5421: LD_ADDR_VAR 0 4
5425: PUSH
5426: CALL_OW 45
5430: ST_TO_ADDR
// tmp := tmp ^ veh ;
5431: LD_ADDR_VAR 0 6
5435: PUSH
5436: LD_VAR 0 6
5440: PUSH
5441: LD_VAR 0 4
5445: ADD
5446: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5447: LD_VAR 0 4
5451: PPUSH
5452: LD_INT 1
5454: PPUSH
5455: LD_INT 0
5457: PPUSH
5458: CALL_OW 49
// end ;
5462: GO 5370
5464: POP
5465: POP
// arabian_guard := tmp ;
5466: LD_ADDR_EXP 57
5470: PUSH
5471: LD_VAR 0 6
5475: ST_TO_ADDR
// end ;
5476: LD_VAR 0 1
5480: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5481: LD_INT 22
5483: PUSH
5484: LD_INT 7
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 91
5493: PUSH
5494: LD_INT 1
5496: PUSH
5497: LD_INT 12
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: IFTRUE 5530
5515: PUSH
5516: LD_EXP 59
5520: PPUSH
5521: CALL_OW 256
5525: PUSH
5526: LD_INT 990
5528: LESS
5529: OR
5530: IFTRUE 5547
5532: PUSH
5533: LD_EXP 58
5537: PPUSH
5538: CALL_OW 256
5542: PUSH
5543: LD_INT 990
5545: LESS
5546: OR
5547: IFFALSE 5692
5549: GO 5551
5551: DISABLE
// begin if IsInUnit ( Abdul ) then
5552: LD_EXP 58
5556: PPUSH
5557: CALL_OW 310
5561: IFFALSE 5572
// ComExitBuilding ( Abdul ) ;
5563: LD_EXP 58
5567: PPUSH
5568: CALL_OW 122
// if Mastodont then
5572: LD_EXP 59
5576: IFFALSE 5593
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5578: LD_EXP 59
5582: PPUSH
5583: LD_INT 205
5585: PPUSH
5586: LD_INT 132
5588: PPUSH
5589: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5593: LD_EXP 58
5597: PPUSH
5598: LD_INT 205
5600: PPUSH
5601: LD_INT 132
5603: PPUSH
5604: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5608: LD_INT 35
5610: PPUSH
5611: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5615: LD_EXP 58
5619: PPUSH
5620: LD_INT 21
5622: PPUSH
5623: CALL_OW 308
5627: IFFALSE 5608
// RemoveUnit ( Abdul ) ;
5629: LD_EXP 58
5633: PPUSH
5634: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5638: LD_INT 35
5640: PPUSH
5641: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5645: LD_EXP 59
5649: PPUSH
5650: LD_INT 21
5652: PPUSH
5653: CALL_OW 308
5657: IFTRUE 5670
5659: PUSH
5660: LD_EXP 59
5664: PPUSH
5665: CALL_OW 301
5669: OR
5670: IFFALSE 5638
// if IsOk ( Mastodont ) then
5672: LD_EXP 59
5676: PPUSH
5677: CALL_OW 302
5681: IFFALSE 5692
// RemoveUnit ( Mastodont ) ;
5683: LD_EXP 59
5687: PPUSH
5688: CALL_OW 64
// end ;
5692: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5693: LD_EXP 58
5697: PPUSH
5698: CALL_OW 301
5702: IFTRUE 5810
5704: PUSH
5705: LD_INT 22
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 2
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 25
5740: PUSH
5741: LD_INT 3
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 25
5750: PUSH
5751: LD_INT 4
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 25
5760: PUSH
5761: LD_INT 8
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PPUSH
5780: CALL_OW 69
5784: PUSH
5785: LD_INT 16
5787: PUSH
5788: LD_INT 19
5790: PUSH
5791: LD_INT 22
5793: PUSH
5794: LD_INT 22
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: LESS
5809: OR
5810: IFFALSE 6483
5812: GO 5814
5814: DISABLE
5815: LD_INT 0
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
// begin MC_Kill ( 1 ) ;
5823: LD_INT 1
5825: PPUSH
5826: CALL 61141 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: LD_INT 22
5837: PUSH
5838: LD_INT 2
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 2
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 25
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 25
5880: PUSH
5881: LD_INT 4
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 25
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL_OW 69
5914: ST_TO_ADDR
// for i in tmp do
5915: LD_ADDR_VAR 0 5
5919: PUSH
5920: LD_VAR 0 2
5924: PUSH
5925: FOR_IN
5926: IFFALSE 5942
// SetTag ( i , 10 ) ;
5928: LD_VAR 0 5
5932: PPUSH
5933: LD_INT 10
5935: PPUSH
5936: CALL_OW 109
5940: GO 5925
5942: POP
5943: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5944: LD_ADDR_VAR 0 3
5948: PUSH
5949: LD_INT 22
5951: PUSH
5952: LD_INT 2
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 21
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PPUSH
5973: CALL_OW 69
5977: PUSH
5978: LD_VAR 0 2
5982: DIFF
5983: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5984: LD_ADDR_VAR 0 1
5988: PUSH
5989: LD_INT 22
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 21
6001: PUSH
6002: LD_INT 2
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PUSH
6009: LD_INT 24
6011: PUSH
6012: LD_INT 300
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 69
6028: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
6029: LD_ADDR_VAR 0 4
6033: PUSH
6034: LD_VAR 0 1
6038: PPUSH
6039: LD_INT 33
6041: PUSH
6042: LD_INT 1
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: LD_INT 58
6051: PUSH
6052: EMPTY
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PPUSH
6059: CALL_OW 72
6063: ST_TO_ADDR
// for i in tmp do
6064: LD_ADDR_VAR 0 5
6068: PUSH
6069: LD_VAR 0 2
6073: PUSH
6074: FOR_IN
6075: IFFALSE 6259
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6077: LD_VAR 0 5
6081: PUSH
6082: LD_INT 55
6084: PUSH
6085: EMPTY
6086: LIST
6087: PPUSH
6088: CALL_OW 69
6092: IN
6093: IFFALSE 6112
// begin AddComMoveXY ( i , 209 , 132 ) ;
6095: LD_VAR 0 5
6099: PPUSH
6100: LD_INT 209
6102: PPUSH
6103: LD_INT 132
6105: PPUSH
6106: CALL_OW 171
// continue ;
6110: GO 6074
// end ; if IsInUnit ( i ) then
6112: LD_VAR 0 5
6116: PPUSH
6117: CALL_OW 310
6121: IFFALSE 6139
// begin ComExitBuilding ( i ) ;
6123: LD_VAR 0 5
6127: PPUSH
6128: CALL_OW 122
// wait ( 3 ) ;
6132: LD_INT 3
6134: PPUSH
6135: CALL_OW 67
// end ; if tmp_empty then
6139: LD_VAR 0 4
6143: IFFALSE 6242
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6145: LD_VAR 0 5
6149: PPUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: PPUSH
6165: CALL_OW 296
6169: PUSH
6170: LD_INT 25
6172: LESS
6173: IFFALSE 6242
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6175: LD_ADDR_VAR 0 6
6179: PUSH
6180: LD_VAR 0 4
6184: PPUSH
6185: LD_VAR 0 5
6189: PPUSH
6190: CALL_OW 74
6194: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6195: LD_VAR 0 5
6199: PPUSH
6200: LD_VAR 0 6
6204: PPUSH
6205: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6209: LD_VAR 0 5
6213: PPUSH
6214: LD_INT 209
6216: PPUSH
6217: LD_INT 132
6219: PPUSH
6220: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6224: LD_ADDR_VAR 0 4
6228: PUSH
6229: LD_VAR 0 4
6233: PUSH
6234: LD_VAR 0 6
6238: DIFF
6239: ST_TO_ADDR
// continue ;
6240: GO 6074
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6242: LD_VAR 0 5
6246: PPUSH
6247: LD_INT 201
6249: PPUSH
6250: LD_INT 132
6252: PPUSH
6253: CALL_OW 171
// end ;
6257: GO 6074
6259: POP
6260: POP
// for i in tmp_ape do
6261: LD_ADDR_VAR 0 5
6265: PUSH
6266: LD_VAR 0 3
6270: PUSH
6271: FOR_IN
6272: IFFALSE 6311
// begin if IsInUnit ( i ) then
6274: LD_VAR 0 5
6278: PPUSH
6279: CALL_OW 310
6283: IFFALSE 6294
// ComExitBuilding ( i ) ;
6285: LD_VAR 0 5
6289: PPUSH
6290: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6294: LD_VAR 0 5
6298: PPUSH
6299: LD_INT 201
6301: PPUSH
6302: LD_INT 132
6304: PPUSH
6305: CALL_OW 171
// end ;
6309: GO 6271
6311: POP
6312: POP
// repeat wait ( 0 0$1 ) ;
6313: LD_INT 35
6315: PPUSH
6316: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6320: LD_ADDR_VAR 0 5
6324: PUSH
6325: LD_VAR 0 2
6329: PUSH
6330: LD_VAR 0 3
6334: UNION
6335: PUSH
6336: LD_VAR 0 1
6340: UNION
6341: PUSH
6342: FOR_IN
6343: IFFALSE 6374
// if not HasTask ( i ) then
6345: LD_VAR 0 5
6349: PPUSH
6350: CALL_OW 314
6354: NOT
6355: IFFALSE 6372
// ComMoveXY ( i , 201 , 132 ) ;
6357: LD_VAR 0 5
6361: PPUSH
6362: LD_INT 201
6364: PPUSH
6365: LD_INT 132
6367: PPUSH
6368: CALL_OW 111
6372: GO 6342
6374: POP
6375: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6376: LD_INT 21
6378: PPUSH
6379: LD_INT 22
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PPUSH
6389: CALL_OW 70
6393: IFFALSE 6434
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6395: LD_ADDR_VAR 0 5
6399: PUSH
6400: LD_INT 21
6402: PPUSH
6403: LD_INT 22
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 70
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6432
// RemoveUnit ( i ) ;
6421: LD_VAR 0 5
6425: PPUSH
6426: CALL_OW 64
6430: GO 6418
6432: POP
6433: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6434: LD_INT 22
6436: PUSH
6437: LD_INT 2
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 2
6446: PUSH
6447: LD_INT 21
6449: PUSH
6450: LD_INT 1
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PUSH
6457: LD_INT 21
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PPUSH
6476: CALL_OW 69
6480: NOT
6481: IFFALSE 6313
// end ;
6483: PPOPN 6
6485: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6486: LD_EXP 10
6490: IFFALSE 6513
6492: PUSH
6493: LD_INT 92
6495: PPUSH
6496: LD_INT 40
6498: PPUSH
6499: CALL_OW 428
6503: PPUSH
6504: CALL_OW 266
6508: PUSH
6509: LD_INT 30
6511: EQUAL
6512: AND
6513: IFFALSE 6709
6515: GO 6517
6517: DISABLE
6518: LD_INT 0
6520: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_EXP 63
6530: PUSH
6531: LD_INT 1
6533: ARRAY
6534: PPUSH
6535: LD_INT 25
6537: PUSH
6538: LD_INT 4
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 72
6549: ST_TO_ADDR
// if not sci then
6550: LD_VAR 0 1
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6709
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6559: LD_ADDR_EXP 63
6563: PUSH
6564: LD_EXP 63
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: LD_EXP 63
6576: PUSH
6577: LD_INT 1
6579: ARRAY
6580: PUSH
6581: LD_VAR 0 1
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: DIFF
6590: PPUSH
6591: CALL_OW 1
6595: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 310
6609: IFFALSE 6624
// ComExitBuilding ( sci [ 1 ] ) ;
6611: LD_VAR 0 1
6615: PUSH
6616: LD_INT 1
6618: ARRAY
6619: PPUSH
6620: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6624: LD_INT 2
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: LD_INT 20
6635: PPUSH
6636: CALL 23752 0 4
6640: PUSH
6641: LD_INT 4
6643: ARRAY
6644: PUSH
6645: LD_INT 10
6647: LESS
6648: IFFALSE 6671
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 1
6657: ARRAY
6658: PPUSH
6659: LD_INT 105
6661: PPUSH
6662: LD_INT 14
6664: PPUSH
6665: CALL_OW 171
6669: GO 6690
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6671: LD_VAR 0 1
6675: PUSH
6676: LD_INT 1
6678: ARRAY
6679: PPUSH
6680: LD_INT 118
6682: PPUSH
6683: LD_INT 77
6685: PPUSH
6686: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6690: LD_VAR 0 1
6694: PUSH
6695: LD_INT 1
6697: ARRAY
6698: PPUSH
6699: LD_INT 92
6701: PPUSH
6702: LD_INT 40
6704: PPUSH
6705: CALL_OW 218
// end ;
6709: PPOPN 1
6711: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6712: LD_INT 1
6714: PPUSH
6715: CALL_OW 302
6719: IFFALSE 6727
6721: PUSH
6722: LD_EXP 10
6726: AND
6727: IFFALSE 7618
6729: GO 6731
6731: DISABLE
6732: LD_INT 0
6734: PPUSH
6735: PPUSH
6736: PPUSH
6737: PPUSH
6738: PPUSH
6739: PPUSH
6740: PPUSH
6741: PPUSH
// begin enable ;
6742: ENABLE
// base := 1 ;
6743: LD_ADDR_VAR 0 3
6747: PUSH
6748: LD_INT 1
6750: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6751: LD_ADDR_VAR 0 5
6755: PUSH
6756: LD_INT 0
6758: PUSH
6759: LD_INT 0
6761: PUSH
6762: LD_INT 0
6764: PUSH
6765: LD_INT 0
6767: PUSH
6768: LD_INT 0
6770: PUSH
6771: LD_INT 0
6773: PUSH
6774: LD_INT 0
6776: PUSH
6777: LD_INT 0
6779: PUSH
6780: LD_INT 1
6782: PUSH
6783: LD_INT 0
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: LIST
6796: LIST
6797: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6798: LD_ADDR_VAR 0 4
6802: PUSH
6803: LD_INT 13
6805: PUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 2
6811: PUSH
6812: LD_INT 26
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: PUSH
6821: LD_INT 13
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 2
6829: PUSH
6830: LD_INT 28
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 13
6841: PUSH
6842: LD_INT 1
6844: PUSH
6845: LD_INT 2
6847: PUSH
6848: LD_INT 29
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: LIST
6861: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6862: LD_ADDR_VAR 0 1
6866: PUSH
6867: DOUBLE
6868: LD_INT 1
6870: DEC
6871: ST_TO_ADDR
6872: LD_OWVAR 67
6876: PUSH
6877: LD_OWVAR 1
6881: PUSH
6882: LD_INT 21000
6884: DIV
6885: PLUS
6886: PUSH
6887: FOR_TO
6888: IFFALSE 6961
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_VAR 0 4
6899: PPUSH
6900: LD_VAR 0 4
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PPUSH
6909: LD_INT 13
6911: PUSH
6912: LD_INT 1
6914: PUSH
6915: LD_INT 2
6917: PUSH
6918: LD_INT 28
6920: PUSH
6921: LD_INT 29
6923: PUSH
6924: LD_INT 25
6926: PUSH
6927: LD_INT 26
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 1
6938: PPUSH
6939: LD_INT 4
6941: PPUSH
6942: CALL_OW 12
6946: ARRAY
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PPUSH
6954: CALL_OW 2
6958: ST_TO_ADDR
6959: GO 6887
6961: POP
6962: POP
// MC_InsertProduceList ( base , tmp ) ;
6963: LD_VAR 0 3
6967: PPUSH
6968: LD_VAR 0 4
6972: PPUSH
6973: CALL 85422 0 2
// wait ( 3 3$20 ) ;
6977: LD_INT 7000
6979: PPUSH
6980: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6984: LD_ADDR_VAR 0 6
6988: PUSH
6989: LD_INT 124
6991: PUSH
6992: LD_INT 85
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 90
7001: PUSH
7002: LD_INT 61
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PUSH
7009: LD_INT 69
7011: PUSH
7012: LD_INT 48
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: PUSH
7019: LD_INT 68
7021: PUSH
7022: LD_INT 48
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 22
7042: PUSH
7043: LD_INT 2
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 23
7052: PUSH
7053: LD_INT 2
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: LD_INT 21
7062: PUSH
7063: LD_INT 2
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 3
7072: PUSH
7073: LD_INT 2
7075: PUSH
7076: LD_INT 34
7078: PUSH
7079: LD_INT 31
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: LD_INT 34
7088: PUSH
7089: LD_INT 88
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: LD_INT 34
7098: PUSH
7099: LD_INT 32
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: PPUSH
7122: CALL_OW 69
7126: PUSH
7127: LD_EXP 82
7131: PUSH
7132: LD_VAR 0 3
7136: ARRAY
7137: PPUSH
7138: LD_INT 2
7140: PUSH
7141: LD_INT 34
7143: PUSH
7144: LD_INT 32
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 34
7153: PUSH
7154: LD_INT 88
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PPUSH
7166: CALL_OW 72
7170: DIFF
7171: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7172: LD_INT 0
7174: PPUSH
7175: LD_INT 1
7177: PPUSH
7178: CALL_OW 12
7182: IFFALSE 7332
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7184: LD_ADDR_VAR 0 1
7188: PUSH
7189: DOUBLE
7190: LD_INT 1
7192: DEC
7193: ST_TO_ADDR
7194: LD_INT 3
7196: PUSH
7197: LD_INT 4
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: LD_INT 6
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_OWVAR 67
7216: ARRAY
7217: PUSH
7218: FOR_TO
7219: IFFALSE 7328
// begin uc_side := 2 ;
7221: LD_ADDR_OWVAR 20
7225: PUSH
7226: LD_INT 2
7228: ST_TO_ADDR
// uc_nation := 2 ;
7229: LD_ADDR_OWVAR 21
7233: PUSH
7234: LD_INT 2
7236: ST_TO_ADDR
// InitHc ;
7237: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7241: LD_INT 0
7243: PPUSH
7244: LD_INT 15
7246: PUSH
7247: LD_INT 17
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PUSH
7254: LD_INT 1
7256: PPUSH
7257: LD_INT 2
7259: PPUSH
7260: CALL_OW 12
7264: ARRAY
7265: PPUSH
7266: LD_INT 8
7268: PPUSH
7269: CALL_OW 380
// un := CreateHuman ;
7273: LD_ADDR_VAR 0 2
7277: PUSH
7278: CALL_OW 44
7282: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 4
7290: PPUSH
7291: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7295: LD_VAR 0 2
7299: PPUSH
7300: LD_INT 23
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 49
// attackers := attackers union un ;
7310: LD_ADDR_VAR 0 7
7314: PUSH
7315: LD_VAR 0 7
7319: PUSH
7320: LD_VAR 0 2
7324: UNION
7325: ST_TO_ADDR
// end ;
7326: GO 7218
7328: POP
7329: POP
// end else
7330: GO 7490
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: DOUBLE
7338: LD_INT 1
7340: DEC
7341: ST_TO_ADDR
7342: LD_INT 2
7344: PUSH
7345: LD_INT 3
7347: PUSH
7348: LD_INT 4
7350: PUSH
7351: LD_INT 5
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: PUSH
7360: LD_OWVAR 67
7364: ARRAY
7365: PUSH
7366: FOR_TO
7367: IFFALSE 7488
// begin uc_side := 2 ;
7369: LD_ADDR_OWVAR 20
7373: PUSH
7374: LD_INT 2
7376: ST_TO_ADDR
// uc_nation := 2 ;
7377: LD_ADDR_OWVAR 21
7381: PUSH
7382: LD_INT 2
7384: ST_TO_ADDR
// InitHc ;
7385: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7389: LD_INT 14
7391: PPUSH
7392: LD_INT 3
7394: PPUSH
7395: LD_INT 5
7397: PPUSH
7398: LD_INT 29
7400: PUSH
7401: LD_INT 29
7403: PUSH
7404: LD_INT 26
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: LIST
7411: PUSH
7412: LD_VAR 0 1
7416: PUSH
7417: LD_INT 3
7419: MOD
7420: PUSH
7421: LD_INT 1
7423: PLUS
7424: ARRAY
7425: PPUSH
7426: LD_INT 100
7428: PPUSH
7429: CALL 22360 0 5
// un := CreateVehicle ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: CALL_OW 45
7442: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7443: LD_VAR 0 2
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7455: LD_VAR 0 2
7459: PPUSH
7460: LD_INT 23
7462: PPUSH
7463: LD_INT 0
7465: PPUSH
7466: CALL_OW 49
// attackers := attackers union un ;
7470: LD_ADDR_VAR 0 7
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_VAR 0 2
7484: UNION
7485: ST_TO_ADDR
// end ;
7486: GO 7366
7488: POP
7489: POP
// end ; if not attackers then
7490: LD_VAR 0 7
7494: NOT
7495: IFFALSE 7499
// exit ;
7497: GO 7618
// ar_attackers := attackers ;
7499: LD_ADDR_EXP 12
7503: PUSH
7504: LD_VAR 0 7
7508: ST_TO_ADDR
// p := 0 ;
7509: LD_ADDR_VAR 0 8
7513: PUSH
7514: LD_INT 0
7516: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7517: LD_INT 35
7519: PPUSH
7520: CALL_OW 67
// p := Inc ( p ) ;
7524: LD_ADDR_VAR 0 8
7528: PUSH
7529: LD_VAR 0 8
7533: PPUSH
7534: CALL 56903 0 1
7538: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7539: LD_VAR 0 7
7543: PPUSH
7544: LD_INT 60
7546: PUSH
7547: EMPTY
7548: LIST
7549: PPUSH
7550: CALL_OW 72
7554: NOT
7555: IFTRUE 7567
7557: PUSH
7558: LD_VAR 0 8
7562: PUSH
7563: LD_INT 30
7565: GREATER
7566: OR
7567: IFFALSE 7517
// repeat wait ( 0 0$1 ) ;
7569: LD_INT 35
7571: PPUSH
7572: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7576: LD_ADDR_VAR 0 7
7580: PUSH
7581: LD_VAR 0 7
7585: PPUSH
7586: LD_INT 50
7588: PUSH
7589: EMPTY
7590: LIST
7591: PPUSH
7592: CALL_OW 72
7596: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7597: LD_VAR 0 7
7601: PPUSH
7602: LD_VAR 0 6
7606: PPUSH
7607: CALL 58296 0 2
// until not attackers ;
7611: LD_VAR 0 7
7615: NOT
7616: IFFALSE 7569
// end ;
7618: PPOPN 8
7620: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7621: LD_INT 1
7623: PPUSH
7624: CALL_OW 302
7628: IFFALSE 7636
7630: PUSH
7631: LD_EXP 10
7635: AND
7636: IFFALSE 7652
7638: PUSH
7639: LD_EXP 52
7643: PPUSH
7644: LD_INT 22
7646: PPUSH
7647: CALL_OW 308
7651: AND
7652: IFFALSE 8158
7654: GO 7656
7656: DISABLE
7657: LD_INT 0
7659: PPUSH
7660: PPUSH
7661: PPUSH
7662: PPUSH
7663: PPUSH
7664: PPUSH
7665: PPUSH
7666: PPUSH
// begin base := 1 ;
7667: LD_ADDR_VAR 0 2
7671: PUSH
7672: LD_INT 1
7674: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 0
7682: PUSH
7683: LD_INT 0
7685: PUSH
7686: LD_INT 0
7688: PUSH
7689: LD_INT 0
7691: PUSH
7692: LD_INT 0
7694: PUSH
7695: LD_INT 0
7697: PUSH
7698: LD_INT 0
7700: PUSH
7701: LD_INT 0
7703: PUSH
7704: LD_INT 1
7706: PUSH
7707: LD_INT 0
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7722: LD_ADDR_VAR 0 3
7726: PUSH
7727: LD_INT 13
7729: PUSH
7730: LD_INT 1
7732: PUSH
7733: LD_INT 2
7735: PUSH
7736: LD_INT 28
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: LIST
7743: LIST
7744: PUSH
7745: LD_INT 13
7747: PUSH
7748: LD_INT 1
7750: PUSH
7751: LD_INT 2
7753: PUSH
7754: LD_INT 27
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 13
7765: PUSH
7766: LD_INT 1
7768: PUSH
7769: LD_INT 2
7771: PUSH
7772: LD_INT 25
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 11
7783: PUSH
7784: LD_INT 2
7786: PUSH
7787: LD_INT 2
7789: PUSH
7790: LD_INT 24
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: PUSH
7799: LD_INT 11
7801: PUSH
7802: LD_INT 2
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: LD_INT 24
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: LIST
7815: LIST
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: LIST
7821: LIST
7822: LIST
7823: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7824: LD_VAR 0 2
7828: PPUSH
7829: LD_VAR 0 3
7833: PPUSH
7834: CALL 85422 0 2
// wait ( 4 4$20 ) ;
7838: LD_INT 9100
7840: PPUSH
7841: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7845: LD_ADDR_VAR 0 5
7849: PUSH
7850: LD_INT 119
7852: PUSH
7853: LD_INT 9
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_EXP 82
7872: PUSH
7873: LD_VAR 0 2
7877: ARRAY
7878: PUSH
7879: LD_EXP 82
7883: PUSH
7884: LD_VAR 0 2
7888: ARRAY
7889: PPUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 34
7895: PUSH
7896: LD_INT 32
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 34
7905: PUSH
7906: LD_INT 88
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 72
7922: DIFF
7923: ST_TO_ADDR
// uc_side := 2 ;
7924: LD_ADDR_OWVAR 20
7928: PUSH
7929: LD_INT 2
7931: ST_TO_ADDR
// uc_nation := 2 ;
7932: LD_ADDR_OWVAR 21
7936: PUSH
7937: LD_INT 2
7939: ST_TO_ADDR
// InitHc ;
7940: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7944: LD_ADDR_VAR 0 1
7948: PUSH
7949: DOUBLE
7950: LD_INT 1
7952: DEC
7953: ST_TO_ADDR
7954: LD_INT 4
7956: PUSH
7957: LD_INT 5
7959: PUSH
7960: LD_INT 6
7962: PUSH
7963: LD_INT 6
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: LD_OWVAR 67
7976: ARRAY
7977: PUSH
7978: FOR_TO
7979: IFFALSE 8056
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7981: LD_INT 0
7983: PPUSH
7984: LD_INT 15
7986: PUSH
7987: LD_INT 17
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 1
7996: PPUSH
7997: LD_INT 2
7999: PPUSH
8000: CALL_OW 12
8004: ARRAY
8005: PPUSH
8006: LD_INT 8
8008: PPUSH
8009: CALL_OW 380
// un := CreateHuman ;
8013: LD_ADDR_VAR 0 7
8017: PUSH
8018: CALL_OW 44
8022: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
8023: LD_VAR 0 7
8027: PPUSH
8028: LD_INT 23
8030: PPUSH
8031: LD_INT 0
8033: PPUSH
8034: CALL_OW 49
// attackers := attackers union un ;
8038: LD_ADDR_VAR 0 6
8042: PUSH
8043: LD_VAR 0 6
8047: PUSH
8048: LD_VAR 0 7
8052: UNION
8053: ST_TO_ADDR
// end ;
8054: GO 7978
8056: POP
8057: POP
// p := 0 ;
8058: LD_ADDR_VAR 0 8
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8066: LD_INT 35
8068: PPUSH
8069: CALL_OW 67
// p := Inc ( p ) ;
8073: LD_ADDR_VAR 0 8
8077: PUSH
8078: LD_VAR 0 8
8082: PPUSH
8083: CALL 56903 0 1
8087: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8088: LD_VAR 0 6
8092: PPUSH
8093: LD_INT 60
8095: PUSH
8096: EMPTY
8097: LIST
8098: PPUSH
8099: CALL_OW 72
8103: NOT
8104: IFTRUE 8116
8106: PUSH
8107: LD_VAR 0 8
8111: PUSH
8112: LD_INT 30
8114: GREATER
8115: OR
8116: IFFALSE 8066
// SetAttitude ( 4 , 2 , att_enemy , true ) ;
8118: LD_INT 4
8120: PPUSH
8121: LD_INT 2
8123: PPUSH
8124: LD_INT 2
8126: PPUSH
8127: LD_INT 1
8129: PPUSH
8130: CALL_OW 80
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8134: LD_VAR 0 2
8138: PPUSH
8139: LD_VAR 0 6
8143: PPUSH
8144: LD_VAR 0 5
8148: PPUSH
8149: LD_VAR 0 4
8153: PPUSH
8154: CALL 85607 0 4
// end ;
8158: PPOPN 8
8160: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8161: LD_INT 0
8163: PPUSH
8164: PPUSH
8165: PPUSH
8166: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8167: LD_ADDR_VAR 0 5
8171: PUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: LD_INT 0
8179: PPUSH
8180: CALL_OW 517
8184: ST_TO_ADDR
// if not tmp then
8185: LD_VAR 0 5
8189: NOT
8190: IFFALSE 8194
// exit ;
8192: GO 8444
// arMinesList := arMinesList diff 0 ;
8194: LD_ADDR_EXP 60
8198: PUSH
8199: LD_EXP 60
8203: PUSH
8204: LD_INT 0
8206: DIFF
8207: ST_TO_ADDR
// for i := 1 to n do
8208: LD_ADDR_VAR 0 4
8212: PUSH
8213: DOUBLE
8214: LD_INT 1
8216: DEC
8217: ST_TO_ADDR
8218: LD_VAR 0 2
8222: PUSH
8223: FOR_TO
8224: IFFALSE 8442
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8226: LD_ADDR_VAR 0 6
8230: PUSH
8231: LD_INT 1
8233: PPUSH
8234: LD_VAR 0 5
8238: PUSH
8239: LD_INT 1
8241: ARRAY
8242: PPUSH
8243: CALL_OW 12
8247: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8248: LD_VAR 0 5
8252: PUSH
8253: LD_INT 1
8255: ARRAY
8256: PUSH
8257: LD_VAR 0 6
8261: ARRAY
8262: PPUSH
8263: LD_VAR 0 5
8267: PUSH
8268: LD_INT 2
8270: ARRAY
8271: PUSH
8272: LD_VAR 0 6
8276: ARRAY
8277: PPUSH
8278: LD_INT 2
8280: PPUSH
8281: LD_INT 0
8283: PPUSH
8284: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8288: LD_ADDR_EXP 60
8292: PUSH
8293: LD_EXP 60
8297: PPUSH
8298: LD_EXP 60
8302: PUSH
8303: LD_INT 1
8305: PLUS
8306: PPUSH
8307: LD_VAR 0 5
8311: PUSH
8312: LD_INT 1
8314: ARRAY
8315: PUSH
8316: LD_VAR 0 6
8320: ARRAY
8321: PPUSH
8322: CALL_OW 2
8326: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8327: LD_ADDR_EXP 60
8331: PUSH
8332: LD_EXP 60
8336: PPUSH
8337: LD_EXP 60
8341: PUSH
8342: LD_INT 1
8344: PLUS
8345: PPUSH
8346: LD_VAR 0 5
8350: PUSH
8351: LD_INT 2
8353: ARRAY
8354: PUSH
8355: LD_VAR 0 6
8359: ARRAY
8360: PPUSH
8361: CALL_OW 2
8365: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8366: LD_ADDR_VAR 0 5
8370: PUSH
8371: LD_VAR 0 5
8375: PPUSH
8376: LD_INT 1
8378: PPUSH
8379: LD_VAR 0 5
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: PPUSH
8388: LD_VAR 0 6
8392: PPUSH
8393: CALL_OW 3
8397: PPUSH
8398: CALL_OW 1
8402: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8403: LD_ADDR_VAR 0 5
8407: PUSH
8408: LD_VAR 0 5
8412: PPUSH
8413: LD_INT 2
8415: PPUSH
8416: LD_VAR 0 5
8420: PUSH
8421: LD_INT 2
8423: ARRAY
8424: PPUSH
8425: LD_VAR 0 6
8429: PPUSH
8430: CALL_OW 3
8434: PPUSH
8435: CALL_OW 1
8439: ST_TO_ADDR
// end ;
8440: GO 8223
8442: POP
8443: POP
// end ;
8444: LD_VAR 0 3
8448: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8449: LD_EXP 60
8453: IFFALSE 8684
8455: GO 8457
8457: DISABLE
8458: LD_INT 0
8460: PPUSH
8461: PPUSH
8462: PPUSH
8463: PPUSH
// begin enable ;
8464: ENABLE
// p := 1 ;
8465: LD_ADDR_VAR 0 2
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: DOUBLE
8479: LD_INT 1
8481: DEC
8482: ST_TO_ADDR
8483: LD_EXP 60
8487: PPUSH
8488: CALL 19598 0 1
8492: PUSH
8493: LD_INT 2
8495: DIV
8496: PUSH
8497: FOR_TO
8498: IFFALSE 8682
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8500: LD_ADDR_VAR 0 3
8504: PUSH
8505: LD_EXP 60
8509: PUSH
8510: LD_VAR 0 2
8514: ARRAY
8515: PPUSH
8516: LD_EXP 60
8520: PUSH
8521: LD_VAR 0 2
8525: PUSH
8526: LD_INT 1
8528: PLUS
8529: ARRAY
8530: PPUSH
8531: CALL_OW 428
8535: ST_TO_ADDR
// if tmp then
8536: LD_VAR 0 3
8540: IFFALSE 8666
// begin side := GetSide ( tmp ) ;
8542: LD_ADDR_VAR 0 4
8546: PUSH
8547: LD_VAR 0 3
8551: PPUSH
8552: CALL_OW 255
8556: ST_TO_ADDR
// if side <> 2 and side > 0 then
8557: LD_VAR 0 4
8561: PUSH
8562: LD_INT 2
8564: NONEQUAL
8565: IFFALSE 8577
8567: PUSH
8568: LD_VAR 0 4
8572: PUSH
8573: LD_INT 0
8575: GREATER
8576: AND
8577: IFFALSE 8666
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8579: LD_EXP 60
8583: PUSH
8584: LD_VAR 0 2
8588: ARRAY
8589: PPUSH
8590: LD_EXP 60
8594: PUSH
8595: LD_VAR 0 2
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 2
8607: PPUSH
8608: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8612: LD_ADDR_EXP 60
8616: PUSH
8617: LD_EXP 60
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 3
8631: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8632: LD_ADDR_EXP 60
8636: PUSH
8637: LD_EXP 60
8641: PPUSH
8642: LD_VAR 0 2
8646: PPUSH
8647: CALL_OW 3
8651: ST_TO_ADDR
// p := p - 2 ;
8652: LD_ADDR_VAR 0 2
8656: PUSH
8657: LD_VAR 0 2
8661: PUSH
8662: LD_INT 2
8664: MINUS
8665: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: LD_VAR 0 2
8675: PUSH
8676: LD_INT 2
8678: PLUS
8679: ST_TO_ADDR
// end ;
8680: GO 8497
8682: POP
8683: POP
// end ; end_of_file
8684: PPOPN 4
8686: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
8693: PPUSH
8694: PPUSH
// uc_side := 1 ;
8695: LD_ADDR_OWVAR 20
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// uc_nation := 1 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 1
8710: ST_TO_ADDR
// InitHc ;
8711: CALL_OW 19
// InitVc ;
8715: CALL_OW 20
// tmp := [ ] ;
8719: LD_ADDR_VAR 0 3
8723: PUSH
8724: EMPTY
8725: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8726: LD_ADDR_VAR 0 2
8730: PUSH
8731: DOUBLE
8732: LD_INT 1
8734: DEC
8735: ST_TO_ADDR
8736: LD_INT 6
8738: PUSH
8739: LD_INT 8
8741: PUSH
8742: LD_INT 10
8744: PUSH
8745: LD_INT 10
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_OWVAR 67
8758: ARRAY
8759: PUSH
8760: FOR_TO
8761: IFFALSE 9051
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8763: LD_ADDR_VAR 0 5
8767: PUSH
8768: LD_INT 2
8770: PUSH
8771: LD_INT 4
8773: PUSH
8774: LD_INT 5
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 1
8784: PPUSH
8785: LD_INT 3
8787: PPUSH
8788: CALL_OW 12
8792: ARRAY
8793: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8794: LD_VAR 0 5
8798: PUSH
8799: LD_INT 2
8801: DOUBLE
8802: EQUAL
8803: IFTRUE 8807
8805: GO 8841
8807: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8808: LD_ADDR_VAR 0 6
8812: PUSH
8813: LD_INT 9
8815: PUSH
8816: LD_INT 5
8818: PUSH
8819: LD_INT 7
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 1
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 12
8837: ARRAY
8838: ST_TO_ADDR
8839: GO 8930
8841: LD_INT 4
8843: DOUBLE
8844: EQUAL
8845: IFTRUE 8849
8847: GO 8887
8849: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8850: LD_ADDR_VAR 0 6
8854: PUSH
8855: LD_INT 9
8857: PUSH
8858: LD_INT 6
8860: PUSH
8861: LD_INT 6
8863: PUSH
8864: LD_INT 7
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 4
8878: PPUSH
8879: CALL_OW 12
8883: ARRAY
8884: ST_TO_ADDR
8885: GO 8930
8887: LD_INT 5
8889: DOUBLE
8890: EQUAL
8891: IFTRUE 8895
8893: GO 8929
8895: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8896: LD_ADDR_VAR 0 6
8900: PUSH
8901: LD_INT 9
8903: PUSH
8904: LD_INT 6
8906: PUSH
8907: LD_INT 7
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 3
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: ST_TO_ADDR
8927: GO 8930
8929: POP
// uc_side := 1 ;
8930: LD_ADDR_OWVAR 20
8934: PUSH
8935: LD_INT 1
8937: ST_TO_ADDR
// uc_nation := 1 ;
8938: LD_ADDR_OWVAR 21
8942: PUSH
8943: LD_INT 1
8945: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8946: LD_VAR 0 5
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_VAR 0 6
8980: PPUSH
8981: LD_INT 70
8983: PPUSH
8984: LD_INT 90
8986: PPUSH
8987: CALL_OW 12
8991: PPUSH
8992: CALL 22360 0 5
// veh := CreateVehicle ;
8996: LD_ADDR_VAR 0 4
9000: PUSH
9001: CALL_OW 45
9005: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9006: LD_VAR 0 4
9010: PPUSH
9011: LD_INT 2
9013: PPUSH
9014: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9018: LD_VAR 0 4
9022: PPUSH
9023: LD_INT 17
9025: PPUSH
9026: LD_INT 0
9028: PPUSH
9029: CALL_OW 49
// tmp := tmp ^ veh ;
9033: LD_ADDR_VAR 0 3
9037: PUSH
9038: LD_VAR 0 3
9042: PUSH
9043: LD_VAR 0 4
9047: ADD
9048: ST_TO_ADDR
// end ;
9049: GO 8760
9051: POP
9052: POP
// if not tmp then
9053: LD_VAR 0 3
9057: NOT
9058: IFFALSE 9062
// exit ;
9060: GO 9171
// if not first_powell_attack then
9062: LD_EXP 13
9066: NOT
9067: IFFALSE 9077
// first_powell_attack := true ;
9069: LD_ADDR_EXP 13
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9077: LD_INT 70
9079: PPUSH
9080: CALL_OW 67
// for i in tmp do
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: FOR_IN
9095: IFFALSE 9162
// if IsOk ( i ) then
9097: LD_VAR 0 2
9101: PPUSH
9102: CALL_OW 302
9106: IFFALSE 9144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9108: LD_VAR 0 2
9112: PPUSH
9113: LD_INT 81
9115: PUSH
9116: LD_INT 1
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: PPUSH
9128: LD_VAR 0 2
9132: PPUSH
9133: CALL_OW 74
9137: PPUSH
9138: CALL_OW 115
9142: GO 9160
// tmp := tmp diff i ;
9144: LD_ADDR_VAR 0 3
9148: PUSH
9149: LD_VAR 0 3
9153: PUSH
9154: LD_VAR 0 2
9158: DIFF
9159: ST_TO_ADDR
9160: GO 9094
9162: POP
9163: POP
// until not tmp ;
9164: LD_VAR 0 3
9168: NOT
9169: IFFALSE 9077
// end ;
9171: LD_VAR 0 1
9175: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9176: LD_INT 0
9178: PPUSH
9179: PPUSH
// uc_side := 1 ;
9180: LD_ADDR_OWVAR 20
9184: PUSH
9185: LD_INT 1
9187: ST_TO_ADDR
// uc_nation := 1 ;
9188: LD_ADDR_OWVAR 21
9192: PUSH
9193: LD_INT 1
9195: ST_TO_ADDR
// InitHc ;
9196: CALL_OW 19
// InitVc ;
9200: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9204: LD_INT 5
9206: PPUSH
9207: LD_INT 3
9209: PPUSH
9210: LD_INT 3
9212: PPUSH
9213: LD_INT 12
9215: PPUSH
9216: LD_INT 100
9218: PPUSH
9219: CALL 22360 0 5
// veh := CreateVehicle ;
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: CALL_OW 45
9232: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9233: LD_VAR 0 3
9237: PPUSH
9238: LD_INT 2
9240: PPUSH
9241: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 17
9252: PPUSH
9253: LD_INT 0
9255: PPUSH
9256: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9260: LD_VAR 0 3
9264: PPUSH
9265: LD_VAR 0 1
9269: PUSH
9270: LD_INT 1
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 1
9278: PUSH
9279: LD_INT 2
9281: ARRAY
9282: PPUSH
9283: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: LD_INT 59
9294: PPUSH
9295: LD_INT 2
9297: PPUSH
9298: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9302: LD_INT 35
9304: PPUSH
9305: CALL_OW 67
// if not IsOk ( veh ) then
9309: LD_VAR 0 3
9313: PPUSH
9314: CALL_OW 302
9318: NOT
9319: IFFALSE 9323
// exit ;
9321: GO 9377
// until IsAt ( veh , 59 , 2 ) ;
9323: LD_VAR 0 3
9327: PPUSH
9328: LD_INT 59
9330: PPUSH
9331: LD_INT 2
9333: PPUSH
9334: CALL_OW 307
9338: IFFALSE 9302
// RemoveUnit ( veh ) ;
9340: LD_VAR 0 3
9344: PPUSH
9345: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9349: LD_VAR 0 3
9353: PPUSH
9354: LD_INT 4
9356: PPUSH
9357: CALL_OW 289
9361: IFFALSE 9377
// begin wait ( 0 0$2 ) ;
9363: LD_INT 70
9365: PPUSH
9366: CALL_OW 67
// YouLost ( Artifact ) ;
9370: LD_STRING Artifact
9372: PPUSH
9373: CALL_OW 104
// end ; end ; end_of_file
9377: LD_VAR 0 2
9381: RET
// export function Action ; var tmp , i , un ; begin
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9388: LD_INT 68
9390: PPUSH
9391: LD_INT 39
9393: PPUSH
9394: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9398: LD_ADDR_VAR 0 2
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 7
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: ST_TO_ADDR
// InGameOn ;
9418: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9422: LD_VAR 0 2
9426: PPUSH
9427: LD_INT 71
9429: PPUSH
9430: LD_INT 49
9432: PPUSH
9433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9437: LD_INT 35
9439: PPUSH
9440: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9444: LD_INT 7
9446: PPUSH
9447: LD_INT 71
9449: PPUSH
9450: LD_INT 51
9452: PPUSH
9453: CALL_OW 293
9457: IFFALSE 9437
// DialogueOn ;
9459: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-1
9470: PPUSH
9471: CALL_OW 88
// if Joan then
9475: LD_EXP 32
9479: IFFALSE 9493
// Say ( Joan , D1-Joan-1 ) ;
9481: LD_EXP 32
9485: PPUSH
9486: LD_STRING D1-Joan-1
9488: PPUSH
9489: CALL_OW 88
// if Lisa then
9493: LD_EXP 19
9497: IFFALSE 9511
// Say ( Lisa , D1-Lisa-1 ) ;
9499: LD_EXP 19
9503: PPUSH
9504: LD_STRING D1-Lisa-1
9506: PPUSH
9507: CALL_OW 88
// if Joan or Lisa then
9511: LD_EXP 32
9515: IFTRUE 9523
9517: PUSH
9518: LD_EXP 19
9522: OR
9523: IFFALSE 9537
// Say ( JMM , D1-JMM-2 ) ;
9525: LD_EXP 17
9529: PPUSH
9530: LD_STRING D1-JMM-2
9532: PPUSH
9533: CALL_OW 88
// DialogueOff ;
9537: CALL_OW 7
// InGameOff ;
9541: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9545: LD_INT 71
9547: PPUSH
9548: LD_INT 50
9550: PPUSH
9551: LD_INT 7
9553: PPUSH
9554: LD_INT 30
9556: NEG
9557: PPUSH
9558: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9562: LD_INT 71
9564: PPUSH
9565: LD_INT 50
9567: PPUSH
9568: LD_INT 7
9570: PPUSH
9571: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9575: LD_STRING M1
9577: PPUSH
9578: CALL_OW 337
// SaveForQuickRestart ;
9582: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9586: LD_INT 35
9588: PPUSH
9589: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9593: LD_EXP 3
9597: IFTRUE 9609
9599: PUSH
9600: LD_OWVAR 1
9604: PUSH
9605: LD_INT 2100
9607: GREATER
9608: OR
9609: IFFALSE 9586
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9611: LD_INT 350
9613: PPUSH
9614: LD_INT 700
9616: PPUSH
9617: CALL_OW 12
9621: PPUSH
9622: CALL_OW 67
// PrepareGossudarov ;
9626: CALL 1949 0 0
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9637: LD_INT 22
9639: PUSH
9640: LD_INT 6
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 3
9649: PUSH
9650: LD_INT 24
9652: PUSH
9653: LD_INT 1000
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: IFTRUE 9688
9674: PUSH
9675: LD_INT 7
9677: PPUSH
9678: LD_EXP 35
9682: PPUSH
9683: CALL_OW 292
9687: OR
9688: IFFALSE 9630
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9690: LD_ADDR_VAR 0 2
9694: PUSH
9695: LD_INT 22
9697: PUSH
9698: LD_INT 6
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PPUSH
9705: CALL_OW 69
9709: ST_TO_ADDR
// for i in tmp do
9710: LD_ADDR_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: FOR_IN
9721: IFFALSE 9737
// SetSide ( i , 7 ) ;
9723: LD_VAR 0 3
9727: PPUSH
9728: LD_INT 7
9730: PPUSH
9731: CALL_OW 235
9735: GO 9720
9737: POP
9738: POP
// DialogueOn ;
9739: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9743: LD_EXP 17
9747: PUSH
9748: LD_EXP 18
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PPUSH
9757: LD_EXP 35
9761: PPUSH
9762: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9766: LD_EXP 35
9770: PPUSH
9771: CALL_OW 87
// if not Roth then
9775: LD_EXP 18
9779: NOT
9780: IFFALSE 9872
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9782: LD_VAR 0 2
9786: PPUSH
9787: LD_INT 3
9789: PUSH
9790: LD_INT 24
9792: PUSH
9793: LD_INT 1000
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: PPUSH
9804: CALL_OW 72
9808: IFFALSE 9822
// Say ( JMM , D2-JMM-1 ) ;
9810: LD_EXP 17
9814: PPUSH
9815: LD_STRING D2-JMM-1
9817: PPUSH
9818: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9822: LD_EXP 17
9826: PPUSH
9827: LD_STRING D2-JMM-1b
9829: PPUSH
9830: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9834: LD_EXP 35
9838: PPUSH
9839: LD_STRING D2-Gos-1
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-2
9853: PPUSH
9854: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9858: LD_EXP 35
9862: PPUSH
9863: LD_STRING D2-Gos-2
9865: PPUSH
9866: CALL_OW 88
// end else
9870: GO 10024
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 1000
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PPUSH
9894: CALL_OW 72
9898: IFFALSE 9924
// begin Say ( Roth , D2-Roth-2 ) ;
9900: LD_EXP 18
9904: PPUSH
9905: LD_STRING D2-Roth-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9912: LD_EXP 17
9916: PPUSH
9917: LD_STRING D2-JMM-1a
9919: PPUSH
9920: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9924: LD_EXP 18
9928: PPUSH
9929: LD_STRING D2-Roth-2a
9931: PPUSH
9932: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9936: LD_EXP 18
9940: PPUSH
9941: LD_STRING D2-Roth-2b
9943: PPUSH
9944: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9948: LD_EXP 17
9952: PPUSH
9953: LD_STRING D2-JMM-3
9955: PPUSH
9956: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9960: LD_VAR 0 2
9964: PPUSH
9965: LD_INT 3
9967: PUSH
9968: LD_INT 24
9970: PUSH
9971: LD_INT 1000
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: IFFALSE 10024
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9988: LD_EXP 35
9992: PPUSH
9993: LD_STRING D2-Gos-3
9995: PPUSH
9996: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
10000: LD_EXP 17
10004: PPUSH
10005: LD_STRING D2-JMM-4
10007: PPUSH
10008: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
10012: LD_EXP 35
10016: PPUSH
10017: LD_STRING D2-Gos-4
10019: PPUSH
10020: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
10024: LD_EXP 17
10028: PPUSH
10029: LD_STRING D2-JMM-5
10031: PPUSH
10032: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
10036: LD_EXP 35
10040: PPUSH
10041: LD_STRING D2-Gos-5
10043: PPUSH
10044: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
10048: LD_EXP 17
10052: PPUSH
10053: LD_STRING D2-JMM-6
10055: PPUSH
10056: CALL_OW 88
// DialogueOff ;
10060: CALL_OW 7
// wait ( 0 0$2 ) ;
10064: LD_INT 70
10066: PPUSH
10067: CALL_OW 67
// if Kirilenkova then
10071: LD_EXP 36
10075: IFFALSE 10089
// Say ( Kirilenkova , D3-Kir-1 ) ;
10077: LD_EXP 36
10081: PPUSH
10082: LD_STRING D3-Kir-1
10084: PPUSH
10085: CALL_OW 88
// gossudarov_arrive := true ;
10089: LD_ADDR_EXP 4
10093: PUSH
10094: LD_INT 1
10096: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10097: LD_INT 35
10099: PPUSH
10100: CALL_OW 67
// until ru_lab_builded ;
10104: LD_EXP 5
10108: IFFALSE 10097
// DialogueOn ;
10110: CALL_OW 6
// if Kirilenkova then
10114: LD_EXP 36
10118: IFFALSE 10134
// Say ( Kirilenkova , D3a-Kir-1 ) else
10120: LD_EXP 36
10124: PPUSH
10125: LD_STRING D3a-Kir-1
10127: PPUSH
10128: CALL_OW 88
10132: GO 10156
// begin un := SciRu ;
10134: LD_ADDR_VAR 0 4
10138: PUSH
10139: CALL 15750 0 0
10143: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10144: LD_VAR 0 4
10148: PPUSH
10149: LD_STRING D3a-Sci1-1
10151: PPUSH
10152: CALL_OW 88
// end ; if Kirilenkova or un then
10156: LD_EXP 36
10160: IFTRUE 10168
10162: PUSH
10163: LD_VAR 0 4
10167: OR
10168: IFFALSE 10182
// Say ( JMM , D3a-JMM-1 ) ;
10170: LD_EXP 17
10174: PPUSH
10175: LD_STRING D3a-JMM-1
10177: PPUSH
10178: CALL_OW 88
// DialogueOff ;
10182: CALL_OW 7
// end ;
10186: LD_VAR 0 1
10190: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10191: LD_EXP 4
10195: IFFALSE 10304
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_INT 7
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: LD_INT 25
10213: PUSH
10214: LD_INT 1
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 25
10223: PUSH
10224: LD_INT 2
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: LD_INT 25
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: PUSH
10241: LD_INT 25
10243: PUSH
10244: LD_INT 4
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 25
10253: PUSH
10254: LD_INT 5
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 25
10263: PUSH
10264: LD_INT 8
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 25
10273: PUSH
10274: LD_INT 9
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: PUSH
10300: LD_INT 7
10302: LESS
10303: AND
10304: IFFALSE 10316
10306: GO 10308
10308: DISABLE
// YouLost ( TooMany ) ;
10309: LD_STRING TooMany
10311: PPUSH
10312: CALL_OW 104
10316: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10317: LD_EXP 35
10321: PPUSH
10322: CALL_OW 255
10326: PUSH
10327: LD_INT 7
10329: EQUAL
10330: IFFALSE 10553
10332: GO 10334
10334: DISABLE
10335: LD_INT 0
10337: PPUSH
10338: PPUSH
10339: PPUSH
// begin uc_side := 3 ;
10340: LD_ADDR_OWVAR 20
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// uc_nation := 3 ;
10348: LD_ADDR_OWVAR 21
10352: PUSH
10353: LD_INT 3
10355: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10356: LD_INT 21
10358: PPUSH
10359: LD_INT 3
10361: PPUSH
10362: LD_INT 3
10364: PPUSH
10365: LD_INT 42
10367: PPUSH
10368: LD_INT 100
10370: PPUSH
10371: CALL 22360 0 5
// un := CreateVehicle ;
10375: LD_ADDR_VAR 0 3
10379: PUSH
10380: CALL_OW 45
10384: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10385: LD_VAR 0 3
10389: PPUSH
10390: LD_INT 15
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10400: LD_VAR 0 3
10404: PPUSH
10405: LD_INT 67
10407: PPUSH
10408: LD_INT 45
10410: PPUSH
10411: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10415: LD_VAR 0 3
10419: PPUSH
10420: LD_INT 70
10422: PPUSH
10423: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10427: LD_VAR 0 3
10431: PPUSH
10432: LD_INT 69
10434: PPUSH
10435: LD_INT 18
10437: PPUSH
10438: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10442: LD_VAR 0 3
10446: PPUSH
10447: LD_INT 60
10449: PPUSH
10450: LD_INT 3
10452: PPUSH
10453: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10457: LD_INT 35
10459: PPUSH
10460: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10464: LD_VAR 0 3
10468: PPUSH
10469: CALL_OW 302
10473: NOT
10474: IFTRUE 10490
10476: PUSH
10477: LD_VAR 0 3
10481: PPUSH
10482: LD_INT 17
10484: PPUSH
10485: CALL_OW 308
10489: OR
10490: IFTRUE 10509
10492: PUSH
10493: LD_VAR 0 3
10497: PPUSH
10498: LD_INT 60
10500: PPUSH
10501: LD_INT 3
10503: PPUSH
10504: CALL_OW 307
10508: OR
10509: IFFALSE 10457
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10511: LD_VAR 0 3
10515: PPUSH
10516: LD_INT 17
10518: PPUSH
10519: CALL_OW 308
10523: IFTRUE 10542
10525: PUSH
10526: LD_VAR 0 3
10530: PPUSH
10531: LD_INT 60
10533: PPUSH
10534: LD_INT 3
10536: PPUSH
10537: CALL_OW 307
10541: OR
10542: IFFALSE 10553
// RemoveUnit ( un ) ;
10544: LD_VAR 0 3
10548: PPUSH
10549: CALL_OW 64
// end ;
10553: PPOPN 3
10555: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10556: LD_EXP 4
10560: IFFALSE 10802
10562: GO 10564
10564: DISABLE
10565: LD_INT 0
10567: PPUSH
10568: PPUSH
10569: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10570: LD_INT 70
10572: PPUSH
10573: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10577: LD_ADDR_VAR 0 3
10581: PUSH
10582: LD_INT 22
10584: PUSH
10585: LD_INT 7
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 101
10594: PUSH
10595: LD_INT 3
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PPUSH
10606: CALL_OW 69
10610: ST_TO_ADDR
// until tmp ;
10611: LD_VAR 0 3
10615: IFFALSE 10570
// un := NearestUnitToUnit ( tmp , JMM ) ;
10617: LD_ADDR_VAR 0 2
10621: PUSH
10622: LD_VAR 0 3
10626: PPUSH
10627: LD_EXP 17
10631: PPUSH
10632: CALL_OW 74
10636: ST_TO_ADDR
// player_spotted := true ;
10637: LD_ADDR_EXP 7
10641: PUSH
10642: LD_INT 1
10644: ST_TO_ADDR
// tmp := SciRu ;
10645: LD_ADDR_VAR 0 3
10649: PUSH
10650: CALL 15750 0 0
10654: ST_TO_ADDR
// if not tmp then
10655: LD_VAR 0 3
10659: NOT
10660: IFFALSE 10672
// tmp := SolRu ;
10662: LD_ADDR_VAR 0 3
10666: PUSH
10667: CALL 15897 0 0
10671: ST_TO_ADDR
// DialogueOn ;
10672: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10676: LD_VAR 0 2
10680: PPUSH
10681: CALL_OW 250
10685: PPUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 251
10695: PPUSH
10696: LD_INT 7
10698: PPUSH
10699: LD_INT 8
10701: NEG
10702: PPUSH
10703: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 87
// if tmp then
10716: LD_VAR 0 3
10720: IFFALSE 10734
// Say ( tmp , D4-RSci1-1 ) ;
10722: LD_VAR 0 3
10726: PPUSH
10727: LD_STRING D4-RSci1-1
10729: PPUSH
10730: CALL_OW 88
// if Gossudarov then
10734: LD_EXP 35
10738: IFFALSE 10764
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10740: LD_EXP 35
10744: PPUSH
10745: LD_STRING D4-Gos-1
10747: PPUSH
10748: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10752: LD_EXP 17
10756: PPUSH
10757: LD_STRING D4-JMM-1
10759: PPUSH
10760: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10764: LD_VAR 0 2
10768: PPUSH
10769: CALL_OW 250
10773: PPUSH
10774: LD_VAR 0 2
10778: PPUSH
10779: CALL_OW 251
10783: PPUSH
10784: LD_INT 7
10786: PPUSH
10787: CALL_OW 331
// DialogueOff ;
10791: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10795: LD_STRING M5
10797: PPUSH
10798: CALL_OW 337
// end ;
10802: PPOPN 3
10804: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10805: LD_EXP 7
10809: IFFALSE 11408
10811: GO 10813
10813: DISABLE
10814: LD_INT 0
10816: PPUSH
10817: PPUSH
10818: PPUSH
// begin PrepareBelkov ;
10819: CALL 2262 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10823: LD_EXP 50
10827: PPUSH
10828: LD_INT 118
10830: PPUSH
10831: LD_INT 106
10833: PPUSH
10834: CALL_OW 111
// AddComHold ( Belkov ) ;
10838: LD_EXP 50
10842: PPUSH
10843: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10847: LD_INT 35
10849: PPUSH
10850: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10854: LD_EXP 50
10858: PPUSH
10859: LD_INT 118
10861: PPUSH
10862: LD_INT 106
10864: PPUSH
10865: CALL_OW 307
10869: IFFALSE 10847
// ChangeSideFog ( 4 , 7 ) ;
10871: LD_INT 4
10873: PPUSH
10874: LD_INT 7
10876: PPUSH
10877: CALL_OW 343
// if IsOk ( Belkov ) then
10881: LD_EXP 50
10885: PPUSH
10886: CALL_OW 302
10890: IFFALSE 10974
// begin InGameOn ;
10892: CALL_OW 8
// DialogueOn ;
10896: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10900: LD_EXP 50
10904: PPUSH
10905: LD_STRING D5-Bel-1
10907: PPUSH
10908: CALL_OW 94
// if Gossudarov then
10912: LD_EXP 35
10916: IFFALSE 10966
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10918: LD_EXP 35
10922: PPUSH
10923: LD_STRING D5-Gos-1
10925: PPUSH
10926: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10930: LD_EXP 17
10934: PPUSH
10935: LD_STRING D5-JMM-1
10937: PPUSH
10938: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10942: LD_EXP 35
10946: PPUSH
10947: LD_STRING D5-Gos-2
10949: PPUSH
10950: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10954: LD_EXP 17
10958: PPUSH
10959: LD_STRING D5-JMM-2
10961: PPUSH
10962: CALL_OW 88
// end ; DialogueOff ;
10966: CALL_OW 7
// InGameOff ;
10970: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10974: LD_STRING QSaveBelkov
10976: PPUSH
10977: CALL_OW 97
10981: PUSH
10982: LD_INT 1
10984: DOUBLE
10985: EQUAL
10986: IFTRUE 10990
10988: GO 11040
10990: POP
// begin DialogueOn ;
10991: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10995: LD_EXP 17
10999: PPUSH
11000: LD_STRING D5a-JMM-1
11002: PPUSH
11003: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
11007: LD_EXP 50
11011: PPUSH
11012: LD_STRING D5a-Bel-1
11014: PPUSH
11015: CALL_OW 94
// DialogueOff ;
11019: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
11023: LD_EXP 50
11027: PPUSH
11028: LD_INT 83
11030: PPUSH
11031: LD_INT 49
11033: PPUSH
11034: CALL_OW 111
// end ; 2 :
11038: GO 11073
11040: LD_INT 2
11042: DOUBLE
11043: EQUAL
11044: IFTRUE 11048
11046: GO 11072
11048: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
11049: LD_EXP 17
11053: PPUSH
11054: LD_STRING D5a-JMM-2
11056: PPUSH
11057: CALL_OW 88
// ComHold ( Belkov ) ;
11061: LD_EXP 50
11065: PPUSH
11066: CALL_OW 140
// end ; end ;
11070: GO 11073
11072: POP
// time := 0 0$00 ;
11073: LD_ADDR_VAR 0 1
11077: PUSH
11078: LD_INT 0
11080: ST_TO_ADDR
// vehSpawned := false ;
11081: LD_ADDR_VAR 0 3
11085: PUSH
11086: LD_INT 0
11088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11089: LD_INT 35
11091: PPUSH
11092: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11096: LD_VAR 0 1
11100: PUSH
11101: LD_INT 350
11103: PUSH
11104: LD_INT 175
11106: PUSH
11107: LD_INT 105
11109: PUSH
11110: LD_INT 70
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: PUSH
11119: LD_OWVAR 67
11123: ARRAY
11124: GREATEREQUAL
11125: IFFALSE 11134
11127: PUSH
11128: LD_VAR 0 3
11132: NOT
11133: AND
11134: IFFALSE 11224
// begin vehSpawned := true ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: LD_INT 1
11143: ST_TO_ADDR
// uc_side := 3 ;
11144: LD_ADDR_OWVAR 20
11148: PUSH
11149: LD_INT 3
11151: ST_TO_ADDR
// uc_nation := 3 ;
11152: LD_ADDR_OWVAR 21
11156: PUSH
11157: LD_INT 3
11159: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11160: LD_INT 22
11162: PPUSH
11163: LD_INT 3
11165: PPUSH
11166: LD_INT 3
11168: PPUSH
11169: LD_INT 43
11171: PPUSH
11172: LD_INT 100
11174: PPUSH
11175: CALL 22360 0 5
// veh := CreateVehicle ;
11179: LD_ADDR_VAR 0 2
11183: PUSH
11184: CALL_OW 45
11188: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11189: LD_VAR 0 2
11193: PPUSH
11194: LD_INT 130
11196: PPUSH
11197: LD_INT 131
11199: PPUSH
11200: LD_INT 0
11202: PPUSH
11203: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11207: LD_VAR 0 2
11211: PPUSH
11212: LD_INT 100
11214: PPUSH
11215: LD_INT 82
11217: PPUSH
11218: CALL_OW 114
// end else
11222: GO 11238
// time := time + 0 0$1 ;
11224: LD_ADDR_VAR 0 1
11228: PUSH
11229: LD_VAR 0 1
11233: PUSH
11234: LD_INT 35
11236: PLUS
11237: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11238: LD_EXP 50
11242: PPUSH
11243: CALL_OW 301
11247: IFFALSE 11264
11249: PUSH
11250: LD_EXP 50
11254: PPUSH
11255: CALL_OW 255
11259: PUSH
11260: LD_INT 4
11262: EQUAL
11263: AND
11264: IFTRUE 11306
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PPUSH
11277: CALL_OW 69
11281: PPUSH
11282: LD_EXP 50
11286: PPUSH
11287: CALL_OW 74
11291: PPUSH
11292: LD_EXP 50
11296: PPUSH
11297: CALL_OW 296
11301: PUSH
11302: LD_INT 10
11304: LESS
11305: OR
11306: IFFALSE 11089
// if IsDead ( Belkov ) then
11308: LD_EXP 50
11312: PPUSH
11313: CALL_OW 301
11317: IFFALSE 11342
// begin CenterNowOnUnits ( Belkov ) ;
11319: LD_EXP 50
11323: PPUSH
11324: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11328: LD_EXP 17
11332: PPUSH
11333: LD_STRING D5a-JMM-2a
11335: PPUSH
11336: CALL_OW 88
// exit ;
11340: GO 11408
// end ; if See ( 7 , Belkov ) then
11342: LD_INT 7
11344: PPUSH
11345: LD_EXP 50
11349: PPUSH
11350: CALL_OW 292
11354: IFFALSE 11368
// SetSide ( Belkov , 7 ) ;
11356: LD_EXP 50
11360: PPUSH
11361: LD_INT 7
11363: PPUSH
11364: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11368: LD_INT 35
11370: PPUSH
11371: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11375: LD_EXP 50
11379: PPUSH
11380: LD_INT 66
11382: PPUSH
11383: LD_INT 45
11385: PPUSH
11386: CALL_OW 297
11390: PUSH
11391: LD_INT 30
11393: LESS
11394: IFFALSE 11368
// Say ( Belkov , D6-Bel-1 ) ;
11396: LD_EXP 50
11400: PPUSH
11401: LD_STRING D6-Bel-1
11403: PPUSH
11404: CALL_OW 88
// end ;
11408: PPOPN 3
11410: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11411: LD_EXP 50
11415: PPUSH
11416: CALL_OW 302
11420: IFFALSE 11467
11422: PUSH
11423: LD_EXP 50
11427: PPUSH
11428: CALL_OW 504
11432: PUSH
11433: LD_INT 2
11435: PUSH
11436: LD_INT 34
11438: PUSH
11439: LD_INT 47
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: LD_INT 34
11448: PUSH
11449: LD_INT 45
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: PPUSH
11461: CALL_OW 69
11465: IN
11466: AND
11467: IFFALSE 11484
11469: GO 11471
11471: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11472: LD_EXP 50
11476: PPUSH
11477: LD_STRING D7-Bel-1
11479: PPUSH
11480: CALL_OW 88
11484: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11485: LD_INT 22
11487: PUSH
11488: LD_INT 7
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: LD_INT 101
11497: PUSH
11498: LD_INT 2
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: PPUSH
11509: CALL_OW 69
11513: IFFALSE 11522
11515: PUSH
11516: LD_EXP 9
11520: NOT
11521: AND
11522: IFFALSE 11536
11524: PUSH
11525: LD_EXP 49
11529: PPUSH
11530: CALL_OW 305
11534: NOT
11535: AND
11536: IFFALSE 12021
11538: GO 11540
11540: DISABLE
11541: LD_INT 0
11543: PPUSH
// begin ar_base_spotted := true ;
11544: LD_ADDR_EXP 9
11548: PUSH
11549: LD_INT 1
11551: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11552: LD_ADDR_VAR 0 1
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 21
11569: PUSH
11570: LD_INT 3
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PPUSH
11581: CALL_OW 69
11585: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11586: LD_ADDR_VAR 0 1
11590: PUSH
11591: LD_VAR 0 1
11595: PPUSH
11596: LD_EXP 17
11600: PPUSH
11601: CALL_OW 74
11605: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11606: LD_INT 7
11608: PPUSH
11609: LD_INT 3
11611: PPUSH
11612: CALL_OW 332
// DialogueOn ;
11616: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11620: LD_VAR 0 1
11624: PPUSH
11625: CALL_OW 250
11629: PPUSH
11630: LD_VAR 0 1
11634: PPUSH
11635: CALL_OW 251
11639: PPUSH
11640: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11644: LD_ADDR_VAR 0 1
11648: PUSH
11649: LD_INT 22
11651: PUSH
11652: LD_INT 7
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 23
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: PPUSH
11684: CALL_OW 69
11688: PUSH
11689: LD_EXP 17
11693: PUSH
11694: LD_EXP 21
11698: PUSH
11699: LD_EXP 22
11703: PUSH
11704: LD_EXP 29
11708: PUSH
11709: LD_EXP 18
11713: PUSH
11714: LD_EXP 27
11718: PUSH
11719: LD_EXP 23
11723: PUSH
11724: LD_EXP 25
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: DIFF
11739: ST_TO_ADDR
// if not tmp then
11740: LD_VAR 0 1
11744: NOT
11745: IFFALSE 11819
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11747: LD_ADDR_VAR 0 1
11751: PUSH
11752: LD_INT 22
11754: PUSH
11755: LD_INT 7
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 23
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 26
11774: PUSH
11775: LD_INT 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: PPUSH
11787: CALL_OW 69
11791: PUSH
11792: LD_EXP 32
11796: PUSH
11797: LD_EXP 19
11801: PUSH
11802: LD_EXP 30
11806: PUSH
11807: LD_EXP 31
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: DIFF
11818: ST_TO_ADDR
// if tmp then
11819: LD_VAR 0 1
11823: IFFALSE 11894
// case GetSex ( tmp [ 1 ] ) of sex_male :
11825: LD_VAR 0 1
11829: PUSH
11830: LD_INT 1
11832: ARRAY
11833: PPUSH
11834: CALL_OW 258
11838: PUSH
11839: LD_INT 1
11841: DOUBLE
11842: EQUAL
11843: IFTRUE 11847
11845: GO 11866
11847: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11848: LD_VAR 0 1
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_STRING D9-Sol1-1
11859: PPUSH
11860: CALL_OW 88
11864: GO 11894
11866: LD_INT 2
11868: DOUBLE
11869: EQUAL
11870: IFTRUE 11874
11872: GO 11893
11874: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11875: LD_VAR 0 1
11879: PUSH
11880: LD_INT 1
11882: ARRAY
11883: PPUSH
11884: LD_STRING D9-FSol1-1
11886: PPUSH
11887: CALL_OW 88
11891: GO 11894
11893: POP
// if Frank then
11894: LD_EXP 29
11898: IFFALSE 12002
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11900: LD_EXP 59
11904: PPUSH
11905: CALL_OW 250
11909: PPUSH
11910: LD_EXP 59
11914: PPUSH
11915: CALL_OW 251
11919: PPUSH
11920: LD_INT 7
11922: PPUSH
11923: LD_INT 8
11925: PPUSH
11926: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11930: LD_EXP 59
11934: PPUSH
11935: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11939: LD_EXP 29
11943: PPUSH
11944: LD_STRING D9-Frank-1
11946: PPUSH
11947: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11951: LD_EXP 17
11955: PPUSH
11956: LD_STRING D9-JMM-1
11958: PPUSH
11959: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11963: LD_EXP 29
11967: PPUSH
11968: LD_STRING D9-Frank-2
11970: PPUSH
11971: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11975: LD_EXP 59
11979: PPUSH
11980: CALL_OW 250
11984: PPUSH
11985: LD_EXP 59
11989: PPUSH
11990: CALL_OW 251
11994: PPUSH
11995: LD_INT 7
11997: PPUSH
11998: CALL_OW 331
// end ; DialogueOff ;
12002: CALL_OW 7
// wait ( 1 1$00 ) ;
12006: LD_INT 2100
12008: PPUSH
12009: CALL_OW 67
// ar_active_attack := true ;
12013: LD_ADDR_EXP 10
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// end ;
12021: PPOPN 1
12023: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
12024: LD_EXP 8
12028: IFTRUE 12040
12030: PUSH
12031: LD_OWVAR 1
12035: PUSH
12036: LD_INT 42000
12038: GREATEREQUAL
12039: OR
12040: IFFALSE 13104
12042: GO 12044
12044: DISABLE
12045: LD_INT 0
12047: PPUSH
12048: PPUSH
// begin selected_option := 1 ;
12049: LD_ADDR_VAR 0 2
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// wait ( 5 5$00 ) ;
12057: LD_INT 10500
12059: PPUSH
12060: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12064: LD_INT 35
12066: PPUSH
12067: CALL_OW 67
// until not ru_attackers ;
12071: LD_EXP 55
12075: NOT
12076: IFFALSE 12064
// PrepareBurlak ;
12078: CALL 2374 0 0
// repeat wait ( 0 0$2 ) ;
12082: LD_INT 70
12084: PPUSH
12085: CALL_OW 67
// until not HasTask ( Burlak ) ;
12089: LD_EXP 49
12093: PPUSH
12094: CALL_OW 314
12098: NOT
12099: IFFALSE 12082
// InGameOn ;
12101: CALL_OW 8
// DialogueOn ;
12105: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12109: LD_EXP 52
12113: PPUSH
12114: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12118: LD_EXP 49
12122: PPUSH
12123: LD_STRING D10-Bur-1
12125: PPUSH
12126: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12130: LD_EXP 50
12134: IFFALSE 12151
12136: PUSH
12137: LD_EXP 50
12141: PPUSH
12142: CALL_OW 255
12146: PUSH
12147: LD_INT 7
12149: EQUAL
12150: AND
12151: IFFALSE 12165
// Say ( Belkov , D10-Bel-1 ) ;
12153: LD_EXP 50
12157: PPUSH
12158: LD_STRING D10-Bel-1
12160: PPUSH
12161: CALL_OW 88
// if Gossudarov then
12165: LD_EXP 35
12169: IFFALSE 12183
// Say ( Gossudarov , D10-Gos-1 ) ;
12171: LD_EXP 35
12175: PPUSH
12176: LD_STRING D10-Gos-1
12178: PPUSH
12179: CALL_OW 88
// if Kirilenkova then
12183: LD_EXP 36
12187: IFFALSE 12201
// Say ( Kirilenkova , D10-Kir-1 ) ;
12189: LD_EXP 36
12193: PPUSH
12194: LD_STRING D10-Kir-1
12196: PPUSH
12197: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12201: CALL 15897 0 0
12205: PPUSH
12206: LD_STRING D10-RSol1-1
12208: PPUSH
12209: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12213: LD_EXP 49
12217: PPUSH
12218: LD_STRING D10-Bur-2
12220: PPUSH
12221: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12225: LD_EXP 17
12229: PPUSH
12230: LD_STRING D10-JMM-2
12232: PPUSH
12233: CALL_OW 88
// if Kirilenkova then
12237: LD_EXP 36
12241: IFFALSE 12257
// Say ( Kirilenkova , D10-Kir-2 ) else
12243: LD_EXP 36
12247: PPUSH
12248: LD_STRING D10-Kir-2
12250: PPUSH
12251: CALL_OW 88
12255: GO 12269
// Say ( SolRu , D10-RSol1-2 ) ;
12257: CALL 15897 0 0
12261: PPUSH
12262: LD_STRING D10-RSol1-2
12264: PPUSH
12265: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12269: LD_EXP 17
12273: PPUSH
12274: LD_STRING D10-JMM-3
12276: PPUSH
12277: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12281: LD_EXP 49
12285: PPUSH
12286: LD_STRING D10-Bur-3
12288: PPUSH
12289: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12293: LD_EXP 17
12297: PPUSH
12298: LD_STRING D10-JMM-4
12300: PPUSH
12301: CALL_OW 88
// DialogueOff ;
12305: CALL_OW 7
// InGameOff ;
12309: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12313: LD_STRING M2
12315: PPUSH
12316: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12320: LD_INT 35
12322: PPUSH
12323: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12327: LD_INT 22
12329: PUSH
12330: LD_INT 7
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 91
12339: PUSH
12340: LD_EXP 49
12344: PUSH
12345: LD_INT 8
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PPUSH
12357: CALL_OW 69
12361: IFFALSE 12320
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12363: LD_ADDR_VAR 0 1
12367: PUSH
12368: LD_INT 22
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PPUSH
12378: CALL_OW 69
12382: PUSH
12383: FOR_IN
12384: IFFALSE 12400
// SetSide ( i , 7 ) ;
12386: LD_VAR 0 1
12390: PPUSH
12391: LD_INT 7
12393: PPUSH
12394: CALL_OW 235
12398: GO 12383
12400: POP
12401: POP
// ChangeMissionObjectives ( M3 ) ;
12402: LD_STRING M3
12404: PPUSH
12405: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12409: LD_INT 35
12411: PPUSH
12412: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12416: LD_EXP 17
12420: PPUSH
12421: LD_EXP 49
12425: PPUSH
12426: CALL_OW 296
12430: PUSH
12431: LD_INT 8
12433: LESS
12434: IFFALSE 12409
// ComTurnUnit ( JMM , Burlak ) ;
12436: LD_EXP 17
12440: PPUSH
12441: LD_EXP 49
12445: PPUSH
12446: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12450: LD_EXP 49
12454: PPUSH
12455: LD_EXP 17
12459: PPUSH
12460: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12464: LD_INT 10
12466: PPUSH
12467: CALL_OW 67
// DialogueOn ;
12471: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12475: LD_EXP 17
12479: PPUSH
12480: LD_STRING D11-JMM-1
12482: PPUSH
12483: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12487: LD_EXP 49
12491: PPUSH
12492: LD_STRING D11-Bur-1
12494: PPUSH
12495: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12499: LD_EXP 17
12503: PPUSH
12504: LD_STRING D11-JMM-2
12506: PPUSH
12507: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12511: LD_EXP 49
12515: PPUSH
12516: LD_STRING D11-Bur-2
12518: PPUSH
12519: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12523: LD_EXP 17
12527: PPUSH
12528: LD_STRING D11-JMM-3
12530: PPUSH
12531: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12535: LD_EXP 49
12539: PPUSH
12540: LD_STRING D11-Bur-3
12542: PPUSH
12543: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12547: LD_EXP 17
12551: PPUSH
12552: LD_STRING D11-JMM-4
12554: PPUSH
12555: CALL_OW 88
// if ar_base_spotted then
12559: LD_EXP 9
12563: IFFALSE 12579
// Say ( Burlak , D12-Bur-1 ) else
12565: LD_EXP 49
12569: PPUSH
12570: LD_STRING D12-Bur-1
12572: PPUSH
12573: CALL_OW 88
12577: GO 12618
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 3
12584: PPUSH
12585: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12589: LD_INT 127
12591: PPUSH
12592: LD_INT 45
12594: PPUSH
12595: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12599: LD_EXP 49
12603: PPUSH
12604: LD_STRING D12-Bur-1a
12606: PPUSH
12607: CALL_OW 88
// dwait ( 0 0$2 ) ;
12611: LD_INT 70
12613: PPUSH
12614: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12618: LD_EXP 58
12622: PPUSH
12623: CALL_OW 302
12627: NOT
12628: IFFALSE 12636
// begin DialogueOff ;
12630: CALL_OW 7
// exit ;
12634: GO 13104
// end ; Say ( Burlak , D12-Bur-1b ) ;
12636: LD_EXP 49
12640: PPUSH
12641: LD_STRING D12-Bur-1b
12643: PPUSH
12644: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12648: LD_EXP 17
12652: PPUSH
12653: LD_STRING D12-JMM-1
12655: PPUSH
12656: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12660: LD_EXP 49
12664: PPUSH
12665: LD_STRING D12-Bur-2
12667: PPUSH
12668: CALL_OW 88
// if Roth then
12672: LD_EXP 18
12676: IFFALSE 12692
// Say ( Roth , D12-Roth-2 ) else
12678: LD_EXP 18
12682: PPUSH
12683: LD_STRING D12-Roth-2
12685: PPUSH
12686: CALL_OW 88
12690: GO 12704
// Say ( SciRu , D12-RSci1-2 ) ;
12692: CALL 15750 0 0
12696: PPUSH
12697: LD_STRING D12-RSci1-2
12699: PPUSH
12700: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12704: LD_EXP 17
12708: PPUSH
12709: LD_STRING D12-JMM-2
12711: PPUSH
12712: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12716: LD_EXP 49
12720: PPUSH
12721: LD_STRING D12-Bur-3
12723: PPUSH
12724: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12728: LD_EXP 17
12732: PPUSH
12733: LD_STRING D12-JMM-3
12735: PPUSH
12736: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12740: LD_EXP 49
12744: PPUSH
12745: LD_STRING D12-Bur-4
12747: PPUSH
12748: CALL_OW 88
// case Query ( QBase ) of 1 :
12752: LD_STRING QBase
12754: PPUSH
12755: CALL_OW 97
12759: PUSH
12760: LD_INT 1
12762: DOUBLE
12763: EQUAL
12764: IFTRUE 12768
12766: GO 12886
12768: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12769: LD_EXP 17
12773: PPUSH
12774: LD_STRING D13a-JMM-1
12776: PPUSH
12777: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12781: LD_EXP 49
12785: PPUSH
12786: LD_STRING D13a-Bur-1
12788: PPUSH
12789: CALL_OW 88
// if Roth then
12793: LD_EXP 18
12797: IFFALSE 12813
// Say ( Roth , D13a-Roth-1 ) else
12799: LD_EXP 18
12803: PPUSH
12804: LD_STRING D13a-Roth-1
12806: PPUSH
12807: CALL_OW 88
12811: GO 12825
// Say ( SciRu , D13a-RSci1-1 ) ;
12813: CALL 15750 0 0
12817: PPUSH
12818: LD_STRING D13a-RSci1-1
12820: PPUSH
12821: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12825: LD_EXP 17
12829: PPUSH
12830: LD_STRING D13a-JMM-2
12832: PPUSH
12833: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12837: LD_STRING QBaseAgain
12839: PPUSH
12840: CALL_OW 97
12844: PUSH
12845: LD_INT 1
12847: DOUBLE
12848: EQUAL
12849: IFTRUE 12853
12851: GO 12864
12853: POP
// selected_option := 2 ; 2 :
12854: LD_ADDR_VAR 0 2
12858: PUSH
12859: LD_INT 2
12861: ST_TO_ADDR
12862: GO 12884
12864: LD_INT 2
12866: DOUBLE
12867: EQUAL
12868: IFTRUE 12872
12870: GO 12883
12872: POP
// selected_option := 3 ; end ;
12873: LD_ADDR_VAR 0 2
12877: PUSH
12878: LD_INT 3
12880: ST_TO_ADDR
12881: GO 12884
12883: POP
// end ; 2 :
12884: GO 12925
12886: LD_INT 2
12888: DOUBLE
12889: EQUAL
12890: IFTRUE 12894
12892: GO 12905
12894: POP
// selected_option := 2 ; 3 :
12895: LD_ADDR_VAR 0 2
12899: PUSH
12900: LD_INT 2
12902: ST_TO_ADDR
12903: GO 12925
12905: LD_INT 3
12907: DOUBLE
12908: EQUAL
12909: IFTRUE 12913
12911: GO 12924
12913: POP
// selected_option := 3 ; end ;
12914: LD_ADDR_VAR 0 2
12918: PUSH
12919: LD_INT 3
12921: ST_TO_ADDR
12922: GO 12925
12924: POP
// if selected_option = 2 then
12925: LD_VAR 0 2
12929: PUSH
12930: LD_INT 2
12932: EQUAL
12933: IFFALSE 13037
// begin Say ( JMM , D13b-JMM-1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_STRING D13b-JMM-1
12942: PPUSH
12943: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12947: LD_EXP 49
12951: PPUSH
12952: LD_STRING D13b-Bur-1
12954: PPUSH
12955: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12959: LD_EXP 17
12963: PPUSH
12964: LD_STRING D13b-JMM-2
12966: PPUSH
12967: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12971: LD_EXP 58
12975: PPUSH
12976: LD_STRING D13b-Abd-2
12978: PPUSH
12979: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12983: LD_EXP 17
12987: PPUSH
12988: LD_STRING D13b-JMM-3
12990: PPUSH
12991: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12995: LD_EXP 58
12999: PPUSH
13000: LD_STRING D13b-Abd-3
13002: PPUSH
13003: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
13007: LD_EXP 17
13011: PPUSH
13012: LD_STRING D13b-JMM-4
13014: PPUSH
13015: CALL_OW 88
// ar_active_attack := true ;
13019: LD_ADDR_EXP 10
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
13027: LD_INT 1
13029: PPUSH
13030: LD_STRING 13a_negotiationWithArabs
13032: PPUSH
13033: CALL_OW 39
// end ; if selected_option = 3 then
13037: LD_VAR 0 2
13041: PUSH
13042: LD_INT 3
13044: EQUAL
13045: IFFALSE 13071
// begin Say ( JMM , D13c-JMM-1 ) ;
13047: LD_EXP 17
13051: PPUSH
13052: LD_STRING D13c-JMM-1
13054: PPUSH
13055: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
13059: LD_EXP 49
13063: PPUSH
13064: LD_STRING D13c-Bur-1
13066: PPUSH
13067: CALL_OW 88
// end ; DialogueOff ;
13071: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
13075: LD_STRING M4
13077: PPUSH
13078: CALL_OW 337
// if not ar_active_attack then
13082: LD_EXP 10
13086: NOT
13087: IFFALSE 13104
// begin wait ( 6 6$00 ) ;
13089: LD_INT 12600
13091: PPUSH
13092: CALL_OW 67
// ar_active_attack := true ;
13096: LD_ADDR_EXP 10
13100: PUSH
13101: LD_INT 1
13103: ST_TO_ADDR
// end ; end ;
13104: PPOPN 2
13106: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13107: LD_EXP 49
13111: PPUSH
13112: CALL_OW 305
13116: IFFALSE 13133
13118: PUSH
13119: LD_EXP 49
13123: PPUSH
13124: CALL_OW 255
13128: PUSH
13129: LD_INT 7
13131: EQUAL
13132: AND
13133: IFFALSE 13360
13135: GO 13137
13137: DISABLE
13138: LD_INT 0
13140: PPUSH
// begin wait ( 4 4$40 ) ;
13141: LD_INT 9800
13143: PPUSH
13144: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13148: LD_INT 35
13150: PPUSH
13151: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13155: LD_EXP 55
13159: NOT
13160: IFFALSE 13189
13162: PUSH
13163: LD_INT 22
13165: PUSH
13166: LD_INT 6
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 50
13175: PUSH
13176: EMPTY
13177: LIST
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PPUSH
13183: CALL_OW 69
13187: NOT
13188: AND
13189: IFFALSE 13148
// PrepareGnyevko ;
13191: CALL 2318 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13195: LD_EXP 51
13199: PPUSH
13200: LD_INT 124
13202: PPUSH
13203: LD_INT 118
13205: PPUSH
13206: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13210: LD_EXP 51
13214: PPUSH
13215: CALL_OW 200
// time := 0 0$00 ;
13219: LD_ADDR_VAR 0 1
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13227: LD_INT 35
13229: PPUSH
13230: CALL_OW 67
// time := time + 0 0$1 ;
13234: LD_ADDR_VAR 0 1
13238: PUSH
13239: LD_VAR 0 1
13243: PUSH
13244: LD_INT 35
13246: PLUS
13247: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13248: LD_EXP 51
13252: PPUSH
13253: LD_INT 124
13255: PPUSH
13256: LD_INT 118
13258: PPUSH
13259: CALL_OW 307
13263: IFTRUE 13275
13265: PUSH
13266: LD_VAR 0 1
13270: PUSH
13271: LD_INT 1050
13273: GREATEREQUAL
13274: OR
13275: IFFALSE 13227
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13277: LD_EXP 51
13281: PPUSH
13282: LD_STRING DBelkov-Gny-1
13284: PPUSH
13285: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13289: LD_EXP 49
13293: PPUSH
13294: LD_STRING DBelkov-Bur-1a
13296: PPUSH
13297: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13301: LD_INT 35
13303: PPUSH
13304: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13308: LD_EXP 51
13312: PPUSH
13313: LD_INT 22
13315: PUSH
13316: LD_INT 7
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PPUSH
13323: CALL_OW 69
13327: PPUSH
13328: LD_EXP 51
13332: PPUSH
13333: CALL_OW 74
13337: PPUSH
13338: CALL_OW 296
13342: PUSH
13343: LD_INT 8
13345: LESS
13346: IFFALSE 13301
// SetSide ( Gnyevko , 7 ) ;
13348: LD_EXP 51
13352: PPUSH
13353: LD_INT 7
13355: PPUSH
13356: CALL_OW 235
// end ;
13360: PPOPN 1
13362: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13363: LD_EXP 49
13367: PPUSH
13368: CALL_OW 255
13372: PUSH
13373: LD_INT 7
13375: EQUAL
13376: IFFALSE 13386
13378: GO 13380
13380: DISABLE
// begin enable ;
13381: ENABLE
// PrepareAmericanAttack ;
13382: CALL 8687 0 0
// end ;
13386: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13387: LD_INT 22
13389: PUSH
13390: LD_INT 1
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PPUSH
13397: CALL_OW 69
13401: IFFALSE 13585
13403: GO 13405
13405: DISABLE
13406: LD_INT 0
13408: PPUSH
13409: PPUSH
// begin while true do
13410: LD_INT 1
13412: IFFALSE 13469
// begin wait ( 0 0$1 ) ;
13414: LD_INT 35
13416: PPUSH
13417: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13421: LD_ADDR_VAR 0 2
13425: PUSH
13426: LD_INT 22
13428: PUSH
13429: LD_INT 1
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PPUSH
13436: CALL_OW 69
13440: PPUSH
13441: LD_EXP 17
13445: PPUSH
13446: CALL_OW 74
13450: ST_TO_ADDR
// if See ( 7 , tmp ) then
13451: LD_INT 7
13453: PPUSH
13454: LD_VAR 0 2
13458: PPUSH
13459: CALL_OW 292
13463: IFFALSE 13467
// break ;
13465: GO 13469
// end ;
13467: GO 13410
// DialogueOn ;
13469: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13473: LD_VAR 0 2
13477: PPUSH
13478: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13482: LD_VAR 0 2
13486: PPUSH
13487: CALL_OW 250
13491: PPUSH
13492: LD_VAR 0 2
13496: PPUSH
13497: CALL_OW 251
13501: PPUSH
13502: LD_INT 7
13504: PPUSH
13505: LD_INT 8
13507: PPUSH
13508: CALL_OW 330
// if Denis then
13512: LD_EXP 23
13516: IFFALSE 13530
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13518: LD_EXP 23
13522: PPUSH
13523: LD_STRING DAmerAttack-Pet-1
13525: PPUSH
13526: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13530: LD_EXP 17
13534: PPUSH
13535: LD_STRING DAmerAttack-JMM-1
13537: PPUSH
13538: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13542: LD_EXP 49
13546: PPUSH
13547: LD_STRING DStop-Bur-1
13549: PPUSH
13550: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13554: LD_VAR 0 2
13558: PPUSH
13559: CALL_OW 250
13563: PPUSH
13564: LD_VAR 0 2
13568: PPUSH
13569: CALL_OW 251
13573: PPUSH
13574: LD_INT 7
13576: PPUSH
13577: CALL_OW 331
// DialogueOff ;
13581: CALL_OW 7
// end ;
13585: PPOPN 2
13587: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13588: LD_INT 22
13590: PUSH
13591: LD_INT 3
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 21
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PPUSH
13612: CALL_OW 69
13616: PUSH
13617: LD_INT 0
13619: EQUAL
13620: IFFALSE 13670
13622: GO 13624
13624: DISABLE
// begin ru_active_attack := false ;
13625: LD_ADDR_EXP 6
13629: PUSH
13630: LD_INT 0
13632: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13633: LD_STRING M5a
13635: PPUSH
13636: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13640: LD_EXP 17
13644: PPUSH
13645: LD_STRING D8-JMM-1
13647: PPUSH
13648: CALL_OW 88
// if Gossudarov then
13652: LD_EXP 35
13656: IFFALSE 13670
// Say ( Gossudarov , D8-Gos-1 ) ;
13658: LD_EXP 35
13662: PPUSH
13663: LD_STRING D8-Gos-1
13665: PPUSH
13666: CALL_OW 88
// end ;
13670: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13671: LD_INT 22
13673: PUSH
13674: LD_INT 2
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 1
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 69
13699: PUSH
13700: LD_INT 0
13702: EQUAL
13703: IFFALSE 13761
13705: GO 13707
13707: DISABLE
// begin ar_active_attack := false ;
13708: LD_ADDR_EXP 10
13712: PUSH
13713: LD_INT 0
13715: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13716: LD_STRING M4c
13718: PPUSH
13719: CALL_OW 337
// if Roth then
13723: LD_EXP 18
13727: IFFALSE 13743
// Say ( Roth , DStop-Roth-1 ) else
13729: LD_EXP 18
13733: PPUSH
13734: LD_STRING DStop-Roth-1
13736: PPUSH
13737: CALL_OW 88
13741: GO 13761
// if Gossudarov then
13743: LD_EXP 35
13747: IFFALSE 13761
// Say ( Gossudarov , D8-Gos-1a ) ;
13749: LD_EXP 35
13753: PPUSH
13754: LD_STRING D8-Gos-1a
13756: PPUSH
13757: CALL_OW 88
// end ;
13761: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13762: LD_INT 3
13764: PPUSH
13765: CALL_OW 469
13769: IFFALSE 13777
13771: PUSH
13772: LD_EXP 13
13776: AND
13777: IFFALSE 13832
13779: GO 13781
13781: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13782: LD_INT 3
13784: PPUSH
13785: CALL_OW 469
13789: PPUSH
13790: CALL 9176 0 1
// if Difficulty > 2 then
13794: LD_OWVAR 67
13798: PUSH
13799: LD_INT 2
13801: GREATER
13802: IFFALSE 13832
// begin wait ( 5 5$00 ) ;
13804: LD_INT 10500
13806: PPUSH
13807: CALL_OW 67
// if FindArtifact ( 3 ) then
13811: LD_INT 3
13813: PPUSH
13814: CALL_OW 469
13818: IFFALSE 13832
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13820: LD_INT 3
13822: PPUSH
13823: CALL_OW 469
13827: PPUSH
13828: CALL 9176 0 1
// end ; end ;
13832: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13833: LD_INT 7
13835: PPUSH
13836: LD_INT 1
13838: PPUSH
13839: LD_INT 1
13841: PPUSH
13842: CALL 17545 0 3
13846: PUSH
13847: LD_INT 0
13849: EQUAL
13850: IFFALSE 13871
13852: PUSH
13853: LD_INT 7
13855: PPUSH
13856: LD_INT 3
13858: PPUSH
13859: LD_INT 1
13861: PPUSH
13862: CALL 17545 0 3
13866: PUSH
13867: LD_INT 0
13869: EQUAL
13870: AND
13871: IFFALSE 13883
13873: GO 13875
13875: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13876: LD_STRING M1a
13878: PPUSH
13879: CALL_OW 337
// end ;
13883: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13884: LD_INT 22
13886: PUSH
13887: LD_INT 2
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: LD_INT 23
13896: PUSH
13897: LD_INT 2
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: PUSH
13904: LD_INT 21
13906: PUSH
13907: LD_INT 1
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: PPUSH
13919: CALL_OW 69
13923: PUSH
13924: LD_INT 0
13926: EQUAL
13927: IFFALSE 13974
13929: PUSH
13930: LD_INT 22
13932: PUSH
13933: LD_INT 3
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: LD_INT 23
13942: PUSH
13943: LD_INT 3
13945: PUSH
13946: EMPTY
13947: LIST
13948: LIST
13949: PUSH
13950: LD_INT 21
13952: PUSH
13953: LD_INT 1
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: LIST
13964: PPUSH
13965: CALL_OW 69
13969: PUSH
13970: LD_INT 0
13972: EQUAL
13973: AND
13974: IFFALSE 13996
13976: PUSH
13977: LD_INT 22
13979: PUSH
13980: LD_INT 1
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PPUSH
13987: CALL_OW 69
13991: PUSH
13992: LD_INT 0
13994: EQUAL
13995: AND
13996: IFFALSE 14017
13998: PUSH
13999: LD_INT 7
14001: PPUSH
14002: LD_INT 1
14004: PPUSH
14005: LD_INT 1
14007: PPUSH
14008: CALL 17545 0 3
14012: PUSH
14013: LD_INT 0
14015: EQUAL
14016: AND
14017: IFFALSE 14038
14019: PUSH
14020: LD_INT 7
14022: PPUSH
14023: LD_INT 3
14025: PPUSH
14026: LD_INT 1
14028: PPUSH
14029: CALL 17545 0 3
14033: PUSH
14034: LD_INT 0
14036: EQUAL
14037: AND
14038: IFFALSE 14055
14040: PUSH
14041: LD_EXP 49
14045: PPUSH
14046: CALL_OW 255
14050: PUSH
14051: LD_INT 7
14053: EQUAL
14054: AND
14055: IFFALSE 14068
14057: PUSH
14058: LD_EXP 49
14062: PPUSH
14063: CALL_OW 302
14067: AND
14068: IFFALSE 15747
14070: GO 14072
14072: DISABLE
14073: LD_INT 0
14075: PPUSH
14076: PPUSH
14077: PPUSH
14078: PPUSH
14079: PPUSH
14080: PPUSH
// begin m1 := false ;
14081: LD_ADDR_VAR 0 4
14085: PUSH
14086: LD_INT 0
14088: ST_TO_ADDR
// m2 := false ;
14089: LD_ADDR_VAR 0 5
14093: PUSH
14094: LD_INT 0
14096: ST_TO_ADDR
// m3 := false ;
14097: LD_ADDR_VAR 0 6
14101: PUSH
14102: LD_INT 0
14104: ST_TO_ADDR
// if tick < 40 40$00 then
14105: LD_OWVAR 1
14109: PUSH
14110: LD_INT 84000
14112: LESS
14113: IFFALSE 14122
// SetAchievement ( ACH_ASPEED_17 ) ;
14115: LD_STRING ACH_ASPEED_17
14117: PPUSH
14118: CALL_OW 543
// wait ( 0 0$5 ) ;
14122: LD_INT 175
14124: PPUSH
14125: CALL_OW 67
// if not masha_killed then
14129: LD_EXP 11
14133: NOT
14134: IFFALSE 14156
// begin m1 := true ;
14136: LD_ADDR_VAR 0 4
14140: PUSH
14141: LD_INT 1
14143: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14144: LD_STRING Masha
14146: PPUSH
14147: LD_INT 1
14149: PPUSH
14150: CALL_OW 101
// end else
14154: GO 14167
// AddMedal ( Masha , - 1 ) ;
14156: LD_STRING Masha
14158: PPUSH
14159: LD_INT 1
14161: NEG
14162: PPUSH
14163: CALL_OW 101
// if abdul_escaped then
14167: LD_EXP 14
14171: IFFALSE 14186
// AddMedal ( Abdul , - 1 ) else
14173: LD_STRING Abdul
14175: PPUSH
14176: LD_INT 1
14178: NEG
14179: PPUSH
14180: CALL_OW 101
14184: GO 14204
// begin m2 := true ;
14186: LD_ADDR_VAR 0 5
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14194: LD_STRING Abdul
14196: PPUSH
14197: LD_INT 1
14199: PPUSH
14200: CALL_OW 101
// end ; if loss_counter = 0 then
14204: LD_EXP 15
14208: PUSH
14209: LD_INT 0
14211: EQUAL
14212: IFFALSE 14234
// begin m3 := true ;
14214: LD_ADDR_VAR 0 6
14218: PUSH
14219: LD_INT 1
14221: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14222: LD_STRING People
14224: PPUSH
14225: LD_INT 2
14227: PPUSH
14228: CALL_OW 101
// end else
14232: GO 14296
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14234: LD_EXP 15
14238: PUSH
14239: LD_INT 3
14241: PUSH
14242: LD_INT 2
14244: PUSH
14245: LD_INT 2
14247: PUSH
14248: LD_INT 1
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PUSH
14257: LD_OWVAR 67
14261: ARRAY
14262: LESSEQUAL
14263: IFFALSE 14285
// begin AddMedal ( People , 1 ) ;
14265: LD_STRING People
14267: PPUSH
14268: LD_INT 1
14270: PPUSH
14271: CALL_OW 101
// m3 := true ;
14275: LD_ADDR_VAR 0 6
14279: PUSH
14280: LD_INT 1
14282: ST_TO_ADDR
// end else
14283: GO 14296
// AddMedal ( People , - 1 ) ;
14285: LD_STRING People
14287: PPUSH
14288: LD_INT 1
14290: NEG
14291: PPUSH
14292: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14296: LD_OWVAR 67
14300: PUSH
14301: LD_INT 3
14303: GREATEREQUAL
14304: IFFALSE 14312
14306: PUSH
14307: LD_VAR 0 4
14311: AND
14312: IFFALSE 14320
14314: PUSH
14315: LD_VAR 0 5
14319: AND
14320: IFFALSE 14328
14322: PUSH
14323: LD_VAR 0 6
14327: AND
14328: IFFALSE 14340
// SetAchievementEX ( ACH_AMER , 17 ) ;
14330: LD_STRING ACH_AMER
14332: PPUSH
14333: LD_INT 17
14335: PPUSH
14336: CALL_OW 564
// GiveMedals ( MAIN ) ;
14340: LD_STRING MAIN
14342: PPUSH
14343: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: LD_INT 22
14354: PUSH
14355: LD_INT 7
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 50
14364: PUSH
14365: EMPTY
14366: LIST
14367: PUSH
14368: LD_INT 2
14370: PUSH
14371: LD_INT 25
14373: PUSH
14374: LD_INT 1
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: LD_INT 25
14383: PUSH
14384: LD_INT 2
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: PUSH
14391: LD_INT 25
14393: PUSH
14394: LD_INT 3
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: LD_INT 25
14403: PUSH
14404: LD_INT 4
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: PUSH
14411: LD_INT 25
14413: PUSH
14414: LD_INT 5
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 25
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 9
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: PPUSH
14456: CALL_OW 69
14460: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14461: LD_VAR 0 2
14465: PPUSH
14466: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14470: LD_ADDR_VAR 0 3
14474: PUSH
14475: LD_EXP 17
14479: PUSH
14480: LD_EXP 18
14484: PUSH
14485: LD_EXP 19
14489: PUSH
14490: LD_EXP 20
14494: PUSH
14495: LD_EXP 21
14499: PUSH
14500: LD_EXP 22
14504: PUSH
14505: LD_EXP 23
14509: PUSH
14510: LD_EXP 24
14514: PUSH
14515: LD_EXP 25
14519: PUSH
14520: LD_EXP 26
14524: PUSH
14525: LD_EXP 27
14529: PUSH
14530: LD_EXP 28
14534: PUSH
14535: LD_EXP 29
14539: PUSH
14540: LD_EXP 30
14544: PUSH
14545: LD_EXP 31
14549: PUSH
14550: LD_EXP 32
14554: PUSH
14555: LD_EXP 33
14559: PUSH
14560: LD_EXP 35
14564: PUSH
14565: LD_EXP 36
14569: PUSH
14570: LD_EXP 37
14574: PUSH
14575: LD_EXP 39
14579: PUSH
14580: LD_EXP 40
14584: PUSH
14585: LD_EXP 41
14589: PUSH
14590: LD_EXP 42
14594: PUSH
14595: LD_EXP 43
14599: PUSH
14600: LD_EXP 44
14604: PUSH
14605: LD_EXP 45
14609: PUSH
14610: LD_EXP 46
14614: PUSH
14615: LD_EXP 47
14619: PUSH
14620: LD_EXP 48
14624: PUSH
14625: LD_EXP 49
14629: PUSH
14630: LD_EXP 50
14634: PUSH
14635: LD_EXP 51
14639: PUSH
14640: LD_EXP 34
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: ST_TO_ADDR
// if tmp diff tmp2 then
14681: LD_VAR 0 2
14685: PUSH
14686: LD_VAR 0 3
14690: DIFF
14691: IFFALSE 14711
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14693: LD_VAR 0 2
14697: PUSH
14698: LD_VAR 0 3
14702: DIFF
14703: PPUSH
14704: LD_STRING 13a_others
14706: PPUSH
14707: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14711: LD_EXP 17
14715: PPUSH
14716: LD_STRING 13a_JMM
14718: PPUSH
14719: CALL_OW 38
// if IsOk ( Mike ) then
14723: LD_EXP 34
14727: PPUSH
14728: CALL_OW 302
14732: IFFALSE 14746
// SaveCharacters ( Mike , 13a_Mike ) ;
14734: LD_EXP 34
14738: PPUSH
14739: LD_STRING 13a_Mike
14741: PPUSH
14742: CALL_OW 38
// if IsOk ( Titov ) then
14746: LD_EXP 37
14750: PPUSH
14751: CALL_OW 302
14755: IFFALSE 14769
// SaveCharacters ( Titov , 13a_Titov ) ;
14757: LD_EXP 37
14761: PPUSH
14762: LD_STRING 13a_Titov
14764: PPUSH
14765: CALL_OW 38
// if IsOk ( Dolgov ) then
14769: LD_EXP 39
14773: PPUSH
14774: CALL_OW 302
14778: IFFALSE 14792
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14780: LD_EXP 39
14784: PPUSH
14785: LD_STRING 13a_Dolgov
14787: PPUSH
14788: CALL_OW 38
// if IsOk ( Petrosyan ) then
14792: LD_EXP 40
14796: PPUSH
14797: CALL_OW 302
14801: IFFALSE 14815
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14803: LD_EXP 40
14807: PPUSH
14808: LD_STRING 13a_Petrosyan
14810: PPUSH
14811: CALL_OW 38
// if IsOk ( Scholtze ) then
14815: LD_EXP 41
14819: PPUSH
14820: CALL_OW 302
14824: IFFALSE 14838
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14826: LD_EXP 41
14830: PPUSH
14831: LD_STRING 13a_Scholtze
14833: PPUSH
14834: CALL_OW 38
// if IsOk ( Oblukov ) then
14838: LD_EXP 42
14842: PPUSH
14843: CALL_OW 302
14847: IFFALSE 14861
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14849: LD_EXP 42
14853: PPUSH
14854: LD_STRING 13a_Oblukov
14856: PPUSH
14857: CALL_OW 38
// if IsOk ( Kapitsova ) then
14861: LD_EXP 43
14865: PPUSH
14866: CALL_OW 302
14870: IFFALSE 14884
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14872: LD_EXP 43
14876: PPUSH
14877: LD_STRING 13a_Kapitsova
14879: PPUSH
14880: CALL_OW 38
// if IsOk ( Lipshchin ) then
14884: LD_EXP 44
14888: PPUSH
14889: CALL_OW 302
14893: IFFALSE 14907
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14895: LD_EXP 44
14899: PPUSH
14900: LD_STRING 13a_Lipshchin
14902: PPUSH
14903: CALL_OW 38
// if IsOk ( Petrovova ) then
14907: LD_EXP 45
14911: PPUSH
14912: CALL_OW 302
14916: IFFALSE 14930
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14918: LD_EXP 45
14922: PPUSH
14923: LD_STRING 13a_Petrovova
14925: PPUSH
14926: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14930: LD_EXP 46
14934: PPUSH
14935: CALL_OW 302
14939: IFFALSE 14953
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14941: LD_EXP 46
14945: PPUSH
14946: LD_STRING 13a_Kovalyuk
14948: PPUSH
14949: CALL_OW 38
// if IsOk ( Kuzmov ) then
14953: LD_EXP 47
14957: PPUSH
14958: CALL_OW 302
14962: IFFALSE 14976
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14964: LD_EXP 47
14968: PPUSH
14969: LD_STRING 13a_Kuzmov
14971: PPUSH
14972: CALL_OW 38
// if IsOk ( Karamazov ) then
14976: LD_EXP 48
14980: PPUSH
14981: CALL_OW 302
14985: IFFALSE 14999
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14987: LD_EXP 48
14991: PPUSH
14992: LD_STRING 13a_Karamazov
14994: PPUSH
14995: CALL_OW 38
// if Burlak then
14999: LD_EXP 49
15003: IFFALSE 15024
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
15005: LD_STRING enableBioCharacter(BIO_GORKI)
15007: PPUSH
15008: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
15012: LD_EXP 49
15016: PPUSH
15017: LD_STRING 13a_Burlak
15019: PPUSH
15020: CALL_OW 38
// end ; if IsOk ( Belkov ) then
15024: LD_EXP 50
15028: PPUSH
15029: CALL_OW 302
15033: IFFALSE 15047
// SaveCharacters ( Belkov , 13a_Belkov ) ;
15035: LD_EXP 50
15039: PPUSH
15040: LD_STRING 13a_Belkov
15042: PPUSH
15043: CALL_OW 38
// if IsOk ( Gnyevko ) then
15047: LD_EXP 51
15051: PPUSH
15052: CALL_OW 302
15056: IFFALSE 15070
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
15058: LD_EXP 51
15062: PPUSH
15063: LD_STRING 13a_Gnyevko
15065: PPUSH
15066: CALL_OW 38
// if IsOk ( Lisa ) then
15070: LD_EXP 19
15074: PPUSH
15075: CALL_OW 302
15079: IFFALSE 15093
// SaveCharacters ( Lisa , 13a_Lisa ) ;
15081: LD_EXP 19
15085: PPUSH
15086: LD_STRING 13a_Lisa
15088: PPUSH
15089: CALL_OW 38
// if IsOk ( Donaldson ) then
15093: LD_EXP 20
15097: PPUSH
15098: CALL_OW 302
15102: IFFALSE 15116
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
15104: LD_EXP 20
15108: PPUSH
15109: LD_STRING 13a_Donaldson
15111: PPUSH
15112: CALL_OW 38
// if IsOk ( Bobby ) then
15116: LD_EXP 21
15120: PPUSH
15121: CALL_OW 302
15125: IFFALSE 15139
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15127: LD_EXP 21
15131: PPUSH
15132: LD_STRING 13a_Bobby
15134: PPUSH
15135: CALL_OW 38
// if IsOk ( Cyrus ) then
15139: LD_EXP 22
15143: PPUSH
15144: CALL_OW 302
15148: IFFALSE 15162
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15150: LD_EXP 22
15154: PPUSH
15155: LD_STRING 13a_Cyrus
15157: PPUSH
15158: CALL_OW 38
// if IsOk ( Denis ) then
15162: LD_EXP 23
15166: PPUSH
15167: CALL_OW 302
15171: IFFALSE 15185
// SaveCharacters ( Denis , 13a_Denis ) ;
15173: LD_EXP 23
15177: PPUSH
15178: LD_STRING 13a_Denis
15180: PPUSH
15181: CALL_OW 38
// if IsOk ( Brown ) then
15185: LD_EXP 24
15189: PPUSH
15190: CALL_OW 302
15194: IFFALSE 15208
// SaveCharacters ( Brown , 13a_Brown ) ;
15196: LD_EXP 24
15200: PPUSH
15201: LD_STRING 13a_Brown
15203: PPUSH
15204: CALL_OW 38
// if IsOk ( Gladstone ) then
15208: LD_EXP 25
15212: PPUSH
15213: CALL_OW 302
15217: IFFALSE 15231
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15219: LD_EXP 25
15223: PPUSH
15224: LD_STRING 13a_Gladstone
15226: PPUSH
15227: CALL_OW 38
// if IsOk ( Houten ) then
15231: LD_EXP 26
15235: PPUSH
15236: CALL_OW 302
15240: IFFALSE 15254
// SaveCharacters ( Houten , 13a_Houten ) ;
15242: LD_EXP 26
15246: PPUSH
15247: LD_STRING 13a_Houten
15249: PPUSH
15250: CALL_OW 38
// if IsOk ( Cornel ) then
15254: LD_EXP 27
15258: PPUSH
15259: CALL_OW 302
15263: IFFALSE 15277
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15265: LD_EXP 27
15269: PPUSH
15270: LD_STRING 13a_Cornel
15272: PPUSH
15273: CALL_OW 38
// if IsOk ( Gary ) then
15277: LD_EXP 28
15281: PPUSH
15282: CALL_OW 302
15286: IFFALSE 15300
// SaveCharacters ( Gary , 13a_Gary ) ;
15288: LD_EXP 28
15292: PPUSH
15293: LD_STRING 13a_Gary
15295: PPUSH
15296: CALL_OW 38
// if IsOk ( Frank ) then
15300: LD_EXP 29
15304: PPUSH
15305: CALL_OW 302
15309: IFFALSE 15323
// SaveCharacters ( Frank , 13a_Frank ) ;
15311: LD_EXP 29
15315: PPUSH
15316: LD_STRING 13a_Frank
15318: PPUSH
15319: CALL_OW 38
// if IsOk ( Kikuchi ) then
15323: LD_EXP 30
15327: PPUSH
15328: CALL_OW 302
15332: IFFALSE 15346
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15334: LD_EXP 30
15338: PPUSH
15339: LD_STRING 13a_Kikuchi
15341: PPUSH
15342: CALL_OW 38
// if IsOk ( Simms ) then
15346: LD_EXP 31
15350: PPUSH
15351: CALL_OW 302
15355: IFFALSE 15369
// SaveCharacters ( Simms , 13a_Simms ) ;
15357: LD_EXP 31
15361: PPUSH
15362: LD_STRING 13a_Simms
15364: PPUSH
15365: CALL_OW 38
// if IsOk ( Joan ) then
15369: LD_EXP 32
15373: PPUSH
15374: CALL_OW 302
15378: IFFALSE 15392
// SaveCharacters ( Joan , 13a_Joan ) ;
15380: LD_EXP 32
15384: PPUSH
15385: LD_STRING 13a_Joan
15387: PPUSH
15388: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15392: LD_EXP 33
15396: PPUSH
15397: CALL_OW 302
15401: IFFALSE 15415
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15403: LD_EXP 33
15407: PPUSH
15408: LD_STRING 13a_DeltaDoctor
15410: PPUSH
15411: CALL_OW 38
// if IsOk ( Gossudarov ) then
15415: LD_EXP 35
15419: PPUSH
15420: CALL_OW 302
15424: IFFALSE 15438
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15426: LD_EXP 35
15430: PPUSH
15431: LD_STRING 13a_Gossudarov
15433: PPUSH
15434: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15438: LD_EXP 36
15442: PPUSH
15443: CALL_OW 302
15447: IFFALSE 15461
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15449: LD_EXP 36
15453: PPUSH
15454: LD_STRING 13a_Kirilenkova
15456: PPUSH
15457: CALL_OW 38
// if IsOk ( Roth ) then
15461: LD_EXP 18
15465: PPUSH
15466: CALL_OW 302
15470: IFFALSE 15484
// SaveCharacters ( Roth , 13a_Roth ) ;
15472: LD_EXP 18
15476: PPUSH
15477: LD_STRING 13a_Roth
15479: PPUSH
15480: CALL_OW 38
// if Masha then
15484: LD_EXP 52
15488: IFFALSE 15543
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15490: LD_EXP 52
15494: PPUSH
15495: CALL_OW 265
15499: PUSH
15500: LD_EXP 52
15504: PPUSH
15505: CALL_OW 262
15509: PUSH
15510: LD_EXP 52
15514: PPUSH
15515: CALL_OW 263
15519: PUSH
15520: LD_EXP 52
15524: PPUSH
15525: CALL_OW 264
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: LD_STRING 13a_Masha
15538: PPUSH
15539: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15543: LD_ADDR_VAR 0 2
15547: PUSH
15548: LD_INT 21
15550: PUSH
15551: LD_INT 3
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PPUSH
15558: CALL_OW 69
15562: ST_TO_ADDR
// tmp2 := [ ] ;
15563: LD_ADDR_VAR 0 3
15567: PUSH
15568: EMPTY
15569: ST_TO_ADDR
// if tmp then
15570: LD_VAR 0 2
15574: IFFALSE 15725
// for i in tmp do
15576: LD_ADDR_VAR 0 1
15580: PUSH
15581: LD_VAR 0 2
15585: PUSH
15586: FOR_IN
15587: IFFALSE 15723
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15589: LD_ADDR_VAR 0 3
15593: PUSH
15594: LD_VAR 0 3
15598: PUSH
15599: LD_VAR 0 1
15603: PPUSH
15604: CALL_OW 255
15608: PUSH
15609: LD_VAR 0 1
15613: PPUSH
15614: CALL_OW 248
15618: PUSH
15619: LD_VAR 0 1
15623: PPUSH
15624: CALL_OW 266
15628: PUSH
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 250
15638: PUSH
15639: LD_VAR 0 1
15643: PPUSH
15644: CALL_OW 251
15648: PUSH
15649: LD_VAR 0 1
15653: PPUSH
15654: CALL_OW 254
15658: PUSH
15659: LD_VAR 0 1
15663: PPUSH
15664: CALL_OW 267
15668: PUSH
15669: LD_VAR 0 1
15673: PPUSH
15674: LD_INT 1
15676: PPUSH
15677: CALL_OW 268
15681: PUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL_OW 268
15694: PUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 269
15704: PUSH
15705: EMPTY
15706: LIST
15707: LIST
15708: LIST
15709: LIST
15710: LIST
15711: LIST
15712: LIST
15713: LIST
15714: LIST
15715: LIST
15716: PUSH
15717: EMPTY
15718: LIST
15719: ADD
15720: ST_TO_ADDR
15721: GO 15586
15723: POP
15724: POP
// if tmp2 then
15725: LD_VAR 0 3
15729: IFFALSE 15743
// SaveVariable ( tmp2 , 13a_buildings ) ;
15731: LD_VAR 0 3
15735: PPUSH
15736: LD_STRING 13a_buildings
15738: PPUSH
15739: CALL_OW 39
// YouWin ;
15743: CALL_OW 103
// end ;
15747: PPOPN 6
15749: END
// export function SciRu ; var tmp , t ; begin
15750: LD_INT 0
15752: PPUSH
15753: PPUSH
15754: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15755: LD_ADDR_VAR 0 3
15759: PUSH
15760: LD_EXP 35
15764: PUSH
15765: LD_EXP 49
15769: PUSH
15770: LD_EXP 37
15774: PUSH
15775: LD_EXP 50
15779: PUSH
15780: LD_EXP 51
15784: PUSH
15785: LD_EXP 40
15789: PUSH
15790: LD_EXP 41
15794: PUSH
15795: LD_EXP 39
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: LIST
15809: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15810: LD_ADDR_VAR 0 2
15814: PUSH
15815: LD_INT 22
15817: PUSH
15818: LD_INT 7
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PUSH
15825: LD_INT 23
15827: PUSH
15828: LD_INT 3
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 25
15837: PUSH
15838: LD_INT 4
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: PUSH
15845: LD_INT 26
15847: PUSH
15848: LD_INT 1
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: LIST
15859: LIST
15860: PPUSH
15861: CALL_OW 69
15865: PUSH
15866: LD_VAR 0 3
15870: DIFF
15871: ST_TO_ADDR
// if tmp then
15872: LD_VAR 0 2
15876: IFFALSE 15892
// result := tmp [ 1 ] ;
15878: LD_ADDR_VAR 0 1
15882: PUSH
15883: LD_VAR 0 2
15887: PUSH
15888: LD_INT 1
15890: ARRAY
15891: ST_TO_ADDR
// end ;
15892: LD_VAR 0 1
15896: RET
// export function SolRu ; var tmp , t ; begin
15897: LD_INT 0
15899: PPUSH
15900: PPUSH
15901: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15902: LD_ADDR_VAR 0 3
15906: PUSH
15907: LD_EXP 35
15911: PUSH
15912: LD_EXP 49
15916: PUSH
15917: LD_EXP 37
15921: PUSH
15922: LD_EXP 50
15926: PUSH
15927: LD_EXP 51
15931: PUSH
15932: LD_EXP 40
15936: PUSH
15937: LD_EXP 41
15941: PUSH
15942: LD_EXP 39
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: LIST
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: LIST
15956: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15957: LD_ADDR_VAR 0 2
15961: PUSH
15962: LD_INT 22
15964: PUSH
15965: LD_INT 7
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: PUSH
15972: LD_INT 23
15974: PUSH
15975: LD_INT 3
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PUSH
15982: LD_INT 25
15984: PUSH
15985: LD_INT 1
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: LD_INT 26
15994: PUSH
15995: LD_INT 1
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: PPUSH
16008: CALL_OW 69
16012: PUSH
16013: LD_VAR 0 3
16017: DIFF
16018: ST_TO_ADDR
// if tmp then
16019: LD_VAR 0 2
16023: IFFALSE 16039
// result := tmp [ 1 ] ;
16025: LD_ADDR_VAR 0 1
16029: PUSH
16030: LD_VAR 0 2
16034: PUSH
16035: LD_INT 1
16037: ARRAY
16038: ST_TO_ADDR
// end ; end_of_file
16039: LD_VAR 0 1
16043: RET
// export function CustomEvent ( event ) ; begin
16044: LD_INT 0
16046: PPUSH
// end ;
16047: LD_VAR 0 2
16051: RET
// on UnitDestroyed ( un ) do var i , side ;
16052: LD_INT 0
16054: PPUSH
16055: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
16056: LD_VAR 0 1
16060: PPUSH
16061: CALL 108025 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
16065: LD_VAR 0 1
16069: PUSH
16070: LD_INT 22
16072: PUSH
16073: LD_INT 7
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: PUSH
16080: LD_INT 2
16082: PUSH
16083: LD_INT 25
16085: PUSH
16086: LD_INT 1
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PUSH
16093: LD_INT 25
16095: PUSH
16096: LD_INT 2
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 25
16105: PUSH
16106: LD_INT 3
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: LD_INT 25
16115: PUSH
16116: LD_INT 4
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: PUSH
16123: LD_INT 25
16125: PUSH
16126: LD_INT 5
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PUSH
16133: LD_INT 25
16135: PUSH
16136: LD_INT 8
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: PUSH
16143: LD_INT 25
16145: PUSH
16146: LD_INT 9
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PPUSH
16167: CALL_OW 69
16171: IN
16172: IFFALSE 16188
// loss_counter := loss_counter + 1 ;
16174: LD_ADDR_EXP 15
16178: PUSH
16179: LD_EXP 15
16183: PUSH
16184: LD_INT 1
16186: PLUS
16187: ST_TO_ADDR
// if un = Abdul then
16188: LD_VAR 0 1
16192: PUSH
16193: LD_EXP 58
16197: EQUAL
16198: IFFALSE 16208
// abdul_escaped := false ;
16200: LD_ADDR_EXP 14
16204: PUSH
16205: LD_INT 0
16207: ST_TO_ADDR
// if un in ru_attackers then
16208: LD_VAR 0 1
16212: PUSH
16213: LD_EXP 55
16217: IN
16218: IFFALSE 16236
// ru_attackers := ru_attackers diff un ;
16220: LD_ADDR_EXP 55
16224: PUSH
16225: LD_EXP 55
16229: PUSH
16230: LD_VAR 0 1
16234: DIFF
16235: ST_TO_ADDR
// if un in ar_attackers then
16236: LD_VAR 0 1
16240: PUSH
16241: LD_EXP 12
16245: IN
16246: IFFALSE 16264
// ar_attackers := ar_attackers diff un ;
16248: LD_ADDR_EXP 12
16252: PUSH
16253: LD_EXP 12
16257: PUSH
16258: LD_VAR 0 1
16262: DIFF
16263: ST_TO_ADDR
// if un = JMM then
16264: LD_VAR 0 1
16268: PUSH
16269: LD_EXP 17
16273: EQUAL
16274: IFFALSE 16285
// begin YouLost ( JMM ) ;
16276: LD_STRING JMM
16278: PPUSH
16279: CALL_OW 104
// exit ;
16283: GO 16382
// end ; if un = Burlak then
16285: LD_VAR 0 1
16289: PUSH
16290: LD_EXP 49
16294: EQUAL
16295: IFFALSE 16306
// begin YouLost ( Burlak ) ;
16297: LD_STRING Burlak
16299: PPUSH
16300: CALL_OW 104
// exit ;
16304: GO 16382
// end ; if un = freedom then
16306: LD_VAR 0 1
16310: PUSH
16311: LD_EXP 3
16315: EQUAL
16316: IFFALSE 16327
// begin YouLost ( Destroyed ) ;
16318: LD_STRING Destroyed
16320: PPUSH
16321: CALL_OW 104
// exit ;
16325: GO 16382
// end ; if un = Masha then
16327: LD_VAR 0 1
16331: PUSH
16332: LD_EXP 52
16336: EQUAL
16337: IFFALSE 16354
// begin ChangeMissionObjectives ( M4b ) ;
16339: LD_STRING M4b
16341: PPUSH
16342: CALL_OW 337
// masha_killed := true ;
16346: LD_ADDR_EXP 11
16350: PUSH
16351: LD_INT 1
16353: ST_TO_ADDR
// end ; if un = Mastodont then
16354: LD_VAR 0 1
16358: PUSH
16359: LD_EXP 59
16363: EQUAL
16364: IFFALSE 16373
// ChangeMissionObjectives ( M4a ) ;
16366: LD_STRING M4a
16368: PPUSH
16369: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16373: LD_VAR 0 1
16377: PPUSH
16378: CALL 88928 0 1
// end ;
16382: PPOPN 3
16384: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16385: LD_VAR 0 1
16389: PPUSH
16390: LD_VAR 0 2
16394: PPUSH
16395: CALL 91282 0 2
// end ;
16399: PPOPN 2
16401: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: CALL 90346 0 1
// end ;
16411: PPOPN 1
16413: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16414: LD_VAR 0 1
16418: PUSH
16419: LD_INT 22
16421: PUSH
16422: LD_INT 7
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: PUSH
16429: LD_INT 30
16431: PUSH
16432: LD_INT 0
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL_OW 69
16447: IN
16448: IFFALSE 16487
// begin SetBName ( building , freedom ) ;
16450: LD_VAR 0 1
16454: PPUSH
16455: LD_STRING freedom
16457: PPUSH
16458: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16462: LD_INT 0
16464: PPUSH
16465: LD_INT 7
16467: PPUSH
16468: LD_INT 0
16470: PPUSH
16471: CALL_OW 324
// freedom := building ;
16475: LD_ADDR_EXP 3
16479: PUSH
16480: LD_VAR 0 1
16484: ST_TO_ADDR
// exit ;
16485: GO 16553
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16487: LD_VAR 0 1
16491: PUSH
16492: LD_INT 22
16494: PUSH
16495: LD_INT 7
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: LD_INT 23
16504: PUSH
16505: LD_INT 3
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 30
16514: PUSH
16515: LD_INT 6
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: LIST
16526: PPUSH
16527: CALL_OW 69
16531: IN
16532: IFFALSE 16544
// begin ru_lab_builded := true ;
16534: LD_ADDR_EXP 5
16538: PUSH
16539: LD_INT 1
16541: ST_TO_ADDR
// exit ;
16542: GO 16553
// end ; MCE_BuildingComplete ( building ) ;
16544: LD_VAR 0 1
16548: PPUSH
16549: CALL 90589 0 1
// end ;
16553: PPOPN 1
16555: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16556: LD_VAR 0 1
16560: PPUSH
16561: LD_VAR 0 2
16565: PPUSH
16566: CALL 88616 0 2
// end ;
16570: PPOPN 2
16572: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_VAR 0 2
16582: PPUSH
16583: LD_VAR 0 3
16587: PPUSH
16588: LD_VAR 0 4
16592: PPUSH
16593: LD_VAR 0 5
16597: PPUSH
16598: CALL 88234 0 5
// end ;
16602: PPOPN 5
16604: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16605: LD_VAR 0 1
16609: PPUSH
16610: LD_VAR 0 2
16614: PPUSH
16615: CALL 108083 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16619: LD_VAR 0 1
16623: PPUSH
16624: LD_VAR 0 2
16628: PPUSH
16629: CALL 87783 0 2
// end ;
16633: PPOPN 2
16635: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16636: LD_VAR 0 1
16640: PPUSH
16641: CALL_OW 263
16645: PUSH
16646: LD_INT 3
16648: EQUAL
16649: IFTRUE 16666
16651: PUSH
16652: LD_VAR 0 2
16656: PPUSH
16657: CALL_OW 263
16661: PUSH
16662: LD_INT 3
16664: EQUAL
16665: OR
16666: IFFALSE 16682
// hack_counter := hack_counter + 1 ;
16668: LD_ADDR_EXP 16
16672: PUSH
16673: LD_EXP 16
16677: PUSH
16678: LD_INT 1
16680: PLUS
16681: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16682: LD_VAR 0 1
16686: PPUSH
16687: LD_VAR 0 2
16691: PPUSH
16692: LD_VAR 0 3
16696: PPUSH
16697: LD_VAR 0 4
16701: PPUSH
16702: CALL 87615 0 4
// end ;
16706: PPOPN 4
16708: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16709: LD_VAR 0 1
16713: PUSH
16714: LD_INT 47
16716: EQUAL
16717: IFFALSE 16739
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16719: LD_VAR 0 1
16723: PPUSH
16724: CALL_OW 274
16728: PPUSH
16729: LD_INT 1
16731: PPUSH
16732: LD_INT 600
16734: PPUSH
16735: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16739: LD_VAR 0 1
16743: PPUSH
16744: LD_VAR 0 2
16748: PPUSH
16749: LD_VAR 0 3
16753: PPUSH
16754: CALL 87388 0 3
// end ;
16758: PPOPN 3
16760: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16761: LD_VAR 0 1
16765: PPUSH
16766: LD_VAR 0 2
16770: PPUSH
16771: CALL 87271 0 2
// end ;
16775: PPOPN 2
16777: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16778: LD_VAR 0 1
16782: PPUSH
16783: LD_VAR 0 2
16787: PPUSH
16788: CALL 91579 0 2
// end ;
16792: PPOPN 2
16794: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16795: LD_VAR 0 1
16799: PPUSH
16800: LD_VAR 0 2
16804: PPUSH
16805: LD_VAR 0 3
16809: PPUSH
16810: LD_VAR 0 4
16814: PPUSH
16815: CALL 91803 0 4
// end ;
16819: PPOPN 4
16821: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16822: LD_VAR 0 1
16826: PPUSH
16827: LD_VAR 0 2
16831: PPUSH
16832: CALL 87078 0 2
// end ;
16836: PPOPN 2
16838: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16839: LD_VAR 0 1
16843: PPUSH
16844: CALL 108067 0 1
// end ; end_of_file
16848: PPOPN 1
16850: END
// every 0 0$30 do var cr , time ;
16851: GO 16853
16853: DISABLE
16854: LD_INT 0
16856: PPUSH
16857: PPUSH
// begin time := 0 0$20 ;
16858: LD_ADDR_VAR 0 2
16862: PUSH
16863: LD_INT 700
16865: ST_TO_ADDR
// while game do
16866: LD_EXP 2
16870: IFFALSE 16973
// begin wait ( time ) ;
16872: LD_VAR 0 2
16876: PPUSH
16877: CALL_OW 67
// if tick > 2 2$00 then
16881: LD_OWVAR 1
16885: PUSH
16886: LD_INT 4200
16888: GREATER
16889: IFFALSE 16926
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16891: LD_ADDR_VAR 0 2
16895: PUSH
16896: LD_VAR 0 2
16900: PUSH
16901: LD_INT 140
16903: PUSH
16904: LD_INT 140
16906: PUSH
16907: LD_INT 210
16909: PUSH
16910: LD_INT 280
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: PUSH
16919: LD_OWVAR 67
16923: ARRAY
16924: PLUS
16925: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16926: LD_INT 1
16928: PPUSH
16929: LD_INT 5
16931: PPUSH
16932: CALL_OW 12
16936: PPUSH
16937: LD_INT 70
16939: PPUSH
16940: LD_INT 49
16942: PPUSH
16943: LD_INT 25
16945: PPUSH
16946: LD_INT 1
16948: PPUSH
16949: CALL_OW 56
// if time > 3 3$00 then
16953: LD_VAR 0 2
16957: PUSH
16958: LD_INT 6300
16960: GREATER
16961: IFFALSE 16971
// time := 0 0$30 ;
16963: LD_ADDR_VAR 0 2
16967: PUSH
16968: LD_INT 1050
16970: ST_TO_ADDR
// end ;
16971: GO 16866
// end ;
16973: PPOPN 2
16975: END
// every 0 0$30 do var cr , time ;
16976: GO 16978
16978: DISABLE
16979: LD_INT 0
16981: PPUSH
16982: PPUSH
// begin time := 0 0$20 ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_INT 700
16990: ST_TO_ADDR
// while game do
16991: LD_EXP 2
16995: IFFALSE 17088
// begin wait ( time ) ;
16997: LD_VAR 0 2
17001: PPUSH
17002: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
17006: LD_ADDR_VAR 0 2
17010: PUSH
17011: LD_VAR 0 2
17015: PUSH
17016: LD_INT 140
17018: PUSH
17019: LD_INT 175
17021: PUSH
17022: LD_INT 210
17024: PUSH
17025: LD_INT 280
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: LIST
17032: LIST
17033: PUSH
17034: LD_OWVAR 67
17038: ARRAY
17039: PLUS
17040: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
17041: LD_INT 3
17043: PPUSH
17044: LD_INT 5
17046: PPUSH
17047: CALL_OW 12
17051: PPUSH
17052: LD_INT 26
17054: PPUSH
17055: LD_INT 9
17057: PPUSH
17058: LD_INT 30
17060: PPUSH
17061: LD_INT 1
17063: PPUSH
17064: CALL_OW 56
// if time > 3 3$00 then
17068: LD_VAR 0 2
17072: PUSH
17073: LD_INT 6300
17075: GREATER
17076: IFFALSE 17086
// time := 0 0$20 ;
17078: LD_ADDR_VAR 0 2
17082: PUSH
17083: LD_INT 700
17085: ST_TO_ADDR
// end ;
17086: GO 16991
// end ;
17088: PPOPN 2
17090: END
// every 0 0$30 do var cr , time ;
17091: GO 17093
17093: DISABLE
17094: LD_INT 0
17096: PPUSH
17097: PPUSH
// begin time := 0 0$20 ;
17098: LD_ADDR_VAR 0 2
17102: PUSH
17103: LD_INT 700
17105: ST_TO_ADDR
// while game do
17106: LD_EXP 2
17110: IFFALSE 17239
// begin wait ( time ) ;
17112: LD_VAR 0 2
17116: PPUSH
17117: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
17121: LD_ADDR_VAR 0 2
17125: PUSH
17126: LD_VAR 0 2
17130: PUSH
17131: LD_INT 175
17133: PUSH
17134: LD_INT 210
17136: PUSH
17137: LD_INT 280
17139: PUSH
17140: LD_INT 350
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_OWVAR 67
17153: ARRAY
17154: PLUS
17155: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17156: LD_INT 1
17158: PPUSH
17159: LD_INT 5
17161: PPUSH
17162: CALL_OW 12
17166: PPUSH
17167: LD_INT 179
17169: PPUSH
17170: LD_INT 101
17172: PPUSH
17173: LD_INT 20
17175: PPUSH
17176: LD_INT 1
17178: PPUSH
17179: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17183: LD_INT 350
17185: PPUSH
17186: LD_INT 525
17188: PPUSH
17189: CALL_OW 12
17193: PPUSH
17194: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17198: LD_INT 1
17200: PPUSH
17201: LD_INT 5
17203: PPUSH
17204: CALL_OW 12
17208: PPUSH
17209: LD_INT 9
17211: PPUSH
17212: LD_INT 1
17214: PPUSH
17215: CALL_OW 55
// if time > 4 4$00 then
17219: LD_VAR 0 2
17223: PUSH
17224: LD_INT 8400
17226: GREATER
17227: IFFALSE 17237
// time := 0 0$30 ;
17229: LD_ADDR_VAR 0 2
17233: PUSH
17234: LD_INT 1050
17236: ST_TO_ADDR
// end ;
17237: GO 17106
// end ;
17239: PPOPN 2
17241: END
// every 0 0$30 do var cr , time ;
17242: GO 17244
17244: DISABLE
17245: LD_INT 0
17247: PPUSH
17248: PPUSH
// begin time := 0 0$10 ;
17249: LD_ADDR_VAR 0 2
17253: PUSH
17254: LD_INT 350
17256: ST_TO_ADDR
// while game do
17257: LD_EXP 2
17261: IFFALSE 17395
// begin wait ( time ) ;
17263: LD_VAR 0 2
17267: PPUSH
17268: CALL_OW 67
// time := time + 0 0$10 ;
17272: LD_ADDR_VAR 0 2
17276: PUSH
17277: LD_VAR 0 2
17281: PUSH
17282: LD_INT 350
17284: PLUS
17285: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17286: LD_INT 1
17288: PPUSH
17289: LD_INT 5
17291: PPUSH
17292: CALL_OW 12
17296: PPUSH
17297: LD_INT 11
17299: PPUSH
17300: LD_INT 1
17302: PPUSH
17303: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17307: LD_ADDR_VAR 0 1
17311: PUSH
17312: LD_INT 1
17314: PPUSH
17315: LD_INT 3
17317: PPUSH
17318: CALL_OW 12
17322: ST_TO_ADDR
// if cr = 1 then
17323: LD_VAR 0 1
17327: PUSH
17328: LD_INT 1
17330: EQUAL
17331: IFFALSE 17375
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17333: LD_INT 700
17335: PPUSH
17336: LD_INT 1575
17338: PPUSH
17339: CALL_OW 12
17343: PPUSH
17344: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17348: LD_INT 1
17350: PPUSH
17351: LD_INT 5
17353: PPUSH
17354: CALL_OW 12
17358: PPUSH
17359: LD_INT 34
17361: PPUSH
17362: LD_INT 50
17364: PPUSH
17365: LD_INT 7
17367: PPUSH
17368: LD_INT 1
17370: PPUSH
17371: CALL_OW 56
// end ; if time > 4 4$00 then
17375: LD_VAR 0 2
17379: PUSH
17380: LD_INT 8400
17382: GREATER
17383: IFFALSE 17393
// time := 0 0$40 ;
17385: LD_ADDR_VAR 0 2
17389: PUSH
17390: LD_INT 1400
17392: ST_TO_ADDR
// end ;
17393: GO 17257
// end ; end_of_file
17395: PPOPN 2
17397: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17398: LD_INT 0
17400: PPUSH
17401: PPUSH
// if exist_mode then
17402: LD_VAR 0 2
17406: IFFALSE 17452
// begin unit := CreateCharacter ( prefix & ident ) ;
17408: LD_ADDR_VAR 0 5
17412: PUSH
17413: LD_VAR 0 3
17417: PUSH
17418: LD_VAR 0 1
17422: STR
17423: PPUSH
17424: CALL_OW 34
17428: ST_TO_ADDR
// if unit then
17429: LD_VAR 0 5
17433: IFFALSE 17450
// DeleteCharacters ( prefix & ident ) ;
17435: LD_VAR 0 3
17439: PUSH
17440: LD_VAR 0 1
17444: STR
17445: PPUSH
17446: CALL_OW 40
// end else
17450: GO 17467
// unit := NewCharacter ( ident ) ;
17452: LD_ADDR_VAR 0 5
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 25
17466: ST_TO_ADDR
// result := unit ;
17467: LD_ADDR_VAR 0 4
17471: PUSH
17472: LD_VAR 0 5
17476: ST_TO_ADDR
// end ;
17477: LD_VAR 0 4
17481: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
// if exist_mode then
17486: LD_VAR 0 2
17490: IFFALSE 17515
// unit := CreateCharacter ( prefix & ident ) else
17492: LD_ADDR_VAR 0 5
17496: PUSH
17497: LD_VAR 0 3
17501: PUSH
17502: LD_VAR 0 1
17506: STR
17507: PPUSH
17508: CALL_OW 34
17512: ST_TO_ADDR
17513: GO 17530
// unit := NewCharacter ( ident ) ;
17515: LD_ADDR_VAR 0 5
17519: PUSH
17520: LD_VAR 0 1
17524: PPUSH
17525: CALL_OW 25
17529: ST_TO_ADDR
// result := unit ;
17530: LD_ADDR_VAR 0 4
17534: PUSH
17535: LD_VAR 0 5
17539: ST_TO_ADDR
// end ;
17540: LD_VAR 0 4
17544: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17545: LD_INT 0
17547: PPUSH
17548: PPUSH
// if not side or not nation then
17549: LD_VAR 0 1
17553: NOT
17554: IFTRUE 17563
17556: PUSH
17557: LD_VAR 0 2
17561: NOT
17562: OR
17563: IFFALSE 17567
// exit ;
17565: GO 18337
// case nation of nation_american :
17567: LD_VAR 0 2
17571: PUSH
17572: LD_INT 1
17574: DOUBLE
17575: EQUAL
17576: IFTRUE 17580
17578: GO 17794
17580: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17581: LD_ADDR_VAR 0 4
17585: PUSH
17586: LD_INT 35
17588: PUSH
17589: LD_INT 45
17591: PUSH
17592: LD_INT 46
17594: PUSH
17595: LD_INT 47
17597: PUSH
17598: LD_INT 82
17600: PUSH
17601: LD_INT 83
17603: PUSH
17604: LD_INT 84
17606: PUSH
17607: LD_INT 85
17609: PUSH
17610: LD_INT 86
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: LD_INT 2
17618: PUSH
17619: LD_INT 6
17621: PUSH
17622: LD_INT 15
17624: PUSH
17625: LD_INT 16
17627: PUSH
17628: LD_INT 7
17630: PUSH
17631: LD_INT 12
17633: PUSH
17634: LD_INT 13
17636: PUSH
17637: LD_INT 10
17639: PUSH
17640: LD_INT 14
17642: PUSH
17643: LD_INT 20
17645: PUSH
17646: LD_INT 21
17648: PUSH
17649: LD_INT 22
17651: PUSH
17652: LD_INT 25
17654: PUSH
17655: LD_INT 32
17657: PUSH
17658: LD_INT 27
17660: PUSH
17661: LD_INT 36
17663: PUSH
17664: LD_INT 69
17666: PUSH
17667: LD_INT 39
17669: PUSH
17670: LD_INT 34
17672: PUSH
17673: LD_INT 40
17675: PUSH
17676: LD_INT 48
17678: PUSH
17679: LD_INT 49
17681: PUSH
17682: LD_INT 50
17684: PUSH
17685: LD_INT 51
17687: PUSH
17688: LD_INT 52
17690: PUSH
17691: LD_INT 53
17693: PUSH
17694: LD_INT 54
17696: PUSH
17697: LD_INT 55
17699: PUSH
17700: LD_INT 56
17702: PUSH
17703: LD_INT 57
17705: PUSH
17706: LD_INT 58
17708: PUSH
17709: LD_INT 59
17711: PUSH
17712: LD_INT 60
17714: PUSH
17715: LD_INT 61
17717: PUSH
17718: LD_INT 62
17720: PUSH
17721: LD_INT 80
17723: PUSH
17724: LD_INT 82
17726: PUSH
17727: LD_INT 83
17729: PUSH
17730: LD_INT 84
17732: PUSH
17733: LD_INT 85
17735: PUSH
17736: LD_INT 86
17738: PUSH
17739: EMPTY
17740: LIST
17741: LIST
17742: LIST
17743: LIST
17744: LIST
17745: LIST
17746: LIST
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: LIST
17752: LIST
17753: LIST
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: ST_TO_ADDR
17792: GO 18259
17794: LD_INT 2
17796: DOUBLE
17797: EQUAL
17798: IFTRUE 17802
17800: GO 18028
17802: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
17803: LD_ADDR_VAR 0 4
17807: PUSH
17808: LD_INT 35
17810: PUSH
17811: LD_INT 45
17813: PUSH
17814: LD_INT 46
17816: PUSH
17817: LD_INT 47
17819: PUSH
17820: LD_INT 82
17822: PUSH
17823: LD_INT 83
17825: PUSH
17826: LD_INT 84
17828: PUSH
17829: LD_INT 85
17831: PUSH
17832: LD_INT 87
17834: PUSH
17835: LD_INT 70
17837: PUSH
17838: LD_INT 1
17840: PUSH
17841: LD_INT 11
17843: PUSH
17844: LD_INT 3
17846: PUSH
17847: LD_INT 4
17849: PUSH
17850: LD_INT 5
17852: PUSH
17853: LD_INT 6
17855: PUSH
17856: LD_INT 15
17858: PUSH
17859: LD_INT 18
17861: PUSH
17862: LD_INT 7
17864: PUSH
17865: LD_INT 17
17867: PUSH
17868: LD_INT 8
17870: PUSH
17871: LD_INT 20
17873: PUSH
17874: LD_INT 21
17876: PUSH
17877: LD_INT 22
17879: PUSH
17880: LD_INT 72
17882: PUSH
17883: LD_INT 26
17885: PUSH
17886: LD_INT 69
17888: PUSH
17889: LD_INT 39
17891: PUSH
17892: LD_INT 40
17894: PUSH
17895: LD_INT 41
17897: PUSH
17898: LD_INT 42
17900: PUSH
17901: LD_INT 43
17903: PUSH
17904: LD_INT 48
17906: PUSH
17907: LD_INT 49
17909: PUSH
17910: LD_INT 50
17912: PUSH
17913: LD_INT 51
17915: PUSH
17916: LD_INT 52
17918: PUSH
17919: LD_INT 53
17921: PUSH
17922: LD_INT 54
17924: PUSH
17925: LD_INT 55
17927: PUSH
17928: LD_INT 56
17930: PUSH
17931: LD_INT 60
17933: PUSH
17934: LD_INT 61
17936: PUSH
17937: LD_INT 62
17939: PUSH
17940: LD_INT 66
17942: PUSH
17943: LD_INT 67
17945: PUSH
17946: LD_INT 68
17948: PUSH
17949: LD_INT 81
17951: PUSH
17952: LD_INT 82
17954: PUSH
17955: LD_INT 83
17957: PUSH
17958: LD_INT 84
17960: PUSH
17961: LD_INT 85
17963: PUSH
17964: LD_INT 87
17966: PUSH
17967: LD_INT 88
17969: PUSH
17970: EMPTY
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: LIST
17981: LIST
17982: LIST
17983: LIST
17984: LIST
17985: LIST
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: ST_TO_ADDR
18026: GO 18259
18028: LD_INT 3
18030: DOUBLE
18031: EQUAL
18032: IFTRUE 18036
18034: GO 18258
18036: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
18037: LD_ADDR_VAR 0 4
18041: PUSH
18042: LD_INT 46
18044: PUSH
18045: LD_INT 47
18047: PUSH
18048: LD_INT 1
18050: PUSH
18051: LD_INT 2
18053: PUSH
18054: LD_INT 82
18056: PUSH
18057: LD_INT 83
18059: PUSH
18060: LD_INT 84
18062: PUSH
18063: LD_INT 85
18065: PUSH
18066: LD_INT 86
18068: PUSH
18069: LD_INT 11
18071: PUSH
18072: LD_INT 9
18074: PUSH
18075: LD_INT 20
18077: PUSH
18078: LD_INT 19
18080: PUSH
18081: LD_INT 21
18083: PUSH
18084: LD_INT 24
18086: PUSH
18087: LD_INT 22
18089: PUSH
18090: LD_INT 25
18092: PUSH
18093: LD_INT 28
18095: PUSH
18096: LD_INT 29
18098: PUSH
18099: LD_INT 30
18101: PUSH
18102: LD_INT 31
18104: PUSH
18105: LD_INT 37
18107: PUSH
18108: LD_INT 38
18110: PUSH
18111: LD_INT 32
18113: PUSH
18114: LD_INT 27
18116: PUSH
18117: LD_INT 33
18119: PUSH
18120: LD_INT 69
18122: PUSH
18123: LD_INT 39
18125: PUSH
18126: LD_INT 34
18128: PUSH
18129: LD_INT 40
18131: PUSH
18132: LD_INT 71
18134: PUSH
18135: LD_INT 23
18137: PUSH
18138: LD_INT 44
18140: PUSH
18141: LD_INT 48
18143: PUSH
18144: LD_INT 49
18146: PUSH
18147: LD_INT 50
18149: PUSH
18150: LD_INT 51
18152: PUSH
18153: LD_INT 52
18155: PUSH
18156: LD_INT 53
18158: PUSH
18159: LD_INT 54
18161: PUSH
18162: LD_INT 55
18164: PUSH
18165: LD_INT 56
18167: PUSH
18168: LD_INT 57
18170: PUSH
18171: LD_INT 58
18173: PUSH
18174: LD_INT 59
18176: PUSH
18177: LD_INT 63
18179: PUSH
18180: LD_INT 64
18182: PUSH
18183: LD_INT 65
18185: PUSH
18186: LD_INT 82
18188: PUSH
18189: LD_INT 83
18191: PUSH
18192: LD_INT 84
18194: PUSH
18195: LD_INT 85
18197: PUSH
18198: LD_INT 86
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: ST_TO_ADDR
18256: GO 18259
18258: POP
// if state > - 1 and state < 3 then
18259: LD_VAR 0 3
18263: PUSH
18264: LD_INT 1
18266: NEG
18267: GREATER
18268: IFFALSE 18280
18270: PUSH
18271: LD_VAR 0 3
18275: PUSH
18276: LD_INT 3
18278: LESS
18279: AND
18280: IFFALSE 18337
// for i in result do
18282: LD_ADDR_VAR 0 5
18286: PUSH
18287: LD_VAR 0 4
18291: PUSH
18292: FOR_IN
18293: IFFALSE 18335
// if GetTech ( i , side ) <> state then
18295: LD_VAR 0 5
18299: PPUSH
18300: LD_VAR 0 1
18304: PPUSH
18305: CALL_OW 321
18309: PUSH
18310: LD_VAR 0 3
18314: NONEQUAL
18315: IFFALSE 18333
// result := result diff i ;
18317: LD_ADDR_VAR 0 4
18321: PUSH
18322: LD_VAR 0 4
18326: PUSH
18327: LD_VAR 0 5
18331: DIFF
18332: ST_TO_ADDR
18333: GO 18292
18335: POP
18336: POP
// end ;
18337: LD_VAR 0 4
18341: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18342: LD_INT 0
18344: PPUSH
18345: PPUSH
18346: PPUSH
// result := true ;
18347: LD_ADDR_VAR 0 3
18351: PUSH
18352: LD_INT 1
18354: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18355: LD_ADDR_VAR 0 5
18359: PUSH
18360: LD_VAR 0 2
18364: PPUSH
18365: CALL_OW 480
18369: ST_TO_ADDR
// if not tmp then
18370: LD_VAR 0 5
18374: NOT
18375: IFFALSE 18379
// exit ;
18377: GO 18428
// for i in tmp do
18379: LD_ADDR_VAR 0 4
18383: PUSH
18384: LD_VAR 0 5
18388: PUSH
18389: FOR_IN
18390: IFFALSE 18426
// if GetTech ( i , side ) <> state_researched then
18392: LD_VAR 0 4
18396: PPUSH
18397: LD_VAR 0 1
18401: PPUSH
18402: CALL_OW 321
18406: PUSH
18407: LD_INT 2
18409: NONEQUAL
18410: IFFALSE 18424
// begin result := false ;
18412: LD_ADDR_VAR 0 3
18416: PUSH
18417: LD_INT 0
18419: ST_TO_ADDR
// exit ;
18420: POP
18421: POP
18422: GO 18428
// end ;
18424: GO 18389
18426: POP
18427: POP
// end ;
18428: LD_VAR 0 3
18432: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18433: LD_INT 0
18435: PPUSH
18436: PPUSH
18437: PPUSH
18438: PPUSH
18439: PPUSH
18440: PPUSH
18441: PPUSH
18442: PPUSH
18443: PPUSH
18444: PPUSH
18445: PPUSH
18446: PPUSH
18447: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18448: LD_VAR 0 1
18452: NOT
18453: IFTRUE 18470
18455: PUSH
18456: LD_VAR 0 1
18460: PPUSH
18461: CALL_OW 257
18465: PUSH
18466: LD_INT 9
18468: NONEQUAL
18469: OR
18470: IFFALSE 18474
// exit ;
18472: GO 19053
// side := GetSide ( unit ) ;
18474: LD_ADDR_VAR 0 9
18478: PUSH
18479: LD_VAR 0 1
18483: PPUSH
18484: CALL_OW 255
18488: ST_TO_ADDR
// tech_space := tech_spacanom ;
18489: LD_ADDR_VAR 0 12
18493: PUSH
18494: LD_INT 29
18496: ST_TO_ADDR
// tech_time := tech_taurad ;
18497: LD_ADDR_VAR 0 13
18501: PUSH
18502: LD_INT 28
18504: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18505: LD_ADDR_VAR 0 11
18509: PUSH
18510: LD_VAR 0 1
18514: PPUSH
18515: CALL_OW 310
18519: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18520: LD_VAR 0 11
18524: PPUSH
18525: CALL_OW 247
18529: PUSH
18530: LD_INT 2
18532: EQUAL
18533: IFFALSE 18537
// exit ;
18535: GO 19053
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18537: LD_ADDR_VAR 0 8
18541: PUSH
18542: LD_INT 81
18544: PUSH
18545: LD_VAR 0 9
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: LD_INT 3
18556: PUSH
18557: LD_INT 21
18559: PUSH
18560: LD_INT 3
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: PUSH
18571: EMPTY
18572: LIST
18573: LIST
18574: PPUSH
18575: CALL_OW 69
18579: ST_TO_ADDR
// if not tmp then
18580: LD_VAR 0 8
18584: NOT
18585: IFFALSE 18589
// exit ;
18587: GO 19053
// if in_unit then
18589: LD_VAR 0 11
18593: IFFALSE 18617
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18595: LD_ADDR_VAR 0 10
18599: PUSH
18600: LD_VAR 0 8
18604: PPUSH
18605: LD_VAR 0 11
18609: PPUSH
18610: CALL_OW 74
18614: ST_TO_ADDR
18615: GO 18637
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18617: LD_ADDR_VAR 0 10
18621: PUSH
18622: LD_VAR 0 8
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: CALL_OW 74
18636: ST_TO_ADDR
// if not enemy then
18637: LD_VAR 0 10
18641: NOT
18642: IFFALSE 18646
// exit ;
18644: GO 19053
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18646: LD_VAR 0 11
18650: IFFALSE 18672
18652: PUSH
18653: LD_VAR 0 11
18657: PPUSH
18658: LD_VAR 0 10
18662: PPUSH
18663: CALL_OW 296
18667: PUSH
18668: LD_INT 13
18670: GREATER
18671: AND
18672: IFTRUE 18694
18674: PUSH
18675: LD_VAR 0 1
18679: PPUSH
18680: LD_VAR 0 10
18684: PPUSH
18685: CALL_OW 296
18689: PUSH
18690: LD_INT 12
18692: GREATER
18693: OR
18694: IFFALSE 18698
// exit ;
18696: GO 19053
// missile := [ 1 ] ;
18698: LD_ADDR_VAR 0 14
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: EMPTY
18707: LIST
18708: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18709: LD_VAR 0 9
18713: PPUSH
18714: LD_VAR 0 12
18718: PPUSH
18719: CALL_OW 325
18723: IFFALSE 18752
// missile := Replace ( missile , missile + 1 , 2 ) ;
18725: LD_ADDR_VAR 0 14
18729: PUSH
18730: LD_VAR 0 14
18734: PPUSH
18735: LD_VAR 0 14
18739: PUSH
18740: LD_INT 1
18742: PLUS
18743: PPUSH
18744: LD_INT 2
18746: PPUSH
18747: CALL_OW 1
18751: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18752: LD_VAR 0 9
18756: PPUSH
18757: LD_VAR 0 13
18761: PPUSH
18762: CALL_OW 325
18766: IFFALSE 18790
18768: PUSH
18769: LD_VAR 0 10
18773: PPUSH
18774: CALL_OW 255
18778: PPUSH
18779: LD_VAR 0 13
18783: PPUSH
18784: CALL_OW 325
18788: NOT
18789: AND
18790: IFFALSE 18819
// missile := Replace ( missile , missile + 1 , 3 ) ;
18792: LD_ADDR_VAR 0 14
18796: PUSH
18797: LD_VAR 0 14
18801: PPUSH
18802: LD_VAR 0 14
18806: PUSH
18807: LD_INT 1
18809: PLUS
18810: PPUSH
18811: LD_INT 3
18813: PPUSH
18814: CALL_OW 1
18818: ST_TO_ADDR
// if missile < 2 then
18819: LD_VAR 0 14
18823: PUSH
18824: LD_INT 2
18826: LESS
18827: IFFALSE 18831
// exit ;
18829: GO 19053
// x := GetX ( enemy ) ;
18831: LD_ADDR_VAR 0 4
18835: PUSH
18836: LD_VAR 0 10
18840: PPUSH
18841: CALL_OW 250
18845: ST_TO_ADDR
// y := GetY ( enemy ) ;
18846: LD_ADDR_VAR 0 5
18850: PUSH
18851: LD_VAR 0 10
18855: PPUSH
18856: CALL_OW 251
18860: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18861: LD_ADDR_VAR 0 6
18865: PUSH
18866: LD_VAR 0 4
18870: PUSH
18871: LD_INT 1
18873: NEG
18874: PPUSH
18875: LD_INT 1
18877: PPUSH
18878: CALL_OW 12
18882: PLUS
18883: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18884: LD_ADDR_VAR 0 7
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: LD_INT 1
18896: NEG
18897: PPUSH
18898: LD_INT 1
18900: PPUSH
18901: CALL_OW 12
18905: PLUS
18906: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18907: LD_VAR 0 6
18911: PPUSH
18912: LD_VAR 0 7
18916: PPUSH
18917: CALL_OW 488
18921: NOT
18922: IFFALSE 18944
// begin _x := x ;
18924: LD_ADDR_VAR 0 6
18928: PUSH
18929: LD_VAR 0 4
18933: ST_TO_ADDR
// _y := y ;
18934: LD_ADDR_VAR 0 7
18938: PUSH
18939: LD_VAR 0 5
18943: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_INT 1
18951: PPUSH
18952: LD_VAR 0 14
18956: PPUSH
18957: CALL_OW 12
18961: ST_TO_ADDR
// case i of 1 :
18962: LD_VAR 0 3
18966: PUSH
18967: LD_INT 1
18969: DOUBLE
18970: EQUAL
18971: IFTRUE 18975
18973: GO 18992
18975: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18976: LD_VAR 0 1
18980: PPUSH
18981: LD_VAR 0 10
18985: PPUSH
18986: CALL_OW 115
18990: GO 19053
18992: LD_INT 2
18994: DOUBLE
18995: EQUAL
18996: IFTRUE 19000
18998: GO 19022
19000: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19001: LD_VAR 0 1
19005: PPUSH
19006: LD_VAR 0 6
19010: PPUSH
19011: LD_VAR 0 7
19015: PPUSH
19016: CALL_OW 153
19020: GO 19053
19022: LD_INT 3
19024: DOUBLE
19025: EQUAL
19026: IFTRUE 19030
19028: GO 19052
19030: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19031: LD_VAR 0 1
19035: PPUSH
19036: LD_VAR 0 6
19040: PPUSH
19041: LD_VAR 0 7
19045: PPUSH
19046: CALL_OW 154
19050: GO 19053
19052: POP
// end ;
19053: LD_VAR 0 2
19057: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19058: LD_INT 0
19060: PPUSH
19061: PPUSH
19062: PPUSH
19063: PPUSH
19064: PPUSH
19065: PPUSH
// if not unit or not building then
19066: LD_VAR 0 1
19070: NOT
19071: IFTRUE 19080
19073: PUSH
19074: LD_VAR 0 2
19078: NOT
19079: OR
19080: IFFALSE 19084
// exit ;
19082: GO 19242
// x := GetX ( building ) ;
19084: LD_ADDR_VAR 0 5
19088: PUSH
19089: LD_VAR 0 2
19093: PPUSH
19094: CALL_OW 250
19098: ST_TO_ADDR
// y := GetY ( building ) ;
19099: LD_ADDR_VAR 0 6
19103: PUSH
19104: LD_VAR 0 2
19108: PPUSH
19109: CALL_OW 251
19113: ST_TO_ADDR
// for i := 0 to 5 do
19114: LD_ADDR_VAR 0 4
19118: PUSH
19119: DOUBLE
19120: LD_INT 0
19122: DEC
19123: ST_TO_ADDR
19124: LD_INT 5
19126: PUSH
19127: FOR_TO
19128: IFFALSE 19240
// begin _x := ShiftX ( x , i , 3 ) ;
19130: LD_ADDR_VAR 0 7
19134: PUSH
19135: LD_VAR 0 5
19139: PPUSH
19140: LD_VAR 0 4
19144: PPUSH
19145: LD_INT 3
19147: PPUSH
19148: CALL_OW 272
19152: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19153: LD_ADDR_VAR 0 8
19157: PUSH
19158: LD_VAR 0 6
19162: PPUSH
19163: LD_VAR 0 4
19167: PPUSH
19168: LD_INT 3
19170: PPUSH
19171: CALL_OW 273
19175: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19176: LD_VAR 0 7
19180: PPUSH
19181: LD_VAR 0 8
19185: PPUSH
19186: CALL_OW 488
19190: NOT
19191: IFFALSE 19195
// continue ;
19193: GO 19127
// if HexInfo ( _x , _y ) = 0 then
19195: LD_VAR 0 7
19199: PPUSH
19200: LD_VAR 0 8
19204: PPUSH
19205: CALL_OW 428
19209: PUSH
19210: LD_INT 0
19212: EQUAL
19213: IFFALSE 19238
// begin ComMoveXY ( unit , _x , _y ) ;
19215: LD_VAR 0 1
19219: PPUSH
19220: LD_VAR 0 7
19224: PPUSH
19225: LD_VAR 0 8
19229: PPUSH
19230: CALL_OW 111
// exit ;
19234: POP
19235: POP
19236: GO 19242
// end ; end ;
19238: GO 19127
19240: POP
19241: POP
// end ;
19242: LD_VAR 0 3
19246: RET
// export function ScanBase ( side , base_area ) ; begin
19247: LD_INT 0
19249: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19250: LD_ADDR_VAR 0 3
19254: PUSH
19255: LD_VAR 0 2
19259: PPUSH
19260: LD_INT 81
19262: PUSH
19263: LD_VAR 0 1
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 70
19276: ST_TO_ADDR
// end ;
19277: LD_VAR 0 3
19281: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19282: LD_INT 0
19284: PPUSH
19285: PPUSH
19286: PPUSH
19287: PPUSH
// result := false ;
19288: LD_ADDR_VAR 0 2
19292: PUSH
19293: LD_INT 0
19295: ST_TO_ADDR
// side := GetSide ( unit ) ;
19296: LD_ADDR_VAR 0 3
19300: PUSH
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 255
19310: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19311: LD_ADDR_VAR 0 4
19315: PUSH
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 248
19325: ST_TO_ADDR
// case nat of 1 :
19326: LD_VAR 0 4
19330: PUSH
19331: LD_INT 1
19333: DOUBLE
19334: EQUAL
19335: IFTRUE 19339
19337: GO 19350
19339: POP
// tech := tech_lassight ; 2 :
19340: LD_ADDR_VAR 0 5
19344: PUSH
19345: LD_INT 12
19347: ST_TO_ADDR
19348: GO 19389
19350: LD_INT 2
19352: DOUBLE
19353: EQUAL
19354: IFTRUE 19358
19356: GO 19369
19358: POP
// tech := tech_mortar ; 3 :
19359: LD_ADDR_VAR 0 5
19363: PUSH
19364: LD_INT 41
19366: ST_TO_ADDR
19367: GO 19389
19369: LD_INT 3
19371: DOUBLE
19372: EQUAL
19373: IFTRUE 19377
19375: GO 19388
19377: POP
// tech := tech_bazooka ; end ;
19378: LD_ADDR_VAR 0 5
19382: PUSH
19383: LD_INT 44
19385: ST_TO_ADDR
19386: GO 19389
19388: POP
// if Researched ( side , tech ) then
19389: LD_VAR 0 3
19393: PPUSH
19394: LD_VAR 0 5
19398: PPUSH
19399: CALL_OW 325
19403: IFFALSE 19430
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19405: LD_ADDR_VAR 0 2
19409: PUSH
19410: LD_INT 5
19412: PUSH
19413: LD_INT 8
19415: PUSH
19416: LD_INT 9
19418: PUSH
19419: EMPTY
19420: LIST
19421: LIST
19422: LIST
19423: PUSH
19424: LD_VAR 0 4
19428: ARRAY
19429: ST_TO_ADDR
// end ;
19430: LD_VAR 0 2
19434: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19435: LD_INT 0
19437: PPUSH
19438: PPUSH
19439: PPUSH
// if not mines then
19440: LD_VAR 0 2
19444: NOT
19445: IFFALSE 19449
// exit ;
19447: GO 19593
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19449: LD_ADDR_VAR 0 5
19453: PUSH
19454: LD_INT 81
19456: PUSH
19457: LD_VAR 0 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PUSH
19466: LD_INT 3
19468: PUSH
19469: LD_INT 21
19471: PUSH
19472: LD_INT 3
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PPUSH
19487: CALL_OW 69
19491: ST_TO_ADDR
// for i in mines do
19492: LD_ADDR_VAR 0 4
19496: PUSH
19497: LD_VAR 0 2
19501: PUSH
19502: FOR_IN
19503: IFFALSE 19591
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19505: LD_VAR 0 4
19509: PUSH
19510: LD_INT 1
19512: ARRAY
19513: PPUSH
19514: LD_VAR 0 4
19518: PUSH
19519: LD_INT 2
19521: ARRAY
19522: PPUSH
19523: CALL_OW 458
19527: NOT
19528: IFFALSE 19532
// continue ;
19530: GO 19502
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19532: LD_VAR 0 4
19536: PUSH
19537: LD_INT 1
19539: ARRAY
19540: PPUSH
19541: LD_VAR 0 4
19545: PUSH
19546: LD_INT 2
19548: ARRAY
19549: PPUSH
19550: CALL_OW 428
19554: PUSH
19555: LD_VAR 0 5
19559: IN
19560: IFFALSE 19589
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19562: LD_VAR 0 4
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: PPUSH
19571: LD_VAR 0 4
19575: PUSH
19576: LD_INT 2
19578: ARRAY
19579: PPUSH
19580: LD_VAR 0 1
19584: PPUSH
19585: CALL_OW 456
// end ;
19589: GO 19502
19591: POP
19592: POP
// end ;
19593: LD_VAR 0 3
19597: RET
// export function Count ( array ) ; begin
19598: LD_INT 0
19600: PPUSH
// result := array + 0 ;
19601: LD_ADDR_VAR 0 2
19605: PUSH
19606: LD_VAR 0 1
19610: PUSH
19611: LD_INT 0
19613: PLUS
19614: ST_TO_ADDR
// end ;
19615: LD_VAR 0 2
19619: RET
// export function IsEmpty ( building ) ; begin
19620: LD_INT 0
19622: PPUSH
// if not building then
19623: LD_VAR 0 1
19627: NOT
19628: IFFALSE 19632
// exit ;
19630: GO 19675
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19632: LD_ADDR_VAR 0 2
19636: PUSH
19637: LD_VAR 0 1
19641: PUSH
19642: LD_INT 22
19644: PUSH
19645: LD_VAR 0 1
19649: PPUSH
19650: CALL_OW 255
19654: PUSH
19655: EMPTY
19656: LIST
19657: LIST
19658: PUSH
19659: LD_INT 58
19661: PUSH
19662: EMPTY
19663: LIST
19664: PUSH
19665: EMPTY
19666: LIST
19667: LIST
19668: PPUSH
19669: CALL_OW 69
19673: IN
19674: ST_TO_ADDR
// end ;
19675: LD_VAR 0 2
19679: RET
// export function IsNotFull ( building ) ; var places ; begin
19680: LD_INT 0
19682: PPUSH
19683: PPUSH
// if not building then
19684: LD_VAR 0 1
19688: NOT
19689: IFFALSE 19693
// exit ;
19691: GO 19721
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19693: LD_ADDR_VAR 0 2
19697: PUSH
19698: LD_VAR 0 1
19702: PPUSH
19703: LD_INT 3
19705: PUSH
19706: LD_INT 62
19708: PUSH
19709: EMPTY
19710: LIST
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PPUSH
19716: CALL_OW 72
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 2
19725: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// tmp := [ ] ;
19732: LD_ADDR_VAR 0 3
19736: PUSH
19737: EMPTY
19738: ST_TO_ADDR
// list := [ ] ;
19739: LD_ADDR_VAR 0 5
19743: PUSH
19744: EMPTY
19745: ST_TO_ADDR
// for i = 16 to 25 do
19746: LD_ADDR_VAR 0 4
19750: PUSH
19751: DOUBLE
19752: LD_INT 16
19754: DEC
19755: ST_TO_ADDR
19756: LD_INT 25
19758: PUSH
19759: FOR_TO
19760: IFFALSE 19833
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19762: LD_ADDR_VAR 0 3
19766: PUSH
19767: LD_VAR 0 3
19771: PUSH
19772: LD_INT 22
19774: PUSH
19775: LD_VAR 0 1
19779: PPUSH
19780: CALL_OW 255
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 91
19791: PUSH
19792: LD_VAR 0 1
19796: PUSH
19797: LD_INT 6
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: LIST
19804: PUSH
19805: LD_INT 30
19807: PUSH
19808: LD_VAR 0 4
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: PUSH
19822: EMPTY
19823: LIST
19824: PPUSH
19825: CALL_OW 69
19829: ADD
19830: ST_TO_ADDR
19831: GO 19759
19833: POP
19834: POP
// for i = 1 to tmp do
19835: LD_ADDR_VAR 0 4
19839: PUSH
19840: DOUBLE
19841: LD_INT 1
19843: DEC
19844: ST_TO_ADDR
19845: LD_VAR 0 3
19849: PUSH
19850: FOR_TO
19851: IFFALSE 19939
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19853: LD_ADDR_VAR 0 5
19857: PUSH
19858: LD_VAR 0 5
19862: PUSH
19863: LD_VAR 0 3
19867: PUSH
19868: LD_VAR 0 4
19872: ARRAY
19873: PPUSH
19874: CALL_OW 266
19878: PUSH
19879: LD_VAR 0 3
19883: PUSH
19884: LD_VAR 0 4
19888: ARRAY
19889: PPUSH
19890: CALL_OW 250
19894: PUSH
19895: LD_VAR 0 3
19899: PUSH
19900: LD_VAR 0 4
19904: ARRAY
19905: PPUSH
19906: CALL_OW 251
19910: PUSH
19911: LD_VAR 0 3
19915: PUSH
19916: LD_VAR 0 4
19920: ARRAY
19921: PPUSH
19922: CALL_OW 254
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: PUSH
19933: EMPTY
19934: LIST
19935: ADD
19936: ST_TO_ADDR
19937: GO 19850
19939: POP
19940: POP
// result := list ;
19941: LD_ADDR_VAR 0 2
19945: PUSH
19946: LD_VAR 0 5
19950: ST_TO_ADDR
// end ;
19951: LD_VAR 0 2
19955: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19956: LD_INT 0
19958: PPUSH
19959: PPUSH
19960: PPUSH
19961: PPUSH
19962: PPUSH
19963: PPUSH
19964: PPUSH
// if not factory then
19965: LD_VAR 0 1
19969: NOT
19970: IFFALSE 19974
// exit ;
19972: GO 20577
// if control = control_apeman then
19974: LD_VAR 0 4
19978: PUSH
19979: LD_INT 5
19981: EQUAL
19982: IFFALSE 20091
// begin tmp := UnitsInside ( factory ) ;
19984: LD_ADDR_VAR 0 8
19988: PUSH
19989: LD_VAR 0 1
19993: PPUSH
19994: CALL_OW 313
19998: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19999: LD_VAR 0 8
20003: PPUSH
20004: LD_INT 25
20006: PUSH
20007: LD_INT 12
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: PPUSH
20014: CALL_OW 72
20018: NOT
20019: IFFALSE 20029
// control := control_manual ;
20021: LD_ADDR_VAR 0 4
20025: PUSH
20026: LD_INT 1
20028: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20029: LD_ADDR_VAR 0 8
20033: PUSH
20034: LD_VAR 0 1
20038: PPUSH
20039: CALL 19726 0 1
20043: ST_TO_ADDR
// if tmp then
20044: LD_VAR 0 8
20048: IFFALSE 20091
// begin for i in tmp do
20050: LD_ADDR_VAR 0 7
20054: PUSH
20055: LD_VAR 0 8
20059: PUSH
20060: FOR_IN
20061: IFFALSE 20089
// if i [ 1 ] = b_ext_radio then
20063: LD_VAR 0 7
20067: PUSH
20068: LD_INT 1
20070: ARRAY
20071: PUSH
20072: LD_INT 22
20074: EQUAL
20075: IFFALSE 20087
// begin control := control_remote ;
20077: LD_ADDR_VAR 0 4
20081: PUSH
20082: LD_INT 2
20084: ST_TO_ADDR
// break ;
20085: GO 20089
// end ;
20087: GO 20060
20089: POP
20090: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20091: LD_VAR 0 1
20095: PPUSH
20096: LD_VAR 0 2
20100: PPUSH
20101: LD_VAR 0 3
20105: PPUSH
20106: LD_VAR 0 4
20110: PPUSH
20111: LD_VAR 0 5
20115: PPUSH
20116: CALL_OW 448
20120: IFFALSE 20155
// begin result := [ chassis , engine , control , weapon ] ;
20122: LD_ADDR_VAR 0 6
20126: PUSH
20127: LD_VAR 0 2
20131: PUSH
20132: LD_VAR 0 3
20136: PUSH
20137: LD_VAR 0 4
20141: PUSH
20142: LD_VAR 0 5
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: ST_TO_ADDR
// exit ;
20153: GO 20577
// end ; _chassis := AvailableChassisList ( factory ) ;
20155: LD_ADDR_VAR 0 9
20159: PUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: CALL_OW 475
20169: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20170: LD_ADDR_VAR 0 11
20174: PUSH
20175: LD_VAR 0 1
20179: PPUSH
20180: CALL_OW 476
20184: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20185: LD_ADDR_VAR 0 12
20189: PUSH
20190: LD_VAR 0 1
20194: PPUSH
20195: CALL_OW 477
20199: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20200: LD_ADDR_VAR 0 10
20204: PUSH
20205: LD_VAR 0 1
20209: PPUSH
20210: CALL_OW 478
20214: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20215: LD_VAR 0 9
20219: NOT
20220: IFTRUE 20229
20222: PUSH
20223: LD_VAR 0 11
20227: NOT
20228: OR
20229: IFTRUE 20238
20231: PUSH
20232: LD_VAR 0 12
20236: NOT
20237: OR
20238: IFTRUE 20247
20240: PUSH
20241: LD_VAR 0 10
20245: NOT
20246: OR
20247: IFFALSE 20282
// begin result := [ chassis , engine , control , weapon ] ;
20249: LD_ADDR_VAR 0 6
20253: PUSH
20254: LD_VAR 0 2
20258: PUSH
20259: LD_VAR 0 3
20263: PUSH
20264: LD_VAR 0 4
20268: PUSH
20269: LD_VAR 0 5
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: ST_TO_ADDR
// exit ;
20280: GO 20577
// end ; if not chassis in _chassis then
20282: LD_VAR 0 2
20286: PUSH
20287: LD_VAR 0 9
20291: IN
20292: NOT
20293: IFFALSE 20319
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20295: LD_ADDR_VAR 0 2
20299: PUSH
20300: LD_VAR 0 9
20304: PUSH
20305: LD_INT 1
20307: PPUSH
20308: LD_VAR 0 9
20312: PPUSH
20313: CALL_OW 12
20317: ARRAY
20318: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20319: LD_VAR 0 2
20323: PPUSH
20324: LD_VAR 0 3
20328: PPUSH
20329: CALL 20582 0 2
20333: NOT
20334: IFFALSE 20395
// repeat engine := _engine [ 1 ] ;
20336: LD_ADDR_VAR 0 3
20340: PUSH
20341: LD_VAR 0 11
20345: PUSH
20346: LD_INT 1
20348: ARRAY
20349: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20350: LD_ADDR_VAR 0 11
20354: PUSH
20355: LD_VAR 0 11
20359: PPUSH
20360: LD_INT 1
20362: PPUSH
20363: CALL_OW 3
20367: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20368: LD_VAR 0 2
20372: PPUSH
20373: LD_VAR 0 3
20377: PPUSH
20378: CALL 20582 0 2
20382: IFTRUE 20393
20384: PUSH
20385: LD_VAR 0 11
20389: PUSH
20390: EMPTY
20391: EQUAL
20392: OR
20393: IFFALSE 20336
// if not control in _control then
20395: LD_VAR 0 4
20399: PUSH
20400: LD_VAR 0 12
20404: IN
20405: NOT
20406: IFFALSE 20432
// control := _control [ rand ( 1 , _control ) ] ;
20408: LD_ADDR_VAR 0 4
20412: PUSH
20413: LD_VAR 0 12
20417: PUSH
20418: LD_INT 1
20420: PPUSH
20421: LD_VAR 0 12
20425: PPUSH
20426: CALL_OW 12
20430: ARRAY
20431: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20432: LD_VAR 0 2
20436: PPUSH
20437: LD_VAR 0 5
20441: PPUSH
20442: CALL 20804 0 2
20446: NOT
20447: IFFALSE 20508
// repeat weapon := _weapon [ 1 ] ;
20449: LD_ADDR_VAR 0 5
20453: PUSH
20454: LD_VAR 0 10
20458: PUSH
20459: LD_INT 1
20461: ARRAY
20462: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20463: LD_ADDR_VAR 0 10
20467: PUSH
20468: LD_VAR 0 10
20472: PPUSH
20473: LD_INT 1
20475: PPUSH
20476: CALL_OW 3
20480: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20481: LD_VAR 0 2
20485: PPUSH
20486: LD_VAR 0 5
20490: PPUSH
20491: CALL 20804 0 2
20495: IFTRUE 20506
20497: PUSH
20498: LD_VAR 0 10
20502: PUSH
20503: EMPTY
20504: EQUAL
20505: OR
20506: IFFALSE 20449
// result := [ ] ;
20508: LD_ADDR_VAR 0 6
20512: PUSH
20513: EMPTY
20514: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_VAR 0 2
20524: PPUSH
20525: LD_VAR 0 3
20529: PPUSH
20530: LD_VAR 0 4
20534: PPUSH
20535: LD_VAR 0 5
20539: PPUSH
20540: CALL_OW 448
20544: IFFALSE 20577
// result := [ chassis , engine , control , weapon ] ;
20546: LD_ADDR_VAR 0 6
20550: PUSH
20551: LD_VAR 0 2
20555: PUSH
20556: LD_VAR 0 3
20560: PUSH
20561: LD_VAR 0 4
20565: PUSH
20566: LD_VAR 0 5
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: ST_TO_ADDR
// end ;
20577: LD_VAR 0 6
20581: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20582: LD_INT 0
20584: PPUSH
// if not chassis or not engine then
20585: LD_VAR 0 1
20589: NOT
20590: IFTRUE 20599
20592: PUSH
20593: LD_VAR 0 2
20597: NOT
20598: OR
20599: IFFALSE 20603
// exit ;
20601: GO 20799
// case engine of engine_solar :
20603: LD_VAR 0 2
20607: PUSH
20608: LD_INT 2
20610: DOUBLE
20611: EQUAL
20612: IFTRUE 20616
20614: GO 20654
20616: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20617: LD_ADDR_VAR 0 3
20621: PUSH
20622: LD_INT 11
20624: PUSH
20625: LD_INT 12
20627: PUSH
20628: LD_INT 13
20630: PUSH
20631: LD_INT 14
20633: PUSH
20634: LD_INT 1
20636: PUSH
20637: LD_INT 2
20639: PUSH
20640: LD_INT 3
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: ST_TO_ADDR
20652: GO 20783
20654: LD_INT 1
20656: DOUBLE
20657: EQUAL
20658: IFTRUE 20662
20660: GO 20724
20662: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20663: LD_ADDR_VAR 0 3
20667: PUSH
20668: LD_INT 11
20670: PUSH
20671: LD_INT 12
20673: PUSH
20674: LD_INT 13
20676: PUSH
20677: LD_INT 14
20679: PUSH
20680: LD_INT 1
20682: PUSH
20683: LD_INT 2
20685: PUSH
20686: LD_INT 3
20688: PUSH
20689: LD_INT 4
20691: PUSH
20692: LD_INT 5
20694: PUSH
20695: LD_INT 21
20697: PUSH
20698: LD_INT 23
20700: PUSH
20701: LD_INT 22
20703: PUSH
20704: LD_INT 24
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: LIST
20713: LIST
20714: LIST
20715: LIST
20716: LIST
20717: LIST
20718: LIST
20719: LIST
20720: LIST
20721: ST_TO_ADDR
20722: GO 20783
20724: LD_INT 3
20726: DOUBLE
20727: EQUAL
20728: IFTRUE 20732
20730: GO 20782
20732: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20733: LD_ADDR_VAR 0 3
20737: PUSH
20738: LD_INT 13
20740: PUSH
20741: LD_INT 14
20743: PUSH
20744: LD_INT 2
20746: PUSH
20747: LD_INT 3
20749: PUSH
20750: LD_INT 4
20752: PUSH
20753: LD_INT 5
20755: PUSH
20756: LD_INT 21
20758: PUSH
20759: LD_INT 22
20761: PUSH
20762: LD_INT 23
20764: PUSH
20765: LD_INT 24
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: LIST
20777: LIST
20778: LIST
20779: ST_TO_ADDR
20780: GO 20783
20782: POP
// result := ( chassis in result ) ;
20783: LD_ADDR_VAR 0 3
20787: PUSH
20788: LD_VAR 0 1
20792: PUSH
20793: LD_VAR 0 3
20797: IN
20798: ST_TO_ADDR
// end ;
20799: LD_VAR 0 3
20803: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20804: LD_INT 0
20806: PPUSH
// if not chassis or not weapon then
20807: LD_VAR 0 1
20811: NOT
20812: IFTRUE 20821
20814: PUSH
20815: LD_VAR 0 2
20819: NOT
20820: OR
20821: IFFALSE 20825
// exit ;
20823: GO 21885
// case weapon of us_machine_gun :
20825: LD_VAR 0 2
20829: PUSH
20830: LD_INT 2
20832: DOUBLE
20833: EQUAL
20834: IFTRUE 20838
20836: GO 20868
20838: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20839: LD_ADDR_VAR 0 3
20843: PUSH
20844: LD_INT 1
20846: PUSH
20847: LD_INT 2
20849: PUSH
20850: LD_INT 3
20852: PUSH
20853: LD_INT 4
20855: PUSH
20856: LD_INT 5
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: LIST
20863: LIST
20864: LIST
20865: ST_TO_ADDR
20866: GO 21869
20868: LD_INT 3
20870: DOUBLE
20871: EQUAL
20872: IFTRUE 20876
20874: GO 20906
20876: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20877: LD_ADDR_VAR 0 3
20881: PUSH
20882: LD_INT 1
20884: PUSH
20885: LD_INT 2
20887: PUSH
20888: LD_INT 3
20890: PUSH
20891: LD_INT 4
20893: PUSH
20894: LD_INT 5
20896: PUSH
20897: EMPTY
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: LIST
20903: ST_TO_ADDR
20904: GO 21869
20906: LD_INT 11
20908: DOUBLE
20909: EQUAL
20910: IFTRUE 20914
20912: GO 20944
20914: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20915: LD_ADDR_VAR 0 3
20919: PUSH
20920: LD_INT 1
20922: PUSH
20923: LD_INT 2
20925: PUSH
20926: LD_INT 3
20928: PUSH
20929: LD_INT 4
20931: PUSH
20932: LD_INT 5
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: ST_TO_ADDR
20942: GO 21869
20944: LD_INT 4
20946: DOUBLE
20947: EQUAL
20948: IFTRUE 20952
20950: GO 20978
20952: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20953: LD_ADDR_VAR 0 3
20957: PUSH
20958: LD_INT 2
20960: PUSH
20961: LD_INT 3
20963: PUSH
20964: LD_INT 4
20966: PUSH
20967: LD_INT 5
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: LIST
20974: LIST
20975: ST_TO_ADDR
20976: GO 21869
20978: LD_INT 5
20980: DOUBLE
20981: EQUAL
20982: IFTRUE 20986
20984: GO 21012
20986: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20987: LD_ADDR_VAR 0 3
20991: PUSH
20992: LD_INT 2
20994: PUSH
20995: LD_INT 3
20997: PUSH
20998: LD_INT 4
21000: PUSH
21001: LD_INT 5
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: ST_TO_ADDR
21010: GO 21869
21012: LD_INT 9
21014: DOUBLE
21015: EQUAL
21016: IFTRUE 21020
21018: GO 21046
21020: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21021: LD_ADDR_VAR 0 3
21025: PUSH
21026: LD_INT 2
21028: PUSH
21029: LD_INT 3
21031: PUSH
21032: LD_INT 4
21034: PUSH
21035: LD_INT 5
21037: PUSH
21038: EMPTY
21039: LIST
21040: LIST
21041: LIST
21042: LIST
21043: ST_TO_ADDR
21044: GO 21869
21046: LD_INT 7
21048: DOUBLE
21049: EQUAL
21050: IFTRUE 21054
21052: GO 21080
21054: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21055: LD_ADDR_VAR 0 3
21059: PUSH
21060: LD_INT 2
21062: PUSH
21063: LD_INT 3
21065: PUSH
21066: LD_INT 4
21068: PUSH
21069: LD_INT 5
21071: PUSH
21072: EMPTY
21073: LIST
21074: LIST
21075: LIST
21076: LIST
21077: ST_TO_ADDR
21078: GO 21869
21080: LD_INT 12
21082: DOUBLE
21083: EQUAL
21084: IFTRUE 21088
21086: GO 21114
21088: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21089: LD_ADDR_VAR 0 3
21093: PUSH
21094: LD_INT 2
21096: PUSH
21097: LD_INT 3
21099: PUSH
21100: LD_INT 4
21102: PUSH
21103: LD_INT 5
21105: PUSH
21106: EMPTY
21107: LIST
21108: LIST
21109: LIST
21110: LIST
21111: ST_TO_ADDR
21112: GO 21869
21114: LD_INT 13
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21122
21120: GO 21148
21122: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21123: LD_ADDR_VAR 0 3
21127: PUSH
21128: LD_INT 2
21130: PUSH
21131: LD_INT 3
21133: PUSH
21134: LD_INT 4
21136: PUSH
21137: LD_INT 5
21139: PUSH
21140: EMPTY
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: ST_TO_ADDR
21146: GO 21869
21148: LD_INT 14
21150: DOUBLE
21151: EQUAL
21152: IFTRUE 21156
21154: GO 21174
21156: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21157: LD_ADDR_VAR 0 3
21161: PUSH
21162: LD_INT 4
21164: PUSH
21165: LD_INT 5
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: ST_TO_ADDR
21172: GO 21869
21174: LD_INT 6
21176: DOUBLE
21177: EQUAL
21178: IFTRUE 21182
21180: GO 21200
21182: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21183: LD_ADDR_VAR 0 3
21187: PUSH
21188: LD_INT 4
21190: PUSH
21191: LD_INT 5
21193: PUSH
21194: EMPTY
21195: LIST
21196: LIST
21197: ST_TO_ADDR
21198: GO 21869
21200: LD_INT 10
21202: DOUBLE
21203: EQUAL
21204: IFTRUE 21208
21206: GO 21226
21208: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21209: LD_ADDR_VAR 0 3
21213: PUSH
21214: LD_INT 4
21216: PUSH
21217: LD_INT 5
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: ST_TO_ADDR
21224: GO 21869
21226: LD_INT 22
21228: DOUBLE
21229: EQUAL
21230: IFTRUE 21234
21232: GO 21260
21234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21235: LD_ADDR_VAR 0 3
21239: PUSH
21240: LD_INT 11
21242: PUSH
21243: LD_INT 12
21245: PUSH
21246: LD_INT 13
21248: PUSH
21249: LD_INT 14
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: LIST
21256: LIST
21257: ST_TO_ADDR
21258: GO 21869
21260: LD_INT 23
21262: DOUBLE
21263: EQUAL
21264: IFTRUE 21268
21266: GO 21294
21268: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21269: LD_ADDR_VAR 0 3
21273: PUSH
21274: LD_INT 11
21276: PUSH
21277: LD_INT 12
21279: PUSH
21280: LD_INT 13
21282: PUSH
21283: LD_INT 14
21285: PUSH
21286: EMPTY
21287: LIST
21288: LIST
21289: LIST
21290: LIST
21291: ST_TO_ADDR
21292: GO 21869
21294: LD_INT 24
21296: DOUBLE
21297: EQUAL
21298: IFTRUE 21302
21300: GO 21328
21302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21303: LD_ADDR_VAR 0 3
21307: PUSH
21308: LD_INT 11
21310: PUSH
21311: LD_INT 12
21313: PUSH
21314: LD_INT 13
21316: PUSH
21317: LD_INT 14
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: ST_TO_ADDR
21326: GO 21869
21328: LD_INT 30
21330: DOUBLE
21331: EQUAL
21332: IFTRUE 21336
21334: GO 21362
21336: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21337: LD_ADDR_VAR 0 3
21341: PUSH
21342: LD_INT 11
21344: PUSH
21345: LD_INT 12
21347: PUSH
21348: LD_INT 13
21350: PUSH
21351: LD_INT 14
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: LIST
21358: LIST
21359: ST_TO_ADDR
21360: GO 21869
21362: LD_INT 25
21364: DOUBLE
21365: EQUAL
21366: IFTRUE 21370
21368: GO 21388
21370: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21371: LD_ADDR_VAR 0 3
21375: PUSH
21376: LD_INT 13
21378: PUSH
21379: LD_INT 14
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: ST_TO_ADDR
21386: GO 21869
21388: LD_INT 27
21390: DOUBLE
21391: EQUAL
21392: IFTRUE 21396
21394: GO 21414
21396: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21397: LD_ADDR_VAR 0 3
21401: PUSH
21402: LD_INT 13
21404: PUSH
21405: LD_INT 14
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: ST_TO_ADDR
21412: GO 21869
21414: LD_INT 92
21416: DOUBLE
21417: EQUAL
21418: IFTRUE 21422
21420: GO 21448
21422: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21423: LD_ADDR_VAR 0 3
21427: PUSH
21428: LD_INT 11
21430: PUSH
21431: LD_INT 12
21433: PUSH
21434: LD_INT 13
21436: PUSH
21437: LD_INT 14
21439: PUSH
21440: EMPTY
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: ST_TO_ADDR
21446: GO 21869
21448: LD_INT 28
21450: DOUBLE
21451: EQUAL
21452: IFTRUE 21456
21454: GO 21474
21456: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21457: LD_ADDR_VAR 0 3
21461: PUSH
21462: LD_INT 13
21464: PUSH
21465: LD_INT 14
21467: PUSH
21468: EMPTY
21469: LIST
21470: LIST
21471: ST_TO_ADDR
21472: GO 21869
21474: LD_INT 29
21476: DOUBLE
21477: EQUAL
21478: IFTRUE 21482
21480: GO 21500
21482: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21483: LD_ADDR_VAR 0 3
21487: PUSH
21488: LD_INT 13
21490: PUSH
21491: LD_INT 14
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: ST_TO_ADDR
21498: GO 21869
21500: LD_INT 31
21502: DOUBLE
21503: EQUAL
21504: IFTRUE 21508
21506: GO 21526
21508: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21509: LD_ADDR_VAR 0 3
21513: PUSH
21514: LD_INT 13
21516: PUSH
21517: LD_INT 14
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: ST_TO_ADDR
21524: GO 21869
21526: LD_INT 26
21528: DOUBLE
21529: EQUAL
21530: IFTRUE 21534
21532: GO 21552
21534: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21535: LD_ADDR_VAR 0 3
21539: PUSH
21540: LD_INT 13
21542: PUSH
21543: LD_INT 14
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: ST_TO_ADDR
21550: GO 21869
21552: LD_INT 42
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21560
21558: GO 21586
21560: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21561: LD_ADDR_VAR 0 3
21565: PUSH
21566: LD_INT 21
21568: PUSH
21569: LD_INT 22
21571: PUSH
21572: LD_INT 23
21574: PUSH
21575: LD_INT 24
21577: PUSH
21578: EMPTY
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: ST_TO_ADDR
21584: GO 21869
21586: LD_INT 43
21588: DOUBLE
21589: EQUAL
21590: IFTRUE 21594
21592: GO 21620
21594: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21595: LD_ADDR_VAR 0 3
21599: PUSH
21600: LD_INT 21
21602: PUSH
21603: LD_INT 22
21605: PUSH
21606: LD_INT 23
21608: PUSH
21609: LD_INT 24
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: LIST
21616: LIST
21617: ST_TO_ADDR
21618: GO 21869
21620: LD_INT 44
21622: DOUBLE
21623: EQUAL
21624: IFTRUE 21628
21626: GO 21654
21628: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21629: LD_ADDR_VAR 0 3
21633: PUSH
21634: LD_INT 21
21636: PUSH
21637: LD_INT 22
21639: PUSH
21640: LD_INT 23
21642: PUSH
21643: LD_INT 24
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: ST_TO_ADDR
21652: GO 21869
21654: LD_INT 45
21656: DOUBLE
21657: EQUAL
21658: IFTRUE 21662
21660: GO 21688
21662: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21663: LD_ADDR_VAR 0 3
21667: PUSH
21668: LD_INT 21
21670: PUSH
21671: LD_INT 22
21673: PUSH
21674: LD_INT 23
21676: PUSH
21677: LD_INT 24
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: ST_TO_ADDR
21686: GO 21869
21688: LD_INT 49
21690: DOUBLE
21691: EQUAL
21692: IFTRUE 21696
21694: GO 21722
21696: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21697: LD_ADDR_VAR 0 3
21701: PUSH
21702: LD_INT 21
21704: PUSH
21705: LD_INT 22
21707: PUSH
21708: LD_INT 23
21710: PUSH
21711: LD_INT 24
21713: PUSH
21714: EMPTY
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: ST_TO_ADDR
21720: GO 21869
21722: LD_INT 51
21724: DOUBLE
21725: EQUAL
21726: IFTRUE 21730
21728: GO 21756
21730: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21731: LD_ADDR_VAR 0 3
21735: PUSH
21736: LD_INT 21
21738: PUSH
21739: LD_INT 22
21741: PUSH
21742: LD_INT 23
21744: PUSH
21745: LD_INT 24
21747: PUSH
21748: EMPTY
21749: LIST
21750: LIST
21751: LIST
21752: LIST
21753: ST_TO_ADDR
21754: GO 21869
21756: LD_INT 52
21758: DOUBLE
21759: EQUAL
21760: IFTRUE 21764
21762: GO 21790
21764: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21765: LD_ADDR_VAR 0 3
21769: PUSH
21770: LD_INT 21
21772: PUSH
21773: LD_INT 22
21775: PUSH
21776: LD_INT 23
21778: PUSH
21779: LD_INT 24
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: LIST
21786: LIST
21787: ST_TO_ADDR
21788: GO 21869
21790: LD_INT 53
21792: DOUBLE
21793: EQUAL
21794: IFTRUE 21798
21796: GO 21816
21798: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21799: LD_ADDR_VAR 0 3
21803: PUSH
21804: LD_INT 23
21806: PUSH
21807: LD_INT 24
21809: PUSH
21810: EMPTY
21811: LIST
21812: LIST
21813: ST_TO_ADDR
21814: GO 21869
21816: LD_INT 46
21818: DOUBLE
21819: EQUAL
21820: IFTRUE 21824
21822: GO 21842
21824: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21825: LD_ADDR_VAR 0 3
21829: PUSH
21830: LD_INT 23
21832: PUSH
21833: LD_INT 24
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: ST_TO_ADDR
21840: GO 21869
21842: LD_INT 47
21844: DOUBLE
21845: EQUAL
21846: IFTRUE 21850
21848: GO 21868
21850: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21851: LD_ADDR_VAR 0 3
21855: PUSH
21856: LD_INT 23
21858: PUSH
21859: LD_INT 24
21861: PUSH
21862: EMPTY
21863: LIST
21864: LIST
21865: ST_TO_ADDR
21866: GO 21869
21868: POP
// result := ( chassis in result ) ;
21869: LD_ADDR_VAR 0 3
21873: PUSH
21874: LD_VAR 0 1
21878: PUSH
21879: LD_VAR 0 3
21883: IN
21884: ST_TO_ADDR
// end ;
21885: LD_VAR 0 3
21889: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21890: LD_INT 0
21892: PPUSH
21893: PPUSH
21894: PPUSH
21895: PPUSH
21896: PPUSH
21897: PPUSH
21898: PPUSH
// result := array ;
21899: LD_ADDR_VAR 0 5
21903: PUSH
21904: LD_VAR 0 1
21908: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21909: LD_VAR 0 1
21913: NOT
21914: IFTRUE 21923
21916: PUSH
21917: LD_VAR 0 2
21921: NOT
21922: OR
21923: IFTRUE 21932
21925: PUSH
21926: LD_VAR 0 3
21930: NOT
21931: OR
21932: IFTRUE 21946
21934: PUSH
21935: LD_VAR 0 2
21939: PUSH
21940: LD_VAR 0 1
21944: GREATER
21945: OR
21946: IFTRUE 21960
21948: PUSH
21949: LD_VAR 0 3
21953: PUSH
21954: LD_VAR 0 1
21958: GREATER
21959: OR
21960: IFFALSE 21964
// exit ;
21962: GO 22260
// if direction then
21964: LD_VAR 0 4
21968: IFFALSE 22032
// begin d := 1 ;
21970: LD_ADDR_VAR 0 9
21974: PUSH
21975: LD_INT 1
21977: ST_TO_ADDR
// if i_from > i_to then
21978: LD_VAR 0 2
21982: PUSH
21983: LD_VAR 0 3
21987: GREATER
21988: IFFALSE 22014
// length := ( array - i_from ) + i_to else
21990: LD_ADDR_VAR 0 11
21994: PUSH
21995: LD_VAR 0 1
21999: PUSH
22000: LD_VAR 0 2
22004: MINUS
22005: PUSH
22006: LD_VAR 0 3
22010: PLUS
22011: ST_TO_ADDR
22012: GO 22030
// length := i_to - i_from ;
22014: LD_ADDR_VAR 0 11
22018: PUSH
22019: LD_VAR 0 3
22023: PUSH
22024: LD_VAR 0 2
22028: MINUS
22029: ST_TO_ADDR
// end else
22030: GO 22093
// begin d := - 1 ;
22032: LD_ADDR_VAR 0 9
22036: PUSH
22037: LD_INT 1
22039: NEG
22040: ST_TO_ADDR
// if i_from > i_to then
22041: LD_VAR 0 2
22045: PUSH
22046: LD_VAR 0 3
22050: GREATER
22051: IFFALSE 22071
// length := i_from - i_to else
22053: LD_ADDR_VAR 0 11
22057: PUSH
22058: LD_VAR 0 2
22062: PUSH
22063: LD_VAR 0 3
22067: MINUS
22068: ST_TO_ADDR
22069: GO 22093
// length := ( array - i_to ) + i_from ;
22071: LD_ADDR_VAR 0 11
22075: PUSH
22076: LD_VAR 0 1
22080: PUSH
22081: LD_VAR 0 3
22085: MINUS
22086: PUSH
22087: LD_VAR 0 2
22091: PLUS
22092: ST_TO_ADDR
// end ; if not length then
22093: LD_VAR 0 11
22097: NOT
22098: IFFALSE 22102
// exit ;
22100: GO 22260
// tmp := array ;
22102: LD_ADDR_VAR 0 10
22106: PUSH
22107: LD_VAR 0 1
22111: ST_TO_ADDR
// for i = 1 to length do
22112: LD_ADDR_VAR 0 6
22116: PUSH
22117: DOUBLE
22118: LD_INT 1
22120: DEC
22121: ST_TO_ADDR
22122: LD_VAR 0 11
22126: PUSH
22127: FOR_TO
22128: IFFALSE 22248
// begin for j = 1 to array do
22130: LD_ADDR_VAR 0 7
22134: PUSH
22135: DOUBLE
22136: LD_INT 1
22138: DEC
22139: ST_TO_ADDR
22140: LD_VAR 0 1
22144: PUSH
22145: FOR_TO
22146: IFFALSE 22234
// begin k := j + d ;
22148: LD_ADDR_VAR 0 8
22152: PUSH
22153: LD_VAR 0 7
22157: PUSH
22158: LD_VAR 0 9
22162: PLUS
22163: ST_TO_ADDR
// if k > array then
22164: LD_VAR 0 8
22168: PUSH
22169: LD_VAR 0 1
22173: GREATER
22174: IFFALSE 22184
// k := 1 ;
22176: LD_ADDR_VAR 0 8
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// if not k then
22184: LD_VAR 0 8
22188: NOT
22189: IFFALSE 22201
// k := array ;
22191: LD_ADDR_VAR 0 8
22195: PUSH
22196: LD_VAR 0 1
22200: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22201: LD_ADDR_VAR 0 10
22205: PUSH
22206: LD_VAR 0 10
22210: PPUSH
22211: LD_VAR 0 8
22215: PPUSH
22216: LD_VAR 0 1
22220: PUSH
22221: LD_VAR 0 7
22225: ARRAY
22226: PPUSH
22227: CALL_OW 1
22231: ST_TO_ADDR
// end ;
22232: GO 22145
22234: POP
22235: POP
// array := tmp ;
22236: LD_ADDR_VAR 0 1
22240: PUSH
22241: LD_VAR 0 10
22245: ST_TO_ADDR
// end ;
22246: GO 22127
22248: POP
22249: POP
// result := array ;
22250: LD_ADDR_VAR 0 5
22254: PUSH
22255: LD_VAR 0 1
22259: ST_TO_ADDR
// end ;
22260: LD_VAR 0 5
22264: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22265: LD_INT 0
22267: PPUSH
22268: PPUSH
// result := 0 ;
22269: LD_ADDR_VAR 0 3
22273: PUSH
22274: LD_INT 0
22276: ST_TO_ADDR
// if not array or not value in array then
22277: LD_VAR 0 1
22281: NOT
22282: IFTRUE 22297
22284: PUSH
22285: LD_VAR 0 2
22289: PUSH
22290: LD_VAR 0 1
22294: IN
22295: NOT
22296: OR
22297: IFFALSE 22301
// exit ;
22299: GO 22355
// for i = 1 to array do
22301: LD_ADDR_VAR 0 4
22305: PUSH
22306: DOUBLE
22307: LD_INT 1
22309: DEC
22310: ST_TO_ADDR
22311: LD_VAR 0 1
22315: PUSH
22316: FOR_TO
22317: IFFALSE 22353
// if value = array [ i ] then
22319: LD_VAR 0 2
22323: PUSH
22324: LD_VAR 0 1
22328: PUSH
22329: LD_VAR 0 4
22333: ARRAY
22334: EQUAL
22335: IFFALSE 22351
// begin result := i ;
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_VAR 0 4
22346: ST_TO_ADDR
// exit ;
22347: POP
22348: POP
22349: GO 22355
// end ;
22351: GO 22316
22353: POP
22354: POP
// end ;
22355: LD_VAR 0 3
22359: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22360: LD_INT 0
22362: PPUSH
// vc_chassis := chassis ;
22363: LD_ADDR_OWVAR 37
22367: PUSH
22368: LD_VAR 0 1
22372: ST_TO_ADDR
// vc_engine := engine ;
22373: LD_ADDR_OWVAR 39
22377: PUSH
22378: LD_VAR 0 2
22382: ST_TO_ADDR
// vc_control := control ;
22383: LD_ADDR_OWVAR 38
22387: PUSH
22388: LD_VAR 0 3
22392: ST_TO_ADDR
// vc_weapon := weapon ;
22393: LD_ADDR_OWVAR 40
22397: PUSH
22398: LD_VAR 0 4
22402: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22403: LD_ADDR_OWVAR 41
22407: PUSH
22408: LD_VAR 0 5
22412: ST_TO_ADDR
// end ;
22413: LD_VAR 0 6
22417: RET
// export function WantPlant ( unit ) ; var task ; begin
22418: LD_INT 0
22420: PPUSH
22421: PPUSH
// result := false ;
22422: LD_ADDR_VAR 0 2
22426: PUSH
22427: LD_INT 0
22429: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22430: LD_ADDR_VAR 0 3
22434: PUSH
22435: LD_VAR 0 1
22439: PPUSH
22440: CALL_OW 437
22444: ST_TO_ADDR
// if task then
22445: LD_VAR 0 3
22449: IFFALSE 22477
// if task [ 1 ] [ 1 ] = p then
22451: LD_VAR 0 3
22455: PUSH
22456: LD_INT 1
22458: ARRAY
22459: PUSH
22460: LD_INT 1
22462: ARRAY
22463: PUSH
22464: LD_STRING p
22466: EQUAL
22467: IFFALSE 22477
// result := true ;
22469: LD_ADDR_VAR 0 2
22473: PUSH
22474: LD_INT 1
22476: ST_TO_ADDR
// end ;
22477: LD_VAR 0 2
22481: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22482: LD_INT 0
22484: PPUSH
22485: PPUSH
22486: PPUSH
22487: PPUSH
// if pos < 1 then
22488: LD_VAR 0 2
22492: PUSH
22493: LD_INT 1
22495: LESS
22496: IFFALSE 22500
// exit ;
22498: GO 22803
// if pos = 1 then
22500: LD_VAR 0 2
22504: PUSH
22505: LD_INT 1
22507: EQUAL
22508: IFFALSE 22541
// result := Replace ( arr , pos [ 1 ] , value ) else
22510: LD_ADDR_VAR 0 4
22514: PUSH
22515: LD_VAR 0 1
22519: PPUSH
22520: LD_VAR 0 2
22524: PUSH
22525: LD_INT 1
22527: ARRAY
22528: PPUSH
22529: LD_VAR 0 3
22533: PPUSH
22534: CALL_OW 1
22538: ST_TO_ADDR
22539: GO 22803
// begin tmp := arr ;
22541: LD_ADDR_VAR 0 6
22545: PUSH
22546: LD_VAR 0 1
22550: ST_TO_ADDR
// s_arr := [ tmp ] ;
22551: LD_ADDR_VAR 0 7
22555: PUSH
22556: LD_VAR 0 6
22560: PUSH
22561: EMPTY
22562: LIST
22563: ST_TO_ADDR
// for i = 1 to pos - 1 do
22564: LD_ADDR_VAR 0 5
22568: PUSH
22569: DOUBLE
22570: LD_INT 1
22572: DEC
22573: ST_TO_ADDR
22574: LD_VAR 0 2
22578: PUSH
22579: LD_INT 1
22581: MINUS
22582: PUSH
22583: FOR_TO
22584: IFFALSE 22629
// begin tmp := tmp [ pos [ i ] ] ;
22586: LD_ADDR_VAR 0 6
22590: PUSH
22591: LD_VAR 0 6
22595: PUSH
22596: LD_VAR 0 2
22600: PUSH
22601: LD_VAR 0 5
22605: ARRAY
22606: ARRAY
22607: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22608: LD_ADDR_VAR 0 7
22612: PUSH
22613: LD_VAR 0 7
22617: PUSH
22618: LD_VAR 0 6
22622: PUSH
22623: EMPTY
22624: LIST
22625: ADD
22626: ST_TO_ADDR
// end ;
22627: GO 22583
22629: POP
22630: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22631: LD_ADDR_VAR 0 6
22635: PUSH
22636: LD_VAR 0 6
22640: PPUSH
22641: LD_VAR 0 2
22645: PUSH
22646: LD_VAR 0 2
22650: ARRAY
22651: PPUSH
22652: LD_VAR 0 3
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22662: LD_ADDR_VAR 0 7
22666: PUSH
22667: LD_VAR 0 7
22671: PPUSH
22672: LD_VAR 0 7
22676: PPUSH
22677: LD_VAR 0 6
22681: PPUSH
22682: CALL_OW 1
22686: ST_TO_ADDR
// for i = s_arr downto 2 do
22687: LD_ADDR_VAR 0 5
22691: PUSH
22692: DOUBLE
22693: LD_VAR 0 7
22697: INC
22698: ST_TO_ADDR
22699: LD_INT 2
22701: PUSH
22702: FOR_DOWNTO
22703: IFFALSE 22787
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22705: LD_ADDR_VAR 0 6
22709: PUSH
22710: LD_VAR 0 7
22714: PUSH
22715: LD_VAR 0 5
22719: PUSH
22720: LD_INT 1
22722: MINUS
22723: ARRAY
22724: PPUSH
22725: LD_VAR 0 2
22729: PUSH
22730: LD_VAR 0 5
22734: PUSH
22735: LD_INT 1
22737: MINUS
22738: ARRAY
22739: PPUSH
22740: LD_VAR 0 7
22744: PUSH
22745: LD_VAR 0 5
22749: ARRAY
22750: PPUSH
22751: CALL_OW 1
22755: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22756: LD_ADDR_VAR 0 7
22760: PUSH
22761: LD_VAR 0 7
22765: PPUSH
22766: LD_VAR 0 5
22770: PUSH
22771: LD_INT 1
22773: MINUS
22774: PPUSH
22775: LD_VAR 0 6
22779: PPUSH
22780: CALL_OW 1
22784: ST_TO_ADDR
// end ;
22785: GO 22702
22787: POP
22788: POP
// result := s_arr [ 1 ] ;
22789: LD_ADDR_VAR 0 4
22793: PUSH
22794: LD_VAR 0 7
22798: PUSH
22799: LD_INT 1
22801: ARRAY
22802: ST_TO_ADDR
// end ; end ;
22803: LD_VAR 0 4
22807: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22808: LD_INT 0
22810: PPUSH
22811: PPUSH
// if not list then
22812: LD_VAR 0 1
22816: NOT
22817: IFFALSE 22821
// exit ;
22819: GO 22912
// i := list [ pos1 ] ;
22821: LD_ADDR_VAR 0 5
22825: PUSH
22826: LD_VAR 0 1
22830: PUSH
22831: LD_VAR 0 2
22835: ARRAY
22836: ST_TO_ADDR
// if not i then
22837: LD_VAR 0 5
22841: NOT
22842: IFFALSE 22846
// exit ;
22844: GO 22912
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22846: LD_ADDR_VAR 0 1
22850: PUSH
22851: LD_VAR 0 1
22855: PPUSH
22856: LD_VAR 0 2
22860: PPUSH
22861: LD_VAR 0 1
22865: PUSH
22866: LD_VAR 0 3
22870: ARRAY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22877: LD_ADDR_VAR 0 1
22881: PUSH
22882: LD_VAR 0 1
22886: PPUSH
22887: LD_VAR 0 3
22891: PPUSH
22892: LD_VAR 0 5
22896: PPUSH
22897: CALL_OW 1
22901: ST_TO_ADDR
// result := list ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 1
22911: ST_TO_ADDR
// end ;
22912: LD_VAR 0 4
22916: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22917: LD_INT 0
22919: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22920: LD_ADDR_VAR 0 5
22924: PUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 250
22934: PPUSH
22935: LD_VAR 0 1
22939: PPUSH
22940: CALL_OW 251
22944: PPUSH
22945: LD_VAR 0 2
22949: PPUSH
22950: LD_VAR 0 3
22954: PPUSH
22955: LD_VAR 0 4
22959: PPUSH
22960: CALL 23342 0 5
22964: ST_TO_ADDR
// end ;
22965: LD_VAR 0 5
22969: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
22970: LD_INT 0
22972: PPUSH
22973: PPUSH
22974: PPUSH
22975: PPUSH
// if not list or not unit then
22976: LD_VAR 0 2
22980: NOT
22981: IFTRUE 22990
22983: PUSH
22984: LD_VAR 0 1
22988: NOT
22989: OR
22990: IFFALSE 22994
// exit ;
22992: GO 23337
// result := [ ] ;
22994: LD_ADDR_VAR 0 5
22998: PUSH
22999: EMPTY
23000: ST_TO_ADDR
// for i in list do
23001: LD_ADDR_VAR 0 6
23005: PUSH
23006: LD_VAR 0 2
23010: PUSH
23011: FOR_IN
23012: IFFALSE 23230
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
23014: LD_ADDR_VAR 0 8
23018: PUSH
23019: LD_VAR 0 1
23023: PPUSH
23024: LD_VAR 0 6
23028: PUSH
23029: LD_INT 1
23031: ARRAY
23032: PPUSH
23033: LD_VAR 0 6
23037: PUSH
23038: LD_INT 2
23040: ARRAY
23041: PPUSH
23042: CALL_OW 297
23046: ST_TO_ADDR
// if not Count ( result ) then
23047: LD_VAR 0 5
23051: PPUSH
23052: CALL 19598 0 1
23056: NOT
23057: IFFALSE 23090
// begin result := Join ( result , [ i , tmp ] ) ;
23059: LD_ADDR_VAR 0 5
23063: PUSH
23064: LD_VAR 0 5
23068: PPUSH
23069: LD_VAR 0 6
23073: PUSH
23074: LD_VAR 0 8
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PPUSH
23083: CALL 55530 0 2
23087: ST_TO_ADDR
// continue ;
23088: GO 23011
// end ; if result [ result ] [ 2 ] <= tmp then
23090: LD_VAR 0 5
23094: PUSH
23095: LD_VAR 0 5
23099: ARRAY
23100: PUSH
23101: LD_INT 2
23103: ARRAY
23104: PUSH
23105: LD_VAR 0 8
23109: LESSEQUAL
23110: IFFALSE 23143
// result := Join ( result , [ i , tmp ] ) else
23112: LD_ADDR_VAR 0 5
23116: PUSH
23117: LD_VAR 0 5
23121: PPUSH
23122: LD_VAR 0 6
23126: PUSH
23127: LD_VAR 0 8
23131: PUSH
23132: EMPTY
23133: LIST
23134: LIST
23135: PPUSH
23136: CALL 55530 0 2
23140: ST_TO_ADDR
23141: GO 23228
// begin for j := 1 to Count ( result ) do
23143: LD_ADDR_VAR 0 7
23147: PUSH
23148: DOUBLE
23149: LD_INT 1
23151: DEC
23152: ST_TO_ADDR
23153: LD_VAR 0 5
23157: PPUSH
23158: CALL 19598 0 1
23162: PUSH
23163: FOR_TO
23164: IFFALSE 23226
// begin if tmp < result [ j ] [ 2 ] then
23166: LD_VAR 0 8
23170: PUSH
23171: LD_VAR 0 5
23175: PUSH
23176: LD_VAR 0 7
23180: ARRAY
23181: PUSH
23182: LD_INT 2
23184: ARRAY
23185: LESS
23186: IFFALSE 23224
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23188: LD_ADDR_VAR 0 5
23192: PUSH
23193: LD_VAR 0 5
23197: PPUSH
23198: LD_VAR 0 7
23202: PPUSH
23203: LD_VAR 0 6
23207: PUSH
23208: LD_VAR 0 8
23212: PUSH
23213: EMPTY
23214: LIST
23215: LIST
23216: PPUSH
23217: CALL_OW 2
23221: ST_TO_ADDR
// break ;
23222: GO 23226
// end ; end ;
23224: GO 23163
23226: POP
23227: POP
// end ; end ;
23228: GO 23011
23230: POP
23231: POP
// if result and not asc then
23232: LD_VAR 0 5
23236: IFFALSE 23245
23238: PUSH
23239: LD_VAR 0 3
23243: NOT
23244: AND
23245: IFFALSE 23262
// result := ReverseArray ( result ) ;
23247: LD_ADDR_VAR 0 5
23251: PUSH
23252: LD_VAR 0 5
23256: PPUSH
23257: CALL 50620 0 1
23261: ST_TO_ADDR
// tmp := [ ] ;
23262: LD_ADDR_VAR 0 8
23266: PUSH
23267: EMPTY
23268: ST_TO_ADDR
// if mode then
23269: LD_VAR 0 4
23273: IFFALSE 23337
// begin for i := 1 to result do
23275: LD_ADDR_VAR 0 6
23279: PUSH
23280: DOUBLE
23281: LD_INT 1
23283: DEC
23284: ST_TO_ADDR
23285: LD_VAR 0 5
23289: PUSH
23290: FOR_TO
23291: IFFALSE 23325
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23293: LD_ADDR_VAR 0 8
23297: PUSH
23298: LD_VAR 0 8
23302: PPUSH
23303: LD_VAR 0 5
23307: PUSH
23308: LD_VAR 0 6
23312: ARRAY
23313: PUSH
23314: LD_INT 1
23316: ARRAY
23317: PPUSH
23318: CALL 55530 0 2
23322: ST_TO_ADDR
23323: GO 23290
23325: POP
23326: POP
// result := tmp ;
23327: LD_ADDR_VAR 0 5
23331: PUSH
23332: LD_VAR 0 8
23336: ST_TO_ADDR
// end ; end ;
23337: LD_VAR 0 5
23341: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23342: LD_INT 0
23344: PPUSH
23345: PPUSH
23346: PPUSH
23347: PPUSH
// if not list then
23348: LD_VAR 0 3
23352: NOT
23353: IFFALSE 23357
// exit ;
23355: GO 23747
// result := [ ] ;
23357: LD_ADDR_VAR 0 6
23361: PUSH
23362: EMPTY
23363: ST_TO_ADDR
// for i in list do
23364: LD_ADDR_VAR 0 7
23368: PUSH
23369: LD_VAR 0 3
23373: PUSH
23374: FOR_IN
23375: IFFALSE 23577
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23377: LD_ADDR_VAR 0 9
23381: PUSH
23382: LD_VAR 0 7
23386: PPUSH
23387: LD_VAR 0 1
23391: PPUSH
23392: LD_VAR 0 2
23396: PPUSH
23397: CALL_OW 297
23401: ST_TO_ADDR
// if not result then
23402: LD_VAR 0 6
23406: NOT
23407: IFFALSE 23433
// result := [ [ i , tmp ] ] else
23409: LD_ADDR_VAR 0 6
23413: PUSH
23414: LD_VAR 0 7
23418: PUSH
23419: LD_VAR 0 9
23423: PUSH
23424: EMPTY
23425: LIST
23426: LIST
23427: PUSH
23428: EMPTY
23429: LIST
23430: ST_TO_ADDR
23431: GO 23575
// begin if result [ result ] [ 2 ] <= tmp then
23433: LD_VAR 0 6
23437: PUSH
23438: LD_VAR 0 6
23442: ARRAY
23443: PUSH
23444: LD_INT 2
23446: ARRAY
23447: PUSH
23448: LD_VAR 0 9
23452: LESSEQUAL
23453: IFFALSE 23495
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23455: LD_ADDR_VAR 0 6
23459: PUSH
23460: LD_VAR 0 6
23464: PPUSH
23465: LD_VAR 0 6
23469: PUSH
23470: LD_INT 1
23472: PLUS
23473: PPUSH
23474: LD_VAR 0 7
23478: PUSH
23479: LD_VAR 0 9
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: PPUSH
23488: CALL_OW 2
23492: ST_TO_ADDR
23493: GO 23575
// for j := 1 to result do
23495: LD_ADDR_VAR 0 8
23499: PUSH
23500: DOUBLE
23501: LD_INT 1
23503: DEC
23504: ST_TO_ADDR
23505: LD_VAR 0 6
23509: PUSH
23510: FOR_TO
23511: IFFALSE 23573
// begin if tmp < result [ j ] [ 2 ] then
23513: LD_VAR 0 9
23517: PUSH
23518: LD_VAR 0 6
23522: PUSH
23523: LD_VAR 0 8
23527: ARRAY
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: LESS
23533: IFFALSE 23571
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23535: LD_ADDR_VAR 0 6
23539: PUSH
23540: LD_VAR 0 6
23544: PPUSH
23545: LD_VAR 0 8
23549: PPUSH
23550: LD_VAR 0 7
23554: PUSH
23555: LD_VAR 0 9
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PPUSH
23564: CALL_OW 2
23568: ST_TO_ADDR
// break ;
23569: GO 23573
// end ; end ;
23571: GO 23510
23573: POP
23574: POP
// end ; end ;
23575: GO 23374
23577: POP
23578: POP
// if result and not asc then
23579: LD_VAR 0 6
23583: IFFALSE 23592
23585: PUSH
23586: LD_VAR 0 4
23590: NOT
23591: AND
23592: IFFALSE 23667
// begin tmp := result ;
23594: LD_ADDR_VAR 0 9
23598: PUSH
23599: LD_VAR 0 6
23603: ST_TO_ADDR
// for i = tmp downto 1 do
23604: LD_ADDR_VAR 0 7
23608: PUSH
23609: DOUBLE
23610: LD_VAR 0 9
23614: INC
23615: ST_TO_ADDR
23616: LD_INT 1
23618: PUSH
23619: FOR_DOWNTO
23620: IFFALSE 23665
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23622: LD_ADDR_VAR 0 6
23626: PUSH
23627: LD_VAR 0 6
23631: PPUSH
23632: LD_VAR 0 9
23636: PUSH
23637: LD_VAR 0 7
23641: MINUS
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: PPUSH
23647: LD_VAR 0 9
23651: PUSH
23652: LD_VAR 0 7
23656: ARRAY
23657: PPUSH
23658: CALL_OW 1
23662: ST_TO_ADDR
23663: GO 23619
23665: POP
23666: POP
// end ; tmp := [ ] ;
23667: LD_ADDR_VAR 0 9
23671: PUSH
23672: EMPTY
23673: ST_TO_ADDR
// if mode then
23674: LD_VAR 0 5
23678: IFFALSE 23747
// begin for i = 1 to result do
23680: LD_ADDR_VAR 0 7
23684: PUSH
23685: DOUBLE
23686: LD_INT 1
23688: DEC
23689: ST_TO_ADDR
23690: LD_VAR 0 6
23694: PUSH
23695: FOR_TO
23696: IFFALSE 23735
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23698: LD_ADDR_VAR 0 9
23702: PUSH
23703: LD_VAR 0 9
23707: PPUSH
23708: LD_VAR 0 7
23712: PPUSH
23713: LD_VAR 0 6
23717: PUSH
23718: LD_VAR 0 7
23722: ARRAY
23723: PUSH
23724: LD_INT 1
23726: ARRAY
23727: PPUSH
23728: CALL_OW 1
23732: ST_TO_ADDR
23733: GO 23695
23735: POP
23736: POP
// result := tmp ;
23737: LD_ADDR_VAR 0 6
23741: PUSH
23742: LD_VAR 0 9
23746: ST_TO_ADDR
// end ; end ;
23747: LD_VAR 0 6
23751: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23752: LD_INT 0
23754: PPUSH
23755: PPUSH
23756: PPUSH
23757: PPUSH
23758: PPUSH
23759: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23760: LD_ADDR_VAR 0 5
23764: PUSH
23765: LD_INT 0
23767: PUSH
23768: LD_INT 0
23770: PUSH
23771: LD_INT 0
23773: PUSH
23774: EMPTY
23775: PUSH
23776: EMPTY
23777: LIST
23778: LIST
23779: LIST
23780: LIST
23781: ST_TO_ADDR
// if not x or not y then
23782: LD_VAR 0 2
23786: NOT
23787: IFTRUE 23796
23789: PUSH
23790: LD_VAR 0 3
23794: NOT
23795: OR
23796: IFFALSE 23800
// exit ;
23798: GO 25456
// if not range then
23800: LD_VAR 0 4
23804: NOT
23805: IFFALSE 23815
// range := 10 ;
23807: LD_ADDR_VAR 0 4
23811: PUSH
23812: LD_INT 10
23814: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23815: LD_ADDR_VAR 0 8
23819: PUSH
23820: LD_INT 81
23822: PUSH
23823: LD_VAR 0 1
23827: PUSH
23828: EMPTY
23829: LIST
23830: LIST
23831: PUSH
23832: LD_INT 92
23834: PUSH
23835: LD_VAR 0 2
23839: PUSH
23840: LD_VAR 0 3
23844: PUSH
23845: LD_VAR 0 4
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: LIST
23854: LIST
23855: PUSH
23856: LD_INT 3
23858: PUSH
23859: LD_INT 21
23861: PUSH
23862: LD_INT 3
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: LIST
23877: PPUSH
23878: CALL_OW 69
23882: ST_TO_ADDR
// if not tmp then
23883: LD_VAR 0 8
23887: NOT
23888: IFFALSE 23892
// exit ;
23890: GO 25456
// for i in tmp do
23892: LD_ADDR_VAR 0 6
23896: PUSH
23897: LD_VAR 0 8
23901: PUSH
23902: FOR_IN
23903: IFFALSE 25431
// begin points := [ 0 , 0 , 0 ] ;
23905: LD_ADDR_VAR 0 9
23909: PUSH
23910: LD_INT 0
23912: PUSH
23913: LD_INT 0
23915: PUSH
23916: LD_INT 0
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: LIST
23923: ST_TO_ADDR
// bpoints := 1 ;
23924: LD_ADDR_VAR 0 10
23928: PUSH
23929: LD_INT 1
23931: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23932: LD_VAR 0 6
23936: PPUSH
23937: CALL_OW 247
23941: PUSH
23942: LD_INT 1
23944: DOUBLE
23945: EQUAL
23946: IFTRUE 23950
23948: GO 24532
23950: POP
// begin if GetClass ( i ) = 1 then
23951: LD_VAR 0 6
23955: PPUSH
23956: CALL_OW 257
23960: PUSH
23961: LD_INT 1
23963: EQUAL
23964: IFFALSE 23985
// points := [ 10 , 5 , 3 ] ;
23966: LD_ADDR_VAR 0 9
23970: PUSH
23971: LD_INT 10
23973: PUSH
23974: LD_INT 5
23976: PUSH
23977: LD_INT 3
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: LIST
23984: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23985: LD_VAR 0 6
23989: PPUSH
23990: CALL_OW 257
23994: PUSH
23995: LD_INT 2
23997: PUSH
23998: LD_INT 3
24000: PUSH
24001: LD_INT 4
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: LIST
24008: IN
24009: IFFALSE 24030
// points := [ 3 , 2 , 1 ] ;
24011: LD_ADDR_VAR 0 9
24015: PUSH
24016: LD_INT 3
24018: PUSH
24019: LD_INT 2
24021: PUSH
24022: LD_INT 1
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: LIST
24029: ST_TO_ADDR
// if GetClass ( i ) = 5 then
24030: LD_VAR 0 6
24034: PPUSH
24035: CALL_OW 257
24039: PUSH
24040: LD_INT 5
24042: EQUAL
24043: IFFALSE 24064
// points := [ 130 , 5 , 2 ] ;
24045: LD_ADDR_VAR 0 9
24049: PUSH
24050: LD_INT 130
24052: PUSH
24053: LD_INT 5
24055: PUSH
24056: LD_INT 2
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: LIST
24063: ST_TO_ADDR
// if GetClass ( i ) = 8 then
24064: LD_VAR 0 6
24068: PPUSH
24069: CALL_OW 257
24073: PUSH
24074: LD_INT 8
24076: EQUAL
24077: IFFALSE 24098
// points := [ 35 , 35 , 30 ] ;
24079: LD_ADDR_VAR 0 9
24083: PUSH
24084: LD_INT 35
24086: PUSH
24087: LD_INT 35
24089: PUSH
24090: LD_INT 30
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: LIST
24097: ST_TO_ADDR
// if GetClass ( i ) = 9 then
24098: LD_VAR 0 6
24102: PPUSH
24103: CALL_OW 257
24107: PUSH
24108: LD_INT 9
24110: EQUAL
24111: IFFALSE 24132
// points := [ 20 , 55 , 40 ] ;
24113: LD_ADDR_VAR 0 9
24117: PUSH
24118: LD_INT 20
24120: PUSH
24121: LD_INT 55
24123: PUSH
24124: LD_INT 40
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
24132: LD_VAR 0 6
24136: PPUSH
24137: CALL_OW 257
24141: PUSH
24142: LD_INT 12
24144: PUSH
24145: LD_INT 16
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: IN
24152: IFFALSE 24173
// points := [ 5 , 3 , 2 ] ;
24154: LD_ADDR_VAR 0 9
24158: PUSH
24159: LD_INT 5
24161: PUSH
24162: LD_INT 3
24164: PUSH
24165: LD_INT 2
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: ST_TO_ADDR
// if GetClass ( i ) = 17 then
24173: LD_VAR 0 6
24177: PPUSH
24178: CALL_OW 257
24182: PUSH
24183: LD_INT 17
24185: EQUAL
24186: IFFALSE 24207
// points := [ 100 , 50 , 75 ] ;
24188: LD_ADDR_VAR 0 9
24192: PUSH
24193: LD_INT 100
24195: PUSH
24196: LD_INT 50
24198: PUSH
24199: LD_INT 75
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: LIST
24206: ST_TO_ADDR
// if GetClass ( i ) = 15 then
24207: LD_VAR 0 6
24211: PPUSH
24212: CALL_OW 257
24216: PUSH
24217: LD_INT 15
24219: EQUAL
24220: IFFALSE 24241
// points := [ 10 , 5 , 3 ] ;
24222: LD_ADDR_VAR 0 9
24226: PUSH
24227: LD_INT 10
24229: PUSH
24230: LD_INT 5
24232: PUSH
24233: LD_INT 3
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: LIST
24240: ST_TO_ADDR
// if GetClass ( i ) = 14 then
24241: LD_VAR 0 6
24245: PPUSH
24246: CALL_OW 257
24250: PUSH
24251: LD_INT 14
24253: EQUAL
24254: IFFALSE 24275
// points := [ 10 , 0 , 0 ] ;
24256: LD_ADDR_VAR 0 9
24260: PUSH
24261: LD_INT 10
24263: PUSH
24264: LD_INT 0
24266: PUSH
24267: LD_INT 0
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24275: LD_VAR 0 6
24279: PPUSH
24280: CALL_OW 257
24284: PUSH
24285: LD_INT 11
24287: EQUAL
24288: IFFALSE 24309
// points := [ 30 , 10 , 5 ] ;
24290: LD_ADDR_VAR 0 9
24294: PUSH
24295: LD_INT 30
24297: PUSH
24298: LD_INT 10
24300: PUSH
24301: LD_INT 5
24303: PUSH
24304: EMPTY
24305: LIST
24306: LIST
24307: LIST
24308: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24309: LD_VAR 0 1
24313: PPUSH
24314: LD_INT 5
24316: PPUSH
24317: CALL_OW 321
24321: PUSH
24322: LD_INT 2
24324: EQUAL
24325: IFFALSE 24342
// bpoints := bpoints * 1.8 ;
24327: LD_ADDR_VAR 0 10
24331: PUSH
24332: LD_VAR 0 10
24336: PUSH
24337: LD_REAL  1.80000000000000E+0000
24340: MUL
24341: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24342: LD_VAR 0 6
24346: PPUSH
24347: CALL_OW 257
24351: PUSH
24352: LD_INT 1
24354: PUSH
24355: LD_INT 2
24357: PUSH
24358: LD_INT 3
24360: PUSH
24361: LD_INT 4
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: IN
24370: IFFALSE 24390
24372: PUSH
24373: LD_VAR 0 1
24377: PPUSH
24378: LD_INT 51
24380: PPUSH
24381: CALL_OW 321
24385: PUSH
24386: LD_INT 2
24388: EQUAL
24389: AND
24390: IFFALSE 24407
// bpoints := bpoints * 1.2 ;
24392: LD_ADDR_VAR 0 10
24396: PUSH
24397: LD_VAR 0 10
24401: PUSH
24402: LD_REAL  1.20000000000000E+0000
24405: MUL
24406: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24407: LD_VAR 0 6
24411: PPUSH
24412: CALL_OW 257
24416: PUSH
24417: LD_INT 5
24419: PUSH
24420: LD_INT 7
24422: PUSH
24423: LD_INT 9
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: LIST
24430: IN
24431: IFFALSE 24451
24433: PUSH
24434: LD_VAR 0 1
24438: PPUSH
24439: LD_INT 52
24441: PPUSH
24442: CALL_OW 321
24446: PUSH
24447: LD_INT 2
24449: EQUAL
24450: AND
24451: IFFALSE 24468
// bpoints := bpoints * 1.5 ;
24453: LD_ADDR_VAR 0 10
24457: PUSH
24458: LD_VAR 0 10
24462: PUSH
24463: LD_REAL  1.50000000000000E+0000
24466: MUL
24467: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24468: LD_VAR 0 1
24472: PPUSH
24473: LD_INT 66
24475: PPUSH
24476: CALL_OW 321
24480: PUSH
24481: LD_INT 2
24483: EQUAL
24484: IFFALSE 24501
// bpoints := bpoints * 1.1 ;
24486: LD_ADDR_VAR 0 10
24490: PUSH
24491: LD_VAR 0 10
24495: PUSH
24496: LD_REAL  1.10000000000000E+0000
24499: MUL
24500: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24501: LD_ADDR_VAR 0 10
24505: PUSH
24506: LD_VAR 0 10
24510: PUSH
24511: LD_VAR 0 6
24515: PPUSH
24516: LD_INT 1
24518: PPUSH
24519: CALL_OW 259
24523: PUSH
24524: LD_REAL  1.15000000000000E+0000
24527: MUL
24528: MUL
24529: ST_TO_ADDR
// end ; unit_vehicle :
24530: GO 25360
24532: LD_INT 2
24534: DOUBLE
24535: EQUAL
24536: IFTRUE 24540
24538: GO 25348
24540: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24541: LD_VAR 0 6
24545: PPUSH
24546: CALL_OW 264
24550: PUSH
24551: LD_INT 2
24553: PUSH
24554: LD_INT 42
24556: PUSH
24557: LD_INT 24
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: LIST
24564: IN
24565: IFFALSE 24586
// points := [ 25 , 5 , 3 ] ;
24567: LD_ADDR_VAR 0 9
24571: PUSH
24572: LD_INT 25
24574: PUSH
24575: LD_INT 5
24577: PUSH
24578: LD_INT 3
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: LIST
24585: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24586: LD_VAR 0 6
24590: PPUSH
24591: CALL_OW 264
24595: PUSH
24596: LD_INT 4
24598: PUSH
24599: LD_INT 43
24601: PUSH
24602: LD_INT 25
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: LIST
24609: IN
24610: IFFALSE 24631
// points := [ 40 , 15 , 5 ] ;
24612: LD_ADDR_VAR 0 9
24616: PUSH
24617: LD_INT 40
24619: PUSH
24620: LD_INT 15
24622: PUSH
24623: LD_INT 5
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: LIST
24630: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24631: LD_VAR 0 6
24635: PPUSH
24636: CALL_OW 264
24640: PUSH
24641: LD_INT 3
24643: PUSH
24644: LD_INT 23
24646: PUSH
24647: EMPTY
24648: LIST
24649: LIST
24650: IN
24651: IFFALSE 24672
// points := [ 7 , 25 , 8 ] ;
24653: LD_ADDR_VAR 0 9
24657: PUSH
24658: LD_INT 7
24660: PUSH
24661: LD_INT 25
24663: PUSH
24664: LD_INT 8
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: LIST
24671: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24672: LD_VAR 0 6
24676: PPUSH
24677: CALL_OW 264
24681: PUSH
24682: LD_INT 5
24684: PUSH
24685: LD_INT 27
24687: PUSH
24688: LD_INT 44
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: LIST
24695: IN
24696: IFFALSE 24717
// points := [ 14 , 50 , 16 ] ;
24698: LD_ADDR_VAR 0 9
24702: PUSH
24703: LD_INT 14
24705: PUSH
24706: LD_INT 50
24708: PUSH
24709: LD_INT 16
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: LIST
24716: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24717: LD_VAR 0 6
24721: PPUSH
24722: CALL_OW 264
24726: PUSH
24727: LD_INT 6
24729: PUSH
24730: LD_INT 46
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: IN
24737: IFFALSE 24758
// points := [ 32 , 120 , 70 ] ;
24739: LD_ADDR_VAR 0 9
24743: PUSH
24744: LD_INT 32
24746: PUSH
24747: LD_INT 120
24749: PUSH
24750: LD_INT 70
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: LIST
24757: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24758: LD_VAR 0 6
24762: PPUSH
24763: CALL_OW 264
24767: PUSH
24768: LD_INT 7
24770: PUSH
24771: LD_INT 28
24773: PUSH
24774: LD_INT 45
24776: PUSH
24777: LD_INT 92
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: IN
24786: IFFALSE 24807
// points := [ 35 , 20 , 45 ] ;
24788: LD_ADDR_VAR 0 9
24792: PUSH
24793: LD_INT 35
24795: PUSH
24796: LD_INT 20
24798: PUSH
24799: LD_INT 45
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: LIST
24806: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24807: LD_VAR 0 6
24811: PPUSH
24812: CALL_OW 264
24816: PUSH
24817: LD_INT 47
24819: PUSH
24820: EMPTY
24821: LIST
24822: IN
24823: IFFALSE 24844
// points := [ 67 , 45 , 75 ] ;
24825: LD_ADDR_VAR 0 9
24829: PUSH
24830: LD_INT 67
24832: PUSH
24833: LD_INT 45
24835: PUSH
24836: LD_INT 75
24838: PUSH
24839: EMPTY
24840: LIST
24841: LIST
24842: LIST
24843: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24844: LD_VAR 0 6
24848: PPUSH
24849: CALL_OW 264
24853: PUSH
24854: LD_INT 26
24856: PUSH
24857: EMPTY
24858: LIST
24859: IN
24860: IFFALSE 24881
// points := [ 120 , 30 , 80 ] ;
24862: LD_ADDR_VAR 0 9
24866: PUSH
24867: LD_INT 120
24869: PUSH
24870: LD_INT 30
24872: PUSH
24873: LD_INT 80
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: LIST
24880: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24881: LD_VAR 0 6
24885: PPUSH
24886: CALL_OW 264
24890: PUSH
24891: LD_INT 22
24893: PUSH
24894: EMPTY
24895: LIST
24896: IN
24897: IFFALSE 24918
// points := [ 40 , 1 , 1 ] ;
24899: LD_ADDR_VAR 0 9
24903: PUSH
24904: LD_INT 40
24906: PUSH
24907: LD_INT 1
24909: PUSH
24910: LD_INT 1
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: LIST
24917: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24918: LD_VAR 0 6
24922: PPUSH
24923: CALL_OW 264
24927: PUSH
24928: LD_INT 29
24930: PUSH
24931: EMPTY
24932: LIST
24933: IN
24934: IFFALSE 24955
// points := [ 70 , 200 , 400 ] ;
24936: LD_ADDR_VAR 0 9
24940: PUSH
24941: LD_INT 70
24943: PUSH
24944: LD_INT 200
24946: PUSH
24947: LD_INT 400
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: LIST
24954: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24955: LD_VAR 0 6
24959: PPUSH
24960: CALL_OW 264
24964: PUSH
24965: LD_INT 14
24967: PUSH
24968: LD_INT 53
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: IN
24975: IFFALSE 24996
// points := [ 40 , 10 , 20 ] ;
24977: LD_ADDR_VAR 0 9
24981: PUSH
24982: LD_INT 40
24984: PUSH
24985: LD_INT 10
24987: PUSH
24988: LD_INT 20
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: LIST
24995: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24996: LD_VAR 0 6
25000: PPUSH
25001: CALL_OW 264
25005: PUSH
25006: LD_INT 9
25008: PUSH
25009: EMPTY
25010: LIST
25011: IN
25012: IFFALSE 25033
// points := [ 5 , 70 , 20 ] ;
25014: LD_ADDR_VAR 0 9
25018: PUSH
25019: LD_INT 5
25021: PUSH
25022: LD_INT 70
25024: PUSH
25025: LD_INT 20
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: LIST
25032: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
25033: LD_VAR 0 6
25037: PPUSH
25038: CALL_OW 264
25042: PUSH
25043: LD_INT 10
25045: PUSH
25046: EMPTY
25047: LIST
25048: IN
25049: IFFALSE 25070
// points := [ 35 , 110 , 70 ] ;
25051: LD_ADDR_VAR 0 9
25055: PUSH
25056: LD_INT 35
25058: PUSH
25059: LD_INT 110
25061: PUSH
25062: LD_INT 70
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
25070: LD_VAR 0 6
25074: PPUSH
25075: CALL_OW 265
25079: PUSH
25080: LD_INT 25
25082: EQUAL
25083: IFFALSE 25104
// points := [ 80 , 65 , 100 ] ;
25085: LD_ADDR_VAR 0 9
25089: PUSH
25090: LD_INT 80
25092: PUSH
25093: LD_INT 65
25095: PUSH
25096: LD_INT 100
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: LIST
25103: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
25104: LD_VAR 0 6
25108: PPUSH
25109: CALL_OW 263
25113: PUSH
25114: LD_INT 1
25116: EQUAL
25117: IFFALSE 25152
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
25119: LD_ADDR_VAR 0 10
25123: PUSH
25124: LD_VAR 0 10
25128: PUSH
25129: LD_VAR 0 6
25133: PPUSH
25134: CALL_OW 311
25138: PPUSH
25139: LD_INT 3
25141: PPUSH
25142: CALL_OW 259
25146: PUSH
25147: LD_INT 4
25149: MUL
25150: MUL
25151: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
25152: LD_VAR 0 6
25156: PPUSH
25157: CALL_OW 263
25161: PUSH
25162: LD_INT 2
25164: EQUAL
25165: IFFALSE 25216
// begin j := IsControledBy ( i ) ;
25167: LD_ADDR_VAR 0 7
25171: PUSH
25172: LD_VAR 0 6
25176: PPUSH
25177: CALL_OW 312
25181: ST_TO_ADDR
// if j then
25182: LD_VAR 0 7
25186: IFFALSE 25216
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
25188: LD_ADDR_VAR 0 10
25192: PUSH
25193: LD_VAR 0 10
25197: PUSH
25198: LD_VAR 0 7
25202: PPUSH
25203: LD_INT 3
25205: PPUSH
25206: CALL_OW 259
25210: PUSH
25211: LD_INT 3
25213: MUL
25214: MUL
25215: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
25216: LD_VAR 0 6
25220: PPUSH
25221: CALL_OW 264
25225: PUSH
25226: LD_INT 5
25228: PUSH
25229: LD_INT 6
25231: PUSH
25232: LD_INT 46
25234: PUSH
25235: LD_INT 44
25237: PUSH
25238: LD_INT 47
25240: PUSH
25241: LD_INT 45
25243: PUSH
25244: LD_INT 28
25246: PUSH
25247: LD_INT 7
25249: PUSH
25250: LD_INT 27
25252: PUSH
25253: LD_INT 29
25255: PUSH
25256: EMPTY
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: IN
25268: IFFALSE 25288
25270: PUSH
25271: LD_VAR 0 1
25275: PPUSH
25276: LD_INT 52
25278: PPUSH
25279: CALL_OW 321
25283: PUSH
25284: LD_INT 2
25286: EQUAL
25287: AND
25288: IFFALSE 25305
// bpoints := bpoints * 1.2 ;
25290: LD_ADDR_VAR 0 10
25294: PUSH
25295: LD_VAR 0 10
25299: PUSH
25300: LD_REAL  1.20000000000000E+0000
25303: MUL
25304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25305: LD_VAR 0 6
25309: PPUSH
25310: CALL_OW 264
25314: PUSH
25315: LD_INT 6
25317: PUSH
25318: LD_INT 46
25320: PUSH
25321: LD_INT 47
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: LIST
25328: IN
25329: IFFALSE 25346
// bpoints := bpoints * 1.2 ;
25331: LD_ADDR_VAR 0 10
25335: PUSH
25336: LD_VAR 0 10
25340: PUSH
25341: LD_REAL  1.20000000000000E+0000
25344: MUL
25345: ST_TO_ADDR
// end ; unit_building :
25346: GO 25360
25348: LD_INT 3
25350: DOUBLE
25351: EQUAL
25352: IFTRUE 25356
25354: GO 25359
25356: POP
// ; end ;
25357: GO 25360
25359: POP
// for j = 1 to 3 do
25360: LD_ADDR_VAR 0 7
25364: PUSH
25365: DOUBLE
25366: LD_INT 1
25368: DEC
25369: ST_TO_ADDR
25370: LD_INT 3
25372: PUSH
25373: FOR_TO
25374: IFFALSE 25427
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25376: LD_ADDR_VAR 0 5
25380: PUSH
25381: LD_VAR 0 5
25385: PPUSH
25386: LD_VAR 0 7
25390: PPUSH
25391: LD_VAR 0 5
25395: PUSH
25396: LD_VAR 0 7
25400: ARRAY
25401: PUSH
25402: LD_VAR 0 9
25406: PUSH
25407: LD_VAR 0 7
25411: ARRAY
25412: PUSH
25413: LD_VAR 0 10
25417: MUL
25418: PLUS
25419: PPUSH
25420: CALL_OW 1
25424: ST_TO_ADDR
25425: GO 25373
25427: POP
25428: POP
// end ;
25429: GO 23902
25431: POP
25432: POP
// result := Replace ( result , 4 , tmp ) ;
25433: LD_ADDR_VAR 0 5
25437: PUSH
25438: LD_VAR 0 5
25442: PPUSH
25443: LD_INT 4
25445: PPUSH
25446: LD_VAR 0 8
25450: PPUSH
25451: CALL_OW 1
25455: ST_TO_ADDR
// end ;
25456: LD_VAR 0 5
25460: RET
// export function DangerAtRange ( unit , range ) ; begin
25461: LD_INT 0
25463: PPUSH
// if not unit then
25464: LD_VAR 0 1
25468: NOT
25469: IFFALSE 25473
// exit ;
25471: GO 25518
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25473: LD_ADDR_VAR 0 3
25477: PUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: CALL_OW 255
25487: PPUSH
25488: LD_VAR 0 1
25492: PPUSH
25493: CALL_OW 250
25497: PPUSH
25498: LD_VAR 0 1
25502: PPUSH
25503: CALL_OW 251
25507: PPUSH
25508: LD_VAR 0 2
25512: PPUSH
25513: CALL 23752 0 4
25517: ST_TO_ADDR
// end ;
25518: LD_VAR 0 3
25522: RET
// export function DangerInArea ( side , area ) ; begin
25523: LD_INT 0
25525: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25526: LD_ADDR_VAR 0 3
25530: PUSH
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_INT 81
25538: PUSH
25539: LD_VAR 0 1
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PPUSH
25548: CALL_OW 70
25552: ST_TO_ADDR
// end ;
25553: LD_VAR 0 3
25557: RET
// export function IsExtension ( b ) ; begin
25558: LD_INT 0
25560: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25561: LD_ADDR_VAR 0 2
25565: PUSH
25566: LD_VAR 0 1
25570: PUSH
25571: LD_INT 23
25573: PUSH
25574: LD_INT 20
25576: PUSH
25577: LD_INT 22
25579: PUSH
25580: LD_INT 17
25582: PUSH
25583: LD_INT 24
25585: PUSH
25586: LD_INT 21
25588: PUSH
25589: LD_INT 19
25591: PUSH
25592: LD_INT 16
25594: PUSH
25595: LD_INT 25
25597: PUSH
25598: LD_INT 18
25600: PUSH
25601: EMPTY
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: IN
25613: ST_TO_ADDR
// end ;
25614: LD_VAR 0 2
25618: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25619: LD_INT 0
25621: PPUSH
25622: PPUSH
25623: PPUSH
// result := [ ] ;
25624: LD_ADDR_VAR 0 4
25628: PUSH
25629: EMPTY
25630: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25631: LD_ADDR_VAR 0 5
25635: PUSH
25636: LD_VAR 0 2
25640: PPUSH
25641: LD_INT 21
25643: PUSH
25644: LD_INT 3
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PPUSH
25651: CALL_OW 70
25655: ST_TO_ADDR
// if not tmp then
25656: LD_VAR 0 5
25660: NOT
25661: IFFALSE 25665
// exit ;
25663: GO 25729
// if checkLink then
25665: LD_VAR 0 3
25669: IFFALSE 25719
// begin for i in tmp do
25671: LD_ADDR_VAR 0 6
25675: PUSH
25676: LD_VAR 0 5
25680: PUSH
25681: FOR_IN
25682: IFFALSE 25717
// if GetBase ( i ) <> base then
25684: LD_VAR 0 6
25688: PPUSH
25689: CALL_OW 274
25693: PUSH
25694: LD_VAR 0 1
25698: NONEQUAL
25699: IFFALSE 25715
// ComLinkToBase ( base , i ) ;
25701: LD_VAR 0 1
25705: PPUSH
25706: LD_VAR 0 6
25710: PPUSH
25711: CALL_OW 169
25715: GO 25681
25717: POP
25718: POP
// end ; result := tmp ;
25719: LD_ADDR_VAR 0 4
25723: PUSH
25724: LD_VAR 0 5
25728: ST_TO_ADDR
// end ;
25729: LD_VAR 0 4
25733: RET
// export function ComComplete ( units , b ) ; var i ; begin
25734: LD_INT 0
25736: PPUSH
25737: PPUSH
// if not units then
25738: LD_VAR 0 1
25742: NOT
25743: IFFALSE 25747
// exit ;
25745: GO 25837
// for i in units do
25747: LD_ADDR_VAR 0 4
25751: PUSH
25752: LD_VAR 0 1
25756: PUSH
25757: FOR_IN
25758: IFFALSE 25835
// if BuildingStatus ( b ) = bs_build then
25760: LD_VAR 0 2
25764: PPUSH
25765: CALL_OW 461
25769: PUSH
25770: LD_INT 1
25772: EQUAL
25773: IFFALSE 25833
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25775: LD_VAR 0 4
25779: PPUSH
25780: LD_STRING h
25782: PUSH
25783: LD_VAR 0 2
25787: PPUSH
25788: CALL_OW 250
25792: PUSH
25793: LD_VAR 0 2
25797: PPUSH
25798: CALL_OW 251
25802: PUSH
25803: LD_VAR 0 2
25807: PUSH
25808: LD_INT 0
25810: PUSH
25811: LD_INT 0
25813: PUSH
25814: LD_INT 0
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: PUSH
25826: EMPTY
25827: LIST
25828: PPUSH
25829: CALL_OW 446
25833: GO 25757
25835: POP
25836: POP
// end ;
25837: LD_VAR 0 3
25841: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25842: LD_INT 0
25844: PPUSH
25845: PPUSH
25846: PPUSH
25847: PPUSH
25848: PPUSH
25849: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25850: LD_VAR 0 1
25854: NOT
25855: IFTRUE 25872
25857: PUSH
25858: LD_VAR 0 1
25862: PPUSH
25863: CALL_OW 263
25867: PUSH
25868: LD_INT 2
25870: NONEQUAL
25871: OR
25872: IFFALSE 25876
// exit ;
25874: GO 26192
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25876: LD_ADDR_VAR 0 6
25880: PUSH
25881: LD_INT 22
25883: PUSH
25884: LD_VAR 0 1
25888: PPUSH
25889: CALL_OW 255
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: PUSH
25898: LD_INT 2
25900: PUSH
25901: LD_INT 30
25903: PUSH
25904: LD_INT 36
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: PUSH
25911: LD_INT 34
25913: PUSH
25914: LD_INT 31
25916: PUSH
25917: EMPTY
25918: LIST
25919: LIST
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: LIST
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PPUSH
25930: CALL_OW 69
25934: ST_TO_ADDR
// if not tmp then
25935: LD_VAR 0 6
25939: NOT
25940: IFFALSE 25944
// exit ;
25942: GO 26192
// result := [ ] ;
25944: LD_ADDR_VAR 0 2
25948: PUSH
25949: EMPTY
25950: ST_TO_ADDR
// for i in tmp do
25951: LD_ADDR_VAR 0 3
25955: PUSH
25956: LD_VAR 0 6
25960: PUSH
25961: FOR_IN
25962: IFFALSE 26033
// begin t := UnitsInside ( i ) ;
25964: LD_ADDR_VAR 0 4
25968: PUSH
25969: LD_VAR 0 3
25973: PPUSH
25974: CALL_OW 313
25978: ST_TO_ADDR
// if t then
25979: LD_VAR 0 4
25983: IFFALSE 26031
// for j in t do
25985: LD_ADDR_VAR 0 7
25989: PUSH
25990: LD_VAR 0 4
25994: PUSH
25995: FOR_IN
25996: IFFALSE 26029
// result := Replace ( result , result + 1 , j ) ;
25998: LD_ADDR_VAR 0 2
26002: PUSH
26003: LD_VAR 0 2
26007: PPUSH
26008: LD_VAR 0 2
26012: PUSH
26013: LD_INT 1
26015: PLUS
26016: PPUSH
26017: LD_VAR 0 7
26021: PPUSH
26022: CALL_OW 1
26026: ST_TO_ADDR
26027: GO 25995
26029: POP
26030: POP
// end ;
26031: GO 25961
26033: POP
26034: POP
// if not result then
26035: LD_VAR 0 2
26039: NOT
26040: IFFALSE 26044
// exit ;
26042: GO 26192
// mech := result [ 1 ] ;
26044: LD_ADDR_VAR 0 5
26048: PUSH
26049: LD_VAR 0 2
26053: PUSH
26054: LD_INT 1
26056: ARRAY
26057: ST_TO_ADDR
// if result > 1 then
26058: LD_VAR 0 2
26062: PUSH
26063: LD_INT 1
26065: GREATER
26066: IFFALSE 26178
// begin for i = 2 to result do
26068: LD_ADDR_VAR 0 3
26072: PUSH
26073: DOUBLE
26074: LD_INT 2
26076: DEC
26077: ST_TO_ADDR
26078: LD_VAR 0 2
26082: PUSH
26083: FOR_TO
26084: IFFALSE 26176
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
26086: LD_ADDR_VAR 0 4
26090: PUSH
26091: LD_VAR 0 2
26095: PUSH
26096: LD_VAR 0 3
26100: ARRAY
26101: PPUSH
26102: LD_INT 3
26104: PPUSH
26105: CALL_OW 259
26109: PUSH
26110: LD_VAR 0 2
26114: PUSH
26115: LD_VAR 0 3
26119: ARRAY
26120: PPUSH
26121: CALL_OW 432
26125: MINUS
26126: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
26127: LD_VAR 0 4
26131: PUSH
26132: LD_VAR 0 5
26136: PPUSH
26137: LD_INT 3
26139: PPUSH
26140: CALL_OW 259
26144: PUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 432
26154: MINUS
26155: GREATEREQUAL
26156: IFFALSE 26174
// mech := result [ i ] ;
26158: LD_ADDR_VAR 0 5
26162: PUSH
26163: LD_VAR 0 2
26167: PUSH
26168: LD_VAR 0 3
26172: ARRAY
26173: ST_TO_ADDR
// end ;
26174: GO 26083
26176: POP
26177: POP
// end ; ComLinkTo ( vehicle , mech ) ;
26178: LD_VAR 0 1
26182: PPUSH
26183: LD_VAR 0 5
26187: PPUSH
26188: CALL_OW 135
// end ;
26192: LD_VAR 0 2
26196: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
26197: LD_INT 0
26199: PPUSH
26200: PPUSH
26201: PPUSH
26202: PPUSH
26203: PPUSH
26204: PPUSH
26205: PPUSH
26206: PPUSH
26207: PPUSH
26208: PPUSH
26209: PPUSH
26210: PPUSH
26211: PPUSH
// result := [ ] ;
26212: LD_ADDR_VAR 0 7
26216: PUSH
26217: EMPTY
26218: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
26219: LD_VAR 0 1
26223: PPUSH
26224: CALL_OW 266
26228: PUSH
26229: LD_INT 0
26231: PUSH
26232: LD_INT 1
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: IN
26239: NOT
26240: IFFALSE 26244
// exit ;
26242: GO 27884
// if name then
26244: LD_VAR 0 3
26248: IFFALSE 26264
// SetBName ( base_dep , name ) ;
26250: LD_VAR 0 1
26254: PPUSH
26255: LD_VAR 0 3
26259: PPUSH
26260: CALL_OW 500
// base := GetBase ( base_dep ) ;
26264: LD_ADDR_VAR 0 15
26268: PUSH
26269: LD_VAR 0 1
26273: PPUSH
26274: CALL_OW 274
26278: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26279: LD_ADDR_VAR 0 16
26283: PUSH
26284: LD_VAR 0 1
26288: PPUSH
26289: CALL_OW 255
26293: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26294: LD_ADDR_VAR 0 17
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 248
26308: ST_TO_ADDR
// if sources then
26309: LD_VAR 0 5
26313: IFFALSE 26360
// for i = 1 to 3 do
26315: LD_ADDR_VAR 0 8
26319: PUSH
26320: DOUBLE
26321: LD_INT 1
26323: DEC
26324: ST_TO_ADDR
26325: LD_INT 3
26327: PUSH
26328: FOR_TO
26329: IFFALSE 26358
// AddResourceType ( base , i , sources [ i ] ) ;
26331: LD_VAR 0 15
26335: PPUSH
26336: LD_VAR 0 8
26340: PPUSH
26341: LD_VAR 0 5
26345: PUSH
26346: LD_VAR 0 8
26350: ARRAY
26351: PPUSH
26352: CALL_OW 276
26356: GO 26328
26358: POP
26359: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26360: LD_ADDR_VAR 0 18
26364: PUSH
26365: LD_VAR 0 15
26369: PPUSH
26370: LD_VAR 0 2
26374: PPUSH
26375: LD_INT 1
26377: PPUSH
26378: CALL 25619 0 3
26382: ST_TO_ADDR
// InitHc ;
26383: CALL_OW 19
// InitUc ;
26387: CALL_OW 18
// uc_side := side ;
26391: LD_ADDR_OWVAR 20
26395: PUSH
26396: LD_VAR 0 16
26400: ST_TO_ADDR
// uc_nation := nation ;
26401: LD_ADDR_OWVAR 21
26405: PUSH
26406: LD_VAR 0 17
26410: ST_TO_ADDR
// if buildings then
26411: LD_VAR 0 18
26415: IFFALSE 27743
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26417: LD_ADDR_VAR 0 19
26421: PUSH
26422: LD_VAR 0 18
26426: PPUSH
26427: LD_INT 2
26429: PUSH
26430: LD_INT 30
26432: PUSH
26433: LD_INT 29
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 30
26442: PUSH
26443: LD_INT 30
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: LIST
26454: PPUSH
26455: CALL_OW 72
26459: ST_TO_ADDR
// if tmp then
26460: LD_VAR 0 19
26464: IFFALSE 26512
// for i in tmp do
26466: LD_ADDR_VAR 0 8
26470: PUSH
26471: LD_VAR 0 19
26475: PUSH
26476: FOR_IN
26477: IFFALSE 26510
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26479: LD_VAR 0 8
26483: PPUSH
26484: CALL_OW 250
26488: PPUSH
26489: LD_VAR 0 8
26493: PPUSH
26494: CALL_OW 251
26498: PPUSH
26499: LD_VAR 0 16
26503: PPUSH
26504: CALL_OW 441
26508: GO 26476
26510: POP
26511: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26512: LD_VAR 0 18
26516: PPUSH
26517: LD_INT 2
26519: PUSH
26520: LD_INT 30
26522: PUSH
26523: LD_INT 32
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PUSH
26530: LD_INT 30
26532: PUSH
26533: LD_INT 33
26535: PUSH
26536: EMPTY
26537: LIST
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: LIST
26544: PPUSH
26545: CALL_OW 72
26549: IFFALSE 26637
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26551: LD_ADDR_VAR 0 8
26555: PUSH
26556: LD_VAR 0 18
26560: PPUSH
26561: LD_INT 2
26563: PUSH
26564: LD_INT 30
26566: PUSH
26567: LD_INT 32
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 30
26576: PUSH
26577: LD_INT 33
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: LIST
26588: PPUSH
26589: CALL_OW 72
26593: PUSH
26594: FOR_IN
26595: IFFALSE 26635
// begin if not GetBWeapon ( i ) then
26597: LD_VAR 0 8
26601: PPUSH
26602: CALL_OW 269
26606: NOT
26607: IFFALSE 26633
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26609: LD_VAR 0 8
26613: PPUSH
26614: LD_VAR 0 8
26618: PPUSH
26619: LD_VAR 0 2
26623: PPUSH
26624: CALL 27889 0 2
26628: PPUSH
26629: CALL_OW 431
// end ;
26633: GO 26594
26635: POP
26636: POP
// end ; for i = 1 to personel do
26637: LD_ADDR_VAR 0 8
26641: PUSH
26642: DOUBLE
26643: LD_INT 1
26645: DEC
26646: ST_TO_ADDR
26647: LD_VAR 0 6
26651: PUSH
26652: FOR_TO
26653: IFFALSE 27723
// begin if i > 4 then
26655: LD_VAR 0 8
26659: PUSH
26660: LD_INT 4
26662: GREATER
26663: IFFALSE 26667
// break ;
26665: GO 27723
// case i of 1 :
26667: LD_VAR 0 8
26671: PUSH
26672: LD_INT 1
26674: DOUBLE
26675: EQUAL
26676: IFTRUE 26680
26678: GO 26760
26680: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26681: LD_ADDR_VAR 0 12
26685: PUSH
26686: LD_VAR 0 18
26690: PPUSH
26691: LD_INT 22
26693: PUSH
26694: LD_VAR 0 16
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: LD_INT 58
26705: PUSH
26706: EMPTY
26707: LIST
26708: PUSH
26709: LD_INT 2
26711: PUSH
26712: LD_INT 30
26714: PUSH
26715: LD_INT 32
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 30
26724: PUSH
26725: LD_INT 4
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: LD_INT 30
26734: PUSH
26735: LD_INT 5
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: LIST
26746: LIST
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: LIST
26752: PPUSH
26753: CALL_OW 72
26757: ST_TO_ADDR
26758: GO 26982
26760: LD_INT 2
26762: DOUBLE
26763: EQUAL
26764: IFTRUE 26768
26766: GO 26830
26768: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26769: LD_ADDR_VAR 0 12
26773: PUSH
26774: LD_VAR 0 18
26778: PPUSH
26779: LD_INT 22
26781: PUSH
26782: LD_VAR 0 16
26786: PUSH
26787: EMPTY
26788: LIST
26789: LIST
26790: PUSH
26791: LD_INT 2
26793: PUSH
26794: LD_INT 30
26796: PUSH
26797: LD_INT 0
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: LD_INT 30
26806: PUSH
26807: LD_INT 1
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: LIST
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PPUSH
26823: CALL_OW 72
26827: ST_TO_ADDR
26828: GO 26982
26830: LD_INT 3
26832: DOUBLE
26833: EQUAL
26834: IFTRUE 26838
26836: GO 26900
26838: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26839: LD_ADDR_VAR 0 12
26843: PUSH
26844: LD_VAR 0 18
26848: PPUSH
26849: LD_INT 22
26851: PUSH
26852: LD_VAR 0 16
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 2
26863: PUSH
26864: LD_INT 30
26866: PUSH
26867: LD_INT 2
26869: PUSH
26870: EMPTY
26871: LIST
26872: LIST
26873: PUSH
26874: LD_INT 30
26876: PUSH
26877: LD_INT 3
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: LIST
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PPUSH
26893: CALL_OW 72
26897: ST_TO_ADDR
26898: GO 26982
26900: LD_INT 4
26902: DOUBLE
26903: EQUAL
26904: IFTRUE 26908
26906: GO 26981
26908: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26909: LD_ADDR_VAR 0 12
26913: PUSH
26914: LD_VAR 0 18
26918: PPUSH
26919: LD_INT 22
26921: PUSH
26922: LD_VAR 0 16
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 2
26933: PUSH
26934: LD_INT 30
26936: PUSH
26937: LD_INT 6
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 30
26946: PUSH
26947: LD_INT 7
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 30
26956: PUSH
26957: LD_INT 8
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: LIST
26968: LIST
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PPUSH
26974: CALL_OW 72
26978: ST_TO_ADDR
26979: GO 26982
26981: POP
// if i = 1 then
26982: LD_VAR 0 8
26986: PUSH
26987: LD_INT 1
26989: EQUAL
26990: IFFALSE 27101
// begin tmp := [ ] ;
26992: LD_ADDR_VAR 0 19
26996: PUSH
26997: EMPTY
26998: ST_TO_ADDR
// for j in f do
26999: LD_ADDR_VAR 0 9
27003: PUSH
27004: LD_VAR 0 12
27008: PUSH
27009: FOR_IN
27010: IFFALSE 27083
// if GetBType ( j ) = b_bunker then
27012: LD_VAR 0 9
27016: PPUSH
27017: CALL_OW 266
27021: PUSH
27022: LD_INT 32
27024: EQUAL
27025: IFFALSE 27052
// tmp := Insert ( tmp , 1 , j ) else
27027: LD_ADDR_VAR 0 19
27031: PUSH
27032: LD_VAR 0 19
27036: PPUSH
27037: LD_INT 1
27039: PPUSH
27040: LD_VAR 0 9
27044: PPUSH
27045: CALL_OW 2
27049: ST_TO_ADDR
27050: GO 27081
// tmp := Insert ( tmp , tmp + 1 , j ) ;
27052: LD_ADDR_VAR 0 19
27056: PUSH
27057: LD_VAR 0 19
27061: PPUSH
27062: LD_VAR 0 19
27066: PUSH
27067: LD_INT 1
27069: PLUS
27070: PPUSH
27071: LD_VAR 0 9
27075: PPUSH
27076: CALL_OW 2
27080: ST_TO_ADDR
27081: GO 27009
27083: POP
27084: POP
// if tmp then
27085: LD_VAR 0 19
27089: IFFALSE 27101
// f := tmp ;
27091: LD_ADDR_VAR 0 12
27095: PUSH
27096: LD_VAR 0 19
27100: ST_TO_ADDR
// end ; x := personel [ i ] ;
27101: LD_ADDR_VAR 0 13
27105: PUSH
27106: LD_VAR 0 6
27110: PUSH
27111: LD_VAR 0 8
27115: ARRAY
27116: ST_TO_ADDR
// if x = - 1 then
27117: LD_VAR 0 13
27121: PUSH
27122: LD_INT 1
27124: NEG
27125: EQUAL
27126: IFFALSE 27337
// begin for j in f do
27128: LD_ADDR_VAR 0 9
27132: PUSH
27133: LD_VAR 0 12
27137: PUSH
27138: FOR_IN
27139: IFFALSE 27333
// repeat InitHc ;
27141: CALL_OW 19
// if GetBType ( j ) = b_barracks then
27145: LD_VAR 0 9
27149: PPUSH
27150: CALL_OW 266
27154: PUSH
27155: LD_INT 5
27157: EQUAL
27158: IFFALSE 27228
// begin if UnitsInside ( j ) < 3 then
27160: LD_VAR 0 9
27164: PPUSH
27165: CALL_OW 313
27169: PUSH
27170: LD_INT 3
27172: LESS
27173: IFFALSE 27209
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27175: LD_INT 0
27177: PPUSH
27178: LD_INT 5
27180: PUSH
27181: LD_INT 8
27183: PUSH
27184: LD_INT 9
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: PUSH
27192: LD_VAR 0 17
27196: ARRAY
27197: PPUSH
27198: LD_VAR 0 4
27202: PPUSH
27203: CALL_OW 380
27207: GO 27226
// PrepareHuman ( false , i , skill ) ;
27209: LD_INT 0
27211: PPUSH
27212: LD_VAR 0 8
27216: PPUSH
27217: LD_VAR 0 4
27221: PPUSH
27222: CALL_OW 380
// end else
27226: GO 27245
// PrepareHuman ( false , i , skill ) ;
27228: LD_INT 0
27230: PPUSH
27231: LD_VAR 0 8
27235: PPUSH
27236: LD_VAR 0 4
27240: PPUSH
27241: CALL_OW 380
// un := CreateHuman ;
27245: LD_ADDR_VAR 0 14
27249: PUSH
27250: CALL_OW 44
27254: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27255: LD_ADDR_VAR 0 7
27259: PUSH
27260: LD_VAR 0 7
27264: PPUSH
27265: LD_INT 1
27267: PPUSH
27268: LD_VAR 0 14
27272: PPUSH
27273: CALL_OW 2
27277: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27278: LD_VAR 0 14
27282: PPUSH
27283: LD_VAR 0 9
27287: PPUSH
27288: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27292: LD_VAR 0 9
27296: PPUSH
27297: CALL_OW 313
27301: PUSH
27302: LD_INT 6
27304: EQUAL
27305: IFTRUE 27329
27307: PUSH
27308: LD_VAR 0 9
27312: PPUSH
27313: CALL_OW 266
27317: PUSH
27318: LD_INT 32
27320: PUSH
27321: LD_INT 31
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: IN
27328: OR
27329: IFFALSE 27141
27331: GO 27138
27333: POP
27334: POP
// end else
27335: GO 27721
// for j = 1 to x do
27337: LD_ADDR_VAR 0 9
27341: PUSH
27342: DOUBLE
27343: LD_INT 1
27345: DEC
27346: ST_TO_ADDR
27347: LD_VAR 0 13
27351: PUSH
27352: FOR_TO
27353: IFFALSE 27719
// begin InitHc ;
27355: CALL_OW 19
// if not f then
27359: LD_VAR 0 12
27363: NOT
27364: IFFALSE 27453
// begin PrepareHuman ( false , i , skill ) ;
27366: LD_INT 0
27368: PPUSH
27369: LD_VAR 0 8
27373: PPUSH
27374: LD_VAR 0 4
27378: PPUSH
27379: CALL_OW 380
// un := CreateHuman ;
27383: LD_ADDR_VAR 0 14
27387: PUSH
27388: CALL_OW 44
27392: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27393: LD_ADDR_VAR 0 7
27397: PUSH
27398: LD_VAR 0 7
27402: PPUSH
27403: LD_INT 1
27405: PPUSH
27406: LD_VAR 0 14
27410: PPUSH
27411: CALL_OW 2
27415: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27416: LD_VAR 0 14
27420: PPUSH
27421: LD_VAR 0 1
27425: PPUSH
27426: CALL_OW 250
27430: PPUSH
27431: LD_VAR 0 1
27435: PPUSH
27436: CALL_OW 251
27440: PPUSH
27441: LD_INT 10
27443: PPUSH
27444: LD_INT 0
27446: PPUSH
27447: CALL_OW 50
// continue ;
27451: GO 27352
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27453: LD_VAR 0 12
27457: PUSH
27458: LD_INT 1
27460: ARRAY
27461: PPUSH
27462: CALL_OW 313
27466: IFFALSE 27494
27468: PUSH
27469: LD_VAR 0 12
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: PPUSH
27478: CALL_OW 266
27482: PUSH
27483: LD_INT 32
27485: PUSH
27486: LD_INT 31
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: IN
27493: AND
27494: IFTRUE 27515
27496: PUSH
27497: LD_VAR 0 12
27501: PUSH
27502: LD_INT 1
27504: ARRAY
27505: PPUSH
27506: CALL_OW 313
27510: PUSH
27511: LD_INT 6
27513: EQUAL
27514: OR
27515: IFFALSE 27535
// f := Delete ( f , 1 ) ;
27517: LD_ADDR_VAR 0 12
27521: PUSH
27522: LD_VAR 0 12
27526: PPUSH
27527: LD_INT 1
27529: PPUSH
27530: CALL_OW 3
27534: ST_TO_ADDR
// if not f then
27535: LD_VAR 0 12
27539: NOT
27540: IFFALSE 27558
// begin x := x + 2 ;
27542: LD_ADDR_VAR 0 13
27546: PUSH
27547: LD_VAR 0 13
27551: PUSH
27552: LD_INT 2
27554: PLUS
27555: ST_TO_ADDR
// continue ;
27556: GO 27352
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27558: LD_VAR 0 12
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: PPUSH
27567: CALL_OW 266
27571: PUSH
27572: LD_INT 5
27574: EQUAL
27575: IFFALSE 27649
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27577: LD_VAR 0 12
27581: PUSH
27582: LD_INT 1
27584: ARRAY
27585: PPUSH
27586: CALL_OW 313
27590: PUSH
27591: LD_INT 3
27593: LESS
27594: IFFALSE 27630
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27596: LD_INT 0
27598: PPUSH
27599: LD_INT 5
27601: PUSH
27602: LD_INT 8
27604: PUSH
27605: LD_INT 9
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: LIST
27612: PUSH
27613: LD_VAR 0 17
27617: ARRAY
27618: PPUSH
27619: LD_VAR 0 4
27623: PPUSH
27624: CALL_OW 380
27628: GO 27647
// PrepareHuman ( false , i , skill ) ;
27630: LD_INT 0
27632: PPUSH
27633: LD_VAR 0 8
27637: PPUSH
27638: LD_VAR 0 4
27642: PPUSH
27643: CALL_OW 380
// end else
27647: GO 27666
// PrepareHuman ( false , i , skill ) ;
27649: LD_INT 0
27651: PPUSH
27652: LD_VAR 0 8
27656: PPUSH
27657: LD_VAR 0 4
27661: PPUSH
27662: CALL_OW 380
// un := CreateHuman ;
27666: LD_ADDR_VAR 0 14
27670: PUSH
27671: CALL_OW 44
27675: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27676: LD_ADDR_VAR 0 7
27680: PUSH
27681: LD_VAR 0 7
27685: PPUSH
27686: LD_INT 1
27688: PPUSH
27689: LD_VAR 0 14
27693: PPUSH
27694: CALL_OW 2
27698: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27699: LD_VAR 0 14
27703: PPUSH
27704: LD_VAR 0 12
27708: PUSH
27709: LD_INT 1
27711: ARRAY
27712: PPUSH
27713: CALL_OW 52
// end ;
27717: GO 27352
27719: POP
27720: POP
// end ;
27721: GO 26652
27723: POP
27724: POP
// result := result ^ buildings ;
27725: LD_ADDR_VAR 0 7
27729: PUSH
27730: LD_VAR 0 7
27734: PUSH
27735: LD_VAR 0 18
27739: ADD
27740: ST_TO_ADDR
// end else
27741: GO 27884
// begin for i = 1 to personel do
27743: LD_ADDR_VAR 0 8
27747: PUSH
27748: DOUBLE
27749: LD_INT 1
27751: DEC
27752: ST_TO_ADDR
27753: LD_VAR 0 6
27757: PUSH
27758: FOR_TO
27759: IFFALSE 27882
// begin if i > 4 then
27761: LD_VAR 0 8
27765: PUSH
27766: LD_INT 4
27768: GREATER
27769: IFFALSE 27773
// break ;
27771: GO 27882
// x := personel [ i ] ;
27773: LD_ADDR_VAR 0 13
27777: PUSH
27778: LD_VAR 0 6
27782: PUSH
27783: LD_VAR 0 8
27787: ARRAY
27788: ST_TO_ADDR
// if x = - 1 then
27789: LD_VAR 0 13
27793: PUSH
27794: LD_INT 1
27796: NEG
27797: EQUAL
27798: IFFALSE 27802
// continue ;
27800: GO 27758
// PrepareHuman ( false , i , skill ) ;
27802: LD_INT 0
27804: PPUSH
27805: LD_VAR 0 8
27809: PPUSH
27810: LD_VAR 0 4
27814: PPUSH
27815: CALL_OW 380
// un := CreateHuman ;
27819: LD_ADDR_VAR 0 14
27823: PUSH
27824: CALL_OW 44
27828: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27829: LD_VAR 0 14
27833: PPUSH
27834: LD_VAR 0 1
27838: PPUSH
27839: CALL_OW 250
27843: PPUSH
27844: LD_VAR 0 1
27848: PPUSH
27849: CALL_OW 251
27853: PPUSH
27854: LD_INT 10
27856: PPUSH
27857: LD_INT 0
27859: PPUSH
27860: CALL_OW 50
// result := result ^ un ;
27864: LD_ADDR_VAR 0 7
27868: PUSH
27869: LD_VAR 0 7
27873: PUSH
27874: LD_VAR 0 14
27878: ADD
27879: ST_TO_ADDR
// end ;
27880: GO 27758
27882: POP
27883: POP
// end ; end ;
27884: LD_VAR 0 7
27888: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27889: LD_INT 0
27891: PPUSH
27892: PPUSH
27893: PPUSH
27894: PPUSH
27895: PPUSH
27896: PPUSH
27897: PPUSH
27898: PPUSH
27899: PPUSH
27900: PPUSH
27901: PPUSH
27902: PPUSH
27903: PPUSH
27904: PPUSH
27905: PPUSH
27906: PPUSH
// result := false ;
27907: LD_ADDR_VAR 0 3
27911: PUSH
27912: LD_INT 0
27914: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27915: LD_VAR 0 1
27919: NOT
27920: IFTRUE 27945
27922: PUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 266
27932: PUSH
27933: LD_INT 32
27935: PUSH
27936: LD_INT 33
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: IN
27943: NOT
27944: OR
27945: IFFALSE 27949
// exit ;
27947: GO 29084
// nat := GetNation ( tower ) ;
27949: LD_ADDR_VAR 0 12
27953: PUSH
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 248
27963: ST_TO_ADDR
// side := GetSide ( tower ) ;
27964: LD_ADDR_VAR 0 16
27968: PUSH
27969: LD_VAR 0 1
27973: PPUSH
27974: CALL_OW 255
27978: ST_TO_ADDR
// x := GetX ( tower ) ;
27979: LD_ADDR_VAR 0 10
27983: PUSH
27984: LD_VAR 0 1
27988: PPUSH
27989: CALL_OW 250
27993: ST_TO_ADDR
// y := GetY ( tower ) ;
27994: LD_ADDR_VAR 0 11
27998: PUSH
27999: LD_VAR 0 1
28003: PPUSH
28004: CALL_OW 251
28008: ST_TO_ADDR
// if not x or not y then
28009: LD_VAR 0 10
28013: NOT
28014: IFTRUE 28023
28016: PUSH
28017: LD_VAR 0 11
28021: NOT
28022: OR
28023: IFFALSE 28027
// exit ;
28025: GO 29084
// weapon := 0 ;
28027: LD_ADDR_VAR 0 18
28031: PUSH
28032: LD_INT 0
28034: ST_TO_ADDR
// fac_list := [ ] ;
28035: LD_ADDR_VAR 0 17
28039: PUSH
28040: EMPTY
28041: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
28042: LD_ADDR_VAR 0 6
28046: PUSH
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 274
28056: PPUSH
28057: LD_VAR 0 2
28061: PPUSH
28062: LD_INT 0
28064: PPUSH
28065: CALL 25619 0 3
28069: PPUSH
28070: LD_INT 30
28072: PUSH
28073: LD_INT 3
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 72
28084: ST_TO_ADDR
// if not factories then
28085: LD_VAR 0 6
28089: NOT
28090: IFFALSE 28094
// exit ;
28092: GO 29084
// for i in factories do
28094: LD_ADDR_VAR 0 8
28098: PUSH
28099: LD_VAR 0 6
28103: PUSH
28104: FOR_IN
28105: IFFALSE 28130
// fac_list := fac_list union AvailableWeaponList ( i ) ;
28107: LD_ADDR_VAR 0 17
28111: PUSH
28112: LD_VAR 0 17
28116: PUSH
28117: LD_VAR 0 8
28121: PPUSH
28122: CALL_OW 478
28126: UNION
28127: ST_TO_ADDR
28128: GO 28104
28130: POP
28131: POP
// if not fac_list then
28132: LD_VAR 0 17
28136: NOT
28137: IFFALSE 28141
// exit ;
28139: GO 29084
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
28141: LD_ADDR_VAR 0 5
28145: PUSH
28146: LD_INT 4
28148: PUSH
28149: LD_INT 5
28151: PUSH
28152: LD_INT 9
28154: PUSH
28155: LD_INT 10
28157: PUSH
28158: LD_INT 6
28160: PUSH
28161: LD_INT 7
28163: PUSH
28164: LD_INT 11
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 27
28178: PUSH
28179: LD_INT 28
28181: PUSH
28182: LD_INT 26
28184: PUSH
28185: LD_INT 30
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 43
28196: PUSH
28197: LD_INT 44
28199: PUSH
28200: LD_INT 46
28202: PUSH
28203: LD_INT 45
28205: PUSH
28206: LD_INT 47
28208: PUSH
28209: LD_INT 49
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: LIST
28224: PUSH
28225: LD_VAR 0 12
28229: ARRAY
28230: ST_TO_ADDR
// list := list isect fac_list ;
28231: LD_ADDR_VAR 0 5
28235: PUSH
28236: LD_VAR 0 5
28240: PUSH
28241: LD_VAR 0 17
28245: ISECT
28246: ST_TO_ADDR
// if not list then
28247: LD_VAR 0 5
28251: NOT
28252: IFFALSE 28256
// exit ;
28254: GO 29084
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
28256: LD_VAR 0 12
28260: PUSH
28261: LD_INT 3
28263: EQUAL
28264: IFFALSE 28276
28266: PUSH
28267: LD_INT 49
28269: PUSH
28270: LD_VAR 0 5
28274: IN
28275: AND
28276: IFFALSE 28296
28278: PUSH
28279: LD_INT 31
28281: PPUSH
28282: LD_VAR 0 16
28286: PPUSH
28287: CALL_OW 321
28291: PUSH
28292: LD_INT 2
28294: EQUAL
28295: AND
28296: IFFALSE 28356
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28298: LD_INT 22
28300: PUSH
28301: LD_VAR 0 16
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 35
28312: PUSH
28313: LD_INT 49
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PUSH
28320: LD_INT 91
28322: PUSH
28323: LD_VAR 0 1
28327: PUSH
28328: LD_INT 10
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: LIST
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: LIST
28340: PPUSH
28341: CALL_OW 69
28345: NOT
28346: IFFALSE 28356
// weapon := ru_time_lapser ;
28348: LD_ADDR_VAR 0 18
28352: PUSH
28353: LD_INT 49
28355: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28356: LD_VAR 0 12
28360: PUSH
28361: LD_INT 1
28363: PUSH
28364: LD_INT 2
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: IN
28371: IFFALSE 28395
28373: PUSH
28374: LD_INT 11
28376: PUSH
28377: LD_VAR 0 5
28381: IN
28382: IFTRUE 28394
28384: PUSH
28385: LD_INT 30
28387: PUSH
28388: LD_VAR 0 5
28392: IN
28393: OR
28394: AND
28395: IFFALSE 28415
28397: PUSH
28398: LD_INT 6
28400: PPUSH
28401: LD_VAR 0 16
28405: PPUSH
28406: CALL_OW 321
28410: PUSH
28411: LD_INT 2
28413: EQUAL
28414: AND
28415: IFFALSE 28582
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28417: LD_INT 22
28419: PUSH
28420: LD_VAR 0 16
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: LD_INT 2
28431: PUSH
28432: LD_INT 35
28434: PUSH
28435: LD_INT 11
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PUSH
28442: LD_INT 35
28444: PUSH
28445: LD_INT 30
28447: PUSH
28448: EMPTY
28449: LIST
28450: LIST
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 91
28459: PUSH
28460: LD_VAR 0 1
28464: PUSH
28465: LD_INT 18
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: LIST
28472: PUSH
28473: EMPTY
28474: LIST
28475: LIST
28476: LIST
28477: PPUSH
28478: CALL_OW 69
28482: NOT
28483: IFFALSE 28559
28485: PUSH
28486: LD_INT 22
28488: PUSH
28489: LD_VAR 0 16
28493: PUSH
28494: EMPTY
28495: LIST
28496: LIST
28497: PUSH
28498: LD_INT 2
28500: PUSH
28501: LD_INT 30
28503: PUSH
28504: LD_INT 32
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: LD_INT 30
28513: PUSH
28514: LD_INT 33
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 91
28528: PUSH
28529: LD_VAR 0 1
28533: PUSH
28534: LD_INT 12
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: LIST
28541: PUSH
28542: EMPTY
28543: LIST
28544: LIST
28545: LIST
28546: PUSH
28547: EMPTY
28548: LIST
28549: PPUSH
28550: CALL_OW 69
28554: PUSH
28555: LD_INT 2
28557: GREATER
28558: AND
28559: IFFALSE 28582
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28561: LD_ADDR_VAR 0 18
28565: PUSH
28566: LD_INT 11
28568: PUSH
28569: LD_INT 30
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_VAR 0 12
28580: ARRAY
28581: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28582: LD_VAR 0 18
28586: NOT
28587: IFFALSE 28607
28589: PUSH
28590: LD_INT 40
28592: PPUSH
28593: LD_VAR 0 16
28597: PPUSH
28598: CALL_OW 321
28602: PUSH
28603: LD_INT 2
28605: EQUAL
28606: AND
28607: IFFALSE 28643
28609: PUSH
28610: LD_INT 7
28612: PUSH
28613: LD_VAR 0 5
28617: IN
28618: IFTRUE 28630
28620: PUSH
28621: LD_INT 28
28623: PUSH
28624: LD_VAR 0 5
28628: IN
28629: OR
28630: IFTRUE 28642
28632: PUSH
28633: LD_INT 45
28635: PUSH
28636: LD_VAR 0 5
28640: IN
28641: OR
28642: AND
28643: IFFALSE 28897
// begin hex := GetHexInfo ( x , y ) ;
28645: LD_ADDR_VAR 0 4
28649: PUSH
28650: LD_VAR 0 10
28654: PPUSH
28655: LD_VAR 0 11
28659: PPUSH
28660: CALL_OW 546
28664: ST_TO_ADDR
// if hex [ 1 ] then
28665: LD_VAR 0 4
28669: PUSH
28670: LD_INT 1
28672: ARRAY
28673: IFFALSE 28677
// exit ;
28675: GO 29084
// height := hex [ 2 ] ;
28677: LD_ADDR_VAR 0 15
28681: PUSH
28682: LD_VAR 0 4
28686: PUSH
28687: LD_INT 2
28689: ARRAY
28690: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28691: LD_ADDR_VAR 0 14
28695: PUSH
28696: LD_INT 0
28698: PUSH
28699: LD_INT 2
28701: PUSH
28702: LD_INT 3
28704: PUSH
28705: LD_INT 5
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: ST_TO_ADDR
// for i in tmp do
28714: LD_ADDR_VAR 0 8
28718: PUSH
28719: LD_VAR 0 14
28723: PUSH
28724: FOR_IN
28725: IFFALSE 28895
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28727: LD_ADDR_VAR 0 9
28731: PUSH
28732: LD_VAR 0 10
28736: PPUSH
28737: LD_VAR 0 8
28741: PPUSH
28742: LD_INT 5
28744: PPUSH
28745: CALL_OW 272
28749: PUSH
28750: LD_VAR 0 11
28754: PPUSH
28755: LD_VAR 0 8
28759: PPUSH
28760: LD_INT 5
28762: PPUSH
28763: CALL_OW 273
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28772: LD_VAR 0 9
28776: PUSH
28777: LD_INT 1
28779: ARRAY
28780: PPUSH
28781: LD_VAR 0 9
28785: PUSH
28786: LD_INT 2
28788: ARRAY
28789: PPUSH
28790: CALL_OW 488
28794: IFFALSE 28893
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28796: LD_ADDR_VAR 0 4
28800: PUSH
28801: LD_VAR 0 9
28805: PUSH
28806: LD_INT 1
28808: ARRAY
28809: PPUSH
28810: LD_VAR 0 9
28814: PUSH
28815: LD_INT 2
28817: ARRAY
28818: PPUSH
28819: CALL_OW 546
28823: ST_TO_ADDR
// if hex [ 1 ] then
28824: LD_VAR 0 4
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: IFFALSE 28836
// continue ;
28834: GO 28724
// h := hex [ 2 ] ;
28836: LD_ADDR_VAR 0 13
28840: PUSH
28841: LD_VAR 0 4
28845: PUSH
28846: LD_INT 2
28848: ARRAY
28849: ST_TO_ADDR
// if h + 7 < height then
28850: LD_VAR 0 13
28854: PUSH
28855: LD_INT 7
28857: PLUS
28858: PUSH
28859: LD_VAR 0 15
28863: LESS
28864: IFFALSE 28893
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28866: LD_ADDR_VAR 0 18
28870: PUSH
28871: LD_INT 7
28873: PUSH
28874: LD_INT 28
28876: PUSH
28877: LD_INT 45
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: LIST
28884: PUSH
28885: LD_VAR 0 12
28889: ARRAY
28890: ST_TO_ADDR
// break ;
28891: GO 28895
// end ; end ; end ;
28893: GO 28724
28895: POP
28896: POP
// end ; if not weapon then
28897: LD_VAR 0 18
28901: NOT
28902: IFFALSE 28962
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28904: LD_ADDR_VAR 0 5
28908: PUSH
28909: LD_VAR 0 5
28913: PUSH
28914: LD_INT 11
28916: PUSH
28917: LD_INT 30
28919: PUSH
28920: LD_INT 49
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: LIST
28927: DIFF
28928: ST_TO_ADDR
// if not list then
28929: LD_VAR 0 5
28933: NOT
28934: IFFALSE 28938
// exit ;
28936: GO 29084
// weapon := list [ rand ( 1 , list ) ] ;
28938: LD_ADDR_VAR 0 18
28942: PUSH
28943: LD_VAR 0 5
28947: PUSH
28948: LD_INT 1
28950: PPUSH
28951: LD_VAR 0 5
28955: PPUSH
28956: CALL_OW 12
28960: ARRAY
28961: ST_TO_ADDR
// end ; if weapon then
28962: LD_VAR 0 18
28966: IFFALSE 29084
// begin tmp := CostOfWeapon ( weapon ) ;
28968: LD_ADDR_VAR 0 14
28972: PUSH
28973: LD_VAR 0 18
28977: PPUSH
28978: CALL_OW 451
28982: ST_TO_ADDR
// j := GetBase ( tower ) ;
28983: LD_ADDR_VAR 0 9
28987: PUSH
28988: LD_VAR 0 1
28992: PPUSH
28993: CALL_OW 274
28997: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28998: LD_VAR 0 9
29002: PPUSH
29003: LD_INT 1
29005: PPUSH
29006: CALL_OW 275
29010: PUSH
29011: LD_VAR 0 14
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: GREATEREQUAL
29020: IFFALSE 29046
29022: PUSH
29023: LD_VAR 0 9
29027: PPUSH
29028: LD_INT 2
29030: PPUSH
29031: CALL_OW 275
29035: PUSH
29036: LD_VAR 0 14
29040: PUSH
29041: LD_INT 2
29043: ARRAY
29044: GREATEREQUAL
29045: AND
29046: IFFALSE 29072
29048: PUSH
29049: LD_VAR 0 9
29053: PPUSH
29054: LD_INT 3
29056: PPUSH
29057: CALL_OW 275
29061: PUSH
29062: LD_VAR 0 14
29066: PUSH
29067: LD_INT 3
29069: ARRAY
29070: GREATEREQUAL
29071: AND
29072: IFFALSE 29084
// result := weapon ;
29074: LD_ADDR_VAR 0 3
29078: PUSH
29079: LD_VAR 0 18
29083: ST_TO_ADDR
// end ; end ;
29084: LD_VAR 0 3
29088: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
29089: LD_INT 0
29091: PPUSH
29092: PPUSH
// result := true ;
29093: LD_ADDR_VAR 0 3
29097: PUSH
29098: LD_INT 1
29100: ST_TO_ADDR
// if array1 = array2 then
29101: LD_VAR 0 1
29105: PUSH
29106: LD_VAR 0 2
29110: EQUAL
29111: IFFALSE 29171
// begin for i = 1 to array1 do
29113: LD_ADDR_VAR 0 4
29117: PUSH
29118: DOUBLE
29119: LD_INT 1
29121: DEC
29122: ST_TO_ADDR
29123: LD_VAR 0 1
29127: PUSH
29128: FOR_TO
29129: IFFALSE 29167
// if array1 [ i ] <> array2 [ i ] then
29131: LD_VAR 0 1
29135: PUSH
29136: LD_VAR 0 4
29140: ARRAY
29141: PUSH
29142: LD_VAR 0 2
29146: PUSH
29147: LD_VAR 0 4
29151: ARRAY
29152: NONEQUAL
29153: IFFALSE 29165
// begin result := false ;
29155: LD_ADDR_VAR 0 3
29159: PUSH
29160: LD_INT 0
29162: ST_TO_ADDR
// break ;
29163: GO 29167
// end ;
29165: GO 29128
29167: POP
29168: POP
// end else
29169: GO 29179
// result := false ;
29171: LD_ADDR_VAR 0 3
29175: PUSH
29176: LD_INT 0
29178: ST_TO_ADDR
// end ;
29179: LD_VAR 0 3
29183: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
29184: LD_INT 0
29186: PPUSH
29187: PPUSH
// if not array1 or not array2 then
29188: LD_VAR 0 1
29192: NOT
29193: IFTRUE 29202
29195: PUSH
29196: LD_VAR 0 2
29200: NOT
29201: OR
29202: IFFALSE 29206
// exit ;
29204: GO 29270
// result := true ;
29206: LD_ADDR_VAR 0 3
29210: PUSH
29211: LD_INT 1
29213: ST_TO_ADDR
// for i = 1 to array1 do
29214: LD_ADDR_VAR 0 4
29218: PUSH
29219: DOUBLE
29220: LD_INT 1
29222: DEC
29223: ST_TO_ADDR
29224: LD_VAR 0 1
29228: PUSH
29229: FOR_TO
29230: IFFALSE 29268
// if array1 [ i ] <> array2 [ i ] then
29232: LD_VAR 0 1
29236: PUSH
29237: LD_VAR 0 4
29241: ARRAY
29242: PUSH
29243: LD_VAR 0 2
29247: PUSH
29248: LD_VAR 0 4
29252: ARRAY
29253: NONEQUAL
29254: IFFALSE 29266
// begin result := false ;
29256: LD_ADDR_VAR 0 3
29260: PUSH
29261: LD_INT 0
29263: ST_TO_ADDR
// break ;
29264: GO 29268
// end ;
29266: GO 29229
29268: POP
29269: POP
// end ;
29270: LD_VAR 0 3
29274: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
29275: LD_INT 0
29277: PPUSH
29278: PPUSH
29279: PPUSH
// pom := GetBase ( fac ) ;
29280: LD_ADDR_VAR 0 5
29284: PUSH
29285: LD_VAR 0 1
29289: PPUSH
29290: CALL_OW 274
29294: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
29295: LD_ADDR_VAR 0 4
29299: PUSH
29300: LD_VAR 0 2
29304: PUSH
29305: LD_INT 1
29307: ARRAY
29308: PPUSH
29309: LD_VAR 0 2
29313: PUSH
29314: LD_INT 2
29316: ARRAY
29317: PPUSH
29318: LD_VAR 0 2
29322: PUSH
29323: LD_INT 3
29325: ARRAY
29326: PPUSH
29327: LD_VAR 0 2
29331: PUSH
29332: LD_INT 4
29334: ARRAY
29335: PPUSH
29336: CALL_OW 449
29340: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29341: LD_ADDR_VAR 0 3
29345: PUSH
29346: LD_VAR 0 5
29350: PPUSH
29351: LD_INT 1
29353: PPUSH
29354: CALL_OW 275
29358: PUSH
29359: LD_VAR 0 4
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: GREATEREQUAL
29368: IFFALSE 29394
29370: PUSH
29371: LD_VAR 0 5
29375: PPUSH
29376: LD_INT 2
29378: PPUSH
29379: CALL_OW 275
29383: PUSH
29384: LD_VAR 0 4
29388: PUSH
29389: LD_INT 2
29391: ARRAY
29392: GREATEREQUAL
29393: AND
29394: IFFALSE 29420
29396: PUSH
29397: LD_VAR 0 5
29401: PPUSH
29402: LD_INT 3
29404: PPUSH
29405: CALL_OW 275
29409: PUSH
29410: LD_VAR 0 4
29414: PUSH
29415: LD_INT 3
29417: ARRAY
29418: GREATEREQUAL
29419: AND
29420: ST_TO_ADDR
// end ;
29421: LD_VAR 0 3
29425: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29426: LD_INT 0
29428: PPUSH
29429: PPUSH
29430: PPUSH
29431: PPUSH
// pom := GetBase ( building ) ;
29432: LD_ADDR_VAR 0 3
29436: PUSH
29437: LD_VAR 0 1
29441: PPUSH
29442: CALL_OW 274
29446: ST_TO_ADDR
// if not pom then
29447: LD_VAR 0 3
29451: NOT
29452: IFFALSE 29456
// exit ;
29454: GO 29630
// btype := GetBType ( building ) ;
29456: LD_ADDR_VAR 0 5
29460: PUSH
29461: LD_VAR 0 1
29465: PPUSH
29466: CALL_OW 266
29470: ST_TO_ADDR
// if btype = b_armoury then
29471: LD_VAR 0 5
29475: PUSH
29476: LD_INT 4
29478: EQUAL
29479: IFFALSE 29489
// btype := b_barracks ;
29481: LD_ADDR_VAR 0 5
29485: PUSH
29486: LD_INT 5
29488: ST_TO_ADDR
// if btype = b_depot then
29489: LD_VAR 0 5
29493: PUSH
29494: LD_INT 0
29496: EQUAL
29497: IFFALSE 29507
// btype := b_warehouse ;
29499: LD_ADDR_VAR 0 5
29503: PUSH
29504: LD_INT 1
29506: ST_TO_ADDR
// if btype = b_workshop then
29507: LD_VAR 0 5
29511: PUSH
29512: LD_INT 2
29514: EQUAL
29515: IFFALSE 29525
// btype := b_factory ;
29517: LD_ADDR_VAR 0 5
29521: PUSH
29522: LD_INT 3
29524: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29525: LD_ADDR_VAR 0 4
29529: PUSH
29530: LD_VAR 0 5
29534: PPUSH
29535: LD_VAR 0 1
29539: PPUSH
29540: CALL_OW 248
29544: PPUSH
29545: CALL_OW 450
29549: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29550: LD_ADDR_VAR 0 2
29554: PUSH
29555: LD_VAR 0 3
29559: PPUSH
29560: LD_INT 1
29562: PPUSH
29563: CALL_OW 275
29567: PUSH
29568: LD_VAR 0 4
29572: PUSH
29573: LD_INT 1
29575: ARRAY
29576: GREATEREQUAL
29577: IFFALSE 29603
29579: PUSH
29580: LD_VAR 0 3
29584: PPUSH
29585: LD_INT 2
29587: PPUSH
29588: CALL_OW 275
29592: PUSH
29593: LD_VAR 0 4
29597: PUSH
29598: LD_INT 2
29600: ARRAY
29601: GREATEREQUAL
29602: AND
29603: IFFALSE 29629
29605: PUSH
29606: LD_VAR 0 3
29610: PPUSH
29611: LD_INT 3
29613: PPUSH
29614: CALL_OW 275
29618: PUSH
29619: LD_VAR 0 4
29623: PUSH
29624: LD_INT 3
29626: ARRAY
29627: GREATEREQUAL
29628: AND
29629: ST_TO_ADDR
// end ;
29630: LD_VAR 0 2
29634: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29635: LD_INT 0
29637: PPUSH
29638: PPUSH
29639: PPUSH
// pom := GetBase ( building ) ;
29640: LD_ADDR_VAR 0 4
29644: PUSH
29645: LD_VAR 0 1
29649: PPUSH
29650: CALL_OW 274
29654: ST_TO_ADDR
// if not pom then
29655: LD_VAR 0 4
29659: NOT
29660: IFFALSE 29664
// exit ;
29662: GO 29769
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29664: LD_ADDR_VAR 0 5
29668: PUSH
29669: LD_VAR 0 2
29673: PPUSH
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 248
29683: PPUSH
29684: CALL_OW 450
29688: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29689: LD_ADDR_VAR 0 3
29693: PUSH
29694: LD_VAR 0 4
29698: PPUSH
29699: LD_INT 1
29701: PPUSH
29702: CALL_OW 275
29706: PUSH
29707: LD_VAR 0 5
29711: PUSH
29712: LD_INT 1
29714: ARRAY
29715: GREATEREQUAL
29716: IFFALSE 29742
29718: PUSH
29719: LD_VAR 0 4
29723: PPUSH
29724: LD_INT 2
29726: PPUSH
29727: CALL_OW 275
29731: PUSH
29732: LD_VAR 0 5
29736: PUSH
29737: LD_INT 2
29739: ARRAY
29740: GREATEREQUAL
29741: AND
29742: IFFALSE 29768
29744: PUSH
29745: LD_VAR 0 4
29749: PPUSH
29750: LD_INT 3
29752: PPUSH
29753: CALL_OW 275
29757: PUSH
29758: LD_VAR 0 5
29762: PUSH
29763: LD_INT 3
29765: ARRAY
29766: GREATEREQUAL
29767: AND
29768: ST_TO_ADDR
// end ;
29769: LD_VAR 0 3
29773: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29774: LD_INT 0
29776: PPUSH
29777: PPUSH
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
// result := false ;
29787: LD_ADDR_VAR 0 8
29791: PUSH
29792: LD_INT 0
29794: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29795: LD_VAR 0 5
29799: NOT
29800: IFTRUE 29809
29802: PUSH
29803: LD_VAR 0 1
29807: NOT
29808: OR
29809: IFTRUE 29818
29811: PUSH
29812: LD_VAR 0 2
29816: NOT
29817: OR
29818: IFTRUE 29827
29820: PUSH
29821: LD_VAR 0 3
29825: NOT
29826: OR
29827: IFFALSE 29831
// exit ;
29829: GO 30657
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29831: LD_ADDR_VAR 0 14
29835: PUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: LD_VAR 0 2
29845: PPUSH
29846: LD_VAR 0 3
29850: PPUSH
29851: LD_VAR 0 4
29855: PPUSH
29856: LD_VAR 0 5
29860: PUSH
29861: LD_INT 1
29863: ARRAY
29864: PPUSH
29865: CALL_OW 248
29869: PPUSH
29870: LD_INT 0
29872: PPUSH
29873: CALL 31938 0 6
29877: ST_TO_ADDR
// if not hexes then
29878: LD_VAR 0 14
29882: NOT
29883: IFFALSE 29887
// exit ;
29885: GO 30657
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29887: LD_ADDR_VAR 0 17
29891: PUSH
29892: LD_VAR 0 5
29896: PPUSH
29897: LD_INT 22
29899: PUSH
29900: LD_VAR 0 13
29904: PPUSH
29905: CALL_OW 255
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 2
29916: PUSH
29917: LD_INT 30
29919: PUSH
29920: LD_INT 0
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 30
29929: PUSH
29930: LD_INT 1
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: LIST
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PPUSH
29946: CALL_OW 72
29950: ST_TO_ADDR
// for i = 1 to hexes do
29951: LD_ADDR_VAR 0 9
29955: PUSH
29956: DOUBLE
29957: LD_INT 1
29959: DEC
29960: ST_TO_ADDR
29961: LD_VAR 0 14
29965: PUSH
29966: FOR_TO
29967: IFFALSE 30655
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29969: LD_ADDR_VAR 0 13
29973: PUSH
29974: LD_VAR 0 14
29978: PUSH
29979: LD_VAR 0 9
29983: ARRAY
29984: PUSH
29985: LD_INT 1
29987: ARRAY
29988: PPUSH
29989: LD_VAR 0 14
29993: PUSH
29994: LD_VAR 0 9
29998: ARRAY
29999: PUSH
30000: LD_INT 2
30002: ARRAY
30003: PPUSH
30004: CALL_OW 428
30008: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
30009: LD_VAR 0 14
30013: PUSH
30014: LD_VAR 0 9
30018: ARRAY
30019: PUSH
30020: LD_INT 1
30022: ARRAY
30023: PPUSH
30024: LD_VAR 0 14
30028: PUSH
30029: LD_VAR 0 9
30033: ARRAY
30034: PUSH
30035: LD_INT 2
30037: ARRAY
30038: PPUSH
30039: CALL_OW 351
30043: IFTRUE 30082
30045: PUSH
30046: LD_VAR 0 14
30050: PUSH
30051: LD_VAR 0 9
30055: ARRAY
30056: PUSH
30057: LD_INT 1
30059: ARRAY
30060: PPUSH
30061: LD_VAR 0 14
30065: PUSH
30066: LD_VAR 0 9
30070: ARRAY
30071: PUSH
30072: LD_INT 2
30074: ARRAY
30075: PPUSH
30076: CALL_OW 488
30080: NOT
30081: OR
30082: IFTRUE 30099
30084: PUSH
30085: LD_VAR 0 13
30089: PPUSH
30090: CALL_OW 247
30094: PUSH
30095: LD_INT 3
30097: EQUAL
30098: OR
30099: IFFALSE 30105
// exit ;
30101: POP
30102: POP
30103: GO 30657
// if not tmp then
30105: LD_VAR 0 13
30109: NOT
30110: IFFALSE 30114
// continue ;
30112: GO 29966
// result := true ;
30114: LD_ADDR_VAR 0 8
30118: PUSH
30119: LD_INT 1
30121: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
30122: LD_VAR 0 6
30126: IFFALSE 30143
30128: PUSH
30129: LD_VAR 0 13
30133: PPUSH
30134: CALL_OW 247
30138: PUSH
30139: LD_INT 2
30141: EQUAL
30142: AND
30143: IFFALSE 30160
30145: PUSH
30146: LD_VAR 0 13
30150: PPUSH
30151: CALL_OW 263
30155: PUSH
30156: LD_INT 1
30158: EQUAL
30159: AND
30160: IFFALSE 30324
// begin if IsDrivenBy ( tmp ) then
30162: LD_VAR 0 13
30166: PPUSH
30167: CALL_OW 311
30171: IFFALSE 30175
// continue ;
30173: GO 29966
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
30175: LD_VAR 0 6
30179: PPUSH
30180: LD_INT 3
30182: PUSH
30183: LD_INT 60
30185: PUSH
30186: EMPTY
30187: LIST
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 3
30195: PUSH
30196: LD_INT 55
30198: PUSH
30199: EMPTY
30200: LIST
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PPUSH
30210: CALL_OW 72
30214: IFFALSE 30322
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
30216: LD_ADDR_VAR 0 18
30220: PUSH
30221: LD_VAR 0 6
30225: PPUSH
30226: LD_INT 3
30228: PUSH
30229: LD_INT 60
30231: PUSH
30232: EMPTY
30233: LIST
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 3
30241: PUSH
30242: LD_INT 55
30244: PUSH
30245: EMPTY
30246: LIST
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PPUSH
30256: CALL_OW 72
30260: PUSH
30261: LD_INT 1
30263: ARRAY
30264: ST_TO_ADDR
// if IsInUnit ( driver ) then
30265: LD_VAR 0 18
30269: PPUSH
30270: CALL_OW 310
30274: IFFALSE 30285
// ComExit ( driver ) ;
30276: LD_VAR 0 18
30280: PPUSH
30281: CALL 55928 0 1
// AddComEnterUnit ( driver , tmp ) ;
30285: LD_VAR 0 18
30289: PPUSH
30290: LD_VAR 0 13
30294: PPUSH
30295: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
30299: LD_VAR 0 18
30303: PPUSH
30304: LD_VAR 0 7
30308: PPUSH
30309: CALL_OW 173
// AddComExitVehicle ( driver ) ;
30313: LD_VAR 0 18
30317: PPUSH
30318: CALL_OW 181
// end ; continue ;
30322: GO 29966
// end ; if not cleaners or not tmp in cleaners then
30324: LD_VAR 0 6
30328: NOT
30329: IFTRUE 30344
30331: PUSH
30332: LD_VAR 0 13
30336: PUSH
30337: LD_VAR 0 6
30341: IN
30342: NOT
30343: OR
30344: IFFALSE 30653
// begin if dep then
30346: LD_VAR 0 17
30350: IFFALSE 30486
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30352: LD_ADDR_VAR 0 16
30356: PUSH
30357: LD_VAR 0 17
30361: PUSH
30362: LD_INT 1
30364: ARRAY
30365: PPUSH
30366: CALL_OW 250
30370: PPUSH
30371: LD_VAR 0 17
30375: PUSH
30376: LD_INT 1
30378: ARRAY
30379: PPUSH
30380: CALL_OW 254
30384: PPUSH
30385: LD_INT 5
30387: PPUSH
30388: CALL_OW 272
30392: PUSH
30393: LD_VAR 0 17
30397: PUSH
30398: LD_INT 1
30400: ARRAY
30401: PPUSH
30402: CALL_OW 251
30406: PPUSH
30407: LD_VAR 0 17
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: CALL_OW 254
30420: PPUSH
30421: LD_INT 5
30423: PPUSH
30424: CALL_OW 273
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30433: LD_VAR 0 16
30437: PUSH
30438: LD_INT 1
30440: ARRAY
30441: PPUSH
30442: LD_VAR 0 16
30446: PUSH
30447: LD_INT 2
30449: ARRAY
30450: PPUSH
30451: CALL_OW 488
30455: IFFALSE 30486
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30457: LD_VAR 0 13
30461: PPUSH
30462: LD_VAR 0 16
30466: PUSH
30467: LD_INT 1
30469: ARRAY
30470: PPUSH
30471: LD_VAR 0 16
30475: PUSH
30476: LD_INT 2
30478: ARRAY
30479: PPUSH
30480: CALL_OW 111
// continue ;
30484: GO 29966
// end ; end ; r := GetDir ( tmp ) ;
30486: LD_ADDR_VAR 0 15
30490: PUSH
30491: LD_VAR 0 13
30495: PPUSH
30496: CALL_OW 254
30500: ST_TO_ADDR
// if r = 5 then
30501: LD_VAR 0 15
30505: PUSH
30506: LD_INT 5
30508: EQUAL
30509: IFFALSE 30519
// r := 0 ;
30511: LD_ADDR_VAR 0 15
30515: PUSH
30516: LD_INT 0
30518: ST_TO_ADDR
// for j = r to 5 do
30519: LD_ADDR_VAR 0 10
30523: PUSH
30524: DOUBLE
30525: LD_VAR 0 15
30529: DEC
30530: ST_TO_ADDR
30531: LD_INT 5
30533: PUSH
30534: FOR_TO
30535: IFFALSE 30651
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30537: LD_ADDR_VAR 0 11
30541: PUSH
30542: LD_VAR 0 13
30546: PPUSH
30547: CALL_OW 250
30551: PPUSH
30552: LD_VAR 0 10
30556: PPUSH
30557: LD_INT 2
30559: PPUSH
30560: CALL_OW 272
30564: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30565: LD_ADDR_VAR 0 12
30569: PUSH
30570: LD_VAR 0 13
30574: PPUSH
30575: CALL_OW 251
30579: PPUSH
30580: LD_VAR 0 10
30584: PPUSH
30585: LD_INT 2
30587: PPUSH
30588: CALL_OW 273
30592: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30593: LD_VAR 0 11
30597: PPUSH
30598: LD_VAR 0 12
30602: PPUSH
30603: CALL_OW 488
30607: IFFALSE 30626
30609: PUSH
30610: LD_VAR 0 11
30614: PPUSH
30615: LD_VAR 0 12
30619: PPUSH
30620: CALL_OW 428
30624: NOT
30625: AND
30626: IFFALSE 30649
// begin ComMoveXY ( tmp , _x , _y ) ;
30628: LD_VAR 0 13
30632: PPUSH
30633: LD_VAR 0 11
30637: PPUSH
30638: LD_VAR 0 12
30642: PPUSH
30643: CALL_OW 111
// break ;
30647: GO 30651
// end ; end ;
30649: GO 30534
30651: POP
30652: POP
// end ; end ;
30653: GO 29966
30655: POP
30656: POP
// end ;
30657: LD_VAR 0 8
30661: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30662: LD_INT 0
30664: PPUSH
// result := true ;
30665: LD_ADDR_VAR 0 3
30669: PUSH
30670: LD_INT 1
30672: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30673: LD_VAR 0 2
30677: PUSH
30678: LD_INT 24
30680: DOUBLE
30681: EQUAL
30682: IFTRUE 30692
30684: LD_INT 33
30686: DOUBLE
30687: EQUAL
30688: IFTRUE 30692
30690: GO 30717
30692: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30693: LD_ADDR_VAR 0 3
30697: PUSH
30698: LD_INT 32
30700: PPUSH
30701: LD_VAR 0 1
30705: PPUSH
30706: CALL_OW 321
30710: PUSH
30711: LD_INT 2
30713: EQUAL
30714: ST_TO_ADDR
30715: GO 31033
30717: LD_INT 20
30719: DOUBLE
30720: EQUAL
30721: IFTRUE 30725
30723: GO 30750
30725: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30726: LD_ADDR_VAR 0 3
30730: PUSH
30731: LD_INT 6
30733: PPUSH
30734: LD_VAR 0 1
30738: PPUSH
30739: CALL_OW 321
30743: PUSH
30744: LD_INT 2
30746: EQUAL
30747: ST_TO_ADDR
30748: GO 31033
30750: LD_INT 22
30752: DOUBLE
30753: EQUAL
30754: IFTRUE 30764
30756: LD_INT 36
30758: DOUBLE
30759: EQUAL
30760: IFTRUE 30764
30762: GO 30789
30764: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30765: LD_ADDR_VAR 0 3
30769: PUSH
30770: LD_INT 15
30772: PPUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 321
30782: PUSH
30783: LD_INT 2
30785: EQUAL
30786: ST_TO_ADDR
30787: GO 31033
30789: LD_INT 30
30791: DOUBLE
30792: EQUAL
30793: IFTRUE 30797
30795: GO 30822
30797: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30798: LD_ADDR_VAR 0 3
30802: PUSH
30803: LD_INT 20
30805: PPUSH
30806: LD_VAR 0 1
30810: PPUSH
30811: CALL_OW 321
30815: PUSH
30816: LD_INT 2
30818: EQUAL
30819: ST_TO_ADDR
30820: GO 31033
30822: LD_INT 28
30824: DOUBLE
30825: EQUAL
30826: IFTRUE 30836
30828: LD_INT 21
30830: DOUBLE
30831: EQUAL
30832: IFTRUE 30836
30834: GO 30861
30836: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30837: LD_ADDR_VAR 0 3
30841: PUSH
30842: LD_INT 21
30844: PPUSH
30845: LD_VAR 0 1
30849: PPUSH
30850: CALL_OW 321
30854: PUSH
30855: LD_INT 2
30857: EQUAL
30858: ST_TO_ADDR
30859: GO 31033
30861: LD_INT 16
30863: DOUBLE
30864: EQUAL
30865: IFTRUE 30869
30867: GO 30894
30869: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30870: LD_ADDR_VAR 0 3
30874: PUSH
30875: LD_INT 84
30877: PPUSH
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 321
30887: PUSH
30888: LD_INT 2
30890: EQUAL
30891: ST_TO_ADDR
30892: GO 31033
30894: LD_INT 19
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30908
30900: LD_INT 23
30902: DOUBLE
30903: EQUAL
30904: IFTRUE 30908
30906: GO 30933
30908: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30909: LD_ADDR_VAR 0 3
30913: PUSH
30914: LD_INT 83
30916: PPUSH
30917: LD_VAR 0 1
30921: PPUSH
30922: CALL_OW 321
30926: PUSH
30927: LD_INT 2
30929: EQUAL
30930: ST_TO_ADDR
30931: GO 31033
30933: LD_INT 17
30935: DOUBLE
30936: EQUAL
30937: IFTRUE 30941
30939: GO 30966
30941: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_INT 39
30949: PPUSH
30950: LD_VAR 0 1
30954: PPUSH
30955: CALL_OW 321
30959: PUSH
30960: LD_INT 2
30962: EQUAL
30963: ST_TO_ADDR
30964: GO 31033
30966: LD_INT 18
30968: DOUBLE
30969: EQUAL
30970: IFTRUE 30974
30972: GO 30999
30974: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
30975: LD_ADDR_VAR 0 3
30979: PUSH
30980: LD_INT 40
30982: PPUSH
30983: LD_VAR 0 1
30987: PPUSH
30988: CALL_OW 321
30992: PUSH
30993: LD_INT 2
30995: EQUAL
30996: ST_TO_ADDR
30997: GO 31033
30999: LD_INT 27
31001: DOUBLE
31002: EQUAL
31003: IFTRUE 31007
31005: GO 31032
31007: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
31008: LD_ADDR_VAR 0 3
31012: PUSH
31013: LD_INT 35
31015: PPUSH
31016: LD_VAR 0 1
31020: PPUSH
31021: CALL_OW 321
31025: PUSH
31026: LD_INT 2
31028: EQUAL
31029: ST_TO_ADDR
31030: GO 31033
31032: POP
// end ;
31033: LD_VAR 0 3
31037: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
31038: LD_INT 0
31040: PPUSH
31041: PPUSH
31042: PPUSH
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
31047: PPUSH
31048: PPUSH
31049: PPUSH
31050: PPUSH
// result := false ;
31051: LD_ADDR_VAR 0 6
31055: PUSH
31056: LD_INT 0
31058: ST_TO_ADDR
// if btype = b_depot then
31059: LD_VAR 0 2
31063: PUSH
31064: LD_INT 0
31066: EQUAL
31067: IFFALSE 31079
// begin result := true ;
31069: LD_ADDR_VAR 0 6
31073: PUSH
31074: LD_INT 1
31076: ST_TO_ADDR
// exit ;
31077: GO 31933
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
31079: LD_VAR 0 1
31083: NOT
31084: IFTRUE 31109
31086: PUSH
31087: LD_VAR 0 1
31091: PPUSH
31092: CALL_OW 266
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 1
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: IN
31107: NOT
31108: OR
31109: IFTRUE 31118
31111: PUSH
31112: LD_VAR 0 2
31116: NOT
31117: OR
31118: IFTRUE 31154
31120: PUSH
31121: LD_VAR 0 5
31125: PUSH
31126: LD_INT 0
31128: PUSH
31129: LD_INT 1
31131: PUSH
31132: LD_INT 2
31134: PUSH
31135: LD_INT 3
31137: PUSH
31138: LD_INT 4
31140: PUSH
31141: LD_INT 5
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: IN
31152: NOT
31153: OR
31154: IFTRUE 31173
31156: PUSH
31157: LD_VAR 0 3
31161: PPUSH
31162: LD_VAR 0 4
31166: PPUSH
31167: CALL_OW 488
31171: NOT
31172: OR
31173: IFFALSE 31177
// exit ;
31175: GO 31933
// side := GetSide ( depot ) ;
31177: LD_ADDR_VAR 0 9
31181: PUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 255
31191: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
31192: LD_VAR 0 9
31196: PPUSH
31197: LD_VAR 0 2
31201: PPUSH
31202: CALL 30662 0 2
31206: NOT
31207: IFFALSE 31211
// exit ;
31209: GO 31933
// pom := GetBase ( depot ) ;
31211: LD_ADDR_VAR 0 10
31215: PUSH
31216: LD_VAR 0 1
31220: PPUSH
31221: CALL_OW 274
31225: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
31226: LD_ADDR_VAR 0 11
31230: PUSH
31231: LD_VAR 0 2
31235: PPUSH
31236: LD_VAR 0 1
31240: PPUSH
31241: CALL_OW 248
31245: PPUSH
31246: CALL_OW 450
31250: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31251: LD_VAR 0 10
31255: PPUSH
31256: LD_INT 1
31258: PPUSH
31259: CALL_OW 275
31263: PUSH
31264: LD_VAR 0 11
31268: PUSH
31269: LD_INT 1
31271: ARRAY
31272: GREATEREQUAL
31273: IFFALSE 31299
31275: PUSH
31276: LD_VAR 0 10
31280: PPUSH
31281: LD_INT 2
31283: PPUSH
31284: CALL_OW 275
31288: PUSH
31289: LD_VAR 0 11
31293: PUSH
31294: LD_INT 2
31296: ARRAY
31297: GREATEREQUAL
31298: AND
31299: IFFALSE 31325
31301: PUSH
31302: LD_VAR 0 10
31306: PPUSH
31307: LD_INT 3
31309: PPUSH
31310: CALL_OW 275
31314: PUSH
31315: LD_VAR 0 11
31319: PUSH
31320: LD_INT 3
31322: ARRAY
31323: GREATEREQUAL
31324: AND
31325: NOT
31326: IFFALSE 31330
// exit ;
31328: GO 31933
// if GetBType ( depot ) = b_depot then
31330: LD_VAR 0 1
31334: PPUSH
31335: CALL_OW 266
31339: PUSH
31340: LD_INT 0
31342: EQUAL
31343: IFFALSE 31355
// dist := 28 else
31345: LD_ADDR_VAR 0 14
31349: PUSH
31350: LD_INT 28
31352: ST_TO_ADDR
31353: GO 31363
// dist := 36 ;
31355: LD_ADDR_VAR 0 14
31359: PUSH
31360: LD_INT 36
31362: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31363: LD_VAR 0 1
31367: PPUSH
31368: LD_VAR 0 3
31372: PPUSH
31373: LD_VAR 0 4
31377: PPUSH
31378: CALL_OW 297
31382: PUSH
31383: LD_VAR 0 14
31387: GREATER
31388: IFFALSE 31392
// exit ;
31390: GO 31933
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31392: LD_ADDR_VAR 0 12
31396: PUSH
31397: LD_VAR 0 2
31401: PPUSH
31402: LD_VAR 0 3
31406: PPUSH
31407: LD_VAR 0 4
31411: PPUSH
31412: LD_VAR 0 5
31416: PPUSH
31417: LD_VAR 0 1
31421: PPUSH
31422: CALL_OW 248
31426: PPUSH
31427: LD_INT 0
31429: PPUSH
31430: CALL 31938 0 6
31434: ST_TO_ADDR
// if not hexes then
31435: LD_VAR 0 12
31439: NOT
31440: IFFALSE 31444
// exit ;
31442: GO 31933
// hex := GetHexInfo ( x , y ) ;
31444: LD_ADDR_VAR 0 15
31448: PUSH
31449: LD_VAR 0 3
31453: PPUSH
31454: LD_VAR 0 4
31458: PPUSH
31459: CALL_OW 546
31463: ST_TO_ADDR
// if hex [ 1 ] then
31464: LD_VAR 0 15
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: IFFALSE 31476
// exit ;
31474: GO 31933
// height := hex [ 2 ] ;
31476: LD_ADDR_VAR 0 13
31480: PUSH
31481: LD_VAR 0 15
31485: PUSH
31486: LD_INT 2
31488: ARRAY
31489: ST_TO_ADDR
// for i = 1 to hexes do
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: DOUBLE
31496: LD_INT 1
31498: DEC
31499: ST_TO_ADDR
31500: LD_VAR 0 12
31504: PUSH
31505: FOR_TO
31506: IFFALSE 31850
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31508: LD_VAR 0 12
31512: PUSH
31513: LD_VAR 0 7
31517: ARRAY
31518: PUSH
31519: LD_INT 1
31521: ARRAY
31522: PPUSH
31523: LD_VAR 0 12
31527: PUSH
31528: LD_VAR 0 7
31532: ARRAY
31533: PUSH
31534: LD_INT 2
31536: ARRAY
31537: PPUSH
31538: CALL_OW 488
31542: NOT
31543: IFTRUE 31585
31545: PUSH
31546: LD_VAR 0 12
31550: PUSH
31551: LD_VAR 0 7
31555: ARRAY
31556: PUSH
31557: LD_INT 1
31559: ARRAY
31560: PPUSH
31561: LD_VAR 0 12
31565: PUSH
31566: LD_VAR 0 7
31570: ARRAY
31571: PUSH
31572: LD_INT 2
31574: ARRAY
31575: PPUSH
31576: CALL_OW 428
31580: PUSH
31581: LD_INT 0
31583: GREATER
31584: OR
31585: IFTRUE 31623
31587: PUSH
31588: LD_VAR 0 12
31592: PUSH
31593: LD_VAR 0 7
31597: ARRAY
31598: PUSH
31599: LD_INT 1
31601: ARRAY
31602: PPUSH
31603: LD_VAR 0 12
31607: PUSH
31608: LD_VAR 0 7
31612: ARRAY
31613: PUSH
31614: LD_INT 2
31616: ARRAY
31617: PPUSH
31618: CALL_OW 351
31622: OR
31623: IFFALSE 31629
// exit ;
31625: POP
31626: POP
31627: GO 31933
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31629: LD_ADDR_VAR 0 8
31633: PUSH
31634: LD_VAR 0 12
31638: PUSH
31639: LD_VAR 0 7
31643: ARRAY
31644: PUSH
31645: LD_INT 1
31647: ARRAY
31648: PPUSH
31649: LD_VAR 0 12
31653: PUSH
31654: LD_VAR 0 7
31658: ARRAY
31659: PUSH
31660: LD_INT 2
31662: ARRAY
31663: PPUSH
31664: CALL_OW 546
31668: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31669: LD_VAR 0 8
31673: PUSH
31674: LD_INT 1
31676: ARRAY
31677: IFTRUE 31699
31679: PUSH
31680: LD_VAR 0 8
31684: PUSH
31685: LD_INT 2
31687: ARRAY
31688: PUSH
31689: LD_VAR 0 13
31693: PUSH
31694: LD_INT 2
31696: PLUS
31697: GREATER
31698: OR
31699: IFTRUE 31721
31701: PUSH
31702: LD_VAR 0 8
31706: PUSH
31707: LD_INT 2
31709: ARRAY
31710: PUSH
31711: LD_VAR 0 13
31715: PUSH
31716: LD_INT 2
31718: MINUS
31719: LESS
31720: OR
31721: IFTRUE 31789
31723: PUSH
31724: LD_VAR 0 8
31728: PUSH
31729: LD_INT 3
31731: ARRAY
31732: PUSH
31733: LD_INT 0
31735: PUSH
31736: LD_INT 8
31738: PUSH
31739: LD_INT 9
31741: PUSH
31742: LD_INT 10
31744: PUSH
31745: LD_INT 11
31747: PUSH
31748: LD_INT 12
31750: PUSH
31751: LD_INT 13
31753: PUSH
31754: LD_INT 16
31756: PUSH
31757: LD_INT 17
31759: PUSH
31760: LD_INT 18
31762: PUSH
31763: LD_INT 19
31765: PUSH
31766: LD_INT 20
31768: PUSH
31769: LD_INT 21
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: LIST
31784: LIST
31785: LIST
31786: IN
31787: NOT
31788: OR
31789: IFTRUE 31802
31791: PUSH
31792: LD_VAR 0 8
31796: PUSH
31797: LD_INT 5
31799: ARRAY
31800: NOT
31801: OR
31802: IFTRUE 31842
31804: PUSH
31805: LD_VAR 0 8
31809: PUSH
31810: LD_INT 6
31812: ARRAY
31813: PUSH
31814: LD_INT 1
31816: PUSH
31817: LD_INT 2
31819: PUSH
31820: LD_INT 7
31822: PUSH
31823: LD_INT 9
31825: PUSH
31826: LD_INT 10
31828: PUSH
31829: LD_INT 11
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: IN
31840: NOT
31841: OR
31842: IFFALSE 31848
// exit ;
31844: POP
31845: POP
31846: GO 31933
// end ;
31848: GO 31505
31850: POP
31851: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31852: LD_VAR 0 9
31856: PPUSH
31857: LD_VAR 0 3
31861: PPUSH
31862: LD_VAR 0 4
31866: PPUSH
31867: LD_INT 20
31869: PPUSH
31870: CALL 23752 0 4
31874: PUSH
31875: LD_INT 4
31877: ARRAY
31878: IFFALSE 31882
// exit ;
31880: GO 31933
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31882: LD_VAR 0 2
31886: PUSH
31887: LD_INT 29
31889: PUSH
31890: LD_INT 30
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: IN
31897: IFFALSE 31921
31899: PUSH
31900: LD_VAR 0 3
31904: PPUSH
31905: LD_VAR 0 4
31909: PPUSH
31910: LD_VAR 0 9
31914: PPUSH
31915: CALL_OW 440
31919: NOT
31920: AND
31921: IFFALSE 31925
// exit ;
31923: GO 31933
// result := true ;
31925: LD_ADDR_VAR 0 6
31929: PUSH
31930: LD_INT 1
31932: ST_TO_ADDR
// end ;
31933: LD_VAR 0 6
31937: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31938: LD_INT 0
31940: PPUSH
31941: PPUSH
31942: PPUSH
31943: PPUSH
31944: PPUSH
31945: PPUSH
31946: PPUSH
31947: PPUSH
31948: PPUSH
31949: PPUSH
31950: PPUSH
31951: PPUSH
31952: PPUSH
31953: PPUSH
31954: PPUSH
31955: PPUSH
31956: PPUSH
31957: PPUSH
31958: PPUSH
31959: PPUSH
31960: PPUSH
31961: PPUSH
31962: PPUSH
31963: PPUSH
31964: PPUSH
31965: PPUSH
31966: PPUSH
31967: PPUSH
31968: PPUSH
31969: PPUSH
31970: PPUSH
31971: PPUSH
31972: PPUSH
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
31977: PPUSH
31978: PPUSH
31979: PPUSH
31980: PPUSH
31981: PPUSH
31982: PPUSH
31983: PPUSH
31984: PPUSH
31985: PPUSH
31986: PPUSH
31987: PPUSH
31988: PPUSH
31989: PPUSH
31990: PPUSH
31991: PPUSH
31992: PPUSH
31993: PPUSH
31994: PPUSH
31995: PPUSH
31996: PPUSH
31997: PPUSH
// result = [ ] ;
31998: LD_ADDR_VAR 0 7
32002: PUSH
32003: EMPTY
32004: ST_TO_ADDR
// temp_list = [ ] ;
32005: LD_ADDR_VAR 0 9
32009: PUSH
32010: EMPTY
32011: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
32012: LD_VAR 0 4
32016: PUSH
32017: LD_INT 0
32019: PUSH
32020: LD_INT 1
32022: PUSH
32023: LD_INT 2
32025: PUSH
32026: LD_INT 3
32028: PUSH
32029: LD_INT 4
32031: PUSH
32032: LD_INT 5
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: IN
32043: NOT
32044: IFTRUE 32087
32046: PUSH
32047: LD_VAR 0 1
32051: PUSH
32052: LD_INT 0
32054: PUSH
32055: LD_INT 1
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: IN
32062: IFFALSE 32086
32064: PUSH
32065: LD_VAR 0 5
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: LD_INT 2
32075: PUSH
32076: LD_INT 3
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: LIST
32083: IN
32084: NOT
32085: AND
32086: OR
32087: IFFALSE 32091
// exit ;
32089: GO 50490
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
32091: LD_VAR 0 1
32095: PUSH
32096: LD_INT 6
32098: PUSH
32099: LD_INT 7
32101: PUSH
32102: LD_INT 8
32104: PUSH
32105: LD_INT 13
32107: PUSH
32108: LD_INT 12
32110: PUSH
32111: LD_INT 15
32113: PUSH
32114: LD_INT 11
32116: PUSH
32117: LD_INT 14
32119: PUSH
32120: LD_INT 10
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: LIST
32127: LIST
32128: LIST
32129: LIST
32130: LIST
32131: LIST
32132: LIST
32133: IN
32134: IFFALSE 32144
// btype = b_lab ;
32136: LD_ADDR_VAR 0 1
32140: PUSH
32141: LD_INT 6
32143: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
32144: LD_VAR 0 6
32148: PUSH
32149: LD_INT 0
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 2
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: LIST
32162: IN
32163: NOT
32164: IFTRUE 32232
32166: PUSH
32167: LD_VAR 0 1
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: LD_INT 1
32177: PUSH
32178: LD_INT 2
32180: PUSH
32181: LD_INT 3
32183: PUSH
32184: LD_INT 6
32186: PUSH
32187: LD_INT 36
32189: PUSH
32190: LD_INT 4
32192: PUSH
32193: LD_INT 5
32195: PUSH
32196: LD_INT 31
32198: PUSH
32199: LD_INT 32
32201: PUSH
32202: LD_INT 33
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: IN
32218: NOT
32219: IFFALSE 32231
32221: PUSH
32222: LD_VAR 0 6
32226: PUSH
32227: LD_INT 1
32229: EQUAL
32230: AND
32231: OR
32232: IFTRUE 32264
32234: PUSH
32235: LD_VAR 0 1
32239: PUSH
32240: LD_INT 2
32242: PUSH
32243: LD_INT 3
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: IN
32250: NOT
32251: IFFALSE 32263
32253: PUSH
32254: LD_VAR 0 6
32258: PUSH
32259: LD_INT 2
32261: EQUAL
32262: AND
32263: OR
32264: IFFALSE 32274
// mode = 0 ;
32266: LD_ADDR_VAR 0 6
32270: PUSH
32271: LD_INT 0
32273: ST_TO_ADDR
// case mode of 0 :
32274: LD_VAR 0 6
32278: PUSH
32279: LD_INT 0
32281: DOUBLE
32282: EQUAL
32283: IFTRUE 32287
32285: GO 43740
32287: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32288: LD_ADDR_VAR 0 11
32292: PUSH
32293: LD_INT 0
32295: PUSH
32296: LD_INT 0
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: LD_INT 1
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 1
32326: PUSH
32327: LD_INT 1
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 1
32346: NEG
32347: PUSH
32348: LD_INT 0
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 1
32357: NEG
32358: PUSH
32359: LD_INT 1
32361: NEG
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 0
32381: PUSH
32382: LD_INT 2
32384: NEG
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: PUSH
32404: LD_INT 2
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: LD_INT 2
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 1
32434: PUSH
32435: LD_INT 3
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: LD_INT 3
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: NEG
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32481: LD_ADDR_VAR 0 12
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: LD_INT 1
32554: NEG
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 2
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 2
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 2
32604: NEG
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: LD_INT 1
32619: NEG
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 2
32627: NEG
32628: PUSH
32629: LD_INT 1
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 3
32638: NEG
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 3
32649: NEG
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32677: LD_ADDR_VAR 0 13
32681: PUSH
32682: LD_INT 0
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 0
32694: PUSH
32695: LD_INT 1
32697: NEG
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: LD_INT 1
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 0
32725: PUSH
32726: LD_INT 1
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: PUSH
32733: LD_INT 1
32735: NEG
32736: PUSH
32737: LD_INT 0
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 1
32746: NEG
32747: PUSH
32748: LD_INT 1
32750: NEG
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 1
32758: NEG
32759: PUSH
32760: LD_INT 2
32762: NEG
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 2
32800: NEG
32801: PUSH
32802: LD_INT 1
32804: NEG
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 2
32812: NEG
32813: PUSH
32814: LD_INT 2
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: NEG
32825: PUSH
32826: LD_INT 3
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 3
32836: NEG
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 3
32848: NEG
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32876: LD_ADDR_VAR 0 14
32880: PUSH
32881: LD_INT 0
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 1
32991: PUSH
32992: LD_INT 2
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: LD_INT 2
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: NEG
33012: PUSH
33013: LD_INT 1
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 3
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 3
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
33072: LD_ADDR_VAR 0 15
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 0
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 0
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 0
33120: PUSH
33121: LD_INT 1
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: LD_INT 0
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 1
33141: NEG
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 1
33153: PUSH
33154: LD_INT 1
33156: NEG
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 2
33164: PUSH
33165: LD_INT 0
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 2
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: NEG
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 2
33195: NEG
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 2
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 3
33229: PUSH
33230: LD_INT 0
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 3
33239: PUSH
33240: LD_INT 1
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
33265: LD_ADDR_VAR 0 16
33269: PUSH
33270: LD_INT 0
33272: PUSH
33273: LD_INT 0
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 0
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: PUSH
33294: LD_INT 0
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 1
33303: PUSH
33304: LD_INT 1
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: LD_INT 0
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 1
33334: NEG
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 1
33346: NEG
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 2
33388: NEG
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 2
33400: NEG
33401: PUSH
33402: LD_INT 2
33404: NEG
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 3
33412: PUSH
33413: LD_INT 2
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 3
33422: PUSH
33423: LD_INT 3
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 2
33432: PUSH
33433: LD_INT 3
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33458: LD_ADDR_VAR 0 17
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 1
33478: NEG
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 2
33554: NEG
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: LD_INT 1
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: LD_INT 0
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: PUSH
33584: LD_INT 1
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 2
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 2
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 0
33613: PUSH
33614: LD_INT 2
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 1
33623: NEG
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 2
33634: NEG
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 2
33645: NEG
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: NEG
33658: PUSH
33659: LD_INT 2
33661: NEG
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33688: LD_ADDR_VAR 0 18
33692: PUSH
33693: LD_INT 0
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 1
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 1
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: LD_INT 2
33773: NEG
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: LD_INT 2
33784: NEG
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 2
33803: PUSH
33804: LD_INT 0
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 1
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 2
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 0
33843: PUSH
33844: LD_INT 2
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: NEG
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: NEG
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: LD_INT 1
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: LD_INT 2
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: EMPTY
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33918: LD_ADDR_VAR 0 19
33922: PUSH
33923: LD_INT 0
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: LD_INT 0
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 1
33956: PUSH
33957: LD_INT 1
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: LD_INT 0
33966: PUSH
33967: LD_INT 1
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: LD_INT 0
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 1
33987: NEG
33988: PUSH
33989: LD_INT 1
33991: NEG
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: LD_INT 2
34003: NEG
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 0
34011: PUSH
34012: LD_INT 2
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: PUSH
34023: LD_INT 1
34025: NEG
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 2
34033: PUSH
34034: LD_INT 0
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 2
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 2
34053: PUSH
34054: LD_INT 2
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 1
34063: PUSH
34064: LD_INT 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: LD_INT 2
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 2
34094: NEG
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: LD_INT 1
34109: NEG
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: PUSH
34115: LD_INT 2
34117: NEG
34118: PUSH
34119: LD_INT 2
34121: NEG
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: LIST
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: LIST
34147: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34148: LD_ADDR_VAR 0 20
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 1
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 0
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: LD_INT 1
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: NEG
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 0
34241: PUSH
34242: LD_INT 2
34244: NEG
34245: PUSH
34246: EMPTY
34247: LIST
34248: LIST
34249: PUSH
34250: LD_INT 1
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 2
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 2
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: PUSH
34284: LD_INT 2
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: LD_INT 2
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 0
34303: PUSH
34304: LD_INT 2
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: NEG
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: NEG
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: NEG
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34378: LD_ADDR_VAR 0 21
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: LD_INT 1
34398: NEG
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 1
34416: PUSH
34417: LD_INT 1
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: LD_INT 1
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: LD_INT 1
34451: NEG
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 1
34459: NEG
34460: PUSH
34461: LD_INT 2
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: LD_INT 2
34474: NEG
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: LD_INT 1
34482: PUSH
34483: LD_INT 1
34485: NEG
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 2
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 1
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 2
34513: PUSH
34514: LD_INT 2
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 2
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 0
34533: PUSH
34534: LD_INT 2
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 1
34543: NEG
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 2
34554: NEG
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 2
34577: NEG
34578: PUSH
34579: LD_INT 2
34581: NEG
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34608: LD_ADDR_VAR 0 22
34612: PUSH
34613: LD_INT 0
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: LD_INT 0
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 1
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 0
34656: PUSH
34657: LD_INT 1
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 1
34677: NEG
34678: PUSH
34679: LD_INT 1
34681: NEG
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 1
34689: NEG
34690: PUSH
34691: LD_INT 2
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 0
34701: PUSH
34702: LD_INT 2
34704: NEG
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: NEG
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 2
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 2
34733: PUSH
34734: LD_INT 1
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 2
34743: PUSH
34744: LD_INT 2
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: LD_INT 2
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 0
34763: PUSH
34764: LD_INT 2
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 2
34784: NEG
34785: PUSH
34786: LD_INT 0
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 2
34807: NEG
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34838: LD_ADDR_VAR 0 23
34842: PUSH
34843: LD_INT 0
34845: PUSH
34846: LD_INT 0
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 1
34866: PUSH
34867: LD_INT 0
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: LD_INT 1
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 0
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 1
34896: NEG
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: LD_INT 2
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 0
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: LD_INT 1
34945: NEG
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: PUSH
34954: LD_INT 0
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: LD_INT 1
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: LD_INT 2
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: PUSH
34984: LD_INT 2
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 0
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: EMPTY
35009: LIST
35010: LIST
35011: PUSH
35012: LD_INT 2
35014: NEG
35015: PUSH
35016: LD_INT 0
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: LD_INT 1
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 2
35037: NEG
35038: PUSH
35039: LD_INT 2
35041: NEG
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: NEG
35050: PUSH
35051: LD_INT 3
35053: NEG
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 1
35061: NEG
35062: PUSH
35063: LD_INT 3
35065: NEG
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: LD_INT 2
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 2
35084: PUSH
35085: LD_INT 1
35087: NEG
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
35118: LD_ADDR_VAR 0 24
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: LD_INT 0
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: LD_INT 1
35138: NEG
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 1
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: LD_INT 0
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 1
35199: NEG
35200: PUSH
35201: LD_INT 2
35203: NEG
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: LD_INT 2
35214: NEG
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: LD_INT 1
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 2
35253: PUSH
35254: LD_INT 2
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: PUSH
35264: LD_INT 2
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 0
35273: PUSH
35274: LD_INT 2
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 1
35283: NEG
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 2
35294: NEG
35295: PUSH
35296: LD_INT 0
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 2
35305: NEG
35306: PUSH
35307: LD_INT 1
35309: NEG
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 2
35317: NEG
35318: PUSH
35319: LD_INT 2
35321: NEG
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 1
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 2
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 3
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 3
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35394: LD_ADDR_VAR 0 25
35398: PUSH
35399: LD_INT 0
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 1
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: LD_INT 1
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: LD_INT 1
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: LD_INT 1
35467: NEG
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 1
35475: NEG
35476: PUSH
35477: LD_INT 2
35479: NEG
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 0
35487: PUSH
35488: LD_INT 2
35490: NEG
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 1
35498: PUSH
35499: LD_INT 1
35501: NEG
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 2
35509: PUSH
35510: LD_INT 0
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 2
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 2
35529: PUSH
35530: LD_INT 2
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: PUSH
35540: LD_INT 2
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 0
35549: PUSH
35550: LD_INT 2
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 1
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 2
35570: NEG
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 2
35581: NEG
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: NEG
35594: PUSH
35595: LD_INT 2
35597: NEG
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 3
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 3
35615: PUSH
35616: LD_INT 2
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 2
35625: PUSH
35626: LD_INT 3
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: PUSH
35636: LD_INT 3
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35668: LD_ADDR_VAR 0 26
35672: PUSH
35673: LD_INT 0
35675: PUSH
35676: LD_INT 0
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 1
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 0
35716: PUSH
35717: LD_INT 1
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: LD_INT 1
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 1
35749: NEG
35750: PUSH
35751: LD_INT 2
35753: NEG
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: LD_INT 1
35775: NEG
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 2
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 1
35813: PUSH
35814: LD_INT 2
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: LD_INT 2
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 1
35833: NEG
35834: PUSH
35835: LD_INT 1
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 2
35844: NEG
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 2
35855: NEG
35856: PUSH
35857: LD_INT 1
35859: NEG
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 2
35867: NEG
35868: PUSH
35869: LD_INT 2
35871: NEG
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 2
35879: PUSH
35880: LD_INT 3
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 1
35889: PUSH
35890: LD_INT 3
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 2
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: LIST
35942: LIST
35943: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35944: LD_ADDR_VAR 0 27
35948: PUSH
35949: LD_INT 0
35951: PUSH
35952: LD_INT 0
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: LD_INT 1
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: LD_INT 0
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 1
35982: PUSH
35983: LD_INT 1
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: LD_INT 1
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: LD_INT 2
36029: NEG
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: LD_INT 2
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 1
36048: PUSH
36049: LD_INT 1
36051: NEG
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: LD_INT 0
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 2
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 2
36079: PUSH
36080: LD_INT 2
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 1
36089: PUSH
36090: LD_INT 2
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: LD_INT 2
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 2
36120: NEG
36121: PUSH
36122: LD_INT 0
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 2
36131: NEG
36132: PUSH
36133: LD_INT 1
36135: NEG
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 2
36143: NEG
36144: PUSH
36145: LD_INT 2
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: NEG
36156: PUSH
36157: LD_INT 2
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 2
36166: NEG
36167: PUSH
36168: LD_INT 1
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 3
36177: NEG
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 3
36189: NEG
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36224: LD_ADDR_VAR 0 28
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: LD_INT 0
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 0
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 0
36272: PUSH
36273: LD_INT 1
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: NEG
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: LD_INT 2
36309: NEG
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 2
36320: NEG
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 1
36328: PUSH
36329: LD_INT 1
36331: NEG
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 2
36339: PUSH
36340: LD_INT 0
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: LD_INT 1
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 2
36359: PUSH
36360: LD_INT 2
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 2
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 0
36379: PUSH
36380: LD_INT 2
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: NEG
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 2
36411: NEG
36412: PUSH
36413: LD_INT 1
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 2
36423: NEG
36424: PUSH
36425: LD_INT 2
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: NEG
36436: PUSH
36437: LD_INT 3
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: LD_INT 3
36451: NEG
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 3
36459: NEG
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 3
36471: NEG
36472: PUSH
36473: LD_INT 2
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36506: LD_ADDR_VAR 0 29
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 1
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: LD_INT 2
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: PUSH
36622: LD_INT 0
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 2
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: LD_INT 2
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: LD_INT 1
36661: NEG
36662: PUSH
36663: LD_INT 1
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 2
36672: NEG
36673: PUSH
36674: LD_INT 1
36676: NEG
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 2
36684: NEG
36685: PUSH
36686: LD_INT 2
36688: NEG
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 2
36696: NEG
36697: PUSH
36698: LD_INT 3
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 2
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 3
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 3
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 3
36750: NEG
36751: PUSH
36752: LD_INT 2
36754: NEG
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36785: LD_ADDR_VAR 0 30
36789: PUSH
36790: LD_INT 0
36792: PUSH
36793: LD_INT 0
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 0
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 1
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 0
36833: PUSH
36834: LD_INT 1
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: LD_INT 1
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 0
36878: PUSH
36879: LD_INT 2
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 1
36889: PUSH
36890: LD_INT 1
36892: NEG
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: LD_INT 0
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: LD_INT 1
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 2
36920: PUSH
36921: LD_INT 2
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: LD_INT 2
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 2
36951: NEG
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 2
36962: NEG
36963: PUSH
36964: LD_INT 1
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: LD_INT 3
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: LD_INT 2
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 3
36997: PUSH
36998: LD_INT 2
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 2
37007: PUSH
37008: LD_INT 3
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 2
37017: NEG
37018: PUSH
37019: LD_INT 1
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 3
37028: NEG
37029: PUSH
37030: LD_INT 1
37032: NEG
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37063: LD_ADDR_VAR 0 31
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 0
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 1
37091: PUSH
37092: LD_INT 0
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 1
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: NEG
37122: PUSH
37123: LD_INT 0
37125: PUSH
37126: EMPTY
37127: LIST
37128: LIST
37129: PUSH
37130: LD_INT 1
37132: NEG
37133: PUSH
37134: LD_INT 1
37136: NEG
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 1
37144: NEG
37145: PUSH
37146: LD_INT 2
37148: NEG
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: LD_INT 1
37159: NEG
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 2
37167: PUSH
37168: LD_INT 0
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: PUSH
37175: LD_INT 2
37177: PUSH
37178: LD_INT 1
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 2
37187: PUSH
37188: LD_INT 2
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 2
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 2
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 1
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 2
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 2
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 2
37252: NEG
37253: PUSH
37254: LD_INT 3
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 2
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 3
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 1
37285: PUSH
37286: LD_INT 3
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 3
37306: NEG
37307: PUSH
37308: LD_INT 2
37310: NEG
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: LIST
37335: LIST
37336: LIST
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37341: LD_ADDR_VAR 0 32
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: LD_INT 0
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 0
37358: PUSH
37359: LD_INT 1
37361: NEG
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 1
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 1
37379: PUSH
37380: LD_INT 1
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 1
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: NEG
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 1
37410: NEG
37411: PUSH
37412: LD_INT 1
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: LD_INT 2
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: LD_INT 2
37437: NEG
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: LD_INT 1
37448: NEG
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 2
37456: PUSH
37457: LD_INT 1
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: LD_INT 2
37466: PUSH
37467: LD_INT 2
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: LD_INT 2
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: LD_INT 2
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: LD_INT 1
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: LD_INT 0
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 2
37518: NEG
37519: PUSH
37520: LD_INT 1
37522: NEG
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: PUSH
37554: LD_INT 2
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 2
37563: PUSH
37564: LD_INT 3
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 2
37573: NEG
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 3
37584: NEG
37585: PUSH
37586: LD_INT 1
37588: NEG
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: LIST
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37619: LD_ADDR_VAR 0 33
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: LD_INT 0
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 0
37636: PUSH
37637: LD_INT 1
37639: NEG
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: LD_INT 1
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: LD_INT 0
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: NEG
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 1
37700: NEG
37701: PUSH
37702: LD_INT 2
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 2
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: PUSH
37744: LD_INT 2
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 0
37753: PUSH
37754: LD_INT 2
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: NEG
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 2
37774: NEG
37775: PUSH
37776: LD_INT 0
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 2
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 2
37797: NEG
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: LD_INT 3
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: PUSH
37822: LD_INT 1
37824: NEG
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 3
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 1
37842: PUSH
37843: LD_INT 3
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 1
37852: NEG
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 3
37863: NEG
37864: PUSH
37865: LD_INT 2
37867: NEG
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: LIST
37897: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37898: LD_ADDR_VAR 0 34
37902: PUSH
37903: LD_INT 0
37905: PUSH
37906: LD_INT 0
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 0
37915: PUSH
37916: LD_INT 1
37918: NEG
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 1
37926: PUSH
37927: LD_INT 0
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: LD_INT 1
37936: PUSH
37937: LD_INT 1
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: LD_INT 1
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: LD_INT 0
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 1
37967: NEG
37968: PUSH
37969: LD_INT 1
37971: NEG
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 1
37979: NEG
37980: PUSH
37981: LD_INT 2
37983: NEG
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: LD_INT 2
37994: NEG
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 2
38013: PUSH
38014: LD_INT 1
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 2
38023: PUSH
38024: LD_INT 2
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: PUSH
38034: LD_INT 2
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: LD_INT 1
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 2
38054: NEG
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 2
38065: NEG
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 2
38077: NEG
38078: PUSH
38079: LD_INT 2
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: LD_INT 3
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 2
38104: NEG
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 3
38112: PUSH
38113: LD_INT 2
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: LD_INT 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 2
38132: NEG
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 3
38143: NEG
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: LIST
38157: LIST
38158: LIST
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: LIST
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38178: LD_ADDR_VAR 0 35
38182: PUSH
38183: LD_INT 0
38185: PUSH
38186: LD_INT 0
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 0
38195: PUSH
38196: LD_INT 1
38198: NEG
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 1
38206: PUSH
38207: LD_INT 0
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: LD_INT 1
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 0
38226: PUSH
38227: LD_INT 1
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 1
38236: NEG
38237: PUSH
38238: LD_INT 0
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: LD_INT 1
38251: NEG
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 2
38259: PUSH
38260: LD_INT 1
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 2
38269: NEG
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: LIST
38288: LIST
38289: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38290: LD_ADDR_VAR 0 36
38294: PUSH
38295: LD_INT 0
38297: PUSH
38298: LD_INT 0
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 0
38307: PUSH
38308: LD_INT 1
38310: NEG
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 1
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 1
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: LD_INT 1
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: LD_INT 0
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: LD_INT 2
38375: NEG
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: LD_INT 2
38386: PUSH
38387: EMPTY
38388: LIST
38389: LIST
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38402: LD_ADDR_VAR 0 37
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 0
38419: PUSH
38420: LD_INT 1
38422: NEG
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 1
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: LD_INT 1
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 1
38471: NEG
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38514: LD_ADDR_VAR 0 38
38518: PUSH
38519: LD_INT 0
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: PUSH
38543: LD_INT 0
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 1
38572: NEG
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 1
38583: NEG
38584: PUSH
38585: LD_INT 1
38587: NEG
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 2
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 2
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38626: LD_ADDR_VAR 0 39
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: LD_INT 0
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 1
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: LD_INT 1
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 0
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 1
38684: NEG
38685: PUSH
38686: LD_INT 0
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 1
38695: NEG
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 1
38707: NEG
38708: PUSH
38709: LD_INT 2
38711: NEG
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: PUSH
38720: LD_INT 2
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38738: LD_ADDR_VAR 0 40
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: LD_INT 0
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: LD_INT 1
38758: NEG
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: LD_INT 1
38766: PUSH
38767: LD_INT 0
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 1
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 0
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: NEG
38797: PUSH
38798: LD_INT 0
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 1
38807: NEG
38808: PUSH
38809: LD_INT 1
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: LD_INT 1
38822: NEG
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: LD_INT 1
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: LIST
38843: LIST
38844: LIST
38845: LIST
38846: LIST
38847: LIST
38848: LIST
38849: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38850: LD_ADDR_VAR 0 41
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 0
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 1
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: LD_INT 1
38888: PUSH
38889: LD_INT 1
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 1
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 0
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: LD_INT 1
38923: NEG
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 1
38931: NEG
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: LD_INT 1
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: LD_INT 2
39005: NEG
39006: PUSH
39007: LD_INT 0
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 2
39028: NEG
39029: PUSH
39030: LD_INT 2
39032: NEG
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 2
39040: NEG
39041: PUSH
39042: LD_INT 3
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 2
39052: PUSH
39053: LD_INT 1
39055: NEG
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 3
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 3
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 3
39083: PUSH
39084: LD_INT 2
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 3
39093: PUSH
39094: LD_INT 3
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 2
39103: PUSH
39104: LD_INT 3
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 2
39113: NEG
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 3
39124: NEG
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 3
39135: NEG
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 3
39147: NEG
39148: PUSH
39149: LD_INT 2
39151: NEG
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 3
39159: NEG
39160: PUSH
39161: LD_INT 3
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39200: LD_ADDR_VAR 0 42
39204: PUSH
39205: LD_INT 0
39207: PUSH
39208: LD_INT 0
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 1
39228: PUSH
39229: LD_INT 0
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: LD_INT 1
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: NEG
39282: PUSH
39283: LD_INT 2
39285: NEG
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 0
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 2
39315: PUSH
39316: LD_INT 1
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 2
39325: PUSH
39326: LD_INT 2
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: LD_INT 2
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 0
39345: PUSH
39346: LD_INT 2
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: NEG
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: NEG
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 2
39378: NEG
39379: PUSH
39380: LD_INT 2
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 2
39390: NEG
39391: PUSH
39392: LD_INT 3
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 1
39402: NEG
39403: PUSH
39404: LD_INT 3
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: LD_INT 3
39417: NEG
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 3
39436: PUSH
39437: LD_INT 2
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 3
39446: PUSH
39447: LD_INT 3
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 2
39456: PUSH
39457: LD_INT 3
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 1
39466: PUSH
39467: LD_INT 3
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: LD_INT 3
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 1
39486: NEG
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 3
39497: NEG
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 3
39509: NEG
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39550: LD_ADDR_VAR 0 43
39554: PUSH
39555: LD_INT 0
39557: PUSH
39558: LD_INT 0
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: LD_INT 1
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 1
39578: PUSH
39579: LD_INT 0
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 1
39588: PUSH
39589: LD_INT 1
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 0
39598: PUSH
39599: LD_INT 1
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: LD_INT 0
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: LD_INT 1
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 1
39631: NEG
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 0
39643: PUSH
39644: LD_INT 2
39646: NEG
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 1
39654: PUSH
39655: LD_INT 1
39657: NEG
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 2
39665: PUSH
39666: LD_INT 0
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 2
39675: PUSH
39676: LD_INT 1
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 1
39685: PUSH
39686: LD_INT 2
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 0
39695: PUSH
39696: LD_INT 2
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 1
39705: NEG
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 2
39716: NEG
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 2
39727: NEG
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: LD_INT 3
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: LD_INT 3
39754: NEG
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: PUSH
39760: LD_INT 1
39762: PUSH
39763: LD_INT 2
39765: NEG
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 2
39773: PUSH
39774: LD_INT 1
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 3
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 3
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: PUSH
39805: LD_INT 3
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 0
39814: PUSH
39815: LD_INT 3
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: LD_INT 2
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 3
39846: NEG
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: NEG
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39898: LD_ADDR_VAR 0 44
39902: PUSH
39903: LD_INT 0
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 0
39915: PUSH
39916: LD_INT 1
39918: NEG
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 1
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 1
39936: PUSH
39937: LD_INT 1
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 0
39946: PUSH
39947: LD_INT 1
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: NEG
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 1
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 1
39979: NEG
39980: PUSH
39981: LD_INT 2
39983: NEG
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: NEG
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 2
40002: PUSH
40003: LD_INT 0
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 2
40012: PUSH
40013: LD_INT 1
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 2
40022: PUSH
40023: LD_INT 2
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: LD_INT 2
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: LD_INT 1
40042: NEG
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 2
40053: NEG
40054: PUSH
40055: LD_INT 0
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 2
40064: NEG
40065: PUSH
40066: LD_INT 1
40068: NEG
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 2
40076: NEG
40077: PUSH
40078: LD_INT 2
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 2
40088: NEG
40089: PUSH
40090: LD_INT 3
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: PUSH
40101: LD_INT 1
40103: NEG
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 3
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 3
40121: PUSH
40122: LD_INT 1
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 3
40131: PUSH
40132: LD_INT 2
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 3
40141: PUSH
40142: LD_INT 3
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 2
40151: PUSH
40152: LD_INT 3
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 2
40161: NEG
40162: PUSH
40163: LD_INT 1
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: PUSH
40170: LD_INT 3
40172: NEG
40173: PUSH
40174: LD_INT 0
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 3
40183: NEG
40184: PUSH
40185: LD_INT 1
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 3
40195: NEG
40196: PUSH
40197: LD_INT 2
40199: NEG
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 3
40207: NEG
40208: PUSH
40209: LD_INT 3
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40248: LD_ADDR_VAR 0 45
40252: PUSH
40253: LD_INT 0
40255: PUSH
40256: LD_INT 0
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 0
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: PUSH
40277: LD_INT 0
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: LD_INT 1
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: LD_INT 1
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 1
40317: NEG
40318: PUSH
40319: LD_INT 1
40321: NEG
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 1
40329: NEG
40330: PUSH
40331: LD_INT 2
40333: NEG
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: LD_INT 2
40344: NEG
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 2
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 2
40373: PUSH
40374: LD_INT 2
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: PUSH
40384: LD_INT 2
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_INT 2
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: NEG
40404: PUSH
40405: LD_INT 1
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 2
40414: NEG
40415: PUSH
40416: LD_INT 1
40418: NEG
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 2
40426: NEG
40427: PUSH
40428: LD_INT 2
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 2
40438: NEG
40439: PUSH
40440: LD_INT 3
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 3
40454: NEG
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: LD_INT 3
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: LD_INT 2
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 3
40484: PUSH
40485: LD_INT 2
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 3
40494: PUSH
40495: LD_INT 3
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: LD_INT 3
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: PUSH
40515: LD_INT 3
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 0
40524: PUSH
40525: LD_INT 3
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: NEG
40535: PUSH
40536: LD_INT 2
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 3
40545: NEG
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 3
40557: NEG
40558: PUSH
40559: LD_INT 3
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40598: LD_ADDR_VAR 0 46
40602: PUSH
40603: LD_INT 0
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 0
40615: PUSH
40616: LD_INT 1
40618: NEG
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: LD_INT 1
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 1
40656: NEG
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 1
40671: NEG
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 1
40679: NEG
40680: PUSH
40681: LD_INT 2
40683: NEG
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 2
40694: NEG
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: LD_INT 1
40705: NEG
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 2
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 2
40723: PUSH
40724: LD_INT 1
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: PUSH
40734: LD_INT 2
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: LD_INT 2
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: LD_INT 1
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 2
40764: NEG
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 2
40775: NEG
40776: PUSH
40777: LD_INT 1
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: LD_INT 3
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: LD_INT 3
40802: NEG
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 1
40810: PUSH
40811: LD_INT 2
40813: NEG
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 2
40821: PUSH
40822: LD_INT 1
40824: NEG
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 3
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 3
40842: PUSH
40843: LD_INT 1
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 1
40852: PUSH
40853: LD_INT 3
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_INT 3
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: LD_INT 2
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: LD_INT 1
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 3
40894: NEG
40895: PUSH
40896: LD_INT 0
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 3
40905: NEG
40906: PUSH
40907: LD_INT 1
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40946: LD_ADDR_VAR 0 47
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 0
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 0
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 1
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 1
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 0
40994: PUSH
40995: LD_INT 1
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PUSH
41013: LD_INT 1
41015: NEG
41016: PUSH
41017: LD_INT 1
41019: NEG
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 1
41027: NEG
41028: PUSH
41029: LD_INT 2
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: LD_INT 2
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: NEG
41062: PUSH
41063: LD_INT 1
41065: NEG
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 2
41073: NEG
41074: PUSH
41075: LD_INT 2
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41097: LD_ADDR_VAR 0 48
41101: PUSH
41102: LD_INT 0
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 0
41114: PUSH
41115: LD_INT 1
41117: NEG
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 1
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: LD_INT 1
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 0
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 1
41155: NEG
41156: PUSH
41157: LD_INT 0
41159: PUSH
41160: EMPTY
41161: LIST
41162: LIST
41163: PUSH
41164: LD_INT 1
41166: NEG
41167: PUSH
41168: LD_INT 1
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 1
41178: NEG
41179: PUSH
41180: LD_INT 2
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 0
41190: PUSH
41191: LD_INT 2
41193: NEG
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: LD_INT 1
41201: PUSH
41202: LD_INT 1
41204: NEG
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 2
41212: PUSH
41213: LD_INT 0
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 2
41222: PUSH
41223: LD_INT 1
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41244: LD_ADDR_VAR 0 49
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: LD_INT 0
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 0
41261: PUSH
41262: LD_INT 1
41264: NEG
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 1
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: PUSH
41283: LD_INT 1
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 0
41292: PUSH
41293: LD_INT 1
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 1
41302: NEG
41303: PUSH
41304: LD_INT 0
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 1
41313: NEG
41314: PUSH
41315: LD_INT 1
41317: NEG
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 1
41325: PUSH
41326: LD_INT 1
41328: NEG
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 2
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: PUSH
41347: LD_INT 1
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 2
41356: PUSH
41357: LD_INT 2
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 1
41366: PUSH
41367: LD_INT 2
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41388: LD_ADDR_VAR 0 50
41392: PUSH
41393: LD_INT 0
41395: PUSH
41396: LD_INT 0
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 1
41426: PUSH
41427: LD_INT 1
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: LD_INT 0
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 1
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 2
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 2
41479: PUSH
41480: LD_INT 2
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 1
41489: PUSH
41490: LD_INT 2
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: LD_INT 2
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 1
41509: NEG
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41532: LD_ADDR_VAR 0 51
41536: PUSH
41537: LD_INT 0
41539: PUSH
41540: LD_INT 0
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 0
41549: PUSH
41550: LD_INT 1
41552: NEG
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 1
41560: PUSH
41561: LD_INT 0
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 1
41570: PUSH
41571: LD_INT 1
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: LD_INT 1
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 1
41601: NEG
41602: PUSH
41603: LD_INT 1
41605: NEG
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 1
41613: PUSH
41614: LD_INT 2
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 0
41623: PUSH
41624: LD_INT 2
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: LD_INT 1
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 2
41644: NEG
41645: PUSH
41646: LD_INT 0
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: LD_INT 1
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41679: LD_ADDR_VAR 0 52
41683: PUSH
41684: LD_INT 0
41686: PUSH
41687: LD_INT 0
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 0
41696: PUSH
41697: LD_INT 1
41699: NEG
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 1
41707: PUSH
41708: LD_INT 0
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 1
41717: PUSH
41718: LD_INT 1
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 0
41727: PUSH
41728: LD_INT 1
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 1
41737: NEG
41738: PUSH
41739: LD_INT 0
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: LD_INT 1
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 1
41772: NEG
41773: PUSH
41774: LD_INT 1
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: LD_INT 2
41783: NEG
41784: PUSH
41785: LD_INT 0
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PUSH
41792: LD_INT 2
41794: NEG
41795: PUSH
41796: LD_INT 1
41798: NEG
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 2
41806: NEG
41807: PUSH
41808: LD_INT 2
41810: NEG
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: LIST
41829: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41830: LD_ADDR_VAR 0 53
41834: PUSH
41835: LD_INT 0
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 0
41847: PUSH
41848: LD_INT 1
41850: NEG
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 1
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 1
41868: PUSH
41869: LD_INT 1
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: PUSH
41876: LD_INT 0
41878: PUSH
41879: LD_INT 1
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 1
41888: NEG
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 1
41899: NEG
41900: PUSH
41901: LD_INT 1
41903: NEG
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 1
41911: NEG
41912: PUSH
41913: LD_INT 2
41915: NEG
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: PUSH
41921: LD_INT 0
41923: PUSH
41924: LD_INT 2
41926: NEG
41927: PUSH
41928: EMPTY
41929: LIST
41930: LIST
41931: PUSH
41932: LD_INT 1
41934: PUSH
41935: LD_INT 1
41937: NEG
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 2
41945: PUSH
41946: LD_INT 0
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 2
41955: PUSH
41956: LD_INT 1
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 2
41965: PUSH
41966: LD_INT 2
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 1
41975: PUSH
41976: LD_INT 2
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 0
41985: PUSH
41986: LD_INT 2
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 1
41995: NEG
41996: PUSH
41997: LD_INT 1
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 2
42006: NEG
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 2
42017: NEG
42018: PUSH
42019: LD_INT 1
42021: NEG
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 2
42029: NEG
42030: PUSH
42031: LD_INT 2
42033: NEG
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: LIST
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42060: LD_ADDR_VAR 0 54
42064: PUSH
42065: LD_INT 0
42067: PUSH
42068: LD_INT 0
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 1
42080: NEG
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 1
42088: PUSH
42089: LD_INT 0
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 1
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: LD_INT 1
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PUSH
42116: LD_INT 1
42118: NEG
42119: PUSH
42120: LD_INT 0
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: NEG
42130: PUSH
42131: LD_INT 1
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 1
42141: NEG
42142: PUSH
42143: LD_INT 2
42145: NEG
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: LD_INT 2
42156: NEG
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: LD_INT 1
42164: PUSH
42165: LD_INT 1
42167: NEG
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: LD_INT 2
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 2
42185: PUSH
42186: LD_INT 1
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 2
42195: PUSH
42196: LD_INT 2
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: LD_INT 2
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 0
42215: PUSH
42216: LD_INT 2
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 1
42225: NEG
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 2
42236: NEG
42237: PUSH
42238: LD_INT 0
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 2
42247: NEG
42248: PUSH
42249: LD_INT 1
42251: NEG
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 2
42259: NEG
42260: PUSH
42261: LD_INT 2
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42290: LD_ADDR_VAR 0 55
42294: PUSH
42295: LD_INT 0
42297: PUSH
42298: LD_INT 0
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 0
42307: PUSH
42308: LD_INT 1
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 1
42328: PUSH
42329: LD_INT 1
42331: PUSH
42332: EMPTY
42333: LIST
42334: LIST
42335: PUSH
42336: LD_INT 0
42338: PUSH
42339: LD_INT 1
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 1
42348: NEG
42349: PUSH
42350: LD_INT 0
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 1
42359: NEG
42360: PUSH
42361: LD_INT 1
42363: NEG
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PUSH
42369: LD_INT 1
42371: NEG
42372: PUSH
42373: LD_INT 2
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 0
42383: PUSH
42384: LD_INT 2
42386: NEG
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 1
42394: PUSH
42395: LD_INT 1
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 2
42405: PUSH
42406: LD_INT 0
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 2
42415: PUSH
42416: LD_INT 1
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: LD_INT 2
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 1
42435: PUSH
42436: LD_INT 2
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: LD_INT 2
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 1
42455: NEG
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 2
42466: NEG
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 2
42477: NEG
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 2
42489: NEG
42490: PUSH
42491: LD_INT 2
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: LIST
42518: LIST
42519: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42520: LD_ADDR_VAR 0 56
42524: PUSH
42525: LD_INT 0
42527: PUSH
42528: LD_INT 0
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 0
42537: PUSH
42538: LD_INT 1
42540: NEG
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 1
42548: PUSH
42549: LD_INT 0
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: PUSH
42559: LD_INT 1
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 0
42568: PUSH
42569: LD_INT 1
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 1
42578: NEG
42579: PUSH
42580: LD_INT 0
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: LD_INT 1
42589: NEG
42590: PUSH
42591: LD_INT 1
42593: NEG
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 1
42601: NEG
42602: PUSH
42603: LD_INT 2
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: LD_INT 2
42616: NEG
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 1
42624: PUSH
42625: LD_INT 1
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 2
42635: PUSH
42636: LD_INT 0
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 2
42645: PUSH
42646: LD_INT 1
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 2
42655: PUSH
42656: LD_INT 2
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 1
42665: PUSH
42666: LD_INT 2
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 0
42675: PUSH
42676: LD_INT 2
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 1
42685: NEG
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 2
42696: NEG
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 2
42707: NEG
42708: PUSH
42709: LD_INT 1
42711: NEG
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 2
42719: NEG
42720: PUSH
42721: LD_INT 2
42723: NEG
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42750: LD_ADDR_VAR 0 57
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: LD_INT 1
42770: NEG
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 1
42778: PUSH
42779: LD_INT 0
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 1
42788: PUSH
42789: LD_INT 1
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: LD_INT 1
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 1
42819: NEG
42820: PUSH
42821: LD_INT 1
42823: NEG
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: NEG
42832: PUSH
42833: LD_INT 2
42835: NEG
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: PUSH
42841: LD_INT 0
42843: PUSH
42844: LD_INT 2
42846: NEG
42847: PUSH
42848: EMPTY
42849: LIST
42850: LIST
42851: PUSH
42852: LD_INT 1
42854: PUSH
42855: LD_INT 1
42857: NEG
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: LD_INT 2
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 2
42875: PUSH
42876: LD_INT 1
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: LD_INT 2
42885: PUSH
42886: LD_INT 2
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 2
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: LD_INT 2
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: LD_INT 1
42915: NEG
42916: PUSH
42917: LD_INT 1
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: PUSH
42924: LD_INT 2
42926: NEG
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 2
42937: NEG
42938: PUSH
42939: LD_INT 1
42941: NEG
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 2
42949: NEG
42950: PUSH
42951: LD_INT 2
42953: NEG
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42980: LD_ADDR_VAR 0 58
42984: PUSH
42985: LD_INT 0
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 1
43008: PUSH
43009: LD_INT 0
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 1
43018: PUSH
43019: LD_INT 1
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 0
43028: PUSH
43029: LD_INT 1
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 1
43038: NEG
43039: PUSH
43040: LD_INT 0
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 1
43049: NEG
43050: PUSH
43051: LD_INT 1
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 1
43061: NEG
43062: PUSH
43063: LD_INT 2
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: LD_INT 2
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: LD_INT 1
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 2
43095: PUSH
43096: LD_INT 0
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 2
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 2
43115: PUSH
43116: LD_INT 2
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 1
43125: PUSH
43126: LD_INT 2
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 0
43135: PUSH
43136: LD_INT 2
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: NEG
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 2
43156: NEG
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 2
43167: NEG
43168: PUSH
43169: LD_INT 1
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 2
43179: NEG
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43210: LD_ADDR_VAR 0 59
43214: PUSH
43215: LD_INT 0
43217: PUSH
43218: LD_INT 0
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: LD_INT 1
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 1
43238: PUSH
43239: LD_INT 0
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 1
43248: PUSH
43249: LD_INT 1
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 0
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 1
43268: NEG
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 1
43279: NEG
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: LIST
43293: LIST
43294: LIST
43295: LIST
43296: LIST
43297: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43298: LD_ADDR_VAR 0 60
43302: PUSH
43303: LD_INT 0
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 0
43315: PUSH
43316: LD_INT 1
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: LD_INT 1
43336: PUSH
43337: LD_INT 1
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: LD_INT 1
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 1
43356: NEG
43357: PUSH
43358: LD_INT 0
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 1
43367: NEG
43368: PUSH
43369: LD_INT 1
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43386: LD_ADDR_VAR 0 61
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 0
43403: PUSH
43404: LD_INT 1
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 1
43414: PUSH
43415: LD_INT 0
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 1
43424: PUSH
43425: LD_INT 1
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 0
43434: PUSH
43435: LD_INT 1
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 1
43444: NEG
43445: PUSH
43446: LD_INT 0
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: LD_INT 1
43455: NEG
43456: PUSH
43457: LD_INT 1
43459: NEG
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: LIST
43469: LIST
43470: LIST
43471: LIST
43472: LIST
43473: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43474: LD_ADDR_VAR 0 62
43478: PUSH
43479: LD_INT 0
43481: PUSH
43482: LD_INT 0
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 0
43491: PUSH
43492: LD_INT 1
43494: NEG
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: LD_INT 1
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 1
43512: PUSH
43513: LD_INT 1
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 1
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 1
43532: NEG
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 1
43543: NEG
43544: PUSH
43545: LD_INT 1
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43562: LD_ADDR_VAR 0 63
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 0
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 0
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 0
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 1
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 0
43610: PUSH
43611: LD_INT 1
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 1
43620: NEG
43621: PUSH
43622: LD_INT 0
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 1
43631: NEG
43632: PUSH
43633: LD_INT 1
43635: NEG
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43650: LD_ADDR_VAR 0 64
43654: PUSH
43655: LD_INT 0
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 1
43678: PUSH
43679: LD_INT 0
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 1
43688: PUSH
43689: LD_INT 1
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 1
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 1
43708: NEG
43709: PUSH
43710: LD_INT 0
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: LD_INT 1
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: ST_TO_ADDR
// end ; 1 :
43738: GO 49635
43740: LD_INT 1
43742: DOUBLE
43743: EQUAL
43744: IFTRUE 43748
43746: GO 46371
43748: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43749: LD_ADDR_VAR 0 11
43753: PUSH
43754: LD_INT 1
43756: NEG
43757: PUSH
43758: LD_INT 3
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 1
43779: PUSH
43780: LD_INT 2
43782: NEG
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: LIST
43792: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43793: LD_ADDR_VAR 0 12
43797: PUSH
43798: LD_INT 2
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 3
43811: PUSH
43812: LD_INT 0
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 3
43821: PUSH
43822: LD_INT 1
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: LIST
43833: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43834: LD_ADDR_VAR 0 13
43838: PUSH
43839: LD_INT 3
43841: PUSH
43842: LD_INT 2
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: LD_INT 3
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 2
43861: PUSH
43862: LD_INT 3
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: LIST
43873: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43874: LD_ADDR_VAR 0 14
43878: PUSH
43879: LD_INT 1
43881: PUSH
43882: LD_INT 3
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 0
43891: PUSH
43892: LD_INT 3
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 1
43901: NEG
43902: PUSH
43903: LD_INT 2
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: LIST
43914: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43915: LD_ADDR_VAR 0 15
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: LD_INT 1
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 3
43933: NEG
43934: PUSH
43935: LD_INT 0
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: PUSH
43942: LD_INT 3
43944: NEG
43945: PUSH
43946: LD_INT 1
43948: NEG
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: LIST
43958: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43959: LD_ADDR_VAR 0 16
43963: PUSH
43964: LD_INT 2
43966: NEG
43967: PUSH
43968: LD_INT 3
43970: NEG
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 3
43978: NEG
43979: PUSH
43980: LD_INT 2
43982: NEG
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 3
43990: NEG
43991: PUSH
43992: LD_INT 3
43994: NEG
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: LIST
44004: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44005: LD_ADDR_VAR 0 17
44009: PUSH
44010: LD_INT 1
44012: NEG
44013: PUSH
44014: LD_INT 3
44016: NEG
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: LD_INT 0
44024: PUSH
44025: LD_INT 3
44027: NEG
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 2
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: LIST
44048: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44049: LD_ADDR_VAR 0 18
44053: PUSH
44054: LD_INT 2
44056: PUSH
44057: LD_INT 1
44059: NEG
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: LD_INT 0
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 3
44077: PUSH
44078: LD_INT 1
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: LIST
44089: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44090: LD_ADDR_VAR 0 19
44094: PUSH
44095: LD_INT 3
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: LD_INT 3
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: LD_INT 2
44117: PUSH
44118: LD_INT 3
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: LIST
44129: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44130: LD_ADDR_VAR 0 20
44134: PUSH
44135: LD_INT 1
44137: PUSH
44138: LD_INT 3
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: PUSH
44145: LD_INT 0
44147: PUSH
44148: LD_INT 3
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 1
44157: NEG
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: LIST
44170: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44171: LD_ADDR_VAR 0 21
44175: PUSH
44176: LD_INT 2
44178: NEG
44179: PUSH
44180: LD_INT 1
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 3
44189: NEG
44190: PUSH
44191: LD_INT 0
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: LD_INT 1
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: LIST
44214: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44215: LD_ADDR_VAR 0 22
44219: PUSH
44220: LD_INT 2
44222: NEG
44223: PUSH
44224: LD_INT 3
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 3
44234: NEG
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: LD_INT 3
44250: NEG
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: LIST
44260: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
44261: LD_ADDR_VAR 0 23
44265: PUSH
44266: LD_INT 0
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: LD_INT 4
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 1
44291: PUSH
44292: LD_INT 3
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: LIST
44304: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
44305: LD_ADDR_VAR 0 24
44309: PUSH
44310: LD_INT 3
44312: PUSH
44313: LD_INT 0
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 3
44322: PUSH
44323: LD_INT 1
44325: NEG
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PUSH
44331: LD_INT 4
44333: PUSH
44334: LD_INT 1
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: LIST
44345: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44346: LD_ADDR_VAR 0 25
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: LD_INT 3
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 4
44363: PUSH
44364: LD_INT 3
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: PUSH
44371: LD_INT 3
44373: PUSH
44374: LD_INT 4
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: LIST
44385: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44386: LD_ADDR_VAR 0 26
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: LD_INT 3
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 1
44403: PUSH
44404: LD_INT 4
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 1
44413: NEG
44414: PUSH
44415: LD_INT 3
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: LIST
44426: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44427: LD_ADDR_VAR 0 27
44431: PUSH
44432: LD_INT 3
44434: NEG
44435: PUSH
44436: LD_INT 0
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 3
44445: NEG
44446: PUSH
44447: LD_INT 1
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 4
44456: NEG
44457: PUSH
44458: LD_INT 1
44460: NEG
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44471: LD_ADDR_VAR 0 28
44475: PUSH
44476: LD_INT 3
44478: NEG
44479: PUSH
44480: LD_INT 3
44482: NEG
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 3
44490: NEG
44491: PUSH
44492: LD_INT 4
44494: NEG
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: PUSH
44500: LD_INT 4
44502: NEG
44503: PUSH
44504: LD_INT 3
44506: NEG
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: LIST
44516: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44517: LD_ADDR_VAR 0 29
44521: PUSH
44522: LD_INT 1
44524: NEG
44525: PUSH
44526: LD_INT 3
44528: NEG
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: LD_INT 3
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: PUSH
44548: LD_INT 2
44550: NEG
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 1
44558: NEG
44559: PUSH
44560: LD_INT 4
44562: NEG
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 0
44570: PUSH
44571: LD_INT 4
44573: NEG
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 1
44581: PUSH
44582: LD_INT 3
44584: NEG
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 1
44592: NEG
44593: PUSH
44594: LD_INT 5
44596: NEG
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 0
44604: PUSH
44605: LD_INT 5
44607: NEG
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 1
44615: PUSH
44616: LD_INT 4
44618: NEG
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 1
44626: NEG
44627: PUSH
44628: LD_INT 6
44630: NEG
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 0
44638: PUSH
44639: LD_INT 6
44641: NEG
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 1
44649: PUSH
44650: LD_INT 5
44652: NEG
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44672: LD_ADDR_VAR 0 30
44676: PUSH
44677: LD_INT 2
44679: PUSH
44680: LD_INT 1
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 3
44690: PUSH
44691: LD_INT 0
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PUSH
44698: LD_INT 3
44700: PUSH
44701: LD_INT 1
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 3
44710: PUSH
44711: LD_INT 1
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 4
44721: PUSH
44722: LD_INT 0
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 4
44731: PUSH
44732: LD_INT 1
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 4
44741: PUSH
44742: LD_INT 1
44744: NEG
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 5
44752: PUSH
44753: LD_INT 0
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 5
44762: PUSH
44763: LD_INT 1
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 5
44772: PUSH
44773: LD_INT 1
44775: NEG
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 6
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 6
44793: PUSH
44794: LD_INT 1
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44815: LD_ADDR_VAR 0 31
44819: PUSH
44820: LD_INT 3
44822: PUSH
44823: LD_INT 2
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 3
44832: PUSH
44833: LD_INT 3
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 2
44842: PUSH
44843: LD_INT 3
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 4
44852: PUSH
44853: LD_INT 3
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 4
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 3
44872: PUSH
44873: LD_INT 4
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 5
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 5
44892: PUSH
44893: LD_INT 5
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 4
44902: PUSH
44903: LD_INT 5
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 6
44912: PUSH
44913: LD_INT 5
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 6
44922: PUSH
44923: LD_INT 6
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PUSH
44930: LD_INT 5
44932: PUSH
44933: LD_INT 6
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44954: LD_ADDR_VAR 0 32
44958: PUSH
44959: LD_INT 1
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: LD_INT 3
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: LD_INT 2
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 1
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 0
45002: PUSH
45003: LD_INT 4
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: LD_INT 1
45012: NEG
45013: PUSH
45014: LD_INT 3
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: LD_INT 1
45023: PUSH
45024: LD_INT 5
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 0
45033: PUSH
45034: LD_INT 5
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 1
45043: NEG
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 1
45054: PUSH
45055: LD_INT 6
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 0
45064: PUSH
45065: LD_INT 6
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: LD_INT 1
45074: NEG
45075: PUSH
45076: LD_INT 5
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
45097: LD_ADDR_VAR 0 33
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 1
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 3
45115: NEG
45116: PUSH
45117: LD_INT 0
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 3
45126: NEG
45127: PUSH
45128: LD_INT 1
45130: NEG
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: LD_INT 3
45138: NEG
45139: PUSH
45140: LD_INT 1
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 4
45149: NEG
45150: PUSH
45151: LD_INT 0
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PUSH
45158: LD_INT 4
45160: NEG
45161: PUSH
45162: LD_INT 1
45164: NEG
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: PUSH
45170: LD_INT 4
45172: NEG
45173: PUSH
45174: LD_INT 1
45176: PUSH
45177: EMPTY
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 5
45183: NEG
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 5
45194: NEG
45195: PUSH
45196: LD_INT 1
45198: NEG
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: PUSH
45204: LD_INT 5
45206: NEG
45207: PUSH
45208: LD_INT 1
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 6
45217: NEG
45218: PUSH
45219: LD_INT 0
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 6
45228: NEG
45229: PUSH
45230: LD_INT 1
45232: NEG
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
45252: LD_ADDR_VAR 0 34
45256: PUSH
45257: LD_INT 2
45259: NEG
45260: PUSH
45261: LD_INT 3
45263: NEG
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 3
45271: NEG
45272: PUSH
45273: LD_INT 2
45275: NEG
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: NEG
45284: PUSH
45285: LD_INT 3
45287: NEG
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: NEG
45296: PUSH
45297: LD_INT 4
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 4
45307: NEG
45308: PUSH
45309: LD_INT 3
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 4
45319: NEG
45320: PUSH
45321: LD_INT 4
45323: NEG
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 4
45331: NEG
45332: PUSH
45333: LD_INT 5
45335: NEG
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 5
45343: NEG
45344: PUSH
45345: LD_INT 4
45347: NEG
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 5
45355: NEG
45356: PUSH
45357: LD_INT 5
45359: NEG
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: LD_INT 5
45367: NEG
45368: PUSH
45369: LD_INT 6
45371: NEG
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 6
45379: NEG
45380: PUSH
45381: LD_INT 5
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 6
45391: NEG
45392: PUSH
45393: LD_INT 6
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: EMPTY
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45415: LD_ADDR_VAR 0 41
45419: PUSH
45420: LD_INT 0
45422: PUSH
45423: LD_INT 2
45425: NEG
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: PUSH
45431: LD_INT 1
45433: NEG
45434: PUSH
45435: LD_INT 3
45437: NEG
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 1
45445: PUSH
45446: LD_INT 2
45448: NEG
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45459: LD_ADDR_VAR 0 42
45463: PUSH
45464: LD_INT 2
45466: PUSH
45467: LD_INT 0
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 2
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 3
45487: PUSH
45488: LD_INT 1
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: LIST
45499: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45500: LD_ADDR_VAR 0 43
45504: PUSH
45505: LD_INT 2
45507: PUSH
45508: LD_INT 2
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 3
45517: PUSH
45518: LD_INT 2
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 2
45527: PUSH
45528: LD_INT 3
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45540: LD_ADDR_VAR 0 44
45544: PUSH
45545: LD_INT 0
45547: PUSH
45548: LD_INT 2
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 1
45557: PUSH
45558: LD_INT 3
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: PUSH
45565: LD_INT 1
45567: NEG
45568: PUSH
45569: LD_INT 2
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: LIST
45580: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45581: LD_ADDR_VAR 0 45
45585: PUSH
45586: LD_INT 2
45588: NEG
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 2
45599: NEG
45600: PUSH
45601: LD_INT 1
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: LD_INT 1
45614: NEG
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: LIST
45624: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45625: LD_ADDR_VAR 0 46
45629: PUSH
45630: LD_INT 2
45632: NEG
45633: PUSH
45634: LD_INT 2
45636: NEG
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: PUSH
45642: LD_INT 2
45644: NEG
45645: PUSH
45646: LD_INT 3
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 3
45656: NEG
45657: PUSH
45658: LD_INT 2
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45671: LD_ADDR_VAR 0 47
45675: PUSH
45676: LD_INT 2
45678: NEG
45679: PUSH
45680: LD_INT 3
45682: NEG
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: LD_INT 3
45694: NEG
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45704: LD_ADDR_VAR 0 48
45708: PUSH
45709: LD_INT 1
45711: PUSH
45712: LD_INT 2
45714: NEG
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 2
45722: PUSH
45723: LD_INT 1
45725: NEG
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45735: LD_ADDR_VAR 0 49
45739: PUSH
45740: LD_INT 3
45742: PUSH
45743: LD_INT 1
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 3
45752: PUSH
45753: LD_INT 2
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45764: LD_ADDR_VAR 0 50
45768: PUSH
45769: LD_INT 2
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 1
45781: PUSH
45782: LD_INT 3
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45793: LD_ADDR_VAR 0 51
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: LD_INT 2
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 2
45811: NEG
45812: PUSH
45813: LD_INT 1
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45824: LD_ADDR_VAR 0 52
45828: PUSH
45829: LD_INT 3
45831: NEG
45832: PUSH
45833: LD_INT 1
45835: NEG
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 3
45843: NEG
45844: PUSH
45845: LD_INT 2
45847: NEG
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45857: LD_ADDR_VAR 0 53
45861: PUSH
45862: LD_INT 1
45864: NEG
45865: PUSH
45866: LD_INT 3
45868: NEG
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 0
45876: PUSH
45877: LD_INT 3
45879: NEG
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PUSH
45885: LD_INT 1
45887: PUSH
45888: LD_INT 2
45890: NEG
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: LIST
45900: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45901: LD_ADDR_VAR 0 54
45905: PUSH
45906: LD_INT 2
45908: PUSH
45909: LD_INT 1
45911: NEG
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 3
45919: PUSH
45920: LD_INT 0
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: LD_INT 3
45929: PUSH
45930: LD_INT 1
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: LIST
45941: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45942: LD_ADDR_VAR 0 55
45946: PUSH
45947: LD_INT 3
45949: PUSH
45950: LD_INT 2
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: PUSH
45957: LD_INT 3
45959: PUSH
45960: LD_INT 3
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: PUSH
45967: LD_INT 2
45969: PUSH
45970: LD_INT 3
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: LIST
45981: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45982: LD_ADDR_VAR 0 56
45986: PUSH
45987: LD_INT 1
45989: PUSH
45990: LD_INT 3
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: LD_INT 0
45999: PUSH
46000: LD_INT 3
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 1
46009: NEG
46010: PUSH
46011: LD_INT 2
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: LIST
46022: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46023: LD_ADDR_VAR 0 57
46027: PUSH
46028: LD_INT 2
46030: NEG
46031: PUSH
46032: LD_INT 1
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 3
46041: NEG
46042: PUSH
46043: LD_INT 0
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 3
46052: NEG
46053: PUSH
46054: LD_INT 1
46056: NEG
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: LIST
46066: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46067: LD_ADDR_VAR 0 58
46071: PUSH
46072: LD_INT 2
46074: NEG
46075: PUSH
46076: LD_INT 3
46078: NEG
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 3
46086: NEG
46087: PUSH
46088: LD_INT 2
46090: NEG
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 3
46098: NEG
46099: PUSH
46100: LD_INT 3
46102: NEG
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: LIST
46112: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
46113: LD_ADDR_VAR 0 59
46117: PUSH
46118: LD_INT 1
46120: NEG
46121: PUSH
46122: LD_INT 2
46124: NEG
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: LD_INT 0
46132: PUSH
46133: LD_INT 2
46135: NEG
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 1
46143: PUSH
46144: LD_INT 1
46146: NEG
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: LIST
46156: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
46157: LD_ADDR_VAR 0 60
46161: PUSH
46162: LD_INT 1
46164: PUSH
46165: LD_INT 1
46167: NEG
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PUSH
46173: LD_INT 2
46175: PUSH
46176: LD_INT 0
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 2
46185: PUSH
46186: LD_INT 1
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: LIST
46197: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
46198: LD_ADDR_VAR 0 61
46202: PUSH
46203: LD_INT 2
46205: PUSH
46206: LD_INT 1
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 2
46215: PUSH
46216: LD_INT 2
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 1
46225: PUSH
46226: LD_INT 2
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: LIST
46237: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
46238: LD_ADDR_VAR 0 62
46242: PUSH
46243: LD_INT 1
46245: PUSH
46246: LD_INT 2
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 0
46255: PUSH
46256: LD_INT 2
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 1
46265: NEG
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: LIST
46278: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
46279: LD_ADDR_VAR 0 63
46283: PUSH
46284: LD_INT 1
46286: NEG
46287: PUSH
46288: LD_INT 1
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PUSH
46295: LD_INT 2
46297: NEG
46298: PUSH
46299: LD_INT 0
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 2
46308: NEG
46309: PUSH
46310: LD_INT 1
46312: NEG
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: EMPTY
46319: LIST
46320: LIST
46321: LIST
46322: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46323: LD_ADDR_VAR 0 64
46327: PUSH
46328: LD_INT 1
46330: NEG
46331: PUSH
46332: LD_INT 2
46334: NEG
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 2
46342: NEG
46343: PUSH
46344: LD_INT 1
46346: NEG
46347: PUSH
46348: EMPTY
46349: LIST
46350: LIST
46351: PUSH
46352: LD_INT 2
46354: NEG
46355: PUSH
46356: LD_INT 2
46358: NEG
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: LIST
46368: ST_TO_ADDR
// end ; 2 :
46369: GO 49635
46371: LD_INT 2
46373: DOUBLE
46374: EQUAL
46375: IFTRUE 46379
46377: GO 49634
46379: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46380: LD_ADDR_VAR 0 29
46384: PUSH
46385: LD_INT 4
46387: PUSH
46388: LD_INT 0
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 4
46397: PUSH
46398: LD_INT 1
46400: NEG
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 5
46408: PUSH
46409: LD_INT 0
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 5
46418: PUSH
46419: LD_INT 1
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: LD_INT 4
46428: PUSH
46429: LD_INT 1
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: PUSH
46436: LD_INT 3
46438: PUSH
46439: LD_INT 0
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PUSH
46446: LD_INT 3
46448: PUSH
46449: LD_INT 1
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 3
46459: PUSH
46460: LD_INT 2
46462: NEG
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 5
46470: PUSH
46471: LD_INT 2
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 3
46480: PUSH
46481: LD_INT 3
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 3
46490: PUSH
46491: LD_INT 2
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 4
46500: PUSH
46501: LD_INT 3
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 4
46510: PUSH
46511: LD_INT 4
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: PUSH
46521: LD_INT 4
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 2
46530: PUSH
46531: LD_INT 3
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 2
46540: PUSH
46541: LD_INT 2
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 4
46550: PUSH
46551: LD_INT 2
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 2
46560: PUSH
46561: LD_INT 4
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 0
46570: PUSH
46571: LD_INT 4
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: PUSH
46578: LD_INT 0
46580: PUSH
46581: LD_INT 3
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 1
46590: PUSH
46591: LD_INT 4
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: LD_INT 5
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 0
46610: PUSH
46611: LD_INT 5
46613: PUSH
46614: EMPTY
46615: LIST
46616: LIST
46617: PUSH
46618: LD_INT 1
46620: NEG
46621: PUSH
46622: LD_INT 4
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 1
46631: NEG
46632: PUSH
46633: LD_INT 3
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 2
46642: PUSH
46643: LD_INT 5
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: LD_INT 2
46652: NEG
46653: PUSH
46654: LD_INT 3
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: LD_INT 3
46663: NEG
46664: PUSH
46665: LD_INT 0
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: PUSH
46672: LD_INT 3
46674: NEG
46675: PUSH
46676: LD_INT 1
46678: NEG
46679: PUSH
46680: EMPTY
46681: LIST
46682: LIST
46683: PUSH
46684: LD_INT 2
46686: NEG
46687: PUSH
46688: LD_INT 0
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PUSH
46695: LD_INT 2
46697: NEG
46698: PUSH
46699: LD_INT 1
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PUSH
46706: LD_INT 3
46708: NEG
46709: PUSH
46710: LD_INT 1
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PUSH
46717: LD_INT 4
46719: NEG
46720: PUSH
46721: LD_INT 0
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 4
46730: NEG
46731: PUSH
46732: LD_INT 1
46734: NEG
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 4
46742: NEG
46743: PUSH
46744: LD_INT 2
46746: NEG
46747: PUSH
46748: EMPTY
46749: LIST
46750: LIST
46751: PUSH
46752: LD_INT 2
46754: NEG
46755: PUSH
46756: LD_INT 2
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: LD_INT 4
46765: NEG
46766: PUSH
46767: LD_INT 4
46769: NEG
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: PUSH
46775: LD_INT 4
46777: NEG
46778: PUSH
46779: LD_INT 5
46781: NEG
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_INT 3
46789: NEG
46790: PUSH
46791: LD_INT 4
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 3
46801: NEG
46802: PUSH
46803: LD_INT 3
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 4
46813: NEG
46814: PUSH
46815: LD_INT 3
46817: NEG
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 5
46825: NEG
46826: PUSH
46827: LD_INT 4
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 5
46837: NEG
46838: PUSH
46839: LD_INT 5
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 5
46853: NEG
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 5
46861: NEG
46862: PUSH
46863: LD_INT 3
46865: NEG
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46918: LD_ADDR_VAR 0 30
46922: PUSH
46923: LD_INT 4
46925: PUSH
46926: LD_INT 4
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 4
46935: PUSH
46936: LD_INT 3
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 5
46945: PUSH
46946: LD_INT 4
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 5
46955: PUSH
46956: LD_INT 5
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 4
46965: PUSH
46966: LD_INT 5
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: PUSH
46973: LD_INT 3
46975: PUSH
46976: LD_INT 4
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 3
46985: PUSH
46986: LD_INT 3
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: PUSH
46993: LD_INT 5
46995: PUSH
46996: LD_INT 3
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PUSH
47003: LD_INT 3
47005: PUSH
47006: LD_INT 5
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: PUSH
47013: LD_INT 0
47015: PUSH
47016: LD_INT 3
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 0
47025: PUSH
47026: LD_INT 2
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 1
47035: PUSH
47036: LD_INT 3
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 1
47045: PUSH
47046: LD_INT 4
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: PUSH
47053: LD_INT 0
47055: PUSH
47056: LD_INT 4
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 1
47065: NEG
47066: PUSH
47067: LD_INT 3
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 1
47076: NEG
47077: PUSH
47078: LD_INT 2
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: PUSH
47085: LD_INT 2
47087: PUSH
47088: LD_INT 4
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: PUSH
47095: LD_INT 2
47097: NEG
47098: PUSH
47099: LD_INT 2
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: PUSH
47106: LD_INT 4
47108: NEG
47109: PUSH
47110: LD_INT 0
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 4
47119: NEG
47120: PUSH
47121: LD_INT 1
47123: NEG
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: PUSH
47129: LD_INT 3
47131: NEG
47132: PUSH
47133: LD_INT 0
47135: PUSH
47136: EMPTY
47137: LIST
47138: LIST
47139: PUSH
47140: LD_INT 3
47142: NEG
47143: PUSH
47144: LD_INT 1
47146: PUSH
47147: EMPTY
47148: LIST
47149: LIST
47150: PUSH
47151: LD_INT 4
47153: NEG
47154: PUSH
47155: LD_INT 1
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 5
47164: NEG
47165: PUSH
47166: LD_INT 0
47168: PUSH
47169: EMPTY
47170: LIST
47171: LIST
47172: PUSH
47173: LD_INT 5
47175: NEG
47176: PUSH
47177: LD_INT 1
47179: NEG
47180: PUSH
47181: EMPTY
47182: LIST
47183: LIST
47184: PUSH
47185: LD_INT 5
47187: NEG
47188: PUSH
47189: LD_INT 2
47191: NEG
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 3
47199: NEG
47200: PUSH
47201: LD_INT 2
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 3
47210: NEG
47211: PUSH
47212: LD_INT 3
47214: NEG
47215: PUSH
47216: EMPTY
47217: LIST
47218: LIST
47219: PUSH
47220: LD_INT 3
47222: NEG
47223: PUSH
47224: LD_INT 4
47226: NEG
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PUSH
47232: LD_INT 2
47234: NEG
47235: PUSH
47236: LD_INT 3
47238: NEG
47239: PUSH
47240: EMPTY
47241: LIST
47242: LIST
47243: PUSH
47244: LD_INT 2
47246: NEG
47247: PUSH
47248: LD_INT 2
47250: NEG
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 3
47258: NEG
47259: PUSH
47260: LD_INT 2
47262: NEG
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 4
47270: NEG
47271: PUSH
47272: LD_INT 3
47274: NEG
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 4
47282: NEG
47283: PUSH
47284: LD_INT 4
47286: NEG
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PUSH
47292: LD_INT 2
47294: NEG
47295: PUSH
47296: LD_INT 4
47298: NEG
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 4
47306: NEG
47307: PUSH
47308: LD_INT 2
47310: NEG
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 0
47318: PUSH
47319: LD_INT 4
47321: NEG
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 0
47329: PUSH
47330: LD_INT 5
47332: NEG
47333: PUSH
47334: EMPTY
47335: LIST
47336: LIST
47337: PUSH
47338: LD_INT 1
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: LD_INT 1
47351: PUSH
47352: LD_INT 3
47354: NEG
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: PUSH
47360: LD_INT 0
47362: PUSH
47363: LD_INT 3
47365: NEG
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PUSH
47371: LD_INT 1
47373: NEG
47374: PUSH
47375: LD_INT 4
47377: NEG
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: LD_INT 1
47385: NEG
47386: PUSH
47387: LD_INT 5
47389: NEG
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 2
47397: PUSH
47398: LD_INT 3
47400: NEG
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 2
47408: NEG
47409: PUSH
47410: LD_INT 5
47412: NEG
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47465: LD_ADDR_VAR 0 31
47469: PUSH
47470: LD_INT 0
47472: PUSH
47473: LD_INT 4
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PUSH
47480: LD_INT 0
47482: PUSH
47483: LD_INT 3
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 1
47492: PUSH
47493: LD_INT 4
47495: PUSH
47496: EMPTY
47497: LIST
47498: LIST
47499: PUSH
47500: LD_INT 1
47502: PUSH
47503: LD_INT 5
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 0
47512: PUSH
47513: LD_INT 5
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: PUSH
47520: LD_INT 1
47522: NEG
47523: PUSH
47524: LD_INT 4
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: PUSH
47531: LD_INT 1
47533: NEG
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: EMPTY
47539: LIST
47540: LIST
47541: PUSH
47542: LD_INT 2
47544: PUSH
47545: LD_INT 5
47547: PUSH
47548: EMPTY
47549: LIST
47550: LIST
47551: PUSH
47552: LD_INT 2
47554: NEG
47555: PUSH
47556: LD_INT 3
47558: PUSH
47559: EMPTY
47560: LIST
47561: LIST
47562: PUSH
47563: LD_INT 3
47565: NEG
47566: PUSH
47567: LD_INT 0
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: PUSH
47574: LD_INT 3
47576: NEG
47577: PUSH
47578: LD_INT 1
47580: NEG
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: LD_INT 2
47588: NEG
47589: PUSH
47590: LD_INT 0
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: PUSH
47597: LD_INT 2
47599: NEG
47600: PUSH
47601: LD_INT 1
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: PUSH
47608: LD_INT 3
47610: NEG
47611: PUSH
47612: LD_INT 1
47614: PUSH
47615: EMPTY
47616: LIST
47617: LIST
47618: PUSH
47619: LD_INT 4
47621: NEG
47622: PUSH
47623: LD_INT 0
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: LD_INT 4
47632: NEG
47633: PUSH
47634: LD_INT 1
47636: NEG
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 4
47644: NEG
47645: PUSH
47646: LD_INT 2
47648: NEG
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: LD_INT 2
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: LD_INT 4
47667: NEG
47668: PUSH
47669: LD_INT 4
47671: NEG
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: LD_INT 4
47679: NEG
47680: PUSH
47681: LD_INT 5
47683: NEG
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: PUSH
47689: LD_INT 3
47691: NEG
47692: PUSH
47693: LD_INT 4
47695: NEG
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: PUSH
47701: LD_INT 3
47703: NEG
47704: PUSH
47705: LD_INT 3
47707: NEG
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 4
47715: NEG
47716: PUSH
47717: LD_INT 3
47719: NEG
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: PUSH
47725: LD_INT 5
47727: NEG
47728: PUSH
47729: LD_INT 4
47731: NEG
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: LD_INT 5
47739: NEG
47740: PUSH
47741: LD_INT 5
47743: NEG
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 3
47751: NEG
47752: PUSH
47753: LD_INT 5
47755: NEG
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: PUSH
47761: LD_INT 5
47763: NEG
47764: PUSH
47765: LD_INT 3
47767: NEG
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 0
47775: PUSH
47776: LD_INT 3
47778: NEG
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: LD_INT 0
47786: PUSH
47787: LD_INT 4
47789: NEG
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: PUSH
47795: LD_INT 1
47797: PUSH
47798: LD_INT 3
47800: NEG
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_INT 1
47808: PUSH
47809: LD_INT 2
47811: NEG
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 0
47819: PUSH
47820: LD_INT 2
47822: NEG
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 1
47830: NEG
47831: PUSH
47832: LD_INT 3
47834: NEG
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 1
47842: NEG
47843: PUSH
47844: LD_INT 4
47846: NEG
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_INT 2
47854: PUSH
47855: LD_INT 2
47857: NEG
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: PUSH
47863: LD_INT 2
47865: NEG
47866: PUSH
47867: LD_INT 4
47869: NEG
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PUSH
47875: LD_INT 4
47877: PUSH
47878: LD_INT 0
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 4
47887: PUSH
47888: LD_INT 1
47890: NEG
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 5
47898: PUSH
47899: LD_INT 0
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: PUSH
47906: LD_INT 5
47908: PUSH
47909: LD_INT 1
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 4
47918: PUSH
47919: LD_INT 1
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 3
47928: PUSH
47929: LD_INT 0
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 3
47938: PUSH
47939: LD_INT 1
47941: NEG
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 2
47952: NEG
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 5
47960: PUSH
47961: LD_INT 2
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
48015: LD_ADDR_VAR 0 32
48019: PUSH
48020: LD_INT 4
48022: NEG
48023: PUSH
48024: LD_INT 0
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 4
48033: NEG
48034: PUSH
48035: LD_INT 1
48037: NEG
48038: PUSH
48039: EMPTY
48040: LIST
48041: LIST
48042: PUSH
48043: LD_INT 3
48045: NEG
48046: PUSH
48047: LD_INT 0
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: PUSH
48054: LD_INT 3
48056: NEG
48057: PUSH
48058: LD_INT 1
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: PUSH
48065: LD_INT 4
48067: NEG
48068: PUSH
48069: LD_INT 1
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: PUSH
48076: LD_INT 5
48078: NEG
48079: PUSH
48080: LD_INT 0
48082: PUSH
48083: EMPTY
48084: LIST
48085: LIST
48086: PUSH
48087: LD_INT 5
48089: NEG
48090: PUSH
48091: LD_INT 1
48093: NEG
48094: PUSH
48095: EMPTY
48096: LIST
48097: LIST
48098: PUSH
48099: LD_INT 5
48101: NEG
48102: PUSH
48103: LD_INT 2
48105: NEG
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PUSH
48111: LD_INT 3
48113: NEG
48114: PUSH
48115: LD_INT 2
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 3
48124: NEG
48125: PUSH
48126: LD_INT 3
48128: NEG
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: LD_INT 3
48136: NEG
48137: PUSH
48138: LD_INT 4
48140: NEG
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: PUSH
48146: LD_INT 2
48148: NEG
48149: PUSH
48150: LD_INT 3
48152: NEG
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 2
48160: NEG
48161: PUSH
48162: LD_INT 2
48164: NEG
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: LD_INT 3
48172: NEG
48173: PUSH
48174: LD_INT 2
48176: NEG
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: LD_INT 4
48184: NEG
48185: PUSH
48186: LD_INT 3
48188: NEG
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 4
48196: NEG
48197: PUSH
48198: LD_INT 4
48200: NEG
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PUSH
48206: LD_INT 2
48208: NEG
48209: PUSH
48210: LD_INT 4
48212: NEG
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 4
48220: NEG
48221: PUSH
48222: LD_INT 2
48224: NEG
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: PUSH
48230: LD_INT 0
48232: PUSH
48233: LD_INT 4
48235: NEG
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: PUSH
48241: LD_INT 0
48243: PUSH
48244: LD_INT 5
48246: NEG
48247: PUSH
48248: EMPTY
48249: LIST
48250: LIST
48251: PUSH
48252: LD_INT 1
48254: PUSH
48255: LD_INT 4
48257: NEG
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: PUSH
48263: LD_INT 1
48265: PUSH
48266: LD_INT 3
48268: NEG
48269: PUSH
48270: EMPTY
48271: LIST
48272: LIST
48273: PUSH
48274: LD_INT 0
48276: PUSH
48277: LD_INT 3
48279: NEG
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: LD_INT 1
48287: NEG
48288: PUSH
48289: LD_INT 4
48291: NEG
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 1
48299: NEG
48300: PUSH
48301: LD_INT 5
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 2
48311: PUSH
48312: LD_INT 3
48314: NEG
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 2
48322: NEG
48323: PUSH
48324: LD_INT 5
48326: NEG
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 3
48334: PUSH
48335: LD_INT 0
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: PUSH
48342: LD_INT 3
48344: PUSH
48345: LD_INT 1
48347: NEG
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 4
48355: PUSH
48356: LD_INT 0
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 4
48365: PUSH
48366: LD_INT 1
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: LD_INT 3
48375: PUSH
48376: LD_INT 1
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 2
48385: PUSH
48386: LD_INT 0
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 2
48395: PUSH
48396: LD_INT 1
48398: NEG
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 2
48409: NEG
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 2
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 4
48427: PUSH
48428: LD_INT 4
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 4
48437: PUSH
48438: LD_INT 3
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: PUSH
48445: LD_INT 5
48447: PUSH
48448: LD_INT 4
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 5
48457: PUSH
48458: LD_INT 5
48460: PUSH
48461: EMPTY
48462: LIST
48463: LIST
48464: PUSH
48465: LD_INT 4
48467: PUSH
48468: LD_INT 5
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: LD_INT 3
48477: PUSH
48478: LD_INT 4
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 3
48487: PUSH
48488: LD_INT 3
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 5
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PUSH
48505: LD_INT 3
48507: PUSH
48508: LD_INT 5
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: LIST
48519: LIST
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: LIST
48537: LIST
48538: LIST
48539: LIST
48540: LIST
48541: LIST
48542: LIST
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: LIST
48549: LIST
48550: LIST
48551: LIST
48552: LIST
48553: LIST
48554: LIST
48555: LIST
48556: LIST
48557: LIST
48558: LIST
48559: LIST
48560: LIST
48561: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48562: LD_ADDR_VAR 0 33
48566: PUSH
48567: LD_INT 4
48569: NEG
48570: PUSH
48571: LD_INT 4
48573: NEG
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: PUSH
48579: LD_INT 4
48581: NEG
48582: PUSH
48583: LD_INT 5
48585: NEG
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 3
48593: NEG
48594: PUSH
48595: LD_INT 4
48597: NEG
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 3
48605: NEG
48606: PUSH
48607: LD_INT 3
48609: NEG
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PUSH
48615: LD_INT 4
48617: NEG
48618: PUSH
48619: LD_INT 3
48621: NEG
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: PUSH
48627: LD_INT 5
48629: NEG
48630: PUSH
48631: LD_INT 4
48633: NEG
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: PUSH
48639: LD_INT 5
48641: NEG
48642: PUSH
48643: LD_INT 5
48645: NEG
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: PUSH
48651: LD_INT 3
48653: NEG
48654: PUSH
48655: LD_INT 5
48657: NEG
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 5
48665: NEG
48666: PUSH
48667: LD_INT 3
48669: NEG
48670: PUSH
48671: EMPTY
48672: LIST
48673: LIST
48674: PUSH
48675: LD_INT 0
48677: PUSH
48678: LD_INT 3
48680: NEG
48681: PUSH
48682: EMPTY
48683: LIST
48684: LIST
48685: PUSH
48686: LD_INT 0
48688: PUSH
48689: LD_INT 4
48691: NEG
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: LD_INT 1
48699: PUSH
48700: LD_INT 3
48702: NEG
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: PUSH
48708: LD_INT 1
48710: PUSH
48711: LD_INT 2
48713: NEG
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PUSH
48719: LD_INT 0
48721: PUSH
48722: LD_INT 2
48724: NEG
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: LD_INT 1
48732: NEG
48733: PUSH
48734: LD_INT 3
48736: NEG
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: LD_INT 1
48744: NEG
48745: PUSH
48746: LD_INT 4
48748: NEG
48749: PUSH
48750: EMPTY
48751: LIST
48752: LIST
48753: PUSH
48754: LD_INT 2
48756: PUSH
48757: LD_INT 2
48759: NEG
48760: PUSH
48761: EMPTY
48762: LIST
48763: LIST
48764: PUSH
48765: LD_INT 2
48767: NEG
48768: PUSH
48769: LD_INT 4
48771: NEG
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PUSH
48777: LD_INT 4
48779: PUSH
48780: LD_INT 0
48782: PUSH
48783: EMPTY
48784: LIST
48785: LIST
48786: PUSH
48787: LD_INT 4
48789: PUSH
48790: LD_INT 1
48792: NEG
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: PUSH
48798: LD_INT 5
48800: PUSH
48801: LD_INT 0
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PUSH
48808: LD_INT 5
48810: PUSH
48811: LD_INT 1
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 4
48820: PUSH
48821: LD_INT 1
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: LD_INT 3
48830: PUSH
48831: LD_INT 0
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: PUSH
48838: LD_INT 3
48840: PUSH
48841: LD_INT 1
48843: NEG
48844: PUSH
48845: EMPTY
48846: LIST
48847: LIST
48848: PUSH
48849: LD_INT 3
48851: PUSH
48852: LD_INT 2
48854: NEG
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 5
48862: PUSH
48863: LD_INT 2
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 3
48872: PUSH
48873: LD_INT 3
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 3
48882: PUSH
48883: LD_INT 2
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 4
48892: PUSH
48893: LD_INT 3
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 4
48902: PUSH
48903: LD_INT 4
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 3
48912: PUSH
48913: LD_INT 4
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 2
48922: PUSH
48923: LD_INT 3
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: PUSH
48930: LD_INT 2
48932: PUSH
48933: LD_INT 2
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 4
48942: PUSH
48943: LD_INT 2
48945: PUSH
48946: EMPTY
48947: LIST
48948: LIST
48949: PUSH
48950: LD_INT 2
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: EMPTY
48957: LIST
48958: LIST
48959: PUSH
48960: LD_INT 0
48962: PUSH
48963: LD_INT 4
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PUSH
48970: LD_INT 0
48972: PUSH
48973: LD_INT 3
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PUSH
48980: LD_INT 1
48982: PUSH
48983: LD_INT 4
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: LD_INT 1
48992: PUSH
48993: LD_INT 5
48995: PUSH
48996: EMPTY
48997: LIST
48998: LIST
48999: PUSH
49000: LD_INT 0
49002: PUSH
49003: LD_INT 5
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 1
49012: NEG
49013: PUSH
49014: LD_INT 4
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 1
49023: NEG
49024: PUSH
49025: LD_INT 3
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 2
49034: PUSH
49035: LD_INT 5
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: PUSH
49042: LD_INT 2
49044: NEG
49045: PUSH
49046: LD_INT 3
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
49100: LD_ADDR_VAR 0 34
49104: PUSH
49105: LD_INT 0
49107: PUSH
49108: LD_INT 4
49110: NEG
49111: PUSH
49112: EMPTY
49113: LIST
49114: LIST
49115: PUSH
49116: LD_INT 0
49118: PUSH
49119: LD_INT 5
49121: NEG
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 1
49129: PUSH
49130: LD_INT 4
49132: NEG
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: PUSH
49138: LD_INT 1
49140: PUSH
49141: LD_INT 3
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 0
49151: PUSH
49152: LD_INT 3
49154: NEG
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 1
49162: NEG
49163: PUSH
49164: LD_INT 4
49166: NEG
49167: PUSH
49168: EMPTY
49169: LIST
49170: LIST
49171: PUSH
49172: LD_INT 1
49174: NEG
49175: PUSH
49176: LD_INT 5
49178: NEG
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: PUSH
49184: LD_INT 2
49186: PUSH
49187: LD_INT 3
49189: NEG
49190: PUSH
49191: EMPTY
49192: LIST
49193: LIST
49194: PUSH
49195: LD_INT 2
49197: NEG
49198: PUSH
49199: LD_INT 5
49201: NEG
49202: PUSH
49203: EMPTY
49204: LIST
49205: LIST
49206: PUSH
49207: LD_INT 3
49209: PUSH
49210: LD_INT 0
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 3
49219: PUSH
49220: LD_INT 1
49222: NEG
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 4
49230: PUSH
49231: LD_INT 0
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: PUSH
49238: LD_INT 4
49240: PUSH
49241: LD_INT 1
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: PUSH
49248: LD_INT 3
49250: PUSH
49251: LD_INT 1
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 2
49260: PUSH
49261: LD_INT 0
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: PUSH
49268: LD_INT 2
49270: PUSH
49271: LD_INT 1
49273: NEG
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: PUSH
49279: LD_INT 2
49281: PUSH
49282: LD_INT 2
49284: NEG
49285: PUSH
49286: EMPTY
49287: LIST
49288: LIST
49289: PUSH
49290: LD_INT 4
49292: PUSH
49293: LD_INT 2
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: PUSH
49303: LD_INT 4
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: LD_INT 4
49312: PUSH
49313: LD_INT 3
49315: PUSH
49316: EMPTY
49317: LIST
49318: LIST
49319: PUSH
49320: LD_INT 5
49322: PUSH
49323: LD_INT 4
49325: PUSH
49326: EMPTY
49327: LIST
49328: LIST
49329: PUSH
49330: LD_INT 5
49332: PUSH
49333: LD_INT 5
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: PUSH
49340: LD_INT 4
49342: PUSH
49343: LD_INT 5
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: PUSH
49350: LD_INT 3
49352: PUSH
49353: LD_INT 4
49355: PUSH
49356: EMPTY
49357: LIST
49358: LIST
49359: PUSH
49360: LD_INT 3
49362: PUSH
49363: LD_INT 3
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: PUSH
49370: LD_INT 5
49372: PUSH
49373: LD_INT 3
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 3
49382: PUSH
49383: LD_INT 5
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: PUSH
49390: LD_INT 0
49392: PUSH
49393: LD_INT 3
49395: PUSH
49396: EMPTY
49397: LIST
49398: LIST
49399: PUSH
49400: LD_INT 0
49402: PUSH
49403: LD_INT 2
49405: PUSH
49406: EMPTY
49407: LIST
49408: LIST
49409: PUSH
49410: LD_INT 1
49412: PUSH
49413: LD_INT 3
49415: PUSH
49416: EMPTY
49417: LIST
49418: LIST
49419: PUSH
49420: LD_INT 1
49422: PUSH
49423: LD_INT 4
49425: PUSH
49426: EMPTY
49427: LIST
49428: LIST
49429: PUSH
49430: LD_INT 0
49432: PUSH
49433: LD_INT 4
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: PUSH
49440: LD_INT 1
49442: NEG
49443: PUSH
49444: LD_INT 3
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: PUSH
49451: LD_INT 1
49453: NEG
49454: PUSH
49455: LD_INT 2
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 2
49464: PUSH
49465: LD_INT 4
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PUSH
49472: LD_INT 2
49474: NEG
49475: PUSH
49476: LD_INT 2
49478: PUSH
49479: EMPTY
49480: LIST
49481: LIST
49482: PUSH
49483: LD_INT 4
49485: NEG
49486: PUSH
49487: LD_INT 0
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: LD_INT 4
49496: NEG
49497: PUSH
49498: LD_INT 1
49500: NEG
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: LD_INT 3
49508: NEG
49509: PUSH
49510: LD_INT 0
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: PUSH
49517: LD_INT 3
49519: NEG
49520: PUSH
49521: LD_INT 1
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: LD_INT 4
49530: NEG
49531: PUSH
49532: LD_INT 1
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: PUSH
49539: LD_INT 5
49541: NEG
49542: PUSH
49543: LD_INT 0
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 5
49552: NEG
49553: PUSH
49554: LD_INT 1
49556: NEG
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 5
49564: NEG
49565: PUSH
49566: LD_INT 2
49568: NEG
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: LD_INT 3
49576: NEG
49577: PUSH
49578: LD_INT 2
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: PUSH
49585: EMPTY
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: ST_TO_ADDR
// end ; end ;
49632: GO 49635
49634: POP
// case btype of b_depot , b_warehouse :
49635: LD_VAR 0 1
49639: PUSH
49640: LD_INT 0
49642: DOUBLE
49643: EQUAL
49644: IFTRUE 49654
49646: LD_INT 1
49648: DOUBLE
49649: EQUAL
49650: IFTRUE 49654
49652: GO 49855
49654: POP
// case nation of nation_american :
49655: LD_VAR 0 5
49659: PUSH
49660: LD_INT 1
49662: DOUBLE
49663: EQUAL
49664: IFTRUE 49668
49666: GO 49724
49668: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49669: LD_ADDR_VAR 0 9
49673: PUSH
49674: LD_VAR 0 11
49678: PUSH
49679: LD_VAR 0 12
49683: PUSH
49684: LD_VAR 0 13
49688: PUSH
49689: LD_VAR 0 14
49693: PUSH
49694: LD_VAR 0 15
49698: PUSH
49699: LD_VAR 0 16
49703: PUSH
49704: EMPTY
49705: LIST
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: LIST
49711: PUSH
49712: LD_VAR 0 4
49716: PUSH
49717: LD_INT 1
49719: PLUS
49720: ARRAY
49721: ST_TO_ADDR
49722: GO 49853
49724: LD_INT 2
49726: DOUBLE
49727: EQUAL
49728: IFTRUE 49732
49730: GO 49788
49732: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49733: LD_ADDR_VAR 0 9
49737: PUSH
49738: LD_VAR 0 17
49742: PUSH
49743: LD_VAR 0 18
49747: PUSH
49748: LD_VAR 0 19
49752: PUSH
49753: LD_VAR 0 20
49757: PUSH
49758: LD_VAR 0 21
49762: PUSH
49763: LD_VAR 0 22
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: PUSH
49776: LD_VAR 0 4
49780: PUSH
49781: LD_INT 1
49783: PLUS
49784: ARRAY
49785: ST_TO_ADDR
49786: GO 49853
49788: LD_INT 3
49790: DOUBLE
49791: EQUAL
49792: IFTRUE 49796
49794: GO 49852
49796: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49797: LD_ADDR_VAR 0 9
49801: PUSH
49802: LD_VAR 0 23
49806: PUSH
49807: LD_VAR 0 24
49811: PUSH
49812: LD_VAR 0 25
49816: PUSH
49817: LD_VAR 0 26
49821: PUSH
49822: LD_VAR 0 27
49826: PUSH
49827: LD_VAR 0 28
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: PUSH
49840: LD_VAR 0 4
49844: PUSH
49845: LD_INT 1
49847: PLUS
49848: ARRAY
49849: ST_TO_ADDR
49850: GO 49853
49852: POP
49853: GO 50408
49855: LD_INT 2
49857: DOUBLE
49858: EQUAL
49859: IFTRUE 49869
49861: LD_INT 3
49863: DOUBLE
49864: EQUAL
49865: IFTRUE 49869
49867: GO 49925
49869: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49870: LD_ADDR_VAR 0 9
49874: PUSH
49875: LD_VAR 0 29
49879: PUSH
49880: LD_VAR 0 30
49884: PUSH
49885: LD_VAR 0 31
49889: PUSH
49890: LD_VAR 0 32
49894: PUSH
49895: LD_VAR 0 33
49899: PUSH
49900: LD_VAR 0 34
49904: PUSH
49905: EMPTY
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: PUSH
49913: LD_VAR 0 4
49917: PUSH
49918: LD_INT 1
49920: PLUS
49921: ARRAY
49922: ST_TO_ADDR
49923: GO 50408
49925: LD_INT 16
49927: DOUBLE
49928: EQUAL
49929: IFTRUE 49987
49931: LD_INT 17
49933: DOUBLE
49934: EQUAL
49935: IFTRUE 49987
49937: LD_INT 18
49939: DOUBLE
49940: EQUAL
49941: IFTRUE 49987
49943: LD_INT 19
49945: DOUBLE
49946: EQUAL
49947: IFTRUE 49987
49949: LD_INT 22
49951: DOUBLE
49952: EQUAL
49953: IFTRUE 49987
49955: LD_INT 20
49957: DOUBLE
49958: EQUAL
49959: IFTRUE 49987
49961: LD_INT 21
49963: DOUBLE
49964: EQUAL
49965: IFTRUE 49987
49967: LD_INT 23
49969: DOUBLE
49970: EQUAL
49971: IFTRUE 49987
49973: LD_INT 24
49975: DOUBLE
49976: EQUAL
49977: IFTRUE 49987
49979: LD_INT 25
49981: DOUBLE
49982: EQUAL
49983: IFTRUE 49987
49985: GO 50043
49987: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
49988: LD_ADDR_VAR 0 9
49992: PUSH
49993: LD_VAR 0 35
49997: PUSH
49998: LD_VAR 0 36
50002: PUSH
50003: LD_VAR 0 37
50007: PUSH
50008: LD_VAR 0 38
50012: PUSH
50013: LD_VAR 0 39
50017: PUSH
50018: LD_VAR 0 40
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: PUSH
50031: LD_VAR 0 4
50035: PUSH
50036: LD_INT 1
50038: PLUS
50039: ARRAY
50040: ST_TO_ADDR
50041: GO 50408
50043: LD_INT 6
50045: DOUBLE
50046: EQUAL
50047: IFTRUE 50099
50049: LD_INT 7
50051: DOUBLE
50052: EQUAL
50053: IFTRUE 50099
50055: LD_INT 8
50057: DOUBLE
50058: EQUAL
50059: IFTRUE 50099
50061: LD_INT 13
50063: DOUBLE
50064: EQUAL
50065: IFTRUE 50099
50067: LD_INT 12
50069: DOUBLE
50070: EQUAL
50071: IFTRUE 50099
50073: LD_INT 15
50075: DOUBLE
50076: EQUAL
50077: IFTRUE 50099
50079: LD_INT 11
50081: DOUBLE
50082: EQUAL
50083: IFTRUE 50099
50085: LD_INT 14
50087: DOUBLE
50088: EQUAL
50089: IFTRUE 50099
50091: LD_INT 10
50093: DOUBLE
50094: EQUAL
50095: IFTRUE 50099
50097: GO 50155
50099: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
50100: LD_ADDR_VAR 0 9
50104: PUSH
50105: LD_VAR 0 41
50109: PUSH
50110: LD_VAR 0 42
50114: PUSH
50115: LD_VAR 0 43
50119: PUSH
50120: LD_VAR 0 44
50124: PUSH
50125: LD_VAR 0 45
50129: PUSH
50130: LD_VAR 0 46
50134: PUSH
50135: EMPTY
50136: LIST
50137: LIST
50138: LIST
50139: LIST
50140: LIST
50141: LIST
50142: PUSH
50143: LD_VAR 0 4
50147: PUSH
50148: LD_INT 1
50150: PLUS
50151: ARRAY
50152: ST_TO_ADDR
50153: GO 50408
50155: LD_INT 36
50157: DOUBLE
50158: EQUAL
50159: IFTRUE 50163
50161: GO 50219
50163: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
50164: LD_ADDR_VAR 0 9
50168: PUSH
50169: LD_VAR 0 47
50173: PUSH
50174: LD_VAR 0 48
50178: PUSH
50179: LD_VAR 0 49
50183: PUSH
50184: LD_VAR 0 50
50188: PUSH
50189: LD_VAR 0 51
50193: PUSH
50194: LD_VAR 0 52
50198: PUSH
50199: EMPTY
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: PUSH
50207: LD_VAR 0 4
50211: PUSH
50212: LD_INT 1
50214: PLUS
50215: ARRAY
50216: ST_TO_ADDR
50217: GO 50408
50219: LD_INT 4
50221: DOUBLE
50222: EQUAL
50223: IFTRUE 50245
50225: LD_INT 5
50227: DOUBLE
50228: EQUAL
50229: IFTRUE 50245
50231: LD_INT 34
50233: DOUBLE
50234: EQUAL
50235: IFTRUE 50245
50237: LD_INT 37
50239: DOUBLE
50240: EQUAL
50241: IFTRUE 50245
50243: GO 50301
50245: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
50246: LD_ADDR_VAR 0 9
50250: PUSH
50251: LD_VAR 0 53
50255: PUSH
50256: LD_VAR 0 54
50260: PUSH
50261: LD_VAR 0 55
50265: PUSH
50266: LD_VAR 0 56
50270: PUSH
50271: LD_VAR 0 57
50275: PUSH
50276: LD_VAR 0 58
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: PUSH
50289: LD_VAR 0 4
50293: PUSH
50294: LD_INT 1
50296: PLUS
50297: ARRAY
50298: ST_TO_ADDR
50299: GO 50408
50301: LD_INT 31
50303: DOUBLE
50304: EQUAL
50305: IFTRUE 50351
50307: LD_INT 32
50309: DOUBLE
50310: EQUAL
50311: IFTRUE 50351
50313: LD_INT 33
50315: DOUBLE
50316: EQUAL
50317: IFTRUE 50351
50319: LD_INT 27
50321: DOUBLE
50322: EQUAL
50323: IFTRUE 50351
50325: LD_INT 26
50327: DOUBLE
50328: EQUAL
50329: IFTRUE 50351
50331: LD_INT 28
50333: DOUBLE
50334: EQUAL
50335: IFTRUE 50351
50337: LD_INT 29
50339: DOUBLE
50340: EQUAL
50341: IFTRUE 50351
50343: LD_INT 30
50345: DOUBLE
50346: EQUAL
50347: IFTRUE 50351
50349: GO 50407
50351: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50352: LD_ADDR_VAR 0 9
50356: PUSH
50357: LD_VAR 0 59
50361: PUSH
50362: LD_VAR 0 60
50366: PUSH
50367: LD_VAR 0 61
50371: PUSH
50372: LD_VAR 0 62
50376: PUSH
50377: LD_VAR 0 63
50381: PUSH
50382: LD_VAR 0 64
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: PUSH
50395: LD_VAR 0 4
50399: PUSH
50400: LD_INT 1
50402: PLUS
50403: ARRAY
50404: ST_TO_ADDR
50405: GO 50408
50407: POP
// temp_list2 = [ ] ;
50408: LD_ADDR_VAR 0 10
50412: PUSH
50413: EMPTY
50414: ST_TO_ADDR
// for i in temp_list do
50415: LD_ADDR_VAR 0 8
50419: PUSH
50420: LD_VAR 0 9
50424: PUSH
50425: FOR_IN
50426: IFFALSE 50478
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50428: LD_ADDR_VAR 0 10
50432: PUSH
50433: LD_VAR 0 10
50437: PUSH
50438: LD_VAR 0 8
50442: PUSH
50443: LD_INT 1
50445: ARRAY
50446: PUSH
50447: LD_VAR 0 2
50451: PLUS
50452: PUSH
50453: LD_VAR 0 8
50457: PUSH
50458: LD_INT 2
50460: ARRAY
50461: PUSH
50462: LD_VAR 0 3
50466: PLUS
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: PUSH
50472: EMPTY
50473: LIST
50474: ADD
50475: ST_TO_ADDR
50476: GO 50425
50478: POP
50479: POP
// result = temp_list2 ;
50480: LD_ADDR_VAR 0 7
50484: PUSH
50485: LD_VAR 0 10
50489: ST_TO_ADDR
// end ;
50490: LD_VAR 0 7
50494: RET
// export function EnemyInRange ( unit , dist ) ; begin
50495: LD_INT 0
50497: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50498: LD_ADDR_VAR 0 3
50502: PUSH
50503: LD_VAR 0 1
50507: PPUSH
50508: CALL_OW 255
50512: PPUSH
50513: LD_VAR 0 1
50517: PPUSH
50518: CALL_OW 250
50522: PPUSH
50523: LD_VAR 0 1
50527: PPUSH
50528: CALL_OW 251
50532: PPUSH
50533: LD_VAR 0 2
50537: PPUSH
50538: CALL 23752 0 4
50542: PUSH
50543: LD_INT 4
50545: ARRAY
50546: ST_TO_ADDR
// end ;
50547: LD_VAR 0 3
50551: RET
// export function PlayerSeeMe ( unit ) ; begin
50552: LD_INT 0
50554: PPUSH
// result := See ( your_side , unit ) ;
50555: LD_ADDR_VAR 0 2
50559: PUSH
50560: LD_OWVAR 2
50564: PPUSH
50565: LD_VAR 0 1
50569: PPUSH
50570: CALL_OW 292
50574: ST_TO_ADDR
// end ;
50575: LD_VAR 0 2
50579: RET
// export function ReverseDir ( unit ) ; begin
50580: LD_INT 0
50582: PPUSH
// if not unit then
50583: LD_VAR 0 1
50587: NOT
50588: IFFALSE 50592
// exit ;
50590: GO 50615
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50592: LD_ADDR_VAR 0 2
50596: PUSH
50597: LD_VAR 0 1
50601: PPUSH
50602: CALL_OW 254
50606: PUSH
50607: LD_INT 3
50609: PLUS
50610: PUSH
50611: LD_INT 6
50613: MOD
50614: ST_TO_ADDR
// end ;
50615: LD_VAR 0 2
50619: RET
// export function ReverseArray ( array ) ; var i ; begin
50620: LD_INT 0
50622: PPUSH
50623: PPUSH
// if not array then
50624: LD_VAR 0 1
50628: NOT
50629: IFFALSE 50633
// exit ;
50631: GO 50688
// result := [ ] ;
50633: LD_ADDR_VAR 0 2
50637: PUSH
50638: EMPTY
50639: ST_TO_ADDR
// for i := array downto 1 do
50640: LD_ADDR_VAR 0 3
50644: PUSH
50645: DOUBLE
50646: LD_VAR 0 1
50650: INC
50651: ST_TO_ADDR
50652: LD_INT 1
50654: PUSH
50655: FOR_DOWNTO
50656: IFFALSE 50686
// result := Join ( result , array [ i ] ) ;
50658: LD_ADDR_VAR 0 2
50662: PUSH
50663: LD_VAR 0 2
50667: PPUSH
50668: LD_VAR 0 1
50672: PUSH
50673: LD_VAR 0 3
50677: ARRAY
50678: PPUSH
50679: CALL 55530 0 2
50683: ST_TO_ADDR
50684: GO 50655
50686: POP
50687: POP
// end ;
50688: LD_VAR 0 2
50692: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50693: LD_INT 0
50695: PPUSH
50696: PPUSH
50697: PPUSH
50698: PPUSH
50699: PPUSH
50700: PPUSH
// if not unit or not hexes then
50701: LD_VAR 0 1
50705: NOT
50706: IFTRUE 50715
50708: PUSH
50709: LD_VAR 0 2
50713: NOT
50714: OR
50715: IFFALSE 50719
// exit ;
50717: GO 50842
// dist := 9999 ;
50719: LD_ADDR_VAR 0 5
50723: PUSH
50724: LD_INT 9999
50726: ST_TO_ADDR
// for i = 1 to hexes do
50727: LD_ADDR_VAR 0 4
50731: PUSH
50732: DOUBLE
50733: LD_INT 1
50735: DEC
50736: ST_TO_ADDR
50737: LD_VAR 0 2
50741: PUSH
50742: FOR_TO
50743: IFFALSE 50830
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50745: LD_ADDR_VAR 0 6
50749: PUSH
50750: LD_VAR 0 1
50754: PPUSH
50755: LD_VAR 0 2
50759: PUSH
50760: LD_VAR 0 4
50764: ARRAY
50765: PUSH
50766: LD_INT 1
50768: ARRAY
50769: PPUSH
50770: LD_VAR 0 2
50774: PUSH
50775: LD_VAR 0 4
50779: ARRAY
50780: PUSH
50781: LD_INT 2
50783: ARRAY
50784: PPUSH
50785: CALL_OW 297
50789: ST_TO_ADDR
// if tdist < dist then
50790: LD_VAR 0 6
50794: PUSH
50795: LD_VAR 0 5
50799: LESS
50800: IFFALSE 50828
// begin hex := hexes [ i ] ;
50802: LD_ADDR_VAR 0 8
50806: PUSH
50807: LD_VAR 0 2
50811: PUSH
50812: LD_VAR 0 4
50816: ARRAY
50817: ST_TO_ADDR
// dist := tdist ;
50818: LD_ADDR_VAR 0 5
50822: PUSH
50823: LD_VAR 0 6
50827: ST_TO_ADDR
// end ; end ;
50828: GO 50742
50830: POP
50831: POP
// result := hex ;
50832: LD_ADDR_VAR 0 3
50836: PUSH
50837: LD_VAR 0 8
50841: ST_TO_ADDR
// end ;
50842: LD_VAR 0 3
50846: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50847: LD_INT 0
50849: PPUSH
50850: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50851: LD_VAR 0 1
50855: NOT
50856: IFTRUE 50895
50858: PUSH
50859: LD_VAR 0 1
50863: PUSH
50864: LD_INT 21
50866: PUSH
50867: LD_INT 2
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PUSH
50874: LD_INT 23
50876: PUSH
50877: LD_INT 2
50879: PUSH
50880: EMPTY
50881: LIST
50882: LIST
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PPUSH
50888: CALL_OW 69
50892: IN
50893: NOT
50894: OR
50895: IFFALSE 50899
// exit ;
50897: GO 50946
// for i = 1 to 3 do
50899: LD_ADDR_VAR 0 3
50903: PUSH
50904: DOUBLE
50905: LD_INT 1
50907: DEC
50908: ST_TO_ADDR
50909: LD_INT 3
50911: PUSH
50912: FOR_TO
50913: IFFALSE 50944
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50915: LD_VAR 0 1
50919: PPUSH
50920: CALL_OW 250
50924: PPUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 251
50934: PPUSH
50935: LD_INT 1
50937: PPUSH
50938: CALL_OW 453
50942: GO 50912
50944: POP
50945: POP
// end ;
50946: LD_VAR 0 2
50950: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
50951: LD_INT 0
50953: PPUSH
50954: PPUSH
50955: PPUSH
50956: PPUSH
50957: PPUSH
50958: PPUSH
// if not unit or not enemy_unit then
50959: LD_VAR 0 1
50963: NOT
50964: IFTRUE 50973
50966: PUSH
50967: LD_VAR 0 2
50971: NOT
50972: OR
50973: IFFALSE 50977
// exit ;
50975: GO 51448
// if GetLives ( i ) < 250 then
50977: LD_VAR 0 4
50981: PPUSH
50982: CALL_OW 256
50986: PUSH
50987: LD_INT 250
50989: LESS
50990: IFFALSE 51003
// begin ComAutodestruct ( i ) ;
50992: LD_VAR 0 4
50996: PPUSH
50997: CALL 50847 0 1
// exit ;
51001: GO 51448
// end ; x := GetX ( enemy_unit ) ;
51003: LD_ADDR_VAR 0 7
51007: PUSH
51008: LD_VAR 0 2
51012: PPUSH
51013: CALL_OW 250
51017: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
51018: LD_ADDR_VAR 0 8
51022: PUSH
51023: LD_VAR 0 2
51027: PPUSH
51028: CALL_OW 251
51032: ST_TO_ADDR
// if not x or not y then
51033: LD_VAR 0 7
51037: NOT
51038: IFTRUE 51047
51040: PUSH
51041: LD_VAR 0 8
51045: NOT
51046: OR
51047: IFFALSE 51051
// exit ;
51049: GO 51448
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
51051: LD_ADDR_VAR 0 6
51055: PUSH
51056: LD_VAR 0 7
51060: PPUSH
51061: LD_INT 0
51063: PPUSH
51064: LD_INT 4
51066: PPUSH
51067: CALL_OW 272
51071: PUSH
51072: LD_VAR 0 8
51076: PPUSH
51077: LD_INT 0
51079: PPUSH
51080: LD_INT 4
51082: PPUSH
51083: CALL_OW 273
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: LD_VAR 0 7
51096: PPUSH
51097: LD_INT 1
51099: PPUSH
51100: LD_INT 4
51102: PPUSH
51103: CALL_OW 272
51107: PUSH
51108: LD_VAR 0 8
51112: PPUSH
51113: LD_INT 1
51115: PPUSH
51116: LD_INT 4
51118: PPUSH
51119: CALL_OW 273
51123: PUSH
51124: EMPTY
51125: LIST
51126: LIST
51127: PUSH
51128: LD_VAR 0 7
51132: PPUSH
51133: LD_INT 2
51135: PPUSH
51136: LD_INT 4
51138: PPUSH
51139: CALL_OW 272
51143: PUSH
51144: LD_VAR 0 8
51148: PPUSH
51149: LD_INT 2
51151: PPUSH
51152: LD_INT 4
51154: PPUSH
51155: CALL_OW 273
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PUSH
51164: LD_VAR 0 7
51168: PPUSH
51169: LD_INT 3
51171: PPUSH
51172: LD_INT 4
51174: PPUSH
51175: CALL_OW 272
51179: PUSH
51180: LD_VAR 0 8
51184: PPUSH
51185: LD_INT 3
51187: PPUSH
51188: LD_INT 4
51190: PPUSH
51191: CALL_OW 273
51195: PUSH
51196: EMPTY
51197: LIST
51198: LIST
51199: PUSH
51200: LD_VAR 0 7
51204: PPUSH
51205: LD_INT 4
51207: PPUSH
51208: LD_INT 4
51210: PPUSH
51211: CALL_OW 272
51215: PUSH
51216: LD_VAR 0 8
51220: PPUSH
51221: LD_INT 4
51223: PPUSH
51224: LD_INT 4
51226: PPUSH
51227: CALL_OW 273
51231: PUSH
51232: EMPTY
51233: LIST
51234: LIST
51235: PUSH
51236: LD_VAR 0 7
51240: PPUSH
51241: LD_INT 5
51243: PPUSH
51244: LD_INT 4
51246: PPUSH
51247: CALL_OW 272
51251: PUSH
51252: LD_VAR 0 8
51256: PPUSH
51257: LD_INT 5
51259: PPUSH
51260: LD_INT 4
51262: PPUSH
51263: CALL_OW 273
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: PUSH
51272: EMPTY
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: ST_TO_ADDR
// for i = tmp downto 1 do
51280: LD_ADDR_VAR 0 4
51284: PUSH
51285: DOUBLE
51286: LD_VAR 0 6
51290: INC
51291: ST_TO_ADDR
51292: LD_INT 1
51294: PUSH
51295: FOR_DOWNTO
51296: IFFALSE 51399
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51298: LD_VAR 0 6
51302: PUSH
51303: LD_VAR 0 4
51307: ARRAY
51308: PUSH
51309: LD_INT 1
51311: ARRAY
51312: PPUSH
51313: LD_VAR 0 6
51317: PUSH
51318: LD_VAR 0 4
51322: ARRAY
51323: PUSH
51324: LD_INT 2
51326: ARRAY
51327: PPUSH
51328: CALL_OW 488
51332: NOT
51333: IFTRUE 51375
51335: PUSH
51336: LD_VAR 0 6
51340: PUSH
51341: LD_VAR 0 4
51345: ARRAY
51346: PUSH
51347: LD_INT 1
51349: ARRAY
51350: PPUSH
51351: LD_VAR 0 6
51355: PUSH
51356: LD_VAR 0 4
51360: ARRAY
51361: PUSH
51362: LD_INT 2
51364: ARRAY
51365: PPUSH
51366: CALL_OW 428
51370: PUSH
51371: LD_INT 0
51373: NONEQUAL
51374: OR
51375: IFFALSE 51397
// tmp := Delete ( tmp , i ) ;
51377: LD_ADDR_VAR 0 6
51381: PUSH
51382: LD_VAR 0 6
51386: PPUSH
51387: LD_VAR 0 4
51391: PPUSH
51392: CALL_OW 3
51396: ST_TO_ADDR
51397: GO 51295
51399: POP
51400: POP
// j := GetClosestHex ( unit , tmp ) ;
51401: LD_ADDR_VAR 0 5
51405: PUSH
51406: LD_VAR 0 1
51410: PPUSH
51411: LD_VAR 0 6
51415: PPUSH
51416: CALL 50693 0 2
51420: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51421: LD_VAR 0 1
51425: PPUSH
51426: LD_VAR 0 5
51430: PUSH
51431: LD_INT 1
51433: ARRAY
51434: PPUSH
51435: LD_VAR 0 5
51439: PUSH
51440: LD_INT 2
51442: ARRAY
51443: PPUSH
51444: CALL_OW 111
// end ;
51448: LD_VAR 0 3
51452: RET
// export function PrepareApemanSoldier ( ) ; begin
51453: LD_INT 0
51455: PPUSH
// uc_nation := 0 ;
51456: LD_ADDR_OWVAR 21
51460: PUSH
51461: LD_INT 0
51463: ST_TO_ADDR
// hc_sex := sex_male ;
51464: LD_ADDR_OWVAR 27
51468: PUSH
51469: LD_INT 1
51471: ST_TO_ADDR
// hc_name :=  ;
51472: LD_ADDR_OWVAR 26
51476: PUSH
51477: LD_STRING 
51479: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51480: LD_ADDR_OWVAR 28
51484: PUSH
51485: LD_INT 15
51487: ST_TO_ADDR
// hc_gallery :=  ;
51488: LD_ADDR_OWVAR 33
51492: PUSH
51493: LD_STRING 
51495: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51496: LD_ADDR_OWVAR 31
51500: PUSH
51501: LD_INT 0
51503: PPUSH
51504: LD_INT 3
51506: PPUSH
51507: CALL_OW 12
51511: PUSH
51512: LD_INT 0
51514: PPUSH
51515: LD_INT 3
51517: PPUSH
51518: CALL_OW 12
51522: PUSH
51523: LD_INT 0
51525: PUSH
51526: LD_INT 0
51528: PUSH
51529: EMPTY
51530: LIST
51531: LIST
51532: LIST
51533: LIST
51534: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51535: LD_ADDR_OWVAR 29
51539: PUSH
51540: LD_INT 12
51542: PUSH
51543: LD_INT 12
51545: PUSH
51546: EMPTY
51547: LIST
51548: LIST
51549: ST_TO_ADDR
// end ;
51550: LD_VAR 0 1
51554: RET
// export function PrepareApemanEngineer ( ) ; begin
51555: LD_INT 0
51557: PPUSH
// uc_nation := 0 ;
51558: LD_ADDR_OWVAR 21
51562: PUSH
51563: LD_INT 0
51565: ST_TO_ADDR
// hc_sex := sex_male ;
51566: LD_ADDR_OWVAR 27
51570: PUSH
51571: LD_INT 1
51573: ST_TO_ADDR
// hc_name :=  ;
51574: LD_ADDR_OWVAR 26
51578: PUSH
51579: LD_STRING 
51581: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51582: LD_ADDR_OWVAR 28
51586: PUSH
51587: LD_INT 16
51589: ST_TO_ADDR
// hc_gallery :=  ;
51590: LD_ADDR_OWVAR 33
51594: PUSH
51595: LD_STRING 
51597: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51598: LD_ADDR_OWVAR 31
51602: PUSH
51603: LD_INT 0
51605: PPUSH
51606: LD_INT 3
51608: PPUSH
51609: CALL_OW 12
51613: PUSH
51614: LD_INT 0
51616: PPUSH
51617: LD_INT 3
51619: PPUSH
51620: CALL_OW 12
51624: PUSH
51625: LD_INT 0
51627: PUSH
51628: LD_INT 0
51630: PUSH
51631: EMPTY
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51637: LD_ADDR_OWVAR 29
51641: PUSH
51642: LD_INT 12
51644: PUSH
51645: LD_INT 12
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: ST_TO_ADDR
// end ;
51652: LD_VAR 0 1
51656: RET
// export function PrepareApeman ( agressivity ) ; begin
51657: LD_INT 0
51659: PPUSH
// uc_side := 0 ;
51660: LD_ADDR_OWVAR 20
51664: PUSH
51665: LD_INT 0
51667: ST_TO_ADDR
// uc_nation := 0 ;
51668: LD_ADDR_OWVAR 21
51672: PUSH
51673: LD_INT 0
51675: ST_TO_ADDR
// hc_sex := sex_male ;
51676: LD_ADDR_OWVAR 27
51680: PUSH
51681: LD_INT 1
51683: ST_TO_ADDR
// hc_class := class_apeman ;
51684: LD_ADDR_OWVAR 28
51688: PUSH
51689: LD_INT 12
51691: ST_TO_ADDR
// hc_gallery :=  ;
51692: LD_ADDR_OWVAR 33
51696: PUSH
51697: LD_STRING 
51699: ST_TO_ADDR
// hc_name :=  ;
51700: LD_ADDR_OWVAR 26
51704: PUSH
51705: LD_STRING 
51707: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51708: LD_ADDR_OWVAR 29
51712: PUSH
51713: LD_INT 12
51715: PUSH
51716: LD_INT 12
51718: PUSH
51719: EMPTY
51720: LIST
51721: LIST
51722: ST_TO_ADDR
// if agressivity = 0 then
51723: LD_VAR 0 1
51727: PUSH
51728: LD_INT 0
51730: EQUAL
51731: IFFALSE 51743
// hc_agressivity := 0 else
51733: LD_ADDR_OWVAR 35
51737: PUSH
51738: LD_INT 0
51740: ST_TO_ADDR
51741: GO 51764
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51743: LD_ADDR_OWVAR 35
51747: PUSH
51748: LD_VAR 0 1
51752: NEG
51753: PPUSH
51754: LD_VAR 0 1
51758: PPUSH
51759: CALL_OW 12
51763: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51764: LD_ADDR_OWVAR 31
51768: PUSH
51769: LD_INT 0
51771: PPUSH
51772: LD_INT 3
51774: PPUSH
51775: CALL_OW 12
51779: PUSH
51780: LD_INT 0
51782: PPUSH
51783: LD_INT 3
51785: PPUSH
51786: CALL_OW 12
51790: PUSH
51791: LD_INT 0
51793: PUSH
51794: LD_INT 0
51796: PUSH
51797: EMPTY
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: ST_TO_ADDR
// end ;
51803: LD_VAR 0 2
51807: RET
// export function PrepareTiger ( agressivity ) ; begin
51808: LD_INT 0
51810: PPUSH
// uc_side := 0 ;
51811: LD_ADDR_OWVAR 20
51815: PUSH
51816: LD_INT 0
51818: ST_TO_ADDR
// uc_nation := 0 ;
51819: LD_ADDR_OWVAR 21
51823: PUSH
51824: LD_INT 0
51826: ST_TO_ADDR
// InitHc ;
51827: CALL_OW 19
// hc_class := class_tiger ;
51831: LD_ADDR_OWVAR 28
51835: PUSH
51836: LD_INT 14
51838: ST_TO_ADDR
// hc_gallery :=  ;
51839: LD_ADDR_OWVAR 33
51843: PUSH
51844: LD_STRING 
51846: ST_TO_ADDR
// hc_name :=  ;
51847: LD_ADDR_OWVAR 26
51851: PUSH
51852: LD_STRING 
51854: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51855: LD_ADDR_OWVAR 35
51859: PUSH
51860: LD_VAR 0 1
51864: NEG
51865: PPUSH
51866: LD_VAR 0 1
51870: PPUSH
51871: CALL_OW 12
51875: ST_TO_ADDR
// end ;
51876: LD_VAR 0 2
51880: RET
// export function PrepareEnchidna ( ) ; begin
51881: LD_INT 0
51883: PPUSH
// uc_side := 0 ;
51884: LD_ADDR_OWVAR 20
51888: PUSH
51889: LD_INT 0
51891: ST_TO_ADDR
// uc_nation := 0 ;
51892: LD_ADDR_OWVAR 21
51896: PUSH
51897: LD_INT 0
51899: ST_TO_ADDR
// InitHc ;
51900: CALL_OW 19
// hc_class := class_baggie ;
51904: LD_ADDR_OWVAR 28
51908: PUSH
51909: LD_INT 13
51911: ST_TO_ADDR
// hc_gallery :=  ;
51912: LD_ADDR_OWVAR 33
51916: PUSH
51917: LD_STRING 
51919: ST_TO_ADDR
// hc_name :=  ;
51920: LD_ADDR_OWVAR 26
51924: PUSH
51925: LD_STRING 
51927: ST_TO_ADDR
// end ;
51928: LD_VAR 0 1
51932: RET
// export function PrepareFrog ( ) ; begin
51933: LD_INT 0
51935: PPUSH
// uc_side := 0 ;
51936: LD_ADDR_OWVAR 20
51940: PUSH
51941: LD_INT 0
51943: ST_TO_ADDR
// uc_nation := 0 ;
51944: LD_ADDR_OWVAR 21
51948: PUSH
51949: LD_INT 0
51951: ST_TO_ADDR
// InitHc ;
51952: CALL_OW 19
// hc_class := class_frog ;
51956: LD_ADDR_OWVAR 28
51960: PUSH
51961: LD_INT 19
51963: ST_TO_ADDR
// hc_gallery :=  ;
51964: LD_ADDR_OWVAR 33
51968: PUSH
51969: LD_STRING 
51971: ST_TO_ADDR
// hc_name :=  ;
51972: LD_ADDR_OWVAR 26
51976: PUSH
51977: LD_STRING 
51979: ST_TO_ADDR
// end ;
51980: LD_VAR 0 1
51984: RET
// export function PrepareFish ( ) ; begin
51985: LD_INT 0
51987: PPUSH
// uc_side := 0 ;
51988: LD_ADDR_OWVAR 20
51992: PUSH
51993: LD_INT 0
51995: ST_TO_ADDR
// uc_nation := 0 ;
51996: LD_ADDR_OWVAR 21
52000: PUSH
52001: LD_INT 0
52003: ST_TO_ADDR
// InitHc ;
52004: CALL_OW 19
// hc_class := class_fish ;
52008: LD_ADDR_OWVAR 28
52012: PUSH
52013: LD_INT 20
52015: ST_TO_ADDR
// hc_gallery :=  ;
52016: LD_ADDR_OWVAR 33
52020: PUSH
52021: LD_STRING 
52023: ST_TO_ADDR
// hc_name :=  ;
52024: LD_ADDR_OWVAR 26
52028: PUSH
52029: LD_STRING 
52031: ST_TO_ADDR
// end ;
52032: LD_VAR 0 1
52036: RET
// export function PrepareBird ( ) ; begin
52037: LD_INT 0
52039: PPUSH
// uc_side := 0 ;
52040: LD_ADDR_OWVAR 20
52044: PUSH
52045: LD_INT 0
52047: ST_TO_ADDR
// uc_nation := 0 ;
52048: LD_ADDR_OWVAR 21
52052: PUSH
52053: LD_INT 0
52055: ST_TO_ADDR
// InitHc ;
52056: CALL_OW 19
// hc_class := class_phororhacos ;
52060: LD_ADDR_OWVAR 28
52064: PUSH
52065: LD_INT 18
52067: ST_TO_ADDR
// hc_gallery :=  ;
52068: LD_ADDR_OWVAR 33
52072: PUSH
52073: LD_STRING 
52075: ST_TO_ADDR
// hc_name :=  ;
52076: LD_ADDR_OWVAR 26
52080: PUSH
52081: LD_STRING 
52083: ST_TO_ADDR
// end ;
52084: LD_VAR 0 1
52088: RET
// export function PrepareHorse ( ) ; begin
52089: LD_INT 0
52091: PPUSH
// uc_side := 0 ;
52092: LD_ADDR_OWVAR 20
52096: PUSH
52097: LD_INT 0
52099: ST_TO_ADDR
// uc_nation := 0 ;
52100: LD_ADDR_OWVAR 21
52104: PUSH
52105: LD_INT 0
52107: ST_TO_ADDR
// InitHc ;
52108: CALL_OW 19
// hc_class := class_horse ;
52112: LD_ADDR_OWVAR 28
52116: PUSH
52117: LD_INT 21
52119: ST_TO_ADDR
// hc_gallery :=  ;
52120: LD_ADDR_OWVAR 33
52124: PUSH
52125: LD_STRING 
52127: ST_TO_ADDR
// hc_name :=  ;
52128: LD_ADDR_OWVAR 26
52132: PUSH
52133: LD_STRING 
52135: ST_TO_ADDR
// end ;
52136: LD_VAR 0 1
52140: RET
// export function PrepareMastodont ( ) ; begin
52141: LD_INT 0
52143: PPUSH
// uc_side := 0 ;
52144: LD_ADDR_OWVAR 20
52148: PUSH
52149: LD_INT 0
52151: ST_TO_ADDR
// uc_nation := 0 ;
52152: LD_ADDR_OWVAR 21
52156: PUSH
52157: LD_INT 0
52159: ST_TO_ADDR
// vc_chassis := class_mastodont ;
52160: LD_ADDR_OWVAR 37
52164: PUSH
52165: LD_INT 31
52167: ST_TO_ADDR
// vc_control := control_rider ;
52168: LD_ADDR_OWVAR 38
52172: PUSH
52173: LD_INT 4
52175: ST_TO_ADDR
// end ;
52176: LD_VAR 0 1
52180: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52181: LD_INT 0
52183: PPUSH
52184: PPUSH
52185: PPUSH
// uc_side = 0 ;
52186: LD_ADDR_OWVAR 20
52190: PUSH
52191: LD_INT 0
52193: ST_TO_ADDR
// uc_nation = 0 ;
52194: LD_ADDR_OWVAR 21
52198: PUSH
52199: LD_INT 0
52201: ST_TO_ADDR
// InitHc_All ( ) ;
52202: CALL_OW 584
// InitVc ;
52206: CALL_OW 20
// if mastodonts then
52210: LD_VAR 0 6
52214: IFFALSE 52281
// for i = 1 to mastodonts do
52216: LD_ADDR_VAR 0 11
52220: PUSH
52221: DOUBLE
52222: LD_INT 1
52224: DEC
52225: ST_TO_ADDR
52226: LD_VAR 0 6
52230: PUSH
52231: FOR_TO
52232: IFFALSE 52279
// begin vc_chassis := 31 ;
52234: LD_ADDR_OWVAR 37
52238: PUSH
52239: LD_INT 31
52241: ST_TO_ADDR
// vc_control := control_rider ;
52242: LD_ADDR_OWVAR 38
52246: PUSH
52247: LD_INT 4
52249: ST_TO_ADDR
// animal := CreateVehicle ;
52250: LD_ADDR_VAR 0 12
52254: PUSH
52255: CALL_OW 45
52259: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52260: LD_VAR 0 12
52264: PPUSH
52265: LD_VAR 0 8
52269: PPUSH
52270: LD_INT 0
52272: PPUSH
52273: CALL 54423 0 3
// end ;
52277: GO 52231
52279: POP
52280: POP
// if horses then
52281: LD_VAR 0 5
52285: IFFALSE 52352
// for i = 1 to horses do
52287: LD_ADDR_VAR 0 11
52291: PUSH
52292: DOUBLE
52293: LD_INT 1
52295: DEC
52296: ST_TO_ADDR
52297: LD_VAR 0 5
52301: PUSH
52302: FOR_TO
52303: IFFALSE 52350
// begin hc_class := 21 ;
52305: LD_ADDR_OWVAR 28
52309: PUSH
52310: LD_INT 21
52312: ST_TO_ADDR
// hc_gallery :=  ;
52313: LD_ADDR_OWVAR 33
52317: PUSH
52318: LD_STRING 
52320: ST_TO_ADDR
// animal := CreateHuman ;
52321: LD_ADDR_VAR 0 12
52325: PUSH
52326: CALL_OW 44
52330: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52331: LD_VAR 0 12
52335: PPUSH
52336: LD_VAR 0 8
52340: PPUSH
52341: LD_INT 0
52343: PPUSH
52344: CALL 54423 0 3
// end ;
52348: GO 52302
52350: POP
52351: POP
// if birds then
52352: LD_VAR 0 1
52356: IFFALSE 52423
// for i = 1 to birds do
52358: LD_ADDR_VAR 0 11
52362: PUSH
52363: DOUBLE
52364: LD_INT 1
52366: DEC
52367: ST_TO_ADDR
52368: LD_VAR 0 1
52372: PUSH
52373: FOR_TO
52374: IFFALSE 52421
// begin hc_class := 18 ;
52376: LD_ADDR_OWVAR 28
52380: PUSH
52381: LD_INT 18
52383: ST_TO_ADDR
// hc_gallery =  ;
52384: LD_ADDR_OWVAR 33
52388: PUSH
52389: LD_STRING 
52391: ST_TO_ADDR
// animal := CreateHuman ;
52392: LD_ADDR_VAR 0 12
52396: PUSH
52397: CALL_OW 44
52401: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52402: LD_VAR 0 12
52406: PPUSH
52407: LD_VAR 0 8
52411: PPUSH
52412: LD_INT 0
52414: PPUSH
52415: CALL 54423 0 3
// end ;
52419: GO 52373
52421: POP
52422: POP
// if tigers then
52423: LD_VAR 0 2
52427: IFFALSE 52511
// for i = 1 to tigers do
52429: LD_ADDR_VAR 0 11
52433: PUSH
52434: DOUBLE
52435: LD_INT 1
52437: DEC
52438: ST_TO_ADDR
52439: LD_VAR 0 2
52443: PUSH
52444: FOR_TO
52445: IFFALSE 52509
// begin hc_class = class_tiger ;
52447: LD_ADDR_OWVAR 28
52451: PUSH
52452: LD_INT 14
52454: ST_TO_ADDR
// hc_gallery =  ;
52455: LD_ADDR_OWVAR 33
52459: PUSH
52460: LD_STRING 
52462: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52463: LD_ADDR_OWVAR 35
52467: PUSH
52468: LD_INT 7
52470: NEG
52471: PPUSH
52472: LD_INT 7
52474: PPUSH
52475: CALL_OW 12
52479: ST_TO_ADDR
// animal := CreateHuman ;
52480: LD_ADDR_VAR 0 12
52484: PUSH
52485: CALL_OW 44
52489: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52490: LD_VAR 0 12
52494: PPUSH
52495: LD_VAR 0 8
52499: PPUSH
52500: LD_INT 0
52502: PPUSH
52503: CALL 54423 0 3
// end ;
52507: GO 52444
52509: POP
52510: POP
// if apemans then
52511: LD_VAR 0 3
52515: IFFALSE 52638
// for i = 1 to apemans do
52517: LD_ADDR_VAR 0 11
52521: PUSH
52522: DOUBLE
52523: LD_INT 1
52525: DEC
52526: ST_TO_ADDR
52527: LD_VAR 0 3
52531: PUSH
52532: FOR_TO
52533: IFFALSE 52636
// begin hc_class = class_apeman ;
52535: LD_ADDR_OWVAR 28
52539: PUSH
52540: LD_INT 12
52542: ST_TO_ADDR
// hc_gallery =  ;
52543: LD_ADDR_OWVAR 33
52547: PUSH
52548: LD_STRING 
52550: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52551: LD_ADDR_OWVAR 35
52555: PUSH
52556: LD_INT 2
52558: NEG
52559: PPUSH
52560: LD_INT 2
52562: PPUSH
52563: CALL_OW 12
52567: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52568: LD_ADDR_OWVAR 31
52572: PUSH
52573: LD_INT 1
52575: PPUSH
52576: LD_INT 3
52578: PPUSH
52579: CALL_OW 12
52583: PUSH
52584: LD_INT 1
52586: PPUSH
52587: LD_INT 3
52589: PPUSH
52590: CALL_OW 12
52594: PUSH
52595: LD_INT 0
52597: PUSH
52598: LD_INT 0
52600: PUSH
52601: EMPTY
52602: LIST
52603: LIST
52604: LIST
52605: LIST
52606: ST_TO_ADDR
// animal := CreateHuman ;
52607: LD_ADDR_VAR 0 12
52611: PUSH
52612: CALL_OW 44
52616: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52617: LD_VAR 0 12
52621: PPUSH
52622: LD_VAR 0 8
52626: PPUSH
52627: LD_INT 0
52629: PPUSH
52630: CALL 54423 0 3
// end ;
52634: GO 52532
52636: POP
52637: POP
// if enchidnas then
52638: LD_VAR 0 4
52642: IFFALSE 52709
// for i = 1 to enchidnas do
52644: LD_ADDR_VAR 0 11
52648: PUSH
52649: DOUBLE
52650: LD_INT 1
52652: DEC
52653: ST_TO_ADDR
52654: LD_VAR 0 4
52658: PUSH
52659: FOR_TO
52660: IFFALSE 52707
// begin hc_class = 13 ;
52662: LD_ADDR_OWVAR 28
52666: PUSH
52667: LD_INT 13
52669: ST_TO_ADDR
// hc_gallery =  ;
52670: LD_ADDR_OWVAR 33
52674: PUSH
52675: LD_STRING 
52677: ST_TO_ADDR
// animal := CreateHuman ;
52678: LD_ADDR_VAR 0 12
52682: PUSH
52683: CALL_OW 44
52687: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52688: LD_VAR 0 12
52692: PPUSH
52693: LD_VAR 0 8
52697: PPUSH
52698: LD_INT 0
52700: PPUSH
52701: CALL 54423 0 3
// end ;
52705: GO 52659
52707: POP
52708: POP
// if fishes then
52709: LD_VAR 0 7
52713: IFFALSE 52780
// for i = 1 to fishes do
52715: LD_ADDR_VAR 0 11
52719: PUSH
52720: DOUBLE
52721: LD_INT 1
52723: DEC
52724: ST_TO_ADDR
52725: LD_VAR 0 7
52729: PUSH
52730: FOR_TO
52731: IFFALSE 52778
// begin hc_class = 20 ;
52733: LD_ADDR_OWVAR 28
52737: PUSH
52738: LD_INT 20
52740: ST_TO_ADDR
// hc_gallery =  ;
52741: LD_ADDR_OWVAR 33
52745: PUSH
52746: LD_STRING 
52748: ST_TO_ADDR
// animal := CreateHuman ;
52749: LD_ADDR_VAR 0 12
52753: PUSH
52754: CALL_OW 44
52758: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52759: LD_VAR 0 12
52763: PPUSH
52764: LD_VAR 0 9
52768: PPUSH
52769: LD_INT 0
52771: PPUSH
52772: CALL 54423 0 3
// end ;
52776: GO 52730
52778: POP
52779: POP
// end ;
52780: LD_VAR 0 10
52784: RET
// export function WantHeal ( sci , unit ) ; begin
52785: LD_INT 0
52787: PPUSH
// if GetTaskList ( sci ) > 0 then
52788: LD_VAR 0 1
52792: PPUSH
52793: CALL_OW 437
52797: PUSH
52798: LD_INT 0
52800: GREATER
52801: IFFALSE 52873
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52803: LD_VAR 0 1
52807: PPUSH
52808: CALL_OW 437
52812: PUSH
52813: LD_INT 1
52815: ARRAY
52816: PUSH
52817: LD_INT 1
52819: ARRAY
52820: PUSH
52821: LD_STRING l
52823: EQUAL
52824: IFFALSE 52851
52826: PUSH
52827: LD_VAR 0 1
52831: PPUSH
52832: CALL_OW 437
52836: PUSH
52837: LD_INT 1
52839: ARRAY
52840: PUSH
52841: LD_INT 4
52843: ARRAY
52844: PUSH
52845: LD_VAR 0 2
52849: EQUAL
52850: AND
52851: IFFALSE 52863
// result := true else
52853: LD_ADDR_VAR 0 3
52857: PUSH
52858: LD_INT 1
52860: ST_TO_ADDR
52861: GO 52871
// result := false ;
52863: LD_ADDR_VAR 0 3
52867: PUSH
52868: LD_INT 0
52870: ST_TO_ADDR
// end else
52871: GO 52881
// result := false ;
52873: LD_ADDR_VAR 0 3
52877: PUSH
52878: LD_INT 0
52880: ST_TO_ADDR
// end ;
52881: LD_VAR 0 3
52885: RET
// export function HealTarget ( sci ) ; begin
52886: LD_INT 0
52888: PPUSH
// if not sci then
52889: LD_VAR 0 1
52893: NOT
52894: IFFALSE 52898
// exit ;
52896: GO 52963
// result := 0 ;
52898: LD_ADDR_VAR 0 2
52902: PUSH
52903: LD_INT 0
52905: ST_TO_ADDR
// if GetTaskList ( sci ) then
52906: LD_VAR 0 1
52910: PPUSH
52911: CALL_OW 437
52915: IFFALSE 52963
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52917: LD_VAR 0 1
52921: PPUSH
52922: CALL_OW 437
52926: PUSH
52927: LD_INT 1
52929: ARRAY
52930: PUSH
52931: LD_INT 1
52933: ARRAY
52934: PUSH
52935: LD_STRING l
52937: EQUAL
52938: IFFALSE 52963
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52940: LD_ADDR_VAR 0 2
52944: PUSH
52945: LD_VAR 0 1
52949: PPUSH
52950: CALL_OW 437
52954: PUSH
52955: LD_INT 1
52957: ARRAY
52958: PUSH
52959: LD_INT 4
52961: ARRAY
52962: ST_TO_ADDR
// end ;
52963: LD_VAR 0 2
52967: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52968: LD_INT 0
52970: PPUSH
52971: PPUSH
52972: PPUSH
52973: PPUSH
// if not base_units then
52974: LD_VAR 0 1
52978: NOT
52979: IFFALSE 52983
// exit ;
52981: GO 53070
// result := false ;
52983: LD_ADDR_VAR 0 2
52987: PUSH
52988: LD_INT 0
52990: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52991: LD_ADDR_VAR 0 5
52995: PUSH
52996: LD_VAR 0 1
53000: PPUSH
53001: LD_INT 21
53003: PUSH
53004: LD_INT 3
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PPUSH
53011: CALL_OW 72
53015: ST_TO_ADDR
// if not tmp then
53016: LD_VAR 0 5
53020: NOT
53021: IFFALSE 53025
// exit ;
53023: GO 53070
// for i in tmp do
53025: LD_ADDR_VAR 0 3
53029: PUSH
53030: LD_VAR 0 5
53034: PUSH
53035: FOR_IN
53036: IFFALSE 53068
// begin result := EnemyInRange ( i , 22 ) ;
53038: LD_ADDR_VAR 0 2
53042: PUSH
53043: LD_VAR 0 3
53047: PPUSH
53048: LD_INT 22
53050: PPUSH
53051: CALL 50495 0 2
53055: ST_TO_ADDR
// if result then
53056: LD_VAR 0 2
53060: IFFALSE 53066
// exit ;
53062: POP
53063: POP
53064: GO 53070
// end ;
53066: GO 53035
53068: POP
53069: POP
// end ;
53070: LD_VAR 0 2
53074: RET
// export function FilterByTag ( units , tag ) ; begin
53075: LD_INT 0
53077: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_VAR 0 1
53087: PPUSH
53088: LD_INT 120
53090: PUSH
53091: LD_VAR 0 2
53095: PUSH
53096: EMPTY
53097: LIST
53098: LIST
53099: PPUSH
53100: CALL_OW 72
53104: ST_TO_ADDR
// end ;
53105: LD_VAR 0 3
53109: RET
// export function IsDriver ( un ) ; begin
53110: LD_INT 0
53112: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53113: LD_ADDR_VAR 0 2
53117: PUSH
53118: LD_VAR 0 1
53122: PUSH
53123: LD_INT 55
53125: PUSH
53126: EMPTY
53127: LIST
53128: PPUSH
53129: CALL_OW 69
53133: IN
53134: ST_TO_ADDR
// end ;
53135: LD_VAR 0 2
53139: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53140: LD_INT 0
53142: PPUSH
53143: PPUSH
// list := [ ] ;
53144: LD_ADDR_VAR 0 5
53148: PUSH
53149: EMPTY
53150: ST_TO_ADDR
// case d of 0 :
53151: LD_VAR 0 3
53155: PUSH
53156: LD_INT 0
53158: DOUBLE
53159: EQUAL
53160: IFTRUE 53164
53162: GO 53297
53164: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53165: LD_ADDR_VAR 0 5
53169: PUSH
53170: LD_VAR 0 1
53174: PUSH
53175: LD_INT 4
53177: MINUS
53178: PUSH
53179: LD_VAR 0 2
53183: PUSH
53184: LD_INT 4
53186: MINUS
53187: PUSH
53188: LD_INT 2
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: LIST
53195: PUSH
53196: LD_VAR 0 1
53200: PUSH
53201: LD_INT 3
53203: MINUS
53204: PUSH
53205: LD_VAR 0 2
53209: PUSH
53210: LD_INT 1
53212: PUSH
53213: EMPTY
53214: LIST
53215: LIST
53216: LIST
53217: PUSH
53218: LD_VAR 0 1
53222: PUSH
53223: LD_INT 4
53225: PLUS
53226: PUSH
53227: LD_VAR 0 2
53231: PUSH
53232: LD_INT 4
53234: PUSH
53235: EMPTY
53236: LIST
53237: LIST
53238: LIST
53239: PUSH
53240: LD_VAR 0 1
53244: PUSH
53245: LD_INT 3
53247: PLUS
53248: PUSH
53249: LD_VAR 0 2
53253: PUSH
53254: LD_INT 3
53256: PLUS
53257: PUSH
53258: LD_INT 5
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: LIST
53265: PUSH
53266: LD_VAR 0 1
53270: PUSH
53271: LD_VAR 0 2
53275: PUSH
53276: LD_INT 4
53278: PLUS
53279: PUSH
53280: LD_INT 0
53282: PUSH
53283: EMPTY
53284: LIST
53285: LIST
53286: LIST
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: LIST
53292: LIST
53293: LIST
53294: ST_TO_ADDR
// end ; 1 :
53295: GO 53995
53297: LD_INT 1
53299: DOUBLE
53300: EQUAL
53301: IFTRUE 53305
53303: GO 53438
53305: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53306: LD_ADDR_VAR 0 5
53310: PUSH
53311: LD_VAR 0 1
53315: PUSH
53316: LD_VAR 0 2
53320: PUSH
53321: LD_INT 4
53323: MINUS
53324: PUSH
53325: LD_INT 3
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: LIST
53332: PUSH
53333: LD_VAR 0 1
53337: PUSH
53338: LD_INT 3
53340: MINUS
53341: PUSH
53342: LD_VAR 0 2
53346: PUSH
53347: LD_INT 3
53349: MINUS
53350: PUSH
53351: LD_INT 2
53353: PUSH
53354: EMPTY
53355: LIST
53356: LIST
53357: LIST
53358: PUSH
53359: LD_VAR 0 1
53363: PUSH
53364: LD_INT 4
53366: MINUS
53367: PUSH
53368: LD_VAR 0 2
53372: PUSH
53373: LD_INT 1
53375: PUSH
53376: EMPTY
53377: LIST
53378: LIST
53379: LIST
53380: PUSH
53381: LD_VAR 0 1
53385: PUSH
53386: LD_VAR 0 2
53390: PUSH
53391: LD_INT 3
53393: PLUS
53394: PUSH
53395: LD_INT 0
53397: PUSH
53398: EMPTY
53399: LIST
53400: LIST
53401: LIST
53402: PUSH
53403: LD_VAR 0 1
53407: PUSH
53408: LD_INT 4
53410: PLUS
53411: PUSH
53412: LD_VAR 0 2
53416: PUSH
53417: LD_INT 4
53419: PLUS
53420: PUSH
53421: LD_INT 5
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: LIST
53433: LIST
53434: LIST
53435: ST_TO_ADDR
// end ; 2 :
53436: GO 53995
53438: LD_INT 2
53440: DOUBLE
53441: EQUAL
53442: IFTRUE 53446
53444: GO 53575
53446: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53447: LD_ADDR_VAR 0 5
53451: PUSH
53452: LD_VAR 0 1
53456: PUSH
53457: LD_VAR 0 2
53461: PUSH
53462: LD_INT 3
53464: MINUS
53465: PUSH
53466: LD_INT 3
53468: PUSH
53469: EMPTY
53470: LIST
53471: LIST
53472: LIST
53473: PUSH
53474: LD_VAR 0 1
53478: PUSH
53479: LD_INT 4
53481: PLUS
53482: PUSH
53483: LD_VAR 0 2
53487: PUSH
53488: LD_INT 4
53490: PUSH
53491: EMPTY
53492: LIST
53493: LIST
53494: LIST
53495: PUSH
53496: LD_VAR 0 1
53500: PUSH
53501: LD_VAR 0 2
53505: PUSH
53506: LD_INT 4
53508: PLUS
53509: PUSH
53510: LD_INT 0
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: LIST
53517: PUSH
53518: LD_VAR 0 1
53522: PUSH
53523: LD_INT 3
53525: MINUS
53526: PUSH
53527: LD_VAR 0 2
53531: PUSH
53532: LD_INT 1
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: LIST
53539: PUSH
53540: LD_VAR 0 1
53544: PUSH
53545: LD_INT 4
53547: MINUS
53548: PUSH
53549: LD_VAR 0 2
53553: PUSH
53554: LD_INT 4
53556: MINUS
53557: PUSH
53558: LD_INT 2
53560: PUSH
53561: EMPTY
53562: LIST
53563: LIST
53564: LIST
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: LIST
53570: LIST
53571: LIST
53572: ST_TO_ADDR
// end ; 3 :
53573: GO 53995
53575: LD_INT 3
53577: DOUBLE
53578: EQUAL
53579: IFTRUE 53583
53581: GO 53716
53583: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53584: LD_ADDR_VAR 0 5
53588: PUSH
53589: LD_VAR 0 1
53593: PUSH
53594: LD_INT 3
53596: PLUS
53597: PUSH
53598: LD_VAR 0 2
53602: PUSH
53603: LD_INT 4
53605: PUSH
53606: EMPTY
53607: LIST
53608: LIST
53609: LIST
53610: PUSH
53611: LD_VAR 0 1
53615: PUSH
53616: LD_INT 4
53618: PLUS
53619: PUSH
53620: LD_VAR 0 2
53624: PUSH
53625: LD_INT 4
53627: PLUS
53628: PUSH
53629: LD_INT 5
53631: PUSH
53632: EMPTY
53633: LIST
53634: LIST
53635: LIST
53636: PUSH
53637: LD_VAR 0 1
53641: PUSH
53642: LD_INT 4
53644: MINUS
53645: PUSH
53646: LD_VAR 0 2
53650: PUSH
53651: LD_INT 1
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: LIST
53658: PUSH
53659: LD_VAR 0 1
53663: PUSH
53664: LD_VAR 0 2
53668: PUSH
53669: LD_INT 4
53671: MINUS
53672: PUSH
53673: LD_INT 3
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: LIST
53680: PUSH
53681: LD_VAR 0 1
53685: PUSH
53686: LD_INT 3
53688: MINUS
53689: PUSH
53690: LD_VAR 0 2
53694: PUSH
53695: LD_INT 3
53697: MINUS
53698: PUSH
53699: LD_INT 2
53701: PUSH
53702: EMPTY
53703: LIST
53704: LIST
53705: LIST
53706: PUSH
53707: EMPTY
53708: LIST
53709: LIST
53710: LIST
53711: LIST
53712: LIST
53713: ST_TO_ADDR
// end ; 4 :
53714: GO 53995
53716: LD_INT 4
53718: DOUBLE
53719: EQUAL
53720: IFTRUE 53724
53722: GO 53857
53724: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53725: LD_ADDR_VAR 0 5
53729: PUSH
53730: LD_VAR 0 1
53734: PUSH
53735: LD_VAR 0 2
53739: PUSH
53740: LD_INT 4
53742: PLUS
53743: PUSH
53744: LD_INT 0
53746: PUSH
53747: EMPTY
53748: LIST
53749: LIST
53750: LIST
53751: PUSH
53752: LD_VAR 0 1
53756: PUSH
53757: LD_INT 3
53759: PLUS
53760: PUSH
53761: LD_VAR 0 2
53765: PUSH
53766: LD_INT 3
53768: PLUS
53769: PUSH
53770: LD_INT 5
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: LIST
53777: PUSH
53778: LD_VAR 0 1
53782: PUSH
53783: LD_INT 4
53785: PLUS
53786: PUSH
53787: LD_VAR 0 2
53791: PUSH
53792: LD_INT 4
53794: PUSH
53795: EMPTY
53796: LIST
53797: LIST
53798: LIST
53799: PUSH
53800: LD_VAR 0 1
53804: PUSH
53805: LD_VAR 0 2
53809: PUSH
53810: LD_INT 3
53812: MINUS
53813: PUSH
53814: LD_INT 3
53816: PUSH
53817: EMPTY
53818: LIST
53819: LIST
53820: LIST
53821: PUSH
53822: LD_VAR 0 1
53826: PUSH
53827: LD_INT 4
53829: MINUS
53830: PUSH
53831: LD_VAR 0 2
53835: PUSH
53836: LD_INT 4
53838: MINUS
53839: PUSH
53840: LD_INT 2
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: PUSH
53848: EMPTY
53849: LIST
53850: LIST
53851: LIST
53852: LIST
53853: LIST
53854: ST_TO_ADDR
// end ; 5 :
53855: GO 53995
53857: LD_INT 5
53859: DOUBLE
53860: EQUAL
53861: IFTRUE 53865
53863: GO 53994
53865: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53866: LD_ADDR_VAR 0 5
53870: PUSH
53871: LD_VAR 0 1
53875: PUSH
53876: LD_INT 4
53878: MINUS
53879: PUSH
53880: LD_VAR 0 2
53884: PUSH
53885: LD_INT 1
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: LIST
53892: PUSH
53893: LD_VAR 0 1
53897: PUSH
53898: LD_VAR 0 2
53902: PUSH
53903: LD_INT 4
53905: MINUS
53906: PUSH
53907: LD_INT 3
53909: PUSH
53910: EMPTY
53911: LIST
53912: LIST
53913: LIST
53914: PUSH
53915: LD_VAR 0 1
53919: PUSH
53920: LD_INT 4
53922: PLUS
53923: PUSH
53924: LD_VAR 0 2
53928: PUSH
53929: LD_INT 4
53931: PLUS
53932: PUSH
53933: LD_INT 5
53935: PUSH
53936: EMPTY
53937: LIST
53938: LIST
53939: LIST
53940: PUSH
53941: LD_VAR 0 1
53945: PUSH
53946: LD_INT 3
53948: PLUS
53949: PUSH
53950: LD_VAR 0 2
53954: PUSH
53955: LD_INT 4
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: LIST
53962: PUSH
53963: LD_VAR 0 1
53967: PUSH
53968: LD_VAR 0 2
53972: PUSH
53973: LD_INT 3
53975: PLUS
53976: PUSH
53977: LD_INT 0
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: LIST
53984: PUSH
53985: EMPTY
53986: LIST
53987: LIST
53988: LIST
53989: LIST
53990: LIST
53991: ST_TO_ADDR
// end ; end ;
53992: GO 53995
53994: POP
// result := list ;
53995: LD_ADDR_VAR 0 4
53999: PUSH
54000: LD_VAR 0 5
54004: ST_TO_ADDR
// end ;
54005: LD_VAR 0 4
54009: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54010: LD_INT 0
54012: PPUSH
54013: PPUSH
54014: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54015: LD_VAR 0 1
54019: NOT
54020: IFTRUE 54048
54022: PUSH
54023: LD_VAR 0 2
54027: PUSH
54028: LD_INT 1
54030: PUSH
54031: LD_INT 2
54033: PUSH
54034: LD_INT 3
54036: PUSH
54037: LD_INT 4
54039: PUSH
54040: EMPTY
54041: LIST
54042: LIST
54043: LIST
54044: LIST
54045: IN
54046: NOT
54047: OR
54048: IFFALSE 54052
// exit ;
54050: GO 54135
// tmp := [ ] ;
54052: LD_ADDR_VAR 0 5
54056: PUSH
54057: EMPTY
54058: ST_TO_ADDR
// for i in units do
54059: LD_ADDR_VAR 0 4
54063: PUSH
54064: LD_VAR 0 1
54068: PUSH
54069: FOR_IN
54070: IFFALSE 54104
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
54072: LD_ADDR_VAR 0 5
54076: PUSH
54077: LD_VAR 0 5
54081: PPUSH
54082: LD_VAR 0 4
54086: PPUSH
54087: LD_VAR 0 2
54091: PPUSH
54092: CALL_OW 259
54096: PPUSH
54097: CALL 55530 0 2
54101: ST_TO_ADDR
54102: GO 54069
54104: POP
54105: POP
// if not tmp then
54106: LD_VAR 0 5
54110: NOT
54111: IFFALSE 54115
// exit ;
54113: GO 54135
// result := SortListByListDesc ( units , tmp ) ;
54115: LD_ADDR_VAR 0 3
54119: PUSH
54120: LD_VAR 0 1
54124: PPUSH
54125: LD_VAR 0 5
54129: PPUSH
54130: CALL_OW 77
54134: ST_TO_ADDR
// end ;
54135: LD_VAR 0 3
54139: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54140: LD_INT 0
54142: PPUSH
54143: PPUSH
54144: PPUSH
// result := false ;
54145: LD_ADDR_VAR 0 3
54149: PUSH
54150: LD_INT 0
54152: ST_TO_ADDR
// if not building then
54153: LD_VAR 0 2
54157: NOT
54158: IFFALSE 54162
// exit ;
54160: GO 54306
// x := GetX ( building ) ;
54162: LD_ADDR_VAR 0 4
54166: PUSH
54167: LD_VAR 0 2
54171: PPUSH
54172: CALL_OW 250
54176: ST_TO_ADDR
// y := GetY ( building ) ;
54177: LD_ADDR_VAR 0 5
54181: PUSH
54182: LD_VAR 0 2
54186: PPUSH
54187: CALL_OW 251
54191: ST_TO_ADDR
// if not x or not y then
54192: LD_VAR 0 4
54196: NOT
54197: IFTRUE 54206
54199: PUSH
54200: LD_VAR 0 5
54204: NOT
54205: OR
54206: IFFALSE 54210
// exit ;
54208: GO 54306
// if GetTaskList ( unit ) then
54210: LD_VAR 0 1
54214: PPUSH
54215: CALL_OW 437
54219: IFFALSE 54306
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54221: LD_STRING e
54223: PUSH
54224: LD_VAR 0 1
54228: PPUSH
54229: CALL_OW 437
54233: PUSH
54234: LD_INT 1
54236: ARRAY
54237: PUSH
54238: LD_INT 1
54240: ARRAY
54241: EQUAL
54242: IFFALSE 54269
54244: PUSH
54245: LD_VAR 0 4
54249: PUSH
54250: LD_VAR 0 1
54254: PPUSH
54255: CALL_OW 437
54259: PUSH
54260: LD_INT 1
54262: ARRAY
54263: PUSH
54264: LD_INT 2
54266: ARRAY
54267: EQUAL
54268: AND
54269: IFFALSE 54296
54271: PUSH
54272: LD_VAR 0 5
54276: PUSH
54277: LD_VAR 0 1
54281: PPUSH
54282: CALL_OW 437
54286: PUSH
54287: LD_INT 1
54289: ARRAY
54290: PUSH
54291: LD_INT 3
54293: ARRAY
54294: EQUAL
54295: AND
54296: IFFALSE 54306
// result := true end ;
54298: LD_ADDR_VAR 0 3
54302: PUSH
54303: LD_INT 1
54305: ST_TO_ADDR
// end ;
54306: LD_VAR 0 3
54310: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54311: LD_INT 0
54313: PPUSH
// result := false ;
54314: LD_ADDR_VAR 0 4
54318: PUSH
54319: LD_INT 0
54321: ST_TO_ADDR
// if GetTaskList ( unit ) then
54322: LD_VAR 0 1
54326: PPUSH
54327: CALL_OW 437
54331: IFFALSE 54418
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54333: LD_STRING M
54335: PUSH
54336: LD_VAR 0 1
54340: PPUSH
54341: CALL_OW 437
54345: PUSH
54346: LD_INT 1
54348: ARRAY
54349: PUSH
54350: LD_INT 1
54352: ARRAY
54353: EQUAL
54354: IFFALSE 54381
54356: PUSH
54357: LD_VAR 0 2
54361: PUSH
54362: LD_VAR 0 1
54366: PPUSH
54367: CALL_OW 437
54371: PUSH
54372: LD_INT 1
54374: ARRAY
54375: PUSH
54376: LD_INT 2
54378: ARRAY
54379: EQUAL
54380: AND
54381: IFFALSE 54408
54383: PUSH
54384: LD_VAR 0 3
54388: PUSH
54389: LD_VAR 0 1
54393: PPUSH
54394: CALL_OW 437
54398: PUSH
54399: LD_INT 1
54401: ARRAY
54402: PUSH
54403: LD_INT 3
54405: ARRAY
54406: EQUAL
54407: AND
54408: IFFALSE 54418
// result := true ;
54410: LD_ADDR_VAR 0 4
54414: PUSH
54415: LD_INT 1
54417: ST_TO_ADDR
// end ; end ;
54418: LD_VAR 0 4
54422: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54423: LD_INT 0
54425: PPUSH
54426: PPUSH
54427: PPUSH
54428: PPUSH
// if not unit or not area then
54429: LD_VAR 0 1
54433: NOT
54434: IFTRUE 54443
54436: PUSH
54437: LD_VAR 0 2
54441: NOT
54442: OR
54443: IFFALSE 54447
// exit ;
54445: GO 54623
// tmp := AreaToList ( area , i ) ;
54447: LD_ADDR_VAR 0 6
54451: PUSH
54452: LD_VAR 0 2
54456: PPUSH
54457: LD_VAR 0 5
54461: PPUSH
54462: CALL_OW 517
54466: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54467: LD_ADDR_VAR 0 5
54471: PUSH
54472: DOUBLE
54473: LD_INT 1
54475: DEC
54476: ST_TO_ADDR
54477: LD_VAR 0 6
54481: PUSH
54482: LD_INT 1
54484: ARRAY
54485: PUSH
54486: FOR_TO
54487: IFFALSE 54621
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54489: LD_ADDR_VAR 0 7
54493: PUSH
54494: LD_VAR 0 6
54498: PUSH
54499: LD_INT 1
54501: ARRAY
54502: PUSH
54503: LD_VAR 0 5
54507: ARRAY
54508: PUSH
54509: LD_VAR 0 6
54513: PUSH
54514: LD_INT 2
54516: ARRAY
54517: PUSH
54518: LD_VAR 0 5
54522: ARRAY
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
54528: LD_INT 92
54530: PUSH
54531: LD_VAR 0 7
54535: PUSH
54536: LD_INT 1
54538: ARRAY
54539: PUSH
54540: LD_VAR 0 7
54544: PUSH
54545: LD_INT 2
54547: ARRAY
54548: PUSH
54549: LD_INT 2
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: LIST
54556: LIST
54557: PPUSH
54558: CALL_OW 69
54562: PUSH
54563: LD_INT 0
54565: EQUAL
54566: IFFALSE 54619
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54568: LD_VAR 0 1
54572: PPUSH
54573: LD_VAR 0 7
54577: PUSH
54578: LD_INT 1
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 7
54586: PUSH
54587: LD_INT 2
54589: ARRAY
54590: PPUSH
54591: LD_VAR 0 3
54595: PPUSH
54596: CALL_OW 48
// result := IsPlaced ( unit ) ;
54600: LD_ADDR_VAR 0 4
54604: PUSH
54605: LD_VAR 0 1
54609: PPUSH
54610: CALL_OW 305
54614: ST_TO_ADDR
// exit ;
54615: POP
54616: POP
54617: GO 54623
// end ; end ;
54619: GO 54486
54621: POP
54622: POP
// end ;
54623: LD_VAR 0 4
54627: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54628: LD_INT 0
54630: PPUSH
54631: PPUSH
54632: PPUSH
// if not side or side > 8 then
54633: LD_VAR 0 1
54637: NOT
54638: IFTRUE 54650
54640: PUSH
54641: LD_VAR 0 1
54645: PUSH
54646: LD_INT 8
54648: GREATER
54649: OR
54650: IFFALSE 54654
// exit ;
54652: GO 54841
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54654: LD_ADDR_VAR 0 4
54658: PUSH
54659: LD_INT 22
54661: PUSH
54662: LD_VAR 0 1
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: PUSH
54671: LD_INT 21
54673: PUSH
54674: LD_INT 3
54676: PUSH
54677: EMPTY
54678: LIST
54679: LIST
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: PPUSH
54685: CALL_OW 69
54689: ST_TO_ADDR
// if not tmp then
54690: LD_VAR 0 4
54694: NOT
54695: IFFALSE 54699
// exit ;
54697: GO 54841
// enable_addtolog := true ;
54699: LD_ADDR_OWVAR 81
54703: PUSH
54704: LD_INT 1
54706: ST_TO_ADDR
// AddToLog ( [ ) ;
54707: LD_STRING [
54709: PPUSH
54710: CALL_OW 561
// for i in tmp do
54714: LD_ADDR_VAR 0 3
54718: PUSH
54719: LD_VAR 0 4
54723: PUSH
54724: FOR_IN
54725: IFFALSE 54832
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54727: LD_STRING [
54729: PUSH
54730: LD_VAR 0 3
54734: PPUSH
54735: CALL_OW 266
54739: STR
54740: PUSH
54741: LD_STRING , 
54743: STR
54744: PUSH
54745: LD_VAR 0 3
54749: PPUSH
54750: CALL_OW 250
54754: STR
54755: PUSH
54756: LD_STRING , 
54758: STR
54759: PUSH
54760: LD_VAR 0 3
54764: PPUSH
54765: CALL_OW 251
54769: STR
54770: PUSH
54771: LD_STRING , 
54773: STR
54774: PUSH
54775: LD_VAR 0 3
54779: PPUSH
54780: CALL_OW 254
54784: STR
54785: PUSH
54786: LD_STRING , 
54788: STR
54789: PUSH
54790: LD_VAR 0 3
54794: PPUSH
54795: LD_INT 1
54797: PPUSH
54798: CALL_OW 268
54802: STR
54803: PUSH
54804: LD_STRING , 
54806: STR
54807: PUSH
54808: LD_VAR 0 3
54812: PPUSH
54813: LD_INT 2
54815: PPUSH
54816: CALL_OW 268
54820: STR
54821: PUSH
54822: LD_STRING ],
54824: STR
54825: PPUSH
54826: CALL_OW 561
// end ;
54830: GO 54724
54832: POP
54833: POP
// AddToLog ( ]; ) ;
54834: LD_STRING ];
54836: PPUSH
54837: CALL_OW 561
// end ;
54841: LD_VAR 0 2
54845: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54846: LD_INT 0
54848: PPUSH
54849: PPUSH
54850: PPUSH
54851: PPUSH
54852: PPUSH
// if not area or not rate or not max then
54853: LD_VAR 0 1
54857: NOT
54858: IFTRUE 54867
54860: PUSH
54861: LD_VAR 0 2
54865: NOT
54866: OR
54867: IFTRUE 54876
54869: PUSH
54870: LD_VAR 0 4
54874: NOT
54875: OR
54876: IFFALSE 54880
// exit ;
54878: GO 55069
// while 1 do
54880: LD_INT 1
54882: IFFALSE 55069
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54884: LD_ADDR_VAR 0 9
54888: PUSH
54889: LD_VAR 0 1
54893: PPUSH
54894: LD_INT 1
54896: PPUSH
54897: CALL_OW 287
54901: PUSH
54902: LD_INT 10
54904: MUL
54905: ST_TO_ADDR
// r := rate / 10 ;
54906: LD_ADDR_VAR 0 7
54910: PUSH
54911: LD_VAR 0 2
54915: PUSH
54916: LD_INT 10
54918: DIVREAL
54919: ST_TO_ADDR
// time := 1 1$00 ;
54920: LD_ADDR_VAR 0 8
54924: PUSH
54925: LD_INT 2100
54927: ST_TO_ADDR
// if amount < min then
54928: LD_VAR 0 9
54932: PUSH
54933: LD_VAR 0 3
54937: LESS
54938: IFFALSE 54956
// r := r * 2 else
54940: LD_ADDR_VAR 0 7
54944: PUSH
54945: LD_VAR 0 7
54949: PUSH
54950: LD_INT 2
54952: MUL
54953: ST_TO_ADDR
54954: GO 54982
// if amount > max then
54956: LD_VAR 0 9
54960: PUSH
54961: LD_VAR 0 4
54965: GREATER
54966: IFFALSE 54982
// r := r / 2 ;
54968: LD_ADDR_VAR 0 7
54972: PUSH
54973: LD_VAR 0 7
54977: PUSH
54978: LD_INT 2
54980: DIVREAL
54981: ST_TO_ADDR
// time := time / r ;
54982: LD_ADDR_VAR 0 8
54986: PUSH
54987: LD_VAR 0 8
54991: PUSH
54992: LD_VAR 0 7
54996: DIVREAL
54997: ST_TO_ADDR
// if time < 0 then
54998: LD_VAR 0 8
55002: PUSH
55003: LD_INT 0
55005: LESS
55006: IFFALSE 55023
// time := time * - 1 ;
55008: LD_ADDR_VAR 0 8
55012: PUSH
55013: LD_VAR 0 8
55017: PUSH
55018: LD_INT 1
55020: NEG
55021: MUL
55022: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
55023: LD_VAR 0 8
55027: PUSH
55028: LD_INT 35
55030: PPUSH
55031: LD_INT 875
55033: PPUSH
55034: CALL_OW 12
55038: PLUS
55039: PPUSH
55040: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55044: LD_INT 1
55046: PPUSH
55047: LD_INT 5
55049: PPUSH
55050: CALL_OW 12
55054: PPUSH
55055: LD_VAR 0 1
55059: PPUSH
55060: LD_INT 1
55062: PPUSH
55063: CALL_OW 55
// end ;
55067: GO 54880
// end ;
55069: LD_VAR 0 5
55073: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55074: LD_INT 0
55076: PPUSH
55077: PPUSH
55078: PPUSH
55079: PPUSH
55080: PPUSH
55081: PPUSH
55082: PPUSH
55083: PPUSH
// if not turrets or not factories then
55084: LD_VAR 0 1
55088: NOT
55089: IFTRUE 55098
55091: PUSH
55092: LD_VAR 0 2
55096: NOT
55097: OR
55098: IFFALSE 55102
// exit ;
55100: GO 55409
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55102: LD_ADDR_VAR 0 10
55106: PUSH
55107: LD_INT 5
55109: PUSH
55110: LD_INT 6
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: LD_INT 2
55119: PUSH
55120: LD_INT 4
55122: PUSH
55123: EMPTY
55124: LIST
55125: LIST
55126: PUSH
55127: LD_INT 3
55129: PUSH
55130: LD_INT 5
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: LIST
55141: PUSH
55142: LD_INT 24
55144: PUSH
55145: LD_INT 25
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: PUSH
55152: LD_INT 23
55154: PUSH
55155: LD_INT 27
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: PUSH
55166: LD_INT 42
55168: PUSH
55169: LD_INT 43
55171: PUSH
55172: EMPTY
55173: LIST
55174: LIST
55175: PUSH
55176: LD_INT 44
55178: PUSH
55179: LD_INT 46
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PUSH
55186: LD_INT 45
55188: PUSH
55189: LD_INT 47
55191: PUSH
55192: EMPTY
55193: LIST
55194: LIST
55195: PUSH
55196: EMPTY
55197: LIST
55198: LIST
55199: LIST
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
// result := [ ] ;
55206: LD_ADDR_VAR 0 3
55210: PUSH
55211: EMPTY
55212: ST_TO_ADDR
// for i in turrets do
55213: LD_ADDR_VAR 0 4
55217: PUSH
55218: LD_VAR 0 1
55222: PUSH
55223: FOR_IN
55224: IFFALSE 55407
// begin nat := GetNation ( i ) ;
55226: LD_ADDR_VAR 0 7
55230: PUSH
55231: LD_VAR 0 4
55235: PPUSH
55236: CALL_OW 248
55240: ST_TO_ADDR
// weapon := 0 ;
55241: LD_ADDR_VAR 0 8
55245: PUSH
55246: LD_INT 0
55248: ST_TO_ADDR
// if not nat then
55249: LD_VAR 0 7
55253: NOT
55254: IFFALSE 55258
// continue ;
55256: GO 55223
// for j in list [ nat ] do
55258: LD_ADDR_VAR 0 5
55262: PUSH
55263: LD_VAR 0 10
55267: PUSH
55268: LD_VAR 0 7
55272: ARRAY
55273: PUSH
55274: FOR_IN
55275: IFFALSE 55316
// if GetBWeapon ( i ) = j [ 1 ] then
55277: LD_VAR 0 4
55281: PPUSH
55282: CALL_OW 269
55286: PUSH
55287: LD_VAR 0 5
55291: PUSH
55292: LD_INT 1
55294: ARRAY
55295: EQUAL
55296: IFFALSE 55314
// begin weapon := j [ 2 ] ;
55298: LD_ADDR_VAR 0 8
55302: PUSH
55303: LD_VAR 0 5
55307: PUSH
55308: LD_INT 2
55310: ARRAY
55311: ST_TO_ADDR
// break ;
55312: GO 55316
// end ;
55314: GO 55274
55316: POP
55317: POP
// if not weapon then
55318: LD_VAR 0 8
55322: NOT
55323: IFFALSE 55327
// continue ;
55325: GO 55223
// for k in factories do
55327: LD_ADDR_VAR 0 6
55331: PUSH
55332: LD_VAR 0 2
55336: PUSH
55337: FOR_IN
55338: IFFALSE 55403
// begin weapons := AvailableWeaponList ( k ) ;
55340: LD_ADDR_VAR 0 9
55344: PUSH
55345: LD_VAR 0 6
55349: PPUSH
55350: CALL_OW 478
55354: ST_TO_ADDR
// if not weapons then
55355: LD_VAR 0 9
55359: NOT
55360: IFFALSE 55364
// continue ;
55362: GO 55337
// if weapon in weapons then
55364: LD_VAR 0 8
55368: PUSH
55369: LD_VAR 0 9
55373: IN
55374: IFFALSE 55401
// begin result := [ i , weapon ] ;
55376: LD_ADDR_VAR 0 3
55380: PUSH
55381: LD_VAR 0 4
55385: PUSH
55386: LD_VAR 0 8
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: ST_TO_ADDR
// exit ;
55395: POP
55396: POP
55397: POP
55398: POP
55399: GO 55409
// end ; end ;
55401: GO 55337
55403: POP
55404: POP
// end ;
55405: GO 55223
55407: POP
55408: POP
// end ;
55409: LD_VAR 0 3
55413: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55414: LD_INT 0
55416: PPUSH
// if not side or side > 8 then
55417: LD_VAR 0 3
55421: NOT
55422: IFTRUE 55434
55424: PUSH
55425: LD_VAR 0 3
55429: PUSH
55430: LD_INT 8
55432: GREATER
55433: OR
55434: IFFALSE 55438
// exit ;
55436: GO 55497
// if not range then
55438: LD_VAR 0 4
55442: NOT
55443: IFFALSE 55454
// range := - 12 ;
55445: LD_ADDR_VAR 0 4
55449: PUSH
55450: LD_INT 12
55452: NEG
55453: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55454: LD_VAR 0 1
55458: PPUSH
55459: LD_VAR 0 2
55463: PPUSH
55464: LD_VAR 0 3
55468: PPUSH
55469: LD_VAR 0 4
55473: PPUSH
55474: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55478: LD_VAR 0 1
55482: PPUSH
55483: LD_VAR 0 2
55487: PPUSH
55488: LD_VAR 0 3
55492: PPUSH
55493: CALL_OW 331
// end ;
55497: LD_VAR 0 5
55501: RET
// export function Video ( mode ) ; begin
55502: LD_INT 0
55504: PPUSH
// ingame_video = mode ;
55505: LD_ADDR_OWVAR 52
55509: PUSH
55510: LD_VAR 0 1
55514: ST_TO_ADDR
// interface_hidden = mode ;
55515: LD_ADDR_OWVAR 54
55519: PUSH
55520: LD_VAR 0 1
55524: ST_TO_ADDR
// end ;
55525: LD_VAR 0 2
55529: RET
// export function Join ( array , element ) ; begin
55530: LD_INT 0
55532: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55533: LD_ADDR_VAR 0 3
55537: PUSH
55538: LD_VAR 0 1
55542: PPUSH
55543: LD_VAR 0 1
55547: PUSH
55548: LD_INT 1
55550: PLUS
55551: PPUSH
55552: LD_VAR 0 2
55556: PPUSH
55557: CALL_OW 1
55561: ST_TO_ADDR
// end ;
55562: LD_VAR 0 3
55566: RET
// export function JoinUnion ( array , element ) ; begin
55567: LD_INT 0
55569: PPUSH
// result := array union element ;
55570: LD_ADDR_VAR 0 3
55574: PUSH
55575: LD_VAR 0 1
55579: PUSH
55580: LD_VAR 0 2
55584: UNION
55585: ST_TO_ADDR
// end ;
55586: LD_VAR 0 3
55590: RET
// export function GetBehemoths ( side ) ; begin
55591: LD_INT 0
55593: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55594: LD_ADDR_VAR 0 2
55598: PUSH
55599: LD_INT 22
55601: PUSH
55602: LD_VAR 0 1
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: PUSH
55611: LD_INT 31
55613: PUSH
55614: LD_INT 25
55616: PUSH
55617: EMPTY
55618: LIST
55619: LIST
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: PPUSH
55625: CALL_OW 69
55629: ST_TO_ADDR
// end ;
55630: LD_VAR 0 2
55634: RET
// export function Shuffle ( array ) ; var i , index ; begin
55635: LD_INT 0
55637: PPUSH
55638: PPUSH
55639: PPUSH
// result := [ ] ;
55640: LD_ADDR_VAR 0 2
55644: PUSH
55645: EMPTY
55646: ST_TO_ADDR
// if not array then
55647: LD_VAR 0 1
55651: NOT
55652: IFFALSE 55656
// exit ;
55654: GO 55755
// Randomize ;
55656: CALL_OW 10
// for i = array downto 1 do
55660: LD_ADDR_VAR 0 3
55664: PUSH
55665: DOUBLE
55666: LD_VAR 0 1
55670: INC
55671: ST_TO_ADDR
55672: LD_INT 1
55674: PUSH
55675: FOR_DOWNTO
55676: IFFALSE 55753
// begin index := rand ( 1 , array ) ;
55678: LD_ADDR_VAR 0 4
55682: PUSH
55683: LD_INT 1
55685: PPUSH
55686: LD_VAR 0 1
55690: PPUSH
55691: CALL_OW 12
55695: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55696: LD_ADDR_VAR 0 2
55700: PUSH
55701: LD_VAR 0 2
55705: PPUSH
55706: LD_VAR 0 2
55710: PUSH
55711: LD_INT 1
55713: PLUS
55714: PPUSH
55715: LD_VAR 0 1
55719: PUSH
55720: LD_VAR 0 4
55724: ARRAY
55725: PPUSH
55726: CALL_OW 2
55730: ST_TO_ADDR
// array := Delete ( array , index ) ;
55731: LD_ADDR_VAR 0 1
55735: PUSH
55736: LD_VAR 0 1
55740: PPUSH
55741: LD_VAR 0 4
55745: PPUSH
55746: CALL_OW 3
55750: ST_TO_ADDR
// end ;
55751: GO 55675
55753: POP
55754: POP
// end ;
55755: LD_VAR 0 2
55759: RET
// export function GetBaseMaterials ( base ) ; begin
55760: LD_INT 0
55762: PPUSH
// result := [ 0 , 0 , 0 ] ;
55763: LD_ADDR_VAR 0 2
55767: PUSH
55768: LD_INT 0
55770: PUSH
55771: LD_INT 0
55773: PUSH
55774: LD_INT 0
55776: PUSH
55777: EMPTY
55778: LIST
55779: LIST
55780: LIST
55781: ST_TO_ADDR
// if not base then
55782: LD_VAR 0 1
55786: NOT
55787: IFFALSE 55791
// exit ;
55789: GO 55840
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55791: LD_ADDR_VAR 0 2
55795: PUSH
55796: LD_VAR 0 1
55800: PPUSH
55801: LD_INT 1
55803: PPUSH
55804: CALL_OW 275
55808: PUSH
55809: LD_VAR 0 1
55813: PPUSH
55814: LD_INT 2
55816: PPUSH
55817: CALL_OW 275
55821: PUSH
55822: LD_VAR 0 1
55826: PPUSH
55827: LD_INT 3
55829: PPUSH
55830: CALL_OW 275
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: LIST
55839: ST_TO_ADDR
// end ;
55840: LD_VAR 0 2
55844: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55845: LD_INT 0
55847: PPUSH
55848: PPUSH
// result := array ;
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: LD_VAR 0 1
55858: ST_TO_ADDR
// if size >= result then
55859: LD_VAR 0 2
55863: PUSH
55864: LD_VAR 0 3
55868: GREATEREQUAL
55869: IFFALSE 55873
// exit ;
55871: GO 55923
// if size then
55873: LD_VAR 0 2
55877: IFFALSE 55923
// for i := array downto size do
55879: LD_ADDR_VAR 0 4
55883: PUSH
55884: DOUBLE
55885: LD_VAR 0 1
55889: INC
55890: ST_TO_ADDR
55891: LD_VAR 0 2
55895: PUSH
55896: FOR_DOWNTO
55897: IFFALSE 55921
// result := Delete ( result , result ) ;
55899: LD_ADDR_VAR 0 3
55903: PUSH
55904: LD_VAR 0 3
55908: PPUSH
55909: LD_VAR 0 3
55913: PPUSH
55914: CALL_OW 3
55918: ST_TO_ADDR
55919: GO 55896
55921: POP
55922: POP
// end ;
55923: LD_VAR 0 3
55927: RET
// export function ComExit ( unit ) ; var tmp ; begin
55928: LD_INT 0
55930: PPUSH
55931: PPUSH
// if not IsInUnit ( unit ) then
55932: LD_VAR 0 1
55936: PPUSH
55937: CALL_OW 310
55941: NOT
55942: IFFALSE 55946
// exit ;
55944: GO 56006
// tmp := IsInUnit ( unit ) ;
55946: LD_ADDR_VAR 0 3
55950: PUSH
55951: LD_VAR 0 1
55955: PPUSH
55956: CALL_OW 310
55960: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55961: LD_VAR 0 3
55965: PPUSH
55966: CALL_OW 247
55970: PUSH
55971: LD_INT 2
55973: EQUAL
55974: IFFALSE 55987
// ComExitVehicle ( unit ) else
55976: LD_VAR 0 1
55980: PPUSH
55981: CALL_OW 121
55985: GO 55996
// ComExitBuilding ( unit ) ;
55987: LD_VAR 0 1
55991: PPUSH
55992: CALL_OW 122
// result := tmp ;
55996: LD_ADDR_VAR 0 2
56000: PUSH
56001: LD_VAR 0 3
56005: ST_TO_ADDR
// end ;
56006: LD_VAR 0 2
56010: RET
// export function ComExitAll ( units ) ; var i ; begin
56011: LD_INT 0
56013: PPUSH
56014: PPUSH
// if not units then
56015: LD_VAR 0 1
56019: NOT
56020: IFFALSE 56024
// exit ;
56022: GO 56050
// for i in units do
56024: LD_ADDR_VAR 0 3
56028: PUSH
56029: LD_VAR 0 1
56033: PUSH
56034: FOR_IN
56035: IFFALSE 56048
// ComExit ( i ) ;
56037: LD_VAR 0 3
56041: PPUSH
56042: CALL 55928 0 1
56046: GO 56034
56048: POP
56049: POP
// end ;
56050: LD_VAR 0 2
56054: RET
// export function ResetHc ; begin
56055: LD_INT 0
56057: PPUSH
// InitHc ;
56058: CALL_OW 19
// hc_importance := 0 ;
56062: LD_ADDR_OWVAR 32
56066: PUSH
56067: LD_INT 0
56069: ST_TO_ADDR
// end ;
56070: LD_VAR 0 1
56074: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56075: LD_INT 0
56077: PPUSH
56078: PPUSH
56079: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56080: LD_ADDR_VAR 0 6
56084: PUSH
56085: LD_VAR 0 1
56089: PUSH
56090: LD_VAR 0 3
56094: PLUS
56095: PUSH
56096: LD_INT 2
56098: DIV
56099: ST_TO_ADDR
// if _x < 0 then
56100: LD_VAR 0 6
56104: PUSH
56105: LD_INT 0
56107: LESS
56108: IFFALSE 56125
// _x := _x * - 1 ;
56110: LD_ADDR_VAR 0 6
56114: PUSH
56115: LD_VAR 0 6
56119: PUSH
56120: LD_INT 1
56122: NEG
56123: MUL
56124: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56125: LD_ADDR_VAR 0 7
56129: PUSH
56130: LD_VAR 0 2
56134: PUSH
56135: LD_VAR 0 4
56139: PLUS
56140: PUSH
56141: LD_INT 2
56143: DIV
56144: ST_TO_ADDR
// if _y < 0 then
56145: LD_VAR 0 7
56149: PUSH
56150: LD_INT 0
56152: LESS
56153: IFFALSE 56170
// _y := _y * - 1 ;
56155: LD_ADDR_VAR 0 7
56159: PUSH
56160: LD_VAR 0 7
56164: PUSH
56165: LD_INT 1
56167: NEG
56168: MUL
56169: ST_TO_ADDR
// result := [ _x , _y ] ;
56170: LD_ADDR_VAR 0 5
56174: PUSH
56175: LD_VAR 0 6
56179: PUSH
56180: LD_VAR 0 7
56184: PUSH
56185: EMPTY
56186: LIST
56187: LIST
56188: ST_TO_ADDR
// end ;
56189: LD_VAR 0 5
56193: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56194: LD_INT 0
56196: PPUSH
56197: PPUSH
56198: PPUSH
56199: PPUSH
// task := GetTaskList ( unit ) ;
56200: LD_ADDR_VAR 0 7
56204: PUSH
56205: LD_VAR 0 1
56209: PPUSH
56210: CALL_OW 437
56214: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56215: LD_VAR 0 7
56219: NOT
56220: IFFALSE 56239
56222: PUSH
56223: LD_VAR 0 1
56227: PPUSH
56228: LD_VAR 0 2
56232: PPUSH
56233: CALL_OW 308
56237: NOT
56238: AND
56239: IFFALSE 56243
// exit ;
56241: GO 56361
// if IsInArea ( unit , area ) then
56243: LD_VAR 0 1
56247: PPUSH
56248: LD_VAR 0 2
56252: PPUSH
56253: CALL_OW 308
56257: IFFALSE 56275
// begin ComMoveToArea ( unit , goAway ) ;
56259: LD_VAR 0 1
56263: PPUSH
56264: LD_VAR 0 3
56268: PPUSH
56269: CALL_OW 113
// exit ;
56273: GO 56361
// end ; if task [ 1 ] [ 1 ] <> M then
56275: LD_VAR 0 7
56279: PUSH
56280: LD_INT 1
56282: ARRAY
56283: PUSH
56284: LD_INT 1
56286: ARRAY
56287: PUSH
56288: LD_STRING M
56290: NONEQUAL
56291: IFFALSE 56295
// exit ;
56293: GO 56361
// x := task [ 1 ] [ 2 ] ;
56295: LD_ADDR_VAR 0 5
56299: PUSH
56300: LD_VAR 0 7
56304: PUSH
56305: LD_INT 1
56307: ARRAY
56308: PUSH
56309: LD_INT 2
56311: ARRAY
56312: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56313: LD_ADDR_VAR 0 6
56317: PUSH
56318: LD_VAR 0 7
56322: PUSH
56323: LD_INT 1
56325: ARRAY
56326: PUSH
56327: LD_INT 3
56329: ARRAY
56330: ST_TO_ADDR
// if InArea ( x , y , area ) then
56331: LD_VAR 0 5
56335: PPUSH
56336: LD_VAR 0 6
56340: PPUSH
56341: LD_VAR 0 2
56345: PPUSH
56346: CALL_OW 309
56350: IFFALSE 56361
// ComStop ( unit ) ;
56352: LD_VAR 0 1
56356: PPUSH
56357: CALL_OW 141
// end ;
56361: LD_VAR 0 4
56365: RET
// export function Abs ( value ) ; begin
56366: LD_INT 0
56368: PPUSH
// result := value ;
56369: LD_ADDR_VAR 0 2
56373: PUSH
56374: LD_VAR 0 1
56378: ST_TO_ADDR
// if value < 0 then
56379: LD_VAR 0 1
56383: PUSH
56384: LD_INT 0
56386: LESS
56387: IFFALSE 56404
// result := value * - 1 ;
56389: LD_ADDR_VAR 0 2
56393: PUSH
56394: LD_VAR 0 1
56398: PUSH
56399: LD_INT 1
56401: NEG
56402: MUL
56403: ST_TO_ADDR
// end ;
56404: LD_VAR 0 2
56408: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56409: LD_INT 0
56411: PPUSH
56412: PPUSH
56413: PPUSH
56414: PPUSH
56415: PPUSH
56416: PPUSH
56417: PPUSH
56418: PPUSH
// if not unit or not building then
56419: LD_VAR 0 1
56423: NOT
56424: IFTRUE 56433
56426: PUSH
56427: LD_VAR 0 2
56431: NOT
56432: OR
56433: IFFALSE 56437
// exit ;
56435: GO 56665
// x := GetX ( building ) ;
56437: LD_ADDR_VAR 0 4
56441: PUSH
56442: LD_VAR 0 2
56446: PPUSH
56447: CALL_OW 250
56451: ST_TO_ADDR
// y := GetY ( building ) ;
56452: LD_ADDR_VAR 0 6
56456: PUSH
56457: LD_VAR 0 2
56461: PPUSH
56462: CALL_OW 251
56466: ST_TO_ADDR
// d := GetDir ( building ) ;
56467: LD_ADDR_VAR 0 8
56471: PUSH
56472: LD_VAR 0 2
56476: PPUSH
56477: CALL_OW 254
56481: ST_TO_ADDR
// r := 4 ;
56482: LD_ADDR_VAR 0 9
56486: PUSH
56487: LD_INT 4
56489: ST_TO_ADDR
// for i := 1 to 5 do
56490: LD_ADDR_VAR 0 10
56494: PUSH
56495: DOUBLE
56496: LD_INT 1
56498: DEC
56499: ST_TO_ADDR
56500: LD_INT 5
56502: PUSH
56503: FOR_TO
56504: IFFALSE 56663
// begin _x := ShiftX ( x , d , r + i ) ;
56506: LD_ADDR_VAR 0 5
56510: PUSH
56511: LD_VAR 0 4
56515: PPUSH
56516: LD_VAR 0 8
56520: PPUSH
56521: LD_VAR 0 9
56525: PUSH
56526: LD_VAR 0 10
56530: PLUS
56531: PPUSH
56532: CALL_OW 272
56536: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56537: LD_ADDR_VAR 0 7
56541: PUSH
56542: LD_VAR 0 6
56546: PPUSH
56547: LD_VAR 0 8
56551: PPUSH
56552: LD_VAR 0 9
56556: PUSH
56557: LD_VAR 0 10
56561: PLUS
56562: PPUSH
56563: CALL_OW 273
56567: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56568: LD_VAR 0 5
56572: PPUSH
56573: LD_VAR 0 7
56577: PPUSH
56578: CALL_OW 488
56582: IFFALSE 56617
56584: PUSH
56585: LD_VAR 0 5
56589: PPUSH
56590: LD_VAR 0 7
56594: PPUSH
56595: CALL_OW 428
56599: PPUSH
56600: CALL_OW 247
56604: PUSH
56605: LD_INT 3
56607: PUSH
56608: LD_INT 2
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: IN
56615: NOT
56616: AND
56617: IFFALSE 56661
// begin ComMoveXY ( unit , _x , _y ) ;
56619: LD_VAR 0 1
56623: PPUSH
56624: LD_VAR 0 5
56628: PPUSH
56629: LD_VAR 0 7
56633: PPUSH
56634: CALL_OW 111
// result := [ _x , _y ] ;
56638: LD_ADDR_VAR 0 3
56642: PUSH
56643: LD_VAR 0 5
56647: PUSH
56648: LD_VAR 0 7
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: ST_TO_ADDR
// exit ;
56657: POP
56658: POP
56659: GO 56665
// end ; end ;
56661: GO 56503
56663: POP
56664: POP
// end ;
56665: LD_VAR 0 3
56669: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56670: LD_INT 0
56672: PPUSH
56673: PPUSH
56674: PPUSH
// result := 0 ;
56675: LD_ADDR_VAR 0 3
56679: PUSH
56680: LD_INT 0
56682: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56683: LD_VAR 0 1
56687: PUSH
56688: LD_INT 0
56690: LESS
56691: IFTRUE 56703
56693: PUSH
56694: LD_VAR 0 1
56698: PUSH
56699: LD_INT 8
56701: GREATER
56702: OR
56703: IFTRUE 56715
56705: PUSH
56706: LD_VAR 0 2
56710: PUSH
56711: LD_INT 0
56713: LESS
56714: OR
56715: IFTRUE 56727
56717: PUSH
56718: LD_VAR 0 2
56722: PUSH
56723: LD_INT 8
56725: GREATER
56726: OR
56727: IFFALSE 56731
// exit ;
56729: GO 56806
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56731: LD_ADDR_VAR 0 4
56735: PUSH
56736: LD_INT 22
56738: PUSH
56739: LD_VAR 0 2
56743: PUSH
56744: EMPTY
56745: LIST
56746: LIST
56747: PPUSH
56748: CALL_OW 69
56752: PUSH
56753: FOR_IN
56754: IFFALSE 56804
// begin un := UnitShoot ( i ) ;
56756: LD_ADDR_VAR 0 5
56760: PUSH
56761: LD_VAR 0 4
56765: PPUSH
56766: CALL_OW 504
56770: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56771: LD_VAR 0 5
56775: PPUSH
56776: CALL_OW 255
56780: PUSH
56781: LD_VAR 0 1
56785: EQUAL
56786: IFFALSE 56802
// begin result := un ;
56788: LD_ADDR_VAR 0 3
56792: PUSH
56793: LD_VAR 0 5
56797: ST_TO_ADDR
// exit ;
56798: POP
56799: POP
56800: GO 56806
// end ; end ;
56802: GO 56753
56804: POP
56805: POP
// end ;
56806: LD_VAR 0 3
56810: RET
// export function GetCargoBay ( units ) ; begin
56811: LD_INT 0
56813: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56814: LD_ADDR_VAR 0 2
56818: PUSH
56819: LD_VAR 0 1
56823: PPUSH
56824: LD_INT 2
56826: PUSH
56827: LD_INT 34
56829: PUSH
56830: LD_INT 12
56832: PUSH
56833: EMPTY
56834: LIST
56835: LIST
56836: PUSH
56837: LD_INT 34
56839: PUSH
56840: LD_INT 51
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: PUSH
56847: LD_INT 34
56849: PUSH
56850: LD_INT 32
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: PUSH
56857: LD_INT 34
56859: PUSH
56860: LD_INT 89
56862: PUSH
56863: EMPTY
56864: LIST
56865: LIST
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: LIST
56871: LIST
56872: LIST
56873: PPUSH
56874: CALL_OW 72
56878: ST_TO_ADDR
// end ;
56879: LD_VAR 0 2
56883: RET
// export function Negate ( value ) ; begin
56884: LD_INT 0
56886: PPUSH
// result := not value ;
56887: LD_ADDR_VAR 0 2
56891: PUSH
56892: LD_VAR 0 1
56896: NOT
56897: ST_TO_ADDR
// end ;
56898: LD_VAR 0 2
56902: RET
// export function Inc ( value ) ; begin
56903: LD_INT 0
56905: PPUSH
// result := value + 1 ;
56906: LD_ADDR_VAR 0 2
56910: PUSH
56911: LD_VAR 0 1
56915: PUSH
56916: LD_INT 1
56918: PLUS
56919: ST_TO_ADDR
// end ;
56920: LD_VAR 0 2
56924: RET
// export function Dec ( value ) ; begin
56925: LD_INT 0
56927: PPUSH
// result := value - 1 ;
56928: LD_ADDR_VAR 0 2
56932: PUSH
56933: LD_VAR 0 1
56937: PUSH
56938: LD_INT 1
56940: MINUS
56941: ST_TO_ADDR
// end ;
56942: LD_VAR 0 2
56946: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
56947: LD_INT 0
56949: PPUSH
56950: PPUSH
56951: PPUSH
56952: PPUSH
56953: PPUSH
56954: PPUSH
56955: PPUSH
56956: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
56957: LD_VAR 0 1
56961: PPUSH
56962: LD_VAR 0 2
56966: PPUSH
56967: CALL_OW 488
56971: NOT
56972: IFTRUE 56991
56974: PUSH
56975: LD_VAR 0 3
56979: PPUSH
56980: LD_VAR 0 4
56984: PPUSH
56985: CALL_OW 488
56989: NOT
56990: OR
56991: IFFALSE 57004
// begin result := - 1 ;
56993: LD_ADDR_VAR 0 5
56997: PUSH
56998: LD_INT 1
57000: NEG
57001: ST_TO_ADDR
// exit ;
57002: GO 57239
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
57004: LD_ADDR_VAR 0 12
57008: PUSH
57009: LD_VAR 0 1
57013: PPUSH
57014: LD_VAR 0 2
57018: PPUSH
57019: LD_VAR 0 3
57023: PPUSH
57024: LD_VAR 0 4
57028: PPUSH
57029: CALL 56075 0 4
57033: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
57034: LD_ADDR_VAR 0 11
57038: PUSH
57039: LD_VAR 0 1
57043: PPUSH
57044: LD_VAR 0 2
57048: PPUSH
57049: LD_VAR 0 12
57053: PUSH
57054: LD_INT 1
57056: ARRAY
57057: PPUSH
57058: LD_VAR 0 12
57062: PUSH
57063: LD_INT 2
57065: ARRAY
57066: PPUSH
57067: CALL_OW 298
57071: ST_TO_ADDR
// distance := 9999 ;
57072: LD_ADDR_VAR 0 10
57076: PUSH
57077: LD_INT 9999
57079: ST_TO_ADDR
// for i := 0 to 5 do
57080: LD_ADDR_VAR 0 6
57084: PUSH
57085: DOUBLE
57086: LD_INT 0
57088: DEC
57089: ST_TO_ADDR
57090: LD_INT 5
57092: PUSH
57093: FOR_TO
57094: IFFALSE 57237
// begin _x := ShiftX ( x1 , i , centerDist ) ;
57096: LD_ADDR_VAR 0 7
57100: PUSH
57101: LD_VAR 0 1
57105: PPUSH
57106: LD_VAR 0 6
57110: PPUSH
57111: LD_VAR 0 11
57115: PPUSH
57116: CALL_OW 272
57120: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
57121: LD_ADDR_VAR 0 8
57125: PUSH
57126: LD_VAR 0 2
57130: PPUSH
57131: LD_VAR 0 6
57135: PPUSH
57136: LD_VAR 0 11
57140: PPUSH
57141: CALL_OW 273
57145: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
57146: LD_VAR 0 7
57150: PPUSH
57151: LD_VAR 0 8
57155: PPUSH
57156: CALL_OW 488
57160: NOT
57161: IFFALSE 57165
// continue ;
57163: GO 57093
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
57165: LD_ADDR_VAR 0 9
57169: PUSH
57170: LD_VAR 0 12
57174: PUSH
57175: LD_INT 1
57177: ARRAY
57178: PPUSH
57179: LD_VAR 0 12
57183: PUSH
57184: LD_INT 2
57186: ARRAY
57187: PPUSH
57188: LD_VAR 0 7
57192: PPUSH
57193: LD_VAR 0 8
57197: PPUSH
57198: CALL_OW 298
57202: ST_TO_ADDR
// if tmp < distance then
57203: LD_VAR 0 9
57207: PUSH
57208: LD_VAR 0 10
57212: LESS
57213: IFFALSE 57235
// begin result := i ;
57215: LD_ADDR_VAR 0 5
57219: PUSH
57220: LD_VAR 0 6
57224: ST_TO_ADDR
// distance := tmp ;
57225: LD_ADDR_VAR 0 10
57229: PUSH
57230: LD_VAR 0 9
57234: ST_TO_ADDR
// end ; end ;
57235: GO 57093
57237: POP
57238: POP
// end ;
57239: LD_VAR 0 5
57243: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57244: LD_INT 0
57246: PPUSH
57247: PPUSH
// if not driver or not IsInUnit ( driver ) then
57248: LD_VAR 0 1
57252: NOT
57253: IFTRUE 57267
57255: PUSH
57256: LD_VAR 0 1
57260: PPUSH
57261: CALL_OW 310
57265: NOT
57266: OR
57267: IFFALSE 57271
// exit ;
57269: GO 57361
// vehicle := IsInUnit ( driver ) ;
57271: LD_ADDR_VAR 0 3
57275: PUSH
57276: LD_VAR 0 1
57280: PPUSH
57281: CALL_OW 310
57285: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57286: LD_VAR 0 1
57290: PPUSH
57291: LD_STRING \
57293: PUSH
57294: LD_INT 0
57296: PUSH
57297: LD_INT 0
57299: PUSH
57300: LD_INT 0
57302: PUSH
57303: LD_INT 0
57305: PUSH
57306: LD_INT 0
57308: PUSH
57309: LD_INT 0
57311: PUSH
57312: EMPTY
57313: LIST
57314: LIST
57315: LIST
57316: LIST
57317: LIST
57318: LIST
57319: LIST
57320: PUSH
57321: LD_STRING E
57323: PUSH
57324: LD_INT 0
57326: PUSH
57327: LD_INT 0
57329: PUSH
57330: LD_VAR 0 3
57334: PUSH
57335: LD_INT 0
57337: PUSH
57338: LD_INT 0
57340: PUSH
57341: LD_INT 0
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: LIST
57348: LIST
57349: LIST
57350: LIST
57351: LIST
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PPUSH
57357: CALL_OW 446
// end ;
57361: LD_VAR 0 2
57365: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57366: LD_INT 0
57368: PPUSH
57369: PPUSH
// if not driver or not IsInUnit ( driver ) then
57370: LD_VAR 0 1
57374: NOT
57375: IFTRUE 57389
57377: PUSH
57378: LD_VAR 0 1
57382: PPUSH
57383: CALL_OW 310
57387: NOT
57388: OR
57389: IFFALSE 57393
// exit ;
57391: GO 57483
// vehicle := IsInUnit ( driver ) ;
57393: LD_ADDR_VAR 0 3
57397: PUSH
57398: LD_VAR 0 1
57402: PPUSH
57403: CALL_OW 310
57407: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57408: LD_VAR 0 1
57412: PPUSH
57413: LD_STRING \
57415: PUSH
57416: LD_INT 0
57418: PUSH
57419: LD_INT 0
57421: PUSH
57422: LD_INT 0
57424: PUSH
57425: LD_INT 0
57427: PUSH
57428: LD_INT 0
57430: PUSH
57431: LD_INT 0
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: LIST
57438: LIST
57439: LIST
57440: LIST
57441: LIST
57442: PUSH
57443: LD_STRING E
57445: PUSH
57446: LD_INT 0
57448: PUSH
57449: LD_INT 0
57451: PUSH
57452: LD_VAR 0 3
57456: PUSH
57457: LD_INT 0
57459: PUSH
57460: LD_INT 0
57462: PUSH
57463: LD_INT 0
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: PUSH
57475: EMPTY
57476: LIST
57477: LIST
57478: PPUSH
57479: CALL_OW 447
// end ;
57483: LD_VAR 0 2
57487: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57488: LD_INT 0
57490: PPUSH
57491: PPUSH
57492: PPUSH
// tmp := [ ] ;
57493: LD_ADDR_VAR 0 5
57497: PUSH
57498: EMPTY
57499: ST_TO_ADDR
// for i in units do
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_VAR 0 1
57509: PUSH
57510: FOR_IN
57511: IFFALSE 57549
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57513: LD_ADDR_VAR 0 5
57517: PUSH
57518: LD_VAR 0 5
57522: PPUSH
57523: LD_VAR 0 5
57527: PUSH
57528: LD_INT 1
57530: PLUS
57531: PPUSH
57532: LD_VAR 0 4
57536: PPUSH
57537: CALL_OW 256
57541: PPUSH
57542: CALL_OW 2
57546: ST_TO_ADDR
57547: GO 57510
57549: POP
57550: POP
// if not tmp then
57551: LD_VAR 0 5
57555: NOT
57556: IFFALSE 57560
// exit ;
57558: GO 57608
// if asc then
57560: LD_VAR 0 2
57564: IFFALSE 57588
// result := SortListByListAsc ( units , tmp ) else
57566: LD_ADDR_VAR 0 3
57570: PUSH
57571: LD_VAR 0 1
57575: PPUSH
57576: LD_VAR 0 5
57580: PPUSH
57581: CALL_OW 76
57585: ST_TO_ADDR
57586: GO 57608
// result := SortListByListDesc ( units , tmp ) ;
57588: LD_ADDR_VAR 0 3
57592: PUSH
57593: LD_VAR 0 1
57597: PPUSH
57598: LD_VAR 0 5
57602: PPUSH
57603: CALL_OW 77
57607: ST_TO_ADDR
// end ;
57608: LD_VAR 0 3
57612: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57613: LD_INT 0
57615: PPUSH
57616: PPUSH
// task := GetTaskList ( mech ) ;
57617: LD_ADDR_VAR 0 4
57621: PUSH
57622: LD_VAR 0 1
57626: PPUSH
57627: CALL_OW 437
57631: ST_TO_ADDR
// if not task then
57632: LD_VAR 0 4
57636: NOT
57637: IFFALSE 57641
// exit ;
57639: GO 57685
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57641: LD_ADDR_VAR 0 3
57645: PUSH
57646: LD_VAR 0 4
57650: PUSH
57651: LD_INT 1
57653: ARRAY
57654: PUSH
57655: LD_INT 1
57657: ARRAY
57658: PUSH
57659: LD_STRING r
57661: EQUAL
57662: IFFALSE 57684
57664: PUSH
57665: LD_VAR 0 4
57669: PUSH
57670: LD_INT 1
57672: ARRAY
57673: PUSH
57674: LD_INT 4
57676: ARRAY
57677: PUSH
57678: LD_VAR 0 2
57682: EQUAL
57683: AND
57684: ST_TO_ADDR
// end ;
57685: LD_VAR 0 3
57689: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57690: LD_INT 0
57692: PPUSH
// SetDir ( unit , d ) ;
57693: LD_VAR 0 1
57697: PPUSH
57698: LD_VAR 0 4
57702: PPUSH
57703: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
57707: LD_ADDR_VAR 0 6
57711: PUSH
57712: LD_VAR 0 1
57716: PPUSH
57717: LD_VAR 0 2
57721: PPUSH
57722: LD_VAR 0 3
57726: PPUSH
57727: LD_VAR 0 5
57731: PPUSH
57732: CALL_OW 48
57736: ST_TO_ADDR
// end ;
57737: LD_VAR 0 6
57741: RET
// export function ToNaturalNumber ( number ) ; begin
57742: LD_INT 0
57744: PPUSH
// result := number div 1 ;
57745: LD_ADDR_VAR 0 2
57749: PUSH
57750: LD_VAR 0 1
57754: PUSH
57755: LD_INT 1
57757: DIV
57758: ST_TO_ADDR
// if number < 0 then
57759: LD_VAR 0 1
57763: PUSH
57764: LD_INT 0
57766: LESS
57767: IFFALSE 57777
// result := 0 ;
57769: LD_ADDR_VAR 0 2
57773: PUSH
57774: LD_INT 0
57776: ST_TO_ADDR
// end ;
57777: LD_VAR 0 2
57781: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
57782: LD_INT 0
57784: PPUSH
57785: PPUSH
57786: PPUSH
// if not buildings then
57787: LD_VAR 0 1
57791: NOT
57792: IFFALSE 57796
// exit ;
57794: GO 57911
// tmp := [ ] ;
57796: LD_ADDR_VAR 0 5
57800: PUSH
57801: EMPTY
57802: ST_TO_ADDR
// for b in buildings do
57803: LD_ADDR_VAR 0 4
57807: PUSH
57808: LD_VAR 0 1
57812: PUSH
57813: FOR_IN
57814: IFFALSE 57852
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
57816: LD_ADDR_VAR 0 5
57820: PUSH
57821: LD_VAR 0 5
57825: PPUSH
57826: LD_VAR 0 5
57830: PUSH
57831: LD_INT 1
57833: PLUS
57834: PPUSH
57835: LD_VAR 0 4
57839: PPUSH
57840: CALL_OW 266
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
57850: GO 57813
57852: POP
57853: POP
// if not tmp then
57854: LD_VAR 0 5
57858: NOT
57859: IFFALSE 57863
// exit ;
57861: GO 57911
// if asc then
57863: LD_VAR 0 2
57867: IFFALSE 57891
// result := SortListByListAsc ( buildings , tmp ) else
57869: LD_ADDR_VAR 0 3
57873: PUSH
57874: LD_VAR 0 1
57878: PPUSH
57879: LD_VAR 0 5
57883: PPUSH
57884: CALL_OW 76
57888: ST_TO_ADDR
57889: GO 57911
// result := SortListByListDesc ( buildings , tmp ) ;
57891: LD_ADDR_VAR 0 3
57895: PUSH
57896: LD_VAR 0 1
57900: PPUSH
57901: LD_VAR 0 5
57905: PPUSH
57906: CALL_OW 77
57910: ST_TO_ADDR
// end ;
57911: LD_VAR 0 3
57915: RET
// export function SortByClass ( units , class ) ; var un ; begin
57916: LD_INT 0
57918: PPUSH
57919: PPUSH
// if not units or not class then
57920: LD_VAR 0 1
57924: NOT
57925: IFTRUE 57934
57927: PUSH
57928: LD_VAR 0 2
57932: NOT
57933: OR
57934: IFFALSE 57938
// exit ;
57936: GO 58033
// result := [ ] ;
57938: LD_ADDR_VAR 0 3
57942: PUSH
57943: EMPTY
57944: ST_TO_ADDR
// for un in units do
57945: LD_ADDR_VAR 0 4
57949: PUSH
57950: LD_VAR 0 1
57954: PUSH
57955: FOR_IN
57956: IFFALSE 58031
// if GetClass ( un ) = class then
57958: LD_VAR 0 4
57962: PPUSH
57963: CALL_OW 257
57967: PUSH
57968: LD_VAR 0 2
57972: EQUAL
57973: IFFALSE 58000
// result := Insert ( result , 1 , un ) else
57975: LD_ADDR_VAR 0 3
57979: PUSH
57980: LD_VAR 0 3
57984: PPUSH
57985: LD_INT 1
57987: PPUSH
57988: LD_VAR 0 4
57992: PPUSH
57993: CALL_OW 2
57997: ST_TO_ADDR
57998: GO 58029
// result := Replace ( result , result + 1 , un ) ;
58000: LD_ADDR_VAR 0 3
58004: PUSH
58005: LD_VAR 0 3
58009: PPUSH
58010: LD_VAR 0 3
58014: PUSH
58015: LD_INT 1
58017: PLUS
58018: PPUSH
58019: LD_VAR 0 4
58023: PPUSH
58024: CALL_OW 1
58028: ST_TO_ADDR
58029: GO 57955
58031: POP
58032: POP
// end ;
58033: LD_VAR 0 3
58037: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58038: LD_INT 0
58040: PPUSH
58041: PPUSH
58042: PPUSH
58043: PPUSH
58044: PPUSH
58045: PPUSH
58046: PPUSH
// result := [ ] ;
58047: LD_ADDR_VAR 0 4
58051: PUSH
58052: EMPTY
58053: ST_TO_ADDR
// if x - r < 0 then
58054: LD_VAR 0 1
58058: PUSH
58059: LD_VAR 0 3
58063: MINUS
58064: PUSH
58065: LD_INT 0
58067: LESS
58068: IFFALSE 58080
// min_x := 0 else
58070: LD_ADDR_VAR 0 8
58074: PUSH
58075: LD_INT 0
58077: ST_TO_ADDR
58078: GO 58096
// min_x := x - r ;
58080: LD_ADDR_VAR 0 8
58084: PUSH
58085: LD_VAR 0 1
58089: PUSH
58090: LD_VAR 0 3
58094: MINUS
58095: ST_TO_ADDR
// if y - r < 0 then
58096: LD_VAR 0 2
58100: PUSH
58101: LD_VAR 0 3
58105: MINUS
58106: PUSH
58107: LD_INT 0
58109: LESS
58110: IFFALSE 58122
// min_y := 0 else
58112: LD_ADDR_VAR 0 7
58116: PUSH
58117: LD_INT 0
58119: ST_TO_ADDR
58120: GO 58138
// min_y := y - r ;
58122: LD_ADDR_VAR 0 7
58126: PUSH
58127: LD_VAR 0 2
58131: PUSH
58132: LD_VAR 0 3
58136: MINUS
58137: ST_TO_ADDR
// max_x := x + r ;
58138: LD_ADDR_VAR 0 9
58142: PUSH
58143: LD_VAR 0 1
58147: PUSH
58148: LD_VAR 0 3
58152: PLUS
58153: ST_TO_ADDR
// max_y := y + r ;
58154: LD_ADDR_VAR 0 10
58158: PUSH
58159: LD_VAR 0 2
58163: PUSH
58164: LD_VAR 0 3
58168: PLUS
58169: ST_TO_ADDR
// for _x = min_x to max_x do
58170: LD_ADDR_VAR 0 5
58174: PUSH
58175: DOUBLE
58176: LD_VAR 0 8
58180: DEC
58181: ST_TO_ADDR
58182: LD_VAR 0 9
58186: PUSH
58187: FOR_TO
58188: IFFALSE 58289
// for _y = min_y to max_y do
58190: LD_ADDR_VAR 0 6
58194: PUSH
58195: DOUBLE
58196: LD_VAR 0 7
58200: DEC
58201: ST_TO_ADDR
58202: LD_VAR 0 10
58206: PUSH
58207: FOR_TO
58208: IFFALSE 58285
// begin if not ValidHex ( _x , _y ) then
58210: LD_VAR 0 5
58214: PPUSH
58215: LD_VAR 0 6
58219: PPUSH
58220: CALL_OW 488
58224: NOT
58225: IFFALSE 58229
// continue ;
58227: GO 58207
// if GetResourceTypeXY ( _x , _y ) then
58229: LD_VAR 0 5
58233: PPUSH
58234: LD_VAR 0 6
58238: PPUSH
58239: CALL_OW 283
58243: IFFALSE 58283
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58245: LD_ADDR_VAR 0 4
58249: PUSH
58250: LD_VAR 0 4
58254: PPUSH
58255: LD_VAR 0 4
58259: PUSH
58260: LD_INT 1
58262: PLUS
58263: PPUSH
58264: LD_VAR 0 5
58268: PUSH
58269: LD_VAR 0 6
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PPUSH
58278: CALL_OW 1
58282: ST_TO_ADDR
// end ;
58283: GO 58207
58285: POP
58286: POP
58287: GO 58187
58289: POP
58290: POP
// end ;
58291: LD_VAR 0 4
58295: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
58296: LD_INT 0
58298: PPUSH
58299: PPUSH
58300: PPUSH
58301: PPUSH
58302: PPUSH
58303: PPUSH
58304: PPUSH
58305: PPUSH
// if not units then
58306: LD_VAR 0 1
58310: NOT
58311: IFFALSE 58315
// exit ;
58313: GO 58847
// result := UnitFilter ( units , [ f_ok ] ) ;
58315: LD_ADDR_VAR 0 3
58319: PUSH
58320: LD_VAR 0 1
58324: PPUSH
58325: LD_INT 50
58327: PUSH
58328: EMPTY
58329: LIST
58330: PPUSH
58331: CALL_OW 72
58335: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58336: LD_ADDR_VAR 0 8
58340: PUSH
58341: LD_VAR 0 1
58345: PUSH
58346: LD_INT 1
58348: ARRAY
58349: PPUSH
58350: CALL_OW 255
58354: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
58355: LD_ADDR_VAR 0 10
58359: PUSH
58360: LD_INT 29
58362: PUSH
58363: LD_INT 91
58365: PUSH
58366: LD_INT 49
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: LIST
58373: ST_TO_ADDR
// if not result then
58374: LD_VAR 0 3
58378: NOT
58379: IFFALSE 58383
// exit ;
58381: GO 58847
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58383: LD_ADDR_VAR 0 5
58387: PUSH
58388: LD_INT 81
58390: PUSH
58391: LD_VAR 0 8
58395: PUSH
58396: EMPTY
58397: LIST
58398: LIST
58399: PPUSH
58400: CALL_OW 69
58404: ST_TO_ADDR
// for i in result do
58405: LD_ADDR_VAR 0 4
58409: PUSH
58410: LD_VAR 0 3
58414: PUSH
58415: FOR_IN
58416: IFFALSE 58845
// begin tag := GetTag ( i ) + 1 ;
58418: LD_ADDR_VAR 0 9
58422: PUSH
58423: LD_VAR 0 4
58427: PPUSH
58428: CALL_OW 110
58432: PUSH
58433: LD_INT 1
58435: PLUS
58436: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
58437: LD_ADDR_VAR 0 7
58441: PUSH
58442: LD_VAR 0 4
58446: PPUSH
58447: CALL_OW 250
58451: PPUSH
58452: LD_VAR 0 4
58456: PPUSH
58457: CALL_OW 251
58461: PPUSH
58462: LD_INT 4
58464: PPUSH
58465: CALL 58038 0 3
58469: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
58470: LD_VAR 0 4
58474: PPUSH
58475: CALL_OW 247
58479: PUSH
58480: LD_INT 2
58482: EQUAL
58483: IFFALSE 58495
58485: PUSH
58486: LD_VAR 0 7
58490: PUSH
58491: LD_INT 2
58493: GREATER
58494: AND
58495: IFFALSE 58515
58497: PUSH
58498: LD_VAR 0 4
58502: PPUSH
58503: CALL_OW 264
58507: PUSH
58508: LD_VAR 0 10
58512: IN
58513: NOT
58514: AND
58515: IFFALSE 58554
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58517: LD_VAR 0 4
58521: PPUSH
58522: LD_VAR 0 7
58526: PUSH
58527: LD_INT 1
58529: ARRAY
58530: PUSH
58531: LD_INT 1
58533: ARRAY
58534: PPUSH
58535: LD_VAR 0 7
58539: PUSH
58540: LD_INT 1
58542: ARRAY
58543: PUSH
58544: LD_INT 2
58546: ARRAY
58547: PPUSH
58548: CALL_OW 116
58552: GO 58843
// if path > tag then
58554: LD_VAR 0 2
58558: PUSH
58559: LD_VAR 0 9
58563: GREATER
58564: IFFALSE 58772
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
58566: LD_ADDR_VAR 0 6
58570: PUSH
58571: LD_VAR 0 5
58575: PPUSH
58576: LD_INT 91
58578: PUSH
58579: LD_VAR 0 4
58583: PUSH
58584: LD_INT 8
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: LIST
58591: PPUSH
58592: CALL_OW 72
58596: ST_TO_ADDR
// if nearEnemy then
58597: LD_VAR 0 6
58601: IFFALSE 58670
// begin if GetWeapon ( i ) = ru_time_lapser then
58603: LD_VAR 0 4
58607: PPUSH
58608: CALL_OW 264
58612: PUSH
58613: LD_INT 49
58615: EQUAL
58616: IFFALSE 58644
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
58618: LD_VAR 0 4
58622: PPUSH
58623: LD_VAR 0 6
58627: PPUSH
58628: LD_VAR 0 4
58632: PPUSH
58633: CALL_OW 74
58637: PPUSH
58638: CALL_OW 112
58642: GO 58668
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
58644: LD_VAR 0 4
58648: PPUSH
58649: LD_VAR 0 6
58653: PPUSH
58654: LD_VAR 0 4
58658: PPUSH
58659: CALL_OW 74
58663: PPUSH
58664: CALL 59928 0 2
// end else
58668: GO 58770
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58670: LD_VAR 0 4
58674: PPUSH
58675: LD_VAR 0 2
58679: PUSH
58680: LD_VAR 0 9
58684: ARRAY
58685: PUSH
58686: LD_INT 1
58688: ARRAY
58689: PPUSH
58690: LD_VAR 0 2
58694: PUSH
58695: LD_VAR 0 9
58699: ARRAY
58700: PUSH
58701: LD_INT 2
58703: ARRAY
58704: PPUSH
58705: CALL_OW 297
58709: PUSH
58710: LD_INT 6
58712: GREATER
58713: IFFALSE 58756
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58715: LD_VAR 0 4
58719: PPUSH
58720: LD_VAR 0 2
58724: PUSH
58725: LD_VAR 0 9
58729: ARRAY
58730: PUSH
58731: LD_INT 1
58733: ARRAY
58734: PPUSH
58735: LD_VAR 0 2
58739: PUSH
58740: LD_VAR 0 9
58744: ARRAY
58745: PUSH
58746: LD_INT 2
58748: ARRAY
58749: PPUSH
58750: CALL_OW 114
58754: GO 58770
// SetTag ( i , tag ) ;
58756: LD_VAR 0 4
58760: PPUSH
58761: LD_VAR 0 9
58765: PPUSH
58766: CALL_OW 109
// end else
58770: GO 58843
// if enemy then
58772: LD_VAR 0 5
58776: IFFALSE 58843
// begin if GetWeapon ( i ) = ru_time_lapser then
58778: LD_VAR 0 4
58782: PPUSH
58783: CALL_OW 264
58787: PUSH
58788: LD_INT 49
58790: EQUAL
58791: IFFALSE 58819
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58793: LD_VAR 0 4
58797: PPUSH
58798: LD_VAR 0 5
58802: PPUSH
58803: LD_VAR 0 4
58807: PPUSH
58808: CALL_OW 74
58812: PPUSH
58813: CALL_OW 112
58817: GO 58843
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58819: LD_VAR 0 4
58823: PPUSH
58824: LD_VAR 0 5
58828: PPUSH
58829: LD_VAR 0 4
58833: PPUSH
58834: CALL_OW 74
58838: PPUSH
58839: CALL 59928 0 2
// end ; end ;
58843: GO 58415
58845: POP
58846: POP
// end ;
58847: LD_VAR 0 3
58851: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58852: LD_INT 0
58854: PPUSH
58855: PPUSH
58856: PPUSH
// if not unit or IsInUnit ( unit ) then
58857: LD_VAR 0 1
58861: NOT
58862: IFTRUE 58875
58864: PUSH
58865: LD_VAR 0 1
58869: PPUSH
58870: CALL_OW 310
58874: OR
58875: IFFALSE 58879
// exit ;
58877: GO 58970
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58879: LD_ADDR_VAR 0 4
58883: PUSH
58884: LD_VAR 0 1
58888: PPUSH
58889: CALL_OW 250
58893: PPUSH
58894: LD_VAR 0 2
58898: PPUSH
58899: LD_INT 1
58901: PPUSH
58902: CALL_OW 272
58906: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58907: LD_ADDR_VAR 0 5
58911: PUSH
58912: LD_VAR 0 1
58916: PPUSH
58917: CALL_OW 251
58921: PPUSH
58922: LD_VAR 0 2
58926: PPUSH
58927: LD_INT 1
58929: PPUSH
58930: CALL_OW 273
58934: ST_TO_ADDR
// if ValidHex ( x , y ) then
58935: LD_VAR 0 4
58939: PPUSH
58940: LD_VAR 0 5
58944: PPUSH
58945: CALL_OW 488
58949: IFFALSE 58970
// ComTurnXY ( unit , x , y ) ;
58951: LD_VAR 0 1
58955: PPUSH
58956: LD_VAR 0 4
58960: PPUSH
58961: LD_VAR 0 5
58965: PPUSH
58966: CALL_OW 118
// end ;
58970: LD_VAR 0 3
58974: RET
// export function SeeUnits ( side , units ) ; var i ; begin
58975: LD_INT 0
58977: PPUSH
58978: PPUSH
// result := false ;
58979: LD_ADDR_VAR 0 3
58983: PUSH
58984: LD_INT 0
58986: ST_TO_ADDR
// if not units then
58987: LD_VAR 0 2
58991: NOT
58992: IFFALSE 58996
// exit ;
58994: GO 59041
// for i in units do
58996: LD_ADDR_VAR 0 4
59000: PUSH
59001: LD_VAR 0 2
59005: PUSH
59006: FOR_IN
59007: IFFALSE 59039
// if See ( side , i ) then
59009: LD_VAR 0 1
59013: PPUSH
59014: LD_VAR 0 4
59018: PPUSH
59019: CALL_OW 292
59023: IFFALSE 59037
// begin result := true ;
59025: LD_ADDR_VAR 0 3
59029: PUSH
59030: LD_INT 1
59032: ST_TO_ADDR
// exit ;
59033: POP
59034: POP
59035: GO 59041
// end ;
59037: GO 59006
59039: POP
59040: POP
// end ;
59041: LD_VAR 0 3
59045: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59046: LD_INT 0
59048: PPUSH
59049: PPUSH
59050: PPUSH
59051: PPUSH
// if not unit or not points then
59052: LD_VAR 0 1
59056: NOT
59057: IFTRUE 59066
59059: PUSH
59060: LD_VAR 0 2
59064: NOT
59065: OR
59066: IFFALSE 59070
// exit ;
59068: GO 59160
// dist := 99999 ;
59070: LD_ADDR_VAR 0 5
59074: PUSH
59075: LD_INT 99999
59077: ST_TO_ADDR
// for i in points do
59078: LD_ADDR_VAR 0 4
59082: PUSH
59083: LD_VAR 0 2
59087: PUSH
59088: FOR_IN
59089: IFFALSE 59158
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59091: LD_ADDR_VAR 0 6
59095: PUSH
59096: LD_VAR 0 1
59100: PPUSH
59101: LD_VAR 0 4
59105: PUSH
59106: LD_INT 1
59108: ARRAY
59109: PPUSH
59110: LD_VAR 0 4
59114: PUSH
59115: LD_INT 2
59117: ARRAY
59118: PPUSH
59119: CALL_OW 297
59123: ST_TO_ADDR
// if tmpDist < dist then
59124: LD_VAR 0 6
59128: PUSH
59129: LD_VAR 0 5
59133: LESS
59134: IFFALSE 59156
// begin result := i ;
59136: LD_ADDR_VAR 0 3
59140: PUSH
59141: LD_VAR 0 4
59145: ST_TO_ADDR
// dist := tmpDist ;
59146: LD_ADDR_VAR 0 5
59150: PUSH
59151: LD_VAR 0 6
59155: ST_TO_ADDR
// end ; end ;
59156: GO 59088
59158: POP
59159: POP
// end ;
59160: LD_VAR 0 3
59164: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
59165: LD_INT 0
59167: PPUSH
// uc_side := side ;
59168: LD_ADDR_OWVAR 20
59172: PUSH
59173: LD_VAR 0 1
59177: ST_TO_ADDR
// uc_nation := 3 ;
59178: LD_ADDR_OWVAR 21
59182: PUSH
59183: LD_INT 3
59185: ST_TO_ADDR
// vc_chassis := 25 ;
59186: LD_ADDR_OWVAR 37
59190: PUSH
59191: LD_INT 25
59193: ST_TO_ADDR
// vc_engine := engine_siberite ;
59194: LD_ADDR_OWVAR 39
59198: PUSH
59199: LD_INT 3
59201: ST_TO_ADDR
// vc_control := control_computer ;
59202: LD_ADDR_OWVAR 38
59206: PUSH
59207: LD_INT 3
59209: ST_TO_ADDR
// vc_weapon := 59 ;
59210: LD_ADDR_OWVAR 40
59214: PUSH
59215: LD_INT 59
59217: ST_TO_ADDR
// result := CreateVehicle ;
59218: LD_ADDR_VAR 0 5
59222: PUSH
59223: CALL_OW 45
59227: ST_TO_ADDR
// SetDir ( result , d ) ;
59228: LD_VAR 0 5
59232: PPUSH
59233: LD_VAR 0 4
59237: PPUSH
59238: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
59242: LD_VAR 0 5
59246: PPUSH
59247: LD_VAR 0 2
59251: PPUSH
59252: LD_VAR 0 3
59256: PPUSH
59257: LD_INT 0
59259: PPUSH
59260: CALL_OW 48
// end ;
59264: LD_VAR 0 5
59268: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
59269: LD_INT 0
59271: PPUSH
59272: PPUSH
59273: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59274: LD_ADDR_VAR 0 2
59278: PUSH
59279: LD_INT 0
59281: PUSH
59282: LD_INT 0
59284: PUSH
59285: LD_INT 0
59287: PUSH
59288: LD_INT 0
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: LIST
59295: LIST
59296: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
59297: LD_VAR 0 1
59301: NOT
59302: IFTRUE 59335
59304: PUSH
59305: LD_VAR 0 1
59309: PPUSH
59310: CALL_OW 264
59314: PUSH
59315: LD_INT 12
59317: PUSH
59318: LD_INT 51
59320: PUSH
59321: LD_INT 32
59323: PUSH
59324: LD_INT 89
59326: PUSH
59327: EMPTY
59328: LIST
59329: LIST
59330: LIST
59331: LIST
59332: IN
59333: NOT
59334: OR
59335: IFFALSE 59339
// exit ;
59337: GO 59437
// for i := 1 to 3 do
59339: LD_ADDR_VAR 0 3
59343: PUSH
59344: DOUBLE
59345: LD_INT 1
59347: DEC
59348: ST_TO_ADDR
59349: LD_INT 3
59351: PUSH
59352: FOR_TO
59353: IFFALSE 59435
// begin tmp := GetCargo ( cargo , i ) ;
59355: LD_ADDR_VAR 0 4
59359: PUSH
59360: LD_VAR 0 1
59364: PPUSH
59365: LD_VAR 0 3
59369: PPUSH
59370: CALL_OW 289
59374: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
59375: LD_ADDR_VAR 0 2
59379: PUSH
59380: LD_VAR 0 2
59384: PPUSH
59385: LD_VAR 0 3
59389: PPUSH
59390: LD_VAR 0 4
59394: PPUSH
59395: CALL_OW 1
59399: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
59400: LD_ADDR_VAR 0 2
59404: PUSH
59405: LD_VAR 0 2
59409: PPUSH
59410: LD_INT 4
59412: PPUSH
59413: LD_VAR 0 2
59417: PUSH
59418: LD_INT 4
59420: ARRAY
59421: PUSH
59422: LD_VAR 0 4
59426: PLUS
59427: PPUSH
59428: CALL_OW 1
59432: ST_TO_ADDR
// end ;
59433: GO 59352
59435: POP
59436: POP
// end ;
59437: LD_VAR 0 2
59441: RET
// export function Length ( array ) ; begin
59442: LD_INT 0
59444: PPUSH
// result := array + 0 ;
59445: LD_ADDR_VAR 0 2
59449: PUSH
59450: LD_VAR 0 1
59454: PUSH
59455: LD_INT 0
59457: PLUS
59458: ST_TO_ADDR
// end ;
59459: LD_VAR 0 2
59463: RET
// export function PrepareArray ( array ) ; begin
59464: LD_INT 0
59466: PPUSH
// result := array diff 0 ;
59467: LD_ADDR_VAR 0 2
59471: PUSH
59472: LD_VAR 0 1
59476: PUSH
59477: LD_INT 0
59479: DIFF
59480: ST_TO_ADDR
// if not result [ 1 ] then
59481: LD_VAR 0 2
59485: PUSH
59486: LD_INT 1
59488: ARRAY
59489: NOT
59490: IFFALSE 59510
// result := Delete ( result , 1 ) ;
59492: LD_ADDR_VAR 0 2
59496: PUSH
59497: LD_VAR 0 2
59501: PPUSH
59502: LD_INT 1
59504: PPUSH
59505: CALL_OW 3
59509: ST_TO_ADDR
// end ;
59510: LD_VAR 0 2
59514: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
59515: LD_INT 0
59517: PPUSH
59518: PPUSH
59519: PPUSH
59520: PPUSH
// sibRocketRange := 25 ;
59521: LD_ADDR_VAR 0 6
59525: PUSH
59526: LD_INT 25
59528: ST_TO_ADDR
// result := false ;
59529: LD_ADDR_VAR 0 4
59533: PUSH
59534: LD_INT 0
59536: ST_TO_ADDR
// for i := 0 to 5 do
59537: LD_ADDR_VAR 0 5
59541: PUSH
59542: DOUBLE
59543: LD_INT 0
59545: DEC
59546: ST_TO_ADDR
59547: LD_INT 5
59549: PUSH
59550: FOR_TO
59551: IFFALSE 59618
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
59553: LD_VAR 0 1
59557: PPUSH
59558: LD_VAR 0 5
59562: PPUSH
59563: LD_VAR 0 6
59567: PPUSH
59568: CALL_OW 272
59572: PPUSH
59573: LD_VAR 0 2
59577: PPUSH
59578: LD_VAR 0 5
59582: PPUSH
59583: LD_VAR 0 6
59587: PPUSH
59588: CALL_OW 273
59592: PPUSH
59593: LD_VAR 0 3
59597: PPUSH
59598: CALL_OW 309
59602: IFFALSE 59616
// begin result := true ;
59604: LD_ADDR_VAR 0 4
59608: PUSH
59609: LD_INT 1
59611: ST_TO_ADDR
// exit ;
59612: POP
59613: POP
59614: GO 59620
// end ;
59616: GO 59550
59618: POP
59619: POP
// end ;
59620: LD_VAR 0 4
59624: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
59625: LD_INT 0
59627: PPUSH
59628: PPUSH
59629: PPUSH
// if btype = b_depot then
59630: LD_VAR 0 2
59634: PUSH
59635: LD_INT 0
59637: EQUAL
59638: IFFALSE 59650
// begin result := true ;
59640: LD_ADDR_VAR 0 3
59644: PUSH
59645: LD_INT 1
59647: ST_TO_ADDR
// exit ;
59648: GO 59770
// end ; pom := GetBase ( depot ) ;
59650: LD_ADDR_VAR 0 4
59654: PUSH
59655: LD_VAR 0 1
59659: PPUSH
59660: CALL_OW 274
59664: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59665: LD_ADDR_VAR 0 5
59669: PUSH
59670: LD_VAR 0 2
59674: PPUSH
59675: LD_VAR 0 1
59679: PPUSH
59680: CALL_OW 248
59684: PPUSH
59685: CALL_OW 450
59689: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
59690: LD_ADDR_VAR 0 3
59694: PUSH
59695: LD_VAR 0 4
59699: PPUSH
59700: LD_INT 1
59702: PPUSH
59703: CALL_OW 275
59707: PUSH
59708: LD_VAR 0 5
59712: PUSH
59713: LD_INT 1
59715: ARRAY
59716: GREATEREQUAL
59717: IFFALSE 59743
59719: PUSH
59720: LD_VAR 0 4
59724: PPUSH
59725: LD_INT 2
59727: PPUSH
59728: CALL_OW 275
59732: PUSH
59733: LD_VAR 0 5
59737: PUSH
59738: LD_INT 2
59740: ARRAY
59741: GREATEREQUAL
59742: AND
59743: IFFALSE 59769
59745: PUSH
59746: LD_VAR 0 4
59750: PPUSH
59751: LD_INT 3
59753: PPUSH
59754: CALL_OW 275
59758: PUSH
59759: LD_VAR 0 5
59763: PUSH
59764: LD_INT 3
59766: ARRAY
59767: GREATEREQUAL
59768: AND
59769: ST_TO_ADDR
// end ;
59770: LD_VAR 0 3
59774: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59775: LD_INT 0
59777: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59778: LD_VAR 0 1
59782: PPUSH
59783: LD_VAR 0 2
59787: PPUSH
59788: LD_INT 0
59790: PPUSH
59791: LD_INT 0
59793: PPUSH
59794: LD_INT 1
59796: PPUSH
59797: LD_INT 0
59799: PPUSH
59800: CALL_OW 587
// end ;
59804: LD_VAR 0 3
59808: RET
// export function CenterOnNow ( unit ) ; begin
59809: LD_INT 0
59811: PPUSH
// result := IsInUnit ( unit ) ;
59812: LD_ADDR_VAR 0 2
59816: PUSH
59817: LD_VAR 0 1
59821: PPUSH
59822: CALL_OW 310
59826: ST_TO_ADDR
// if not result then
59827: LD_VAR 0 2
59831: NOT
59832: IFFALSE 59844
// result := unit ;
59834: LD_ADDR_VAR 0 2
59838: PUSH
59839: LD_VAR 0 1
59843: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59844: LD_VAR 0 1
59848: PPUSH
59849: CALL_OW 87
// end ;
59853: LD_VAR 0 2
59857: RET
// export function ComMoveHex ( unit , hex ) ; begin
59858: LD_INT 0
59860: PPUSH
// if not hex then
59861: LD_VAR 0 2
59865: NOT
59866: IFFALSE 59870
// exit ;
59868: GO 59923
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59870: LD_VAR 0 2
59874: PUSH
59875: LD_INT 1
59877: ARRAY
59878: PPUSH
59879: LD_VAR 0 2
59883: PUSH
59884: LD_INT 2
59886: ARRAY
59887: PPUSH
59888: CALL_OW 428
59892: IFFALSE 59896
// exit ;
59894: GO 59923
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59896: LD_VAR 0 1
59900: PPUSH
59901: LD_VAR 0 2
59905: PUSH
59906: LD_INT 1
59908: ARRAY
59909: PPUSH
59910: LD_VAR 0 2
59914: PUSH
59915: LD_INT 2
59917: ARRAY
59918: PPUSH
59919: CALL_OW 111
// end ;
59923: LD_VAR 0 3
59927: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
59928: LD_INT 0
59930: PPUSH
59931: PPUSH
59932: PPUSH
// if not unit or not enemy then
59933: LD_VAR 0 1
59937: NOT
59938: IFTRUE 59947
59940: PUSH
59941: LD_VAR 0 2
59945: NOT
59946: OR
59947: IFFALSE 59951
// exit ;
59949: GO 60077
// x := GetX ( enemy ) ;
59951: LD_ADDR_VAR 0 4
59955: PUSH
59956: LD_VAR 0 2
59960: PPUSH
59961: CALL_OW 250
59965: ST_TO_ADDR
// y := GetY ( enemy ) ;
59966: LD_ADDR_VAR 0 5
59970: PUSH
59971: LD_VAR 0 2
59975: PPUSH
59976: CALL_OW 251
59980: ST_TO_ADDR
// if ValidHex ( x , y ) then
59981: LD_VAR 0 4
59985: PPUSH
59986: LD_VAR 0 5
59990: PPUSH
59991: CALL_OW 488
59995: IFFALSE 60077
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
59997: LD_VAR 0 2
60001: PPUSH
60002: CALL_OW 247
60006: PUSH
60007: LD_INT 3
60009: PUSH
60010: LD_INT 2
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: IN
60017: IFTRUE 60040
60019: PUSH
60020: LD_VAR 0 1
60024: PPUSH
60025: CALL_OW 255
60029: PPUSH
60030: LD_VAR 0 2
60034: PPUSH
60035: CALL_OW 292
60039: OR
60040: IFFALSE 60058
// ComAttackUnit ( unit , enemy ) else
60042: LD_VAR 0 1
60046: PPUSH
60047: LD_VAR 0 2
60051: PPUSH
60052: CALL_OW 115
60056: GO 60077
// ComAgressiveMove ( unit , x , y ) ;
60058: LD_VAR 0 1
60062: PPUSH
60063: LD_VAR 0 4
60067: PPUSH
60068: LD_VAR 0 5
60072: PPUSH
60073: CALL_OW 114
// end ;
60077: LD_VAR 0 3
60081: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
60082: LD_INT 0
60084: PPUSH
60085: PPUSH
60086: PPUSH
// list := AreaToList ( area , 0 ) ;
60087: LD_ADDR_VAR 0 5
60091: PUSH
60092: LD_VAR 0 1
60096: PPUSH
60097: LD_INT 0
60099: PPUSH
60100: CALL_OW 517
60104: ST_TO_ADDR
// if not list then
60105: LD_VAR 0 5
60109: NOT
60110: IFFALSE 60114
// exit ;
60112: GO 60244
// if all then
60114: LD_VAR 0 2
60118: IFFALSE 60206
// begin for i := 1 to list [ 1 ] do
60120: LD_ADDR_VAR 0 4
60124: PUSH
60125: DOUBLE
60126: LD_INT 1
60128: DEC
60129: ST_TO_ADDR
60130: LD_VAR 0 5
60134: PUSH
60135: LD_INT 1
60137: ARRAY
60138: PUSH
60139: FOR_TO
60140: IFFALSE 60202
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
60142: LD_ADDR_VAR 0 3
60146: PUSH
60147: LD_VAR 0 3
60151: PPUSH
60152: LD_VAR 0 3
60156: PUSH
60157: LD_INT 1
60159: PLUS
60160: PPUSH
60161: LD_VAR 0 5
60165: PUSH
60166: LD_INT 1
60168: ARRAY
60169: PUSH
60170: LD_VAR 0 4
60174: ARRAY
60175: PUSH
60176: LD_VAR 0 5
60180: PUSH
60181: LD_INT 2
60183: ARRAY
60184: PUSH
60185: LD_VAR 0 4
60189: ARRAY
60190: PUSH
60191: EMPTY
60192: LIST
60193: LIST
60194: PPUSH
60195: CALL_OW 1
60199: ST_TO_ADDR
60200: GO 60139
60202: POP
60203: POP
// exit ;
60204: GO 60244
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
60206: LD_ADDR_VAR 0 3
60210: PUSH
60211: LD_VAR 0 5
60215: PUSH
60216: LD_INT 1
60218: ARRAY
60219: PUSH
60220: LD_INT 1
60222: ARRAY
60223: PUSH
60224: LD_VAR 0 5
60228: PUSH
60229: LD_INT 2
60231: ARRAY
60232: PUSH
60233: LD_INT 1
60235: ARRAY
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PUSH
60241: EMPTY
60242: LIST
60243: ST_TO_ADDR
// end ;
60244: LD_VAR 0 3
60248: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
60249: LD_INT 0
60251: PPUSH
60252: PPUSH
// list := AreaToList ( area , 0 ) ;
60253: LD_ADDR_VAR 0 4
60257: PUSH
60258: LD_VAR 0 1
60262: PPUSH
60263: LD_INT 0
60265: PPUSH
60266: CALL_OW 517
60270: ST_TO_ADDR
// if not list then
60271: LD_VAR 0 4
60275: NOT
60276: IFFALSE 60280
// exit ;
60278: GO 60321
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
60280: LD_ADDR_VAR 0 3
60284: PUSH
60285: LD_VAR 0 4
60289: PUSH
60290: LD_INT 1
60292: ARRAY
60293: PUSH
60294: LD_INT 1
60296: ARRAY
60297: PUSH
60298: LD_VAR 0 4
60302: PUSH
60303: LD_INT 2
60305: ARRAY
60306: PUSH
60307: LD_INT 1
60309: ARRAY
60310: PUSH
60311: LD_VAR 0 2
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: LIST
60320: ST_TO_ADDR
// end ;
60321: LD_VAR 0 3
60325: RET
// export function First ( array ) ; begin
60326: LD_INT 0
60328: PPUSH
// if not array then
60329: LD_VAR 0 1
60333: NOT
60334: IFFALSE 60338
// exit ;
60336: GO 60352
// result := array [ 1 ] ;
60338: LD_ADDR_VAR 0 2
60342: PUSH
60343: LD_VAR 0 1
60347: PUSH
60348: LD_INT 1
60350: ARRAY
60351: ST_TO_ADDR
// end ;
60352: LD_VAR 0 2
60356: RET
// export function Last ( array ) ; begin
60357: LD_INT 0
60359: PPUSH
// if not array then
60360: LD_VAR 0 1
60364: NOT
60365: IFFALSE 60369
// exit ;
60367: GO 60385
// result := array [ array ] ;
60369: LD_ADDR_VAR 0 2
60373: PUSH
60374: LD_VAR 0 1
60378: PUSH
60379: LD_VAR 0 1
60383: ARRAY
60384: ST_TO_ADDR
// end ;
60385: LD_VAR 0 2
60389: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
60390: LD_INT 0
60392: PPUSH
60393: PPUSH
// result := [ ] ;
60394: LD_ADDR_VAR 0 5
60398: PUSH
60399: EMPTY
60400: ST_TO_ADDR
// if not array then
60401: LD_VAR 0 1
60405: NOT
60406: IFFALSE 60410
// exit ;
60408: GO 60522
// for i := 1 to array do
60410: LD_ADDR_VAR 0 6
60414: PUSH
60415: DOUBLE
60416: LD_INT 1
60418: DEC
60419: ST_TO_ADDR
60420: LD_VAR 0 1
60424: PUSH
60425: FOR_TO
60426: IFFALSE 60520
// if array [ i ] [ index ] = value then
60428: LD_VAR 0 1
60432: PUSH
60433: LD_VAR 0 6
60437: ARRAY
60438: PUSH
60439: LD_VAR 0 2
60443: ARRAY
60444: PUSH
60445: LD_VAR 0 3
60449: EQUAL
60450: IFFALSE 60518
// begin if indexColumn then
60452: LD_VAR 0 4
60456: IFFALSE 60492
// result := Join ( result , array [ i ] [ indexColumn ] ) else
60458: LD_ADDR_VAR 0 5
60462: PUSH
60463: LD_VAR 0 5
60467: PPUSH
60468: LD_VAR 0 1
60472: PUSH
60473: LD_VAR 0 6
60477: ARRAY
60478: PUSH
60479: LD_VAR 0 4
60483: ARRAY
60484: PPUSH
60485: CALL 55530 0 2
60489: ST_TO_ADDR
60490: GO 60518
// result := Join ( result , array [ i ] ) ;
60492: LD_ADDR_VAR 0 5
60496: PUSH
60497: LD_VAR 0 5
60501: PPUSH
60502: LD_VAR 0 1
60506: PUSH
60507: LD_VAR 0 6
60511: ARRAY
60512: PPUSH
60513: CALL 55530 0 2
60517: ST_TO_ADDR
// end ;
60518: GO 60425
60520: POP
60521: POP
// end ;
60522: LD_VAR 0 5
60526: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
60527: LD_INT 0
60529: PPUSH
// if not vehicles or not parkingPoint then
60530: LD_VAR 0 1
60534: NOT
60535: IFTRUE 60544
60537: PUSH
60538: LD_VAR 0 2
60542: NOT
60543: OR
60544: IFFALSE 60548
// exit ;
60546: GO 60646
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
60548: LD_ADDR_VAR 0 1
60552: PUSH
60553: LD_VAR 0 1
60557: PPUSH
60558: LD_INT 50
60560: PUSH
60561: EMPTY
60562: LIST
60563: PUSH
60564: LD_INT 3
60566: PUSH
60567: LD_INT 92
60569: PUSH
60570: LD_VAR 0 2
60574: PUSH
60575: LD_INT 1
60577: ARRAY
60578: PUSH
60579: LD_VAR 0 2
60583: PUSH
60584: LD_INT 2
60586: ARRAY
60587: PUSH
60588: LD_INT 8
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: LIST
60595: LIST
60596: PUSH
60597: EMPTY
60598: LIST
60599: LIST
60600: PUSH
60601: EMPTY
60602: LIST
60603: LIST
60604: PPUSH
60605: CALL_OW 72
60609: ST_TO_ADDR
// if not vehicles then
60610: LD_VAR 0 1
60614: NOT
60615: IFFALSE 60619
// exit ;
60617: GO 60646
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
60619: LD_VAR 0 1
60623: PPUSH
60624: LD_VAR 0 2
60628: PUSH
60629: LD_INT 1
60631: ARRAY
60632: PPUSH
60633: LD_VAR 0 2
60637: PUSH
60638: LD_INT 2
60640: ARRAY
60641: PPUSH
60642: CALL_OW 111
// end ;
60646: LD_VAR 0 3
60650: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
60651: LD_INT 0
60653: PPUSH
60654: PPUSH
60655: PPUSH
// if not side or not area then
60656: LD_VAR 0 1
60660: NOT
60661: IFTRUE 60670
60663: PUSH
60664: LD_VAR 0 2
60668: NOT
60669: OR
60670: IFFALSE 60674
// exit ;
60672: GO 60793
// tmp := AreaToList ( area , 0 ) ;
60674: LD_ADDR_VAR 0 5
60678: PUSH
60679: LD_VAR 0 2
60683: PPUSH
60684: LD_INT 0
60686: PPUSH
60687: CALL_OW 517
60691: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: DOUBLE
60698: LD_INT 1
60700: DEC
60701: ST_TO_ADDR
60702: LD_VAR 0 5
60706: PUSH
60707: LD_INT 1
60709: ARRAY
60710: PUSH
60711: FOR_TO
60712: IFFALSE 60791
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
60714: LD_VAR 0 5
60718: PUSH
60719: LD_INT 1
60721: ARRAY
60722: PUSH
60723: LD_VAR 0 4
60727: ARRAY
60728: PPUSH
60729: LD_VAR 0 5
60733: PUSH
60734: LD_INT 2
60736: ARRAY
60737: PUSH
60738: LD_VAR 0 4
60742: ARRAY
60743: PPUSH
60744: CALL_OW 351
60748: IFFALSE 60789
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60750: LD_VAR 0 5
60754: PUSH
60755: LD_INT 1
60757: ARRAY
60758: PUSH
60759: LD_VAR 0 4
60763: ARRAY
60764: PPUSH
60765: LD_VAR 0 5
60769: PUSH
60770: LD_INT 2
60772: ARRAY
60773: PUSH
60774: LD_VAR 0 4
60778: ARRAY
60779: PPUSH
60780: LD_VAR 0 1
60784: PPUSH
60785: CALL_OW 244
// end ;
60789: GO 60711
60791: POP
60792: POP
// end ;
60793: LD_VAR 0 3
60797: RET
// export function UniqueArray ( array ) ; var i ; begin
60798: LD_INT 0
60800: PPUSH
60801: PPUSH
// result := [ ] ;
60802: LD_ADDR_VAR 0 2
60806: PUSH
60807: EMPTY
60808: ST_TO_ADDR
// if not array then
60809: LD_VAR 0 1
60813: NOT
60814: IFFALSE 60818
// exit ;
60816: GO 60879
// for i := 1 to array do
60818: LD_ADDR_VAR 0 3
60822: PUSH
60823: DOUBLE
60824: LD_INT 1
60826: DEC
60827: ST_TO_ADDR
60828: LD_VAR 0 1
60832: PUSH
60833: FOR_TO
60834: IFFALSE 60877
// if not array [ i ] in result then
60836: LD_VAR 0 1
60840: PUSH
60841: LD_VAR 0 3
60845: ARRAY
60846: PUSH
60847: LD_VAR 0 2
60851: IN
60852: NOT
60853: IFFALSE 60875
// result := Join ( result , i ) ;
60855: LD_ADDR_VAR 0 2
60859: PUSH
60860: LD_VAR 0 2
60864: PPUSH
60865: LD_VAR 0 3
60869: PPUSH
60870: CALL 55530 0 2
60874: ST_TO_ADDR
60875: GO 60833
60877: POP
60878: POP
// end ; end_of_file
60879: LD_VAR 0 2
60883: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60884: LD_INT 0
60886: PPUSH
60887: PPUSH
// skirmish := false ;
60888: LD_ADDR_EXP 61
60892: PUSH
60893: LD_INT 0
60895: ST_TO_ADDR
// debug_mc := false ;
60896: LD_ADDR_EXP 62
60900: PUSH
60901: LD_INT 0
60903: ST_TO_ADDR
// mc_bases := [ ] ;
60904: LD_ADDR_EXP 63
60908: PUSH
60909: EMPTY
60910: ST_TO_ADDR
// mc_sides := [ ] ;
60911: LD_ADDR_EXP 89
60915: PUSH
60916: EMPTY
60917: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60918: LD_ADDR_EXP 64
60922: PUSH
60923: EMPTY
60924: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60925: LD_ADDR_EXP 65
60929: PUSH
60930: EMPTY
60931: ST_TO_ADDR
// mc_need_heal := [ ] ;
60932: LD_ADDR_EXP 66
60936: PUSH
60937: EMPTY
60938: ST_TO_ADDR
// mc_healers := [ ] ;
60939: LD_ADDR_EXP 67
60943: PUSH
60944: EMPTY
60945: ST_TO_ADDR
// mc_build_list := [ ] ;
60946: LD_ADDR_EXP 68
60950: PUSH
60951: EMPTY
60952: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60953: LD_ADDR_EXP 95
60957: PUSH
60958: EMPTY
60959: ST_TO_ADDR
// mc_builders := [ ] ;
60960: LD_ADDR_EXP 69
60964: PUSH
60965: EMPTY
60966: ST_TO_ADDR
// mc_construct_list := [ ] ;
60967: LD_ADDR_EXP 70
60971: PUSH
60972: EMPTY
60973: ST_TO_ADDR
// mc_turret_list := [ ] ;
60974: LD_ADDR_EXP 71
60978: PUSH
60979: EMPTY
60980: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
60981: LD_ADDR_EXP 72
60985: PUSH
60986: EMPTY
60987: ST_TO_ADDR
// mc_miners := [ ] ;
60988: LD_ADDR_EXP 77
60992: PUSH
60993: EMPTY
60994: ST_TO_ADDR
// mc_mines := [ ] ;
60995: LD_ADDR_EXP 76
60999: PUSH
61000: EMPTY
61001: ST_TO_ADDR
// mc_minefields := [ ] ;
61002: LD_ADDR_EXP 78
61006: PUSH
61007: EMPTY
61008: ST_TO_ADDR
// mc_crates := [ ] ;
61009: LD_ADDR_EXP 79
61013: PUSH
61014: EMPTY
61015: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61016: LD_ADDR_EXP 80
61020: PUSH
61021: EMPTY
61022: ST_TO_ADDR
// mc_crates_area := [ ] ;
61023: LD_ADDR_EXP 81
61027: PUSH
61028: EMPTY
61029: ST_TO_ADDR
// mc_vehicles := [ ] ;
61030: LD_ADDR_EXP 82
61034: PUSH
61035: EMPTY
61036: ST_TO_ADDR
// mc_attack := [ ] ;
61037: LD_ADDR_EXP 83
61041: PUSH
61042: EMPTY
61043: ST_TO_ADDR
// mc_produce := [ ] ;
61044: LD_ADDR_EXP 84
61048: PUSH
61049: EMPTY
61050: ST_TO_ADDR
// mc_defender := [ ] ;
61051: LD_ADDR_EXP 85
61055: PUSH
61056: EMPTY
61057: ST_TO_ADDR
// mc_parking := [ ] ;
61058: LD_ADDR_EXP 87
61062: PUSH
61063: EMPTY
61064: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61065: LD_ADDR_EXP 73
61069: PUSH
61070: EMPTY
61071: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61072: LD_ADDR_EXP 75
61076: PUSH
61077: EMPTY
61078: ST_TO_ADDR
// mc_scan := [ ] ;
61079: LD_ADDR_EXP 86
61083: PUSH
61084: EMPTY
61085: ST_TO_ADDR
// mc_scan_area := [ ] ;
61086: LD_ADDR_EXP 88
61090: PUSH
61091: EMPTY
61092: ST_TO_ADDR
// mc_tech := [ ] ;
61093: LD_ADDR_EXP 90
61097: PUSH
61098: EMPTY
61099: ST_TO_ADDR
// mc_class := [ ] ;
61100: LD_ADDR_EXP 104
61104: PUSH
61105: EMPTY
61106: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61107: LD_ADDR_EXP 105
61111: PUSH
61112: EMPTY
61113: ST_TO_ADDR
// mc_is_defending := [ ] ;
61114: LD_ADDR_EXP 106
61118: PUSH
61119: EMPTY
61120: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61121: LD_ADDR_EXP 97
61125: PUSH
61126: EMPTY
61127: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61128: LD_ADDR_EXP 107
61132: PUSH
61133: LD_INT 0
61135: ST_TO_ADDR
// end ;
61136: LD_VAR 0 1
61140: RET
// export function MC_Kill ( base ) ; begin
61141: LD_INT 0
61143: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61144: LD_ADDR_EXP 63
61148: PUSH
61149: LD_EXP 63
61153: PPUSH
61154: LD_VAR 0 1
61158: PPUSH
61159: EMPTY
61160: PPUSH
61161: CALL_OW 1
61165: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61166: LD_ADDR_EXP 64
61170: PUSH
61171: LD_EXP 64
61175: PPUSH
61176: LD_VAR 0 1
61180: PPUSH
61181: EMPTY
61182: PPUSH
61183: CALL_OW 1
61187: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61188: LD_ADDR_EXP 65
61192: PUSH
61193: LD_EXP 65
61197: PPUSH
61198: LD_VAR 0 1
61202: PPUSH
61203: EMPTY
61204: PPUSH
61205: CALL_OW 1
61209: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61210: LD_ADDR_EXP 66
61214: PUSH
61215: LD_EXP 66
61219: PPUSH
61220: LD_VAR 0 1
61224: PPUSH
61225: EMPTY
61226: PPUSH
61227: CALL_OW 1
61231: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61232: LD_ADDR_EXP 67
61236: PUSH
61237: LD_EXP 67
61241: PPUSH
61242: LD_VAR 0 1
61246: PPUSH
61247: EMPTY
61248: PPUSH
61249: CALL_OW 1
61253: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61254: LD_ADDR_EXP 68
61258: PUSH
61259: LD_EXP 68
61263: PPUSH
61264: LD_VAR 0 1
61268: PPUSH
61269: EMPTY
61270: PPUSH
61271: CALL_OW 1
61275: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61276: LD_ADDR_EXP 69
61280: PUSH
61281: LD_EXP 69
61285: PPUSH
61286: LD_VAR 0 1
61290: PPUSH
61291: EMPTY
61292: PPUSH
61293: CALL_OW 1
61297: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61298: LD_ADDR_EXP 70
61302: PUSH
61303: LD_EXP 70
61307: PPUSH
61308: LD_VAR 0 1
61312: PPUSH
61313: EMPTY
61314: PPUSH
61315: CALL_OW 1
61319: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61320: LD_ADDR_EXP 71
61324: PUSH
61325: LD_EXP 71
61329: PPUSH
61330: LD_VAR 0 1
61334: PPUSH
61335: EMPTY
61336: PPUSH
61337: CALL_OW 1
61341: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61342: LD_ADDR_EXP 72
61346: PUSH
61347: LD_EXP 72
61351: PPUSH
61352: LD_VAR 0 1
61356: PPUSH
61357: EMPTY
61358: PPUSH
61359: CALL_OW 1
61363: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61364: LD_ADDR_EXP 73
61368: PUSH
61369: LD_EXP 73
61373: PPUSH
61374: LD_VAR 0 1
61378: PPUSH
61379: EMPTY
61380: PPUSH
61381: CALL_OW 1
61385: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61386: LD_ADDR_EXP 74
61390: PUSH
61391: LD_EXP 74
61395: PPUSH
61396: LD_VAR 0 1
61400: PPUSH
61401: LD_INT 0
61403: PPUSH
61404: CALL_OW 1
61408: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61409: LD_ADDR_EXP 75
61413: PUSH
61414: LD_EXP 75
61418: PPUSH
61419: LD_VAR 0 1
61423: PPUSH
61424: EMPTY
61425: PPUSH
61426: CALL_OW 1
61430: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61431: LD_ADDR_EXP 76
61435: PUSH
61436: LD_EXP 76
61440: PPUSH
61441: LD_VAR 0 1
61445: PPUSH
61446: EMPTY
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61453: LD_ADDR_EXP 77
61457: PUSH
61458: LD_EXP 77
61462: PPUSH
61463: LD_VAR 0 1
61467: PPUSH
61468: EMPTY
61469: PPUSH
61470: CALL_OW 1
61474: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61475: LD_ADDR_EXP 78
61479: PUSH
61480: LD_EXP 78
61484: PPUSH
61485: LD_VAR 0 1
61489: PPUSH
61490: EMPTY
61491: PPUSH
61492: CALL_OW 1
61496: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61497: LD_ADDR_EXP 79
61501: PUSH
61502: LD_EXP 79
61506: PPUSH
61507: LD_VAR 0 1
61511: PPUSH
61512: EMPTY
61513: PPUSH
61514: CALL_OW 1
61518: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61519: LD_ADDR_EXP 80
61523: PUSH
61524: LD_EXP 80
61528: PPUSH
61529: LD_VAR 0 1
61533: PPUSH
61534: EMPTY
61535: PPUSH
61536: CALL_OW 1
61540: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61541: LD_ADDR_EXP 81
61545: PUSH
61546: LD_EXP 81
61550: PPUSH
61551: LD_VAR 0 1
61555: PPUSH
61556: EMPTY
61557: PPUSH
61558: CALL_OW 1
61562: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61563: LD_ADDR_EXP 82
61567: PUSH
61568: LD_EXP 82
61572: PPUSH
61573: LD_VAR 0 1
61577: PPUSH
61578: EMPTY
61579: PPUSH
61580: CALL_OW 1
61584: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61585: LD_ADDR_EXP 83
61589: PUSH
61590: LD_EXP 83
61594: PPUSH
61595: LD_VAR 0 1
61599: PPUSH
61600: EMPTY
61601: PPUSH
61602: CALL_OW 1
61606: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61607: LD_ADDR_EXP 84
61611: PUSH
61612: LD_EXP 84
61616: PPUSH
61617: LD_VAR 0 1
61621: PPUSH
61622: EMPTY
61623: PPUSH
61624: CALL_OW 1
61628: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61629: LD_ADDR_EXP 85
61633: PUSH
61634: LD_EXP 85
61638: PPUSH
61639: LD_VAR 0 1
61643: PPUSH
61644: EMPTY
61645: PPUSH
61646: CALL_OW 1
61650: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61651: LD_ADDR_EXP 86
61655: PUSH
61656: LD_EXP 86
61660: PPUSH
61661: LD_VAR 0 1
61665: PPUSH
61666: EMPTY
61667: PPUSH
61668: CALL_OW 1
61672: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61673: LD_ADDR_EXP 87
61677: PUSH
61678: LD_EXP 87
61682: PPUSH
61683: LD_VAR 0 1
61687: PPUSH
61688: EMPTY
61689: PPUSH
61690: CALL_OW 1
61694: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61695: LD_ADDR_EXP 88
61699: PUSH
61700: LD_EXP 88
61704: PPUSH
61705: LD_VAR 0 1
61709: PPUSH
61710: EMPTY
61711: PPUSH
61712: CALL_OW 1
61716: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61717: LD_ADDR_EXP 90
61721: PUSH
61722: LD_EXP 90
61726: PPUSH
61727: LD_VAR 0 1
61731: PPUSH
61732: EMPTY
61733: PPUSH
61734: CALL_OW 1
61738: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61739: LD_ADDR_EXP 92
61743: PUSH
61744: LD_EXP 92
61748: PPUSH
61749: LD_VAR 0 1
61753: PPUSH
61754: EMPTY
61755: PPUSH
61756: CALL_OW 1
61760: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61761: LD_ADDR_EXP 93
61765: PUSH
61766: LD_EXP 93
61770: PPUSH
61771: LD_VAR 0 1
61775: PPUSH
61776: EMPTY
61777: PPUSH
61778: CALL_OW 1
61782: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61783: LD_ADDR_EXP 94
61787: PUSH
61788: LD_EXP 94
61792: PPUSH
61793: LD_VAR 0 1
61797: PPUSH
61798: EMPTY
61799: PPUSH
61800: CALL_OW 1
61804: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61805: LD_ADDR_EXP 95
61809: PUSH
61810: LD_EXP 95
61814: PPUSH
61815: LD_VAR 0 1
61819: PPUSH
61820: EMPTY
61821: PPUSH
61822: CALL_OW 1
61826: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61827: LD_ADDR_EXP 96
61831: PUSH
61832: LD_EXP 96
61836: PPUSH
61837: LD_VAR 0 1
61841: PPUSH
61842: EMPTY
61843: PPUSH
61844: CALL_OW 1
61848: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61849: LD_ADDR_EXP 97
61853: PUSH
61854: LD_EXP 97
61858: PPUSH
61859: LD_VAR 0 1
61863: PPUSH
61864: EMPTY
61865: PPUSH
61866: CALL_OW 1
61870: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61871: LD_ADDR_EXP 98
61875: PUSH
61876: LD_EXP 98
61880: PPUSH
61881: LD_VAR 0 1
61885: PPUSH
61886: EMPTY
61887: PPUSH
61888: CALL_OW 1
61892: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61893: LD_ADDR_EXP 99
61897: PUSH
61898: LD_EXP 99
61902: PPUSH
61903: LD_VAR 0 1
61907: PPUSH
61908: EMPTY
61909: PPUSH
61910: CALL_OW 1
61914: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61915: LD_ADDR_EXP 100
61919: PUSH
61920: LD_EXP 100
61924: PPUSH
61925: LD_VAR 0 1
61929: PPUSH
61930: EMPTY
61931: PPUSH
61932: CALL_OW 1
61936: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61937: LD_ADDR_EXP 101
61941: PUSH
61942: LD_EXP 101
61946: PPUSH
61947: LD_VAR 0 1
61951: PPUSH
61952: EMPTY
61953: PPUSH
61954: CALL_OW 1
61958: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61959: LD_ADDR_EXP 102
61963: PUSH
61964: LD_EXP 102
61968: PPUSH
61969: LD_VAR 0 1
61973: PPUSH
61974: EMPTY
61975: PPUSH
61976: CALL_OW 1
61980: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61981: LD_ADDR_EXP 103
61985: PUSH
61986: LD_EXP 103
61990: PPUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: EMPTY
61997: PPUSH
61998: CALL_OW 1
62002: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62003: LD_ADDR_EXP 104
62007: PUSH
62008: LD_EXP 104
62012: PPUSH
62013: LD_VAR 0 1
62017: PPUSH
62018: EMPTY
62019: PPUSH
62020: CALL_OW 1
62024: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62025: LD_ADDR_EXP 105
62029: PUSH
62030: LD_EXP 105
62034: PPUSH
62035: LD_VAR 0 1
62039: PPUSH
62040: LD_INT 0
62042: PPUSH
62043: CALL_OW 1
62047: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62048: LD_ADDR_EXP 106
62052: PUSH
62053: LD_EXP 106
62057: PPUSH
62058: LD_VAR 0 1
62062: PPUSH
62063: LD_INT 0
62065: PPUSH
62066: CALL_OW 1
62070: ST_TO_ADDR
// end ;
62071: LD_VAR 0 2
62075: RET
// export function MC_Add ( side , units ) ; var base ; begin
62076: LD_INT 0
62078: PPUSH
62079: PPUSH
// base := mc_bases + 1 ;
62080: LD_ADDR_VAR 0 4
62084: PUSH
62085: LD_EXP 63
62089: PUSH
62090: LD_INT 1
62092: PLUS
62093: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62094: LD_ADDR_EXP 89
62098: PUSH
62099: LD_EXP 89
62103: PPUSH
62104: LD_VAR 0 4
62108: PPUSH
62109: LD_VAR 0 1
62113: PPUSH
62114: CALL_OW 1
62118: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62119: LD_ADDR_EXP 63
62123: PUSH
62124: LD_EXP 63
62128: PPUSH
62129: LD_VAR 0 4
62133: PPUSH
62134: LD_VAR 0 2
62138: PPUSH
62139: CALL_OW 1
62143: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62144: LD_ADDR_EXP 64
62148: PUSH
62149: LD_EXP 64
62153: PPUSH
62154: LD_VAR 0 4
62158: PPUSH
62159: EMPTY
62160: PPUSH
62161: CALL_OW 1
62165: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62166: LD_ADDR_EXP 65
62170: PUSH
62171: LD_EXP 65
62175: PPUSH
62176: LD_VAR 0 4
62180: PPUSH
62181: EMPTY
62182: PPUSH
62183: CALL_OW 1
62187: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62188: LD_ADDR_EXP 66
62192: PUSH
62193: LD_EXP 66
62197: PPUSH
62198: LD_VAR 0 4
62202: PPUSH
62203: EMPTY
62204: PPUSH
62205: CALL_OW 1
62209: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62210: LD_ADDR_EXP 67
62214: PUSH
62215: LD_EXP 67
62219: PPUSH
62220: LD_VAR 0 4
62224: PPUSH
62225: EMPTY
62226: PPUSH
62227: CALL_OW 1
62231: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62232: LD_ADDR_EXP 68
62236: PUSH
62237: LD_EXP 68
62241: PPUSH
62242: LD_VAR 0 4
62246: PPUSH
62247: EMPTY
62248: PPUSH
62249: CALL_OW 1
62253: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62254: LD_ADDR_EXP 69
62258: PUSH
62259: LD_EXP 69
62263: PPUSH
62264: LD_VAR 0 4
62268: PPUSH
62269: EMPTY
62270: PPUSH
62271: CALL_OW 1
62275: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62276: LD_ADDR_EXP 70
62280: PUSH
62281: LD_EXP 70
62285: PPUSH
62286: LD_VAR 0 4
62290: PPUSH
62291: EMPTY
62292: PPUSH
62293: CALL_OW 1
62297: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62298: LD_ADDR_EXP 71
62302: PUSH
62303: LD_EXP 71
62307: PPUSH
62308: LD_VAR 0 4
62312: PPUSH
62313: EMPTY
62314: PPUSH
62315: CALL_OW 1
62319: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62320: LD_ADDR_EXP 72
62324: PUSH
62325: LD_EXP 72
62329: PPUSH
62330: LD_VAR 0 4
62334: PPUSH
62335: EMPTY
62336: PPUSH
62337: CALL_OW 1
62341: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62342: LD_ADDR_EXP 73
62346: PUSH
62347: LD_EXP 73
62351: PPUSH
62352: LD_VAR 0 4
62356: PPUSH
62357: EMPTY
62358: PPUSH
62359: CALL_OW 1
62363: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62364: LD_ADDR_EXP 74
62368: PUSH
62369: LD_EXP 74
62373: PPUSH
62374: LD_VAR 0 4
62378: PPUSH
62379: LD_INT 0
62381: PPUSH
62382: CALL_OW 1
62386: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62387: LD_ADDR_EXP 75
62391: PUSH
62392: LD_EXP 75
62396: PPUSH
62397: LD_VAR 0 4
62401: PPUSH
62402: EMPTY
62403: PPUSH
62404: CALL_OW 1
62408: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62409: LD_ADDR_EXP 76
62413: PUSH
62414: LD_EXP 76
62418: PPUSH
62419: LD_VAR 0 4
62423: PPUSH
62424: EMPTY
62425: PPUSH
62426: CALL_OW 1
62430: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62431: LD_ADDR_EXP 77
62435: PUSH
62436: LD_EXP 77
62440: PPUSH
62441: LD_VAR 0 4
62445: PPUSH
62446: EMPTY
62447: PPUSH
62448: CALL_OW 1
62452: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62453: LD_ADDR_EXP 78
62457: PUSH
62458: LD_EXP 78
62462: PPUSH
62463: LD_VAR 0 4
62467: PPUSH
62468: EMPTY
62469: PPUSH
62470: CALL_OW 1
62474: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62475: LD_ADDR_EXP 79
62479: PUSH
62480: LD_EXP 79
62484: PPUSH
62485: LD_VAR 0 4
62489: PPUSH
62490: EMPTY
62491: PPUSH
62492: CALL_OW 1
62496: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62497: LD_ADDR_EXP 80
62501: PUSH
62502: LD_EXP 80
62506: PPUSH
62507: LD_VAR 0 4
62511: PPUSH
62512: EMPTY
62513: PPUSH
62514: CALL_OW 1
62518: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62519: LD_ADDR_EXP 81
62523: PUSH
62524: LD_EXP 81
62528: PPUSH
62529: LD_VAR 0 4
62533: PPUSH
62534: EMPTY
62535: PPUSH
62536: CALL_OW 1
62540: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62541: LD_ADDR_EXP 82
62545: PUSH
62546: LD_EXP 82
62550: PPUSH
62551: LD_VAR 0 4
62555: PPUSH
62556: EMPTY
62557: PPUSH
62558: CALL_OW 1
62562: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62563: LD_ADDR_EXP 83
62567: PUSH
62568: LD_EXP 83
62572: PPUSH
62573: LD_VAR 0 4
62577: PPUSH
62578: EMPTY
62579: PPUSH
62580: CALL_OW 1
62584: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62585: LD_ADDR_EXP 84
62589: PUSH
62590: LD_EXP 84
62594: PPUSH
62595: LD_VAR 0 4
62599: PPUSH
62600: EMPTY
62601: PPUSH
62602: CALL_OW 1
62606: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62607: LD_ADDR_EXP 85
62611: PUSH
62612: LD_EXP 85
62616: PPUSH
62617: LD_VAR 0 4
62621: PPUSH
62622: EMPTY
62623: PPUSH
62624: CALL_OW 1
62628: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62629: LD_ADDR_EXP 86
62633: PUSH
62634: LD_EXP 86
62638: PPUSH
62639: LD_VAR 0 4
62643: PPUSH
62644: EMPTY
62645: PPUSH
62646: CALL_OW 1
62650: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62651: LD_ADDR_EXP 87
62655: PUSH
62656: LD_EXP 87
62660: PPUSH
62661: LD_VAR 0 4
62665: PPUSH
62666: EMPTY
62667: PPUSH
62668: CALL_OW 1
62672: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62673: LD_ADDR_EXP 88
62677: PUSH
62678: LD_EXP 88
62682: PPUSH
62683: LD_VAR 0 4
62687: PPUSH
62688: EMPTY
62689: PPUSH
62690: CALL_OW 1
62694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62695: LD_ADDR_EXP 90
62699: PUSH
62700: LD_EXP 90
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: EMPTY
62711: PPUSH
62712: CALL_OW 1
62716: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62717: LD_ADDR_EXP 92
62721: PUSH
62722: LD_EXP 92
62726: PPUSH
62727: LD_VAR 0 4
62731: PPUSH
62732: EMPTY
62733: PPUSH
62734: CALL_OW 1
62738: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62739: LD_ADDR_EXP 93
62743: PUSH
62744: LD_EXP 93
62748: PPUSH
62749: LD_VAR 0 4
62753: PPUSH
62754: EMPTY
62755: PPUSH
62756: CALL_OW 1
62760: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62761: LD_ADDR_EXP 94
62765: PUSH
62766: LD_EXP 94
62770: PPUSH
62771: LD_VAR 0 4
62775: PPUSH
62776: EMPTY
62777: PPUSH
62778: CALL_OW 1
62782: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62783: LD_ADDR_EXP 95
62787: PUSH
62788: LD_EXP 95
62792: PPUSH
62793: LD_VAR 0 4
62797: PPUSH
62798: EMPTY
62799: PPUSH
62800: CALL_OW 1
62804: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62805: LD_ADDR_EXP 96
62809: PUSH
62810: LD_EXP 96
62814: PPUSH
62815: LD_VAR 0 4
62819: PPUSH
62820: EMPTY
62821: PPUSH
62822: CALL_OW 1
62826: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62827: LD_ADDR_EXP 97
62831: PUSH
62832: LD_EXP 97
62836: PPUSH
62837: LD_VAR 0 4
62841: PPUSH
62842: EMPTY
62843: PPUSH
62844: CALL_OW 1
62848: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62849: LD_ADDR_EXP 98
62853: PUSH
62854: LD_EXP 98
62858: PPUSH
62859: LD_VAR 0 4
62863: PPUSH
62864: EMPTY
62865: PPUSH
62866: CALL_OW 1
62870: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62871: LD_ADDR_EXP 99
62875: PUSH
62876: LD_EXP 99
62880: PPUSH
62881: LD_VAR 0 4
62885: PPUSH
62886: EMPTY
62887: PPUSH
62888: CALL_OW 1
62892: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62893: LD_ADDR_EXP 100
62897: PUSH
62898: LD_EXP 100
62902: PPUSH
62903: LD_VAR 0 4
62907: PPUSH
62908: EMPTY
62909: PPUSH
62910: CALL_OW 1
62914: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62915: LD_ADDR_EXP 101
62919: PUSH
62920: LD_EXP 101
62924: PPUSH
62925: LD_VAR 0 4
62929: PPUSH
62930: EMPTY
62931: PPUSH
62932: CALL_OW 1
62936: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62937: LD_ADDR_EXP 102
62941: PUSH
62942: LD_EXP 102
62946: PPUSH
62947: LD_VAR 0 4
62951: PPUSH
62952: EMPTY
62953: PPUSH
62954: CALL_OW 1
62958: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62959: LD_ADDR_EXP 103
62963: PUSH
62964: LD_EXP 103
62968: PPUSH
62969: LD_VAR 0 4
62973: PPUSH
62974: EMPTY
62975: PPUSH
62976: CALL_OW 1
62980: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62981: LD_ADDR_EXP 104
62985: PUSH
62986: LD_EXP 104
62990: PPUSH
62991: LD_VAR 0 4
62995: PPUSH
62996: EMPTY
62997: PPUSH
62998: CALL_OW 1
63002: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63003: LD_ADDR_EXP 105
63007: PUSH
63008: LD_EXP 105
63012: PPUSH
63013: LD_VAR 0 4
63017: PPUSH
63018: LD_INT 0
63020: PPUSH
63021: CALL_OW 1
63025: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63026: LD_ADDR_EXP 106
63030: PUSH
63031: LD_EXP 106
63035: PPUSH
63036: LD_VAR 0 4
63040: PPUSH
63041: LD_INT 0
63043: PPUSH
63044: CALL_OW 1
63048: ST_TO_ADDR
// result := base ;
63049: LD_ADDR_VAR 0 3
63053: PUSH
63054: LD_VAR 0 4
63058: ST_TO_ADDR
// end ;
63059: LD_VAR 0 3
63063: RET
// export function MC_Start ( ) ; var i ; begin
63064: LD_INT 0
63066: PPUSH
63067: PPUSH
// for i = 1 to mc_bases do
63068: LD_ADDR_VAR 0 2
63072: PUSH
63073: DOUBLE
63074: LD_INT 1
63076: DEC
63077: ST_TO_ADDR
63078: LD_EXP 63
63082: PUSH
63083: FOR_TO
63084: IFFALSE 64184
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63086: LD_ADDR_EXP 63
63090: PUSH
63091: LD_EXP 63
63095: PPUSH
63096: LD_VAR 0 2
63100: PPUSH
63101: LD_EXP 63
63105: PUSH
63106: LD_VAR 0 2
63110: ARRAY
63111: PUSH
63112: LD_INT 0
63114: DIFF
63115: PPUSH
63116: CALL_OW 1
63120: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63121: LD_ADDR_EXP 64
63125: PUSH
63126: LD_EXP 64
63130: PPUSH
63131: LD_VAR 0 2
63135: PPUSH
63136: EMPTY
63137: PPUSH
63138: CALL_OW 1
63142: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63143: LD_ADDR_EXP 65
63147: PUSH
63148: LD_EXP 65
63152: PPUSH
63153: LD_VAR 0 2
63157: PPUSH
63158: EMPTY
63159: PPUSH
63160: CALL_OW 1
63164: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63165: LD_ADDR_EXP 66
63169: PUSH
63170: LD_EXP 66
63174: PPUSH
63175: LD_VAR 0 2
63179: PPUSH
63180: EMPTY
63181: PPUSH
63182: CALL_OW 1
63186: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63187: LD_ADDR_EXP 67
63191: PUSH
63192: LD_EXP 67
63196: PPUSH
63197: LD_VAR 0 2
63201: PPUSH
63202: EMPTY
63203: PUSH
63204: EMPTY
63205: PUSH
63206: EMPTY
63207: LIST
63208: LIST
63209: PPUSH
63210: CALL_OW 1
63214: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63215: LD_ADDR_EXP 68
63219: PUSH
63220: LD_EXP 68
63224: PPUSH
63225: LD_VAR 0 2
63229: PPUSH
63230: EMPTY
63231: PPUSH
63232: CALL_OW 1
63236: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63237: LD_ADDR_EXP 95
63241: PUSH
63242: LD_EXP 95
63246: PPUSH
63247: LD_VAR 0 2
63251: PPUSH
63252: EMPTY
63253: PPUSH
63254: CALL_OW 1
63258: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63259: LD_ADDR_EXP 69
63263: PUSH
63264: LD_EXP 69
63268: PPUSH
63269: LD_VAR 0 2
63273: PPUSH
63274: EMPTY
63275: PPUSH
63276: CALL_OW 1
63280: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63281: LD_ADDR_EXP 70
63285: PUSH
63286: LD_EXP 70
63290: PPUSH
63291: LD_VAR 0 2
63295: PPUSH
63296: EMPTY
63297: PPUSH
63298: CALL_OW 1
63302: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63303: LD_ADDR_EXP 71
63307: PUSH
63308: LD_EXP 71
63312: PPUSH
63313: LD_VAR 0 2
63317: PPUSH
63318: LD_EXP 63
63322: PUSH
63323: LD_VAR 0 2
63327: ARRAY
63328: PPUSH
63329: LD_INT 2
63331: PUSH
63332: LD_INT 30
63334: PUSH
63335: LD_INT 32
63337: PUSH
63338: EMPTY
63339: LIST
63340: LIST
63341: PUSH
63342: LD_INT 30
63344: PUSH
63345: LD_INT 33
63347: PUSH
63348: EMPTY
63349: LIST
63350: LIST
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: LIST
63356: PPUSH
63357: CALL_OW 72
63361: PPUSH
63362: CALL_OW 1
63366: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63367: LD_ADDR_EXP 72
63371: PUSH
63372: LD_EXP 72
63376: PPUSH
63377: LD_VAR 0 2
63381: PPUSH
63382: LD_EXP 63
63386: PUSH
63387: LD_VAR 0 2
63391: ARRAY
63392: PPUSH
63393: LD_INT 2
63395: PUSH
63396: LD_INT 30
63398: PUSH
63399: LD_INT 32
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: LD_INT 30
63408: PUSH
63409: LD_INT 31
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 58
63423: PUSH
63424: EMPTY
63425: LIST
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PPUSH
63431: CALL_OW 72
63435: PPUSH
63436: CALL_OW 1
63440: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63441: LD_ADDR_EXP 73
63445: PUSH
63446: LD_EXP 73
63450: PPUSH
63451: LD_VAR 0 2
63455: PPUSH
63456: EMPTY
63457: PPUSH
63458: CALL_OW 1
63462: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63463: LD_ADDR_EXP 77
63467: PUSH
63468: LD_EXP 77
63472: PPUSH
63473: LD_VAR 0 2
63477: PPUSH
63478: EMPTY
63479: PPUSH
63480: CALL_OW 1
63484: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63485: LD_ADDR_EXP 76
63489: PUSH
63490: LD_EXP 76
63494: PPUSH
63495: LD_VAR 0 2
63499: PPUSH
63500: EMPTY
63501: PPUSH
63502: CALL_OW 1
63506: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63507: LD_ADDR_EXP 78
63511: PUSH
63512: LD_EXP 78
63516: PPUSH
63517: LD_VAR 0 2
63521: PPUSH
63522: EMPTY
63523: PPUSH
63524: CALL_OW 1
63528: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63529: LD_ADDR_EXP 79
63533: PUSH
63534: LD_EXP 79
63538: PPUSH
63539: LD_VAR 0 2
63543: PPUSH
63544: EMPTY
63545: PPUSH
63546: CALL_OW 1
63550: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63551: LD_ADDR_EXP 80
63555: PUSH
63556: LD_EXP 80
63560: PPUSH
63561: LD_VAR 0 2
63565: PPUSH
63566: EMPTY
63567: PPUSH
63568: CALL_OW 1
63572: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63573: LD_ADDR_EXP 81
63577: PUSH
63578: LD_EXP 81
63582: PPUSH
63583: LD_VAR 0 2
63587: PPUSH
63588: EMPTY
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63595: LD_ADDR_EXP 82
63599: PUSH
63600: LD_EXP 82
63604: PPUSH
63605: LD_VAR 0 2
63609: PPUSH
63610: EMPTY
63611: PPUSH
63612: CALL_OW 1
63616: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63617: LD_ADDR_EXP 83
63621: PUSH
63622: LD_EXP 83
63626: PPUSH
63627: LD_VAR 0 2
63631: PPUSH
63632: EMPTY
63633: PPUSH
63634: CALL_OW 1
63638: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
63639: LD_ADDR_EXP 84
63643: PUSH
63644: LD_EXP 84
63648: PPUSH
63649: LD_VAR 0 2
63653: PPUSH
63654: EMPTY
63655: PPUSH
63656: CALL_OW 1
63660: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63661: LD_ADDR_EXP 85
63665: PUSH
63666: LD_EXP 85
63670: PPUSH
63671: LD_VAR 0 2
63675: PPUSH
63676: EMPTY
63677: PPUSH
63678: CALL_OW 1
63682: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
63683: LD_ADDR_EXP 74
63687: PUSH
63688: LD_EXP 74
63692: PPUSH
63693: LD_VAR 0 2
63697: PPUSH
63698: LD_INT 0
63700: PPUSH
63701: CALL_OW 1
63705: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
63706: LD_ADDR_EXP 87
63710: PUSH
63711: LD_EXP 87
63715: PPUSH
63716: LD_VAR 0 2
63720: PPUSH
63721: LD_INT 0
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
63729: LD_ADDR_EXP 75
63733: PUSH
63734: LD_EXP 75
63738: PPUSH
63739: LD_VAR 0 2
63743: PPUSH
63744: EMPTY
63745: PPUSH
63746: CALL_OW 1
63750: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
63751: LD_ADDR_EXP 86
63755: PUSH
63756: LD_EXP 86
63760: PPUSH
63761: LD_VAR 0 2
63765: PPUSH
63766: LD_INT 0
63768: PPUSH
63769: CALL_OW 1
63773: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63774: LD_ADDR_EXP 88
63778: PUSH
63779: LD_EXP 88
63783: PPUSH
63784: LD_VAR 0 2
63788: PPUSH
63789: EMPTY
63790: PPUSH
63791: CALL_OW 1
63795: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63796: LD_ADDR_EXP 91
63800: PUSH
63801: LD_EXP 91
63805: PPUSH
63806: LD_VAR 0 2
63810: PPUSH
63811: LD_INT 0
63813: PPUSH
63814: CALL_OW 1
63818: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63819: LD_ADDR_EXP 92
63823: PUSH
63824: LD_EXP 92
63828: PPUSH
63829: LD_VAR 0 2
63833: PPUSH
63834: EMPTY
63835: PPUSH
63836: CALL_OW 1
63840: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63841: LD_ADDR_EXP 93
63845: PUSH
63846: LD_EXP 93
63850: PPUSH
63851: LD_VAR 0 2
63855: PPUSH
63856: EMPTY
63857: PPUSH
63858: CALL_OW 1
63862: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63863: LD_ADDR_EXP 94
63867: PUSH
63868: LD_EXP 94
63872: PPUSH
63873: LD_VAR 0 2
63877: PPUSH
63878: EMPTY
63879: PPUSH
63880: CALL_OW 1
63884: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63885: LD_ADDR_EXP 96
63889: PUSH
63890: LD_EXP 96
63894: PPUSH
63895: LD_VAR 0 2
63899: PPUSH
63900: LD_EXP 63
63904: PUSH
63905: LD_VAR 0 2
63909: ARRAY
63910: PPUSH
63911: LD_INT 2
63913: PUSH
63914: LD_INT 30
63916: PUSH
63917: LD_INT 6
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 30
63926: PUSH
63927: LD_INT 7
63929: PUSH
63930: EMPTY
63931: LIST
63932: LIST
63933: PUSH
63934: LD_INT 30
63936: PUSH
63937: LD_INT 8
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: EMPTY
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: PPUSH
63950: CALL_OW 72
63954: PPUSH
63955: CALL_OW 1
63959: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63960: LD_ADDR_EXP 97
63964: PUSH
63965: LD_EXP 97
63969: PPUSH
63970: LD_VAR 0 2
63974: PPUSH
63975: EMPTY
63976: PPUSH
63977: CALL_OW 1
63981: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
63982: LD_ADDR_EXP 98
63986: PUSH
63987: LD_EXP 98
63991: PPUSH
63992: LD_VAR 0 2
63996: PPUSH
63997: EMPTY
63998: PPUSH
63999: CALL_OW 1
64003: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64004: LD_ADDR_EXP 99
64008: PUSH
64009: LD_EXP 99
64013: PPUSH
64014: LD_VAR 0 2
64018: PPUSH
64019: EMPTY
64020: PPUSH
64021: CALL_OW 1
64025: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64026: LD_ADDR_EXP 100
64030: PUSH
64031: LD_EXP 100
64035: PPUSH
64036: LD_VAR 0 2
64040: PPUSH
64041: EMPTY
64042: PPUSH
64043: CALL_OW 1
64047: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64048: LD_ADDR_EXP 101
64052: PUSH
64053: LD_EXP 101
64057: PPUSH
64058: LD_VAR 0 2
64062: PPUSH
64063: EMPTY
64064: PPUSH
64065: CALL_OW 1
64069: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64070: LD_ADDR_EXP 102
64074: PUSH
64075: LD_EXP 102
64079: PPUSH
64080: LD_VAR 0 2
64084: PPUSH
64085: EMPTY
64086: PPUSH
64087: CALL_OW 1
64091: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64092: LD_ADDR_EXP 103
64096: PUSH
64097: LD_EXP 103
64101: PPUSH
64102: LD_VAR 0 2
64106: PPUSH
64107: EMPTY
64108: PPUSH
64109: CALL_OW 1
64113: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64114: LD_ADDR_EXP 104
64118: PUSH
64119: LD_EXP 104
64123: PPUSH
64124: LD_VAR 0 2
64128: PPUSH
64129: EMPTY
64130: PPUSH
64131: CALL_OW 1
64135: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64136: LD_ADDR_EXP 105
64140: PUSH
64141: LD_EXP 105
64145: PPUSH
64146: LD_VAR 0 2
64150: PPUSH
64151: LD_INT 0
64153: PPUSH
64154: CALL_OW 1
64158: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64159: LD_ADDR_EXP 106
64163: PUSH
64164: LD_EXP 106
64168: PPUSH
64169: LD_VAR 0 2
64173: PPUSH
64174: LD_INT 0
64176: PPUSH
64177: CALL_OW 1
64181: ST_TO_ADDR
// end ;
64182: GO 63083
64184: POP
64185: POP
// MC_InitSides ( ) ;
64186: CALL 64472 0 0
// MC_InitResearch ( ) ;
64190: CALL 64211 0 0
// CustomInitMacro ( ) ;
64194: CALL 219 0 0
// skirmish := true ;
64198: LD_ADDR_EXP 61
64202: PUSH
64203: LD_INT 1
64205: ST_TO_ADDR
// end ;
64206: LD_VAR 0 1
64210: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64211: LD_INT 0
64213: PPUSH
64214: PPUSH
64215: PPUSH
64216: PPUSH
64217: PPUSH
64218: PPUSH
// if not mc_bases then
64219: LD_EXP 63
64223: NOT
64224: IFFALSE 64228
// exit ;
64226: GO 64467
// for i = 1 to 8 do
64228: LD_ADDR_VAR 0 2
64232: PUSH
64233: DOUBLE
64234: LD_INT 1
64236: DEC
64237: ST_TO_ADDR
64238: LD_INT 8
64240: PUSH
64241: FOR_TO
64242: IFFALSE 64268
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64244: LD_ADDR_EXP 90
64248: PUSH
64249: LD_EXP 90
64253: PPUSH
64254: LD_VAR 0 2
64258: PPUSH
64259: EMPTY
64260: PPUSH
64261: CALL_OW 1
64265: ST_TO_ADDR
64266: GO 64241
64268: POP
64269: POP
// tmp := [ ] ;
64270: LD_ADDR_VAR 0 5
64274: PUSH
64275: EMPTY
64276: ST_TO_ADDR
// for i = 1 to mc_sides do
64277: LD_ADDR_VAR 0 2
64281: PUSH
64282: DOUBLE
64283: LD_INT 1
64285: DEC
64286: ST_TO_ADDR
64287: LD_EXP 89
64291: PUSH
64292: FOR_TO
64293: IFFALSE 64351
// if not mc_sides [ i ] in tmp then
64295: LD_EXP 89
64299: PUSH
64300: LD_VAR 0 2
64304: ARRAY
64305: PUSH
64306: LD_VAR 0 5
64310: IN
64311: NOT
64312: IFFALSE 64349
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64314: LD_ADDR_VAR 0 5
64318: PUSH
64319: LD_VAR 0 5
64323: PPUSH
64324: LD_VAR 0 5
64328: PUSH
64329: LD_INT 1
64331: PLUS
64332: PPUSH
64333: LD_EXP 89
64337: PUSH
64338: LD_VAR 0 2
64342: ARRAY
64343: PPUSH
64344: CALL_OW 2
64348: ST_TO_ADDR
64349: GO 64292
64351: POP
64352: POP
// if not tmp then
64353: LD_VAR 0 5
64357: NOT
64358: IFFALSE 64362
// exit ;
64360: GO 64467
// for j in tmp do
64362: LD_ADDR_VAR 0 3
64366: PUSH
64367: LD_VAR 0 5
64371: PUSH
64372: FOR_IN
64373: IFFALSE 64465
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64375: LD_ADDR_VAR 0 6
64379: PUSH
64380: LD_INT 22
64382: PUSH
64383: LD_VAR 0 3
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PPUSH
64392: CALL_OW 69
64396: ST_TO_ADDR
// if not un then
64397: LD_VAR 0 6
64401: NOT
64402: IFFALSE 64406
// continue ;
64404: GO 64372
// nation := GetNation ( un [ 1 ] ) ;
64406: LD_ADDR_VAR 0 4
64410: PUSH
64411: LD_VAR 0 6
64415: PUSH
64416: LD_INT 1
64418: ARRAY
64419: PPUSH
64420: CALL_OW 248
64424: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64425: LD_ADDR_EXP 90
64429: PUSH
64430: LD_EXP 90
64434: PPUSH
64435: LD_VAR 0 3
64439: PPUSH
64440: LD_VAR 0 3
64444: PPUSH
64445: LD_VAR 0 4
64449: PPUSH
64450: LD_INT 1
64452: PPUSH
64453: CALL 17545 0 3
64457: PPUSH
64458: CALL_OW 1
64462: ST_TO_ADDR
// end ;
64463: GO 64372
64465: POP
64466: POP
// end ;
64467: LD_VAR 0 1
64471: RET
// export function MC_InitSides ( ) ; var i ; begin
64472: LD_INT 0
64474: PPUSH
64475: PPUSH
// if not mc_bases then
64476: LD_EXP 63
64480: NOT
64481: IFFALSE 64485
// exit ;
64483: GO 64559
// for i = 1 to mc_bases do
64485: LD_ADDR_VAR 0 2
64489: PUSH
64490: DOUBLE
64491: LD_INT 1
64493: DEC
64494: ST_TO_ADDR
64495: LD_EXP 63
64499: PUSH
64500: FOR_TO
64501: IFFALSE 64557
// if mc_bases [ i ] then
64503: LD_EXP 63
64507: PUSH
64508: LD_VAR 0 2
64512: ARRAY
64513: IFFALSE 64555
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64515: LD_ADDR_EXP 89
64519: PUSH
64520: LD_EXP 89
64524: PPUSH
64525: LD_VAR 0 2
64529: PPUSH
64530: LD_EXP 63
64534: PUSH
64535: LD_VAR 0 2
64539: ARRAY
64540: PUSH
64541: LD_INT 1
64543: ARRAY
64544: PPUSH
64545: CALL_OW 255
64549: PPUSH
64550: CALL_OW 1
64554: ST_TO_ADDR
64555: GO 64500
64557: POP
64558: POP
// end ;
64559: LD_VAR 0 1
64563: RET
// every 0 0$03 trigger skirmish do
64564: LD_EXP 61
64568: IFFALSE 64722
64570: GO 64572
64572: DISABLE
// begin enable ;
64573: ENABLE
// MC_CheckBuildings ( ) ;
64574: CALL 69280 0 0
// MC_CheckPeopleLife ( ) ;
64578: CALL 69441 0 0
// RaiseSailEvent ( 100 ) ;
64582: LD_INT 100
64584: PPUSH
64585: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64589: LD_INT 103
64591: PPUSH
64592: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64596: LD_INT 104
64598: PPUSH
64599: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64603: LD_INT 105
64605: PPUSH
64606: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64610: LD_INT 106
64612: PPUSH
64613: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64617: LD_INT 107
64619: PPUSH
64620: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64624: LD_INT 108
64626: PPUSH
64627: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64631: LD_INT 109
64633: PPUSH
64634: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
64638: LD_INT 110
64640: PPUSH
64641: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
64645: LD_INT 111
64647: PPUSH
64648: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
64652: LD_INT 112
64654: PPUSH
64655: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
64659: LD_INT 113
64661: PPUSH
64662: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
64666: LD_INT 120
64668: PPUSH
64669: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
64673: LD_INT 121
64675: PPUSH
64676: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
64680: LD_INT 122
64682: PPUSH
64683: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
64687: LD_INT 123
64689: PPUSH
64690: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
64694: LD_INT 124
64696: PPUSH
64697: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
64701: LD_INT 125
64703: PPUSH
64704: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
64708: LD_INT 126
64710: PPUSH
64711: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
64715: LD_INT 200
64717: PPUSH
64718: CALL_OW 427
// end ;
64722: END
// on SailEvent ( event ) do begin if event < 100 then
64723: LD_VAR 0 1
64727: PUSH
64728: LD_INT 100
64730: LESS
64731: IFFALSE 64742
// CustomEvent ( event ) ;
64733: LD_VAR 0 1
64737: PPUSH
64738: CALL 16044 0 1
// if event = 100 then
64742: LD_VAR 0 1
64746: PUSH
64747: LD_INT 100
64749: EQUAL
64750: IFFALSE 64756
// MC_ClassManager ( ) ;
64752: CALL 65150 0 0
// if event = 101 then
64756: LD_VAR 0 1
64760: PUSH
64761: LD_INT 101
64763: EQUAL
64764: IFFALSE 64770
// MC_RepairBuildings ( ) ;
64766: CALL 70028 0 0
// if event = 102 then
64770: LD_VAR 0 1
64774: PUSH
64775: LD_INT 102
64777: EQUAL
64778: IFFALSE 64784
// MC_Heal ( ) ;
64780: CALL 70967 0 0
// if event = 103 then
64784: LD_VAR 0 1
64788: PUSH
64789: LD_INT 103
64791: EQUAL
64792: IFFALSE 64798
// MC_Build ( ) ;
64794: CALL 71393 0 0
// if event = 104 then
64798: LD_VAR 0 1
64802: PUSH
64803: LD_INT 104
64805: EQUAL
64806: IFFALSE 64812
// MC_TurretWeapon ( ) ;
64808: CALL 73041 0 0
// if event = 105 then
64812: LD_VAR 0 1
64816: PUSH
64817: LD_INT 105
64819: EQUAL
64820: IFFALSE 64826
// MC_BuildUpgrade ( ) ;
64822: CALL 72586 0 0
// if event = 106 then
64826: LD_VAR 0 1
64830: PUSH
64831: LD_INT 106
64833: EQUAL
64834: IFFALSE 64840
// MC_PlantMines ( ) ;
64836: CALL 73473 0 0
// if event = 107 then
64840: LD_VAR 0 1
64844: PUSH
64845: LD_INT 107
64847: EQUAL
64848: IFFALSE 64854
// MC_CollectCrates ( ) ;
64850: CALL 74283 0 0
// if event = 108 then
64854: LD_VAR 0 1
64858: PUSH
64859: LD_INT 108
64861: EQUAL
64862: IFFALSE 64868
// MC_LinkRemoteControl ( ) ;
64864: CALL 76157 0 0
// if event = 109 then
64868: LD_VAR 0 1
64872: PUSH
64873: LD_INT 109
64875: EQUAL
64876: IFFALSE 64882
// MC_ProduceVehicle ( ) ;
64878: CALL 76342 0 0
// if event = 110 then
64882: LD_VAR 0 1
64886: PUSH
64887: LD_INT 110
64889: EQUAL
64890: IFFALSE 64896
// MC_SendAttack ( ) ;
64892: CALL 76812 0 0
// if event = 111 then
64896: LD_VAR 0 1
64900: PUSH
64901: LD_INT 111
64903: EQUAL
64904: IFFALSE 64910
// MC_Defend ( ) ;
64906: CALL 76920 0 0
// if event = 112 then
64910: LD_VAR 0 1
64914: PUSH
64915: LD_INT 112
64917: EQUAL
64918: IFFALSE 64924
// MC_Research ( ) ;
64920: CALL 77820 0 0
// if event = 113 then
64924: LD_VAR 0 1
64928: PUSH
64929: LD_INT 113
64931: EQUAL
64932: IFFALSE 64938
// MC_MinesTrigger ( ) ;
64934: CALL 78960 0 0
// if event = 120 then
64938: LD_VAR 0 1
64942: PUSH
64943: LD_INT 120
64945: EQUAL
64946: IFFALSE 64952
// MC_RepairVehicle ( ) ;
64948: CALL 79061 0 0
// if event = 121 then
64952: LD_VAR 0 1
64956: PUSH
64957: LD_INT 121
64959: EQUAL
64960: IFFALSE 64966
// MC_TameApe ( ) ;
64962: CALL 79838 0 0
// if event = 122 then
64966: LD_VAR 0 1
64970: PUSH
64971: LD_INT 122
64973: EQUAL
64974: IFFALSE 64980
// MC_ChangeApeClass ( ) ;
64976: CALL 80683 0 0
// if event = 123 then
64980: LD_VAR 0 1
64984: PUSH
64985: LD_INT 123
64987: EQUAL
64988: IFFALSE 64994
// MC_Bazooka ( ) ;
64990: CALL 81339 0 0
// if event = 124 then
64994: LD_VAR 0 1
64998: PUSH
64999: LD_INT 124
65001: EQUAL
65002: IFFALSE 65008
// MC_TeleportExit ( ) ;
65004: CALL 81541 0 0
// if event = 125 then
65008: LD_VAR 0 1
65012: PUSH
65013: LD_INT 125
65015: EQUAL
65016: IFFALSE 65022
// MC_Deposits ( ) ;
65018: CALL 82198 0 0
// if event = 126 then
65022: LD_VAR 0 1
65026: PUSH
65027: LD_INT 126
65029: EQUAL
65030: IFFALSE 65036
// MC_RemoteDriver ( ) ;
65032: CALL 82831 0 0
// if event = 200 then
65036: LD_VAR 0 1
65040: PUSH
65041: LD_INT 200
65043: EQUAL
65044: IFFALSE 65050
// MC_Idle ( ) ;
65046: CALL 84766 0 0
// end ;
65050: PPOPN 1
65052: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65053: LD_INT 0
65055: PPUSH
65056: PPUSH
// if not mc_bases [ base ] or not tag then
65057: LD_EXP 63
65061: PUSH
65062: LD_VAR 0 1
65066: ARRAY
65067: NOT
65068: IFTRUE 65077
65070: PUSH
65071: LD_VAR 0 2
65075: NOT
65076: OR
65077: IFFALSE 65081
// exit ;
65079: GO 65145
// for i in mc_bases [ base ] union mc_ape [ base ] do
65081: LD_ADDR_VAR 0 4
65085: PUSH
65086: LD_EXP 63
65090: PUSH
65091: LD_VAR 0 1
65095: ARRAY
65096: PUSH
65097: LD_EXP 92
65101: PUSH
65102: LD_VAR 0 1
65106: ARRAY
65107: UNION
65108: PUSH
65109: FOR_IN
65110: IFFALSE 65143
// if GetTag ( i ) = tag then
65112: LD_VAR 0 4
65116: PPUSH
65117: CALL_OW 110
65121: PUSH
65122: LD_VAR 0 2
65126: EQUAL
65127: IFFALSE 65141
// SetTag ( i , 0 ) ;
65129: LD_VAR 0 4
65133: PPUSH
65134: LD_INT 0
65136: PPUSH
65137: CALL_OW 109
65141: GO 65109
65143: POP
65144: POP
// end ;
65145: LD_VAR 0 3
65149: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65150: LD_INT 0
65152: PPUSH
65153: PPUSH
65154: PPUSH
65155: PPUSH
65156: PPUSH
65157: PPUSH
65158: PPUSH
65159: PPUSH
// if not mc_bases then
65160: LD_EXP 63
65164: NOT
65165: IFFALSE 65169
// exit ;
65167: GO 65620
// for i = 1 to mc_bases do
65169: LD_ADDR_VAR 0 2
65173: PUSH
65174: DOUBLE
65175: LD_INT 1
65177: DEC
65178: ST_TO_ADDR
65179: LD_EXP 63
65183: PUSH
65184: FOR_TO
65185: IFFALSE 65618
// begin tmp := MC_ClassCheckReq ( i ) ;
65187: LD_ADDR_VAR 0 4
65191: PUSH
65192: LD_VAR 0 2
65196: PPUSH
65197: CALL 65625 0 1
65201: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65202: LD_ADDR_EXP 104
65206: PUSH
65207: LD_EXP 104
65211: PPUSH
65212: LD_VAR 0 2
65216: PPUSH
65217: LD_VAR 0 4
65221: PPUSH
65222: CALL_OW 1
65226: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65227: LD_ADDR_VAR 0 6
65231: PUSH
65232: LD_EXP 63
65236: PUSH
65237: LD_VAR 0 2
65241: ARRAY
65242: PPUSH
65243: LD_INT 2
65245: PUSH
65246: LD_INT 30
65248: PUSH
65249: LD_INT 4
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 30
65258: PUSH
65259: LD_INT 5
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: LIST
65270: PPUSH
65271: CALL_OW 72
65275: PUSH
65276: LD_EXP 63
65280: PUSH
65281: LD_VAR 0 2
65285: ARRAY
65286: PPUSH
65287: LD_INT 2
65289: PUSH
65290: LD_INT 30
65292: PUSH
65293: LD_INT 0
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: LD_INT 30
65302: PUSH
65303: LD_INT 1
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: LIST
65314: PPUSH
65315: CALL_OW 72
65319: PUSH
65320: LD_EXP 63
65324: PUSH
65325: LD_VAR 0 2
65329: ARRAY
65330: PPUSH
65331: LD_INT 30
65333: PUSH
65334: LD_INT 3
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PPUSH
65341: CALL_OW 72
65345: PUSH
65346: LD_EXP 63
65350: PUSH
65351: LD_VAR 0 2
65355: ARRAY
65356: PPUSH
65357: LD_INT 2
65359: PUSH
65360: LD_INT 30
65362: PUSH
65363: LD_INT 6
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 30
65372: PUSH
65373: LD_INT 7
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 30
65382: PUSH
65383: LD_INT 8
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: PPUSH
65396: CALL_OW 72
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: ST_TO_ADDR
// for j := 1 to 4 do
65407: LD_ADDR_VAR 0 3
65411: PUSH
65412: DOUBLE
65413: LD_INT 1
65415: DEC
65416: ST_TO_ADDR
65417: LD_INT 4
65419: PUSH
65420: FOR_TO
65421: IFFALSE 65614
// begin if not tmp [ j ] then
65423: LD_VAR 0 4
65427: PUSH
65428: LD_VAR 0 3
65432: ARRAY
65433: NOT
65434: IFFALSE 65438
// continue ;
65436: GO 65420
// for p in tmp [ j ] do
65438: LD_ADDR_VAR 0 5
65442: PUSH
65443: LD_VAR 0 4
65447: PUSH
65448: LD_VAR 0 3
65452: ARRAY
65453: PUSH
65454: FOR_IN
65455: IFFALSE 65610
// begin if not b [ j ] then
65457: LD_VAR 0 6
65461: PUSH
65462: LD_VAR 0 3
65466: ARRAY
65467: NOT
65468: IFFALSE 65472
// break ;
65470: GO 65610
// e := 0 ;
65472: LD_ADDR_VAR 0 7
65476: PUSH
65477: LD_INT 0
65479: ST_TO_ADDR
// for k in b [ j ] do
65480: LD_ADDR_VAR 0 8
65484: PUSH
65485: LD_VAR 0 6
65489: PUSH
65490: LD_VAR 0 3
65494: ARRAY
65495: PUSH
65496: FOR_IN
65497: IFFALSE 65524
// if IsNotFull ( k ) then
65499: LD_VAR 0 8
65503: PPUSH
65504: CALL 19680 0 1
65508: IFFALSE 65522
// begin e := k ;
65510: LD_ADDR_VAR 0 7
65514: PUSH
65515: LD_VAR 0 8
65519: ST_TO_ADDR
// break ;
65520: GO 65524
// end ;
65522: GO 65496
65524: POP
65525: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65526: LD_VAR 0 7
65530: IFFALSE 65549
65532: PUSH
65533: LD_VAR 0 5
65537: PPUSH
65538: LD_VAR 0 7
65542: PPUSH
65543: CALL 54140 0 2
65547: NOT
65548: AND
65549: IFFALSE 65608
// begin if IsInUnit ( p ) then
65551: LD_VAR 0 5
65555: PPUSH
65556: CALL_OW 310
65560: IFFALSE 65571
// ComExitBuilding ( p ) ;
65562: LD_VAR 0 5
65566: PPUSH
65567: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65571: LD_VAR 0 5
65575: PPUSH
65576: LD_VAR 0 7
65580: PPUSH
65581: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65585: LD_VAR 0 5
65589: PPUSH
65590: LD_VAR 0 3
65594: PPUSH
65595: CALL_OW 183
// AddComExitBuilding ( p ) ;
65599: LD_VAR 0 5
65603: PPUSH
65604: CALL_OW 182
// end ; end ;
65608: GO 65454
65610: POP
65611: POP
// end ;
65612: GO 65420
65614: POP
65615: POP
// end ;
65616: GO 65184
65618: POP
65619: POP
// end ;
65620: LD_VAR 0 1
65624: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65625: LD_INT 0
65627: PPUSH
65628: PPUSH
65629: PPUSH
65630: PPUSH
65631: PPUSH
65632: PPUSH
65633: PPUSH
65634: PPUSH
65635: PPUSH
65636: PPUSH
65637: PPUSH
65638: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
65639: LD_ADDR_VAR 0 2
65643: PUSH
65644: LD_INT 0
65646: PUSH
65647: LD_INT 0
65649: PUSH
65650: LD_INT 0
65652: PUSH
65653: LD_INT 0
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65662: LD_VAR 0 1
65666: NOT
65667: IFTRUE 65682
65669: PUSH
65670: LD_EXP 63
65674: PUSH
65675: LD_VAR 0 1
65679: ARRAY
65680: NOT
65681: OR
65682: IFTRUE 65730
65684: PUSH
65685: LD_EXP 63
65689: PUSH
65690: LD_VAR 0 1
65694: ARRAY
65695: PPUSH
65696: LD_INT 2
65698: PUSH
65699: LD_INT 30
65701: PUSH
65702: LD_INT 0
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: LD_INT 30
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: LIST
65723: PPUSH
65724: CALL_OW 72
65728: NOT
65729: OR
65730: IFFALSE 65734
// exit ;
65732: GO 69275
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65734: LD_ADDR_VAR 0 4
65738: PUSH
65739: LD_EXP 63
65743: PUSH
65744: LD_VAR 0 1
65748: ARRAY
65749: PPUSH
65750: LD_INT 2
65752: PUSH
65753: LD_INT 25
65755: PUSH
65756: LD_INT 1
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: LD_INT 25
65765: PUSH
65766: LD_INT 2
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PUSH
65773: LD_INT 25
65775: PUSH
65776: LD_INT 3
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 25
65785: PUSH
65786: LD_INT 4
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 25
65795: PUSH
65796: LD_INT 5
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 25
65805: PUSH
65806: LD_INT 8
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 25
65815: PUSH
65816: LD_INT 9
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: PPUSH
65833: CALL_OW 72
65837: ST_TO_ADDR
// if not tmp then
65838: LD_VAR 0 4
65842: NOT
65843: IFFALSE 65847
// exit ;
65845: GO 69275
// for i in tmp do
65847: LD_ADDR_VAR 0 3
65851: PUSH
65852: LD_VAR 0 4
65856: PUSH
65857: FOR_IN
65858: IFFALSE 65889
// if GetTag ( i ) then
65860: LD_VAR 0 3
65864: PPUSH
65865: CALL_OW 110
65869: IFFALSE 65887
// tmp := tmp diff i ;
65871: LD_ADDR_VAR 0 4
65875: PUSH
65876: LD_VAR 0 4
65880: PUSH
65881: LD_VAR 0 3
65885: DIFF
65886: ST_TO_ADDR
65887: GO 65857
65889: POP
65890: POP
// if not tmp then
65891: LD_VAR 0 4
65895: NOT
65896: IFFALSE 65900
// exit ;
65898: GO 69275
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65900: LD_ADDR_VAR 0 5
65904: PUSH
65905: LD_EXP 63
65909: PUSH
65910: LD_VAR 0 1
65914: ARRAY
65915: PPUSH
65916: LD_INT 2
65918: PUSH
65919: LD_INT 25
65921: PUSH
65922: LD_INT 1
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: PUSH
65929: LD_INT 25
65931: PUSH
65932: LD_INT 5
65934: PUSH
65935: EMPTY
65936: LIST
65937: LIST
65938: PUSH
65939: LD_INT 25
65941: PUSH
65942: LD_INT 8
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: LD_INT 25
65951: PUSH
65952: LD_INT 9
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: PPUSH
65966: CALL_OW 72
65970: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65971: LD_ADDR_VAR 0 6
65975: PUSH
65976: LD_EXP 63
65980: PUSH
65981: LD_VAR 0 1
65985: ARRAY
65986: PPUSH
65987: LD_INT 25
65989: PUSH
65990: LD_INT 2
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PPUSH
65997: CALL_OW 72
66001: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66002: LD_ADDR_VAR 0 7
66006: PUSH
66007: LD_EXP 63
66011: PUSH
66012: LD_VAR 0 1
66016: ARRAY
66017: PPUSH
66018: LD_INT 25
66020: PUSH
66021: LD_INT 3
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PPUSH
66028: CALL_OW 72
66032: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66033: LD_ADDR_VAR 0 8
66037: PUSH
66038: LD_EXP 63
66042: PUSH
66043: LD_VAR 0 1
66047: ARRAY
66048: PPUSH
66049: LD_INT 25
66051: PUSH
66052: LD_INT 4
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 24
66061: PUSH
66062: LD_INT 251
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PPUSH
66073: CALL_OW 72
66077: ST_TO_ADDR
// if mc_is_defending [ base ] then
66078: LD_EXP 106
66082: PUSH
66083: LD_VAR 0 1
66087: ARRAY
66088: IFFALSE 66549
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66090: LD_ADDR_EXP 105
66094: PUSH
66095: LD_EXP 105
66099: PPUSH
66100: LD_VAR 0 1
66104: PPUSH
66105: LD_INT 4
66107: PPUSH
66108: CALL_OW 1
66112: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66113: LD_ADDR_VAR 0 12
66117: PUSH
66118: LD_EXP 63
66122: PUSH
66123: LD_VAR 0 1
66127: ARRAY
66128: PPUSH
66129: LD_INT 2
66131: PUSH
66132: LD_INT 30
66134: PUSH
66135: LD_INT 4
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 30
66144: PUSH
66145: LD_INT 5
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: LIST
66156: PPUSH
66157: CALL_OW 72
66161: ST_TO_ADDR
// if not b then
66162: LD_VAR 0 12
66166: NOT
66167: IFFALSE 66171
// exit ;
66169: GO 69275
// p := [ ] ;
66171: LD_ADDR_VAR 0 11
66175: PUSH
66176: EMPTY
66177: ST_TO_ADDR
// if sci >= 2 then
66178: LD_VAR 0 8
66182: PUSH
66183: LD_INT 2
66185: GREATEREQUAL
66186: IFFALSE 66217
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66188: LD_ADDR_VAR 0 8
66192: PUSH
66193: LD_VAR 0 8
66197: PUSH
66198: LD_INT 1
66200: ARRAY
66201: PUSH
66202: LD_VAR 0 8
66206: PUSH
66207: LD_INT 2
66209: ARRAY
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: ST_TO_ADDR
66215: GO 66278
// if sci = 1 then
66217: LD_VAR 0 8
66221: PUSH
66222: LD_INT 1
66224: EQUAL
66225: IFFALSE 66246
// sci := [ sci [ 1 ] ] else
66227: LD_ADDR_VAR 0 8
66231: PUSH
66232: LD_VAR 0 8
66236: PUSH
66237: LD_INT 1
66239: ARRAY
66240: PUSH
66241: EMPTY
66242: LIST
66243: ST_TO_ADDR
66244: GO 66278
// if sci = 0 then
66246: LD_VAR 0 8
66250: PUSH
66251: LD_INT 0
66253: EQUAL
66254: IFFALSE 66278
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66256: LD_ADDR_VAR 0 11
66260: PUSH
66261: LD_VAR 0 4
66265: PPUSH
66266: LD_INT 4
66268: PPUSH
66269: CALL 54010 0 2
66273: PUSH
66274: LD_INT 1
66276: ARRAY
66277: ST_TO_ADDR
// if eng > 4 then
66278: LD_VAR 0 6
66282: PUSH
66283: LD_INT 4
66285: GREATER
66286: IFFALSE 66332
// for i = eng downto 4 do
66288: LD_ADDR_VAR 0 3
66292: PUSH
66293: DOUBLE
66294: LD_VAR 0 6
66298: INC
66299: ST_TO_ADDR
66300: LD_INT 4
66302: PUSH
66303: FOR_DOWNTO
66304: IFFALSE 66330
// eng := eng diff eng [ i ] ;
66306: LD_ADDR_VAR 0 6
66310: PUSH
66311: LD_VAR 0 6
66315: PUSH
66316: LD_VAR 0 6
66320: PUSH
66321: LD_VAR 0 3
66325: ARRAY
66326: DIFF
66327: ST_TO_ADDR
66328: GO 66303
66330: POP
66331: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66332: LD_ADDR_VAR 0 4
66336: PUSH
66337: LD_VAR 0 4
66341: PUSH
66342: LD_VAR 0 5
66346: PUSH
66347: LD_VAR 0 6
66351: UNION
66352: PUSH
66353: LD_VAR 0 7
66357: UNION
66358: PUSH
66359: LD_VAR 0 8
66363: UNION
66364: DIFF
66365: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66366: LD_ADDR_VAR 0 13
66370: PUSH
66371: LD_EXP 63
66375: PUSH
66376: LD_VAR 0 1
66380: ARRAY
66381: PPUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 30
66387: PUSH
66388: LD_INT 32
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 30
66397: PUSH
66398: LD_INT 31
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: LIST
66409: PPUSH
66410: CALL_OW 72
66414: PUSH
66415: LD_EXP 63
66419: PUSH
66420: LD_VAR 0 1
66424: ARRAY
66425: PPUSH
66426: LD_INT 2
66428: PUSH
66429: LD_INT 30
66431: PUSH
66432: LD_INT 4
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 30
66441: PUSH
66442: LD_INT 5
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: LIST
66453: PPUSH
66454: CALL_OW 72
66458: PUSH
66459: LD_INT 6
66461: MUL
66462: PLUS
66463: ST_TO_ADDR
// if bcount < tmp then
66464: LD_VAR 0 13
66468: PUSH
66469: LD_VAR 0 4
66473: LESS
66474: IFFALSE 66520
// for i = tmp downto bcount do
66476: LD_ADDR_VAR 0 3
66480: PUSH
66481: DOUBLE
66482: LD_VAR 0 4
66486: INC
66487: ST_TO_ADDR
66488: LD_VAR 0 13
66492: PUSH
66493: FOR_DOWNTO
66494: IFFALSE 66518
// tmp := Delete ( tmp , tmp ) ;
66496: LD_ADDR_VAR 0 4
66500: PUSH
66501: LD_VAR 0 4
66505: PPUSH
66506: LD_VAR 0 4
66510: PPUSH
66511: CALL_OW 3
66515: ST_TO_ADDR
66516: GO 66493
66518: POP
66519: POP
// result := [ tmp , 0 , 0 , p ] ;
66520: LD_ADDR_VAR 0 2
66524: PUSH
66525: LD_VAR 0 4
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: LD_INT 0
66535: PUSH
66536: LD_VAR 0 11
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: ST_TO_ADDR
// exit ;
66547: GO 69275
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66549: LD_EXP 63
66553: PUSH
66554: LD_VAR 0 1
66558: ARRAY
66559: PPUSH
66560: LD_INT 2
66562: PUSH
66563: LD_INT 30
66565: PUSH
66566: LD_INT 6
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 30
66575: PUSH
66576: LD_INT 7
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 30
66585: PUSH
66586: LD_INT 8
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: PPUSH
66599: CALL_OW 72
66603: NOT
66604: IFFALSE 66634
66606: PUSH
66607: LD_EXP 63
66611: PUSH
66612: LD_VAR 0 1
66616: ARRAY
66617: PPUSH
66618: LD_INT 30
66620: PUSH
66621: LD_INT 3
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PPUSH
66628: CALL_OW 72
66632: NOT
66633: AND
66634: IFFALSE 66706
// begin if eng = tmp then
66636: LD_VAR 0 6
66640: PUSH
66641: LD_VAR 0 4
66645: EQUAL
66646: IFFALSE 66650
// exit ;
66648: GO 69275
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66650: LD_ADDR_EXP 105
66654: PUSH
66655: LD_EXP 105
66659: PPUSH
66660: LD_VAR 0 1
66664: PPUSH
66665: LD_INT 1
66667: PPUSH
66668: CALL_OW 1
66672: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
66673: LD_ADDR_VAR 0 2
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: LD_VAR 0 4
66685: PUSH
66686: LD_VAR 0 6
66690: DIFF
66691: PUSH
66692: LD_INT 0
66694: PUSH
66695: LD_INT 0
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: ST_TO_ADDR
// exit ;
66704: GO 69275
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66706: LD_EXP 90
66710: PUSH
66711: LD_EXP 89
66715: PUSH
66716: LD_VAR 0 1
66720: ARRAY
66721: ARRAY
66722: IFFALSE 66780
66724: PUSH
66725: LD_EXP 63
66729: PUSH
66730: LD_VAR 0 1
66734: ARRAY
66735: PPUSH
66736: LD_INT 2
66738: PUSH
66739: LD_INT 30
66741: PUSH
66742: LD_INT 6
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 30
66751: PUSH
66752: LD_INT 7
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 30
66761: PUSH
66762: LD_INT 8
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: PPUSH
66775: CALL_OW 72
66779: AND
66780: IFFALSE 66810
66782: PUSH
66783: LD_EXP 63
66787: PUSH
66788: LD_VAR 0 1
66792: ARRAY
66793: PPUSH
66794: LD_INT 30
66796: PUSH
66797: LD_INT 3
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PPUSH
66804: CALL_OW 72
66808: NOT
66809: AND
66810: IFFALSE 67026
// begin if sci >= 6 then
66812: LD_VAR 0 8
66816: PUSH
66817: LD_INT 6
66819: GREATEREQUAL
66820: IFFALSE 66824
// exit ;
66822: GO 69275
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66824: LD_ADDR_EXP 105
66828: PUSH
66829: LD_EXP 105
66833: PPUSH
66834: LD_VAR 0 1
66838: PPUSH
66839: LD_INT 2
66841: PPUSH
66842: CALL_OW 1
66846: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66847: LD_ADDR_VAR 0 9
66851: PUSH
66852: LD_VAR 0 4
66856: PUSH
66857: LD_VAR 0 8
66861: DIFF
66862: PPUSH
66863: LD_INT 4
66865: PPUSH
66866: CALL 54010 0 2
66870: ST_TO_ADDR
// p := [ ] ;
66871: LD_ADDR_VAR 0 11
66875: PUSH
66876: EMPTY
66877: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66878: LD_VAR 0 8
66882: PUSH
66883: LD_INT 6
66885: LESS
66886: IFFALSE 66898
66888: PUSH
66889: LD_VAR 0 9
66893: PUSH
66894: LD_INT 6
66896: GREATER
66897: AND
66898: IFFALSE 66979
// begin for i = 1 to 6 - sci do
66900: LD_ADDR_VAR 0 3
66904: PUSH
66905: DOUBLE
66906: LD_INT 1
66908: DEC
66909: ST_TO_ADDR
66910: LD_INT 6
66912: PUSH
66913: LD_VAR 0 8
66917: MINUS
66918: PUSH
66919: FOR_TO
66920: IFFALSE 66975
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66922: LD_ADDR_VAR 0 11
66926: PUSH
66927: LD_VAR 0 11
66931: PPUSH
66932: LD_VAR 0 11
66936: PUSH
66937: LD_INT 1
66939: PLUS
66940: PPUSH
66941: LD_VAR 0 9
66945: PUSH
66946: LD_INT 1
66948: ARRAY
66949: PPUSH
66950: CALL_OW 2
66954: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66955: LD_ADDR_VAR 0 9
66959: PUSH
66960: LD_VAR 0 9
66964: PPUSH
66965: LD_INT 1
66967: PPUSH
66968: CALL_OW 3
66972: ST_TO_ADDR
// end ;
66973: GO 66919
66975: POP
66976: POP
// end else
66977: GO 66999
// if sort then
66979: LD_VAR 0 9
66983: IFFALSE 66999
// p := sort [ 1 ] ;
66985: LD_ADDR_VAR 0 11
66989: PUSH
66990: LD_VAR 0 9
66994: PUSH
66995: LD_INT 1
66997: ARRAY
66998: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
66999: LD_ADDR_VAR 0 2
67003: PUSH
67004: LD_INT 0
67006: PUSH
67007: LD_INT 0
67009: PUSH
67010: LD_INT 0
67012: PUSH
67013: LD_VAR 0 11
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: ST_TO_ADDR
// exit ;
67024: GO 69275
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67026: LD_EXP 90
67030: PUSH
67031: LD_EXP 89
67035: PUSH
67036: LD_VAR 0 1
67040: ARRAY
67041: ARRAY
67042: IFFALSE 67100
67044: PUSH
67045: LD_EXP 63
67049: PUSH
67050: LD_VAR 0 1
67054: ARRAY
67055: PPUSH
67056: LD_INT 2
67058: PUSH
67059: LD_INT 30
67061: PUSH
67062: LD_INT 6
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 30
67071: PUSH
67072: LD_INT 7
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 30
67081: PUSH
67082: LD_INT 8
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: PPUSH
67095: CALL_OW 72
67099: AND
67100: IFFALSE 67129
67102: PUSH
67103: LD_EXP 63
67107: PUSH
67108: LD_VAR 0 1
67112: ARRAY
67113: PPUSH
67114: LD_INT 30
67116: PUSH
67117: LD_INT 3
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PPUSH
67124: CALL_OW 72
67128: AND
67129: IFFALSE 67869
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67131: LD_ADDR_EXP 105
67135: PUSH
67136: LD_EXP 105
67140: PPUSH
67141: LD_VAR 0 1
67145: PPUSH
67146: LD_INT 3
67148: PPUSH
67149: CALL_OW 1
67153: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67154: LD_ADDR_VAR 0 2
67158: PUSH
67159: LD_INT 0
67161: PUSH
67162: LD_INT 0
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: ST_TO_ADDR
// if not eng then
67177: LD_VAR 0 6
67181: NOT
67182: IFFALSE 67245
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67184: LD_ADDR_VAR 0 11
67188: PUSH
67189: LD_VAR 0 4
67193: PPUSH
67194: LD_INT 2
67196: PPUSH
67197: CALL 54010 0 2
67201: PUSH
67202: LD_INT 1
67204: ARRAY
67205: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67206: LD_ADDR_VAR 0 2
67210: PUSH
67211: LD_VAR 0 2
67215: PPUSH
67216: LD_INT 2
67218: PPUSH
67219: LD_VAR 0 11
67223: PPUSH
67224: CALL_OW 1
67228: ST_TO_ADDR
// tmp := tmp diff p ;
67229: LD_ADDR_VAR 0 4
67233: PUSH
67234: LD_VAR 0 4
67238: PUSH
67239: LD_VAR 0 11
67243: DIFF
67244: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67245: LD_VAR 0 4
67249: IFFALSE 67261
67251: PUSH
67252: LD_VAR 0 8
67256: PUSH
67257: LD_INT 6
67259: LESS
67260: AND
67261: IFFALSE 67449
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67263: LD_ADDR_VAR 0 9
67267: PUSH
67268: LD_VAR 0 4
67272: PUSH
67273: LD_VAR 0 8
67277: PUSH
67278: LD_VAR 0 7
67282: UNION
67283: DIFF
67284: PPUSH
67285: LD_INT 4
67287: PPUSH
67288: CALL 54010 0 2
67292: ST_TO_ADDR
// p := [ ] ;
67293: LD_ADDR_VAR 0 11
67297: PUSH
67298: EMPTY
67299: ST_TO_ADDR
// if sort then
67300: LD_VAR 0 9
67304: IFFALSE 67420
// for i = 1 to 6 - sci do
67306: LD_ADDR_VAR 0 3
67310: PUSH
67311: DOUBLE
67312: LD_INT 1
67314: DEC
67315: ST_TO_ADDR
67316: LD_INT 6
67318: PUSH
67319: LD_VAR 0 8
67323: MINUS
67324: PUSH
67325: FOR_TO
67326: IFFALSE 67418
// begin if i = sort then
67328: LD_VAR 0 3
67332: PUSH
67333: LD_VAR 0 9
67337: EQUAL
67338: IFFALSE 67342
// break ;
67340: GO 67418
// if GetClass ( i ) = 4 then
67342: LD_VAR 0 3
67346: PPUSH
67347: CALL_OW 257
67351: PUSH
67352: LD_INT 4
67354: EQUAL
67355: IFFALSE 67359
// continue ;
67357: GO 67325
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67359: LD_ADDR_VAR 0 11
67363: PUSH
67364: LD_VAR 0 11
67368: PPUSH
67369: LD_VAR 0 11
67373: PUSH
67374: LD_INT 1
67376: PLUS
67377: PPUSH
67378: LD_VAR 0 9
67382: PUSH
67383: LD_VAR 0 3
67387: ARRAY
67388: PPUSH
67389: CALL_OW 2
67393: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67394: LD_ADDR_VAR 0 4
67398: PUSH
67399: LD_VAR 0 4
67403: PUSH
67404: LD_VAR 0 9
67408: PUSH
67409: LD_VAR 0 3
67413: ARRAY
67414: DIFF
67415: ST_TO_ADDR
// end ;
67416: GO 67325
67418: POP
67419: POP
// if p then
67420: LD_VAR 0 11
67424: IFFALSE 67449
// result := Replace ( result , 4 , p ) ;
67426: LD_ADDR_VAR 0 2
67430: PUSH
67431: LD_VAR 0 2
67435: PPUSH
67436: LD_INT 4
67438: PPUSH
67439: LD_VAR 0 11
67443: PPUSH
67444: CALL_OW 1
67448: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67449: LD_VAR 0 4
67453: IFFALSE 67465
67455: PUSH
67456: LD_VAR 0 7
67460: PUSH
67461: LD_INT 6
67463: LESS
67464: AND
67465: IFFALSE 67653
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67467: LD_ADDR_VAR 0 9
67471: PUSH
67472: LD_VAR 0 4
67476: PUSH
67477: LD_VAR 0 8
67481: PUSH
67482: LD_VAR 0 7
67486: UNION
67487: DIFF
67488: PPUSH
67489: LD_INT 3
67491: PPUSH
67492: CALL 54010 0 2
67496: ST_TO_ADDR
// p := [ ] ;
67497: LD_ADDR_VAR 0 11
67501: PUSH
67502: EMPTY
67503: ST_TO_ADDR
// if sort then
67504: LD_VAR 0 9
67508: IFFALSE 67624
// for i = 1 to 6 - mech do
67510: LD_ADDR_VAR 0 3
67514: PUSH
67515: DOUBLE
67516: LD_INT 1
67518: DEC
67519: ST_TO_ADDR
67520: LD_INT 6
67522: PUSH
67523: LD_VAR 0 7
67527: MINUS
67528: PUSH
67529: FOR_TO
67530: IFFALSE 67622
// begin if i = sort then
67532: LD_VAR 0 3
67536: PUSH
67537: LD_VAR 0 9
67541: EQUAL
67542: IFFALSE 67546
// break ;
67544: GO 67622
// if GetClass ( i ) = 3 then
67546: LD_VAR 0 3
67550: PPUSH
67551: CALL_OW 257
67555: PUSH
67556: LD_INT 3
67558: EQUAL
67559: IFFALSE 67563
// continue ;
67561: GO 67529
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67563: LD_ADDR_VAR 0 11
67567: PUSH
67568: LD_VAR 0 11
67572: PPUSH
67573: LD_VAR 0 11
67577: PUSH
67578: LD_INT 1
67580: PLUS
67581: PPUSH
67582: LD_VAR 0 9
67586: PUSH
67587: LD_VAR 0 3
67591: ARRAY
67592: PPUSH
67593: CALL_OW 2
67597: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67598: LD_ADDR_VAR 0 4
67602: PUSH
67603: LD_VAR 0 4
67607: PUSH
67608: LD_VAR 0 9
67612: PUSH
67613: LD_VAR 0 3
67617: ARRAY
67618: DIFF
67619: ST_TO_ADDR
// end ;
67620: GO 67529
67622: POP
67623: POP
// if p then
67624: LD_VAR 0 11
67628: IFFALSE 67653
// result := Replace ( result , 3 , p ) ;
67630: LD_ADDR_VAR 0 2
67634: PUSH
67635: LD_VAR 0 2
67639: PPUSH
67640: LD_INT 3
67642: PPUSH
67643: LD_VAR 0 11
67647: PPUSH
67648: CALL_OW 1
67652: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67653: LD_VAR 0 4
67657: PUSH
67658: LD_INT 6
67660: GREATER
67661: IFFALSE 67673
67663: PUSH
67664: LD_VAR 0 6
67668: PUSH
67669: LD_INT 6
67671: LESS
67672: AND
67673: IFFALSE 67867
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67675: LD_ADDR_VAR 0 9
67679: PUSH
67680: LD_VAR 0 4
67684: PUSH
67685: LD_VAR 0 8
67689: PUSH
67690: LD_VAR 0 7
67694: UNION
67695: PUSH
67696: LD_VAR 0 6
67700: UNION
67701: DIFF
67702: PPUSH
67703: LD_INT 2
67705: PPUSH
67706: CALL 54010 0 2
67710: ST_TO_ADDR
// p := [ ] ;
67711: LD_ADDR_VAR 0 11
67715: PUSH
67716: EMPTY
67717: ST_TO_ADDR
// if sort then
67718: LD_VAR 0 9
67722: IFFALSE 67838
// for i = 1 to 6 - eng do
67724: LD_ADDR_VAR 0 3
67728: PUSH
67729: DOUBLE
67730: LD_INT 1
67732: DEC
67733: ST_TO_ADDR
67734: LD_INT 6
67736: PUSH
67737: LD_VAR 0 6
67741: MINUS
67742: PUSH
67743: FOR_TO
67744: IFFALSE 67836
// begin if i = sort then
67746: LD_VAR 0 3
67750: PUSH
67751: LD_VAR 0 9
67755: EQUAL
67756: IFFALSE 67760
// break ;
67758: GO 67836
// if GetClass ( i ) = 2 then
67760: LD_VAR 0 3
67764: PPUSH
67765: CALL_OW 257
67769: PUSH
67770: LD_INT 2
67772: EQUAL
67773: IFFALSE 67777
// continue ;
67775: GO 67743
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67777: LD_ADDR_VAR 0 11
67781: PUSH
67782: LD_VAR 0 11
67786: PPUSH
67787: LD_VAR 0 11
67791: PUSH
67792: LD_INT 1
67794: PLUS
67795: PPUSH
67796: LD_VAR 0 9
67800: PUSH
67801: LD_VAR 0 3
67805: ARRAY
67806: PPUSH
67807: CALL_OW 2
67811: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67812: LD_ADDR_VAR 0 4
67816: PUSH
67817: LD_VAR 0 4
67821: PUSH
67822: LD_VAR 0 9
67826: PUSH
67827: LD_VAR 0 3
67831: ARRAY
67832: DIFF
67833: ST_TO_ADDR
// end ;
67834: GO 67743
67836: POP
67837: POP
// if p then
67838: LD_VAR 0 11
67842: IFFALSE 67867
// result := Replace ( result , 2 , p ) ;
67844: LD_ADDR_VAR 0 2
67848: PUSH
67849: LD_VAR 0 2
67853: PPUSH
67854: LD_INT 2
67856: PPUSH
67857: LD_VAR 0 11
67861: PPUSH
67862: CALL_OW 1
67866: ST_TO_ADDR
// end ; exit ;
67867: GO 69275
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67869: LD_EXP 90
67873: PUSH
67874: LD_EXP 89
67878: PUSH
67879: LD_VAR 0 1
67883: ARRAY
67884: ARRAY
67885: NOT
67886: IFFALSE 67915
67888: PUSH
67889: LD_EXP 63
67893: PUSH
67894: LD_VAR 0 1
67898: ARRAY
67899: PPUSH
67900: LD_INT 30
67902: PUSH
67903: LD_INT 3
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PPUSH
67910: CALL_OW 72
67914: AND
67915: IFFALSE 67929
67917: PUSH
67918: LD_EXP 68
67922: PUSH
67923: LD_VAR 0 1
67927: ARRAY
67928: AND
67929: IFFALSE 68543
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67931: LD_ADDR_EXP 105
67935: PUSH
67936: LD_EXP 105
67940: PPUSH
67941: LD_VAR 0 1
67945: PPUSH
67946: LD_INT 5
67948: PPUSH
67949: CALL_OW 1
67953: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67954: LD_ADDR_VAR 0 2
67958: PUSH
67959: LD_INT 0
67961: PUSH
67962: LD_INT 0
67964: PUSH
67965: LD_INT 0
67967: PUSH
67968: LD_INT 0
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: ST_TO_ADDR
// if sci > 1 then
67977: LD_VAR 0 8
67981: PUSH
67982: LD_INT 1
67984: GREATER
67985: IFFALSE 68013
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
67987: LD_ADDR_VAR 0 4
67991: PUSH
67992: LD_VAR 0 4
67996: PUSH
67997: LD_VAR 0 8
68001: PUSH
68002: LD_VAR 0 8
68006: PUSH
68007: LD_INT 1
68009: ARRAY
68010: DIFF
68011: DIFF
68012: ST_TO_ADDR
// if tmp and not sci then
68013: LD_VAR 0 4
68017: IFFALSE 68026
68019: PUSH
68020: LD_VAR 0 8
68024: NOT
68025: AND
68026: IFFALSE 68095
// begin sort := SortBySkill ( tmp , 4 ) ;
68028: LD_ADDR_VAR 0 9
68032: PUSH
68033: LD_VAR 0 4
68037: PPUSH
68038: LD_INT 4
68040: PPUSH
68041: CALL 54010 0 2
68045: ST_TO_ADDR
// if sort then
68046: LD_VAR 0 9
68050: IFFALSE 68066
// p := sort [ 1 ] ;
68052: LD_ADDR_VAR 0 11
68056: PUSH
68057: LD_VAR 0 9
68061: PUSH
68062: LD_INT 1
68064: ARRAY
68065: ST_TO_ADDR
// if p then
68066: LD_VAR 0 11
68070: IFFALSE 68095
// result := Replace ( result , 4 , p ) ;
68072: LD_ADDR_VAR 0 2
68076: PUSH
68077: LD_VAR 0 2
68081: PPUSH
68082: LD_INT 4
68084: PPUSH
68085: LD_VAR 0 11
68089: PPUSH
68090: CALL_OW 1
68094: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68095: LD_ADDR_VAR 0 4
68099: PUSH
68100: LD_VAR 0 4
68104: PUSH
68105: LD_VAR 0 7
68109: DIFF
68110: ST_TO_ADDR
// if tmp and mech < 6 then
68111: LD_VAR 0 4
68115: IFFALSE 68127
68117: PUSH
68118: LD_VAR 0 7
68122: PUSH
68123: LD_INT 6
68125: LESS
68126: AND
68127: IFFALSE 68315
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68129: LD_ADDR_VAR 0 9
68133: PUSH
68134: LD_VAR 0 4
68138: PUSH
68139: LD_VAR 0 8
68143: PUSH
68144: LD_VAR 0 7
68148: UNION
68149: DIFF
68150: PPUSH
68151: LD_INT 3
68153: PPUSH
68154: CALL 54010 0 2
68158: ST_TO_ADDR
// p := [ ] ;
68159: LD_ADDR_VAR 0 11
68163: PUSH
68164: EMPTY
68165: ST_TO_ADDR
// if sort then
68166: LD_VAR 0 9
68170: IFFALSE 68286
// for i = 1 to 6 - mech do
68172: LD_ADDR_VAR 0 3
68176: PUSH
68177: DOUBLE
68178: LD_INT 1
68180: DEC
68181: ST_TO_ADDR
68182: LD_INT 6
68184: PUSH
68185: LD_VAR 0 7
68189: MINUS
68190: PUSH
68191: FOR_TO
68192: IFFALSE 68284
// begin if i = sort then
68194: LD_VAR 0 3
68198: PUSH
68199: LD_VAR 0 9
68203: EQUAL
68204: IFFALSE 68208
// break ;
68206: GO 68284
// if GetClass ( i ) = 3 then
68208: LD_VAR 0 3
68212: PPUSH
68213: CALL_OW 257
68217: PUSH
68218: LD_INT 3
68220: EQUAL
68221: IFFALSE 68225
// continue ;
68223: GO 68191
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68225: LD_ADDR_VAR 0 11
68229: PUSH
68230: LD_VAR 0 11
68234: PPUSH
68235: LD_VAR 0 11
68239: PUSH
68240: LD_INT 1
68242: PLUS
68243: PPUSH
68244: LD_VAR 0 9
68248: PUSH
68249: LD_VAR 0 3
68253: ARRAY
68254: PPUSH
68255: CALL_OW 2
68259: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68260: LD_ADDR_VAR 0 4
68264: PUSH
68265: LD_VAR 0 4
68269: PUSH
68270: LD_VAR 0 9
68274: PUSH
68275: LD_VAR 0 3
68279: ARRAY
68280: DIFF
68281: ST_TO_ADDR
// end ;
68282: GO 68191
68284: POP
68285: POP
// if p then
68286: LD_VAR 0 11
68290: IFFALSE 68315
// result := Replace ( result , 3 , p ) ;
68292: LD_ADDR_VAR 0 2
68296: PUSH
68297: LD_VAR 0 2
68301: PPUSH
68302: LD_INT 3
68304: PPUSH
68305: LD_VAR 0 11
68309: PPUSH
68310: CALL_OW 1
68314: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68315: LD_ADDR_VAR 0 4
68319: PUSH
68320: LD_VAR 0 4
68324: PUSH
68325: LD_VAR 0 6
68329: DIFF
68330: ST_TO_ADDR
// if tmp and eng < 6 then
68331: LD_VAR 0 4
68335: IFFALSE 68347
68337: PUSH
68338: LD_VAR 0 6
68342: PUSH
68343: LD_INT 6
68345: LESS
68346: AND
68347: IFFALSE 68541
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68349: LD_ADDR_VAR 0 9
68353: PUSH
68354: LD_VAR 0 4
68358: PUSH
68359: LD_VAR 0 8
68363: PUSH
68364: LD_VAR 0 7
68368: UNION
68369: PUSH
68370: LD_VAR 0 6
68374: UNION
68375: DIFF
68376: PPUSH
68377: LD_INT 2
68379: PPUSH
68380: CALL 54010 0 2
68384: ST_TO_ADDR
// p := [ ] ;
68385: LD_ADDR_VAR 0 11
68389: PUSH
68390: EMPTY
68391: ST_TO_ADDR
// if sort then
68392: LD_VAR 0 9
68396: IFFALSE 68512
// for i = 1 to 6 - eng do
68398: LD_ADDR_VAR 0 3
68402: PUSH
68403: DOUBLE
68404: LD_INT 1
68406: DEC
68407: ST_TO_ADDR
68408: LD_INT 6
68410: PUSH
68411: LD_VAR 0 6
68415: MINUS
68416: PUSH
68417: FOR_TO
68418: IFFALSE 68510
// begin if i = sort then
68420: LD_VAR 0 3
68424: PUSH
68425: LD_VAR 0 9
68429: EQUAL
68430: IFFALSE 68434
// break ;
68432: GO 68510
// if GetClass ( i ) = 2 then
68434: LD_VAR 0 3
68438: PPUSH
68439: CALL_OW 257
68443: PUSH
68444: LD_INT 2
68446: EQUAL
68447: IFFALSE 68451
// continue ;
68449: GO 68417
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68451: LD_ADDR_VAR 0 11
68455: PUSH
68456: LD_VAR 0 11
68460: PPUSH
68461: LD_VAR 0 11
68465: PUSH
68466: LD_INT 1
68468: PLUS
68469: PPUSH
68470: LD_VAR 0 9
68474: PUSH
68475: LD_VAR 0 3
68479: ARRAY
68480: PPUSH
68481: CALL_OW 2
68485: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68486: LD_ADDR_VAR 0 4
68490: PUSH
68491: LD_VAR 0 4
68495: PUSH
68496: LD_VAR 0 9
68500: PUSH
68501: LD_VAR 0 3
68505: ARRAY
68506: DIFF
68507: ST_TO_ADDR
// end ;
68508: GO 68417
68510: POP
68511: POP
// if p then
68512: LD_VAR 0 11
68516: IFFALSE 68541
// result := Replace ( result , 2 , p ) ;
68518: LD_ADDR_VAR 0 2
68522: PUSH
68523: LD_VAR 0 2
68527: PPUSH
68528: LD_INT 2
68530: PPUSH
68531: LD_VAR 0 11
68535: PPUSH
68536: CALL_OW 1
68540: ST_TO_ADDR
// end ; exit ;
68541: GO 69275
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68543: LD_EXP 90
68547: PUSH
68548: LD_EXP 89
68552: PUSH
68553: LD_VAR 0 1
68557: ARRAY
68558: ARRAY
68559: NOT
68560: IFFALSE 68589
68562: PUSH
68563: LD_EXP 63
68567: PUSH
68568: LD_VAR 0 1
68572: ARRAY
68573: PPUSH
68574: LD_INT 30
68576: PUSH
68577: LD_INT 3
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PPUSH
68584: CALL_OW 72
68588: AND
68589: IFFALSE 68604
68591: PUSH
68592: LD_EXP 68
68596: PUSH
68597: LD_VAR 0 1
68601: ARRAY
68602: NOT
68603: AND
68604: IFFALSE 69275
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68606: LD_ADDR_EXP 105
68610: PUSH
68611: LD_EXP 105
68615: PPUSH
68616: LD_VAR 0 1
68620: PPUSH
68621: LD_INT 6
68623: PPUSH
68624: CALL_OW 1
68628: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68629: LD_ADDR_VAR 0 2
68633: PUSH
68634: LD_INT 0
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: LD_INT 0
68642: PUSH
68643: LD_INT 0
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: ST_TO_ADDR
// if sci >= 1 then
68652: LD_VAR 0 8
68656: PUSH
68657: LD_INT 1
68659: GREATEREQUAL
68660: IFFALSE 68682
// tmp := tmp diff sci [ 1 ] ;
68662: LD_ADDR_VAR 0 4
68666: PUSH
68667: LD_VAR 0 4
68671: PUSH
68672: LD_VAR 0 8
68676: PUSH
68677: LD_INT 1
68679: ARRAY
68680: DIFF
68681: ST_TO_ADDR
// if tmp and not sci then
68682: LD_VAR 0 4
68686: IFFALSE 68695
68688: PUSH
68689: LD_VAR 0 8
68693: NOT
68694: AND
68695: IFFALSE 68764
// begin sort := SortBySkill ( tmp , 4 ) ;
68697: LD_ADDR_VAR 0 9
68701: PUSH
68702: LD_VAR 0 4
68706: PPUSH
68707: LD_INT 4
68709: PPUSH
68710: CALL 54010 0 2
68714: ST_TO_ADDR
// if sort then
68715: LD_VAR 0 9
68719: IFFALSE 68735
// p := sort [ 1 ] ;
68721: LD_ADDR_VAR 0 11
68725: PUSH
68726: LD_VAR 0 9
68730: PUSH
68731: LD_INT 1
68733: ARRAY
68734: ST_TO_ADDR
// if p then
68735: LD_VAR 0 11
68739: IFFALSE 68764
// result := Replace ( result , 4 , p ) ;
68741: LD_ADDR_VAR 0 2
68745: PUSH
68746: LD_VAR 0 2
68750: PPUSH
68751: LD_INT 4
68753: PPUSH
68754: LD_VAR 0 11
68758: PPUSH
68759: CALL_OW 1
68763: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68764: LD_ADDR_VAR 0 4
68768: PUSH
68769: LD_VAR 0 4
68773: PUSH
68774: LD_VAR 0 7
68778: DIFF
68779: ST_TO_ADDR
// if tmp and mech < 6 then
68780: LD_VAR 0 4
68784: IFFALSE 68796
68786: PUSH
68787: LD_VAR 0 7
68791: PUSH
68792: LD_INT 6
68794: LESS
68795: AND
68796: IFFALSE 68978
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
68798: LD_ADDR_VAR 0 9
68802: PUSH
68803: LD_VAR 0 4
68807: PUSH
68808: LD_VAR 0 7
68812: DIFF
68813: PPUSH
68814: LD_INT 3
68816: PPUSH
68817: CALL 54010 0 2
68821: ST_TO_ADDR
// p := [ ] ;
68822: LD_ADDR_VAR 0 11
68826: PUSH
68827: EMPTY
68828: ST_TO_ADDR
// if sort then
68829: LD_VAR 0 9
68833: IFFALSE 68949
// for i = 1 to 6 - mech do
68835: LD_ADDR_VAR 0 3
68839: PUSH
68840: DOUBLE
68841: LD_INT 1
68843: DEC
68844: ST_TO_ADDR
68845: LD_INT 6
68847: PUSH
68848: LD_VAR 0 7
68852: MINUS
68853: PUSH
68854: FOR_TO
68855: IFFALSE 68947
// begin if i = sort then
68857: LD_VAR 0 3
68861: PUSH
68862: LD_VAR 0 9
68866: EQUAL
68867: IFFALSE 68871
// break ;
68869: GO 68947
// if GetClass ( i ) = 3 then
68871: LD_VAR 0 3
68875: PPUSH
68876: CALL_OW 257
68880: PUSH
68881: LD_INT 3
68883: EQUAL
68884: IFFALSE 68888
// continue ;
68886: GO 68854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68888: LD_ADDR_VAR 0 11
68892: PUSH
68893: LD_VAR 0 11
68897: PPUSH
68898: LD_VAR 0 11
68902: PUSH
68903: LD_INT 1
68905: PLUS
68906: PPUSH
68907: LD_VAR 0 9
68911: PUSH
68912: LD_VAR 0 3
68916: ARRAY
68917: PPUSH
68918: CALL_OW 2
68922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68923: LD_ADDR_VAR 0 4
68927: PUSH
68928: LD_VAR 0 4
68932: PUSH
68933: LD_VAR 0 9
68937: PUSH
68938: LD_VAR 0 3
68942: ARRAY
68943: DIFF
68944: ST_TO_ADDR
// end ;
68945: GO 68854
68947: POP
68948: POP
// if p then
68949: LD_VAR 0 11
68953: IFFALSE 68978
// result := Replace ( result , 3 , p ) ;
68955: LD_ADDR_VAR 0 2
68959: PUSH
68960: LD_VAR 0 2
68964: PPUSH
68965: LD_INT 3
68967: PPUSH
68968: LD_VAR 0 11
68972: PPUSH
68973: CALL_OW 1
68977: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68978: LD_ADDR_VAR 0 4
68982: PUSH
68983: LD_VAR 0 4
68987: PUSH
68988: LD_VAR 0 6
68992: DIFF
68993: ST_TO_ADDR
// if tmp and eng < 4 then
68994: LD_VAR 0 4
68998: IFFALSE 69010
69000: PUSH
69001: LD_VAR 0 6
69005: PUSH
69006: LD_INT 4
69008: LESS
69009: AND
69010: IFFALSE 69200
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69012: LD_ADDR_VAR 0 9
69016: PUSH
69017: LD_VAR 0 4
69021: PUSH
69022: LD_VAR 0 7
69026: PUSH
69027: LD_VAR 0 6
69031: UNION
69032: DIFF
69033: PPUSH
69034: LD_INT 2
69036: PPUSH
69037: CALL 54010 0 2
69041: ST_TO_ADDR
// p := [ ] ;
69042: LD_ADDR_VAR 0 11
69046: PUSH
69047: EMPTY
69048: ST_TO_ADDR
// if sort then
69049: LD_VAR 0 9
69053: IFFALSE 69169
// for i = 1 to 4 - eng do
69055: LD_ADDR_VAR 0 3
69059: PUSH
69060: DOUBLE
69061: LD_INT 1
69063: DEC
69064: ST_TO_ADDR
69065: LD_INT 4
69067: PUSH
69068: LD_VAR 0 6
69072: MINUS
69073: PUSH
69074: FOR_TO
69075: IFFALSE 69167
// begin if i = sort then
69077: LD_VAR 0 3
69081: PUSH
69082: LD_VAR 0 9
69086: EQUAL
69087: IFFALSE 69091
// break ;
69089: GO 69167
// if GetClass ( i ) = 2 then
69091: LD_VAR 0 3
69095: PPUSH
69096: CALL_OW 257
69100: PUSH
69101: LD_INT 2
69103: EQUAL
69104: IFFALSE 69108
// continue ;
69106: GO 69074
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69108: LD_ADDR_VAR 0 11
69112: PUSH
69113: LD_VAR 0 11
69117: PPUSH
69118: LD_VAR 0 11
69122: PUSH
69123: LD_INT 1
69125: PLUS
69126: PPUSH
69127: LD_VAR 0 9
69131: PUSH
69132: LD_VAR 0 3
69136: ARRAY
69137: PPUSH
69138: CALL_OW 2
69142: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69143: LD_ADDR_VAR 0 4
69147: PUSH
69148: LD_VAR 0 4
69152: PUSH
69153: LD_VAR 0 9
69157: PUSH
69158: LD_VAR 0 3
69162: ARRAY
69163: DIFF
69164: ST_TO_ADDR
// end ;
69165: GO 69074
69167: POP
69168: POP
// if p then
69169: LD_VAR 0 11
69173: IFFALSE 69198
// result := Replace ( result , 2 , p ) ;
69175: LD_ADDR_VAR 0 2
69179: PUSH
69180: LD_VAR 0 2
69184: PPUSH
69185: LD_INT 2
69187: PPUSH
69188: LD_VAR 0 11
69192: PPUSH
69193: CALL_OW 1
69197: ST_TO_ADDR
// end else
69198: GO 69244
// for i = eng downto 5 do
69200: LD_ADDR_VAR 0 3
69204: PUSH
69205: DOUBLE
69206: LD_VAR 0 6
69210: INC
69211: ST_TO_ADDR
69212: LD_INT 5
69214: PUSH
69215: FOR_DOWNTO
69216: IFFALSE 69242
// tmp := tmp union eng [ i ] ;
69218: LD_ADDR_VAR 0 4
69222: PUSH
69223: LD_VAR 0 4
69227: PUSH
69228: LD_VAR 0 6
69232: PUSH
69233: LD_VAR 0 3
69237: ARRAY
69238: UNION
69239: ST_TO_ADDR
69240: GO 69215
69242: POP
69243: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69244: LD_ADDR_VAR 0 2
69248: PUSH
69249: LD_VAR 0 2
69253: PPUSH
69254: LD_INT 1
69256: PPUSH
69257: LD_VAR 0 4
69261: PUSH
69262: LD_VAR 0 5
69266: DIFF
69267: PPUSH
69268: CALL_OW 1
69272: ST_TO_ADDR
// exit ;
69273: GO 69275
// end ; end ;
69275: LD_VAR 0 2
69279: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69280: LD_INT 0
69282: PPUSH
69283: PPUSH
69284: PPUSH
// if not mc_bases then
69285: LD_EXP 63
69289: NOT
69290: IFFALSE 69294
// exit ;
69292: GO 69436
// for i = 1 to mc_bases do
69294: LD_ADDR_VAR 0 2
69298: PUSH
69299: DOUBLE
69300: LD_INT 1
69302: DEC
69303: ST_TO_ADDR
69304: LD_EXP 63
69308: PUSH
69309: FOR_TO
69310: IFFALSE 69427
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_EXP 63
69321: PUSH
69322: LD_VAR 0 2
69326: ARRAY
69327: PPUSH
69328: LD_INT 21
69330: PUSH
69331: LD_INT 3
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 3
69340: PUSH
69341: LD_INT 2
69343: PUSH
69344: LD_INT 30
69346: PUSH
69347: LD_INT 29
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 30
69356: PUSH
69357: LD_INT 30
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: EMPTY
69365: LIST
69366: LIST
69367: LIST
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 3
69375: PUSH
69376: LD_INT 24
69378: PUSH
69379: LD_INT 1000
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: LIST
69394: PPUSH
69395: CALL_OW 72
69399: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69400: LD_ADDR_EXP 64
69404: PUSH
69405: LD_EXP 64
69409: PPUSH
69410: LD_VAR 0 2
69414: PPUSH
69415: LD_VAR 0 3
69419: PPUSH
69420: CALL_OW 1
69424: ST_TO_ADDR
// end ;
69425: GO 69309
69427: POP
69428: POP
// RaiseSailEvent ( 101 ) ;
69429: LD_INT 101
69431: PPUSH
69432: CALL_OW 427
// end ;
69436: LD_VAR 0 1
69440: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69441: LD_INT 0
69443: PPUSH
69444: PPUSH
69445: PPUSH
69446: PPUSH
69447: PPUSH
69448: PPUSH
69449: PPUSH
// if not mc_bases then
69450: LD_EXP 63
69454: NOT
69455: IFFALSE 69459
// exit ;
69457: GO 70023
// for i = 1 to mc_bases do
69459: LD_ADDR_VAR 0 2
69463: PUSH
69464: DOUBLE
69465: LD_INT 1
69467: DEC
69468: ST_TO_ADDR
69469: LD_EXP 63
69473: PUSH
69474: FOR_TO
69475: IFFALSE 70014
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69477: LD_ADDR_VAR 0 5
69481: PUSH
69482: LD_EXP 63
69486: PUSH
69487: LD_VAR 0 2
69491: ARRAY
69492: PUSH
69493: LD_EXP 92
69497: PUSH
69498: LD_VAR 0 2
69502: ARRAY
69503: UNION
69504: PPUSH
69505: LD_INT 21
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 1
69517: PUSH
69518: LD_INT 3
69520: PUSH
69521: LD_INT 54
69523: PUSH
69524: EMPTY
69525: LIST
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 3
69533: PUSH
69534: LD_INT 24
69536: PUSH
69537: LD_INT 1000
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: LIST
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PPUSH
69557: CALL_OW 72
69561: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69562: LD_ADDR_VAR 0 6
69566: PUSH
69567: LD_EXP 63
69571: PUSH
69572: LD_VAR 0 2
69576: ARRAY
69577: PPUSH
69578: LD_INT 21
69580: PUSH
69581: LD_INT 1
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 1
69590: PUSH
69591: LD_INT 3
69593: PUSH
69594: LD_INT 54
69596: PUSH
69597: EMPTY
69598: LIST
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 3
69606: PUSH
69607: LD_INT 24
69609: PUSH
69610: LD_INT 250
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: LIST
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PPUSH
69630: CALL_OW 72
69634: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69635: LD_ADDR_VAR 0 7
69639: PUSH
69640: LD_VAR 0 5
69644: PUSH
69645: LD_VAR 0 6
69649: DIFF
69650: ST_TO_ADDR
// if not need_heal_1 then
69651: LD_VAR 0 6
69655: NOT
69656: IFFALSE 69689
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69658: LD_ADDR_EXP 66
69662: PUSH
69663: LD_EXP 66
69667: PPUSH
69668: LD_VAR 0 2
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PPUSH
69680: EMPTY
69681: PPUSH
69682: CALL 22482 0 3
69686: ST_TO_ADDR
69687: GO 69759
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69689: LD_ADDR_EXP 66
69693: PUSH
69694: LD_EXP 66
69698: PPUSH
69699: LD_VAR 0 2
69703: PUSH
69704: LD_INT 1
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PPUSH
69711: LD_EXP 66
69715: PUSH
69716: LD_VAR 0 2
69720: ARRAY
69721: PUSH
69722: LD_INT 1
69724: ARRAY
69725: PPUSH
69726: LD_INT 3
69728: PUSH
69729: LD_INT 24
69731: PUSH
69732: LD_INT 1000
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PPUSH
69743: CALL_OW 72
69747: PUSH
69748: LD_VAR 0 6
69752: UNION
69753: PPUSH
69754: CALL 22482 0 3
69758: ST_TO_ADDR
// if not need_heal_2 then
69759: LD_VAR 0 7
69763: NOT
69764: IFFALSE 69797
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
69766: LD_ADDR_EXP 66
69770: PUSH
69771: LD_EXP 66
69775: PPUSH
69776: LD_VAR 0 2
69780: PUSH
69781: LD_INT 2
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PPUSH
69788: EMPTY
69789: PPUSH
69790: CALL 22482 0 3
69794: ST_TO_ADDR
69795: GO 69829
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
69797: LD_ADDR_EXP 66
69801: PUSH
69802: LD_EXP 66
69806: PPUSH
69807: LD_VAR 0 2
69811: PUSH
69812: LD_INT 2
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PPUSH
69819: LD_VAR 0 7
69823: PPUSH
69824: CALL 22482 0 3
69828: ST_TO_ADDR
// if need_heal_2 then
69829: LD_VAR 0 7
69833: IFFALSE 69994
// for j in need_heal_2 do
69835: LD_ADDR_VAR 0 3
69839: PUSH
69840: LD_VAR 0 7
69844: PUSH
69845: FOR_IN
69846: IFFALSE 69992
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69848: LD_ADDR_VAR 0 5
69852: PUSH
69853: LD_EXP 63
69857: PUSH
69858: LD_VAR 0 2
69862: ARRAY
69863: PPUSH
69864: LD_INT 2
69866: PUSH
69867: LD_INT 30
69869: PUSH
69870: LD_INT 6
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 30
69879: PUSH
69880: LD_INT 7
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 30
69889: PUSH
69890: LD_INT 8
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 30
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 30
69909: PUSH
69910: LD_INT 1
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: PPUSH
69925: CALL_OW 72
69929: ST_TO_ADDR
// if tmp then
69930: LD_VAR 0 5
69934: IFFALSE 69990
// begin k := NearestUnitToUnit ( tmp , j ) ;
69936: LD_ADDR_VAR 0 4
69940: PUSH
69941: LD_VAR 0 5
69945: PPUSH
69946: LD_VAR 0 3
69950: PPUSH
69951: CALL_OW 74
69955: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69956: LD_VAR 0 3
69960: PPUSH
69961: LD_VAR 0 4
69965: PPUSH
69966: CALL_OW 296
69970: PUSH
69971: LD_INT 5
69973: GREATER
69974: IFFALSE 69990
// ComMoveToNearbyEntrance ( j , k ) ;
69976: LD_VAR 0 3
69980: PPUSH
69981: LD_VAR 0 4
69985: PPUSH
69986: CALL 56409 0 2
// end ; end ;
69990: GO 69845
69992: POP
69993: POP
// if not need_heal_1 and not need_heal_2 then
69994: LD_VAR 0 6
69998: NOT
69999: IFFALSE 70008
70001: PUSH
70002: LD_VAR 0 7
70006: NOT
70007: AND
70008: IFFALSE 70012
// continue ;
70010: GO 69474
// end ;
70012: GO 69474
70014: POP
70015: POP
// RaiseSailEvent ( 102 ) ;
70016: LD_INT 102
70018: PPUSH
70019: CALL_OW 427
// end ;
70023: LD_VAR 0 1
70027: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70028: LD_INT 0
70030: PPUSH
70031: PPUSH
70032: PPUSH
70033: PPUSH
70034: PPUSH
70035: PPUSH
70036: PPUSH
70037: PPUSH
// if not mc_bases then
70038: LD_EXP 63
70042: NOT
70043: IFFALSE 70047
// exit ;
70045: GO 70962
// for i = 1 to mc_bases do
70047: LD_ADDR_VAR 0 2
70051: PUSH
70052: DOUBLE
70053: LD_INT 1
70055: DEC
70056: ST_TO_ADDR
70057: LD_EXP 63
70061: PUSH
70062: FOR_TO
70063: IFFALSE 70960
// begin if not mc_building_need_repair [ i ] then
70065: LD_EXP 64
70069: PUSH
70070: LD_VAR 0 2
70074: ARRAY
70075: NOT
70076: IFFALSE 70261
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70078: LD_ADDR_VAR 0 6
70082: PUSH
70083: LD_EXP 82
70087: PUSH
70088: LD_VAR 0 2
70092: ARRAY
70093: PPUSH
70094: LD_INT 3
70096: PUSH
70097: LD_INT 24
70099: PUSH
70100: LD_INT 1000
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 34
70116: PUSH
70117: LD_INT 13
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 34
70126: PUSH
70127: LD_INT 52
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 34
70136: PUSH
70137: LD_INT 88
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PPUSH
70154: CALL_OW 72
70158: ST_TO_ADDR
// if cranes then
70159: LD_VAR 0 6
70163: IFFALSE 70225
// for j in cranes do
70165: LD_ADDR_VAR 0 3
70169: PUSH
70170: LD_VAR 0 6
70174: PUSH
70175: FOR_IN
70176: IFFALSE 70223
// if not IsInArea ( j , mc_parking [ i ] ) then
70178: LD_VAR 0 3
70182: PPUSH
70183: LD_EXP 87
70187: PUSH
70188: LD_VAR 0 2
70192: ARRAY
70193: PPUSH
70194: CALL_OW 308
70198: NOT
70199: IFFALSE 70221
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70201: LD_VAR 0 3
70205: PPUSH
70206: LD_EXP 87
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: PPUSH
70217: CALL_OW 113
70221: GO 70175
70223: POP
70224: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70225: LD_ADDR_EXP 65
70229: PUSH
70230: LD_EXP 65
70234: PPUSH
70235: LD_VAR 0 2
70239: PPUSH
70240: EMPTY
70241: PPUSH
70242: CALL_OW 1
70246: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70247: LD_VAR 0 2
70251: PPUSH
70252: LD_INT 101
70254: PPUSH
70255: CALL 65053 0 2
// continue ;
70259: GO 70062
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70261: LD_ADDR_EXP 69
70265: PUSH
70266: LD_EXP 69
70270: PPUSH
70271: LD_VAR 0 2
70275: PPUSH
70276: EMPTY
70277: PPUSH
70278: CALL_OW 1
70282: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70283: LD_VAR 0 2
70287: PPUSH
70288: LD_INT 103
70290: PPUSH
70291: CALL 65053 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70295: LD_ADDR_VAR 0 5
70299: PUSH
70300: LD_EXP 63
70304: PUSH
70305: LD_VAR 0 2
70309: ARRAY
70310: PUSH
70311: LD_EXP 92
70315: PUSH
70316: LD_VAR 0 2
70320: ARRAY
70321: UNION
70322: PPUSH
70323: LD_INT 2
70325: PUSH
70326: LD_INT 25
70328: PUSH
70329: LD_INT 2
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 25
70338: PUSH
70339: LD_INT 16
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: LIST
70350: PUSH
70351: EMPTY
70352: LIST
70353: PPUSH
70354: CALL_OW 72
70358: ST_TO_ADDR
// if mc_need_heal [ i ] then
70359: LD_EXP 66
70363: PUSH
70364: LD_VAR 0 2
70368: ARRAY
70369: IFFALSE 70413
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70371: LD_ADDR_VAR 0 5
70375: PUSH
70376: LD_VAR 0 5
70380: PUSH
70381: LD_EXP 66
70385: PUSH
70386: LD_VAR 0 2
70390: ARRAY
70391: PUSH
70392: LD_INT 1
70394: ARRAY
70395: PUSH
70396: LD_EXP 66
70400: PUSH
70401: LD_VAR 0 2
70405: ARRAY
70406: PUSH
70407: LD_INT 2
70409: ARRAY
70410: UNION
70411: DIFF
70412: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70413: LD_ADDR_VAR 0 6
70417: PUSH
70418: LD_EXP 82
70422: PUSH
70423: LD_VAR 0 2
70427: ARRAY
70428: PPUSH
70429: LD_INT 2
70431: PUSH
70432: LD_INT 34
70434: PUSH
70435: LD_INT 13
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 34
70444: PUSH
70445: LD_INT 52
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 34
70454: PUSH
70455: LD_INT 88
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: PPUSH
70468: CALL_OW 72
70472: ST_TO_ADDR
// if cranes then
70473: LD_VAR 0 6
70477: IFFALSE 70649
// begin for j in cranes do
70479: LD_ADDR_VAR 0 3
70483: PUSH
70484: LD_VAR 0 6
70488: PUSH
70489: FOR_IN
70490: IFFALSE 70647
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70492: LD_VAR 0 3
70496: PPUSH
70497: CALL_OW 256
70501: PUSH
70502: LD_INT 1000
70504: EQUAL
70505: IFFALSE 70519
70507: PUSH
70508: LD_VAR 0 3
70512: PPUSH
70513: CALL_OW 314
70517: NOT
70518: AND
70519: IFFALSE 70585
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70521: LD_ADDR_VAR 0 8
70525: PUSH
70526: LD_EXP 64
70530: PUSH
70531: LD_VAR 0 2
70535: ARRAY
70536: PPUSH
70537: LD_VAR 0 3
70541: PPUSH
70542: CALL_OW 74
70546: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70547: LD_VAR 0 8
70551: PPUSH
70552: LD_INT 16
70554: PPUSH
70555: CALL 25461 0 2
70559: PUSH
70560: LD_INT 4
70562: ARRAY
70563: PUSH
70564: LD_INT 10
70566: LESS
70567: IFFALSE 70583
// ComRepairBuilding ( j , to_repair ) ;
70569: LD_VAR 0 3
70573: PPUSH
70574: LD_VAR 0 8
70578: PPUSH
70579: CALL_OW 130
// end else
70583: GO 70645
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70585: LD_VAR 0 3
70589: PPUSH
70590: CALL_OW 256
70594: PUSH
70595: LD_INT 500
70597: LESS
70598: IFFALSE 70623
70600: PUSH
70601: LD_VAR 0 3
70605: PPUSH
70606: LD_EXP 87
70610: PUSH
70611: LD_VAR 0 2
70615: ARRAY
70616: PPUSH
70617: CALL_OW 308
70621: NOT
70622: AND
70623: IFFALSE 70645
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70625: LD_VAR 0 3
70629: PPUSH
70630: LD_EXP 87
70634: PUSH
70635: LD_VAR 0 2
70639: ARRAY
70640: PPUSH
70641: CALL_OW 113
// end ;
70645: GO 70489
70647: POP
70648: POP
// end ; if tmp > 3 then
70649: LD_VAR 0 5
70653: PUSH
70654: LD_INT 3
70656: GREATER
70657: IFFALSE 70677
// tmp := ShrinkArray ( tmp , 4 ) ;
70659: LD_ADDR_VAR 0 5
70663: PUSH
70664: LD_VAR 0 5
70668: PPUSH
70669: LD_INT 4
70671: PPUSH
70672: CALL 55845 0 2
70676: ST_TO_ADDR
// if not tmp then
70677: LD_VAR 0 5
70681: NOT
70682: IFFALSE 70686
// continue ;
70684: GO 70062
// for j in tmp do
70686: LD_ADDR_VAR 0 3
70690: PUSH
70691: LD_VAR 0 5
70695: PUSH
70696: FOR_IN
70697: IFFALSE 70956
// begin if IsInUnit ( j ) then
70699: LD_VAR 0 3
70703: PPUSH
70704: CALL_OW 310
70708: IFFALSE 70719
// ComExitBuilding ( j ) ;
70710: LD_VAR 0 3
70714: PPUSH
70715: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
70719: LD_VAR 0 3
70723: PUSH
70724: LD_EXP 65
70728: PUSH
70729: LD_VAR 0 2
70733: ARRAY
70734: IN
70735: NOT
70736: IFFALSE 70794
// begin SetTag ( j , 101 ) ;
70738: LD_VAR 0 3
70742: PPUSH
70743: LD_INT 101
70745: PPUSH
70746: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
70750: LD_ADDR_EXP 65
70754: PUSH
70755: LD_EXP 65
70759: PPUSH
70760: LD_VAR 0 2
70764: PUSH
70765: LD_EXP 65
70769: PUSH
70770: LD_VAR 0 2
70774: ARRAY
70775: PUSH
70776: LD_INT 1
70778: PLUS
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PPUSH
70784: LD_VAR 0 3
70788: PPUSH
70789: CALL 22482 0 3
70793: ST_TO_ADDR
// end ; wait ( 1 ) ;
70794: LD_INT 1
70796: PPUSH
70797: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
70801: LD_ADDR_VAR 0 7
70805: PUSH
70806: LD_EXP 64
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: ST_TO_ADDR
// if mc_scan [ i ] then
70817: LD_EXP 86
70821: PUSH
70822: LD_VAR 0 2
70826: ARRAY
70827: IFFALSE 70889
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
70829: LD_ADDR_VAR 0 7
70833: PUSH
70834: LD_EXP 64
70838: PUSH
70839: LD_VAR 0 2
70843: ARRAY
70844: PPUSH
70845: LD_INT 3
70847: PUSH
70848: LD_INT 30
70850: PUSH
70851: LD_INT 32
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 30
70860: PUSH
70861: LD_INT 33
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 30
70870: PUSH
70871: LD_INT 31
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: PPUSH
70884: CALL_OW 72
70888: ST_TO_ADDR
// if not to_repair_tmp then
70889: LD_VAR 0 7
70893: NOT
70894: IFFALSE 70898
// continue ;
70896: GO 70696
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70898: LD_ADDR_VAR 0 8
70902: PUSH
70903: LD_VAR 0 7
70907: PPUSH
70908: LD_VAR 0 3
70912: PPUSH
70913: CALL_OW 74
70917: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
70918: LD_VAR 0 8
70922: PPUSH
70923: LD_INT 16
70925: PPUSH
70926: CALL 25461 0 2
70930: PUSH
70931: LD_INT 4
70933: ARRAY
70934: PUSH
70935: LD_INT 14
70937: LESS
70938: IFFALSE 70954
// ComRepairBuilding ( j , to_repair ) ;
70940: LD_VAR 0 3
70944: PPUSH
70945: LD_VAR 0 8
70949: PPUSH
70950: CALL_OW 130
// end ;
70954: GO 70696
70956: POP
70957: POP
// end ;
70958: GO 70062
70960: POP
70961: POP
// end ;
70962: LD_VAR 0 1
70966: RET
// export function MC_Heal ; var i , j , tmp ; begin
70967: LD_INT 0
70969: PPUSH
70970: PPUSH
70971: PPUSH
70972: PPUSH
// if not mc_bases then
70973: LD_EXP 63
70977: NOT
70978: IFFALSE 70982
// exit ;
70980: GO 71388
// for i = 1 to mc_bases do
70982: LD_ADDR_VAR 0 2
70986: PUSH
70987: DOUBLE
70988: LD_INT 1
70990: DEC
70991: ST_TO_ADDR
70992: LD_EXP 63
70996: PUSH
70997: FOR_TO
70998: IFFALSE 71386
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71000: LD_EXP 66
71004: PUSH
71005: LD_VAR 0 2
71009: ARRAY
71010: PUSH
71011: LD_INT 1
71013: ARRAY
71014: NOT
71015: IFFALSE 71034
71017: PUSH
71018: LD_EXP 66
71022: PUSH
71023: LD_VAR 0 2
71027: ARRAY
71028: PUSH
71029: LD_INT 2
71031: ARRAY
71032: NOT
71033: AND
71034: IFFALSE 71072
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71036: LD_ADDR_EXP 67
71040: PUSH
71041: LD_EXP 67
71045: PPUSH
71046: LD_VAR 0 2
71050: PPUSH
71051: EMPTY
71052: PPUSH
71053: CALL_OW 1
71057: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71058: LD_VAR 0 2
71062: PPUSH
71063: LD_INT 102
71065: PPUSH
71066: CALL 65053 0 2
// continue ;
71070: GO 70997
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71072: LD_ADDR_VAR 0 4
71076: PUSH
71077: LD_EXP 63
71081: PUSH
71082: LD_VAR 0 2
71086: ARRAY
71087: PPUSH
71088: LD_INT 25
71090: PUSH
71091: LD_INT 4
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PPUSH
71098: CALL_OW 72
71102: ST_TO_ADDR
// if not tmp then
71103: LD_VAR 0 4
71107: NOT
71108: IFFALSE 71112
// continue ;
71110: GO 70997
// if mc_taming [ i ] then
71112: LD_EXP 94
71116: PUSH
71117: LD_VAR 0 2
71121: ARRAY
71122: IFFALSE 71146
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71124: LD_ADDR_EXP 94
71128: PUSH
71129: LD_EXP 94
71133: PPUSH
71134: LD_VAR 0 2
71138: PPUSH
71139: EMPTY
71140: PPUSH
71141: CALL_OW 1
71145: ST_TO_ADDR
// for j in tmp do
71146: LD_ADDR_VAR 0 3
71150: PUSH
71151: LD_VAR 0 4
71155: PUSH
71156: FOR_IN
71157: IFFALSE 71382
// begin if IsInUnit ( j ) then
71159: LD_VAR 0 3
71163: PPUSH
71164: CALL_OW 310
71168: IFFALSE 71179
// ComExitBuilding ( j ) ;
71170: LD_VAR 0 3
71174: PPUSH
71175: CALL_OW 122
// if not j in mc_healers [ i ] then
71179: LD_VAR 0 3
71183: PUSH
71184: LD_EXP 67
71188: PUSH
71189: LD_VAR 0 2
71193: ARRAY
71194: IN
71195: NOT
71196: IFFALSE 71242
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71198: LD_ADDR_EXP 67
71202: PUSH
71203: LD_EXP 67
71207: PPUSH
71208: LD_VAR 0 2
71212: PUSH
71213: LD_EXP 67
71217: PUSH
71218: LD_VAR 0 2
71222: ARRAY
71223: PUSH
71224: LD_INT 1
71226: PLUS
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PPUSH
71232: LD_VAR 0 3
71236: PPUSH
71237: CALL 22482 0 3
71241: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71242: LD_VAR 0 3
71246: PPUSH
71247: CALL_OW 110
71251: PUSH
71252: LD_INT 102
71254: NONEQUAL
71255: IFFALSE 71269
// SetTag ( j , 102 ) ;
71257: LD_VAR 0 3
71261: PPUSH
71262: LD_INT 102
71264: PPUSH
71265: CALL_OW 109
// Wait ( 3 ) ;
71269: LD_INT 3
71271: PPUSH
71272: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71276: LD_EXP 66
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: PUSH
71287: LD_INT 1
71289: ARRAY
71290: IFFALSE 71322
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71292: LD_VAR 0 3
71296: PPUSH
71297: LD_EXP 66
71301: PUSH
71302: LD_VAR 0 2
71306: ARRAY
71307: PUSH
71308: LD_INT 1
71310: ARRAY
71311: PUSH
71312: LD_INT 1
71314: ARRAY
71315: PPUSH
71316: CALL_OW 128
71320: GO 71380
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71322: LD_VAR 0 3
71326: PPUSH
71327: CALL_OW 314
71331: NOT
71332: IFFALSE 71350
71334: PUSH
71335: LD_EXP 66
71339: PUSH
71340: LD_VAR 0 2
71344: ARRAY
71345: PUSH
71346: LD_INT 2
71348: ARRAY
71349: AND
71350: IFFALSE 71380
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71352: LD_VAR 0 3
71356: PPUSH
71357: LD_EXP 66
71361: PUSH
71362: LD_VAR 0 2
71366: ARRAY
71367: PUSH
71368: LD_INT 2
71370: ARRAY
71371: PUSH
71372: LD_INT 1
71374: ARRAY
71375: PPUSH
71376: CALL_OW 128
// end ;
71380: GO 71156
71382: POP
71383: POP
// end ;
71384: GO 70997
71386: POP
71387: POP
// end ;
71388: LD_VAR 0 1
71392: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71393: LD_INT 0
71395: PPUSH
71396: PPUSH
71397: PPUSH
71398: PPUSH
71399: PPUSH
71400: PPUSH
// if not mc_bases then
71401: LD_EXP 63
71405: NOT
71406: IFFALSE 71410
// exit ;
71408: GO 72581
// for i = 1 to mc_bases do
71410: LD_ADDR_VAR 0 2
71414: PUSH
71415: DOUBLE
71416: LD_INT 1
71418: DEC
71419: ST_TO_ADDR
71420: LD_EXP 63
71424: PUSH
71425: FOR_TO
71426: IFFALSE 72579
// begin if mc_scan [ i ] then
71428: LD_EXP 86
71432: PUSH
71433: LD_VAR 0 2
71437: ARRAY
71438: IFFALSE 71442
// continue ;
71440: GO 71425
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71442: LD_EXP 68
71446: PUSH
71447: LD_VAR 0 2
71451: ARRAY
71452: NOT
71453: IFFALSE 71468
71455: PUSH
71456: LD_EXP 70
71460: PUSH
71461: LD_VAR 0 2
71465: ARRAY
71466: NOT
71467: AND
71468: IFFALSE 71482
71470: PUSH
71471: LD_EXP 69
71475: PUSH
71476: LD_VAR 0 2
71480: ARRAY
71481: AND
71482: IFFALSE 71520
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71484: LD_ADDR_EXP 69
71488: PUSH
71489: LD_EXP 69
71493: PPUSH
71494: LD_VAR 0 2
71498: PPUSH
71499: EMPTY
71500: PPUSH
71501: CALL_OW 1
71505: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71506: LD_VAR 0 2
71510: PPUSH
71511: LD_INT 103
71513: PPUSH
71514: CALL 65053 0 2
// continue ;
71518: GO 71425
// end ; if mc_construct_list [ i ] then
71520: LD_EXP 70
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: IFFALSE 71750
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71532: LD_ADDR_VAR 0 5
71536: PUSH
71537: LD_EXP 63
71541: PUSH
71542: LD_VAR 0 2
71546: ARRAY
71547: PPUSH
71548: LD_INT 25
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PPUSH
71558: CALL_OW 72
71562: PUSH
71563: LD_EXP 65
71567: PUSH
71568: LD_VAR 0 2
71572: ARRAY
71573: DIFF
71574: ST_TO_ADDR
// if not tmp then
71575: LD_VAR 0 5
71579: NOT
71580: IFFALSE 71584
// continue ;
71582: GO 71425
// for j in tmp do
71584: LD_ADDR_VAR 0 3
71588: PUSH
71589: LD_VAR 0 5
71593: PUSH
71594: FOR_IN
71595: IFFALSE 71746
// begin if not mc_builders [ i ] then
71597: LD_EXP 69
71601: PUSH
71602: LD_VAR 0 2
71606: ARRAY
71607: NOT
71608: IFFALSE 71666
// begin SetTag ( j , 103 ) ;
71610: LD_VAR 0 3
71614: PPUSH
71615: LD_INT 103
71617: PPUSH
71618: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71622: LD_ADDR_EXP 69
71626: PUSH
71627: LD_EXP 69
71631: PPUSH
71632: LD_VAR 0 2
71636: PUSH
71637: LD_EXP 69
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: PUSH
71648: LD_INT 1
71650: PLUS
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PPUSH
71656: LD_VAR 0 3
71660: PPUSH
71661: CALL 22482 0 3
71665: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71666: LD_VAR 0 3
71670: PPUSH
71671: CALL_OW 310
71675: IFFALSE 71686
// ComExitBuilding ( j ) ;
71677: LD_VAR 0 3
71681: PPUSH
71682: CALL_OW 122
// wait ( 3 ) ;
71686: LD_INT 3
71688: PPUSH
71689: CALL_OW 67
// if not mc_construct_list [ i ] then
71693: LD_EXP 70
71697: PUSH
71698: LD_VAR 0 2
71702: ARRAY
71703: NOT
71704: IFFALSE 71708
// break ;
71706: GO 71746
// if not HasTask ( j ) then
71708: LD_VAR 0 3
71712: PPUSH
71713: CALL_OW 314
71717: NOT
71718: IFFALSE 71744
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
71720: LD_VAR 0 3
71724: PPUSH
71725: LD_EXP 70
71729: PUSH
71730: LD_VAR 0 2
71734: ARRAY
71735: PUSH
71736: LD_INT 1
71738: ARRAY
71739: PPUSH
71740: CALL 25734 0 2
// end ;
71744: GO 71594
71746: POP
71747: POP
// end else
71748: GO 72577
// if mc_build_list [ i ] then
71750: LD_EXP 68
71754: PUSH
71755: LD_VAR 0 2
71759: ARRAY
71760: IFFALSE 72577
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
71762: LD_EXP 68
71766: PUSH
71767: LD_VAR 0 2
71771: ARRAY
71772: PUSH
71773: LD_INT 1
71775: ARRAY
71776: PUSH
71777: LD_INT 1
71779: ARRAY
71780: PPUSH
71781: CALL 25558 0 1
71785: IFFALSE 71833
71787: PUSH
71788: LD_EXP 63
71792: PUSH
71793: LD_VAR 0 2
71797: ARRAY
71798: PPUSH
71799: LD_INT 2
71801: PUSH
71802: LD_INT 30
71804: PUSH
71805: LD_INT 2
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 30
71814: PUSH
71815: LD_INT 3
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: PPUSH
71827: CALL_OW 72
71831: NOT
71832: AND
71833: IFFALSE 71938
// begin for j = 1 to mc_build_list [ i ] do
71835: LD_ADDR_VAR 0 3
71839: PUSH
71840: DOUBLE
71841: LD_INT 1
71843: DEC
71844: ST_TO_ADDR
71845: LD_EXP 68
71849: PUSH
71850: LD_VAR 0 2
71854: ARRAY
71855: PUSH
71856: FOR_TO
71857: IFFALSE 71936
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71859: LD_EXP 68
71863: PUSH
71864: LD_VAR 0 2
71868: ARRAY
71869: PUSH
71870: LD_VAR 0 3
71874: ARRAY
71875: PUSH
71876: LD_INT 1
71878: ARRAY
71879: PUSH
71880: LD_INT 2
71882: EQUAL
71883: IFFALSE 71934
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71885: LD_ADDR_EXP 68
71889: PUSH
71890: LD_EXP 68
71894: PPUSH
71895: LD_VAR 0 2
71899: PPUSH
71900: LD_EXP 68
71904: PUSH
71905: LD_VAR 0 2
71909: ARRAY
71910: PPUSH
71911: LD_VAR 0 3
71915: PPUSH
71916: LD_INT 1
71918: PPUSH
71919: LD_INT 0
71921: PPUSH
71922: CALL 21890 0 4
71926: PPUSH
71927: CALL_OW 1
71931: ST_TO_ADDR
// break ;
71932: GO 71936
// end ;
71934: GO 71856
71936: POP
71937: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71938: LD_ADDR_VAR 0 6
71942: PUSH
71943: LD_EXP 63
71947: PUSH
71948: LD_VAR 0 2
71952: ARRAY
71953: PPUSH
71954: LD_INT 2
71956: PUSH
71957: LD_INT 30
71959: PUSH
71960: LD_INT 0
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 30
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: LIST
71981: PPUSH
71982: CALL_OW 72
71986: ST_TO_ADDR
// for k := 1 to depot do
71987: LD_ADDR_VAR 0 4
71991: PUSH
71992: DOUBLE
71993: LD_INT 1
71995: DEC
71996: ST_TO_ADDR
71997: LD_VAR 0 6
72001: PUSH
72002: FOR_TO
72003: IFFALSE 72575
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72005: LD_EXP 68
72009: PUSH
72010: LD_VAR 0 2
72014: ARRAY
72015: PUSH
72016: LD_INT 1
72018: ARRAY
72019: PUSH
72020: LD_INT 1
72022: ARRAY
72023: PUSH
72024: LD_INT 0
72026: EQUAL
72027: IFTRUE 72122
72029: PUSH
72030: LD_VAR 0 6
72034: PUSH
72035: LD_VAR 0 4
72039: ARRAY
72040: PPUSH
72041: LD_EXP 68
72045: PUSH
72046: LD_VAR 0 2
72050: ARRAY
72051: PUSH
72052: LD_INT 1
72054: ARRAY
72055: PUSH
72056: LD_INT 1
72058: ARRAY
72059: PPUSH
72060: LD_EXP 68
72064: PUSH
72065: LD_VAR 0 2
72069: ARRAY
72070: PUSH
72071: LD_INT 1
72073: ARRAY
72074: PUSH
72075: LD_INT 2
72077: ARRAY
72078: PPUSH
72079: LD_EXP 68
72083: PUSH
72084: LD_VAR 0 2
72088: ARRAY
72089: PUSH
72090: LD_INT 1
72092: ARRAY
72093: PUSH
72094: LD_INT 3
72096: ARRAY
72097: PPUSH
72098: LD_EXP 68
72102: PUSH
72103: LD_VAR 0 2
72107: ARRAY
72108: PUSH
72109: LD_INT 1
72111: ARRAY
72112: PUSH
72113: LD_INT 4
72115: ARRAY
72116: PPUSH
72117: CALL 31038 0 5
72121: OR
72122: IFFALSE 72403
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72124: LD_ADDR_VAR 0 5
72128: PUSH
72129: LD_EXP 63
72133: PUSH
72134: LD_VAR 0 2
72138: ARRAY
72139: PPUSH
72140: LD_INT 25
72142: PUSH
72143: LD_INT 2
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PPUSH
72150: CALL_OW 72
72154: PUSH
72155: LD_EXP 65
72159: PUSH
72160: LD_VAR 0 2
72164: ARRAY
72165: DIFF
72166: ST_TO_ADDR
// if not tmp then
72167: LD_VAR 0 5
72171: NOT
72172: IFFALSE 72176
// continue ;
72174: GO 72002
// for j in tmp do
72176: LD_ADDR_VAR 0 3
72180: PUSH
72181: LD_VAR 0 5
72185: PUSH
72186: FOR_IN
72187: IFFALSE 72399
// begin if not mc_builders [ i ] then
72189: LD_EXP 69
72193: PUSH
72194: LD_VAR 0 2
72198: ARRAY
72199: NOT
72200: IFFALSE 72258
// begin SetTag ( j , 103 ) ;
72202: LD_VAR 0 3
72206: PPUSH
72207: LD_INT 103
72209: PPUSH
72210: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72214: LD_ADDR_EXP 69
72218: PUSH
72219: LD_EXP 69
72223: PPUSH
72224: LD_VAR 0 2
72228: PUSH
72229: LD_EXP 69
72233: PUSH
72234: LD_VAR 0 2
72238: ARRAY
72239: PUSH
72240: LD_INT 1
72242: PLUS
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PPUSH
72248: LD_VAR 0 3
72252: PPUSH
72253: CALL 22482 0 3
72257: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72258: LD_VAR 0 3
72262: PPUSH
72263: CALL_OW 310
72267: IFFALSE 72278
// ComExitBuilding ( j ) ;
72269: LD_VAR 0 3
72273: PPUSH
72274: CALL_OW 122
// wait ( 3 ) ;
72278: LD_INT 3
72280: PPUSH
72281: CALL_OW 67
// if not mc_build_list [ i ] then
72285: LD_EXP 68
72289: PUSH
72290: LD_VAR 0 2
72294: ARRAY
72295: NOT
72296: IFFALSE 72300
// break ;
72298: GO 72399
// if not HasTask ( j ) then
72300: LD_VAR 0 3
72304: PPUSH
72305: CALL_OW 314
72309: NOT
72310: IFFALSE 72397
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72312: LD_VAR 0 3
72316: PPUSH
72317: LD_EXP 68
72321: PUSH
72322: LD_VAR 0 2
72326: ARRAY
72327: PUSH
72328: LD_INT 1
72330: ARRAY
72331: PUSH
72332: LD_INT 1
72334: ARRAY
72335: PPUSH
72336: LD_EXP 68
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: LD_INT 1
72349: ARRAY
72350: PUSH
72351: LD_INT 2
72353: ARRAY
72354: PPUSH
72355: LD_EXP 68
72359: PUSH
72360: LD_VAR 0 2
72364: ARRAY
72365: PUSH
72366: LD_INT 1
72368: ARRAY
72369: PUSH
72370: LD_INT 3
72372: ARRAY
72373: PPUSH
72374: LD_EXP 68
72378: PUSH
72379: LD_VAR 0 2
72383: ARRAY
72384: PUSH
72385: LD_INT 1
72387: ARRAY
72388: PUSH
72389: LD_INT 4
72391: ARRAY
72392: PPUSH
72393: CALL_OW 145
// end ;
72397: GO 72186
72399: POP
72400: POP
// end else
72401: GO 72573
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72403: LD_EXP 63
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: PPUSH
72414: LD_EXP 68
72418: PUSH
72419: LD_VAR 0 2
72423: ARRAY
72424: PUSH
72425: LD_INT 1
72427: ARRAY
72428: PUSH
72429: LD_INT 1
72431: ARRAY
72432: PPUSH
72433: LD_EXP 68
72437: PUSH
72438: LD_VAR 0 2
72442: ARRAY
72443: PUSH
72444: LD_INT 1
72446: ARRAY
72447: PUSH
72448: LD_INT 2
72450: ARRAY
72451: PPUSH
72452: LD_EXP 68
72456: PUSH
72457: LD_VAR 0 2
72461: ARRAY
72462: PUSH
72463: LD_INT 1
72465: ARRAY
72466: PUSH
72467: LD_INT 3
72469: ARRAY
72470: PPUSH
72471: LD_EXP 68
72475: PUSH
72476: LD_VAR 0 2
72480: ARRAY
72481: PUSH
72482: LD_INT 1
72484: ARRAY
72485: PUSH
72486: LD_INT 4
72488: ARRAY
72489: PPUSH
72490: LD_EXP 63
72494: PUSH
72495: LD_VAR 0 2
72499: ARRAY
72500: PPUSH
72501: LD_INT 21
72503: PUSH
72504: LD_INT 3
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PPUSH
72511: CALL_OW 72
72515: PPUSH
72516: EMPTY
72517: PPUSH
72518: CALL 29774 0 7
72522: NOT
72523: IFFALSE 72573
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72525: LD_ADDR_EXP 68
72529: PUSH
72530: LD_EXP 68
72534: PPUSH
72535: LD_VAR 0 2
72539: PPUSH
72540: LD_EXP 68
72544: PUSH
72545: LD_VAR 0 2
72549: ARRAY
72550: PPUSH
72551: LD_INT 1
72553: PPUSH
72554: LD_INT 1
72556: NEG
72557: PPUSH
72558: LD_INT 0
72560: PPUSH
72561: CALL 21890 0 4
72565: PPUSH
72566: CALL_OW 1
72570: ST_TO_ADDR
// continue ;
72571: GO 72002
// end ; end ;
72573: GO 72002
72575: POP
72576: POP
// end ; end ;
72577: GO 71425
72579: POP
72580: POP
// end ;
72581: LD_VAR 0 1
72585: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72586: LD_INT 0
72588: PPUSH
72589: PPUSH
72590: PPUSH
72591: PPUSH
72592: PPUSH
72593: PPUSH
// if not mc_bases then
72594: LD_EXP 63
72598: NOT
72599: IFFALSE 72603
// exit ;
72601: GO 73036
// for i = 1 to mc_bases do
72603: LD_ADDR_VAR 0 2
72607: PUSH
72608: DOUBLE
72609: LD_INT 1
72611: DEC
72612: ST_TO_ADDR
72613: LD_EXP 63
72617: PUSH
72618: FOR_TO
72619: IFFALSE 73034
// begin tmp := mc_build_upgrade [ i ] ;
72621: LD_ADDR_VAR 0 4
72625: PUSH
72626: LD_EXP 95
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72637: LD_ADDR_VAR 0 6
72641: PUSH
72642: LD_EXP 96
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PPUSH
72653: LD_INT 2
72655: PUSH
72656: LD_INT 30
72658: PUSH
72659: LD_INT 6
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 30
72668: PUSH
72669: LD_INT 7
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: LIST
72680: PPUSH
72681: CALL_OW 72
72685: ST_TO_ADDR
// if not tmp and not lab then
72686: LD_VAR 0 4
72690: NOT
72691: IFFALSE 72700
72693: PUSH
72694: LD_VAR 0 6
72698: NOT
72699: AND
72700: IFFALSE 72704
// continue ;
72702: GO 72618
// if tmp then
72704: LD_VAR 0 4
72708: IFFALSE 72828
// for j in tmp do
72710: LD_ADDR_VAR 0 3
72714: PUSH
72715: LD_VAR 0 4
72719: PUSH
72720: FOR_IN
72721: IFFALSE 72826
// begin if UpgradeCost ( j ) then
72723: LD_VAR 0 3
72727: PPUSH
72728: CALL 29426 0 1
72732: IFFALSE 72824
// begin ComUpgrade ( j ) ;
72734: LD_VAR 0 3
72738: PPUSH
72739: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
72743: LD_ADDR_EXP 95
72747: PUSH
72748: LD_EXP 95
72752: PPUSH
72753: LD_VAR 0 2
72757: PPUSH
72758: LD_EXP 95
72762: PUSH
72763: LD_VAR 0 2
72767: ARRAY
72768: PUSH
72769: LD_VAR 0 3
72773: DIFF
72774: PPUSH
72775: CALL_OW 1
72779: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72780: LD_ADDR_EXP 70
72784: PUSH
72785: LD_EXP 70
72789: PPUSH
72790: LD_VAR 0 2
72794: PUSH
72795: LD_EXP 70
72799: PUSH
72800: LD_VAR 0 2
72804: ARRAY
72805: PUSH
72806: LD_INT 1
72808: PLUS
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PPUSH
72814: LD_VAR 0 3
72818: PPUSH
72819: CALL 22482 0 3
72823: ST_TO_ADDR
// end ; end ;
72824: GO 72720
72826: POP
72827: POP
// if not lab or not mc_lab_upgrade [ i ] then
72828: LD_VAR 0 6
72832: NOT
72833: IFTRUE 72848
72835: PUSH
72836: LD_EXP 97
72840: PUSH
72841: LD_VAR 0 2
72845: ARRAY
72846: NOT
72847: OR
72848: IFFALSE 72852
// continue ;
72850: GO 72618
// for j in lab do
72852: LD_ADDR_VAR 0 3
72856: PUSH
72857: LD_VAR 0 6
72861: PUSH
72862: FOR_IN
72863: IFFALSE 73030
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72865: LD_VAR 0 3
72869: PPUSH
72870: CALL_OW 266
72874: PUSH
72875: LD_INT 6
72877: PUSH
72878: LD_INT 7
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: IN
72885: IFFALSE 72902
72887: PUSH
72888: LD_VAR 0 3
72892: PPUSH
72893: CALL_OW 461
72897: PUSH
72898: LD_INT 1
72900: NONEQUAL
72901: AND
72902: IFFALSE 73028
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72904: LD_VAR 0 3
72908: PPUSH
72909: LD_EXP 97
72913: PUSH
72914: LD_VAR 0 2
72918: ARRAY
72919: PUSH
72920: LD_INT 1
72922: ARRAY
72923: PPUSH
72924: CALL 29635 0 2
72928: IFFALSE 73028
// begin ComCancel ( j ) ;
72930: LD_VAR 0 3
72934: PPUSH
72935: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72939: LD_VAR 0 3
72943: PPUSH
72944: LD_EXP 97
72948: PUSH
72949: LD_VAR 0 2
72953: ARRAY
72954: PUSH
72955: LD_INT 1
72957: ARRAY
72958: PPUSH
72959: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72963: LD_VAR 0 3
72967: PUSH
72968: LD_EXP 70
72972: PUSH
72973: LD_VAR 0 2
72977: ARRAY
72978: IN
72979: NOT
72980: IFFALSE 73026
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72982: LD_ADDR_EXP 70
72986: PUSH
72987: LD_EXP 70
72991: PPUSH
72992: LD_VAR 0 2
72996: PUSH
72997: LD_EXP 70
73001: PUSH
73002: LD_VAR 0 2
73006: ARRAY
73007: PUSH
73008: LD_INT 1
73010: PLUS
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PPUSH
73016: LD_VAR 0 3
73020: PPUSH
73021: CALL 22482 0 3
73025: ST_TO_ADDR
// break ;
73026: GO 73030
// end ; end ; end ;
73028: GO 72862
73030: POP
73031: POP
// end ;
73032: GO 72618
73034: POP
73035: POP
// end ;
73036: LD_VAR 0 1
73040: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73041: LD_INT 0
73043: PPUSH
73044: PPUSH
73045: PPUSH
73046: PPUSH
73047: PPUSH
73048: PPUSH
73049: PPUSH
73050: PPUSH
73051: PPUSH
// if not mc_bases then
73052: LD_EXP 63
73056: NOT
73057: IFFALSE 73061
// exit ;
73059: GO 73468
// for i = 1 to mc_bases do
73061: LD_ADDR_VAR 0 2
73065: PUSH
73066: DOUBLE
73067: LD_INT 1
73069: DEC
73070: ST_TO_ADDR
73071: LD_EXP 63
73075: PUSH
73076: FOR_TO
73077: IFFALSE 73466
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73079: LD_EXP 71
73083: PUSH
73084: LD_VAR 0 2
73088: ARRAY
73089: NOT
73090: IFTRUE 73120
73092: PUSH
73093: LD_EXP 63
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PPUSH
73104: LD_INT 30
73106: PUSH
73107: LD_INT 3
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PPUSH
73114: CALL_OW 72
73118: NOT
73119: OR
73120: IFFALSE 73124
// continue ;
73122: GO 73076
// busy := false ;
73124: LD_ADDR_VAR 0 8
73128: PUSH
73129: LD_INT 0
73131: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73132: LD_ADDR_VAR 0 4
73136: PUSH
73137: LD_EXP 63
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PPUSH
73148: LD_INT 30
73150: PUSH
73151: LD_INT 3
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PPUSH
73158: CALL_OW 72
73162: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73163: LD_ADDR_VAR 0 6
73167: PUSH
73168: LD_EXP 71
73172: PUSH
73173: LD_VAR 0 2
73177: ARRAY
73178: PPUSH
73179: LD_INT 2
73181: PUSH
73182: LD_INT 30
73184: PUSH
73185: LD_INT 32
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 30
73194: PUSH
73195: LD_INT 33
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: LIST
73206: PPUSH
73207: CALL_OW 72
73211: ST_TO_ADDR
// if not t then
73212: LD_VAR 0 6
73216: NOT
73217: IFFALSE 73221
// continue ;
73219: GO 73076
// for j in tmp do
73221: LD_ADDR_VAR 0 3
73225: PUSH
73226: LD_VAR 0 4
73230: PUSH
73231: FOR_IN
73232: IFFALSE 73262
// if not BuildingStatus ( j ) = bs_idle then
73234: LD_VAR 0 3
73238: PPUSH
73239: CALL_OW 461
73243: PUSH
73244: LD_INT 2
73246: EQUAL
73247: NOT
73248: IFFALSE 73260
// begin busy := true ;
73250: LD_ADDR_VAR 0 8
73254: PUSH
73255: LD_INT 1
73257: ST_TO_ADDR
// break ;
73258: GO 73262
// end ;
73260: GO 73231
73262: POP
73263: POP
// if busy then
73264: LD_VAR 0 8
73268: IFFALSE 73272
// continue ;
73270: GO 73076
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73272: LD_ADDR_VAR 0 7
73276: PUSH
73277: LD_VAR 0 6
73281: PPUSH
73282: LD_INT 35
73284: PUSH
73285: LD_INT 0
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PPUSH
73292: CALL_OW 72
73296: ST_TO_ADDR
// if tw then
73297: LD_VAR 0 7
73301: IFFALSE 73378
// begin tw := tw [ 1 ] ;
73303: LD_ADDR_VAR 0 7
73307: PUSH
73308: LD_VAR 0 7
73312: PUSH
73313: LD_INT 1
73315: ARRAY
73316: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73317: LD_ADDR_VAR 0 9
73321: PUSH
73322: LD_VAR 0 7
73326: PPUSH
73327: LD_EXP 88
73331: PUSH
73332: LD_VAR 0 2
73336: ARRAY
73337: PPUSH
73338: CALL 27889 0 2
73342: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73343: LD_EXP 102
73347: PUSH
73348: LD_VAR 0 2
73352: ARRAY
73353: IFFALSE 73376
// if not weapon in mc_allowed_tower_weapons [ i ] then
73355: LD_VAR 0 9
73359: PUSH
73360: LD_EXP 102
73364: PUSH
73365: LD_VAR 0 2
73369: ARRAY
73370: IN
73371: NOT
73372: IFFALSE 73376
// continue ;
73374: GO 73076
// end else
73376: GO 73441
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73378: LD_ADDR_VAR 0 5
73382: PUSH
73383: LD_EXP 71
73387: PUSH
73388: LD_VAR 0 2
73392: ARRAY
73393: PPUSH
73394: LD_VAR 0 4
73398: PPUSH
73399: CALL 55074 0 2
73403: ST_TO_ADDR
// if not tmp2 then
73404: LD_VAR 0 5
73408: NOT
73409: IFFALSE 73413
// continue ;
73411: GO 73076
// tw := tmp2 [ 1 ] ;
73413: LD_ADDR_VAR 0 7
73417: PUSH
73418: LD_VAR 0 5
73422: PUSH
73423: LD_INT 1
73425: ARRAY
73426: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73427: LD_ADDR_VAR 0 9
73431: PUSH
73432: LD_VAR 0 5
73436: PUSH
73437: LD_INT 2
73439: ARRAY
73440: ST_TO_ADDR
// end ; if not weapon then
73441: LD_VAR 0 9
73445: NOT
73446: IFFALSE 73450
// continue ;
73448: GO 73076
// ComPlaceWeapon ( tw , weapon ) ;
73450: LD_VAR 0 7
73454: PPUSH
73455: LD_VAR 0 9
73459: PPUSH
73460: CALL_OW 148
// end ;
73464: GO 73076
73466: POP
73467: POP
// end ;
73468: LD_VAR 0 1
73472: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73473: LD_INT 0
73475: PPUSH
73476: PPUSH
73477: PPUSH
73478: PPUSH
73479: PPUSH
73480: PPUSH
73481: PPUSH
// if not mc_bases then
73482: LD_EXP 63
73486: NOT
73487: IFFALSE 73491
// exit ;
73489: GO 74278
// for i = 1 to mc_bases do
73491: LD_ADDR_VAR 0 2
73495: PUSH
73496: DOUBLE
73497: LD_INT 1
73499: DEC
73500: ST_TO_ADDR
73501: LD_EXP 63
73505: PUSH
73506: FOR_TO
73507: IFFALSE 74276
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73509: LD_EXP 76
73513: PUSH
73514: LD_VAR 0 2
73518: ARRAY
73519: NOT
73520: IFTRUE 73546
73522: PUSH
73523: LD_EXP 76
73527: PUSH
73528: LD_VAR 0 2
73532: ARRAY
73533: PUSH
73534: LD_EXP 77
73538: PUSH
73539: LD_VAR 0 2
73543: ARRAY
73544: EQUAL
73545: OR
73546: IFTRUE 73560
73548: PUSH
73549: LD_EXP 86
73553: PUSH
73554: LD_VAR 0 2
73558: ARRAY
73559: OR
73560: IFFALSE 73564
// continue ;
73562: GO 73506
// if mc_miners [ i ] then
73564: LD_EXP 77
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: IFFALSE 73961
// begin for j = mc_miners [ i ] downto 1 do
73576: LD_ADDR_VAR 0 3
73580: PUSH
73581: DOUBLE
73582: LD_EXP 77
73586: PUSH
73587: LD_VAR 0 2
73591: ARRAY
73592: INC
73593: ST_TO_ADDR
73594: LD_INT 1
73596: PUSH
73597: FOR_DOWNTO
73598: IFFALSE 73959
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73600: LD_EXP 77
73604: PUSH
73605: LD_VAR 0 2
73609: ARRAY
73610: PUSH
73611: LD_VAR 0 3
73615: ARRAY
73616: PPUSH
73617: CALL_OW 301
73621: IFTRUE 73650
73623: PUSH
73624: LD_EXP 77
73628: PUSH
73629: LD_VAR 0 2
73633: ARRAY
73634: PUSH
73635: LD_VAR 0 3
73639: ARRAY
73640: PPUSH
73641: CALL_OW 257
73645: PUSH
73646: LD_INT 1
73648: NONEQUAL
73649: OR
73650: IFFALSE 73713
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73652: LD_ADDR_VAR 0 5
73656: PUSH
73657: LD_EXP 77
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: PUSH
73668: LD_EXP 77
73672: PUSH
73673: LD_VAR 0 2
73677: ARRAY
73678: PUSH
73679: LD_VAR 0 3
73683: ARRAY
73684: DIFF
73685: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73686: LD_ADDR_EXP 77
73690: PUSH
73691: LD_EXP 77
73695: PPUSH
73696: LD_VAR 0 2
73700: PPUSH
73701: LD_VAR 0 5
73705: PPUSH
73706: CALL_OW 1
73710: ST_TO_ADDR
// continue ;
73711: GO 73597
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73713: LD_EXP 77
73717: PUSH
73718: LD_VAR 0 2
73722: ARRAY
73723: PUSH
73724: LD_VAR 0 3
73728: ARRAY
73729: PPUSH
73730: CALL_OW 257
73734: PUSH
73735: LD_INT 1
73737: EQUAL
73738: IFFALSE 73764
73740: PUSH
73741: LD_EXP 77
73745: PUSH
73746: LD_VAR 0 2
73750: ARRAY
73751: PUSH
73752: LD_VAR 0 3
73756: ARRAY
73757: PPUSH
73758: CALL_OW 459
73762: NOT
73763: AND
73764: IFFALSE 73790
73766: PUSH
73767: LD_EXP 77
73771: PUSH
73772: LD_VAR 0 2
73776: ARRAY
73777: PUSH
73778: LD_VAR 0 3
73782: ARRAY
73783: PPUSH
73784: CALL_OW 314
73788: NOT
73789: AND
73790: IFFALSE 73957
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
73792: LD_EXP 77
73796: PUSH
73797: LD_VAR 0 2
73801: ARRAY
73802: PUSH
73803: LD_VAR 0 3
73807: ARRAY
73808: PPUSH
73809: CALL_OW 310
73813: IFFALSE 73836
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
73815: LD_EXP 77
73819: PUSH
73820: LD_VAR 0 2
73824: ARRAY
73825: PUSH
73826: LD_VAR 0 3
73830: ARRAY
73831: PPUSH
73832: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
73836: LD_EXP 77
73840: PUSH
73841: LD_VAR 0 2
73845: ARRAY
73846: PUSH
73847: LD_VAR 0 3
73851: ARRAY
73852: PPUSH
73853: CALL_OW 314
73857: NOT
73858: IFFALSE 73957
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
73860: LD_ADDR_VAR 0 7
73864: PUSH
73865: LD_VAR 0 3
73869: PUSH
73870: LD_EXP 76
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: PPUSH
73881: CALL 19598 0 1
73885: MOD
73886: PUSH
73887: LD_INT 1
73889: PLUS
73890: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73891: LD_EXP 77
73895: PUSH
73896: LD_VAR 0 2
73900: ARRAY
73901: PUSH
73902: LD_VAR 0 3
73906: ARRAY
73907: PPUSH
73908: LD_EXP 76
73912: PUSH
73913: LD_VAR 0 2
73917: ARRAY
73918: PUSH
73919: LD_VAR 0 7
73923: ARRAY
73924: PUSH
73925: LD_INT 1
73927: ARRAY
73928: PPUSH
73929: LD_EXP 76
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: PUSH
73940: LD_VAR 0 7
73944: ARRAY
73945: PUSH
73946: LD_INT 2
73948: ARRAY
73949: PPUSH
73950: LD_INT 0
73952: PPUSH
73953: CALL_OW 193
// end ; end ; end ;
73957: GO 73597
73959: POP
73960: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73961: LD_ADDR_VAR 0 5
73965: PUSH
73966: LD_EXP 63
73970: PUSH
73971: LD_VAR 0 2
73975: ARRAY
73976: PPUSH
73977: LD_INT 2
73979: PUSH
73980: LD_INT 30
73982: PUSH
73983: LD_INT 4
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 30
73992: PUSH
73993: LD_INT 5
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 30
74002: PUSH
74003: LD_INT 32
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: PPUSH
74016: CALL_OW 72
74020: ST_TO_ADDR
// if not tmp then
74021: LD_VAR 0 5
74025: NOT
74026: IFFALSE 74030
// continue ;
74028: GO 73506
// list := [ ] ;
74030: LD_ADDR_VAR 0 6
74034: PUSH
74035: EMPTY
74036: ST_TO_ADDR
// for j in tmp do
74037: LD_ADDR_VAR 0 3
74041: PUSH
74042: LD_VAR 0 5
74046: PUSH
74047: FOR_IN
74048: IFFALSE 74119
// begin for k in UnitsInside ( j ) do
74050: LD_ADDR_VAR 0 4
74054: PUSH
74055: LD_VAR 0 3
74059: PPUSH
74060: CALL_OW 313
74064: PUSH
74065: FOR_IN
74066: IFFALSE 74115
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74068: LD_VAR 0 4
74072: PPUSH
74073: CALL_OW 257
74077: PUSH
74078: LD_INT 1
74080: EQUAL
74081: IFFALSE 74095
74083: PUSH
74084: LD_VAR 0 4
74088: PPUSH
74089: CALL_OW 459
74093: NOT
74094: AND
74095: IFFALSE 74113
// list := list ^ k ;
74097: LD_ADDR_VAR 0 6
74101: PUSH
74102: LD_VAR 0 6
74106: PUSH
74107: LD_VAR 0 4
74111: ADD
74112: ST_TO_ADDR
74113: GO 74065
74115: POP
74116: POP
// end ;
74117: GO 74047
74119: POP
74120: POP
// list := list diff mc_miners [ i ] ;
74121: LD_ADDR_VAR 0 6
74125: PUSH
74126: LD_VAR 0 6
74130: PUSH
74131: LD_EXP 77
74135: PUSH
74136: LD_VAR 0 2
74140: ARRAY
74141: DIFF
74142: ST_TO_ADDR
// if not list then
74143: LD_VAR 0 6
74147: NOT
74148: IFFALSE 74152
// continue ;
74150: GO 73506
// k := mc_mines [ i ] - mc_miners [ i ] ;
74152: LD_ADDR_VAR 0 4
74156: PUSH
74157: LD_EXP 76
74161: PUSH
74162: LD_VAR 0 2
74166: ARRAY
74167: PUSH
74168: LD_EXP 77
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: MINUS
74179: ST_TO_ADDR
// if k > list then
74180: LD_VAR 0 4
74184: PUSH
74185: LD_VAR 0 6
74189: GREATER
74190: IFFALSE 74202
// k := list ;
74192: LD_ADDR_VAR 0 4
74196: PUSH
74197: LD_VAR 0 6
74201: ST_TO_ADDR
// for j = 1 to k do
74202: LD_ADDR_VAR 0 3
74206: PUSH
74207: DOUBLE
74208: LD_INT 1
74210: DEC
74211: ST_TO_ADDR
74212: LD_VAR 0 4
74216: PUSH
74217: FOR_TO
74218: IFFALSE 74272
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74220: LD_ADDR_EXP 77
74224: PUSH
74225: LD_EXP 77
74229: PPUSH
74230: LD_VAR 0 2
74234: PUSH
74235: LD_EXP 77
74239: PUSH
74240: LD_VAR 0 2
74244: ARRAY
74245: PUSH
74246: LD_INT 1
74248: PLUS
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PPUSH
74254: LD_VAR 0 6
74258: PUSH
74259: LD_VAR 0 3
74263: ARRAY
74264: PPUSH
74265: CALL 22482 0 3
74269: ST_TO_ADDR
74270: GO 74217
74272: POP
74273: POP
// end ;
74274: GO 73506
74276: POP
74277: POP
// end ;
74278: LD_VAR 0 1
74282: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74283: LD_INT 0
74285: PPUSH
74286: PPUSH
74287: PPUSH
74288: PPUSH
74289: PPUSH
74290: PPUSH
74291: PPUSH
74292: PPUSH
74293: PPUSH
74294: PPUSH
74295: PPUSH
// if not mc_bases then
74296: LD_EXP 63
74300: NOT
74301: IFFALSE 74305
// exit ;
74303: GO 76152
// for i = 1 to mc_bases do
74305: LD_ADDR_VAR 0 2
74309: PUSH
74310: DOUBLE
74311: LD_INT 1
74313: DEC
74314: ST_TO_ADDR
74315: LD_EXP 63
74319: PUSH
74320: FOR_TO
74321: IFFALSE 76150
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74323: LD_EXP 63
74327: PUSH
74328: LD_VAR 0 2
74332: ARRAY
74333: NOT
74334: IFTRUE 74348
74336: PUSH
74337: LD_EXP 70
74341: PUSH
74342: LD_VAR 0 2
74346: ARRAY
74347: OR
74348: IFFALSE 74352
// continue ;
74350: GO 74320
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74352: LD_EXP 79
74356: PUSH
74357: LD_VAR 0 2
74361: ARRAY
74362: NOT
74363: IFFALSE 74377
74365: PUSH
74366: LD_EXP 80
74370: PUSH
74371: LD_VAR 0 2
74375: ARRAY
74376: AND
74377: IFFALSE 74415
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74379: LD_ADDR_EXP 80
74383: PUSH
74384: LD_EXP 80
74388: PPUSH
74389: LD_VAR 0 2
74393: PPUSH
74394: EMPTY
74395: PPUSH
74396: CALL_OW 1
74400: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74401: LD_VAR 0 2
74405: PPUSH
74406: LD_INT 107
74408: PPUSH
74409: CALL 65053 0 2
// continue ;
74413: GO 74320
// end ; target := [ ] ;
74415: LD_ADDR_VAR 0 7
74419: PUSH
74420: EMPTY
74421: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74422: LD_ADDR_VAR 0 6
74426: PUSH
74427: LD_EXP 63
74431: PUSH
74432: LD_VAR 0 2
74436: ARRAY
74437: PUSH
74438: LD_INT 1
74440: ARRAY
74441: PPUSH
74442: CALL_OW 255
74446: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74447: LD_ADDR_VAR 0 9
74451: PUSH
74452: LD_EXP 63
74456: PUSH
74457: LD_VAR 0 2
74461: ARRAY
74462: PPUSH
74463: LD_INT 2
74465: PUSH
74466: LD_INT 30
74468: PUSH
74469: LD_INT 0
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 30
74478: PUSH
74479: LD_INT 1
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: LIST
74490: PPUSH
74491: CALL_OW 72
74495: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74496: LD_ADDR_VAR 0 3
74500: PUSH
74501: DOUBLE
74502: LD_EXP 79
74506: PUSH
74507: LD_VAR 0 2
74511: ARRAY
74512: INC
74513: ST_TO_ADDR
74514: LD_INT 1
74516: PUSH
74517: FOR_DOWNTO
74518: IFFALSE 74765
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74520: LD_EXP 79
74524: PUSH
74525: LD_VAR 0 2
74529: ARRAY
74530: PUSH
74531: LD_VAR 0 3
74535: ARRAY
74536: PUSH
74537: LD_INT 2
74539: ARRAY
74540: PPUSH
74541: LD_EXP 79
74545: PUSH
74546: LD_VAR 0 2
74550: ARRAY
74551: PUSH
74552: LD_VAR 0 3
74556: ARRAY
74557: PUSH
74558: LD_INT 3
74560: ARRAY
74561: PPUSH
74562: CALL_OW 488
74566: IFFALSE 74620
74568: PUSH
74569: LD_EXP 79
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: PUSH
74580: LD_VAR 0 3
74584: ARRAY
74585: PUSH
74586: LD_INT 2
74588: ARRAY
74589: PPUSH
74590: LD_EXP 79
74594: PUSH
74595: LD_VAR 0 2
74599: ARRAY
74600: PUSH
74601: LD_VAR 0 3
74605: ARRAY
74606: PUSH
74607: LD_INT 3
74609: ARRAY
74610: PPUSH
74611: CALL_OW 284
74615: PUSH
74616: LD_INT 0
74618: EQUAL
74619: AND
74620: IFFALSE 74675
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74622: LD_ADDR_VAR 0 5
74626: PUSH
74627: LD_EXP 79
74631: PUSH
74632: LD_VAR 0 2
74636: ARRAY
74637: PPUSH
74638: LD_VAR 0 3
74642: PPUSH
74643: CALL_OW 3
74647: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74648: LD_ADDR_EXP 79
74652: PUSH
74653: LD_EXP 79
74657: PPUSH
74658: LD_VAR 0 2
74662: PPUSH
74663: LD_VAR 0 5
74667: PPUSH
74668: CALL_OW 1
74672: ST_TO_ADDR
// continue ;
74673: GO 74517
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74675: LD_VAR 0 6
74679: PPUSH
74680: LD_EXP 79
74684: PUSH
74685: LD_VAR 0 2
74689: ARRAY
74690: PUSH
74691: LD_VAR 0 3
74695: ARRAY
74696: PUSH
74697: LD_INT 2
74699: ARRAY
74700: PPUSH
74701: LD_EXP 79
74705: PUSH
74706: LD_VAR 0 2
74710: ARRAY
74711: PUSH
74712: LD_VAR 0 3
74716: ARRAY
74717: PUSH
74718: LD_INT 3
74720: ARRAY
74721: PPUSH
74722: LD_INT 30
74724: PPUSH
74725: CALL 23752 0 4
74729: PUSH
74730: LD_INT 4
74732: ARRAY
74733: PUSH
74734: LD_INT 0
74736: EQUAL
74737: IFFALSE 74763
// begin target := mc_crates [ i ] [ j ] ;
74739: LD_ADDR_VAR 0 7
74743: PUSH
74744: LD_EXP 79
74748: PUSH
74749: LD_VAR 0 2
74753: ARRAY
74754: PUSH
74755: LD_VAR 0 3
74759: ARRAY
74760: ST_TO_ADDR
// break ;
74761: GO 74765
// end ; end ;
74763: GO 74517
74765: POP
74766: POP
// if not target then
74767: LD_VAR 0 7
74771: NOT
74772: IFFALSE 74776
// continue ;
74774: GO 74320
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
74776: LD_ADDR_VAR 0 8
74780: PUSH
74781: LD_EXP 82
74785: PUSH
74786: LD_VAR 0 2
74790: ARRAY
74791: PPUSH
74792: LD_INT 2
74794: PUSH
74795: LD_INT 3
74797: PUSH
74798: LD_INT 58
74800: PUSH
74801: EMPTY
74802: LIST
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 61
74810: PUSH
74811: EMPTY
74812: LIST
74813: PUSH
74814: LD_INT 33
74816: PUSH
74817: LD_INT 5
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: LD_INT 33
74826: PUSH
74827: LD_INT 3
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: LIST
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 2
74843: PUSH
74844: LD_INT 34
74846: PUSH
74847: LD_INT 32
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 34
74856: PUSH
74857: LD_INT 51
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 34
74866: PUSH
74867: LD_INT 12
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PPUSH
74884: CALL_OW 72
74888: ST_TO_ADDR
// if not cargo then
74889: LD_VAR 0 8
74893: NOT
74894: IFFALSE 75608
// begin if mc_crates_collector [ i ] < 5 then
74896: LD_EXP 80
74900: PUSH
74901: LD_VAR 0 2
74905: ARRAY
74906: PUSH
74907: LD_INT 5
74909: LESS
74910: IFFALSE 75280
// begin if mc_ape [ i ] then
74912: LD_EXP 92
74916: PUSH
74917: LD_VAR 0 2
74921: ARRAY
74922: IFFALSE 74969
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74924: LD_ADDR_VAR 0 5
74928: PUSH
74929: LD_EXP 92
74933: PUSH
74934: LD_VAR 0 2
74938: ARRAY
74939: PPUSH
74940: LD_INT 25
74942: PUSH
74943: LD_INT 16
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 24
74952: PUSH
74953: LD_INT 750
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PPUSH
74964: CALL_OW 72
74968: ST_TO_ADDR
// if not tmp then
74969: LD_VAR 0 5
74973: NOT
74974: IFFALSE 75021
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
74976: LD_ADDR_VAR 0 5
74980: PUSH
74981: LD_EXP 63
74985: PUSH
74986: LD_VAR 0 2
74990: ARRAY
74991: PPUSH
74992: LD_INT 25
74994: PUSH
74995: LD_INT 2
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: LD_INT 24
75004: PUSH
75005: LD_INT 750
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PPUSH
75016: CALL_OW 72
75020: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75021: LD_EXP 92
75025: PUSH
75026: LD_VAR 0 2
75030: ARRAY
75031: IFFALSE 75074
75033: PUSH
75034: LD_EXP 63
75038: PUSH
75039: LD_VAR 0 2
75043: ARRAY
75044: PPUSH
75045: LD_INT 25
75047: PUSH
75048: LD_INT 2
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 24
75057: PUSH
75058: LD_INT 750
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PPUSH
75069: CALL_OW 72
75073: AND
75074: IFFALSE 75086
75076: PUSH
75077: LD_VAR 0 5
75081: PUSH
75082: LD_INT 5
75084: LESS
75085: AND
75086: IFFALSE 75168
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75088: LD_ADDR_VAR 0 3
75092: PUSH
75093: LD_EXP 63
75097: PUSH
75098: LD_VAR 0 2
75102: ARRAY
75103: PPUSH
75104: LD_INT 25
75106: PUSH
75107: LD_INT 2
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 24
75116: PUSH
75117: LD_INT 750
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PPUSH
75128: CALL_OW 72
75132: PUSH
75133: FOR_IN
75134: IFFALSE 75166
// begin tmp := tmp union j ;
75136: LD_ADDR_VAR 0 5
75140: PUSH
75141: LD_VAR 0 5
75145: PUSH
75146: LD_VAR 0 3
75150: UNION
75151: ST_TO_ADDR
// if tmp >= 5 then
75152: LD_VAR 0 5
75156: PUSH
75157: LD_INT 5
75159: GREATEREQUAL
75160: IFFALSE 75164
// break ;
75162: GO 75166
// end ;
75164: GO 75133
75166: POP
75167: POP
// end ; if not tmp then
75168: LD_VAR 0 5
75172: NOT
75173: IFFALSE 75177
// continue ;
75175: GO 74320
// for j in tmp do
75177: LD_ADDR_VAR 0 3
75181: PUSH
75182: LD_VAR 0 5
75186: PUSH
75187: FOR_IN
75188: IFFALSE 75278
// if not GetTag ( j ) then
75190: LD_VAR 0 3
75194: PPUSH
75195: CALL_OW 110
75199: NOT
75200: IFFALSE 75276
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75202: LD_ADDR_EXP 80
75206: PUSH
75207: LD_EXP 80
75211: PPUSH
75212: LD_VAR 0 2
75216: PUSH
75217: LD_EXP 80
75221: PUSH
75222: LD_VAR 0 2
75226: ARRAY
75227: PUSH
75228: LD_INT 1
75230: PLUS
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PPUSH
75236: LD_VAR 0 3
75240: PPUSH
75241: CALL 22482 0 3
75245: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75246: LD_VAR 0 3
75250: PPUSH
75251: LD_INT 107
75253: PPUSH
75254: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75258: LD_EXP 80
75262: PUSH
75263: LD_VAR 0 2
75267: ARRAY
75268: PUSH
75269: LD_INT 5
75271: GREATEREQUAL
75272: IFFALSE 75276
// break ;
75274: GO 75278
// end ;
75276: GO 75187
75278: POP
75279: POP
// end ; if mc_crates_collector [ i ] and target then
75280: LD_EXP 80
75284: PUSH
75285: LD_VAR 0 2
75289: ARRAY
75290: IFFALSE 75298
75292: PUSH
75293: LD_VAR 0 7
75297: AND
75298: IFFALSE 75606
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75300: LD_EXP 80
75304: PUSH
75305: LD_VAR 0 2
75309: ARRAY
75310: PUSH
75311: LD_VAR 0 7
75315: PUSH
75316: LD_INT 1
75318: ARRAY
75319: LESS
75320: IFFALSE 75340
// tmp := mc_crates_collector [ i ] else
75322: LD_ADDR_VAR 0 5
75326: PUSH
75327: LD_EXP 80
75331: PUSH
75332: LD_VAR 0 2
75336: ARRAY
75337: ST_TO_ADDR
75338: GO 75354
// tmp := target [ 1 ] ;
75340: LD_ADDR_VAR 0 5
75344: PUSH
75345: LD_VAR 0 7
75349: PUSH
75350: LD_INT 1
75352: ARRAY
75353: ST_TO_ADDR
// k := 0 ;
75354: LD_ADDR_VAR 0 4
75358: PUSH
75359: LD_INT 0
75361: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75362: LD_ADDR_VAR 0 3
75366: PUSH
75367: LD_EXP 80
75371: PUSH
75372: LD_VAR 0 2
75376: ARRAY
75377: PUSH
75378: FOR_IN
75379: IFFALSE 75604
// begin k := k + 1 ;
75381: LD_ADDR_VAR 0 4
75385: PUSH
75386: LD_VAR 0 4
75390: PUSH
75391: LD_INT 1
75393: PLUS
75394: ST_TO_ADDR
// if k > tmp then
75395: LD_VAR 0 4
75399: PUSH
75400: LD_VAR 0 5
75404: GREATER
75405: IFFALSE 75409
// break ;
75407: GO 75604
// if not GetClass ( j ) in [ 2 , 16 ] then
75409: LD_VAR 0 3
75413: PPUSH
75414: CALL_OW 257
75418: PUSH
75419: LD_INT 2
75421: PUSH
75422: LD_INT 16
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: IN
75429: NOT
75430: IFFALSE 75483
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75432: LD_ADDR_EXP 80
75436: PUSH
75437: LD_EXP 80
75441: PPUSH
75442: LD_VAR 0 2
75446: PPUSH
75447: LD_EXP 80
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PUSH
75458: LD_VAR 0 3
75462: DIFF
75463: PPUSH
75464: CALL_OW 1
75468: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75469: LD_VAR 0 3
75473: PPUSH
75474: LD_INT 0
75476: PPUSH
75477: CALL_OW 109
// continue ;
75481: GO 75378
// end ; if IsInUnit ( j ) then
75483: LD_VAR 0 3
75487: PPUSH
75488: CALL_OW 310
75492: IFFALSE 75503
// ComExitBuilding ( j ) ;
75494: LD_VAR 0 3
75498: PPUSH
75499: CALL_OW 122
// wait ( 3 ) ;
75503: LD_INT 3
75505: PPUSH
75506: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75510: LD_VAR 0 3
75514: PPUSH
75515: CALL_OW 314
75519: IFFALSE 75557
75521: PUSH
75522: LD_VAR 0 6
75526: PPUSH
75527: LD_VAR 0 7
75531: PUSH
75532: LD_INT 2
75534: ARRAY
75535: PPUSH
75536: LD_VAR 0 7
75540: PUSH
75541: LD_INT 3
75543: ARRAY
75544: PPUSH
75545: LD_INT 30
75547: PPUSH
75548: CALL 23752 0 4
75552: PUSH
75553: LD_INT 4
75555: ARRAY
75556: AND
75557: IFFALSE 75575
// ComStandNearbyBuilding ( j , depot ) else
75559: LD_VAR 0 3
75563: PPUSH
75564: LD_VAR 0 9
75568: PPUSH
75569: CALL 19058 0 2
75573: GO 75602
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75575: LD_VAR 0 3
75579: PPUSH
75580: LD_VAR 0 7
75584: PUSH
75585: LD_INT 2
75587: ARRAY
75588: PPUSH
75589: LD_VAR 0 7
75593: PUSH
75594: LD_INT 3
75596: ARRAY
75597: PPUSH
75598: CALL_OW 117
// end ;
75602: GO 75378
75604: POP
75605: POP
// end ; end else
75606: GO 76148
// begin for j in cargo do
75608: LD_ADDR_VAR 0 3
75612: PUSH
75613: LD_VAR 0 8
75617: PUSH
75618: FOR_IN
75619: IFFALSE 76146
// begin if GetTag ( j ) <> 0 then
75621: LD_VAR 0 3
75625: PPUSH
75626: CALL_OW 110
75630: PUSH
75631: LD_INT 0
75633: NONEQUAL
75634: IFFALSE 75638
// continue ;
75636: GO 75618
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75638: LD_VAR 0 3
75642: PPUSH
75643: CALL_OW 256
75647: PUSH
75648: LD_INT 1000
75650: LESS
75651: IFFALSE 75676
75653: PUSH
75654: LD_VAR 0 3
75658: PPUSH
75659: LD_EXP 87
75663: PUSH
75664: LD_VAR 0 2
75668: ARRAY
75669: PPUSH
75670: CALL_OW 308
75674: NOT
75675: AND
75676: IFFALSE 75698
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75678: LD_VAR 0 3
75682: PPUSH
75683: LD_EXP 87
75687: PUSH
75688: LD_VAR 0 2
75692: ARRAY
75693: PPUSH
75694: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75698: LD_VAR 0 3
75702: PPUSH
75703: CALL_OW 256
75707: PUSH
75708: LD_INT 1000
75710: LESS
75711: IFFALSE 75735
75713: PUSH
75714: LD_VAR 0 3
75718: PPUSH
75719: LD_EXP 87
75723: PUSH
75724: LD_VAR 0 2
75728: ARRAY
75729: PPUSH
75730: CALL_OW 308
75734: AND
75735: IFFALSE 75739
// continue ;
75737: GO 75618
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75739: LD_VAR 0 3
75743: PPUSH
75744: CALL_OW 262
75748: PUSH
75749: LD_INT 2
75751: EQUAL
75752: IFFALSE 75769
75754: PUSH
75755: LD_VAR 0 3
75759: PPUSH
75760: CALL_OW 261
75764: PUSH
75765: LD_INT 15
75767: LESS
75768: AND
75769: IFFALSE 75773
// continue ;
75771: GO 75618
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
75773: LD_VAR 0 3
75777: PPUSH
75778: CALL_OW 262
75782: PUSH
75783: LD_INT 1
75785: EQUAL
75786: IFFALSE 75803
75788: PUSH
75789: LD_VAR 0 3
75793: PPUSH
75794: CALL_OW 261
75798: PUSH
75799: LD_INT 10
75801: LESS
75802: AND
75803: IFFALSE 76083
// begin if not depot then
75805: LD_VAR 0 9
75809: NOT
75810: IFFALSE 75814
// continue ;
75812: GO 75618
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
75814: LD_VAR 0 3
75818: PPUSH
75819: LD_VAR 0 9
75823: PPUSH
75824: LD_VAR 0 3
75828: PPUSH
75829: CALL_OW 74
75833: PPUSH
75834: CALL_OW 296
75838: PUSH
75839: LD_INT 6
75841: LESS
75842: IFFALSE 75858
// SetFuel ( j , 100 ) else
75844: LD_VAR 0 3
75848: PPUSH
75849: LD_INT 100
75851: PPUSH
75852: CALL_OW 240
75856: GO 76083
// if GetFuel ( j ) = 0 then
75858: LD_VAR 0 3
75862: PPUSH
75863: CALL_OW 261
75867: PUSH
75868: LD_INT 0
75870: EQUAL
75871: IFFALSE 76083
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
75873: LD_ADDR_EXP 82
75877: PUSH
75878: LD_EXP 82
75882: PPUSH
75883: LD_VAR 0 2
75887: PPUSH
75888: LD_EXP 82
75892: PUSH
75893: LD_VAR 0 2
75897: ARRAY
75898: PUSH
75899: LD_VAR 0 3
75903: DIFF
75904: PPUSH
75905: CALL_OW 1
75909: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75910: LD_VAR 0 3
75914: PPUSH
75915: CALL_OW 263
75919: PUSH
75920: LD_INT 1
75922: EQUAL
75923: IFFALSE 75939
// ComExitVehicle ( IsInUnit ( j ) ) ;
75925: LD_VAR 0 3
75929: PPUSH
75930: CALL_OW 310
75934: PPUSH
75935: CALL_OW 121
// if GetControl ( j ) = control_remote then
75939: LD_VAR 0 3
75943: PPUSH
75944: CALL_OW 263
75948: PUSH
75949: LD_INT 2
75951: EQUAL
75952: IFFALSE 75963
// ComUnlink ( j ) ;
75954: LD_VAR 0 3
75958: PPUSH
75959: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75963: LD_ADDR_VAR 0 10
75967: PUSH
75968: LD_VAR 0 2
75972: PPUSH
75973: LD_INT 3
75975: PPUSH
75976: CALL 85877 0 2
75980: ST_TO_ADDR
// if fac then
75981: LD_VAR 0 10
75985: IFFALSE 76081
// begin for k in fac do
75987: LD_ADDR_VAR 0 4
75991: PUSH
75992: LD_VAR 0 10
75996: PUSH
75997: FOR_IN
75998: IFFALSE 76079
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76000: LD_ADDR_VAR 0 11
76004: PUSH
76005: LD_VAR 0 10
76009: PPUSH
76010: LD_VAR 0 3
76014: PPUSH
76015: CALL_OW 265
76019: PPUSH
76020: LD_VAR 0 3
76024: PPUSH
76025: CALL_OW 262
76029: PPUSH
76030: LD_VAR 0 3
76034: PPUSH
76035: CALL_OW 263
76039: PPUSH
76040: LD_VAR 0 3
76044: PPUSH
76045: CALL_OW 264
76049: PPUSH
76050: CALL 19956 0 5
76054: ST_TO_ADDR
// if components then
76055: LD_VAR 0 11
76059: IFFALSE 76077
// begin MC_InsertProduceList ( i , components ) ;
76061: LD_VAR 0 2
76065: PPUSH
76066: LD_VAR 0 11
76070: PPUSH
76071: CALL 85422 0 2
// break ;
76075: GO 76079
// end ; end ;
76077: GO 75997
76079: POP
76080: POP
// end ; continue ;
76081: GO 75618
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76083: LD_VAR 0 3
76087: PPUSH
76088: LD_INT 1
76090: PPUSH
76091: CALL_OW 289
76095: PUSH
76096: LD_INT 100
76098: LESS
76099: IFFALSE 76113
76101: PUSH
76102: LD_VAR 0 3
76106: PPUSH
76107: CALL_OW 314
76111: NOT
76112: AND
76113: IFFALSE 76142
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76115: LD_VAR 0 3
76119: PPUSH
76120: LD_VAR 0 7
76124: PUSH
76125: LD_INT 2
76127: ARRAY
76128: PPUSH
76129: LD_VAR 0 7
76133: PUSH
76134: LD_INT 3
76136: ARRAY
76137: PPUSH
76138: CALL_OW 117
// break ;
76142: GO 76146
// end ;
76144: GO 75618
76146: POP
76147: POP
// end ; end ;
76148: GO 74320
76150: POP
76151: POP
// end ;
76152: LD_VAR 0 1
76156: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76157: LD_INT 0
76159: PPUSH
76160: PPUSH
76161: PPUSH
76162: PPUSH
// if not mc_bases then
76163: LD_EXP 63
76167: NOT
76168: IFFALSE 76172
// exit ;
76170: GO 76337
// for i = 1 to mc_bases do
76172: LD_ADDR_VAR 0 2
76176: PUSH
76177: DOUBLE
76178: LD_INT 1
76180: DEC
76181: ST_TO_ADDR
76182: LD_EXP 63
76186: PUSH
76187: FOR_TO
76188: IFFALSE 76335
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76190: LD_ADDR_VAR 0 4
76194: PUSH
76195: LD_EXP 82
76199: PUSH
76200: LD_VAR 0 2
76204: ARRAY
76205: PUSH
76206: LD_EXP 85
76210: PUSH
76211: LD_VAR 0 2
76215: ARRAY
76216: UNION
76217: PPUSH
76218: LD_INT 33
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PPUSH
76228: CALL_OW 72
76232: ST_TO_ADDR
// if tmp then
76233: LD_VAR 0 4
76237: IFFALSE 76333
// for j in tmp do
76239: LD_ADDR_VAR 0 3
76243: PUSH
76244: LD_VAR 0 4
76248: PUSH
76249: FOR_IN
76250: IFFALSE 76331
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76252: LD_VAR 0 3
76256: PPUSH
76257: CALL_OW 312
76261: NOT
76262: IFFALSE 76279
76264: PUSH
76265: LD_VAR 0 3
76269: PPUSH
76270: CALL_OW 256
76274: PUSH
76275: LD_INT 250
76277: GREATEREQUAL
76278: AND
76279: IFFALSE 76292
// Connect ( j ) else
76281: LD_VAR 0 3
76285: PPUSH
76286: CALL 25842 0 1
76290: GO 76329
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76292: LD_VAR 0 3
76296: PPUSH
76297: CALL_OW 256
76301: PUSH
76302: LD_INT 250
76304: LESS
76305: IFFALSE 76318
76307: PUSH
76308: LD_VAR 0 3
76312: PPUSH
76313: CALL_OW 312
76317: AND
76318: IFFALSE 76329
// ComUnlink ( j ) ;
76320: LD_VAR 0 3
76324: PPUSH
76325: CALL_OW 136
76329: GO 76249
76331: POP
76332: POP
// end ;
76333: GO 76187
76335: POP
76336: POP
// end ;
76337: LD_VAR 0 1
76341: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76342: LD_INT 0
76344: PPUSH
76345: PPUSH
76346: PPUSH
76347: PPUSH
76348: PPUSH
// if not mc_bases then
76349: LD_EXP 63
76353: NOT
76354: IFFALSE 76358
// exit ;
76356: GO 76807
// for i = 1 to mc_bases do
76358: LD_ADDR_VAR 0 2
76362: PUSH
76363: DOUBLE
76364: LD_INT 1
76366: DEC
76367: ST_TO_ADDR
76368: LD_EXP 63
76372: PUSH
76373: FOR_TO
76374: IFFALSE 76805
// begin if not mc_produce [ i ] then
76376: LD_EXP 84
76380: PUSH
76381: LD_VAR 0 2
76385: ARRAY
76386: NOT
76387: IFFALSE 76391
// continue ;
76389: GO 76373
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76391: LD_ADDR_VAR 0 5
76395: PUSH
76396: LD_EXP 63
76400: PUSH
76401: LD_VAR 0 2
76405: ARRAY
76406: PPUSH
76407: LD_INT 30
76409: PUSH
76410: LD_INT 3
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PPUSH
76417: CALL_OW 72
76421: ST_TO_ADDR
// if not fac then
76422: LD_VAR 0 5
76426: NOT
76427: IFFALSE 76431
// continue ;
76429: GO 76373
// for j in fac do
76431: LD_ADDR_VAR 0 3
76435: PUSH
76436: LD_VAR 0 5
76440: PUSH
76441: FOR_IN
76442: IFFALSE 76801
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76444: LD_VAR 0 3
76448: PPUSH
76449: CALL_OW 461
76453: PUSH
76454: LD_INT 2
76456: NONEQUAL
76457: IFTRUE 76477
76459: PUSH
76460: LD_VAR 0 3
76464: PPUSH
76465: LD_INT 15
76467: PPUSH
76468: CALL 25461 0 2
76472: PUSH
76473: LD_INT 4
76475: ARRAY
76476: OR
76477: IFFALSE 76481
// continue ;
76479: GO 76441
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76481: LD_VAR 0 3
76485: PPUSH
76486: LD_EXP 84
76490: PUSH
76491: LD_VAR 0 2
76495: ARRAY
76496: PUSH
76497: LD_INT 1
76499: ARRAY
76500: PUSH
76501: LD_INT 1
76503: ARRAY
76504: PPUSH
76505: LD_EXP 84
76509: PUSH
76510: LD_VAR 0 2
76514: ARRAY
76515: PUSH
76516: LD_INT 1
76518: ARRAY
76519: PUSH
76520: LD_INT 2
76522: ARRAY
76523: PPUSH
76524: LD_EXP 84
76528: PUSH
76529: LD_VAR 0 2
76533: ARRAY
76534: PUSH
76535: LD_INT 1
76537: ARRAY
76538: PUSH
76539: LD_INT 3
76541: ARRAY
76542: PPUSH
76543: LD_EXP 84
76547: PUSH
76548: LD_VAR 0 2
76552: ARRAY
76553: PUSH
76554: LD_INT 1
76556: ARRAY
76557: PUSH
76558: LD_INT 4
76560: ARRAY
76561: PPUSH
76562: CALL_OW 448
76566: IFFALSE 76661
76568: PUSH
76569: LD_VAR 0 3
76573: PPUSH
76574: LD_EXP 84
76578: PUSH
76579: LD_VAR 0 2
76583: ARRAY
76584: PUSH
76585: LD_INT 1
76587: ARRAY
76588: PUSH
76589: LD_INT 1
76591: ARRAY
76592: PUSH
76593: LD_EXP 84
76597: PUSH
76598: LD_VAR 0 2
76602: ARRAY
76603: PUSH
76604: LD_INT 1
76606: ARRAY
76607: PUSH
76608: LD_INT 2
76610: ARRAY
76611: PUSH
76612: LD_EXP 84
76616: PUSH
76617: LD_VAR 0 2
76621: ARRAY
76622: PUSH
76623: LD_INT 1
76625: ARRAY
76626: PUSH
76627: LD_INT 3
76629: ARRAY
76630: PUSH
76631: LD_EXP 84
76635: PUSH
76636: LD_VAR 0 2
76640: ARRAY
76641: PUSH
76642: LD_INT 1
76644: ARRAY
76645: PUSH
76646: LD_INT 4
76648: ARRAY
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: PPUSH
76656: CALL 29275 0 2
76660: AND
76661: IFFALSE 76799
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76663: LD_VAR 0 3
76667: PPUSH
76668: LD_EXP 84
76672: PUSH
76673: LD_VAR 0 2
76677: ARRAY
76678: PUSH
76679: LD_INT 1
76681: ARRAY
76682: PUSH
76683: LD_INT 1
76685: ARRAY
76686: PPUSH
76687: LD_EXP 84
76691: PUSH
76692: LD_VAR 0 2
76696: ARRAY
76697: PUSH
76698: LD_INT 1
76700: ARRAY
76701: PUSH
76702: LD_INT 2
76704: ARRAY
76705: PPUSH
76706: LD_EXP 84
76710: PUSH
76711: LD_VAR 0 2
76715: ARRAY
76716: PUSH
76717: LD_INT 1
76719: ARRAY
76720: PUSH
76721: LD_INT 3
76723: ARRAY
76724: PPUSH
76725: LD_EXP 84
76729: PUSH
76730: LD_VAR 0 2
76734: ARRAY
76735: PUSH
76736: LD_INT 1
76738: ARRAY
76739: PUSH
76740: LD_INT 4
76742: ARRAY
76743: PPUSH
76744: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76748: LD_ADDR_VAR 0 4
76752: PUSH
76753: LD_EXP 84
76757: PUSH
76758: LD_VAR 0 2
76762: ARRAY
76763: PPUSH
76764: LD_INT 1
76766: PPUSH
76767: CALL_OW 3
76771: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76772: LD_ADDR_EXP 84
76776: PUSH
76777: LD_EXP 84
76781: PPUSH
76782: LD_VAR 0 2
76786: PPUSH
76787: LD_VAR 0 4
76791: PPUSH
76792: CALL_OW 1
76796: ST_TO_ADDR
// break ;
76797: GO 76801
// end ; end ;
76799: GO 76441
76801: POP
76802: POP
// end ;
76803: GO 76373
76805: POP
76806: POP
// end ;
76807: LD_VAR 0 1
76811: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
76812: LD_INT 0
76814: PPUSH
76815: PPUSH
76816: PPUSH
// if not mc_bases then
76817: LD_EXP 63
76821: NOT
76822: IFFALSE 76826
// exit ;
76824: GO 76915
// for i = 1 to mc_bases do
76826: LD_ADDR_VAR 0 2
76830: PUSH
76831: DOUBLE
76832: LD_INT 1
76834: DEC
76835: ST_TO_ADDR
76836: LD_EXP 63
76840: PUSH
76841: FOR_TO
76842: IFFALSE 76913
// begin if mc_attack [ i ] then
76844: LD_EXP 83
76848: PUSH
76849: LD_VAR 0 2
76853: ARRAY
76854: IFFALSE 76911
// begin tmp := mc_attack [ i ] [ 1 ] ;
76856: LD_ADDR_VAR 0 3
76860: PUSH
76861: LD_EXP 83
76865: PUSH
76866: LD_VAR 0 2
76870: ARRAY
76871: PUSH
76872: LD_INT 1
76874: ARRAY
76875: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
76876: LD_ADDR_EXP 83
76880: PUSH
76881: LD_EXP 83
76885: PPUSH
76886: LD_VAR 0 2
76890: PPUSH
76891: EMPTY
76892: PPUSH
76893: CALL_OW 1
76897: ST_TO_ADDR
// Attack ( tmp ) ;
76898: LD_VAR 0 3
76902: PPUSH
76903: CALL 113451 0 1
// exit ;
76907: POP
76908: POP
76909: GO 76915
// end ; end ;
76911: GO 76841
76913: POP
76914: POP
// end ;
76915: LD_VAR 0 1
76919: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
76920: LD_INT 0
76922: PPUSH
76923: PPUSH
76924: PPUSH
76925: PPUSH
76926: PPUSH
76927: PPUSH
76928: PPUSH
// if not mc_bases then
76929: LD_EXP 63
76933: NOT
76934: IFFALSE 76938
// exit ;
76936: GO 77815
// for i = 1 to mc_bases do
76938: LD_ADDR_VAR 0 2
76942: PUSH
76943: DOUBLE
76944: LD_INT 1
76946: DEC
76947: ST_TO_ADDR
76948: LD_EXP 63
76952: PUSH
76953: FOR_TO
76954: IFFALSE 77813
// begin if not mc_bases [ i ] then
76956: LD_EXP 63
76960: PUSH
76961: LD_VAR 0 2
76965: ARRAY
76966: NOT
76967: IFFALSE 76971
// continue ;
76969: GO 76953
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76971: LD_ADDR_VAR 0 7
76975: PUSH
76976: LD_EXP 63
76980: PUSH
76981: LD_VAR 0 2
76985: ARRAY
76986: PUSH
76987: LD_INT 1
76989: ARRAY
76990: PPUSH
76991: CALL 19282 0 1
76995: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
76996: LD_ADDR_EXP 86
77000: PUSH
77001: LD_EXP 86
77005: PPUSH
77006: LD_VAR 0 2
77010: PPUSH
77011: LD_EXP 63
77015: PUSH
77016: LD_VAR 0 2
77020: ARRAY
77021: PUSH
77022: LD_INT 1
77024: ARRAY
77025: PPUSH
77026: CALL_OW 255
77030: PPUSH
77031: LD_EXP 88
77035: PUSH
77036: LD_VAR 0 2
77040: ARRAY
77041: PPUSH
77042: CALL 19247 0 2
77046: PPUSH
77047: CALL_OW 1
77051: ST_TO_ADDR
// if not mc_scan [ i ] then
77052: LD_EXP 86
77056: PUSH
77057: LD_VAR 0 2
77061: ARRAY
77062: NOT
77063: IFFALSE 77247
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77065: LD_ADDR_EXP 106
77069: PUSH
77070: LD_EXP 106
77074: PPUSH
77075: LD_VAR 0 2
77079: PPUSH
77080: LD_INT 0
77082: PPUSH
77083: CALL_OW 1
77087: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77088: LD_ADDR_VAR 0 4
77092: PUSH
77093: LD_EXP 63
77097: PUSH
77098: LD_VAR 0 2
77102: ARRAY
77103: PPUSH
77104: LD_INT 2
77106: PUSH
77107: LD_INT 25
77109: PUSH
77110: LD_INT 5
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 25
77119: PUSH
77120: LD_INT 8
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 25
77129: PUSH
77130: LD_INT 9
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: PPUSH
77143: CALL_OW 72
77147: ST_TO_ADDR
// if not tmp then
77148: LD_VAR 0 4
77152: NOT
77153: IFFALSE 77157
// continue ;
77155: GO 76953
// for j in tmp do
77157: LD_ADDR_VAR 0 3
77161: PUSH
77162: LD_VAR 0 4
77166: PUSH
77167: FOR_IN
77168: IFFALSE 77245
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77170: LD_VAR 0 3
77174: PPUSH
77175: CALL_OW 310
77179: PPUSH
77180: CALL_OW 266
77184: PUSH
77185: LD_INT 5
77187: EQUAL
77188: IFFALSE 77205
77190: PUSH
77191: LD_VAR 0 3
77195: PPUSH
77196: CALL_OW 257
77200: PUSH
77201: LD_INT 1
77203: EQUAL
77204: AND
77205: IFFALSE 77219
77207: PUSH
77208: LD_VAR 0 3
77212: PPUSH
77213: CALL_OW 459
77217: NOT
77218: AND
77219: IFFALSE 77227
77221: PUSH
77222: LD_VAR 0 7
77226: AND
77227: IFFALSE 77243
// ComChangeProfession ( j , class ) ;
77229: LD_VAR 0 3
77233: PPUSH
77234: LD_VAR 0 7
77238: PPUSH
77239: CALL_OW 123
77243: GO 77167
77245: POP
77246: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77247: LD_EXP 86
77251: PUSH
77252: LD_VAR 0 2
77256: ARRAY
77257: IFFALSE 77272
77259: PUSH
77260: LD_EXP 106
77264: PUSH
77265: LD_VAR 0 2
77269: ARRAY
77270: NOT
77271: AND
77272: IFFALSE 77287
77274: PUSH
77275: LD_EXP 85
77279: PUSH
77280: LD_VAR 0 2
77284: ARRAY
77285: NOT
77286: AND
77287: IFFALSE 77438
77289: PUSH
77290: LD_EXP 63
77294: PUSH
77295: LD_VAR 0 2
77299: ARRAY
77300: PPUSH
77301: LD_INT 50
77303: PUSH
77304: EMPTY
77305: LIST
77306: PUSH
77307: LD_INT 2
77309: PUSH
77310: LD_INT 30
77312: PUSH
77313: LD_INT 32
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 30
77322: PUSH
77323: LD_INT 33
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 30
77332: PUSH
77333: LD_INT 4
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 30
77342: PUSH
77343: LD_INT 5
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PPUSH
77361: CALL_OW 72
77365: PUSH
77366: LD_INT 4
77368: LESS
77369: IFTRUE 77437
77371: PUSH
77372: LD_EXP 63
77376: PUSH
77377: LD_VAR 0 2
77381: ARRAY
77382: PPUSH
77383: LD_INT 3
77385: PUSH
77386: LD_INT 24
77388: PUSH
77389: LD_INT 1000
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 2
77402: PUSH
77403: LD_INT 30
77405: PUSH
77406: LD_INT 0
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 30
77415: PUSH
77416: LD_INT 1
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: LIST
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PPUSH
77432: CALL_OW 72
77436: OR
77437: AND
77438: IFFALSE 77691
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77440: LD_ADDR_EXP 106
77444: PUSH
77445: LD_EXP 106
77449: PPUSH
77450: LD_VAR 0 2
77454: PPUSH
77455: LD_INT 1
77457: PPUSH
77458: CALL_OW 1
77462: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77463: LD_ADDR_VAR 0 4
77467: PUSH
77468: LD_EXP 63
77472: PUSH
77473: LD_VAR 0 2
77477: ARRAY
77478: PPUSH
77479: LD_INT 2
77481: PUSH
77482: LD_INT 25
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 25
77494: PUSH
77495: LD_INT 5
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 25
77504: PUSH
77505: LD_INT 8
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 25
77514: PUSH
77515: LD_INT 9
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: LIST
77526: LIST
77527: LIST
77528: PPUSH
77529: CALL_OW 72
77533: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77534: LD_ADDR_VAR 0 4
77538: PUSH
77539: LD_VAR 0 4
77543: PUSH
77544: LD_VAR 0 4
77548: PPUSH
77549: LD_INT 18
77551: PPUSH
77552: CALL 53075 0 2
77556: DIFF
77557: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77558: LD_VAR 0 4
77562: NOT
77563: IFFALSE 77611
77565: PUSH
77566: LD_EXP 63
77570: PUSH
77571: LD_VAR 0 2
77575: ARRAY
77576: PPUSH
77577: LD_INT 2
77579: PUSH
77580: LD_INT 30
77582: PUSH
77583: LD_INT 4
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 30
77592: PUSH
77593: LD_INT 5
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: PPUSH
77605: CALL_OW 72
77609: NOT
77610: AND
77611: IFFALSE 77673
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77613: LD_ADDR_VAR 0 4
77617: PUSH
77618: LD_EXP 63
77622: PUSH
77623: LD_VAR 0 2
77627: ARRAY
77628: PPUSH
77629: LD_INT 2
77631: PUSH
77632: LD_INT 25
77634: PUSH
77635: LD_INT 2
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 25
77644: PUSH
77645: LD_INT 3
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 25
77654: PUSH
77655: LD_INT 4
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: PPUSH
77668: CALL_OW 72
77672: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77673: LD_VAR 0 2
77677: PPUSH
77678: LD_VAR 0 4
77682: PPUSH
77683: CALL 118220 0 2
// exit ;
77687: POP
77688: POP
77689: GO 77815
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77691: LD_EXP 86
77695: PUSH
77696: LD_VAR 0 2
77700: ARRAY
77701: IFFALSE 77716
77703: PUSH
77704: LD_EXP 106
77708: PUSH
77709: LD_VAR 0 2
77713: ARRAY
77714: NOT
77715: AND
77716: IFFALSE 77730
77718: PUSH
77719: LD_EXP 85
77723: PUSH
77724: LD_VAR 0 2
77728: ARRAY
77729: AND
77730: IFFALSE 77811
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77732: LD_ADDR_EXP 106
77736: PUSH
77737: LD_EXP 106
77741: PPUSH
77742: LD_VAR 0 2
77746: PPUSH
77747: LD_INT 1
77749: PPUSH
77750: CALL_OW 1
77754: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77755: LD_ADDR_VAR 0 4
77759: PUSH
77760: LD_EXP 85
77764: PUSH
77765: LD_VAR 0 2
77769: ARRAY
77770: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77771: LD_ADDR_EXP 85
77775: PUSH
77776: LD_EXP 85
77780: PPUSH
77781: LD_VAR 0 2
77785: PPUSH
77786: EMPTY
77787: PPUSH
77788: CALL_OW 1
77792: ST_TO_ADDR
// Defend ( i , tmp ) ;
77793: LD_VAR 0 2
77797: PPUSH
77798: LD_VAR 0 4
77802: PPUSH
77803: CALL 118824 0 2
// exit ;
77807: POP
77808: POP
77809: GO 77815
// end ; end ;
77811: GO 76953
77813: POP
77814: POP
// end ;
77815: LD_VAR 0 1
77819: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
77820: LD_INT 0
77822: PPUSH
77823: PPUSH
77824: PPUSH
77825: PPUSH
77826: PPUSH
77827: PPUSH
77828: PPUSH
77829: PPUSH
77830: PPUSH
77831: PPUSH
77832: PPUSH
// if not mc_bases then
77833: LD_EXP 63
77837: NOT
77838: IFFALSE 77842
// exit ;
77840: GO 78955
// for i = 1 to mc_bases do
77842: LD_ADDR_VAR 0 2
77846: PUSH
77847: DOUBLE
77848: LD_INT 1
77850: DEC
77851: ST_TO_ADDR
77852: LD_EXP 63
77856: PUSH
77857: FOR_TO
77858: IFFALSE 78953
// begin tmp := mc_lab [ i ] ;
77860: LD_ADDR_VAR 0 6
77864: PUSH
77865: LD_EXP 96
77869: PUSH
77870: LD_VAR 0 2
77874: ARRAY
77875: ST_TO_ADDR
// if not tmp then
77876: LD_VAR 0 6
77880: NOT
77881: IFFALSE 77885
// continue ;
77883: GO 77857
// idle_lab := 0 ;
77885: LD_ADDR_VAR 0 11
77889: PUSH
77890: LD_INT 0
77892: ST_TO_ADDR
// for j in tmp do
77893: LD_ADDR_VAR 0 3
77897: PUSH
77898: LD_VAR 0 6
77902: PUSH
77903: FOR_IN
77904: IFFALSE 78949
// begin researching := false ;
77906: LD_ADDR_VAR 0 10
77910: PUSH
77911: LD_INT 0
77913: ST_TO_ADDR
// side := GetSide ( j ) ;
77914: LD_ADDR_VAR 0 4
77918: PUSH
77919: LD_VAR 0 3
77923: PPUSH
77924: CALL_OW 255
77928: ST_TO_ADDR
// if not mc_tech [ side ] then
77929: LD_EXP 90
77933: PUSH
77934: LD_VAR 0 4
77938: ARRAY
77939: NOT
77940: IFFALSE 77944
// continue ;
77942: GO 77903
// if BuildingStatus ( j ) = bs_idle then
77944: LD_VAR 0 3
77948: PPUSH
77949: CALL_OW 461
77953: PUSH
77954: LD_INT 2
77956: EQUAL
77957: IFFALSE 78149
// begin if idle_lab and UnitsInside ( j ) < 6 then
77959: LD_VAR 0 11
77963: IFFALSE 77980
77965: PUSH
77966: LD_VAR 0 3
77970: PPUSH
77971: CALL_OW 313
77975: PUSH
77976: LD_INT 6
77978: LESS
77979: AND
77980: IFFALSE 78051
// begin tmp2 := UnitsInside ( idle_lab ) ;
77982: LD_ADDR_VAR 0 9
77986: PUSH
77987: LD_VAR 0 11
77991: PPUSH
77992: CALL_OW 313
77996: ST_TO_ADDR
// if tmp2 then
77997: LD_VAR 0 9
78001: IFFALSE 78043
// for x in tmp2 do
78003: LD_ADDR_VAR 0 7
78007: PUSH
78008: LD_VAR 0 9
78012: PUSH
78013: FOR_IN
78014: IFFALSE 78041
// begin ComExitBuilding ( x ) ;
78016: LD_VAR 0 7
78020: PPUSH
78021: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78025: LD_VAR 0 7
78029: PPUSH
78030: LD_VAR 0 3
78034: PPUSH
78035: CALL_OW 180
// end ;
78039: GO 78013
78041: POP
78042: POP
// idle_lab := 0 ;
78043: LD_ADDR_VAR 0 11
78047: PUSH
78048: LD_INT 0
78050: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78051: LD_ADDR_VAR 0 5
78055: PUSH
78056: LD_EXP 90
78060: PUSH
78061: LD_VAR 0 4
78065: ARRAY
78066: PUSH
78067: FOR_IN
78068: IFFALSE 78130
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78070: LD_VAR 0 3
78074: PPUSH
78075: LD_VAR 0 5
78079: PPUSH
78080: CALL_OW 430
78084: IFFALSE 78102
78086: PUSH
78087: LD_VAR 0 4
78091: PPUSH
78092: LD_VAR 0 5
78096: PPUSH
78097: CALL 18342 0 2
78101: AND
78102: IFFALSE 78128
// begin researching := true ;
78104: LD_ADDR_VAR 0 10
78108: PUSH
78109: LD_INT 1
78111: ST_TO_ADDR
// ComResearch ( j , t ) ;
78112: LD_VAR 0 3
78116: PPUSH
78117: LD_VAR 0 5
78121: PPUSH
78122: CALL_OW 124
// break ;
78126: GO 78130
// end ;
78128: GO 78067
78130: POP
78131: POP
// if not researching then
78132: LD_VAR 0 10
78136: NOT
78137: IFFALSE 78149
// idle_lab := j ;
78139: LD_ADDR_VAR 0 11
78143: PUSH
78144: LD_VAR 0 3
78148: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78149: LD_VAR 0 3
78153: PPUSH
78154: CALL_OW 461
78158: PUSH
78159: LD_INT 10
78161: EQUAL
78162: IFFALSE 78768
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78164: LD_EXP 92
78168: PUSH
78169: LD_VAR 0 2
78173: ARRAY
78174: NOT
78175: IFFALSE 78190
78177: PUSH
78178: LD_EXP 93
78182: PUSH
78183: LD_VAR 0 2
78187: ARRAY
78188: NOT
78189: AND
78190: IFFALSE 78208
78192: PUSH
78193: LD_EXP 90
78197: PUSH
78198: LD_VAR 0 4
78202: ARRAY
78203: PUSH
78204: LD_INT 1
78206: GREATER
78207: AND
78208: IFFALSE 78339
// begin ComCancel ( j ) ;
78210: LD_VAR 0 3
78214: PPUSH
78215: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78219: LD_ADDR_EXP 90
78223: PUSH
78224: LD_EXP 90
78228: PPUSH
78229: LD_VAR 0 4
78233: PPUSH
78234: LD_EXP 90
78238: PUSH
78239: LD_VAR 0 4
78243: ARRAY
78244: PPUSH
78245: LD_EXP 90
78249: PUSH
78250: LD_VAR 0 4
78254: ARRAY
78255: PUSH
78256: LD_INT 1
78258: MINUS
78259: PPUSH
78260: LD_EXP 90
78264: PUSH
78265: LD_VAR 0 4
78269: ARRAY
78270: PPUSH
78271: LD_INT 0
78273: PPUSH
78274: CALL 21890 0 4
78278: PPUSH
78279: CALL_OW 1
78283: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78284: LD_ADDR_EXP 90
78288: PUSH
78289: LD_EXP 90
78293: PPUSH
78294: LD_VAR 0 4
78298: PPUSH
78299: LD_EXP 90
78303: PUSH
78304: LD_VAR 0 4
78308: ARRAY
78309: PPUSH
78310: LD_EXP 90
78314: PUSH
78315: LD_VAR 0 4
78319: ARRAY
78320: PPUSH
78321: LD_INT 1
78323: PPUSH
78324: LD_INT 0
78326: PPUSH
78327: CALL 21890 0 4
78331: PPUSH
78332: CALL_OW 1
78336: ST_TO_ADDR
// continue ;
78337: GO 77903
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78339: LD_EXP 92
78343: PUSH
78344: LD_VAR 0 2
78348: ARRAY
78349: IFFALSE 78364
78351: PUSH
78352: LD_EXP 93
78356: PUSH
78357: LD_VAR 0 2
78361: ARRAY
78362: NOT
78363: AND
78364: IFFALSE 78491
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78366: LD_ADDR_EXP 93
78370: PUSH
78371: LD_EXP 93
78375: PPUSH
78376: LD_VAR 0 2
78380: PUSH
78381: LD_EXP 93
78385: PUSH
78386: LD_VAR 0 2
78390: ARRAY
78391: PUSH
78392: LD_INT 1
78394: PLUS
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PPUSH
78400: LD_EXP 92
78404: PUSH
78405: LD_VAR 0 2
78409: ARRAY
78410: PUSH
78411: LD_INT 1
78413: ARRAY
78414: PPUSH
78415: CALL 22482 0 3
78419: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78420: LD_EXP 92
78424: PUSH
78425: LD_VAR 0 2
78429: ARRAY
78430: PUSH
78431: LD_INT 1
78433: ARRAY
78434: PPUSH
78435: LD_INT 112
78437: PPUSH
78438: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78442: LD_ADDR_VAR 0 9
78446: PUSH
78447: LD_EXP 92
78451: PUSH
78452: LD_VAR 0 2
78456: ARRAY
78457: PPUSH
78458: LD_INT 1
78460: PPUSH
78461: CALL_OW 3
78465: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78466: LD_ADDR_EXP 92
78470: PUSH
78471: LD_EXP 92
78475: PPUSH
78476: LD_VAR 0 2
78480: PPUSH
78481: LD_VAR 0 9
78485: PPUSH
78486: CALL_OW 1
78490: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78491: LD_EXP 92
78495: PUSH
78496: LD_VAR 0 2
78500: ARRAY
78501: IFFALSE 78515
78503: PUSH
78504: LD_EXP 93
78508: PUSH
78509: LD_VAR 0 2
78513: ARRAY
78514: AND
78515: IFFALSE 78539
78517: PUSH
78518: LD_EXP 93
78522: PUSH
78523: LD_VAR 0 2
78527: ARRAY
78528: PUSH
78529: LD_INT 1
78531: ARRAY
78532: PPUSH
78533: CALL_OW 310
78537: NOT
78538: AND
78539: IFFALSE 78556
78541: PUSH
78542: LD_VAR 0 3
78546: PPUSH
78547: CALL_OW 313
78551: PUSH
78552: LD_INT 6
78554: EQUAL
78555: AND
78556: IFFALSE 78612
// begin tmp2 := UnitsInside ( j ) ;
78558: LD_ADDR_VAR 0 9
78562: PUSH
78563: LD_VAR 0 3
78567: PPUSH
78568: CALL_OW 313
78572: ST_TO_ADDR
// if tmp2 = 6 then
78573: LD_VAR 0 9
78577: PUSH
78578: LD_INT 6
78580: EQUAL
78581: IFFALSE 78612
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78583: LD_VAR 0 9
78587: PUSH
78588: LD_INT 1
78590: ARRAY
78591: PPUSH
78592: LD_INT 112
78594: PPUSH
78595: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78599: LD_VAR 0 9
78603: PUSH
78604: LD_INT 1
78606: ARRAY
78607: PPUSH
78608: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78612: LD_EXP 93
78616: PUSH
78617: LD_VAR 0 2
78621: ARRAY
78622: IFFALSE 78646
78624: PUSH
78625: LD_EXP 93
78629: PUSH
78630: LD_VAR 0 2
78634: ARRAY
78635: PUSH
78636: LD_INT 1
78638: ARRAY
78639: PPUSH
78640: CALL_OW 314
78644: NOT
78645: AND
78646: IFFALSE 78670
78648: PUSH
78649: LD_EXP 93
78653: PUSH
78654: LD_VAR 0 2
78658: ARRAY
78659: PUSH
78660: LD_INT 1
78662: ARRAY
78663: PPUSH
78664: CALL_OW 310
78668: NOT
78669: AND
78670: IFFALSE 78696
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78672: LD_EXP 93
78676: PUSH
78677: LD_VAR 0 2
78681: ARRAY
78682: PUSH
78683: LD_INT 1
78685: ARRAY
78686: PPUSH
78687: LD_VAR 0 3
78691: PPUSH
78692: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78696: LD_EXP 93
78700: PUSH
78701: LD_VAR 0 2
78705: ARRAY
78706: PUSH
78707: LD_INT 1
78709: ARRAY
78710: PPUSH
78711: CALL_OW 310
78715: IFFALSE 78747
78717: PUSH
78718: LD_EXP 93
78722: PUSH
78723: LD_VAR 0 2
78727: ARRAY
78728: PUSH
78729: LD_INT 1
78731: ARRAY
78732: PPUSH
78733: CALL_OW 310
78737: PPUSH
78738: CALL_OW 461
78742: PUSH
78743: LD_INT 3
78745: NONEQUAL
78746: AND
78747: IFFALSE 78768
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78749: LD_EXP 93
78753: PUSH
78754: LD_VAR 0 2
78758: ARRAY
78759: PUSH
78760: LD_INT 1
78762: ARRAY
78763: PPUSH
78764: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78768: LD_VAR 0 3
78772: PPUSH
78773: CALL_OW 461
78777: PUSH
78778: LD_INT 6
78780: EQUAL
78781: IFFALSE 78793
78783: PUSH
78784: LD_VAR 0 6
78788: PUSH
78789: LD_INT 1
78791: GREATER
78792: AND
78793: IFFALSE 78947
// begin sci := [ ] ;
78795: LD_ADDR_VAR 0 8
78799: PUSH
78800: EMPTY
78801: ST_TO_ADDR
// for x in ( tmp diff j ) do
78802: LD_ADDR_VAR 0 7
78806: PUSH
78807: LD_VAR 0 6
78811: PUSH
78812: LD_VAR 0 3
78816: DIFF
78817: PUSH
78818: FOR_IN
78819: IFFALSE 78871
// begin if sci = 6 then
78821: LD_VAR 0 8
78825: PUSH
78826: LD_INT 6
78828: EQUAL
78829: IFFALSE 78833
// break ;
78831: GO 78871
// if BuildingStatus ( x ) = bs_idle then
78833: LD_VAR 0 7
78837: PPUSH
78838: CALL_OW 461
78842: PUSH
78843: LD_INT 2
78845: EQUAL
78846: IFFALSE 78869
// sci := sci ^ UnitsInside ( x ) ;
78848: LD_ADDR_VAR 0 8
78852: PUSH
78853: LD_VAR 0 8
78857: PUSH
78858: LD_VAR 0 7
78862: PPUSH
78863: CALL_OW 313
78867: ADD
78868: ST_TO_ADDR
// end ;
78869: GO 78818
78871: POP
78872: POP
// if not sci then
78873: LD_VAR 0 8
78877: NOT
78878: IFFALSE 78882
// continue ;
78880: GO 77903
// for x in sci do
78882: LD_ADDR_VAR 0 7
78886: PUSH
78887: LD_VAR 0 8
78891: PUSH
78892: FOR_IN
78893: IFFALSE 78945
// if IsInUnit ( x ) and not HasTask ( x ) then
78895: LD_VAR 0 7
78899: PPUSH
78900: CALL_OW 310
78904: IFFALSE 78918
78906: PUSH
78907: LD_VAR 0 7
78911: PPUSH
78912: CALL_OW 314
78916: NOT
78917: AND
78918: IFFALSE 78943
// begin ComExitBuilding ( x ) ;
78920: LD_VAR 0 7
78924: PPUSH
78925: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78929: LD_VAR 0 7
78933: PPUSH
78934: LD_VAR 0 3
78938: PPUSH
78939: CALL_OW 180
// end ;
78943: GO 78892
78945: POP
78946: POP
// end ; end ;
78947: GO 77903
78949: POP
78950: POP
// end ;
78951: GO 77857
78953: POP
78954: POP
// end ;
78955: LD_VAR 0 1
78959: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
78960: LD_INT 0
78962: PPUSH
78963: PPUSH
// if not mc_bases then
78964: LD_EXP 63
78968: NOT
78969: IFFALSE 78973
// exit ;
78971: GO 79056
// for i = 1 to mc_bases do
78973: LD_ADDR_VAR 0 2
78977: PUSH
78978: DOUBLE
78979: LD_INT 1
78981: DEC
78982: ST_TO_ADDR
78983: LD_EXP 63
78987: PUSH
78988: FOR_TO
78989: IFFALSE 79054
// if mc_mines [ i ] and mc_miners [ i ] then
78991: LD_EXP 76
78995: PUSH
78996: LD_VAR 0 2
79000: ARRAY
79001: IFFALSE 79015
79003: PUSH
79004: LD_EXP 77
79008: PUSH
79009: LD_VAR 0 2
79013: ARRAY
79014: AND
79015: IFFALSE 79052
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79017: LD_EXP 77
79021: PUSH
79022: LD_VAR 0 2
79026: ARRAY
79027: PUSH
79028: LD_INT 1
79030: ARRAY
79031: PPUSH
79032: CALL_OW 255
79036: PPUSH
79037: LD_EXP 76
79041: PUSH
79042: LD_VAR 0 2
79046: ARRAY
79047: PPUSH
79048: CALL 19435 0 2
79052: GO 78988
79054: POP
79055: POP
// end ;
79056: LD_VAR 0 1
79060: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79061: LD_INT 0
79063: PPUSH
79064: PPUSH
79065: PPUSH
79066: PPUSH
79067: PPUSH
79068: PPUSH
79069: PPUSH
79070: PPUSH
// if not mc_bases or not mc_parking then
79071: LD_EXP 63
79075: NOT
79076: IFTRUE 79085
79078: PUSH
79079: LD_EXP 87
79083: NOT
79084: OR
79085: IFFALSE 79089
// exit ;
79087: GO 79833
// for i = 1 to mc_bases do
79089: LD_ADDR_VAR 0 2
79093: PUSH
79094: DOUBLE
79095: LD_INT 1
79097: DEC
79098: ST_TO_ADDR
79099: LD_EXP 63
79103: PUSH
79104: FOR_TO
79105: IFFALSE 79831
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79107: LD_EXP 63
79111: PUSH
79112: LD_VAR 0 2
79116: ARRAY
79117: NOT
79118: IFTRUE 79133
79120: PUSH
79121: LD_EXP 87
79125: PUSH
79126: LD_VAR 0 2
79130: ARRAY
79131: NOT
79132: OR
79133: IFFALSE 79137
// continue ;
79135: GO 79104
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79137: LD_ADDR_VAR 0 5
79141: PUSH
79142: LD_EXP 63
79146: PUSH
79147: LD_VAR 0 2
79151: ARRAY
79152: PUSH
79153: LD_INT 1
79155: ARRAY
79156: PPUSH
79157: CALL_OW 255
79161: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79162: LD_ADDR_VAR 0 6
79166: PUSH
79167: LD_EXP 63
79171: PUSH
79172: LD_VAR 0 2
79176: ARRAY
79177: PPUSH
79178: LD_INT 30
79180: PUSH
79181: LD_INT 3
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PPUSH
79188: CALL_OW 72
79192: ST_TO_ADDR
// if not fac then
79193: LD_VAR 0 6
79197: NOT
79198: IFFALSE 79249
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79200: LD_ADDR_VAR 0 6
79204: PUSH
79205: LD_EXP 63
79209: PUSH
79210: LD_VAR 0 2
79214: ARRAY
79215: PPUSH
79216: LD_INT 2
79218: PUSH
79219: LD_INT 30
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 30
79231: PUSH
79232: LD_INT 1
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: LIST
79243: PPUSH
79244: CALL_OW 72
79248: ST_TO_ADDR
// if not fac then
79249: LD_VAR 0 6
79253: NOT
79254: IFFALSE 79258
// continue ;
79256: GO 79104
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79258: LD_ADDR_VAR 0 7
79262: PUSH
79263: LD_EXP 87
79267: PUSH
79268: LD_VAR 0 2
79272: ARRAY
79273: PPUSH
79274: LD_INT 22
79276: PUSH
79277: LD_VAR 0 5
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 21
79288: PUSH
79289: LD_INT 2
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 3
79298: PUSH
79299: LD_INT 60
79301: PUSH
79302: EMPTY
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 3
79311: PUSH
79312: LD_INT 24
79314: PUSH
79315: LD_INT 1000
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: PPUSH
79332: CALL_OW 70
79336: ST_TO_ADDR
// for j in fac do
79337: LD_ADDR_VAR 0 3
79341: PUSH
79342: LD_VAR 0 6
79346: PUSH
79347: FOR_IN
79348: IFFALSE 79443
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79350: LD_ADDR_VAR 0 7
79354: PUSH
79355: LD_VAR 0 7
79359: PUSH
79360: LD_INT 22
79362: PUSH
79363: LD_VAR 0 5
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: PUSH
79372: LD_INT 91
79374: PUSH
79375: LD_VAR 0 3
79379: PUSH
79380: LD_INT 15
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 21
79390: PUSH
79391: LD_INT 2
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 3
79400: PUSH
79401: LD_INT 60
79403: PUSH
79404: EMPTY
79405: LIST
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 3
79413: PUSH
79414: LD_INT 24
79416: PUSH
79417: LD_INT 1000
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: PPUSH
79435: CALL_OW 69
79439: UNION
79440: ST_TO_ADDR
79441: GO 79347
79443: POP
79444: POP
// if not vehs then
79445: LD_VAR 0 7
79449: NOT
79450: IFFALSE 79476
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79452: LD_ADDR_EXP 75
79456: PUSH
79457: LD_EXP 75
79461: PPUSH
79462: LD_VAR 0 2
79466: PPUSH
79467: EMPTY
79468: PPUSH
79469: CALL_OW 1
79473: ST_TO_ADDR
// continue ;
79474: GO 79104
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79476: LD_ADDR_VAR 0 8
79480: PUSH
79481: LD_EXP 63
79485: PUSH
79486: LD_VAR 0 2
79490: ARRAY
79491: PPUSH
79492: LD_INT 30
79494: PUSH
79495: LD_INT 3
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PPUSH
79502: CALL_OW 72
79506: ST_TO_ADDR
// if tmp then
79507: LD_VAR 0 8
79511: IFFALSE 79614
// begin for j in tmp do
79513: LD_ADDR_VAR 0 3
79517: PUSH
79518: LD_VAR 0 8
79522: PUSH
79523: FOR_IN
79524: IFFALSE 79612
// for k in UnitsInside ( j ) do
79526: LD_ADDR_VAR 0 4
79530: PUSH
79531: LD_VAR 0 3
79535: PPUSH
79536: CALL_OW 313
79540: PUSH
79541: FOR_IN
79542: IFFALSE 79608
// if k then
79544: LD_VAR 0 4
79548: IFFALSE 79606
// if not k in mc_repair_vehicle [ i ] then
79550: LD_VAR 0 4
79554: PUSH
79555: LD_EXP 75
79559: PUSH
79560: LD_VAR 0 2
79564: ARRAY
79565: IN
79566: NOT
79567: IFFALSE 79606
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79569: LD_ADDR_EXP 75
79573: PUSH
79574: LD_EXP 75
79578: PPUSH
79579: LD_VAR 0 2
79583: PPUSH
79584: LD_EXP 75
79588: PUSH
79589: LD_VAR 0 2
79593: ARRAY
79594: PUSH
79595: LD_VAR 0 4
79599: UNION
79600: PPUSH
79601: CALL_OW 1
79605: ST_TO_ADDR
79606: GO 79541
79608: POP
79609: POP
79610: GO 79523
79612: POP
79613: POP
// end ; if not mc_repair_vehicle [ i ] then
79614: LD_EXP 75
79618: PUSH
79619: LD_VAR 0 2
79623: ARRAY
79624: NOT
79625: IFFALSE 79629
// continue ;
79627: GO 79104
// for j in mc_repair_vehicle [ i ] do
79629: LD_ADDR_VAR 0 3
79633: PUSH
79634: LD_EXP 75
79638: PUSH
79639: LD_VAR 0 2
79643: ARRAY
79644: PUSH
79645: FOR_IN
79646: IFFALSE 79827
// begin if GetClass ( j ) <> 3 then
79648: LD_VAR 0 3
79652: PPUSH
79653: CALL_OW 257
79657: PUSH
79658: LD_INT 3
79660: NONEQUAL
79661: IFFALSE 79702
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79663: LD_ADDR_EXP 75
79667: PUSH
79668: LD_EXP 75
79672: PPUSH
79673: LD_VAR 0 2
79677: PPUSH
79678: LD_EXP 75
79682: PUSH
79683: LD_VAR 0 2
79687: ARRAY
79688: PUSH
79689: LD_VAR 0 3
79693: DIFF
79694: PPUSH
79695: CALL_OW 1
79699: ST_TO_ADDR
// continue ;
79700: GO 79645
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79702: LD_VAR 0 3
79706: PPUSH
79707: CALL_OW 311
79711: NOT
79712: IFFALSE 79737
79714: PUSH
79715: LD_VAR 0 3
79719: PUSH
79720: LD_EXP 66
79724: PUSH
79725: LD_VAR 0 2
79729: ARRAY
79730: PUSH
79731: LD_INT 1
79733: ARRAY
79734: IN
79735: NOT
79736: AND
79737: IFFALSE 79762
79739: PUSH
79740: LD_VAR 0 3
79744: PUSH
79745: LD_EXP 66
79749: PUSH
79750: LD_VAR 0 2
79754: ARRAY
79755: PUSH
79756: LD_INT 2
79758: ARRAY
79759: IN
79760: NOT
79761: AND
79762: IFFALSE 79825
// begin if IsInUnit ( j ) then
79764: LD_VAR 0 3
79768: PPUSH
79769: CALL_OW 310
79773: IFFALSE 79786
// ComExitBuilding ( j ) else
79775: LD_VAR 0 3
79779: PPUSH
79780: CALL_OW 122
79784: GO 79825
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79786: LD_VAR 0 3
79790: PPUSH
79791: LD_VAR 0 7
79795: PUSH
79796: LD_INT 1
79798: ARRAY
79799: PPUSH
79800: CALL 57613 0 2
79804: NOT
79805: IFFALSE 79825
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79807: LD_VAR 0 3
79811: PPUSH
79812: LD_VAR 0 7
79816: PUSH
79817: LD_INT 1
79819: ARRAY
79820: PPUSH
79821: CALL_OW 129
// end ; end ;
79825: GO 79645
79827: POP
79828: POP
// end ;
79829: GO 79104
79831: POP
79832: POP
// end ;
79833: LD_VAR 0 1
79837: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79838: LD_INT 0
79840: PPUSH
79841: PPUSH
79842: PPUSH
79843: PPUSH
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
// if not mc_bases then
79851: LD_EXP 63
79855: NOT
79856: IFFALSE 79860
// exit ;
79858: GO 80678
// for i = 1 to mc_bases do
79860: LD_ADDR_VAR 0 2
79864: PUSH
79865: DOUBLE
79866: LD_INT 1
79868: DEC
79869: ST_TO_ADDR
79870: LD_EXP 63
79874: PUSH
79875: FOR_TO
79876: IFFALSE 80676
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
79878: LD_EXP 91
79882: PUSH
79883: LD_VAR 0 2
79887: ARRAY
79888: NOT
79889: IFTRUE 79907
79891: PUSH
79892: LD_EXP 66
79896: PUSH
79897: LD_VAR 0 2
79901: ARRAY
79902: PUSH
79903: LD_INT 1
79905: ARRAY
79906: OR
79907: IFTRUE 79925
79909: PUSH
79910: LD_EXP 66
79914: PUSH
79915: LD_VAR 0 2
79919: ARRAY
79920: PUSH
79921: LD_INT 2
79923: ARRAY
79924: OR
79925: IFTRUE 79948
79927: PUSH
79928: LD_EXP 89
79932: PUSH
79933: LD_VAR 0 2
79937: ARRAY
79938: PPUSH
79939: LD_INT 1
79941: PPUSH
79942: CALL_OW 325
79946: NOT
79947: OR
79948: IFTRUE 79962
79950: PUSH
79951: LD_EXP 86
79955: PUSH
79956: LD_VAR 0 2
79960: ARRAY
79961: OR
79962: IFFALSE 79966
// continue ;
79964: GO 79875
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
79966: LD_ADDR_VAR 0 8
79970: PUSH
79971: LD_EXP 63
79975: PUSH
79976: LD_VAR 0 2
79980: ARRAY
79981: PPUSH
79982: LD_INT 25
79984: PUSH
79985: LD_INT 4
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 50
79994: PUSH
79995: EMPTY
79996: LIST
79997: PUSH
79998: LD_INT 3
80000: PUSH
80001: LD_INT 60
80003: PUSH
80004: EMPTY
80005: LIST
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: LIST
80015: PPUSH
80016: CALL_OW 72
80020: PUSH
80021: LD_EXP 67
80025: PUSH
80026: LD_VAR 0 2
80030: ARRAY
80031: DIFF
80032: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80033: LD_ADDR_VAR 0 9
80037: PUSH
80038: LD_EXP 63
80042: PUSH
80043: LD_VAR 0 2
80047: ARRAY
80048: PPUSH
80049: LD_INT 2
80051: PUSH
80052: LD_INT 30
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: LD_INT 30
80064: PUSH
80065: LD_INT 1
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: LIST
80076: PPUSH
80077: CALL_OW 72
80081: ST_TO_ADDR
// if not tmp or not dep then
80082: LD_VAR 0 8
80086: NOT
80087: IFTRUE 80096
80089: PUSH
80090: LD_VAR 0 9
80094: NOT
80095: OR
80096: IFFALSE 80100
// continue ;
80098: GO 79875
// side := GetSide ( tmp [ 1 ] ) ;
80100: LD_ADDR_VAR 0 11
80104: PUSH
80105: LD_VAR 0 8
80109: PUSH
80110: LD_INT 1
80112: ARRAY
80113: PPUSH
80114: CALL_OW 255
80118: ST_TO_ADDR
// dep := dep [ 1 ] ;
80119: LD_ADDR_VAR 0 9
80123: PUSH
80124: LD_VAR 0 9
80128: PUSH
80129: LD_INT 1
80131: ARRAY
80132: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80133: LD_ADDR_VAR 0 7
80137: PUSH
80138: LD_EXP 91
80142: PUSH
80143: LD_VAR 0 2
80147: ARRAY
80148: PPUSH
80149: LD_INT 22
80151: PUSH
80152: LD_INT 0
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 25
80161: PUSH
80162: LD_INT 12
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PPUSH
80173: CALL_OW 70
80177: PUSH
80178: LD_INT 22
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 25
80190: PUSH
80191: LD_INT 12
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 91
80200: PUSH
80201: LD_VAR 0 9
80205: PUSH
80206: LD_INT 20
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: LIST
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: LIST
80218: PPUSH
80219: CALL_OW 69
80223: UNION
80224: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80225: LD_ADDR_VAR 0 10
80229: PUSH
80230: LD_EXP 91
80234: PUSH
80235: LD_VAR 0 2
80239: ARRAY
80240: PPUSH
80241: LD_INT 81
80243: PUSH
80244: LD_VAR 0 11
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PPUSH
80253: CALL_OW 70
80257: ST_TO_ADDR
// if not apes or danger_at_area then
80258: LD_VAR 0 7
80262: NOT
80263: IFTRUE 80271
80265: PUSH
80266: LD_VAR 0 10
80270: OR
80271: IFFALSE 80321
// begin if mc_taming [ i ] then
80273: LD_EXP 94
80277: PUSH
80278: LD_VAR 0 2
80282: ARRAY
80283: IFFALSE 80319
// begin MC_Reset ( i , 121 ) ;
80285: LD_VAR 0 2
80289: PPUSH
80290: LD_INT 121
80292: PPUSH
80293: CALL 65053 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80297: LD_ADDR_EXP 94
80301: PUSH
80302: LD_EXP 94
80306: PPUSH
80307: LD_VAR 0 2
80311: PPUSH
80312: EMPTY
80313: PPUSH
80314: CALL_OW 1
80318: ST_TO_ADDR
// end ; continue ;
80319: GO 79875
// end ; for j in tmp do
80321: LD_ADDR_VAR 0 3
80325: PUSH
80326: LD_VAR 0 8
80330: PUSH
80331: FOR_IN
80332: IFFALSE 80672
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80334: LD_VAR 0 3
80338: PUSH
80339: LD_EXP 94
80343: PUSH
80344: LD_VAR 0 2
80348: ARRAY
80349: IN
80350: NOT
80351: IFFALSE 80369
80353: PUSH
80354: LD_EXP 94
80358: PUSH
80359: LD_VAR 0 2
80363: ARRAY
80364: PUSH
80365: LD_INT 3
80367: LESS
80368: AND
80369: IFFALSE 80427
// begin SetTag ( j , 121 ) ;
80371: LD_VAR 0 3
80375: PPUSH
80376: LD_INT 121
80378: PPUSH
80379: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80383: LD_ADDR_EXP 94
80387: PUSH
80388: LD_EXP 94
80392: PPUSH
80393: LD_VAR 0 2
80397: PUSH
80398: LD_EXP 94
80402: PUSH
80403: LD_VAR 0 2
80407: ARRAY
80408: PUSH
80409: LD_INT 1
80411: PLUS
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PPUSH
80417: LD_VAR 0 3
80421: PPUSH
80422: CALL 22482 0 3
80426: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80427: LD_VAR 0 3
80431: PUSH
80432: LD_EXP 94
80436: PUSH
80437: LD_VAR 0 2
80441: ARRAY
80442: IN
80443: IFFALSE 80670
// begin if GetClass ( j ) <> 4 then
80445: LD_VAR 0 3
80449: PPUSH
80450: CALL_OW 257
80454: PUSH
80455: LD_INT 4
80457: NONEQUAL
80458: IFFALSE 80511
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80460: LD_ADDR_EXP 94
80464: PUSH
80465: LD_EXP 94
80469: PPUSH
80470: LD_VAR 0 2
80474: PPUSH
80475: LD_EXP 94
80479: PUSH
80480: LD_VAR 0 2
80484: ARRAY
80485: PUSH
80486: LD_VAR 0 3
80490: DIFF
80491: PPUSH
80492: CALL_OW 1
80496: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80497: LD_VAR 0 3
80501: PPUSH
80502: LD_INT 0
80504: PPUSH
80505: CALL_OW 109
// continue ;
80509: GO 80331
// end ; if IsInUnit ( j ) then
80511: LD_VAR 0 3
80515: PPUSH
80516: CALL_OW 310
80520: IFFALSE 80531
// ComExitBuilding ( j ) ;
80522: LD_VAR 0 3
80526: PPUSH
80527: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80531: LD_ADDR_VAR 0 6
80535: PUSH
80536: LD_VAR 0 7
80540: PPUSH
80541: LD_VAR 0 3
80545: PPUSH
80546: CALL_OW 74
80550: ST_TO_ADDR
// if not ape then
80551: LD_VAR 0 6
80555: NOT
80556: IFFALSE 80560
// break ;
80558: GO 80672
// x := GetX ( ape ) ;
80560: LD_ADDR_VAR 0 4
80564: PUSH
80565: LD_VAR 0 6
80569: PPUSH
80570: CALL_OW 250
80574: ST_TO_ADDR
// y := GetY ( ape ) ;
80575: LD_ADDR_VAR 0 5
80579: PUSH
80580: LD_VAR 0 6
80584: PPUSH
80585: CALL_OW 251
80589: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80590: LD_VAR 0 4
80594: PPUSH
80595: LD_VAR 0 5
80599: PPUSH
80600: CALL_OW 488
80604: NOT
80605: IFTRUE 80635
80607: PUSH
80608: LD_VAR 0 11
80612: PPUSH
80613: LD_VAR 0 4
80617: PPUSH
80618: LD_VAR 0 5
80622: PPUSH
80623: LD_INT 20
80625: PPUSH
80626: CALL 23752 0 4
80630: PUSH
80631: LD_INT 4
80633: ARRAY
80634: OR
80635: IFFALSE 80639
// break ;
80637: GO 80672
// if not HasTask ( j ) then
80639: LD_VAR 0 3
80643: PPUSH
80644: CALL_OW 314
80648: NOT
80649: IFFALSE 80670
// ComTameXY ( j , x , y ) ;
80651: LD_VAR 0 3
80655: PPUSH
80656: LD_VAR 0 4
80660: PPUSH
80661: LD_VAR 0 5
80665: PPUSH
80666: CALL_OW 131
// end ; end ;
80670: GO 80331
80672: POP
80673: POP
// end ;
80674: GO 79875
80676: POP
80677: POP
// end ;
80678: LD_VAR 0 1
80682: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80683: LD_INT 0
80685: PPUSH
80686: PPUSH
80687: PPUSH
80688: PPUSH
80689: PPUSH
80690: PPUSH
80691: PPUSH
80692: PPUSH
// if not mc_bases then
80693: LD_EXP 63
80697: NOT
80698: IFFALSE 80702
// exit ;
80700: GO 81334
// for i = 1 to mc_bases do
80702: LD_ADDR_VAR 0 2
80706: PUSH
80707: DOUBLE
80708: LD_INT 1
80710: DEC
80711: ST_TO_ADDR
80712: LD_EXP 63
80716: PUSH
80717: FOR_TO
80718: IFFALSE 81332
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80720: LD_EXP 92
80724: PUSH
80725: LD_VAR 0 2
80729: ARRAY
80730: NOT
80731: IFTRUE 80761
80733: PUSH
80734: LD_EXP 92
80738: PUSH
80739: LD_VAR 0 2
80743: ARRAY
80744: PPUSH
80745: LD_INT 25
80747: PUSH
80748: LD_INT 12
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PPUSH
80755: CALL_OW 72
80759: NOT
80760: OR
80761: IFFALSE 80765
// continue ;
80763: GO 80717
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80765: LD_ADDR_VAR 0 5
80769: PUSH
80770: LD_EXP 92
80774: PUSH
80775: LD_VAR 0 2
80779: ARRAY
80780: PUSH
80781: LD_INT 1
80783: ARRAY
80784: PPUSH
80785: CALL_OW 255
80789: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80790: LD_VAR 0 5
80794: PPUSH
80795: LD_INT 2
80797: PPUSH
80798: CALL_OW 325
80802: IFFALSE 81055
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80804: LD_ADDR_VAR 0 4
80808: PUSH
80809: LD_EXP 92
80813: PUSH
80814: LD_VAR 0 2
80818: ARRAY
80819: PPUSH
80820: LD_INT 25
80822: PUSH
80823: LD_INT 16
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PPUSH
80830: CALL_OW 72
80834: ST_TO_ADDR
// if tmp < 6 then
80835: LD_VAR 0 4
80839: PUSH
80840: LD_INT 6
80842: LESS
80843: IFFALSE 81055
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80845: LD_ADDR_VAR 0 6
80849: PUSH
80850: LD_EXP 63
80854: PUSH
80855: LD_VAR 0 2
80859: ARRAY
80860: PPUSH
80861: LD_INT 2
80863: PUSH
80864: LD_INT 30
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 30
80876: PUSH
80877: LD_INT 1
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: LIST
80888: PPUSH
80889: CALL_OW 72
80893: ST_TO_ADDR
// if depot then
80894: LD_VAR 0 6
80898: IFFALSE 81055
// begin selected := 0 ;
80900: LD_ADDR_VAR 0 7
80904: PUSH
80905: LD_INT 0
80907: ST_TO_ADDR
// for j in depot do
80908: LD_ADDR_VAR 0 3
80912: PUSH
80913: LD_VAR 0 6
80917: PUSH
80918: FOR_IN
80919: IFFALSE 80950
// begin if UnitsInside ( j ) < 6 then
80921: LD_VAR 0 3
80925: PPUSH
80926: CALL_OW 313
80930: PUSH
80931: LD_INT 6
80933: LESS
80934: IFFALSE 80948
// begin selected := j ;
80936: LD_ADDR_VAR 0 7
80940: PUSH
80941: LD_VAR 0 3
80945: ST_TO_ADDR
// break ;
80946: GO 80950
// end ; end ;
80948: GO 80918
80950: POP
80951: POP
// if selected then
80952: LD_VAR 0 7
80956: IFFALSE 81055
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80958: LD_ADDR_VAR 0 3
80962: PUSH
80963: LD_EXP 92
80967: PUSH
80968: LD_VAR 0 2
80972: ARRAY
80973: PPUSH
80974: LD_INT 25
80976: PUSH
80977: LD_INT 12
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PPUSH
80984: CALL_OW 72
80988: PUSH
80989: FOR_IN
80990: IFFALSE 81053
// if not HasTask ( j ) then
80992: LD_VAR 0 3
80996: PPUSH
80997: CALL_OW 314
81001: NOT
81002: IFFALSE 81051
// begin if not IsInUnit ( j ) then
81004: LD_VAR 0 3
81008: PPUSH
81009: CALL_OW 310
81013: NOT
81014: IFFALSE 81030
// ComEnterUnit ( j , selected ) ;
81016: LD_VAR 0 3
81020: PPUSH
81021: LD_VAR 0 7
81025: PPUSH
81026: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81030: LD_VAR 0 3
81034: PPUSH
81035: LD_INT 16
81037: PPUSH
81038: CALL_OW 183
// AddComExitBuilding ( j ) ;
81042: LD_VAR 0 3
81046: PPUSH
81047: CALL_OW 182
// end ;
81051: GO 80989
81053: POP
81054: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81055: LD_VAR 0 5
81059: PPUSH
81060: LD_INT 11
81062: PPUSH
81063: CALL_OW 325
81067: IFFALSE 81330
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81069: LD_ADDR_VAR 0 4
81073: PUSH
81074: LD_EXP 92
81078: PUSH
81079: LD_VAR 0 2
81083: ARRAY
81084: PPUSH
81085: LD_INT 25
81087: PUSH
81088: LD_INT 16
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PPUSH
81095: CALL_OW 72
81099: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81100: LD_VAR 0 4
81104: PUSH
81105: LD_INT 6
81107: GREATEREQUAL
81108: IFTRUE 81125
81110: PUSH
81111: LD_VAR 0 5
81115: PPUSH
81116: LD_INT 2
81118: PPUSH
81119: CALL_OW 325
81123: NOT
81124: OR
81125: IFFALSE 81330
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81127: LD_ADDR_VAR 0 8
81131: PUSH
81132: LD_EXP 63
81136: PUSH
81137: LD_VAR 0 2
81141: ARRAY
81142: PPUSH
81143: LD_INT 2
81145: PUSH
81146: LD_INT 30
81148: PUSH
81149: LD_INT 4
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 30
81158: PUSH
81159: LD_INT 5
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: LIST
81170: PPUSH
81171: CALL_OW 72
81175: ST_TO_ADDR
// if barracks then
81176: LD_VAR 0 8
81180: IFFALSE 81330
// begin selected := 0 ;
81182: LD_ADDR_VAR 0 7
81186: PUSH
81187: LD_INT 0
81189: ST_TO_ADDR
// for j in barracks do
81190: LD_ADDR_VAR 0 3
81194: PUSH
81195: LD_VAR 0 8
81199: PUSH
81200: FOR_IN
81201: IFFALSE 81232
// begin if UnitsInside ( j ) < 6 then
81203: LD_VAR 0 3
81207: PPUSH
81208: CALL_OW 313
81212: PUSH
81213: LD_INT 6
81215: LESS
81216: IFFALSE 81230
// begin selected := j ;
81218: LD_ADDR_VAR 0 7
81222: PUSH
81223: LD_VAR 0 3
81227: ST_TO_ADDR
// break ;
81228: GO 81232
// end ; end ;
81230: GO 81200
81232: POP
81233: POP
// if selected then
81234: LD_VAR 0 7
81238: IFFALSE 81330
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81240: LD_ADDR_VAR 0 3
81244: PUSH
81245: LD_EXP 92
81249: PUSH
81250: LD_VAR 0 2
81254: ARRAY
81255: PPUSH
81256: LD_INT 25
81258: PUSH
81259: LD_INT 12
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PPUSH
81266: CALL_OW 72
81270: PUSH
81271: FOR_IN
81272: IFFALSE 81328
// if not IsInUnit ( j ) and not HasTask ( j ) then
81274: LD_VAR 0 3
81278: PPUSH
81279: CALL_OW 310
81283: NOT
81284: IFFALSE 81298
81286: PUSH
81287: LD_VAR 0 3
81291: PPUSH
81292: CALL_OW 314
81296: NOT
81297: AND
81298: IFFALSE 81326
// begin ComEnterUnit ( j , selected ) ;
81300: LD_VAR 0 3
81304: PPUSH
81305: LD_VAR 0 7
81309: PPUSH
81310: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81314: LD_VAR 0 3
81318: PPUSH
81319: LD_INT 15
81321: PPUSH
81322: CALL_OW 183
// end ;
81326: GO 81271
81328: POP
81329: POP
// end ; end ; end ; end ; end ;
81330: GO 80717
81332: POP
81333: POP
// end ;
81334: LD_VAR 0 1
81338: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81339: LD_INT 0
81341: PPUSH
81342: PPUSH
81343: PPUSH
81344: PPUSH
// if not mc_bases then
81345: LD_EXP 63
81349: NOT
81350: IFFALSE 81354
// exit ;
81352: GO 81536
// for i = 1 to mc_bases do
81354: LD_ADDR_VAR 0 2
81358: PUSH
81359: DOUBLE
81360: LD_INT 1
81362: DEC
81363: ST_TO_ADDR
81364: LD_EXP 63
81368: PUSH
81369: FOR_TO
81370: IFFALSE 81534
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81372: LD_ADDR_VAR 0 4
81376: PUSH
81377: LD_EXP 63
81381: PUSH
81382: LD_VAR 0 2
81386: ARRAY
81387: PPUSH
81388: LD_INT 25
81390: PUSH
81391: LD_INT 9
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PPUSH
81398: CALL_OW 72
81402: ST_TO_ADDR
// if not tmp then
81403: LD_VAR 0 4
81407: NOT
81408: IFFALSE 81412
// continue ;
81410: GO 81369
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81412: LD_EXP 89
81416: PUSH
81417: LD_VAR 0 2
81421: ARRAY
81422: PPUSH
81423: LD_INT 29
81425: PPUSH
81426: CALL_OW 325
81430: NOT
81431: IFFALSE 81454
81433: PUSH
81434: LD_EXP 89
81438: PUSH
81439: LD_VAR 0 2
81443: ARRAY
81444: PPUSH
81445: LD_INT 28
81447: PPUSH
81448: CALL_OW 325
81452: NOT
81453: AND
81454: IFFALSE 81458
// continue ;
81456: GO 81369
// for j in tmp do
81458: LD_ADDR_VAR 0 3
81462: PUSH
81463: LD_VAR 0 4
81467: PUSH
81468: FOR_IN
81469: IFFALSE 81530
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81471: LD_VAR 0 3
81475: PUSH
81476: LD_EXP 66
81480: PUSH
81481: LD_VAR 0 2
81485: ARRAY
81486: PUSH
81487: LD_INT 1
81489: ARRAY
81490: IN
81491: NOT
81492: IFFALSE 81517
81494: PUSH
81495: LD_VAR 0 3
81499: PUSH
81500: LD_EXP 66
81504: PUSH
81505: LD_VAR 0 2
81509: ARRAY
81510: PUSH
81511: LD_INT 2
81513: ARRAY
81514: IN
81515: NOT
81516: AND
81517: IFFALSE 81528
// ComSpaceTimeShoot ( j ) ;
81519: LD_VAR 0 3
81523: PPUSH
81524: CALL 18433 0 1
81528: GO 81468
81530: POP
81531: POP
// end ;
81532: GO 81369
81534: POP
81535: POP
// end ;
81536: LD_VAR 0 1
81540: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81541: LD_INT 0
81543: PPUSH
81544: PPUSH
81545: PPUSH
81546: PPUSH
81547: PPUSH
81548: PPUSH
81549: PPUSH
81550: PPUSH
81551: PPUSH
// if not mc_bases then
81552: LD_EXP 63
81556: NOT
81557: IFFALSE 81561
// exit ;
81559: GO 82193
// for i = 1 to mc_bases do
81561: LD_ADDR_VAR 0 2
81565: PUSH
81566: DOUBLE
81567: LD_INT 1
81569: DEC
81570: ST_TO_ADDR
81571: LD_EXP 63
81575: PUSH
81576: FOR_TO
81577: IFFALSE 82191
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81579: LD_EXP 98
81583: PUSH
81584: LD_VAR 0 2
81588: ARRAY
81589: NOT
81590: IFTRUE 81616
81592: PUSH
81593: LD_INT 38
81595: PPUSH
81596: LD_EXP 89
81600: PUSH
81601: LD_VAR 0 2
81605: ARRAY
81606: PPUSH
81607: CALL_OW 321
81611: PUSH
81612: LD_INT 2
81614: NONEQUAL
81615: OR
81616: IFFALSE 81620
// continue ;
81618: GO 81576
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81620: LD_ADDR_VAR 0 8
81624: PUSH
81625: LD_EXP 63
81629: PUSH
81630: LD_VAR 0 2
81634: ARRAY
81635: PPUSH
81636: LD_INT 30
81638: PUSH
81639: LD_INT 34
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PPUSH
81646: CALL_OW 72
81650: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81651: LD_ADDR_VAR 0 9
81655: PUSH
81656: LD_EXP 63
81660: PUSH
81661: LD_VAR 0 2
81665: ARRAY
81666: PPUSH
81667: LD_INT 25
81669: PUSH
81670: LD_INT 4
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PPUSH
81677: CALL_OW 72
81681: PPUSH
81682: LD_INT 0
81684: PPUSH
81685: CALL 53075 0 2
81689: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81690: LD_VAR 0 9
81694: NOT
81695: IFTRUE 81704
81697: PUSH
81698: LD_VAR 0 8
81702: NOT
81703: OR
81704: IFTRUE 81726
81706: PUSH
81707: LD_EXP 63
81711: PUSH
81712: LD_VAR 0 2
81716: ARRAY
81717: PPUSH
81718: LD_INT 124
81720: PPUSH
81721: CALL 53075 0 2
81725: OR
81726: IFFALSE 81730
// continue ;
81728: GO 81576
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81730: LD_EXP 99
81734: PUSH
81735: LD_VAR 0 2
81739: ARRAY
81740: PUSH
81741: LD_EXP 98
81745: PUSH
81746: LD_VAR 0 2
81750: ARRAY
81751: LESS
81752: IFFALSE 81772
81754: PUSH
81755: LD_EXP 99
81759: PUSH
81760: LD_VAR 0 2
81764: ARRAY
81765: PUSH
81766: LD_VAR 0 8
81770: LESS
81771: AND
81772: IFFALSE 82189
// begin tmp := sci [ 1 ] ;
81774: LD_ADDR_VAR 0 7
81778: PUSH
81779: LD_VAR 0 9
81783: PUSH
81784: LD_INT 1
81786: ARRAY
81787: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81788: LD_VAR 0 7
81792: PPUSH
81793: LD_INT 124
81795: PPUSH
81796: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81800: LD_ADDR_VAR 0 3
81804: PUSH
81805: DOUBLE
81806: LD_EXP 98
81810: PUSH
81811: LD_VAR 0 2
81815: ARRAY
81816: INC
81817: ST_TO_ADDR
81818: LD_EXP 98
81822: PUSH
81823: LD_VAR 0 2
81827: ARRAY
81828: PUSH
81829: FOR_DOWNTO
81830: IFFALSE 82175
// begin if IsInUnit ( tmp ) then
81832: LD_VAR 0 7
81836: PPUSH
81837: CALL_OW 310
81841: IFFALSE 81852
// ComExitBuilding ( tmp ) ;
81843: LD_VAR 0 7
81847: PPUSH
81848: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81852: LD_INT 35
81854: PPUSH
81855: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81859: LD_VAR 0 7
81863: PPUSH
81864: CALL_OW 310
81868: NOT
81869: IFFALSE 81883
81871: PUSH
81872: LD_VAR 0 7
81876: PPUSH
81877: CALL_OW 314
81881: NOT
81882: AND
81883: IFFALSE 81852
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81885: LD_ADDR_VAR 0 6
81889: PUSH
81890: LD_VAR 0 7
81894: PPUSH
81895: CALL_OW 250
81899: PUSH
81900: LD_VAR 0 7
81904: PPUSH
81905: CALL_OW 251
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
81914: LD_INT 35
81916: PPUSH
81917: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
81921: LD_ADDR_VAR 0 4
81925: PUSH
81926: LD_EXP 98
81930: PUSH
81931: LD_VAR 0 2
81935: ARRAY
81936: PUSH
81937: LD_VAR 0 3
81941: ARRAY
81942: PUSH
81943: LD_INT 1
81945: ARRAY
81946: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
81947: LD_ADDR_VAR 0 5
81951: PUSH
81952: LD_EXP 98
81956: PUSH
81957: LD_VAR 0 2
81961: ARRAY
81962: PUSH
81963: LD_VAR 0 3
81967: ARRAY
81968: PUSH
81969: LD_INT 2
81971: ARRAY
81972: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
81973: LD_VAR 0 7
81977: PPUSH
81978: LD_INT 10
81980: PPUSH
81981: CALL 25461 0 2
81985: PUSH
81986: LD_INT 4
81988: ARRAY
81989: IFFALSE 82027
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
81991: LD_VAR 0 7
81995: PPUSH
81996: LD_VAR 0 6
82000: PUSH
82001: LD_INT 1
82003: ARRAY
82004: PPUSH
82005: LD_VAR 0 6
82009: PUSH
82010: LD_INT 2
82012: ARRAY
82013: PPUSH
82014: CALL_OW 111
// wait ( 0 0$10 ) ;
82018: LD_INT 350
82020: PPUSH
82021: CALL_OW 67
// end else
82025: GO 82053
// begin ComMoveXY ( tmp , x , y ) ;
82027: LD_VAR 0 7
82031: PPUSH
82032: LD_VAR 0 4
82036: PPUSH
82037: LD_VAR 0 5
82041: PPUSH
82042: CALL_OW 111
// wait ( 0 0$3 ) ;
82046: LD_INT 105
82048: PPUSH
82049: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82053: LD_VAR 0 7
82057: PPUSH
82058: LD_VAR 0 4
82062: PPUSH
82063: LD_VAR 0 5
82067: PPUSH
82068: CALL_OW 307
82072: IFFALSE 81914
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82074: LD_VAR 0 7
82078: PPUSH
82079: LD_VAR 0 4
82083: PPUSH
82084: LD_VAR 0 5
82088: PPUSH
82089: LD_VAR 0 8
82093: PUSH
82094: LD_VAR 0 3
82098: ARRAY
82099: PPUSH
82100: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82104: LD_INT 35
82106: PPUSH
82107: CALL_OW 67
// until not HasTask ( tmp ) ;
82111: LD_VAR 0 7
82115: PPUSH
82116: CALL_OW 314
82120: NOT
82121: IFFALSE 82104
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82123: LD_ADDR_EXP 99
82127: PUSH
82128: LD_EXP 99
82132: PPUSH
82133: LD_VAR 0 2
82137: PUSH
82138: LD_EXP 99
82142: PUSH
82143: LD_VAR 0 2
82147: ARRAY
82148: PUSH
82149: LD_INT 1
82151: PLUS
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PPUSH
82157: LD_VAR 0 8
82161: PUSH
82162: LD_VAR 0 3
82166: ARRAY
82167: PPUSH
82168: CALL 22482 0 3
82172: ST_TO_ADDR
// end ;
82173: GO 81829
82175: POP
82176: POP
// MC_Reset ( i , 124 ) ;
82177: LD_VAR 0 2
82181: PPUSH
82182: LD_INT 124
82184: PPUSH
82185: CALL 65053 0 2
// end ; end ;
82189: GO 81576
82191: POP
82192: POP
// end ;
82193: LD_VAR 0 1
82197: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82198: LD_INT 0
82200: PPUSH
82201: PPUSH
82202: PPUSH
// if not mc_bases then
82203: LD_EXP 63
82207: NOT
82208: IFFALSE 82212
// exit ;
82210: GO 82826
// for i = 1 to mc_bases do
82212: LD_ADDR_VAR 0 2
82216: PUSH
82217: DOUBLE
82218: LD_INT 1
82220: DEC
82221: ST_TO_ADDR
82222: LD_EXP 63
82226: PUSH
82227: FOR_TO
82228: IFFALSE 82824
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82230: LD_ADDR_VAR 0 3
82234: PUSH
82235: LD_EXP 63
82239: PUSH
82240: LD_VAR 0 2
82244: ARRAY
82245: PPUSH
82246: LD_INT 25
82248: PUSH
82249: LD_INT 4
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PPUSH
82256: CALL_OW 72
82260: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82261: LD_VAR 0 3
82265: NOT
82266: IFTRUE 82281
82268: PUSH
82269: LD_EXP 100
82273: PUSH
82274: LD_VAR 0 2
82278: ARRAY
82279: NOT
82280: OR
82281: IFTRUE 82329
82283: PUSH
82284: LD_EXP 63
82288: PUSH
82289: LD_VAR 0 2
82293: ARRAY
82294: PPUSH
82295: LD_INT 2
82297: PUSH
82298: LD_INT 30
82300: PUSH
82301: LD_INT 0
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 30
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: LIST
82322: PPUSH
82323: CALL_OW 72
82327: NOT
82328: OR
82329: IFFALSE 82379
// begin if mc_deposits_finder [ i ] then
82331: LD_EXP 101
82335: PUSH
82336: LD_VAR 0 2
82340: ARRAY
82341: IFFALSE 82377
// begin MC_Reset ( i , 125 ) ;
82343: LD_VAR 0 2
82347: PPUSH
82348: LD_INT 125
82350: PPUSH
82351: CALL 65053 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82355: LD_ADDR_EXP 101
82359: PUSH
82360: LD_EXP 101
82364: PPUSH
82365: LD_VAR 0 2
82369: PPUSH
82370: EMPTY
82371: PPUSH
82372: CALL_OW 1
82376: ST_TO_ADDR
// end ; continue ;
82377: GO 82227
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82379: LD_EXP 100
82383: PUSH
82384: LD_VAR 0 2
82388: ARRAY
82389: PUSH
82390: LD_INT 1
82392: ARRAY
82393: PUSH
82394: LD_INT 3
82396: ARRAY
82397: PUSH
82398: LD_INT 1
82400: EQUAL
82401: IFFALSE 82427
82403: PUSH
82404: LD_INT 20
82406: PPUSH
82407: LD_EXP 89
82411: PUSH
82412: LD_VAR 0 2
82416: ARRAY
82417: PPUSH
82418: CALL_OW 321
82422: PUSH
82423: LD_INT 2
82425: NONEQUAL
82426: AND
82427: IFFALSE 82477
// begin if mc_deposits_finder [ i ] then
82429: LD_EXP 101
82433: PUSH
82434: LD_VAR 0 2
82438: ARRAY
82439: IFFALSE 82475
// begin MC_Reset ( i , 125 ) ;
82441: LD_VAR 0 2
82445: PPUSH
82446: LD_INT 125
82448: PPUSH
82449: CALL 65053 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82453: LD_ADDR_EXP 101
82457: PUSH
82458: LD_EXP 101
82462: PPUSH
82463: LD_VAR 0 2
82467: PPUSH
82468: EMPTY
82469: PPUSH
82470: CALL_OW 1
82474: ST_TO_ADDR
// end ; continue ;
82475: GO 82227
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82477: LD_EXP 100
82481: PUSH
82482: LD_VAR 0 2
82486: ARRAY
82487: PUSH
82488: LD_INT 1
82490: ARRAY
82491: PUSH
82492: LD_INT 1
82494: ARRAY
82495: PPUSH
82496: LD_EXP 100
82500: PUSH
82501: LD_VAR 0 2
82505: ARRAY
82506: PUSH
82507: LD_INT 1
82509: ARRAY
82510: PUSH
82511: LD_INT 2
82513: ARRAY
82514: PPUSH
82515: LD_EXP 89
82519: PUSH
82520: LD_VAR 0 2
82524: ARRAY
82525: PPUSH
82526: CALL_OW 440
82530: IFFALSE 82573
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82532: LD_ADDR_EXP 100
82536: PUSH
82537: LD_EXP 100
82541: PPUSH
82542: LD_VAR 0 2
82546: PPUSH
82547: LD_EXP 100
82551: PUSH
82552: LD_VAR 0 2
82556: ARRAY
82557: PPUSH
82558: LD_INT 1
82560: PPUSH
82561: CALL_OW 3
82565: PPUSH
82566: CALL_OW 1
82570: ST_TO_ADDR
82571: GO 82822
// begin if not mc_deposits_finder [ i ] then
82573: LD_EXP 101
82577: PUSH
82578: LD_VAR 0 2
82582: ARRAY
82583: NOT
82584: IFFALSE 82636
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82586: LD_ADDR_EXP 101
82590: PUSH
82591: LD_EXP 101
82595: PPUSH
82596: LD_VAR 0 2
82600: PPUSH
82601: LD_VAR 0 3
82605: PUSH
82606: LD_INT 1
82608: ARRAY
82609: PUSH
82610: EMPTY
82611: LIST
82612: PPUSH
82613: CALL_OW 1
82617: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82618: LD_VAR 0 3
82622: PUSH
82623: LD_INT 1
82625: ARRAY
82626: PPUSH
82627: LD_INT 125
82629: PPUSH
82630: CALL_OW 109
// end else
82634: GO 82822
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82636: LD_EXP 101
82640: PUSH
82641: LD_VAR 0 2
82645: ARRAY
82646: PUSH
82647: LD_INT 1
82649: ARRAY
82650: PPUSH
82651: CALL_OW 310
82655: IFFALSE 82678
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82657: LD_EXP 101
82661: PUSH
82662: LD_VAR 0 2
82666: ARRAY
82667: PUSH
82668: LD_INT 1
82670: ARRAY
82671: PPUSH
82672: CALL_OW 122
82676: GO 82822
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82678: LD_EXP 101
82682: PUSH
82683: LD_VAR 0 2
82687: ARRAY
82688: PUSH
82689: LD_INT 1
82691: ARRAY
82692: PPUSH
82693: CALL_OW 314
82697: NOT
82698: IFFALSE 82763
82700: PUSH
82701: LD_EXP 101
82705: PUSH
82706: LD_VAR 0 2
82710: ARRAY
82711: PUSH
82712: LD_INT 1
82714: ARRAY
82715: PPUSH
82716: LD_EXP 100
82720: PUSH
82721: LD_VAR 0 2
82725: ARRAY
82726: PUSH
82727: LD_INT 1
82729: ARRAY
82730: PUSH
82731: LD_INT 1
82733: ARRAY
82734: PPUSH
82735: LD_EXP 100
82739: PUSH
82740: LD_VAR 0 2
82744: ARRAY
82745: PUSH
82746: LD_INT 1
82748: ARRAY
82749: PUSH
82750: LD_INT 2
82752: ARRAY
82753: PPUSH
82754: CALL_OW 297
82758: PUSH
82759: LD_INT 6
82761: GREATER
82762: AND
82763: IFFALSE 82822
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82765: LD_EXP 101
82769: PUSH
82770: LD_VAR 0 2
82774: ARRAY
82775: PUSH
82776: LD_INT 1
82778: ARRAY
82779: PPUSH
82780: LD_EXP 100
82784: PUSH
82785: LD_VAR 0 2
82789: ARRAY
82790: PUSH
82791: LD_INT 1
82793: ARRAY
82794: PUSH
82795: LD_INT 1
82797: ARRAY
82798: PPUSH
82799: LD_EXP 100
82803: PUSH
82804: LD_VAR 0 2
82808: ARRAY
82809: PUSH
82810: LD_INT 1
82812: ARRAY
82813: PUSH
82814: LD_INT 2
82816: ARRAY
82817: PPUSH
82818: CALL_OW 111
// end ; end ; end ;
82822: GO 82227
82824: POP
82825: POP
// end ;
82826: LD_VAR 0 1
82830: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82831: LD_INT 0
82833: PPUSH
82834: PPUSH
82835: PPUSH
82836: PPUSH
82837: PPUSH
82838: PPUSH
82839: PPUSH
82840: PPUSH
82841: PPUSH
82842: PPUSH
82843: PPUSH
// if not mc_bases then
82844: LD_EXP 63
82848: NOT
82849: IFFALSE 82853
// exit ;
82851: GO 83813
// for i = 1 to mc_bases do
82853: LD_ADDR_VAR 0 2
82857: PUSH
82858: DOUBLE
82859: LD_INT 1
82861: DEC
82862: ST_TO_ADDR
82863: LD_EXP 63
82867: PUSH
82868: FOR_TO
82869: IFFALSE 83811
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82871: LD_EXP 63
82875: PUSH
82876: LD_VAR 0 2
82880: ARRAY
82881: NOT
82882: IFTRUE 82896
82884: PUSH
82885: LD_EXP 86
82889: PUSH
82890: LD_VAR 0 2
82894: ARRAY
82895: OR
82896: IFFALSE 82900
// continue ;
82898: GO 82868
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82900: LD_ADDR_VAR 0 7
82904: PUSH
82905: LD_EXP 63
82909: PUSH
82910: LD_VAR 0 2
82914: ARRAY
82915: PUSH
82916: LD_INT 1
82918: ARRAY
82919: PPUSH
82920: CALL_OW 248
82924: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
82925: LD_VAR 0 7
82929: PUSH
82930: LD_INT 3
82932: EQUAL
82933: IFTRUE 82975
82935: PUSH
82936: LD_EXP 82
82940: PUSH
82941: LD_VAR 0 2
82945: ARRAY
82946: PUSH
82947: LD_EXP 85
82951: PUSH
82952: LD_VAR 0 2
82956: ARRAY
82957: UNION
82958: PPUSH
82959: LD_INT 33
82961: PUSH
82962: LD_INT 2
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PPUSH
82969: CALL_OW 72
82973: NOT
82974: OR
82975: IFFALSE 82979
// continue ;
82977: GO 82868
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
82979: LD_ADDR_VAR 0 9
82983: PUSH
82984: LD_EXP 63
82988: PUSH
82989: LD_VAR 0 2
82993: ARRAY
82994: PPUSH
82995: LD_INT 30
82997: PUSH
82998: LD_INT 36
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PPUSH
83005: CALL_OW 72
83009: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83010: LD_ADDR_VAR 0 10
83014: PUSH
83015: LD_EXP 82
83019: PUSH
83020: LD_VAR 0 2
83024: ARRAY
83025: PPUSH
83026: LD_INT 34
83028: PUSH
83029: LD_INT 31
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PPUSH
83036: CALL_OW 72
83040: ST_TO_ADDR
// if not cts and not mcts then
83041: LD_VAR 0 9
83045: NOT
83046: IFFALSE 83055
83048: PUSH
83049: LD_VAR 0 10
83053: NOT
83054: AND
83055: IFFALSE 83059
// continue ;
83057: GO 82868
// x := cts ;
83059: LD_ADDR_VAR 0 11
83063: PUSH
83064: LD_VAR 0 9
83068: ST_TO_ADDR
// if not x then
83069: LD_VAR 0 11
83073: NOT
83074: IFFALSE 83086
// x := mcts ;
83076: LD_ADDR_VAR 0 11
83080: PUSH
83081: LD_VAR 0 10
83085: ST_TO_ADDR
// if not x then
83086: LD_VAR 0 11
83090: NOT
83091: IFFALSE 83095
// continue ;
83093: GO 82868
// if mc_remote_driver [ i ] then
83095: LD_EXP 103
83099: PUSH
83100: LD_VAR 0 2
83104: ARRAY
83105: IFFALSE 83504
// for j in mc_remote_driver [ i ] do
83107: LD_ADDR_VAR 0 3
83111: PUSH
83112: LD_EXP 103
83116: PUSH
83117: LD_VAR 0 2
83121: ARRAY
83122: PUSH
83123: FOR_IN
83124: IFFALSE 83502
// begin if GetClass ( j ) <> 3 then
83126: LD_VAR 0 3
83130: PPUSH
83131: CALL_OW 257
83135: PUSH
83136: LD_INT 3
83138: NONEQUAL
83139: IFFALSE 83192
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83141: LD_ADDR_EXP 103
83145: PUSH
83146: LD_EXP 103
83150: PPUSH
83151: LD_VAR 0 2
83155: PPUSH
83156: LD_EXP 103
83160: PUSH
83161: LD_VAR 0 2
83165: ARRAY
83166: PUSH
83167: LD_VAR 0 3
83171: DIFF
83172: PPUSH
83173: CALL_OW 1
83177: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83178: LD_VAR 0 3
83182: PPUSH
83183: LD_INT 0
83185: PPUSH
83186: CALL_OW 109
// continue ;
83190: GO 83123
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83192: LD_EXP 82
83196: PUSH
83197: LD_VAR 0 2
83201: ARRAY
83202: PPUSH
83203: LD_INT 34
83205: PUSH
83206: LD_INT 31
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 58
83215: PUSH
83216: EMPTY
83217: LIST
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PPUSH
83223: CALL_OW 72
83227: IFFALSE 83241
83229: PUSH
83230: LD_VAR 0 3
83234: PPUSH
83235: CALL 53110 0 1
83239: NOT
83240: AND
83241: IFFALSE 83312
// begin if IsInUnit ( j ) then
83243: LD_VAR 0 3
83247: PPUSH
83248: CALL_OW 310
83252: IFFALSE 83263
// ComExitBuilding ( j ) ;
83254: LD_VAR 0 3
83258: PPUSH
83259: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83263: LD_VAR 0 3
83267: PPUSH
83268: LD_EXP 82
83272: PUSH
83273: LD_VAR 0 2
83277: ARRAY
83278: PPUSH
83279: LD_INT 34
83281: PUSH
83282: LD_INT 31
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 58
83291: PUSH
83292: EMPTY
83293: LIST
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PPUSH
83299: CALL_OW 72
83303: PUSH
83304: LD_INT 1
83306: ARRAY
83307: PPUSH
83308: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83312: LD_VAR 0 3
83316: PPUSH
83317: CALL_OW 310
83321: NOT
83322: IFTRUE 83358
83324: PUSH
83325: LD_VAR 0 3
83329: PPUSH
83330: CALL_OW 310
83334: PPUSH
83335: CALL_OW 266
83339: PUSH
83340: LD_INT 36
83342: NONEQUAL
83343: IFFALSE 83357
83345: PUSH
83346: LD_VAR 0 3
83350: PPUSH
83351: CALL 53110 0 1
83355: NOT
83356: AND
83357: OR
83358: IFFALSE 83500
// begin if IsInUnit ( j ) then
83360: LD_VAR 0 3
83364: PPUSH
83365: CALL_OW 310
83369: IFFALSE 83380
// ComExitBuilding ( j ) ;
83371: LD_VAR 0 3
83375: PPUSH
83376: CALL_OW 122
// ct := 0 ;
83380: LD_ADDR_VAR 0 8
83384: PUSH
83385: LD_INT 0
83387: ST_TO_ADDR
// for k in x do
83388: LD_ADDR_VAR 0 4
83392: PUSH
83393: LD_VAR 0 11
83397: PUSH
83398: FOR_IN
83399: IFFALSE 83478
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83401: LD_VAR 0 4
83405: PPUSH
83406: CALL_OW 264
83410: PUSH
83411: LD_INT 31
83413: EQUAL
83414: IFFALSE 83428
83416: PUSH
83417: LD_VAR 0 4
83421: PPUSH
83422: CALL_OW 311
83426: NOT
83427: AND
83428: IFTRUE 83462
83430: PUSH
83431: LD_VAR 0 4
83435: PPUSH
83436: CALL_OW 266
83440: PUSH
83441: LD_INT 36
83443: EQUAL
83444: IFFALSE 83461
83446: PUSH
83447: LD_VAR 0 4
83451: PPUSH
83452: CALL_OW 313
83456: PUSH
83457: LD_INT 3
83459: LESS
83460: AND
83461: OR
83462: IFFALSE 83476
// begin ct := k ;
83464: LD_ADDR_VAR 0 8
83468: PUSH
83469: LD_VAR 0 4
83473: ST_TO_ADDR
// break ;
83474: GO 83478
// end ;
83476: GO 83398
83478: POP
83479: POP
// if ct then
83480: LD_VAR 0 8
83484: IFFALSE 83500
// ComEnterUnit ( j , ct ) ;
83486: LD_VAR 0 3
83490: PPUSH
83491: LD_VAR 0 8
83495: PPUSH
83496: CALL_OW 120
// end ; end ;
83500: GO 83123
83502: POP
83503: POP
// places := 0 ;
83504: LD_ADDR_VAR 0 5
83508: PUSH
83509: LD_INT 0
83511: ST_TO_ADDR
// for j = 1 to x do
83512: LD_ADDR_VAR 0 3
83516: PUSH
83517: DOUBLE
83518: LD_INT 1
83520: DEC
83521: ST_TO_ADDR
83522: LD_VAR 0 11
83526: PUSH
83527: FOR_TO
83528: IFFALSE 83604
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83530: LD_VAR 0 11
83534: PUSH
83535: LD_VAR 0 3
83539: ARRAY
83540: PPUSH
83541: CALL_OW 264
83545: PUSH
83546: LD_INT 31
83548: EQUAL
83549: IFFALSE 83567
// places := places + 1 else
83551: LD_ADDR_VAR 0 5
83555: PUSH
83556: LD_VAR 0 5
83560: PUSH
83561: LD_INT 1
83563: PLUS
83564: ST_TO_ADDR
83565: GO 83602
// if GetBType ( x [ j ] ) = b_control_tower then
83567: LD_VAR 0 11
83571: PUSH
83572: LD_VAR 0 3
83576: ARRAY
83577: PPUSH
83578: CALL_OW 266
83582: PUSH
83583: LD_INT 36
83585: EQUAL
83586: IFFALSE 83602
// places := places + 3 ;
83588: LD_ADDR_VAR 0 5
83592: PUSH
83593: LD_VAR 0 5
83597: PUSH
83598: LD_INT 3
83600: PLUS
83601: ST_TO_ADDR
83602: GO 83527
83604: POP
83605: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83606: LD_VAR 0 5
83610: PUSH
83611: LD_INT 0
83613: EQUAL
83614: IFTRUE 83634
83616: PUSH
83617: LD_VAR 0 5
83621: PUSH
83622: LD_EXP 103
83626: PUSH
83627: LD_VAR 0 2
83631: ARRAY
83632: LESSEQUAL
83633: OR
83634: IFFALSE 83638
// continue ;
83636: GO 82868
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83638: LD_ADDR_VAR 0 6
83642: PUSH
83643: LD_EXP 63
83647: PUSH
83648: LD_VAR 0 2
83652: ARRAY
83653: PPUSH
83654: LD_INT 25
83656: PUSH
83657: LD_INT 3
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PPUSH
83664: CALL_OW 72
83668: PUSH
83669: LD_EXP 103
83673: PUSH
83674: LD_VAR 0 2
83678: ARRAY
83679: DIFF
83680: PPUSH
83681: LD_INT 3
83683: PPUSH
83684: CALL 54010 0 2
83688: ST_TO_ADDR
// for j in tmp do
83689: LD_ADDR_VAR 0 3
83693: PUSH
83694: LD_VAR 0 6
83698: PUSH
83699: FOR_IN
83700: IFFALSE 83735
// if GetTag ( j ) > 0 then
83702: LD_VAR 0 3
83706: PPUSH
83707: CALL_OW 110
83711: PUSH
83712: LD_INT 0
83714: GREATER
83715: IFFALSE 83733
// tmp := tmp diff j ;
83717: LD_ADDR_VAR 0 6
83721: PUSH
83722: LD_VAR 0 6
83726: PUSH
83727: LD_VAR 0 3
83731: DIFF
83732: ST_TO_ADDR
83733: GO 83699
83735: POP
83736: POP
// if not tmp then
83737: LD_VAR 0 6
83741: NOT
83742: IFFALSE 83746
// continue ;
83744: GO 82868
// if places then
83746: LD_VAR 0 5
83750: IFFALSE 83809
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83752: LD_ADDR_EXP 103
83756: PUSH
83757: LD_EXP 103
83761: PPUSH
83762: LD_VAR 0 2
83766: PPUSH
83767: LD_EXP 103
83771: PUSH
83772: LD_VAR 0 2
83776: ARRAY
83777: PUSH
83778: LD_VAR 0 6
83782: PUSH
83783: LD_INT 1
83785: ARRAY
83786: UNION
83787: PPUSH
83788: CALL_OW 1
83792: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83793: LD_VAR 0 6
83797: PUSH
83798: LD_INT 1
83800: ARRAY
83801: PPUSH
83802: LD_INT 126
83804: PPUSH
83805: CALL_OW 109
// end ; end ;
83809: GO 82868
83811: POP
83812: POP
// end ;
83813: LD_VAR 0 1
83817: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83818: LD_INT 0
83820: PPUSH
83821: PPUSH
83822: PPUSH
83823: PPUSH
83824: PPUSH
83825: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83826: LD_VAR 0 1
83830: NOT
83831: IFTRUE 83840
83833: PUSH
83834: LD_VAR 0 2
83838: NOT
83839: OR
83840: IFTRUE 83849
83842: PUSH
83843: LD_VAR 0 3
83847: NOT
83848: OR
83849: IFTRUE 83897
83851: PUSH
83852: LD_VAR 0 4
83856: PUSH
83857: LD_INT 1
83859: PUSH
83860: LD_INT 2
83862: PUSH
83863: LD_INT 3
83865: PUSH
83866: LD_INT 4
83868: PUSH
83869: LD_INT 5
83871: PUSH
83872: LD_INT 8
83874: PUSH
83875: LD_INT 9
83877: PUSH
83878: LD_INT 15
83880: PUSH
83881: LD_INT 16
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: IN
83895: NOT
83896: OR
83897: IFFALSE 83901
// exit ;
83899: GO 84761
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83901: LD_ADDR_VAR 0 2
83905: PUSH
83906: LD_VAR 0 2
83910: PPUSH
83911: LD_INT 21
83913: PUSH
83914: LD_INT 3
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 24
83923: PUSH
83924: LD_INT 250
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PPUSH
83935: CALL_OW 72
83939: ST_TO_ADDR
// case class of 1 , 15 :
83940: LD_VAR 0 4
83944: PUSH
83945: LD_INT 1
83947: DOUBLE
83948: EQUAL
83949: IFTRUE 83959
83951: LD_INT 15
83953: DOUBLE
83954: EQUAL
83955: IFTRUE 83959
83957: GO 84044
83959: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
83960: LD_ADDR_VAR 0 8
83964: PUSH
83965: LD_VAR 0 2
83969: PPUSH
83970: LD_INT 2
83972: PUSH
83973: LD_INT 30
83975: PUSH
83976: LD_INT 32
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 30
83985: PUSH
83986: LD_INT 31
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: LIST
83997: PPUSH
83998: CALL_OW 72
84002: PUSH
84003: LD_VAR 0 2
84007: PPUSH
84008: LD_INT 2
84010: PUSH
84011: LD_INT 30
84013: PUSH
84014: LD_INT 4
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 30
84023: PUSH
84024: LD_INT 5
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: LIST
84035: PPUSH
84036: CALL_OW 72
84040: ADD
84041: ST_TO_ADDR
84042: GO 84290
84044: LD_INT 2
84046: DOUBLE
84047: EQUAL
84048: IFTRUE 84058
84050: LD_INT 16
84052: DOUBLE
84053: EQUAL
84054: IFTRUE 84058
84056: GO 84104
84058: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84059: LD_ADDR_VAR 0 8
84063: PUSH
84064: LD_VAR 0 2
84068: PPUSH
84069: LD_INT 2
84071: PUSH
84072: LD_INT 30
84074: PUSH
84075: LD_INT 0
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 30
84084: PUSH
84085: LD_INT 1
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: LIST
84096: PPUSH
84097: CALL_OW 72
84101: ST_TO_ADDR
84102: GO 84290
84104: LD_INT 3
84106: DOUBLE
84107: EQUAL
84108: IFTRUE 84112
84110: GO 84158
84112: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84113: LD_ADDR_VAR 0 8
84117: PUSH
84118: LD_VAR 0 2
84122: PPUSH
84123: LD_INT 2
84125: PUSH
84126: LD_INT 30
84128: PUSH
84129: LD_INT 2
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 30
84138: PUSH
84139: LD_INT 3
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: LIST
84150: PPUSH
84151: CALL_OW 72
84155: ST_TO_ADDR
84156: GO 84290
84158: LD_INT 4
84160: DOUBLE
84161: EQUAL
84162: IFTRUE 84166
84164: GO 84223
84166: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84167: LD_ADDR_VAR 0 8
84171: PUSH
84172: LD_VAR 0 2
84176: PPUSH
84177: LD_INT 2
84179: PUSH
84180: LD_INT 30
84182: PUSH
84183: LD_INT 6
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 30
84192: PUSH
84193: LD_INT 7
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 30
84202: PUSH
84203: LD_INT 8
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: PPUSH
84216: CALL_OW 72
84220: ST_TO_ADDR
84221: GO 84290
84223: LD_INT 5
84225: DOUBLE
84226: EQUAL
84227: IFTRUE 84243
84229: LD_INT 8
84231: DOUBLE
84232: EQUAL
84233: IFTRUE 84243
84235: LD_INT 9
84237: DOUBLE
84238: EQUAL
84239: IFTRUE 84243
84241: GO 84289
84243: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84244: LD_ADDR_VAR 0 8
84248: PUSH
84249: LD_VAR 0 2
84253: PPUSH
84254: LD_INT 2
84256: PUSH
84257: LD_INT 30
84259: PUSH
84260: LD_INT 4
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 30
84269: PUSH
84270: LD_INT 5
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: LIST
84281: PPUSH
84282: CALL_OW 72
84286: ST_TO_ADDR
84287: GO 84290
84289: POP
// if not tmp then
84290: LD_VAR 0 8
84294: NOT
84295: IFFALSE 84299
// exit ;
84297: GO 84761
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84299: LD_VAR 0 4
84303: PUSH
84304: LD_INT 1
84306: PUSH
84307: LD_INT 15
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: IN
84314: IFFALSE 84328
84316: PUSH
84317: LD_EXP 72
84321: PUSH
84322: LD_VAR 0 1
84326: ARRAY
84327: AND
84328: IFFALSE 84484
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84330: LD_ADDR_VAR 0 9
84334: PUSH
84335: LD_EXP 72
84339: PUSH
84340: LD_VAR 0 1
84344: ARRAY
84345: PUSH
84346: LD_INT 1
84348: ARRAY
84349: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84350: LD_VAR 0 9
84354: PUSH
84355: LD_EXP 73
84359: PUSH
84360: LD_VAR 0 1
84364: ARRAY
84365: IN
84366: NOT
84367: IFFALSE 84482
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84369: LD_ADDR_EXP 73
84373: PUSH
84374: LD_EXP 73
84378: PPUSH
84379: LD_VAR 0 1
84383: PUSH
84384: LD_EXP 73
84388: PUSH
84389: LD_VAR 0 1
84393: ARRAY
84394: PUSH
84395: LD_INT 1
84397: PLUS
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PPUSH
84403: LD_VAR 0 9
84407: PPUSH
84408: CALL 22482 0 3
84412: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84413: LD_ADDR_EXP 72
84417: PUSH
84418: LD_EXP 72
84422: PPUSH
84423: LD_VAR 0 1
84427: PPUSH
84428: LD_EXP 72
84432: PUSH
84433: LD_VAR 0 1
84437: ARRAY
84438: PUSH
84439: LD_VAR 0 9
84443: DIFF
84444: PPUSH
84445: CALL_OW 1
84449: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84450: LD_VAR 0 3
84454: PPUSH
84455: LD_EXP 73
84459: PUSH
84460: LD_VAR 0 1
84464: ARRAY
84465: PUSH
84466: LD_EXP 73
84470: PUSH
84471: LD_VAR 0 1
84475: ARRAY
84476: ARRAY
84477: PPUSH
84478: CALL_OW 120
// end ; exit ;
84482: GO 84761
// end ; if tmp > 1 then
84484: LD_VAR 0 8
84488: PUSH
84489: LD_INT 1
84491: GREATER
84492: IFFALSE 84596
// for i = 2 to tmp do
84494: LD_ADDR_VAR 0 6
84498: PUSH
84499: DOUBLE
84500: LD_INT 2
84502: DEC
84503: ST_TO_ADDR
84504: LD_VAR 0 8
84508: PUSH
84509: FOR_TO
84510: IFFALSE 84594
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84512: LD_VAR 0 8
84516: PUSH
84517: LD_VAR 0 6
84521: ARRAY
84522: PPUSH
84523: CALL_OW 461
84527: PUSH
84528: LD_INT 6
84530: EQUAL
84531: IFFALSE 84592
// begin x := tmp [ i ] ;
84533: LD_ADDR_VAR 0 9
84537: PUSH
84538: LD_VAR 0 8
84542: PUSH
84543: LD_VAR 0 6
84547: ARRAY
84548: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84549: LD_ADDR_VAR 0 8
84553: PUSH
84554: LD_VAR 0 8
84558: PPUSH
84559: LD_VAR 0 6
84563: PPUSH
84564: CALL_OW 3
84568: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84569: LD_ADDR_VAR 0 8
84573: PUSH
84574: LD_VAR 0 8
84578: PPUSH
84579: LD_INT 1
84581: PPUSH
84582: LD_VAR 0 9
84586: PPUSH
84587: CALL_OW 2
84591: ST_TO_ADDR
// end ;
84592: GO 84509
84594: POP
84595: POP
// for i in tmp do
84596: LD_ADDR_VAR 0 6
84600: PUSH
84601: LD_VAR 0 8
84605: PUSH
84606: FOR_IN
84607: IFFALSE 84634
// begin if IsNotFull ( i ) then
84609: LD_VAR 0 6
84613: PPUSH
84614: CALL 19680 0 1
84618: IFFALSE 84632
// begin j := i ;
84620: LD_ADDR_VAR 0 7
84624: PUSH
84625: LD_VAR 0 6
84629: ST_TO_ADDR
// break ;
84630: GO 84634
// end ; end ;
84632: GO 84606
84634: POP
84635: POP
// if j then
84636: LD_VAR 0 7
84640: IFFALSE 84658
// ComEnterUnit ( unit , j ) else
84642: LD_VAR 0 3
84646: PPUSH
84647: LD_VAR 0 7
84651: PPUSH
84652: CALL_OW 120
84656: GO 84761
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84658: LD_ADDR_VAR 0 10
84662: PUSH
84663: LD_VAR 0 2
84667: PPUSH
84668: LD_INT 2
84670: PUSH
84671: LD_INT 30
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 30
84683: PUSH
84684: LD_INT 1
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: LIST
84695: PPUSH
84696: CALL_OW 72
84700: ST_TO_ADDR
// if depot then
84701: LD_VAR 0 10
84705: IFFALSE 84761
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84707: LD_ADDR_VAR 0 10
84711: PUSH
84712: LD_VAR 0 10
84716: PPUSH
84717: LD_VAR 0 3
84721: PPUSH
84722: CALL_OW 74
84726: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84727: LD_VAR 0 3
84731: PPUSH
84732: LD_VAR 0 10
84736: PPUSH
84737: CALL_OW 296
84741: PUSH
84742: LD_INT 10
84744: GREATER
84745: IFFALSE 84761
// ComStandNearbyBuilding ( unit , depot ) ;
84747: LD_VAR 0 3
84751: PPUSH
84752: LD_VAR 0 10
84756: PPUSH
84757: CALL 19058 0 2
// end ; end ; end ;
84761: LD_VAR 0 5
84765: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84766: LD_INT 0
84768: PPUSH
84769: PPUSH
84770: PPUSH
84771: PPUSH
// if not mc_bases then
84772: LD_EXP 63
84776: NOT
84777: IFFALSE 84781
// exit ;
84779: GO 85032
// for i = 1 to mc_bases do
84781: LD_ADDR_VAR 0 2
84785: PUSH
84786: DOUBLE
84787: LD_INT 1
84789: DEC
84790: ST_TO_ADDR
84791: LD_EXP 63
84795: PUSH
84796: FOR_TO
84797: IFFALSE 85030
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84799: LD_ADDR_VAR 0 4
84803: PUSH
84804: LD_EXP 63
84808: PUSH
84809: LD_VAR 0 2
84813: ARRAY
84814: PPUSH
84815: LD_INT 21
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PPUSH
84825: CALL_OW 72
84829: PUSH
84830: LD_EXP 92
84834: PUSH
84835: LD_VAR 0 2
84839: ARRAY
84840: UNION
84841: ST_TO_ADDR
// if not tmp then
84842: LD_VAR 0 4
84846: NOT
84847: IFFALSE 84851
// continue ;
84849: GO 84796
// for j in tmp do
84851: LD_ADDR_VAR 0 3
84855: PUSH
84856: LD_VAR 0 4
84860: PUSH
84861: FOR_IN
84862: IFFALSE 85026
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84864: LD_VAR 0 3
84868: PPUSH
84869: CALL_OW 110
84873: NOT
84874: IFFALSE 84888
84876: PUSH
84877: LD_VAR 0 3
84881: PPUSH
84882: CALL_OW 314
84886: NOT
84887: AND
84888: IFFALSE 84902
84890: PUSH
84891: LD_VAR 0 3
84895: PPUSH
84896: CALL_OW 311
84900: NOT
84901: AND
84902: IFFALSE 84916
84904: PUSH
84905: LD_VAR 0 3
84909: PPUSH
84910: CALL_OW 310
84914: NOT
84915: AND
84916: IFFALSE 84941
84918: PUSH
84919: LD_VAR 0 3
84923: PUSH
84924: LD_EXP 66
84928: PUSH
84929: LD_VAR 0 2
84933: ARRAY
84934: PUSH
84935: LD_INT 1
84937: ARRAY
84938: IN
84939: NOT
84940: AND
84941: IFFALSE 84966
84943: PUSH
84944: LD_VAR 0 3
84948: PUSH
84949: LD_EXP 66
84953: PUSH
84954: LD_VAR 0 2
84958: ARRAY
84959: PUSH
84960: LD_INT 2
84962: ARRAY
84963: IN
84964: NOT
84965: AND
84966: IFFALSE 84987
84968: PUSH
84969: LD_VAR 0 3
84973: PUSH
84974: LD_EXP 75
84978: PUSH
84979: LD_VAR 0 2
84983: ARRAY
84984: IN
84985: NOT
84986: AND
84987: IFFALSE 85024
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
84989: LD_VAR 0 2
84993: PPUSH
84994: LD_EXP 63
84998: PUSH
84999: LD_VAR 0 2
85003: ARRAY
85004: PPUSH
85005: LD_VAR 0 3
85009: PPUSH
85010: LD_VAR 0 3
85014: PPUSH
85015: CALL_OW 257
85019: PPUSH
85020: CALL 83818 0 4
// end ;
85024: GO 84861
85026: POP
85027: POP
// end ;
85028: GO 84796
85030: POP
85031: POP
// end ;
85032: LD_VAR 0 1
85036: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85037: LD_INT 0
85039: PPUSH
85040: PPUSH
85041: PPUSH
85042: PPUSH
85043: PPUSH
85044: PPUSH
// if not mc_bases [ base ] then
85045: LD_EXP 63
85049: PUSH
85050: LD_VAR 0 1
85054: ARRAY
85055: NOT
85056: IFFALSE 85060
// exit ;
85058: GO 85261
// tmp := [ ] ;
85060: LD_ADDR_VAR 0 6
85064: PUSH
85065: EMPTY
85066: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85067: LD_ADDR_VAR 0 7
85071: PUSH
85072: LD_VAR 0 3
85076: PPUSH
85077: LD_INT 0
85079: PPUSH
85080: CALL_OW 517
85084: ST_TO_ADDR
// if not list then
85085: LD_VAR 0 7
85089: NOT
85090: IFFALSE 85094
// exit ;
85092: GO 85261
// c := Count ( list [ 1 ] ) ;
85094: LD_ADDR_VAR 0 9
85098: PUSH
85099: LD_VAR 0 7
85103: PUSH
85104: LD_INT 1
85106: ARRAY
85107: PPUSH
85108: CALL 19598 0 1
85112: ST_TO_ADDR
// if amount > c then
85113: LD_VAR 0 2
85117: PUSH
85118: LD_VAR 0 9
85122: GREATER
85123: IFFALSE 85135
// amount := c ;
85125: LD_ADDR_VAR 0 2
85129: PUSH
85130: LD_VAR 0 9
85134: ST_TO_ADDR
// for i := 1 to amount do
85135: LD_ADDR_VAR 0 5
85139: PUSH
85140: DOUBLE
85141: LD_INT 1
85143: DEC
85144: ST_TO_ADDR
85145: LD_VAR 0 2
85149: PUSH
85150: FOR_TO
85151: IFFALSE 85209
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85153: LD_ADDR_VAR 0 6
85157: PUSH
85158: LD_VAR 0 6
85162: PPUSH
85163: LD_VAR 0 5
85167: PPUSH
85168: LD_VAR 0 7
85172: PUSH
85173: LD_INT 1
85175: ARRAY
85176: PUSH
85177: LD_VAR 0 5
85181: ARRAY
85182: PUSH
85183: LD_VAR 0 7
85187: PUSH
85188: LD_INT 2
85190: ARRAY
85191: PUSH
85192: LD_VAR 0 5
85196: ARRAY
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PPUSH
85202: CALL_OW 1
85206: ST_TO_ADDR
85207: GO 85150
85209: POP
85210: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85211: LD_ADDR_EXP 76
85215: PUSH
85216: LD_EXP 76
85220: PPUSH
85221: LD_VAR 0 1
85225: PPUSH
85226: LD_VAR 0 6
85230: PPUSH
85231: CALL_OW 1
85235: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85236: LD_ADDR_EXP 78
85240: PUSH
85241: LD_EXP 78
85245: PPUSH
85246: LD_VAR 0 1
85250: PPUSH
85251: LD_VAR 0 3
85255: PPUSH
85256: CALL_OW 1
85260: ST_TO_ADDR
// end ;
85261: LD_VAR 0 4
85265: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85266: LD_INT 0
85268: PPUSH
// if not mc_bases [ base ] then
85269: LD_EXP 63
85273: PUSH
85274: LD_VAR 0 1
85278: ARRAY
85279: NOT
85280: IFFALSE 85284
// exit ;
85282: GO 85309
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85284: LD_ADDR_EXP 68
85288: PUSH
85289: LD_EXP 68
85293: PPUSH
85294: LD_VAR 0 1
85298: PPUSH
85299: LD_VAR 0 2
85303: PPUSH
85304: CALL_OW 1
85308: ST_TO_ADDR
// end ;
85309: LD_VAR 0 3
85313: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85314: LD_INT 0
85316: PPUSH
// if not mc_bases [ base ] then
85317: LD_EXP 63
85321: PUSH
85322: LD_VAR 0 1
85326: ARRAY
85327: NOT
85328: IFFALSE 85332
// exit ;
85330: GO 85369
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85332: LD_ADDR_EXP 68
85336: PUSH
85337: LD_EXP 68
85341: PPUSH
85342: LD_VAR 0 1
85346: PPUSH
85347: LD_EXP 68
85351: PUSH
85352: LD_VAR 0 1
85356: ARRAY
85357: PUSH
85358: LD_VAR 0 2
85362: UNION
85363: PPUSH
85364: CALL_OW 1
85368: ST_TO_ADDR
// end ;
85369: LD_VAR 0 3
85373: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85374: LD_INT 0
85376: PPUSH
// if not mc_bases [ base ] then
85377: LD_EXP 63
85381: PUSH
85382: LD_VAR 0 1
85386: ARRAY
85387: NOT
85388: IFFALSE 85392
// exit ;
85390: GO 85417
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85392: LD_ADDR_EXP 84
85396: PUSH
85397: LD_EXP 84
85401: PPUSH
85402: LD_VAR 0 1
85406: PPUSH
85407: LD_VAR 0 2
85411: PPUSH
85412: CALL_OW 1
85416: ST_TO_ADDR
// end ;
85417: LD_VAR 0 3
85421: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85422: LD_INT 0
85424: PPUSH
// if not mc_bases [ base ] then
85425: LD_EXP 63
85429: PUSH
85430: LD_VAR 0 1
85434: ARRAY
85435: NOT
85436: IFFALSE 85440
// exit ;
85438: GO 85477
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85440: LD_ADDR_EXP 84
85444: PUSH
85445: LD_EXP 84
85449: PPUSH
85450: LD_VAR 0 1
85454: PPUSH
85455: LD_EXP 84
85459: PUSH
85460: LD_VAR 0 1
85464: ARRAY
85465: PUSH
85466: LD_VAR 0 2
85470: ADD
85471: PPUSH
85472: CALL_OW 1
85476: ST_TO_ADDR
// end ;
85477: LD_VAR 0 3
85481: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85482: LD_INT 0
85484: PPUSH
// if not mc_bases [ base ] then
85485: LD_EXP 63
85489: PUSH
85490: LD_VAR 0 1
85494: ARRAY
85495: NOT
85496: IFFALSE 85500
// exit ;
85498: GO 85554
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85500: LD_ADDR_EXP 85
85504: PUSH
85505: LD_EXP 85
85509: PPUSH
85510: LD_VAR 0 1
85514: PPUSH
85515: LD_VAR 0 2
85519: PPUSH
85520: CALL_OW 1
85524: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85525: LD_ADDR_EXP 74
85529: PUSH
85530: LD_EXP 74
85534: PPUSH
85535: LD_VAR 0 1
85539: PPUSH
85540: LD_VAR 0 2
85544: PUSH
85545: LD_INT 0
85547: PLUS
85548: PPUSH
85549: CALL_OW 1
85553: ST_TO_ADDR
// end ;
85554: LD_VAR 0 3
85558: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85559: LD_INT 0
85561: PPUSH
// if not mc_bases [ base ] then
85562: LD_EXP 63
85566: PUSH
85567: LD_VAR 0 1
85571: ARRAY
85572: NOT
85573: IFFALSE 85577
// exit ;
85575: GO 85602
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85577: LD_ADDR_EXP 74
85581: PUSH
85582: LD_EXP 74
85586: PPUSH
85587: LD_VAR 0 1
85591: PPUSH
85592: LD_VAR 0 2
85596: PPUSH
85597: CALL_OW 1
85601: ST_TO_ADDR
// end ;
85602: LD_VAR 0 3
85606: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85607: LD_INT 0
85609: PPUSH
85610: PPUSH
85611: PPUSH
85612: PPUSH
// if not mc_bases [ base ] then
85613: LD_EXP 63
85617: PUSH
85618: LD_VAR 0 1
85622: ARRAY
85623: NOT
85624: IFFALSE 85628
// exit ;
85626: GO 85693
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85628: LD_ADDR_EXP 83
85632: PUSH
85633: LD_EXP 83
85637: PPUSH
85638: LD_VAR 0 1
85642: PUSH
85643: LD_EXP 83
85647: PUSH
85648: LD_VAR 0 1
85652: ARRAY
85653: PUSH
85654: LD_INT 1
85656: PLUS
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PPUSH
85662: LD_VAR 0 1
85666: PUSH
85667: LD_VAR 0 2
85671: PUSH
85672: LD_VAR 0 3
85676: PUSH
85677: LD_VAR 0 4
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: PPUSH
85688: CALL 22482 0 3
85692: ST_TO_ADDR
// end ;
85693: LD_VAR 0 5
85697: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85698: LD_INT 0
85700: PPUSH
// if not mc_bases [ base ] then
85701: LD_EXP 63
85705: PUSH
85706: LD_VAR 0 1
85710: ARRAY
85711: NOT
85712: IFFALSE 85716
// exit ;
85714: GO 85741
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85716: LD_ADDR_EXP 100
85720: PUSH
85721: LD_EXP 100
85725: PPUSH
85726: LD_VAR 0 1
85730: PPUSH
85731: LD_VAR 0 2
85735: PPUSH
85736: CALL_OW 1
85740: ST_TO_ADDR
// end ;
85741: LD_VAR 0 3
85745: RET
// export function MC_GetMinesField ( base ) ; begin
85746: LD_INT 0
85748: PPUSH
// result := mc_mines [ base ] ;
85749: LD_ADDR_VAR 0 2
85753: PUSH
85754: LD_EXP 76
85758: PUSH
85759: LD_VAR 0 1
85763: ARRAY
85764: ST_TO_ADDR
// end ;
85765: LD_VAR 0 2
85769: RET
// export function MC_GetProduceList ( base ) ; begin
85770: LD_INT 0
85772: PPUSH
// result := mc_produce [ base ] ;
85773: LD_ADDR_VAR 0 2
85777: PUSH
85778: LD_EXP 84
85782: PUSH
85783: LD_VAR 0 1
85787: ARRAY
85788: ST_TO_ADDR
// end ;
85789: LD_VAR 0 2
85793: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85794: LD_INT 0
85796: PPUSH
85797: PPUSH
// if not mc_bases then
85798: LD_EXP 63
85802: NOT
85803: IFFALSE 85807
// exit ;
85805: GO 85872
// if mc_bases [ base ] then
85807: LD_EXP 63
85811: PUSH
85812: LD_VAR 0 1
85816: ARRAY
85817: IFFALSE 85872
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85819: LD_ADDR_VAR 0 3
85823: PUSH
85824: LD_EXP 63
85828: PUSH
85829: LD_VAR 0 1
85833: ARRAY
85834: PPUSH
85835: LD_INT 30
85837: PUSH
85838: LD_VAR 0 2
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PPUSH
85847: CALL_OW 72
85851: ST_TO_ADDR
// if result then
85852: LD_VAR 0 3
85856: IFFALSE 85872
// result := result [ 1 ] ;
85858: LD_ADDR_VAR 0 3
85862: PUSH
85863: LD_VAR 0 3
85867: PUSH
85868: LD_INT 1
85870: ARRAY
85871: ST_TO_ADDR
// end ; end ;
85872: LD_VAR 0 3
85876: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85877: LD_INT 0
85879: PPUSH
85880: PPUSH
// if not mc_bases then
85881: LD_EXP 63
85885: NOT
85886: IFFALSE 85890
// exit ;
85888: GO 85935
// if mc_bases [ base ] then
85890: LD_EXP 63
85894: PUSH
85895: LD_VAR 0 1
85899: ARRAY
85900: IFFALSE 85935
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85902: LD_ADDR_VAR 0 3
85906: PUSH
85907: LD_EXP 63
85911: PUSH
85912: LD_VAR 0 1
85916: ARRAY
85917: PPUSH
85918: LD_INT 30
85920: PUSH
85921: LD_VAR 0 2
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PPUSH
85930: CALL_OW 72
85934: ST_TO_ADDR
// end ;
85935: LD_VAR 0 3
85939: RET
// export function MC_SetTame ( base , area ) ; begin
85940: LD_INT 0
85942: PPUSH
// if not mc_bases or not base then
85943: LD_EXP 63
85947: NOT
85948: IFTRUE 85957
85950: PUSH
85951: LD_VAR 0 1
85955: NOT
85956: OR
85957: IFFALSE 85961
// exit ;
85959: GO 85986
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
85961: LD_ADDR_EXP 91
85965: PUSH
85966: LD_EXP 91
85970: PPUSH
85971: LD_VAR 0 1
85975: PPUSH
85976: LD_VAR 0 2
85980: PPUSH
85981: CALL_OW 1
85985: ST_TO_ADDR
// end ;
85986: LD_VAR 0 3
85990: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
85991: LD_INT 0
85993: PPUSH
85994: PPUSH
// if not mc_bases or not base then
85995: LD_EXP 63
85999: NOT
86000: IFTRUE 86009
86002: PUSH
86003: LD_VAR 0 1
86007: NOT
86008: OR
86009: IFFALSE 86013
// exit ;
86011: GO 86115
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86013: LD_ADDR_VAR 0 4
86017: PUSH
86018: LD_EXP 63
86022: PUSH
86023: LD_VAR 0 1
86027: ARRAY
86028: PPUSH
86029: LD_INT 30
86031: PUSH
86032: LD_VAR 0 2
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PPUSH
86041: CALL_OW 72
86045: ST_TO_ADDR
// if not tmp then
86046: LD_VAR 0 4
86050: NOT
86051: IFFALSE 86055
// exit ;
86053: GO 86115
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86055: LD_ADDR_EXP 95
86059: PUSH
86060: LD_EXP 95
86064: PPUSH
86065: LD_VAR 0 1
86069: PPUSH
86070: LD_EXP 95
86074: PUSH
86075: LD_VAR 0 1
86079: ARRAY
86080: PPUSH
86081: LD_EXP 95
86085: PUSH
86086: LD_VAR 0 1
86090: ARRAY
86091: PUSH
86092: LD_INT 1
86094: PLUS
86095: PPUSH
86096: LD_VAR 0 4
86100: PUSH
86101: LD_INT 1
86103: ARRAY
86104: PPUSH
86105: CALL_OW 2
86109: PPUSH
86110: CALL_OW 1
86114: ST_TO_ADDR
// end ;
86115: LD_VAR 0 3
86119: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86120: LD_INT 0
86122: PPUSH
86123: PPUSH
// if not mc_bases or not base or not kinds then
86124: LD_EXP 63
86128: NOT
86129: IFTRUE 86138
86131: PUSH
86132: LD_VAR 0 1
86136: NOT
86137: OR
86138: IFTRUE 86147
86140: PUSH
86141: LD_VAR 0 2
86145: NOT
86146: OR
86147: IFFALSE 86151
// exit ;
86149: GO 86212
// for i in kinds do
86151: LD_ADDR_VAR 0 4
86155: PUSH
86156: LD_VAR 0 2
86160: PUSH
86161: FOR_IN
86162: IFFALSE 86210
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86164: LD_ADDR_EXP 97
86168: PUSH
86169: LD_EXP 97
86173: PPUSH
86174: LD_VAR 0 1
86178: PUSH
86179: LD_EXP 97
86183: PUSH
86184: LD_VAR 0 1
86188: ARRAY
86189: PUSH
86190: LD_INT 1
86192: PLUS
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PPUSH
86198: LD_VAR 0 4
86202: PPUSH
86203: CALL 22482 0 3
86207: ST_TO_ADDR
86208: GO 86161
86210: POP
86211: POP
// end ;
86212: LD_VAR 0 3
86216: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86217: LD_INT 0
86219: PPUSH
// if not mc_bases or not base or not areas then
86220: LD_EXP 63
86224: NOT
86225: IFTRUE 86234
86227: PUSH
86228: LD_VAR 0 1
86232: NOT
86233: OR
86234: IFTRUE 86243
86236: PUSH
86237: LD_VAR 0 2
86241: NOT
86242: OR
86243: IFFALSE 86247
// exit ;
86245: GO 86272
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86247: LD_ADDR_EXP 81
86251: PUSH
86252: LD_EXP 81
86256: PPUSH
86257: LD_VAR 0 1
86261: PPUSH
86262: LD_VAR 0 2
86266: PPUSH
86267: CALL_OW 1
86271: ST_TO_ADDR
// end ;
86272: LD_VAR 0 3
86276: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86277: LD_INT 0
86279: PPUSH
// if not mc_bases or not base or not teleports_exit then
86280: LD_EXP 63
86284: NOT
86285: IFTRUE 86294
86287: PUSH
86288: LD_VAR 0 1
86292: NOT
86293: OR
86294: IFTRUE 86303
86296: PUSH
86297: LD_VAR 0 2
86301: NOT
86302: OR
86303: IFFALSE 86307
// exit ;
86305: GO 86332
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86307: LD_ADDR_EXP 98
86311: PUSH
86312: LD_EXP 98
86316: PPUSH
86317: LD_VAR 0 1
86321: PPUSH
86322: LD_VAR 0 2
86326: PPUSH
86327: CALL_OW 1
86331: ST_TO_ADDR
// end ;
86332: LD_VAR 0 3
86336: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86337: LD_INT 0
86339: PPUSH
86340: PPUSH
86341: PPUSH
// if not mc_bases or not base or not ext_list then
86342: LD_EXP 63
86346: NOT
86347: IFTRUE 86356
86349: PUSH
86350: LD_VAR 0 1
86354: NOT
86355: OR
86356: IFTRUE 86365
86358: PUSH
86359: LD_VAR 0 5
86363: NOT
86364: OR
86365: IFFALSE 86369
// exit ;
86367: GO 86542
// tmp := GetFacExtXYD ( x , y , d ) ;
86369: LD_ADDR_VAR 0 8
86373: PUSH
86374: LD_VAR 0 2
86378: PPUSH
86379: LD_VAR 0 3
86383: PPUSH
86384: LD_VAR 0 4
86388: PPUSH
86389: CALL 53140 0 3
86393: ST_TO_ADDR
// if not tmp then
86394: LD_VAR 0 8
86398: NOT
86399: IFFALSE 86403
// exit ;
86401: GO 86542
// for i in tmp do
86403: LD_ADDR_VAR 0 7
86407: PUSH
86408: LD_VAR 0 8
86412: PUSH
86413: FOR_IN
86414: IFFALSE 86540
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86416: LD_ADDR_EXP 68
86420: PUSH
86421: LD_EXP 68
86425: PPUSH
86426: LD_VAR 0 1
86430: PPUSH
86431: LD_EXP 68
86435: PUSH
86436: LD_VAR 0 1
86440: ARRAY
86441: PPUSH
86442: LD_EXP 68
86446: PUSH
86447: LD_VAR 0 1
86451: ARRAY
86452: PUSH
86453: LD_INT 1
86455: PLUS
86456: PPUSH
86457: LD_VAR 0 5
86461: PUSH
86462: LD_INT 1
86464: ARRAY
86465: PUSH
86466: LD_VAR 0 7
86470: PUSH
86471: LD_INT 1
86473: ARRAY
86474: PUSH
86475: LD_VAR 0 7
86479: PUSH
86480: LD_INT 2
86482: ARRAY
86483: PUSH
86484: LD_VAR 0 7
86488: PUSH
86489: LD_INT 3
86491: ARRAY
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: PPUSH
86499: CALL_OW 2
86503: PPUSH
86504: CALL_OW 1
86508: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86509: LD_ADDR_VAR 0 5
86513: PUSH
86514: LD_VAR 0 5
86518: PPUSH
86519: LD_INT 1
86521: PPUSH
86522: CALL_OW 3
86526: ST_TO_ADDR
// if not ext_list then
86527: LD_VAR 0 5
86531: NOT
86532: IFFALSE 86538
// exit ;
86534: POP
86535: POP
86536: GO 86542
// end ;
86538: GO 86413
86540: POP
86541: POP
// end ;
86542: LD_VAR 0 6
86546: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86547: LD_INT 0
86549: PPUSH
// if not mc_bases or not base or not weapon_list then
86550: LD_EXP 63
86554: NOT
86555: IFTRUE 86564
86557: PUSH
86558: LD_VAR 0 1
86562: NOT
86563: OR
86564: IFTRUE 86573
86566: PUSH
86567: LD_VAR 0 2
86571: NOT
86572: OR
86573: IFFALSE 86577
// exit ;
86575: GO 86602
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86577: LD_ADDR_EXP 102
86581: PUSH
86582: LD_EXP 102
86586: PPUSH
86587: LD_VAR 0 1
86591: PPUSH
86592: LD_VAR 0 2
86596: PPUSH
86597: CALL_OW 1
86601: ST_TO_ADDR
// end ;
86602: LD_VAR 0 3
86606: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86607: LD_INT 0
86609: PPUSH
// if not mc_bases or not base or not tech_list then
86610: LD_EXP 63
86614: NOT
86615: IFTRUE 86624
86617: PUSH
86618: LD_VAR 0 1
86622: NOT
86623: OR
86624: IFTRUE 86633
86626: PUSH
86627: LD_VAR 0 2
86631: NOT
86632: OR
86633: IFFALSE 86637
// exit ;
86635: GO 86662
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86637: LD_ADDR_EXP 90
86641: PUSH
86642: LD_EXP 90
86646: PPUSH
86647: LD_VAR 0 1
86651: PPUSH
86652: LD_VAR 0 2
86656: PPUSH
86657: CALL_OW 1
86661: ST_TO_ADDR
// end ;
86662: LD_VAR 0 3
86666: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86667: LD_INT 0
86669: PPUSH
// if not mc_bases or not parking_area or not base then
86670: LD_EXP 63
86674: NOT
86675: IFTRUE 86684
86677: PUSH
86678: LD_VAR 0 2
86682: NOT
86683: OR
86684: IFTRUE 86693
86686: PUSH
86687: LD_VAR 0 1
86691: NOT
86692: OR
86693: IFFALSE 86697
// exit ;
86695: GO 86722
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86697: LD_ADDR_EXP 87
86701: PUSH
86702: LD_EXP 87
86706: PPUSH
86707: LD_VAR 0 1
86711: PPUSH
86712: LD_VAR 0 2
86716: PPUSH
86717: CALL_OW 1
86721: ST_TO_ADDR
// end ;
86722: LD_VAR 0 3
86726: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86727: LD_INT 0
86729: PPUSH
// if not mc_bases or not base or not scan_area then
86730: LD_EXP 63
86734: NOT
86735: IFTRUE 86744
86737: PUSH
86738: LD_VAR 0 1
86742: NOT
86743: OR
86744: IFTRUE 86753
86746: PUSH
86747: LD_VAR 0 2
86751: NOT
86752: OR
86753: IFFALSE 86757
// exit ;
86755: GO 86782
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86757: LD_ADDR_EXP 88
86761: PUSH
86762: LD_EXP 88
86766: PPUSH
86767: LD_VAR 0 1
86771: PPUSH
86772: LD_VAR 0 2
86776: PPUSH
86777: CALL_OW 1
86781: ST_TO_ADDR
// end ;
86782: LD_VAR 0 3
86786: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86787: LD_INT 0
86789: PPUSH
86790: PPUSH
// if not mc_bases or not base then
86791: LD_EXP 63
86795: NOT
86796: IFTRUE 86805
86798: PUSH
86799: LD_VAR 0 1
86803: NOT
86804: OR
86805: IFFALSE 86809
// exit ;
86807: GO 86873
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86809: LD_ADDR_VAR 0 3
86813: PUSH
86814: LD_INT 1
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 3
86822: PUSH
86823: LD_INT 4
86825: PUSH
86826: LD_INT 11
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86836: LD_ADDR_EXP 90
86840: PUSH
86841: LD_EXP 90
86845: PPUSH
86846: LD_VAR 0 1
86850: PPUSH
86851: LD_EXP 90
86855: PUSH
86856: LD_VAR 0 1
86860: ARRAY
86861: PUSH
86862: LD_VAR 0 3
86866: DIFF
86867: PPUSH
86868: CALL_OW 1
86872: ST_TO_ADDR
// end ;
86873: LD_VAR 0 2
86877: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86878: LD_INT 0
86880: PPUSH
// result := mc_vehicles [ base ] ;
86881: LD_ADDR_VAR 0 3
86885: PUSH
86886: LD_EXP 82
86890: PUSH
86891: LD_VAR 0 1
86895: ARRAY
86896: ST_TO_ADDR
// if onlyCombat then
86897: LD_VAR 0 2
86901: IFFALSE 87073
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86903: LD_ADDR_VAR 0 3
86907: PUSH
86908: LD_VAR 0 3
86912: PUSH
86913: LD_VAR 0 3
86917: PPUSH
86918: LD_INT 2
86920: PUSH
86921: LD_INT 34
86923: PUSH
86924: LD_INT 12
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 34
86933: PUSH
86934: LD_INT 51
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 34
86943: PUSH
86944: LD_INT 89
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 34
86953: PUSH
86954: LD_INT 32
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 34
86963: PUSH
86964: LD_INT 13
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 34
86973: PUSH
86974: LD_INT 52
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 34
86983: PUSH
86984: LD_INT 88
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 34
86993: PUSH
86994: LD_INT 14
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 34
87003: PUSH
87004: LD_INT 53
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 34
87013: PUSH
87014: LD_INT 98
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 34
87023: PUSH
87024: LD_INT 31
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 34
87033: PUSH
87034: LD_INT 48
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 34
87043: PUSH
87044: LD_INT 8
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: PPUSH
87067: CALL_OW 72
87071: DIFF
87072: ST_TO_ADDR
// end ; end_of_file
87073: LD_VAR 0 3
87077: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87078: LD_INT 0
87080: PPUSH
87081: PPUSH
87082: PPUSH
// if not mc_bases or not skirmish then
87083: LD_EXP 63
87087: NOT
87088: IFTRUE 87097
87090: PUSH
87091: LD_EXP 61
87095: NOT
87096: OR
87097: IFFALSE 87101
// exit ;
87099: GO 87266
// for i = 1 to mc_bases do
87101: LD_ADDR_VAR 0 4
87105: PUSH
87106: DOUBLE
87107: LD_INT 1
87109: DEC
87110: ST_TO_ADDR
87111: LD_EXP 63
87115: PUSH
87116: FOR_TO
87117: IFFALSE 87264
// begin if sci in mc_bases [ i ] then
87119: LD_VAR 0 2
87123: PUSH
87124: LD_EXP 63
87128: PUSH
87129: LD_VAR 0 4
87133: ARRAY
87134: IN
87135: IFFALSE 87262
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87137: LD_ADDR_EXP 92
87141: PUSH
87142: LD_EXP 92
87146: PPUSH
87147: LD_VAR 0 4
87151: PUSH
87152: LD_EXP 92
87156: PUSH
87157: LD_VAR 0 4
87161: ARRAY
87162: PUSH
87163: LD_INT 1
87165: PLUS
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PPUSH
87171: LD_VAR 0 1
87175: PPUSH
87176: CALL 22482 0 3
87180: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87181: LD_ADDR_VAR 0 5
87185: PUSH
87186: LD_EXP 63
87190: PUSH
87191: LD_VAR 0 4
87195: ARRAY
87196: PPUSH
87197: LD_INT 2
87199: PUSH
87200: LD_INT 30
87202: PUSH
87203: LD_INT 0
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 30
87212: PUSH
87213: LD_INT 1
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: LIST
87224: PPUSH
87225: CALL_OW 72
87229: PPUSH
87230: LD_VAR 0 1
87234: PPUSH
87235: CALL_OW 74
87239: ST_TO_ADDR
// if tmp then
87240: LD_VAR 0 5
87244: IFFALSE 87260
// ComStandNearbyBuilding ( ape , tmp ) ;
87246: LD_VAR 0 1
87250: PPUSH
87251: LD_VAR 0 5
87255: PPUSH
87256: CALL 19058 0 2
// break ;
87260: GO 87264
// end ; end ;
87262: GO 87116
87264: POP
87265: POP
// end ;
87266: LD_VAR 0 3
87270: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87271: LD_INT 0
87273: PPUSH
87274: PPUSH
87275: PPUSH
// if not mc_bases or not skirmish then
87276: LD_EXP 63
87280: NOT
87281: IFTRUE 87290
87283: PUSH
87284: LD_EXP 61
87288: NOT
87289: OR
87290: IFFALSE 87294
// exit ;
87292: GO 87383
// for i = 1 to mc_bases do
87294: LD_ADDR_VAR 0 4
87298: PUSH
87299: DOUBLE
87300: LD_INT 1
87302: DEC
87303: ST_TO_ADDR
87304: LD_EXP 63
87308: PUSH
87309: FOR_TO
87310: IFFALSE 87381
// begin if building in mc_busy_turret_list [ i ] then
87312: LD_VAR 0 1
87316: PUSH
87317: LD_EXP 73
87321: PUSH
87322: LD_VAR 0 4
87326: ARRAY
87327: IN
87328: IFFALSE 87379
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87330: LD_ADDR_VAR 0 5
87334: PUSH
87335: LD_EXP 73
87339: PUSH
87340: LD_VAR 0 4
87344: ARRAY
87345: PUSH
87346: LD_VAR 0 1
87350: DIFF
87351: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87352: LD_ADDR_EXP 73
87356: PUSH
87357: LD_EXP 73
87361: PPUSH
87362: LD_VAR 0 4
87366: PPUSH
87367: LD_VAR 0 5
87371: PPUSH
87372: CALL_OW 1
87376: ST_TO_ADDR
// break ;
87377: GO 87381
// end ; end ;
87379: GO 87309
87381: POP
87382: POP
// end ;
87383: LD_VAR 0 3
87387: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87388: LD_INT 0
87390: PPUSH
87391: PPUSH
87392: PPUSH
// if not mc_bases or not skirmish then
87393: LD_EXP 63
87397: NOT
87398: IFTRUE 87407
87400: PUSH
87401: LD_EXP 61
87405: NOT
87406: OR
87407: IFFALSE 87411
// exit ;
87409: GO 87610
// for i = 1 to mc_bases do
87411: LD_ADDR_VAR 0 5
87415: PUSH
87416: DOUBLE
87417: LD_INT 1
87419: DEC
87420: ST_TO_ADDR
87421: LD_EXP 63
87425: PUSH
87426: FOR_TO
87427: IFFALSE 87608
// if building in mc_bases [ i ] then
87429: LD_VAR 0 1
87433: PUSH
87434: LD_EXP 63
87438: PUSH
87439: LD_VAR 0 5
87443: ARRAY
87444: IN
87445: IFFALSE 87606
// begin tmp := mc_bases [ i ] diff building ;
87447: LD_ADDR_VAR 0 6
87451: PUSH
87452: LD_EXP 63
87456: PUSH
87457: LD_VAR 0 5
87461: ARRAY
87462: PUSH
87463: LD_VAR 0 1
87467: DIFF
87468: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87469: LD_ADDR_EXP 63
87473: PUSH
87474: LD_EXP 63
87478: PPUSH
87479: LD_VAR 0 5
87483: PPUSH
87484: LD_VAR 0 6
87488: PPUSH
87489: CALL_OW 1
87493: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87494: LD_VAR 0 1
87498: PUSH
87499: LD_EXP 71
87503: PUSH
87504: LD_VAR 0 5
87508: ARRAY
87509: IN
87510: IFFALSE 87549
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87512: LD_ADDR_EXP 71
87516: PUSH
87517: LD_EXP 71
87521: PPUSH
87522: LD_VAR 0 5
87526: PPUSH
87527: LD_EXP 71
87531: PUSH
87532: LD_VAR 0 5
87536: ARRAY
87537: PUSH
87538: LD_VAR 0 1
87542: DIFF
87543: PPUSH
87544: CALL_OW 1
87548: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87549: LD_VAR 0 1
87553: PUSH
87554: LD_EXP 72
87558: PUSH
87559: LD_VAR 0 5
87563: ARRAY
87564: IN
87565: IFFALSE 87604
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87567: LD_ADDR_EXP 72
87571: PUSH
87572: LD_EXP 72
87576: PPUSH
87577: LD_VAR 0 5
87581: PPUSH
87582: LD_EXP 72
87586: PUSH
87587: LD_VAR 0 5
87591: ARRAY
87592: PUSH
87593: LD_VAR 0 1
87597: DIFF
87598: PPUSH
87599: CALL_OW 1
87603: ST_TO_ADDR
// break ;
87604: GO 87608
// end ;
87606: GO 87426
87608: POP
87609: POP
// end ;
87610: LD_VAR 0 4
87614: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87615: LD_INT 0
87617: PPUSH
87618: PPUSH
87619: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87620: LD_EXP 63
87624: NOT
87625: IFTRUE 87634
87627: PUSH
87628: LD_EXP 61
87632: NOT
87633: OR
87634: IFTRUE 87649
87636: PUSH
87637: LD_VAR 0 3
87641: PUSH
87642: LD_EXP 89
87646: IN
87647: NOT
87648: OR
87649: IFFALSE 87653
// exit ;
87651: GO 87778
// for i = 1 to mc_vehicles do
87653: LD_ADDR_VAR 0 6
87657: PUSH
87658: DOUBLE
87659: LD_INT 1
87661: DEC
87662: ST_TO_ADDR
87663: LD_EXP 82
87667: PUSH
87668: FOR_TO
87669: IFFALSE 87776
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87671: LD_VAR 0 2
87675: PUSH
87676: LD_EXP 82
87680: PUSH
87681: LD_VAR 0 6
87685: ARRAY
87686: IN
87687: IFTRUE 87707
87689: PUSH
87690: LD_VAR 0 1
87694: PUSH
87695: LD_EXP 82
87699: PUSH
87700: LD_VAR 0 6
87704: ARRAY
87705: IN
87706: OR
87707: IFFALSE 87774
// begin tmp := mc_vehicles [ i ] diff old ;
87709: LD_ADDR_VAR 0 7
87713: PUSH
87714: LD_EXP 82
87718: PUSH
87719: LD_VAR 0 6
87723: ARRAY
87724: PUSH
87725: LD_VAR 0 2
87729: DIFF
87730: ST_TO_ADDR
// tmp := tmp diff new ;
87731: LD_ADDR_VAR 0 7
87735: PUSH
87736: LD_VAR 0 7
87740: PUSH
87741: LD_VAR 0 1
87745: DIFF
87746: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87747: LD_ADDR_EXP 82
87751: PUSH
87752: LD_EXP 82
87756: PPUSH
87757: LD_VAR 0 6
87761: PPUSH
87762: LD_VAR 0 7
87766: PPUSH
87767: CALL_OW 1
87771: ST_TO_ADDR
// break ;
87772: GO 87776
// end ;
87774: GO 87668
87776: POP
87777: POP
// end ;
87778: LD_VAR 0 5
87782: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87783: LD_INT 0
87785: PPUSH
87786: PPUSH
87787: PPUSH
87788: PPUSH
// if not mc_bases or not skirmish then
87789: LD_EXP 63
87793: NOT
87794: IFTRUE 87803
87796: PUSH
87797: LD_EXP 61
87801: NOT
87802: OR
87803: IFFALSE 87807
// exit ;
87805: GO 88229
// repeat wait ( 0 0$1 ) ;
87807: LD_INT 35
87809: PPUSH
87810: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
87814: LD_EXP 107
87818: NOT
87819: IFFALSE 87807
// mc_block_vehicle_constructed_thread := true ;
87821: LD_ADDR_EXP 107
87825: PUSH
87826: LD_INT 1
87828: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
87829: LD_ADDR_VAR 0 5
87833: PUSH
87834: LD_VAR 0 1
87838: PPUSH
87839: CALL_OW 255
87843: ST_TO_ADDR
// for i = 1 to mc_bases do
87844: LD_ADDR_VAR 0 4
87848: PUSH
87849: DOUBLE
87850: LD_INT 1
87852: DEC
87853: ST_TO_ADDR
87854: LD_EXP 63
87858: PUSH
87859: FOR_TO
87860: IFFALSE 88219
// begin if factory in mc_bases [ i ] then
87862: LD_VAR 0 2
87866: PUSH
87867: LD_EXP 63
87871: PUSH
87872: LD_VAR 0 4
87876: ARRAY
87877: IN
87878: IFFALSE 88217
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87880: LD_EXP 85
87884: PUSH
87885: LD_VAR 0 4
87889: ARRAY
87890: PUSH
87891: LD_EXP 74
87895: PUSH
87896: LD_VAR 0 4
87900: ARRAY
87901: LESS
87902: IFFALSE 87991
87904: PUSH
87905: LD_VAR 0 1
87909: PPUSH
87910: CALL_OW 264
87914: PUSH
87915: LD_INT 31
87917: PUSH
87918: LD_INT 32
87920: PUSH
87921: LD_INT 51
87923: PUSH
87924: LD_INT 89
87926: PUSH
87927: LD_INT 12
87929: PUSH
87930: LD_INT 30
87932: PUSH
87933: LD_INT 98
87935: PUSH
87936: LD_INT 11
87938: PUSH
87939: LD_INT 53
87941: PUSH
87942: LD_INT 14
87944: PUSH
87945: LD_INT 91
87947: PUSH
87948: LD_INT 29
87950: PUSH
87951: LD_INT 99
87953: PUSH
87954: LD_INT 13
87956: PUSH
87957: LD_INT 52
87959: PUSH
87960: LD_INT 88
87962: PUSH
87963: LD_INT 48
87965: PUSH
87966: LD_INT 8
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: IN
87989: NOT
87990: AND
87991: IFFALSE 88039
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
87993: LD_ADDR_EXP 85
87997: PUSH
87998: LD_EXP 85
88002: PPUSH
88003: LD_VAR 0 4
88007: PUSH
88008: LD_EXP 85
88012: PUSH
88013: LD_VAR 0 4
88017: ARRAY
88018: PUSH
88019: LD_INT 1
88021: PLUS
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PPUSH
88027: LD_VAR 0 1
88031: PPUSH
88032: CALL 22482 0 3
88036: ST_TO_ADDR
88037: GO 88083
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88039: LD_ADDR_EXP 82
88043: PUSH
88044: LD_EXP 82
88048: PPUSH
88049: LD_VAR 0 4
88053: PUSH
88054: LD_EXP 82
88058: PUSH
88059: LD_VAR 0 4
88063: ARRAY
88064: PUSH
88065: LD_INT 1
88067: PLUS
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PPUSH
88073: LD_VAR 0 1
88077: PPUSH
88078: CALL 22482 0 3
88082: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88083: LD_ADDR_EXP 107
88087: PUSH
88088: LD_INT 0
88090: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88091: LD_VAR 0 1
88095: PPUSH
88096: CALL_OW 263
88100: PUSH
88101: LD_INT 2
88103: EQUAL
88104: IFFALSE 88133
// begin repeat wait ( 0 0$3 ) ;
88106: LD_INT 105
88108: PPUSH
88109: CALL_OW 67
// Connect ( vehicle ) ;
88113: LD_VAR 0 1
88117: PPUSH
88118: CALL 25842 0 1
// until IsControledBy ( vehicle ) ;
88122: LD_VAR 0 1
88126: PPUSH
88127: CALL_OW 312
88131: IFFALSE 88106
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88133: LD_VAR 0 1
88137: PPUSH
88138: LD_EXP 87
88142: PUSH
88143: LD_VAR 0 4
88147: ARRAY
88148: PPUSH
88149: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88153: LD_VAR 0 1
88157: PPUSH
88158: CALL_OW 263
88162: PUSH
88163: LD_INT 1
88165: NONEQUAL
88166: IFFALSE 88170
// break ;
88168: GO 88219
// repeat wait ( 0 0$1 ) ;
88170: LD_INT 35
88172: PPUSH
88173: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88177: LD_VAR 0 1
88181: PPUSH
88182: LD_EXP 87
88186: PUSH
88187: LD_VAR 0 4
88191: ARRAY
88192: PPUSH
88193: CALL_OW 308
88197: IFFALSE 88170
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88199: LD_VAR 0 1
88203: PPUSH
88204: CALL_OW 311
88208: PPUSH
88209: CALL_OW 121
// exit ;
88213: POP
88214: POP
88215: GO 88229
// end ; end ;
88217: GO 87859
88219: POP
88220: POP
// mc_block_vehicle_constructed_thread := false ;
88221: LD_ADDR_EXP 107
88225: PUSH
88226: LD_INT 0
88228: ST_TO_ADDR
// end ;
88229: LD_VAR 0 3
88233: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88234: LD_INT 0
88236: PPUSH
88237: PPUSH
88238: PPUSH
88239: PPUSH
// if not mc_bases or not skirmish then
88240: LD_EXP 63
88244: NOT
88245: IFTRUE 88254
88247: PUSH
88248: LD_EXP 61
88252: NOT
88253: OR
88254: IFFALSE 88258
// exit ;
88256: GO 88611
// repeat wait ( 0 0$1 ) ;
88258: LD_INT 35
88260: PPUSH
88261: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88265: LD_VAR 0 2
88269: PPUSH
88270: LD_VAR 0 3
88274: PPUSH
88275: CALL_OW 284
88279: IFFALSE 88258
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88281: LD_VAR 0 2
88285: PPUSH
88286: LD_VAR 0 3
88290: PPUSH
88291: CALL_OW 283
88295: PUSH
88296: LD_INT 4
88298: EQUAL
88299: IFFALSE 88303
// exit ;
88301: GO 88611
// for i = 1 to mc_bases do
88303: LD_ADDR_VAR 0 7
88307: PUSH
88308: DOUBLE
88309: LD_INT 1
88311: DEC
88312: ST_TO_ADDR
88313: LD_EXP 63
88317: PUSH
88318: FOR_TO
88319: IFFALSE 88609
// begin if mc_crates_area [ i ] then
88321: LD_EXP 81
88325: PUSH
88326: LD_VAR 0 7
88330: ARRAY
88331: IFFALSE 88442
// for j in mc_crates_area [ i ] do
88333: LD_ADDR_VAR 0 8
88337: PUSH
88338: LD_EXP 81
88342: PUSH
88343: LD_VAR 0 7
88347: ARRAY
88348: PUSH
88349: FOR_IN
88350: IFFALSE 88440
// if InArea ( x , y , j ) then
88352: LD_VAR 0 2
88356: PPUSH
88357: LD_VAR 0 3
88361: PPUSH
88362: LD_VAR 0 8
88366: PPUSH
88367: CALL_OW 309
88371: IFFALSE 88438
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88373: LD_ADDR_EXP 79
88377: PUSH
88378: LD_EXP 79
88382: PPUSH
88383: LD_VAR 0 7
88387: PUSH
88388: LD_EXP 79
88392: PUSH
88393: LD_VAR 0 7
88397: ARRAY
88398: PUSH
88399: LD_INT 1
88401: PLUS
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PPUSH
88407: LD_VAR 0 4
88411: PUSH
88412: LD_VAR 0 2
88416: PUSH
88417: LD_VAR 0 3
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: LIST
88426: PPUSH
88427: CALL 22482 0 3
88431: ST_TO_ADDR
// exit ;
88432: POP
88433: POP
88434: POP
88435: POP
88436: GO 88611
// end ;
88438: GO 88349
88440: POP
88441: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88442: LD_ADDR_VAR 0 9
88446: PUSH
88447: LD_EXP 63
88451: PUSH
88452: LD_VAR 0 7
88456: ARRAY
88457: PPUSH
88458: LD_INT 2
88460: PUSH
88461: LD_INT 30
88463: PUSH
88464: LD_INT 0
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 30
88473: PUSH
88474: LD_INT 1
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: LIST
88485: PPUSH
88486: CALL_OW 72
88490: ST_TO_ADDR
// if not depot then
88491: LD_VAR 0 9
88495: NOT
88496: IFFALSE 88500
// continue ;
88498: GO 88318
// for j in depot do
88500: LD_ADDR_VAR 0 8
88504: PUSH
88505: LD_VAR 0 9
88509: PUSH
88510: FOR_IN
88511: IFFALSE 88605
// if GetDistUnitXY ( j , x , y ) < 30 then
88513: LD_VAR 0 8
88517: PPUSH
88518: LD_VAR 0 2
88522: PPUSH
88523: LD_VAR 0 3
88527: PPUSH
88528: CALL_OW 297
88532: PUSH
88533: LD_INT 30
88535: LESS
88536: IFFALSE 88603
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88538: LD_ADDR_EXP 79
88542: PUSH
88543: LD_EXP 79
88547: PPUSH
88548: LD_VAR 0 7
88552: PUSH
88553: LD_EXP 79
88557: PUSH
88558: LD_VAR 0 7
88562: ARRAY
88563: PUSH
88564: LD_INT 1
88566: PLUS
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PPUSH
88572: LD_VAR 0 4
88576: PUSH
88577: LD_VAR 0 2
88581: PUSH
88582: LD_VAR 0 3
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: LIST
88591: PPUSH
88592: CALL 22482 0 3
88596: ST_TO_ADDR
// exit ;
88597: POP
88598: POP
88599: POP
88600: POP
88601: GO 88611
// end ;
88603: GO 88510
88605: POP
88606: POP
// end ;
88607: GO 88318
88609: POP
88610: POP
// end ;
88611: LD_VAR 0 6
88615: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88616: LD_INT 0
88618: PPUSH
88619: PPUSH
88620: PPUSH
88621: PPUSH
// if not mc_bases or not skirmish then
88622: LD_EXP 63
88626: NOT
88627: IFTRUE 88636
88629: PUSH
88630: LD_EXP 61
88634: NOT
88635: OR
88636: IFFALSE 88640
// exit ;
88638: GO 88923
// side := GetSide ( lab ) ;
88640: LD_ADDR_VAR 0 4
88644: PUSH
88645: LD_VAR 0 2
88649: PPUSH
88650: CALL_OW 255
88654: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88655: LD_VAR 0 4
88659: PUSH
88660: LD_EXP 89
88664: IN
88665: NOT
88666: IFTRUE 88675
88668: PUSH
88669: LD_EXP 90
88673: NOT
88674: OR
88675: IFTRUE 88684
88677: PUSH
88678: LD_EXP 63
88682: NOT
88683: OR
88684: IFFALSE 88688
// exit ;
88686: GO 88923
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88688: LD_ADDR_EXP 90
88692: PUSH
88693: LD_EXP 90
88697: PPUSH
88698: LD_VAR 0 4
88702: PPUSH
88703: LD_EXP 90
88707: PUSH
88708: LD_VAR 0 4
88712: ARRAY
88713: PUSH
88714: LD_VAR 0 1
88718: DIFF
88719: PPUSH
88720: CALL_OW 1
88724: ST_TO_ADDR
// for i = 1 to mc_bases do
88725: LD_ADDR_VAR 0 5
88729: PUSH
88730: DOUBLE
88731: LD_INT 1
88733: DEC
88734: ST_TO_ADDR
88735: LD_EXP 63
88739: PUSH
88740: FOR_TO
88741: IFFALSE 88921
// begin if lab in mc_bases [ i ] then
88743: LD_VAR 0 2
88747: PUSH
88748: LD_EXP 63
88752: PUSH
88753: LD_VAR 0 5
88757: ARRAY
88758: IN
88759: IFFALSE 88919
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88761: LD_VAR 0 1
88765: PUSH
88766: LD_INT 11
88768: PUSH
88769: LD_INT 4
88771: PUSH
88772: LD_INT 3
88774: PUSH
88775: LD_INT 2
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: IN
88784: IFFALSE 88798
88786: PUSH
88787: LD_EXP 93
88791: PUSH
88792: LD_VAR 0 5
88796: ARRAY
88797: AND
88798: IFFALSE 88919
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88800: LD_ADDR_VAR 0 6
88804: PUSH
88805: LD_EXP 93
88809: PUSH
88810: LD_VAR 0 5
88814: ARRAY
88815: PUSH
88816: LD_INT 1
88818: ARRAY
88819: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88820: LD_ADDR_EXP 93
88824: PUSH
88825: LD_EXP 93
88829: PPUSH
88830: LD_VAR 0 5
88834: PPUSH
88835: EMPTY
88836: PPUSH
88837: CALL_OW 1
88841: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88842: LD_VAR 0 6
88846: PPUSH
88847: LD_INT 0
88849: PPUSH
88850: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88854: LD_VAR 0 6
88858: PPUSH
88859: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88863: LD_ADDR_EXP 92
88867: PUSH
88868: LD_EXP 92
88872: PPUSH
88873: LD_VAR 0 5
88877: PPUSH
88878: LD_EXP 92
88882: PUSH
88883: LD_VAR 0 5
88887: ARRAY
88888: PPUSH
88889: LD_INT 1
88891: PPUSH
88892: LD_VAR 0 6
88896: PPUSH
88897: CALL_OW 2
88901: PPUSH
88902: CALL_OW 1
88906: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88907: LD_VAR 0 5
88911: PPUSH
88912: LD_INT 112
88914: PPUSH
88915: CALL 65053 0 2
// end ; end ; end ;
88919: GO 88740
88921: POP
88922: POP
// end ;
88923: LD_VAR 0 3
88927: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88928: LD_INT 0
88930: PPUSH
88931: PPUSH
88932: PPUSH
88933: PPUSH
88934: PPUSH
88935: PPUSH
88936: PPUSH
88937: PPUSH
// if not mc_bases or not skirmish then
88938: LD_EXP 63
88942: NOT
88943: IFTRUE 88952
88945: PUSH
88946: LD_EXP 61
88950: NOT
88951: OR
88952: IFFALSE 88956
// exit ;
88954: GO 90341
// for i = 1 to mc_bases do
88956: LD_ADDR_VAR 0 3
88960: PUSH
88961: DOUBLE
88962: LD_INT 1
88964: DEC
88965: ST_TO_ADDR
88966: LD_EXP 63
88970: PUSH
88971: FOR_TO
88972: IFFALSE 90339
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88974: LD_VAR 0 1
88978: PUSH
88979: LD_EXP 63
88983: PUSH
88984: LD_VAR 0 3
88988: ARRAY
88989: IN
88990: IFTRUE 89010
88992: PUSH
88993: LD_VAR 0 1
88997: PUSH
88998: LD_EXP 70
89002: PUSH
89003: LD_VAR 0 3
89007: ARRAY
89008: IN
89009: OR
89010: IFTRUE 89030
89012: PUSH
89013: LD_VAR 0 1
89017: PUSH
89018: LD_EXP 85
89022: PUSH
89023: LD_VAR 0 3
89027: ARRAY
89028: IN
89029: OR
89030: IFTRUE 89050
89032: PUSH
89033: LD_VAR 0 1
89037: PUSH
89038: LD_EXP 82
89042: PUSH
89043: LD_VAR 0 3
89047: ARRAY
89048: IN
89049: OR
89050: IFTRUE 89070
89052: PUSH
89053: LD_VAR 0 1
89057: PUSH
89058: LD_EXP 92
89062: PUSH
89063: LD_VAR 0 3
89067: ARRAY
89068: IN
89069: OR
89070: IFTRUE 89090
89072: PUSH
89073: LD_VAR 0 1
89077: PUSH
89078: LD_EXP 93
89082: PUSH
89083: LD_VAR 0 3
89087: ARRAY
89088: IN
89089: OR
89090: IFFALSE 90337
// begin if un in mc_ape [ i ] then
89092: LD_VAR 0 1
89096: PUSH
89097: LD_EXP 92
89101: PUSH
89102: LD_VAR 0 3
89106: ARRAY
89107: IN
89108: IFFALSE 89147
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89110: LD_ADDR_EXP 92
89114: PUSH
89115: LD_EXP 92
89119: PPUSH
89120: LD_VAR 0 3
89124: PPUSH
89125: LD_EXP 92
89129: PUSH
89130: LD_VAR 0 3
89134: ARRAY
89135: PUSH
89136: LD_VAR 0 1
89140: DIFF
89141: PPUSH
89142: CALL_OW 1
89146: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89147: LD_VAR 0 1
89151: PUSH
89152: LD_EXP 93
89156: PUSH
89157: LD_VAR 0 3
89161: ARRAY
89162: IN
89163: IFFALSE 89187
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89165: LD_ADDR_EXP 93
89169: PUSH
89170: LD_EXP 93
89174: PPUSH
89175: LD_VAR 0 3
89179: PPUSH
89180: EMPTY
89181: PPUSH
89182: CALL_OW 1
89186: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89187: LD_VAR 0 1
89191: PPUSH
89192: CALL_OW 247
89196: PUSH
89197: LD_INT 2
89199: EQUAL
89200: IFFALSE 89281
89202: PUSH
89203: LD_VAR 0 1
89207: PPUSH
89208: CALL_OW 110
89212: PUSH
89213: LD_INT 20
89215: EQUAL
89216: IFTRUE 89236
89218: PUSH
89219: LD_VAR 0 1
89223: PUSH
89224: LD_EXP 85
89228: PUSH
89229: LD_VAR 0 3
89233: ARRAY
89234: IN
89235: OR
89236: IFTRUE 89280
89238: PUSH
89239: LD_VAR 0 1
89243: PPUSH
89244: CALL_OW 264
89248: PUSH
89249: LD_INT 12
89251: PUSH
89252: LD_INT 51
89254: PUSH
89255: LD_INT 89
89257: PUSH
89258: LD_INT 32
89260: PUSH
89261: LD_INT 13
89263: PUSH
89264: LD_INT 52
89266: PUSH
89267: LD_INT 31
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: IN
89279: OR
89280: AND
89281: IFFALSE 89589
// begin if un in mc_defender [ i ] then
89283: LD_VAR 0 1
89287: PUSH
89288: LD_EXP 85
89292: PUSH
89293: LD_VAR 0 3
89297: ARRAY
89298: IN
89299: IFFALSE 89338
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89301: LD_ADDR_EXP 85
89305: PUSH
89306: LD_EXP 85
89310: PPUSH
89311: LD_VAR 0 3
89315: PPUSH
89316: LD_EXP 85
89320: PUSH
89321: LD_VAR 0 3
89325: ARRAY
89326: PUSH
89327: LD_VAR 0 1
89331: DIFF
89332: PPUSH
89333: CALL_OW 1
89337: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89338: LD_ADDR_VAR 0 8
89342: PUSH
89343: LD_VAR 0 3
89347: PPUSH
89348: LD_INT 3
89350: PPUSH
89351: CALL 85877 0 2
89355: ST_TO_ADDR
// if fac then
89356: LD_VAR 0 8
89360: IFFALSE 89589
// begin for j in fac do
89362: LD_ADDR_VAR 0 4
89366: PUSH
89367: LD_VAR 0 8
89371: PUSH
89372: FOR_IN
89373: IFFALSE 89587
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89375: LD_ADDR_VAR 0 9
89379: PUSH
89380: LD_VAR 0 8
89384: PPUSH
89385: LD_VAR 0 1
89389: PPUSH
89390: CALL_OW 265
89394: PPUSH
89395: LD_VAR 0 1
89399: PPUSH
89400: CALL_OW 262
89404: PPUSH
89405: LD_VAR 0 1
89409: PPUSH
89410: CALL_OW 263
89414: PPUSH
89415: LD_VAR 0 1
89419: PPUSH
89420: CALL_OW 264
89424: PPUSH
89425: CALL 19956 0 5
89429: ST_TO_ADDR
// if components then
89430: LD_VAR 0 9
89434: IFFALSE 89585
// begin if GetWeapon ( un ) = ar_control_tower then
89436: LD_VAR 0 1
89440: PPUSH
89441: CALL_OW 264
89445: PUSH
89446: LD_INT 31
89448: EQUAL
89449: IFFALSE 89566
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89451: LD_VAR 0 1
89455: PPUSH
89456: CALL_OW 311
89460: PPUSH
89461: LD_INT 0
89463: PPUSH
89464: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89468: LD_ADDR_EXP 103
89472: PUSH
89473: LD_EXP 103
89477: PPUSH
89478: LD_VAR 0 3
89482: PPUSH
89483: LD_EXP 103
89487: PUSH
89488: LD_VAR 0 3
89492: ARRAY
89493: PUSH
89494: LD_VAR 0 1
89498: PPUSH
89499: CALL_OW 311
89503: DIFF
89504: PPUSH
89505: CALL_OW 1
89509: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89510: LD_ADDR_VAR 0 7
89514: PUSH
89515: LD_EXP 84
89519: PUSH
89520: LD_VAR 0 3
89524: ARRAY
89525: PPUSH
89526: LD_INT 1
89528: PPUSH
89529: LD_VAR 0 9
89533: PPUSH
89534: CALL_OW 2
89538: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89539: LD_ADDR_EXP 84
89543: PUSH
89544: LD_EXP 84
89548: PPUSH
89549: LD_VAR 0 3
89553: PPUSH
89554: LD_VAR 0 7
89558: PPUSH
89559: CALL_OW 1
89563: ST_TO_ADDR
// end else
89564: GO 89583
// MC_InsertProduceList ( i , [ components ] ) ;
89566: LD_VAR 0 3
89570: PPUSH
89571: LD_VAR 0 9
89575: PUSH
89576: EMPTY
89577: LIST
89578: PPUSH
89579: CALL 85422 0 2
// break ;
89583: GO 89587
// end ; end ;
89585: GO 89372
89587: POP
89588: POP
// end ; end ; if GetType ( un ) = unit_building then
89589: LD_VAR 0 1
89593: PPUSH
89594: CALL_OW 247
89598: PUSH
89599: LD_INT 3
89601: EQUAL
89602: IFFALSE 90005
// begin btype := GetBType ( un ) ;
89604: LD_ADDR_VAR 0 5
89608: PUSH
89609: LD_VAR 0 1
89613: PPUSH
89614: CALL_OW 266
89618: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89619: LD_VAR 0 5
89623: PUSH
89624: LD_INT 29
89626: PUSH
89627: LD_INT 30
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: IN
89634: IFFALSE 89707
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89636: LD_VAR 0 1
89640: PPUSH
89641: CALL_OW 250
89645: PPUSH
89646: LD_VAR 0 1
89650: PPUSH
89651: CALL_OW 251
89655: PPUSH
89656: LD_VAR 0 1
89660: PPUSH
89661: CALL_OW 255
89665: PPUSH
89666: CALL_OW 440
89670: NOT
89671: IFFALSE 89707
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89673: LD_VAR 0 1
89677: PPUSH
89678: CALL_OW 250
89682: PPUSH
89683: LD_VAR 0 1
89687: PPUSH
89688: CALL_OW 251
89692: PPUSH
89693: LD_VAR 0 1
89697: PPUSH
89698: CALL_OW 255
89702: PPUSH
89703: CALL_OW 441
// end ; if btype = b_warehouse then
89707: LD_VAR 0 5
89711: PUSH
89712: LD_INT 1
89714: EQUAL
89715: IFFALSE 89733
// begin btype := b_depot ;
89717: LD_ADDR_VAR 0 5
89721: PUSH
89722: LD_INT 0
89724: ST_TO_ADDR
// pos := 1 ;
89725: LD_ADDR_VAR 0 6
89729: PUSH
89730: LD_INT 1
89732: ST_TO_ADDR
// end ; if btype = b_factory then
89733: LD_VAR 0 5
89737: PUSH
89738: LD_INT 3
89740: EQUAL
89741: IFFALSE 89759
// begin btype := b_workshop ;
89743: LD_ADDR_VAR 0 5
89747: PUSH
89748: LD_INT 2
89750: ST_TO_ADDR
// pos := 1 ;
89751: LD_ADDR_VAR 0 6
89755: PUSH
89756: LD_INT 1
89758: ST_TO_ADDR
// end ; if btype = b_barracks then
89759: LD_VAR 0 5
89763: PUSH
89764: LD_INT 5
89766: EQUAL
89767: IFFALSE 89777
// btype := b_armoury ;
89769: LD_ADDR_VAR 0 5
89773: PUSH
89774: LD_INT 4
89776: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89777: LD_VAR 0 5
89781: PUSH
89782: LD_INT 7
89784: PUSH
89785: LD_INT 8
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: IN
89792: IFFALSE 89802
// btype := b_lab ;
89794: LD_ADDR_VAR 0 5
89798: PUSH
89799: LD_INT 6
89801: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89802: LD_ADDR_EXP 68
89806: PUSH
89807: LD_EXP 68
89811: PPUSH
89812: LD_VAR 0 3
89816: PUSH
89817: LD_EXP 68
89821: PUSH
89822: LD_VAR 0 3
89826: ARRAY
89827: PUSH
89828: LD_INT 1
89830: PLUS
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PPUSH
89836: LD_VAR 0 5
89840: PUSH
89841: LD_VAR 0 1
89845: PPUSH
89846: CALL_OW 250
89850: PUSH
89851: LD_VAR 0 1
89855: PPUSH
89856: CALL_OW 251
89860: PUSH
89861: LD_VAR 0 1
89865: PPUSH
89866: CALL_OW 254
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: PPUSH
89877: CALL 22482 0 3
89881: ST_TO_ADDR
// if pos = 1 then
89882: LD_VAR 0 6
89886: PUSH
89887: LD_INT 1
89889: EQUAL
89890: IFFALSE 90005
// begin tmp := mc_build_list [ i ] ;
89892: LD_ADDR_VAR 0 7
89896: PUSH
89897: LD_EXP 68
89901: PUSH
89902: LD_VAR 0 3
89906: ARRAY
89907: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89908: LD_VAR 0 7
89912: PPUSH
89913: LD_INT 2
89915: PUSH
89916: LD_INT 30
89918: PUSH
89919: LD_INT 0
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 30
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: LIST
89940: PPUSH
89941: CALL_OW 72
89945: IFFALSE 89955
// pos := 2 ;
89947: LD_ADDR_VAR 0 6
89951: PUSH
89952: LD_INT 2
89954: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89955: LD_ADDR_VAR 0 7
89959: PUSH
89960: LD_VAR 0 7
89964: PPUSH
89965: LD_VAR 0 6
89969: PPUSH
89970: LD_VAR 0 7
89974: PPUSH
89975: CALL 22808 0 3
89979: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89980: LD_ADDR_EXP 68
89984: PUSH
89985: LD_EXP 68
89989: PPUSH
89990: LD_VAR 0 3
89994: PPUSH
89995: LD_VAR 0 7
89999: PPUSH
90000: CALL_OW 1
90004: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90005: LD_VAR 0 1
90009: PUSH
90010: LD_EXP 63
90014: PUSH
90015: LD_VAR 0 3
90019: ARRAY
90020: IN
90021: IFFALSE 90060
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90023: LD_ADDR_EXP 63
90027: PUSH
90028: LD_EXP 63
90032: PPUSH
90033: LD_VAR 0 3
90037: PPUSH
90038: LD_EXP 63
90042: PUSH
90043: LD_VAR 0 3
90047: ARRAY
90048: PUSH
90049: LD_VAR 0 1
90053: DIFF
90054: PPUSH
90055: CALL_OW 1
90059: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90060: LD_VAR 0 1
90064: PUSH
90065: LD_EXP 70
90069: PUSH
90070: LD_VAR 0 3
90074: ARRAY
90075: IN
90076: IFFALSE 90115
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90078: LD_ADDR_EXP 70
90082: PUSH
90083: LD_EXP 70
90087: PPUSH
90088: LD_VAR 0 3
90092: PPUSH
90093: LD_EXP 70
90097: PUSH
90098: LD_VAR 0 3
90102: ARRAY
90103: PUSH
90104: LD_VAR 0 1
90108: DIFF
90109: PPUSH
90110: CALL_OW 1
90114: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90115: LD_VAR 0 1
90119: PUSH
90120: LD_EXP 82
90124: PUSH
90125: LD_VAR 0 3
90129: ARRAY
90130: IN
90131: IFFALSE 90170
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90133: LD_ADDR_EXP 82
90137: PUSH
90138: LD_EXP 82
90142: PPUSH
90143: LD_VAR 0 3
90147: PPUSH
90148: LD_EXP 82
90152: PUSH
90153: LD_VAR 0 3
90157: ARRAY
90158: PUSH
90159: LD_VAR 0 1
90163: DIFF
90164: PPUSH
90165: CALL_OW 1
90169: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90170: LD_VAR 0 1
90174: PUSH
90175: LD_EXP 85
90179: PUSH
90180: LD_VAR 0 3
90184: ARRAY
90185: IN
90186: IFFALSE 90225
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90188: LD_ADDR_EXP 85
90192: PUSH
90193: LD_EXP 85
90197: PPUSH
90198: LD_VAR 0 3
90202: PPUSH
90203: LD_EXP 85
90207: PUSH
90208: LD_VAR 0 3
90212: ARRAY
90213: PUSH
90214: LD_VAR 0 1
90218: DIFF
90219: PPUSH
90220: CALL_OW 1
90224: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90225: LD_VAR 0 1
90229: PUSH
90230: LD_EXP 72
90234: PUSH
90235: LD_VAR 0 3
90239: ARRAY
90240: IN
90241: IFFALSE 90280
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90243: LD_ADDR_EXP 72
90247: PUSH
90248: LD_EXP 72
90252: PPUSH
90253: LD_VAR 0 3
90257: PPUSH
90258: LD_EXP 72
90262: PUSH
90263: LD_VAR 0 3
90267: ARRAY
90268: PUSH
90269: LD_VAR 0 1
90273: DIFF
90274: PPUSH
90275: CALL_OW 1
90279: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90280: LD_VAR 0 1
90284: PUSH
90285: LD_EXP 71
90289: PUSH
90290: LD_VAR 0 3
90294: ARRAY
90295: IN
90296: IFFALSE 90335
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90298: LD_ADDR_EXP 71
90302: PUSH
90303: LD_EXP 71
90307: PPUSH
90308: LD_VAR 0 3
90312: PPUSH
90313: LD_EXP 71
90317: PUSH
90318: LD_VAR 0 3
90322: ARRAY
90323: PUSH
90324: LD_VAR 0 1
90328: DIFF
90329: PPUSH
90330: CALL_OW 1
90334: ST_TO_ADDR
// end ; break ;
90335: GO 90339
// end ;
90337: GO 88971
90339: POP
90340: POP
// end ;
90341: LD_VAR 0 2
90345: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90346: LD_INT 0
90348: PPUSH
90349: PPUSH
90350: PPUSH
// if not mc_bases or not skirmish then
90351: LD_EXP 63
90355: NOT
90356: IFTRUE 90365
90358: PUSH
90359: LD_EXP 61
90363: NOT
90364: OR
90365: IFFALSE 90369
// exit ;
90367: GO 90584
// for i = 1 to mc_bases do
90369: LD_ADDR_VAR 0 3
90373: PUSH
90374: DOUBLE
90375: LD_INT 1
90377: DEC
90378: ST_TO_ADDR
90379: LD_EXP 63
90383: PUSH
90384: FOR_TO
90385: IFFALSE 90582
// begin if building in mc_construct_list [ i ] then
90387: LD_VAR 0 1
90391: PUSH
90392: LD_EXP 70
90396: PUSH
90397: LD_VAR 0 3
90401: ARRAY
90402: IN
90403: IFFALSE 90580
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90405: LD_ADDR_EXP 70
90409: PUSH
90410: LD_EXP 70
90414: PPUSH
90415: LD_VAR 0 3
90419: PPUSH
90420: LD_EXP 70
90424: PUSH
90425: LD_VAR 0 3
90429: ARRAY
90430: PUSH
90431: LD_VAR 0 1
90435: DIFF
90436: PPUSH
90437: CALL_OW 1
90441: ST_TO_ADDR
// if building in mc_lab [ i ] then
90442: LD_VAR 0 1
90446: PUSH
90447: LD_EXP 96
90451: PUSH
90452: LD_VAR 0 3
90456: ARRAY
90457: IN
90458: IFFALSE 90513
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90460: LD_ADDR_EXP 97
90464: PUSH
90465: LD_EXP 97
90469: PPUSH
90470: LD_VAR 0 3
90474: PPUSH
90475: LD_EXP 97
90479: PUSH
90480: LD_VAR 0 3
90484: ARRAY
90485: PPUSH
90486: LD_INT 1
90488: PPUSH
90489: LD_EXP 97
90493: PUSH
90494: LD_VAR 0 3
90498: ARRAY
90499: PPUSH
90500: LD_INT 0
90502: PPUSH
90503: CALL 21890 0 4
90507: PPUSH
90508: CALL_OW 1
90512: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90513: LD_VAR 0 1
90517: PUSH
90518: LD_EXP 63
90522: PUSH
90523: LD_VAR 0 3
90527: ARRAY
90528: IN
90529: NOT
90530: IFFALSE 90576
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90532: LD_ADDR_EXP 63
90536: PUSH
90537: LD_EXP 63
90541: PPUSH
90542: LD_VAR 0 3
90546: PUSH
90547: LD_EXP 63
90551: PUSH
90552: LD_VAR 0 3
90556: ARRAY
90557: PUSH
90558: LD_INT 1
90560: PLUS
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PPUSH
90566: LD_VAR 0 1
90570: PPUSH
90571: CALL 22482 0 3
90575: ST_TO_ADDR
// exit ;
90576: POP
90577: POP
90578: GO 90584
// end ; end ;
90580: GO 90384
90582: POP
90583: POP
// end ;
90584: LD_VAR 0 2
90588: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90589: LD_INT 0
90591: PPUSH
90592: PPUSH
90593: PPUSH
90594: PPUSH
90595: PPUSH
90596: PPUSH
90597: PPUSH
// if not mc_bases or not skirmish then
90598: LD_EXP 63
90602: NOT
90603: IFTRUE 90612
90605: PUSH
90606: LD_EXP 61
90610: NOT
90611: OR
90612: IFFALSE 90616
// exit ;
90614: GO 91277
// for i = 1 to mc_bases do
90616: LD_ADDR_VAR 0 3
90620: PUSH
90621: DOUBLE
90622: LD_INT 1
90624: DEC
90625: ST_TO_ADDR
90626: LD_EXP 63
90630: PUSH
90631: FOR_TO
90632: IFFALSE 91275
// begin if building in mc_construct_list [ i ] then
90634: LD_VAR 0 1
90638: PUSH
90639: LD_EXP 70
90643: PUSH
90644: LD_VAR 0 3
90648: ARRAY
90649: IN
90650: IFFALSE 91273
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90652: LD_ADDR_EXP 70
90656: PUSH
90657: LD_EXP 70
90661: PPUSH
90662: LD_VAR 0 3
90666: PPUSH
90667: LD_EXP 70
90671: PUSH
90672: LD_VAR 0 3
90676: ARRAY
90677: PUSH
90678: LD_VAR 0 1
90682: DIFF
90683: PPUSH
90684: CALL_OW 1
90688: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90689: LD_ADDR_EXP 63
90693: PUSH
90694: LD_EXP 63
90698: PPUSH
90699: LD_VAR 0 3
90703: PUSH
90704: LD_EXP 63
90708: PUSH
90709: LD_VAR 0 3
90713: ARRAY
90714: PUSH
90715: LD_INT 1
90717: PLUS
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PPUSH
90723: LD_VAR 0 1
90727: PPUSH
90728: CALL 22482 0 3
90732: ST_TO_ADDR
// btype := GetBType ( building ) ;
90733: LD_ADDR_VAR 0 5
90737: PUSH
90738: LD_VAR 0 1
90742: PPUSH
90743: CALL_OW 266
90747: ST_TO_ADDR
// side := GetSide ( building ) ;
90748: LD_ADDR_VAR 0 8
90752: PUSH
90753: LD_VAR 0 1
90757: PPUSH
90758: CALL_OW 255
90762: ST_TO_ADDR
// if btype = b_lab then
90763: LD_VAR 0 5
90767: PUSH
90768: LD_INT 6
90770: EQUAL
90771: IFFALSE 90821
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90773: LD_ADDR_EXP 96
90777: PUSH
90778: LD_EXP 96
90782: PPUSH
90783: LD_VAR 0 3
90787: PUSH
90788: LD_EXP 96
90792: PUSH
90793: LD_VAR 0 3
90797: ARRAY
90798: PUSH
90799: LD_INT 1
90801: PLUS
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PPUSH
90807: LD_VAR 0 1
90811: PPUSH
90812: CALL 22482 0 3
90816: ST_TO_ADDR
// exit ;
90817: POP
90818: POP
90819: GO 91277
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90821: LD_VAR 0 5
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: LD_INT 2
90831: PUSH
90832: LD_INT 4
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: LIST
90839: IN
90840: IFFALSE 90964
// begin if btype = b_armoury then
90842: LD_VAR 0 5
90846: PUSH
90847: LD_INT 4
90849: EQUAL
90850: IFFALSE 90860
// btype := b_barracks ;
90852: LD_ADDR_VAR 0 5
90856: PUSH
90857: LD_INT 5
90859: ST_TO_ADDR
// if btype = b_depot then
90860: LD_VAR 0 5
90864: PUSH
90865: LD_INT 0
90867: EQUAL
90868: IFFALSE 90878
// btype := b_warehouse ;
90870: LD_ADDR_VAR 0 5
90874: PUSH
90875: LD_INT 1
90877: ST_TO_ADDR
// if btype = b_workshop then
90878: LD_VAR 0 5
90882: PUSH
90883: LD_INT 2
90885: EQUAL
90886: IFFALSE 90896
// btype := b_factory ;
90888: LD_ADDR_VAR 0 5
90892: PUSH
90893: LD_INT 3
90895: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90896: LD_VAR 0 5
90900: PPUSH
90901: LD_VAR 0 8
90905: PPUSH
90906: CALL_OW 323
90910: PUSH
90911: LD_INT 1
90913: EQUAL
90914: IFFALSE 90960
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90916: LD_ADDR_EXP 95
90920: PUSH
90921: LD_EXP 95
90925: PPUSH
90926: LD_VAR 0 3
90930: PUSH
90931: LD_EXP 95
90935: PUSH
90936: LD_VAR 0 3
90940: ARRAY
90941: PUSH
90942: LD_INT 1
90944: PLUS
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PPUSH
90950: LD_VAR 0 1
90954: PPUSH
90955: CALL 22482 0 3
90959: ST_TO_ADDR
// exit ;
90960: POP
90961: POP
90962: GO 91277
// end ; if btype in [ b_bunker , b_turret ] then
90964: LD_VAR 0 5
90968: PUSH
90969: LD_INT 32
90971: PUSH
90972: LD_INT 33
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: IN
90979: IFFALSE 91269
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90981: LD_ADDR_EXP 71
90985: PUSH
90986: LD_EXP 71
90990: PPUSH
90991: LD_VAR 0 3
90995: PUSH
90996: LD_EXP 71
91000: PUSH
91001: LD_VAR 0 3
91005: ARRAY
91006: PUSH
91007: LD_INT 1
91009: PLUS
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PPUSH
91015: LD_VAR 0 1
91019: PPUSH
91020: CALL 22482 0 3
91024: ST_TO_ADDR
// if btype = b_bunker then
91025: LD_VAR 0 5
91029: PUSH
91030: LD_INT 32
91032: EQUAL
91033: IFFALSE 91269
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91035: LD_ADDR_EXP 72
91039: PUSH
91040: LD_EXP 72
91044: PPUSH
91045: LD_VAR 0 3
91049: PUSH
91050: LD_EXP 72
91054: PUSH
91055: LD_VAR 0 3
91059: ARRAY
91060: PUSH
91061: LD_INT 1
91063: PLUS
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PPUSH
91069: LD_VAR 0 1
91073: PPUSH
91074: CALL 22482 0 3
91078: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91079: LD_ADDR_VAR 0 6
91083: PUSH
91084: LD_EXP 63
91088: PUSH
91089: LD_VAR 0 3
91093: ARRAY
91094: PPUSH
91095: LD_INT 25
91097: PUSH
91098: LD_INT 1
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 3
91107: PUSH
91108: LD_INT 54
91110: PUSH
91111: EMPTY
91112: LIST
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PPUSH
91122: CALL_OW 72
91126: ST_TO_ADDR
// if tmp then
91127: LD_VAR 0 6
91131: IFFALSE 91137
// exit ;
91133: POP
91134: POP
91135: GO 91277
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91137: LD_ADDR_VAR 0 6
91141: PUSH
91142: LD_EXP 63
91146: PUSH
91147: LD_VAR 0 3
91151: ARRAY
91152: PPUSH
91153: LD_INT 2
91155: PUSH
91156: LD_INT 30
91158: PUSH
91159: LD_INT 4
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 30
91168: PUSH
91169: LD_INT 5
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: LIST
91180: PPUSH
91181: CALL_OW 72
91185: ST_TO_ADDR
// if not tmp then
91186: LD_VAR 0 6
91190: NOT
91191: IFFALSE 91197
// exit ;
91193: POP
91194: POP
91195: GO 91277
// for j in tmp do
91197: LD_ADDR_VAR 0 4
91201: PUSH
91202: LD_VAR 0 6
91206: PUSH
91207: FOR_IN
91208: IFFALSE 91267
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91210: LD_ADDR_VAR 0 7
91214: PUSH
91215: LD_VAR 0 4
91219: PPUSH
91220: CALL_OW 313
91224: PPUSH
91225: LD_INT 25
91227: PUSH
91228: LD_INT 1
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PPUSH
91235: CALL_OW 72
91239: ST_TO_ADDR
// if units then
91240: LD_VAR 0 7
91244: IFFALSE 91265
// begin ComExitBuilding ( units [ 1 ] ) ;
91246: LD_VAR 0 7
91250: PUSH
91251: LD_INT 1
91253: ARRAY
91254: PPUSH
91255: CALL_OW 122
// exit ;
91259: POP
91260: POP
91261: POP
91262: POP
91263: GO 91277
// end ; end ;
91265: GO 91207
91267: POP
91268: POP
// end ; end ; exit ;
91269: POP
91270: POP
91271: GO 91277
// end ; end ;
91273: GO 90631
91275: POP
91276: POP
// end ;
91277: LD_VAR 0 2
91281: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91282: LD_INT 0
91284: PPUSH
91285: PPUSH
91286: PPUSH
91287: PPUSH
91288: PPUSH
91289: PPUSH
91290: PPUSH
// if not mc_bases or not skirmish then
91291: LD_EXP 63
91295: NOT
91296: IFTRUE 91305
91298: PUSH
91299: LD_EXP 61
91303: NOT
91304: OR
91305: IFFALSE 91309
// exit ;
91307: GO 91574
// btype := GetBType ( building ) ;
91309: LD_ADDR_VAR 0 6
91313: PUSH
91314: LD_VAR 0 1
91318: PPUSH
91319: CALL_OW 266
91323: ST_TO_ADDR
// x := GetX ( building ) ;
91324: LD_ADDR_VAR 0 7
91328: PUSH
91329: LD_VAR 0 1
91333: PPUSH
91334: CALL_OW 250
91338: ST_TO_ADDR
// y := GetY ( building ) ;
91339: LD_ADDR_VAR 0 8
91343: PUSH
91344: LD_VAR 0 1
91348: PPUSH
91349: CALL_OW 251
91353: ST_TO_ADDR
// d := GetDir ( building ) ;
91354: LD_ADDR_VAR 0 9
91358: PUSH
91359: LD_VAR 0 1
91363: PPUSH
91364: CALL_OW 254
91368: ST_TO_ADDR
// for i = 1 to mc_bases do
91369: LD_ADDR_VAR 0 4
91373: PUSH
91374: DOUBLE
91375: LD_INT 1
91377: DEC
91378: ST_TO_ADDR
91379: LD_EXP 63
91383: PUSH
91384: FOR_TO
91385: IFFALSE 91572
// begin if not mc_build_list [ i ] then
91387: LD_EXP 68
91391: PUSH
91392: LD_VAR 0 4
91396: ARRAY
91397: NOT
91398: IFFALSE 91402
// continue ;
91400: GO 91384
// for j := 1 to mc_build_list [ i ] do
91402: LD_ADDR_VAR 0 5
91406: PUSH
91407: DOUBLE
91408: LD_INT 1
91410: DEC
91411: ST_TO_ADDR
91412: LD_EXP 68
91416: PUSH
91417: LD_VAR 0 4
91421: ARRAY
91422: PUSH
91423: FOR_TO
91424: IFFALSE 91568
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91426: LD_VAR 0 6
91430: PUSH
91431: LD_VAR 0 7
91435: PUSH
91436: LD_VAR 0 8
91440: PUSH
91441: LD_VAR 0 9
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: PPUSH
91452: LD_EXP 68
91456: PUSH
91457: LD_VAR 0 4
91461: ARRAY
91462: PUSH
91463: LD_VAR 0 5
91467: ARRAY
91468: PPUSH
91469: CALL 29089 0 2
91473: IFFALSE 91566
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91475: LD_ADDR_EXP 68
91479: PUSH
91480: LD_EXP 68
91484: PPUSH
91485: LD_VAR 0 4
91489: PPUSH
91490: LD_EXP 68
91494: PUSH
91495: LD_VAR 0 4
91499: ARRAY
91500: PPUSH
91501: LD_VAR 0 5
91505: PPUSH
91506: CALL_OW 3
91510: PPUSH
91511: CALL_OW 1
91515: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91516: LD_ADDR_EXP 70
91520: PUSH
91521: LD_EXP 70
91525: PPUSH
91526: LD_VAR 0 4
91530: PUSH
91531: LD_EXP 70
91535: PUSH
91536: LD_VAR 0 4
91540: ARRAY
91541: PUSH
91542: LD_INT 1
91544: PLUS
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PPUSH
91550: LD_VAR 0 1
91554: PPUSH
91555: CALL 22482 0 3
91559: ST_TO_ADDR
// exit ;
91560: POP
91561: POP
91562: POP
91563: POP
91564: GO 91574
// end ;
91566: GO 91423
91568: POP
91569: POP
// end ;
91570: GO 91384
91572: POP
91573: POP
// end ;
91574: LD_VAR 0 3
91578: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91579: LD_INT 0
91581: PPUSH
91582: PPUSH
91583: PPUSH
// if not mc_bases or not skirmish then
91584: LD_EXP 63
91588: NOT
91589: IFTRUE 91598
91591: PUSH
91592: LD_EXP 61
91596: NOT
91597: OR
91598: IFFALSE 91602
// exit ;
91600: GO 91798
// for i = 1 to mc_bases do
91602: LD_ADDR_VAR 0 4
91606: PUSH
91607: DOUBLE
91608: LD_INT 1
91610: DEC
91611: ST_TO_ADDR
91612: LD_EXP 63
91616: PUSH
91617: FOR_TO
91618: IFFALSE 91707
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91620: LD_VAR 0 1
91624: PUSH
91625: LD_EXP 71
91629: PUSH
91630: LD_VAR 0 4
91634: ARRAY
91635: IN
91636: IFFALSE 91657
91638: PUSH
91639: LD_VAR 0 1
91643: PUSH
91644: LD_EXP 72
91648: PUSH
91649: LD_VAR 0 4
91653: ARRAY
91654: IN
91655: NOT
91656: AND
91657: IFFALSE 91705
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91659: LD_ADDR_EXP 72
91663: PUSH
91664: LD_EXP 72
91668: PPUSH
91669: LD_VAR 0 4
91673: PUSH
91674: LD_EXP 72
91678: PUSH
91679: LD_VAR 0 4
91683: ARRAY
91684: PUSH
91685: LD_INT 1
91687: PLUS
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PPUSH
91693: LD_VAR 0 1
91697: PPUSH
91698: CALL 22482 0 3
91702: ST_TO_ADDR
// break ;
91703: GO 91707
// end ; end ;
91705: GO 91617
91707: POP
91708: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91709: LD_VAR 0 1
91713: PPUSH
91714: CALL_OW 257
91718: PUSH
91719: LD_EXP 89
91723: IN
91724: IFFALSE 91741
91726: PUSH
91727: LD_VAR 0 1
91731: PPUSH
91732: CALL_OW 266
91736: PUSH
91737: LD_INT 5
91739: EQUAL
91740: AND
91741: IFFALSE 91758
91743: PUSH
91744: LD_VAR 0 2
91748: PPUSH
91749: CALL_OW 110
91753: PUSH
91754: LD_INT 18
91756: NONEQUAL
91757: AND
91758: IFFALSE 91798
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91760: LD_VAR 0 2
91764: PPUSH
91765: CALL_OW 257
91769: PUSH
91770: LD_INT 5
91772: PUSH
91773: LD_INT 8
91775: PUSH
91776: LD_INT 9
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: LIST
91783: IN
91784: IFFALSE 91798
// SetClass ( unit , 1 ) ;
91786: LD_VAR 0 2
91790: PPUSH
91791: LD_INT 1
91793: PPUSH
91794: CALL_OW 336
// end ;
91798: LD_VAR 0 3
91802: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91803: LD_INT 0
91805: PPUSH
91806: PPUSH
// if not mc_bases or not skirmish then
91807: LD_EXP 63
91811: NOT
91812: IFTRUE 91821
91814: PUSH
91815: LD_EXP 61
91819: NOT
91820: OR
91821: IFFALSE 91825
// exit ;
91823: GO 91941
// if GetLives ( abandoned_vehicle ) > 250 then
91825: LD_VAR 0 2
91829: PPUSH
91830: CALL_OW 256
91834: PUSH
91835: LD_INT 250
91837: GREATER
91838: IFFALSE 91842
// exit ;
91840: GO 91941
// for i = 1 to mc_bases do
91842: LD_ADDR_VAR 0 6
91846: PUSH
91847: DOUBLE
91848: LD_INT 1
91850: DEC
91851: ST_TO_ADDR
91852: LD_EXP 63
91856: PUSH
91857: FOR_TO
91858: IFFALSE 91939
// begin if driver in mc_bases [ i ] then
91860: LD_VAR 0 1
91864: PUSH
91865: LD_EXP 63
91869: PUSH
91870: LD_VAR 0 6
91874: ARRAY
91875: IN
91876: IFFALSE 91937
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91878: LD_VAR 0 1
91882: PPUSH
91883: LD_EXP 63
91887: PUSH
91888: LD_VAR 0 6
91892: ARRAY
91893: PPUSH
91894: LD_INT 2
91896: PUSH
91897: LD_INT 30
91899: PUSH
91900: LD_INT 0
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 30
91909: PUSH
91910: LD_INT 1
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: LIST
91921: PPUSH
91922: CALL_OW 72
91926: PUSH
91927: LD_INT 1
91929: ARRAY
91930: PPUSH
91931: CALL 56409 0 2
// break ;
91935: GO 91939
// end ; end ;
91937: GO 91857
91939: POP
91940: POP
// end ; end_of_file end_of_file
91941: LD_VAR 0 5
91945: RET
// export globalGameSaveCounter ; every 0 0$1 do
91946: GO 91948
91948: DISABLE
// begin enable ;
91949: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91950: LD_STRING updateTimer(
91952: PUSH
91953: LD_OWVAR 1
91957: STR
91958: PUSH
91959: LD_STRING );
91961: STR
91962: PPUSH
91963: CALL_OW 559
// end ;
91967: END
// every 0 0$1 do
91968: GO 91970
91970: DISABLE
// begin globalGameSaveCounter := 0 ;
91971: LD_ADDR_EXP 108
91975: PUSH
91976: LD_INT 0
91978: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91979: LD_STRING setGameSaveCounter(0)
91981: PPUSH
91982: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91986: LD_STRING initStreamRollete();
91988: PPUSH
91989: CALL_OW 559
// InitStreamMode ;
91993: CALL 93338 0 0
// DefineStreamItems ( false ) ;
91997: LD_INT 0
91999: PPUSH
92000: CALL 93802 0 1
// end ;
92004: END
// export function SOS_MapStart ( ) ; begin
92005: LD_INT 0
92007: PPUSH
// if streamModeActive then
92008: LD_EXP 109
92012: IFFALSE 92021
// DefineStreamItems ( true ) ;
92014: LD_INT 1
92016: PPUSH
92017: CALL 93802 0 1
// UpdateLuaVariables ( ) ;
92021: CALL 92038 0 0
// UpdateFactoryWaypoints ( ) ;
92025: CALL 106924 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92029: CALL 107176 0 0
// end ;
92033: LD_VAR 0 1
92037: RET
// function UpdateLuaVariables ( ) ; begin
92038: LD_INT 0
92040: PPUSH
// if globalGameSaveCounter then
92041: LD_EXP 108
92045: IFFALSE 92079
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92047: LD_ADDR_EXP 108
92051: PUSH
92052: LD_EXP 108
92056: PPUSH
92057: CALL 56903 0 1
92061: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92062: LD_STRING setGameSaveCounter(
92064: PUSH
92065: LD_EXP 108
92069: STR
92070: PUSH
92071: LD_STRING )
92073: STR
92074: PPUSH
92075: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92079: LD_STRING setGameDifficulty(
92081: PUSH
92082: LD_OWVAR 67
92086: STR
92087: PUSH
92088: LD_STRING )
92090: STR
92091: PPUSH
92092: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92096: LD_STRING displayDifficulty(
92098: PUSH
92099: LD_OWVAR 67
92103: STR
92104: PUSH
92105: LD_STRING )
92107: STR
92108: PPUSH
92109: CALL_OW 559
// end ;
92113: LD_VAR 0 1
92117: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92118: LD_INT 0
92120: PPUSH
// if p2 = stream_mode then
92121: LD_VAR 0 2
92125: PUSH
92126: LD_INT 100
92128: EQUAL
92129: IFFALSE 93132
// begin if not StreamModeActive then
92131: LD_EXP 109
92135: NOT
92136: IFFALSE 92146
// StreamModeActive := true ;
92138: LD_ADDR_EXP 109
92142: PUSH
92143: LD_INT 1
92145: ST_TO_ADDR
// if p3 = 0 then
92146: LD_VAR 0 3
92150: PUSH
92151: LD_INT 0
92153: EQUAL
92154: IFFALSE 92160
// InitStreamMode ;
92156: CALL 93338 0 0
// if p3 = 1 then
92160: LD_VAR 0 3
92164: PUSH
92165: LD_INT 1
92167: EQUAL
92168: IFFALSE 92178
// sRocket := true ;
92170: LD_ADDR_EXP 114
92174: PUSH
92175: LD_INT 1
92177: ST_TO_ADDR
// if p3 = 2 then
92178: LD_VAR 0 3
92182: PUSH
92183: LD_INT 2
92185: EQUAL
92186: IFFALSE 92196
// sSpeed := true ;
92188: LD_ADDR_EXP 113
92192: PUSH
92193: LD_INT 1
92195: ST_TO_ADDR
// if p3 = 3 then
92196: LD_VAR 0 3
92200: PUSH
92201: LD_INT 3
92203: EQUAL
92204: IFFALSE 92214
// sEngine := true ;
92206: LD_ADDR_EXP 115
92210: PUSH
92211: LD_INT 1
92213: ST_TO_ADDR
// if p3 = 4 then
92214: LD_VAR 0 3
92218: PUSH
92219: LD_INT 4
92221: EQUAL
92222: IFFALSE 92232
// sSpec := true ;
92224: LD_ADDR_EXP 112
92228: PUSH
92229: LD_INT 1
92231: ST_TO_ADDR
// if p3 = 5 then
92232: LD_VAR 0 3
92236: PUSH
92237: LD_INT 5
92239: EQUAL
92240: IFFALSE 92250
// sLevel := true ;
92242: LD_ADDR_EXP 116
92246: PUSH
92247: LD_INT 1
92249: ST_TO_ADDR
// if p3 = 6 then
92250: LD_VAR 0 3
92254: PUSH
92255: LD_INT 6
92257: EQUAL
92258: IFFALSE 92268
// sArmoury := true ;
92260: LD_ADDR_EXP 117
92264: PUSH
92265: LD_INT 1
92267: ST_TO_ADDR
// if p3 = 7 then
92268: LD_VAR 0 3
92272: PUSH
92273: LD_INT 7
92275: EQUAL
92276: IFFALSE 92286
// sRadar := true ;
92278: LD_ADDR_EXP 118
92282: PUSH
92283: LD_INT 1
92285: ST_TO_ADDR
// if p3 = 8 then
92286: LD_VAR 0 3
92290: PUSH
92291: LD_INT 8
92293: EQUAL
92294: IFFALSE 92304
// sBunker := true ;
92296: LD_ADDR_EXP 119
92300: PUSH
92301: LD_INT 1
92303: ST_TO_ADDR
// if p3 = 9 then
92304: LD_VAR 0 3
92308: PUSH
92309: LD_INT 9
92311: EQUAL
92312: IFFALSE 92322
// sHack := true ;
92314: LD_ADDR_EXP 120
92318: PUSH
92319: LD_INT 1
92321: ST_TO_ADDR
// if p3 = 10 then
92322: LD_VAR 0 3
92326: PUSH
92327: LD_INT 10
92329: EQUAL
92330: IFFALSE 92340
// sFire := true ;
92332: LD_ADDR_EXP 121
92336: PUSH
92337: LD_INT 1
92339: ST_TO_ADDR
// if p3 = 11 then
92340: LD_VAR 0 3
92344: PUSH
92345: LD_INT 11
92347: EQUAL
92348: IFFALSE 92358
// sRefresh := true ;
92350: LD_ADDR_EXP 122
92354: PUSH
92355: LD_INT 1
92357: ST_TO_ADDR
// if p3 = 12 then
92358: LD_VAR 0 3
92362: PUSH
92363: LD_INT 12
92365: EQUAL
92366: IFFALSE 92376
// sExp := true ;
92368: LD_ADDR_EXP 123
92372: PUSH
92373: LD_INT 1
92375: ST_TO_ADDR
// if p3 = 13 then
92376: LD_VAR 0 3
92380: PUSH
92381: LD_INT 13
92383: EQUAL
92384: IFFALSE 92394
// sDepot := true ;
92386: LD_ADDR_EXP 124
92390: PUSH
92391: LD_INT 1
92393: ST_TO_ADDR
// if p3 = 14 then
92394: LD_VAR 0 3
92398: PUSH
92399: LD_INT 14
92401: EQUAL
92402: IFFALSE 92412
// sFlag := true ;
92404: LD_ADDR_EXP 125
92408: PUSH
92409: LD_INT 1
92411: ST_TO_ADDR
// if p3 = 15 then
92412: LD_VAR 0 3
92416: PUSH
92417: LD_INT 15
92419: EQUAL
92420: IFFALSE 92430
// sKamikadze := true ;
92422: LD_ADDR_EXP 133
92426: PUSH
92427: LD_INT 1
92429: ST_TO_ADDR
// if p3 = 16 then
92430: LD_VAR 0 3
92434: PUSH
92435: LD_INT 16
92437: EQUAL
92438: IFFALSE 92448
// sTroll := true ;
92440: LD_ADDR_EXP 134
92444: PUSH
92445: LD_INT 1
92447: ST_TO_ADDR
// if p3 = 17 then
92448: LD_VAR 0 3
92452: PUSH
92453: LD_INT 17
92455: EQUAL
92456: IFFALSE 92466
// sSlow := true ;
92458: LD_ADDR_EXP 135
92462: PUSH
92463: LD_INT 1
92465: ST_TO_ADDR
// if p3 = 18 then
92466: LD_VAR 0 3
92470: PUSH
92471: LD_INT 18
92473: EQUAL
92474: IFFALSE 92484
// sLack := true ;
92476: LD_ADDR_EXP 136
92480: PUSH
92481: LD_INT 1
92483: ST_TO_ADDR
// if p3 = 19 then
92484: LD_VAR 0 3
92488: PUSH
92489: LD_INT 19
92491: EQUAL
92492: IFFALSE 92502
// sTank := true ;
92494: LD_ADDR_EXP 138
92498: PUSH
92499: LD_INT 1
92501: ST_TO_ADDR
// if p3 = 20 then
92502: LD_VAR 0 3
92506: PUSH
92507: LD_INT 20
92509: EQUAL
92510: IFFALSE 92520
// sRemote := true ;
92512: LD_ADDR_EXP 139
92516: PUSH
92517: LD_INT 1
92519: ST_TO_ADDR
// if p3 = 21 then
92520: LD_VAR 0 3
92524: PUSH
92525: LD_INT 21
92527: EQUAL
92528: IFFALSE 92538
// sPowell := true ;
92530: LD_ADDR_EXP 140
92534: PUSH
92535: LD_INT 1
92537: ST_TO_ADDR
// if p3 = 22 then
92538: LD_VAR 0 3
92542: PUSH
92543: LD_INT 22
92545: EQUAL
92546: IFFALSE 92556
// sTeleport := true ;
92548: LD_ADDR_EXP 143
92552: PUSH
92553: LD_INT 1
92555: ST_TO_ADDR
// if p3 = 23 then
92556: LD_VAR 0 3
92560: PUSH
92561: LD_INT 23
92563: EQUAL
92564: IFFALSE 92574
// sOilTower := true ;
92566: LD_ADDR_EXP 145
92570: PUSH
92571: LD_INT 1
92573: ST_TO_ADDR
// if p3 = 24 then
92574: LD_VAR 0 3
92578: PUSH
92579: LD_INT 24
92581: EQUAL
92582: IFFALSE 92592
// sShovel := true ;
92584: LD_ADDR_EXP 146
92588: PUSH
92589: LD_INT 1
92591: ST_TO_ADDR
// if p3 = 25 then
92592: LD_VAR 0 3
92596: PUSH
92597: LD_INT 25
92599: EQUAL
92600: IFFALSE 92610
// sSheik := true ;
92602: LD_ADDR_EXP 147
92606: PUSH
92607: LD_INT 1
92609: ST_TO_ADDR
// if p3 = 26 then
92610: LD_VAR 0 3
92614: PUSH
92615: LD_INT 26
92617: EQUAL
92618: IFFALSE 92628
// sEarthquake := true ;
92620: LD_ADDR_EXP 149
92624: PUSH
92625: LD_INT 1
92627: ST_TO_ADDR
// if p3 = 27 then
92628: LD_VAR 0 3
92632: PUSH
92633: LD_INT 27
92635: EQUAL
92636: IFFALSE 92646
// sAI := true ;
92638: LD_ADDR_EXP 150
92642: PUSH
92643: LD_INT 1
92645: ST_TO_ADDR
// if p3 = 28 then
92646: LD_VAR 0 3
92650: PUSH
92651: LD_INT 28
92653: EQUAL
92654: IFFALSE 92664
// sCargo := true ;
92656: LD_ADDR_EXP 153
92660: PUSH
92661: LD_INT 1
92663: ST_TO_ADDR
// if p3 = 29 then
92664: LD_VAR 0 3
92668: PUSH
92669: LD_INT 29
92671: EQUAL
92672: IFFALSE 92682
// sDLaser := true ;
92674: LD_ADDR_EXP 154
92678: PUSH
92679: LD_INT 1
92681: ST_TO_ADDR
// if p3 = 30 then
92682: LD_VAR 0 3
92686: PUSH
92687: LD_INT 30
92689: EQUAL
92690: IFFALSE 92700
// sExchange := true ;
92692: LD_ADDR_EXP 155
92696: PUSH
92697: LD_INT 1
92699: ST_TO_ADDR
// if p3 = 31 then
92700: LD_VAR 0 3
92704: PUSH
92705: LD_INT 31
92707: EQUAL
92708: IFFALSE 92718
// sFac := true ;
92710: LD_ADDR_EXP 156
92714: PUSH
92715: LD_INT 1
92717: ST_TO_ADDR
// if p3 = 32 then
92718: LD_VAR 0 3
92722: PUSH
92723: LD_INT 32
92725: EQUAL
92726: IFFALSE 92736
// sPower := true ;
92728: LD_ADDR_EXP 157
92732: PUSH
92733: LD_INT 1
92735: ST_TO_ADDR
// if p3 = 33 then
92736: LD_VAR 0 3
92740: PUSH
92741: LD_INT 33
92743: EQUAL
92744: IFFALSE 92754
// sRandom := true ;
92746: LD_ADDR_EXP 158
92750: PUSH
92751: LD_INT 1
92753: ST_TO_ADDR
// if p3 = 34 then
92754: LD_VAR 0 3
92758: PUSH
92759: LD_INT 34
92761: EQUAL
92762: IFFALSE 92772
// sShield := true ;
92764: LD_ADDR_EXP 159
92768: PUSH
92769: LD_INT 1
92771: ST_TO_ADDR
// if p3 = 35 then
92772: LD_VAR 0 3
92776: PUSH
92777: LD_INT 35
92779: EQUAL
92780: IFFALSE 92790
// sTime := true ;
92782: LD_ADDR_EXP 160
92786: PUSH
92787: LD_INT 1
92789: ST_TO_ADDR
// if p3 = 36 then
92790: LD_VAR 0 3
92794: PUSH
92795: LD_INT 36
92797: EQUAL
92798: IFFALSE 92808
// sTools := true ;
92800: LD_ADDR_EXP 161
92804: PUSH
92805: LD_INT 1
92807: ST_TO_ADDR
// if p3 = 101 then
92808: LD_VAR 0 3
92812: PUSH
92813: LD_INT 101
92815: EQUAL
92816: IFFALSE 92826
// sSold := true ;
92818: LD_ADDR_EXP 126
92822: PUSH
92823: LD_INT 1
92825: ST_TO_ADDR
// if p3 = 102 then
92826: LD_VAR 0 3
92830: PUSH
92831: LD_INT 102
92833: EQUAL
92834: IFFALSE 92844
// sDiff := true ;
92836: LD_ADDR_EXP 127
92840: PUSH
92841: LD_INT 1
92843: ST_TO_ADDR
// if p3 = 103 then
92844: LD_VAR 0 3
92848: PUSH
92849: LD_INT 103
92851: EQUAL
92852: IFFALSE 92862
// sFog := true ;
92854: LD_ADDR_EXP 130
92858: PUSH
92859: LD_INT 1
92861: ST_TO_ADDR
// if p3 = 104 then
92862: LD_VAR 0 3
92866: PUSH
92867: LD_INT 104
92869: EQUAL
92870: IFFALSE 92880
// sReset := true ;
92872: LD_ADDR_EXP 131
92876: PUSH
92877: LD_INT 1
92879: ST_TO_ADDR
// if p3 = 105 then
92880: LD_VAR 0 3
92884: PUSH
92885: LD_INT 105
92887: EQUAL
92888: IFFALSE 92898
// sSun := true ;
92890: LD_ADDR_EXP 132
92894: PUSH
92895: LD_INT 1
92897: ST_TO_ADDR
// if p3 = 106 then
92898: LD_VAR 0 3
92902: PUSH
92903: LD_INT 106
92905: EQUAL
92906: IFFALSE 92916
// sTiger := true ;
92908: LD_ADDR_EXP 128
92912: PUSH
92913: LD_INT 1
92915: ST_TO_ADDR
// if p3 = 107 then
92916: LD_VAR 0 3
92920: PUSH
92921: LD_INT 107
92923: EQUAL
92924: IFFALSE 92934
// sBomb := true ;
92926: LD_ADDR_EXP 129
92930: PUSH
92931: LD_INT 1
92933: ST_TO_ADDR
// if p3 = 108 then
92934: LD_VAR 0 3
92938: PUSH
92939: LD_INT 108
92941: EQUAL
92942: IFFALSE 92952
// sWound := true ;
92944: LD_ADDR_EXP 137
92948: PUSH
92949: LD_INT 1
92951: ST_TO_ADDR
// if p3 = 109 then
92952: LD_VAR 0 3
92956: PUSH
92957: LD_INT 109
92959: EQUAL
92960: IFFALSE 92970
// sBetray := true ;
92962: LD_ADDR_EXP 141
92966: PUSH
92967: LD_INT 1
92969: ST_TO_ADDR
// if p3 = 110 then
92970: LD_VAR 0 3
92974: PUSH
92975: LD_INT 110
92977: EQUAL
92978: IFFALSE 92988
// sContamin := true ;
92980: LD_ADDR_EXP 142
92984: PUSH
92985: LD_INT 1
92987: ST_TO_ADDR
// if p3 = 111 then
92988: LD_VAR 0 3
92992: PUSH
92993: LD_INT 111
92995: EQUAL
92996: IFFALSE 93006
// sOil := true ;
92998: LD_ADDR_EXP 144
93002: PUSH
93003: LD_INT 1
93005: ST_TO_ADDR
// if p3 = 112 then
93006: LD_VAR 0 3
93010: PUSH
93011: LD_INT 112
93013: EQUAL
93014: IFFALSE 93024
// sStu := true ;
93016: LD_ADDR_EXP 148
93020: PUSH
93021: LD_INT 1
93023: ST_TO_ADDR
// if p3 = 113 then
93024: LD_VAR 0 3
93028: PUSH
93029: LD_INT 113
93031: EQUAL
93032: IFFALSE 93042
// sBazooka := true ;
93034: LD_ADDR_EXP 151
93038: PUSH
93039: LD_INT 1
93041: ST_TO_ADDR
// if p3 = 114 then
93042: LD_VAR 0 3
93046: PUSH
93047: LD_INT 114
93049: EQUAL
93050: IFFALSE 93060
// sMortar := true ;
93052: LD_ADDR_EXP 152
93056: PUSH
93057: LD_INT 1
93059: ST_TO_ADDR
// if p3 = 115 then
93060: LD_VAR 0 3
93064: PUSH
93065: LD_INT 115
93067: EQUAL
93068: IFFALSE 93078
// sRanger := true ;
93070: LD_ADDR_EXP 162
93074: PUSH
93075: LD_INT 1
93077: ST_TO_ADDR
// if p3 = 116 then
93078: LD_VAR 0 3
93082: PUSH
93083: LD_INT 116
93085: EQUAL
93086: IFFALSE 93096
// sComputer := true ;
93088: LD_ADDR_EXP 163
93092: PUSH
93093: LD_INT 1
93095: ST_TO_ADDR
// if p3 = 117 then
93096: LD_VAR 0 3
93100: PUSH
93101: LD_INT 117
93103: EQUAL
93104: IFFALSE 93114
// s30 := true ;
93106: LD_ADDR_EXP 164
93110: PUSH
93111: LD_INT 1
93113: ST_TO_ADDR
// if p3 = 118 then
93114: LD_VAR 0 3
93118: PUSH
93119: LD_INT 118
93121: EQUAL
93122: IFFALSE 93132
// s60 := true ;
93124: LD_ADDR_EXP 165
93128: PUSH
93129: LD_INT 1
93131: ST_TO_ADDR
// end ; if p2 = hack_mode then
93132: LD_VAR 0 2
93136: PUSH
93137: LD_INT 101
93139: EQUAL
93140: IFFALSE 93268
// begin case p3 of 1 :
93142: LD_VAR 0 3
93146: PUSH
93147: LD_INT 1
93149: DOUBLE
93150: EQUAL
93151: IFTRUE 93155
93153: GO 93162
93155: POP
// hHackUnlimitedResources ; 2 :
93156: CALL 105531 0 0
93160: GO 93268
93162: LD_INT 2
93164: DOUBLE
93165: EQUAL
93166: IFTRUE 93170
93168: GO 93177
93170: POP
// hHackSetLevel10 ; 3 :
93171: CALL 105664 0 0
93175: GO 93268
93177: LD_INT 3
93179: DOUBLE
93180: EQUAL
93181: IFTRUE 93185
93183: GO 93192
93185: POP
// hHackSetLevel10YourUnits ; 4 :
93186: CALL 105749 0 0
93190: GO 93268
93192: LD_INT 4
93194: DOUBLE
93195: EQUAL
93196: IFTRUE 93200
93198: GO 93207
93200: POP
// hHackInvincible ; 5 :
93201: CALL 106197 0 0
93205: GO 93268
93207: LD_INT 5
93209: DOUBLE
93210: EQUAL
93211: IFTRUE 93215
93213: GO 93222
93215: POP
// hHackInvisible ; 6 :
93216: CALL 106308 0 0
93220: GO 93268
93222: LD_INT 6
93224: DOUBLE
93225: EQUAL
93226: IFTRUE 93230
93228: GO 93237
93230: POP
// hHackChangeYourSide ; 7 :
93231: CALL 106365 0 0
93235: GO 93268
93237: LD_INT 7
93239: DOUBLE
93240: EQUAL
93241: IFTRUE 93245
93243: GO 93252
93245: POP
// hHackChangeUnitSide ; 8 :
93246: CALL 106407 0 0
93250: GO 93268
93252: LD_INT 8
93254: DOUBLE
93255: EQUAL
93256: IFTRUE 93260
93258: GO 93267
93260: POP
// hHackFog ; end ;
93261: CALL 106508 0 0
93265: GO 93268
93267: POP
// end ; if p2 = game_save_mode then
93268: LD_VAR 0 2
93272: PUSH
93273: LD_INT 102
93275: EQUAL
93276: IFFALSE 93333
// begin if p3 = 1 then
93278: LD_VAR 0 3
93282: PUSH
93283: LD_INT 1
93285: EQUAL
93286: IFFALSE 93298
// globalGameSaveCounter := p4 ;
93288: LD_ADDR_EXP 108
93292: PUSH
93293: LD_VAR 0 4
93297: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93298: LD_VAR 0 3
93302: PUSH
93303: LD_INT 2
93305: EQUAL
93306: IFFALSE 93314
93308: PUSH
93309: LD_EXP 108
93313: AND
93314: IFFALSE 93333
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93316: LD_STRING setGameSaveCounter(
93318: PUSH
93319: LD_EXP 108
93323: STR
93324: PUSH
93325: LD_STRING )
93327: STR
93328: PPUSH
93329: CALL_OW 559
// end ; end ;
93333: LD_VAR 0 7
93337: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93338: LD_INT 0
93340: PPUSH
// streamModeActive := false ;
93341: LD_ADDR_EXP 109
93345: PUSH
93346: LD_INT 0
93348: ST_TO_ADDR
// normalCounter := 36 ;
93349: LD_ADDR_EXP 110
93353: PUSH
93354: LD_INT 36
93356: ST_TO_ADDR
// hardcoreCounter := 18 ;
93357: LD_ADDR_EXP 111
93361: PUSH
93362: LD_INT 18
93364: ST_TO_ADDR
// sRocket := false ;
93365: LD_ADDR_EXP 114
93369: PUSH
93370: LD_INT 0
93372: ST_TO_ADDR
// sSpeed := false ;
93373: LD_ADDR_EXP 113
93377: PUSH
93378: LD_INT 0
93380: ST_TO_ADDR
// sEngine := false ;
93381: LD_ADDR_EXP 115
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// sSpec := false ;
93389: LD_ADDR_EXP 112
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// sLevel := false ;
93397: LD_ADDR_EXP 116
93401: PUSH
93402: LD_INT 0
93404: ST_TO_ADDR
// sArmoury := false ;
93405: LD_ADDR_EXP 117
93409: PUSH
93410: LD_INT 0
93412: ST_TO_ADDR
// sRadar := false ;
93413: LD_ADDR_EXP 118
93417: PUSH
93418: LD_INT 0
93420: ST_TO_ADDR
// sBunker := false ;
93421: LD_ADDR_EXP 119
93425: PUSH
93426: LD_INT 0
93428: ST_TO_ADDR
// sHack := false ;
93429: LD_ADDR_EXP 120
93433: PUSH
93434: LD_INT 0
93436: ST_TO_ADDR
// sFire := false ;
93437: LD_ADDR_EXP 121
93441: PUSH
93442: LD_INT 0
93444: ST_TO_ADDR
// sRefresh := false ;
93445: LD_ADDR_EXP 122
93449: PUSH
93450: LD_INT 0
93452: ST_TO_ADDR
// sExp := false ;
93453: LD_ADDR_EXP 123
93457: PUSH
93458: LD_INT 0
93460: ST_TO_ADDR
// sDepot := false ;
93461: LD_ADDR_EXP 124
93465: PUSH
93466: LD_INT 0
93468: ST_TO_ADDR
// sFlag := false ;
93469: LD_ADDR_EXP 125
93473: PUSH
93474: LD_INT 0
93476: ST_TO_ADDR
// sKamikadze := false ;
93477: LD_ADDR_EXP 133
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// sTroll := false ;
93485: LD_ADDR_EXP 134
93489: PUSH
93490: LD_INT 0
93492: ST_TO_ADDR
// sSlow := false ;
93493: LD_ADDR_EXP 135
93497: PUSH
93498: LD_INT 0
93500: ST_TO_ADDR
// sLack := false ;
93501: LD_ADDR_EXP 136
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// sTank := false ;
93509: LD_ADDR_EXP 138
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// sRemote := false ;
93517: LD_ADDR_EXP 139
93521: PUSH
93522: LD_INT 0
93524: ST_TO_ADDR
// sPowell := false ;
93525: LD_ADDR_EXP 140
93529: PUSH
93530: LD_INT 0
93532: ST_TO_ADDR
// sTeleport := false ;
93533: LD_ADDR_EXP 143
93537: PUSH
93538: LD_INT 0
93540: ST_TO_ADDR
// sOilTower := false ;
93541: LD_ADDR_EXP 145
93545: PUSH
93546: LD_INT 0
93548: ST_TO_ADDR
// sShovel := false ;
93549: LD_ADDR_EXP 146
93553: PUSH
93554: LD_INT 0
93556: ST_TO_ADDR
// sSheik := false ;
93557: LD_ADDR_EXP 147
93561: PUSH
93562: LD_INT 0
93564: ST_TO_ADDR
// sEarthquake := false ;
93565: LD_ADDR_EXP 149
93569: PUSH
93570: LD_INT 0
93572: ST_TO_ADDR
// sAI := false ;
93573: LD_ADDR_EXP 150
93577: PUSH
93578: LD_INT 0
93580: ST_TO_ADDR
// sCargo := false ;
93581: LD_ADDR_EXP 153
93585: PUSH
93586: LD_INT 0
93588: ST_TO_ADDR
// sDLaser := false ;
93589: LD_ADDR_EXP 154
93593: PUSH
93594: LD_INT 0
93596: ST_TO_ADDR
// sExchange := false ;
93597: LD_ADDR_EXP 155
93601: PUSH
93602: LD_INT 0
93604: ST_TO_ADDR
// sFac := false ;
93605: LD_ADDR_EXP 156
93609: PUSH
93610: LD_INT 0
93612: ST_TO_ADDR
// sPower := false ;
93613: LD_ADDR_EXP 157
93617: PUSH
93618: LD_INT 0
93620: ST_TO_ADDR
// sRandom := false ;
93621: LD_ADDR_EXP 158
93625: PUSH
93626: LD_INT 0
93628: ST_TO_ADDR
// sShield := false ;
93629: LD_ADDR_EXP 159
93633: PUSH
93634: LD_INT 0
93636: ST_TO_ADDR
// sTime := false ;
93637: LD_ADDR_EXP 160
93641: PUSH
93642: LD_INT 0
93644: ST_TO_ADDR
// sTools := false ;
93645: LD_ADDR_EXP 161
93649: PUSH
93650: LD_INT 0
93652: ST_TO_ADDR
// sSold := false ;
93653: LD_ADDR_EXP 126
93657: PUSH
93658: LD_INT 0
93660: ST_TO_ADDR
// sDiff := false ;
93661: LD_ADDR_EXP 127
93665: PUSH
93666: LD_INT 0
93668: ST_TO_ADDR
// sFog := false ;
93669: LD_ADDR_EXP 130
93673: PUSH
93674: LD_INT 0
93676: ST_TO_ADDR
// sReset := false ;
93677: LD_ADDR_EXP 131
93681: PUSH
93682: LD_INT 0
93684: ST_TO_ADDR
// sSun := false ;
93685: LD_ADDR_EXP 132
93689: PUSH
93690: LD_INT 0
93692: ST_TO_ADDR
// sTiger := false ;
93693: LD_ADDR_EXP 128
93697: PUSH
93698: LD_INT 0
93700: ST_TO_ADDR
// sBomb := false ;
93701: LD_ADDR_EXP 129
93705: PUSH
93706: LD_INT 0
93708: ST_TO_ADDR
// sWound := false ;
93709: LD_ADDR_EXP 137
93713: PUSH
93714: LD_INT 0
93716: ST_TO_ADDR
// sBetray := false ;
93717: LD_ADDR_EXP 141
93721: PUSH
93722: LD_INT 0
93724: ST_TO_ADDR
// sContamin := false ;
93725: LD_ADDR_EXP 142
93729: PUSH
93730: LD_INT 0
93732: ST_TO_ADDR
// sOil := false ;
93733: LD_ADDR_EXP 144
93737: PUSH
93738: LD_INT 0
93740: ST_TO_ADDR
// sStu := false ;
93741: LD_ADDR_EXP 148
93745: PUSH
93746: LD_INT 0
93748: ST_TO_ADDR
// sBazooka := false ;
93749: LD_ADDR_EXP 151
93753: PUSH
93754: LD_INT 0
93756: ST_TO_ADDR
// sMortar := false ;
93757: LD_ADDR_EXP 152
93761: PUSH
93762: LD_INT 0
93764: ST_TO_ADDR
// sRanger := false ;
93765: LD_ADDR_EXP 162
93769: PUSH
93770: LD_INT 0
93772: ST_TO_ADDR
// sComputer := false ;
93773: LD_ADDR_EXP 163
93777: PUSH
93778: LD_INT 0
93780: ST_TO_ADDR
// s30 := false ;
93781: LD_ADDR_EXP 164
93785: PUSH
93786: LD_INT 0
93788: ST_TO_ADDR
// s60 := false ;
93789: LD_ADDR_EXP 165
93793: PUSH
93794: LD_INT 0
93796: ST_TO_ADDR
// end ;
93797: LD_VAR 0 1
93801: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93802: LD_INT 0
93804: PPUSH
93805: PPUSH
93806: PPUSH
93807: PPUSH
93808: PPUSH
93809: PPUSH
93810: PPUSH
// result := [ ] ;
93811: LD_ADDR_VAR 0 2
93815: PUSH
93816: EMPTY
93817: ST_TO_ADDR
// if campaign_id = 1 then
93818: LD_OWVAR 69
93822: PUSH
93823: LD_INT 1
93825: EQUAL
93826: IFFALSE 96992
// begin case mission_number of 1 :
93828: LD_OWVAR 70
93832: PUSH
93833: LD_INT 1
93835: DOUBLE
93836: EQUAL
93837: IFTRUE 93841
93839: GO 93917
93841: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93842: LD_ADDR_VAR 0 2
93846: PUSH
93847: LD_INT 2
93849: PUSH
93850: LD_INT 4
93852: PUSH
93853: LD_INT 11
93855: PUSH
93856: LD_INT 12
93858: PUSH
93859: LD_INT 15
93861: PUSH
93862: LD_INT 16
93864: PUSH
93865: LD_INT 22
93867: PUSH
93868: LD_INT 23
93870: PUSH
93871: LD_INT 26
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 101
93887: PUSH
93888: LD_INT 102
93890: PUSH
93891: LD_INT 106
93893: PUSH
93894: LD_INT 116
93896: PUSH
93897: LD_INT 117
93899: PUSH
93900: LD_INT 118
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: ST_TO_ADDR
93915: GO 96990
93917: LD_INT 2
93919: DOUBLE
93920: EQUAL
93921: IFTRUE 93925
93923: GO 94009
93925: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93926: LD_ADDR_VAR 0 2
93930: PUSH
93931: LD_INT 2
93933: PUSH
93934: LD_INT 4
93936: PUSH
93937: LD_INT 11
93939: PUSH
93940: LD_INT 12
93942: PUSH
93943: LD_INT 15
93945: PUSH
93946: LD_INT 16
93948: PUSH
93949: LD_INT 22
93951: PUSH
93952: LD_INT 23
93954: PUSH
93955: LD_INT 26
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: PUSH
93969: LD_INT 101
93971: PUSH
93972: LD_INT 102
93974: PUSH
93975: LD_INT 105
93977: PUSH
93978: LD_INT 106
93980: PUSH
93981: LD_INT 108
93983: PUSH
93984: LD_INT 116
93986: PUSH
93987: LD_INT 117
93989: PUSH
93990: LD_INT 118
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: ST_TO_ADDR
94007: GO 96990
94009: LD_INT 3
94011: DOUBLE
94012: EQUAL
94013: IFTRUE 94017
94015: GO 94105
94017: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94018: LD_ADDR_VAR 0 2
94022: PUSH
94023: LD_INT 2
94025: PUSH
94026: LD_INT 4
94028: PUSH
94029: LD_INT 5
94031: PUSH
94032: LD_INT 11
94034: PUSH
94035: LD_INT 12
94037: PUSH
94038: LD_INT 15
94040: PUSH
94041: LD_INT 16
94043: PUSH
94044: LD_INT 22
94046: PUSH
94047: LD_INT 26
94049: PUSH
94050: LD_INT 36
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 101
94067: PUSH
94068: LD_INT 102
94070: PUSH
94071: LD_INT 105
94073: PUSH
94074: LD_INT 106
94076: PUSH
94077: LD_INT 108
94079: PUSH
94080: LD_INT 116
94082: PUSH
94083: LD_INT 117
94085: PUSH
94086: LD_INT 118
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: ST_TO_ADDR
94103: GO 96990
94105: LD_INT 4
94107: DOUBLE
94108: EQUAL
94109: IFTRUE 94113
94111: GO 94209
94113: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94114: LD_ADDR_VAR 0 2
94118: PUSH
94119: LD_INT 2
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: LD_INT 5
94127: PUSH
94128: LD_INT 8
94130: PUSH
94131: LD_INT 11
94133: PUSH
94134: LD_INT 12
94136: PUSH
94137: LD_INT 15
94139: PUSH
94140: LD_INT 16
94142: PUSH
94143: LD_INT 22
94145: PUSH
94146: LD_INT 23
94148: PUSH
94149: LD_INT 26
94151: PUSH
94152: LD_INT 36
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 101
94171: PUSH
94172: LD_INT 102
94174: PUSH
94175: LD_INT 105
94177: PUSH
94178: LD_INT 106
94180: PUSH
94181: LD_INT 108
94183: PUSH
94184: LD_INT 116
94186: PUSH
94187: LD_INT 117
94189: PUSH
94190: LD_INT 118
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: ST_TO_ADDR
94207: GO 96990
94209: LD_INT 5
94211: DOUBLE
94212: EQUAL
94213: IFTRUE 94217
94215: GO 94329
94217: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94218: LD_ADDR_VAR 0 2
94222: PUSH
94223: LD_INT 2
94225: PUSH
94226: LD_INT 4
94228: PUSH
94229: LD_INT 5
94231: PUSH
94232: LD_INT 6
94234: PUSH
94235: LD_INT 8
94237: PUSH
94238: LD_INT 11
94240: PUSH
94241: LD_INT 12
94243: PUSH
94244: LD_INT 15
94246: PUSH
94247: LD_INT 16
94249: PUSH
94250: LD_INT 22
94252: PUSH
94253: LD_INT 23
94255: PUSH
94256: LD_INT 25
94258: PUSH
94259: LD_INT 26
94261: PUSH
94262: LD_INT 36
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 101
94283: PUSH
94284: LD_INT 102
94286: PUSH
94287: LD_INT 105
94289: PUSH
94290: LD_INT 106
94292: PUSH
94293: LD_INT 108
94295: PUSH
94296: LD_INT 109
94298: PUSH
94299: LD_INT 112
94301: PUSH
94302: LD_INT 116
94304: PUSH
94305: LD_INT 117
94307: PUSH
94308: LD_INT 118
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: ST_TO_ADDR
94327: GO 96990
94329: LD_INT 6
94331: DOUBLE
94332: EQUAL
94333: IFTRUE 94337
94335: GO 94469
94337: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94338: LD_ADDR_VAR 0 2
94342: PUSH
94343: LD_INT 2
94345: PUSH
94346: LD_INT 4
94348: PUSH
94349: LD_INT 5
94351: PUSH
94352: LD_INT 6
94354: PUSH
94355: LD_INT 8
94357: PUSH
94358: LD_INT 11
94360: PUSH
94361: LD_INT 12
94363: PUSH
94364: LD_INT 15
94366: PUSH
94367: LD_INT 16
94369: PUSH
94370: LD_INT 20
94372: PUSH
94373: LD_INT 21
94375: PUSH
94376: LD_INT 22
94378: PUSH
94379: LD_INT 23
94381: PUSH
94382: LD_INT 25
94384: PUSH
94385: LD_INT 26
94387: PUSH
94388: LD_INT 30
94390: PUSH
94391: LD_INT 31
94393: PUSH
94394: LD_INT 32
94396: PUSH
94397: LD_INT 36
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 101
94423: PUSH
94424: LD_INT 102
94426: PUSH
94427: LD_INT 105
94429: PUSH
94430: LD_INT 106
94432: PUSH
94433: LD_INT 108
94435: PUSH
94436: LD_INT 109
94438: PUSH
94439: LD_INT 112
94441: PUSH
94442: LD_INT 116
94444: PUSH
94445: LD_INT 117
94447: PUSH
94448: LD_INT 118
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: ST_TO_ADDR
94467: GO 96990
94469: LD_INT 7
94471: DOUBLE
94472: EQUAL
94473: IFTRUE 94477
94475: GO 94589
94477: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94478: LD_ADDR_VAR 0 2
94482: PUSH
94483: LD_INT 2
94485: PUSH
94486: LD_INT 4
94488: PUSH
94489: LD_INT 5
94491: PUSH
94492: LD_INT 7
94494: PUSH
94495: LD_INT 11
94497: PUSH
94498: LD_INT 12
94500: PUSH
94501: LD_INT 15
94503: PUSH
94504: LD_INT 16
94506: PUSH
94507: LD_INT 20
94509: PUSH
94510: LD_INT 21
94512: PUSH
94513: LD_INT 22
94515: PUSH
94516: LD_INT 23
94518: PUSH
94519: LD_INT 25
94521: PUSH
94522: LD_INT 26
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 101
94543: PUSH
94544: LD_INT 102
94546: PUSH
94547: LD_INT 103
94549: PUSH
94550: LD_INT 105
94552: PUSH
94553: LD_INT 106
94555: PUSH
94556: LD_INT 108
94558: PUSH
94559: LD_INT 112
94561: PUSH
94562: LD_INT 116
94564: PUSH
94565: LD_INT 117
94567: PUSH
94568: LD_INT 118
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: ST_TO_ADDR
94587: GO 96990
94589: LD_INT 8
94591: DOUBLE
94592: EQUAL
94593: IFTRUE 94597
94595: GO 94737
94597: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94598: LD_ADDR_VAR 0 2
94602: PUSH
94603: LD_INT 2
94605: PUSH
94606: LD_INT 4
94608: PUSH
94609: LD_INT 5
94611: PUSH
94612: LD_INT 6
94614: PUSH
94615: LD_INT 7
94617: PUSH
94618: LD_INT 8
94620: PUSH
94621: LD_INT 11
94623: PUSH
94624: LD_INT 12
94626: PUSH
94627: LD_INT 15
94629: PUSH
94630: LD_INT 16
94632: PUSH
94633: LD_INT 20
94635: PUSH
94636: LD_INT 21
94638: PUSH
94639: LD_INT 22
94641: PUSH
94642: LD_INT 23
94644: PUSH
94645: LD_INT 25
94647: PUSH
94648: LD_INT 26
94650: PUSH
94651: LD_INT 30
94653: PUSH
94654: LD_INT 31
94656: PUSH
94657: LD_INT 32
94659: PUSH
94660: LD_INT 36
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 101
94687: PUSH
94688: LD_INT 102
94690: PUSH
94691: LD_INT 103
94693: PUSH
94694: LD_INT 105
94696: PUSH
94697: LD_INT 106
94699: PUSH
94700: LD_INT 108
94702: PUSH
94703: LD_INT 109
94705: PUSH
94706: LD_INT 112
94708: PUSH
94709: LD_INT 116
94711: PUSH
94712: LD_INT 117
94714: PUSH
94715: LD_INT 118
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: ST_TO_ADDR
94735: GO 96990
94737: LD_INT 9
94739: DOUBLE
94740: EQUAL
94741: IFTRUE 94745
94743: GO 94893
94745: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94746: LD_ADDR_VAR 0 2
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: LD_INT 4
94756: PUSH
94757: LD_INT 5
94759: PUSH
94760: LD_INT 6
94762: PUSH
94763: LD_INT 7
94765: PUSH
94766: LD_INT 8
94768: PUSH
94769: LD_INT 11
94771: PUSH
94772: LD_INT 12
94774: PUSH
94775: LD_INT 15
94777: PUSH
94778: LD_INT 16
94780: PUSH
94781: LD_INT 20
94783: PUSH
94784: LD_INT 21
94786: PUSH
94787: LD_INT 22
94789: PUSH
94790: LD_INT 23
94792: PUSH
94793: LD_INT 25
94795: PUSH
94796: LD_INT 26
94798: PUSH
94799: LD_INT 28
94801: PUSH
94802: LD_INT 30
94804: PUSH
94805: LD_INT 31
94807: PUSH
94808: LD_INT 32
94810: PUSH
94811: LD_INT 36
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 101
94839: PUSH
94840: LD_INT 102
94842: PUSH
94843: LD_INT 103
94845: PUSH
94846: LD_INT 105
94848: PUSH
94849: LD_INT 106
94851: PUSH
94852: LD_INT 108
94854: PUSH
94855: LD_INT 109
94857: PUSH
94858: LD_INT 112
94860: PUSH
94861: LD_INT 114
94863: PUSH
94864: LD_INT 116
94866: PUSH
94867: LD_INT 117
94869: PUSH
94870: LD_INT 118
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: ST_TO_ADDR
94891: GO 96990
94893: LD_INT 10
94895: DOUBLE
94896: EQUAL
94897: IFTRUE 94901
94899: GO 95097
94901: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94902: LD_ADDR_VAR 0 2
94906: PUSH
94907: LD_INT 2
94909: PUSH
94910: LD_INT 4
94912: PUSH
94913: LD_INT 5
94915: PUSH
94916: LD_INT 6
94918: PUSH
94919: LD_INT 7
94921: PUSH
94922: LD_INT 8
94924: PUSH
94925: LD_INT 9
94927: PUSH
94928: LD_INT 10
94930: PUSH
94931: LD_INT 11
94933: PUSH
94934: LD_INT 12
94936: PUSH
94937: LD_INT 13
94939: PUSH
94940: LD_INT 14
94942: PUSH
94943: LD_INT 15
94945: PUSH
94946: LD_INT 16
94948: PUSH
94949: LD_INT 17
94951: PUSH
94952: LD_INT 18
94954: PUSH
94955: LD_INT 19
94957: PUSH
94958: LD_INT 20
94960: PUSH
94961: LD_INT 21
94963: PUSH
94964: LD_INT 22
94966: PUSH
94967: LD_INT 23
94969: PUSH
94970: LD_INT 24
94972: PUSH
94973: LD_INT 25
94975: PUSH
94976: LD_INT 26
94978: PUSH
94979: LD_INT 28
94981: PUSH
94982: LD_INT 30
94984: PUSH
94985: LD_INT 31
94987: PUSH
94988: LD_INT 32
94990: PUSH
94991: LD_INT 36
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 101
95027: PUSH
95028: LD_INT 102
95030: PUSH
95031: LD_INT 103
95033: PUSH
95034: LD_INT 104
95036: PUSH
95037: LD_INT 105
95039: PUSH
95040: LD_INT 106
95042: PUSH
95043: LD_INT 107
95045: PUSH
95046: LD_INT 108
95048: PUSH
95049: LD_INT 109
95051: PUSH
95052: LD_INT 110
95054: PUSH
95055: LD_INT 111
95057: PUSH
95058: LD_INT 112
95060: PUSH
95061: LD_INT 114
95063: PUSH
95064: LD_INT 116
95066: PUSH
95067: LD_INT 117
95069: PUSH
95070: LD_INT 118
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: ST_TO_ADDR
95095: GO 96990
95097: LD_INT 11
95099: DOUBLE
95100: EQUAL
95101: IFTRUE 95105
95103: GO 95309
95105: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95106: LD_ADDR_VAR 0 2
95110: PUSH
95111: LD_INT 2
95113: PUSH
95114: LD_INT 3
95116: PUSH
95117: LD_INT 4
95119: PUSH
95120: LD_INT 5
95122: PUSH
95123: LD_INT 6
95125: PUSH
95126: LD_INT 7
95128: PUSH
95129: LD_INT 8
95131: PUSH
95132: LD_INT 9
95134: PUSH
95135: LD_INT 10
95137: PUSH
95138: LD_INT 11
95140: PUSH
95141: LD_INT 12
95143: PUSH
95144: LD_INT 13
95146: PUSH
95147: LD_INT 14
95149: PUSH
95150: LD_INT 15
95152: PUSH
95153: LD_INT 16
95155: PUSH
95156: LD_INT 17
95158: PUSH
95159: LD_INT 18
95161: PUSH
95162: LD_INT 19
95164: PUSH
95165: LD_INT 20
95167: PUSH
95168: LD_INT 21
95170: PUSH
95171: LD_INT 22
95173: PUSH
95174: LD_INT 23
95176: PUSH
95177: LD_INT 24
95179: PUSH
95180: LD_INT 25
95182: PUSH
95183: LD_INT 26
95185: PUSH
95186: LD_INT 28
95188: PUSH
95189: LD_INT 30
95191: PUSH
95192: LD_INT 31
95194: PUSH
95195: LD_INT 32
95197: PUSH
95198: LD_INT 34
95200: PUSH
95201: LD_INT 36
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 101
95239: PUSH
95240: LD_INT 102
95242: PUSH
95243: LD_INT 103
95245: PUSH
95246: LD_INT 104
95248: PUSH
95249: LD_INT 105
95251: PUSH
95252: LD_INT 106
95254: PUSH
95255: LD_INT 107
95257: PUSH
95258: LD_INT 108
95260: PUSH
95261: LD_INT 109
95263: PUSH
95264: LD_INT 110
95266: PUSH
95267: LD_INT 111
95269: PUSH
95270: LD_INT 112
95272: PUSH
95273: LD_INT 114
95275: PUSH
95276: LD_INT 116
95278: PUSH
95279: LD_INT 117
95281: PUSH
95282: LD_INT 118
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: ST_TO_ADDR
95307: GO 96990
95309: LD_INT 12
95311: DOUBLE
95312: EQUAL
95313: IFTRUE 95317
95315: GO 95537
95317: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95318: LD_ADDR_VAR 0 2
95322: PUSH
95323: LD_INT 1
95325: PUSH
95326: LD_INT 2
95328: PUSH
95329: LD_INT 3
95331: PUSH
95332: LD_INT 4
95334: PUSH
95335: LD_INT 5
95337: PUSH
95338: LD_INT 6
95340: PUSH
95341: LD_INT 7
95343: PUSH
95344: LD_INT 8
95346: PUSH
95347: LD_INT 9
95349: PUSH
95350: LD_INT 10
95352: PUSH
95353: LD_INT 11
95355: PUSH
95356: LD_INT 12
95358: PUSH
95359: LD_INT 13
95361: PUSH
95362: LD_INT 14
95364: PUSH
95365: LD_INT 15
95367: PUSH
95368: LD_INT 16
95370: PUSH
95371: LD_INT 17
95373: PUSH
95374: LD_INT 18
95376: PUSH
95377: LD_INT 19
95379: PUSH
95380: LD_INT 20
95382: PUSH
95383: LD_INT 21
95385: PUSH
95386: LD_INT 22
95388: PUSH
95389: LD_INT 23
95391: PUSH
95392: LD_INT 24
95394: PUSH
95395: LD_INT 25
95397: PUSH
95398: LD_INT 26
95400: PUSH
95401: LD_INT 27
95403: PUSH
95404: LD_INT 28
95406: PUSH
95407: LD_INT 30
95409: PUSH
95410: LD_INT 31
95412: PUSH
95413: LD_INT 32
95415: PUSH
95416: LD_INT 33
95418: PUSH
95419: LD_INT 34
95421: PUSH
95422: LD_INT 36
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 101
95463: PUSH
95464: LD_INT 102
95466: PUSH
95467: LD_INT 103
95469: PUSH
95470: LD_INT 104
95472: PUSH
95473: LD_INT 105
95475: PUSH
95476: LD_INT 106
95478: PUSH
95479: LD_INT 107
95481: PUSH
95482: LD_INT 108
95484: PUSH
95485: LD_INT 109
95487: PUSH
95488: LD_INT 110
95490: PUSH
95491: LD_INT 111
95493: PUSH
95494: LD_INT 112
95496: PUSH
95497: LD_INT 113
95499: PUSH
95500: LD_INT 114
95502: PUSH
95503: LD_INT 116
95505: PUSH
95506: LD_INT 117
95508: PUSH
95509: LD_INT 118
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: ST_TO_ADDR
95535: GO 96990
95537: LD_INT 13
95539: DOUBLE
95540: EQUAL
95541: IFTRUE 95545
95543: GO 95753
95545: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95546: LD_ADDR_VAR 0 2
95550: PUSH
95551: LD_INT 1
95553: PUSH
95554: LD_INT 2
95556: PUSH
95557: LD_INT 3
95559: PUSH
95560: LD_INT 4
95562: PUSH
95563: LD_INT 5
95565: PUSH
95566: LD_INT 8
95568: PUSH
95569: LD_INT 9
95571: PUSH
95572: LD_INT 10
95574: PUSH
95575: LD_INT 11
95577: PUSH
95578: LD_INT 12
95580: PUSH
95581: LD_INT 14
95583: PUSH
95584: LD_INT 15
95586: PUSH
95587: LD_INT 16
95589: PUSH
95590: LD_INT 17
95592: PUSH
95593: LD_INT 18
95595: PUSH
95596: LD_INT 19
95598: PUSH
95599: LD_INT 20
95601: PUSH
95602: LD_INT 21
95604: PUSH
95605: LD_INT 22
95607: PUSH
95608: LD_INT 23
95610: PUSH
95611: LD_INT 24
95613: PUSH
95614: LD_INT 25
95616: PUSH
95617: LD_INT 26
95619: PUSH
95620: LD_INT 27
95622: PUSH
95623: LD_INT 28
95625: PUSH
95626: LD_INT 30
95628: PUSH
95629: LD_INT 31
95631: PUSH
95632: LD_INT 32
95634: PUSH
95635: LD_INT 33
95637: PUSH
95638: LD_INT 34
95640: PUSH
95641: LD_INT 36
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 101
95679: PUSH
95680: LD_INT 102
95682: PUSH
95683: LD_INT 103
95685: PUSH
95686: LD_INT 104
95688: PUSH
95689: LD_INT 105
95691: PUSH
95692: LD_INT 106
95694: PUSH
95695: LD_INT 107
95697: PUSH
95698: LD_INT 108
95700: PUSH
95701: LD_INT 109
95703: PUSH
95704: LD_INT 110
95706: PUSH
95707: LD_INT 111
95709: PUSH
95710: LD_INT 112
95712: PUSH
95713: LD_INT 113
95715: PUSH
95716: LD_INT 114
95718: PUSH
95719: LD_INT 116
95721: PUSH
95722: LD_INT 117
95724: PUSH
95725: LD_INT 118
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: ST_TO_ADDR
95751: GO 96990
95753: LD_INT 14
95755: DOUBLE
95756: EQUAL
95757: IFTRUE 95761
95759: GO 95985
95761: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95762: LD_ADDR_VAR 0 2
95766: PUSH
95767: LD_INT 1
95769: PUSH
95770: LD_INT 2
95772: PUSH
95773: LD_INT 3
95775: PUSH
95776: LD_INT 4
95778: PUSH
95779: LD_INT 5
95781: PUSH
95782: LD_INT 6
95784: PUSH
95785: LD_INT 7
95787: PUSH
95788: LD_INT 8
95790: PUSH
95791: LD_INT 9
95793: PUSH
95794: LD_INT 10
95796: PUSH
95797: LD_INT 11
95799: PUSH
95800: LD_INT 12
95802: PUSH
95803: LD_INT 13
95805: PUSH
95806: LD_INT 14
95808: PUSH
95809: LD_INT 15
95811: PUSH
95812: LD_INT 16
95814: PUSH
95815: LD_INT 17
95817: PUSH
95818: LD_INT 18
95820: PUSH
95821: LD_INT 19
95823: PUSH
95824: LD_INT 20
95826: PUSH
95827: LD_INT 21
95829: PUSH
95830: LD_INT 22
95832: PUSH
95833: LD_INT 23
95835: PUSH
95836: LD_INT 24
95838: PUSH
95839: LD_INT 25
95841: PUSH
95842: LD_INT 26
95844: PUSH
95845: LD_INT 27
95847: PUSH
95848: LD_INT 28
95850: PUSH
95851: LD_INT 29
95853: PUSH
95854: LD_INT 30
95856: PUSH
95857: LD_INT 31
95859: PUSH
95860: LD_INT 32
95862: PUSH
95863: LD_INT 33
95865: PUSH
95866: LD_INT 34
95868: PUSH
95869: LD_INT 36
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 101
95911: PUSH
95912: LD_INT 102
95914: PUSH
95915: LD_INT 103
95917: PUSH
95918: LD_INT 104
95920: PUSH
95921: LD_INT 105
95923: PUSH
95924: LD_INT 106
95926: PUSH
95927: LD_INT 107
95929: PUSH
95930: LD_INT 108
95932: PUSH
95933: LD_INT 109
95935: PUSH
95936: LD_INT 110
95938: PUSH
95939: LD_INT 111
95941: PUSH
95942: LD_INT 112
95944: PUSH
95945: LD_INT 113
95947: PUSH
95948: LD_INT 114
95950: PUSH
95951: LD_INT 116
95953: PUSH
95954: LD_INT 117
95956: PUSH
95957: LD_INT 118
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: ST_TO_ADDR
95983: GO 96990
95985: LD_INT 15
95987: DOUBLE
95988: EQUAL
95989: IFTRUE 95993
95991: GO 96217
95993: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95994: LD_ADDR_VAR 0 2
95998: PUSH
95999: LD_INT 1
96001: PUSH
96002: LD_INT 2
96004: PUSH
96005: LD_INT 3
96007: PUSH
96008: LD_INT 4
96010: PUSH
96011: LD_INT 5
96013: PUSH
96014: LD_INT 6
96016: PUSH
96017: LD_INT 7
96019: PUSH
96020: LD_INT 8
96022: PUSH
96023: LD_INT 9
96025: PUSH
96026: LD_INT 10
96028: PUSH
96029: LD_INT 11
96031: PUSH
96032: LD_INT 12
96034: PUSH
96035: LD_INT 13
96037: PUSH
96038: LD_INT 14
96040: PUSH
96041: LD_INT 15
96043: PUSH
96044: LD_INT 16
96046: PUSH
96047: LD_INT 17
96049: PUSH
96050: LD_INT 18
96052: PUSH
96053: LD_INT 19
96055: PUSH
96056: LD_INT 20
96058: PUSH
96059: LD_INT 21
96061: PUSH
96062: LD_INT 22
96064: PUSH
96065: LD_INT 23
96067: PUSH
96068: LD_INT 24
96070: PUSH
96071: LD_INT 25
96073: PUSH
96074: LD_INT 26
96076: PUSH
96077: LD_INT 27
96079: PUSH
96080: LD_INT 28
96082: PUSH
96083: LD_INT 29
96085: PUSH
96086: LD_INT 30
96088: PUSH
96089: LD_INT 31
96091: PUSH
96092: LD_INT 32
96094: PUSH
96095: LD_INT 33
96097: PUSH
96098: LD_INT 34
96100: PUSH
96101: LD_INT 36
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 101
96143: PUSH
96144: LD_INT 102
96146: PUSH
96147: LD_INT 103
96149: PUSH
96150: LD_INT 104
96152: PUSH
96153: LD_INT 105
96155: PUSH
96156: LD_INT 106
96158: PUSH
96159: LD_INT 107
96161: PUSH
96162: LD_INT 108
96164: PUSH
96165: LD_INT 109
96167: PUSH
96168: LD_INT 110
96170: PUSH
96171: LD_INT 111
96173: PUSH
96174: LD_INT 112
96176: PUSH
96177: LD_INT 113
96179: PUSH
96180: LD_INT 114
96182: PUSH
96183: LD_INT 116
96185: PUSH
96186: LD_INT 117
96188: PUSH
96189: LD_INT 118
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: ST_TO_ADDR
96215: GO 96990
96217: LD_INT 16
96219: DOUBLE
96220: EQUAL
96221: IFTRUE 96225
96223: GO 96361
96225: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96226: LD_ADDR_VAR 0 2
96230: PUSH
96231: LD_INT 2
96233: PUSH
96234: LD_INT 4
96236: PUSH
96237: LD_INT 5
96239: PUSH
96240: LD_INT 7
96242: PUSH
96243: LD_INT 11
96245: PUSH
96246: LD_INT 12
96248: PUSH
96249: LD_INT 15
96251: PUSH
96252: LD_INT 16
96254: PUSH
96255: LD_INT 20
96257: PUSH
96258: LD_INT 21
96260: PUSH
96261: LD_INT 22
96263: PUSH
96264: LD_INT 23
96266: PUSH
96267: LD_INT 25
96269: PUSH
96270: LD_INT 26
96272: PUSH
96273: LD_INT 30
96275: PUSH
96276: LD_INT 31
96278: PUSH
96279: LD_INT 32
96281: PUSH
96282: LD_INT 33
96284: PUSH
96285: LD_INT 34
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: PUSH
96309: LD_INT 101
96311: PUSH
96312: LD_INT 102
96314: PUSH
96315: LD_INT 103
96317: PUSH
96318: LD_INT 106
96320: PUSH
96321: LD_INT 108
96323: PUSH
96324: LD_INT 112
96326: PUSH
96327: LD_INT 113
96329: PUSH
96330: LD_INT 114
96332: PUSH
96333: LD_INT 116
96335: PUSH
96336: LD_INT 117
96338: PUSH
96339: LD_INT 118
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: ST_TO_ADDR
96359: GO 96990
96361: LD_INT 17
96363: DOUBLE
96364: EQUAL
96365: IFTRUE 96369
96367: GO 96593
96369: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96370: LD_ADDR_VAR 0 2
96374: PUSH
96375: LD_INT 1
96377: PUSH
96378: LD_INT 2
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 4
96386: PUSH
96387: LD_INT 5
96389: PUSH
96390: LD_INT 6
96392: PUSH
96393: LD_INT 7
96395: PUSH
96396: LD_INT 8
96398: PUSH
96399: LD_INT 9
96401: PUSH
96402: LD_INT 10
96404: PUSH
96405: LD_INT 11
96407: PUSH
96408: LD_INT 12
96410: PUSH
96411: LD_INT 13
96413: PUSH
96414: LD_INT 14
96416: PUSH
96417: LD_INT 15
96419: PUSH
96420: LD_INT 16
96422: PUSH
96423: LD_INT 17
96425: PUSH
96426: LD_INT 18
96428: PUSH
96429: LD_INT 19
96431: PUSH
96432: LD_INT 20
96434: PUSH
96435: LD_INT 21
96437: PUSH
96438: LD_INT 22
96440: PUSH
96441: LD_INT 23
96443: PUSH
96444: LD_INT 24
96446: PUSH
96447: LD_INT 25
96449: PUSH
96450: LD_INT 26
96452: PUSH
96453: LD_INT 27
96455: PUSH
96456: LD_INT 28
96458: PUSH
96459: LD_INT 29
96461: PUSH
96462: LD_INT 30
96464: PUSH
96465: LD_INT 31
96467: PUSH
96468: LD_INT 32
96470: PUSH
96471: LD_INT 33
96473: PUSH
96474: LD_INT 34
96476: PUSH
96477: LD_INT 36
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 101
96519: PUSH
96520: LD_INT 102
96522: PUSH
96523: LD_INT 103
96525: PUSH
96526: LD_INT 104
96528: PUSH
96529: LD_INT 105
96531: PUSH
96532: LD_INT 106
96534: PUSH
96535: LD_INT 107
96537: PUSH
96538: LD_INT 108
96540: PUSH
96541: LD_INT 109
96543: PUSH
96544: LD_INT 110
96546: PUSH
96547: LD_INT 111
96549: PUSH
96550: LD_INT 112
96552: PUSH
96553: LD_INT 113
96555: PUSH
96556: LD_INT 114
96558: PUSH
96559: LD_INT 116
96561: PUSH
96562: LD_INT 117
96564: PUSH
96565: LD_INT 118
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: ST_TO_ADDR
96591: GO 96990
96593: LD_INT 18
96595: DOUBLE
96596: EQUAL
96597: IFTRUE 96601
96599: GO 96749
96601: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96602: LD_ADDR_VAR 0 2
96606: PUSH
96607: LD_INT 2
96609: PUSH
96610: LD_INT 4
96612: PUSH
96613: LD_INT 5
96615: PUSH
96616: LD_INT 7
96618: PUSH
96619: LD_INT 11
96621: PUSH
96622: LD_INT 12
96624: PUSH
96625: LD_INT 15
96627: PUSH
96628: LD_INT 16
96630: PUSH
96631: LD_INT 20
96633: PUSH
96634: LD_INT 21
96636: PUSH
96637: LD_INT 22
96639: PUSH
96640: LD_INT 23
96642: PUSH
96643: LD_INT 25
96645: PUSH
96646: LD_INT 26
96648: PUSH
96649: LD_INT 30
96651: PUSH
96652: LD_INT 31
96654: PUSH
96655: LD_INT 32
96657: PUSH
96658: LD_INT 33
96660: PUSH
96661: LD_INT 34
96663: PUSH
96664: LD_INT 35
96666: PUSH
96667: LD_INT 36
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: PUSH
96693: LD_INT 101
96695: PUSH
96696: LD_INT 102
96698: PUSH
96699: LD_INT 103
96701: PUSH
96702: LD_INT 106
96704: PUSH
96705: LD_INT 108
96707: PUSH
96708: LD_INT 112
96710: PUSH
96711: LD_INT 113
96713: PUSH
96714: LD_INT 114
96716: PUSH
96717: LD_INT 115
96719: PUSH
96720: LD_INT 116
96722: PUSH
96723: LD_INT 117
96725: PUSH
96726: LD_INT 118
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: ST_TO_ADDR
96747: GO 96990
96749: LD_INT 19
96751: DOUBLE
96752: EQUAL
96753: IFTRUE 96757
96755: GO 96989
96757: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96758: LD_ADDR_VAR 0 2
96762: PUSH
96763: LD_INT 1
96765: PUSH
96766: LD_INT 2
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: LD_INT 4
96774: PUSH
96775: LD_INT 5
96777: PUSH
96778: LD_INT 6
96780: PUSH
96781: LD_INT 7
96783: PUSH
96784: LD_INT 8
96786: PUSH
96787: LD_INT 9
96789: PUSH
96790: LD_INT 10
96792: PUSH
96793: LD_INT 11
96795: PUSH
96796: LD_INT 12
96798: PUSH
96799: LD_INT 13
96801: PUSH
96802: LD_INT 14
96804: PUSH
96805: LD_INT 15
96807: PUSH
96808: LD_INT 16
96810: PUSH
96811: LD_INT 17
96813: PUSH
96814: LD_INT 18
96816: PUSH
96817: LD_INT 19
96819: PUSH
96820: LD_INT 20
96822: PUSH
96823: LD_INT 21
96825: PUSH
96826: LD_INT 22
96828: PUSH
96829: LD_INT 23
96831: PUSH
96832: LD_INT 24
96834: PUSH
96835: LD_INT 25
96837: PUSH
96838: LD_INT 26
96840: PUSH
96841: LD_INT 27
96843: PUSH
96844: LD_INT 28
96846: PUSH
96847: LD_INT 29
96849: PUSH
96850: LD_INT 30
96852: PUSH
96853: LD_INT 31
96855: PUSH
96856: LD_INT 32
96858: PUSH
96859: LD_INT 33
96861: PUSH
96862: LD_INT 34
96864: PUSH
96865: LD_INT 35
96867: PUSH
96868: LD_INT 36
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: PUSH
96909: LD_INT 101
96911: PUSH
96912: LD_INT 102
96914: PUSH
96915: LD_INT 103
96917: PUSH
96918: LD_INT 104
96920: PUSH
96921: LD_INT 105
96923: PUSH
96924: LD_INT 106
96926: PUSH
96927: LD_INT 107
96929: PUSH
96930: LD_INT 108
96932: PUSH
96933: LD_INT 109
96935: PUSH
96936: LD_INT 110
96938: PUSH
96939: LD_INT 111
96941: PUSH
96942: LD_INT 112
96944: PUSH
96945: LD_INT 113
96947: PUSH
96948: LD_INT 114
96950: PUSH
96951: LD_INT 115
96953: PUSH
96954: LD_INT 116
96956: PUSH
96957: LD_INT 117
96959: PUSH
96960: LD_INT 118
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: ST_TO_ADDR
96987: GO 96990
96989: POP
// end else
96990: GO 97221
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96992: LD_ADDR_VAR 0 2
96996: PUSH
96997: LD_INT 1
96999: PUSH
97000: LD_INT 2
97002: PUSH
97003: LD_INT 3
97005: PUSH
97006: LD_INT 4
97008: PUSH
97009: LD_INT 5
97011: PUSH
97012: LD_INT 6
97014: PUSH
97015: LD_INT 7
97017: PUSH
97018: LD_INT 8
97020: PUSH
97021: LD_INT 9
97023: PUSH
97024: LD_INT 10
97026: PUSH
97027: LD_INT 11
97029: PUSH
97030: LD_INT 12
97032: PUSH
97033: LD_INT 13
97035: PUSH
97036: LD_INT 14
97038: PUSH
97039: LD_INT 15
97041: PUSH
97042: LD_INT 16
97044: PUSH
97045: LD_INT 17
97047: PUSH
97048: LD_INT 18
97050: PUSH
97051: LD_INT 19
97053: PUSH
97054: LD_INT 20
97056: PUSH
97057: LD_INT 21
97059: PUSH
97060: LD_INT 22
97062: PUSH
97063: LD_INT 23
97065: PUSH
97066: LD_INT 24
97068: PUSH
97069: LD_INT 25
97071: PUSH
97072: LD_INT 26
97074: PUSH
97075: LD_INT 27
97077: PUSH
97078: LD_INT 28
97080: PUSH
97081: LD_INT 29
97083: PUSH
97084: LD_INT 30
97086: PUSH
97087: LD_INT 31
97089: PUSH
97090: LD_INT 32
97092: PUSH
97093: LD_INT 33
97095: PUSH
97096: LD_INT 34
97098: PUSH
97099: LD_INT 35
97101: PUSH
97102: LD_INT 36
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: PUSH
97143: LD_INT 101
97145: PUSH
97146: LD_INT 102
97148: PUSH
97149: LD_INT 103
97151: PUSH
97152: LD_INT 104
97154: PUSH
97155: LD_INT 105
97157: PUSH
97158: LD_INT 106
97160: PUSH
97161: LD_INT 107
97163: PUSH
97164: LD_INT 108
97166: PUSH
97167: LD_INT 109
97169: PUSH
97170: LD_INT 110
97172: PUSH
97173: LD_INT 111
97175: PUSH
97176: LD_INT 112
97178: PUSH
97179: LD_INT 113
97181: PUSH
97182: LD_INT 114
97184: PUSH
97185: LD_INT 115
97187: PUSH
97188: LD_INT 116
97190: PUSH
97191: LD_INT 117
97193: PUSH
97194: LD_INT 118
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: ST_TO_ADDR
// if result then
97221: LD_VAR 0 2
97225: IFFALSE 98011
// begin normal :=  ;
97227: LD_ADDR_VAR 0 5
97231: PUSH
97232: LD_STRING 
97234: ST_TO_ADDR
// hardcore :=  ;
97235: LD_ADDR_VAR 0 6
97239: PUSH
97240: LD_STRING 
97242: ST_TO_ADDR
// active :=  ;
97243: LD_ADDR_VAR 0 7
97247: PUSH
97248: LD_STRING 
97250: ST_TO_ADDR
// for i = 1 to normalCounter do
97251: LD_ADDR_VAR 0 8
97255: PUSH
97256: DOUBLE
97257: LD_INT 1
97259: DEC
97260: ST_TO_ADDR
97261: LD_EXP 110
97265: PUSH
97266: FOR_TO
97267: IFFALSE 97368
// begin tmp := 0 ;
97269: LD_ADDR_VAR 0 3
97273: PUSH
97274: LD_STRING 0
97276: ST_TO_ADDR
// if result [ 1 ] then
97277: LD_VAR 0 2
97281: PUSH
97282: LD_INT 1
97284: ARRAY
97285: IFFALSE 97350
// if result [ 1 ] [ 1 ] = i then
97287: LD_VAR 0 2
97291: PUSH
97292: LD_INT 1
97294: ARRAY
97295: PUSH
97296: LD_INT 1
97298: ARRAY
97299: PUSH
97300: LD_VAR 0 8
97304: EQUAL
97305: IFFALSE 97350
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97307: LD_ADDR_VAR 0 2
97311: PUSH
97312: LD_VAR 0 2
97316: PPUSH
97317: LD_INT 1
97319: PPUSH
97320: LD_VAR 0 2
97324: PUSH
97325: LD_INT 1
97327: ARRAY
97328: PPUSH
97329: LD_INT 1
97331: PPUSH
97332: CALL_OW 3
97336: PPUSH
97337: CALL_OW 1
97341: ST_TO_ADDR
// tmp := 1 ;
97342: LD_ADDR_VAR 0 3
97346: PUSH
97347: LD_STRING 1
97349: ST_TO_ADDR
// end ; normal := normal & tmp ;
97350: LD_ADDR_VAR 0 5
97354: PUSH
97355: LD_VAR 0 5
97359: PUSH
97360: LD_VAR 0 3
97364: STR
97365: ST_TO_ADDR
// end ;
97366: GO 97266
97368: POP
97369: POP
// for i = 1 to hardcoreCounter do
97370: LD_ADDR_VAR 0 8
97374: PUSH
97375: DOUBLE
97376: LD_INT 1
97378: DEC
97379: ST_TO_ADDR
97380: LD_EXP 111
97384: PUSH
97385: FOR_TO
97386: IFFALSE 97491
// begin tmp := 0 ;
97388: LD_ADDR_VAR 0 3
97392: PUSH
97393: LD_STRING 0
97395: ST_TO_ADDR
// if result [ 2 ] then
97396: LD_VAR 0 2
97400: PUSH
97401: LD_INT 2
97403: ARRAY
97404: IFFALSE 97473
// if result [ 2 ] [ 1 ] = 100 + i then
97406: LD_VAR 0 2
97410: PUSH
97411: LD_INT 2
97413: ARRAY
97414: PUSH
97415: LD_INT 1
97417: ARRAY
97418: PUSH
97419: LD_INT 100
97421: PUSH
97422: LD_VAR 0 8
97426: PLUS
97427: EQUAL
97428: IFFALSE 97473
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97430: LD_ADDR_VAR 0 2
97434: PUSH
97435: LD_VAR 0 2
97439: PPUSH
97440: LD_INT 2
97442: PPUSH
97443: LD_VAR 0 2
97447: PUSH
97448: LD_INT 2
97450: ARRAY
97451: PPUSH
97452: LD_INT 1
97454: PPUSH
97455: CALL_OW 3
97459: PPUSH
97460: CALL_OW 1
97464: ST_TO_ADDR
// tmp := 1 ;
97465: LD_ADDR_VAR 0 3
97469: PUSH
97470: LD_STRING 1
97472: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97473: LD_ADDR_VAR 0 6
97477: PUSH
97478: LD_VAR 0 6
97482: PUSH
97483: LD_VAR 0 3
97487: STR
97488: ST_TO_ADDR
// end ;
97489: GO 97385
97491: POP
97492: POP
// if isGameLoad then
97493: LD_VAR 0 1
97497: IFFALSE 97972
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97499: LD_ADDR_VAR 0 4
97503: PUSH
97504: LD_EXP 114
97508: PUSH
97509: LD_EXP 113
97513: PUSH
97514: LD_EXP 115
97518: PUSH
97519: LD_EXP 112
97523: PUSH
97524: LD_EXP 116
97528: PUSH
97529: LD_EXP 117
97533: PUSH
97534: LD_EXP 118
97538: PUSH
97539: LD_EXP 119
97543: PUSH
97544: LD_EXP 120
97548: PUSH
97549: LD_EXP 121
97553: PUSH
97554: LD_EXP 122
97558: PUSH
97559: LD_EXP 123
97563: PUSH
97564: LD_EXP 124
97568: PUSH
97569: LD_EXP 125
97573: PUSH
97574: LD_EXP 133
97578: PUSH
97579: LD_EXP 134
97583: PUSH
97584: LD_EXP 135
97588: PUSH
97589: LD_EXP 136
97593: PUSH
97594: LD_EXP 138
97598: PUSH
97599: LD_EXP 139
97603: PUSH
97604: LD_EXP 140
97608: PUSH
97609: LD_EXP 143
97613: PUSH
97614: LD_EXP 145
97618: PUSH
97619: LD_EXP 146
97623: PUSH
97624: LD_EXP 147
97628: PUSH
97629: LD_EXP 149
97633: PUSH
97634: LD_EXP 150
97638: PUSH
97639: LD_EXP 153
97643: PUSH
97644: LD_EXP 154
97648: PUSH
97649: LD_EXP 155
97653: PUSH
97654: LD_EXP 156
97658: PUSH
97659: LD_EXP 157
97663: PUSH
97664: LD_EXP 158
97668: PUSH
97669: LD_EXP 159
97673: PUSH
97674: LD_EXP 160
97678: PUSH
97679: LD_EXP 161
97683: PUSH
97684: LD_EXP 126
97688: PUSH
97689: LD_EXP 127
97693: PUSH
97694: LD_EXP 130
97698: PUSH
97699: LD_EXP 131
97703: PUSH
97704: LD_EXP 132
97708: PUSH
97709: LD_EXP 128
97713: PUSH
97714: LD_EXP 129
97718: PUSH
97719: LD_EXP 137
97723: PUSH
97724: LD_EXP 141
97728: PUSH
97729: LD_EXP 142
97733: PUSH
97734: LD_EXP 144
97738: PUSH
97739: LD_EXP 148
97743: PUSH
97744: LD_EXP 151
97748: PUSH
97749: LD_EXP 152
97753: PUSH
97754: LD_EXP 162
97758: PUSH
97759: LD_EXP 163
97763: PUSH
97764: LD_EXP 164
97768: PUSH
97769: LD_EXP 165
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: ST_TO_ADDR
// tmp :=  ;
97830: LD_ADDR_VAR 0 3
97834: PUSH
97835: LD_STRING 
97837: ST_TO_ADDR
// for i = 1 to normalCounter do
97838: LD_ADDR_VAR 0 8
97842: PUSH
97843: DOUBLE
97844: LD_INT 1
97846: DEC
97847: ST_TO_ADDR
97848: LD_EXP 110
97852: PUSH
97853: FOR_TO
97854: IFFALSE 97890
// begin if flags [ i ] then
97856: LD_VAR 0 4
97860: PUSH
97861: LD_VAR 0 8
97865: ARRAY
97866: IFFALSE 97888
// tmp := tmp & i & ; ;
97868: LD_ADDR_VAR 0 3
97872: PUSH
97873: LD_VAR 0 3
97877: PUSH
97878: LD_VAR 0 8
97882: STR
97883: PUSH
97884: LD_STRING ;
97886: STR
97887: ST_TO_ADDR
// end ;
97888: GO 97853
97890: POP
97891: POP
// for i = 1 to hardcoreCounter do
97892: LD_ADDR_VAR 0 8
97896: PUSH
97897: DOUBLE
97898: LD_INT 1
97900: DEC
97901: ST_TO_ADDR
97902: LD_EXP 111
97906: PUSH
97907: FOR_TO
97908: IFFALSE 97954
// begin if flags [ normalCounter + i ] then
97910: LD_VAR 0 4
97914: PUSH
97915: LD_EXP 110
97919: PUSH
97920: LD_VAR 0 8
97924: PLUS
97925: ARRAY
97926: IFFALSE 97952
// tmp := tmp & ( 100 + i ) & ; ;
97928: LD_ADDR_VAR 0 3
97932: PUSH
97933: LD_VAR 0 3
97937: PUSH
97938: LD_INT 100
97940: PUSH
97941: LD_VAR 0 8
97945: PLUS
97946: STR
97947: PUSH
97948: LD_STRING ;
97950: STR
97951: ST_TO_ADDR
// end ;
97952: GO 97907
97954: POP
97955: POP
// if tmp then
97956: LD_VAR 0 3
97960: IFFALSE 97972
// active := tmp ;
97962: LD_ADDR_VAR 0 7
97966: PUSH
97967: LD_VAR 0 3
97971: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97972: LD_STRING getStreamItemsFromMission("
97974: PUSH
97975: LD_VAR 0 5
97979: STR
97980: PUSH
97981: LD_STRING ","
97983: STR
97984: PUSH
97985: LD_VAR 0 6
97989: STR
97990: PUSH
97991: LD_STRING ","
97993: STR
97994: PUSH
97995: LD_VAR 0 7
97999: STR
98000: PUSH
98001: LD_STRING ")
98003: STR
98004: PPUSH
98005: CALL_OW 559
// end else
98009: GO 98018
// ToLua ( getStreamItemsFromMission("","","") ) ;
98011: LD_STRING getStreamItemsFromMission("","","")
98013: PPUSH
98014: CALL_OW 559
// end ;
98018: LD_VAR 0 2
98022: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98023: LD_EXP 109
98027: IFFALSE 98035
98029: PUSH
98030: LD_EXP 114
98034: AND
98035: IFFALSE 98159
98037: GO 98039
98039: DISABLE
98040: LD_INT 0
98042: PPUSH
98043: PPUSH
// begin enable ;
98044: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98045: LD_ADDR_VAR 0 2
98049: PUSH
98050: LD_INT 22
98052: PUSH
98053: LD_OWVAR 2
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: PUSH
98062: LD_INT 2
98064: PUSH
98065: LD_INT 34
98067: PUSH
98068: LD_INT 7
98070: PUSH
98071: EMPTY
98072: LIST
98073: LIST
98074: PUSH
98075: LD_INT 34
98077: PUSH
98078: LD_INT 45
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: PUSH
98085: LD_INT 34
98087: PUSH
98088: LD_INT 28
98090: PUSH
98091: EMPTY
98092: LIST
98093: LIST
98094: PUSH
98095: LD_INT 34
98097: PUSH
98098: LD_INT 47
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PPUSH
98116: CALL_OW 69
98120: ST_TO_ADDR
// if not tmp then
98121: LD_VAR 0 2
98125: NOT
98126: IFFALSE 98130
// exit ;
98128: GO 98159
// for i in tmp do
98130: LD_ADDR_VAR 0 1
98134: PUSH
98135: LD_VAR 0 2
98139: PUSH
98140: FOR_IN
98141: IFFALSE 98157
// begin SetLives ( i , 0 ) ;
98143: LD_VAR 0 1
98147: PPUSH
98148: LD_INT 0
98150: PPUSH
98151: CALL_OW 234
// end ;
98155: GO 98140
98157: POP
98158: POP
// end ;
98159: PPOPN 2
98161: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98162: LD_EXP 109
98166: IFFALSE 98174
98168: PUSH
98169: LD_EXP 115
98173: AND
98174: IFFALSE 98258
98176: GO 98178
98178: DISABLE
98179: LD_INT 0
98181: PPUSH
98182: PPUSH
// begin enable ;
98183: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98184: LD_ADDR_VAR 0 2
98188: PUSH
98189: LD_INT 22
98191: PUSH
98192: LD_OWVAR 2
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 32
98203: PUSH
98204: LD_INT 3
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: PUSH
98211: EMPTY
98212: LIST
98213: LIST
98214: PPUSH
98215: CALL_OW 69
98219: ST_TO_ADDR
// if not tmp then
98220: LD_VAR 0 2
98224: NOT
98225: IFFALSE 98229
// exit ;
98227: GO 98258
// for i in tmp do
98229: LD_ADDR_VAR 0 1
98233: PUSH
98234: LD_VAR 0 2
98238: PUSH
98239: FOR_IN
98240: IFFALSE 98256
// begin SetLives ( i , 0 ) ;
98242: LD_VAR 0 1
98246: PPUSH
98247: LD_INT 0
98249: PPUSH
98250: CALL_OW 234
// end ;
98254: GO 98239
98256: POP
98257: POP
// end ;
98258: PPOPN 2
98260: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98261: LD_EXP 109
98265: IFFALSE 98273
98267: PUSH
98268: LD_EXP 112
98272: AND
98273: IFFALSE 98366
98275: GO 98277
98277: DISABLE
98278: LD_INT 0
98280: PPUSH
// begin enable ;
98281: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98282: LD_ADDR_VAR 0 1
98286: PUSH
98287: LD_INT 22
98289: PUSH
98290: LD_OWVAR 2
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 2
98301: PUSH
98302: LD_INT 25
98304: PUSH
98305: LD_INT 5
98307: PUSH
98308: EMPTY
98309: LIST
98310: LIST
98311: PUSH
98312: LD_INT 25
98314: PUSH
98315: LD_INT 9
98317: PUSH
98318: EMPTY
98319: LIST
98320: LIST
98321: PUSH
98322: LD_INT 25
98324: PUSH
98325: LD_INT 8
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: PPUSH
98342: CALL_OW 69
98346: PUSH
98347: FOR_IN
98348: IFFALSE 98364
// begin SetClass ( i , 1 ) ;
98350: LD_VAR 0 1
98354: PPUSH
98355: LD_INT 1
98357: PPUSH
98358: CALL_OW 336
// end ;
98362: GO 98347
98364: POP
98365: POP
// end ;
98366: PPOPN 1
98368: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98369: LD_EXP 109
98373: IFFALSE 98381
98375: PUSH
98376: LD_EXP 113
98380: AND
98381: IFFALSE 98393
98383: PUSH
98384: LD_OWVAR 65
98388: PUSH
98389: LD_INT 7
98391: LESS
98392: AND
98393: IFFALSE 98407
98395: GO 98397
98397: DISABLE
// begin enable ;
98398: ENABLE
// game_speed := 7 ;
98399: LD_ADDR_OWVAR 65
98403: PUSH
98404: LD_INT 7
98406: ST_TO_ADDR
// end ;
98407: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98408: LD_EXP 109
98412: IFFALSE 98420
98414: PUSH
98415: LD_EXP 116
98419: AND
98420: IFFALSE 98622
98422: GO 98424
98424: DISABLE
98425: LD_INT 0
98427: PPUSH
98428: PPUSH
98429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98430: LD_ADDR_VAR 0 3
98434: PUSH
98435: LD_INT 81
98437: PUSH
98438: LD_OWVAR 2
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PUSH
98447: LD_INT 21
98449: PUSH
98450: LD_INT 1
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PPUSH
98461: CALL_OW 69
98465: ST_TO_ADDR
// if not tmp then
98466: LD_VAR 0 3
98470: NOT
98471: IFFALSE 98475
// exit ;
98473: GO 98622
// if tmp > 5 then
98475: LD_VAR 0 3
98479: PUSH
98480: LD_INT 5
98482: GREATER
98483: IFFALSE 98495
// k := 5 else
98485: LD_ADDR_VAR 0 2
98489: PUSH
98490: LD_INT 5
98492: ST_TO_ADDR
98493: GO 98505
// k := tmp ;
98495: LD_ADDR_VAR 0 2
98499: PUSH
98500: LD_VAR 0 3
98504: ST_TO_ADDR
// for i := 1 to k do
98505: LD_ADDR_VAR 0 1
98509: PUSH
98510: DOUBLE
98511: LD_INT 1
98513: DEC
98514: ST_TO_ADDR
98515: LD_VAR 0 2
98519: PUSH
98520: FOR_TO
98521: IFFALSE 98620
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98523: LD_VAR 0 3
98527: PUSH
98528: LD_VAR 0 1
98532: ARRAY
98533: PPUSH
98534: LD_VAR 0 1
98538: PUSH
98539: LD_INT 4
98541: MOD
98542: PUSH
98543: LD_INT 1
98545: PLUS
98546: PPUSH
98547: CALL_OW 259
98551: PUSH
98552: LD_INT 10
98554: LESS
98555: IFFALSE 98618
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98557: LD_VAR 0 3
98561: PUSH
98562: LD_VAR 0 1
98566: ARRAY
98567: PPUSH
98568: LD_VAR 0 1
98572: PUSH
98573: LD_INT 4
98575: MOD
98576: PUSH
98577: LD_INT 1
98579: PLUS
98580: PPUSH
98581: LD_VAR 0 3
98585: PUSH
98586: LD_VAR 0 1
98590: ARRAY
98591: PPUSH
98592: LD_VAR 0 1
98596: PUSH
98597: LD_INT 4
98599: MOD
98600: PUSH
98601: LD_INT 1
98603: PLUS
98604: PPUSH
98605: CALL_OW 259
98609: PUSH
98610: LD_INT 1
98612: PLUS
98613: PPUSH
98614: CALL_OW 237
98618: GO 98520
98620: POP
98621: POP
// end ;
98622: PPOPN 3
98624: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98625: LD_EXP 109
98629: IFFALSE 98637
98631: PUSH
98632: LD_EXP 117
98636: AND
98637: IFFALSE 98657
98639: GO 98641
98641: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98642: LD_INT 4
98644: PPUSH
98645: LD_OWVAR 2
98649: PPUSH
98650: LD_INT 0
98652: PPUSH
98653: CALL_OW 324
98657: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98658: LD_EXP 109
98662: IFFALSE 98670
98664: PUSH
98665: LD_EXP 146
98669: AND
98670: IFFALSE 98690
98672: GO 98674
98674: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98675: LD_INT 19
98677: PPUSH
98678: LD_OWVAR 2
98682: PPUSH
98683: LD_INT 0
98685: PPUSH
98686: CALL_OW 324
98690: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98691: LD_EXP 109
98695: IFFALSE 98703
98697: PUSH
98698: LD_EXP 118
98702: AND
98703: IFFALSE 98805
98705: GO 98707
98707: DISABLE
98708: LD_INT 0
98710: PPUSH
98711: PPUSH
// begin enable ;
98712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98713: LD_ADDR_VAR 0 2
98717: PUSH
98718: LD_INT 22
98720: PUSH
98721: LD_OWVAR 2
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 2
98732: PUSH
98733: LD_INT 34
98735: PUSH
98736: LD_INT 11
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: LD_INT 34
98745: PUSH
98746: LD_INT 30
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: LIST
98757: PUSH
98758: EMPTY
98759: LIST
98760: LIST
98761: PPUSH
98762: CALL_OW 69
98766: ST_TO_ADDR
// if not tmp then
98767: LD_VAR 0 2
98771: NOT
98772: IFFALSE 98776
// exit ;
98774: GO 98805
// for i in tmp do
98776: LD_ADDR_VAR 0 1
98780: PUSH
98781: LD_VAR 0 2
98785: PUSH
98786: FOR_IN
98787: IFFALSE 98803
// begin SetLives ( i , 0 ) ;
98789: LD_VAR 0 1
98793: PPUSH
98794: LD_INT 0
98796: PPUSH
98797: CALL_OW 234
// end ;
98801: GO 98786
98803: POP
98804: POP
// end ;
98805: PPOPN 2
98807: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98808: LD_EXP 109
98812: IFFALSE 98820
98814: PUSH
98815: LD_EXP 119
98819: AND
98820: IFFALSE 98840
98822: GO 98824
98824: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98825: LD_INT 32
98827: PPUSH
98828: LD_OWVAR 2
98832: PPUSH
98833: LD_INT 0
98835: PPUSH
98836: CALL_OW 324
98840: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98841: LD_EXP 109
98845: IFFALSE 98853
98847: PUSH
98848: LD_EXP 120
98852: AND
98853: IFFALSE 99036
98855: GO 98857
98857: DISABLE
98858: LD_INT 0
98860: PPUSH
98861: PPUSH
98862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98863: LD_ADDR_VAR 0 2
98867: PUSH
98868: LD_INT 22
98870: PUSH
98871: LD_OWVAR 2
98875: PUSH
98876: EMPTY
98877: LIST
98878: LIST
98879: PUSH
98880: LD_INT 33
98882: PUSH
98883: LD_INT 3
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PPUSH
98894: CALL_OW 69
98898: ST_TO_ADDR
// if not tmp then
98899: LD_VAR 0 2
98903: NOT
98904: IFFALSE 98908
// exit ;
98906: GO 99036
// side := 0 ;
98908: LD_ADDR_VAR 0 3
98912: PUSH
98913: LD_INT 0
98915: ST_TO_ADDR
// for i := 1 to 8 do
98916: LD_ADDR_VAR 0 1
98920: PUSH
98921: DOUBLE
98922: LD_INT 1
98924: DEC
98925: ST_TO_ADDR
98926: LD_INT 8
98928: PUSH
98929: FOR_TO
98930: IFFALSE 98980
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98932: LD_OWVAR 2
98936: PUSH
98937: LD_VAR 0 1
98941: NONEQUAL
98942: IFFALSE 98964
98944: PUSH
98945: LD_OWVAR 2
98949: PPUSH
98950: LD_VAR 0 1
98954: PPUSH
98955: CALL_OW 81
98959: PUSH
98960: LD_INT 2
98962: EQUAL
98963: AND
98964: IFFALSE 98978
// begin side := i ;
98966: LD_ADDR_VAR 0 3
98970: PUSH
98971: LD_VAR 0 1
98975: ST_TO_ADDR
// break ;
98976: GO 98980
// end ;
98978: GO 98929
98980: POP
98981: POP
// if not side then
98982: LD_VAR 0 3
98986: NOT
98987: IFFALSE 98991
// exit ;
98989: GO 99036
// for i := 1 to tmp do
98991: LD_ADDR_VAR 0 1
98995: PUSH
98996: DOUBLE
98997: LD_INT 1
98999: DEC
99000: ST_TO_ADDR
99001: LD_VAR 0 2
99005: PUSH
99006: FOR_TO
99007: IFFALSE 99034
// if Prob ( 60 ) then
99009: LD_INT 60
99011: PPUSH
99012: CALL_OW 13
99016: IFFALSE 99032
// SetSide ( i , side ) ;
99018: LD_VAR 0 1
99022: PPUSH
99023: LD_VAR 0 3
99027: PPUSH
99028: CALL_OW 235
99032: GO 99006
99034: POP
99035: POP
// end ;
99036: PPOPN 3
99038: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99039: LD_EXP 109
99043: IFFALSE 99051
99045: PUSH
99046: LD_EXP 122
99050: AND
99051: IFFALSE 99170
99053: GO 99055
99055: DISABLE
99056: LD_INT 0
99058: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99059: LD_ADDR_VAR 0 1
99063: PUSH
99064: LD_INT 22
99066: PUSH
99067: LD_OWVAR 2
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 21
99078: PUSH
99079: LD_INT 1
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: PUSH
99086: LD_INT 3
99088: PUSH
99089: LD_INT 23
99091: PUSH
99092: LD_INT 0
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PUSH
99103: EMPTY
99104: LIST
99105: LIST
99106: LIST
99107: PPUSH
99108: CALL_OW 69
99112: PUSH
99113: FOR_IN
99114: IFFALSE 99168
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99116: LD_VAR 0 1
99120: PPUSH
99121: CALL_OW 257
99125: PUSH
99126: LD_INT 1
99128: PUSH
99129: LD_INT 2
99131: PUSH
99132: LD_INT 3
99134: PUSH
99135: LD_INT 4
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: IN
99144: IFFALSE 99166
// SetClass ( un , rand ( 1 , 4 ) ) ;
99146: LD_VAR 0 1
99150: PPUSH
99151: LD_INT 1
99153: PPUSH
99154: LD_INT 4
99156: PPUSH
99157: CALL_OW 12
99161: PPUSH
99162: CALL_OW 336
99166: GO 99113
99168: POP
99169: POP
// end ;
99170: PPOPN 1
99172: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99173: LD_EXP 109
99177: IFFALSE 99185
99179: PUSH
99180: LD_EXP 121
99184: AND
99185: IFFALSE 99264
99187: GO 99189
99189: DISABLE
99190: LD_INT 0
99192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99193: LD_ADDR_VAR 0 1
99197: PUSH
99198: LD_INT 22
99200: PUSH
99201: LD_OWVAR 2
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: PUSH
99210: LD_INT 21
99212: PUSH
99213: LD_INT 3
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: PPUSH
99224: CALL_OW 69
99228: ST_TO_ADDR
// if not tmp then
99229: LD_VAR 0 1
99233: NOT
99234: IFFALSE 99238
// exit ;
99236: GO 99264
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99238: LD_VAR 0 1
99242: PUSH
99243: LD_INT 1
99245: PPUSH
99246: LD_VAR 0 1
99250: PPUSH
99251: CALL_OW 12
99255: ARRAY
99256: PPUSH
99257: LD_INT 100
99259: PPUSH
99260: CALL_OW 234
// end ;
99264: PPOPN 1
99266: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99267: LD_EXP 109
99271: IFFALSE 99279
99273: PUSH
99274: LD_EXP 123
99278: AND
99279: IFFALSE 99377
99281: GO 99283
99283: DISABLE
99284: LD_INT 0
99286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99287: LD_ADDR_VAR 0 1
99291: PUSH
99292: LD_INT 22
99294: PUSH
99295: LD_OWVAR 2
99299: PUSH
99300: EMPTY
99301: LIST
99302: LIST
99303: PUSH
99304: LD_INT 21
99306: PUSH
99307: LD_INT 1
99309: PUSH
99310: EMPTY
99311: LIST
99312: LIST
99313: PUSH
99314: EMPTY
99315: LIST
99316: LIST
99317: PPUSH
99318: CALL_OW 69
99322: ST_TO_ADDR
// if not tmp then
99323: LD_VAR 0 1
99327: NOT
99328: IFFALSE 99332
// exit ;
99330: GO 99377
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99332: LD_VAR 0 1
99336: PUSH
99337: LD_INT 1
99339: PPUSH
99340: LD_VAR 0 1
99344: PPUSH
99345: CALL_OW 12
99349: ARRAY
99350: PPUSH
99351: LD_INT 1
99353: PPUSH
99354: LD_INT 4
99356: PPUSH
99357: CALL_OW 12
99361: PPUSH
99362: LD_INT 3000
99364: PPUSH
99365: LD_INT 9000
99367: PPUSH
99368: CALL_OW 12
99372: PPUSH
99373: CALL_OW 492
// end ;
99377: PPOPN 1
99379: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99380: LD_EXP 109
99384: IFFALSE 99392
99386: PUSH
99387: LD_EXP 124
99391: AND
99392: IFFALSE 99412
99394: GO 99396
99396: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99397: LD_INT 1
99399: PPUSH
99400: LD_OWVAR 2
99404: PPUSH
99405: LD_INT 0
99407: PPUSH
99408: CALL_OW 324
99412: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99413: LD_EXP 109
99417: IFFALSE 99425
99419: PUSH
99420: LD_EXP 125
99424: AND
99425: IFFALSE 99508
99427: GO 99429
99429: DISABLE
99430: LD_INT 0
99432: PPUSH
99433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99434: LD_ADDR_VAR 0 2
99438: PUSH
99439: LD_INT 22
99441: PUSH
99442: LD_OWVAR 2
99446: PUSH
99447: EMPTY
99448: LIST
99449: LIST
99450: PUSH
99451: LD_INT 21
99453: PUSH
99454: LD_INT 3
99456: PUSH
99457: EMPTY
99458: LIST
99459: LIST
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PPUSH
99465: CALL_OW 69
99469: ST_TO_ADDR
// if not tmp then
99470: LD_VAR 0 2
99474: NOT
99475: IFFALSE 99479
// exit ;
99477: GO 99508
// for i in tmp do
99479: LD_ADDR_VAR 0 1
99483: PUSH
99484: LD_VAR 0 2
99488: PUSH
99489: FOR_IN
99490: IFFALSE 99506
// SetBLevel ( i , 10 ) ;
99492: LD_VAR 0 1
99496: PPUSH
99497: LD_INT 10
99499: PPUSH
99500: CALL_OW 241
99504: GO 99489
99506: POP
99507: POP
// end ;
99508: PPOPN 2
99510: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99511: LD_EXP 109
99515: IFFALSE 99523
99517: PUSH
99518: LD_EXP 126
99522: AND
99523: IFFALSE 99634
99525: GO 99527
99527: DISABLE
99528: LD_INT 0
99530: PPUSH
99531: PPUSH
99532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99533: LD_ADDR_VAR 0 3
99537: PUSH
99538: LD_INT 22
99540: PUSH
99541: LD_OWVAR 2
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: PUSH
99550: LD_INT 25
99552: PUSH
99553: LD_INT 1
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PPUSH
99564: CALL_OW 69
99568: ST_TO_ADDR
// if not tmp then
99569: LD_VAR 0 3
99573: NOT
99574: IFFALSE 99578
// exit ;
99576: GO 99634
// un := tmp [ rand ( 1 , tmp ) ] ;
99578: LD_ADDR_VAR 0 2
99582: PUSH
99583: LD_VAR 0 3
99587: PUSH
99588: LD_INT 1
99590: PPUSH
99591: LD_VAR 0 3
99595: PPUSH
99596: CALL_OW 12
99600: ARRAY
99601: ST_TO_ADDR
// if Crawls ( un ) then
99602: LD_VAR 0 2
99606: PPUSH
99607: CALL_OW 318
99611: IFFALSE 99622
// ComWalk ( un ) ;
99613: LD_VAR 0 2
99617: PPUSH
99618: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99622: LD_VAR 0 2
99626: PPUSH
99627: LD_INT 5
99629: PPUSH
99630: CALL_OW 336
// end ;
99634: PPOPN 3
99636: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99637: LD_EXP 109
99641: IFFALSE 99649
99643: PUSH
99644: LD_EXP 127
99648: AND
99649: IFFALSE 99661
99651: PUSH
99652: LD_OWVAR 67
99656: PUSH
99657: LD_INT 4
99659: LESS
99660: AND
99661: IFFALSE 99680
99663: GO 99665
99665: DISABLE
// begin Difficulty := Difficulty + 1 ;
99666: LD_ADDR_OWVAR 67
99670: PUSH
99671: LD_OWVAR 67
99675: PUSH
99676: LD_INT 1
99678: PLUS
99679: ST_TO_ADDR
// end ;
99680: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99681: LD_EXP 109
99685: IFFALSE 99693
99687: PUSH
99688: LD_EXP 128
99692: AND
99693: IFFALSE 99796
99695: GO 99697
99697: DISABLE
99698: LD_INT 0
99700: PPUSH
// begin for i := 1 to 5 do
99701: LD_ADDR_VAR 0 1
99705: PUSH
99706: DOUBLE
99707: LD_INT 1
99709: DEC
99710: ST_TO_ADDR
99711: LD_INT 5
99713: PUSH
99714: FOR_TO
99715: IFFALSE 99794
// begin uc_nation := nation_nature ;
99717: LD_ADDR_OWVAR 21
99721: PUSH
99722: LD_INT 0
99724: ST_TO_ADDR
// uc_side := 0 ;
99725: LD_ADDR_OWVAR 20
99729: PUSH
99730: LD_INT 0
99732: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99733: LD_ADDR_OWVAR 29
99737: PUSH
99738: LD_INT 12
99740: PUSH
99741: LD_INT 12
99743: PUSH
99744: EMPTY
99745: LIST
99746: LIST
99747: ST_TO_ADDR
// hc_agressivity := 20 ;
99748: LD_ADDR_OWVAR 35
99752: PUSH
99753: LD_INT 20
99755: ST_TO_ADDR
// hc_class := class_tiger ;
99756: LD_ADDR_OWVAR 28
99760: PUSH
99761: LD_INT 14
99763: ST_TO_ADDR
// hc_gallery :=  ;
99764: LD_ADDR_OWVAR 33
99768: PUSH
99769: LD_STRING 
99771: ST_TO_ADDR
// hc_name :=  ;
99772: LD_ADDR_OWVAR 26
99776: PUSH
99777: LD_STRING 
99779: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99780: CALL_OW 44
99784: PPUSH
99785: LD_INT 0
99787: PPUSH
99788: CALL_OW 51
// end ;
99792: GO 99714
99794: POP
99795: POP
// end ;
99796: PPOPN 1
99798: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99799: LD_EXP 109
99803: IFFALSE 99811
99805: PUSH
99806: LD_EXP 129
99810: AND
99811: IFFALSE 99820
99813: GO 99815
99815: DISABLE
// StreamSibBomb ;
99816: CALL 99821 0 0
99820: END
// export function StreamSibBomb ; var i , x , y ; begin
99821: LD_INT 0
99823: PPUSH
99824: PPUSH
99825: PPUSH
99826: PPUSH
// result := false ;
99827: LD_ADDR_VAR 0 1
99831: PUSH
99832: LD_INT 0
99834: ST_TO_ADDR
// for i := 1 to 16 do
99835: LD_ADDR_VAR 0 2
99839: PUSH
99840: DOUBLE
99841: LD_INT 1
99843: DEC
99844: ST_TO_ADDR
99845: LD_INT 16
99847: PUSH
99848: FOR_TO
99849: IFFALSE 100048
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99851: LD_ADDR_VAR 0 3
99855: PUSH
99856: LD_INT 10
99858: PUSH
99859: LD_INT 20
99861: PUSH
99862: LD_INT 30
99864: PUSH
99865: LD_INT 40
99867: PUSH
99868: LD_INT 50
99870: PUSH
99871: LD_INT 60
99873: PUSH
99874: LD_INT 70
99876: PUSH
99877: LD_INT 80
99879: PUSH
99880: LD_INT 90
99882: PUSH
99883: LD_INT 100
99885: PUSH
99886: LD_INT 110
99888: PUSH
99889: LD_INT 120
99891: PUSH
99892: LD_INT 130
99894: PUSH
99895: LD_INT 140
99897: PUSH
99898: LD_INT 150
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: LIST
99905: LIST
99906: LIST
99907: LIST
99908: LIST
99909: LIST
99910: LIST
99911: LIST
99912: LIST
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: PUSH
99918: LD_INT 1
99920: PPUSH
99921: LD_INT 15
99923: PPUSH
99924: CALL_OW 12
99928: ARRAY
99929: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99930: LD_ADDR_VAR 0 4
99934: PUSH
99935: LD_INT 10
99937: PUSH
99938: LD_INT 20
99940: PUSH
99941: LD_INT 30
99943: PUSH
99944: LD_INT 40
99946: PUSH
99947: LD_INT 50
99949: PUSH
99950: LD_INT 60
99952: PUSH
99953: LD_INT 70
99955: PUSH
99956: LD_INT 80
99958: PUSH
99959: LD_INT 90
99961: PUSH
99962: LD_INT 100
99964: PUSH
99965: LD_INT 110
99967: PUSH
99968: LD_INT 120
99970: PUSH
99971: LD_INT 130
99973: PUSH
99974: LD_INT 140
99976: PUSH
99977: LD_INT 150
99979: PUSH
99980: EMPTY
99981: LIST
99982: LIST
99983: LIST
99984: LIST
99985: LIST
99986: LIST
99987: LIST
99988: LIST
99989: LIST
99990: LIST
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: PUSH
99997: LD_INT 1
99999: PPUSH
100000: LD_INT 15
100002: PPUSH
100003: CALL_OW 12
100007: ARRAY
100008: ST_TO_ADDR
// if ValidHex ( x , y ) then
100009: LD_VAR 0 3
100013: PPUSH
100014: LD_VAR 0 4
100018: PPUSH
100019: CALL_OW 488
100023: IFFALSE 100046
// begin result := [ x , y ] ;
100025: LD_ADDR_VAR 0 1
100029: PUSH
100030: LD_VAR 0 3
100034: PUSH
100035: LD_VAR 0 4
100039: PUSH
100040: EMPTY
100041: LIST
100042: LIST
100043: ST_TO_ADDR
// break ;
100044: GO 100048
// end ; end ;
100046: GO 99848
100048: POP
100049: POP
// if result then
100050: LD_VAR 0 1
100054: IFFALSE 100114
// begin ToLua ( playSibBomb() ) ;
100056: LD_STRING playSibBomb()
100058: PPUSH
100059: CALL_OW 559
// wait ( 0 0$14 ) ;
100063: LD_INT 490
100065: PPUSH
100066: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100070: LD_VAR 0 1
100074: PUSH
100075: LD_INT 1
100077: ARRAY
100078: PPUSH
100079: LD_VAR 0 1
100083: PUSH
100084: LD_INT 2
100086: ARRAY
100087: PPUSH
100088: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100092: LD_VAR 0 1
100096: PUSH
100097: LD_INT 1
100099: ARRAY
100100: PPUSH
100101: LD_VAR 0 1
100105: PUSH
100106: LD_INT 2
100108: ARRAY
100109: PPUSH
100110: CALL_OW 429
// end ; end ;
100114: LD_VAR 0 1
100118: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100119: LD_EXP 109
100123: IFFALSE 100131
100125: PUSH
100126: LD_EXP 131
100130: AND
100131: IFFALSE 100143
100133: GO 100135
100135: DISABLE
// YouLost (  ) ;
100136: LD_STRING 
100138: PPUSH
100139: CALL_OW 104
100143: END
// every 0 0$1 trigger StreamModeActive and sFog do
100144: LD_EXP 109
100148: IFFALSE 100156
100150: PUSH
100151: LD_EXP 130
100155: AND
100156: IFFALSE 100170
100158: GO 100160
100160: DISABLE
// FogOff ( your_side ) ;
100161: LD_OWVAR 2
100165: PPUSH
100166: CALL_OW 344
100170: END
// every 0 0$1 trigger StreamModeActive and sSun do
100171: LD_EXP 109
100175: IFFALSE 100183
100177: PUSH
100178: LD_EXP 132
100182: AND
100183: IFFALSE 100211
100185: GO 100187
100187: DISABLE
// begin solar_recharge_percent := 0 ;
100188: LD_ADDR_OWVAR 79
100192: PUSH
100193: LD_INT 0
100195: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100196: LD_INT 10500
100198: PPUSH
100199: CALL_OW 67
// solar_recharge_percent := 100 ;
100203: LD_ADDR_OWVAR 79
100207: PUSH
100208: LD_INT 100
100210: ST_TO_ADDR
// end ;
100211: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100212: LD_EXP 109
100216: IFFALSE 100224
100218: PUSH
100219: LD_EXP 133
100223: AND
100224: IFFALSE 100463
100226: GO 100228
100228: DISABLE
100229: LD_INT 0
100231: PPUSH
100232: PPUSH
100233: PPUSH
// begin tmp := [ ] ;
100234: LD_ADDR_VAR 0 3
100238: PUSH
100239: EMPTY
100240: ST_TO_ADDR
// for i := 1 to 6 do
100241: LD_ADDR_VAR 0 1
100245: PUSH
100246: DOUBLE
100247: LD_INT 1
100249: DEC
100250: ST_TO_ADDR
100251: LD_INT 6
100253: PUSH
100254: FOR_TO
100255: IFFALSE 100360
// begin uc_nation := nation_nature ;
100257: LD_ADDR_OWVAR 21
100261: PUSH
100262: LD_INT 0
100264: ST_TO_ADDR
// uc_side := 0 ;
100265: LD_ADDR_OWVAR 20
100269: PUSH
100270: LD_INT 0
100272: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100273: LD_ADDR_OWVAR 29
100277: PUSH
100278: LD_INT 12
100280: PUSH
100281: LD_INT 12
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: ST_TO_ADDR
// hc_agressivity := 20 ;
100288: LD_ADDR_OWVAR 35
100292: PUSH
100293: LD_INT 20
100295: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100296: LD_ADDR_OWVAR 28
100300: PUSH
100301: LD_INT 17
100303: ST_TO_ADDR
// hc_gallery :=  ;
100304: LD_ADDR_OWVAR 33
100308: PUSH
100309: LD_STRING 
100311: ST_TO_ADDR
// hc_name :=  ;
100312: LD_ADDR_OWVAR 26
100316: PUSH
100317: LD_STRING 
100319: ST_TO_ADDR
// un := CreateHuman ;
100320: LD_ADDR_VAR 0 2
100324: PUSH
100325: CALL_OW 44
100329: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100330: LD_VAR 0 2
100334: PPUSH
100335: LD_INT 1
100337: PPUSH
100338: CALL_OW 51
// tmp := tmp ^ un ;
100342: LD_ADDR_VAR 0 3
100346: PUSH
100347: LD_VAR 0 3
100351: PUSH
100352: LD_VAR 0 2
100356: ADD
100357: ST_TO_ADDR
// end ;
100358: GO 100254
100360: POP
100361: POP
// repeat wait ( 0 0$1 ) ;
100362: LD_INT 35
100364: PPUSH
100365: CALL_OW 67
// for un in tmp do
100369: LD_ADDR_VAR 0 2
100373: PUSH
100374: LD_VAR 0 3
100378: PUSH
100379: FOR_IN
100380: IFFALSE 100454
// begin if IsDead ( un ) then
100382: LD_VAR 0 2
100386: PPUSH
100387: CALL_OW 301
100391: IFFALSE 100411
// begin tmp := tmp diff un ;
100393: LD_ADDR_VAR 0 3
100397: PUSH
100398: LD_VAR 0 3
100402: PUSH
100403: LD_VAR 0 2
100407: DIFF
100408: ST_TO_ADDR
// continue ;
100409: GO 100379
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100411: LD_VAR 0 2
100415: PPUSH
100416: LD_INT 3
100418: PUSH
100419: LD_INT 22
100421: PUSH
100422: LD_INT 0
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PUSH
100429: EMPTY
100430: LIST
100431: LIST
100432: PPUSH
100433: CALL_OW 69
100437: PPUSH
100438: LD_VAR 0 2
100442: PPUSH
100443: CALL_OW 74
100447: PPUSH
100448: CALL_OW 115
// end ;
100452: GO 100379
100454: POP
100455: POP
// until not tmp ;
100456: LD_VAR 0 3
100460: NOT
100461: IFFALSE 100362
// end ;
100463: PPOPN 3
100465: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100466: LD_EXP 109
100470: IFFALSE 100478
100472: PUSH
100473: LD_EXP 134
100477: AND
100478: IFFALSE 100532
100480: GO 100482
100482: DISABLE
// begin ToLua ( displayTroll(); ) ;
100483: LD_STRING displayTroll();
100485: PPUSH
100486: CALL_OW 559
// wait ( 3 3$00 ) ;
100490: LD_INT 6300
100492: PPUSH
100493: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100497: LD_STRING hideTroll();
100499: PPUSH
100500: CALL_OW 559
// wait ( 1 1$00 ) ;
100504: LD_INT 2100
100506: PPUSH
100507: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100511: LD_STRING displayTroll();
100513: PPUSH
100514: CALL_OW 559
// wait ( 1 1$00 ) ;
100518: LD_INT 2100
100520: PPUSH
100521: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100525: LD_STRING hideTroll();
100527: PPUSH
100528: CALL_OW 559
// end ;
100532: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100533: LD_EXP 109
100537: IFFALSE 100545
100539: PUSH
100540: LD_EXP 135
100544: AND
100545: IFFALSE 100608
100547: GO 100549
100549: DISABLE
100550: LD_INT 0
100552: PPUSH
// begin p := 0 ;
100553: LD_ADDR_VAR 0 1
100557: PUSH
100558: LD_INT 0
100560: ST_TO_ADDR
// repeat game_speed := 1 ;
100561: LD_ADDR_OWVAR 65
100565: PUSH
100566: LD_INT 1
100568: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100569: LD_INT 35
100571: PPUSH
100572: CALL_OW 67
// p := p + 1 ;
100576: LD_ADDR_VAR 0 1
100580: PUSH
100581: LD_VAR 0 1
100585: PUSH
100586: LD_INT 1
100588: PLUS
100589: ST_TO_ADDR
// until p >= 60 ;
100590: LD_VAR 0 1
100594: PUSH
100595: LD_INT 60
100597: GREATEREQUAL
100598: IFFALSE 100561
// game_speed := 4 ;
100600: LD_ADDR_OWVAR 65
100604: PUSH
100605: LD_INT 4
100607: ST_TO_ADDR
// end ;
100608: PPOPN 1
100610: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100611: LD_EXP 109
100615: IFFALSE 100623
100617: PUSH
100618: LD_EXP 136
100622: AND
100623: IFFALSE 100769
100625: GO 100627
100627: DISABLE
100628: LD_INT 0
100630: PPUSH
100631: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100632: LD_ADDR_VAR 0 1
100636: PUSH
100637: LD_INT 22
100639: PUSH
100640: LD_OWVAR 2
100644: PUSH
100645: EMPTY
100646: LIST
100647: LIST
100648: PUSH
100649: LD_INT 2
100651: PUSH
100652: LD_INT 30
100654: PUSH
100655: LD_INT 0
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PUSH
100662: LD_INT 30
100664: PUSH
100665: LD_INT 1
100667: PUSH
100668: EMPTY
100669: LIST
100670: LIST
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: LIST
100676: PUSH
100677: EMPTY
100678: LIST
100679: LIST
100680: PPUSH
100681: CALL_OW 69
100685: ST_TO_ADDR
// if not depot then
100686: LD_VAR 0 1
100690: NOT
100691: IFFALSE 100695
// exit ;
100693: GO 100769
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100695: LD_ADDR_VAR 0 2
100699: PUSH
100700: LD_VAR 0 1
100704: PUSH
100705: LD_INT 1
100707: PPUSH
100708: LD_VAR 0 1
100712: PPUSH
100713: CALL_OW 12
100717: ARRAY
100718: PPUSH
100719: CALL_OW 274
100723: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100724: LD_VAR 0 2
100728: PPUSH
100729: LD_INT 1
100731: PPUSH
100732: LD_INT 0
100734: PPUSH
100735: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100739: LD_VAR 0 2
100743: PPUSH
100744: LD_INT 2
100746: PPUSH
100747: LD_INT 0
100749: PPUSH
100750: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100754: LD_VAR 0 2
100758: PPUSH
100759: LD_INT 3
100761: PPUSH
100762: LD_INT 0
100764: PPUSH
100765: CALL_OW 277
// end ;
100769: PPOPN 2
100771: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100772: LD_EXP 109
100776: IFFALSE 100784
100778: PUSH
100779: LD_EXP 137
100783: AND
100784: IFFALSE 100881
100786: GO 100788
100788: DISABLE
100789: LD_INT 0
100791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100792: LD_ADDR_VAR 0 1
100796: PUSH
100797: LD_INT 22
100799: PUSH
100800: LD_OWVAR 2
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 21
100811: PUSH
100812: LD_INT 1
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 3
100821: PUSH
100822: LD_INT 23
100824: PUSH
100825: LD_INT 0
100827: PUSH
100828: EMPTY
100829: LIST
100830: LIST
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PUSH
100836: EMPTY
100837: LIST
100838: LIST
100839: LIST
100840: PPUSH
100841: CALL_OW 69
100845: ST_TO_ADDR
// if not tmp then
100846: LD_VAR 0 1
100850: NOT
100851: IFFALSE 100855
// exit ;
100853: GO 100881
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100855: LD_VAR 0 1
100859: PUSH
100860: LD_INT 1
100862: PPUSH
100863: LD_VAR 0 1
100867: PPUSH
100868: CALL_OW 12
100872: ARRAY
100873: PPUSH
100874: LD_INT 200
100876: PPUSH
100877: CALL_OW 234
// end ;
100881: PPOPN 1
100883: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100884: LD_EXP 109
100888: IFFALSE 100896
100890: PUSH
100891: LD_EXP 138
100895: AND
100896: IFFALSE 100975
100898: GO 100900
100900: DISABLE
100901: LD_INT 0
100903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100904: LD_ADDR_VAR 0 1
100908: PUSH
100909: LD_INT 22
100911: PUSH
100912: LD_OWVAR 2
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: LD_INT 21
100923: PUSH
100924: LD_INT 2
100926: PUSH
100927: EMPTY
100928: LIST
100929: LIST
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PPUSH
100935: CALL_OW 69
100939: ST_TO_ADDR
// if not tmp then
100940: LD_VAR 0 1
100944: NOT
100945: IFFALSE 100949
// exit ;
100947: GO 100975
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100949: LD_VAR 0 1
100953: PUSH
100954: LD_INT 1
100956: PPUSH
100957: LD_VAR 0 1
100961: PPUSH
100962: CALL_OW 12
100966: ARRAY
100967: PPUSH
100968: LD_INT 60
100970: PPUSH
100971: CALL_OW 234
// end ;
100975: PPOPN 1
100977: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100978: LD_EXP 109
100982: IFFALSE 100990
100984: PUSH
100985: LD_EXP 139
100989: AND
100990: IFFALSE 101089
100992: GO 100994
100994: DISABLE
100995: LD_INT 0
100997: PPUSH
100998: PPUSH
// begin enable ;
100999: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101000: LD_ADDR_VAR 0 1
101004: PUSH
101005: LD_INT 22
101007: PUSH
101008: LD_OWVAR 2
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PUSH
101017: LD_INT 61
101019: PUSH
101020: EMPTY
101021: LIST
101022: PUSH
101023: LD_INT 33
101025: PUSH
101026: LD_INT 2
101028: PUSH
101029: EMPTY
101030: LIST
101031: LIST
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: LIST
101037: PPUSH
101038: CALL_OW 69
101042: ST_TO_ADDR
// if not tmp then
101043: LD_VAR 0 1
101047: NOT
101048: IFFALSE 101052
// exit ;
101050: GO 101089
// for i in tmp do
101052: LD_ADDR_VAR 0 2
101056: PUSH
101057: LD_VAR 0 1
101061: PUSH
101062: FOR_IN
101063: IFFALSE 101087
// if IsControledBy ( i ) then
101065: LD_VAR 0 2
101069: PPUSH
101070: CALL_OW 312
101074: IFFALSE 101085
// ComUnlink ( i ) ;
101076: LD_VAR 0 2
101080: PPUSH
101081: CALL_OW 136
101085: GO 101062
101087: POP
101088: POP
// end ;
101089: PPOPN 2
101091: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101092: LD_EXP 109
101096: IFFALSE 101104
101098: PUSH
101099: LD_EXP 140
101103: AND
101104: IFFALSE 101244
101106: GO 101108
101108: DISABLE
101109: LD_INT 0
101111: PPUSH
101112: PPUSH
// begin ToLua ( displayPowell(); ) ;
101113: LD_STRING displayPowell();
101115: PPUSH
101116: CALL_OW 559
// uc_side := 0 ;
101120: LD_ADDR_OWVAR 20
101124: PUSH
101125: LD_INT 0
101127: ST_TO_ADDR
// uc_nation := 2 ;
101128: LD_ADDR_OWVAR 21
101132: PUSH
101133: LD_INT 2
101135: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101136: LD_ADDR_OWVAR 37
101140: PUSH
101141: LD_INT 14
101143: ST_TO_ADDR
// vc_engine := engine_siberite ;
101144: LD_ADDR_OWVAR 39
101148: PUSH
101149: LD_INT 3
101151: ST_TO_ADDR
// vc_control := control_apeman ;
101152: LD_ADDR_OWVAR 38
101156: PUSH
101157: LD_INT 5
101159: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101160: LD_ADDR_OWVAR 40
101164: PUSH
101165: LD_INT 29
101167: ST_TO_ADDR
// un := CreateVehicle ;
101168: LD_ADDR_VAR 0 2
101172: PUSH
101173: CALL_OW 45
101177: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101178: LD_VAR 0 2
101182: PPUSH
101183: LD_INT 1
101185: PPUSH
101186: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101190: LD_INT 35
101192: PPUSH
101193: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101197: LD_VAR 0 2
101201: PPUSH
101202: LD_INT 22
101204: PUSH
101205: LD_OWVAR 2
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: PPUSH
101214: CALL_OW 69
101218: PPUSH
101219: LD_VAR 0 2
101223: PPUSH
101224: CALL_OW 74
101228: PPUSH
101229: CALL_OW 115
// until IsDead ( un ) ;
101233: LD_VAR 0 2
101237: PPUSH
101238: CALL_OW 301
101242: IFFALSE 101190
// end ;
101244: PPOPN 2
101246: END
// every 0 0$1 trigger StreamModeActive and sStu do
101247: LD_EXP 109
101251: IFFALSE 101259
101253: PUSH
101254: LD_EXP 148
101258: AND
101259: IFFALSE 101275
101261: GO 101263
101263: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101264: LD_STRING displayStucuk();
101266: PPUSH
101267: CALL_OW 559
// ResetFog ;
101271: CALL_OW 335
// end ;
101275: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101276: LD_EXP 109
101280: IFFALSE 101288
101282: PUSH
101283: LD_EXP 141
101287: AND
101288: IFFALSE 101429
101290: GO 101292
101292: DISABLE
101293: LD_INT 0
101295: PPUSH
101296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101297: LD_ADDR_VAR 0 2
101301: PUSH
101302: LD_INT 22
101304: PUSH
101305: LD_OWVAR 2
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 21
101316: PUSH
101317: LD_INT 1
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PPUSH
101328: CALL_OW 69
101332: ST_TO_ADDR
// if not tmp then
101333: LD_VAR 0 2
101337: NOT
101338: IFFALSE 101342
// exit ;
101340: GO 101429
// un := tmp [ rand ( 1 , tmp ) ] ;
101342: LD_ADDR_VAR 0 1
101346: PUSH
101347: LD_VAR 0 2
101351: PUSH
101352: LD_INT 1
101354: PPUSH
101355: LD_VAR 0 2
101359: PPUSH
101360: CALL_OW 12
101364: ARRAY
101365: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101366: LD_VAR 0 1
101370: PPUSH
101371: LD_INT 0
101373: PPUSH
101374: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101378: LD_VAR 0 1
101382: PPUSH
101383: LD_OWVAR 3
101387: PUSH
101388: LD_VAR 0 1
101392: DIFF
101393: PPUSH
101394: LD_VAR 0 1
101398: PPUSH
101399: CALL_OW 74
101403: PPUSH
101404: CALL_OW 115
// wait ( 0 0$20 ) ;
101408: LD_INT 700
101410: PPUSH
101411: CALL_OW 67
// SetSide ( un , your_side ) ;
101415: LD_VAR 0 1
101419: PPUSH
101420: LD_OWVAR 2
101424: PPUSH
101425: CALL_OW 235
// end ;
101429: PPOPN 2
101431: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101432: LD_EXP 109
101436: IFFALSE 101444
101438: PUSH
101439: LD_EXP 142
101443: AND
101444: IFFALSE 101550
101446: GO 101448
101448: DISABLE
101449: LD_INT 0
101451: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101452: LD_ADDR_VAR 0 1
101456: PUSH
101457: LD_INT 22
101459: PUSH
101460: LD_OWVAR 2
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: LD_INT 2
101471: PUSH
101472: LD_INT 30
101474: PUSH
101475: LD_INT 0
101477: PUSH
101478: EMPTY
101479: LIST
101480: LIST
101481: PUSH
101482: LD_INT 30
101484: PUSH
101485: LD_INT 1
101487: PUSH
101488: EMPTY
101489: LIST
101490: LIST
101491: PUSH
101492: EMPTY
101493: LIST
101494: LIST
101495: LIST
101496: PUSH
101497: EMPTY
101498: LIST
101499: LIST
101500: PPUSH
101501: CALL_OW 69
101505: ST_TO_ADDR
// if not depot then
101506: LD_VAR 0 1
101510: NOT
101511: IFFALSE 101515
// exit ;
101513: GO 101550
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101515: LD_VAR 0 1
101519: PUSH
101520: LD_INT 1
101522: ARRAY
101523: PPUSH
101524: CALL_OW 250
101528: PPUSH
101529: LD_VAR 0 1
101533: PUSH
101534: LD_INT 1
101536: ARRAY
101537: PPUSH
101538: CALL_OW 251
101542: PPUSH
101543: LD_INT 70
101545: PPUSH
101546: CALL_OW 495
// end ;
101550: PPOPN 1
101552: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101553: LD_EXP 109
101557: IFFALSE 101565
101559: PUSH
101560: LD_EXP 143
101564: AND
101565: IFFALSE 101776
101567: GO 101569
101569: DISABLE
101570: LD_INT 0
101572: PPUSH
101573: PPUSH
101574: PPUSH
101575: PPUSH
101576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101577: LD_ADDR_VAR 0 5
101581: PUSH
101582: LD_INT 22
101584: PUSH
101585: LD_OWVAR 2
101589: PUSH
101590: EMPTY
101591: LIST
101592: LIST
101593: PUSH
101594: LD_INT 21
101596: PUSH
101597: LD_INT 1
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PPUSH
101608: CALL_OW 69
101612: ST_TO_ADDR
// if not tmp then
101613: LD_VAR 0 5
101617: NOT
101618: IFFALSE 101622
// exit ;
101620: GO 101776
// for i in tmp do
101622: LD_ADDR_VAR 0 1
101626: PUSH
101627: LD_VAR 0 5
101631: PUSH
101632: FOR_IN
101633: IFFALSE 101774
// begin d := rand ( 0 , 5 ) ;
101635: LD_ADDR_VAR 0 4
101639: PUSH
101640: LD_INT 0
101642: PPUSH
101643: LD_INT 5
101645: PPUSH
101646: CALL_OW 12
101650: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101651: LD_ADDR_VAR 0 2
101655: PUSH
101656: LD_VAR 0 1
101660: PPUSH
101661: CALL_OW 250
101665: PPUSH
101666: LD_VAR 0 4
101670: PPUSH
101671: LD_INT 3
101673: PPUSH
101674: LD_INT 12
101676: PPUSH
101677: CALL_OW 12
101681: PPUSH
101682: CALL_OW 272
101686: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101687: LD_ADDR_VAR 0 3
101691: PUSH
101692: LD_VAR 0 1
101696: PPUSH
101697: CALL_OW 251
101701: PPUSH
101702: LD_VAR 0 4
101706: PPUSH
101707: LD_INT 3
101709: PPUSH
101710: LD_INT 12
101712: PPUSH
101713: CALL_OW 12
101717: PPUSH
101718: CALL_OW 273
101722: ST_TO_ADDR
// if ValidHex ( x , y ) then
101723: LD_VAR 0 2
101727: PPUSH
101728: LD_VAR 0 3
101732: PPUSH
101733: CALL_OW 488
101737: IFFALSE 101772
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101739: LD_VAR 0 1
101743: PPUSH
101744: LD_VAR 0 2
101748: PPUSH
101749: LD_VAR 0 3
101753: PPUSH
101754: LD_INT 3
101756: PPUSH
101757: LD_INT 6
101759: PPUSH
101760: CALL_OW 12
101764: PPUSH
101765: LD_INT 1
101767: PPUSH
101768: CALL_OW 483
// end ;
101772: GO 101632
101774: POP
101775: POP
// end ;
101776: PPOPN 5
101778: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101779: LD_EXP 109
101783: IFFALSE 101791
101785: PUSH
101786: LD_EXP 144
101790: AND
101791: IFFALSE 101885
101793: GO 101795
101795: DISABLE
101796: LD_INT 0
101798: PPUSH
101799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101800: LD_ADDR_VAR 0 2
101804: PUSH
101805: LD_INT 22
101807: PUSH
101808: LD_OWVAR 2
101812: PUSH
101813: EMPTY
101814: LIST
101815: LIST
101816: PUSH
101817: LD_INT 32
101819: PUSH
101820: LD_INT 1
101822: PUSH
101823: EMPTY
101824: LIST
101825: LIST
101826: PUSH
101827: LD_INT 21
101829: PUSH
101830: LD_INT 2
101832: PUSH
101833: EMPTY
101834: LIST
101835: LIST
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: LIST
101841: PPUSH
101842: CALL_OW 69
101846: ST_TO_ADDR
// if not tmp then
101847: LD_VAR 0 2
101851: NOT
101852: IFFALSE 101856
// exit ;
101854: GO 101885
// for i in tmp do
101856: LD_ADDR_VAR 0 1
101860: PUSH
101861: LD_VAR 0 2
101865: PUSH
101866: FOR_IN
101867: IFFALSE 101883
// SetFuel ( i , 0 ) ;
101869: LD_VAR 0 1
101873: PPUSH
101874: LD_INT 0
101876: PPUSH
101877: CALL_OW 240
101881: GO 101866
101883: POP
101884: POP
// end ;
101885: PPOPN 2
101887: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101888: LD_EXP 109
101892: IFFALSE 101900
101894: PUSH
101895: LD_EXP 145
101899: AND
101900: IFFALSE 101966
101902: GO 101904
101904: DISABLE
101905: LD_INT 0
101907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101908: LD_ADDR_VAR 0 1
101912: PUSH
101913: LD_INT 22
101915: PUSH
101916: LD_OWVAR 2
101920: PUSH
101921: EMPTY
101922: LIST
101923: LIST
101924: PUSH
101925: LD_INT 30
101927: PUSH
101928: LD_INT 29
101930: PUSH
101931: EMPTY
101932: LIST
101933: LIST
101934: PUSH
101935: EMPTY
101936: LIST
101937: LIST
101938: PPUSH
101939: CALL_OW 69
101943: ST_TO_ADDR
// if not tmp then
101944: LD_VAR 0 1
101948: NOT
101949: IFFALSE 101953
// exit ;
101951: GO 101966
// DestroyUnit ( tmp [ 1 ] ) ;
101953: LD_VAR 0 1
101957: PUSH
101958: LD_INT 1
101960: ARRAY
101961: PPUSH
101962: CALL_OW 65
// end ;
101966: PPOPN 1
101968: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101969: LD_EXP 109
101973: IFFALSE 101981
101975: PUSH
101976: LD_EXP 147
101980: AND
101981: IFFALSE 102110
101983: GO 101985
101985: DISABLE
101986: LD_INT 0
101988: PPUSH
// begin uc_side := 0 ;
101989: LD_ADDR_OWVAR 20
101993: PUSH
101994: LD_INT 0
101996: ST_TO_ADDR
// uc_nation := nation_arabian ;
101997: LD_ADDR_OWVAR 21
102001: PUSH
102002: LD_INT 2
102004: ST_TO_ADDR
// hc_gallery :=  ;
102005: LD_ADDR_OWVAR 33
102009: PUSH
102010: LD_STRING 
102012: ST_TO_ADDR
// hc_name :=  ;
102013: LD_ADDR_OWVAR 26
102017: PUSH
102018: LD_STRING 
102020: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102021: LD_INT 1
102023: PPUSH
102024: LD_INT 11
102026: PPUSH
102027: LD_INT 10
102029: PPUSH
102030: CALL_OW 380
// un := CreateHuman ;
102034: LD_ADDR_VAR 0 1
102038: PUSH
102039: CALL_OW 44
102043: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102044: LD_VAR 0 1
102048: PPUSH
102049: LD_INT 1
102051: PPUSH
102052: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102056: LD_INT 35
102058: PPUSH
102059: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102063: LD_VAR 0 1
102067: PPUSH
102068: LD_INT 22
102070: PUSH
102071: LD_OWVAR 2
102075: PUSH
102076: EMPTY
102077: LIST
102078: LIST
102079: PPUSH
102080: CALL_OW 69
102084: PPUSH
102085: LD_VAR 0 1
102089: PPUSH
102090: CALL_OW 74
102094: PPUSH
102095: CALL_OW 115
// until IsDead ( un ) ;
102099: LD_VAR 0 1
102103: PPUSH
102104: CALL_OW 301
102108: IFFALSE 102056
// end ;
102110: PPOPN 1
102112: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102113: LD_EXP 109
102117: IFFALSE 102125
102119: PUSH
102120: LD_EXP 149
102124: AND
102125: IFFALSE 102137
102127: GO 102129
102129: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102130: LD_STRING earthquake(getX(game), 0, 32)
102132: PPUSH
102133: CALL_OW 559
102137: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102138: LD_EXP 109
102142: IFFALSE 102150
102144: PUSH
102145: LD_EXP 150
102149: AND
102150: IFFALSE 102241
102152: GO 102154
102154: DISABLE
102155: LD_INT 0
102157: PPUSH
// begin enable ;
102158: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102159: LD_ADDR_VAR 0 1
102163: PUSH
102164: LD_INT 22
102166: PUSH
102167: LD_OWVAR 2
102171: PUSH
102172: EMPTY
102173: LIST
102174: LIST
102175: PUSH
102176: LD_INT 21
102178: PUSH
102179: LD_INT 2
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: PUSH
102186: LD_INT 33
102188: PUSH
102189: LD_INT 3
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: LIST
102200: PPUSH
102201: CALL_OW 69
102205: ST_TO_ADDR
// if not tmp then
102206: LD_VAR 0 1
102210: NOT
102211: IFFALSE 102215
// exit ;
102213: GO 102241
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102215: LD_VAR 0 1
102219: PUSH
102220: LD_INT 1
102222: PPUSH
102223: LD_VAR 0 1
102227: PPUSH
102228: CALL_OW 12
102232: ARRAY
102233: PPUSH
102234: LD_INT 1
102236: PPUSH
102237: CALL_OW 234
// end ;
102241: PPOPN 1
102243: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102244: LD_EXP 109
102248: IFFALSE 102256
102250: PUSH
102251: LD_EXP 151
102255: AND
102256: IFFALSE 102397
102258: GO 102260
102260: DISABLE
102261: LD_INT 0
102263: PPUSH
102264: PPUSH
102265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102266: LD_ADDR_VAR 0 3
102270: PUSH
102271: LD_INT 22
102273: PUSH
102274: LD_OWVAR 2
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: PUSH
102283: LD_INT 25
102285: PUSH
102286: LD_INT 1
102288: PUSH
102289: EMPTY
102290: LIST
102291: LIST
102292: PUSH
102293: EMPTY
102294: LIST
102295: LIST
102296: PPUSH
102297: CALL_OW 69
102301: ST_TO_ADDR
// if not tmp then
102302: LD_VAR 0 3
102306: NOT
102307: IFFALSE 102311
// exit ;
102309: GO 102397
// un := tmp [ rand ( 1 , tmp ) ] ;
102311: LD_ADDR_VAR 0 2
102315: PUSH
102316: LD_VAR 0 3
102320: PUSH
102321: LD_INT 1
102323: PPUSH
102324: LD_VAR 0 3
102328: PPUSH
102329: CALL_OW 12
102333: ARRAY
102334: ST_TO_ADDR
// if Crawls ( un ) then
102335: LD_VAR 0 2
102339: PPUSH
102340: CALL_OW 318
102344: IFFALSE 102355
// ComWalk ( un ) ;
102346: LD_VAR 0 2
102350: PPUSH
102351: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102355: LD_VAR 0 2
102359: PPUSH
102360: LD_INT 9
102362: PPUSH
102363: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102367: LD_INT 28
102369: PPUSH
102370: LD_OWVAR 2
102374: PPUSH
102375: LD_INT 2
102377: PPUSH
102378: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102382: LD_INT 29
102384: PPUSH
102385: LD_OWVAR 2
102389: PPUSH
102390: LD_INT 2
102392: PPUSH
102393: CALL_OW 322
// end ;
102397: PPOPN 3
102399: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102400: LD_EXP 109
102404: IFFALSE 102412
102406: PUSH
102407: LD_EXP 152
102411: AND
102412: IFFALSE 102523
102414: GO 102416
102416: DISABLE
102417: LD_INT 0
102419: PPUSH
102420: PPUSH
102421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102422: LD_ADDR_VAR 0 3
102426: PUSH
102427: LD_INT 22
102429: PUSH
102430: LD_OWVAR 2
102434: PUSH
102435: EMPTY
102436: LIST
102437: LIST
102438: PUSH
102439: LD_INT 25
102441: PUSH
102442: LD_INT 1
102444: PUSH
102445: EMPTY
102446: LIST
102447: LIST
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: PPUSH
102453: CALL_OW 69
102457: ST_TO_ADDR
// if not tmp then
102458: LD_VAR 0 3
102462: NOT
102463: IFFALSE 102467
// exit ;
102465: GO 102523
// un := tmp [ rand ( 1 , tmp ) ] ;
102467: LD_ADDR_VAR 0 2
102471: PUSH
102472: LD_VAR 0 3
102476: PUSH
102477: LD_INT 1
102479: PPUSH
102480: LD_VAR 0 3
102484: PPUSH
102485: CALL_OW 12
102489: ARRAY
102490: ST_TO_ADDR
// if Crawls ( un ) then
102491: LD_VAR 0 2
102495: PPUSH
102496: CALL_OW 318
102500: IFFALSE 102511
// ComWalk ( un ) ;
102502: LD_VAR 0 2
102506: PPUSH
102507: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102511: LD_VAR 0 2
102515: PPUSH
102516: LD_INT 8
102518: PPUSH
102519: CALL_OW 336
// end ;
102523: PPOPN 3
102525: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102526: LD_EXP 109
102530: IFFALSE 102538
102532: PUSH
102533: LD_EXP 153
102537: AND
102538: IFFALSE 102682
102540: GO 102542
102542: DISABLE
102543: LD_INT 0
102545: PPUSH
102546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102547: LD_ADDR_VAR 0 2
102551: PUSH
102552: LD_INT 22
102554: PUSH
102555: LD_OWVAR 2
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: PUSH
102564: LD_INT 21
102566: PUSH
102567: LD_INT 2
102569: PUSH
102570: EMPTY
102571: LIST
102572: LIST
102573: PUSH
102574: LD_INT 2
102576: PUSH
102577: LD_INT 34
102579: PUSH
102580: LD_INT 12
102582: PUSH
102583: EMPTY
102584: LIST
102585: LIST
102586: PUSH
102587: LD_INT 34
102589: PUSH
102590: LD_INT 51
102592: PUSH
102593: EMPTY
102594: LIST
102595: LIST
102596: PUSH
102597: LD_INT 34
102599: PUSH
102600: LD_INT 32
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: LIST
102611: LIST
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: LIST
102617: PPUSH
102618: CALL_OW 69
102622: ST_TO_ADDR
// if not tmp then
102623: LD_VAR 0 2
102627: NOT
102628: IFFALSE 102632
// exit ;
102630: GO 102682
// for i in tmp do
102632: LD_ADDR_VAR 0 1
102636: PUSH
102637: LD_VAR 0 2
102641: PUSH
102642: FOR_IN
102643: IFFALSE 102680
// if GetCargo ( i , mat_artifact ) = 0 then
102645: LD_VAR 0 1
102649: PPUSH
102650: LD_INT 4
102652: PPUSH
102653: CALL_OW 289
102657: PUSH
102658: LD_INT 0
102660: EQUAL
102661: IFFALSE 102678
// SetCargo ( i , mat_siberit , 100 ) ;
102663: LD_VAR 0 1
102667: PPUSH
102668: LD_INT 3
102670: PPUSH
102671: LD_INT 100
102673: PPUSH
102674: CALL_OW 290
102678: GO 102642
102680: POP
102681: POP
// end ;
102682: PPOPN 2
102684: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102685: LD_EXP 109
102689: IFFALSE 102697
102691: PUSH
102692: LD_EXP 154
102696: AND
102697: IFFALSE 102880
102699: GO 102701
102701: DISABLE
102702: LD_INT 0
102704: PPUSH
102705: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102706: LD_ADDR_VAR 0 2
102710: PUSH
102711: LD_INT 22
102713: PUSH
102714: LD_OWVAR 2
102718: PUSH
102719: EMPTY
102720: LIST
102721: LIST
102722: PPUSH
102723: CALL_OW 69
102727: ST_TO_ADDR
// if not tmp then
102728: LD_VAR 0 2
102732: NOT
102733: IFFALSE 102737
// exit ;
102735: GO 102880
// for i := 1 to 2 do
102737: LD_ADDR_VAR 0 1
102741: PUSH
102742: DOUBLE
102743: LD_INT 1
102745: DEC
102746: ST_TO_ADDR
102747: LD_INT 2
102749: PUSH
102750: FOR_TO
102751: IFFALSE 102878
// begin uc_side := your_side ;
102753: LD_ADDR_OWVAR 20
102757: PUSH
102758: LD_OWVAR 2
102762: ST_TO_ADDR
// uc_nation := nation_american ;
102763: LD_ADDR_OWVAR 21
102767: PUSH
102768: LD_INT 1
102770: ST_TO_ADDR
// vc_chassis := us_morphling ;
102771: LD_ADDR_OWVAR 37
102775: PUSH
102776: LD_INT 5
102778: ST_TO_ADDR
// vc_engine := engine_siberite ;
102779: LD_ADDR_OWVAR 39
102783: PUSH
102784: LD_INT 3
102786: ST_TO_ADDR
// vc_control := control_computer ;
102787: LD_ADDR_OWVAR 38
102791: PUSH
102792: LD_INT 3
102794: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102795: LD_ADDR_OWVAR 40
102799: PUSH
102800: LD_INT 10
102802: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102803: LD_VAR 0 2
102807: PUSH
102808: LD_INT 1
102810: ARRAY
102811: PPUSH
102812: CALL_OW 310
102816: NOT
102817: IFFALSE 102864
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102819: CALL_OW 45
102823: PPUSH
102824: LD_VAR 0 2
102828: PUSH
102829: LD_INT 1
102831: ARRAY
102832: PPUSH
102833: CALL_OW 250
102837: PPUSH
102838: LD_VAR 0 2
102842: PUSH
102843: LD_INT 1
102845: ARRAY
102846: PPUSH
102847: CALL_OW 251
102851: PPUSH
102852: LD_INT 12
102854: PPUSH
102855: LD_INT 1
102857: PPUSH
102858: CALL_OW 50
102862: GO 102876
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102864: CALL_OW 45
102868: PPUSH
102869: LD_INT 1
102871: PPUSH
102872: CALL_OW 51
// end ;
102876: GO 102750
102878: POP
102879: POP
// end ;
102880: PPOPN 2
102882: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102883: LD_EXP 109
102887: IFFALSE 102895
102889: PUSH
102890: LD_EXP 155
102894: AND
102895: IFFALSE 103117
102897: GO 102899
102899: DISABLE
102900: LD_INT 0
102902: PPUSH
102903: PPUSH
102904: PPUSH
102905: PPUSH
102906: PPUSH
102907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102908: LD_ADDR_VAR 0 6
102912: PUSH
102913: LD_INT 22
102915: PUSH
102916: LD_OWVAR 2
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: PUSH
102925: LD_INT 21
102927: PUSH
102928: LD_INT 1
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: PUSH
102935: LD_INT 3
102937: PUSH
102938: LD_INT 23
102940: PUSH
102941: LD_INT 0
102943: PUSH
102944: EMPTY
102945: LIST
102946: LIST
102947: PUSH
102948: EMPTY
102949: LIST
102950: LIST
102951: PUSH
102952: EMPTY
102953: LIST
102954: LIST
102955: LIST
102956: PPUSH
102957: CALL_OW 69
102961: ST_TO_ADDR
// if not tmp then
102962: LD_VAR 0 6
102966: NOT
102967: IFFALSE 102971
// exit ;
102969: GO 103117
// s1 := rand ( 1 , 4 ) ;
102971: LD_ADDR_VAR 0 2
102975: PUSH
102976: LD_INT 1
102978: PPUSH
102979: LD_INT 4
102981: PPUSH
102982: CALL_OW 12
102986: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102987: LD_ADDR_VAR 0 4
102991: PUSH
102992: LD_VAR 0 6
102996: PUSH
102997: LD_INT 1
102999: ARRAY
103000: PPUSH
103001: LD_VAR 0 2
103005: PPUSH
103006: CALL_OW 259
103010: ST_TO_ADDR
// if s1 = 1 then
103011: LD_VAR 0 2
103015: PUSH
103016: LD_INT 1
103018: EQUAL
103019: IFFALSE 103039
// s2 := rand ( 2 , 4 ) else
103021: LD_ADDR_VAR 0 3
103025: PUSH
103026: LD_INT 2
103028: PPUSH
103029: LD_INT 4
103031: PPUSH
103032: CALL_OW 12
103036: ST_TO_ADDR
103037: GO 103047
// s2 := 1 ;
103039: LD_ADDR_VAR 0 3
103043: PUSH
103044: LD_INT 1
103046: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103047: LD_ADDR_VAR 0 5
103051: PUSH
103052: LD_VAR 0 6
103056: PUSH
103057: LD_INT 1
103059: ARRAY
103060: PPUSH
103061: LD_VAR 0 3
103065: PPUSH
103066: CALL_OW 259
103070: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103071: LD_VAR 0 6
103075: PUSH
103076: LD_INT 1
103078: ARRAY
103079: PPUSH
103080: LD_VAR 0 2
103084: PPUSH
103085: LD_VAR 0 5
103089: PPUSH
103090: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103094: LD_VAR 0 6
103098: PUSH
103099: LD_INT 1
103101: ARRAY
103102: PPUSH
103103: LD_VAR 0 3
103107: PPUSH
103108: LD_VAR 0 4
103112: PPUSH
103113: CALL_OW 237
// end ;
103117: PPOPN 6
103119: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103120: LD_EXP 109
103124: IFFALSE 103132
103126: PUSH
103127: LD_EXP 156
103131: AND
103132: IFFALSE 103211
103134: GO 103136
103136: DISABLE
103137: LD_INT 0
103139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103140: LD_ADDR_VAR 0 1
103144: PUSH
103145: LD_INT 22
103147: PUSH
103148: LD_OWVAR 2
103152: PUSH
103153: EMPTY
103154: LIST
103155: LIST
103156: PUSH
103157: LD_INT 30
103159: PUSH
103160: LD_INT 3
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: PPUSH
103171: CALL_OW 69
103175: ST_TO_ADDR
// if not tmp then
103176: LD_VAR 0 1
103180: NOT
103181: IFFALSE 103185
// exit ;
103183: GO 103211
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103185: LD_VAR 0 1
103189: PUSH
103190: LD_INT 1
103192: PPUSH
103193: LD_VAR 0 1
103197: PPUSH
103198: CALL_OW 12
103202: ARRAY
103203: PPUSH
103204: LD_INT 1
103206: PPUSH
103207: CALL_OW 234
// end ;
103211: PPOPN 1
103213: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103214: LD_EXP 109
103218: IFFALSE 103226
103220: PUSH
103221: LD_EXP 157
103225: AND
103226: IFFALSE 103338
103228: GO 103230
103230: DISABLE
103231: LD_INT 0
103233: PPUSH
103234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103235: LD_ADDR_VAR 0 2
103239: PUSH
103240: LD_INT 22
103242: PUSH
103243: LD_OWVAR 2
103247: PUSH
103248: EMPTY
103249: LIST
103250: LIST
103251: PUSH
103252: LD_INT 2
103254: PUSH
103255: LD_INT 30
103257: PUSH
103258: LD_INT 27
103260: PUSH
103261: EMPTY
103262: LIST
103263: LIST
103264: PUSH
103265: LD_INT 30
103267: PUSH
103268: LD_INT 26
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: PUSH
103275: LD_INT 30
103277: PUSH
103278: LD_INT 28
103280: PUSH
103281: EMPTY
103282: LIST
103283: LIST
103284: PUSH
103285: EMPTY
103286: LIST
103287: LIST
103288: LIST
103289: LIST
103290: PUSH
103291: EMPTY
103292: LIST
103293: LIST
103294: PPUSH
103295: CALL_OW 69
103299: ST_TO_ADDR
// if not tmp then
103300: LD_VAR 0 2
103304: NOT
103305: IFFALSE 103309
// exit ;
103307: GO 103338
// for i in tmp do
103309: LD_ADDR_VAR 0 1
103313: PUSH
103314: LD_VAR 0 2
103318: PUSH
103319: FOR_IN
103320: IFFALSE 103336
// SetLives ( i , 1 ) ;
103322: LD_VAR 0 1
103326: PPUSH
103327: LD_INT 1
103329: PPUSH
103330: CALL_OW 234
103334: GO 103319
103336: POP
103337: POP
// end ;
103338: PPOPN 2
103340: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103341: LD_EXP 109
103345: IFFALSE 103353
103347: PUSH
103348: LD_EXP 158
103352: AND
103353: IFFALSE 103640
103355: GO 103357
103357: DISABLE
103358: LD_INT 0
103360: PPUSH
103361: PPUSH
103362: PPUSH
// begin i := rand ( 1 , 7 ) ;
103363: LD_ADDR_VAR 0 1
103367: PUSH
103368: LD_INT 1
103370: PPUSH
103371: LD_INT 7
103373: PPUSH
103374: CALL_OW 12
103378: ST_TO_ADDR
// case i of 1 :
103379: LD_VAR 0 1
103383: PUSH
103384: LD_INT 1
103386: DOUBLE
103387: EQUAL
103388: IFTRUE 103392
103390: GO 103402
103392: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103393: LD_STRING earthquake(getX(game), 0, 32)
103395: PPUSH
103396: CALL_OW 559
103400: GO 103640
103402: LD_INT 2
103404: DOUBLE
103405: EQUAL
103406: IFTRUE 103410
103408: GO 103424
103410: POP
// begin ToLua ( displayStucuk(); ) ;
103411: LD_STRING displayStucuk();
103413: PPUSH
103414: CALL_OW 559
// ResetFog ;
103418: CALL_OW 335
// end ; 3 :
103422: GO 103640
103424: LD_INT 3
103426: DOUBLE
103427: EQUAL
103428: IFTRUE 103432
103430: GO 103536
103432: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103433: LD_ADDR_VAR 0 2
103437: PUSH
103438: LD_INT 22
103440: PUSH
103441: LD_OWVAR 2
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: PUSH
103450: LD_INT 25
103452: PUSH
103453: LD_INT 1
103455: PUSH
103456: EMPTY
103457: LIST
103458: LIST
103459: PUSH
103460: EMPTY
103461: LIST
103462: LIST
103463: PPUSH
103464: CALL_OW 69
103468: ST_TO_ADDR
// if not tmp then
103469: LD_VAR 0 2
103473: NOT
103474: IFFALSE 103478
// exit ;
103476: GO 103640
// un := tmp [ rand ( 1 , tmp ) ] ;
103478: LD_ADDR_VAR 0 3
103482: PUSH
103483: LD_VAR 0 2
103487: PUSH
103488: LD_INT 1
103490: PPUSH
103491: LD_VAR 0 2
103495: PPUSH
103496: CALL_OW 12
103500: ARRAY
103501: ST_TO_ADDR
// if Crawls ( un ) then
103502: LD_VAR 0 3
103506: PPUSH
103507: CALL_OW 318
103511: IFFALSE 103522
// ComWalk ( un ) ;
103513: LD_VAR 0 3
103517: PPUSH
103518: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103522: LD_VAR 0 3
103526: PPUSH
103527: LD_INT 8
103529: PPUSH
103530: CALL_OW 336
// end ; 4 :
103534: GO 103640
103536: LD_INT 4
103538: DOUBLE
103539: EQUAL
103540: IFTRUE 103544
103542: GO 103618
103544: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103545: LD_ADDR_VAR 0 2
103549: PUSH
103550: LD_INT 22
103552: PUSH
103553: LD_OWVAR 2
103557: PUSH
103558: EMPTY
103559: LIST
103560: LIST
103561: PUSH
103562: LD_INT 30
103564: PUSH
103565: LD_INT 29
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: PUSH
103572: EMPTY
103573: LIST
103574: LIST
103575: PPUSH
103576: CALL_OW 69
103580: ST_TO_ADDR
// if not tmp then
103581: LD_VAR 0 2
103585: NOT
103586: IFFALSE 103590
// exit ;
103588: GO 103640
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103590: LD_VAR 0 2
103594: PUSH
103595: LD_INT 1
103597: ARRAY
103598: PPUSH
103599: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103603: LD_VAR 0 2
103607: PUSH
103608: LD_INT 1
103610: ARRAY
103611: PPUSH
103612: CALL_OW 65
// end ; 5 .. 7 :
103616: GO 103640
103618: LD_INT 5
103620: DOUBLE
103621: GREATEREQUAL
103622: IFFALSE 103630
103624: LD_INT 7
103626: DOUBLE
103627: LESSEQUAL
103628: IFTRUE 103632
103630: GO 103639
103632: POP
// StreamSibBomb ; end ;
103633: CALL 99821 0 0
103637: GO 103640
103639: POP
// end ;
103640: PPOPN 3
103642: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103643: LD_EXP 109
103647: IFFALSE 103655
103649: PUSH
103650: LD_EXP 159
103654: AND
103655: IFFALSE 103811
103657: GO 103659
103659: DISABLE
103660: LD_INT 0
103662: PPUSH
103663: PPUSH
103664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103665: LD_ADDR_VAR 0 2
103669: PUSH
103670: LD_INT 81
103672: PUSH
103673: LD_OWVAR 2
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: PUSH
103682: LD_INT 2
103684: PUSH
103685: LD_INT 21
103687: PUSH
103688: LD_INT 1
103690: PUSH
103691: EMPTY
103692: LIST
103693: LIST
103694: PUSH
103695: LD_INT 21
103697: PUSH
103698: LD_INT 2
103700: PUSH
103701: EMPTY
103702: LIST
103703: LIST
103704: PUSH
103705: EMPTY
103706: LIST
103707: LIST
103708: LIST
103709: PUSH
103710: EMPTY
103711: LIST
103712: LIST
103713: PPUSH
103714: CALL_OW 69
103718: ST_TO_ADDR
// if not tmp then
103719: LD_VAR 0 2
103723: NOT
103724: IFFALSE 103728
// exit ;
103726: GO 103811
// p := 0 ;
103728: LD_ADDR_VAR 0 3
103732: PUSH
103733: LD_INT 0
103735: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103736: LD_INT 35
103738: PPUSH
103739: CALL_OW 67
// p := p + 1 ;
103743: LD_ADDR_VAR 0 3
103747: PUSH
103748: LD_VAR 0 3
103752: PUSH
103753: LD_INT 1
103755: PLUS
103756: ST_TO_ADDR
// for i in tmp do
103757: LD_ADDR_VAR 0 1
103761: PUSH
103762: LD_VAR 0 2
103766: PUSH
103767: FOR_IN
103768: IFFALSE 103799
// if GetLives ( i ) < 1000 then
103770: LD_VAR 0 1
103774: PPUSH
103775: CALL_OW 256
103779: PUSH
103780: LD_INT 1000
103782: LESS
103783: IFFALSE 103797
// SetLives ( i , 1000 ) ;
103785: LD_VAR 0 1
103789: PPUSH
103790: LD_INT 1000
103792: PPUSH
103793: CALL_OW 234
103797: GO 103767
103799: POP
103800: POP
// until p > 20 ;
103801: LD_VAR 0 3
103805: PUSH
103806: LD_INT 20
103808: GREATER
103809: IFFALSE 103736
// end ;
103811: PPOPN 3
103813: END
// every 0 0$1 trigger StreamModeActive and sTime do
103814: LD_EXP 109
103818: IFFALSE 103826
103820: PUSH
103821: LD_EXP 160
103825: AND
103826: IFFALSE 103861
103828: GO 103830
103830: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103831: LD_INT 28
103833: PPUSH
103834: LD_OWVAR 2
103838: PPUSH
103839: LD_INT 2
103841: PPUSH
103842: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103846: LD_INT 30
103848: PPUSH
103849: LD_OWVAR 2
103853: PPUSH
103854: LD_INT 2
103856: PPUSH
103857: CALL_OW 322
// end ;
103861: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103862: LD_EXP 109
103866: IFFALSE 103874
103868: PUSH
103869: LD_EXP 161
103873: AND
103874: IFFALSE 103995
103876: GO 103878
103878: DISABLE
103879: LD_INT 0
103881: PPUSH
103882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103883: LD_ADDR_VAR 0 2
103887: PUSH
103888: LD_INT 22
103890: PUSH
103891: LD_OWVAR 2
103895: PUSH
103896: EMPTY
103897: LIST
103898: LIST
103899: PUSH
103900: LD_INT 21
103902: PUSH
103903: LD_INT 1
103905: PUSH
103906: EMPTY
103907: LIST
103908: LIST
103909: PUSH
103910: LD_INT 3
103912: PUSH
103913: LD_INT 23
103915: PUSH
103916: LD_INT 0
103918: PUSH
103919: EMPTY
103920: LIST
103921: LIST
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: EMPTY
103928: LIST
103929: LIST
103930: LIST
103931: PPUSH
103932: CALL_OW 69
103936: ST_TO_ADDR
// if not tmp then
103937: LD_VAR 0 2
103941: NOT
103942: IFFALSE 103946
// exit ;
103944: GO 103995
// for i in tmp do
103946: LD_ADDR_VAR 0 1
103950: PUSH
103951: LD_VAR 0 2
103955: PUSH
103956: FOR_IN
103957: IFFALSE 103993
// begin if Crawls ( i ) then
103959: LD_VAR 0 1
103963: PPUSH
103964: CALL_OW 318
103968: IFFALSE 103979
// ComWalk ( i ) ;
103970: LD_VAR 0 1
103974: PPUSH
103975: CALL_OW 138
// SetClass ( i , 2 ) ;
103979: LD_VAR 0 1
103983: PPUSH
103984: LD_INT 2
103986: PPUSH
103987: CALL_OW 336
// end ;
103991: GO 103956
103993: POP
103994: POP
// end ;
103995: PPOPN 2
103997: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103998: LD_EXP 109
104002: IFFALSE 104010
104004: PUSH
104005: LD_EXP 162
104009: AND
104010: IFFALSE 104300
104012: GO 104014
104014: DISABLE
104015: LD_INT 0
104017: PPUSH
104018: PPUSH
104019: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104020: LD_OWVAR 2
104024: PPUSH
104025: LD_INT 9
104027: PPUSH
104028: LD_INT 1
104030: PPUSH
104031: LD_INT 1
104033: PPUSH
104034: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104038: LD_INT 9
104040: PPUSH
104041: LD_OWVAR 2
104045: PPUSH
104046: CALL_OW 343
// uc_side := 9 ;
104050: LD_ADDR_OWVAR 20
104054: PUSH
104055: LD_INT 9
104057: ST_TO_ADDR
// uc_nation := 2 ;
104058: LD_ADDR_OWVAR 21
104062: PUSH
104063: LD_INT 2
104065: ST_TO_ADDR
// hc_name := Dark Warrior ;
104066: LD_ADDR_OWVAR 26
104070: PUSH
104071: LD_STRING Dark Warrior
104073: ST_TO_ADDR
// hc_gallery :=  ;
104074: LD_ADDR_OWVAR 33
104078: PUSH
104079: LD_STRING 
104081: ST_TO_ADDR
// hc_noskilllimit := true ;
104082: LD_ADDR_OWVAR 76
104086: PUSH
104087: LD_INT 1
104089: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104090: LD_ADDR_OWVAR 31
104094: PUSH
104095: LD_INT 30
104097: PUSH
104098: LD_INT 30
104100: PUSH
104101: LD_INT 30
104103: PUSH
104104: LD_INT 30
104106: PUSH
104107: EMPTY
104108: LIST
104109: LIST
104110: LIST
104111: LIST
104112: ST_TO_ADDR
// un := CreateHuman ;
104113: LD_ADDR_VAR 0 3
104117: PUSH
104118: CALL_OW 44
104122: ST_TO_ADDR
// hc_noskilllimit := false ;
104123: LD_ADDR_OWVAR 76
104127: PUSH
104128: LD_INT 0
104130: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104131: LD_VAR 0 3
104135: PPUSH
104136: LD_INT 1
104138: PPUSH
104139: CALL_OW 51
// ToLua ( playRanger() ) ;
104143: LD_STRING playRanger()
104145: PPUSH
104146: CALL_OW 559
// p := 0 ;
104150: LD_ADDR_VAR 0 2
104154: PUSH
104155: LD_INT 0
104157: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104158: LD_INT 35
104160: PPUSH
104161: CALL_OW 67
// p := p + 1 ;
104165: LD_ADDR_VAR 0 2
104169: PUSH
104170: LD_VAR 0 2
104174: PUSH
104175: LD_INT 1
104177: PLUS
104178: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104179: LD_VAR 0 3
104183: PPUSH
104184: CALL_OW 256
104188: PUSH
104189: LD_INT 1000
104191: LESS
104192: IFFALSE 104206
// SetLives ( un , 1000 ) ;
104194: LD_VAR 0 3
104198: PPUSH
104199: LD_INT 1000
104201: PPUSH
104202: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104206: LD_VAR 0 3
104210: PPUSH
104211: LD_INT 81
104213: PUSH
104214: LD_OWVAR 2
104218: PUSH
104219: EMPTY
104220: LIST
104221: LIST
104222: PUSH
104223: LD_INT 91
104225: PUSH
104226: LD_VAR 0 3
104230: PUSH
104231: LD_INT 30
104233: PUSH
104234: EMPTY
104235: LIST
104236: LIST
104237: LIST
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: PPUSH
104243: CALL_OW 69
104247: PPUSH
104248: LD_VAR 0 3
104252: PPUSH
104253: CALL_OW 74
104257: PPUSH
104258: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104262: LD_VAR 0 2
104266: PUSH
104267: LD_INT 80
104269: GREATER
104270: IFTRUE 104283
104272: PUSH
104273: LD_VAR 0 3
104277: PPUSH
104278: CALL_OW 301
104282: OR
104283: IFFALSE 104158
// if un then
104285: LD_VAR 0 3
104289: IFFALSE 104300
// RemoveUnit ( un ) ;
104291: LD_VAR 0 3
104295: PPUSH
104296: CALL_OW 64
// end ;
104300: PPOPN 3
104302: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104303: LD_EXP 163
104307: IFFALSE 104423
104309: GO 104311
104311: DISABLE
104312: LD_INT 0
104314: PPUSH
104315: PPUSH
104316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104317: LD_ADDR_VAR 0 2
104321: PUSH
104322: LD_INT 81
104324: PUSH
104325: LD_OWVAR 2
104329: PUSH
104330: EMPTY
104331: LIST
104332: LIST
104333: PUSH
104334: LD_INT 21
104336: PUSH
104337: LD_INT 1
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PUSH
104344: EMPTY
104345: LIST
104346: LIST
104347: PPUSH
104348: CALL_OW 69
104352: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104353: LD_STRING playComputer()
104355: PPUSH
104356: CALL_OW 559
// if not tmp then
104360: LD_VAR 0 2
104364: NOT
104365: IFFALSE 104369
// exit ;
104367: GO 104423
// for i in tmp do
104369: LD_ADDR_VAR 0 1
104373: PUSH
104374: LD_VAR 0 2
104378: PUSH
104379: FOR_IN
104380: IFFALSE 104421
// for j := 1 to 4 do
104382: LD_ADDR_VAR 0 3
104386: PUSH
104387: DOUBLE
104388: LD_INT 1
104390: DEC
104391: ST_TO_ADDR
104392: LD_INT 4
104394: PUSH
104395: FOR_TO
104396: IFFALSE 104417
// SetSkill ( i , j , 10 ) ;
104398: LD_VAR 0 1
104402: PPUSH
104403: LD_VAR 0 3
104407: PPUSH
104408: LD_INT 10
104410: PPUSH
104411: CALL_OW 237
104415: GO 104395
104417: POP
104418: POP
104419: GO 104379
104421: POP
104422: POP
// end ;
104423: PPOPN 3
104425: END
// every 0 0$1 trigger s30 do var i , tmp ;
104426: LD_EXP 164
104430: IFFALSE 104499
104432: GO 104434
104434: DISABLE
104435: LD_INT 0
104437: PPUSH
104438: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104439: LD_ADDR_VAR 0 2
104443: PUSH
104444: LD_INT 22
104446: PUSH
104447: LD_OWVAR 2
104451: PUSH
104452: EMPTY
104453: LIST
104454: LIST
104455: PPUSH
104456: CALL_OW 69
104460: ST_TO_ADDR
// if not tmp then
104461: LD_VAR 0 2
104465: NOT
104466: IFFALSE 104470
// exit ;
104468: GO 104499
// for i in tmp do
104470: LD_ADDR_VAR 0 1
104474: PUSH
104475: LD_VAR 0 2
104479: PUSH
104480: FOR_IN
104481: IFFALSE 104497
// SetLives ( i , 300 ) ;
104483: LD_VAR 0 1
104487: PPUSH
104488: LD_INT 300
104490: PPUSH
104491: CALL_OW 234
104495: GO 104480
104497: POP
104498: POP
// end ;
104499: PPOPN 2
104501: END
// every 0 0$1 trigger s60 do var i , tmp ;
104502: LD_EXP 165
104506: IFFALSE 104575
104508: GO 104510
104510: DISABLE
104511: LD_INT 0
104513: PPUSH
104514: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104515: LD_ADDR_VAR 0 2
104519: PUSH
104520: LD_INT 22
104522: PUSH
104523: LD_OWVAR 2
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PPUSH
104532: CALL_OW 69
104536: ST_TO_ADDR
// if not tmp then
104537: LD_VAR 0 2
104541: NOT
104542: IFFALSE 104546
// exit ;
104544: GO 104575
// for i in tmp do
104546: LD_ADDR_VAR 0 1
104550: PUSH
104551: LD_VAR 0 2
104555: PUSH
104556: FOR_IN
104557: IFFALSE 104573
// SetLives ( i , 600 ) ;
104559: LD_VAR 0 1
104563: PPUSH
104564: LD_INT 600
104566: PPUSH
104567: CALL_OW 234
104571: GO 104556
104573: POP
104574: POP
// end ;
104575: PPOPN 2
104577: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104578: LD_INT 0
104580: PPUSH
// case cmd of 301 :
104581: LD_VAR 0 1
104585: PUSH
104586: LD_INT 301
104588: DOUBLE
104589: EQUAL
104590: IFTRUE 104594
104592: GO 104626
104594: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104595: LD_VAR 0 6
104599: PPUSH
104600: LD_VAR 0 7
104604: PPUSH
104605: LD_VAR 0 8
104609: PPUSH
104610: LD_VAR 0 4
104614: PPUSH
104615: LD_VAR 0 5
104619: PPUSH
104620: CALL 105839 0 5
104624: GO 104747
104626: LD_INT 302
104628: DOUBLE
104629: EQUAL
104630: IFTRUE 104634
104632: GO 104671
104634: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104635: LD_VAR 0 6
104639: PPUSH
104640: LD_VAR 0 7
104644: PPUSH
104645: LD_VAR 0 8
104649: PPUSH
104650: LD_VAR 0 9
104654: PPUSH
104655: LD_VAR 0 4
104659: PPUSH
104660: LD_VAR 0 5
104664: PPUSH
104665: CALL 105930 0 6
104669: GO 104747
104671: LD_INT 303
104673: DOUBLE
104674: EQUAL
104675: IFTRUE 104679
104677: GO 104716
104679: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104680: LD_VAR 0 6
104684: PPUSH
104685: LD_VAR 0 7
104689: PPUSH
104690: LD_VAR 0 8
104694: PPUSH
104695: LD_VAR 0 9
104699: PPUSH
104700: LD_VAR 0 4
104704: PPUSH
104705: LD_VAR 0 5
104709: PPUSH
104710: CALL 104752 0 6
104714: GO 104747
104716: LD_INT 304
104718: DOUBLE
104719: EQUAL
104720: IFTRUE 104724
104722: GO 104746
104724: POP
// hHackTeleport ( unit , x , y ) ; end ;
104725: LD_VAR 0 2
104729: PPUSH
104730: LD_VAR 0 4
104734: PPUSH
104735: LD_VAR 0 5
104739: PPUSH
104740: CALL 106523 0 3
104744: GO 104747
104746: POP
// end ;
104747: LD_VAR 0 12
104751: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104752: LD_INT 0
104754: PPUSH
104755: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104756: LD_VAR 0 1
104760: PUSH
104761: LD_INT 1
104763: LESS
104764: IFTRUE 104776
104766: PUSH
104767: LD_VAR 0 1
104771: PUSH
104772: LD_INT 3
104774: GREATER
104775: OR
104776: IFTRUE 104794
104778: PUSH
104779: LD_VAR 0 5
104783: PPUSH
104784: LD_VAR 0 6
104788: PPUSH
104789: CALL_OW 428
104793: OR
104794: IFFALSE 104798
// exit ;
104796: GO 105526
// uc_side := your_side ;
104798: LD_ADDR_OWVAR 20
104802: PUSH
104803: LD_OWVAR 2
104807: ST_TO_ADDR
// uc_nation := nation ;
104808: LD_ADDR_OWVAR 21
104812: PUSH
104813: LD_VAR 0 1
104817: ST_TO_ADDR
// bc_level = 1 ;
104818: LD_ADDR_OWVAR 43
104822: PUSH
104823: LD_INT 1
104825: ST_TO_ADDR
// case btype of 1 :
104826: LD_VAR 0 2
104830: PUSH
104831: LD_INT 1
104833: DOUBLE
104834: EQUAL
104835: IFTRUE 104839
104837: GO 104850
104839: POP
// bc_type := b_depot ; 2 :
104840: LD_ADDR_OWVAR 42
104844: PUSH
104845: LD_INT 0
104847: ST_TO_ADDR
104848: GO 105470
104850: LD_INT 2
104852: DOUBLE
104853: EQUAL
104854: IFTRUE 104858
104856: GO 104869
104858: POP
// bc_type := b_warehouse ; 3 :
104859: LD_ADDR_OWVAR 42
104863: PUSH
104864: LD_INT 1
104866: ST_TO_ADDR
104867: GO 105470
104869: LD_INT 3
104871: DOUBLE
104872: EQUAL
104873: IFTRUE 104877
104875: GO 104888
104877: POP
// bc_type := b_lab ; 4 .. 9 :
104878: LD_ADDR_OWVAR 42
104882: PUSH
104883: LD_INT 6
104885: ST_TO_ADDR
104886: GO 105470
104888: LD_INT 4
104890: DOUBLE
104891: GREATEREQUAL
104892: IFFALSE 104900
104894: LD_INT 9
104896: DOUBLE
104897: LESSEQUAL
104898: IFTRUE 104902
104900: GO 104962
104902: POP
// begin bc_type := b_lab_half ;
104903: LD_ADDR_OWVAR 42
104907: PUSH
104908: LD_INT 7
104910: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104911: LD_ADDR_OWVAR 44
104915: PUSH
104916: LD_INT 10
104918: PUSH
104919: LD_INT 11
104921: PUSH
104922: LD_INT 12
104924: PUSH
104925: LD_INT 15
104927: PUSH
104928: LD_INT 14
104930: PUSH
104931: LD_INT 13
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: LIST
104941: PUSH
104942: LD_VAR 0 2
104946: PUSH
104947: LD_INT 3
104949: MINUS
104950: ARRAY
104951: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104952: LD_ADDR_OWVAR 45
104956: PUSH
104957: LD_INT 9
104959: ST_TO_ADDR
// end ; 10 .. 13 :
104960: GO 105470
104962: LD_INT 10
104964: DOUBLE
104965: GREATEREQUAL
104966: IFFALSE 104974
104968: LD_INT 13
104970: DOUBLE
104971: LESSEQUAL
104972: IFTRUE 104976
104974: GO 105053
104976: POP
// begin bc_type := b_lab_full ;
104977: LD_ADDR_OWVAR 42
104981: PUSH
104982: LD_INT 8
104984: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104985: LD_ADDR_OWVAR 44
104989: PUSH
104990: LD_INT 10
104992: PUSH
104993: LD_INT 12
104995: PUSH
104996: LD_INT 14
104998: PUSH
104999: LD_INT 13
105001: PUSH
105002: EMPTY
105003: LIST
105004: LIST
105005: LIST
105006: LIST
105007: PUSH
105008: LD_VAR 0 2
105012: PUSH
105013: LD_INT 9
105015: MINUS
105016: ARRAY
105017: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105018: LD_ADDR_OWVAR 45
105022: PUSH
105023: LD_INT 11
105025: PUSH
105026: LD_INT 15
105028: PUSH
105029: LD_INT 12
105031: PUSH
105032: LD_INT 15
105034: PUSH
105035: EMPTY
105036: LIST
105037: LIST
105038: LIST
105039: LIST
105040: PUSH
105041: LD_VAR 0 2
105045: PUSH
105046: LD_INT 9
105048: MINUS
105049: ARRAY
105050: ST_TO_ADDR
// end ; 14 :
105051: GO 105470
105053: LD_INT 14
105055: DOUBLE
105056: EQUAL
105057: IFTRUE 105061
105059: GO 105072
105061: POP
// bc_type := b_workshop ; 15 :
105062: LD_ADDR_OWVAR 42
105066: PUSH
105067: LD_INT 2
105069: ST_TO_ADDR
105070: GO 105470
105072: LD_INT 15
105074: DOUBLE
105075: EQUAL
105076: IFTRUE 105080
105078: GO 105091
105080: POP
// bc_type := b_factory ; 16 :
105081: LD_ADDR_OWVAR 42
105085: PUSH
105086: LD_INT 3
105088: ST_TO_ADDR
105089: GO 105470
105091: LD_INT 16
105093: DOUBLE
105094: EQUAL
105095: IFTRUE 105099
105097: GO 105110
105099: POP
// bc_type := b_ext_gun ; 17 :
105100: LD_ADDR_OWVAR 42
105104: PUSH
105105: LD_INT 17
105107: ST_TO_ADDR
105108: GO 105470
105110: LD_INT 17
105112: DOUBLE
105113: EQUAL
105114: IFTRUE 105118
105116: GO 105146
105118: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105119: LD_ADDR_OWVAR 42
105123: PUSH
105124: LD_INT 19
105126: PUSH
105127: LD_INT 23
105129: PUSH
105130: LD_INT 19
105132: PUSH
105133: EMPTY
105134: LIST
105135: LIST
105136: LIST
105137: PUSH
105138: LD_VAR 0 1
105142: ARRAY
105143: ST_TO_ADDR
105144: GO 105470
105146: LD_INT 18
105148: DOUBLE
105149: EQUAL
105150: IFTRUE 105154
105152: GO 105165
105154: POP
// bc_type := b_ext_radar ; 19 :
105155: LD_ADDR_OWVAR 42
105159: PUSH
105160: LD_INT 20
105162: ST_TO_ADDR
105163: GO 105470
105165: LD_INT 19
105167: DOUBLE
105168: EQUAL
105169: IFTRUE 105173
105171: GO 105184
105173: POP
// bc_type := b_ext_radio ; 20 :
105174: LD_ADDR_OWVAR 42
105178: PUSH
105179: LD_INT 22
105181: ST_TO_ADDR
105182: GO 105470
105184: LD_INT 20
105186: DOUBLE
105187: EQUAL
105188: IFTRUE 105192
105190: GO 105203
105192: POP
// bc_type := b_ext_siberium ; 21 :
105193: LD_ADDR_OWVAR 42
105197: PUSH
105198: LD_INT 21
105200: ST_TO_ADDR
105201: GO 105470
105203: LD_INT 21
105205: DOUBLE
105206: EQUAL
105207: IFTRUE 105211
105209: GO 105222
105211: POP
// bc_type := b_ext_computer ; 22 :
105212: LD_ADDR_OWVAR 42
105216: PUSH
105217: LD_INT 24
105219: ST_TO_ADDR
105220: GO 105470
105222: LD_INT 22
105224: DOUBLE
105225: EQUAL
105226: IFTRUE 105230
105228: GO 105241
105230: POP
// bc_type := b_ext_track ; 23 :
105231: LD_ADDR_OWVAR 42
105235: PUSH
105236: LD_INT 16
105238: ST_TO_ADDR
105239: GO 105470
105241: LD_INT 23
105243: DOUBLE
105244: EQUAL
105245: IFTRUE 105249
105247: GO 105260
105249: POP
// bc_type := b_ext_laser ; 24 :
105250: LD_ADDR_OWVAR 42
105254: PUSH
105255: LD_INT 25
105257: ST_TO_ADDR
105258: GO 105470
105260: LD_INT 24
105262: DOUBLE
105263: EQUAL
105264: IFTRUE 105268
105266: GO 105279
105268: POP
// bc_type := b_control_tower ; 25 :
105269: LD_ADDR_OWVAR 42
105273: PUSH
105274: LD_INT 36
105276: ST_TO_ADDR
105277: GO 105470
105279: LD_INT 25
105281: DOUBLE
105282: EQUAL
105283: IFTRUE 105287
105285: GO 105298
105287: POP
// bc_type := b_breastwork ; 26 :
105288: LD_ADDR_OWVAR 42
105292: PUSH
105293: LD_INT 31
105295: ST_TO_ADDR
105296: GO 105470
105298: LD_INT 26
105300: DOUBLE
105301: EQUAL
105302: IFTRUE 105306
105304: GO 105317
105306: POP
// bc_type := b_bunker ; 27 :
105307: LD_ADDR_OWVAR 42
105311: PUSH
105312: LD_INT 32
105314: ST_TO_ADDR
105315: GO 105470
105317: LD_INT 27
105319: DOUBLE
105320: EQUAL
105321: IFTRUE 105325
105323: GO 105336
105325: POP
// bc_type := b_turret ; 28 :
105326: LD_ADDR_OWVAR 42
105330: PUSH
105331: LD_INT 33
105333: ST_TO_ADDR
105334: GO 105470
105336: LD_INT 28
105338: DOUBLE
105339: EQUAL
105340: IFTRUE 105344
105342: GO 105355
105344: POP
// bc_type := b_armoury ; 29 :
105345: LD_ADDR_OWVAR 42
105349: PUSH
105350: LD_INT 4
105352: ST_TO_ADDR
105353: GO 105470
105355: LD_INT 29
105357: DOUBLE
105358: EQUAL
105359: IFTRUE 105363
105361: GO 105374
105363: POP
// bc_type := b_barracks ; 30 :
105364: LD_ADDR_OWVAR 42
105368: PUSH
105369: LD_INT 5
105371: ST_TO_ADDR
105372: GO 105470
105374: LD_INT 30
105376: DOUBLE
105377: EQUAL
105378: IFTRUE 105382
105380: GO 105393
105382: POP
// bc_type := b_solar_power ; 31 :
105383: LD_ADDR_OWVAR 42
105387: PUSH
105388: LD_INT 27
105390: ST_TO_ADDR
105391: GO 105470
105393: LD_INT 31
105395: DOUBLE
105396: EQUAL
105397: IFTRUE 105401
105399: GO 105412
105401: POP
// bc_type := b_oil_power ; 32 :
105402: LD_ADDR_OWVAR 42
105406: PUSH
105407: LD_INT 26
105409: ST_TO_ADDR
105410: GO 105470
105412: LD_INT 32
105414: DOUBLE
105415: EQUAL
105416: IFTRUE 105420
105418: GO 105431
105420: POP
// bc_type := b_siberite_power ; 33 :
105421: LD_ADDR_OWVAR 42
105425: PUSH
105426: LD_INT 28
105428: ST_TO_ADDR
105429: GO 105470
105431: LD_INT 33
105433: DOUBLE
105434: EQUAL
105435: IFTRUE 105439
105437: GO 105450
105439: POP
// bc_type := b_oil_mine ; 34 :
105440: LD_ADDR_OWVAR 42
105444: PUSH
105445: LD_INT 29
105447: ST_TO_ADDR
105448: GO 105470
105450: LD_INT 34
105452: DOUBLE
105453: EQUAL
105454: IFTRUE 105458
105456: GO 105469
105458: POP
// bc_type := b_siberite_mine ; end ;
105459: LD_ADDR_OWVAR 42
105463: PUSH
105464: LD_INT 30
105466: ST_TO_ADDR
105467: GO 105470
105469: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105470: LD_ADDR_VAR 0 8
105474: PUSH
105475: LD_VAR 0 5
105479: PPUSH
105480: LD_VAR 0 6
105484: PPUSH
105485: LD_VAR 0 3
105489: PPUSH
105490: CALL_OW 47
105494: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105495: LD_OWVAR 42
105499: PUSH
105500: LD_INT 32
105502: PUSH
105503: LD_INT 33
105505: PUSH
105506: EMPTY
105507: LIST
105508: LIST
105509: IN
105510: IFFALSE 105526
// PlaceWeaponTurret ( b , weapon ) ;
105512: LD_VAR 0 8
105516: PPUSH
105517: LD_VAR 0 4
105521: PPUSH
105522: CALL_OW 431
// end ;
105526: LD_VAR 0 7
105530: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105531: LD_INT 0
105533: PPUSH
105534: PPUSH
105535: PPUSH
105536: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105537: LD_ADDR_VAR 0 4
105541: PUSH
105542: LD_INT 22
105544: PUSH
105545: LD_OWVAR 2
105549: PUSH
105550: EMPTY
105551: LIST
105552: LIST
105553: PUSH
105554: LD_INT 2
105556: PUSH
105557: LD_INT 30
105559: PUSH
105560: LD_INT 0
105562: PUSH
105563: EMPTY
105564: LIST
105565: LIST
105566: PUSH
105567: LD_INT 30
105569: PUSH
105570: LD_INT 1
105572: PUSH
105573: EMPTY
105574: LIST
105575: LIST
105576: PUSH
105577: EMPTY
105578: LIST
105579: LIST
105580: LIST
105581: PUSH
105582: EMPTY
105583: LIST
105584: LIST
105585: PPUSH
105586: CALL_OW 69
105590: ST_TO_ADDR
// if not tmp then
105591: LD_VAR 0 4
105595: NOT
105596: IFFALSE 105600
// exit ;
105598: GO 105659
// for i in tmp do
105600: LD_ADDR_VAR 0 2
105604: PUSH
105605: LD_VAR 0 4
105609: PUSH
105610: FOR_IN
105611: IFFALSE 105657
// for j = 1 to 3 do
105613: LD_ADDR_VAR 0 3
105617: PUSH
105618: DOUBLE
105619: LD_INT 1
105621: DEC
105622: ST_TO_ADDR
105623: LD_INT 3
105625: PUSH
105626: FOR_TO
105627: IFFALSE 105653
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105629: LD_VAR 0 2
105633: PPUSH
105634: CALL_OW 274
105638: PPUSH
105639: LD_VAR 0 3
105643: PPUSH
105644: LD_INT 99999
105646: PPUSH
105647: CALL_OW 277
105651: GO 105626
105653: POP
105654: POP
105655: GO 105610
105657: POP
105658: POP
// end ;
105659: LD_VAR 0 1
105663: RET
// export function hHackSetLevel10 ; var i , j ; begin
105664: LD_INT 0
105666: PPUSH
105667: PPUSH
105668: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105669: LD_ADDR_VAR 0 2
105673: PUSH
105674: LD_INT 21
105676: PUSH
105677: LD_INT 1
105679: PUSH
105680: EMPTY
105681: LIST
105682: LIST
105683: PPUSH
105684: CALL_OW 69
105688: PUSH
105689: FOR_IN
105690: IFFALSE 105742
// if IsSelected ( i ) then
105692: LD_VAR 0 2
105696: PPUSH
105697: CALL_OW 306
105701: IFFALSE 105740
// begin for j := 1 to 4 do
105703: LD_ADDR_VAR 0 3
105707: PUSH
105708: DOUBLE
105709: LD_INT 1
105711: DEC
105712: ST_TO_ADDR
105713: LD_INT 4
105715: PUSH
105716: FOR_TO
105717: IFFALSE 105738
// SetSkill ( i , j , 10 ) ;
105719: LD_VAR 0 2
105723: PPUSH
105724: LD_VAR 0 3
105728: PPUSH
105729: LD_INT 10
105731: PPUSH
105732: CALL_OW 237
105736: GO 105716
105738: POP
105739: POP
// end ;
105740: GO 105689
105742: POP
105743: POP
// end ;
105744: LD_VAR 0 1
105748: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105749: LD_INT 0
105751: PPUSH
105752: PPUSH
105753: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105754: LD_ADDR_VAR 0 2
105758: PUSH
105759: LD_INT 22
105761: PUSH
105762: LD_OWVAR 2
105766: PUSH
105767: EMPTY
105768: LIST
105769: LIST
105770: PUSH
105771: LD_INT 21
105773: PUSH
105774: LD_INT 1
105776: PUSH
105777: EMPTY
105778: LIST
105779: LIST
105780: PUSH
105781: EMPTY
105782: LIST
105783: LIST
105784: PPUSH
105785: CALL_OW 69
105789: PUSH
105790: FOR_IN
105791: IFFALSE 105832
// begin for j := 1 to 4 do
105793: LD_ADDR_VAR 0 3
105797: PUSH
105798: DOUBLE
105799: LD_INT 1
105801: DEC
105802: ST_TO_ADDR
105803: LD_INT 4
105805: PUSH
105806: FOR_TO
105807: IFFALSE 105828
// SetSkill ( i , j , 10 ) ;
105809: LD_VAR 0 2
105813: PPUSH
105814: LD_VAR 0 3
105818: PPUSH
105819: LD_INT 10
105821: PPUSH
105822: CALL_OW 237
105826: GO 105806
105828: POP
105829: POP
// end ;
105830: GO 105790
105832: POP
105833: POP
// end ;
105834: LD_VAR 0 1
105838: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105839: LD_INT 0
105841: PPUSH
// uc_side := your_side ;
105842: LD_ADDR_OWVAR 20
105846: PUSH
105847: LD_OWVAR 2
105851: ST_TO_ADDR
// uc_nation := nation ;
105852: LD_ADDR_OWVAR 21
105856: PUSH
105857: LD_VAR 0 1
105861: ST_TO_ADDR
// InitHc ;
105862: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105866: LD_INT 0
105868: PPUSH
105869: LD_VAR 0 2
105873: PPUSH
105874: LD_VAR 0 3
105878: PPUSH
105879: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105883: LD_VAR 0 4
105887: PPUSH
105888: LD_VAR 0 5
105892: PPUSH
105893: CALL_OW 428
105897: PUSH
105898: LD_INT 0
105900: EQUAL
105901: IFFALSE 105925
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105903: CALL_OW 44
105907: PPUSH
105908: LD_VAR 0 4
105912: PPUSH
105913: LD_VAR 0 5
105917: PPUSH
105918: LD_INT 1
105920: PPUSH
105921: CALL_OW 48
// end ;
105925: LD_VAR 0 6
105929: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105930: LD_INT 0
105932: PPUSH
105933: PPUSH
// uc_side := your_side ;
105934: LD_ADDR_OWVAR 20
105938: PUSH
105939: LD_OWVAR 2
105943: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105944: LD_VAR 0 1
105948: PUSH
105949: LD_INT 1
105951: PUSH
105952: LD_INT 2
105954: PUSH
105955: LD_INT 3
105957: PUSH
105958: LD_INT 4
105960: PUSH
105961: LD_INT 5
105963: PUSH
105964: EMPTY
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: IN
105971: IFFALSE 105983
// uc_nation := nation_american else
105973: LD_ADDR_OWVAR 21
105977: PUSH
105978: LD_INT 1
105980: ST_TO_ADDR
105981: GO 106026
// if chassis in [ 11 , 12 , 13 , 14 ] then
105983: LD_VAR 0 1
105987: PUSH
105988: LD_INT 11
105990: PUSH
105991: LD_INT 12
105993: PUSH
105994: LD_INT 13
105996: PUSH
105997: LD_INT 14
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: LIST
106004: LIST
106005: IN
106006: IFFALSE 106018
// uc_nation := nation_arabian else
106008: LD_ADDR_OWVAR 21
106012: PUSH
106013: LD_INT 2
106015: ST_TO_ADDR
106016: GO 106026
// uc_nation := nation_russian ;
106018: LD_ADDR_OWVAR 21
106022: PUSH
106023: LD_INT 3
106025: ST_TO_ADDR
// vc_chassis := chassis ;
106026: LD_ADDR_OWVAR 37
106030: PUSH
106031: LD_VAR 0 1
106035: ST_TO_ADDR
// vc_engine := engine ;
106036: LD_ADDR_OWVAR 39
106040: PUSH
106041: LD_VAR 0 2
106045: ST_TO_ADDR
// vc_control := control ;
106046: LD_ADDR_OWVAR 38
106050: PUSH
106051: LD_VAR 0 3
106055: ST_TO_ADDR
// vc_weapon := weapon ;
106056: LD_ADDR_OWVAR 40
106060: PUSH
106061: LD_VAR 0 4
106065: ST_TO_ADDR
// un := CreateVehicle ;
106066: LD_ADDR_VAR 0 8
106070: PUSH
106071: CALL_OW 45
106075: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106076: LD_VAR 0 8
106080: PPUSH
106081: LD_INT 0
106083: PPUSH
106084: LD_INT 5
106086: PPUSH
106087: CALL_OW 12
106091: PPUSH
106092: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106096: LD_VAR 0 8
106100: PPUSH
106101: LD_VAR 0 5
106105: PPUSH
106106: LD_VAR 0 6
106110: PPUSH
106111: LD_INT 1
106113: PPUSH
106114: CALL_OW 48
// end ;
106118: LD_VAR 0 7
106122: RET
// export hInvincible ; every 1 do
106123: GO 106125
106125: DISABLE
// hInvincible := [ ] ;
106126: LD_ADDR_EXP 166
106130: PUSH
106131: EMPTY
106132: ST_TO_ADDR
106133: END
// every 10 do var i ;
106134: GO 106136
106136: DISABLE
106137: LD_INT 0
106139: PPUSH
// begin enable ;
106140: ENABLE
// if not hInvincible then
106141: LD_EXP 166
106145: NOT
106146: IFFALSE 106150
// exit ;
106148: GO 106194
// for i in hInvincible do
106150: LD_ADDR_VAR 0 1
106154: PUSH
106155: LD_EXP 166
106159: PUSH
106160: FOR_IN
106161: IFFALSE 106192
// if GetLives ( i ) < 1000 then
106163: LD_VAR 0 1
106167: PPUSH
106168: CALL_OW 256
106172: PUSH
106173: LD_INT 1000
106175: LESS
106176: IFFALSE 106190
// SetLives ( i , 1000 ) ;
106178: LD_VAR 0 1
106182: PPUSH
106183: LD_INT 1000
106185: PPUSH
106186: CALL_OW 234
106190: GO 106160
106192: POP
106193: POP
// end ;
106194: PPOPN 1
106196: END
// export function hHackInvincible ; var i ; begin
106197: LD_INT 0
106199: PPUSH
106200: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106201: LD_ADDR_VAR 0 2
106205: PUSH
106206: LD_INT 2
106208: PUSH
106209: LD_INT 21
106211: PUSH
106212: LD_INT 1
106214: PUSH
106215: EMPTY
106216: LIST
106217: LIST
106218: PUSH
106219: LD_INT 21
106221: PUSH
106222: LD_INT 2
106224: PUSH
106225: EMPTY
106226: LIST
106227: LIST
106228: PUSH
106229: EMPTY
106230: LIST
106231: LIST
106232: LIST
106233: PPUSH
106234: CALL_OW 69
106238: PUSH
106239: FOR_IN
106240: IFFALSE 106301
// if IsSelected ( i ) then
106242: LD_VAR 0 2
106246: PPUSH
106247: CALL_OW 306
106251: IFFALSE 106299
// begin if i in hInvincible then
106253: LD_VAR 0 2
106257: PUSH
106258: LD_EXP 166
106262: IN
106263: IFFALSE 106283
// hInvincible := hInvincible diff i else
106265: LD_ADDR_EXP 166
106269: PUSH
106270: LD_EXP 166
106274: PUSH
106275: LD_VAR 0 2
106279: DIFF
106280: ST_TO_ADDR
106281: GO 106299
// hInvincible := hInvincible union i ;
106283: LD_ADDR_EXP 166
106287: PUSH
106288: LD_EXP 166
106292: PUSH
106293: LD_VAR 0 2
106297: UNION
106298: ST_TO_ADDR
// end ;
106299: GO 106239
106301: POP
106302: POP
// end ;
106303: LD_VAR 0 1
106307: RET
// export function hHackInvisible ; var i , j ; begin
106308: LD_INT 0
106310: PPUSH
106311: PPUSH
106312: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106313: LD_ADDR_VAR 0 2
106317: PUSH
106318: LD_INT 21
106320: PUSH
106321: LD_INT 1
106323: PUSH
106324: EMPTY
106325: LIST
106326: LIST
106327: PPUSH
106328: CALL_OW 69
106332: PUSH
106333: FOR_IN
106334: IFFALSE 106358
// if IsSelected ( i ) then
106336: LD_VAR 0 2
106340: PPUSH
106341: CALL_OW 306
106345: IFFALSE 106356
// ComForceInvisible ( i ) ;
106347: LD_VAR 0 2
106351: PPUSH
106352: CALL_OW 496
106356: GO 106333
106358: POP
106359: POP
// end ;
106360: LD_VAR 0 1
106364: RET
// export function hHackChangeYourSide ; begin
106365: LD_INT 0
106367: PPUSH
// if your_side = 8 then
106368: LD_OWVAR 2
106372: PUSH
106373: LD_INT 8
106375: EQUAL
106376: IFFALSE 106388
// your_side := 0 else
106378: LD_ADDR_OWVAR 2
106382: PUSH
106383: LD_INT 0
106385: ST_TO_ADDR
106386: GO 106402
// your_side := your_side + 1 ;
106388: LD_ADDR_OWVAR 2
106392: PUSH
106393: LD_OWVAR 2
106397: PUSH
106398: LD_INT 1
106400: PLUS
106401: ST_TO_ADDR
// end ;
106402: LD_VAR 0 1
106406: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106407: LD_INT 0
106409: PPUSH
106410: PPUSH
106411: PPUSH
// for i in all_units do
106412: LD_ADDR_VAR 0 2
106416: PUSH
106417: LD_OWVAR 3
106421: PUSH
106422: FOR_IN
106423: IFFALSE 106501
// if IsSelected ( i ) then
106425: LD_VAR 0 2
106429: PPUSH
106430: CALL_OW 306
106434: IFFALSE 106499
// begin j := GetSide ( i ) ;
106436: LD_ADDR_VAR 0 3
106440: PUSH
106441: LD_VAR 0 2
106445: PPUSH
106446: CALL_OW 255
106450: ST_TO_ADDR
// if j = 8 then
106451: LD_VAR 0 3
106455: PUSH
106456: LD_INT 8
106458: EQUAL
106459: IFFALSE 106471
// j := 0 else
106461: LD_ADDR_VAR 0 3
106465: PUSH
106466: LD_INT 0
106468: ST_TO_ADDR
106469: GO 106485
// j := j + 1 ;
106471: LD_ADDR_VAR 0 3
106475: PUSH
106476: LD_VAR 0 3
106480: PUSH
106481: LD_INT 1
106483: PLUS
106484: ST_TO_ADDR
// SetSide ( i , j ) ;
106485: LD_VAR 0 2
106489: PPUSH
106490: LD_VAR 0 3
106494: PPUSH
106495: CALL_OW 235
// end ;
106499: GO 106422
106501: POP
106502: POP
// end ;
106503: LD_VAR 0 1
106507: RET
// export function hHackFog ; begin
106508: LD_INT 0
106510: PPUSH
// FogOff ( true ) ;
106511: LD_INT 1
106513: PPUSH
106514: CALL_OW 344
// end ;
106518: LD_VAR 0 1
106522: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106523: LD_INT 0
106525: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106526: LD_VAR 0 1
106530: PPUSH
106531: LD_VAR 0 2
106535: PPUSH
106536: LD_VAR 0 3
106540: PPUSH
106541: LD_INT 1
106543: PPUSH
106544: LD_INT 1
106546: PPUSH
106547: CALL_OW 483
// CenterOnXY ( x , y ) ;
106551: LD_VAR 0 2
106555: PPUSH
106556: LD_VAR 0 3
106560: PPUSH
106561: CALL_OW 84
// end ;
106565: LD_VAR 0 4
106569: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106570: LD_INT 0
106572: PPUSH
106573: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106574: LD_VAR 0 1
106578: NOT
106579: IFTRUE 106598
106581: PUSH
106582: LD_VAR 0 2
106586: PPUSH
106587: LD_VAR 0 3
106591: PPUSH
106592: CALL_OW 488
106596: NOT
106597: OR
106598: IFTRUE 106633
106600: PUSH
106601: LD_VAR 0 1
106605: PPUSH
106606: CALL_OW 266
106610: PUSH
106611: LD_INT 3
106613: NONEQUAL
106614: IFFALSE 106632
106616: PUSH
106617: LD_VAR 0 1
106621: PPUSH
106622: CALL_OW 247
106626: PUSH
106627: LD_INT 1
106629: EQUAL
106630: NOT
106631: AND
106632: OR
106633: IFFALSE 106637
// exit ;
106635: GO 106919
// if GetType ( factory ) = unit_human then
106637: LD_VAR 0 1
106641: PPUSH
106642: CALL_OW 247
106646: PUSH
106647: LD_INT 1
106649: EQUAL
106650: IFFALSE 106667
// factory := IsInUnit ( factory ) ;
106652: LD_ADDR_VAR 0 1
106656: PUSH
106657: LD_VAR 0 1
106661: PPUSH
106662: CALL_OW 310
106666: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106667: LD_VAR 0 1
106671: PPUSH
106672: CALL_OW 266
106676: PUSH
106677: LD_INT 3
106679: NONEQUAL
106680: IFFALSE 106684
// exit ;
106682: GO 106919
// for i := 1 to Count ( factoryWaypoints ) do
106684: LD_ADDR_VAR 0 5
106688: PUSH
106689: DOUBLE
106690: LD_INT 1
106692: DEC
106693: ST_TO_ADDR
106694: LD_EXP 167
106698: PPUSH
106699: CALL 19598 0 1
106703: PUSH
106704: FOR_TO
106705: IFFALSE 106867
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
106707: LD_VAR 0 2
106711: PPUSH
106712: LD_VAR 0 3
106716: PPUSH
106717: CALL_OW 428
106721: PUSH
106722: LD_EXP 167
106726: PUSH
106727: LD_VAR 0 5
106731: ARRAY
106732: PUSH
106733: LD_INT 2
106735: ARRAY
106736: EQUAL
106737: IFFALSE 106769
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106739: LD_ADDR_EXP 167
106743: PUSH
106744: LD_EXP 167
106748: PPUSH
106749: LD_VAR 0 5
106753: PPUSH
106754: CALL_OW 3
106758: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106759: CALL 106924 0 0
// exit ;
106763: POP
106764: POP
106765: GO 106919
// end else
106767: GO 106865
// if factory = factoryWaypoints [ i ] [ 2 ] then
106769: LD_VAR 0 1
106773: PUSH
106774: LD_EXP 167
106778: PUSH
106779: LD_VAR 0 5
106783: ARRAY
106784: PUSH
106785: LD_INT 2
106787: ARRAY
106788: EQUAL
106789: IFFALSE 106865
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106791: LD_ADDR_EXP 167
106795: PUSH
106796: LD_EXP 167
106800: PPUSH
106801: LD_VAR 0 5
106805: PPUSH
106806: CALL_OW 3
106810: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106811: LD_ADDR_EXP 167
106815: PUSH
106816: LD_EXP 167
106820: PPUSH
106821: LD_VAR 0 1
106825: PPUSH
106826: CALL_OW 255
106830: PUSH
106831: LD_VAR 0 1
106835: PUSH
106836: LD_VAR 0 2
106840: PUSH
106841: LD_VAR 0 3
106845: PUSH
106846: EMPTY
106847: LIST
106848: LIST
106849: LIST
106850: LIST
106851: PPUSH
106852: CALL 55530 0 2
106856: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106857: CALL 106924 0 0
// exit ;
106861: POP
106862: POP
106863: GO 106919
// end ; end ;
106865: GO 106704
106867: POP
106868: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106869: LD_ADDR_EXP 167
106873: PUSH
106874: LD_EXP 167
106878: PPUSH
106879: LD_VAR 0 1
106883: PPUSH
106884: CALL_OW 255
106888: PUSH
106889: LD_VAR 0 1
106893: PUSH
106894: LD_VAR 0 2
106898: PUSH
106899: LD_VAR 0 3
106903: PUSH
106904: EMPTY
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: PPUSH
106910: CALL 55530 0 2
106914: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106915: CALL 106924 0 0
// end ;
106919: LD_VAR 0 4
106923: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106924: LD_INT 0
106926: PPUSH
106927: PPUSH
106928: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106929: LD_STRING resetFactoryWaypoint();
106931: PPUSH
106932: CALL_OW 559
// if factoryWaypoints then
106936: LD_EXP 167
106940: IFFALSE 107061
// begin list := factoryWaypoints ;
106942: LD_ADDR_VAR 0 3
106946: PUSH
106947: LD_EXP 167
106951: ST_TO_ADDR
// for i := 1 to list do
106952: LD_ADDR_VAR 0 2
106956: PUSH
106957: DOUBLE
106958: LD_INT 1
106960: DEC
106961: ST_TO_ADDR
106962: LD_VAR 0 3
106966: PUSH
106967: FOR_TO
106968: IFFALSE 107059
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106970: LD_STRING setFactoryWaypointXY(
106972: PUSH
106973: LD_VAR 0 3
106977: PUSH
106978: LD_VAR 0 2
106982: ARRAY
106983: PUSH
106984: LD_INT 1
106986: ARRAY
106987: STR
106988: PUSH
106989: LD_STRING ,
106991: STR
106992: PUSH
106993: LD_VAR 0 3
106997: PUSH
106998: LD_VAR 0 2
107002: ARRAY
107003: PUSH
107004: LD_INT 2
107006: ARRAY
107007: STR
107008: PUSH
107009: LD_STRING ,
107011: STR
107012: PUSH
107013: LD_VAR 0 3
107017: PUSH
107018: LD_VAR 0 2
107022: ARRAY
107023: PUSH
107024: LD_INT 3
107026: ARRAY
107027: STR
107028: PUSH
107029: LD_STRING ,
107031: STR
107032: PUSH
107033: LD_VAR 0 3
107037: PUSH
107038: LD_VAR 0 2
107042: ARRAY
107043: PUSH
107044: LD_INT 4
107046: ARRAY
107047: STR
107048: PUSH
107049: LD_STRING )
107051: STR
107052: PPUSH
107053: CALL_OW 559
107057: GO 106967
107059: POP
107060: POP
// end ; end ;
107061: LD_VAR 0 1
107065: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107066: LD_INT 0
107068: PPUSH
// if HexInfo ( x , y ) = warehouse then
107069: LD_VAR 0 2
107073: PPUSH
107074: LD_VAR 0 3
107078: PPUSH
107079: CALL_OW 428
107083: PUSH
107084: LD_VAR 0 1
107088: EQUAL
107089: IFFALSE 107116
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107091: LD_ADDR_EXP 169
107095: PUSH
107096: LD_EXP 169
107100: PPUSH
107101: LD_VAR 0 1
107105: PPUSH
107106: LD_INT 0
107108: PPUSH
107109: CALL_OW 1
107113: ST_TO_ADDR
107114: GO 107167
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107116: LD_ADDR_EXP 169
107120: PUSH
107121: LD_EXP 169
107125: PPUSH
107126: LD_VAR 0 1
107130: PPUSH
107131: LD_VAR 0 1
107135: PPUSH
107136: CALL_OW 255
107140: PUSH
107141: LD_VAR 0 1
107145: PUSH
107146: LD_VAR 0 2
107150: PUSH
107151: LD_VAR 0 3
107155: PUSH
107156: EMPTY
107157: LIST
107158: LIST
107159: LIST
107160: LIST
107161: PPUSH
107162: CALL_OW 1
107166: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107167: CALL 107176 0 0
// end ;
107171: LD_VAR 0 4
107175: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107176: LD_INT 0
107178: PPUSH
107179: PPUSH
107180: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107181: LD_STRING resetWarehouseGatheringPoints();
107183: PPUSH
107184: CALL_OW 559
// if warehouseGatheringPoints then
107188: LD_EXP 169
107192: IFFALSE 107318
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107194: LD_ADDR_VAR 0 3
107198: PUSH
107199: LD_EXP 169
107203: PPUSH
107204: CALL 59464 0 1
107208: ST_TO_ADDR
// for i := 1 to list do
107209: LD_ADDR_VAR 0 2
107213: PUSH
107214: DOUBLE
107215: LD_INT 1
107217: DEC
107218: ST_TO_ADDR
107219: LD_VAR 0 3
107223: PUSH
107224: FOR_TO
107225: IFFALSE 107316
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107227: LD_STRING setWarehouseGatheringPointXY(
107229: PUSH
107230: LD_VAR 0 3
107234: PUSH
107235: LD_VAR 0 2
107239: ARRAY
107240: PUSH
107241: LD_INT 1
107243: ARRAY
107244: STR
107245: PUSH
107246: LD_STRING ,
107248: STR
107249: PUSH
107250: LD_VAR 0 3
107254: PUSH
107255: LD_VAR 0 2
107259: ARRAY
107260: PUSH
107261: LD_INT 2
107263: ARRAY
107264: STR
107265: PUSH
107266: LD_STRING ,
107268: STR
107269: PUSH
107270: LD_VAR 0 3
107274: PUSH
107275: LD_VAR 0 2
107279: ARRAY
107280: PUSH
107281: LD_INT 3
107283: ARRAY
107284: STR
107285: PUSH
107286: LD_STRING ,
107288: STR
107289: PUSH
107290: LD_VAR 0 3
107294: PUSH
107295: LD_VAR 0 2
107299: ARRAY
107300: PUSH
107301: LD_INT 4
107303: ARRAY
107304: STR
107305: PUSH
107306: LD_STRING )
107308: STR
107309: PPUSH
107310: CALL_OW 559
107314: GO 107224
107316: POP
107317: POP
// end ; end ;
107318: LD_VAR 0 1
107322: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107323: LD_EXP 169
107327: IFFALSE 108022
107329: GO 107331
107331: DISABLE
107332: LD_INT 0
107334: PPUSH
107335: PPUSH
107336: PPUSH
107337: PPUSH
107338: PPUSH
107339: PPUSH
107340: PPUSH
107341: PPUSH
107342: PPUSH
// begin enable ;
107343: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107344: LD_ADDR_VAR 0 3
107348: PUSH
107349: LD_EXP 169
107353: PPUSH
107354: CALL 59464 0 1
107358: ST_TO_ADDR
// if not list then
107359: LD_VAR 0 3
107363: NOT
107364: IFFALSE 107368
// exit ;
107366: GO 108022
// for i := 1 to list do
107368: LD_ADDR_VAR 0 1
107372: PUSH
107373: DOUBLE
107374: LD_INT 1
107376: DEC
107377: ST_TO_ADDR
107378: LD_VAR 0 3
107382: PUSH
107383: FOR_TO
107384: IFFALSE 108020
// begin depot := list [ i ] [ 2 ] ;
107386: LD_ADDR_VAR 0 8
107390: PUSH
107391: LD_VAR 0 3
107395: PUSH
107396: LD_VAR 0 1
107400: ARRAY
107401: PUSH
107402: LD_INT 2
107404: ARRAY
107405: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107406: LD_ADDR_VAR 0 5
107410: PUSH
107411: LD_VAR 0 3
107415: PUSH
107416: LD_VAR 0 1
107420: ARRAY
107421: PUSH
107422: LD_INT 1
107424: ARRAY
107425: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107426: LD_VAR 0 8
107430: PPUSH
107431: CALL_OW 301
107435: IFTRUE 107454
107437: PUSH
107438: LD_VAR 0 5
107442: PUSH
107443: LD_VAR 0 8
107447: PPUSH
107448: CALL_OW 255
107452: NONEQUAL
107453: OR
107454: IFFALSE 107483
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107456: LD_ADDR_EXP 169
107460: PUSH
107461: LD_EXP 169
107465: PPUSH
107466: LD_VAR 0 8
107470: PPUSH
107471: LD_INT 0
107473: PPUSH
107474: CALL_OW 1
107478: ST_TO_ADDR
// exit ;
107479: POP
107480: POP
107481: GO 108022
// end ; x := list [ i ] [ 3 ] ;
107483: LD_ADDR_VAR 0 6
107487: PUSH
107488: LD_VAR 0 3
107492: PUSH
107493: LD_VAR 0 1
107497: ARRAY
107498: PUSH
107499: LD_INT 3
107501: ARRAY
107502: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107503: LD_ADDR_VAR 0 7
107507: PUSH
107508: LD_VAR 0 3
107512: PUSH
107513: LD_VAR 0 1
107517: ARRAY
107518: PUSH
107519: LD_INT 4
107521: ARRAY
107522: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107523: LD_ADDR_VAR 0 9
107527: PUSH
107528: LD_VAR 0 6
107532: PPUSH
107533: LD_VAR 0 7
107537: PPUSH
107538: LD_INT 16
107540: PPUSH
107541: CALL 58038 0 3
107545: ST_TO_ADDR
// if not cratesNearbyPoint then
107546: LD_VAR 0 9
107550: NOT
107551: IFFALSE 107557
// exit ;
107553: POP
107554: POP
107555: GO 108022
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107557: LD_ADDR_VAR 0 4
107561: PUSH
107562: LD_INT 22
107564: PUSH
107565: LD_VAR 0 5
107569: PUSH
107570: EMPTY
107571: LIST
107572: LIST
107573: PUSH
107574: LD_INT 3
107576: PUSH
107577: LD_INT 60
107579: PUSH
107580: EMPTY
107581: LIST
107582: PUSH
107583: EMPTY
107584: LIST
107585: LIST
107586: PUSH
107587: LD_INT 91
107589: PUSH
107590: LD_VAR 0 8
107594: PUSH
107595: LD_INT 6
107597: PUSH
107598: EMPTY
107599: LIST
107600: LIST
107601: LIST
107602: PUSH
107603: LD_INT 2
107605: PUSH
107606: LD_INT 25
107608: PUSH
107609: LD_INT 2
107611: PUSH
107612: EMPTY
107613: LIST
107614: LIST
107615: PUSH
107616: LD_INT 25
107618: PUSH
107619: LD_INT 16
107621: PUSH
107622: EMPTY
107623: LIST
107624: LIST
107625: PUSH
107626: EMPTY
107627: LIST
107628: LIST
107629: LIST
107630: PUSH
107631: EMPTY
107632: LIST
107633: LIST
107634: LIST
107635: LIST
107636: PPUSH
107637: CALL_OW 69
107641: PUSH
107642: LD_VAR 0 8
107646: PPUSH
107647: CALL_OW 313
107651: PPUSH
107652: LD_INT 3
107654: PUSH
107655: LD_INT 60
107657: PUSH
107658: EMPTY
107659: LIST
107660: PUSH
107661: EMPTY
107662: LIST
107663: LIST
107664: PUSH
107665: LD_INT 2
107667: PUSH
107668: LD_INT 25
107670: PUSH
107671: LD_INT 2
107673: PUSH
107674: EMPTY
107675: LIST
107676: LIST
107677: PUSH
107678: LD_INT 25
107680: PUSH
107681: LD_INT 16
107683: PUSH
107684: EMPTY
107685: LIST
107686: LIST
107687: PUSH
107688: EMPTY
107689: LIST
107690: LIST
107691: LIST
107692: PUSH
107693: EMPTY
107694: LIST
107695: LIST
107696: PPUSH
107697: CALL_OW 72
107701: UNION
107702: ST_TO_ADDR
// if tmp then
107703: LD_VAR 0 4
107707: IFFALSE 107787
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107709: LD_ADDR_VAR 0 4
107713: PUSH
107714: LD_VAR 0 4
107718: PPUSH
107719: LD_INT 3
107721: PPUSH
107722: CALL 55845 0 2
107726: ST_TO_ADDR
// for j in tmp do
107727: LD_ADDR_VAR 0 2
107731: PUSH
107732: LD_VAR 0 4
107736: PUSH
107737: FOR_IN
107738: IFFALSE 107781
// begin if IsInUnit ( j ) then
107740: LD_VAR 0 2
107744: PPUSH
107745: CALL_OW 310
107749: IFFALSE 107760
// ComExit ( j ) ;
107751: LD_VAR 0 2
107755: PPUSH
107756: CALL 55928 0 1
// AddComCollect ( j , x , y ) ;
107760: LD_VAR 0 2
107764: PPUSH
107765: LD_VAR 0 6
107769: PPUSH
107770: LD_VAR 0 7
107774: PPUSH
107775: CALL_OW 177
// end ;
107779: GO 107737
107781: POP
107782: POP
// exit ;
107783: POP
107784: POP
107785: GO 108022
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107787: LD_ADDR_VAR 0 4
107791: PUSH
107792: LD_INT 22
107794: PUSH
107795: LD_VAR 0 5
107799: PUSH
107800: EMPTY
107801: LIST
107802: LIST
107803: PUSH
107804: LD_INT 91
107806: PUSH
107807: LD_VAR 0 8
107811: PUSH
107812: LD_INT 8
107814: PUSH
107815: EMPTY
107816: LIST
107817: LIST
107818: LIST
107819: PUSH
107820: LD_INT 2
107822: PUSH
107823: LD_INT 34
107825: PUSH
107826: LD_INT 12
107828: PUSH
107829: EMPTY
107830: LIST
107831: LIST
107832: PUSH
107833: LD_INT 34
107835: PUSH
107836: LD_INT 51
107838: PUSH
107839: EMPTY
107840: LIST
107841: LIST
107842: PUSH
107843: LD_INT 34
107845: PUSH
107846: LD_INT 32
107848: PUSH
107849: EMPTY
107850: LIST
107851: LIST
107852: PUSH
107853: LD_INT 34
107855: PUSH
107856: LD_INT 89
107858: PUSH
107859: EMPTY
107860: LIST
107861: LIST
107862: PUSH
107863: EMPTY
107864: LIST
107865: LIST
107866: LIST
107867: LIST
107868: LIST
107869: PUSH
107870: EMPTY
107871: LIST
107872: LIST
107873: LIST
107874: PPUSH
107875: CALL_OW 69
107879: ST_TO_ADDR
// if tmp then
107880: LD_VAR 0 4
107884: IFFALSE 108018
// begin for j in tmp do
107886: LD_ADDR_VAR 0 2
107890: PUSH
107891: LD_VAR 0 4
107895: PUSH
107896: FOR_IN
107897: IFFALSE 108016
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107899: LD_VAR 0 2
107903: PPUSH
107904: CALL_OW 262
107908: PUSH
107909: LD_INT 3
107911: EQUAL
107912: IFTRUE 107929
107914: PUSH
107915: LD_VAR 0 2
107919: PPUSH
107920: CALL_OW 261
107924: PUSH
107925: LD_INT 20
107927: GREATER
107928: OR
107929: IFFALSE 107943
107931: PUSH
107932: LD_VAR 0 2
107936: PPUSH
107937: CALL_OW 314
107941: NOT
107942: AND
107943: IFFALSE 107973
107945: PUSH
107946: LD_VAR 0 2
107950: PPUSH
107951: CALL_OW 263
107955: PUSH
107956: LD_INT 1
107958: NONEQUAL
107959: IFTRUE 107972
107961: PUSH
107962: LD_VAR 0 2
107966: PPUSH
107967: CALL_OW 311
107971: OR
107972: AND
107973: IFFALSE 108014
// begin ComCollect ( j , x , y ) ;
107975: LD_VAR 0 2
107979: PPUSH
107980: LD_VAR 0 6
107984: PPUSH
107985: LD_VAR 0 7
107989: PPUSH
107990: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107994: LD_VAR 0 2
107998: PPUSH
107999: LD_VAR 0 8
108003: PPUSH
108004: CALL_OW 172
// exit ;
108008: POP
108009: POP
108010: POP
108011: POP
108012: GO 108022
// end ;
108014: GO 107896
108016: POP
108017: POP
// end ; end ;
108018: GO 107383
108020: POP
108021: POP
// end ; end_of_file
108022: PPOPN 9
108024: END
// export function SOS_UnitDestroyed ( un ) ; begin
108025: LD_INT 0
108027: PPUSH
// ComRadiation ( un ) ;
108028: LD_VAR 0 1
108032: PPUSH
108033: CALL 109114 0 1
// end ;
108037: LD_VAR 0 2
108041: RET
// export function SOS_UnitKamikazed ( un ) ; begin
108042: LD_INT 0
108044: PPUSH
// ComRadiation ( un ) ;
108045: LD_VAR 0 1
108049: PPUSH
108050: CALL 109114 0 1
// end ;
108054: LD_VAR 0 2
108058: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108059: LD_INT 0
108061: PPUSH
// end ;
108062: LD_VAR 0 4
108066: RET
// export function SOS_Command ( cmd ) ; begin
108067: LD_INT 0
108069: PPUSH
// end ;
108070: LD_VAR 0 2
108074: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108075: LD_INT 0
108077: PPUSH
// end ;
108078: LD_VAR 0 6
108082: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
108083: LD_INT 0
108085: PPUSH
108086: PPUSH
108087: PPUSH
108088: PPUSH
// if not vehicle or not factory then
108089: LD_VAR 0 1
108093: NOT
108094: IFTRUE 108103
108096: PUSH
108097: LD_VAR 0 2
108101: NOT
108102: OR
108103: IFFALSE 108107
// exit ;
108105: GO 108689
// if not factoryWaypoints then
108107: LD_EXP 167
108111: NOT
108112: IFFALSE 108116
// exit ;
108114: GO 108689
// for i := 1 to Count ( factoryWaypoints ) do
108116: LD_ADDR_VAR 0 4
108120: PUSH
108121: DOUBLE
108122: LD_INT 1
108124: DEC
108125: ST_TO_ADDR
108126: LD_EXP 167
108130: PPUSH
108131: CALL 19598 0 1
108135: PUSH
108136: FOR_TO
108137: IFFALSE 108687
// if factoryWaypoints [ i ] [ 2 ] = factory then
108139: LD_EXP 167
108143: PUSH
108144: LD_VAR 0 4
108148: ARRAY
108149: PUSH
108150: LD_INT 2
108152: ARRAY
108153: PUSH
108154: LD_VAR 0 2
108158: EQUAL
108159: IFFALSE 108685
// begin if GetControl ( vehicle ) = control_manual then
108161: LD_VAR 0 1
108165: PPUSH
108166: CALL_OW 263
108170: PUSH
108171: LD_INT 1
108173: EQUAL
108174: IFFALSE 108538
// begin driver := IsDrivenBy ( vehicle ) ;
108176: LD_ADDR_VAR 0 5
108180: PUSH
108181: LD_VAR 0 1
108185: PPUSH
108186: CALL_OW 311
108190: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
108191: LD_VAR 0 5
108195: PUSH
108196: LD_EXP 168
108200: IN
108201: IFTRUE 108215
108203: PUSH
108204: LD_VAR 0 1
108208: PUSH
108209: LD_EXP 168
108213: IN
108214: OR
108215: IFFALSE 108221
// exit ;
108217: POP
108218: POP
108219: GO 108689
// if not HasTask ( driver ) then
108221: LD_VAR 0 5
108225: PPUSH
108226: CALL_OW 314
108230: NOT
108231: IFFALSE 108536
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
108233: LD_ADDR_EXP 168
108237: PUSH
108238: LD_EXP 168
108242: PPUSH
108243: LD_VAR 0 5
108247: PPUSH
108248: CALL 55530 0 2
108252: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
108253: LD_ADDR_EXP 168
108257: PUSH
108258: LD_EXP 168
108262: PPUSH
108263: LD_VAR 0 1
108267: PPUSH
108268: CALL 55530 0 2
108272: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108273: LD_ADDR_VAR 0 6
108277: PUSH
108278: LD_EXP 167
108282: PUSH
108283: LD_VAR 0 4
108287: ARRAY
108288: PUSH
108289: LD_INT 3
108291: ARRAY
108292: PPUSH
108293: LD_EXP 167
108297: PUSH
108298: LD_VAR 0 4
108302: ARRAY
108303: PUSH
108304: LD_INT 4
108306: ARRAY
108307: PPUSH
108308: CALL_OW 428
108312: ST_TO_ADDR
// if hex then
108313: LD_VAR 0 6
108317: IFFALSE 108335
// ComMoveUnit ( driver , hex ) else
108319: LD_VAR 0 5
108323: PPUSH
108324: LD_VAR 0 6
108328: PPUSH
108329: CALL_OW 112
108333: GO 108419
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
108335: LD_VAR 0 1
108339: PPUSH
108340: LD_EXP 167
108344: PUSH
108345: LD_VAR 0 4
108349: ARRAY
108350: PUSH
108351: LD_INT 3
108353: ARRAY
108354: PPUSH
108355: LD_EXP 167
108359: PUSH
108360: LD_VAR 0 4
108364: ARRAY
108365: PUSH
108366: LD_INT 4
108368: ARRAY
108369: PPUSH
108370: CALL_OW 297
108374: PUSH
108375: LD_INT 0
108377: GREATER
108378: IFFALSE 108419
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108380: LD_VAR 0 5
108384: PPUSH
108385: LD_EXP 167
108389: PUSH
108390: LD_VAR 0 4
108394: ARRAY
108395: PUSH
108396: LD_INT 3
108398: ARRAY
108399: PPUSH
108400: LD_EXP 167
108404: PUSH
108405: LD_VAR 0 4
108409: ARRAY
108410: PUSH
108411: LD_INT 4
108413: ARRAY
108414: PPUSH
108415: CALL_OW 111
// AddComExitVehicle ( driver ) ;
108419: LD_VAR 0 5
108423: PPUSH
108424: CALL_OW 181
// if Multiplayer then
108428: LD_OWVAR 4
108432: IFFALSE 108481
// begin repeat wait ( 10 ) ;
108434: LD_INT 10
108436: PPUSH
108437: CALL_OW 67
// until not IsInUnit ( driver ) ;
108441: LD_VAR 0 5
108445: PPUSH
108446: CALL_OW 310
108450: NOT
108451: IFFALSE 108434
// if not HasTask ( driver ) then
108453: LD_VAR 0 5
108457: PPUSH
108458: CALL_OW 314
108462: NOT
108463: IFFALSE 108479
// ComEnterUnit ( driver , factory ) ;
108465: LD_VAR 0 5
108469: PPUSH
108470: LD_VAR 0 2
108474: PPUSH
108475: CALL_OW 120
// end else
108479: GO 108495
// AddComEnterUnit ( driver , factory ) ;
108481: LD_VAR 0 5
108485: PPUSH
108486: LD_VAR 0 2
108490: PPUSH
108491: CALL_OW 180
// wait ( 0 0$1 ) ;
108495: LD_INT 35
108497: PPUSH
108498: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
108502: LD_ADDR_EXP 168
108506: PUSH
108507: LD_EXP 168
108511: PUSH
108512: LD_VAR 0 5
108516: DIFF
108517: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
108518: LD_ADDR_EXP 168
108522: PUSH
108523: LD_EXP 168
108527: PUSH
108528: LD_VAR 0 1
108532: DIFF
108533: ST_TO_ADDR
// break ;
108534: GO 108687
// end ; end else
108536: GO 108685
// if GetControl ( vehicle ) = control_remote then
108538: LD_VAR 0 1
108542: PPUSH
108543: CALL_OW 263
108547: PUSH
108548: LD_INT 2
108550: EQUAL
108551: IFFALSE 108637
// begin wait ( 0 0$2 ) ;
108553: LD_INT 70
108555: PPUSH
108556: CALL_OW 67
// repeat wait ( 10 ) ;
108560: LD_INT 10
108562: PPUSH
108563: CALL_OW 67
// Connect ( vehicle ) ;
108567: LD_VAR 0 1
108571: PPUSH
108572: CALL 25842 0 1
// until IsControledBy ( vehicle ) ;
108576: LD_VAR 0 1
108580: PPUSH
108581: CALL_OW 312
108585: IFFALSE 108560
// wait ( 10 ) ;
108587: LD_INT 10
108589: PPUSH
108590: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108594: LD_VAR 0 1
108598: PPUSH
108599: LD_EXP 167
108603: PUSH
108604: LD_VAR 0 4
108608: ARRAY
108609: PUSH
108610: LD_INT 3
108612: ARRAY
108613: PPUSH
108614: LD_EXP 167
108618: PUSH
108619: LD_VAR 0 4
108623: ARRAY
108624: PUSH
108625: LD_INT 4
108627: ARRAY
108628: PPUSH
108629: CALL_OW 111
// break ;
108633: GO 108687
// end else
108635: GO 108685
// begin wait ( 0 0$3 ) ;
108637: LD_INT 105
108639: PPUSH
108640: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108644: LD_VAR 0 1
108648: PPUSH
108649: LD_EXP 167
108653: PUSH
108654: LD_VAR 0 4
108658: ARRAY
108659: PUSH
108660: LD_INT 3
108662: ARRAY
108663: PPUSH
108664: LD_EXP 167
108668: PUSH
108669: LD_VAR 0 4
108673: ARRAY
108674: PUSH
108675: LD_INT 4
108677: ARRAY
108678: PPUSH
108679: CALL_OW 111
// break ;
108683: GO 108687
// end ; end ;
108685: GO 108136
108687: POP
108688: POP
// end ;
108689: LD_VAR 0 3
108693: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108694: LD_INT 0
108696: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108697: LD_VAR 0 1
108701: PUSH
108702: LD_INT 250
108704: EQUAL
108705: IFFALSE 108722
108707: PUSH
108708: LD_VAR 0 2
108712: PPUSH
108713: CALL_OW 264
108717: PUSH
108718: LD_INT 81
108720: EQUAL
108721: AND
108722: IFFALSE 108743
// MinerPlaceMine ( unit , x , y ) ;
108724: LD_VAR 0 2
108728: PPUSH
108729: LD_VAR 0 4
108733: PPUSH
108734: LD_VAR 0 5
108738: PPUSH
108739: CALL 111875 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108743: LD_VAR 0 1
108747: PUSH
108748: LD_INT 251
108750: EQUAL
108751: IFFALSE 108768
108753: PUSH
108754: LD_VAR 0 2
108758: PPUSH
108759: CALL_OW 264
108763: PUSH
108764: LD_INT 81
108766: EQUAL
108767: AND
108768: IFFALSE 108789
// MinerDetonateMine ( unit , x , y ) ;
108770: LD_VAR 0 2
108774: PPUSH
108775: LD_VAR 0 4
108779: PPUSH
108780: LD_VAR 0 5
108784: PPUSH
108785: CALL 112154 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108789: LD_VAR 0 1
108793: PUSH
108794: LD_INT 252
108796: EQUAL
108797: IFFALSE 108814
108799: PUSH
108800: LD_VAR 0 2
108804: PPUSH
108805: CALL_OW 264
108809: PUSH
108810: LD_INT 81
108812: EQUAL
108813: AND
108814: IFFALSE 108835
// MinerCreateMinefield ( unit , x , y ) ;
108816: LD_VAR 0 2
108820: PPUSH
108821: LD_VAR 0 4
108825: PPUSH
108826: LD_VAR 0 5
108830: PPUSH
108831: CALL 112573 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108835: LD_VAR 0 1
108839: PUSH
108840: LD_INT 253
108842: EQUAL
108843: IFFALSE 108860
108845: PUSH
108846: LD_VAR 0 2
108850: PPUSH
108851: CALL_OW 257
108855: PUSH
108856: LD_INT 5
108858: EQUAL
108859: AND
108860: IFFALSE 108881
// ComBinocular ( unit , x , y ) ;
108862: LD_VAR 0 2
108866: PPUSH
108867: LD_VAR 0 4
108871: PPUSH
108872: LD_VAR 0 5
108876: PPUSH
108877: CALL 112948 0 3
// if selectedUnit then
108881: LD_VAR 0 3
108885: IFFALSE 108945
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108887: LD_VAR 0 1
108891: PUSH
108892: LD_INT 254
108894: EQUAL
108895: IFFALSE 108912
108897: PUSH
108898: LD_VAR 0 2
108902: PPUSH
108903: CALL_OW 264
108907: PUSH
108908: LD_INT 99
108910: EQUAL
108911: AND
108912: IFFALSE 108929
108914: PUSH
108915: LD_VAR 0 3
108919: PPUSH
108920: CALL_OW 263
108924: PUSH
108925: LD_INT 3
108927: EQUAL
108928: AND
108929: IFFALSE 108945
// HackDestroyVehicle ( unit , selectedUnit ) ;
108931: LD_VAR 0 2
108935: PPUSH
108936: LD_VAR 0 3
108940: PPUSH
108941: CALL 111235 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108945: LD_VAR 0 1
108949: PUSH
108950: LD_INT 255
108952: EQUAL
108953: IFFALSE 108977
108955: PUSH
108956: LD_VAR 0 2
108960: PPUSH
108961: CALL_OW 264
108965: PUSH
108966: LD_INT 14
108968: PUSH
108969: LD_INT 53
108971: PUSH
108972: EMPTY
108973: LIST
108974: LIST
108975: IN
108976: AND
108977: IFFALSE 108995
108979: PUSH
108980: LD_VAR 0 4
108984: PPUSH
108985: LD_VAR 0 5
108989: PPUSH
108990: CALL_OW 488
108994: AND
108995: IFFALSE 109019
// CutTreeXYR ( unit , x , y , 12 ) ;
108997: LD_VAR 0 2
109001: PPUSH
109002: LD_VAR 0 4
109006: PPUSH
109007: LD_VAR 0 5
109011: PPUSH
109012: LD_INT 12
109014: PPUSH
109015: CALL 109210 0 4
// if cmd = 256 then
109019: LD_VAR 0 1
109023: PUSH
109024: LD_INT 256
109026: EQUAL
109027: IFFALSE 109048
// SetFactoryWaypoint ( unit , x , y ) ;
109029: LD_VAR 0 2
109033: PPUSH
109034: LD_VAR 0 4
109038: PPUSH
109039: LD_VAR 0 5
109043: PPUSH
109044: CALL 106570 0 3
// if cmd = 257 then
109048: LD_VAR 0 1
109052: PUSH
109053: LD_INT 257
109055: EQUAL
109056: IFFALSE 109077
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109058: LD_VAR 0 2
109062: PPUSH
109063: LD_VAR 0 4
109067: PPUSH
109068: LD_VAR 0 5
109072: PPUSH
109073: CALL 107066 0 3
// if cmd = 258 then
109077: LD_VAR 0 1
109081: PUSH
109082: LD_INT 258
109084: EQUAL
109085: IFFALSE 109109
// BurnTreeXYR ( unit , x , y , 8 ) ;
109087: LD_VAR 0 2
109091: PPUSH
109092: LD_VAR 0 4
109096: PPUSH
109097: LD_VAR 0 5
109101: PPUSH
109102: LD_INT 8
109104: PPUSH
109105: CALL 109610 0 4
// end ;
109109: LD_VAR 0 6
109113: RET
// export function ComRadiation ( un ) ; var eff ; begin
109114: LD_INT 0
109116: PPUSH
109117: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
109118: LD_VAR 0 1
109122: PPUSH
109123: CALL_OW 264
109127: PUSH
109128: LD_INT 91
109130: NONEQUAL
109131: IFFALSE 109135
// exit ;
109133: GO 109205
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109135: LD_INT 68
109137: PPUSH
109138: LD_VAR 0 1
109142: PPUSH
109143: CALL_OW 255
109147: PPUSH
109148: CALL_OW 321
109152: PUSH
109153: LD_INT 2
109155: EQUAL
109156: IFFALSE 109168
// eff := 50 else
109158: LD_ADDR_VAR 0 3
109162: PUSH
109163: LD_INT 50
109165: ST_TO_ADDR
109166: GO 109176
// eff := 25 ;
109168: LD_ADDR_VAR 0 3
109172: PUSH
109173: LD_INT 25
109175: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109176: LD_VAR 0 1
109180: PPUSH
109181: CALL_OW 250
109185: PPUSH
109186: LD_VAR 0 1
109190: PPUSH
109191: CALL_OW 251
109195: PPUSH
109196: LD_VAR 0 3
109200: PPUSH
109201: CALL_OW 495
// end ;
109205: LD_VAR 0 2
109209: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109210: LD_INT 0
109212: PPUSH
109213: PPUSH
109214: PPUSH
109215: PPUSH
109216: PPUSH
109217: PPUSH
109218: PPUSH
109219: PPUSH
109220: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109221: LD_VAR 0 1
109225: PPUSH
109226: CALL_OW 302
109230: NOT
109231: IFTRUE 109250
109233: PUSH
109234: LD_VAR 0 2
109238: PPUSH
109239: LD_VAR 0 3
109243: PPUSH
109244: CALL_OW 488
109248: NOT
109249: OR
109250: IFTRUE 109259
109252: PUSH
109253: LD_VAR 0 4
109257: NOT
109258: OR
109259: IFFALSE 109263
// exit ;
109261: GO 109605
// list := [ ] ;
109263: LD_ADDR_VAR 0 13
109267: PUSH
109268: EMPTY
109269: ST_TO_ADDR
// if x - r < 0 then
109270: LD_VAR 0 2
109274: PUSH
109275: LD_VAR 0 4
109279: MINUS
109280: PUSH
109281: LD_INT 0
109283: LESS
109284: IFFALSE 109296
// min_x := 0 else
109286: LD_ADDR_VAR 0 7
109290: PUSH
109291: LD_INT 0
109293: ST_TO_ADDR
109294: GO 109312
// min_x := x - r ;
109296: LD_ADDR_VAR 0 7
109300: PUSH
109301: LD_VAR 0 2
109305: PUSH
109306: LD_VAR 0 4
109310: MINUS
109311: ST_TO_ADDR
// if y - r < 0 then
109312: LD_VAR 0 3
109316: PUSH
109317: LD_VAR 0 4
109321: MINUS
109322: PUSH
109323: LD_INT 0
109325: LESS
109326: IFFALSE 109338
// min_y := 0 else
109328: LD_ADDR_VAR 0 8
109332: PUSH
109333: LD_INT 0
109335: ST_TO_ADDR
109336: GO 109354
// min_y := y - r ;
109338: LD_ADDR_VAR 0 8
109342: PUSH
109343: LD_VAR 0 3
109347: PUSH
109348: LD_VAR 0 4
109352: MINUS
109353: ST_TO_ADDR
// max_x := x + r ;
109354: LD_ADDR_VAR 0 9
109358: PUSH
109359: LD_VAR 0 2
109363: PUSH
109364: LD_VAR 0 4
109368: PLUS
109369: ST_TO_ADDR
// max_y := y + r ;
109370: LD_ADDR_VAR 0 10
109374: PUSH
109375: LD_VAR 0 3
109379: PUSH
109380: LD_VAR 0 4
109384: PLUS
109385: ST_TO_ADDR
// for _x = min_x to max_x do
109386: LD_ADDR_VAR 0 11
109390: PUSH
109391: DOUBLE
109392: LD_VAR 0 7
109396: DEC
109397: ST_TO_ADDR
109398: LD_VAR 0 9
109402: PUSH
109403: FOR_TO
109404: IFFALSE 109523
// for _y = min_y to max_y do
109406: LD_ADDR_VAR 0 12
109410: PUSH
109411: DOUBLE
109412: LD_VAR 0 8
109416: DEC
109417: ST_TO_ADDR
109418: LD_VAR 0 10
109422: PUSH
109423: FOR_TO
109424: IFFALSE 109519
// begin if not ValidHex ( _x , _y ) then
109426: LD_VAR 0 11
109430: PPUSH
109431: LD_VAR 0 12
109435: PPUSH
109436: CALL_OW 488
109440: NOT
109441: IFFALSE 109445
// continue ;
109443: GO 109423
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109445: LD_VAR 0 11
109449: PPUSH
109450: LD_VAR 0 12
109454: PPUSH
109455: CALL_OW 351
109459: IFFALSE 109477
109461: PUSH
109462: LD_VAR 0 11
109466: PPUSH
109467: LD_VAR 0 12
109471: PPUSH
109472: CALL_OW 554
109476: AND
109477: IFFALSE 109517
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109479: LD_ADDR_VAR 0 13
109483: PUSH
109484: LD_VAR 0 13
109488: PPUSH
109489: LD_VAR 0 13
109493: PUSH
109494: LD_INT 1
109496: PLUS
109497: PPUSH
109498: LD_VAR 0 11
109502: PUSH
109503: LD_VAR 0 12
109507: PUSH
109508: EMPTY
109509: LIST
109510: LIST
109511: PPUSH
109512: CALL_OW 2
109516: ST_TO_ADDR
// end ;
109517: GO 109423
109519: POP
109520: POP
109521: GO 109403
109523: POP
109524: POP
// if not list then
109525: LD_VAR 0 13
109529: NOT
109530: IFFALSE 109534
// exit ;
109532: GO 109605
// for i in list do
109534: LD_ADDR_VAR 0 6
109538: PUSH
109539: LD_VAR 0 13
109543: PUSH
109544: FOR_IN
109545: IFFALSE 109603
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109547: LD_VAR 0 1
109551: PPUSH
109552: LD_STRING M
109554: PUSH
109555: LD_VAR 0 6
109559: PUSH
109560: LD_INT 1
109562: ARRAY
109563: PUSH
109564: LD_VAR 0 6
109568: PUSH
109569: LD_INT 2
109571: ARRAY
109572: PUSH
109573: LD_INT 0
109575: PUSH
109576: LD_INT 0
109578: PUSH
109579: LD_INT 0
109581: PUSH
109582: LD_INT 0
109584: PUSH
109585: EMPTY
109586: LIST
109587: LIST
109588: LIST
109589: LIST
109590: LIST
109591: LIST
109592: LIST
109593: PUSH
109594: EMPTY
109595: LIST
109596: PPUSH
109597: CALL_OW 447
109601: GO 109544
109603: POP
109604: POP
// end ;
109605: LD_VAR 0 5
109609: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
109610: LD_INT 0
109612: PPUSH
109613: PPUSH
109614: PPUSH
109615: PPUSH
109616: PPUSH
109617: PPUSH
109618: PPUSH
109619: PPUSH
109620: PPUSH
109621: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109622: LD_VAR 0 1
109626: PPUSH
109627: CALL_OW 302
109631: NOT
109632: IFTRUE 109651
109634: PUSH
109635: LD_VAR 0 2
109639: PPUSH
109640: LD_VAR 0 3
109644: PPUSH
109645: CALL_OW 488
109649: NOT
109650: OR
109651: IFTRUE 109660
109653: PUSH
109654: LD_VAR 0 4
109658: NOT
109659: OR
109660: IFFALSE 109664
// exit ;
109662: GO 110181
// list := [ ] ;
109664: LD_ADDR_VAR 0 13
109668: PUSH
109669: EMPTY
109670: ST_TO_ADDR
// if x - r < 0 then
109671: LD_VAR 0 2
109675: PUSH
109676: LD_VAR 0 4
109680: MINUS
109681: PUSH
109682: LD_INT 0
109684: LESS
109685: IFFALSE 109697
// min_x := 0 else
109687: LD_ADDR_VAR 0 7
109691: PUSH
109692: LD_INT 0
109694: ST_TO_ADDR
109695: GO 109713
// min_x := x - r ;
109697: LD_ADDR_VAR 0 7
109701: PUSH
109702: LD_VAR 0 2
109706: PUSH
109707: LD_VAR 0 4
109711: MINUS
109712: ST_TO_ADDR
// if y - r < 0 then
109713: LD_VAR 0 3
109717: PUSH
109718: LD_VAR 0 4
109722: MINUS
109723: PUSH
109724: LD_INT 0
109726: LESS
109727: IFFALSE 109739
// min_y := 0 else
109729: LD_ADDR_VAR 0 8
109733: PUSH
109734: LD_INT 0
109736: ST_TO_ADDR
109737: GO 109755
// min_y := y - r ;
109739: LD_ADDR_VAR 0 8
109743: PUSH
109744: LD_VAR 0 3
109748: PUSH
109749: LD_VAR 0 4
109753: MINUS
109754: ST_TO_ADDR
// max_x := x + r ;
109755: LD_ADDR_VAR 0 9
109759: PUSH
109760: LD_VAR 0 2
109764: PUSH
109765: LD_VAR 0 4
109769: PLUS
109770: ST_TO_ADDR
// max_y := y + r ;
109771: LD_ADDR_VAR 0 10
109775: PUSH
109776: LD_VAR 0 3
109780: PUSH
109781: LD_VAR 0 4
109785: PLUS
109786: ST_TO_ADDR
// for _x = min_x to max_x do
109787: LD_ADDR_VAR 0 11
109791: PUSH
109792: DOUBLE
109793: LD_VAR 0 7
109797: DEC
109798: ST_TO_ADDR
109799: LD_VAR 0 9
109803: PUSH
109804: FOR_TO
109805: IFFALSE 109924
// for _y = min_y to max_y do
109807: LD_ADDR_VAR 0 12
109811: PUSH
109812: DOUBLE
109813: LD_VAR 0 8
109817: DEC
109818: ST_TO_ADDR
109819: LD_VAR 0 10
109823: PUSH
109824: FOR_TO
109825: IFFALSE 109920
// begin if not ValidHex ( _x , _y ) then
109827: LD_VAR 0 11
109831: PPUSH
109832: LD_VAR 0 12
109836: PPUSH
109837: CALL_OW 488
109841: NOT
109842: IFFALSE 109846
// continue ;
109844: GO 109824
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109846: LD_VAR 0 11
109850: PPUSH
109851: LD_VAR 0 12
109855: PPUSH
109856: CALL_OW 351
109860: IFFALSE 109878
109862: PUSH
109863: LD_VAR 0 11
109867: PPUSH
109868: LD_VAR 0 12
109872: PPUSH
109873: CALL_OW 554
109877: AND
109878: IFFALSE 109918
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109880: LD_ADDR_VAR 0 13
109884: PUSH
109885: LD_VAR 0 13
109889: PPUSH
109890: LD_VAR 0 13
109894: PUSH
109895: LD_INT 1
109897: PLUS
109898: PPUSH
109899: LD_VAR 0 11
109903: PUSH
109904: LD_VAR 0 12
109908: PUSH
109909: EMPTY
109910: LIST
109911: LIST
109912: PPUSH
109913: CALL_OW 2
109917: ST_TO_ADDR
// end ;
109918: GO 109824
109920: POP
109921: POP
109922: GO 109804
109924: POP
109925: POP
// if not list then
109926: LD_VAR 0 13
109930: NOT
109931: IFFALSE 109935
// exit ;
109933: GO 110181
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109935: LD_ADDR_VAR 0 13
109939: PUSH
109940: LD_VAR 0 1
109944: PPUSH
109945: LD_VAR 0 13
109949: PPUSH
109950: LD_INT 1
109952: PPUSH
109953: LD_INT 1
109955: PPUSH
109956: CALL 22970 0 4
109960: ST_TO_ADDR
// ComStop ( flame ) ;
109961: LD_VAR 0 1
109965: PPUSH
109966: CALL_OW 141
// for i in list do
109970: LD_ADDR_VAR 0 6
109974: PUSH
109975: LD_VAR 0 13
109979: PUSH
109980: FOR_IN
109981: IFFALSE 110012
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109983: LD_VAR 0 1
109987: PPUSH
109988: LD_VAR 0 6
109992: PUSH
109993: LD_INT 1
109995: ARRAY
109996: PPUSH
109997: LD_VAR 0 6
110001: PUSH
110002: LD_INT 2
110004: ARRAY
110005: PPUSH
110006: CALL_OW 176
110010: GO 109980
110012: POP
110013: POP
// repeat wait ( 0 0$1 ) ;
110014: LD_INT 35
110016: PPUSH
110017: CALL_OW 67
// task := GetTaskList ( flame ) ;
110021: LD_ADDR_VAR 0 14
110025: PUSH
110026: LD_VAR 0 1
110030: PPUSH
110031: CALL_OW 437
110035: ST_TO_ADDR
// if not task then
110036: LD_VAR 0 14
110040: NOT
110041: IFFALSE 110045
// exit ;
110043: GO 110181
// if task [ 1 ] [ 1 ] <> | then
110045: LD_VAR 0 14
110049: PUSH
110050: LD_INT 1
110052: ARRAY
110053: PUSH
110054: LD_INT 1
110056: ARRAY
110057: PUSH
110058: LD_STRING |
110060: NONEQUAL
110061: IFFALSE 110065
// exit ;
110063: GO 110181
// _x := task [ 1 ] [ 2 ] ;
110065: LD_ADDR_VAR 0 11
110069: PUSH
110070: LD_VAR 0 14
110074: PUSH
110075: LD_INT 1
110077: ARRAY
110078: PUSH
110079: LD_INT 2
110081: ARRAY
110082: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
110083: LD_ADDR_VAR 0 12
110087: PUSH
110088: LD_VAR 0 14
110092: PUSH
110093: LD_INT 1
110095: ARRAY
110096: PUSH
110097: LD_INT 3
110099: ARRAY
110100: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
110101: LD_VAR 0 11
110105: PPUSH
110106: LD_VAR 0 12
110110: PPUSH
110111: CALL_OW 351
110115: NOT
110116: IFTRUE 110135
110118: PUSH
110119: LD_VAR 0 11
110123: PPUSH
110124: LD_VAR 0 12
110128: PPUSH
110129: CALL_OW 554
110133: NOT
110134: OR
110135: IFFALSE 110169
// begin task := Delete ( task , 1 ) ;
110137: LD_ADDR_VAR 0 14
110141: PUSH
110142: LD_VAR 0 14
110146: PPUSH
110147: LD_INT 1
110149: PPUSH
110150: CALL_OW 3
110154: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
110155: LD_VAR 0 1
110159: PPUSH
110160: LD_VAR 0 14
110164: PPUSH
110165: CALL_OW 446
// end ; until not HasTask ( flame ) ;
110169: LD_VAR 0 1
110173: PPUSH
110174: CALL_OW 314
110178: NOT
110179: IFFALSE 110014
// end ;
110181: LD_VAR 0 5
110185: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110186: LD_EXP 171
110190: NOT
110191: IFFALSE 110241
110193: GO 110195
110195: DISABLE
// begin initHack := true ;
110196: LD_ADDR_EXP 171
110200: PUSH
110201: LD_INT 1
110203: ST_TO_ADDR
// hackTanks := [ ] ;
110204: LD_ADDR_EXP 172
110208: PUSH
110209: EMPTY
110210: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110211: LD_ADDR_EXP 173
110215: PUSH
110216: EMPTY
110217: ST_TO_ADDR
// hackLimit := 3 ;
110218: LD_ADDR_EXP 174
110222: PUSH
110223: LD_INT 3
110225: ST_TO_ADDR
// hackDist := 12 ;
110226: LD_ADDR_EXP 175
110230: PUSH
110231: LD_INT 12
110233: ST_TO_ADDR
// hackCounter := [ ] ;
110234: LD_ADDR_EXP 176
110238: PUSH
110239: EMPTY
110240: ST_TO_ADDR
// end ;
110241: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110242: LD_EXP 171
110246: IFFALSE 110264
110248: PUSH
110249: LD_INT 34
110251: PUSH
110252: LD_INT 99
110254: PUSH
110255: EMPTY
110256: LIST
110257: LIST
110258: PPUSH
110259: CALL_OW 69
110263: AND
110264: IFFALSE 110517
110266: GO 110268
110268: DISABLE
110269: LD_INT 0
110271: PPUSH
110272: PPUSH
// begin enable ;
110273: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110274: LD_ADDR_VAR 0 1
110278: PUSH
110279: LD_INT 34
110281: PUSH
110282: LD_INT 99
110284: PUSH
110285: EMPTY
110286: LIST
110287: LIST
110288: PPUSH
110289: CALL_OW 69
110293: PUSH
110294: FOR_IN
110295: IFFALSE 110515
// begin if not i in hackTanks then
110297: LD_VAR 0 1
110301: PUSH
110302: LD_EXP 172
110306: IN
110307: NOT
110308: IFFALSE 110391
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110310: LD_ADDR_EXP 172
110314: PUSH
110315: LD_EXP 172
110319: PPUSH
110320: LD_EXP 172
110324: PUSH
110325: LD_INT 1
110327: PLUS
110328: PPUSH
110329: LD_VAR 0 1
110333: PPUSH
110334: CALL_OW 1
110338: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110339: LD_ADDR_EXP 173
110343: PUSH
110344: LD_EXP 173
110348: PPUSH
110349: LD_EXP 173
110353: PUSH
110354: LD_INT 1
110356: PLUS
110357: PPUSH
110358: EMPTY
110359: PPUSH
110360: CALL_OW 1
110364: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110365: LD_ADDR_EXP 176
110369: PUSH
110370: LD_EXP 176
110374: PPUSH
110375: LD_EXP 176
110379: PUSH
110380: LD_INT 1
110382: PLUS
110383: PPUSH
110384: EMPTY
110385: PPUSH
110386: CALL_OW 1
110390: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110391: LD_VAR 0 1
110395: PPUSH
110396: CALL_OW 302
110400: NOT
110401: IFFALSE 110414
// begin HackUnlinkAll ( i ) ;
110403: LD_VAR 0 1
110407: PPUSH
110408: CALL 110520 0 1
// continue ;
110412: GO 110294
// end ; HackCheckCapturedStatus ( i ) ;
110414: LD_VAR 0 1
110418: PPUSH
110419: CALL 110965 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110423: LD_ADDR_VAR 0 2
110427: PUSH
110428: LD_INT 81
110430: PUSH
110431: LD_VAR 0 1
110435: PPUSH
110436: CALL_OW 255
110440: PUSH
110441: EMPTY
110442: LIST
110443: LIST
110444: PUSH
110445: LD_INT 33
110447: PUSH
110448: LD_INT 3
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: PUSH
110455: LD_INT 91
110457: PUSH
110458: LD_VAR 0 1
110462: PUSH
110463: LD_EXP 175
110467: PUSH
110468: EMPTY
110469: LIST
110470: LIST
110471: LIST
110472: PUSH
110473: LD_INT 50
110475: PUSH
110476: EMPTY
110477: LIST
110478: PUSH
110479: EMPTY
110480: LIST
110481: LIST
110482: LIST
110483: LIST
110484: PPUSH
110485: CALL_OW 69
110489: ST_TO_ADDR
// if not tmp then
110490: LD_VAR 0 2
110494: NOT
110495: IFFALSE 110499
// continue ;
110497: GO 110294
// HackLink ( i , tmp ) ;
110499: LD_VAR 0 1
110503: PPUSH
110504: LD_VAR 0 2
110508: PPUSH
110509: CALL 110656 0 2
// end ;
110513: GO 110294
110515: POP
110516: POP
// end ;
110517: PPOPN 2
110519: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110520: LD_INT 0
110522: PPUSH
110523: PPUSH
110524: PPUSH
// if not hack in hackTanks then
110525: LD_VAR 0 1
110529: PUSH
110530: LD_EXP 172
110534: IN
110535: NOT
110536: IFFALSE 110540
// exit ;
110538: GO 110651
// index := GetElementIndex ( hackTanks , hack ) ;
110540: LD_ADDR_VAR 0 4
110544: PUSH
110545: LD_EXP 172
110549: PPUSH
110550: LD_VAR 0 1
110554: PPUSH
110555: CALL 22265 0 2
110559: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110560: LD_EXP 173
110564: PUSH
110565: LD_VAR 0 4
110569: ARRAY
110570: IFFALSE 110651
// begin for i in hackTanksCaptured [ index ] do
110572: LD_ADDR_VAR 0 3
110576: PUSH
110577: LD_EXP 173
110581: PUSH
110582: LD_VAR 0 4
110586: ARRAY
110587: PUSH
110588: FOR_IN
110589: IFFALSE 110615
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110591: LD_VAR 0 3
110595: PUSH
110596: LD_INT 1
110598: ARRAY
110599: PPUSH
110600: LD_VAR 0 3
110604: PUSH
110605: LD_INT 2
110607: ARRAY
110608: PPUSH
110609: CALL_OW 235
110613: GO 110588
110615: POP
110616: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110617: LD_ADDR_EXP 173
110621: PUSH
110622: LD_EXP 173
110626: PPUSH
110627: LD_VAR 0 4
110631: PPUSH
110632: EMPTY
110633: PPUSH
110634: CALL_OW 1
110638: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110639: LD_VAR 0 1
110643: PPUSH
110644: LD_INT 0
110646: PPUSH
110647: CALL_OW 505
// end ; end ;
110651: LD_VAR 0 2
110655: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110656: LD_INT 0
110658: PPUSH
110659: PPUSH
110660: PPUSH
// if not hack in hackTanks or not vehicles then
110661: LD_VAR 0 1
110665: PUSH
110666: LD_EXP 172
110670: IN
110671: NOT
110672: IFTRUE 110681
110674: PUSH
110675: LD_VAR 0 2
110679: NOT
110680: OR
110681: IFFALSE 110685
// exit ;
110683: GO 110960
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110685: LD_ADDR_VAR 0 2
110689: PUSH
110690: LD_VAR 0 1
110694: PPUSH
110695: LD_VAR 0 2
110699: PPUSH
110700: LD_INT 1
110702: PPUSH
110703: LD_INT 1
110705: PPUSH
110706: CALL 22917 0 4
110710: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110711: LD_ADDR_VAR 0 5
110715: PUSH
110716: LD_EXP 172
110720: PPUSH
110721: LD_VAR 0 1
110725: PPUSH
110726: CALL 22265 0 2
110730: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110731: LD_EXP 173
110735: PUSH
110736: LD_VAR 0 5
110740: ARRAY
110741: PUSH
110742: LD_EXP 174
110746: LESS
110747: IFFALSE 110936
// begin for i := 1 to vehicles do
110749: LD_ADDR_VAR 0 4
110753: PUSH
110754: DOUBLE
110755: LD_INT 1
110757: DEC
110758: ST_TO_ADDR
110759: LD_VAR 0 2
110763: PUSH
110764: FOR_TO
110765: IFFALSE 110934
// begin if hackTanksCaptured [ index ] = hackLimit then
110767: LD_EXP 173
110771: PUSH
110772: LD_VAR 0 5
110776: ARRAY
110777: PUSH
110778: LD_EXP 174
110782: EQUAL
110783: IFFALSE 110787
// break ;
110785: GO 110934
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110787: LD_ADDR_EXP 176
110791: PUSH
110792: LD_EXP 176
110796: PPUSH
110797: LD_VAR 0 5
110801: PPUSH
110802: LD_EXP 176
110806: PUSH
110807: LD_VAR 0 5
110811: ARRAY
110812: PUSH
110813: LD_INT 1
110815: PLUS
110816: PPUSH
110817: CALL_OW 1
110821: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110822: LD_ADDR_EXP 173
110826: PUSH
110827: LD_EXP 173
110831: PPUSH
110832: LD_VAR 0 5
110836: PUSH
110837: LD_EXP 173
110841: PUSH
110842: LD_VAR 0 5
110846: ARRAY
110847: PUSH
110848: LD_INT 1
110850: PLUS
110851: PUSH
110852: EMPTY
110853: LIST
110854: LIST
110855: PPUSH
110856: LD_VAR 0 2
110860: PUSH
110861: LD_VAR 0 4
110865: ARRAY
110866: PUSH
110867: LD_VAR 0 2
110871: PUSH
110872: LD_VAR 0 4
110876: ARRAY
110877: PPUSH
110878: CALL_OW 255
110882: PUSH
110883: EMPTY
110884: LIST
110885: LIST
110886: PPUSH
110887: CALL 22482 0 3
110891: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110892: LD_VAR 0 2
110896: PUSH
110897: LD_VAR 0 4
110901: ARRAY
110902: PPUSH
110903: LD_VAR 0 1
110907: PPUSH
110908: CALL_OW 255
110912: PPUSH
110913: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110917: LD_VAR 0 2
110921: PUSH
110922: LD_VAR 0 4
110926: ARRAY
110927: PPUSH
110928: CALL_OW 141
// end ;
110932: GO 110764
110934: POP
110935: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110936: LD_VAR 0 1
110940: PPUSH
110941: LD_EXP 173
110945: PUSH
110946: LD_VAR 0 5
110950: ARRAY
110951: PUSH
110952: LD_INT 0
110954: PLUS
110955: PPUSH
110956: CALL_OW 505
// end ;
110960: LD_VAR 0 3
110964: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110965: LD_INT 0
110967: PPUSH
110968: PPUSH
110969: PPUSH
110970: PPUSH
// if not hack in hackTanks then
110971: LD_VAR 0 1
110975: PUSH
110976: LD_EXP 172
110980: IN
110981: NOT
110982: IFFALSE 110986
// exit ;
110984: GO 111230
// index := GetElementIndex ( hackTanks , hack ) ;
110986: LD_ADDR_VAR 0 4
110990: PUSH
110991: LD_EXP 172
110995: PPUSH
110996: LD_VAR 0 1
111000: PPUSH
111001: CALL 22265 0 2
111005: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111006: LD_ADDR_VAR 0 3
111010: PUSH
111011: DOUBLE
111012: LD_EXP 173
111016: PUSH
111017: LD_VAR 0 4
111021: ARRAY
111022: INC
111023: ST_TO_ADDR
111024: LD_INT 1
111026: PUSH
111027: FOR_DOWNTO
111028: IFFALSE 111204
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111030: LD_ADDR_VAR 0 5
111034: PUSH
111035: LD_EXP 173
111039: PUSH
111040: LD_VAR 0 4
111044: ARRAY
111045: PUSH
111046: LD_VAR 0 3
111050: ARRAY
111051: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111052: LD_VAR 0 5
111056: PUSH
111057: LD_INT 1
111059: ARRAY
111060: PPUSH
111061: CALL_OW 302
111065: NOT
111066: IFTRUE 111094
111068: PUSH
111069: LD_VAR 0 5
111073: PUSH
111074: LD_INT 1
111076: ARRAY
111077: PPUSH
111078: CALL_OW 255
111082: PUSH
111083: LD_VAR 0 1
111087: PPUSH
111088: CALL_OW 255
111092: NONEQUAL
111093: OR
111094: IFFALSE 111202
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111096: LD_VAR 0 5
111100: PUSH
111101: LD_INT 1
111103: ARRAY
111104: PPUSH
111105: CALL_OW 305
111109: IFFALSE 111137
111111: PUSH
111112: LD_VAR 0 5
111116: PUSH
111117: LD_INT 1
111119: ARRAY
111120: PPUSH
111121: CALL_OW 255
111125: PUSH
111126: LD_VAR 0 1
111130: PPUSH
111131: CALL_OW 255
111135: EQUAL
111136: AND
111137: IFFALSE 111161
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111139: LD_VAR 0 5
111143: PUSH
111144: LD_INT 1
111146: ARRAY
111147: PPUSH
111148: LD_VAR 0 5
111152: PUSH
111153: LD_INT 2
111155: ARRAY
111156: PPUSH
111157: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111161: LD_ADDR_EXP 173
111165: PUSH
111166: LD_EXP 173
111170: PPUSH
111171: LD_VAR 0 4
111175: PPUSH
111176: LD_EXP 173
111180: PUSH
111181: LD_VAR 0 4
111185: ARRAY
111186: PPUSH
111187: LD_VAR 0 3
111191: PPUSH
111192: CALL_OW 3
111196: PPUSH
111197: CALL_OW 1
111201: ST_TO_ADDR
// end ; end ;
111202: GO 111027
111204: POP
111205: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111206: LD_VAR 0 1
111210: PPUSH
111211: LD_EXP 173
111215: PUSH
111216: LD_VAR 0 4
111220: ARRAY
111221: PUSH
111222: LD_INT 0
111224: PLUS
111225: PPUSH
111226: CALL_OW 505
// end ;
111230: LD_VAR 0 2
111234: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111235: LD_INT 0
111237: PPUSH
111238: PPUSH
111239: PPUSH
111240: PPUSH
// if not hack in hackTanks then
111241: LD_VAR 0 1
111245: PUSH
111246: LD_EXP 172
111250: IN
111251: NOT
111252: IFFALSE 111256
// exit ;
111254: GO 111341
// index := GetElementIndex ( hackTanks , hack ) ;
111256: LD_ADDR_VAR 0 5
111260: PUSH
111261: LD_EXP 172
111265: PPUSH
111266: LD_VAR 0 1
111270: PPUSH
111271: CALL 22265 0 2
111275: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111276: LD_ADDR_VAR 0 4
111280: PUSH
111281: DOUBLE
111282: LD_INT 1
111284: DEC
111285: ST_TO_ADDR
111286: LD_EXP 173
111290: PUSH
111291: LD_VAR 0 5
111295: ARRAY
111296: PUSH
111297: FOR_TO
111298: IFFALSE 111339
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111300: LD_EXP 173
111304: PUSH
111305: LD_VAR 0 5
111309: ARRAY
111310: PUSH
111311: LD_VAR 0 4
111315: ARRAY
111316: PUSH
111317: LD_INT 1
111319: ARRAY
111320: PUSH
111321: LD_VAR 0 2
111325: EQUAL
111326: IFFALSE 111337
// KillUnit ( vehicle ) ;
111328: LD_VAR 0 2
111332: PPUSH
111333: CALL_OW 66
111337: GO 111297
111339: POP
111340: POP
// end ;
111341: LD_VAR 0 3
111345: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111346: LD_EXP 177
111350: NOT
111351: IFFALSE 111386
111353: GO 111355
111355: DISABLE
// begin initMiner := true ;
111356: LD_ADDR_EXP 177
111360: PUSH
111361: LD_INT 1
111363: ST_TO_ADDR
// minersList := [ ] ;
111364: LD_ADDR_EXP 178
111368: PUSH
111369: EMPTY
111370: ST_TO_ADDR
// minerMinesList := [ ] ;
111371: LD_ADDR_EXP 179
111375: PUSH
111376: EMPTY
111377: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111378: LD_ADDR_EXP 180
111382: PUSH
111383: LD_INT 5
111385: ST_TO_ADDR
// end ;
111386: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111387: LD_EXP 177
111391: IFFALSE 111409
111393: PUSH
111394: LD_INT 34
111396: PUSH
111397: LD_INT 81
111399: PUSH
111400: EMPTY
111401: LIST
111402: LIST
111403: PPUSH
111404: CALL_OW 69
111408: AND
111409: IFFALSE 111872
111411: GO 111413
111413: DISABLE
111414: LD_INT 0
111416: PPUSH
111417: PPUSH
111418: PPUSH
111419: PPUSH
// begin enable ;
111420: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111421: LD_ADDR_VAR 0 1
111425: PUSH
111426: LD_INT 34
111428: PUSH
111429: LD_INT 81
111431: PUSH
111432: EMPTY
111433: LIST
111434: LIST
111435: PPUSH
111436: CALL_OW 69
111440: PUSH
111441: FOR_IN
111442: IFFALSE 111514
// begin if not i in minersList then
111444: LD_VAR 0 1
111448: PUSH
111449: LD_EXP 178
111453: IN
111454: NOT
111455: IFFALSE 111512
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111457: LD_ADDR_EXP 178
111461: PUSH
111462: LD_EXP 178
111466: PPUSH
111467: LD_EXP 178
111471: PUSH
111472: LD_INT 1
111474: PLUS
111475: PPUSH
111476: LD_VAR 0 1
111480: PPUSH
111481: CALL_OW 1
111485: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111486: LD_ADDR_EXP 179
111490: PUSH
111491: LD_EXP 179
111495: PPUSH
111496: LD_EXP 179
111500: PUSH
111501: LD_INT 1
111503: PLUS
111504: PPUSH
111505: EMPTY
111506: PPUSH
111507: CALL_OW 1
111511: ST_TO_ADDR
// end end ;
111512: GO 111441
111514: POP
111515: POP
// for i := minerMinesList downto 1 do
111516: LD_ADDR_VAR 0 1
111520: PUSH
111521: DOUBLE
111522: LD_EXP 179
111526: INC
111527: ST_TO_ADDR
111528: LD_INT 1
111530: PUSH
111531: FOR_DOWNTO
111532: IFFALSE 111870
// begin if IsLive ( minersList [ i ] ) then
111534: LD_EXP 178
111538: PUSH
111539: LD_VAR 0 1
111543: ARRAY
111544: PPUSH
111545: CALL_OW 300
111549: IFFALSE 111577
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111551: LD_EXP 178
111555: PUSH
111556: LD_VAR 0 1
111560: ARRAY
111561: PPUSH
111562: LD_EXP 179
111566: PUSH
111567: LD_VAR 0 1
111571: ARRAY
111572: PPUSH
111573: CALL_OW 505
// if not minerMinesList [ i ] then
111577: LD_EXP 179
111581: PUSH
111582: LD_VAR 0 1
111586: ARRAY
111587: NOT
111588: IFFALSE 111592
// continue ;
111590: GO 111531
// for j := minerMinesList [ i ] downto 1 do
111592: LD_ADDR_VAR 0 2
111596: PUSH
111597: DOUBLE
111598: LD_EXP 179
111602: PUSH
111603: LD_VAR 0 1
111607: ARRAY
111608: INC
111609: ST_TO_ADDR
111610: LD_INT 1
111612: PUSH
111613: FOR_DOWNTO
111614: IFFALSE 111866
// begin side := GetSide ( minersList [ i ] ) ;
111616: LD_ADDR_VAR 0 3
111620: PUSH
111621: LD_EXP 178
111625: PUSH
111626: LD_VAR 0 1
111630: ARRAY
111631: PPUSH
111632: CALL_OW 255
111636: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111637: LD_ADDR_VAR 0 4
111641: PUSH
111642: LD_EXP 179
111646: PUSH
111647: LD_VAR 0 1
111651: ARRAY
111652: PUSH
111653: LD_VAR 0 2
111657: ARRAY
111658: PUSH
111659: LD_INT 1
111661: ARRAY
111662: PPUSH
111663: LD_EXP 179
111667: PUSH
111668: LD_VAR 0 1
111672: ARRAY
111673: PUSH
111674: LD_VAR 0 2
111678: ARRAY
111679: PUSH
111680: LD_INT 2
111682: ARRAY
111683: PPUSH
111684: CALL_OW 428
111688: ST_TO_ADDR
// if not tmp then
111689: LD_VAR 0 4
111693: NOT
111694: IFFALSE 111698
// continue ;
111696: GO 111613
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111698: LD_VAR 0 4
111702: PUSH
111703: LD_INT 81
111705: PUSH
111706: LD_VAR 0 3
111710: PUSH
111711: EMPTY
111712: LIST
111713: LIST
111714: PPUSH
111715: CALL_OW 69
111719: IN
111720: IFFALSE 111770
111722: PUSH
111723: LD_EXP 179
111727: PUSH
111728: LD_VAR 0 1
111732: ARRAY
111733: PUSH
111734: LD_VAR 0 2
111738: ARRAY
111739: PUSH
111740: LD_INT 1
111742: ARRAY
111743: PPUSH
111744: LD_EXP 179
111748: PUSH
111749: LD_VAR 0 1
111753: ARRAY
111754: PUSH
111755: LD_VAR 0 2
111759: ARRAY
111760: PUSH
111761: LD_INT 2
111763: ARRAY
111764: PPUSH
111765: CALL_OW 458
111769: AND
111770: IFFALSE 111864
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111772: LD_EXP 179
111776: PUSH
111777: LD_VAR 0 1
111781: ARRAY
111782: PUSH
111783: LD_VAR 0 2
111787: ARRAY
111788: PUSH
111789: LD_INT 1
111791: ARRAY
111792: PPUSH
111793: LD_EXP 179
111797: PUSH
111798: LD_VAR 0 1
111802: ARRAY
111803: PUSH
111804: LD_VAR 0 2
111808: ARRAY
111809: PUSH
111810: LD_INT 2
111812: ARRAY
111813: PPUSH
111814: LD_VAR 0 3
111818: PPUSH
111819: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111823: LD_ADDR_EXP 179
111827: PUSH
111828: LD_EXP 179
111832: PPUSH
111833: LD_VAR 0 1
111837: PPUSH
111838: LD_EXP 179
111842: PUSH
111843: LD_VAR 0 1
111847: ARRAY
111848: PPUSH
111849: LD_VAR 0 2
111853: PPUSH
111854: CALL_OW 3
111858: PPUSH
111859: CALL_OW 1
111863: ST_TO_ADDR
// end ; end ;
111864: GO 111613
111866: POP
111867: POP
// end ;
111868: GO 111531
111870: POP
111871: POP
// end ;
111872: PPOPN 4
111874: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111875: LD_INT 0
111877: PPUSH
111878: PPUSH
// result := false ;
111879: LD_ADDR_VAR 0 4
111883: PUSH
111884: LD_INT 0
111886: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111887: LD_VAR 0 1
111891: PPUSH
111892: CALL_OW 264
111896: PUSH
111897: LD_INT 81
111899: EQUAL
111900: NOT
111901: IFFALSE 111905
// exit ;
111903: GO 112149
// index := GetElementIndex ( minersList , unit ) ;
111905: LD_ADDR_VAR 0 5
111909: PUSH
111910: LD_EXP 178
111914: PPUSH
111915: LD_VAR 0 1
111919: PPUSH
111920: CALL 22265 0 2
111924: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111925: LD_EXP 179
111929: PUSH
111930: LD_VAR 0 5
111934: ARRAY
111935: PUSH
111936: LD_EXP 180
111940: GREATEREQUAL
111941: IFFALSE 111945
// exit ;
111943: GO 112149
// ComMoveXY ( unit , x , y ) ;
111945: LD_VAR 0 1
111949: PPUSH
111950: LD_VAR 0 2
111954: PPUSH
111955: LD_VAR 0 3
111959: PPUSH
111960: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111964: LD_INT 35
111966: PPUSH
111967: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111971: LD_VAR 0 1
111975: PPUSH
111976: LD_VAR 0 2
111980: PPUSH
111981: LD_VAR 0 3
111985: PPUSH
111986: CALL 54311 0 3
111990: NOT
111991: IFFALSE 112004
111993: PUSH
111994: LD_VAR 0 1
111998: PPUSH
111999: CALL_OW 314
112003: AND
112004: IFFALSE 112008
// exit ;
112006: GO 112149
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112008: LD_VAR 0 2
112012: PPUSH
112013: LD_VAR 0 3
112017: PPUSH
112018: CALL_OW 428
112022: PUSH
112023: LD_VAR 0 1
112027: EQUAL
112028: IFFALSE 112042
112030: PUSH
112031: LD_VAR 0 1
112035: PPUSH
112036: CALL_OW 314
112040: NOT
112041: AND
112042: IFFALSE 111964
// PlaySoundXY ( x , y , PlantMine ) ;
112044: LD_VAR 0 2
112048: PPUSH
112049: LD_VAR 0 3
112053: PPUSH
112054: LD_STRING PlantMine
112056: PPUSH
112057: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112061: LD_VAR 0 2
112065: PPUSH
112066: LD_VAR 0 3
112070: PPUSH
112071: LD_VAR 0 1
112075: PPUSH
112076: CALL_OW 255
112080: PPUSH
112081: LD_INT 0
112083: PPUSH
112084: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112088: LD_ADDR_EXP 179
112092: PUSH
112093: LD_EXP 179
112097: PPUSH
112098: LD_VAR 0 5
112102: PUSH
112103: LD_EXP 179
112107: PUSH
112108: LD_VAR 0 5
112112: ARRAY
112113: PUSH
112114: LD_INT 1
112116: PLUS
112117: PUSH
112118: EMPTY
112119: LIST
112120: LIST
112121: PPUSH
112122: LD_VAR 0 2
112126: PUSH
112127: LD_VAR 0 3
112131: PUSH
112132: EMPTY
112133: LIST
112134: LIST
112135: PPUSH
112136: CALL 22482 0 3
112140: ST_TO_ADDR
// result := true ;
112141: LD_ADDR_VAR 0 4
112145: PUSH
112146: LD_INT 1
112148: ST_TO_ADDR
// end ;
112149: LD_VAR 0 4
112153: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112154: LD_INT 0
112156: PPUSH
112157: PPUSH
112158: PPUSH
// if not unit in minersList then
112159: LD_VAR 0 1
112163: PUSH
112164: LD_EXP 178
112168: IN
112169: NOT
112170: IFFALSE 112174
// exit ;
112172: GO 112568
// index := GetElementIndex ( minersList , unit ) ;
112174: LD_ADDR_VAR 0 6
112178: PUSH
112179: LD_EXP 178
112183: PPUSH
112184: LD_VAR 0 1
112188: PPUSH
112189: CALL 22265 0 2
112193: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112194: LD_ADDR_VAR 0 5
112198: PUSH
112199: DOUBLE
112200: LD_EXP 179
112204: PUSH
112205: LD_VAR 0 6
112209: ARRAY
112210: INC
112211: ST_TO_ADDR
112212: LD_INT 1
112214: PUSH
112215: FOR_DOWNTO
112216: IFFALSE 112379
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112218: LD_EXP 179
112222: PUSH
112223: LD_VAR 0 6
112227: ARRAY
112228: PUSH
112229: LD_VAR 0 5
112233: ARRAY
112234: PUSH
112235: LD_INT 1
112237: ARRAY
112238: PUSH
112239: LD_VAR 0 2
112243: EQUAL
112244: IFFALSE 112274
112246: PUSH
112247: LD_EXP 179
112251: PUSH
112252: LD_VAR 0 6
112256: ARRAY
112257: PUSH
112258: LD_VAR 0 5
112262: ARRAY
112263: PUSH
112264: LD_INT 2
112266: ARRAY
112267: PUSH
112268: LD_VAR 0 3
112272: EQUAL
112273: AND
112274: IFFALSE 112377
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112276: LD_EXP 179
112280: PUSH
112281: LD_VAR 0 6
112285: ARRAY
112286: PUSH
112287: LD_VAR 0 5
112291: ARRAY
112292: PUSH
112293: LD_INT 1
112295: ARRAY
112296: PPUSH
112297: LD_EXP 179
112301: PUSH
112302: LD_VAR 0 6
112306: ARRAY
112307: PUSH
112308: LD_VAR 0 5
112312: ARRAY
112313: PUSH
112314: LD_INT 2
112316: ARRAY
112317: PPUSH
112318: LD_VAR 0 1
112322: PPUSH
112323: CALL_OW 255
112327: PPUSH
112328: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112332: LD_ADDR_EXP 179
112336: PUSH
112337: LD_EXP 179
112341: PPUSH
112342: LD_VAR 0 6
112346: PPUSH
112347: LD_EXP 179
112351: PUSH
112352: LD_VAR 0 6
112356: ARRAY
112357: PPUSH
112358: LD_VAR 0 5
112362: PPUSH
112363: CALL_OW 3
112367: PPUSH
112368: CALL_OW 1
112372: ST_TO_ADDR
// exit ;
112373: POP
112374: POP
112375: GO 112568
// end ; end ;
112377: GO 112215
112379: POP
112380: POP
// for i := minerMinesList [ index ] downto 1 do
112381: LD_ADDR_VAR 0 5
112385: PUSH
112386: DOUBLE
112387: LD_EXP 179
112391: PUSH
112392: LD_VAR 0 6
112396: ARRAY
112397: INC
112398: ST_TO_ADDR
112399: LD_INT 1
112401: PUSH
112402: FOR_DOWNTO
112403: IFFALSE 112566
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112405: LD_EXP 179
112409: PUSH
112410: LD_VAR 0 6
112414: ARRAY
112415: PUSH
112416: LD_VAR 0 5
112420: ARRAY
112421: PUSH
112422: LD_INT 1
112424: ARRAY
112425: PPUSH
112426: LD_EXP 179
112430: PUSH
112431: LD_VAR 0 6
112435: ARRAY
112436: PUSH
112437: LD_VAR 0 5
112441: ARRAY
112442: PUSH
112443: LD_INT 2
112445: ARRAY
112446: PPUSH
112447: LD_VAR 0 2
112451: PPUSH
112452: LD_VAR 0 3
112456: PPUSH
112457: CALL_OW 298
112461: PUSH
112462: LD_INT 6
112464: LESS
112465: IFFALSE 112564
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112467: LD_EXP 179
112471: PUSH
112472: LD_VAR 0 6
112476: ARRAY
112477: PUSH
112478: LD_VAR 0 5
112482: ARRAY
112483: PUSH
112484: LD_INT 1
112486: ARRAY
112487: PPUSH
112488: LD_EXP 179
112492: PUSH
112493: LD_VAR 0 6
112497: ARRAY
112498: PUSH
112499: LD_VAR 0 5
112503: ARRAY
112504: PUSH
112505: LD_INT 2
112507: ARRAY
112508: PPUSH
112509: LD_VAR 0 1
112513: PPUSH
112514: CALL_OW 255
112518: PPUSH
112519: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112523: LD_ADDR_EXP 179
112527: PUSH
112528: LD_EXP 179
112532: PPUSH
112533: LD_VAR 0 6
112537: PPUSH
112538: LD_EXP 179
112542: PUSH
112543: LD_VAR 0 6
112547: ARRAY
112548: PPUSH
112549: LD_VAR 0 5
112553: PPUSH
112554: CALL_OW 3
112558: PPUSH
112559: CALL_OW 1
112563: ST_TO_ADDR
// end ; end ;
112564: GO 112402
112566: POP
112567: POP
// end ;
112568: LD_VAR 0 4
112572: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112573: LD_INT 0
112575: PPUSH
112576: PPUSH
112577: PPUSH
112578: PPUSH
112579: PPUSH
112580: PPUSH
112581: PPUSH
112582: PPUSH
112583: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112584: LD_VAR 0 1
112588: PPUSH
112589: CALL_OW 264
112593: PUSH
112594: LD_INT 81
112596: EQUAL
112597: NOT
112598: IFTRUE 112613
112600: PUSH
112601: LD_VAR 0 1
112605: PUSH
112606: LD_EXP 178
112610: IN
112611: NOT
112612: OR
112613: IFFALSE 112617
// exit ;
112615: GO 112943
// index := GetElementIndex ( minersList , unit ) ;
112617: LD_ADDR_VAR 0 6
112621: PUSH
112622: LD_EXP 178
112626: PPUSH
112627: LD_VAR 0 1
112631: PPUSH
112632: CALL 22265 0 2
112636: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112637: LD_ADDR_VAR 0 8
112641: PUSH
112642: LD_EXP 180
112646: PUSH
112647: LD_EXP 179
112651: PUSH
112652: LD_VAR 0 6
112656: ARRAY
112657: MINUS
112658: ST_TO_ADDR
// if not minesFreeAmount then
112659: LD_VAR 0 8
112663: NOT
112664: IFFALSE 112668
// exit ;
112666: GO 112943
// tmp := [ ] ;
112668: LD_ADDR_VAR 0 7
112672: PUSH
112673: EMPTY
112674: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112675: LD_ADDR_VAR 0 5
112679: PUSH
112680: DOUBLE
112681: LD_INT 1
112683: DEC
112684: ST_TO_ADDR
112685: LD_VAR 0 8
112689: PUSH
112690: FOR_TO
112691: IFFALSE 112890
// begin _d := rand ( 0 , 5 ) ;
112693: LD_ADDR_VAR 0 11
112697: PUSH
112698: LD_INT 0
112700: PPUSH
112701: LD_INT 5
112703: PPUSH
112704: CALL_OW 12
112708: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112709: LD_ADDR_VAR 0 12
112713: PUSH
112714: LD_INT 2
112716: PPUSH
112717: LD_INT 6
112719: PPUSH
112720: CALL_OW 12
112724: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112725: LD_ADDR_VAR 0 9
112729: PUSH
112730: LD_VAR 0 2
112734: PPUSH
112735: LD_VAR 0 11
112739: PPUSH
112740: LD_VAR 0 12
112744: PPUSH
112745: CALL_OW 272
112749: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112750: LD_ADDR_VAR 0 10
112754: PUSH
112755: LD_VAR 0 3
112759: PPUSH
112760: LD_VAR 0 11
112764: PPUSH
112765: LD_VAR 0 12
112769: PPUSH
112770: CALL_OW 273
112774: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112775: LD_VAR 0 9
112779: PPUSH
112780: LD_VAR 0 10
112784: PPUSH
112785: CALL_OW 488
112789: IFFALSE 112813
112791: PUSH
112792: LD_VAR 0 9
112796: PUSH
112797: LD_VAR 0 10
112801: PUSH
112802: EMPTY
112803: LIST
112804: LIST
112805: PUSH
112806: LD_VAR 0 7
112810: IN
112811: NOT
112812: AND
112813: IFFALSE 112832
112815: PUSH
112816: LD_VAR 0 9
112820: PPUSH
112821: LD_VAR 0 10
112825: PPUSH
112826: CALL_OW 458
112830: NOT
112831: AND
112832: IFFALSE 112874
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112834: LD_ADDR_VAR 0 7
112838: PUSH
112839: LD_VAR 0 7
112843: PPUSH
112844: LD_VAR 0 7
112848: PUSH
112849: LD_INT 1
112851: PLUS
112852: PPUSH
112853: LD_VAR 0 9
112857: PUSH
112858: LD_VAR 0 10
112862: PUSH
112863: EMPTY
112864: LIST
112865: LIST
112866: PPUSH
112867: CALL_OW 1
112871: ST_TO_ADDR
112872: GO 112888
// i := i - 1 ;
112874: LD_ADDR_VAR 0 5
112878: PUSH
112879: LD_VAR 0 5
112883: PUSH
112884: LD_INT 1
112886: MINUS
112887: ST_TO_ADDR
// end ;
112888: GO 112690
112890: POP
112891: POP
// for i in tmp do
112892: LD_ADDR_VAR 0 5
112896: PUSH
112897: LD_VAR 0 7
112901: PUSH
112902: FOR_IN
112903: IFFALSE 112941
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112905: LD_VAR 0 1
112909: PPUSH
112910: LD_VAR 0 5
112914: PUSH
112915: LD_INT 1
112917: ARRAY
112918: PPUSH
112919: LD_VAR 0 5
112923: PUSH
112924: LD_INT 2
112926: ARRAY
112927: PPUSH
112928: CALL 111875 0 3
112932: NOT
112933: IFFALSE 112939
// exit ;
112935: POP
112936: POP
112937: GO 112943
112939: GO 112902
112941: POP
112942: POP
// end ;
112943: LD_VAR 0 4
112947: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
112948: LD_INT 0
112950: PPUSH
112951: PPUSH
112952: PPUSH
112953: PPUSH
112954: PPUSH
112955: PPUSH
112956: PPUSH
112957: PPUSH
112958: PPUSH
// if GetClass ( unit ) <> class_sniper then
112959: LD_VAR 0 1
112963: PPUSH
112964: CALL_OW 257
112968: PUSH
112969: LD_INT 5
112971: NONEQUAL
112972: IFFALSE 112976
// exit ;
112974: GO 113446
// dist := 8 ;
112976: LD_ADDR_VAR 0 5
112980: PUSH
112981: LD_INT 8
112983: ST_TO_ADDR
// viewRange := 12 ;
112984: LD_ADDR_VAR 0 8
112988: PUSH
112989: LD_INT 12
112991: ST_TO_ADDR
// side := GetSide ( unit ) ;
112992: LD_ADDR_VAR 0 6
112996: PUSH
112997: LD_VAR 0 1
113001: PPUSH
113002: CALL_OW 255
113006: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113007: LD_INT 61
113009: PPUSH
113010: LD_VAR 0 6
113014: PPUSH
113015: CALL_OW 321
113019: PUSH
113020: LD_INT 2
113022: EQUAL
113023: IFFALSE 113033
// viewRange := 16 ;
113025: LD_ADDR_VAR 0 8
113029: PUSH
113030: LD_INT 16
113032: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113033: LD_VAR 0 1
113037: PPUSH
113038: LD_VAR 0 2
113042: PPUSH
113043: LD_VAR 0 3
113047: PPUSH
113048: CALL_OW 297
113052: PUSH
113053: LD_VAR 0 5
113057: GREATER
113058: IFFALSE 113137
// begin ComMoveXY ( unit , x , y ) ;
113060: LD_VAR 0 1
113064: PPUSH
113065: LD_VAR 0 2
113069: PPUSH
113070: LD_VAR 0 3
113074: PPUSH
113075: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113079: LD_INT 35
113081: PPUSH
113082: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113086: LD_VAR 0 1
113090: PPUSH
113091: LD_VAR 0 2
113095: PPUSH
113096: LD_VAR 0 3
113100: PPUSH
113101: CALL 54311 0 3
113105: NOT
113106: IFFALSE 113110
// exit ;
113108: GO 113446
// until GetDistUnitXY ( unit , x , y ) < dist ;
113110: LD_VAR 0 1
113114: PPUSH
113115: LD_VAR 0 2
113119: PPUSH
113120: LD_VAR 0 3
113124: PPUSH
113125: CALL_OW 297
113129: PUSH
113130: LD_VAR 0 5
113134: LESS
113135: IFFALSE 113079
// end ; ComTurnXY ( unit , x , y ) ;
113137: LD_VAR 0 1
113141: PPUSH
113142: LD_VAR 0 2
113146: PPUSH
113147: LD_VAR 0 3
113151: PPUSH
113152: CALL_OW 118
// repeat if Multiplayer then
113156: LD_OWVAR 4
113160: IFFALSE 113171
// wait ( 35 ) else
113162: LD_INT 35
113164: PPUSH
113165: CALL_OW 67
113169: GO 113178
// wait ( 5 ) ;
113171: LD_INT 5
113173: PPUSH
113174: CALL_OW 67
// _d := GetDir ( unit ) ;
113178: LD_ADDR_VAR 0 11
113182: PUSH
113183: LD_VAR 0 1
113187: PPUSH
113188: CALL_OW 254
113192: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
113193: LD_ADDR_VAR 0 7
113197: PUSH
113198: LD_VAR 0 1
113202: PPUSH
113203: CALL_OW 250
113207: PPUSH
113208: LD_VAR 0 1
113212: PPUSH
113213: CALL_OW 251
113217: PPUSH
113218: LD_VAR 0 2
113222: PPUSH
113223: LD_VAR 0 3
113227: PPUSH
113228: CALL 56947 0 4
113232: ST_TO_ADDR
// until dir = _d ;
113233: LD_VAR 0 7
113237: PUSH
113238: LD_VAR 0 11
113242: EQUAL
113243: IFFALSE 113156
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
113245: LD_ADDR_VAR 0 9
113249: PUSH
113250: LD_VAR 0 1
113254: PPUSH
113255: CALL_OW 250
113259: PPUSH
113260: LD_VAR 0 7
113264: PPUSH
113265: LD_VAR 0 5
113269: PPUSH
113270: CALL_OW 272
113274: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
113275: LD_ADDR_VAR 0 10
113279: PUSH
113280: LD_VAR 0 1
113284: PPUSH
113285: CALL_OW 251
113289: PPUSH
113290: LD_VAR 0 7
113294: PPUSH
113295: LD_VAR 0 5
113299: PPUSH
113300: CALL_OW 273
113304: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113305: LD_VAR 0 9
113309: PPUSH
113310: LD_VAR 0 10
113314: PPUSH
113315: CALL_OW 488
113319: NOT
113320: IFFALSE 113324
// exit ;
113322: GO 113446
// ComAnimCustom ( unit , 1 ) ;
113324: LD_VAR 0 1
113328: PPUSH
113329: LD_INT 1
113331: PPUSH
113332: CALL_OW 592
// p := 0 ;
113336: LD_ADDR_VAR 0 12
113340: PUSH
113341: LD_INT 0
113343: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113344: LD_VAR 0 9
113348: PPUSH
113349: LD_VAR 0 10
113353: PPUSH
113354: LD_VAR 0 6
113358: PPUSH
113359: LD_VAR 0 8
113363: PPUSH
113364: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
113368: LD_INT 35
113370: PPUSH
113371: CALL_OW 67
// p := Inc ( p ) ;
113375: LD_ADDR_VAR 0 12
113379: PUSH
113380: LD_VAR 0 12
113384: PPUSH
113385: CALL 56903 0 1
113389: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
113390: LD_VAR 0 12
113394: PUSH
113395: LD_INT 3
113397: EQUAL
113398: IFTRUE 113412
113400: PUSH
113401: LD_VAR 0 1
113405: PPUSH
113406: CALL_OW 302
113410: NOT
113411: OR
113412: IFTRUE 113425
113414: PUSH
113415: LD_VAR 0 1
113419: PPUSH
113420: CALL_OW 301
113424: OR
113425: IFFALSE 113368
// RemoveSeeing ( _x , _y , side ) ;
113427: LD_VAR 0 9
113431: PPUSH
113432: LD_VAR 0 10
113436: PPUSH
113437: LD_VAR 0 6
113441: PPUSH
113442: CALL_OW 331
// end ; end_of_file
113446: LD_VAR 0 4
113450: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113451: LD_INT 0
113453: PPUSH
113454: PPUSH
113455: PPUSH
113456: PPUSH
113457: PPUSH
113458: PPUSH
113459: PPUSH
113460: PPUSH
113461: PPUSH
113462: PPUSH
113463: PPUSH
113464: PPUSH
113465: PPUSH
113466: PPUSH
113467: PPUSH
113468: PPUSH
113469: PPUSH
113470: PPUSH
113471: PPUSH
113472: PPUSH
113473: PPUSH
113474: PPUSH
113475: PPUSH
113476: PPUSH
113477: PPUSH
113478: PPUSH
113479: PPUSH
113480: PPUSH
113481: PPUSH
113482: PPUSH
113483: PPUSH
113484: PPUSH
113485: PPUSH
113486: PPUSH
// if not list then
113487: LD_VAR 0 1
113491: NOT
113492: IFFALSE 113496
// exit ;
113494: GO 118215
// base := list [ 1 ] ;
113496: LD_ADDR_VAR 0 3
113500: PUSH
113501: LD_VAR 0 1
113505: PUSH
113506: LD_INT 1
113508: ARRAY
113509: ST_TO_ADDR
// group := list [ 2 ] ;
113510: LD_ADDR_VAR 0 4
113514: PUSH
113515: LD_VAR 0 1
113519: PUSH
113520: LD_INT 2
113522: ARRAY
113523: ST_TO_ADDR
// path := list [ 3 ] ;
113524: LD_ADDR_VAR 0 5
113528: PUSH
113529: LD_VAR 0 1
113533: PUSH
113534: LD_INT 3
113536: ARRAY
113537: ST_TO_ADDR
// flags := list [ 4 ] ;
113538: LD_ADDR_VAR 0 6
113542: PUSH
113543: LD_VAR 0 1
113547: PUSH
113548: LD_INT 4
113550: ARRAY
113551: ST_TO_ADDR
// mined := [ ] ;
113552: LD_ADDR_VAR 0 27
113556: PUSH
113557: EMPTY
113558: ST_TO_ADDR
// bombed := [ ] ;
113559: LD_ADDR_VAR 0 28
113563: PUSH
113564: EMPTY
113565: ST_TO_ADDR
// healers := [ ] ;
113566: LD_ADDR_VAR 0 31
113570: PUSH
113571: EMPTY
113572: ST_TO_ADDR
// to_heal := [ ] ;
113573: LD_ADDR_VAR 0 30
113577: PUSH
113578: EMPTY
113579: ST_TO_ADDR
// repairs := [ ] ;
113580: LD_ADDR_VAR 0 33
113584: PUSH
113585: EMPTY
113586: ST_TO_ADDR
// to_repair := [ ] ;
113587: LD_ADDR_VAR 0 32
113591: PUSH
113592: EMPTY
113593: ST_TO_ADDR
// if not group or not path then
113594: LD_VAR 0 4
113598: NOT
113599: IFTRUE 113608
113601: PUSH
113602: LD_VAR 0 5
113606: NOT
113607: OR
113608: IFFALSE 113612
// exit ;
113610: GO 118215
// side := GetSide ( group [ 1 ] ) ;
113612: LD_ADDR_VAR 0 35
113616: PUSH
113617: LD_VAR 0 4
113621: PUSH
113622: LD_INT 1
113624: ARRAY
113625: PPUSH
113626: CALL_OW 255
113630: ST_TO_ADDR
// if flags then
113631: LD_VAR 0 6
113635: IFFALSE 113779
// begin f_ignore_area := flags [ 1 ] ;
113637: LD_ADDR_VAR 0 17
113641: PUSH
113642: LD_VAR 0 6
113646: PUSH
113647: LD_INT 1
113649: ARRAY
113650: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113651: LD_ADDR_VAR 0 18
113655: PUSH
113656: LD_VAR 0 6
113660: PUSH
113661: LD_INT 2
113663: ARRAY
113664: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113665: LD_ADDR_VAR 0 19
113669: PUSH
113670: LD_VAR 0 6
113674: PUSH
113675: LD_INT 3
113677: ARRAY
113678: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113679: LD_ADDR_VAR 0 20
113683: PUSH
113684: LD_VAR 0 6
113688: PUSH
113689: LD_INT 4
113691: ARRAY
113692: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113693: LD_ADDR_VAR 0 21
113697: PUSH
113698: LD_VAR 0 6
113702: PUSH
113703: LD_INT 5
113705: ARRAY
113706: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113707: LD_ADDR_VAR 0 22
113711: PUSH
113712: LD_VAR 0 6
113716: PUSH
113717: LD_INT 6
113719: ARRAY
113720: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113721: LD_ADDR_VAR 0 23
113725: PUSH
113726: LD_VAR 0 6
113730: PUSH
113731: LD_INT 7
113733: ARRAY
113734: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113735: LD_ADDR_VAR 0 24
113739: PUSH
113740: LD_VAR 0 6
113744: PUSH
113745: LD_INT 8
113747: ARRAY
113748: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113749: LD_ADDR_VAR 0 25
113753: PUSH
113754: LD_VAR 0 6
113758: PUSH
113759: LD_INT 9
113761: ARRAY
113762: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113763: LD_ADDR_VAR 0 26
113767: PUSH
113768: LD_VAR 0 6
113772: PUSH
113773: LD_INT 10
113775: ARRAY
113776: ST_TO_ADDR
// end else
113777: GO 113859
// begin f_ignore_area := false ;
113779: LD_ADDR_VAR 0 17
113783: PUSH
113784: LD_INT 0
113786: ST_TO_ADDR
// f_capture := false ;
113787: LD_ADDR_VAR 0 18
113791: PUSH
113792: LD_INT 0
113794: ST_TO_ADDR
// f_ignore_civ := false ;
113795: LD_ADDR_VAR 0 19
113799: PUSH
113800: LD_INT 0
113802: ST_TO_ADDR
// f_murder := false ;
113803: LD_ADDR_VAR 0 20
113807: PUSH
113808: LD_INT 0
113810: ST_TO_ADDR
// f_mines := false ;
113811: LD_ADDR_VAR 0 21
113815: PUSH
113816: LD_INT 0
113818: ST_TO_ADDR
// f_repair := false ;
113819: LD_ADDR_VAR 0 22
113823: PUSH
113824: LD_INT 0
113826: ST_TO_ADDR
// f_heal := false ;
113827: LD_ADDR_VAR 0 23
113831: PUSH
113832: LD_INT 0
113834: ST_TO_ADDR
// f_spacetime := false ;
113835: LD_ADDR_VAR 0 24
113839: PUSH
113840: LD_INT 0
113842: ST_TO_ADDR
// f_attack_depot := false ;
113843: LD_ADDR_VAR 0 25
113847: PUSH
113848: LD_INT 0
113850: ST_TO_ADDR
// f_crawl := false ;
113851: LD_ADDR_VAR 0 26
113855: PUSH
113856: LD_INT 0
113858: ST_TO_ADDR
// end ; if f_heal then
113859: LD_VAR 0 23
113863: IFFALSE 113890
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113865: LD_ADDR_VAR 0 31
113869: PUSH
113870: LD_VAR 0 4
113874: PPUSH
113875: LD_INT 25
113877: PUSH
113878: LD_INT 4
113880: PUSH
113881: EMPTY
113882: LIST
113883: LIST
113884: PPUSH
113885: CALL_OW 72
113889: ST_TO_ADDR
// if f_repair then
113890: LD_VAR 0 22
113894: IFFALSE 113921
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113896: LD_ADDR_VAR 0 33
113900: PUSH
113901: LD_VAR 0 4
113905: PPUSH
113906: LD_INT 25
113908: PUSH
113909: LD_INT 3
113911: PUSH
113912: EMPTY
113913: LIST
113914: LIST
113915: PPUSH
113916: CALL_OW 72
113920: ST_TO_ADDR
// units_path := [ ] ;
113921: LD_ADDR_VAR 0 16
113925: PUSH
113926: EMPTY
113927: ST_TO_ADDR
// for i = 1 to group do
113928: LD_ADDR_VAR 0 7
113932: PUSH
113933: DOUBLE
113934: LD_INT 1
113936: DEC
113937: ST_TO_ADDR
113938: LD_VAR 0 4
113942: PUSH
113943: FOR_TO
113944: IFFALSE 113973
// units_path := Replace ( units_path , i , path ) ;
113946: LD_ADDR_VAR 0 16
113950: PUSH
113951: LD_VAR 0 16
113955: PPUSH
113956: LD_VAR 0 7
113960: PPUSH
113961: LD_VAR 0 5
113965: PPUSH
113966: CALL_OW 1
113970: ST_TO_ADDR
113971: GO 113943
113973: POP
113974: POP
// repeat for i = group downto 1 do
113975: LD_ADDR_VAR 0 7
113979: PUSH
113980: DOUBLE
113981: LD_VAR 0 4
113985: INC
113986: ST_TO_ADDR
113987: LD_INT 1
113989: PUSH
113990: FOR_DOWNTO
113991: IFFALSE 118167
// begin wait ( 5 ) ;
113993: LD_INT 5
113995: PPUSH
113996: CALL_OW 67
// tmp := [ ] ;
114000: LD_ADDR_VAR 0 14
114004: PUSH
114005: EMPTY
114006: ST_TO_ADDR
// attacking := false ;
114007: LD_ADDR_VAR 0 29
114011: PUSH
114012: LD_INT 0
114014: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114015: LD_VAR 0 4
114019: PUSH
114020: LD_VAR 0 7
114024: ARRAY
114025: PPUSH
114026: CALL_OW 301
114030: IFTRUE 114045
114032: PUSH
114033: LD_VAR 0 4
114037: PUSH
114038: LD_VAR 0 7
114042: ARRAY
114043: NOT
114044: OR
114045: IFFALSE 114154
// begin if GetType ( group [ i ] ) = unit_human then
114047: LD_VAR 0 4
114051: PUSH
114052: LD_VAR 0 7
114056: ARRAY
114057: PPUSH
114058: CALL_OW 247
114062: PUSH
114063: LD_INT 1
114065: EQUAL
114066: IFFALSE 114112
// begin to_heal := to_heal diff group [ i ] ;
114068: LD_ADDR_VAR 0 30
114072: PUSH
114073: LD_VAR 0 30
114077: PUSH
114078: LD_VAR 0 4
114082: PUSH
114083: LD_VAR 0 7
114087: ARRAY
114088: DIFF
114089: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114090: LD_ADDR_VAR 0 31
114094: PUSH
114095: LD_VAR 0 31
114099: PUSH
114100: LD_VAR 0 4
114104: PUSH
114105: LD_VAR 0 7
114109: ARRAY
114110: DIFF
114111: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114112: LD_ADDR_VAR 0 4
114116: PUSH
114117: LD_VAR 0 4
114121: PPUSH
114122: LD_VAR 0 7
114126: PPUSH
114127: CALL_OW 3
114131: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114132: LD_ADDR_VAR 0 16
114136: PUSH
114137: LD_VAR 0 16
114141: PPUSH
114142: LD_VAR 0 7
114146: PPUSH
114147: CALL_OW 3
114151: ST_TO_ADDR
// continue ;
114152: GO 113990
// end ; if f_repair then
114154: LD_VAR 0 22
114158: IFFALSE 114655
// begin if GetType ( group [ i ] ) = unit_vehicle then
114160: LD_VAR 0 4
114164: PUSH
114165: LD_VAR 0 7
114169: ARRAY
114170: PPUSH
114171: CALL_OW 247
114175: PUSH
114176: LD_INT 2
114178: EQUAL
114179: IFFALSE 114373
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114181: LD_VAR 0 4
114185: PUSH
114186: LD_VAR 0 7
114190: ARRAY
114191: PPUSH
114192: CALL_OW 256
114196: PUSH
114197: LD_INT 700
114199: LESS
114200: IFFALSE 114221
114202: PUSH
114203: LD_VAR 0 4
114207: PUSH
114208: LD_VAR 0 7
114212: ARRAY
114213: PUSH
114214: LD_VAR 0 32
114218: IN
114219: NOT
114220: AND
114221: IFFALSE 114245
// to_repair := to_repair union group [ i ] ;
114223: LD_ADDR_VAR 0 32
114227: PUSH
114228: LD_VAR 0 32
114232: PUSH
114233: LD_VAR 0 4
114237: PUSH
114238: LD_VAR 0 7
114242: ARRAY
114243: UNION
114244: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114245: LD_VAR 0 4
114249: PUSH
114250: LD_VAR 0 7
114254: ARRAY
114255: PPUSH
114256: CALL_OW 256
114260: PUSH
114261: LD_INT 1000
114263: EQUAL
114264: IFFALSE 114284
114266: PUSH
114267: LD_VAR 0 4
114271: PUSH
114272: LD_VAR 0 7
114276: ARRAY
114277: PUSH
114278: LD_VAR 0 32
114282: IN
114283: AND
114284: IFFALSE 114308
// to_repair := to_repair diff group [ i ] ;
114286: LD_ADDR_VAR 0 32
114290: PUSH
114291: LD_VAR 0 32
114295: PUSH
114296: LD_VAR 0 4
114300: PUSH
114301: LD_VAR 0 7
114305: ARRAY
114306: DIFF
114307: ST_TO_ADDR
// if group [ i ] in to_repair then
114308: LD_VAR 0 4
114312: PUSH
114313: LD_VAR 0 7
114317: ARRAY
114318: PUSH
114319: LD_VAR 0 32
114323: IN
114324: IFFALSE 114371
// begin if not IsInArea ( group [ i ] , f_repair ) then
114326: LD_VAR 0 4
114330: PUSH
114331: LD_VAR 0 7
114335: ARRAY
114336: PPUSH
114337: LD_VAR 0 22
114341: PPUSH
114342: CALL_OW 308
114346: NOT
114347: IFFALSE 114369
// ComMoveToArea ( group [ i ] , f_repair ) ;
114349: LD_VAR 0 4
114353: PUSH
114354: LD_VAR 0 7
114358: ARRAY
114359: PPUSH
114360: LD_VAR 0 22
114364: PPUSH
114365: CALL_OW 113
// continue ;
114369: GO 113990
// end ; end else
114371: GO 114655
// if group [ i ] in repairs then
114373: LD_VAR 0 4
114377: PUSH
114378: LD_VAR 0 7
114382: ARRAY
114383: PUSH
114384: LD_VAR 0 33
114388: IN
114389: IFFALSE 114655
// begin if IsInUnit ( group [ i ] ) then
114391: LD_VAR 0 4
114395: PUSH
114396: LD_VAR 0 7
114400: ARRAY
114401: PPUSH
114402: CALL_OW 310
114406: IFFALSE 114476
// begin z := IsInUnit ( group [ i ] ) ;
114408: LD_ADDR_VAR 0 13
114412: PUSH
114413: LD_VAR 0 4
114417: PUSH
114418: LD_VAR 0 7
114422: ARRAY
114423: PPUSH
114424: CALL_OW 310
114428: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114429: LD_VAR 0 13
114433: PUSH
114434: LD_VAR 0 32
114438: IN
114439: IFFALSE 114457
114441: PUSH
114442: LD_VAR 0 13
114446: PPUSH
114447: LD_VAR 0 22
114451: PPUSH
114452: CALL_OW 308
114456: AND
114457: IFFALSE 114474
// ComExitVehicle ( group [ i ] ) ;
114459: LD_VAR 0 4
114463: PUSH
114464: LD_VAR 0 7
114468: ARRAY
114469: PPUSH
114470: CALL_OW 121
// end else
114474: GO 114655
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114476: LD_ADDR_VAR 0 13
114480: PUSH
114481: LD_VAR 0 4
114485: PPUSH
114486: LD_INT 95
114488: PUSH
114489: LD_VAR 0 22
114493: PUSH
114494: EMPTY
114495: LIST
114496: LIST
114497: PUSH
114498: LD_INT 58
114500: PUSH
114501: EMPTY
114502: LIST
114503: PUSH
114504: EMPTY
114505: LIST
114506: LIST
114507: PPUSH
114508: CALL_OW 72
114512: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114513: LD_VAR 0 4
114517: PUSH
114518: LD_VAR 0 7
114522: ARRAY
114523: PPUSH
114524: CALL_OW 314
114528: NOT
114529: IFFALSE 114653
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114531: LD_ADDR_VAR 0 10
114535: PUSH
114536: LD_VAR 0 13
114540: PPUSH
114541: LD_VAR 0 4
114545: PUSH
114546: LD_VAR 0 7
114550: ARRAY
114551: PPUSH
114552: CALL_OW 74
114556: ST_TO_ADDR
// if not x then
114557: LD_VAR 0 10
114561: NOT
114562: IFFALSE 114566
// continue ;
114564: GO 113990
// if GetLives ( x ) < 1000 then
114566: LD_VAR 0 10
114570: PPUSH
114571: CALL_OW 256
114575: PUSH
114576: LD_INT 1000
114578: LESS
114579: IFFALSE 114603
// ComRepairVehicle ( group [ i ] , x ) else
114581: LD_VAR 0 4
114585: PUSH
114586: LD_VAR 0 7
114590: ARRAY
114591: PPUSH
114592: LD_VAR 0 10
114596: PPUSH
114597: CALL_OW 129
114601: GO 114653
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114603: LD_VAR 0 23
114607: IFFALSE 114630
114609: PUSH
114610: LD_VAR 0 4
114614: PUSH
114615: LD_VAR 0 7
114619: ARRAY
114620: PPUSH
114621: CALL_OW 256
114625: PUSH
114626: LD_INT 1000
114628: LESS
114629: AND
114630: NOT
114631: IFFALSE 114653
// ComEnterUnit ( group [ i ] , x ) ;
114633: LD_VAR 0 4
114637: PUSH
114638: LD_VAR 0 7
114642: ARRAY
114643: PPUSH
114644: LD_VAR 0 10
114648: PPUSH
114649: CALL_OW 120
// end ; continue ;
114653: GO 113990
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114655: LD_VAR 0 23
114659: IFFALSE 114682
114661: PUSH
114662: LD_VAR 0 4
114666: PUSH
114667: LD_VAR 0 7
114671: ARRAY
114672: PPUSH
114673: CALL_OW 247
114677: PUSH
114678: LD_INT 1
114680: EQUAL
114681: AND
114682: IFFALSE 115166
// begin if group [ i ] in healers then
114684: LD_VAR 0 4
114688: PUSH
114689: LD_VAR 0 7
114693: ARRAY
114694: PUSH
114695: LD_VAR 0 31
114699: IN
114700: IFFALSE 114977
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114702: LD_VAR 0 4
114706: PUSH
114707: LD_VAR 0 7
114711: ARRAY
114712: PPUSH
114713: LD_VAR 0 23
114717: PPUSH
114718: CALL_OW 308
114722: NOT
114723: IFFALSE 114743
114725: PUSH
114726: LD_VAR 0 4
114730: PUSH
114731: LD_VAR 0 7
114735: ARRAY
114736: PPUSH
114737: CALL_OW 314
114741: NOT
114742: AND
114743: IFFALSE 114767
// ComMoveToArea ( group [ i ] , f_heal ) else
114745: LD_VAR 0 4
114749: PUSH
114750: LD_VAR 0 7
114754: ARRAY
114755: PPUSH
114756: LD_VAR 0 23
114760: PPUSH
114761: CALL_OW 113
114765: GO 114975
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114767: LD_VAR 0 4
114771: PUSH
114772: LD_VAR 0 7
114776: ARRAY
114777: PPUSH
114778: CALL 52886 0 1
114782: PPUSH
114783: CALL_OW 256
114787: PUSH
114788: LD_INT 1000
114790: EQUAL
114791: IFFALSE 114810
// ComStop ( group [ i ] ) else
114793: LD_VAR 0 4
114797: PUSH
114798: LD_VAR 0 7
114802: ARRAY
114803: PPUSH
114804: CALL_OW 141
114808: GO 114975
// if not HasTask ( group [ i ] ) and to_heal then
114810: LD_VAR 0 4
114814: PUSH
114815: LD_VAR 0 7
114819: ARRAY
114820: PPUSH
114821: CALL_OW 314
114825: NOT
114826: IFFALSE 114834
114828: PUSH
114829: LD_VAR 0 30
114833: AND
114834: IFFALSE 114975
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114836: LD_ADDR_VAR 0 13
114840: PUSH
114841: LD_VAR 0 30
114845: PPUSH
114846: LD_INT 3
114848: PUSH
114849: LD_INT 54
114851: PUSH
114852: EMPTY
114853: LIST
114854: PUSH
114855: EMPTY
114856: LIST
114857: LIST
114858: PPUSH
114859: CALL_OW 72
114863: PPUSH
114864: LD_VAR 0 4
114868: PUSH
114869: LD_VAR 0 7
114873: ARRAY
114874: PPUSH
114875: CALL_OW 74
114879: ST_TO_ADDR
// if z then
114880: LD_VAR 0 13
114884: IFFALSE 114975
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114886: LD_INT 91
114888: PUSH
114889: LD_VAR 0 13
114893: PUSH
114894: LD_INT 10
114896: PUSH
114897: EMPTY
114898: LIST
114899: LIST
114900: LIST
114901: PUSH
114902: LD_INT 81
114904: PUSH
114905: LD_VAR 0 13
114909: PPUSH
114910: CALL_OW 255
114914: PUSH
114915: EMPTY
114916: LIST
114917: LIST
114918: PUSH
114919: EMPTY
114920: LIST
114921: LIST
114922: PPUSH
114923: CALL_OW 69
114927: PUSH
114928: LD_INT 0
114930: EQUAL
114931: IFFALSE 114955
// ComHeal ( group [ i ] , z ) else
114933: LD_VAR 0 4
114937: PUSH
114938: LD_VAR 0 7
114942: ARRAY
114943: PPUSH
114944: LD_VAR 0 13
114948: PPUSH
114949: CALL_OW 128
114953: GO 114975
// ComMoveToArea ( group [ i ] , f_heal ) ;
114955: LD_VAR 0 4
114959: PUSH
114960: LD_VAR 0 7
114964: ARRAY
114965: PPUSH
114966: LD_VAR 0 23
114970: PPUSH
114971: CALL_OW 113
// end ; continue ;
114975: GO 113990
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114977: LD_VAR 0 4
114981: PUSH
114982: LD_VAR 0 7
114986: ARRAY
114987: PPUSH
114988: CALL_OW 256
114992: PUSH
114993: LD_INT 700
114995: LESS
114996: IFFALSE 115017
114998: PUSH
114999: LD_VAR 0 4
115003: PUSH
115004: LD_VAR 0 7
115008: ARRAY
115009: PUSH
115010: LD_VAR 0 30
115014: IN
115015: NOT
115016: AND
115017: IFFALSE 115041
// to_heal := to_heal union group [ i ] ;
115019: LD_ADDR_VAR 0 30
115023: PUSH
115024: LD_VAR 0 30
115028: PUSH
115029: LD_VAR 0 4
115033: PUSH
115034: LD_VAR 0 7
115038: ARRAY
115039: UNION
115040: ST_TO_ADDR
// if group [ i ] in to_heal then
115041: LD_VAR 0 4
115045: PUSH
115046: LD_VAR 0 7
115050: ARRAY
115051: PUSH
115052: LD_VAR 0 30
115056: IN
115057: IFFALSE 115166
// begin if GetLives ( group [ i ] ) = 1000 then
115059: LD_VAR 0 4
115063: PUSH
115064: LD_VAR 0 7
115068: ARRAY
115069: PPUSH
115070: CALL_OW 256
115074: PUSH
115075: LD_INT 1000
115077: EQUAL
115078: IFFALSE 115104
// to_heal := to_heal diff group [ i ] else
115080: LD_ADDR_VAR 0 30
115084: PUSH
115085: LD_VAR 0 30
115089: PUSH
115090: LD_VAR 0 4
115094: PUSH
115095: LD_VAR 0 7
115099: ARRAY
115100: DIFF
115101: ST_TO_ADDR
115102: GO 115166
// begin if not IsInArea ( group [ i ] , to_heal ) then
115104: LD_VAR 0 4
115108: PUSH
115109: LD_VAR 0 7
115113: ARRAY
115114: PPUSH
115115: LD_VAR 0 30
115119: PPUSH
115120: CALL_OW 308
115124: NOT
115125: IFFALSE 115149
// ComMoveToArea ( group [ i ] , f_heal ) else
115127: LD_VAR 0 4
115131: PUSH
115132: LD_VAR 0 7
115136: ARRAY
115137: PPUSH
115138: LD_VAR 0 23
115142: PPUSH
115143: CALL_OW 113
115147: GO 115164
// ComHold ( group [ i ] ) ;
115149: LD_VAR 0 4
115153: PUSH
115154: LD_VAR 0 7
115158: ARRAY
115159: PPUSH
115160: CALL_OW 140
// continue ;
115164: GO 113990
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115166: LD_VAR 0 4
115170: PUSH
115171: LD_VAR 0 7
115175: ARRAY
115176: PPUSH
115177: LD_INT 10
115179: PPUSH
115180: CALL 50495 0 2
115184: NOT
115185: IFFALSE 115203
115187: PUSH
115188: LD_VAR 0 16
115192: PUSH
115193: LD_VAR 0 7
115197: ARRAY
115198: PUSH
115199: EMPTY
115200: EQUAL
115201: NOT
115202: AND
115203: IFFALSE 115469
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115205: LD_VAR 0 4
115209: PUSH
115210: LD_VAR 0 7
115214: ARRAY
115215: PPUSH
115216: CALL_OW 262
115220: PUSH
115221: LD_INT 1
115223: PUSH
115224: LD_INT 2
115226: PUSH
115227: EMPTY
115228: LIST
115229: LIST
115230: IN
115231: IFFALSE 115272
// if GetFuel ( group [ i ] ) < 10 then
115233: LD_VAR 0 4
115237: PUSH
115238: LD_VAR 0 7
115242: ARRAY
115243: PPUSH
115244: CALL_OW 261
115248: PUSH
115249: LD_INT 10
115251: LESS
115252: IFFALSE 115272
// SetFuel ( group [ i ] , 12 ) ;
115254: LD_VAR 0 4
115258: PUSH
115259: LD_VAR 0 7
115263: ARRAY
115264: PPUSH
115265: LD_INT 12
115267: PPUSH
115268: CALL_OW 240
// if units_path [ i ] then
115272: LD_VAR 0 16
115276: PUSH
115277: LD_VAR 0 7
115281: ARRAY
115282: IFFALSE 115467
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115284: LD_VAR 0 4
115288: PUSH
115289: LD_VAR 0 7
115293: ARRAY
115294: PPUSH
115295: LD_VAR 0 16
115299: PUSH
115300: LD_VAR 0 7
115304: ARRAY
115305: PUSH
115306: LD_INT 1
115308: ARRAY
115309: PUSH
115310: LD_INT 1
115312: ARRAY
115313: PPUSH
115314: LD_VAR 0 16
115318: PUSH
115319: LD_VAR 0 7
115323: ARRAY
115324: PUSH
115325: LD_INT 1
115327: ARRAY
115328: PUSH
115329: LD_INT 2
115331: ARRAY
115332: PPUSH
115333: CALL_OW 297
115337: PUSH
115338: LD_INT 6
115340: GREATER
115341: IFFALSE 115416
// begin if not HasTask ( group [ i ] ) then
115343: LD_VAR 0 4
115347: PUSH
115348: LD_VAR 0 7
115352: ARRAY
115353: PPUSH
115354: CALL_OW 314
115358: NOT
115359: IFFALSE 115414
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115361: LD_VAR 0 4
115365: PUSH
115366: LD_VAR 0 7
115370: ARRAY
115371: PPUSH
115372: LD_VAR 0 16
115376: PUSH
115377: LD_VAR 0 7
115381: ARRAY
115382: PUSH
115383: LD_INT 1
115385: ARRAY
115386: PUSH
115387: LD_INT 1
115389: ARRAY
115390: PPUSH
115391: LD_VAR 0 16
115395: PUSH
115396: LD_VAR 0 7
115400: ARRAY
115401: PUSH
115402: LD_INT 1
115404: ARRAY
115405: PUSH
115406: LD_INT 2
115408: ARRAY
115409: PPUSH
115410: CALL_OW 114
// end else
115414: GO 115467
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115416: LD_ADDR_VAR 0 15
115420: PUSH
115421: LD_VAR 0 16
115425: PUSH
115426: LD_VAR 0 7
115430: ARRAY
115431: PPUSH
115432: LD_INT 1
115434: PPUSH
115435: CALL_OW 3
115439: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115440: LD_ADDR_VAR 0 16
115444: PUSH
115445: LD_VAR 0 16
115449: PPUSH
115450: LD_VAR 0 7
115454: PPUSH
115455: LD_VAR 0 15
115459: PPUSH
115460: CALL_OW 1
115464: ST_TO_ADDR
// continue ;
115465: GO 113990
// end ; end ; end else
115467: GO 118165
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115469: LD_ADDR_VAR 0 14
115473: PUSH
115474: LD_INT 81
115476: PUSH
115477: LD_VAR 0 4
115481: PUSH
115482: LD_VAR 0 7
115486: ARRAY
115487: PPUSH
115488: CALL_OW 255
115492: PUSH
115493: EMPTY
115494: LIST
115495: LIST
115496: PPUSH
115497: CALL_OW 69
115501: ST_TO_ADDR
// if not tmp then
115502: LD_VAR 0 14
115506: NOT
115507: IFFALSE 115511
// continue ;
115509: GO 113990
// if f_ignore_area then
115511: LD_VAR 0 17
115515: IFFALSE 115603
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115517: LD_ADDR_VAR 0 15
115521: PUSH
115522: LD_VAR 0 14
115526: PPUSH
115527: LD_INT 3
115529: PUSH
115530: LD_INT 92
115532: PUSH
115533: LD_VAR 0 17
115537: PUSH
115538: LD_INT 1
115540: ARRAY
115541: PUSH
115542: LD_VAR 0 17
115546: PUSH
115547: LD_INT 2
115549: ARRAY
115550: PUSH
115551: LD_VAR 0 17
115555: PUSH
115556: LD_INT 3
115558: ARRAY
115559: PUSH
115560: EMPTY
115561: LIST
115562: LIST
115563: LIST
115564: LIST
115565: PUSH
115566: EMPTY
115567: LIST
115568: LIST
115569: PPUSH
115570: CALL_OW 72
115574: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115575: LD_VAR 0 14
115579: PUSH
115580: LD_VAR 0 15
115584: DIFF
115585: IFFALSE 115603
// tmp := tmp diff tmp2 ;
115587: LD_ADDR_VAR 0 14
115591: PUSH
115592: LD_VAR 0 14
115596: PUSH
115597: LD_VAR 0 15
115601: DIFF
115602: ST_TO_ADDR
// end ; if not f_murder then
115603: LD_VAR 0 20
115607: NOT
115608: IFFALSE 115666
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115610: LD_ADDR_VAR 0 15
115614: PUSH
115615: LD_VAR 0 14
115619: PPUSH
115620: LD_INT 3
115622: PUSH
115623: LD_INT 50
115625: PUSH
115626: EMPTY
115627: LIST
115628: PUSH
115629: EMPTY
115630: LIST
115631: LIST
115632: PPUSH
115633: CALL_OW 72
115637: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115638: LD_VAR 0 14
115642: PUSH
115643: LD_VAR 0 15
115647: DIFF
115648: IFFALSE 115666
// tmp := tmp diff tmp2 ;
115650: LD_ADDR_VAR 0 14
115654: PUSH
115655: LD_VAR 0 14
115659: PUSH
115660: LD_VAR 0 15
115664: DIFF
115665: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115666: LD_ADDR_VAR 0 14
115670: PUSH
115671: LD_VAR 0 4
115675: PUSH
115676: LD_VAR 0 7
115680: ARRAY
115681: PPUSH
115682: LD_VAR 0 14
115686: PPUSH
115687: LD_INT 1
115689: PPUSH
115690: LD_INT 1
115692: PPUSH
115693: CALL 22917 0 4
115697: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115698: LD_VAR 0 4
115702: PUSH
115703: LD_VAR 0 7
115707: ARRAY
115708: PPUSH
115709: CALL_OW 257
115713: PUSH
115714: LD_INT 1
115716: EQUAL
115717: IFFALSE 116177
// begin if WantPlant ( group [ i ] ) then
115719: LD_VAR 0 4
115723: PUSH
115724: LD_VAR 0 7
115728: ARRAY
115729: PPUSH
115730: CALL 22418 0 1
115734: IFFALSE 115738
// continue ;
115736: GO 113990
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115738: LD_VAR 0 18
115742: IFFALSE 115762
115744: PUSH
115745: LD_VAR 0 4
115749: PUSH
115750: LD_VAR 0 7
115754: ARRAY
115755: PPUSH
115756: CALL_OW 310
115760: NOT
115761: AND
115762: IFFALSE 115805
115764: PUSH
115765: LD_VAR 0 14
115769: PUSH
115770: LD_INT 1
115772: ARRAY
115773: PUSH
115774: LD_VAR 0 14
115778: PPUSH
115779: LD_INT 21
115781: PUSH
115782: LD_INT 2
115784: PUSH
115785: EMPTY
115786: LIST
115787: LIST
115788: PUSH
115789: LD_INT 58
115791: PUSH
115792: EMPTY
115793: LIST
115794: PUSH
115795: EMPTY
115796: LIST
115797: LIST
115798: PPUSH
115799: CALL_OW 72
115803: IN
115804: AND
115805: IFFALSE 115841
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115807: LD_VAR 0 4
115811: PUSH
115812: LD_VAR 0 7
115816: ARRAY
115817: PPUSH
115818: LD_VAR 0 14
115822: PUSH
115823: LD_INT 1
115825: ARRAY
115826: PPUSH
115827: CALL_OW 120
// attacking := true ;
115831: LD_ADDR_VAR 0 29
115835: PUSH
115836: LD_INT 1
115838: ST_TO_ADDR
// continue ;
115839: GO 113990
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115841: LD_VAR 0 26
115845: IFFALSE 115868
115847: PUSH
115848: LD_VAR 0 4
115852: PUSH
115853: LD_VAR 0 7
115857: ARRAY
115858: PPUSH
115859: CALL_OW 257
115863: PUSH
115864: LD_INT 1
115866: EQUAL
115867: AND
115868: IFFALSE 115891
115870: PUSH
115871: LD_VAR 0 4
115875: PUSH
115876: LD_VAR 0 7
115880: ARRAY
115881: PPUSH
115882: CALL_OW 256
115886: PUSH
115887: LD_INT 800
115889: LESS
115890: AND
115891: IFFALSE 115911
115893: PUSH
115894: LD_VAR 0 4
115898: PUSH
115899: LD_VAR 0 7
115903: ARRAY
115904: PPUSH
115905: CALL_OW 318
115909: NOT
115910: AND
115911: IFFALSE 115928
// ComCrawl ( group [ i ] ) ;
115913: LD_VAR 0 4
115917: PUSH
115918: LD_VAR 0 7
115922: ARRAY
115923: PPUSH
115924: CALL_OW 137
// if f_mines then
115928: LD_VAR 0 21
115932: IFFALSE 116177
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115934: LD_VAR 0 14
115938: PUSH
115939: LD_INT 1
115941: ARRAY
115942: PPUSH
115943: CALL_OW 247
115947: PUSH
115948: LD_INT 3
115950: EQUAL
115951: IFFALSE 115970
115953: PUSH
115954: LD_VAR 0 14
115958: PUSH
115959: LD_INT 1
115961: ARRAY
115962: PUSH
115963: LD_VAR 0 27
115967: IN
115968: NOT
115969: AND
115970: IFFALSE 116177
// begin x := GetX ( tmp [ 1 ] ) ;
115972: LD_ADDR_VAR 0 10
115976: PUSH
115977: LD_VAR 0 14
115981: PUSH
115982: LD_INT 1
115984: ARRAY
115985: PPUSH
115986: CALL_OW 250
115990: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115991: LD_ADDR_VAR 0 11
115995: PUSH
115996: LD_VAR 0 14
116000: PUSH
116001: LD_INT 1
116003: ARRAY
116004: PPUSH
116005: CALL_OW 251
116009: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116010: LD_ADDR_VAR 0 12
116014: PUSH
116015: LD_VAR 0 4
116019: PUSH
116020: LD_VAR 0 7
116024: ARRAY
116025: PPUSH
116026: CALL 50580 0 1
116030: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116031: LD_VAR 0 4
116035: PUSH
116036: LD_VAR 0 7
116040: ARRAY
116041: PPUSH
116042: LD_VAR 0 10
116046: PPUSH
116047: LD_VAR 0 11
116051: PPUSH
116052: LD_VAR 0 14
116056: PUSH
116057: LD_INT 1
116059: ARRAY
116060: PPUSH
116061: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116065: LD_VAR 0 4
116069: PUSH
116070: LD_VAR 0 7
116074: ARRAY
116075: PPUSH
116076: LD_VAR 0 10
116080: PPUSH
116081: LD_VAR 0 12
116085: PPUSH
116086: LD_INT 7
116088: PPUSH
116089: CALL_OW 272
116093: PPUSH
116094: LD_VAR 0 11
116098: PPUSH
116099: LD_VAR 0 12
116103: PPUSH
116104: LD_INT 7
116106: PPUSH
116107: CALL_OW 273
116111: PPUSH
116112: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116116: LD_VAR 0 4
116120: PUSH
116121: LD_VAR 0 7
116125: ARRAY
116126: PPUSH
116127: LD_INT 71
116129: PPUSH
116130: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116134: LD_ADDR_VAR 0 27
116138: PUSH
116139: LD_VAR 0 27
116143: PPUSH
116144: LD_VAR 0 27
116148: PUSH
116149: LD_INT 1
116151: PLUS
116152: PPUSH
116153: LD_VAR 0 14
116157: PUSH
116158: LD_INT 1
116160: ARRAY
116161: PPUSH
116162: CALL_OW 1
116166: ST_TO_ADDR
// attacking := true ;
116167: LD_ADDR_VAR 0 29
116171: PUSH
116172: LD_INT 1
116174: ST_TO_ADDR
// continue ;
116175: GO 113990
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116177: LD_VAR 0 4
116181: PUSH
116182: LD_VAR 0 7
116186: ARRAY
116187: PPUSH
116188: CALL_OW 257
116192: PUSH
116193: LD_INT 17
116195: EQUAL
116196: IFFALSE 116220
116198: PUSH
116199: LD_VAR 0 4
116203: PUSH
116204: LD_VAR 0 7
116208: ARRAY
116209: PPUSH
116210: CALL_OW 110
116214: PUSH
116215: LD_INT 71
116217: EQUAL
116218: NOT
116219: AND
116220: IFFALSE 116366
// begin attacking := false ;
116222: LD_ADDR_VAR 0 29
116226: PUSH
116227: LD_INT 0
116229: ST_TO_ADDR
// k := 5 ;
116230: LD_ADDR_VAR 0 9
116234: PUSH
116235: LD_INT 5
116237: ST_TO_ADDR
// if tmp < k then
116238: LD_VAR 0 14
116242: PUSH
116243: LD_VAR 0 9
116247: LESS
116248: IFFALSE 116260
// k := tmp ;
116250: LD_ADDR_VAR 0 9
116254: PUSH
116255: LD_VAR 0 14
116259: ST_TO_ADDR
// for j = 1 to k do
116260: LD_ADDR_VAR 0 8
116264: PUSH
116265: DOUBLE
116266: LD_INT 1
116268: DEC
116269: ST_TO_ADDR
116270: LD_VAR 0 9
116274: PUSH
116275: FOR_TO
116276: IFFALSE 116364
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116278: LD_VAR 0 14
116282: PUSH
116283: LD_VAR 0 8
116287: ARRAY
116288: PUSH
116289: LD_VAR 0 14
116293: PPUSH
116294: LD_INT 58
116296: PUSH
116297: EMPTY
116298: LIST
116299: PPUSH
116300: CALL_OW 72
116304: IN
116305: NOT
116306: IFFALSE 116362
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116308: LD_VAR 0 4
116312: PUSH
116313: LD_VAR 0 7
116317: ARRAY
116318: PPUSH
116319: LD_VAR 0 14
116323: PUSH
116324: LD_VAR 0 8
116328: ARRAY
116329: PPUSH
116330: CALL_OW 115
// attacking := true ;
116334: LD_ADDR_VAR 0 29
116338: PUSH
116339: LD_INT 1
116341: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116342: LD_VAR 0 4
116346: PUSH
116347: LD_VAR 0 7
116351: ARRAY
116352: PPUSH
116353: LD_INT 71
116355: PPUSH
116356: CALL_OW 109
// continue ;
116360: GO 116275
// end ; end ;
116362: GO 116275
116364: POP
116365: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116366: LD_VAR 0 4
116370: PUSH
116371: LD_VAR 0 7
116375: ARRAY
116376: PPUSH
116377: CALL_OW 257
116381: PUSH
116382: LD_INT 8
116384: EQUAL
116385: IFTRUE 116423
116387: PUSH
116388: LD_VAR 0 4
116392: PUSH
116393: LD_VAR 0 7
116397: ARRAY
116398: PPUSH
116399: CALL_OW 264
116403: PUSH
116404: LD_INT 28
116406: PUSH
116407: LD_INT 45
116409: PUSH
116410: LD_INT 7
116412: PUSH
116413: LD_INT 47
116415: PUSH
116416: EMPTY
116417: LIST
116418: LIST
116419: LIST
116420: LIST
116421: IN
116422: OR
116423: IFFALSE 116679
// begin attacking := false ;
116425: LD_ADDR_VAR 0 29
116429: PUSH
116430: LD_INT 0
116432: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116433: LD_VAR 0 14
116437: PUSH
116438: LD_INT 1
116440: ARRAY
116441: PPUSH
116442: CALL_OW 266
116446: PUSH
116447: LD_INT 32
116449: PUSH
116450: LD_INT 31
116452: PUSH
116453: LD_INT 33
116455: PUSH
116456: LD_INT 4
116458: PUSH
116459: LD_INT 5
116461: PUSH
116462: EMPTY
116463: LIST
116464: LIST
116465: LIST
116466: LIST
116467: LIST
116468: IN
116469: IFFALSE 116655
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116471: LD_ADDR_VAR 0 9
116475: PUSH
116476: LD_VAR 0 14
116480: PUSH
116481: LD_INT 1
116483: ARRAY
116484: PPUSH
116485: CALL_OW 266
116489: PPUSH
116490: LD_VAR 0 14
116494: PUSH
116495: LD_INT 1
116497: ARRAY
116498: PPUSH
116499: CALL_OW 250
116503: PPUSH
116504: LD_VAR 0 14
116508: PUSH
116509: LD_INT 1
116511: ARRAY
116512: PPUSH
116513: CALL_OW 251
116517: PPUSH
116518: LD_VAR 0 14
116522: PUSH
116523: LD_INT 1
116525: ARRAY
116526: PPUSH
116527: CALL_OW 254
116531: PPUSH
116532: LD_VAR 0 14
116536: PUSH
116537: LD_INT 1
116539: ARRAY
116540: PPUSH
116541: CALL_OW 248
116545: PPUSH
116546: LD_INT 0
116548: PPUSH
116549: CALL 31938 0 6
116553: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116554: LD_ADDR_VAR 0 8
116558: PUSH
116559: LD_VAR 0 4
116563: PUSH
116564: LD_VAR 0 7
116568: ARRAY
116569: PPUSH
116570: LD_VAR 0 9
116574: PPUSH
116575: CALL 50693 0 2
116579: ST_TO_ADDR
// if j then
116580: LD_VAR 0 8
116584: IFFALSE 116653
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116586: LD_VAR 0 8
116590: PUSH
116591: LD_INT 1
116593: ARRAY
116594: PPUSH
116595: LD_VAR 0 8
116599: PUSH
116600: LD_INT 2
116602: ARRAY
116603: PPUSH
116604: CALL_OW 488
116608: IFFALSE 116653
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116610: LD_VAR 0 4
116614: PUSH
116615: LD_VAR 0 7
116619: ARRAY
116620: PPUSH
116621: LD_VAR 0 8
116625: PUSH
116626: LD_INT 1
116628: ARRAY
116629: PPUSH
116630: LD_VAR 0 8
116634: PUSH
116635: LD_INT 2
116637: ARRAY
116638: PPUSH
116639: CALL_OW 116
// attacking := true ;
116643: LD_ADDR_VAR 0 29
116647: PUSH
116648: LD_INT 1
116650: ST_TO_ADDR
// continue ;
116651: GO 113990
// end ; end else
116653: GO 116679
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116655: LD_VAR 0 4
116659: PUSH
116660: LD_VAR 0 7
116664: ARRAY
116665: PPUSH
116666: LD_VAR 0 14
116670: PUSH
116671: LD_INT 1
116673: ARRAY
116674: PPUSH
116675: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116679: LD_VAR 0 4
116683: PUSH
116684: LD_VAR 0 7
116688: ARRAY
116689: PPUSH
116690: CALL_OW 265
116694: PUSH
116695: LD_INT 11
116697: EQUAL
116698: IFFALSE 116976
// begin k := 10 ;
116700: LD_ADDR_VAR 0 9
116704: PUSH
116705: LD_INT 10
116707: ST_TO_ADDR
// x := 0 ;
116708: LD_ADDR_VAR 0 10
116712: PUSH
116713: LD_INT 0
116715: ST_TO_ADDR
// if tmp < k then
116716: LD_VAR 0 14
116720: PUSH
116721: LD_VAR 0 9
116725: LESS
116726: IFFALSE 116738
// k := tmp ;
116728: LD_ADDR_VAR 0 9
116732: PUSH
116733: LD_VAR 0 14
116737: ST_TO_ADDR
// for j = k downto 1 do
116738: LD_ADDR_VAR 0 8
116742: PUSH
116743: DOUBLE
116744: LD_VAR 0 9
116748: INC
116749: ST_TO_ADDR
116750: LD_INT 1
116752: PUSH
116753: FOR_DOWNTO
116754: IFFALSE 116829
// begin if GetType ( tmp [ j ] ) = unit_human then
116756: LD_VAR 0 14
116760: PUSH
116761: LD_VAR 0 8
116765: ARRAY
116766: PPUSH
116767: CALL_OW 247
116771: PUSH
116772: LD_INT 1
116774: EQUAL
116775: IFFALSE 116827
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116777: LD_VAR 0 4
116781: PUSH
116782: LD_VAR 0 7
116786: ARRAY
116787: PPUSH
116788: LD_VAR 0 14
116792: PUSH
116793: LD_VAR 0 8
116797: ARRAY
116798: PPUSH
116799: CALL 50951 0 2
// x := tmp [ j ] ;
116803: LD_ADDR_VAR 0 10
116807: PUSH
116808: LD_VAR 0 14
116812: PUSH
116813: LD_VAR 0 8
116817: ARRAY
116818: ST_TO_ADDR
// attacking := true ;
116819: LD_ADDR_VAR 0 29
116823: PUSH
116824: LD_INT 1
116826: ST_TO_ADDR
// end ; end ;
116827: GO 116753
116829: POP
116830: POP
// if not x then
116831: LD_VAR 0 10
116835: NOT
116836: IFFALSE 116976
// begin attacking := true ;
116838: LD_ADDR_VAR 0 29
116842: PUSH
116843: LD_INT 1
116845: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116846: LD_VAR 0 4
116850: PUSH
116851: LD_VAR 0 7
116855: ARRAY
116856: PPUSH
116857: CALL_OW 250
116861: PPUSH
116862: LD_VAR 0 4
116866: PUSH
116867: LD_VAR 0 7
116871: ARRAY
116872: PPUSH
116873: CALL_OW 251
116877: PPUSH
116878: CALL_OW 546
116882: PUSH
116883: LD_INT 2
116885: ARRAY
116886: PUSH
116887: LD_VAR 0 14
116891: PUSH
116892: LD_INT 1
116894: ARRAY
116895: PPUSH
116896: CALL_OW 250
116900: PPUSH
116901: LD_VAR 0 14
116905: PUSH
116906: LD_INT 1
116908: ARRAY
116909: PPUSH
116910: CALL_OW 251
116914: PPUSH
116915: CALL_OW 546
116919: PUSH
116920: LD_INT 2
116922: ARRAY
116923: EQUAL
116924: IFFALSE 116952
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116926: LD_VAR 0 4
116930: PUSH
116931: LD_VAR 0 7
116935: ARRAY
116936: PPUSH
116937: LD_VAR 0 14
116941: PUSH
116942: LD_INT 1
116944: ARRAY
116945: PPUSH
116946: CALL 50951 0 2
116950: GO 116976
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116952: LD_VAR 0 4
116956: PUSH
116957: LD_VAR 0 7
116961: ARRAY
116962: PPUSH
116963: LD_VAR 0 14
116967: PUSH
116968: LD_INT 1
116970: ARRAY
116971: PPUSH
116972: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116976: LD_VAR 0 4
116980: PUSH
116981: LD_VAR 0 7
116985: ARRAY
116986: PPUSH
116987: CALL_OW 264
116991: PUSH
116992: LD_INT 29
116994: EQUAL
116995: IFFALSE 117365
// begin if WantsToAttack ( group [ i ] ) in bombed then
116997: LD_VAR 0 4
117001: PUSH
117002: LD_VAR 0 7
117006: ARRAY
117007: PPUSH
117008: CALL_OW 319
117012: PUSH
117013: LD_VAR 0 28
117017: IN
117018: IFFALSE 117022
// continue ;
117020: GO 113990
// k := 8 ;
117022: LD_ADDR_VAR 0 9
117026: PUSH
117027: LD_INT 8
117029: ST_TO_ADDR
// x := 0 ;
117030: LD_ADDR_VAR 0 10
117034: PUSH
117035: LD_INT 0
117037: ST_TO_ADDR
// if tmp < k then
117038: LD_VAR 0 14
117042: PUSH
117043: LD_VAR 0 9
117047: LESS
117048: IFFALSE 117060
// k := tmp ;
117050: LD_ADDR_VAR 0 9
117054: PUSH
117055: LD_VAR 0 14
117059: ST_TO_ADDR
// for j = 1 to k do
117060: LD_ADDR_VAR 0 8
117064: PUSH
117065: DOUBLE
117066: LD_INT 1
117068: DEC
117069: ST_TO_ADDR
117070: LD_VAR 0 9
117074: PUSH
117075: FOR_TO
117076: IFFALSE 117210
// begin if GetType ( tmp [ j ] ) = unit_building then
117078: LD_VAR 0 14
117082: PUSH
117083: LD_VAR 0 8
117087: ARRAY
117088: PPUSH
117089: CALL_OW 247
117093: PUSH
117094: LD_INT 3
117096: EQUAL
117097: IFFALSE 117208
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117099: LD_VAR 0 14
117103: PUSH
117104: LD_VAR 0 8
117108: ARRAY
117109: PUSH
117110: LD_VAR 0 28
117114: IN
117115: NOT
117116: IFFALSE 117135
117118: PUSH
117119: LD_VAR 0 14
117123: PUSH
117124: LD_VAR 0 8
117128: ARRAY
117129: PPUSH
117130: CALL_OW 313
117134: AND
117135: IFFALSE 117208
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117137: LD_VAR 0 4
117141: PUSH
117142: LD_VAR 0 7
117146: ARRAY
117147: PPUSH
117148: LD_VAR 0 14
117152: PUSH
117153: LD_VAR 0 8
117157: ARRAY
117158: PPUSH
117159: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117163: LD_ADDR_VAR 0 28
117167: PUSH
117168: LD_VAR 0 28
117172: PPUSH
117173: LD_VAR 0 28
117177: PUSH
117178: LD_INT 1
117180: PLUS
117181: PPUSH
117182: LD_VAR 0 14
117186: PUSH
117187: LD_VAR 0 8
117191: ARRAY
117192: PPUSH
117193: CALL_OW 1
117197: ST_TO_ADDR
// attacking := true ;
117198: LD_ADDR_VAR 0 29
117202: PUSH
117203: LD_INT 1
117205: ST_TO_ADDR
// break ;
117206: GO 117210
// end ; end ;
117208: GO 117075
117210: POP
117211: POP
// if not attacking and f_attack_depot then
117212: LD_VAR 0 29
117216: NOT
117217: IFFALSE 117225
117219: PUSH
117220: LD_VAR 0 25
117224: AND
117225: IFFALSE 117320
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117227: LD_ADDR_VAR 0 13
117231: PUSH
117232: LD_VAR 0 14
117236: PPUSH
117237: LD_INT 2
117239: PUSH
117240: LD_INT 30
117242: PUSH
117243: LD_INT 0
117245: PUSH
117246: EMPTY
117247: LIST
117248: LIST
117249: PUSH
117250: LD_INT 30
117252: PUSH
117253: LD_INT 1
117255: PUSH
117256: EMPTY
117257: LIST
117258: LIST
117259: PUSH
117260: EMPTY
117261: LIST
117262: LIST
117263: LIST
117264: PPUSH
117265: CALL_OW 72
117269: ST_TO_ADDR
// if z then
117270: LD_VAR 0 13
117274: IFFALSE 117320
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117276: LD_VAR 0 4
117280: PUSH
117281: LD_VAR 0 7
117285: ARRAY
117286: PPUSH
117287: LD_VAR 0 13
117291: PPUSH
117292: LD_VAR 0 4
117296: PUSH
117297: LD_VAR 0 7
117301: ARRAY
117302: PPUSH
117303: CALL_OW 74
117307: PPUSH
117308: CALL_OW 115
// attacking := true ;
117312: LD_ADDR_VAR 0 29
117316: PUSH
117317: LD_INT 1
117319: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117320: LD_VAR 0 4
117324: PUSH
117325: LD_VAR 0 7
117329: ARRAY
117330: PPUSH
117331: CALL_OW 256
117335: PUSH
117336: LD_INT 500
117338: LESS
117339: IFFALSE 117365
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117341: LD_VAR 0 4
117345: PUSH
117346: LD_VAR 0 7
117350: ARRAY
117351: PPUSH
117352: LD_VAR 0 14
117356: PUSH
117357: LD_INT 1
117359: ARRAY
117360: PPUSH
117361: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117365: LD_VAR 0 4
117369: PUSH
117370: LD_VAR 0 7
117374: ARRAY
117375: PPUSH
117376: CALL_OW 264
117380: PUSH
117381: LD_INT 49
117383: EQUAL
117384: IFFALSE 117505
// begin if not HasTask ( group [ i ] ) then
117386: LD_VAR 0 4
117390: PUSH
117391: LD_VAR 0 7
117395: ARRAY
117396: PPUSH
117397: CALL_OW 314
117401: NOT
117402: IFFALSE 117505
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117404: LD_ADDR_VAR 0 9
117408: PUSH
117409: LD_INT 81
117411: PUSH
117412: LD_VAR 0 4
117416: PUSH
117417: LD_VAR 0 7
117421: ARRAY
117422: PPUSH
117423: CALL_OW 255
117427: PUSH
117428: EMPTY
117429: LIST
117430: LIST
117431: PPUSH
117432: CALL_OW 69
117436: PPUSH
117437: LD_VAR 0 4
117441: PUSH
117442: LD_VAR 0 7
117446: ARRAY
117447: PPUSH
117448: CALL_OW 74
117452: ST_TO_ADDR
// if k then
117453: LD_VAR 0 9
117457: IFFALSE 117505
// if GetDistUnits ( group [ i ] , k ) > 10 then
117459: LD_VAR 0 4
117463: PUSH
117464: LD_VAR 0 7
117468: ARRAY
117469: PPUSH
117470: LD_VAR 0 9
117474: PPUSH
117475: CALL_OW 296
117479: PUSH
117480: LD_INT 10
117482: GREATER
117483: IFFALSE 117505
// ComMoveUnit ( group [ i ] , k ) ;
117485: LD_VAR 0 4
117489: PUSH
117490: LD_VAR 0 7
117494: ARRAY
117495: PPUSH
117496: LD_VAR 0 9
117500: PPUSH
117501: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117505: LD_VAR 0 4
117509: PUSH
117510: LD_VAR 0 7
117514: ARRAY
117515: PPUSH
117516: CALL_OW 256
117520: PUSH
117521: LD_INT 250
117523: LESS
117524: IFFALSE 117568
117526: PUSH
117527: LD_VAR 0 4
117531: PUSH
117532: LD_VAR 0 7
117536: ARRAY
117537: PUSH
117538: LD_INT 21
117540: PUSH
117541: LD_INT 2
117543: PUSH
117544: EMPTY
117545: LIST
117546: LIST
117547: PUSH
117548: LD_INT 23
117550: PUSH
117551: LD_INT 2
117553: PUSH
117554: EMPTY
117555: LIST
117556: LIST
117557: PUSH
117558: EMPTY
117559: LIST
117560: LIST
117561: PPUSH
117562: CALL_OW 69
117566: IN
117567: AND
117568: IFFALSE 117695
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117570: LD_ADDR_VAR 0 9
117574: PUSH
117575: LD_OWVAR 3
117579: PUSH
117580: LD_VAR 0 4
117584: PUSH
117585: LD_VAR 0 7
117589: ARRAY
117590: DIFF
117591: PPUSH
117592: LD_VAR 0 4
117596: PUSH
117597: LD_VAR 0 7
117601: ARRAY
117602: PPUSH
117603: CALL_OW 74
117607: ST_TO_ADDR
// if not k then
117608: LD_VAR 0 9
117612: NOT
117613: IFFALSE 117617
// continue ;
117615: GO 113990
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117617: LD_VAR 0 9
117621: PUSH
117622: LD_INT 81
117624: PUSH
117625: LD_VAR 0 4
117629: PUSH
117630: LD_VAR 0 7
117634: ARRAY
117635: PPUSH
117636: CALL_OW 255
117640: PUSH
117641: EMPTY
117642: LIST
117643: LIST
117644: PPUSH
117645: CALL_OW 69
117649: IN
117650: IFFALSE 117678
117652: PUSH
117653: LD_VAR 0 9
117657: PPUSH
117658: LD_VAR 0 4
117662: PUSH
117663: LD_VAR 0 7
117667: ARRAY
117668: PPUSH
117669: CALL_OW 296
117673: PUSH
117674: LD_INT 5
117676: LESS
117677: AND
117678: IFFALSE 117695
// ComAutodestruct ( group [ i ] ) ;
117680: LD_VAR 0 4
117684: PUSH
117685: LD_VAR 0 7
117689: ARRAY
117690: PPUSH
117691: CALL 50847 0 1
// end ; if f_attack_depot then
117695: LD_VAR 0 25
117699: IFFALSE 117811
// begin k := 6 ;
117701: LD_ADDR_VAR 0 9
117705: PUSH
117706: LD_INT 6
117708: ST_TO_ADDR
// if tmp < k then
117709: LD_VAR 0 14
117713: PUSH
117714: LD_VAR 0 9
117718: LESS
117719: IFFALSE 117731
// k := tmp ;
117721: LD_ADDR_VAR 0 9
117725: PUSH
117726: LD_VAR 0 14
117730: ST_TO_ADDR
// for j = 1 to k do
117731: LD_ADDR_VAR 0 8
117735: PUSH
117736: DOUBLE
117737: LD_INT 1
117739: DEC
117740: ST_TO_ADDR
117741: LD_VAR 0 9
117745: PUSH
117746: FOR_TO
117747: IFFALSE 117809
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117749: LD_VAR 0 8
117753: PPUSH
117754: CALL_OW 266
117758: PUSH
117759: LD_INT 0
117761: PUSH
117762: LD_INT 1
117764: PUSH
117765: EMPTY
117766: LIST
117767: LIST
117768: IN
117769: IFFALSE 117807
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117771: LD_VAR 0 4
117775: PUSH
117776: LD_VAR 0 7
117780: ARRAY
117781: PPUSH
117782: LD_VAR 0 14
117786: PUSH
117787: LD_VAR 0 8
117791: ARRAY
117792: PPUSH
117793: CALL_OW 115
// attacking := true ;
117797: LD_ADDR_VAR 0 29
117801: PUSH
117802: LD_INT 1
117804: ST_TO_ADDR
// break ;
117805: GO 117809
// end ;
117807: GO 117746
117809: POP
117810: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117811: LD_VAR 0 4
117815: PUSH
117816: LD_VAR 0 7
117820: ARRAY
117821: PPUSH
117822: CALL_OW 302
117826: IFFALSE 117835
117828: PUSH
117829: LD_VAR 0 29
117833: NOT
117834: AND
117835: IFFALSE 118165
// begin if GetTag ( group [ i ] ) = 71 then
117837: LD_VAR 0 4
117841: PUSH
117842: LD_VAR 0 7
117846: ARRAY
117847: PPUSH
117848: CALL_OW 110
117852: PUSH
117853: LD_INT 71
117855: EQUAL
117856: IFFALSE 117897
// begin if HasTask ( group [ i ] ) then
117858: LD_VAR 0 4
117862: PUSH
117863: LD_VAR 0 7
117867: ARRAY
117868: PPUSH
117869: CALL_OW 314
117873: IFFALSE 117879
// continue else
117875: GO 113990
117877: GO 117897
// SetTag ( group [ i ] , 0 ) ;
117879: LD_VAR 0 4
117883: PUSH
117884: LD_VAR 0 7
117888: ARRAY
117889: PPUSH
117890: LD_INT 0
117892: PPUSH
117893: CALL_OW 109
// end ; k := 8 ;
117897: LD_ADDR_VAR 0 9
117901: PUSH
117902: LD_INT 8
117904: ST_TO_ADDR
// x := 0 ;
117905: LD_ADDR_VAR 0 10
117909: PUSH
117910: LD_INT 0
117912: ST_TO_ADDR
// if tmp < k then
117913: LD_VAR 0 14
117917: PUSH
117918: LD_VAR 0 9
117922: LESS
117923: IFFALSE 117935
// k := tmp ;
117925: LD_ADDR_VAR 0 9
117929: PUSH
117930: LD_VAR 0 14
117934: ST_TO_ADDR
// for j = 1 to k do
117935: LD_ADDR_VAR 0 8
117939: PUSH
117940: DOUBLE
117941: LD_INT 1
117943: DEC
117944: ST_TO_ADDR
117945: LD_VAR 0 9
117949: PUSH
117950: FOR_TO
117951: IFFALSE 118057
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117953: LD_VAR 0 14
117957: PUSH
117958: LD_VAR 0 8
117962: ARRAY
117963: PPUSH
117964: CALL_OW 247
117968: PUSH
117969: LD_INT 1
117971: EQUAL
117972: IFFALSE 118035
117974: PUSH
117975: LD_VAR 0 14
117979: PUSH
117980: LD_VAR 0 8
117984: ARRAY
117985: PPUSH
117986: CALL_OW 256
117990: PUSH
117991: LD_INT 250
117993: LESS
117994: IFFALSE 118002
117996: PUSH
117997: LD_VAR 0 20
118001: AND
118002: IFTRUE 118034
118004: PUSH
118005: LD_VAR 0 20
118009: NOT
118010: IFFALSE 118033
118012: PUSH
118013: LD_VAR 0 14
118017: PUSH
118018: LD_VAR 0 8
118022: ARRAY
118023: PPUSH
118024: CALL_OW 256
118028: PUSH
118029: LD_INT 250
118031: GREATEREQUAL
118032: AND
118033: OR
118034: AND
118035: IFFALSE 118055
// begin x := tmp [ j ] ;
118037: LD_ADDR_VAR 0 10
118041: PUSH
118042: LD_VAR 0 14
118046: PUSH
118047: LD_VAR 0 8
118051: ARRAY
118052: ST_TO_ADDR
// break ;
118053: GO 118057
// end ;
118055: GO 117950
118057: POP
118058: POP
// if x then
118059: LD_VAR 0 10
118063: IFFALSE 118087
// ComAttackUnit ( group [ i ] , x ) else
118065: LD_VAR 0 4
118069: PUSH
118070: LD_VAR 0 7
118074: ARRAY
118075: PPUSH
118076: LD_VAR 0 10
118080: PPUSH
118081: CALL_OW 115
118085: GO 118111
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118087: LD_VAR 0 4
118091: PUSH
118092: LD_VAR 0 7
118096: ARRAY
118097: PPUSH
118098: LD_VAR 0 14
118102: PUSH
118103: LD_INT 1
118105: ARRAY
118106: PPUSH
118107: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118111: LD_VAR 0 4
118115: PUSH
118116: LD_VAR 0 7
118120: ARRAY
118121: PPUSH
118122: CALL_OW 314
118126: NOT
118127: IFFALSE 118165
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118129: LD_VAR 0 4
118133: PUSH
118134: LD_VAR 0 7
118138: ARRAY
118139: PPUSH
118140: LD_VAR 0 14
118144: PPUSH
118145: LD_VAR 0 4
118149: PUSH
118150: LD_VAR 0 7
118154: ARRAY
118155: PPUSH
118156: CALL_OW 74
118160: PPUSH
118161: CALL_OW 115
// end ; end ; end ;
118165: GO 113990
118167: POP
118168: POP
// wait ( 0 0$2 ) ;
118169: LD_INT 70
118171: PPUSH
118172: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118176: LD_VAR 0 4
118180: NOT
118181: IFTRUE 118192
118183: PUSH
118184: LD_VAR 0 4
118188: PUSH
118189: EMPTY
118190: EQUAL
118191: OR
118192: IFTRUE 118213
118194: PUSH
118195: LD_INT 81
118197: PUSH
118198: LD_VAR 0 35
118202: PUSH
118203: EMPTY
118204: LIST
118205: LIST
118206: PPUSH
118207: CALL_OW 69
118211: NOT
118212: OR
118213: IFFALSE 113975
// end ;
118215: LD_VAR 0 2
118219: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118220: LD_INT 0
118222: PPUSH
118223: PPUSH
118224: PPUSH
118225: PPUSH
118226: PPUSH
118227: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118228: LD_VAR 0 1
118232: NOT
118233: IFTRUE 118248
118235: PUSH
118236: LD_EXP 63
118240: PUSH
118241: LD_VAR 0 1
118245: ARRAY
118246: NOT
118247: OR
118248: IFTRUE 118257
118250: PUSH
118251: LD_VAR 0 2
118255: NOT
118256: OR
118257: IFFALSE 118261
// exit ;
118259: GO 118819
// side := mc_sides [ base ] ;
118261: LD_ADDR_VAR 0 6
118265: PUSH
118266: LD_EXP 89
118270: PUSH
118271: LD_VAR 0 1
118275: ARRAY
118276: ST_TO_ADDR
// if not side then
118277: LD_VAR 0 6
118281: NOT
118282: IFFALSE 118286
// exit ;
118284: GO 118819
// for i in solds do
118286: LD_ADDR_VAR 0 7
118290: PUSH
118291: LD_VAR 0 2
118295: PUSH
118296: FOR_IN
118297: IFFALSE 118358
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118299: LD_VAR 0 7
118303: PPUSH
118304: CALL_OW 310
118308: PPUSH
118309: CALL_OW 266
118313: PUSH
118314: LD_INT 32
118316: PUSH
118317: LD_INT 31
118319: PUSH
118320: EMPTY
118321: LIST
118322: LIST
118323: IN
118324: IFFALSE 118344
// solds := solds diff i else
118326: LD_ADDR_VAR 0 2
118330: PUSH
118331: LD_VAR 0 2
118335: PUSH
118336: LD_VAR 0 7
118340: DIFF
118341: ST_TO_ADDR
118342: GO 118356
// SetTag ( i , 18 ) ;
118344: LD_VAR 0 7
118348: PPUSH
118349: LD_INT 18
118351: PPUSH
118352: CALL_OW 109
118356: GO 118296
118358: POP
118359: POP
// if not solds then
118360: LD_VAR 0 2
118364: NOT
118365: IFFALSE 118369
// exit ;
118367: GO 118819
// repeat wait ( 0 0$2 ) ;
118369: LD_INT 70
118371: PPUSH
118372: CALL_OW 67
// enemy := mc_scan [ base ] ;
118376: LD_ADDR_VAR 0 4
118380: PUSH
118381: LD_EXP 86
118385: PUSH
118386: LD_VAR 0 1
118390: ARRAY
118391: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118392: LD_EXP 63
118396: PUSH
118397: LD_VAR 0 1
118401: ARRAY
118402: NOT
118403: IFTRUE 118420
118405: PUSH
118406: LD_EXP 63
118410: PUSH
118411: LD_VAR 0 1
118415: ARRAY
118416: PUSH
118417: EMPTY
118418: EQUAL
118419: OR
118420: IFFALSE 118457
// begin for i in solds do
118422: LD_ADDR_VAR 0 7
118426: PUSH
118427: LD_VAR 0 2
118431: PUSH
118432: FOR_IN
118433: IFFALSE 118446
// ComStop ( i ) ;
118435: LD_VAR 0 7
118439: PPUSH
118440: CALL_OW 141
118444: GO 118432
118446: POP
118447: POP
// solds := [ ] ;
118448: LD_ADDR_VAR 0 2
118452: PUSH
118453: EMPTY
118454: ST_TO_ADDR
// exit ;
118455: GO 118819
// end ; for i in solds do
118457: LD_ADDR_VAR 0 7
118461: PUSH
118462: LD_VAR 0 2
118466: PUSH
118467: FOR_IN
118468: IFFALSE 118789
// begin if IsInUnit ( i ) then
118470: LD_VAR 0 7
118474: PPUSH
118475: CALL_OW 310
118479: IFFALSE 118490
// ComExitBuilding ( i ) ;
118481: LD_VAR 0 7
118485: PPUSH
118486: CALL_OW 122
// if GetLives ( i ) > 500 then
118490: LD_VAR 0 7
118494: PPUSH
118495: CALL_OW 256
118499: PUSH
118500: LD_INT 500
118502: GREATER
118503: IFFALSE 118556
// begin e := NearestUnitToUnit ( enemy , i ) ;
118505: LD_ADDR_VAR 0 5
118509: PUSH
118510: LD_VAR 0 4
118514: PPUSH
118515: LD_VAR 0 7
118519: PPUSH
118520: CALL_OW 74
118524: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118525: LD_VAR 0 7
118529: PPUSH
118530: LD_VAR 0 5
118534: PPUSH
118535: CALL_OW 250
118539: PPUSH
118540: LD_VAR 0 5
118544: PPUSH
118545: CALL_OW 251
118549: PPUSH
118550: CALL_OW 114
// end else
118554: GO 118787
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118556: LD_VAR 0 7
118560: PPUSH
118561: LD_EXP 63
118565: PUSH
118566: LD_VAR 0 1
118570: ARRAY
118571: PPUSH
118572: LD_INT 2
118574: PUSH
118575: LD_INT 30
118577: PUSH
118578: LD_INT 0
118580: PUSH
118581: EMPTY
118582: LIST
118583: LIST
118584: PUSH
118585: LD_INT 30
118587: PUSH
118588: LD_INT 1
118590: PUSH
118591: EMPTY
118592: LIST
118593: LIST
118594: PUSH
118595: LD_INT 30
118597: PUSH
118598: LD_INT 6
118600: PUSH
118601: EMPTY
118602: LIST
118603: LIST
118604: PUSH
118605: EMPTY
118606: LIST
118607: LIST
118608: LIST
118609: LIST
118610: PPUSH
118611: CALL_OW 72
118615: PPUSH
118616: LD_VAR 0 7
118620: PPUSH
118621: CALL_OW 74
118625: PPUSH
118626: CALL_OW 296
118630: PUSH
118631: LD_INT 10
118633: GREATER
118634: IFFALSE 118787
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118636: LD_ADDR_VAR 0 8
118640: PUSH
118641: LD_EXP 63
118645: PUSH
118646: LD_VAR 0 1
118650: ARRAY
118651: PPUSH
118652: LD_INT 2
118654: PUSH
118655: LD_INT 30
118657: PUSH
118658: LD_INT 0
118660: PUSH
118661: EMPTY
118662: LIST
118663: LIST
118664: PUSH
118665: LD_INT 30
118667: PUSH
118668: LD_INT 1
118670: PUSH
118671: EMPTY
118672: LIST
118673: LIST
118674: PUSH
118675: LD_INT 30
118677: PUSH
118678: LD_INT 6
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: PUSH
118685: EMPTY
118686: LIST
118687: LIST
118688: LIST
118689: LIST
118690: PPUSH
118691: CALL_OW 72
118695: PPUSH
118696: LD_VAR 0 7
118700: PPUSH
118701: CALL_OW 74
118705: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118706: LD_VAR 0 7
118710: PPUSH
118711: LD_VAR 0 8
118715: PPUSH
118716: CALL_OW 250
118720: PPUSH
118721: LD_INT 3
118723: PPUSH
118724: LD_INT 5
118726: PPUSH
118727: CALL_OW 272
118731: PPUSH
118732: LD_VAR 0 8
118736: PPUSH
118737: CALL_OW 251
118741: PPUSH
118742: LD_INT 3
118744: PPUSH
118745: LD_INT 5
118747: PPUSH
118748: CALL_OW 273
118752: PPUSH
118753: CALL_OW 111
// SetTag ( i , 0 ) ;
118757: LD_VAR 0 7
118761: PPUSH
118762: LD_INT 0
118764: PPUSH
118765: CALL_OW 109
// solds := solds diff i ;
118769: LD_ADDR_VAR 0 2
118773: PUSH
118774: LD_VAR 0 2
118778: PUSH
118779: LD_VAR 0 7
118783: DIFF
118784: ST_TO_ADDR
// continue ;
118785: GO 118467
// end ; end ;
118787: GO 118467
118789: POP
118790: POP
// until not solds or not enemy ;
118791: LD_VAR 0 2
118795: NOT
118796: IFTRUE 118805
118798: PUSH
118799: LD_VAR 0 4
118803: NOT
118804: OR
118805: IFFALSE 118369
// MC_Reset ( base , 18 ) ;
118807: LD_VAR 0 1
118811: PPUSH
118812: LD_INT 18
118814: PPUSH
118815: CALL 65053 0 2
// end ;
118819: LD_VAR 0 3
118823: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118824: LD_INT 0
118826: PPUSH
118827: PPUSH
118828: PPUSH
118829: PPUSH
118830: PPUSH
118831: PPUSH
118832: PPUSH
118833: PPUSH
118834: PPUSH
118835: PPUSH
118836: PPUSH
118837: PPUSH
118838: PPUSH
118839: PPUSH
118840: PPUSH
118841: PPUSH
118842: PPUSH
118843: PPUSH
118844: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118845: LD_ADDR_VAR 0 12
118849: PUSH
118850: LD_EXP 63
118854: PUSH
118855: LD_VAR 0 1
118859: ARRAY
118860: PPUSH
118861: LD_INT 25
118863: PUSH
118864: LD_INT 3
118866: PUSH
118867: EMPTY
118868: LIST
118869: LIST
118870: PPUSH
118871: CALL_OW 72
118875: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118876: LD_EXP 103
118880: PUSH
118881: LD_VAR 0 1
118885: ARRAY
118886: IFFALSE 118910
// mechs := mechs diff mc_remote_driver [ base ] ;
118888: LD_ADDR_VAR 0 12
118892: PUSH
118893: LD_VAR 0 12
118897: PUSH
118898: LD_EXP 103
118902: PUSH
118903: LD_VAR 0 1
118907: ARRAY
118908: DIFF
118909: ST_TO_ADDR
// for i in mechs do
118910: LD_ADDR_VAR 0 4
118914: PUSH
118915: LD_VAR 0 12
118919: PUSH
118920: FOR_IN
118921: IFFALSE 118956
// if GetTag ( i ) > 0 then
118923: LD_VAR 0 4
118927: PPUSH
118928: CALL_OW 110
118932: PUSH
118933: LD_INT 0
118935: GREATER
118936: IFFALSE 118954
// mechs := mechs diff i ;
118938: LD_ADDR_VAR 0 12
118942: PUSH
118943: LD_VAR 0 12
118947: PUSH
118948: LD_VAR 0 4
118952: DIFF
118953: ST_TO_ADDR
118954: GO 118920
118956: POP
118957: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118958: LD_ADDR_VAR 0 8
118962: PUSH
118963: LD_EXP 63
118967: PUSH
118968: LD_VAR 0 1
118972: ARRAY
118973: PPUSH
118974: LD_INT 2
118976: PUSH
118977: LD_INT 25
118979: PUSH
118980: LD_INT 1
118982: PUSH
118983: EMPTY
118984: LIST
118985: LIST
118986: PUSH
118987: LD_INT 25
118989: PUSH
118990: LD_INT 5
118992: PUSH
118993: EMPTY
118994: LIST
118995: LIST
118996: PUSH
118997: LD_INT 25
118999: PUSH
119000: LD_INT 8
119002: PUSH
119003: EMPTY
119004: LIST
119005: LIST
119006: PUSH
119007: LD_INT 25
119009: PUSH
119010: LD_INT 9
119012: PUSH
119013: EMPTY
119014: LIST
119015: LIST
119016: PUSH
119017: EMPTY
119018: LIST
119019: LIST
119020: LIST
119021: LIST
119022: LIST
119023: PPUSH
119024: CALL_OW 72
119028: ST_TO_ADDR
// if not defenders and not solds then
119029: LD_VAR 0 2
119033: NOT
119034: IFFALSE 119043
119036: PUSH
119037: LD_VAR 0 8
119041: NOT
119042: AND
119043: IFFALSE 119047
// exit ;
119045: GO 120869
// depot_under_attack := false ;
119047: LD_ADDR_VAR 0 16
119051: PUSH
119052: LD_INT 0
119054: ST_TO_ADDR
// sold_defenders := [ ] ;
119055: LD_ADDR_VAR 0 17
119059: PUSH
119060: EMPTY
119061: ST_TO_ADDR
// if mechs then
119062: LD_VAR 0 12
119066: IFFALSE 119221
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119068: LD_ADDR_VAR 0 4
119072: PUSH
119073: LD_VAR 0 2
119077: PPUSH
119078: LD_INT 21
119080: PUSH
119081: LD_INT 2
119083: PUSH
119084: EMPTY
119085: LIST
119086: LIST
119087: PPUSH
119088: CALL_OW 72
119092: PUSH
119093: FOR_IN
119094: IFFALSE 119219
// begin if GetTag ( i ) <> 20 then
119096: LD_VAR 0 4
119100: PPUSH
119101: CALL_OW 110
119105: PUSH
119106: LD_INT 20
119108: NONEQUAL
119109: IFFALSE 119123
// SetTag ( i , 20 ) ;
119111: LD_VAR 0 4
119115: PPUSH
119116: LD_INT 20
119118: PPUSH
119119: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119123: LD_VAR 0 4
119127: PPUSH
119128: CALL_OW 263
119132: PUSH
119133: LD_INT 1
119135: EQUAL
119136: IFFALSE 119150
119138: PUSH
119139: LD_VAR 0 4
119143: PPUSH
119144: CALL_OW 311
119148: NOT
119149: AND
119150: IFFALSE 119217
// begin un := mechs [ 1 ] ;
119152: LD_ADDR_VAR 0 10
119156: PUSH
119157: LD_VAR 0 12
119161: PUSH
119162: LD_INT 1
119164: ARRAY
119165: ST_TO_ADDR
// ComExit ( un ) ;
119166: LD_VAR 0 10
119170: PPUSH
119171: CALL 55928 0 1
// AddComEnterUnit ( un , i ) ;
119175: LD_VAR 0 10
119179: PPUSH
119180: LD_VAR 0 4
119184: PPUSH
119185: CALL_OW 180
// SetTag ( un , 19 ) ;
119189: LD_VAR 0 10
119193: PPUSH
119194: LD_INT 19
119196: PPUSH
119197: CALL_OW 109
// mechs := mechs diff un ;
119201: LD_ADDR_VAR 0 12
119205: PUSH
119206: LD_VAR 0 12
119210: PUSH
119211: LD_VAR 0 10
119215: DIFF
119216: ST_TO_ADDR
// end ; end ;
119217: GO 119093
119219: POP
119220: POP
// if solds then
119221: LD_VAR 0 8
119225: IFFALSE 119284
// for i in solds do
119227: LD_ADDR_VAR 0 4
119231: PUSH
119232: LD_VAR 0 8
119236: PUSH
119237: FOR_IN
119238: IFFALSE 119282
// if not GetTag ( i ) then
119240: LD_VAR 0 4
119244: PPUSH
119245: CALL_OW 110
119249: NOT
119250: IFFALSE 119280
// begin defenders := defenders union i ;
119252: LD_ADDR_VAR 0 2
119256: PUSH
119257: LD_VAR 0 2
119261: PUSH
119262: LD_VAR 0 4
119266: UNION
119267: ST_TO_ADDR
// SetTag ( i , 18 ) ;
119268: LD_VAR 0 4
119272: PPUSH
119273: LD_INT 18
119275: PPUSH
119276: CALL_OW 109
// end ;
119280: GO 119237
119282: POP
119283: POP
// repeat wait ( 0 0$2 ) ;
119284: LD_INT 70
119286: PPUSH
119287: CALL_OW 67
// enemy := mc_scan [ base ] ;
119291: LD_ADDR_VAR 0 21
119295: PUSH
119296: LD_EXP 86
119300: PUSH
119301: LD_VAR 0 1
119305: ARRAY
119306: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119307: LD_EXP 63
119311: PUSH
119312: LD_VAR 0 1
119316: ARRAY
119317: NOT
119318: IFTRUE 119335
119320: PUSH
119321: LD_EXP 63
119325: PUSH
119326: LD_VAR 0 1
119330: ARRAY
119331: PUSH
119332: EMPTY
119333: EQUAL
119334: OR
119335: IFFALSE 119372
// begin for i in defenders do
119337: LD_ADDR_VAR 0 4
119341: PUSH
119342: LD_VAR 0 2
119346: PUSH
119347: FOR_IN
119348: IFFALSE 119361
// ComStop ( i ) ;
119350: LD_VAR 0 4
119354: PPUSH
119355: CALL_OW 141
119359: GO 119347
119361: POP
119362: POP
// defenders := [ ] ;
119363: LD_ADDR_VAR 0 2
119367: PUSH
119368: EMPTY
119369: ST_TO_ADDR
// exit ;
119370: GO 120869
// end ; for i in defenders do
119372: LD_ADDR_VAR 0 4
119376: PUSH
119377: LD_VAR 0 2
119381: PUSH
119382: FOR_IN
119383: IFFALSE 120317
// begin e := NearestUnitToUnit ( enemy , i ) ;
119385: LD_ADDR_VAR 0 13
119389: PUSH
119390: LD_VAR 0 21
119394: PPUSH
119395: LD_VAR 0 4
119399: PPUSH
119400: CALL_OW 74
119404: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119405: LD_ADDR_VAR 0 7
119409: PUSH
119410: LD_EXP 63
119414: PUSH
119415: LD_VAR 0 1
119419: ARRAY
119420: PPUSH
119421: LD_INT 2
119423: PUSH
119424: LD_INT 30
119426: PUSH
119427: LD_INT 0
119429: PUSH
119430: EMPTY
119431: LIST
119432: LIST
119433: PUSH
119434: LD_INT 30
119436: PUSH
119437: LD_INT 1
119439: PUSH
119440: EMPTY
119441: LIST
119442: LIST
119443: PUSH
119444: EMPTY
119445: LIST
119446: LIST
119447: LIST
119448: PPUSH
119449: CALL_OW 72
119453: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119454: LD_ADDR_VAR 0 16
119458: PUSH
119459: LD_VAR 0 7
119463: NOT
119464: IFTRUE 119494
119466: PUSH
119467: LD_VAR 0 7
119471: PPUSH
119472: LD_INT 3
119474: PUSH
119475: LD_INT 24
119477: PUSH
119478: LD_INT 600
119480: PUSH
119481: EMPTY
119482: LIST
119483: LIST
119484: PUSH
119485: EMPTY
119486: LIST
119487: LIST
119488: PPUSH
119489: CALL_OW 72
119493: OR
119494: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119495: LD_VAR 0 4
119499: PPUSH
119500: CALL_OW 247
119504: PUSH
119505: LD_INT 2
119507: DOUBLE
119508: EQUAL
119509: IFTRUE 119513
119511: GO 119929
119513: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119514: LD_VAR 0 4
119518: PPUSH
119519: CALL_OW 256
119523: PUSH
119524: LD_INT 1000
119526: EQUAL
119527: IFFALSE 119573
119529: PUSH
119530: LD_VAR 0 4
119534: PPUSH
119535: LD_VAR 0 13
119539: PPUSH
119540: CALL_OW 296
119544: PUSH
119545: LD_INT 40
119547: LESS
119548: IFTRUE 119572
119550: PUSH
119551: LD_VAR 0 13
119555: PPUSH
119556: LD_EXP 88
119560: PUSH
119561: LD_VAR 0 1
119565: ARRAY
119566: PPUSH
119567: CALL_OW 308
119571: OR
119572: AND
119573: IFFALSE 119699
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119575: LD_VAR 0 4
119579: PPUSH
119580: CALL_OW 262
119584: PUSH
119585: LD_INT 1
119587: EQUAL
119588: IFFALSE 119605
119590: PUSH
119591: LD_VAR 0 4
119595: PPUSH
119596: CALL_OW 261
119600: PUSH
119601: LD_INT 30
119603: LESS
119604: AND
119605: IFFALSE 119613
119607: PUSH
119608: LD_VAR 0 7
119612: AND
119613: IFFALSE 119683
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119615: LD_VAR 0 4
119619: PPUSH
119620: LD_VAR 0 7
119624: PPUSH
119625: LD_VAR 0 4
119629: PPUSH
119630: CALL_OW 74
119634: PPUSH
119635: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119639: LD_VAR 0 4
119643: PPUSH
119644: LD_VAR 0 7
119648: PPUSH
119649: LD_VAR 0 4
119653: PPUSH
119654: CALL_OW 74
119658: PPUSH
119659: CALL_OW 296
119663: PUSH
119664: LD_INT 6
119666: LESS
119667: IFFALSE 119681
// SetFuel ( i , 100 ) ;
119669: LD_VAR 0 4
119673: PPUSH
119674: LD_INT 100
119676: PPUSH
119677: CALL_OW 240
// end else
119681: GO 119697
// ComAttackUnit ( i , e ) ;
119683: LD_VAR 0 4
119687: PPUSH
119688: LD_VAR 0 13
119692: PPUSH
119693: CALL_OW 115
// end else
119697: GO 119806
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119699: LD_VAR 0 13
119703: PPUSH
119704: LD_EXP 88
119708: PUSH
119709: LD_VAR 0 1
119713: ARRAY
119714: PPUSH
119715: CALL_OW 308
119719: NOT
119720: IFFALSE 119742
119722: PUSH
119723: LD_VAR 0 4
119727: PPUSH
119728: LD_VAR 0 13
119732: PPUSH
119733: CALL_OW 296
119737: PUSH
119738: LD_INT 40
119740: GREATEREQUAL
119741: AND
119742: IFTRUE 119759
119744: PUSH
119745: LD_VAR 0 4
119749: PPUSH
119750: CALL_OW 256
119754: PUSH
119755: LD_INT 650
119757: LESSEQUAL
119758: OR
119759: IFFALSE 119784
119761: PUSH
119762: LD_VAR 0 4
119766: PPUSH
119767: LD_EXP 87
119771: PUSH
119772: LD_VAR 0 1
119776: ARRAY
119777: PPUSH
119778: CALL_OW 308
119782: NOT
119783: AND
119784: IFFALSE 119806
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119786: LD_VAR 0 4
119790: PPUSH
119791: LD_EXP 87
119795: PUSH
119796: LD_VAR 0 1
119800: ARRAY
119801: PPUSH
119802: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119806: LD_VAR 0 4
119810: PPUSH
119811: CALL_OW 256
119815: PUSH
119816: LD_INT 1000
119818: LESS
119819: IFFALSE 119836
119821: PUSH
119822: LD_VAR 0 4
119826: PPUSH
119827: CALL_OW 263
119831: PUSH
119832: LD_INT 1
119834: EQUAL
119835: AND
119836: IFFALSE 119849
119838: PUSH
119839: LD_VAR 0 4
119843: PPUSH
119844: CALL_OW 311
119848: AND
119849: IFFALSE 119873
119851: PUSH
119852: LD_VAR 0 4
119856: PPUSH
119857: LD_EXP 87
119861: PUSH
119862: LD_VAR 0 1
119866: ARRAY
119867: PPUSH
119868: CALL_OW 308
119872: AND
119873: IFFALSE 119927
// begin mech := IsDrivenBy ( i ) ;
119875: LD_ADDR_VAR 0 9
119879: PUSH
119880: LD_VAR 0 4
119884: PPUSH
119885: CALL_OW 311
119889: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119890: LD_VAR 0 9
119894: PPUSH
119895: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119899: LD_VAR 0 9
119903: PPUSH
119904: LD_VAR 0 4
119908: PPUSH
119909: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119913: LD_VAR 0 9
119917: PPUSH
119918: LD_VAR 0 4
119922: PPUSH
119923: CALL_OW 180
// end ; end ; unit_human :
119927: GO 120288
119929: LD_INT 1
119931: DOUBLE
119932: EQUAL
119933: IFTRUE 119937
119935: GO 120287
119937: POP
// begin b := IsInUnit ( i ) ;
119938: LD_ADDR_VAR 0 18
119942: PUSH
119943: LD_VAR 0 4
119947: PPUSH
119948: CALL_OW 310
119952: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119953: LD_ADDR_VAR 0 19
119957: PUSH
119958: LD_VAR 0 18
119962: NOT
119963: IFTRUE 119987
119965: PUSH
119966: LD_VAR 0 18
119970: PPUSH
119971: CALL_OW 266
119975: PUSH
119976: LD_INT 32
119978: PUSH
119979: LD_INT 31
119981: PUSH
119982: EMPTY
119983: LIST
119984: LIST
119985: IN
119986: OR
119987: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119988: LD_VAR 0 18
119992: PPUSH
119993: CALL_OW 266
119997: PUSH
119998: LD_INT 5
120000: EQUAL
120001: IFFALSE 120033
120003: PUSH
120004: LD_VAR 0 4
120008: PPUSH
120009: CALL_OW 257
120013: PUSH
120014: LD_INT 1
120016: PUSH
120017: LD_INT 2
120019: PUSH
120020: LD_INT 3
120022: PUSH
120023: LD_INT 4
120025: PUSH
120026: EMPTY
120027: LIST
120028: LIST
120029: LIST
120030: LIST
120031: IN
120032: AND
120033: IFFALSE 120070
// begin class := AllowSpecClass ( i ) ;
120035: LD_ADDR_VAR 0 20
120039: PUSH
120040: LD_VAR 0 4
120044: PPUSH
120045: CALL 19282 0 1
120049: ST_TO_ADDR
// if class then
120050: LD_VAR 0 20
120054: IFFALSE 120070
// ComChangeProfession ( i , class ) ;
120056: LD_VAR 0 4
120060: PPUSH
120061: LD_VAR 0 20
120065: PPUSH
120066: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120070: LD_VAR 0 16
120074: IFTRUE 120101
120076: PUSH
120077: LD_VAR 0 2
120081: PPUSH
120082: LD_INT 21
120084: PUSH
120085: LD_INT 2
120087: PUSH
120088: EMPTY
120089: LIST
120090: LIST
120091: PPUSH
120092: CALL_OW 72
120096: PUSH
120097: LD_INT 1
120099: LESSEQUAL
120100: OR
120101: IFFALSE 120109
120103: PUSH
120104: LD_VAR 0 19
120108: AND
120109: IFFALSE 120124
120111: PUSH
120112: LD_VAR 0 4
120116: PUSH
120117: LD_VAR 0 17
120121: IN
120122: NOT
120123: AND
120124: IFFALSE 120219
// begin if b then
120126: LD_VAR 0 18
120130: IFFALSE 120181
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120132: LD_VAR 0 18
120136: PPUSH
120137: LD_VAR 0 21
120141: PPUSH
120142: LD_VAR 0 18
120146: PPUSH
120147: CALL_OW 74
120151: PPUSH
120152: CALL_OW 296
120156: PUSH
120157: LD_INT 10
120159: LESS
120160: IFFALSE 120177
120162: PUSH
120163: LD_VAR 0 18
120167: PPUSH
120168: CALL_OW 461
120172: PUSH
120173: LD_INT 7
120175: NONEQUAL
120176: AND
120177: IFFALSE 120181
// continue ;
120179: GO 119382
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120181: LD_ADDR_VAR 0 17
120185: PUSH
120186: LD_VAR 0 17
120190: PPUSH
120191: LD_VAR 0 17
120195: PUSH
120196: LD_INT 1
120198: PLUS
120199: PPUSH
120200: LD_VAR 0 4
120204: PPUSH
120205: CALL_OW 1
120209: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120210: LD_VAR 0 4
120214: PPUSH
120215: CALL_OW 122
// end ; if sold_defenders then
120219: LD_VAR 0 17
120223: IFFALSE 120285
// if i in sold_defenders then
120225: LD_VAR 0 4
120229: PUSH
120230: LD_VAR 0 17
120234: IN
120235: IFFALSE 120285
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120237: LD_VAR 0 4
120241: PPUSH
120242: CALL_OW 314
120246: NOT
120247: IFFALSE 120269
120249: PUSH
120250: LD_VAR 0 4
120254: PPUSH
120255: LD_VAR 0 13
120259: PPUSH
120260: CALL_OW 296
120264: PUSH
120265: LD_INT 30
120267: LESS
120268: AND
120269: IFFALSE 120285
// ComAttackUnit ( i , e ) ;
120271: LD_VAR 0 4
120275: PPUSH
120276: LD_VAR 0 13
120280: PPUSH
120281: CALL_OW 115
// end ; end ; end ;
120285: GO 120288
120287: POP
// if IsDead ( i ) then
120288: LD_VAR 0 4
120292: PPUSH
120293: CALL_OW 301
120297: IFFALSE 120315
// defenders := defenders diff i ;
120299: LD_ADDR_VAR 0 2
120303: PUSH
120304: LD_VAR 0 2
120308: PUSH
120309: LD_VAR 0 4
120313: DIFF
120314: ST_TO_ADDR
// end ;
120315: GO 119382
120317: POP
120318: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
120319: LD_VAR 0 21
120323: NOT
120324: IFTRUE 120333
120326: PUSH
120327: LD_VAR 0 2
120331: NOT
120332: OR
120333: IFTRUE 120348
120335: PUSH
120336: LD_EXP 63
120340: PUSH
120341: LD_VAR 0 1
120345: ARRAY
120346: NOT
120347: OR
120348: IFFALSE 119284
// MC_Reset ( base , 18 ) ;
120350: LD_VAR 0 1
120354: PPUSH
120355: LD_INT 18
120357: PPUSH
120358: CALL 65053 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120362: LD_ADDR_VAR 0 2
120366: PUSH
120367: LD_VAR 0 2
120371: PUSH
120372: LD_VAR 0 2
120376: PPUSH
120377: LD_INT 2
120379: PUSH
120380: LD_INT 25
120382: PUSH
120383: LD_INT 1
120385: PUSH
120386: EMPTY
120387: LIST
120388: LIST
120389: PUSH
120390: LD_INT 25
120392: PUSH
120393: LD_INT 5
120395: PUSH
120396: EMPTY
120397: LIST
120398: LIST
120399: PUSH
120400: LD_INT 25
120402: PUSH
120403: LD_INT 8
120405: PUSH
120406: EMPTY
120407: LIST
120408: LIST
120409: PUSH
120410: LD_INT 25
120412: PUSH
120413: LD_INT 9
120415: PUSH
120416: EMPTY
120417: LIST
120418: LIST
120419: PUSH
120420: EMPTY
120421: LIST
120422: LIST
120423: LIST
120424: LIST
120425: LIST
120426: PPUSH
120427: CALL_OW 72
120431: DIFF
120432: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120433: LD_VAR 0 21
120437: NOT
120438: IFFALSE 120461
120440: PUSH
120441: LD_VAR 0 2
120445: PPUSH
120446: LD_INT 21
120448: PUSH
120449: LD_INT 2
120451: PUSH
120452: EMPTY
120453: LIST
120454: LIST
120455: PPUSH
120456: CALL_OW 72
120460: AND
120461: IFFALSE 120805
// begin tmp := FilterByTag ( defenders , 19 ) ;
120463: LD_ADDR_VAR 0 11
120467: PUSH
120468: LD_VAR 0 2
120472: PPUSH
120473: LD_INT 19
120475: PPUSH
120476: CALL 53075 0 2
120480: ST_TO_ADDR
// if tmp then
120481: LD_VAR 0 11
120485: IFFALSE 120555
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120487: LD_ADDR_VAR 0 11
120491: PUSH
120492: LD_VAR 0 11
120496: PPUSH
120497: LD_INT 25
120499: PUSH
120500: LD_INT 3
120502: PUSH
120503: EMPTY
120504: LIST
120505: LIST
120506: PPUSH
120507: CALL_OW 72
120511: ST_TO_ADDR
// if tmp then
120512: LD_VAR 0 11
120516: IFFALSE 120555
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120518: LD_ADDR_EXP 75
120522: PUSH
120523: LD_EXP 75
120527: PPUSH
120528: LD_VAR 0 1
120532: PPUSH
120533: LD_EXP 75
120537: PUSH
120538: LD_VAR 0 1
120542: ARRAY
120543: PUSH
120544: LD_VAR 0 11
120548: UNION
120549: PPUSH
120550: CALL_OW 1
120554: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120555: LD_VAR 0 1
120559: PPUSH
120560: LD_INT 19
120562: PPUSH
120563: CALL 65053 0 2
// repeat wait ( 0 0$1 ) ;
120567: LD_INT 35
120569: PPUSH
120570: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120574: LD_EXP 63
120578: PUSH
120579: LD_VAR 0 1
120583: ARRAY
120584: NOT
120585: IFTRUE 120602
120587: PUSH
120588: LD_EXP 63
120592: PUSH
120593: LD_VAR 0 1
120597: ARRAY
120598: PUSH
120599: EMPTY
120600: EQUAL
120601: OR
120602: IFFALSE 120639
// begin for i in defenders do
120604: LD_ADDR_VAR 0 4
120608: PUSH
120609: LD_VAR 0 2
120613: PUSH
120614: FOR_IN
120615: IFFALSE 120628
// ComStop ( i ) ;
120617: LD_VAR 0 4
120621: PPUSH
120622: CALL_OW 141
120626: GO 120614
120628: POP
120629: POP
// defenders := [ ] ;
120630: LD_ADDR_VAR 0 2
120634: PUSH
120635: EMPTY
120636: ST_TO_ADDR
// exit ;
120637: GO 120869
// end ; for i in defenders do
120639: LD_ADDR_VAR 0 4
120643: PUSH
120644: LD_VAR 0 2
120648: PUSH
120649: FOR_IN
120650: IFFALSE 120739
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120652: LD_VAR 0 4
120656: PPUSH
120657: LD_EXP 87
120661: PUSH
120662: LD_VAR 0 1
120666: ARRAY
120667: PPUSH
120668: CALL_OW 308
120672: NOT
120673: IFFALSE 120697
// ComMoveToArea ( i , mc_parking [ base ] ) else
120675: LD_VAR 0 4
120679: PPUSH
120680: LD_EXP 87
120684: PUSH
120685: LD_VAR 0 1
120689: ARRAY
120690: PPUSH
120691: CALL_OW 113
120695: GO 120737
// if GetControl ( i ) = control_manual then
120697: LD_VAR 0 4
120701: PPUSH
120702: CALL_OW 263
120706: PUSH
120707: LD_INT 1
120709: EQUAL
120710: IFFALSE 120737
// if IsDrivenBy ( i ) then
120712: LD_VAR 0 4
120716: PPUSH
120717: CALL_OW 311
120721: IFFALSE 120737
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120723: LD_VAR 0 4
120727: PPUSH
120728: CALL_OW 311
120732: PPUSH
120733: CALL_OW 121
// end ;
120737: GO 120649
120739: POP
120740: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120741: LD_VAR 0 2
120745: PPUSH
120746: LD_INT 95
120748: PUSH
120749: LD_EXP 87
120753: PUSH
120754: LD_VAR 0 1
120758: ARRAY
120759: PUSH
120760: EMPTY
120761: LIST
120762: LIST
120763: PPUSH
120764: CALL_OW 72
120768: PUSH
120769: LD_VAR 0 2
120773: EQUAL
120774: IFTRUE 120788
120776: PUSH
120777: LD_EXP 86
120781: PUSH
120782: LD_VAR 0 1
120786: ARRAY
120787: OR
120788: IFTRUE 120803
120790: PUSH
120791: LD_EXP 63
120795: PUSH
120796: LD_VAR 0 1
120800: ARRAY
120801: NOT
120802: OR
120803: IFFALSE 120567
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120805: LD_ADDR_EXP 85
120809: PUSH
120810: LD_EXP 85
120814: PPUSH
120815: LD_VAR 0 1
120819: PPUSH
120820: LD_VAR 0 2
120824: PPUSH
120825: LD_INT 21
120827: PUSH
120828: LD_INT 2
120830: PUSH
120831: EMPTY
120832: LIST
120833: LIST
120834: PPUSH
120835: CALL_OW 72
120839: PPUSH
120840: CALL_OW 1
120844: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120845: LD_VAR 0 1
120849: PPUSH
120850: LD_INT 19
120852: PPUSH
120853: CALL 65053 0 2
// MC_Reset ( base , 20 ) ;
120857: LD_VAR 0 1
120861: PPUSH
120862: LD_INT 20
120864: PPUSH
120865: CALL 65053 0 2
// end ; end_of_file
120869: LD_VAR 0 3
120873: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120874: LD_VAR 0 1
120878: PUSH
120879: LD_INT 200
120881: DOUBLE
120882: GREATEREQUAL
120883: IFFALSE 120891
120885: LD_INT 299
120887: DOUBLE
120888: LESSEQUAL
120889: IFTRUE 120893
120891: GO 120925
120893: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120894: LD_VAR 0 1
120898: PPUSH
120899: LD_VAR 0 2
120903: PPUSH
120904: LD_VAR 0 3
120908: PPUSH
120909: LD_VAR 0 4
120913: PPUSH
120914: LD_VAR 0 5
120918: PPUSH
120919: CALL 108694 0 5
120923: GO 121002
120925: LD_INT 300
120927: DOUBLE
120928: GREATEREQUAL
120929: IFFALSE 120937
120931: LD_INT 399
120933: DOUBLE
120934: LESSEQUAL
120935: IFTRUE 120939
120937: GO 121001
120939: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120940: LD_VAR 0 1
120944: PPUSH
120945: LD_VAR 0 2
120949: PPUSH
120950: LD_VAR 0 3
120954: PPUSH
120955: LD_VAR 0 4
120959: PPUSH
120960: LD_VAR 0 5
120964: PPUSH
120965: LD_VAR 0 6
120969: PPUSH
120970: LD_VAR 0 7
120974: PPUSH
120975: LD_VAR 0 8
120979: PPUSH
120980: LD_VAR 0 9
120984: PPUSH
120985: LD_VAR 0 10
120989: PPUSH
120990: LD_VAR 0 11
120994: PPUSH
120995: CALL 104578 0 11
120999: GO 121002
121001: POP
// end ;
121002: PPOPN 11
121004: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121005: LD_VAR 0 1
121009: PPUSH
121010: LD_VAR 0 2
121014: PPUSH
121015: LD_VAR 0 3
121019: PPUSH
121020: LD_VAR 0 4
121024: PPUSH
121025: LD_VAR 0 5
121029: PPUSH
121030: CALL 108075 0 5
// end ; end_of_file
121034: PPOPN 5
121036: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121037: LD_VAR 0 1
121041: PPUSH
121042: LD_VAR 0 2
121046: PPUSH
121047: LD_VAR 0 3
121051: PPUSH
121052: LD_VAR 0 4
121056: PPUSH
121057: LD_VAR 0 5
121061: PPUSH
121062: LD_VAR 0 6
121066: PPUSH
121067: CALL 92118 0 6
// end ;
121071: PPOPN 6
121073: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121074: LD_INT 0
121076: PPUSH
// begin if not units then
121077: LD_VAR 0 1
121081: NOT
121082: IFFALSE 121086
// exit ;
121084: GO 121086
// end ;
121086: PPOPN 7
121088: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121089: CALL 92005 0 0
// end ;
121093: PPOPN 1
121095: END
