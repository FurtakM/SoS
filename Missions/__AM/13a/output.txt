// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57464 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49198 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59576 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80793 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81219 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81677 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81946 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81159 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81853 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81219 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81677 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81946 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 81003 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81159 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21407 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21407 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21407 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24816 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21407 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81159 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81344 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24816 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21529 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21529 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21407 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57699 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22425 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81159 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81344 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81507 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81159 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81344 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21407 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 21407 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 21407 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 84551 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 86885 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 85953 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 86194 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 84247 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 83867 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 83463 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 83301 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 83076 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 82961 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 87146 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 87362 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 82770 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 98387 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15019
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14562
14388: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: LD_INT 2
14411: PUSH
14412: LD_INT 6
14414: PUSH
14415: LD_INT 15
14417: PUSH
14418: LD_INT 16
14420: PUSH
14421: LD_INT 7
14423: PUSH
14424: LD_INT 12
14426: PUSH
14427: LD_INT 13
14429: PUSH
14430: LD_INT 10
14432: PUSH
14433: LD_INT 14
14435: PUSH
14436: LD_INT 20
14438: PUSH
14439: LD_INT 21
14441: PUSH
14442: LD_INT 22
14444: PUSH
14445: LD_INT 25
14447: PUSH
14448: LD_INT 32
14450: PUSH
14451: LD_INT 27
14453: PUSH
14454: LD_INT 36
14456: PUSH
14457: LD_INT 69
14459: PUSH
14460: LD_INT 39
14462: PUSH
14463: LD_INT 34
14465: PUSH
14466: LD_INT 40
14468: PUSH
14469: LD_INT 48
14471: PUSH
14472: LD_INT 49
14474: PUSH
14475: LD_INT 50
14477: PUSH
14478: LD_INT 51
14480: PUSH
14481: LD_INT 52
14483: PUSH
14484: LD_INT 53
14486: PUSH
14487: LD_INT 54
14489: PUSH
14490: LD_INT 55
14492: PUSH
14493: LD_INT 56
14495: PUSH
14496: LD_INT 57
14498: PUSH
14499: LD_INT 58
14501: PUSH
14502: LD_INT 59
14504: PUSH
14505: LD_INT 60
14507: PUSH
14508: LD_INT 61
14510: PUSH
14511: LD_INT 62
14513: PUSH
14514: LD_INT 80
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 14943
14562: LD_INT 2
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14752
14570: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14571: LD_ADDR_VAR 0 4
14575: PUSH
14576: LD_INT 35
14578: PUSH
14579: LD_INT 45
14581: PUSH
14582: LD_INT 46
14584: PUSH
14585: LD_INT 47
14587: PUSH
14588: LD_INT 70
14590: PUSH
14591: LD_INT 1
14593: PUSH
14594: LD_INT 11
14596: PUSH
14597: LD_INT 3
14599: PUSH
14600: LD_INT 4
14602: PUSH
14603: LD_INT 5
14605: PUSH
14606: LD_INT 6
14608: PUSH
14609: LD_INT 15
14611: PUSH
14612: LD_INT 18
14614: PUSH
14615: LD_INT 7
14617: PUSH
14618: LD_INT 17
14620: PUSH
14621: LD_INT 8
14623: PUSH
14624: LD_INT 20
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 22
14632: PUSH
14633: LD_INT 72
14635: PUSH
14636: LD_INT 26
14638: PUSH
14639: LD_INT 69
14641: PUSH
14642: LD_INT 39
14644: PUSH
14645: LD_INT 40
14647: PUSH
14648: LD_INT 41
14650: PUSH
14651: LD_INT 42
14653: PUSH
14654: LD_INT 43
14656: PUSH
14657: LD_INT 48
14659: PUSH
14660: LD_INT 49
14662: PUSH
14663: LD_INT 50
14665: PUSH
14666: LD_INT 51
14668: PUSH
14669: LD_INT 52
14671: PUSH
14672: LD_INT 53
14674: PUSH
14675: LD_INT 54
14677: PUSH
14678: LD_INT 55
14680: PUSH
14681: LD_INT 56
14683: PUSH
14684: LD_INT 60
14686: PUSH
14687: LD_INT 61
14689: PUSH
14690: LD_INT 62
14692: PUSH
14693: LD_INT 66
14695: PUSH
14696: LD_INT 67
14698: PUSH
14699: LD_INT 68
14701: PUSH
14702: LD_INT 81
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: ST_TO_ADDR
14750: GO 14943
14752: LD_INT 3
14754: DOUBLE
14755: EQUAL
14756: IFTRUE 14760
14758: GO 14942
14760: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14761: LD_ADDR_VAR 0 4
14765: PUSH
14766: LD_INT 46
14768: PUSH
14769: LD_INT 47
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: LD_INT 2
14777: PUSH
14778: LD_INT 11
14780: PUSH
14781: LD_INT 9
14783: PUSH
14784: LD_INT 20
14786: PUSH
14787: LD_INT 19
14789: PUSH
14790: LD_INT 21
14792: PUSH
14793: LD_INT 24
14795: PUSH
14796: LD_INT 22
14798: PUSH
14799: LD_INT 25
14801: PUSH
14802: LD_INT 28
14804: PUSH
14805: LD_INT 29
14807: PUSH
14808: LD_INT 30
14810: PUSH
14811: LD_INT 31
14813: PUSH
14814: LD_INT 37
14816: PUSH
14817: LD_INT 38
14819: PUSH
14820: LD_INT 32
14822: PUSH
14823: LD_INT 27
14825: PUSH
14826: LD_INT 33
14828: PUSH
14829: LD_INT 69
14831: PUSH
14832: LD_INT 39
14834: PUSH
14835: LD_INT 34
14837: PUSH
14838: LD_INT 40
14840: PUSH
14841: LD_INT 71
14843: PUSH
14844: LD_INT 23
14846: PUSH
14847: LD_INT 44
14849: PUSH
14850: LD_INT 48
14852: PUSH
14853: LD_INT 49
14855: PUSH
14856: LD_INT 50
14858: PUSH
14859: LD_INT 51
14861: PUSH
14862: LD_INT 52
14864: PUSH
14865: LD_INT 53
14867: PUSH
14868: LD_INT 54
14870: PUSH
14871: LD_INT 55
14873: PUSH
14874: LD_INT 56
14876: PUSH
14877: LD_INT 57
14879: PUSH
14880: LD_INT 58
14882: PUSH
14883: LD_INT 59
14885: PUSH
14886: LD_INT 63
14888: PUSH
14889: LD_INT 64
14891: PUSH
14892: LD_INT 65
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: LIST
14931: LIST
14932: LIST
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: LIST
14938: LIST
14939: ST_TO_ADDR
14940: GO 14943
14942: POP
// if state > - 1 and state < 3 then
14943: LD_VAR 0 3
14947: PUSH
14948: LD_INT 1
14950: NEG
14951: GREATER
14952: PUSH
14953: LD_VAR 0 3
14957: PUSH
14958: LD_INT 3
14960: LESS
14961: AND
14962: IFFALSE 15019
// for i in result do
14964: LD_ADDR_VAR 0 5
14968: PUSH
14969: LD_VAR 0 4
14973: PUSH
14974: FOR_IN
14975: IFFALSE 15017
// if GetTech ( i , side ) <> state then
14977: LD_VAR 0 5
14981: PPUSH
14982: LD_VAR 0 1
14986: PPUSH
14987: CALL_OW 321
14991: PUSH
14992: LD_VAR 0 3
14996: NONEQUAL
14997: IFFALSE 15015
// result := result diff i ;
14999: LD_ADDR_VAR 0 4
15003: PUSH
15004: LD_VAR 0 4
15008: PUSH
15009: LD_VAR 0 5
15013: DIFF
15014: ST_TO_ADDR
15015: GO 14974
15017: POP
15018: POP
// end ;
15019: LD_VAR 0 4
15023: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15024: LD_INT 0
15026: PPUSH
15027: PPUSH
15028: PPUSH
// result := true ;
15029: LD_ADDR_VAR 0 3
15033: PUSH
15034: LD_INT 1
15036: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15037: LD_ADDR_VAR 0 5
15041: PUSH
15042: LD_VAR 0 2
15046: PPUSH
15047: CALL_OW 480
15051: ST_TO_ADDR
// if not tmp then
15052: LD_VAR 0 5
15056: NOT
15057: IFFALSE 15061
// exit ;
15059: GO 15110
// for i in tmp do
15061: LD_ADDR_VAR 0 4
15065: PUSH
15066: LD_VAR 0 5
15070: PUSH
15071: FOR_IN
15072: IFFALSE 15108
// if GetTech ( i , side ) <> state_researched then
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_VAR 0 1
15083: PPUSH
15084: CALL_OW 321
15088: PUSH
15089: LD_INT 2
15091: NONEQUAL
15092: IFFALSE 15106
// begin result := false ;
15094: LD_ADDR_VAR 0 3
15098: PUSH
15099: LD_INT 0
15101: ST_TO_ADDR
// exit ;
15102: POP
15103: POP
15104: GO 15110
// end ;
15106: GO 15071
15108: POP
15109: POP
// end ;
15110: LD_VAR 0 3
15114: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15115: LD_INT 0
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
15126: PPUSH
15127: PPUSH
15128: PPUSH
15129: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15130: LD_VAR 0 1
15134: NOT
15135: PUSH
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 257
15145: PUSH
15146: LD_INT 9
15148: NONEQUAL
15149: OR
15150: IFFALSE 15154
// exit ;
15152: GO 15727
// side := GetSide ( unit ) ;
15154: LD_ADDR_VAR 0 9
15158: PUSH
15159: LD_VAR 0 1
15163: PPUSH
15164: CALL_OW 255
15168: ST_TO_ADDR
// tech_space := tech_spacanom ;
15169: LD_ADDR_VAR 0 12
15173: PUSH
15174: LD_INT 29
15176: ST_TO_ADDR
// tech_time := tech_taurad ;
15177: LD_ADDR_VAR 0 13
15181: PUSH
15182: LD_INT 28
15184: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15185: LD_ADDR_VAR 0 11
15189: PUSH
15190: LD_VAR 0 1
15194: PPUSH
15195: CALL_OW 310
15199: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15200: LD_VAR 0 11
15204: PPUSH
15205: CALL_OW 247
15209: PUSH
15210: LD_INT 2
15212: EQUAL
15213: IFFALSE 15217
// exit ;
15215: GO 15727
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15217: LD_ADDR_VAR 0 8
15221: PUSH
15222: LD_INT 81
15224: PUSH
15225: LD_VAR 0 9
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: PUSH
15234: LD_INT 3
15236: PUSH
15237: LD_INT 21
15239: PUSH
15240: LD_INT 3
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: PPUSH
15255: CALL_OW 69
15259: ST_TO_ADDR
// if not tmp then
15260: LD_VAR 0 8
15264: NOT
15265: IFFALSE 15269
// exit ;
15267: GO 15727
// if in_unit then
15269: LD_VAR 0 11
15273: IFFALSE 15297
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15275: LD_ADDR_VAR 0 10
15279: PUSH
15280: LD_VAR 0 8
15284: PPUSH
15285: LD_VAR 0 11
15289: PPUSH
15290: CALL_OW 74
15294: ST_TO_ADDR
15295: GO 15317
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15297: LD_ADDR_VAR 0 10
15301: PUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: LD_VAR 0 1
15311: PPUSH
15312: CALL_OW 74
15316: ST_TO_ADDR
// if not enemy then
15317: LD_VAR 0 10
15321: NOT
15322: IFFALSE 15326
// exit ;
15324: GO 15727
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15326: LD_VAR 0 11
15330: PUSH
15331: LD_VAR 0 11
15335: PPUSH
15336: LD_VAR 0 10
15340: PPUSH
15341: CALL_OW 296
15345: PUSH
15346: LD_INT 13
15348: GREATER
15349: AND
15350: PUSH
15351: LD_VAR 0 1
15355: PPUSH
15356: LD_VAR 0 10
15360: PPUSH
15361: CALL_OW 296
15365: PUSH
15366: LD_INT 12
15368: GREATER
15369: OR
15370: IFFALSE 15374
// exit ;
15372: GO 15727
// missile := [ 1 ] ;
15374: LD_ADDR_VAR 0 14
15378: PUSH
15379: LD_INT 1
15381: PUSH
15382: EMPTY
15383: LIST
15384: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15385: LD_VAR 0 9
15389: PPUSH
15390: LD_VAR 0 12
15394: PPUSH
15395: CALL_OW 325
15399: IFFALSE 15428
// missile := Insert ( missile , missile + 1 , 2 ) ;
15401: LD_ADDR_VAR 0 14
15405: PUSH
15406: LD_VAR 0 14
15410: PPUSH
15411: LD_VAR 0 14
15415: PUSH
15416: LD_INT 1
15418: PLUS
15419: PPUSH
15420: LD_INT 2
15422: PPUSH
15423: CALL_OW 2
15427: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15428: LD_VAR 0 9
15432: PPUSH
15433: LD_VAR 0 13
15437: PPUSH
15438: CALL_OW 325
15442: PUSH
15443: LD_VAR 0 10
15447: PPUSH
15448: CALL_OW 255
15452: PPUSH
15453: LD_VAR 0 13
15457: PPUSH
15458: CALL_OW 325
15462: NOT
15463: AND
15464: IFFALSE 15493
// missile := Insert ( missile , missile + 1 , 3 ) ;
15466: LD_ADDR_VAR 0 14
15470: PUSH
15471: LD_VAR 0 14
15475: PPUSH
15476: LD_VAR 0 14
15480: PUSH
15481: LD_INT 1
15483: PLUS
15484: PPUSH
15485: LD_INT 3
15487: PPUSH
15488: CALL_OW 2
15492: ST_TO_ADDR
// if missile < 2 then
15493: LD_VAR 0 14
15497: PUSH
15498: LD_INT 2
15500: LESS
15501: IFFALSE 15505
// exit ;
15503: GO 15727
// x := GetX ( enemy ) ;
15505: LD_ADDR_VAR 0 4
15509: PUSH
15510: LD_VAR 0 10
15514: PPUSH
15515: CALL_OW 250
15519: ST_TO_ADDR
// y := GetY ( enemy ) ;
15520: LD_ADDR_VAR 0 5
15524: PUSH
15525: LD_VAR 0 10
15529: PPUSH
15530: CALL_OW 251
15534: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15535: LD_ADDR_VAR 0 6
15539: PUSH
15540: LD_VAR 0 4
15544: PUSH
15545: LD_INT 1
15547: NEG
15548: PPUSH
15549: LD_INT 1
15551: PPUSH
15552: CALL_OW 12
15556: PLUS
15557: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15558: LD_ADDR_VAR 0 7
15562: PUSH
15563: LD_VAR 0 5
15567: PUSH
15568: LD_INT 1
15570: NEG
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: CALL_OW 12
15579: PLUS
15580: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15581: LD_VAR 0 6
15585: PPUSH
15586: LD_VAR 0 7
15590: PPUSH
15591: CALL_OW 488
15595: NOT
15596: IFFALSE 15618
// begin _x := x ;
15598: LD_ADDR_VAR 0 6
15602: PUSH
15603: LD_VAR 0 4
15607: ST_TO_ADDR
// _y := y ;
15608: LD_ADDR_VAR 0 7
15612: PUSH
15613: LD_VAR 0 5
15617: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15618: LD_ADDR_VAR 0 3
15622: PUSH
15623: LD_INT 1
15625: PPUSH
15626: LD_VAR 0 14
15630: PPUSH
15631: CALL_OW 12
15635: ST_TO_ADDR
// case i of 1 :
15636: LD_VAR 0 3
15640: PUSH
15641: LD_INT 1
15643: DOUBLE
15644: EQUAL
15645: IFTRUE 15649
15647: GO 15666
15649: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_VAR 0 10
15659: PPUSH
15660: CALL_OW 115
15664: GO 15727
15666: LD_INT 2
15668: DOUBLE
15669: EQUAL
15670: IFTRUE 15674
15672: GO 15696
15674: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15675: LD_VAR 0 1
15679: PPUSH
15680: LD_VAR 0 6
15684: PPUSH
15685: LD_VAR 0 7
15689: PPUSH
15690: CALL_OW 153
15694: GO 15727
15696: LD_INT 3
15698: DOUBLE
15699: EQUAL
15700: IFTRUE 15704
15702: GO 15726
15704: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_VAR 0 6
15714: PPUSH
15715: LD_VAR 0 7
15719: PPUSH
15720: CALL_OW 154
15724: GO 15727
15726: POP
// end ;
15727: LD_VAR 0 2
15731: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15732: LD_INT 0
15734: PPUSH
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
15739: PPUSH
// if not unit or not building then
15740: LD_VAR 0 1
15744: NOT
15745: PUSH
15746: LD_VAR 0 2
15750: NOT
15751: OR
15752: IFFALSE 15756
// exit ;
15754: GO 15914
// x := GetX ( building ) ;
15756: LD_ADDR_VAR 0 5
15760: PUSH
15761: LD_VAR 0 2
15765: PPUSH
15766: CALL_OW 250
15770: ST_TO_ADDR
// y := GetY ( building ) ;
15771: LD_ADDR_VAR 0 6
15775: PUSH
15776: LD_VAR 0 2
15780: PPUSH
15781: CALL_OW 251
15785: ST_TO_ADDR
// for i = 0 to 5 do
15786: LD_ADDR_VAR 0 4
15790: PUSH
15791: DOUBLE
15792: LD_INT 0
15794: DEC
15795: ST_TO_ADDR
15796: LD_INT 5
15798: PUSH
15799: FOR_TO
15800: IFFALSE 15912
// begin _x := ShiftX ( x , i , 3 ) ;
15802: LD_ADDR_VAR 0 7
15806: PUSH
15807: LD_VAR 0 5
15811: PPUSH
15812: LD_VAR 0 4
15816: PPUSH
15817: LD_INT 3
15819: PPUSH
15820: CALL_OW 272
15824: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15825: LD_ADDR_VAR 0 8
15829: PUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 4
15839: PPUSH
15840: LD_INT 3
15842: PPUSH
15843: CALL_OW 273
15847: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15848: LD_VAR 0 7
15852: PPUSH
15853: LD_VAR 0 8
15857: PPUSH
15858: CALL_OW 488
15862: NOT
15863: IFFALSE 15867
// continue ;
15865: GO 15799
// if HexInfo ( _x , _y ) = 0 then
15867: LD_VAR 0 7
15871: PPUSH
15872: LD_VAR 0 8
15876: PPUSH
15877: CALL_OW 428
15881: PUSH
15882: LD_INT 0
15884: EQUAL
15885: IFFALSE 15910
// begin ComMoveXY ( unit , _x , _y ) ;
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_VAR 0 7
15896: PPUSH
15897: LD_VAR 0 8
15901: PPUSH
15902: CALL_OW 111
// exit ;
15906: POP
15907: POP
15908: GO 15914
// end ; end ;
15910: GO 15799
15912: POP
15913: POP
// end ;
15914: LD_VAR 0 3
15918: RET
// export function ScanBase ( side , base_area ) ; begin
15919: LD_INT 0
15921: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15922: LD_ADDR_VAR 0 3
15926: PUSH
15927: LD_VAR 0 2
15931: PPUSH
15932: LD_INT 81
15934: PUSH
15935: LD_VAR 0 1
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PPUSH
15944: CALL_OW 70
15948: ST_TO_ADDR
// end ;
15949: LD_VAR 0 3
15953: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15954: LD_INT 0
15956: PPUSH
15957: PPUSH
15958: PPUSH
15959: PPUSH
15960: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15961: LD_VAR 0 1
15965: NOT
15966: PUSH
15967: LD_EXP 59
15971: PUSH
15972: LD_VAR 0 1
15976: ARRAY
15977: NOT
15978: OR
15979: PUSH
15980: LD_VAR 0 2
15984: NOT
15985: OR
15986: PUSH
15987: LD_VAR 0 3
15991: NOT
15992: OR
15993: IFFALSE 15997
// exit ;
15995: GO 16510
// side := mc_sides [ base ] ;
15997: LD_ADDR_VAR 0 6
16001: PUSH
16002: LD_EXP 85
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: ST_TO_ADDR
// if not side then
16013: LD_VAR 0 6
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 16510
// for i in solds do
16022: LD_ADDR_VAR 0 7
16026: PUSH
16027: LD_VAR 0 2
16031: PUSH
16032: FOR_IN
16033: IFFALSE 16094
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16035: LD_VAR 0 7
16039: PPUSH
16040: CALL_OW 310
16044: PPUSH
16045: CALL_OW 266
16049: PUSH
16050: LD_INT 32
16052: PUSH
16053: LD_INT 31
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: IN
16060: IFFALSE 16080
// solds := solds diff i else
16062: LD_ADDR_VAR 0 2
16066: PUSH
16067: LD_VAR 0 2
16071: PUSH
16072: LD_VAR 0 7
16076: DIFF
16077: ST_TO_ADDR
16078: GO 16092
// SetTag ( i , 18 ) ;
16080: LD_VAR 0 7
16084: PPUSH
16085: LD_INT 18
16087: PPUSH
16088: CALL_OW 109
16092: GO 16032
16094: POP
16095: POP
// if not solds then
16096: LD_VAR 0 2
16100: NOT
16101: IFFALSE 16105
// exit ;
16103: GO 16510
// repeat wait ( 0 0$1 ) ;
16105: LD_INT 35
16107: PPUSH
16108: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16112: LD_ADDR_VAR 0 5
16116: PUSH
16117: LD_VAR 0 6
16121: PPUSH
16122: LD_VAR 0 3
16126: PPUSH
16127: CALL 15919 0 2
16131: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16132: LD_EXP 59
16136: PUSH
16137: LD_VAR 0 1
16141: ARRAY
16142: NOT
16143: PUSH
16144: LD_EXP 59
16148: PUSH
16149: LD_VAR 0 1
16153: ARRAY
16154: PUSH
16155: EMPTY
16156: EQUAL
16157: OR
16158: IFFALSE 16195
// begin for i in solds do
16160: LD_ADDR_VAR 0 7
16164: PUSH
16165: LD_VAR 0 2
16169: PUSH
16170: FOR_IN
16171: IFFALSE 16184
// ComStop ( i ) ;
16173: LD_VAR 0 7
16177: PPUSH
16178: CALL_OW 141
16182: GO 16170
16184: POP
16185: POP
// solds := [ ] ;
16186: LD_ADDR_VAR 0 2
16190: PUSH
16191: EMPTY
16192: ST_TO_ADDR
// exit ;
16193: GO 16510
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16195: LD_VAR 0 5
16199: NOT
16200: PUSH
16201: LD_VAR 0 5
16205: PUSH
16206: LD_INT 3
16208: GREATER
16209: OR
16210: PUSH
16211: LD_EXP 81
16215: PUSH
16216: LD_VAR 0 1
16220: ARRAY
16221: OR
16222: IFFALSE 16263
// begin for i in solds do
16224: LD_ADDR_VAR 0 7
16228: PUSH
16229: LD_VAR 0 2
16233: PUSH
16234: FOR_IN
16235: IFFALSE 16259
// if HasTask ( i ) then
16237: LD_VAR 0 7
16241: PPUSH
16242: CALL_OW 314
16246: IFFALSE 16257
// ComStop ( i ) ;
16248: LD_VAR 0 7
16252: PPUSH
16253: CALL_OW 141
16257: GO 16234
16259: POP
16260: POP
// break ;
16261: GO 16498
// end ; for i in solds do
16263: LD_ADDR_VAR 0 7
16267: PUSH
16268: LD_VAR 0 2
16272: PUSH
16273: FOR_IN
16274: IFFALSE 16490
// begin if IsInUnit ( i ) then
16276: LD_VAR 0 7
16280: PPUSH
16281: CALL_OW 310
16285: IFFALSE 16296
// ComExitBuilding ( i ) ;
16287: LD_VAR 0 7
16291: PPUSH
16292: CALL_OW 122
// if GetLives ( i ) > 333 then
16296: LD_VAR 0 7
16300: PPUSH
16301: CALL_OW 256
16305: PUSH
16306: LD_INT 333
16308: GREATER
16309: IFFALSE 16337
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16311: LD_VAR 0 7
16315: PPUSH
16316: LD_VAR 0 5
16320: PPUSH
16321: LD_VAR 0 7
16325: PPUSH
16326: CALL_OW 74
16330: PPUSH
16331: CALL_OW 115
16335: GO 16488
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16337: LD_ADDR_VAR 0 8
16341: PUSH
16342: LD_EXP 59
16346: PUSH
16347: LD_VAR 0 1
16351: ARRAY
16352: PPUSH
16353: LD_INT 2
16355: PUSH
16356: LD_INT 30
16358: PUSH
16359: LD_INT 0
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 30
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: LD_INT 30
16378: PUSH
16379: LD_INT 6
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: EMPTY
16387: LIST
16388: LIST
16389: LIST
16390: LIST
16391: PPUSH
16392: CALL_OW 72
16396: PPUSH
16397: LD_VAR 0 7
16401: PPUSH
16402: CALL_OW 74
16406: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16407: LD_VAR 0 7
16411: PPUSH
16412: LD_VAR 0 8
16416: PPUSH
16417: CALL_OW 250
16421: PPUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 5
16427: PPUSH
16428: CALL_OW 272
16432: PPUSH
16433: LD_VAR 0 8
16437: PPUSH
16438: CALL_OW 251
16442: PPUSH
16443: LD_INT 3
16445: PPUSH
16446: LD_INT 5
16448: PPUSH
16449: CALL_OW 273
16453: PPUSH
16454: CALL_OW 111
// SetTag ( i , 0 ) ;
16458: LD_VAR 0 7
16462: PPUSH
16463: LD_INT 0
16465: PPUSH
16466: CALL_OW 109
// solds := solds diff i ;
16470: LD_ADDR_VAR 0 2
16474: PUSH
16475: LD_VAR 0 2
16479: PUSH
16480: LD_VAR 0 7
16484: DIFF
16485: ST_TO_ADDR
// continue ;
16486: GO 16273
// end ; end ;
16488: GO 16273
16490: POP
16491: POP
// until solds ;
16492: LD_VAR 0 2
16496: IFFALSE 16105
// MC_Reset ( base , 18 ) ;
16498: LD_VAR 0 1
16502: PPUSH
16503: LD_INT 18
16505: PPUSH
16506: CALL 61542 0 2
// end ;
16510: LD_VAR 0 4
16514: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16515: LD_INT 0
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
16522: PPUSH
16523: PPUSH
16524: PPUSH
16525: PPUSH
16526: PPUSH
16527: PPUSH
16528: PPUSH
16529: PPUSH
16530: PPUSH
16531: PPUSH
16532: PPUSH
16533: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16534: LD_ADDR_VAR 0 13
16538: PUSH
16539: LD_EXP 59
16543: PUSH
16544: LD_VAR 0 1
16548: ARRAY
16549: PPUSH
16550: LD_INT 25
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 72
16564: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16565: LD_EXP 99
16569: PUSH
16570: LD_VAR 0 1
16574: ARRAY
16575: IFFALSE 16599
// mechs := mechs diff mc_remote_driver [ base ] ;
16577: LD_ADDR_VAR 0 13
16581: PUSH
16582: LD_VAR 0 13
16586: PUSH
16587: LD_EXP 99
16591: PUSH
16592: LD_VAR 0 1
16596: ARRAY
16597: DIFF
16598: ST_TO_ADDR
// for i in mechs do
16599: LD_ADDR_VAR 0 5
16603: PUSH
16604: LD_VAR 0 13
16608: PUSH
16609: FOR_IN
16610: IFFALSE 16645
// if GetTag ( i ) > 0 then
16612: LD_VAR 0 5
16616: PPUSH
16617: CALL_OW 110
16621: PUSH
16622: LD_INT 0
16624: GREATER
16625: IFFALSE 16643
// mechs := mechs diff i ;
16627: LD_ADDR_VAR 0 13
16631: PUSH
16632: LD_VAR 0 13
16636: PUSH
16637: LD_VAR 0 5
16641: DIFF
16642: ST_TO_ADDR
16643: GO 16609
16645: POP
16646: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16647: LD_ADDR_VAR 0 9
16651: PUSH
16652: LD_EXP 59
16656: PUSH
16657: LD_VAR 0 1
16661: ARRAY
16662: PPUSH
16663: LD_INT 2
16665: PUSH
16666: LD_INT 25
16668: PUSH
16669: LD_INT 1
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PUSH
16676: LD_INT 25
16678: PUSH
16679: LD_INT 5
16681: PUSH
16682: EMPTY
16683: LIST
16684: LIST
16685: PUSH
16686: LD_INT 25
16688: PUSH
16689: LD_INT 8
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PUSH
16696: LD_INT 25
16698: PUSH
16699: LD_INT 9
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: PPUSH
16713: CALL_OW 72
16717: ST_TO_ADDR
// if not defenders and not solds then
16718: LD_VAR 0 2
16722: NOT
16723: PUSH
16724: LD_VAR 0 9
16728: NOT
16729: AND
16730: IFFALSE 16734
// exit ;
16732: GO 18360
// depot_under_attack := false ;
16734: LD_ADDR_VAR 0 17
16738: PUSH
16739: LD_INT 0
16741: ST_TO_ADDR
// sold_defenders := [ ] ;
16742: LD_ADDR_VAR 0 18
16746: PUSH
16747: EMPTY
16748: ST_TO_ADDR
// if mechs then
16749: LD_VAR 0 13
16753: IFFALSE 16882
// for i in defenders do
16755: LD_ADDR_VAR 0 5
16759: PUSH
16760: LD_VAR 0 2
16764: PUSH
16765: FOR_IN
16766: IFFALSE 16880
// begin SetTag ( i , 20 ) ;
16768: LD_VAR 0 5
16772: PPUSH
16773: LD_INT 20
16775: PPUSH
16776: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16780: LD_VAR 0 5
16784: PPUSH
16785: CALL_OW 263
16789: PUSH
16790: LD_INT 1
16792: EQUAL
16793: PUSH
16794: LD_VAR 0 5
16798: PPUSH
16799: CALL_OW 311
16803: NOT
16804: AND
16805: PUSH
16806: LD_VAR 0 13
16810: AND
16811: IFFALSE 16878
// begin un := mechs [ 1 ] ;
16813: LD_ADDR_VAR 0 11
16817: PUSH
16818: LD_VAR 0 13
16822: PUSH
16823: LD_INT 1
16825: ARRAY
16826: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16827: LD_VAR 0 11
16831: PPUSH
16832: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16836: LD_VAR 0 11
16840: PPUSH
16841: LD_VAR 0 5
16845: PPUSH
16846: CALL_OW 180
// SetTag ( un , 19 ) ;
16850: LD_VAR 0 11
16854: PPUSH
16855: LD_INT 19
16857: PPUSH
16858: CALL_OW 109
// mechs := mechs diff un ;
16862: LD_ADDR_VAR 0 13
16866: PUSH
16867: LD_VAR 0 13
16871: PUSH
16872: LD_VAR 0 11
16876: DIFF
16877: ST_TO_ADDR
// end ; end ;
16878: GO 16765
16880: POP
16881: POP
// if solds then
16882: LD_VAR 0 9
16886: IFFALSE 16945
// for i in solds do
16888: LD_ADDR_VAR 0 5
16892: PUSH
16893: LD_VAR 0 9
16897: PUSH
16898: FOR_IN
16899: IFFALSE 16943
// if not GetTag ( i ) then
16901: LD_VAR 0 5
16905: PPUSH
16906: CALL_OW 110
16910: NOT
16911: IFFALSE 16941
// begin defenders := defenders union i ;
16913: LD_ADDR_VAR 0 2
16917: PUSH
16918: LD_VAR 0 2
16922: PUSH
16923: LD_VAR 0 5
16927: UNION
16928: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16929: LD_VAR 0 5
16933: PPUSH
16934: LD_INT 18
16936: PPUSH
16937: CALL_OW 109
// end ;
16941: GO 16898
16943: POP
16944: POP
// repeat wait ( 0 0$1 ) ;
16945: LD_INT 35
16947: PPUSH
16948: CALL_OW 67
// enemy := mc_scan [ base ] ;
16952: LD_ADDR_VAR 0 3
16956: PUSH
16957: LD_EXP 82
16961: PUSH
16962: LD_VAR 0 1
16966: ARRAY
16967: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16968: LD_EXP 59
16972: PUSH
16973: LD_VAR 0 1
16977: ARRAY
16978: NOT
16979: PUSH
16980: LD_EXP 59
16984: PUSH
16985: LD_VAR 0 1
16989: ARRAY
16990: PUSH
16991: EMPTY
16992: EQUAL
16993: OR
16994: IFFALSE 17031
// begin for i in defenders do
16996: LD_ADDR_VAR 0 5
17000: PUSH
17001: LD_VAR 0 2
17005: PUSH
17006: FOR_IN
17007: IFFALSE 17020
// ComStop ( i ) ;
17009: LD_VAR 0 5
17013: PPUSH
17014: CALL_OW 141
17018: GO 17006
17020: POP
17021: POP
// defenders := [ ] ;
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: EMPTY
17028: ST_TO_ADDR
// exit ;
17029: GO 18360
// end ; for i in defenders do
17031: LD_ADDR_VAR 0 5
17035: PUSH
17036: LD_VAR 0 2
17040: PUSH
17041: FOR_IN
17042: IFFALSE 17860
// begin e := NearestUnitToUnit ( enemy , i ) ;
17044: LD_ADDR_VAR 0 14
17048: PUSH
17049: LD_VAR 0 3
17053: PPUSH
17054: LD_VAR 0 5
17058: PPUSH
17059: CALL_OW 74
17063: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17064: LD_ADDR_VAR 0 8
17068: PUSH
17069: LD_EXP 59
17073: PUSH
17074: LD_VAR 0 1
17078: ARRAY
17079: PPUSH
17080: LD_INT 2
17082: PUSH
17083: LD_INT 30
17085: PUSH
17086: LD_INT 0
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: PUSH
17093: LD_INT 30
17095: PUSH
17096: LD_INT 1
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: LIST
17107: PPUSH
17108: CALL_OW 72
17112: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17113: LD_ADDR_VAR 0 17
17117: PUSH
17118: LD_VAR 0 8
17122: NOT
17123: PUSH
17124: LD_VAR 0 8
17128: PPUSH
17129: LD_INT 3
17131: PUSH
17132: LD_INT 24
17134: PUSH
17135: LD_INT 600
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PPUSH
17146: CALL_OW 72
17150: OR
17151: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17152: LD_VAR 0 5
17156: PPUSH
17157: CALL_OW 247
17161: PUSH
17162: LD_INT 2
17164: DOUBLE
17165: EQUAL
17166: IFTRUE 17170
17168: GO 17566
17170: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17171: LD_VAR 0 5
17175: PPUSH
17176: CALL_OW 256
17180: PUSH
17181: LD_INT 650
17183: GREATER
17184: PUSH
17185: LD_VAR 0 5
17189: PPUSH
17190: LD_VAR 0 14
17194: PPUSH
17195: CALL_OW 296
17199: PUSH
17200: LD_INT 40
17202: LESS
17203: PUSH
17204: LD_VAR 0 14
17208: PPUSH
17209: LD_EXP 84
17213: PUSH
17214: LD_VAR 0 1
17218: ARRAY
17219: PPUSH
17220: CALL_OW 308
17224: OR
17225: AND
17226: IFFALSE 17348
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17228: LD_VAR 0 5
17232: PPUSH
17233: CALL_OW 262
17237: PUSH
17238: LD_INT 1
17240: EQUAL
17241: PUSH
17242: LD_VAR 0 5
17246: PPUSH
17247: CALL_OW 261
17251: PUSH
17252: LD_INT 30
17254: LESS
17255: AND
17256: PUSH
17257: LD_VAR 0 8
17261: AND
17262: IFFALSE 17332
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17264: LD_VAR 0 5
17268: PPUSH
17269: LD_VAR 0 8
17273: PPUSH
17274: LD_VAR 0 5
17278: PPUSH
17279: CALL_OW 74
17283: PPUSH
17284: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17288: LD_VAR 0 5
17292: PPUSH
17293: LD_VAR 0 8
17297: PPUSH
17298: LD_VAR 0 5
17302: PPUSH
17303: CALL_OW 74
17307: PPUSH
17308: CALL_OW 296
17312: PUSH
17313: LD_INT 6
17315: LESS
17316: IFFALSE 17330
// SetFuel ( i , 100 ) ;
17318: LD_VAR 0 5
17322: PPUSH
17323: LD_INT 100
17325: PPUSH
17326: CALL_OW 240
// end else
17330: GO 17346
// ComAttackUnit ( i , e ) ;
17332: LD_VAR 0 5
17336: PPUSH
17337: LD_VAR 0 14
17341: PPUSH
17342: CALL_OW 115
// end else
17346: GO 17449
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17348: LD_VAR 0 14
17352: PPUSH
17353: LD_EXP 84
17357: PUSH
17358: LD_VAR 0 1
17362: ARRAY
17363: PPUSH
17364: CALL_OW 308
17368: NOT
17369: PUSH
17370: LD_VAR 0 5
17374: PPUSH
17375: LD_VAR 0 14
17379: PPUSH
17380: CALL_OW 296
17384: PUSH
17385: LD_INT 40
17387: GREATEREQUAL
17388: AND
17389: PUSH
17390: LD_VAR 0 5
17394: PPUSH
17395: CALL_OW 256
17399: PUSH
17400: LD_INT 650
17402: LESSEQUAL
17403: OR
17404: PUSH
17405: LD_VAR 0 5
17409: PPUSH
17410: LD_EXP 83
17414: PUSH
17415: LD_VAR 0 1
17419: ARRAY
17420: PPUSH
17421: CALL_OW 308
17425: NOT
17426: AND
17427: IFFALSE 17449
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17429: LD_VAR 0 5
17433: PPUSH
17434: LD_EXP 83
17438: PUSH
17439: LD_VAR 0 1
17443: ARRAY
17444: PPUSH
17445: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17449: LD_VAR 0 5
17453: PPUSH
17454: CALL_OW 256
17458: PUSH
17459: LD_INT 998
17461: LESS
17462: PUSH
17463: LD_VAR 0 5
17467: PPUSH
17468: CALL_OW 263
17472: PUSH
17473: LD_INT 1
17475: EQUAL
17476: AND
17477: PUSH
17478: LD_VAR 0 5
17482: PPUSH
17483: CALL_OW 311
17487: AND
17488: PUSH
17489: LD_VAR 0 5
17493: PPUSH
17494: LD_EXP 83
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 308
17509: AND
17510: IFFALSE 17564
// begin mech := IsDrivenBy ( i ) ;
17512: LD_ADDR_VAR 0 10
17516: PUSH
17517: LD_VAR 0 5
17521: PPUSH
17522: CALL_OW 311
17526: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17527: LD_VAR 0 10
17531: PPUSH
17532: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17536: LD_VAR 0 10
17540: PPUSH
17541: LD_VAR 0 5
17545: PPUSH
17546: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17550: LD_VAR 0 10
17554: PPUSH
17555: LD_VAR 0 5
17559: PPUSH
17560: CALL_OW 180
// end ; end ; unit_human :
17564: GO 17831
17566: LD_INT 1
17568: DOUBLE
17569: EQUAL
17570: IFTRUE 17574
17572: GO 17830
17574: POP
// begin b := IsInUnit ( i ) ;
17575: LD_ADDR_VAR 0 19
17579: PUSH
17580: LD_VAR 0 5
17584: PPUSH
17585: CALL_OW 310
17589: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17590: LD_ADDR_VAR 0 20
17594: PUSH
17595: LD_VAR 0 19
17599: NOT
17600: PUSH
17601: LD_VAR 0 19
17605: PPUSH
17606: CALL_OW 266
17610: PUSH
17611: LD_INT 32
17613: PUSH
17614: LD_INT 31
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: IN
17621: OR
17622: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17623: LD_VAR 0 17
17627: PUSH
17628: LD_VAR 0 2
17632: PPUSH
17633: LD_INT 21
17635: PUSH
17636: LD_INT 2
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: PPUSH
17643: CALL_OW 72
17647: PUSH
17648: LD_INT 1
17650: LESSEQUAL
17651: OR
17652: PUSH
17653: LD_VAR 0 20
17657: AND
17658: PUSH
17659: LD_VAR 0 5
17663: PUSH
17664: LD_VAR 0 18
17668: IN
17669: NOT
17670: AND
17671: IFFALSE 17764
// begin if b then
17673: LD_VAR 0 19
17677: IFFALSE 17726
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17679: LD_VAR 0 19
17683: PPUSH
17684: LD_VAR 0 3
17688: PPUSH
17689: LD_VAR 0 19
17693: PPUSH
17694: CALL_OW 74
17698: PPUSH
17699: CALL_OW 296
17703: PUSH
17704: LD_INT 10
17706: LESS
17707: PUSH
17708: LD_VAR 0 19
17712: PPUSH
17713: CALL_OW 461
17717: PUSH
17718: LD_INT 7
17720: NONEQUAL
17721: AND
17722: IFFALSE 17726
// continue ;
17724: GO 17041
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17726: LD_ADDR_VAR 0 18
17730: PUSH
17731: LD_VAR 0 18
17735: PPUSH
17736: LD_VAR 0 18
17740: PUSH
17741: LD_INT 1
17743: PLUS
17744: PPUSH
17745: LD_VAR 0 5
17749: PPUSH
17750: CALL_OW 1
17754: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17755: LD_VAR 0 5
17759: PPUSH
17760: CALL_OW 122
// end ; if sold_defenders then
17764: LD_VAR 0 18
17768: IFFALSE 17828
// if i in sold_defenders then
17770: LD_VAR 0 5
17774: PUSH
17775: LD_VAR 0 18
17779: IN
17780: IFFALSE 17828
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17782: LD_VAR 0 5
17786: PPUSH
17787: CALL_OW 314
17791: NOT
17792: PUSH
17793: LD_VAR 0 5
17797: PPUSH
17798: LD_VAR 0 14
17802: PPUSH
17803: CALL_OW 296
17807: PUSH
17808: LD_INT 30
17810: LESS
17811: AND
17812: IFFALSE 17828
// ComAttackUnit ( i , e ) ;
17814: LD_VAR 0 5
17818: PPUSH
17819: LD_VAR 0 14
17823: PPUSH
17824: CALL_OW 115
// end ; end ; end ;
17828: GO 17831
17830: POP
// if IsDead ( i ) then
17831: LD_VAR 0 5
17835: PPUSH
17836: CALL_OW 301
17840: IFFALSE 17858
// defenders := defenders diff i ;
17842: LD_ADDR_VAR 0 2
17846: PUSH
17847: LD_VAR 0 2
17851: PUSH
17852: LD_VAR 0 5
17856: DIFF
17857: ST_TO_ADDR
// end ;
17858: GO 17041
17860: POP
17861: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17862: LD_VAR 0 3
17866: NOT
17867: PUSH
17868: LD_VAR 0 2
17872: NOT
17873: OR
17874: PUSH
17875: LD_EXP 59
17879: PUSH
17880: LD_VAR 0 1
17884: ARRAY
17885: NOT
17886: OR
17887: IFFALSE 16945
// MC_Reset ( base , 18 ) ;
17889: LD_VAR 0 1
17893: PPUSH
17894: LD_INT 18
17896: PPUSH
17897: CALL 61542 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17901: LD_ADDR_VAR 0 2
17905: PUSH
17906: LD_VAR 0 2
17910: PUSH
17911: LD_VAR 0 2
17915: PPUSH
17916: LD_INT 2
17918: PUSH
17919: LD_INT 25
17921: PUSH
17922: LD_INT 1
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: LD_INT 25
17931: PUSH
17932: LD_INT 5
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 25
17941: PUSH
17942: LD_INT 8
17944: PUSH
17945: EMPTY
17946: LIST
17947: LIST
17948: PUSH
17949: LD_INT 25
17951: PUSH
17952: LD_INT 9
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: LIST
17963: LIST
17964: LIST
17965: PPUSH
17966: CALL_OW 72
17970: DIFF
17971: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17972: LD_VAR 0 3
17976: NOT
17977: PUSH
17978: LD_VAR 0 2
17982: PPUSH
17983: LD_INT 21
17985: PUSH
17986: LD_INT 2
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PPUSH
17993: CALL_OW 72
17997: AND
17998: IFFALSE 18336
// begin tmp := FilterByTag ( defenders , 19 ) ;
18000: LD_ADDR_VAR 0 12
18004: PUSH
18005: LD_VAR 0 2
18009: PPUSH
18010: LD_INT 19
18012: PPUSH
18013: CALL 54799 0 2
18017: ST_TO_ADDR
// if tmp then
18018: LD_VAR 0 12
18022: IFFALSE 18092
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18024: LD_ADDR_VAR 0 12
18028: PUSH
18029: LD_VAR 0 12
18033: PPUSH
18034: LD_INT 25
18036: PUSH
18037: LD_INT 3
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PPUSH
18044: CALL_OW 72
18048: ST_TO_ADDR
// if tmp then
18049: LD_VAR 0 12
18053: IFFALSE 18092
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18055: LD_ADDR_EXP 71
18059: PUSH
18060: LD_EXP 71
18064: PPUSH
18065: LD_VAR 0 1
18069: PPUSH
18070: LD_EXP 71
18074: PUSH
18075: LD_VAR 0 1
18079: ARRAY
18080: PUSH
18081: LD_VAR 0 12
18085: UNION
18086: PPUSH
18087: CALL_OW 1
18091: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18092: LD_VAR 0 1
18096: PPUSH
18097: LD_INT 19
18099: PPUSH
18100: CALL 61542 0 2
// repeat wait ( 0 0$1 ) ;
18104: LD_INT 35
18106: PPUSH
18107: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18111: LD_EXP 59
18115: PUSH
18116: LD_VAR 0 1
18120: ARRAY
18121: NOT
18122: PUSH
18123: LD_EXP 59
18127: PUSH
18128: LD_VAR 0 1
18132: ARRAY
18133: PUSH
18134: EMPTY
18135: EQUAL
18136: OR
18137: IFFALSE 18174
// begin for i in defenders do
18139: LD_ADDR_VAR 0 5
18143: PUSH
18144: LD_VAR 0 2
18148: PUSH
18149: FOR_IN
18150: IFFALSE 18163
// ComStop ( i ) ;
18152: LD_VAR 0 5
18156: PPUSH
18157: CALL_OW 141
18161: GO 18149
18163: POP
18164: POP
// defenders := [ ] ;
18165: LD_ADDR_VAR 0 2
18169: PUSH
18170: EMPTY
18171: ST_TO_ADDR
// exit ;
18172: GO 18360
// end ; for i in defenders do
18174: LD_ADDR_VAR 0 5
18178: PUSH
18179: LD_VAR 0 2
18183: PUSH
18184: FOR_IN
18185: IFFALSE 18274
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18187: LD_VAR 0 5
18191: PPUSH
18192: LD_EXP 83
18196: PUSH
18197: LD_VAR 0 1
18201: ARRAY
18202: PPUSH
18203: CALL_OW 308
18207: NOT
18208: IFFALSE 18232
// ComMoveToArea ( i , mc_parking [ base ] ) else
18210: LD_VAR 0 5
18214: PPUSH
18215: LD_EXP 83
18219: PUSH
18220: LD_VAR 0 1
18224: ARRAY
18225: PPUSH
18226: CALL_OW 113
18230: GO 18272
// if GetControl ( i ) = control_manual then
18232: LD_VAR 0 5
18236: PPUSH
18237: CALL_OW 263
18241: PUSH
18242: LD_INT 1
18244: EQUAL
18245: IFFALSE 18272
// if IsDrivenBy ( i ) then
18247: LD_VAR 0 5
18251: PPUSH
18252: CALL_OW 311
18256: IFFALSE 18272
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18258: LD_VAR 0 5
18262: PPUSH
18263: CALL_OW 311
18267: PPUSH
18268: CALL_OW 121
// end ;
18272: GO 18184
18274: POP
18275: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18276: LD_VAR 0 2
18280: PPUSH
18281: LD_INT 95
18283: PUSH
18284: LD_EXP 83
18288: PUSH
18289: LD_VAR 0 1
18293: ARRAY
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: PPUSH
18299: CALL_OW 72
18303: PUSH
18304: LD_VAR 0 2
18308: EQUAL
18309: PUSH
18310: LD_EXP 82
18314: PUSH
18315: LD_VAR 0 1
18319: ARRAY
18320: OR
18321: PUSH
18322: LD_EXP 59
18326: PUSH
18327: LD_VAR 0 1
18331: ARRAY
18332: NOT
18333: OR
18334: IFFALSE 18104
// end ; MC_Reset ( base , 19 ) ;
18336: LD_VAR 0 1
18340: PPUSH
18341: LD_INT 19
18343: PPUSH
18344: CALL 61542 0 2
// MC_Reset ( base , 20 ) ;
18348: LD_VAR 0 1
18352: PPUSH
18353: LD_INT 20
18355: PPUSH
18356: CALL 61542 0 2
// end ;
18360: LD_VAR 0 4
18364: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18365: LD_INT 0
18367: PPUSH
18368: PPUSH
18369: PPUSH
18370: PPUSH
// result := false ;
18371: LD_ADDR_VAR 0 2
18375: PUSH
18376: LD_INT 0
18378: ST_TO_ADDR
// side := GetSide ( unit ) ;
18379: LD_ADDR_VAR 0 3
18383: PUSH
18384: LD_VAR 0 1
18388: PPUSH
18389: CALL_OW 255
18393: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18394: LD_ADDR_VAR 0 4
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: CALL_OW 248
18408: ST_TO_ADDR
// case nat of 1 :
18409: LD_VAR 0 4
18413: PUSH
18414: LD_INT 1
18416: DOUBLE
18417: EQUAL
18418: IFTRUE 18422
18420: GO 18433
18422: POP
// tech := tech_lassight ; 2 :
18423: LD_ADDR_VAR 0 5
18427: PUSH
18428: LD_INT 12
18430: ST_TO_ADDR
18431: GO 18472
18433: LD_INT 2
18435: DOUBLE
18436: EQUAL
18437: IFTRUE 18441
18439: GO 18452
18441: POP
// tech := tech_mortar ; 3 :
18442: LD_ADDR_VAR 0 5
18446: PUSH
18447: LD_INT 41
18449: ST_TO_ADDR
18450: GO 18472
18452: LD_INT 3
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18471
18460: POP
// tech := tech_bazooka ; end ;
18461: LD_ADDR_VAR 0 5
18465: PUSH
18466: LD_INT 44
18468: ST_TO_ADDR
18469: GO 18472
18471: POP
// if Researched ( side , tech ) then
18472: LD_VAR 0 3
18476: PPUSH
18477: LD_VAR 0 5
18481: PPUSH
18482: CALL_OW 325
18486: IFFALSE 18513
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 5
18495: PUSH
18496: LD_INT 8
18498: PUSH
18499: LD_INT 9
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: LIST
18506: PUSH
18507: LD_VAR 0 4
18511: ARRAY
18512: ST_TO_ADDR
// end ;
18513: LD_VAR 0 2
18517: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18518: LD_INT 0
18520: PPUSH
18521: PPUSH
18522: PPUSH
// if not mines then
18523: LD_VAR 0 2
18527: NOT
18528: IFFALSE 18532
// exit ;
18530: GO 18676
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18532: LD_ADDR_VAR 0 5
18536: PUSH
18537: LD_INT 81
18539: PUSH
18540: LD_VAR 0 1
18544: PUSH
18545: EMPTY
18546: LIST
18547: LIST
18548: PUSH
18549: LD_INT 3
18551: PUSH
18552: LD_INT 21
18554: PUSH
18555: LD_INT 3
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: PPUSH
18570: CALL_OW 69
18574: ST_TO_ADDR
// for i in mines do
18575: LD_ADDR_VAR 0 4
18579: PUSH
18580: LD_VAR 0 2
18584: PUSH
18585: FOR_IN
18586: IFFALSE 18674
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18588: LD_VAR 0 4
18592: PUSH
18593: LD_INT 1
18595: ARRAY
18596: PPUSH
18597: LD_VAR 0 4
18601: PUSH
18602: LD_INT 2
18604: ARRAY
18605: PPUSH
18606: CALL_OW 458
18610: NOT
18611: IFFALSE 18615
// continue ;
18613: GO 18585
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18615: LD_VAR 0 4
18619: PUSH
18620: LD_INT 1
18622: ARRAY
18623: PPUSH
18624: LD_VAR 0 4
18628: PUSH
18629: LD_INT 2
18631: ARRAY
18632: PPUSH
18633: CALL_OW 428
18637: PUSH
18638: LD_VAR 0 5
18642: IN
18643: IFFALSE 18672
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18645: LD_VAR 0 4
18649: PUSH
18650: LD_INT 1
18652: ARRAY
18653: PPUSH
18654: LD_VAR 0 4
18658: PUSH
18659: LD_INT 2
18661: ARRAY
18662: PPUSH
18663: LD_VAR 0 1
18667: PPUSH
18668: CALL_OW 456
// end ;
18672: GO 18585
18674: POP
18675: POP
// end ;
18676: LD_VAR 0 3
18680: RET
// export function Count ( array ) ; var i ; begin
18681: LD_INT 0
18683: PPUSH
18684: PPUSH
// result := 0 ;
18685: LD_ADDR_VAR 0 2
18689: PUSH
18690: LD_INT 0
18692: ST_TO_ADDR
// for i in array do
18693: LD_ADDR_VAR 0 3
18697: PUSH
18698: LD_VAR 0 1
18702: PUSH
18703: FOR_IN
18704: IFFALSE 18728
// if i then
18706: LD_VAR 0 3
18710: IFFALSE 18726
// result := result + 1 ;
18712: LD_ADDR_VAR 0 2
18716: PUSH
18717: LD_VAR 0 2
18721: PUSH
18722: LD_INT 1
18724: PLUS
18725: ST_TO_ADDR
18726: GO 18703
18728: POP
18729: POP
// end ;
18730: LD_VAR 0 2
18734: RET
// export function IsEmpty ( building ) ; begin
18735: LD_INT 0
18737: PPUSH
// if not building then
18738: LD_VAR 0 1
18742: NOT
18743: IFFALSE 18747
// exit ;
18745: GO 18790
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18747: LD_ADDR_VAR 0 2
18751: PUSH
18752: LD_VAR 0 1
18756: PUSH
18757: LD_INT 22
18759: PUSH
18760: LD_VAR 0 1
18764: PPUSH
18765: CALL_OW 255
18769: PUSH
18770: EMPTY
18771: LIST
18772: LIST
18773: PUSH
18774: LD_INT 58
18776: PUSH
18777: EMPTY
18778: LIST
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PPUSH
18784: CALL_OW 69
18788: IN
18789: ST_TO_ADDR
// end ;
18790: LD_VAR 0 2
18794: RET
// export function IsNotFull ( building ) ; begin
18795: LD_INT 0
18797: PPUSH
// if not building then
18798: LD_VAR 0 1
18802: NOT
18803: IFFALSE 18807
// exit ;
18805: GO 18826
// result := UnitsInside ( building ) < 6 ;
18807: LD_ADDR_VAR 0 2
18811: PUSH
18812: LD_VAR 0 1
18816: PPUSH
18817: CALL_OW 313
18821: PUSH
18822: LD_INT 6
18824: LESS
18825: ST_TO_ADDR
// end ;
18826: LD_VAR 0 2
18830: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18831: LD_INT 0
18833: PPUSH
18834: PPUSH
18835: PPUSH
18836: PPUSH
// tmp := [ ] ;
18837: LD_ADDR_VAR 0 3
18841: PUSH
18842: EMPTY
18843: ST_TO_ADDR
// list := [ ] ;
18844: LD_ADDR_VAR 0 5
18848: PUSH
18849: EMPTY
18850: ST_TO_ADDR
// for i = 16 to 25 do
18851: LD_ADDR_VAR 0 4
18855: PUSH
18856: DOUBLE
18857: LD_INT 16
18859: DEC
18860: ST_TO_ADDR
18861: LD_INT 25
18863: PUSH
18864: FOR_TO
18865: IFFALSE 18938
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18867: LD_ADDR_VAR 0 3
18871: PUSH
18872: LD_VAR 0 3
18876: PUSH
18877: LD_INT 22
18879: PUSH
18880: LD_VAR 0 1
18884: PPUSH
18885: CALL_OW 255
18889: PUSH
18890: EMPTY
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 91
18896: PUSH
18897: LD_VAR 0 1
18901: PUSH
18902: LD_INT 6
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 30
18912: PUSH
18913: LD_VAR 0 4
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: PPUSH
18930: CALL_OW 69
18934: ADD
18935: ST_TO_ADDR
18936: GO 18864
18938: POP
18939: POP
// for i = 1 to tmp do
18940: LD_ADDR_VAR 0 4
18944: PUSH
18945: DOUBLE
18946: LD_INT 1
18948: DEC
18949: ST_TO_ADDR
18950: LD_VAR 0 3
18954: PUSH
18955: FOR_TO
18956: IFFALSE 19044
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18958: LD_ADDR_VAR 0 5
18962: PUSH
18963: LD_VAR 0 5
18967: PUSH
18968: LD_VAR 0 3
18972: PUSH
18973: LD_VAR 0 4
18977: ARRAY
18978: PPUSH
18979: CALL_OW 266
18983: PUSH
18984: LD_VAR 0 3
18988: PUSH
18989: LD_VAR 0 4
18993: ARRAY
18994: PPUSH
18995: CALL_OW 250
18999: PUSH
19000: LD_VAR 0 3
19004: PUSH
19005: LD_VAR 0 4
19009: ARRAY
19010: PPUSH
19011: CALL_OW 251
19015: PUSH
19016: LD_VAR 0 3
19020: PUSH
19021: LD_VAR 0 4
19025: ARRAY
19026: PPUSH
19027: CALL_OW 254
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: ADD
19041: ST_TO_ADDR
19042: GO 18955
19044: POP
19045: POP
// result := list ;
19046: LD_ADDR_VAR 0 2
19050: PUSH
19051: LD_VAR 0 5
19055: ST_TO_ADDR
// end ;
19056: LD_VAR 0 2
19060: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
19069: PPUSH
// if not factory then
19070: LD_VAR 0 1
19074: NOT
19075: IFFALSE 19079
// exit ;
19077: GO 19672
// if control = control_apeman then
19079: LD_VAR 0 4
19083: PUSH
19084: LD_INT 5
19086: EQUAL
19087: IFFALSE 19196
// begin tmp := UnitsInside ( factory ) ;
19089: LD_ADDR_VAR 0 8
19093: PUSH
19094: LD_VAR 0 1
19098: PPUSH
19099: CALL_OW 313
19103: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19104: LD_VAR 0 8
19108: PPUSH
19109: LD_INT 25
19111: PUSH
19112: LD_INT 12
19114: PUSH
19115: EMPTY
19116: LIST
19117: LIST
19118: PPUSH
19119: CALL_OW 72
19123: NOT
19124: IFFALSE 19134
// control := control_manual ;
19126: LD_ADDR_VAR 0 4
19130: PUSH
19131: LD_INT 1
19133: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19134: LD_ADDR_VAR 0 8
19138: PUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL 18831 0 1
19148: ST_TO_ADDR
// if tmp then
19149: LD_VAR 0 8
19153: IFFALSE 19196
// begin for i in tmp do
19155: LD_ADDR_VAR 0 7
19159: PUSH
19160: LD_VAR 0 8
19164: PUSH
19165: FOR_IN
19166: IFFALSE 19194
// if i [ 1 ] = b_ext_radio then
19168: LD_VAR 0 7
19172: PUSH
19173: LD_INT 1
19175: ARRAY
19176: PUSH
19177: LD_INT 22
19179: EQUAL
19180: IFFALSE 19192
// begin control := control_remote ;
19182: LD_ADDR_VAR 0 4
19186: PUSH
19187: LD_INT 2
19189: ST_TO_ADDR
// break ;
19190: GO 19194
// end ;
19192: GO 19165
19194: POP
19195: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19196: LD_VAR 0 1
19200: PPUSH
19201: LD_VAR 0 2
19205: PPUSH
19206: LD_VAR 0 3
19210: PPUSH
19211: LD_VAR 0 4
19215: PPUSH
19216: LD_VAR 0 5
19220: PPUSH
19221: CALL_OW 448
19225: IFFALSE 19260
// begin result := [ chassis , engine , control , weapon ] ;
19227: LD_ADDR_VAR 0 6
19231: PUSH
19232: LD_VAR 0 2
19236: PUSH
19237: LD_VAR 0 3
19241: PUSH
19242: LD_VAR 0 4
19246: PUSH
19247: LD_VAR 0 5
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: LIST
19256: LIST
19257: ST_TO_ADDR
// exit ;
19258: GO 19672
// end ; _chassis := AvailableChassisList ( factory ) ;
19260: LD_ADDR_VAR 0 9
19264: PUSH
19265: LD_VAR 0 1
19269: PPUSH
19270: CALL_OW 475
19274: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19275: LD_ADDR_VAR 0 11
19279: PUSH
19280: LD_VAR 0 1
19284: PPUSH
19285: CALL_OW 476
19289: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19290: LD_ADDR_VAR 0 12
19294: PUSH
19295: LD_VAR 0 1
19299: PPUSH
19300: CALL_OW 477
19304: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19305: LD_ADDR_VAR 0 10
19309: PUSH
19310: LD_VAR 0 1
19314: PPUSH
19315: CALL_OW 478
19319: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19320: LD_VAR 0 9
19324: NOT
19325: PUSH
19326: LD_VAR 0 11
19330: NOT
19331: OR
19332: PUSH
19333: LD_VAR 0 12
19337: NOT
19338: OR
19339: PUSH
19340: LD_VAR 0 10
19344: NOT
19345: OR
19346: IFFALSE 19381
// begin result := [ chassis , engine , control , weapon ] ;
19348: LD_ADDR_VAR 0 6
19352: PUSH
19353: LD_VAR 0 2
19357: PUSH
19358: LD_VAR 0 3
19362: PUSH
19363: LD_VAR 0 4
19367: PUSH
19368: LD_VAR 0 5
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: ST_TO_ADDR
// exit ;
19379: GO 19672
// end ; if not chassis in _chassis then
19381: LD_VAR 0 2
19385: PUSH
19386: LD_VAR 0 9
19390: IN
19391: NOT
19392: IFFALSE 19418
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19394: LD_ADDR_VAR 0 2
19398: PUSH
19399: LD_VAR 0 9
19403: PUSH
19404: LD_INT 1
19406: PPUSH
19407: LD_VAR 0 9
19411: PPUSH
19412: CALL_OW 12
19416: ARRAY
19417: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19418: LD_VAR 0 2
19422: PPUSH
19423: LD_VAR 0 3
19427: PPUSH
19428: CALL 19677 0 2
19432: NOT
19433: IFFALSE 19492
// repeat engine := _engine [ 1 ] ;
19435: LD_ADDR_VAR 0 3
19439: PUSH
19440: LD_VAR 0 11
19444: PUSH
19445: LD_INT 1
19447: ARRAY
19448: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19449: LD_ADDR_VAR 0 11
19453: PUSH
19454: LD_VAR 0 11
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 3
19466: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19467: LD_VAR 0 2
19471: PPUSH
19472: LD_VAR 0 3
19476: PPUSH
19477: CALL 19677 0 2
19481: PUSH
19482: LD_VAR 0 11
19486: PUSH
19487: EMPTY
19488: EQUAL
19489: OR
19490: IFFALSE 19435
// if not control in _control then
19492: LD_VAR 0 4
19496: PUSH
19497: LD_VAR 0 12
19501: IN
19502: NOT
19503: IFFALSE 19529
// control := _control [ rand ( 1 , _control ) ] ;
19505: LD_ADDR_VAR 0 4
19509: PUSH
19510: LD_VAR 0 12
19514: PUSH
19515: LD_INT 1
19517: PPUSH
19518: LD_VAR 0 12
19522: PPUSH
19523: CALL_OW 12
19527: ARRAY
19528: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19529: LD_VAR 0 2
19533: PPUSH
19534: LD_VAR 0 5
19538: PPUSH
19539: CALL 19897 0 2
19543: NOT
19544: IFFALSE 19603
// repeat weapon := _weapon [ 1 ] ;
19546: LD_ADDR_VAR 0 5
19550: PUSH
19551: LD_VAR 0 10
19555: PUSH
19556: LD_INT 1
19558: ARRAY
19559: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19560: LD_ADDR_VAR 0 10
19564: PUSH
19565: LD_VAR 0 10
19569: PPUSH
19570: LD_INT 1
19572: PPUSH
19573: CALL_OW 3
19577: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19578: LD_VAR 0 2
19582: PPUSH
19583: LD_VAR 0 5
19587: PPUSH
19588: CALL 19897 0 2
19592: PUSH
19593: LD_VAR 0 10
19597: PUSH
19598: EMPTY
19599: EQUAL
19600: OR
19601: IFFALSE 19546
// result := [ ] ;
19603: LD_ADDR_VAR 0 6
19607: PUSH
19608: EMPTY
19609: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19610: LD_VAR 0 1
19614: PPUSH
19615: LD_VAR 0 2
19619: PPUSH
19620: LD_VAR 0 3
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: LD_VAR 0 5
19634: PPUSH
19635: CALL_OW 448
19639: IFFALSE 19672
// result := [ chassis , engine , control , weapon ] ;
19641: LD_ADDR_VAR 0 6
19645: PUSH
19646: LD_VAR 0 2
19650: PUSH
19651: LD_VAR 0 3
19655: PUSH
19656: LD_VAR 0 4
19660: PUSH
19661: LD_VAR 0 5
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: ST_TO_ADDR
// end ;
19672: LD_VAR 0 6
19676: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19677: LD_INT 0
19679: PPUSH
// if not chassis or not engine then
19680: LD_VAR 0 1
19684: NOT
19685: PUSH
19686: LD_VAR 0 2
19690: NOT
19691: OR
19692: IFFALSE 19696
// exit ;
19694: GO 19892
// case engine of engine_solar :
19696: LD_VAR 0 2
19700: PUSH
19701: LD_INT 2
19703: DOUBLE
19704: EQUAL
19705: IFTRUE 19709
19707: GO 19747
19709: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_INT 11
19717: PUSH
19718: LD_INT 12
19720: PUSH
19721: LD_INT 13
19723: PUSH
19724: LD_INT 14
19726: PUSH
19727: LD_INT 1
19729: PUSH
19730: LD_INT 2
19732: PUSH
19733: LD_INT 3
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19876
19747: LD_INT 1
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19817
19755: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 11
19763: PUSH
19764: LD_INT 12
19766: PUSH
19767: LD_INT 13
19769: PUSH
19770: LD_INT 14
19772: PUSH
19773: LD_INT 1
19775: PUSH
19776: LD_INT 2
19778: PUSH
19779: LD_INT 3
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: LD_INT 5
19787: PUSH
19788: LD_INT 21
19790: PUSH
19791: LD_INT 23
19793: PUSH
19794: LD_INT 22
19796: PUSH
19797: LD_INT 24
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: ST_TO_ADDR
19815: GO 19876
19817: LD_INT 3
19819: DOUBLE
19820: EQUAL
19821: IFTRUE 19825
19823: GO 19875
19825: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19826: LD_ADDR_VAR 0 3
19830: PUSH
19831: LD_INT 13
19833: PUSH
19834: LD_INT 14
19836: PUSH
19837: LD_INT 2
19839: PUSH
19840: LD_INT 3
19842: PUSH
19843: LD_INT 4
19845: PUSH
19846: LD_INT 5
19848: PUSH
19849: LD_INT 21
19851: PUSH
19852: LD_INT 22
19854: PUSH
19855: LD_INT 23
19857: PUSH
19858: LD_INT 24
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: ST_TO_ADDR
19873: GO 19876
19875: POP
// result := ( chassis in result ) ;
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_VAR 0 1
19885: PUSH
19886: LD_VAR 0 3
19890: IN
19891: ST_TO_ADDR
// end ;
19892: LD_VAR 0 3
19896: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19897: LD_INT 0
19899: PPUSH
// if not chassis or not weapon then
19900: LD_VAR 0 1
19904: NOT
19905: PUSH
19906: LD_VAR 0 2
19910: NOT
19911: OR
19912: IFFALSE 19916
// exit ;
19914: GO 20942
// case weapon of us_machine_gun :
19916: LD_VAR 0 2
19920: PUSH
19921: LD_INT 2
19923: DOUBLE
19924: EQUAL
19925: IFTRUE 19929
19927: GO 19959
19929: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19930: LD_ADDR_VAR 0 3
19934: PUSH
19935: LD_INT 1
19937: PUSH
19938: LD_INT 2
19940: PUSH
19941: LD_INT 3
19943: PUSH
19944: LD_INT 4
19946: PUSH
19947: LD_INT 5
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: ST_TO_ADDR
19957: GO 20926
19959: LD_INT 3
19961: DOUBLE
19962: EQUAL
19963: IFTRUE 19967
19965: GO 19997
19967: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19968: LD_ADDR_VAR 0 3
19972: PUSH
19973: LD_INT 1
19975: PUSH
19976: LD_INT 2
19978: PUSH
19979: LD_INT 3
19981: PUSH
19982: LD_INT 4
19984: PUSH
19985: LD_INT 5
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: ST_TO_ADDR
19995: GO 20926
19997: LD_INT 11
19999: DOUBLE
20000: EQUAL
20001: IFTRUE 20005
20003: GO 20035
20005: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20006: LD_ADDR_VAR 0 3
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: LD_INT 2
20016: PUSH
20017: LD_INT 3
20019: PUSH
20020: LD_INT 4
20022: PUSH
20023: LD_INT 5
20025: PUSH
20026: EMPTY
20027: LIST
20028: LIST
20029: LIST
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20926
20035: LD_INT 4
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20069
20043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 2
20051: PUSH
20052: LD_INT 3
20054: PUSH
20055: LD_INT 4
20057: PUSH
20058: LD_INT 5
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: ST_TO_ADDR
20067: GO 20926
20069: LD_INT 5
20071: DOUBLE
20072: EQUAL
20073: IFTRUE 20077
20075: GO 20103
20077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20078: LD_ADDR_VAR 0 3
20082: PUSH
20083: LD_INT 2
20085: PUSH
20086: LD_INT 3
20088: PUSH
20089: LD_INT 4
20091: PUSH
20092: LD_INT 5
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: ST_TO_ADDR
20101: GO 20926
20103: LD_INT 9
20105: DOUBLE
20106: EQUAL
20107: IFTRUE 20111
20109: GO 20137
20111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20112: LD_ADDR_VAR 0 3
20116: PUSH
20117: LD_INT 2
20119: PUSH
20120: LD_INT 3
20122: PUSH
20123: LD_INT 4
20125: PUSH
20126: LD_INT 5
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: LIST
20133: LIST
20134: ST_TO_ADDR
20135: GO 20926
20137: LD_INT 7
20139: DOUBLE
20140: EQUAL
20141: IFTRUE 20145
20143: GO 20171
20145: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20146: LD_ADDR_VAR 0 3
20150: PUSH
20151: LD_INT 2
20153: PUSH
20154: LD_INT 3
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 5
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: ST_TO_ADDR
20169: GO 20926
20171: LD_INT 12
20173: DOUBLE
20174: EQUAL
20175: IFTRUE 20179
20177: GO 20205
20179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20180: LD_ADDR_VAR 0 3
20184: PUSH
20185: LD_INT 2
20187: PUSH
20188: LD_INT 3
20190: PUSH
20191: LD_INT 4
20193: PUSH
20194: LD_INT 5
20196: PUSH
20197: EMPTY
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: ST_TO_ADDR
20203: GO 20926
20205: LD_INT 13
20207: DOUBLE
20208: EQUAL
20209: IFTRUE 20213
20211: GO 20239
20213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20214: LD_ADDR_VAR 0 3
20218: PUSH
20219: LD_INT 2
20221: PUSH
20222: LD_INT 3
20224: PUSH
20225: LD_INT 4
20227: PUSH
20228: LD_INT 5
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: LIST
20235: LIST
20236: ST_TO_ADDR
20237: GO 20926
20239: LD_INT 14
20241: DOUBLE
20242: EQUAL
20243: IFTRUE 20247
20245: GO 20265
20247: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20248: LD_ADDR_VAR 0 3
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: LD_INT 5
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20926
20265: LD_INT 6
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20291
20273: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 4
20281: PUSH
20282: LD_INT 5
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: ST_TO_ADDR
20289: GO 20926
20291: LD_INT 10
20293: DOUBLE
20294: EQUAL
20295: IFTRUE 20299
20297: GO 20317
20299: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20300: LD_ADDR_VAR 0 3
20304: PUSH
20305: LD_INT 4
20307: PUSH
20308: LD_INT 5
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: ST_TO_ADDR
20315: GO 20926
20317: LD_INT 22
20319: DOUBLE
20320: EQUAL
20321: IFTRUE 20325
20323: GO 20351
20325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20326: LD_ADDR_VAR 0 3
20330: PUSH
20331: LD_INT 11
20333: PUSH
20334: LD_INT 12
20336: PUSH
20337: LD_INT 13
20339: PUSH
20340: LD_INT 14
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: ST_TO_ADDR
20349: GO 20926
20351: LD_INT 23
20353: DOUBLE
20354: EQUAL
20355: IFTRUE 20359
20357: GO 20385
20359: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_INT 11
20367: PUSH
20368: LD_INT 12
20370: PUSH
20371: LD_INT 13
20373: PUSH
20374: LD_INT 14
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: ST_TO_ADDR
20383: GO 20926
20385: LD_INT 24
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20393
20391: GO 20419
20393: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20394: LD_ADDR_VAR 0 3
20398: PUSH
20399: LD_INT 11
20401: PUSH
20402: LD_INT 12
20404: PUSH
20405: LD_INT 13
20407: PUSH
20408: LD_INT 14
20410: PUSH
20411: EMPTY
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: ST_TO_ADDR
20417: GO 20926
20419: LD_INT 30
20421: DOUBLE
20422: EQUAL
20423: IFTRUE 20427
20425: GO 20453
20427: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20428: LD_ADDR_VAR 0 3
20432: PUSH
20433: LD_INT 11
20435: PUSH
20436: LD_INT 12
20438: PUSH
20439: LD_INT 13
20441: PUSH
20442: LD_INT 14
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: ST_TO_ADDR
20451: GO 20926
20453: LD_INT 25
20455: DOUBLE
20456: EQUAL
20457: IFTRUE 20461
20459: GO 20479
20461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20462: LD_ADDR_VAR 0 3
20466: PUSH
20467: LD_INT 13
20469: PUSH
20470: LD_INT 14
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: ST_TO_ADDR
20477: GO 20926
20479: LD_INT 27
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20505
20487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20488: LD_ADDR_VAR 0 3
20492: PUSH
20493: LD_INT 13
20495: PUSH
20496: LD_INT 14
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: ST_TO_ADDR
20503: GO 20926
20505: LD_INT 28
20507: DOUBLE
20508: EQUAL
20509: IFTRUE 20513
20511: GO 20531
20513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20514: LD_ADDR_VAR 0 3
20518: PUSH
20519: LD_INT 13
20521: PUSH
20522: LD_INT 14
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: ST_TO_ADDR
20529: GO 20926
20531: LD_INT 29
20533: DOUBLE
20534: EQUAL
20535: IFTRUE 20539
20537: GO 20557
20539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20540: LD_ADDR_VAR 0 3
20544: PUSH
20545: LD_INT 13
20547: PUSH
20548: LD_INT 14
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: ST_TO_ADDR
20555: GO 20926
20557: LD_INT 31
20559: DOUBLE
20560: EQUAL
20561: IFTRUE 20565
20563: GO 20583
20565: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20566: LD_ADDR_VAR 0 3
20570: PUSH
20571: LD_INT 13
20573: PUSH
20574: LD_INT 14
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: ST_TO_ADDR
20581: GO 20926
20583: LD_INT 26
20585: DOUBLE
20586: EQUAL
20587: IFTRUE 20591
20589: GO 20609
20591: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_INT 13
20599: PUSH
20600: LD_INT 14
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: ST_TO_ADDR
20607: GO 20926
20609: LD_INT 42
20611: DOUBLE
20612: EQUAL
20613: IFTRUE 20617
20615: GO 20643
20617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20618: LD_ADDR_VAR 0 3
20622: PUSH
20623: LD_INT 21
20625: PUSH
20626: LD_INT 22
20628: PUSH
20629: LD_INT 23
20631: PUSH
20632: LD_INT 24
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: ST_TO_ADDR
20641: GO 20926
20643: LD_INT 43
20645: DOUBLE
20646: EQUAL
20647: IFTRUE 20651
20649: GO 20677
20651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_INT 21
20659: PUSH
20660: LD_INT 22
20662: PUSH
20663: LD_INT 23
20665: PUSH
20666: LD_INT 24
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: ST_TO_ADDR
20675: GO 20926
20677: LD_INT 44
20679: DOUBLE
20680: EQUAL
20681: IFTRUE 20685
20683: GO 20711
20685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20686: LD_ADDR_VAR 0 3
20690: PUSH
20691: LD_INT 21
20693: PUSH
20694: LD_INT 22
20696: PUSH
20697: LD_INT 23
20699: PUSH
20700: LD_INT 24
20702: PUSH
20703: EMPTY
20704: LIST
20705: LIST
20706: LIST
20707: LIST
20708: ST_TO_ADDR
20709: GO 20926
20711: LD_INT 45
20713: DOUBLE
20714: EQUAL
20715: IFTRUE 20719
20717: GO 20745
20719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20720: LD_ADDR_VAR 0 3
20724: PUSH
20725: LD_INT 21
20727: PUSH
20728: LD_INT 22
20730: PUSH
20731: LD_INT 23
20733: PUSH
20734: LD_INT 24
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: ST_TO_ADDR
20743: GO 20926
20745: LD_INT 49
20747: DOUBLE
20748: EQUAL
20749: IFTRUE 20753
20751: GO 20779
20753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20754: LD_ADDR_VAR 0 3
20758: PUSH
20759: LD_INT 21
20761: PUSH
20762: LD_INT 22
20764: PUSH
20765: LD_INT 23
20767: PUSH
20768: LD_INT 24
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: ST_TO_ADDR
20777: GO 20926
20779: LD_INT 51
20781: DOUBLE
20782: EQUAL
20783: IFTRUE 20787
20785: GO 20813
20787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20788: LD_ADDR_VAR 0 3
20792: PUSH
20793: LD_INT 21
20795: PUSH
20796: LD_INT 22
20798: PUSH
20799: LD_INT 23
20801: PUSH
20802: LD_INT 24
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: ST_TO_ADDR
20811: GO 20926
20813: LD_INT 52
20815: DOUBLE
20816: EQUAL
20817: IFTRUE 20821
20819: GO 20847
20821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20822: LD_ADDR_VAR 0 3
20826: PUSH
20827: LD_INT 21
20829: PUSH
20830: LD_INT 22
20832: PUSH
20833: LD_INT 23
20835: PUSH
20836: LD_INT 24
20838: PUSH
20839: EMPTY
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: ST_TO_ADDR
20845: GO 20926
20847: LD_INT 53
20849: DOUBLE
20850: EQUAL
20851: IFTRUE 20855
20853: GO 20873
20855: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20856: LD_ADDR_VAR 0 3
20860: PUSH
20861: LD_INT 23
20863: PUSH
20864: LD_INT 24
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: ST_TO_ADDR
20871: GO 20926
20873: LD_INT 46
20875: DOUBLE
20876: EQUAL
20877: IFTRUE 20881
20879: GO 20899
20881: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20882: LD_ADDR_VAR 0 3
20886: PUSH
20887: LD_INT 23
20889: PUSH
20890: LD_INT 24
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: ST_TO_ADDR
20897: GO 20926
20899: LD_INT 47
20901: DOUBLE
20902: EQUAL
20903: IFTRUE 20907
20905: GO 20925
20907: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20908: LD_ADDR_VAR 0 3
20912: PUSH
20913: LD_INT 23
20915: PUSH
20916: LD_INT 24
20918: PUSH
20919: EMPTY
20920: LIST
20921: LIST
20922: ST_TO_ADDR
20923: GO 20926
20925: POP
// result := ( chassis in result ) ;
20926: LD_ADDR_VAR 0 3
20930: PUSH
20931: LD_VAR 0 1
20935: PUSH
20936: LD_VAR 0 3
20940: IN
20941: ST_TO_ADDR
// end ;
20942: LD_VAR 0 3
20946: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20947: LD_INT 0
20949: PPUSH
20950: PPUSH
20951: PPUSH
20952: PPUSH
20953: PPUSH
20954: PPUSH
20955: PPUSH
// result := array ;
20956: LD_ADDR_VAR 0 5
20960: PUSH
20961: LD_VAR 0 1
20965: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20966: LD_VAR 0 1
20970: NOT
20971: PUSH
20972: LD_VAR 0 2
20976: NOT
20977: OR
20978: PUSH
20979: LD_VAR 0 3
20983: NOT
20984: OR
20985: PUSH
20986: LD_VAR 0 2
20990: PUSH
20991: LD_VAR 0 1
20995: GREATER
20996: OR
20997: PUSH
20998: LD_VAR 0 3
21002: PUSH
21003: LD_VAR 0 1
21007: GREATER
21008: OR
21009: IFFALSE 21013
// exit ;
21011: GO 21309
// if direction then
21013: LD_VAR 0 4
21017: IFFALSE 21081
// begin d := 1 ;
21019: LD_ADDR_VAR 0 9
21023: PUSH
21024: LD_INT 1
21026: ST_TO_ADDR
// if i_from > i_to then
21027: LD_VAR 0 2
21031: PUSH
21032: LD_VAR 0 3
21036: GREATER
21037: IFFALSE 21063
// length := ( array - i_from ) + i_to else
21039: LD_ADDR_VAR 0 11
21043: PUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 2
21053: MINUS
21054: PUSH
21055: LD_VAR 0 3
21059: PLUS
21060: ST_TO_ADDR
21061: GO 21079
// length := i_to - i_from ;
21063: LD_ADDR_VAR 0 11
21067: PUSH
21068: LD_VAR 0 3
21072: PUSH
21073: LD_VAR 0 2
21077: MINUS
21078: ST_TO_ADDR
// end else
21079: GO 21142
// begin d := - 1 ;
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: LD_INT 1
21088: NEG
21089: ST_TO_ADDR
// if i_from > i_to then
21090: LD_VAR 0 2
21094: PUSH
21095: LD_VAR 0 3
21099: GREATER
21100: IFFALSE 21120
// length := i_from - i_to else
21102: LD_ADDR_VAR 0 11
21106: PUSH
21107: LD_VAR 0 2
21111: PUSH
21112: LD_VAR 0 3
21116: MINUS
21117: ST_TO_ADDR
21118: GO 21142
// length := ( array - i_to ) + i_from ;
21120: LD_ADDR_VAR 0 11
21124: PUSH
21125: LD_VAR 0 1
21129: PUSH
21130: LD_VAR 0 3
21134: MINUS
21135: PUSH
21136: LD_VAR 0 2
21140: PLUS
21141: ST_TO_ADDR
// end ; if not length then
21142: LD_VAR 0 11
21146: NOT
21147: IFFALSE 21151
// exit ;
21149: GO 21309
// tmp := array ;
21151: LD_ADDR_VAR 0 10
21155: PUSH
21156: LD_VAR 0 1
21160: ST_TO_ADDR
// for i = 1 to length do
21161: LD_ADDR_VAR 0 6
21165: PUSH
21166: DOUBLE
21167: LD_INT 1
21169: DEC
21170: ST_TO_ADDR
21171: LD_VAR 0 11
21175: PUSH
21176: FOR_TO
21177: IFFALSE 21297
// begin for j = 1 to array do
21179: LD_ADDR_VAR 0 7
21183: PUSH
21184: DOUBLE
21185: LD_INT 1
21187: DEC
21188: ST_TO_ADDR
21189: LD_VAR 0 1
21193: PUSH
21194: FOR_TO
21195: IFFALSE 21283
// begin k := j + d ;
21197: LD_ADDR_VAR 0 8
21201: PUSH
21202: LD_VAR 0 7
21206: PUSH
21207: LD_VAR 0 9
21211: PLUS
21212: ST_TO_ADDR
// if k > array then
21213: LD_VAR 0 8
21217: PUSH
21218: LD_VAR 0 1
21222: GREATER
21223: IFFALSE 21233
// k := 1 ;
21225: LD_ADDR_VAR 0 8
21229: PUSH
21230: LD_INT 1
21232: ST_TO_ADDR
// if not k then
21233: LD_VAR 0 8
21237: NOT
21238: IFFALSE 21250
// k := array ;
21240: LD_ADDR_VAR 0 8
21244: PUSH
21245: LD_VAR 0 1
21249: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21250: LD_ADDR_VAR 0 10
21254: PUSH
21255: LD_VAR 0 10
21259: PPUSH
21260: LD_VAR 0 8
21264: PPUSH
21265: LD_VAR 0 1
21269: PUSH
21270: LD_VAR 0 7
21274: ARRAY
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// end ;
21281: GO 21194
21283: POP
21284: POP
// array := tmp ;
21285: LD_ADDR_VAR 0 1
21289: PUSH
21290: LD_VAR 0 10
21294: ST_TO_ADDR
// end ;
21295: GO 21176
21297: POP
21298: POP
// result := array ;
21299: LD_ADDR_VAR 0 5
21303: PUSH
21304: LD_VAR 0 1
21308: ST_TO_ADDR
// end ;
21309: LD_VAR 0 5
21313: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21314: LD_INT 0
21316: PPUSH
21317: PPUSH
// result := 0 ;
21318: LD_ADDR_VAR 0 3
21322: PUSH
21323: LD_INT 0
21325: ST_TO_ADDR
// if not array or not value in array then
21326: LD_VAR 0 1
21330: NOT
21331: PUSH
21332: LD_VAR 0 2
21336: PUSH
21337: LD_VAR 0 1
21341: IN
21342: NOT
21343: OR
21344: IFFALSE 21348
// exit ;
21346: GO 21402
// for i = 1 to array do
21348: LD_ADDR_VAR 0 4
21352: PUSH
21353: DOUBLE
21354: LD_INT 1
21356: DEC
21357: ST_TO_ADDR
21358: LD_VAR 0 1
21362: PUSH
21363: FOR_TO
21364: IFFALSE 21400
// if value = array [ i ] then
21366: LD_VAR 0 2
21370: PUSH
21371: LD_VAR 0 1
21375: PUSH
21376: LD_VAR 0 4
21380: ARRAY
21381: EQUAL
21382: IFFALSE 21398
// begin result := i ;
21384: LD_ADDR_VAR 0 3
21388: PUSH
21389: LD_VAR 0 4
21393: ST_TO_ADDR
// exit ;
21394: POP
21395: POP
21396: GO 21402
// end ;
21398: GO 21363
21400: POP
21401: POP
// end ;
21402: LD_VAR 0 3
21406: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21407: LD_INT 0
21409: PPUSH
// vc_chassis := chassis ;
21410: LD_ADDR_OWVAR 37
21414: PUSH
21415: LD_VAR 0 1
21419: ST_TO_ADDR
// vc_engine := engine ;
21420: LD_ADDR_OWVAR 39
21424: PUSH
21425: LD_VAR 0 2
21429: ST_TO_ADDR
// vc_control := control ;
21430: LD_ADDR_OWVAR 38
21434: PUSH
21435: LD_VAR 0 3
21439: ST_TO_ADDR
// vc_weapon := weapon ;
21440: LD_ADDR_OWVAR 40
21444: PUSH
21445: LD_VAR 0 4
21449: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21450: LD_ADDR_OWVAR 41
21454: PUSH
21455: LD_VAR 0 5
21459: ST_TO_ADDR
// end ;
21460: LD_VAR 0 6
21464: RET
// export function WantPlant ( unit ) ; var task ; begin
21465: LD_INT 0
21467: PPUSH
21468: PPUSH
// result := false ;
21469: LD_ADDR_VAR 0 2
21473: PUSH
21474: LD_INT 0
21476: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21477: LD_ADDR_VAR 0 3
21481: PUSH
21482: LD_VAR 0 1
21486: PPUSH
21487: CALL_OW 437
21491: ST_TO_ADDR
// if task then
21492: LD_VAR 0 3
21496: IFFALSE 21524
// if task [ 1 ] [ 1 ] = p then
21498: LD_VAR 0 3
21502: PUSH
21503: LD_INT 1
21505: ARRAY
21506: PUSH
21507: LD_INT 1
21509: ARRAY
21510: PUSH
21511: LD_STRING p
21513: EQUAL
21514: IFFALSE 21524
// result := true ;
21516: LD_ADDR_VAR 0 2
21520: PUSH
21521: LD_INT 1
21523: ST_TO_ADDR
// end ;
21524: LD_VAR 0 2
21528: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21529: LD_INT 0
21531: PPUSH
21532: PPUSH
21533: PPUSH
21534: PPUSH
// if pos < 1 then
21535: LD_VAR 0 2
21539: PUSH
21540: LD_INT 1
21542: LESS
21543: IFFALSE 21547
// exit ;
21545: GO 21850
// if pos = 1 then
21547: LD_VAR 0 2
21551: PUSH
21552: LD_INT 1
21554: EQUAL
21555: IFFALSE 21588
// result := Replace ( arr , pos [ 1 ] , value ) else
21557: LD_ADDR_VAR 0 4
21561: PUSH
21562: LD_VAR 0 1
21566: PPUSH
21567: LD_VAR 0 2
21571: PUSH
21572: LD_INT 1
21574: ARRAY
21575: PPUSH
21576: LD_VAR 0 3
21580: PPUSH
21581: CALL_OW 1
21585: ST_TO_ADDR
21586: GO 21850
// begin tmp := arr ;
21588: LD_ADDR_VAR 0 6
21592: PUSH
21593: LD_VAR 0 1
21597: ST_TO_ADDR
// s_arr := [ tmp ] ;
21598: LD_ADDR_VAR 0 7
21602: PUSH
21603: LD_VAR 0 6
21607: PUSH
21608: EMPTY
21609: LIST
21610: ST_TO_ADDR
// for i = 1 to pos - 1 do
21611: LD_ADDR_VAR 0 5
21615: PUSH
21616: DOUBLE
21617: LD_INT 1
21619: DEC
21620: ST_TO_ADDR
21621: LD_VAR 0 2
21625: PUSH
21626: LD_INT 1
21628: MINUS
21629: PUSH
21630: FOR_TO
21631: IFFALSE 21676
// begin tmp := tmp [ pos [ i ] ] ;
21633: LD_ADDR_VAR 0 6
21637: PUSH
21638: LD_VAR 0 6
21642: PUSH
21643: LD_VAR 0 2
21647: PUSH
21648: LD_VAR 0 5
21652: ARRAY
21653: ARRAY
21654: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21655: LD_ADDR_VAR 0 7
21659: PUSH
21660: LD_VAR 0 7
21664: PUSH
21665: LD_VAR 0 6
21669: PUSH
21670: EMPTY
21671: LIST
21672: ADD
21673: ST_TO_ADDR
// end ;
21674: GO 21630
21676: POP
21677: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21678: LD_ADDR_VAR 0 6
21682: PUSH
21683: LD_VAR 0 6
21687: PPUSH
21688: LD_VAR 0 2
21692: PUSH
21693: LD_VAR 0 2
21697: ARRAY
21698: PPUSH
21699: LD_VAR 0 3
21703: PPUSH
21704: CALL_OW 1
21708: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21709: LD_ADDR_VAR 0 7
21713: PUSH
21714: LD_VAR 0 7
21718: PPUSH
21719: LD_VAR 0 7
21723: PPUSH
21724: LD_VAR 0 6
21728: PPUSH
21729: CALL_OW 1
21733: ST_TO_ADDR
// for i = s_arr downto 2 do
21734: LD_ADDR_VAR 0 5
21738: PUSH
21739: DOUBLE
21740: LD_VAR 0 7
21744: INC
21745: ST_TO_ADDR
21746: LD_INT 2
21748: PUSH
21749: FOR_DOWNTO
21750: IFFALSE 21834
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21752: LD_ADDR_VAR 0 6
21756: PUSH
21757: LD_VAR 0 7
21761: PUSH
21762: LD_VAR 0 5
21766: PUSH
21767: LD_INT 1
21769: MINUS
21770: ARRAY
21771: PPUSH
21772: LD_VAR 0 2
21776: PUSH
21777: LD_VAR 0 5
21781: PUSH
21782: LD_INT 1
21784: MINUS
21785: ARRAY
21786: PPUSH
21787: LD_VAR 0 7
21791: PUSH
21792: LD_VAR 0 5
21796: ARRAY
21797: PPUSH
21798: CALL_OW 1
21802: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21803: LD_ADDR_VAR 0 7
21807: PUSH
21808: LD_VAR 0 7
21812: PPUSH
21813: LD_VAR 0 5
21817: PUSH
21818: LD_INT 1
21820: MINUS
21821: PPUSH
21822: LD_VAR 0 6
21826: PPUSH
21827: CALL_OW 1
21831: ST_TO_ADDR
// end ;
21832: GO 21749
21834: POP
21835: POP
// result := s_arr [ 1 ] ;
21836: LD_ADDR_VAR 0 4
21840: PUSH
21841: LD_VAR 0 7
21845: PUSH
21846: LD_INT 1
21848: ARRAY
21849: ST_TO_ADDR
// end ; end ;
21850: LD_VAR 0 4
21854: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21855: LD_INT 0
21857: PPUSH
21858: PPUSH
// if not list then
21859: LD_VAR 0 1
21863: NOT
21864: IFFALSE 21868
// exit ;
21866: GO 21959
// i := list [ pos1 ] ;
21868: LD_ADDR_VAR 0 5
21872: PUSH
21873: LD_VAR 0 1
21877: PUSH
21878: LD_VAR 0 2
21882: ARRAY
21883: ST_TO_ADDR
// if not i then
21884: LD_VAR 0 5
21888: NOT
21889: IFFALSE 21893
// exit ;
21891: GO 21959
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21893: LD_ADDR_VAR 0 1
21897: PUSH
21898: LD_VAR 0 1
21902: PPUSH
21903: LD_VAR 0 2
21907: PPUSH
21908: LD_VAR 0 1
21912: PUSH
21913: LD_VAR 0 3
21917: ARRAY
21918: PPUSH
21919: CALL_OW 1
21923: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21924: LD_ADDR_VAR 0 1
21928: PUSH
21929: LD_VAR 0 1
21933: PPUSH
21934: LD_VAR 0 3
21938: PPUSH
21939: LD_VAR 0 5
21943: PPUSH
21944: CALL_OW 1
21948: ST_TO_ADDR
// result := list ;
21949: LD_ADDR_VAR 0 4
21953: PUSH
21954: LD_VAR 0 1
21958: ST_TO_ADDR
// end ;
21959: LD_VAR 0 4
21963: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21964: LD_INT 0
21966: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21967: LD_ADDR_VAR 0 5
21971: PUSH
21972: LD_VAR 0 1
21976: PPUSH
21977: CALL_OW 250
21981: PPUSH
21982: LD_VAR 0 1
21986: PPUSH
21987: CALL_OW 251
21991: PPUSH
21992: LD_VAR 0 2
21996: PPUSH
21997: LD_VAR 0 3
22001: PPUSH
22002: LD_VAR 0 4
22006: PPUSH
22007: CALL 22017 0 5
22011: ST_TO_ADDR
// end ;
22012: LD_VAR 0 5
22016: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22017: LD_INT 0
22019: PPUSH
22020: PPUSH
22021: PPUSH
22022: PPUSH
// if not list then
22023: LD_VAR 0 3
22027: NOT
22028: IFFALSE 22032
// exit ;
22030: GO 22420
// result := [ ] ;
22032: LD_ADDR_VAR 0 6
22036: PUSH
22037: EMPTY
22038: ST_TO_ADDR
// for i in list do
22039: LD_ADDR_VAR 0 7
22043: PUSH
22044: LD_VAR 0 3
22048: PUSH
22049: FOR_IN
22050: IFFALSE 22252
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22052: LD_ADDR_VAR 0 9
22056: PUSH
22057: LD_VAR 0 7
22061: PPUSH
22062: LD_VAR 0 1
22066: PPUSH
22067: LD_VAR 0 2
22071: PPUSH
22072: CALL_OW 297
22076: ST_TO_ADDR
// if not result then
22077: LD_VAR 0 6
22081: NOT
22082: IFFALSE 22108
// result := [ [ i , tmp ] ] else
22084: LD_ADDR_VAR 0 6
22088: PUSH
22089: LD_VAR 0 7
22093: PUSH
22094: LD_VAR 0 9
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: PUSH
22103: EMPTY
22104: LIST
22105: ST_TO_ADDR
22106: GO 22250
// begin if result [ result ] [ 2 ] < tmp then
22108: LD_VAR 0 6
22112: PUSH
22113: LD_VAR 0 6
22117: ARRAY
22118: PUSH
22119: LD_INT 2
22121: ARRAY
22122: PUSH
22123: LD_VAR 0 9
22127: LESS
22128: IFFALSE 22170
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22130: LD_ADDR_VAR 0 6
22134: PUSH
22135: LD_VAR 0 6
22139: PPUSH
22140: LD_VAR 0 6
22144: PUSH
22145: LD_INT 1
22147: PLUS
22148: PPUSH
22149: LD_VAR 0 7
22153: PUSH
22154: LD_VAR 0 9
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: PPUSH
22163: CALL_OW 2
22167: ST_TO_ADDR
22168: GO 22250
// for j = 1 to result do
22170: LD_ADDR_VAR 0 8
22174: PUSH
22175: DOUBLE
22176: LD_INT 1
22178: DEC
22179: ST_TO_ADDR
22180: LD_VAR 0 6
22184: PUSH
22185: FOR_TO
22186: IFFALSE 22248
// begin if tmp < result [ j ] [ 2 ] then
22188: LD_VAR 0 9
22192: PUSH
22193: LD_VAR 0 6
22197: PUSH
22198: LD_VAR 0 8
22202: ARRAY
22203: PUSH
22204: LD_INT 2
22206: ARRAY
22207: LESS
22208: IFFALSE 22246
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22210: LD_ADDR_VAR 0 6
22214: PUSH
22215: LD_VAR 0 6
22219: PPUSH
22220: LD_VAR 0 8
22224: PPUSH
22225: LD_VAR 0 7
22229: PUSH
22230: LD_VAR 0 9
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PPUSH
22239: CALL_OW 2
22243: ST_TO_ADDR
// break ;
22244: GO 22248
// end ; end ;
22246: GO 22185
22248: POP
22249: POP
// end ; end ;
22250: GO 22049
22252: POP
22253: POP
// if result and not asc then
22254: LD_VAR 0 6
22258: PUSH
22259: LD_VAR 0 4
22263: NOT
22264: AND
22265: IFFALSE 22340
// begin tmp := result ;
22267: LD_ADDR_VAR 0 9
22271: PUSH
22272: LD_VAR 0 6
22276: ST_TO_ADDR
// for i = tmp downto 1 do
22277: LD_ADDR_VAR 0 7
22281: PUSH
22282: DOUBLE
22283: LD_VAR 0 9
22287: INC
22288: ST_TO_ADDR
22289: LD_INT 1
22291: PUSH
22292: FOR_DOWNTO
22293: IFFALSE 22338
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22295: LD_ADDR_VAR 0 6
22299: PUSH
22300: LD_VAR 0 6
22304: PPUSH
22305: LD_VAR 0 9
22309: PUSH
22310: LD_VAR 0 7
22314: MINUS
22315: PUSH
22316: LD_INT 1
22318: PLUS
22319: PPUSH
22320: LD_VAR 0 9
22324: PUSH
22325: LD_VAR 0 7
22329: ARRAY
22330: PPUSH
22331: CALL_OW 1
22335: ST_TO_ADDR
22336: GO 22292
22338: POP
22339: POP
// end ; tmp := [ ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: EMPTY
22346: ST_TO_ADDR
// if mode then
22347: LD_VAR 0 5
22351: IFFALSE 22420
// begin for i = 1 to result do
22353: LD_ADDR_VAR 0 7
22357: PUSH
22358: DOUBLE
22359: LD_INT 1
22361: DEC
22362: ST_TO_ADDR
22363: LD_VAR 0 6
22367: PUSH
22368: FOR_TO
22369: IFFALSE 22408
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22371: LD_ADDR_VAR 0 9
22375: PUSH
22376: LD_VAR 0 9
22380: PPUSH
22381: LD_VAR 0 7
22385: PPUSH
22386: LD_VAR 0 6
22390: PUSH
22391: LD_VAR 0 7
22395: ARRAY
22396: PUSH
22397: LD_INT 1
22399: ARRAY
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
22406: GO 22368
22408: POP
22409: POP
// result := tmp ;
22410: LD_ADDR_VAR 0 6
22414: PUSH
22415: LD_VAR 0 9
22419: ST_TO_ADDR
// end ; end ;
22420: LD_VAR 0 6
22424: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22425: LD_INT 0
22427: PPUSH
22428: PPUSH
22429: PPUSH
22430: PPUSH
22431: PPUSH
22432: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22433: LD_ADDR_VAR 0 5
22437: PUSH
22438: LD_INT 0
22440: PUSH
22441: LD_INT 0
22443: PUSH
22444: LD_INT 0
22446: PUSH
22447: EMPTY
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: ST_TO_ADDR
// if not x or not y then
22455: LD_VAR 0 2
22459: NOT
22460: PUSH
22461: LD_VAR 0 3
22465: NOT
22466: OR
22467: IFFALSE 22471
// exit ;
22469: GO 24117
// if not range then
22471: LD_VAR 0 4
22475: NOT
22476: IFFALSE 22486
// range := 10 ;
22478: LD_ADDR_VAR 0 4
22482: PUSH
22483: LD_INT 10
22485: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22486: LD_ADDR_VAR 0 8
22490: PUSH
22491: LD_INT 81
22493: PUSH
22494: LD_VAR 0 1
22498: PUSH
22499: EMPTY
22500: LIST
22501: LIST
22502: PUSH
22503: LD_INT 92
22505: PUSH
22506: LD_VAR 0 2
22510: PUSH
22511: LD_VAR 0 3
22515: PUSH
22516: LD_VAR 0 4
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: LIST
22525: LIST
22526: PUSH
22527: LD_INT 3
22529: PUSH
22530: LD_INT 21
22532: PUSH
22533: LD_INT 3
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: EMPTY
22545: LIST
22546: LIST
22547: LIST
22548: PPUSH
22549: CALL_OW 69
22553: ST_TO_ADDR
// if not tmp then
22554: LD_VAR 0 8
22558: NOT
22559: IFFALSE 22563
// exit ;
22561: GO 24117
// for i in tmp do
22563: LD_ADDR_VAR 0 6
22567: PUSH
22568: LD_VAR 0 8
22572: PUSH
22573: FOR_IN
22574: IFFALSE 24092
// begin points := [ 0 , 0 , 0 ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: LD_INT 0
22583: PUSH
22584: LD_INT 0
22586: PUSH
22587: LD_INT 0
22589: PUSH
22590: EMPTY
22591: LIST
22592: LIST
22593: LIST
22594: ST_TO_ADDR
// bpoints := 1 ;
22595: LD_ADDR_VAR 0 10
22599: PUSH
22600: LD_INT 1
22602: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22603: LD_VAR 0 6
22607: PPUSH
22608: CALL_OW 247
22612: PUSH
22613: LD_INT 1
22615: DOUBLE
22616: EQUAL
22617: IFTRUE 22621
22619: GO 23199
22621: POP
// begin if GetClass ( i ) = 1 then
22622: LD_VAR 0 6
22626: PPUSH
22627: CALL_OW 257
22631: PUSH
22632: LD_INT 1
22634: EQUAL
22635: IFFALSE 22656
// points := [ 10 , 5 , 3 ] ;
22637: LD_ADDR_VAR 0 9
22641: PUSH
22642: LD_INT 10
22644: PUSH
22645: LD_INT 5
22647: PUSH
22648: LD_INT 3
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: LIST
22655: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22656: LD_VAR 0 6
22660: PPUSH
22661: CALL_OW 257
22665: PUSH
22666: LD_INT 2
22668: PUSH
22669: LD_INT 3
22671: PUSH
22672: LD_INT 4
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: IN
22680: IFFALSE 22701
// points := [ 3 , 2 , 1 ] ;
22682: LD_ADDR_VAR 0 9
22686: PUSH
22687: LD_INT 3
22689: PUSH
22690: LD_INT 2
22692: PUSH
22693: LD_INT 1
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22701: LD_VAR 0 6
22705: PPUSH
22706: CALL_OW 257
22710: PUSH
22711: LD_INT 5
22713: EQUAL
22714: IFFALSE 22735
// points := [ 130 , 5 , 2 ] ;
22716: LD_ADDR_VAR 0 9
22720: PUSH
22721: LD_INT 130
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: LD_INT 2
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22735: LD_VAR 0 6
22739: PPUSH
22740: CALL_OW 257
22744: PUSH
22745: LD_INT 8
22747: EQUAL
22748: IFFALSE 22769
// points := [ 35 , 35 , 30 ] ;
22750: LD_ADDR_VAR 0 9
22754: PUSH
22755: LD_INT 35
22757: PUSH
22758: LD_INT 35
22760: PUSH
22761: LD_INT 30
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: LIST
22768: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22769: LD_VAR 0 6
22773: PPUSH
22774: CALL_OW 257
22778: PUSH
22779: LD_INT 9
22781: EQUAL
22782: IFFALSE 22803
// points := [ 20 , 55 , 40 ] ;
22784: LD_ADDR_VAR 0 9
22788: PUSH
22789: LD_INT 20
22791: PUSH
22792: LD_INT 55
22794: PUSH
22795: LD_INT 40
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22803: LD_VAR 0 6
22807: PPUSH
22808: CALL_OW 257
22812: PUSH
22813: LD_INT 12
22815: PUSH
22816: LD_INT 16
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: IN
22823: IFFALSE 22844
// points := [ 5 , 3 , 2 ] ;
22825: LD_ADDR_VAR 0 9
22829: PUSH
22830: LD_INT 5
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 2
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: LIST
22843: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22844: LD_VAR 0 6
22848: PPUSH
22849: CALL_OW 257
22853: PUSH
22854: LD_INT 17
22856: EQUAL
22857: IFFALSE 22878
// points := [ 100 , 50 , 75 ] ;
22859: LD_ADDR_VAR 0 9
22863: PUSH
22864: LD_INT 100
22866: PUSH
22867: LD_INT 50
22869: PUSH
22870: LD_INT 75
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: LIST
22877: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22878: LD_VAR 0 6
22882: PPUSH
22883: CALL_OW 257
22887: PUSH
22888: LD_INT 15
22890: EQUAL
22891: IFFALSE 22912
// points := [ 10 , 5 , 3 ] ;
22893: LD_ADDR_VAR 0 9
22897: PUSH
22898: LD_INT 10
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: LD_INT 3
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: LIST
22911: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22912: LD_VAR 0 6
22916: PPUSH
22917: CALL_OW 257
22921: PUSH
22922: LD_INT 14
22924: EQUAL
22925: IFFALSE 22946
// points := [ 10 , 0 , 0 ] ;
22927: LD_ADDR_VAR 0 9
22931: PUSH
22932: LD_INT 10
22934: PUSH
22935: LD_INT 0
22937: PUSH
22938: LD_INT 0
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: LIST
22945: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22946: LD_VAR 0 6
22950: PPUSH
22951: CALL_OW 257
22955: PUSH
22956: LD_INT 11
22958: EQUAL
22959: IFFALSE 22980
// points := [ 30 , 10 , 5 ] ;
22961: LD_ADDR_VAR 0 9
22965: PUSH
22966: LD_INT 30
22968: PUSH
22969: LD_INT 10
22971: PUSH
22972: LD_INT 5
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: LIST
22979: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22980: LD_VAR 0 1
22984: PPUSH
22985: LD_INT 5
22987: PPUSH
22988: CALL_OW 321
22992: PUSH
22993: LD_INT 2
22995: EQUAL
22996: IFFALSE 23013
// bpoints := bpoints * 1.8 ;
22998: LD_ADDR_VAR 0 10
23002: PUSH
23003: LD_VAR 0 10
23007: PUSH
23008: LD_REAL  1.80000000000000E+0000
23011: MUL
23012: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23013: LD_VAR 0 6
23017: PPUSH
23018: CALL_OW 257
23022: PUSH
23023: LD_INT 1
23025: PUSH
23026: LD_INT 2
23028: PUSH
23029: LD_INT 3
23031: PUSH
23032: LD_INT 4
23034: PUSH
23035: EMPTY
23036: LIST
23037: LIST
23038: LIST
23039: LIST
23040: IN
23041: PUSH
23042: LD_VAR 0 1
23046: PPUSH
23047: LD_INT 51
23049: PPUSH
23050: CALL_OW 321
23054: PUSH
23055: LD_INT 2
23057: EQUAL
23058: AND
23059: IFFALSE 23076
// bpoints := bpoints * 1.2 ;
23061: LD_ADDR_VAR 0 10
23065: PUSH
23066: LD_VAR 0 10
23070: PUSH
23071: LD_REAL  1.20000000000000E+0000
23074: MUL
23075: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23076: LD_VAR 0 6
23080: PPUSH
23081: CALL_OW 257
23085: PUSH
23086: LD_INT 5
23088: PUSH
23089: LD_INT 7
23091: PUSH
23092: LD_INT 9
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: IN
23100: PUSH
23101: LD_VAR 0 1
23105: PPUSH
23106: LD_INT 52
23108: PPUSH
23109: CALL_OW 321
23113: PUSH
23114: LD_INT 2
23116: EQUAL
23117: AND
23118: IFFALSE 23135
// bpoints := bpoints * 1.5 ;
23120: LD_ADDR_VAR 0 10
23124: PUSH
23125: LD_VAR 0 10
23129: PUSH
23130: LD_REAL  1.50000000000000E+0000
23133: MUL
23134: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23135: LD_VAR 0 1
23139: PPUSH
23140: LD_INT 66
23142: PPUSH
23143: CALL_OW 321
23147: PUSH
23148: LD_INT 2
23150: EQUAL
23151: IFFALSE 23168
// bpoints := bpoints * 1.1 ;
23153: LD_ADDR_VAR 0 10
23157: PUSH
23158: LD_VAR 0 10
23162: PUSH
23163: LD_REAL  1.10000000000000E+0000
23166: MUL
23167: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23168: LD_ADDR_VAR 0 10
23172: PUSH
23173: LD_VAR 0 10
23177: PUSH
23178: LD_VAR 0 6
23182: PPUSH
23183: LD_INT 1
23185: PPUSH
23186: CALL_OW 259
23190: PUSH
23191: LD_REAL  1.15000000000000E+0000
23194: MUL
23195: MUL
23196: ST_TO_ADDR
// end ; unit_vehicle :
23197: GO 24021
23199: LD_INT 2
23201: DOUBLE
23202: EQUAL
23203: IFTRUE 23207
23205: GO 24009
23207: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23208: LD_VAR 0 6
23212: PPUSH
23213: CALL_OW 264
23217: PUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 42
23223: PUSH
23224: LD_INT 24
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: LIST
23231: IN
23232: IFFALSE 23253
// points := [ 25 , 5 , 3 ] ;
23234: LD_ADDR_VAR 0 9
23238: PUSH
23239: LD_INT 25
23241: PUSH
23242: LD_INT 5
23244: PUSH
23245: LD_INT 3
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: LIST
23252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23253: LD_VAR 0 6
23257: PPUSH
23258: CALL_OW 264
23262: PUSH
23263: LD_INT 4
23265: PUSH
23266: LD_INT 43
23268: PUSH
23269: LD_INT 25
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: IFFALSE 23298
// points := [ 40 , 15 , 5 ] ;
23279: LD_ADDR_VAR 0 9
23283: PUSH
23284: LD_INT 40
23286: PUSH
23287: LD_INT 15
23289: PUSH
23290: LD_INT 5
23292: PUSH
23293: EMPTY
23294: LIST
23295: LIST
23296: LIST
23297: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23298: LD_VAR 0 6
23302: PPUSH
23303: CALL_OW 264
23307: PUSH
23308: LD_INT 3
23310: PUSH
23311: LD_INT 23
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: IN
23318: IFFALSE 23339
// points := [ 7 , 25 , 8 ] ;
23320: LD_ADDR_VAR 0 9
23324: PUSH
23325: LD_INT 7
23327: PUSH
23328: LD_INT 25
23330: PUSH
23331: LD_INT 8
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: LIST
23338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 264
23348: PUSH
23349: LD_INT 5
23351: PUSH
23352: LD_INT 27
23354: PUSH
23355: LD_INT 44
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: LIST
23362: IN
23363: IFFALSE 23384
// points := [ 14 , 50 , 16 ] ;
23365: LD_ADDR_VAR 0 9
23369: PUSH
23370: LD_INT 14
23372: PUSH
23373: LD_INT 50
23375: PUSH
23376: LD_INT 16
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23384: LD_VAR 0 6
23388: PPUSH
23389: CALL_OW 264
23393: PUSH
23394: LD_INT 6
23396: PUSH
23397: LD_INT 46
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: IN
23404: IFFALSE 23425
// points := [ 32 , 120 , 70 ] ;
23406: LD_ADDR_VAR 0 9
23410: PUSH
23411: LD_INT 32
23413: PUSH
23414: LD_INT 120
23416: PUSH
23417: LD_INT 70
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: LIST
23424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23425: LD_VAR 0 6
23429: PPUSH
23430: CALL_OW 264
23434: PUSH
23435: LD_INT 7
23437: PUSH
23438: LD_INT 28
23440: PUSH
23441: LD_INT 45
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: IN
23449: IFFALSE 23470
// points := [ 35 , 20 , 45 ] ;
23451: LD_ADDR_VAR 0 9
23455: PUSH
23456: LD_INT 35
23458: PUSH
23459: LD_INT 20
23461: PUSH
23462: LD_INT 45
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: LIST
23469: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23470: LD_VAR 0 6
23474: PPUSH
23475: CALL_OW 264
23479: PUSH
23480: LD_INT 47
23482: PUSH
23483: EMPTY
23484: LIST
23485: IN
23486: IFFALSE 23507
// points := [ 67 , 45 , 75 ] ;
23488: LD_ADDR_VAR 0 9
23492: PUSH
23493: LD_INT 67
23495: PUSH
23496: LD_INT 45
23498: PUSH
23499: LD_INT 75
23501: PUSH
23502: EMPTY
23503: LIST
23504: LIST
23505: LIST
23506: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23507: LD_VAR 0 6
23511: PPUSH
23512: CALL_OW 264
23516: PUSH
23517: LD_INT 26
23519: PUSH
23520: EMPTY
23521: LIST
23522: IN
23523: IFFALSE 23544
// points := [ 120 , 30 , 80 ] ;
23525: LD_ADDR_VAR 0 9
23529: PUSH
23530: LD_INT 120
23532: PUSH
23533: LD_INT 30
23535: PUSH
23536: LD_INT 80
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: LIST
23543: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23544: LD_VAR 0 6
23548: PPUSH
23549: CALL_OW 264
23553: PUSH
23554: LD_INT 22
23556: PUSH
23557: EMPTY
23558: LIST
23559: IN
23560: IFFALSE 23581
// points := [ 40 , 1 , 1 ] ;
23562: LD_ADDR_VAR 0 9
23566: PUSH
23567: LD_INT 40
23569: PUSH
23570: LD_INT 1
23572: PUSH
23573: LD_INT 1
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: LIST
23580: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23581: LD_VAR 0 6
23585: PPUSH
23586: CALL_OW 264
23590: PUSH
23591: LD_INT 29
23593: PUSH
23594: EMPTY
23595: LIST
23596: IN
23597: IFFALSE 23618
// points := [ 70 , 200 , 400 ] ;
23599: LD_ADDR_VAR 0 9
23603: PUSH
23604: LD_INT 70
23606: PUSH
23607: LD_INT 200
23609: PUSH
23610: LD_INT 400
23612: PUSH
23613: EMPTY
23614: LIST
23615: LIST
23616: LIST
23617: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23618: LD_VAR 0 6
23622: PPUSH
23623: CALL_OW 264
23627: PUSH
23628: LD_INT 14
23630: PUSH
23631: LD_INT 53
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: IN
23638: IFFALSE 23659
// points := [ 40 , 10 , 20 ] ;
23640: LD_ADDR_VAR 0 9
23644: PUSH
23645: LD_INT 40
23647: PUSH
23648: LD_INT 10
23650: PUSH
23651: LD_INT 20
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: LIST
23658: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23659: LD_VAR 0 6
23663: PPUSH
23664: CALL_OW 264
23668: PUSH
23669: LD_INT 9
23671: PUSH
23672: EMPTY
23673: LIST
23674: IN
23675: IFFALSE 23696
// points := [ 5 , 70 , 20 ] ;
23677: LD_ADDR_VAR 0 9
23681: PUSH
23682: LD_INT 5
23684: PUSH
23685: LD_INT 70
23687: PUSH
23688: LD_INT 20
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: LIST
23695: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23696: LD_VAR 0 6
23700: PPUSH
23701: CALL_OW 264
23705: PUSH
23706: LD_INT 10
23708: PUSH
23709: EMPTY
23710: LIST
23711: IN
23712: IFFALSE 23733
// points := [ 35 , 110 , 70 ] ;
23714: LD_ADDR_VAR 0 9
23718: PUSH
23719: LD_INT 35
23721: PUSH
23722: LD_INT 110
23724: PUSH
23725: LD_INT 70
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23733: LD_VAR 0 6
23737: PPUSH
23738: CALL_OW 265
23742: PUSH
23743: LD_INT 25
23745: EQUAL
23746: IFFALSE 23767
// points := [ 80 , 65 , 100 ] ;
23748: LD_ADDR_VAR 0 9
23752: PUSH
23753: LD_INT 80
23755: PUSH
23756: LD_INT 65
23758: PUSH
23759: LD_INT 100
23761: PUSH
23762: EMPTY
23763: LIST
23764: LIST
23765: LIST
23766: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23767: LD_VAR 0 6
23771: PPUSH
23772: CALL_OW 263
23776: PUSH
23777: LD_INT 1
23779: EQUAL
23780: IFFALSE 23815
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23782: LD_ADDR_VAR 0 10
23786: PUSH
23787: LD_VAR 0 10
23791: PUSH
23792: LD_VAR 0 6
23796: PPUSH
23797: CALL_OW 311
23801: PPUSH
23802: LD_INT 3
23804: PPUSH
23805: CALL_OW 259
23809: PUSH
23810: LD_INT 4
23812: MUL
23813: MUL
23814: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23815: LD_VAR 0 6
23819: PPUSH
23820: CALL_OW 263
23824: PUSH
23825: LD_INT 2
23827: EQUAL
23828: IFFALSE 23879
// begin j := IsControledBy ( i ) ;
23830: LD_ADDR_VAR 0 7
23834: PUSH
23835: LD_VAR 0 6
23839: PPUSH
23840: CALL_OW 312
23844: ST_TO_ADDR
// if j then
23845: LD_VAR 0 7
23849: IFFALSE 23879
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23851: LD_ADDR_VAR 0 10
23855: PUSH
23856: LD_VAR 0 10
23860: PUSH
23861: LD_VAR 0 7
23865: PPUSH
23866: LD_INT 3
23868: PPUSH
23869: CALL_OW 259
23873: PUSH
23874: LD_INT 3
23876: MUL
23877: MUL
23878: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23879: LD_VAR 0 6
23883: PPUSH
23884: CALL_OW 264
23888: PUSH
23889: LD_INT 5
23891: PUSH
23892: LD_INT 6
23894: PUSH
23895: LD_INT 46
23897: PUSH
23898: LD_INT 44
23900: PUSH
23901: LD_INT 47
23903: PUSH
23904: LD_INT 45
23906: PUSH
23907: LD_INT 28
23909: PUSH
23910: LD_INT 7
23912: PUSH
23913: LD_INT 27
23915: PUSH
23916: LD_INT 29
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: IN
23931: PUSH
23932: LD_VAR 0 1
23936: PPUSH
23937: LD_INT 52
23939: PPUSH
23940: CALL_OW 321
23944: PUSH
23945: LD_INT 2
23947: EQUAL
23948: AND
23949: IFFALSE 23966
// bpoints := bpoints * 1.2 ;
23951: LD_ADDR_VAR 0 10
23955: PUSH
23956: LD_VAR 0 10
23960: PUSH
23961: LD_REAL  1.20000000000000E+0000
23964: MUL
23965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23966: LD_VAR 0 6
23970: PPUSH
23971: CALL_OW 264
23975: PUSH
23976: LD_INT 6
23978: PUSH
23979: LD_INT 46
23981: PUSH
23982: LD_INT 47
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: LIST
23989: IN
23990: IFFALSE 24007
// bpoints := bpoints * 1.2 ;
23992: LD_ADDR_VAR 0 10
23996: PUSH
23997: LD_VAR 0 10
24001: PUSH
24002: LD_REAL  1.20000000000000E+0000
24005: MUL
24006: ST_TO_ADDR
// end ; unit_building :
24007: GO 24021
24009: LD_INT 3
24011: DOUBLE
24012: EQUAL
24013: IFTRUE 24017
24015: GO 24020
24017: POP
// ; end ;
24018: GO 24021
24020: POP
// for j = 1 to 3 do
24021: LD_ADDR_VAR 0 7
24025: PUSH
24026: DOUBLE
24027: LD_INT 1
24029: DEC
24030: ST_TO_ADDR
24031: LD_INT 3
24033: PUSH
24034: FOR_TO
24035: IFFALSE 24088
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24037: LD_ADDR_VAR 0 5
24041: PUSH
24042: LD_VAR 0 5
24046: PPUSH
24047: LD_VAR 0 7
24051: PPUSH
24052: LD_VAR 0 5
24056: PUSH
24057: LD_VAR 0 7
24061: ARRAY
24062: PUSH
24063: LD_VAR 0 9
24067: PUSH
24068: LD_VAR 0 7
24072: ARRAY
24073: PUSH
24074: LD_VAR 0 10
24078: MUL
24079: PLUS
24080: PPUSH
24081: CALL_OW 1
24085: ST_TO_ADDR
24086: GO 24034
24088: POP
24089: POP
// end ;
24090: GO 22573
24092: POP
24093: POP
// result := Replace ( result , 4 , tmp ) ;
24094: LD_ADDR_VAR 0 5
24098: PUSH
24099: LD_VAR 0 5
24103: PPUSH
24104: LD_INT 4
24106: PPUSH
24107: LD_VAR 0 8
24111: PPUSH
24112: CALL_OW 1
24116: ST_TO_ADDR
// end ;
24117: LD_VAR 0 5
24121: RET
// export function DangerAtRange ( unit , range ) ; begin
24122: LD_INT 0
24124: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24125: LD_ADDR_VAR 0 3
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: CALL_OW 255
24139: PPUSH
24140: LD_VAR 0 1
24144: PPUSH
24145: CALL_OW 250
24149: PPUSH
24150: LD_VAR 0 1
24154: PPUSH
24155: CALL_OW 251
24159: PPUSH
24160: LD_VAR 0 2
24164: PPUSH
24165: CALL 22425 0 4
24169: ST_TO_ADDR
// end ;
24170: LD_VAR 0 3
24174: RET
// export function DangerInArea ( side , area ) ; begin
24175: LD_INT 0
24177: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_VAR 0 2
24187: PPUSH
24188: LD_INT 81
24190: PUSH
24191: LD_VAR 0 1
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PPUSH
24200: CALL_OW 70
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 3
24209: RET
// export function IsExtension ( b ) ; begin
24210: LD_INT 0
24212: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24213: LD_ADDR_VAR 0 2
24217: PUSH
24218: LD_VAR 0 1
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 20
24228: PUSH
24229: LD_INT 22
24231: PUSH
24232: LD_INT 17
24234: PUSH
24235: LD_INT 24
24237: PUSH
24238: LD_INT 21
24240: PUSH
24241: LD_INT 19
24243: PUSH
24244: LD_INT 16
24246: PUSH
24247: LD_INT 25
24249: PUSH
24250: LD_INT 18
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: LIST
24260: LIST
24261: LIST
24262: LIST
24263: LIST
24264: IN
24265: ST_TO_ADDR
// end ;
24266: LD_VAR 0 2
24270: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24271: LD_INT 0
24273: PPUSH
24274: PPUSH
24275: PPUSH
// result := [ ] ;
24276: LD_ADDR_VAR 0 3
24280: PUSH
24281: EMPTY
24282: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24283: LD_ADDR_VAR 0 4
24287: PUSH
24288: LD_VAR 0 2
24292: PPUSH
24293: LD_INT 21
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 70
24307: ST_TO_ADDR
// if not tmp then
24308: LD_VAR 0 4
24312: NOT
24313: IFFALSE 24317
// exit ;
24315: GO 24375
// for i in tmp do
24317: LD_ADDR_VAR 0 5
24321: PUSH
24322: LD_VAR 0 4
24326: PUSH
24327: FOR_IN
24328: IFFALSE 24363
// if GetBase ( i ) <> base then
24330: LD_VAR 0 5
24334: PPUSH
24335: CALL_OW 274
24339: PUSH
24340: LD_VAR 0 1
24344: NONEQUAL
24345: IFFALSE 24361
// ComLinkToBase ( base , i ) ;
24347: LD_VAR 0 1
24351: PPUSH
24352: LD_VAR 0 5
24356: PPUSH
24357: CALL_OW 169
24361: GO 24327
24363: POP
24364: POP
// result := tmp ;
24365: LD_ADDR_VAR 0 3
24369: PUSH
24370: LD_VAR 0 4
24374: ST_TO_ADDR
// end ;
24375: LD_VAR 0 3
24379: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24380: LD_INT 0
24382: PPUSH
24383: PPUSH
// if BuildingStatus ( b ) = bs_build then
24384: LD_VAR 0 2
24388: PPUSH
24389: CALL_OW 461
24393: PUSH
24394: LD_INT 1
24396: EQUAL
24397: IFFALSE 24457
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24399: LD_VAR 0 1
24403: PPUSH
24404: LD_STRING h
24406: PUSH
24407: LD_VAR 0 2
24411: PPUSH
24412: CALL_OW 250
24416: PUSH
24417: LD_VAR 0 2
24421: PPUSH
24422: CALL_OW 251
24426: PUSH
24427: LD_VAR 0 2
24431: PUSH
24432: LD_INT 0
24434: PUSH
24435: LD_INT 0
24437: PUSH
24438: LD_INT 0
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: PPUSH
24453: CALL_OW 446
// end ;
24457: LD_VAR 0 3
24461: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24462: LD_INT 0
24464: PPUSH
24465: PPUSH
24466: PPUSH
24467: PPUSH
24468: PPUSH
24469: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24470: LD_VAR 0 1
24474: NOT
24475: PUSH
24476: LD_VAR 0 1
24480: PPUSH
24481: CALL_OW 263
24485: PUSH
24486: LD_INT 2
24488: EQUAL
24489: NOT
24490: OR
24491: IFFALSE 24495
// exit ;
24493: GO 24811
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24495: LD_ADDR_VAR 0 6
24499: PUSH
24500: LD_INT 22
24502: PUSH
24503: LD_VAR 0 1
24507: PPUSH
24508: CALL_OW 255
24512: PUSH
24513: EMPTY
24514: LIST
24515: LIST
24516: PUSH
24517: LD_INT 2
24519: PUSH
24520: LD_INT 30
24522: PUSH
24523: LD_INT 36
24525: PUSH
24526: EMPTY
24527: LIST
24528: LIST
24529: PUSH
24530: LD_INT 34
24532: PUSH
24533: LD_INT 31
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PPUSH
24549: CALL_OW 69
24553: ST_TO_ADDR
// if not tmp then
24554: LD_VAR 0 6
24558: NOT
24559: IFFALSE 24563
// exit ;
24561: GO 24811
// result := [ ] ;
24563: LD_ADDR_VAR 0 2
24567: PUSH
24568: EMPTY
24569: ST_TO_ADDR
// for i in tmp do
24570: LD_ADDR_VAR 0 3
24574: PUSH
24575: LD_VAR 0 6
24579: PUSH
24580: FOR_IN
24581: IFFALSE 24652
// begin t := UnitsInside ( i ) ;
24583: LD_ADDR_VAR 0 4
24587: PUSH
24588: LD_VAR 0 3
24592: PPUSH
24593: CALL_OW 313
24597: ST_TO_ADDR
// if t then
24598: LD_VAR 0 4
24602: IFFALSE 24650
// for j in t do
24604: LD_ADDR_VAR 0 7
24608: PUSH
24609: LD_VAR 0 4
24613: PUSH
24614: FOR_IN
24615: IFFALSE 24648
// result := Insert ( result , result + 1 , j ) ;
24617: LD_ADDR_VAR 0 2
24621: PUSH
24622: LD_VAR 0 2
24626: PPUSH
24627: LD_VAR 0 2
24631: PUSH
24632: LD_INT 1
24634: PLUS
24635: PPUSH
24636: LD_VAR 0 7
24640: PPUSH
24641: CALL_OW 2
24645: ST_TO_ADDR
24646: GO 24614
24648: POP
24649: POP
// end ;
24650: GO 24580
24652: POP
24653: POP
// if not result then
24654: LD_VAR 0 2
24658: NOT
24659: IFFALSE 24663
// exit ;
24661: GO 24811
// mech := result [ 1 ] ;
24663: LD_ADDR_VAR 0 5
24667: PUSH
24668: LD_VAR 0 2
24672: PUSH
24673: LD_INT 1
24675: ARRAY
24676: ST_TO_ADDR
// if result > 1 then
24677: LD_VAR 0 2
24681: PUSH
24682: LD_INT 1
24684: GREATER
24685: IFFALSE 24797
// for i = 2 to result do
24687: LD_ADDR_VAR 0 3
24691: PUSH
24692: DOUBLE
24693: LD_INT 2
24695: DEC
24696: ST_TO_ADDR
24697: LD_VAR 0 2
24701: PUSH
24702: FOR_TO
24703: IFFALSE 24795
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24705: LD_ADDR_VAR 0 4
24709: PUSH
24710: LD_VAR 0 2
24714: PUSH
24715: LD_VAR 0 3
24719: ARRAY
24720: PPUSH
24721: LD_INT 3
24723: PPUSH
24724: CALL_OW 259
24728: PUSH
24729: LD_VAR 0 2
24733: PUSH
24734: LD_VAR 0 3
24738: ARRAY
24739: PPUSH
24740: CALL_OW 432
24744: MINUS
24745: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24746: LD_VAR 0 4
24750: PUSH
24751: LD_VAR 0 5
24755: PPUSH
24756: LD_INT 3
24758: PPUSH
24759: CALL_OW 259
24763: PUSH
24764: LD_VAR 0 5
24768: PPUSH
24769: CALL_OW 432
24773: MINUS
24774: GREATEREQUAL
24775: IFFALSE 24793
// mech := result [ i ] ;
24777: LD_ADDR_VAR 0 5
24781: PUSH
24782: LD_VAR 0 2
24786: PUSH
24787: LD_VAR 0 3
24791: ARRAY
24792: ST_TO_ADDR
// end ;
24793: GO 24702
24795: POP
24796: POP
// ComLinkTo ( vehicle , mech ) ;
24797: LD_VAR 0 1
24801: PPUSH
24802: LD_VAR 0 5
24806: PPUSH
24807: CALL_OW 135
// end ;
24811: LD_VAR 0 2
24815: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24816: LD_INT 0
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
24829: PPUSH
24830: PPUSH
// result := [ ] ;
24831: LD_ADDR_VAR 0 7
24835: PUSH
24836: EMPTY
24837: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24838: LD_VAR 0 1
24842: PPUSH
24843: CALL_OW 266
24847: PUSH
24848: LD_INT 0
24850: PUSH
24851: LD_INT 1
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: IN
24858: NOT
24859: IFFALSE 24863
// exit ;
24861: GO 26494
// if name then
24863: LD_VAR 0 3
24867: IFFALSE 24883
// SetBName ( base_dep , name ) ;
24869: LD_VAR 0 1
24873: PPUSH
24874: LD_VAR 0 3
24878: PPUSH
24879: CALL_OW 500
// base := GetBase ( base_dep ) ;
24883: LD_ADDR_VAR 0 15
24887: PUSH
24888: LD_VAR 0 1
24892: PPUSH
24893: CALL_OW 274
24897: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24898: LD_ADDR_VAR 0 16
24902: PUSH
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 255
24912: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24913: LD_ADDR_VAR 0 17
24917: PUSH
24918: LD_VAR 0 1
24922: PPUSH
24923: CALL_OW 248
24927: ST_TO_ADDR
// if sources then
24928: LD_VAR 0 5
24932: IFFALSE 24979
// for i = 1 to 3 do
24934: LD_ADDR_VAR 0 8
24938: PUSH
24939: DOUBLE
24940: LD_INT 1
24942: DEC
24943: ST_TO_ADDR
24944: LD_INT 3
24946: PUSH
24947: FOR_TO
24948: IFFALSE 24977
// AddResourceType ( base , i , sources [ i ] ) ;
24950: LD_VAR 0 15
24954: PPUSH
24955: LD_VAR 0 8
24959: PPUSH
24960: LD_VAR 0 5
24964: PUSH
24965: LD_VAR 0 8
24969: ARRAY
24970: PPUSH
24971: CALL_OW 276
24975: GO 24947
24977: POP
24978: POP
// buildings := GetBaseBuildings ( base , area ) ;
24979: LD_ADDR_VAR 0 18
24983: PUSH
24984: LD_VAR 0 15
24988: PPUSH
24989: LD_VAR 0 2
24993: PPUSH
24994: CALL 24271 0 2
24998: ST_TO_ADDR
// InitHc ;
24999: CALL_OW 19
// InitUc ;
25003: CALL_OW 18
// uc_side := side ;
25007: LD_ADDR_OWVAR 20
25011: PUSH
25012: LD_VAR 0 16
25016: ST_TO_ADDR
// uc_nation := nation ;
25017: LD_ADDR_OWVAR 21
25021: PUSH
25022: LD_VAR 0 17
25026: ST_TO_ADDR
// if buildings then
25027: LD_VAR 0 18
25031: IFFALSE 26353
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25033: LD_ADDR_VAR 0 19
25037: PUSH
25038: LD_VAR 0 18
25042: PPUSH
25043: LD_INT 2
25045: PUSH
25046: LD_INT 30
25048: PUSH
25049: LD_INT 29
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 30
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: LIST
25070: PPUSH
25071: CALL_OW 72
25075: ST_TO_ADDR
// if tmp then
25076: LD_VAR 0 19
25080: IFFALSE 25128
// for i in tmp do
25082: LD_ADDR_VAR 0 8
25086: PUSH
25087: LD_VAR 0 19
25091: PUSH
25092: FOR_IN
25093: IFFALSE 25126
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25095: LD_VAR 0 8
25099: PPUSH
25100: CALL_OW 250
25104: PPUSH
25105: LD_VAR 0 8
25109: PPUSH
25110: CALL_OW 251
25114: PPUSH
25115: LD_VAR 0 16
25119: PPUSH
25120: CALL_OW 441
25124: GO 25092
25126: POP
25127: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25128: LD_VAR 0 18
25132: PPUSH
25133: LD_INT 2
25135: PUSH
25136: LD_INT 30
25138: PUSH
25139: LD_INT 32
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 30
25148: PUSH
25149: LD_INT 33
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: LIST
25160: PPUSH
25161: CALL_OW 72
25165: IFFALSE 25253
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_VAR 0 18
25176: PPUSH
25177: LD_INT 2
25179: PUSH
25180: LD_INT 30
25182: PUSH
25183: LD_INT 32
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 33
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: LIST
25204: PPUSH
25205: CALL_OW 72
25209: PUSH
25210: FOR_IN
25211: IFFALSE 25251
// begin if not GetBWeapon ( i ) then
25213: LD_VAR 0 8
25217: PPUSH
25218: CALL_OW 269
25222: NOT
25223: IFFALSE 25249
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25225: LD_VAR 0 8
25229: PPUSH
25230: LD_VAR 0 8
25234: PPUSH
25235: LD_VAR 0 2
25239: PPUSH
25240: CALL 26499 0 2
25244: PPUSH
25245: CALL_OW 431
// end ;
25249: GO 25210
25251: POP
25252: POP
// end ; for i = 1 to personel do
25253: LD_ADDR_VAR 0 8
25257: PUSH
25258: DOUBLE
25259: LD_INT 1
25261: DEC
25262: ST_TO_ADDR
25263: LD_VAR 0 6
25267: PUSH
25268: FOR_TO
25269: IFFALSE 26333
// begin if i > 4 then
25271: LD_VAR 0 8
25275: PUSH
25276: LD_INT 4
25278: GREATER
25279: IFFALSE 25283
// break ;
25281: GO 26333
// case i of 1 :
25283: LD_VAR 0 8
25287: PUSH
25288: LD_INT 1
25290: DOUBLE
25291: EQUAL
25292: IFTRUE 25296
25294: GO 25376
25296: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25297: LD_ADDR_VAR 0 12
25301: PUSH
25302: LD_VAR 0 18
25306: PPUSH
25307: LD_INT 22
25309: PUSH
25310: LD_VAR 0 16
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 58
25321: PUSH
25322: EMPTY
25323: LIST
25324: PUSH
25325: LD_INT 2
25327: PUSH
25328: LD_INT 30
25330: PUSH
25331: LD_INT 32
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PUSH
25338: LD_INT 30
25340: PUSH
25341: LD_INT 4
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 30
25350: PUSH
25351: LD_INT 5
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: LIST
25362: LIST
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: LIST
25368: PPUSH
25369: CALL_OW 72
25373: ST_TO_ADDR
25374: GO 25598
25376: LD_INT 2
25378: DOUBLE
25379: EQUAL
25380: IFTRUE 25384
25382: GO 25446
25384: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25385: LD_ADDR_VAR 0 12
25389: PUSH
25390: LD_VAR 0 18
25394: PPUSH
25395: LD_INT 22
25397: PUSH
25398: LD_VAR 0 16
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 2
25409: PUSH
25410: LD_INT 30
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: LD_INT 30
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: LIST
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PPUSH
25439: CALL_OW 72
25443: ST_TO_ADDR
25444: GO 25598
25446: LD_INT 3
25448: DOUBLE
25449: EQUAL
25450: IFTRUE 25454
25452: GO 25516
25454: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25455: LD_ADDR_VAR 0 12
25459: PUSH
25460: LD_VAR 0 18
25464: PPUSH
25465: LD_INT 22
25467: PUSH
25468: LD_VAR 0 16
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 2
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 30
25492: PUSH
25493: LD_INT 3
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PPUSH
25509: CALL_OW 72
25513: ST_TO_ADDR
25514: GO 25598
25516: LD_INT 4
25518: DOUBLE
25519: EQUAL
25520: IFTRUE 25524
25522: GO 25597
25524: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25525: LD_ADDR_VAR 0 12
25529: PUSH
25530: LD_VAR 0 18
25534: PPUSH
25535: LD_INT 22
25537: PUSH
25538: LD_VAR 0 16
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 2
25549: PUSH
25550: LD_INT 30
25552: PUSH
25553: LD_INT 6
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: LD_INT 30
25562: PUSH
25563: LD_INT 7
25565: PUSH
25566: EMPTY
25567: LIST
25568: LIST
25569: PUSH
25570: LD_INT 30
25572: PUSH
25573: LD_INT 8
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PPUSH
25590: CALL_OW 72
25594: ST_TO_ADDR
25595: GO 25598
25597: POP
// if i = 1 then
25598: LD_VAR 0 8
25602: PUSH
25603: LD_INT 1
25605: EQUAL
25606: IFFALSE 25717
// begin tmp := [ ] ;
25608: LD_ADDR_VAR 0 19
25612: PUSH
25613: EMPTY
25614: ST_TO_ADDR
// for j in f do
25615: LD_ADDR_VAR 0 9
25619: PUSH
25620: LD_VAR 0 12
25624: PUSH
25625: FOR_IN
25626: IFFALSE 25699
// if GetBType ( j ) = b_bunker then
25628: LD_VAR 0 9
25632: PPUSH
25633: CALL_OW 266
25637: PUSH
25638: LD_INT 32
25640: EQUAL
25641: IFFALSE 25668
// tmp := Insert ( tmp , 1 , j ) else
25643: LD_ADDR_VAR 0 19
25647: PUSH
25648: LD_VAR 0 19
25652: PPUSH
25653: LD_INT 1
25655: PPUSH
25656: LD_VAR 0 9
25660: PPUSH
25661: CALL_OW 2
25665: ST_TO_ADDR
25666: GO 25697
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25668: LD_ADDR_VAR 0 19
25672: PUSH
25673: LD_VAR 0 19
25677: PPUSH
25678: LD_VAR 0 19
25682: PUSH
25683: LD_INT 1
25685: PLUS
25686: PPUSH
25687: LD_VAR 0 9
25691: PPUSH
25692: CALL_OW 2
25696: ST_TO_ADDR
25697: GO 25625
25699: POP
25700: POP
// if tmp then
25701: LD_VAR 0 19
25705: IFFALSE 25717
// f := tmp ;
25707: LD_ADDR_VAR 0 12
25711: PUSH
25712: LD_VAR 0 19
25716: ST_TO_ADDR
// end ; x := personel [ i ] ;
25717: LD_ADDR_VAR 0 13
25721: PUSH
25722: LD_VAR 0 6
25726: PUSH
25727: LD_VAR 0 8
25731: ARRAY
25732: ST_TO_ADDR
// if x = - 1 then
25733: LD_VAR 0 13
25737: PUSH
25738: LD_INT 1
25740: NEG
25741: EQUAL
25742: IFFALSE 25951
// begin for j in f do
25744: LD_ADDR_VAR 0 9
25748: PUSH
25749: LD_VAR 0 12
25753: PUSH
25754: FOR_IN
25755: IFFALSE 25947
// repeat InitHc ;
25757: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25761: LD_VAR 0 9
25765: PPUSH
25766: CALL_OW 266
25770: PUSH
25771: LD_INT 5
25773: EQUAL
25774: IFFALSE 25844
// begin if UnitsInside ( j ) < 3 then
25776: LD_VAR 0 9
25780: PPUSH
25781: CALL_OW 313
25785: PUSH
25786: LD_INT 3
25788: LESS
25789: IFFALSE 25825
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25791: LD_INT 0
25793: PPUSH
25794: LD_INT 5
25796: PUSH
25797: LD_INT 8
25799: PUSH
25800: LD_INT 9
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: LIST
25807: PUSH
25808: LD_VAR 0 17
25812: ARRAY
25813: PPUSH
25814: LD_VAR 0 4
25818: PPUSH
25819: CALL_OW 380
25823: GO 25842
// PrepareHuman ( false , i , skill ) ;
25825: LD_INT 0
25827: PPUSH
25828: LD_VAR 0 8
25832: PPUSH
25833: LD_VAR 0 4
25837: PPUSH
25838: CALL_OW 380
// end else
25842: GO 25861
// PrepareHuman ( false , i , skill ) ;
25844: LD_INT 0
25846: PPUSH
25847: LD_VAR 0 8
25851: PPUSH
25852: LD_VAR 0 4
25856: PPUSH
25857: CALL_OW 380
// un := CreateHuman ;
25861: LD_ADDR_VAR 0 14
25865: PUSH
25866: CALL_OW 44
25870: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25871: LD_ADDR_VAR 0 7
25875: PUSH
25876: LD_VAR 0 7
25880: PPUSH
25881: LD_INT 1
25883: PPUSH
25884: LD_VAR 0 14
25888: PPUSH
25889: CALL_OW 2
25893: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25894: LD_VAR 0 14
25898: PPUSH
25899: LD_VAR 0 9
25903: PPUSH
25904: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25908: LD_VAR 0 9
25912: PPUSH
25913: CALL_OW 313
25917: PUSH
25918: LD_INT 6
25920: EQUAL
25921: PUSH
25922: LD_VAR 0 9
25926: PPUSH
25927: CALL_OW 266
25931: PUSH
25932: LD_INT 32
25934: PUSH
25935: LD_INT 31
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: IN
25942: OR
25943: IFFALSE 25757
25945: GO 25754
25947: POP
25948: POP
// end else
25949: GO 26331
// for j = 1 to x do
25951: LD_ADDR_VAR 0 9
25955: PUSH
25956: DOUBLE
25957: LD_INT 1
25959: DEC
25960: ST_TO_ADDR
25961: LD_VAR 0 13
25965: PUSH
25966: FOR_TO
25967: IFFALSE 26329
// begin InitHc ;
25969: CALL_OW 19
// if not f then
25973: LD_VAR 0 12
25977: NOT
25978: IFFALSE 26067
// begin PrepareHuman ( false , i , skill ) ;
25980: LD_INT 0
25982: PPUSH
25983: LD_VAR 0 8
25987: PPUSH
25988: LD_VAR 0 4
25992: PPUSH
25993: CALL_OW 380
// un := CreateHuman ;
25997: LD_ADDR_VAR 0 14
26001: PUSH
26002: CALL_OW 44
26006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26007: LD_ADDR_VAR 0 7
26011: PUSH
26012: LD_VAR 0 7
26016: PPUSH
26017: LD_INT 1
26019: PPUSH
26020: LD_VAR 0 14
26024: PPUSH
26025: CALL_OW 2
26029: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26030: LD_VAR 0 14
26034: PPUSH
26035: LD_VAR 0 1
26039: PPUSH
26040: CALL_OW 250
26044: PPUSH
26045: LD_VAR 0 1
26049: PPUSH
26050: CALL_OW 251
26054: PPUSH
26055: LD_INT 10
26057: PPUSH
26058: LD_INT 0
26060: PPUSH
26061: CALL_OW 50
// continue ;
26065: GO 25966
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26067: LD_VAR 0 12
26071: PUSH
26072: LD_INT 1
26074: ARRAY
26075: PPUSH
26076: CALL_OW 313
26080: PUSH
26081: LD_VAR 0 12
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: PPUSH
26090: CALL_OW 266
26094: PUSH
26095: LD_INT 32
26097: PUSH
26098: LD_INT 31
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: IN
26105: AND
26106: PUSH
26107: LD_VAR 0 12
26111: PUSH
26112: LD_INT 1
26114: ARRAY
26115: PPUSH
26116: CALL_OW 313
26120: PUSH
26121: LD_INT 6
26123: EQUAL
26124: OR
26125: IFFALSE 26145
// f := Delete ( f , 1 ) ;
26127: LD_ADDR_VAR 0 12
26131: PUSH
26132: LD_VAR 0 12
26136: PPUSH
26137: LD_INT 1
26139: PPUSH
26140: CALL_OW 3
26144: ST_TO_ADDR
// if not f then
26145: LD_VAR 0 12
26149: NOT
26150: IFFALSE 26168
// begin x := x + 2 ;
26152: LD_ADDR_VAR 0 13
26156: PUSH
26157: LD_VAR 0 13
26161: PUSH
26162: LD_INT 2
26164: PLUS
26165: ST_TO_ADDR
// continue ;
26166: GO 25966
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26168: LD_VAR 0 12
26172: PUSH
26173: LD_INT 1
26175: ARRAY
26176: PPUSH
26177: CALL_OW 266
26181: PUSH
26182: LD_INT 5
26184: EQUAL
26185: IFFALSE 26259
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26187: LD_VAR 0 12
26191: PUSH
26192: LD_INT 1
26194: ARRAY
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_INT 3
26203: LESS
26204: IFFALSE 26240
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26206: LD_INT 0
26208: PPUSH
26209: LD_INT 5
26211: PUSH
26212: LD_INT 8
26214: PUSH
26215: LD_INT 9
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: LIST
26222: PUSH
26223: LD_VAR 0 17
26227: ARRAY
26228: PPUSH
26229: LD_VAR 0 4
26233: PPUSH
26234: CALL_OW 380
26238: GO 26257
// PrepareHuman ( false , i , skill ) ;
26240: LD_INT 0
26242: PPUSH
26243: LD_VAR 0 8
26247: PPUSH
26248: LD_VAR 0 4
26252: PPUSH
26253: CALL_OW 380
// end else
26257: GO 26276
// PrepareHuman ( false , i , skill ) ;
26259: LD_INT 0
26261: PPUSH
26262: LD_VAR 0 8
26266: PPUSH
26267: LD_VAR 0 4
26271: PPUSH
26272: CALL_OW 380
// un := CreateHuman ;
26276: LD_ADDR_VAR 0 14
26280: PUSH
26281: CALL_OW 44
26285: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26286: LD_ADDR_VAR 0 7
26290: PUSH
26291: LD_VAR 0 7
26295: PPUSH
26296: LD_INT 1
26298: PPUSH
26299: LD_VAR 0 14
26303: PPUSH
26304: CALL_OW 2
26308: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26309: LD_VAR 0 14
26313: PPUSH
26314: LD_VAR 0 12
26318: PUSH
26319: LD_INT 1
26321: ARRAY
26322: PPUSH
26323: CALL_OW 52
// end ;
26327: GO 25966
26329: POP
26330: POP
// end ;
26331: GO 25268
26333: POP
26334: POP
// result := result ^ buildings ;
26335: LD_ADDR_VAR 0 7
26339: PUSH
26340: LD_VAR 0 7
26344: PUSH
26345: LD_VAR 0 18
26349: ADD
26350: ST_TO_ADDR
// end else
26351: GO 26494
// begin for i = 1 to personel do
26353: LD_ADDR_VAR 0 8
26357: PUSH
26358: DOUBLE
26359: LD_INT 1
26361: DEC
26362: ST_TO_ADDR
26363: LD_VAR 0 6
26367: PUSH
26368: FOR_TO
26369: IFFALSE 26492
// begin if i > 4 then
26371: LD_VAR 0 8
26375: PUSH
26376: LD_INT 4
26378: GREATER
26379: IFFALSE 26383
// break ;
26381: GO 26492
// x := personel [ i ] ;
26383: LD_ADDR_VAR 0 13
26387: PUSH
26388: LD_VAR 0 6
26392: PUSH
26393: LD_VAR 0 8
26397: ARRAY
26398: ST_TO_ADDR
// if x = - 1 then
26399: LD_VAR 0 13
26403: PUSH
26404: LD_INT 1
26406: NEG
26407: EQUAL
26408: IFFALSE 26412
// continue ;
26410: GO 26368
// PrepareHuman ( false , i , skill ) ;
26412: LD_INT 0
26414: PPUSH
26415: LD_VAR 0 8
26419: PPUSH
26420: LD_VAR 0 4
26424: PPUSH
26425: CALL_OW 380
// un := CreateHuman ;
26429: LD_ADDR_VAR 0 14
26433: PUSH
26434: CALL_OW 44
26438: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26439: LD_VAR 0 14
26443: PPUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 250
26453: PPUSH
26454: LD_VAR 0 1
26458: PPUSH
26459: CALL_OW 251
26463: PPUSH
26464: LD_INT 10
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 50
// result := result ^ un ;
26474: LD_ADDR_VAR 0 7
26478: PUSH
26479: LD_VAR 0 7
26483: PUSH
26484: LD_VAR 0 14
26488: ADD
26489: ST_TO_ADDR
// end ;
26490: GO 26368
26492: POP
26493: POP
// end ; end ;
26494: LD_VAR 0 7
26498: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26499: LD_INT 0
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
26511: PPUSH
26512: PPUSH
26513: PPUSH
26514: PPUSH
26515: PPUSH
26516: PPUSH
// result := false ;
26517: LD_ADDR_VAR 0 3
26521: PUSH
26522: LD_INT 0
26524: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26525: LD_VAR 0 1
26529: NOT
26530: PUSH
26531: LD_VAR 0 1
26535: PPUSH
26536: CALL_OW 266
26540: PUSH
26541: LD_INT 32
26543: PUSH
26544: LD_INT 33
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: IN
26551: NOT
26552: OR
26553: IFFALSE 26557
// exit ;
26555: GO 27693
// nat := GetNation ( tower ) ;
26557: LD_ADDR_VAR 0 12
26561: PUSH
26562: LD_VAR 0 1
26566: PPUSH
26567: CALL_OW 248
26571: ST_TO_ADDR
// side := GetSide ( tower ) ;
26572: LD_ADDR_VAR 0 16
26576: PUSH
26577: LD_VAR 0 1
26581: PPUSH
26582: CALL_OW 255
26586: ST_TO_ADDR
// x := GetX ( tower ) ;
26587: LD_ADDR_VAR 0 10
26591: PUSH
26592: LD_VAR 0 1
26596: PPUSH
26597: CALL_OW 250
26601: ST_TO_ADDR
// y := GetY ( tower ) ;
26602: LD_ADDR_VAR 0 11
26606: PUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: CALL_OW 251
26616: ST_TO_ADDR
// if not x or not y then
26617: LD_VAR 0 10
26621: NOT
26622: PUSH
26623: LD_VAR 0 11
26627: NOT
26628: OR
26629: IFFALSE 26633
// exit ;
26631: GO 27693
// weapon := 0 ;
26633: LD_ADDR_VAR 0 18
26637: PUSH
26638: LD_INT 0
26640: ST_TO_ADDR
// fac_list := [ ] ;
26641: LD_ADDR_VAR 0 17
26645: PUSH
26646: EMPTY
26647: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26648: LD_ADDR_VAR 0 6
26652: PUSH
26653: LD_VAR 0 1
26657: PPUSH
26658: CALL_OW 274
26662: PPUSH
26663: LD_VAR 0 2
26667: PPUSH
26668: CALL 24271 0 2
26672: PPUSH
26673: LD_INT 30
26675: PUSH
26676: LD_INT 3
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: PPUSH
26683: CALL_OW 72
26687: ST_TO_ADDR
// if not factories then
26688: LD_VAR 0 6
26692: NOT
26693: IFFALSE 26697
// exit ;
26695: GO 27693
// for i in factories do
26697: LD_ADDR_VAR 0 8
26701: PUSH
26702: LD_VAR 0 6
26706: PUSH
26707: FOR_IN
26708: IFFALSE 26733
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26710: LD_ADDR_VAR 0 17
26714: PUSH
26715: LD_VAR 0 17
26719: PUSH
26720: LD_VAR 0 8
26724: PPUSH
26725: CALL_OW 478
26729: UNION
26730: ST_TO_ADDR
26731: GO 26707
26733: POP
26734: POP
// if not fac_list then
26735: LD_VAR 0 17
26739: NOT
26740: IFFALSE 26744
// exit ;
26742: GO 27693
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26744: LD_ADDR_VAR 0 5
26748: PUSH
26749: LD_INT 4
26751: PUSH
26752: LD_INT 5
26754: PUSH
26755: LD_INT 9
26757: PUSH
26758: LD_INT 10
26760: PUSH
26761: LD_INT 6
26763: PUSH
26764: LD_INT 7
26766: PUSH
26767: LD_INT 11
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: PUSH
26779: LD_INT 27
26781: PUSH
26782: LD_INT 28
26784: PUSH
26785: LD_INT 26
26787: PUSH
26788: LD_INT 30
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: PUSH
26797: LD_INT 43
26799: PUSH
26800: LD_INT 44
26802: PUSH
26803: LD_INT 46
26805: PUSH
26806: LD_INT 45
26808: PUSH
26809: LD_INT 47
26811: PUSH
26812: LD_INT 49
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: LIST
26827: PUSH
26828: LD_VAR 0 12
26832: ARRAY
26833: ST_TO_ADDR
// for i in list do
26834: LD_ADDR_VAR 0 8
26838: PUSH
26839: LD_VAR 0 5
26843: PUSH
26844: FOR_IN
26845: IFFALSE 26878
// if not i in fac_list then
26847: LD_VAR 0 8
26851: PUSH
26852: LD_VAR 0 17
26856: IN
26857: NOT
26858: IFFALSE 26876
// list := list diff i ;
26860: LD_ADDR_VAR 0 5
26864: PUSH
26865: LD_VAR 0 5
26869: PUSH
26870: LD_VAR 0 8
26874: DIFF
26875: ST_TO_ADDR
26876: GO 26844
26878: POP
26879: POP
// if not list then
26880: LD_VAR 0 5
26884: NOT
26885: IFFALSE 26889
// exit ;
26887: GO 27693
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26889: LD_VAR 0 12
26893: PUSH
26894: LD_INT 3
26896: EQUAL
26897: PUSH
26898: LD_INT 49
26900: PUSH
26901: LD_VAR 0 5
26905: IN
26906: AND
26907: PUSH
26908: LD_INT 31
26910: PPUSH
26911: LD_VAR 0 16
26915: PPUSH
26916: CALL_OW 321
26920: PUSH
26921: LD_INT 2
26923: EQUAL
26924: AND
26925: IFFALSE 26985
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26927: LD_INT 22
26929: PUSH
26930: LD_VAR 0 16
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 35
26941: PUSH
26942: LD_INT 49
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 91
26951: PUSH
26952: LD_VAR 0 1
26956: PUSH
26957: LD_INT 10
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: LIST
26969: PPUSH
26970: CALL_OW 69
26974: NOT
26975: IFFALSE 26985
// weapon := ru_time_lapser ;
26977: LD_ADDR_VAR 0 18
26981: PUSH
26982: LD_INT 49
26984: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26985: LD_VAR 0 12
26989: PUSH
26990: LD_INT 1
26992: PUSH
26993: LD_INT 2
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: IN
27000: PUSH
27001: LD_INT 11
27003: PUSH
27004: LD_VAR 0 5
27008: IN
27009: PUSH
27010: LD_INT 30
27012: PUSH
27013: LD_VAR 0 5
27017: IN
27018: OR
27019: AND
27020: PUSH
27021: LD_INT 6
27023: PPUSH
27024: LD_VAR 0 16
27028: PPUSH
27029: CALL_OW 321
27033: PUSH
27034: LD_INT 2
27036: EQUAL
27037: AND
27038: IFFALSE 27203
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27040: LD_INT 22
27042: PUSH
27043: LD_VAR 0 16
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 2
27054: PUSH
27055: LD_INT 35
27057: PUSH
27058: LD_INT 11
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 35
27067: PUSH
27068: LD_INT 30
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: LIST
27079: PUSH
27080: LD_INT 91
27082: PUSH
27083: LD_VAR 0 1
27087: PUSH
27088: LD_INT 18
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: LIST
27095: PUSH
27096: EMPTY
27097: LIST
27098: LIST
27099: LIST
27100: PPUSH
27101: CALL_OW 69
27105: NOT
27106: PUSH
27107: LD_INT 22
27109: PUSH
27110: LD_VAR 0 16
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: LD_INT 2
27121: PUSH
27122: LD_INT 30
27124: PUSH
27125: LD_INT 32
27127: PUSH
27128: EMPTY
27129: LIST
27130: LIST
27131: PUSH
27132: LD_INT 30
27134: PUSH
27135: LD_INT 33
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 91
27149: PUSH
27150: LD_VAR 0 1
27154: PUSH
27155: LD_INT 12
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: LIST
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: LIST
27167: PUSH
27168: EMPTY
27169: LIST
27170: PPUSH
27171: CALL_OW 69
27175: PUSH
27176: LD_INT 2
27178: GREATER
27179: AND
27180: IFFALSE 27203
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27182: LD_ADDR_VAR 0 18
27186: PUSH
27187: LD_INT 11
27189: PUSH
27190: LD_INT 30
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_VAR 0 12
27201: ARRAY
27202: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27203: LD_VAR 0 18
27207: NOT
27208: PUSH
27209: LD_INT 40
27211: PPUSH
27212: LD_VAR 0 16
27216: PPUSH
27217: CALL_OW 321
27221: PUSH
27222: LD_INT 2
27224: EQUAL
27225: AND
27226: PUSH
27227: LD_INT 7
27229: PUSH
27230: LD_VAR 0 5
27234: IN
27235: PUSH
27236: LD_INT 28
27238: PUSH
27239: LD_VAR 0 5
27243: IN
27244: OR
27245: PUSH
27246: LD_INT 45
27248: PUSH
27249: LD_VAR 0 5
27253: IN
27254: OR
27255: AND
27256: IFFALSE 27510
// begin hex := GetHexInfo ( x , y ) ;
27258: LD_ADDR_VAR 0 4
27262: PUSH
27263: LD_VAR 0 10
27267: PPUSH
27268: LD_VAR 0 11
27272: PPUSH
27273: CALL_OW 546
27277: ST_TO_ADDR
// if hex [ 1 ] then
27278: LD_VAR 0 4
27282: PUSH
27283: LD_INT 1
27285: ARRAY
27286: IFFALSE 27290
// exit ;
27288: GO 27693
// height := hex [ 2 ] ;
27290: LD_ADDR_VAR 0 15
27294: PUSH
27295: LD_VAR 0 4
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27304: LD_ADDR_VAR 0 14
27308: PUSH
27309: LD_INT 0
27311: PUSH
27312: LD_INT 2
27314: PUSH
27315: LD_INT 3
27317: PUSH
27318: LD_INT 5
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: LIST
27325: LIST
27326: ST_TO_ADDR
// for i in tmp do
27327: LD_ADDR_VAR 0 8
27331: PUSH
27332: LD_VAR 0 14
27336: PUSH
27337: FOR_IN
27338: IFFALSE 27508
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27340: LD_ADDR_VAR 0 9
27344: PUSH
27345: LD_VAR 0 10
27349: PPUSH
27350: LD_VAR 0 8
27354: PPUSH
27355: LD_INT 5
27357: PPUSH
27358: CALL_OW 272
27362: PUSH
27363: LD_VAR 0 11
27367: PPUSH
27368: LD_VAR 0 8
27372: PPUSH
27373: LD_INT 5
27375: PPUSH
27376: CALL_OW 273
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27385: LD_VAR 0 9
27389: PUSH
27390: LD_INT 1
27392: ARRAY
27393: PPUSH
27394: LD_VAR 0 9
27398: PUSH
27399: LD_INT 2
27401: ARRAY
27402: PPUSH
27403: CALL_OW 488
27407: IFFALSE 27506
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27409: LD_ADDR_VAR 0 4
27413: PUSH
27414: LD_VAR 0 9
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: PPUSH
27423: LD_VAR 0 9
27427: PUSH
27428: LD_INT 2
27430: ARRAY
27431: PPUSH
27432: CALL_OW 546
27436: ST_TO_ADDR
// if hex [ 1 ] then
27437: LD_VAR 0 4
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: IFFALSE 27449
// continue ;
27447: GO 27337
// h := hex [ 2 ] ;
27449: LD_ADDR_VAR 0 13
27453: PUSH
27454: LD_VAR 0 4
27458: PUSH
27459: LD_INT 2
27461: ARRAY
27462: ST_TO_ADDR
// if h + 7 < height then
27463: LD_VAR 0 13
27467: PUSH
27468: LD_INT 7
27470: PLUS
27471: PUSH
27472: LD_VAR 0 15
27476: LESS
27477: IFFALSE 27506
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27479: LD_ADDR_VAR 0 18
27483: PUSH
27484: LD_INT 7
27486: PUSH
27487: LD_INT 28
27489: PUSH
27490: LD_INT 45
27492: PUSH
27493: EMPTY
27494: LIST
27495: LIST
27496: LIST
27497: PUSH
27498: LD_VAR 0 12
27502: ARRAY
27503: ST_TO_ADDR
// break ;
27504: GO 27508
// end ; end ; end ;
27506: GO 27337
27508: POP
27509: POP
// end ; if not weapon then
27510: LD_VAR 0 18
27514: NOT
27515: IFFALSE 27575
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27517: LD_ADDR_VAR 0 5
27521: PUSH
27522: LD_VAR 0 5
27526: PUSH
27527: LD_INT 11
27529: PUSH
27530: LD_INT 30
27532: PUSH
27533: LD_INT 49
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: LIST
27540: DIFF
27541: ST_TO_ADDR
// if not list then
27542: LD_VAR 0 5
27546: NOT
27547: IFFALSE 27551
// exit ;
27549: GO 27693
// weapon := list [ rand ( 1 , list ) ] ;
27551: LD_ADDR_VAR 0 18
27555: PUSH
27556: LD_VAR 0 5
27560: PUSH
27561: LD_INT 1
27563: PPUSH
27564: LD_VAR 0 5
27568: PPUSH
27569: CALL_OW 12
27573: ARRAY
27574: ST_TO_ADDR
// end ; if weapon then
27575: LD_VAR 0 18
27579: IFFALSE 27693
// begin tmp := CostOfWeapon ( weapon ) ;
27581: LD_ADDR_VAR 0 14
27585: PUSH
27586: LD_VAR 0 18
27590: PPUSH
27591: CALL_OW 451
27595: ST_TO_ADDR
// j := GetBase ( tower ) ;
27596: LD_ADDR_VAR 0 9
27600: PUSH
27601: LD_VAR 0 1
27605: PPUSH
27606: CALL_OW 274
27610: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27611: LD_VAR 0 9
27615: PPUSH
27616: LD_INT 1
27618: PPUSH
27619: CALL_OW 275
27623: PUSH
27624: LD_VAR 0 14
27628: PUSH
27629: LD_INT 1
27631: ARRAY
27632: GREATEREQUAL
27633: PUSH
27634: LD_VAR 0 9
27638: PPUSH
27639: LD_INT 2
27641: PPUSH
27642: CALL_OW 275
27646: PUSH
27647: LD_VAR 0 14
27651: PUSH
27652: LD_INT 2
27654: ARRAY
27655: GREATEREQUAL
27656: AND
27657: PUSH
27658: LD_VAR 0 9
27662: PPUSH
27663: LD_INT 3
27665: PPUSH
27666: CALL_OW 275
27670: PUSH
27671: LD_VAR 0 14
27675: PUSH
27676: LD_INT 3
27678: ARRAY
27679: GREATEREQUAL
27680: AND
27681: IFFALSE 27693
// result := weapon ;
27683: LD_ADDR_VAR 0 3
27687: PUSH
27688: LD_VAR 0 18
27692: ST_TO_ADDR
// end ; end ;
27693: LD_VAR 0 3
27697: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27698: LD_INT 0
27700: PPUSH
27701: PPUSH
// result := true ;
27702: LD_ADDR_VAR 0 3
27706: PUSH
27707: LD_INT 1
27709: ST_TO_ADDR
// if array1 = array2 then
27710: LD_VAR 0 1
27714: PUSH
27715: LD_VAR 0 2
27719: EQUAL
27720: IFFALSE 27780
// begin for i = 1 to array1 do
27722: LD_ADDR_VAR 0 4
27726: PUSH
27727: DOUBLE
27728: LD_INT 1
27730: DEC
27731: ST_TO_ADDR
27732: LD_VAR 0 1
27736: PUSH
27737: FOR_TO
27738: IFFALSE 27776
// if array1 [ i ] <> array2 [ i ] then
27740: LD_VAR 0 1
27744: PUSH
27745: LD_VAR 0 4
27749: ARRAY
27750: PUSH
27751: LD_VAR 0 2
27755: PUSH
27756: LD_VAR 0 4
27760: ARRAY
27761: NONEQUAL
27762: IFFALSE 27774
// begin result := false ;
27764: LD_ADDR_VAR 0 3
27768: PUSH
27769: LD_INT 0
27771: ST_TO_ADDR
// break ;
27772: GO 27776
// end ;
27774: GO 27737
27776: POP
27777: POP
// end else
27778: GO 27788
// result := false ;
27780: LD_ADDR_VAR 0 3
27784: PUSH
27785: LD_INT 0
27787: ST_TO_ADDR
// end ;
27788: LD_VAR 0 3
27792: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27793: LD_INT 0
27795: PPUSH
27796: PPUSH
27797: PPUSH
// pom := GetBase ( fac ) ;
27798: LD_ADDR_VAR 0 5
27802: PUSH
27803: LD_VAR 0 1
27807: PPUSH
27808: CALL_OW 274
27812: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27813: LD_ADDR_VAR 0 4
27817: PUSH
27818: LD_VAR 0 2
27822: PUSH
27823: LD_INT 1
27825: ARRAY
27826: PPUSH
27827: LD_VAR 0 2
27831: PUSH
27832: LD_INT 2
27834: ARRAY
27835: PPUSH
27836: LD_VAR 0 2
27840: PUSH
27841: LD_INT 3
27843: ARRAY
27844: PPUSH
27845: LD_VAR 0 2
27849: PUSH
27850: LD_INT 4
27852: ARRAY
27853: PPUSH
27854: CALL_OW 449
27858: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27859: LD_ADDR_VAR 0 3
27863: PUSH
27864: LD_VAR 0 5
27868: PPUSH
27869: LD_INT 1
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 4
27881: PUSH
27882: LD_INT 1
27884: ARRAY
27885: GREATEREQUAL
27886: PUSH
27887: LD_VAR 0 5
27891: PPUSH
27892: LD_INT 2
27894: PPUSH
27895: CALL_OW 275
27899: PUSH
27900: LD_VAR 0 4
27904: PUSH
27905: LD_INT 2
27907: ARRAY
27908: GREATEREQUAL
27909: AND
27910: PUSH
27911: LD_VAR 0 5
27915: PPUSH
27916: LD_INT 3
27918: PPUSH
27919: CALL_OW 275
27923: PUSH
27924: LD_VAR 0 4
27928: PUSH
27929: LD_INT 3
27931: ARRAY
27932: GREATEREQUAL
27933: AND
27934: ST_TO_ADDR
// end ;
27935: LD_VAR 0 3
27939: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27940: LD_INT 0
27942: PPUSH
27943: PPUSH
27944: PPUSH
27945: PPUSH
// pom := GetBase ( building ) ;
27946: LD_ADDR_VAR 0 3
27950: PUSH
27951: LD_VAR 0 1
27955: PPUSH
27956: CALL_OW 274
27960: ST_TO_ADDR
// if not pom then
27961: LD_VAR 0 3
27965: NOT
27966: IFFALSE 27970
// exit ;
27968: GO 28140
// btype := GetBType ( building ) ;
27970: LD_ADDR_VAR 0 5
27974: PUSH
27975: LD_VAR 0 1
27979: PPUSH
27980: CALL_OW 266
27984: ST_TO_ADDR
// if btype = b_armoury then
27985: LD_VAR 0 5
27989: PUSH
27990: LD_INT 4
27992: EQUAL
27993: IFFALSE 28003
// btype := b_barracks ;
27995: LD_ADDR_VAR 0 5
27999: PUSH
28000: LD_INT 5
28002: ST_TO_ADDR
// if btype = b_depot then
28003: LD_VAR 0 5
28007: PUSH
28008: LD_INT 0
28010: EQUAL
28011: IFFALSE 28021
// btype := b_warehouse ;
28013: LD_ADDR_VAR 0 5
28017: PUSH
28018: LD_INT 1
28020: ST_TO_ADDR
// if btype = b_workshop then
28021: LD_VAR 0 5
28025: PUSH
28026: LD_INT 2
28028: EQUAL
28029: IFFALSE 28039
// btype := b_factory ;
28031: LD_ADDR_VAR 0 5
28035: PUSH
28036: LD_INT 3
28038: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28039: LD_ADDR_VAR 0 4
28043: PUSH
28044: LD_VAR 0 5
28048: PPUSH
28049: LD_VAR 0 1
28053: PPUSH
28054: CALL_OW 248
28058: PPUSH
28059: CALL_OW 450
28063: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28064: LD_ADDR_VAR 0 2
28068: PUSH
28069: LD_VAR 0 3
28073: PPUSH
28074: LD_INT 1
28076: PPUSH
28077: CALL_OW 275
28081: PUSH
28082: LD_VAR 0 4
28086: PUSH
28087: LD_INT 1
28089: ARRAY
28090: GREATEREQUAL
28091: PUSH
28092: LD_VAR 0 3
28096: PPUSH
28097: LD_INT 2
28099: PPUSH
28100: CALL_OW 275
28104: PUSH
28105: LD_VAR 0 4
28109: PUSH
28110: LD_INT 2
28112: ARRAY
28113: GREATEREQUAL
28114: AND
28115: PUSH
28116: LD_VAR 0 3
28120: PPUSH
28121: LD_INT 3
28123: PPUSH
28124: CALL_OW 275
28128: PUSH
28129: LD_VAR 0 4
28133: PUSH
28134: LD_INT 3
28136: ARRAY
28137: GREATEREQUAL
28138: AND
28139: ST_TO_ADDR
// end ;
28140: LD_VAR 0 2
28144: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28145: LD_INT 0
28147: PPUSH
28148: PPUSH
28149: PPUSH
// pom := GetBase ( building ) ;
28150: LD_ADDR_VAR 0 4
28154: PUSH
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: ST_TO_ADDR
// if not pom then
28165: LD_VAR 0 4
28169: NOT
28170: IFFALSE 28174
// exit ;
28172: GO 28275
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28174: LD_ADDR_VAR 0 5
28178: PUSH
28179: LD_VAR 0 2
28183: PPUSH
28184: LD_VAR 0 1
28188: PPUSH
28189: CALL_OW 248
28193: PPUSH
28194: CALL_OW 450
28198: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28199: LD_ADDR_VAR 0 3
28203: PUSH
28204: LD_VAR 0 4
28208: PPUSH
28209: LD_INT 1
28211: PPUSH
28212: CALL_OW 275
28216: PUSH
28217: LD_VAR 0 5
28221: PUSH
28222: LD_INT 1
28224: ARRAY
28225: GREATEREQUAL
28226: PUSH
28227: LD_VAR 0 4
28231: PPUSH
28232: LD_INT 2
28234: PPUSH
28235: CALL_OW 275
28239: PUSH
28240: LD_VAR 0 5
28244: PUSH
28245: LD_INT 2
28247: ARRAY
28248: GREATEREQUAL
28249: AND
28250: PUSH
28251: LD_VAR 0 4
28255: PPUSH
28256: LD_INT 3
28258: PPUSH
28259: CALL_OW 275
28263: PUSH
28264: LD_VAR 0 5
28268: PUSH
28269: LD_INT 3
28271: ARRAY
28272: GREATEREQUAL
28273: AND
28274: ST_TO_ADDR
// end ;
28275: LD_VAR 0 3
28279: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28280: LD_INT 0
28282: PPUSH
28283: PPUSH
28284: PPUSH
28285: PPUSH
28286: PPUSH
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
28291: PPUSH
// result := false ;
28292: LD_ADDR_VAR 0 6
28296: PUSH
28297: LD_INT 0
28299: ST_TO_ADDR
// if not base or not btype or not x or not y then
28300: LD_VAR 0 1
28304: NOT
28305: PUSH
28306: LD_VAR 0 2
28310: NOT
28311: OR
28312: PUSH
28313: LD_VAR 0 3
28317: NOT
28318: OR
28319: PUSH
28320: LD_VAR 0 4
28324: NOT
28325: OR
28326: IFFALSE 28330
// exit ;
28328: GO 28939
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28330: LD_ADDR_VAR 0 12
28334: PUSH
28335: LD_VAR 0 2
28339: PPUSH
28340: LD_VAR 0 3
28344: PPUSH
28345: LD_VAR 0 4
28349: PPUSH
28350: LD_VAR 0 5
28354: PPUSH
28355: LD_VAR 0 1
28359: PUSH
28360: LD_INT 1
28362: ARRAY
28363: PPUSH
28364: CALL_OW 248
28368: PPUSH
28369: LD_INT 0
28371: PPUSH
28372: CALL 29776 0 6
28376: ST_TO_ADDR
// if not hexes then
28377: LD_VAR 0 12
28381: NOT
28382: IFFALSE 28386
// exit ;
28384: GO 28939
// for i = 1 to hexes do
28386: LD_ADDR_VAR 0 7
28390: PUSH
28391: DOUBLE
28392: LD_INT 1
28394: DEC
28395: ST_TO_ADDR
28396: LD_VAR 0 12
28400: PUSH
28401: FOR_TO
28402: IFFALSE 28937
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28404: LD_ADDR_VAR 0 11
28408: PUSH
28409: LD_VAR 0 12
28413: PUSH
28414: LD_VAR 0 7
28418: ARRAY
28419: PUSH
28420: LD_INT 1
28422: ARRAY
28423: PPUSH
28424: LD_VAR 0 12
28428: PUSH
28429: LD_VAR 0 7
28433: ARRAY
28434: PUSH
28435: LD_INT 2
28437: ARRAY
28438: PPUSH
28439: CALL_OW 428
28443: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28444: LD_VAR 0 12
28448: PUSH
28449: LD_VAR 0 7
28453: ARRAY
28454: PUSH
28455: LD_INT 1
28457: ARRAY
28458: PPUSH
28459: LD_VAR 0 12
28463: PUSH
28464: LD_VAR 0 7
28468: ARRAY
28469: PUSH
28470: LD_INT 2
28472: ARRAY
28473: PPUSH
28474: CALL_OW 351
28478: PUSH
28479: LD_VAR 0 12
28483: PUSH
28484: LD_VAR 0 7
28488: ARRAY
28489: PUSH
28490: LD_INT 1
28492: ARRAY
28493: PPUSH
28494: LD_VAR 0 12
28498: PUSH
28499: LD_VAR 0 7
28503: ARRAY
28504: PUSH
28505: LD_INT 2
28507: ARRAY
28508: PPUSH
28509: CALL_OW 488
28513: NOT
28514: OR
28515: PUSH
28516: LD_VAR 0 11
28520: PPUSH
28521: CALL_OW 247
28525: PUSH
28526: LD_INT 3
28528: EQUAL
28529: OR
28530: IFFALSE 28536
// exit ;
28532: POP
28533: POP
28534: GO 28939
// if not tmp or not tmp in base then
28536: LD_VAR 0 11
28540: NOT
28541: PUSH
28542: LD_VAR 0 11
28546: PUSH
28547: LD_VAR 0 1
28551: IN
28552: NOT
28553: OR
28554: IFFALSE 28558
// continue ;
28556: GO 28401
// result := true ;
28558: LD_ADDR_VAR 0 6
28562: PUSH
28563: LD_INT 1
28565: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28566: LD_ADDR_VAR 0 15
28570: PUSH
28571: LD_VAR 0 1
28575: PPUSH
28576: LD_INT 22
28578: PUSH
28579: LD_VAR 0 11
28583: PPUSH
28584: CALL_OW 255
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: LD_INT 2
28595: PUSH
28596: LD_INT 30
28598: PUSH
28599: LD_INT 0
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 30
28608: PUSH
28609: LD_INT 1
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: LIST
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PPUSH
28625: CALL_OW 72
28629: ST_TO_ADDR
// if dep then
28630: LD_VAR 0 15
28634: IFFALSE 28770
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28636: LD_ADDR_VAR 0 14
28640: PUSH
28641: LD_VAR 0 15
28645: PUSH
28646: LD_INT 1
28648: ARRAY
28649: PPUSH
28650: CALL_OW 250
28654: PPUSH
28655: LD_VAR 0 15
28659: PUSH
28660: LD_INT 1
28662: ARRAY
28663: PPUSH
28664: CALL_OW 254
28668: PPUSH
28669: LD_INT 5
28671: PPUSH
28672: CALL_OW 272
28676: PUSH
28677: LD_VAR 0 15
28681: PUSH
28682: LD_INT 1
28684: ARRAY
28685: PPUSH
28686: CALL_OW 251
28690: PPUSH
28691: LD_VAR 0 15
28695: PUSH
28696: LD_INT 1
28698: ARRAY
28699: PPUSH
28700: CALL_OW 254
28704: PPUSH
28705: LD_INT 5
28707: PPUSH
28708: CALL_OW 273
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28717: LD_VAR 0 14
28721: PUSH
28722: LD_INT 1
28724: ARRAY
28725: PPUSH
28726: LD_VAR 0 14
28730: PUSH
28731: LD_INT 2
28733: ARRAY
28734: PPUSH
28735: CALL_OW 488
28739: IFFALSE 28770
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28741: LD_VAR 0 11
28745: PPUSH
28746: LD_VAR 0 14
28750: PUSH
28751: LD_INT 1
28753: ARRAY
28754: PPUSH
28755: LD_VAR 0 14
28759: PUSH
28760: LD_INT 2
28762: ARRAY
28763: PPUSH
28764: CALL_OW 111
// continue ;
28768: GO 28401
// end ; end ; r := GetDir ( tmp ) ;
28770: LD_ADDR_VAR 0 13
28774: PUSH
28775: LD_VAR 0 11
28779: PPUSH
28780: CALL_OW 254
28784: ST_TO_ADDR
// if r = 5 then
28785: LD_VAR 0 13
28789: PUSH
28790: LD_INT 5
28792: EQUAL
28793: IFFALSE 28803
// r := 0 ;
28795: LD_ADDR_VAR 0 13
28799: PUSH
28800: LD_INT 0
28802: ST_TO_ADDR
// for j = r to 5 do
28803: LD_ADDR_VAR 0 8
28807: PUSH
28808: DOUBLE
28809: LD_VAR 0 13
28813: DEC
28814: ST_TO_ADDR
28815: LD_INT 5
28817: PUSH
28818: FOR_TO
28819: IFFALSE 28933
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28821: LD_ADDR_VAR 0 9
28825: PUSH
28826: LD_VAR 0 11
28830: PPUSH
28831: CALL_OW 250
28835: PPUSH
28836: LD_VAR 0 8
28840: PPUSH
28841: LD_INT 2
28843: PPUSH
28844: CALL_OW 272
28848: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28849: LD_ADDR_VAR 0 10
28853: PUSH
28854: LD_VAR 0 11
28858: PPUSH
28859: CALL_OW 251
28863: PPUSH
28864: LD_VAR 0 8
28868: PPUSH
28869: LD_INT 2
28871: PPUSH
28872: CALL_OW 273
28876: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28877: LD_VAR 0 9
28881: PPUSH
28882: LD_VAR 0 10
28886: PPUSH
28887: CALL_OW 488
28891: PUSH
28892: LD_VAR 0 9
28896: PPUSH
28897: LD_VAR 0 10
28901: PPUSH
28902: CALL_OW 428
28906: NOT
28907: AND
28908: IFFALSE 28931
// begin ComMoveXY ( tmp , _x , _y ) ;
28910: LD_VAR 0 11
28914: PPUSH
28915: LD_VAR 0 9
28919: PPUSH
28920: LD_VAR 0 10
28924: PPUSH
28925: CALL_OW 111
// break ;
28929: GO 28933
// end ; end ;
28931: GO 28818
28933: POP
28934: POP
// end ;
28935: GO 28401
28937: POP
28938: POP
// end ;
28939: LD_VAR 0 6
28943: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28944: LD_INT 0
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
// result := false ;
28956: LD_ADDR_VAR 0 6
28960: PUSH
28961: LD_INT 0
28963: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28964: LD_VAR 0 1
28968: NOT
28969: PUSH
28970: LD_VAR 0 1
28974: PPUSH
28975: CALL_OW 266
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: IN
28990: NOT
28991: OR
28992: PUSH
28993: LD_VAR 0 2
28997: NOT
28998: OR
28999: PUSH
29000: LD_VAR 0 5
29004: PUSH
29005: LD_INT 0
29007: PUSH
29008: LD_INT 1
29010: PUSH
29011: LD_INT 2
29013: PUSH
29014: LD_INT 3
29016: PUSH
29017: LD_INT 4
29019: PUSH
29020: LD_INT 5
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: IN
29031: NOT
29032: OR
29033: PUSH
29034: LD_VAR 0 3
29038: PPUSH
29039: LD_VAR 0 4
29043: PPUSH
29044: CALL_OW 488
29048: NOT
29049: OR
29050: IFFALSE 29054
// exit ;
29052: GO 29771
// pom := GetBase ( depot ) ;
29054: LD_ADDR_VAR 0 10
29058: PUSH
29059: LD_VAR 0 1
29063: PPUSH
29064: CALL_OW 274
29068: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29069: LD_ADDR_VAR 0 11
29073: PUSH
29074: LD_VAR 0 2
29078: PPUSH
29079: LD_VAR 0 1
29083: PPUSH
29084: CALL_OW 248
29088: PPUSH
29089: CALL_OW 450
29093: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29094: LD_VAR 0 10
29098: PPUSH
29099: LD_INT 1
29101: PPUSH
29102: CALL_OW 275
29106: PUSH
29107: LD_VAR 0 11
29111: PUSH
29112: LD_INT 1
29114: ARRAY
29115: GREATEREQUAL
29116: PUSH
29117: LD_VAR 0 10
29121: PPUSH
29122: LD_INT 2
29124: PPUSH
29125: CALL_OW 275
29129: PUSH
29130: LD_VAR 0 11
29134: PUSH
29135: LD_INT 2
29137: ARRAY
29138: GREATEREQUAL
29139: AND
29140: PUSH
29141: LD_VAR 0 10
29145: PPUSH
29146: LD_INT 3
29148: PPUSH
29149: CALL_OW 275
29153: PUSH
29154: LD_VAR 0 11
29158: PUSH
29159: LD_INT 3
29161: ARRAY
29162: GREATEREQUAL
29163: AND
29164: NOT
29165: IFFALSE 29169
// exit ;
29167: GO 29771
// if GetBType ( depot ) = b_depot then
29169: LD_VAR 0 1
29173: PPUSH
29174: CALL_OW 266
29178: PUSH
29179: LD_INT 0
29181: EQUAL
29182: IFFALSE 29194
// dist := 28 else
29184: LD_ADDR_VAR 0 14
29188: PUSH
29189: LD_INT 28
29191: ST_TO_ADDR
29192: GO 29202
// dist := 36 ;
29194: LD_ADDR_VAR 0 14
29198: PUSH
29199: LD_INT 36
29201: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29202: LD_VAR 0 1
29206: PPUSH
29207: LD_VAR 0 3
29211: PPUSH
29212: LD_VAR 0 4
29216: PPUSH
29217: CALL_OW 297
29221: PUSH
29222: LD_VAR 0 14
29226: GREATER
29227: IFFALSE 29231
// exit ;
29229: GO 29771
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29231: LD_ADDR_VAR 0 12
29235: PUSH
29236: LD_VAR 0 2
29240: PPUSH
29241: LD_VAR 0 3
29245: PPUSH
29246: LD_VAR 0 4
29250: PPUSH
29251: LD_VAR 0 5
29255: PPUSH
29256: LD_VAR 0 1
29260: PPUSH
29261: CALL_OW 248
29265: PPUSH
29266: LD_INT 0
29268: PPUSH
29269: CALL 29776 0 6
29273: ST_TO_ADDR
// if not hexes then
29274: LD_VAR 0 12
29278: NOT
29279: IFFALSE 29283
// exit ;
29281: GO 29771
// hex := GetHexInfo ( x , y ) ;
29283: LD_ADDR_VAR 0 15
29287: PUSH
29288: LD_VAR 0 3
29292: PPUSH
29293: LD_VAR 0 4
29297: PPUSH
29298: CALL_OW 546
29302: ST_TO_ADDR
// if hex [ 1 ] then
29303: LD_VAR 0 15
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: IFFALSE 29315
// exit ;
29313: GO 29771
// height := hex [ 2 ] ;
29315: LD_ADDR_VAR 0 13
29319: PUSH
29320: LD_VAR 0 15
29324: PUSH
29325: LD_INT 2
29327: ARRAY
29328: ST_TO_ADDR
// for i = 1 to hexes do
29329: LD_ADDR_VAR 0 7
29333: PUSH
29334: DOUBLE
29335: LD_INT 1
29337: DEC
29338: ST_TO_ADDR
29339: LD_VAR 0 12
29343: PUSH
29344: FOR_TO
29345: IFFALSE 29675
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29347: LD_VAR 0 12
29351: PUSH
29352: LD_VAR 0 7
29356: ARRAY
29357: PUSH
29358: LD_INT 1
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 12
29366: PUSH
29367: LD_VAR 0 7
29371: ARRAY
29372: PUSH
29373: LD_INT 2
29375: ARRAY
29376: PPUSH
29377: CALL_OW 488
29381: NOT
29382: PUSH
29383: LD_VAR 0 12
29387: PUSH
29388: LD_VAR 0 7
29392: ARRAY
29393: PUSH
29394: LD_INT 1
29396: ARRAY
29397: PPUSH
29398: LD_VAR 0 12
29402: PUSH
29403: LD_VAR 0 7
29407: ARRAY
29408: PUSH
29409: LD_INT 2
29411: ARRAY
29412: PPUSH
29413: CALL_OW 428
29417: PUSH
29418: LD_INT 0
29420: GREATER
29421: OR
29422: PUSH
29423: LD_VAR 0 12
29427: PUSH
29428: LD_VAR 0 7
29432: ARRAY
29433: PUSH
29434: LD_INT 1
29436: ARRAY
29437: PPUSH
29438: LD_VAR 0 12
29442: PUSH
29443: LD_VAR 0 7
29447: ARRAY
29448: PUSH
29449: LD_INT 2
29451: ARRAY
29452: PPUSH
29453: CALL_OW 351
29457: OR
29458: IFFALSE 29464
// exit ;
29460: POP
29461: POP
29462: GO 29771
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29464: LD_ADDR_VAR 0 8
29468: PUSH
29469: LD_VAR 0 12
29473: PUSH
29474: LD_VAR 0 7
29478: ARRAY
29479: PUSH
29480: LD_INT 1
29482: ARRAY
29483: PPUSH
29484: LD_VAR 0 12
29488: PUSH
29489: LD_VAR 0 7
29493: ARRAY
29494: PUSH
29495: LD_INT 2
29497: ARRAY
29498: PPUSH
29499: CALL_OW 546
29503: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29504: LD_VAR 0 8
29508: PUSH
29509: LD_INT 1
29511: ARRAY
29512: PUSH
29513: LD_VAR 0 8
29517: PUSH
29518: LD_INT 2
29520: ARRAY
29521: PUSH
29522: LD_VAR 0 13
29526: PUSH
29527: LD_INT 2
29529: PLUS
29530: GREATER
29531: OR
29532: PUSH
29533: LD_VAR 0 8
29537: PUSH
29538: LD_INT 2
29540: ARRAY
29541: PUSH
29542: LD_VAR 0 13
29546: PUSH
29547: LD_INT 2
29549: MINUS
29550: LESS
29551: OR
29552: PUSH
29553: LD_VAR 0 8
29557: PUSH
29558: LD_INT 3
29560: ARRAY
29561: PUSH
29562: LD_INT 0
29564: PUSH
29565: LD_INT 8
29567: PUSH
29568: LD_INT 9
29570: PUSH
29571: LD_INT 10
29573: PUSH
29574: LD_INT 11
29576: PUSH
29577: LD_INT 12
29579: PUSH
29580: LD_INT 13
29582: PUSH
29583: LD_INT 16
29585: PUSH
29586: LD_INT 17
29588: PUSH
29589: LD_INT 18
29591: PUSH
29592: LD_INT 19
29594: PUSH
29595: LD_INT 20
29597: PUSH
29598: LD_INT 21
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: IN
29616: NOT
29617: OR
29618: PUSH
29619: LD_VAR 0 8
29623: PUSH
29624: LD_INT 5
29626: ARRAY
29627: NOT
29628: OR
29629: PUSH
29630: LD_VAR 0 8
29634: PUSH
29635: LD_INT 6
29637: ARRAY
29638: PUSH
29639: LD_INT 1
29641: PUSH
29642: LD_INT 2
29644: PUSH
29645: LD_INT 7
29647: PUSH
29648: LD_INT 9
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: LD_INT 11
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: IN
29665: NOT
29666: OR
29667: IFFALSE 29673
// exit ;
29669: POP
29670: POP
29671: GO 29771
// end ;
29673: GO 29344
29675: POP
29676: POP
// side := GetSide ( depot ) ;
29677: LD_ADDR_VAR 0 9
29681: PUSH
29682: LD_VAR 0 1
29686: PPUSH
29687: CALL_OW 255
29691: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29692: LD_VAR 0 9
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: LD_VAR 0 4
29706: PPUSH
29707: LD_INT 20
29709: PPUSH
29710: CALL 22425 0 4
29714: PUSH
29715: LD_INT 4
29717: ARRAY
29718: IFFALSE 29722
// exit ;
29720: GO 29771
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29722: LD_VAR 0 2
29726: PUSH
29727: LD_INT 29
29729: PUSH
29730: LD_INT 30
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: IN
29737: PUSH
29738: LD_VAR 0 3
29742: PPUSH
29743: LD_VAR 0 4
29747: PPUSH
29748: LD_VAR 0 9
29752: PPUSH
29753: CALL_OW 440
29757: NOT
29758: AND
29759: IFFALSE 29763
// exit ;
29761: GO 29771
// result := true ;
29763: LD_ADDR_VAR 0 6
29767: PUSH
29768: LD_INT 1
29770: ST_TO_ADDR
// end ;
29771: LD_VAR 0 6
29775: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29776: LD_INT 0
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
29828: PPUSH
29829: PPUSH
29830: PPUSH
29831: PPUSH
29832: PPUSH
29833: PPUSH
29834: PPUSH
29835: PPUSH
// result = [ ] ;
29836: LD_ADDR_VAR 0 7
29840: PUSH
29841: EMPTY
29842: ST_TO_ADDR
// temp_list = [ ] ;
29843: LD_ADDR_VAR 0 9
29847: PUSH
29848: EMPTY
29849: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29850: LD_VAR 0 4
29854: PUSH
29855: LD_INT 0
29857: PUSH
29858: LD_INT 1
29860: PUSH
29861: LD_INT 2
29863: PUSH
29864: LD_INT 3
29866: PUSH
29867: LD_INT 4
29869: PUSH
29870: LD_INT 5
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: IN
29881: NOT
29882: PUSH
29883: LD_VAR 0 1
29887: PUSH
29888: LD_INT 0
29890: PUSH
29891: LD_INT 1
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: IN
29898: PUSH
29899: LD_VAR 0 5
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: LD_INT 2
29909: PUSH
29910: LD_INT 3
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: LIST
29917: IN
29918: NOT
29919: AND
29920: OR
29921: IFFALSE 29925
// exit ;
29923: GO 48316
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29925: LD_VAR 0 1
29929: PUSH
29930: LD_INT 6
29932: PUSH
29933: LD_INT 7
29935: PUSH
29936: LD_INT 8
29938: PUSH
29939: LD_INT 13
29941: PUSH
29942: LD_INT 12
29944: PUSH
29945: LD_INT 15
29947: PUSH
29948: LD_INT 11
29950: PUSH
29951: LD_INT 14
29953: PUSH
29954: LD_INT 10
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: IN
29968: IFFALSE 29978
// btype = b_lab ;
29970: LD_ADDR_VAR 0 1
29974: PUSH
29975: LD_INT 6
29977: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29978: LD_VAR 0 6
29982: PUSH
29983: LD_INT 0
29985: PUSH
29986: LD_INT 1
29988: PUSH
29989: LD_INT 2
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: LIST
29996: IN
29997: NOT
29998: PUSH
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 2
30012: PUSH
30013: LD_INT 3
30015: PUSH
30016: LD_INT 6
30018: PUSH
30019: LD_INT 36
30021: PUSH
30022: LD_INT 4
30024: PUSH
30025: LD_INT 5
30027: PUSH
30028: LD_INT 31
30030: PUSH
30031: LD_INT 32
30033: PUSH
30034: LD_INT 33
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: IN
30050: NOT
30051: PUSH
30052: LD_VAR 0 6
30056: PUSH
30057: LD_INT 1
30059: EQUAL
30060: AND
30061: OR
30062: PUSH
30063: LD_VAR 0 1
30067: PUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 3
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: IN
30078: NOT
30079: PUSH
30080: LD_VAR 0 6
30084: PUSH
30085: LD_INT 2
30087: EQUAL
30088: AND
30089: OR
30090: IFFALSE 30100
// mode = 0 ;
30092: LD_ADDR_VAR 0 6
30096: PUSH
30097: LD_INT 0
30099: ST_TO_ADDR
// case mode of 0 :
30100: LD_VAR 0 6
30104: PUSH
30105: LD_INT 0
30107: DOUBLE
30108: EQUAL
30109: IFTRUE 30113
30111: GO 41566
30113: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30114: LD_ADDR_VAR 0 11
30118: PUSH
30119: LD_INT 0
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 0
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: LD_INT 0
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: LD_INT 0
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 1
30195: NEG
30196: PUSH
30197: LD_INT 2
30199: NEG
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 2
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 0
30239: PUSH
30240: LD_INT 2
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 1
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: LD_INT 3
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: LD_INT 3
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: NEG
30281: PUSH
30282: LD_INT 2
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30307: LD_ADDR_VAR 0 12
30311: PUSH
30312: LD_INT 0
30314: PUSH
30315: LD_INT 0
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 0
30324: PUSH
30325: LD_INT 1
30327: NEG
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: LD_INT 0
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 1
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: LD_INT 1
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: LD_INT 0
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: LD_INT 1
30380: NEG
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 1
30388: PUSH
30389: LD_INT 1
30391: NEG
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 2
30399: PUSH
30400: LD_INT 0
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 2
30409: PUSH
30410: LD_INT 1
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 1
30419: NEG
30420: PUSH
30421: LD_INT 1
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 2
30430: NEG
30431: PUSH
30432: LD_INT 0
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 2
30441: NEG
30442: PUSH
30443: LD_INT 1
30445: NEG
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 2
30453: NEG
30454: PUSH
30455: LD_INT 1
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 3
30464: NEG
30465: PUSH
30466: LD_INT 0
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 3
30475: NEG
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30503: LD_ADDR_VAR 0 13
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 0
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 0
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: NEG
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 1
30584: NEG
30585: PUSH
30586: LD_INT 2
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: PUSH
30597: LD_INT 1
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 2
30606: PUSH
30607: LD_INT 2
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 2
30626: NEG
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 2
30638: NEG
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: NEG
30651: PUSH
30652: LD_INT 3
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 3
30662: NEG
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 3
30674: NEG
30675: PUSH
30676: LD_INT 3
30678: NEG
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30702: LD_ADDR_VAR 0 14
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 0
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 0
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 1
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: NEG
30784: PUSH
30785: LD_INT 2
30787: NEG
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 0
30795: PUSH
30796: LD_INT 2
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 2
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: LD_INT 2
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: NEG
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 1
30848: NEG
30849: PUSH
30850: LD_INT 3
30852: NEG
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 0
30860: PUSH
30861: LD_INT 3
30863: NEG
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 1
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30898: LD_ADDR_VAR 0 15
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 1
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: PUSH
30980: LD_INT 1
30982: NEG
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: LD_INT 2
30990: PUSH
30991: LD_INT 0
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: LD_INT 1
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 1
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 2
31021: NEG
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 2
31032: NEG
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 1
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 3
31055: PUSH
31056: LD_INT 0
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 3
31065: PUSH
31066: LD_INT 1
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31091: LD_ADDR_VAR 0 16
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 0
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 1
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 0
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: LD_INT 2
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 2
31214: NEG
31215: PUSH
31216: LD_INT 1
31218: NEG
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 2
31226: NEG
31227: PUSH
31228: LD_INT 2
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 3
31238: PUSH
31239: LD_INT 2
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 3
31248: PUSH
31249: LD_INT 3
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: PUSH
31259: LD_INT 3
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31284: LD_ADDR_VAR 0 17
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 2
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: LD_INT 2
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 1
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 0
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 2
31471: NEG
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: LD_INT 2
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31514: LD_ADDR_VAR 0 18
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 0
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: LD_INT 0
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: NEG
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 2
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 2
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31744: LD_ADDR_VAR 0 19
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 1
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 2
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 2
31840: NEG
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 2
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 2
31879: PUSH
31880: LD_INT 2
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 1
31889: PUSH
31890: LD_INT 2
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: LD_INT 2
31920: NEG
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: NEG
31944: PUSH
31945: LD_INT 2
31947: NEG
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31974: LD_ADDR_VAR 0 20
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: NEG
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: NEG
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: LD_INT 2
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: LD_INT 1
32081: NEG
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: LD_INT 0
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 2
32099: PUSH
32100: LD_INT 1
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 2
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 0
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 1
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: NEG
32162: PUSH
32163: LD_INT 1
32165: NEG
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 2
32173: NEG
32174: PUSH
32175: LD_INT 2
32177: NEG
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32204: LD_ADDR_VAR 0 21
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 0
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: LD_INT 1
32224: NEG
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 1
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 1
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: LD_INT 2
32300: NEG
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 1
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 2
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 2
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 0
32359: PUSH
32360: LD_INT 2
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 2
32380: NEG
32381: PUSH
32382: LD_INT 0
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: LD_INT 2
32407: NEG
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32434: LD_ADDR_VAR 0 22
32438: PUSH
32439: LD_INT 0
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: LD_INT 1
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 1
32462: PUSH
32463: LD_INT 0
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: LD_INT 1
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: LD_INT 1
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: NEG
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 1
32515: NEG
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 0
32527: PUSH
32528: LD_INT 2
32530: NEG
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: LD_INT 1
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 2
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 2
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 2
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 2
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 0
32589: PUSH
32590: LD_INT 2
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: LD_INT 1
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 2
32621: NEG
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 2
32633: NEG
32634: PUSH
32635: LD_INT 2
32637: NEG
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32664: LD_ADDR_VAR 0 23
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 1
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 1
32722: NEG
32723: PUSH
32724: LD_INT 0
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 2
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 1
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 2
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 2
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 2
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 1
32809: PUSH
32810: LD_INT 2
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 1
32829: NEG
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: LD_INT 0
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 3
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 3
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: LD_INT 2
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32944: LD_ADDR_VAR 0 24
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 0
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 0
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 0
32992: PUSH
32993: LD_INT 1
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: LD_INT 2
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: LD_INT 2
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: LD_INT 1
33051: NEG
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 2
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: PUSH
33090: LD_INT 2
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 2
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 1
33109: NEG
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 2
33120: NEG
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: NEG
33132: PUSH
33133: LD_INT 1
33135: NEG
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 2
33143: NEG
33144: PUSH
33145: LD_INT 2
33147: NEG
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: PUSH
33156: LD_INT 2
33158: NEG
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 3
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 3
33187: PUSH
33188: LD_INT 2
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33220: LD_ADDR_VAR 0 25
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: PUSH
33249: LD_INT 0
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: LD_INT 0
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 2
33305: NEG
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: LD_INT 2
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 2
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 2
33345: PUSH
33346: LD_INT 1
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 2
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: LD_INT 2
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: LD_INT 1
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PUSH
33394: LD_INT 2
33396: NEG
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 2
33407: NEG
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: LD_INT 2
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 3
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 3
33441: PUSH
33442: LD_INT 2
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: LD_INT 3
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 3
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33494: LD_ADDR_VAR 0 26
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 0
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: LD_INT 0
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: LD_INT 1
33563: NEG
33564: PUSH
33565: LD_INT 1
33567: NEG
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: LD_INT 2
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 2
33590: NEG
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: LD_INT 1
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 2
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: LD_INT 1
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: LD_INT 2
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 1
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: NEG
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 2
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 2
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 2
33705: PUSH
33706: LD_INT 3
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: NEG
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: NEG
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33770: LD_ADDR_VAR 0 27
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 0
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 0
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 1
33828: NEG
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 2
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 0
33863: PUSH
33864: LD_INT 2
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 2
33885: PUSH
33886: LD_INT 0
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: PUSH
33896: LD_INT 1
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 2
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 0
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 2
33946: NEG
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 2
33957: NEG
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: NEG
33970: PUSH
33971: LD_INT 2
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: NEG
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: LD_INT 1
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 3
34015: NEG
34016: PUSH
34017: LD_INT 2
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34050: LD_ADDR_VAR 0 28
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 0
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 1
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 1
34108: NEG
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 1
34131: NEG
34132: PUSH
34133: LD_INT 2
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: LD_INT 2
34146: NEG
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: LD_INT 1
34157: NEG
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: LD_INT 1
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 0
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 2
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 2
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 2
34261: NEG
34262: PUSH
34263: LD_INT 3
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 1
34273: NEG
34274: PUSH
34275: LD_INT 3
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 3
34285: NEG
34286: PUSH
34287: LD_INT 1
34289: NEG
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 3
34297: NEG
34298: PUSH
34299: LD_INT 2
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34332: LD_ADDR_VAR 0 29
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: LD_INT 0
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: LD_INT 1
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: LD_INT 2
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 0
34425: PUSH
34426: LD_INT 2
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: LD_INT 2
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: NEG
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: LD_INT 2
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 2
34522: NEG
34523: PUSH
34524: LD_INT 3
34526: NEG
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 1
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 3
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 3
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 2
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 3
34576: NEG
34577: PUSH
34578: LD_INT 2
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34611: LD_ADDR_VAR 0 30
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: LD_INT 1
34631: NEG
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: LD_INT 1
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: NEG
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 2
34707: NEG
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 2
34746: PUSH
34747: LD_INT 2
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 2
34777: NEG
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: NEG
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: LD_INT 3
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 2
34815: NEG
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 3
34823: PUSH
34824: LD_INT 2
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 3
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: LD_INT 1
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 3
34854: NEG
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34889: LD_ADDR_VAR 0 31
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: LD_INT 0
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: NEG
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: NEG
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 2
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 1
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 2
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 2
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 0
35033: PUSH
35034: LD_INT 2
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: NEG
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: LD_INT 2
35070: NEG
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 2
35078: NEG
35079: PUSH
35080: LD_INT 3
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 3
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 1
35111: PUSH
35112: LD_INT 3
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 2
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 3
35132: NEG
35133: PUSH
35134: LD_INT 2
35136: NEG
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35167: LD_ADDR_VAR 0 32
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: LD_INT 0
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 1
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: LD_INT 1
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: NEG
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: LD_INT 2
35252: NEG
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: LD_INT 2
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 1
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 2
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 2
35292: PUSH
35293: LD_INT 2
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: LD_INT 2
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 2
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 2
35333: NEG
35334: PUSH
35335: LD_INT 0
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 2
35344: NEG
35345: PUSH
35346: LD_INT 1
35348: NEG
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 3
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: LD_INT 2
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 3
35379: PUSH
35380: LD_INT 2
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: LD_INT 3
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 3
35410: NEG
35411: PUSH
35412: LD_INT 1
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35445: LD_ADDR_VAR 0 33
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 0
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: LD_INT 1
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: NEG
35504: PUSH
35505: LD_INT 0
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 1
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: LD_INT 2
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: LD_INT 1
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: PUSH
35550: LD_INT 0
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 2
35559: PUSH
35560: LD_INT 1
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: LD_INT 2
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 2
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: NEG
35636: PUSH
35637: LD_INT 3
35639: NEG
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 2
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 3
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: PUSH
35669: LD_INT 3
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: NEG
35679: PUSH
35680: LD_INT 2
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 3
35689: NEG
35690: PUSH
35691: LD_INT 2
35693: NEG
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35724: LD_ADDR_VAR 0 34
35728: PUSH
35729: LD_INT 0
35731: PUSH
35732: LD_INT 0
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 0
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: LD_INT 1
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 0
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 1
35782: NEG
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 1
35793: NEG
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 1
35805: NEG
35806: PUSH
35807: LD_INT 2
35809: NEG
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: LD_INT 2
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: LD_INT 1
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 2
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 2
35849: PUSH
35850: LD_INT 2
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 1
35859: PUSH
35860: LD_INT 2
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 2
35891: NEG
35892: PUSH
35893: LD_INT 1
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 2
35903: NEG
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: LD_INT 3
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 2
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: PUSH
35939: LD_INT 2
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 3
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: NEG
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36004: LD_ADDR_VAR 0 35
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 0
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 1
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 0
36052: PUSH
36053: LD_INT 1
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 0
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: LD_INT 1
36077: NEG
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 2
36085: PUSH
36086: LD_INT 1
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 2
36095: NEG
36096: PUSH
36097: LD_INT 1
36099: NEG
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36116: LD_ADDR_VAR 0 36
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 0
36133: PUSH
36134: LD_INT 1
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 1
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 1
36174: NEG
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 1
36185: NEG
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: LD_INT 2
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: LD_INT 2
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36228: LD_ADDR_VAR 0 37
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 0
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: LD_INT 0
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: NEG
36287: PUSH
36288: LD_INT 0
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 1
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 1
36320: NEG
36321: PUSH
36322: LD_INT 1
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36340: LD_ADDR_VAR 0 38
36344: PUSH
36345: LD_INT 0
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 0
36357: PUSH
36358: LD_INT 1
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: LD_INT 0
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: LD_INT 1
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 1
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 1
36398: NEG
36399: PUSH
36400: LD_INT 0
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: NEG
36410: PUSH
36411: LD_INT 1
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 2
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 2
36431: NEG
36432: PUSH
36433: LD_INT 1
36435: NEG
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36452: LD_ADDR_VAR 0 39
36456: PUSH
36457: LD_INT 0
36459: PUSH
36460: LD_INT 0
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: LD_INT 0
36469: PUSH
36470: LD_INT 1
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: LD_INT 1
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: LD_INT 1
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 1
36510: NEG
36511: PUSH
36512: LD_INT 0
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: LD_INT 1
36525: NEG
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 1
36533: NEG
36534: PUSH
36535: LD_INT 2
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: LD_INT 2
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36564: LD_ADDR_VAR 0 40
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 0
36581: PUSH
36582: LD_INT 1
36584: NEG
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: LD_INT 0
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: LD_INT 1
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: LD_INT 1
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: LD_INT 1
36622: NEG
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: NEG
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36676: LD_ADDR_VAR 0 41
36680: PUSH
36681: LD_INT 0
36683: PUSH
36684: LD_INT 0
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: NEG
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 1
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: LD_INT 1
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 1
36734: NEG
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 1
36757: NEG
36758: PUSH
36759: LD_INT 2
36761: NEG
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 1
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 2
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: LD_INT 2
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 2
36842: NEG
36843: PUSH
36844: LD_INT 1
36846: NEG
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 2
36854: NEG
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 2
36866: NEG
36867: PUSH
36868: LD_INT 3
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 2
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 3
36899: PUSH
36900: LD_INT 1
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 3
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 3
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 3
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 3
36950: NEG
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 3
36961: NEG
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37026: LD_ADDR_VAR 0 42
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: LD_INT 0
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 1
37046: NEG
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: LD_INT 0
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: LD_INT 1
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 1
37084: NEG
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: NEG
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: LD_INT 2
37111: NEG
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 0
37119: PUSH
37120: LD_INT 2
37122: NEG
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 1
37130: PUSH
37131: LD_INT 1
37133: NEG
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 2
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: LD_INT 2
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: LD_INT 2
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 0
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: NEG
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 2
37192: NEG
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 2
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 2
37216: NEG
37217: PUSH
37218: LD_INT 3
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 3
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 3
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 2
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 3
37262: PUSH
37263: LD_INT 2
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 3
37272: PUSH
37273: LD_INT 3
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 2
37282: PUSH
37283: LD_INT 3
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 1
37292: PUSH
37293: LD_INT 3
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: LD_INT 3
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: LD_INT 3
37323: NEG
37324: PUSH
37325: LD_INT 2
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 3
37335: NEG
37336: PUSH
37337: LD_INT 3
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37376: LD_ADDR_VAR 0 43
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 0
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 1
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: LD_INT 1
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 0
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 1
37445: NEG
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: NEG
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 0
37469: PUSH
37470: LD_INT 2
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: PUSH
37492: LD_INT 0
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 2
37501: PUSH
37502: LD_INT 1
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: PUSH
37512: LD_INT 2
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 0
37521: PUSH
37522: LD_INT 2
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 1
37531: NEG
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 2
37542: NEG
37543: PUSH
37544: LD_INT 0
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: LD_INT 3
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 0
37577: PUSH
37578: LD_INT 3
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: LD_INT 2
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 3
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 3
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: PUSH
37631: LD_INT 3
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 3
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: LD_INT 2
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 2
37661: NEG
37662: PUSH
37663: LD_INT 1
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 3
37672: NEG
37673: PUSH
37674: LD_INT 0
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: LD_INT 3
37683: NEG
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37724: LD_ADDR_VAR 0 44
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: LD_INT 0
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 0
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 1
37782: NEG
37783: PUSH
37784: LD_INT 0
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 1
37805: NEG
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 1
37817: PUSH
37818: LD_INT 1
37820: NEG
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PUSH
37826: LD_INT 2
37828: PUSH
37829: LD_INT 0
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 2
37838: PUSH
37839: LD_INT 1
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 2
37848: PUSH
37849: LD_INT 2
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: LD_INT 2
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 1
37868: NEG
37869: PUSH
37870: LD_INT 1
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: LD_INT 0
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: NEG
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 2
37914: NEG
37915: PUSH
37916: LD_INT 3
37918: NEG
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 2
37926: PUSH
37927: LD_INT 1
37929: NEG
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: LD_INT 0
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: LD_INT 1
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: LD_INT 3
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 2
37977: PUSH
37978: LD_INT 3
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: NEG
37988: PUSH
37989: LD_INT 1
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 3
37998: NEG
37999: PUSH
38000: LD_INT 0
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 3
38009: NEG
38010: PUSH
38011: LD_INT 1
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 3
38021: NEG
38022: PUSH
38023: LD_INT 2
38025: NEG
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 3
38033: NEG
38034: PUSH
38035: LD_INT 3
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38074: LD_ADDR_VAR 0 45
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: LD_INT 0
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: LD_INT 1
38094: NEG
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: LD_INT 1
38102: PUSH
38103: LD_INT 0
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 1
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: LD_INT 0
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: NEG
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: LD_INT 2
38170: NEG
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 2
38189: PUSH
38190: LD_INT 1
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 2
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: LD_INT 2
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 1
38229: NEG
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 2
38240: NEG
38241: PUSH
38242: LD_INT 1
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 2
38252: NEG
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 2
38264: NEG
38265: PUSH
38266: LD_INT 3
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: NEG
38277: PUSH
38278: LD_INT 3
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: LD_INT 3
38291: NEG
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 1
38299: PUSH
38300: LD_INT 2
38302: NEG
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 3
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 3
38320: PUSH
38321: LD_INT 3
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 2
38330: PUSH
38331: LD_INT 3
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 1
38340: PUSH
38341: LD_INT 3
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 3
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: NEG
38361: PUSH
38362: LD_INT 2
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 3
38371: NEG
38372: PUSH
38373: LD_INT 2
38375: NEG
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 3
38383: NEG
38384: PUSH
38385: LD_INT 3
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38424: LD_ADDR_VAR 0 46
38428: PUSH
38429: LD_INT 0
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: LD_INT 1
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: LD_INT 1
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 1
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: LD_INT 1
38497: NEG
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 0
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 1
38528: PUSH
38529: LD_INT 1
38531: NEG
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 2
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: LD_INT 2
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: LD_INT 2
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: LD_INT 1
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 2
38590: NEG
38591: PUSH
38592: LD_INT 0
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: LD_INT 1
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: LD_INT 3
38617: NEG
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 0
38625: PUSH
38626: LD_INT 3
38628: NEG
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 1
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 3
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: PUSH
38679: LD_INT 3
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 0
38688: PUSH
38689: LD_INT 3
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 1
38698: NEG
38699: PUSH
38700: LD_INT 2
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: LD_INT 0
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 3
38731: NEG
38732: PUSH
38733: LD_INT 1
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: LIST
38770: LIST
38771: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38772: LD_ADDR_VAR 0 47
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: LD_INT 0
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: LD_INT 1
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 1
38800: PUSH
38801: LD_INT 0
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: LD_INT 1
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 1
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: LD_INT 2
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: LD_INT 2
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 2
38887: NEG
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: NEG
38900: PUSH
38901: LD_INT 2
38903: NEG
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: LIST
38922: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38923: LD_ADDR_VAR 0 48
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: LD_INT 0
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: LD_INT 1
38943: NEG
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 0
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 1
38992: NEG
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: NEG
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 2
39048: PUSH
39049: LD_INT 1
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39070: LD_ADDR_VAR 0 49
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: LD_INT 0
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: LD_INT 0
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 1
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 0
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PUSH
39126: LD_INT 1
39128: NEG
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 2
39172: PUSH
39173: LD_INT 1
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 2
39182: PUSH
39183: LD_INT 2
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: LD_INT 2
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39214: LD_ADDR_VAR 0 50
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: LD_INT 0
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 0
39231: PUSH
39232: LD_INT 1
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: PUSH
39243: LD_INT 0
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 1
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: NEG
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 2
39305: PUSH
39306: LD_INT 2
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 2
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 0
39325: PUSH
39326: LD_INT 2
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39358: LD_ADDR_VAR 0 51
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: LD_INT 1
39378: NEG
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 1
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: NEG
39417: PUSH
39418: LD_INT 0
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 1
39427: NEG
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 2
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 2
39470: NEG
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 2
39481: NEG
39482: PUSH
39483: LD_INT 1
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39505: LD_ADDR_VAR 0 52
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 2
39609: NEG
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: PUSH
39618: LD_INT 2
39620: NEG
39621: PUSH
39622: LD_INT 1
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 2
39632: NEG
39633: PUSH
39634: LD_INT 2
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39656: LD_ADDR_VAR 0 53
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: LD_INT 0
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: LD_INT 1
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 1
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 2
39752: NEG
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 1
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 2
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 2
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: LD_INT 2
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: LD_INT 1
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 2
39832: NEG
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39886: LD_ADDR_VAR 0 54
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: LD_INT 1
39906: NEG
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 1
39924: PUSH
39925: LD_INT 1
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 2
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: LD_INT 2
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 2
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 2
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 2
40021: PUSH
40022: LD_INT 2
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 1
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 0
40041: PUSH
40042: LD_INT 2
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 2
40062: NEG
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 2
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 2
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40116: LD_ADDR_VAR 0 55
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 0
40133: PUSH
40134: LD_INT 1
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 0
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 1
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 1
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 1
40197: NEG
40198: PUSH
40199: LD_INT 2
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 2
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: LD_INT 0
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 2
40251: PUSH
40252: LD_INT 2
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: LD_INT 2
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 2
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: LD_INT 1
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 2
40292: NEG
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 2
40315: NEG
40316: PUSH
40317: LD_INT 2
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40346: LD_ADDR_VAR 0 56
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: LD_INT 1
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 1
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 1
40384: PUSH
40385: LD_INT 1
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: LD_INT 1
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: LD_INT 2
40431: NEG
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 2
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 1
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 2
40461: PUSH
40462: LD_INT 0
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: LD_INT 1
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: PUSH
40482: LD_INT 2
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: PUSH
40492: LD_INT 2
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 0
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: NEG
40512: PUSH
40513: LD_INT 1
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 2
40522: NEG
40523: PUSH
40524: LD_INT 0
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 2
40533: NEG
40534: PUSH
40535: LD_INT 1
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 2
40545: NEG
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40576: LD_ADDR_VAR 0 57
40580: PUSH
40581: LD_INT 0
40583: PUSH
40584: LD_INT 0
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: LD_INT 1
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 1
40604: PUSH
40605: LD_INT 0
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: PUSH
40615: LD_INT 1
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: LD_INT 1
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: LD_INT 0
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: LD_INT 2
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 0
40669: PUSH
40670: LD_INT 2
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: LD_INT 1
40683: NEG
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 2
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 2
40701: PUSH
40702: LD_INT 1
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: LD_INT 2
40711: PUSH
40712: LD_INT 2
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 1
40721: PUSH
40722: LD_INT 2
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: LD_INT 2
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 1
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 2
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 2
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 2
40775: NEG
40776: PUSH
40777: LD_INT 2
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: LIST
40795: LIST
40796: LIST
40797: LIST
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40806: LD_ADDR_VAR 0 58
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: LD_INT 1
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 1
40844: PUSH
40845: LD_INT 1
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: LD_INT 1
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 1
40864: NEG
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 1
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: LD_INT 2
40902: NEG
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 1
40910: PUSH
40911: LD_INT 1
40913: NEG
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: PUSH
40932: LD_INT 1
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 2
40941: PUSH
40942: LD_INT 2
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: LD_INT 2
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 0
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: NEG
40972: PUSH
40973: LD_INT 1
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: LD_INT 0
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 2
40993: NEG
40994: PUSH
40995: LD_INT 1
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 2
41005: NEG
41006: PUSH
41007: LD_INT 2
41009: NEG
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41036: LD_ADDR_VAR 0 59
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: LD_INT 1
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 1
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 1
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 1
41094: NEG
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 1
41105: NEG
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41124: LD_ADDR_VAR 0 60
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 0
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 0
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 0
41172: PUSH
41173: LD_INT 1
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 0
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: LD_INT 1
41193: NEG
41194: PUSH
41195: LD_INT 1
41197: NEG
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41212: LD_ADDR_VAR 0 61
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 0
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 0
41229: PUSH
41230: LD_INT 1
41232: NEG
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: LD_INT 0
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: PUSH
41251: LD_INT 1
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 0
41260: PUSH
41261: LD_INT 1
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: NEG
41271: PUSH
41272: LD_INT 0
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: NEG
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41300: LD_ADDR_VAR 0 62
41304: PUSH
41305: LD_INT 0
41307: PUSH
41308: LD_INT 0
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 0
41317: PUSH
41318: LD_INT 1
41320: NEG
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 1
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 1
41358: NEG
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: LD_INT 1
41373: NEG
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41388: LD_ADDR_VAR 0 63
41392: PUSH
41393: LD_INT 0
41395: PUSH
41396: LD_INT 0
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 1
41426: PUSH
41427: LD_INT 1
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: LD_INT 0
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 1
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41476: LD_ADDR_VAR 0 64
41480: PUSH
41481: LD_INT 0
41483: PUSH
41484: LD_INT 0
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: LD_INT 1
41496: NEG
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: LD_INT 1
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: LD_INT 1
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 1
41534: NEG
41535: PUSH
41536: LD_INT 0
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: ST_TO_ADDR
// end ; 1 :
41564: GO 47461
41566: LD_INT 1
41568: DOUBLE
41569: EQUAL
41570: IFTRUE 41574
41572: GO 44197
41574: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41575: LD_ADDR_VAR 0 11
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: PUSH
41606: LD_INT 2
41608: NEG
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: LIST
41618: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41619: LD_ADDR_VAR 0 12
41623: PUSH
41624: LD_INT 2
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 3
41637: PUSH
41638: LD_INT 0
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 3
41647: PUSH
41648: LD_INT 1
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41660: LD_ADDR_VAR 0 13
41664: PUSH
41665: LD_INT 3
41667: PUSH
41668: LD_INT 2
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 3
41677: PUSH
41678: LD_INT 3
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 2
41687: PUSH
41688: LD_INT 3
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: LIST
41699: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41700: LD_ADDR_VAR 0 14
41704: PUSH
41705: LD_INT 1
41707: PUSH
41708: LD_INT 3
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 0
41717: PUSH
41718: LD_INT 3
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: LIST
41740: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41741: LD_ADDR_VAR 0 15
41745: PUSH
41746: LD_INT 2
41748: NEG
41749: PUSH
41750: LD_INT 1
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 3
41759: NEG
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 3
41770: NEG
41771: PUSH
41772: LD_INT 1
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: LIST
41784: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41785: LD_ADDR_VAR 0 16
41789: PUSH
41790: LD_INT 2
41792: NEG
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: NEG
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41831: LD_ADDR_VAR 0 17
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: LD_INT 3
41842: NEG
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 0
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41875: LD_ADDR_VAR 0 18
41879: PUSH
41880: LD_INT 2
41882: PUSH
41883: LD_INT 1
41885: NEG
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 3
41893: PUSH
41894: LD_INT 0
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 3
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41916: LD_ADDR_VAR 0 19
41920: PUSH
41921: LD_INT 3
41923: PUSH
41924: LD_INT 2
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 3
41933: PUSH
41934: LD_INT 3
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 2
41943: PUSH
41944: LD_INT 3
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: LIST
41955: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41956: LD_ADDR_VAR 0 20
41960: PUSH
41961: LD_INT 1
41963: PUSH
41964: LD_INT 3
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 0
41973: PUSH
41974: LD_INT 3
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 2
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: LIST
41996: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41997: LD_ADDR_VAR 0 21
42001: PUSH
42002: LD_INT 2
42004: NEG
42005: PUSH
42006: LD_INT 1
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: LD_INT 0
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 3
42026: NEG
42027: PUSH
42028: LD_INT 1
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: LIST
42040: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42041: LD_ADDR_VAR 0 22
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 3
42060: NEG
42061: PUSH
42062: LD_INT 2
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 3
42072: NEG
42073: PUSH
42074: LD_INT 3
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: LIST
42086: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42087: LD_ADDR_VAR 0 23
42091: PUSH
42092: LD_INT 0
42094: PUSH
42095: LD_INT 3
42097: NEG
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 1
42105: NEG
42106: PUSH
42107: LD_INT 4
42109: NEG
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 1
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: LIST
42130: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42131: LD_ADDR_VAR 0 24
42135: PUSH
42136: LD_INT 3
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 3
42148: PUSH
42149: LD_INT 1
42151: NEG
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: LIST
42171: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42172: LD_ADDR_VAR 0 25
42176: PUSH
42177: LD_INT 3
42179: PUSH
42180: LD_INT 3
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 4
42189: PUSH
42190: LD_INT 3
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 3
42199: PUSH
42200: LD_INT 4
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: LIST
42211: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42212: LD_ADDR_VAR 0 26
42216: PUSH
42217: LD_INT 0
42219: PUSH
42220: LD_INT 3
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: LD_INT 4
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: LIST
42252: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42253: LD_ADDR_VAR 0 27
42257: PUSH
42258: LD_INT 3
42260: NEG
42261: PUSH
42262: LD_INT 0
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 3
42271: NEG
42272: PUSH
42273: LD_INT 1
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 4
42282: NEG
42283: PUSH
42284: LD_INT 1
42286: NEG
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: LIST
42296: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42297: LD_ADDR_VAR 0 28
42301: PUSH
42302: LD_INT 3
42304: NEG
42305: PUSH
42306: LD_INT 3
42308: NEG
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 3
42316: NEG
42317: PUSH
42318: LD_INT 4
42320: NEG
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: LD_INT 3
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: LIST
42342: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42343: LD_ADDR_VAR 0 29
42347: PUSH
42348: LD_INT 1
42350: NEG
42351: PUSH
42352: LD_INT 3
42354: NEG
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 3
42365: NEG
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 1
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 0
42396: PUSH
42397: LD_INT 4
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 1
42418: NEG
42419: PUSH
42420: LD_INT 5
42422: NEG
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: LD_INT 5
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 1
42441: PUSH
42442: LD_INT 4
42444: NEG
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 1
42452: NEG
42453: PUSH
42454: LD_INT 6
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: LD_INT 6
42467: NEG
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 1
42475: PUSH
42476: LD_INT 5
42478: NEG
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42498: LD_ADDR_VAR 0 30
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: LD_INT 1
42508: NEG
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 3
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 3
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 3
42536: PUSH
42537: LD_INT 1
42539: NEG
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 4
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 4
42557: PUSH
42558: LD_INT 1
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 4
42567: PUSH
42568: LD_INT 1
42570: NEG
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 5
42578: PUSH
42579: LD_INT 0
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: LD_INT 1
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 5
42598: PUSH
42599: LD_INT 1
42601: NEG
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 6
42609: PUSH
42610: LD_INT 0
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 6
42619: PUSH
42620: LD_INT 1
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42641: LD_ADDR_VAR 0 31
42645: PUSH
42646: LD_INT 3
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 3
42658: PUSH
42659: LD_INT 3
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: PUSH
42669: LD_INT 3
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 4
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: PUSH
42689: LD_INT 4
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 3
42698: PUSH
42699: LD_INT 4
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 5
42708: PUSH
42709: LD_INT 4
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 5
42718: PUSH
42719: LD_INT 5
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 4
42728: PUSH
42729: LD_INT 5
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 6
42738: PUSH
42739: LD_INT 5
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 6
42748: PUSH
42749: LD_INT 6
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 5
42758: PUSH
42759: LD_INT 6
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42780: LD_ADDR_VAR 0 32
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: LD_INT 3
42790: PUSH
42791: EMPTY
42792: LIST
42793: LIST
42794: PUSH
42795: LD_INT 0
42797: PUSH
42798: LD_INT 3
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 2
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: LD_INT 4
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 0
42828: PUSH
42829: LD_INT 4
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: NEG
42839: PUSH
42840: LD_INT 3
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 1
42849: PUSH
42850: LD_INT 5
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: LD_INT 5
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 4
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 1
42880: PUSH
42881: LD_INT 6
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 0
42890: PUSH
42891: LD_INT 6
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 1
42900: NEG
42901: PUSH
42902: LD_INT 5
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: LIST
42916: LIST
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42923: LD_ADDR_VAR 0 33
42927: PUSH
42928: LD_INT 2
42930: NEG
42931: PUSH
42932: LD_INT 1
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 3
42941: NEG
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 3
42952: NEG
42953: PUSH
42954: LD_INT 1
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 3
42964: NEG
42965: PUSH
42966: LD_INT 1
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 4
42975: NEG
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 4
42986: NEG
42987: PUSH
42988: LD_INT 1
42990: NEG
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 4
42998: NEG
42999: PUSH
43000: LD_INT 1
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 5
43009: NEG
43010: PUSH
43011: LD_INT 0
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 5
43020: NEG
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 5
43032: NEG
43033: PUSH
43034: LD_INT 1
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 6
43043: NEG
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 6
43054: NEG
43055: PUSH
43056: LD_INT 1
43058: NEG
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43078: LD_ADDR_VAR 0 34
43082: PUSH
43083: LD_INT 2
43085: NEG
43086: PUSH
43087: LD_INT 3
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 3
43097: NEG
43098: PUSH
43099: LD_INT 2
43101: NEG
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 3
43109: NEG
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 3
43121: NEG
43122: PUSH
43123: LD_INT 4
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: LD_INT 4
43133: NEG
43134: PUSH
43135: LD_INT 3
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 4
43145: NEG
43146: PUSH
43147: LD_INT 4
43149: NEG
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 4
43157: NEG
43158: PUSH
43159: LD_INT 5
43161: NEG
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 5
43169: NEG
43170: PUSH
43171: LD_INT 4
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 5
43181: NEG
43182: PUSH
43183: LD_INT 5
43185: NEG
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 5
43193: NEG
43194: PUSH
43195: LD_INT 6
43197: NEG
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 6
43205: NEG
43206: PUSH
43207: LD_INT 5
43209: NEG
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 6
43217: NEG
43218: PUSH
43219: LD_INT 6
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: LIST
43237: LIST
43238: LIST
43239: LIST
43240: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43241: LD_ADDR_VAR 0 41
43245: PUSH
43246: LD_INT 0
43248: PUSH
43249: LD_INT 2
43251: NEG
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 1
43259: NEG
43260: PUSH
43261: LD_INT 3
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: PUSH
43272: LD_INT 2
43274: NEG
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: LIST
43284: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43285: LD_ADDR_VAR 0 42
43289: PUSH
43290: LD_INT 2
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 2
43302: PUSH
43303: LD_INT 1
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: LIST
43325: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43326: LD_ADDR_VAR 0 43
43330: PUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 3
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 2
43353: PUSH
43354: LD_INT 3
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: LIST
43365: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43366: LD_ADDR_VAR 0 44
43370: PUSH
43371: LD_INT 0
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 1
43383: PUSH
43384: LD_INT 3
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: PUSH
43391: LD_INT 1
43393: NEG
43394: PUSH
43395: LD_INT 2
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: LIST
43406: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43407: LD_ADDR_VAR 0 45
43411: PUSH
43412: LD_INT 2
43414: NEG
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 2
43425: NEG
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 3
43436: NEG
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: LIST
43450: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43451: LD_ADDR_VAR 0 46
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: EMPTY
43477: LIST
43478: LIST
43479: PUSH
43480: LD_INT 3
43482: NEG
43483: PUSH
43484: LD_INT 2
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: LIST
43496: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43497: LD_ADDR_VAR 0 47
43501: PUSH
43502: LD_INT 2
43504: NEG
43505: PUSH
43506: LD_INT 3
43508: NEG
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 1
43516: NEG
43517: PUSH
43518: LD_INT 3
43520: NEG
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43530: LD_ADDR_VAR 0 48
43534: PUSH
43535: LD_INT 1
43537: PUSH
43538: LD_INT 2
43540: NEG
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 2
43548: PUSH
43549: LD_INT 1
43551: NEG
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43561: LD_ADDR_VAR 0 49
43565: PUSH
43566: LD_INT 3
43568: PUSH
43569: LD_INT 1
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 3
43578: PUSH
43579: LD_INT 2
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43590: LD_ADDR_VAR 0 50
43594: PUSH
43595: LD_INT 2
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 1
43607: PUSH
43608: LD_INT 3
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43619: LD_ADDR_VAR 0 51
43623: PUSH
43624: LD_INT 1
43626: NEG
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: LD_INT 1
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43650: LD_ADDR_VAR 0 52
43654: PUSH
43655: LD_INT 3
43657: NEG
43658: PUSH
43659: LD_INT 1
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 3
43669: NEG
43670: PUSH
43671: LD_INT 2
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43683: LD_ADDR_VAR 0 53
43687: PUSH
43688: LD_INT 1
43690: NEG
43691: PUSH
43692: LD_INT 3
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 0
43702: PUSH
43703: LD_INT 3
43705: NEG
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 1
43713: PUSH
43714: LD_INT 2
43716: NEG
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: LIST
43726: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43727: LD_ADDR_VAR 0 54
43731: PUSH
43732: LD_INT 2
43734: PUSH
43735: LD_INT 1
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 3
43745: PUSH
43746: LD_INT 0
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 3
43755: PUSH
43756: LD_INT 1
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: LIST
43767: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43768: LD_ADDR_VAR 0 55
43772: PUSH
43773: LD_INT 3
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 3
43785: PUSH
43786: LD_INT 3
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: PUSH
43796: LD_INT 3
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: LIST
43807: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43808: LD_ADDR_VAR 0 56
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: LD_INT 3
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 0
43825: PUSH
43826: LD_INT 3
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 1
43835: NEG
43836: PUSH
43837: LD_INT 2
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: LIST
43848: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43849: LD_ADDR_VAR 0 57
43853: PUSH
43854: LD_INT 2
43856: NEG
43857: PUSH
43858: LD_INT 1
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 3
43867: NEG
43868: PUSH
43869: LD_INT 0
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 3
43878: NEG
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: LIST
43892: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43893: LD_ADDR_VAR 0 58
43897: PUSH
43898: LD_INT 2
43900: NEG
43901: PUSH
43902: LD_INT 3
43904: NEG
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 3
43912: NEG
43913: PUSH
43914: LD_INT 2
43916: NEG
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: LD_INT 3
43924: NEG
43925: PUSH
43926: LD_INT 3
43928: NEG
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: LIST
43938: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43939: LD_ADDR_VAR 0 59
43943: PUSH
43944: LD_INT 1
43946: NEG
43947: PUSH
43948: LD_INT 2
43950: NEG
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 0
43958: PUSH
43959: LD_INT 2
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: LD_INT 1
43972: NEG
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: LIST
43982: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43983: LD_ADDR_VAR 0 60
43987: PUSH
43988: LD_INT 1
43990: PUSH
43991: LD_INT 1
43993: NEG
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 0
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: PUSH
44009: LD_INT 2
44011: PUSH
44012: LD_INT 1
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: LIST
44023: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44024: LD_ADDR_VAR 0 61
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 1
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: PUSH
44042: LD_INT 2
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 2
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44064: LD_ADDR_VAR 0 62
44068: PUSH
44069: LD_INT 1
44071: PUSH
44072: LD_INT 2
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 0
44081: PUSH
44082: LD_INT 2
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 1
44091: NEG
44092: PUSH
44093: LD_INT 1
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: LIST
44104: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44105: LD_ADDR_VAR 0 63
44109: PUSH
44110: LD_INT 1
44112: NEG
44113: PUSH
44114: LD_INT 1
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 2
44123: NEG
44124: PUSH
44125: LD_INT 0
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 2
44134: NEG
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: LIST
44148: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44149: LD_ADDR_VAR 0 64
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: LD_INT 1
44172: NEG
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 2
44180: NEG
44181: PUSH
44182: LD_INT 2
44184: NEG
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// end ; 2 :
44195: GO 47461
44197: LD_INT 2
44199: DOUBLE
44200: EQUAL
44201: IFTRUE 44205
44203: GO 47460
44205: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44206: LD_ADDR_VAR 0 29
44210: PUSH
44211: LD_INT 4
44213: PUSH
44214: LD_INT 0
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 4
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 5
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 5
44244: PUSH
44245: LD_INT 1
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 4
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 3
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: EMPTY
44269: LIST
44270: LIST
44271: PUSH
44272: LD_INT 3
44274: PUSH
44275: LD_INT 1
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 3
44285: PUSH
44286: LD_INT 2
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 5
44296: PUSH
44297: LD_INT 2
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 3
44306: PUSH
44307: LD_INT 3
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 3
44316: PUSH
44317: LD_INT 2
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 4
44326: PUSH
44327: LD_INT 3
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 4
44336: PUSH
44337: LD_INT 4
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 3
44346: PUSH
44347: LD_INT 4
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 2
44356: PUSH
44357: LD_INT 3
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_INT 2
44366: PUSH
44367: LD_INT 2
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 4
44376: PUSH
44377: LD_INT 2
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 2
44386: PUSH
44387: LD_INT 4
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: LD_INT 4
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 0
44406: PUSH
44407: LD_INT 3
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: LD_INT 5
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 0
44436: PUSH
44437: LD_INT 5
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: NEG
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 1
44457: NEG
44458: PUSH
44459: LD_INT 3
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: LD_INT 5
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: PUSH
44476: LD_INT 2
44478: NEG
44479: PUSH
44480: LD_INT 3
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: LD_INT 3
44489: NEG
44490: PUSH
44491: LD_INT 0
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 3
44500: NEG
44501: PUSH
44502: LD_INT 1
44504: NEG
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 2
44512: NEG
44513: PUSH
44514: LD_INT 0
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 2
44523: NEG
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 3
44534: NEG
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 4
44545: NEG
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 4
44556: NEG
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 4
44568: NEG
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 2
44580: NEG
44581: PUSH
44582: LD_INT 2
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 4
44591: NEG
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 4
44603: NEG
44604: PUSH
44605: LD_INT 5
44607: NEG
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 3
44615: NEG
44616: PUSH
44617: LD_INT 4
44619: NEG
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 3
44627: NEG
44628: PUSH
44629: LD_INT 3
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 4
44639: NEG
44640: PUSH
44641: LD_INT 3
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 5
44651: NEG
44652: PUSH
44653: LD_INT 4
44655: NEG
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 5
44663: NEG
44664: PUSH
44665: LD_INT 5
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 3
44675: NEG
44676: PUSH
44677: LD_INT 5
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 5
44687: NEG
44688: PUSH
44689: LD_INT 3
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44744: LD_ADDR_VAR 0 30
44748: PUSH
44749: LD_INT 4
44751: PUSH
44752: LD_INT 4
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 4
44761: PUSH
44762: LD_INT 3
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 5
44771: PUSH
44772: LD_INT 4
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 5
44781: PUSH
44782: LD_INT 5
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PUSH
44789: LD_INT 4
44791: PUSH
44792: LD_INT 5
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: PUSH
44799: LD_INT 3
44801: PUSH
44802: LD_INT 4
44804: PUSH
44805: EMPTY
44806: LIST
44807: LIST
44808: PUSH
44809: LD_INT 3
44811: PUSH
44812: LD_INT 3
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 5
44821: PUSH
44822: LD_INT 3
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 3
44831: PUSH
44832: LD_INT 5
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 0
44841: PUSH
44842: LD_INT 3
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 0
44851: PUSH
44852: LD_INT 2
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 1
44861: PUSH
44862: LD_INT 3
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 1
44871: PUSH
44872: LD_INT 4
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 0
44881: PUSH
44882: LD_INT 4
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 1
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 1
44902: NEG
44903: PUSH
44904: LD_INT 2
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 2
44913: PUSH
44914: LD_INT 4
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 2
44923: NEG
44924: PUSH
44925: LD_INT 2
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 4
44934: NEG
44935: PUSH
44936: LD_INT 0
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 4
44945: NEG
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 3
44957: NEG
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 3
44968: NEG
44969: PUSH
44970: LD_INT 1
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 4
44979: NEG
44980: PUSH
44981: LD_INT 1
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 5
44990: NEG
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 5
45001: NEG
45002: PUSH
45003: LD_INT 1
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 5
45013: NEG
45014: PUSH
45015: LD_INT 2
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 3
45025: NEG
45026: PUSH
45027: LD_INT 2
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: NEG
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 3
45048: NEG
45049: PUSH
45050: LD_INT 4
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 2
45060: NEG
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 2
45072: NEG
45073: PUSH
45074: LD_INT 2
45076: NEG
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 3
45084: NEG
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 4
45096: NEG
45097: PUSH
45098: LD_INT 3
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 4
45108: NEG
45109: PUSH
45110: LD_INT 4
45112: NEG
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: LD_INT 4
45124: NEG
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 4
45132: NEG
45133: PUSH
45134: LD_INT 2
45136: NEG
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: PUSH
45142: LD_INT 0
45144: PUSH
45145: LD_INT 4
45147: NEG
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 1
45166: PUSH
45167: LD_INT 4
45169: NEG
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 1
45177: PUSH
45178: LD_INT 3
45180: NEG
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: LD_INT 0
45188: PUSH
45189: LD_INT 3
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 1
45199: NEG
45200: PUSH
45201: LD_INT 4
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 1
45211: NEG
45212: PUSH
45213: LD_INT 5
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 2
45223: PUSH
45224: LD_INT 3
45226: NEG
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 2
45234: NEG
45235: PUSH
45236: LD_INT 5
45238: NEG
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45291: LD_ADDR_VAR 0 31
45295: PUSH
45296: LD_INT 0
45298: PUSH
45299: LD_INT 4
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 0
45308: PUSH
45309: LD_INT 3
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 1
45318: PUSH
45319: LD_INT 4
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 1
45328: PUSH
45329: LD_INT 5
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 0
45338: PUSH
45339: LD_INT 5
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 1
45348: NEG
45349: PUSH
45350: LD_INT 4
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 1
45359: NEG
45360: PUSH
45361: LD_INT 3
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: LD_INT 2
45370: PUSH
45371: LD_INT 5
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 2
45380: NEG
45381: PUSH
45382: LD_INT 3
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 3
45391: NEG
45392: PUSH
45393: LD_INT 0
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PUSH
45400: LD_INT 3
45402: NEG
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 2
45414: NEG
45415: PUSH
45416: LD_INT 0
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 2
45425: NEG
45426: PUSH
45427: LD_INT 1
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 3
45436: NEG
45437: PUSH
45438: LD_INT 1
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 4
45447: NEG
45448: PUSH
45449: LD_INT 0
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 4
45458: NEG
45459: PUSH
45460: LD_INT 1
45462: NEG
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 4
45470: NEG
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 2
45482: NEG
45483: PUSH
45484: LD_INT 2
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 4
45493: NEG
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 4
45505: NEG
45506: PUSH
45507: LD_INT 5
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 3
45517: NEG
45518: PUSH
45519: LD_INT 4
45521: NEG
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 3
45529: NEG
45530: PUSH
45531: LD_INT 3
45533: NEG
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: LD_INT 3
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 5
45553: NEG
45554: PUSH
45555: LD_INT 4
45557: NEG
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 5
45565: NEG
45566: PUSH
45567: LD_INT 5
45569: NEG
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 3
45577: NEG
45578: PUSH
45579: LD_INT 5
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 5
45589: NEG
45590: PUSH
45591: LD_INT 3
45593: NEG
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 0
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 0
45612: PUSH
45613: LD_INT 4
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: LD_INT 3
45626: NEG
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: LD_INT 2
45637: NEG
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 0
45645: PUSH
45646: LD_INT 2
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 1
45656: NEG
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 1
45668: NEG
45669: PUSH
45670: LD_INT 4
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 2
45680: PUSH
45681: LD_INT 2
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 2
45691: NEG
45692: PUSH
45693: LD_INT 4
45695: NEG
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 4
45703: PUSH
45704: LD_INT 0
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 4
45713: PUSH
45714: LD_INT 1
45716: NEG
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 5
45724: PUSH
45725: LD_INT 0
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 5
45734: PUSH
45735: LD_INT 1
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 4
45744: PUSH
45745: LD_INT 1
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 3
45754: PUSH
45755: LD_INT 0
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 3
45764: PUSH
45765: LD_INT 1
45767: NEG
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 3
45775: PUSH
45776: LD_INT 2
45778: NEG
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PUSH
45784: LD_INT 5
45786: PUSH
45787: LD_INT 2
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45841: LD_ADDR_VAR 0 32
45845: PUSH
45846: LD_INT 4
45848: NEG
45849: PUSH
45850: LD_INT 0
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 4
45859: NEG
45860: PUSH
45861: LD_INT 1
45863: NEG
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: NEG
45872: PUSH
45873: LD_INT 0
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 3
45882: NEG
45883: PUSH
45884: LD_INT 1
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 4
45893: NEG
45894: PUSH
45895: LD_INT 1
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 5
45904: NEG
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 5
45915: NEG
45916: PUSH
45917: LD_INT 1
45919: NEG
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 5
45927: NEG
45928: PUSH
45929: LD_INT 2
45931: NEG
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: LD_INT 3
45939: NEG
45940: PUSH
45941: LD_INT 2
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 3
45950: NEG
45951: PUSH
45952: LD_INT 3
45954: NEG
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 3
45962: NEG
45963: PUSH
45964: LD_INT 4
45966: NEG
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 2
45974: NEG
45975: PUSH
45976: LD_INT 3
45978: NEG
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 2
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 4
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: LD_INT 4
46022: NEG
46023: PUSH
46024: LD_INT 4
46026: NEG
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 2
46034: NEG
46035: PUSH
46036: LD_INT 4
46038: NEG
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 4
46046: NEG
46047: PUSH
46048: LD_INT 2
46050: NEG
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: LD_INT 4
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: LD_INT 5
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 1
46080: PUSH
46081: LD_INT 4
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 1
46091: PUSH
46092: LD_INT 3
46094: NEG
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 0
46102: PUSH
46103: LD_INT 3
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 4
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: NEG
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 2
46148: NEG
46149: PUSH
46150: LD_INT 5
46152: NEG
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 4
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 4
46191: PUSH
46192: LD_INT 1
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: LD_INT 1
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: LD_INT 0
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 2
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 2
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: LD_INT 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 4
46263: PUSH
46264: LD_INT 3
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: LD_INT 4
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 4
46293: PUSH
46294: LD_INT 5
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: PUSH
46304: LD_INT 4
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 3
46313: PUSH
46314: LD_INT 3
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 5
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 3
46333: PUSH
46334: LD_INT 5
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46388: LD_ADDR_VAR 0 33
46392: PUSH
46393: LD_INT 4
46395: NEG
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PUSH
46405: LD_INT 4
46407: NEG
46408: PUSH
46409: LD_INT 5
46411: NEG
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: LD_INT 3
46419: NEG
46420: PUSH
46421: LD_INT 4
46423: NEG
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: NEG
46432: PUSH
46433: LD_INT 3
46435: NEG
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 4
46443: NEG
46444: PUSH
46445: LD_INT 3
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: LD_INT 5
46455: NEG
46456: PUSH
46457: LD_INT 4
46459: NEG
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: PUSH
46465: LD_INT 5
46467: NEG
46468: PUSH
46469: LD_INT 5
46471: NEG
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 3
46479: NEG
46480: PUSH
46481: LD_INT 5
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 5
46491: NEG
46492: PUSH
46493: LD_INT 3
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 0
46503: PUSH
46504: LD_INT 3
46506: NEG
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 0
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 1
46525: PUSH
46526: LD_INT 3
46528: NEG
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: LD_INT 2
46539: NEG
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: LD_INT 2
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 1
46558: NEG
46559: PUSH
46560: LD_INT 3
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 1
46570: NEG
46571: PUSH
46572: LD_INT 4
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 2
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 2
46593: NEG
46594: PUSH
46595: LD_INT 4
46597: NEG
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 4
46605: PUSH
46606: LD_INT 0
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 4
46615: PUSH
46616: LD_INT 1
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 5
46626: PUSH
46627: LD_INT 0
46629: PUSH
46630: EMPTY
46631: LIST
46632: LIST
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 1
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 4
46646: PUSH
46647: LD_INT 1
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: LD_INT 3
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: LD_INT 3
46666: PUSH
46667: LD_INT 1
46669: NEG
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 3
46677: PUSH
46678: LD_INT 2
46680: NEG
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 5
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 3
46698: PUSH
46699: LD_INT 3
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PUSH
46706: LD_INT 3
46708: PUSH
46709: LD_INT 2
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: PUSH
46716: LD_INT 4
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: PUSH
46726: LD_INT 4
46728: PUSH
46729: LD_INT 4
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: PUSH
46736: LD_INT 3
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 2
46748: PUSH
46749: LD_INT 3
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 2
46758: PUSH
46759: LD_INT 2
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: LD_INT 4
46768: PUSH
46769: LD_INT 2
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 2
46778: PUSH
46779: LD_INT 4
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: LD_INT 0
46788: PUSH
46789: LD_INT 4
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: LD_INT 0
46798: PUSH
46799: LD_INT 3
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 1
46808: PUSH
46809: LD_INT 4
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: LD_INT 5
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 0
46828: PUSH
46829: LD_INT 5
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 1
46838: NEG
46839: PUSH
46840: LD_INT 4
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 1
46849: NEG
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: LD_INT 5
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 2
46870: NEG
46871: PUSH
46872: LD_INT 3
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46926: LD_ADDR_VAR 0 34
46930: PUSH
46931: LD_INT 0
46933: PUSH
46934: LD_INT 4
46936: NEG
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 0
46944: PUSH
46945: LD_INT 5
46947: NEG
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 1
46955: PUSH
46956: LD_INT 4
46958: NEG
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PUSH
46964: LD_INT 1
46966: PUSH
46967: LD_INT 3
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 0
46977: PUSH
46978: LD_INT 3
46980: NEG
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 1
46988: NEG
46989: PUSH
46990: LD_INT 4
46992: NEG
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 1
47000: NEG
47001: PUSH
47002: LD_INT 5
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 2
47012: PUSH
47013: LD_INT 3
47015: NEG
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 2
47023: NEG
47024: PUSH
47025: LD_INT 5
47027: NEG
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 3
47035: PUSH
47036: LD_INT 0
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 3
47045: PUSH
47046: LD_INT 1
47048: NEG
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 4
47056: PUSH
47057: LD_INT 0
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: LD_INT 4
47066: PUSH
47067: LD_INT 1
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 3
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: PUSH
47084: LD_INT 2
47086: PUSH
47087: LD_INT 0
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PUSH
47094: LD_INT 2
47096: PUSH
47097: LD_INT 1
47099: NEG
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PUSH
47105: LD_INT 2
47107: PUSH
47108: LD_INT 2
47110: NEG
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: PUSH
47116: LD_INT 4
47118: PUSH
47119: LD_INT 2
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 4
47128: PUSH
47129: LD_INT 4
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PUSH
47136: LD_INT 4
47138: PUSH
47139: LD_INT 3
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 5
47148: PUSH
47149: LD_INT 4
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 5
47158: PUSH
47159: LD_INT 5
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 4
47168: PUSH
47169: LD_INT 5
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 3
47178: PUSH
47179: LD_INT 4
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 3
47188: PUSH
47189: LD_INT 3
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: PUSH
47196: LD_INT 5
47198: PUSH
47199: LD_INT 3
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PUSH
47206: LD_INT 3
47208: PUSH
47209: LD_INT 5
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 0
47218: PUSH
47219: LD_INT 3
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: LD_INT 0
47228: PUSH
47229: LD_INT 2
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PUSH
47236: LD_INT 1
47238: PUSH
47239: LD_INT 3
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 1
47248: PUSH
47249: LD_INT 4
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 0
47258: PUSH
47259: LD_INT 4
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PUSH
47266: LD_INT 1
47268: NEG
47269: PUSH
47270: LD_INT 3
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 1
47279: NEG
47280: PUSH
47281: LD_INT 2
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 2
47290: PUSH
47291: LD_INT 4
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 2
47300: NEG
47301: PUSH
47302: LD_INT 2
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: PUSH
47309: LD_INT 4
47311: NEG
47312: PUSH
47313: LD_INT 0
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: LD_INT 4
47322: NEG
47323: PUSH
47324: LD_INT 1
47326: NEG
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: PUSH
47332: LD_INT 3
47334: NEG
47335: PUSH
47336: LD_INT 0
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: LD_INT 3
47345: NEG
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_INT 4
47356: NEG
47357: PUSH
47358: LD_INT 1
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 5
47367: NEG
47368: PUSH
47369: LD_INT 0
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 5
47378: NEG
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 5
47390: NEG
47391: PUSH
47392: LD_INT 2
47394: NEG
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 3
47402: NEG
47403: PUSH
47404: LD_INT 2
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: ST_TO_ADDR
// end ; end ;
47458: GO 47461
47460: POP
// case btype of b_depot , b_warehouse :
47461: LD_VAR 0 1
47465: PUSH
47466: LD_INT 0
47468: DOUBLE
47469: EQUAL
47470: IFTRUE 47480
47472: LD_INT 1
47474: DOUBLE
47475: EQUAL
47476: IFTRUE 47480
47478: GO 47681
47480: POP
// case nation of nation_american :
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 1
47488: DOUBLE
47489: EQUAL
47490: IFTRUE 47494
47492: GO 47550
47494: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47495: LD_ADDR_VAR 0 9
47499: PUSH
47500: LD_VAR 0 11
47504: PUSH
47505: LD_VAR 0 12
47509: PUSH
47510: LD_VAR 0 13
47514: PUSH
47515: LD_VAR 0 14
47519: PUSH
47520: LD_VAR 0 15
47524: PUSH
47525: LD_VAR 0 16
47529: PUSH
47530: EMPTY
47531: LIST
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: PUSH
47538: LD_VAR 0 4
47542: PUSH
47543: LD_INT 1
47545: PLUS
47546: ARRAY
47547: ST_TO_ADDR
47548: GO 47679
47550: LD_INT 2
47552: DOUBLE
47553: EQUAL
47554: IFTRUE 47558
47556: GO 47614
47558: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47559: LD_ADDR_VAR 0 9
47563: PUSH
47564: LD_VAR 0 17
47568: PUSH
47569: LD_VAR 0 18
47573: PUSH
47574: LD_VAR 0 19
47578: PUSH
47579: LD_VAR 0 20
47583: PUSH
47584: LD_VAR 0 21
47588: PUSH
47589: LD_VAR 0 22
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: PUSH
47602: LD_VAR 0 4
47606: PUSH
47607: LD_INT 1
47609: PLUS
47610: ARRAY
47611: ST_TO_ADDR
47612: GO 47679
47614: LD_INT 3
47616: DOUBLE
47617: EQUAL
47618: IFTRUE 47622
47620: GO 47678
47622: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47623: LD_ADDR_VAR 0 9
47627: PUSH
47628: LD_VAR 0 23
47632: PUSH
47633: LD_VAR 0 24
47637: PUSH
47638: LD_VAR 0 25
47642: PUSH
47643: LD_VAR 0 26
47647: PUSH
47648: LD_VAR 0 27
47652: PUSH
47653: LD_VAR 0 28
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: PUSH
47666: LD_VAR 0 4
47670: PUSH
47671: LD_INT 1
47673: PLUS
47674: ARRAY
47675: ST_TO_ADDR
47676: GO 47679
47678: POP
47679: GO 48234
47681: LD_INT 2
47683: DOUBLE
47684: EQUAL
47685: IFTRUE 47695
47687: LD_INT 3
47689: DOUBLE
47690: EQUAL
47691: IFTRUE 47695
47693: GO 47751
47695: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47696: LD_ADDR_VAR 0 9
47700: PUSH
47701: LD_VAR 0 29
47705: PUSH
47706: LD_VAR 0 30
47710: PUSH
47711: LD_VAR 0 31
47715: PUSH
47716: LD_VAR 0 32
47720: PUSH
47721: LD_VAR 0 33
47725: PUSH
47726: LD_VAR 0 34
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: PUSH
47739: LD_VAR 0 4
47743: PUSH
47744: LD_INT 1
47746: PLUS
47747: ARRAY
47748: ST_TO_ADDR
47749: GO 48234
47751: LD_INT 16
47753: DOUBLE
47754: EQUAL
47755: IFTRUE 47813
47757: LD_INT 17
47759: DOUBLE
47760: EQUAL
47761: IFTRUE 47813
47763: LD_INT 18
47765: DOUBLE
47766: EQUAL
47767: IFTRUE 47813
47769: LD_INT 19
47771: DOUBLE
47772: EQUAL
47773: IFTRUE 47813
47775: LD_INT 22
47777: DOUBLE
47778: EQUAL
47779: IFTRUE 47813
47781: LD_INT 20
47783: DOUBLE
47784: EQUAL
47785: IFTRUE 47813
47787: LD_INT 21
47789: DOUBLE
47790: EQUAL
47791: IFTRUE 47813
47793: LD_INT 23
47795: DOUBLE
47796: EQUAL
47797: IFTRUE 47813
47799: LD_INT 24
47801: DOUBLE
47802: EQUAL
47803: IFTRUE 47813
47805: LD_INT 25
47807: DOUBLE
47808: EQUAL
47809: IFTRUE 47813
47811: GO 47869
47813: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47814: LD_ADDR_VAR 0 9
47818: PUSH
47819: LD_VAR 0 35
47823: PUSH
47824: LD_VAR 0 36
47828: PUSH
47829: LD_VAR 0 37
47833: PUSH
47834: LD_VAR 0 38
47838: PUSH
47839: LD_VAR 0 39
47843: PUSH
47844: LD_VAR 0 40
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: PUSH
47857: LD_VAR 0 4
47861: PUSH
47862: LD_INT 1
47864: PLUS
47865: ARRAY
47866: ST_TO_ADDR
47867: GO 48234
47869: LD_INT 6
47871: DOUBLE
47872: EQUAL
47873: IFTRUE 47925
47875: LD_INT 7
47877: DOUBLE
47878: EQUAL
47879: IFTRUE 47925
47881: LD_INT 8
47883: DOUBLE
47884: EQUAL
47885: IFTRUE 47925
47887: LD_INT 13
47889: DOUBLE
47890: EQUAL
47891: IFTRUE 47925
47893: LD_INT 12
47895: DOUBLE
47896: EQUAL
47897: IFTRUE 47925
47899: LD_INT 15
47901: DOUBLE
47902: EQUAL
47903: IFTRUE 47925
47905: LD_INT 11
47907: DOUBLE
47908: EQUAL
47909: IFTRUE 47925
47911: LD_INT 14
47913: DOUBLE
47914: EQUAL
47915: IFTRUE 47925
47917: LD_INT 10
47919: DOUBLE
47920: EQUAL
47921: IFTRUE 47925
47923: GO 47981
47925: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47926: LD_ADDR_VAR 0 9
47930: PUSH
47931: LD_VAR 0 41
47935: PUSH
47936: LD_VAR 0 42
47940: PUSH
47941: LD_VAR 0 43
47945: PUSH
47946: LD_VAR 0 44
47950: PUSH
47951: LD_VAR 0 45
47955: PUSH
47956: LD_VAR 0 46
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: PUSH
47969: LD_VAR 0 4
47973: PUSH
47974: LD_INT 1
47976: PLUS
47977: ARRAY
47978: ST_TO_ADDR
47979: GO 48234
47981: LD_INT 36
47983: DOUBLE
47984: EQUAL
47985: IFTRUE 47989
47987: GO 48045
47989: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47990: LD_ADDR_VAR 0 9
47994: PUSH
47995: LD_VAR 0 47
47999: PUSH
48000: LD_VAR 0 48
48004: PUSH
48005: LD_VAR 0 49
48009: PUSH
48010: LD_VAR 0 50
48014: PUSH
48015: LD_VAR 0 51
48019: PUSH
48020: LD_VAR 0 52
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: PUSH
48033: LD_VAR 0 4
48037: PUSH
48038: LD_INT 1
48040: PLUS
48041: ARRAY
48042: ST_TO_ADDR
48043: GO 48234
48045: LD_INT 4
48047: DOUBLE
48048: EQUAL
48049: IFTRUE 48071
48051: LD_INT 5
48053: DOUBLE
48054: EQUAL
48055: IFTRUE 48071
48057: LD_INT 34
48059: DOUBLE
48060: EQUAL
48061: IFTRUE 48071
48063: LD_INT 37
48065: DOUBLE
48066: EQUAL
48067: IFTRUE 48071
48069: GO 48127
48071: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48072: LD_ADDR_VAR 0 9
48076: PUSH
48077: LD_VAR 0 53
48081: PUSH
48082: LD_VAR 0 54
48086: PUSH
48087: LD_VAR 0 55
48091: PUSH
48092: LD_VAR 0 56
48096: PUSH
48097: LD_VAR 0 57
48101: PUSH
48102: LD_VAR 0 58
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: PUSH
48115: LD_VAR 0 4
48119: PUSH
48120: LD_INT 1
48122: PLUS
48123: ARRAY
48124: ST_TO_ADDR
48125: GO 48234
48127: LD_INT 31
48129: DOUBLE
48130: EQUAL
48131: IFTRUE 48177
48133: LD_INT 32
48135: DOUBLE
48136: EQUAL
48137: IFTRUE 48177
48139: LD_INT 33
48141: DOUBLE
48142: EQUAL
48143: IFTRUE 48177
48145: LD_INT 27
48147: DOUBLE
48148: EQUAL
48149: IFTRUE 48177
48151: LD_INT 26
48153: DOUBLE
48154: EQUAL
48155: IFTRUE 48177
48157: LD_INT 28
48159: DOUBLE
48160: EQUAL
48161: IFTRUE 48177
48163: LD_INT 29
48165: DOUBLE
48166: EQUAL
48167: IFTRUE 48177
48169: LD_INT 30
48171: DOUBLE
48172: EQUAL
48173: IFTRUE 48177
48175: GO 48233
48177: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48178: LD_ADDR_VAR 0 9
48182: PUSH
48183: LD_VAR 0 59
48187: PUSH
48188: LD_VAR 0 60
48192: PUSH
48193: LD_VAR 0 61
48197: PUSH
48198: LD_VAR 0 62
48202: PUSH
48203: LD_VAR 0 63
48207: PUSH
48208: LD_VAR 0 64
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: PUSH
48221: LD_VAR 0 4
48225: PUSH
48226: LD_INT 1
48228: PLUS
48229: ARRAY
48230: ST_TO_ADDR
48231: GO 48234
48233: POP
// temp_list2 = [ ] ;
48234: LD_ADDR_VAR 0 10
48238: PUSH
48239: EMPTY
48240: ST_TO_ADDR
// for i in temp_list do
48241: LD_ADDR_VAR 0 8
48245: PUSH
48246: LD_VAR 0 9
48250: PUSH
48251: FOR_IN
48252: IFFALSE 48304
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48254: LD_ADDR_VAR 0 10
48258: PUSH
48259: LD_VAR 0 10
48263: PUSH
48264: LD_VAR 0 8
48268: PUSH
48269: LD_INT 1
48271: ARRAY
48272: PUSH
48273: LD_VAR 0 2
48277: PLUS
48278: PUSH
48279: LD_VAR 0 8
48283: PUSH
48284: LD_INT 2
48286: ARRAY
48287: PUSH
48288: LD_VAR 0 3
48292: PLUS
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: EMPTY
48299: LIST
48300: ADD
48301: ST_TO_ADDR
48302: GO 48251
48304: POP
48305: POP
// result = temp_list2 ;
48306: LD_ADDR_VAR 0 7
48310: PUSH
48311: LD_VAR 0 10
48315: ST_TO_ADDR
// end ;
48316: LD_VAR 0 7
48320: RET
// export function EnemyInRange ( unit , dist ) ; begin
48321: LD_INT 0
48323: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48324: LD_ADDR_VAR 0 3
48328: PUSH
48329: LD_VAR 0 1
48333: PPUSH
48334: CALL_OW 255
48338: PPUSH
48339: LD_VAR 0 1
48343: PPUSH
48344: CALL_OW 250
48348: PPUSH
48349: LD_VAR 0 1
48353: PPUSH
48354: CALL_OW 251
48358: PPUSH
48359: LD_VAR 0 2
48363: PPUSH
48364: CALL 22425 0 4
48368: PUSH
48369: LD_INT 4
48371: ARRAY
48372: ST_TO_ADDR
// end ;
48373: LD_VAR 0 3
48377: RET
// export function PlayerSeeMe ( unit ) ; begin
48378: LD_INT 0
48380: PPUSH
// result := See ( your_side , unit ) ;
48381: LD_ADDR_VAR 0 2
48385: PUSH
48386: LD_OWVAR 2
48390: PPUSH
48391: LD_VAR 0 1
48395: PPUSH
48396: CALL_OW 292
48400: ST_TO_ADDR
// end ;
48401: LD_VAR 0 2
48405: RET
// export function ReverseDir ( unit ) ; begin
48406: LD_INT 0
48408: PPUSH
// if not unit then
48409: LD_VAR 0 1
48413: NOT
48414: IFFALSE 48418
// exit ;
48416: GO 48441
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48418: LD_ADDR_VAR 0 2
48422: PUSH
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL_OW 254
48432: PUSH
48433: LD_INT 3
48435: PLUS
48436: PUSH
48437: LD_INT 6
48439: MOD
48440: ST_TO_ADDR
// end ;
48441: LD_VAR 0 2
48445: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48446: LD_INT 0
48448: PPUSH
48449: PPUSH
48450: PPUSH
48451: PPUSH
48452: PPUSH
// if not hexes then
48453: LD_VAR 0 2
48457: NOT
48458: IFFALSE 48462
// exit ;
48460: GO 48610
// dist := 9999 ;
48462: LD_ADDR_VAR 0 5
48466: PUSH
48467: LD_INT 9999
48469: ST_TO_ADDR
// for i = 1 to hexes do
48470: LD_ADDR_VAR 0 4
48474: PUSH
48475: DOUBLE
48476: LD_INT 1
48478: DEC
48479: ST_TO_ADDR
48480: LD_VAR 0 2
48484: PUSH
48485: FOR_TO
48486: IFFALSE 48598
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48488: LD_VAR 0 1
48492: PPUSH
48493: LD_VAR 0 2
48497: PUSH
48498: LD_VAR 0 4
48502: ARRAY
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PPUSH
48508: LD_VAR 0 2
48512: PUSH
48513: LD_VAR 0 4
48517: ARRAY
48518: PUSH
48519: LD_INT 2
48521: ARRAY
48522: PPUSH
48523: CALL_OW 297
48527: PUSH
48528: LD_VAR 0 5
48532: LESS
48533: IFFALSE 48596
// begin hex := hexes [ i ] ;
48535: LD_ADDR_VAR 0 7
48539: PUSH
48540: LD_VAR 0 2
48544: PUSH
48545: LD_VAR 0 4
48549: ARRAY
48550: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48551: LD_ADDR_VAR 0 5
48555: PUSH
48556: LD_VAR 0 1
48560: PPUSH
48561: LD_VAR 0 2
48565: PUSH
48566: LD_VAR 0 4
48570: ARRAY
48571: PUSH
48572: LD_INT 1
48574: ARRAY
48575: PPUSH
48576: LD_VAR 0 2
48580: PUSH
48581: LD_VAR 0 4
48585: ARRAY
48586: PUSH
48587: LD_INT 2
48589: ARRAY
48590: PPUSH
48591: CALL_OW 297
48595: ST_TO_ADDR
// end ; end ;
48596: GO 48485
48598: POP
48599: POP
// result := hex ;
48600: LD_ADDR_VAR 0 3
48604: PUSH
48605: LD_VAR 0 7
48609: ST_TO_ADDR
// end ;
48610: LD_VAR 0 3
48614: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48615: LD_INT 0
48617: PPUSH
48618: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48619: LD_VAR 0 1
48623: NOT
48624: PUSH
48625: LD_VAR 0 1
48629: PUSH
48630: LD_INT 21
48632: PUSH
48633: LD_INT 2
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: PUSH
48640: LD_INT 23
48642: PUSH
48643: LD_INT 2
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PPUSH
48654: CALL_OW 69
48658: IN
48659: NOT
48660: OR
48661: IFFALSE 48665
// exit ;
48663: GO 48712
// for i = 1 to 3 do
48665: LD_ADDR_VAR 0 3
48669: PUSH
48670: DOUBLE
48671: LD_INT 1
48673: DEC
48674: ST_TO_ADDR
48675: LD_INT 3
48677: PUSH
48678: FOR_TO
48679: IFFALSE 48710
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48681: LD_VAR 0 1
48685: PPUSH
48686: CALL_OW 250
48690: PPUSH
48691: LD_VAR 0 1
48695: PPUSH
48696: CALL_OW 251
48700: PPUSH
48701: LD_INT 1
48703: PPUSH
48704: CALL_OW 453
48708: GO 48678
48710: POP
48711: POP
// end ;
48712: LD_VAR 0 2
48716: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48717: LD_INT 0
48719: PPUSH
48720: PPUSH
48721: PPUSH
48722: PPUSH
48723: PPUSH
48724: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48725: LD_VAR 0 1
48729: NOT
48730: PUSH
48731: LD_VAR 0 2
48735: NOT
48736: OR
48737: PUSH
48738: LD_VAR 0 1
48742: PPUSH
48743: CALL_OW 314
48747: OR
48748: IFFALSE 48752
// exit ;
48750: GO 49193
// x := GetX ( enemy_unit ) ;
48752: LD_ADDR_VAR 0 7
48756: PUSH
48757: LD_VAR 0 2
48761: PPUSH
48762: CALL_OW 250
48766: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48767: LD_ADDR_VAR 0 8
48771: PUSH
48772: LD_VAR 0 2
48776: PPUSH
48777: CALL_OW 251
48781: ST_TO_ADDR
// if not x or not y then
48782: LD_VAR 0 7
48786: NOT
48787: PUSH
48788: LD_VAR 0 8
48792: NOT
48793: OR
48794: IFFALSE 48798
// exit ;
48796: GO 49193
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48798: LD_ADDR_VAR 0 6
48802: PUSH
48803: LD_VAR 0 7
48807: PPUSH
48808: LD_INT 0
48810: PPUSH
48811: LD_INT 4
48813: PPUSH
48814: CALL_OW 272
48818: PUSH
48819: LD_VAR 0 8
48823: PPUSH
48824: LD_INT 0
48826: PPUSH
48827: LD_INT 4
48829: PPUSH
48830: CALL_OW 273
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: PUSH
48839: LD_VAR 0 7
48843: PPUSH
48844: LD_INT 1
48846: PPUSH
48847: LD_INT 4
48849: PPUSH
48850: CALL_OW 272
48854: PUSH
48855: LD_VAR 0 8
48859: PPUSH
48860: LD_INT 1
48862: PPUSH
48863: LD_INT 4
48865: PPUSH
48866: CALL_OW 273
48870: PUSH
48871: EMPTY
48872: LIST
48873: LIST
48874: PUSH
48875: LD_VAR 0 7
48879: PPUSH
48880: LD_INT 2
48882: PPUSH
48883: LD_INT 4
48885: PPUSH
48886: CALL_OW 272
48890: PUSH
48891: LD_VAR 0 8
48895: PPUSH
48896: LD_INT 2
48898: PPUSH
48899: LD_INT 4
48901: PPUSH
48902: CALL_OW 273
48906: PUSH
48907: EMPTY
48908: LIST
48909: LIST
48910: PUSH
48911: LD_VAR 0 7
48915: PPUSH
48916: LD_INT 3
48918: PPUSH
48919: LD_INT 4
48921: PPUSH
48922: CALL_OW 272
48926: PUSH
48927: LD_VAR 0 8
48931: PPUSH
48932: LD_INT 3
48934: PPUSH
48935: LD_INT 4
48937: PPUSH
48938: CALL_OW 273
48942: PUSH
48943: EMPTY
48944: LIST
48945: LIST
48946: PUSH
48947: LD_VAR 0 7
48951: PPUSH
48952: LD_INT 4
48954: PPUSH
48955: LD_INT 4
48957: PPUSH
48958: CALL_OW 272
48962: PUSH
48963: LD_VAR 0 8
48967: PPUSH
48968: LD_INT 4
48970: PPUSH
48971: LD_INT 4
48973: PPUSH
48974: CALL_OW 273
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_VAR 0 7
48987: PPUSH
48988: LD_INT 5
48990: PPUSH
48991: LD_INT 4
48993: PPUSH
48994: CALL_OW 272
48998: PUSH
48999: LD_VAR 0 8
49003: PPUSH
49004: LD_INT 5
49006: PPUSH
49007: LD_INT 4
49009: PPUSH
49010: CALL_OW 273
49014: PUSH
49015: EMPTY
49016: LIST
49017: LIST
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: LIST
49023: LIST
49024: LIST
49025: LIST
49026: ST_TO_ADDR
// for i = tmp downto 1 do
49027: LD_ADDR_VAR 0 4
49031: PUSH
49032: DOUBLE
49033: LD_VAR 0 6
49037: INC
49038: ST_TO_ADDR
49039: LD_INT 1
49041: PUSH
49042: FOR_DOWNTO
49043: IFFALSE 49144
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49045: LD_VAR 0 6
49049: PUSH
49050: LD_VAR 0 4
49054: ARRAY
49055: PUSH
49056: LD_INT 1
49058: ARRAY
49059: PPUSH
49060: LD_VAR 0 6
49064: PUSH
49065: LD_VAR 0 4
49069: ARRAY
49070: PUSH
49071: LD_INT 2
49073: ARRAY
49074: PPUSH
49075: CALL_OW 488
49079: NOT
49080: PUSH
49081: LD_VAR 0 6
49085: PUSH
49086: LD_VAR 0 4
49090: ARRAY
49091: PUSH
49092: LD_INT 1
49094: ARRAY
49095: PPUSH
49096: LD_VAR 0 6
49100: PUSH
49101: LD_VAR 0 4
49105: ARRAY
49106: PUSH
49107: LD_INT 2
49109: ARRAY
49110: PPUSH
49111: CALL_OW 428
49115: PUSH
49116: LD_INT 0
49118: NONEQUAL
49119: OR
49120: IFFALSE 49142
// tmp := Delete ( tmp , i ) ;
49122: LD_ADDR_VAR 0 6
49126: PUSH
49127: LD_VAR 0 6
49131: PPUSH
49132: LD_VAR 0 4
49136: PPUSH
49137: CALL_OW 3
49141: ST_TO_ADDR
49142: GO 49042
49144: POP
49145: POP
// j := GetClosestHex ( unit , tmp ) ;
49146: LD_ADDR_VAR 0 5
49150: PUSH
49151: LD_VAR 0 1
49155: PPUSH
49156: LD_VAR 0 6
49160: PPUSH
49161: CALL 48446 0 2
49165: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49166: LD_VAR 0 1
49170: PPUSH
49171: LD_VAR 0 5
49175: PUSH
49176: LD_INT 1
49178: ARRAY
49179: PPUSH
49180: LD_VAR 0 5
49184: PUSH
49185: LD_INT 2
49187: ARRAY
49188: PPUSH
49189: CALL_OW 111
// end ;
49193: LD_VAR 0 3
49197: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49198: LD_INT 0
49200: PPUSH
49201: PPUSH
49202: PPUSH
// uc_side = 0 ;
49203: LD_ADDR_OWVAR 20
49207: PUSH
49208: LD_INT 0
49210: ST_TO_ADDR
// uc_nation = 0 ;
49211: LD_ADDR_OWVAR 21
49215: PUSH
49216: LD_INT 0
49218: ST_TO_ADDR
// InitHc ;
49219: CALL_OW 19
// InitVc ;
49223: CALL_OW 20
// if mastodonts then
49227: LD_VAR 0 6
49231: IFFALSE 49298
// for i = 1 to mastodonts do
49233: LD_ADDR_VAR 0 11
49237: PUSH
49238: DOUBLE
49239: LD_INT 1
49241: DEC
49242: ST_TO_ADDR
49243: LD_VAR 0 6
49247: PUSH
49248: FOR_TO
49249: IFFALSE 49296
// begin vc_chassis := 31 ;
49251: LD_ADDR_OWVAR 37
49255: PUSH
49256: LD_INT 31
49258: ST_TO_ADDR
// vc_control := control_rider ;
49259: LD_ADDR_OWVAR 38
49263: PUSH
49264: LD_INT 4
49266: ST_TO_ADDR
// animal := CreateVehicle ;
49267: LD_ADDR_VAR 0 12
49271: PUSH
49272: CALL_OW 45
49276: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49277: LD_VAR 0 12
49281: PPUSH
49282: LD_VAR 0 8
49286: PPUSH
49287: LD_INT 0
49289: PPUSH
49290: CALL 56076 0 3
// end ;
49294: GO 49248
49296: POP
49297: POP
// if horses then
49298: LD_VAR 0 5
49302: IFFALSE 49369
// for i = 1 to horses do
49304: LD_ADDR_VAR 0 11
49308: PUSH
49309: DOUBLE
49310: LD_INT 1
49312: DEC
49313: ST_TO_ADDR
49314: LD_VAR 0 5
49318: PUSH
49319: FOR_TO
49320: IFFALSE 49367
// begin hc_class := 21 ;
49322: LD_ADDR_OWVAR 28
49326: PUSH
49327: LD_INT 21
49329: ST_TO_ADDR
// hc_gallery :=  ;
49330: LD_ADDR_OWVAR 33
49334: PUSH
49335: LD_STRING 
49337: ST_TO_ADDR
// animal := CreateHuman ;
49338: LD_ADDR_VAR 0 12
49342: PUSH
49343: CALL_OW 44
49347: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49348: LD_VAR 0 12
49352: PPUSH
49353: LD_VAR 0 8
49357: PPUSH
49358: LD_INT 0
49360: PPUSH
49361: CALL 56076 0 3
// end ;
49365: GO 49319
49367: POP
49368: POP
// if birds then
49369: LD_VAR 0 1
49373: IFFALSE 49440
// for i = 1 to birds do
49375: LD_ADDR_VAR 0 11
49379: PUSH
49380: DOUBLE
49381: LD_INT 1
49383: DEC
49384: ST_TO_ADDR
49385: LD_VAR 0 1
49389: PUSH
49390: FOR_TO
49391: IFFALSE 49438
// begin hc_class = 18 ;
49393: LD_ADDR_OWVAR 28
49397: PUSH
49398: LD_INT 18
49400: ST_TO_ADDR
// hc_gallery =  ;
49401: LD_ADDR_OWVAR 33
49405: PUSH
49406: LD_STRING 
49408: ST_TO_ADDR
// animal := CreateHuman ;
49409: LD_ADDR_VAR 0 12
49413: PUSH
49414: CALL_OW 44
49418: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49419: LD_VAR 0 12
49423: PPUSH
49424: LD_VAR 0 8
49428: PPUSH
49429: LD_INT 0
49431: PPUSH
49432: CALL 56076 0 3
// end ;
49436: GO 49390
49438: POP
49439: POP
// if tigers then
49440: LD_VAR 0 2
49444: IFFALSE 49528
// for i = 1 to tigers do
49446: LD_ADDR_VAR 0 11
49450: PUSH
49451: DOUBLE
49452: LD_INT 1
49454: DEC
49455: ST_TO_ADDR
49456: LD_VAR 0 2
49460: PUSH
49461: FOR_TO
49462: IFFALSE 49526
// begin hc_class = class_tiger ;
49464: LD_ADDR_OWVAR 28
49468: PUSH
49469: LD_INT 14
49471: ST_TO_ADDR
// hc_gallery =  ;
49472: LD_ADDR_OWVAR 33
49476: PUSH
49477: LD_STRING 
49479: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49480: LD_ADDR_OWVAR 35
49484: PUSH
49485: LD_INT 7
49487: NEG
49488: PPUSH
49489: LD_INT 7
49491: PPUSH
49492: CALL_OW 12
49496: ST_TO_ADDR
// animal := CreateHuman ;
49497: LD_ADDR_VAR 0 12
49501: PUSH
49502: CALL_OW 44
49506: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49507: LD_VAR 0 12
49511: PPUSH
49512: LD_VAR 0 8
49516: PPUSH
49517: LD_INT 0
49519: PPUSH
49520: CALL 56076 0 3
// end ;
49524: GO 49461
49526: POP
49527: POP
// if apemans then
49528: LD_VAR 0 3
49532: IFFALSE 49655
// for i = 1 to apemans do
49534: LD_ADDR_VAR 0 11
49538: PUSH
49539: DOUBLE
49540: LD_INT 1
49542: DEC
49543: ST_TO_ADDR
49544: LD_VAR 0 3
49548: PUSH
49549: FOR_TO
49550: IFFALSE 49653
// begin hc_class = class_apeman ;
49552: LD_ADDR_OWVAR 28
49556: PUSH
49557: LD_INT 12
49559: ST_TO_ADDR
// hc_gallery =  ;
49560: LD_ADDR_OWVAR 33
49564: PUSH
49565: LD_STRING 
49567: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49568: LD_ADDR_OWVAR 35
49572: PUSH
49573: LD_INT 5
49575: NEG
49576: PPUSH
49577: LD_INT 5
49579: PPUSH
49580: CALL_OW 12
49584: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49585: LD_ADDR_OWVAR 31
49589: PUSH
49590: LD_INT 1
49592: PPUSH
49593: LD_INT 3
49595: PPUSH
49596: CALL_OW 12
49600: PUSH
49601: LD_INT 1
49603: PPUSH
49604: LD_INT 3
49606: PPUSH
49607: CALL_OW 12
49611: PUSH
49612: LD_INT 0
49614: PUSH
49615: LD_INT 0
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: ST_TO_ADDR
// animal := CreateHuman ;
49624: LD_ADDR_VAR 0 12
49628: PUSH
49629: CALL_OW 44
49633: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49634: LD_VAR 0 12
49638: PPUSH
49639: LD_VAR 0 8
49643: PPUSH
49644: LD_INT 0
49646: PPUSH
49647: CALL 56076 0 3
// end ;
49651: GO 49549
49653: POP
49654: POP
// if enchidnas then
49655: LD_VAR 0 4
49659: IFFALSE 49726
// for i = 1 to enchidnas do
49661: LD_ADDR_VAR 0 11
49665: PUSH
49666: DOUBLE
49667: LD_INT 1
49669: DEC
49670: ST_TO_ADDR
49671: LD_VAR 0 4
49675: PUSH
49676: FOR_TO
49677: IFFALSE 49724
// begin hc_class = 13 ;
49679: LD_ADDR_OWVAR 28
49683: PUSH
49684: LD_INT 13
49686: ST_TO_ADDR
// hc_gallery =  ;
49687: LD_ADDR_OWVAR 33
49691: PUSH
49692: LD_STRING 
49694: ST_TO_ADDR
// animal := CreateHuman ;
49695: LD_ADDR_VAR 0 12
49699: PUSH
49700: CALL_OW 44
49704: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49705: LD_VAR 0 12
49709: PPUSH
49710: LD_VAR 0 8
49714: PPUSH
49715: LD_INT 0
49717: PPUSH
49718: CALL 56076 0 3
// end ;
49722: GO 49676
49724: POP
49725: POP
// if fishes then
49726: LD_VAR 0 7
49730: IFFALSE 49797
// for i = 1 to fishes do
49732: LD_ADDR_VAR 0 11
49736: PUSH
49737: DOUBLE
49738: LD_INT 1
49740: DEC
49741: ST_TO_ADDR
49742: LD_VAR 0 7
49746: PUSH
49747: FOR_TO
49748: IFFALSE 49795
// begin hc_class = 20 ;
49750: LD_ADDR_OWVAR 28
49754: PUSH
49755: LD_INT 20
49757: ST_TO_ADDR
// hc_gallery =  ;
49758: LD_ADDR_OWVAR 33
49762: PUSH
49763: LD_STRING 
49765: ST_TO_ADDR
// animal := CreateHuman ;
49766: LD_ADDR_VAR 0 12
49770: PUSH
49771: CALL_OW 44
49775: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49776: LD_VAR 0 12
49780: PPUSH
49781: LD_VAR 0 9
49785: PPUSH
49786: LD_INT 0
49788: PPUSH
49789: CALL 56076 0 3
// end ;
49793: GO 49747
49795: POP
49796: POP
// end ;
49797: LD_VAR 0 10
49801: RET
// export function WantHeal ( sci , unit ) ; begin
49802: LD_INT 0
49804: PPUSH
// if GetTaskList ( sci ) > 0 then
49805: LD_VAR 0 1
49809: PPUSH
49810: CALL_OW 437
49814: PUSH
49815: LD_INT 0
49817: GREATER
49818: IFFALSE 49888
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49820: LD_VAR 0 1
49824: PPUSH
49825: CALL_OW 437
49829: PUSH
49830: LD_INT 1
49832: ARRAY
49833: PUSH
49834: LD_INT 1
49836: ARRAY
49837: PUSH
49838: LD_STRING l
49840: EQUAL
49841: PUSH
49842: LD_VAR 0 1
49846: PPUSH
49847: CALL_OW 437
49851: PUSH
49852: LD_INT 1
49854: ARRAY
49855: PUSH
49856: LD_INT 4
49858: ARRAY
49859: PUSH
49860: LD_VAR 0 2
49864: EQUAL
49865: AND
49866: IFFALSE 49878
// result := true else
49868: LD_ADDR_VAR 0 3
49872: PUSH
49873: LD_INT 1
49875: ST_TO_ADDR
49876: GO 49886
// result := false ;
49878: LD_ADDR_VAR 0 3
49882: PUSH
49883: LD_INT 0
49885: ST_TO_ADDR
// end else
49886: GO 49896
// result := false ;
49888: LD_ADDR_VAR 0 3
49892: PUSH
49893: LD_INT 0
49895: ST_TO_ADDR
// end ;
49896: LD_VAR 0 3
49900: RET
// export function HealTarget ( sci ) ; begin
49901: LD_INT 0
49903: PPUSH
// if not sci then
49904: LD_VAR 0 1
49908: NOT
49909: IFFALSE 49913
// exit ;
49911: GO 49978
// result := 0 ;
49913: LD_ADDR_VAR 0 2
49917: PUSH
49918: LD_INT 0
49920: ST_TO_ADDR
// if GetTaskList ( sci ) then
49921: LD_VAR 0 1
49925: PPUSH
49926: CALL_OW 437
49930: IFFALSE 49978
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49932: LD_VAR 0 1
49936: PPUSH
49937: CALL_OW 437
49941: PUSH
49942: LD_INT 1
49944: ARRAY
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PUSH
49950: LD_STRING l
49952: EQUAL
49953: IFFALSE 49978
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49955: LD_ADDR_VAR 0 2
49959: PUSH
49960: LD_VAR 0 1
49964: PPUSH
49965: CALL_OW 437
49969: PUSH
49970: LD_INT 1
49972: ARRAY
49973: PUSH
49974: LD_INT 4
49976: ARRAY
49977: ST_TO_ADDR
// end ;
49978: LD_VAR 0 2
49982: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49983: LD_INT 0
49985: PPUSH
49986: PPUSH
49987: PPUSH
49988: PPUSH
49989: PPUSH
49990: PPUSH
49991: PPUSH
49992: PPUSH
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
49999: PPUSH
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
50011: PPUSH
50012: PPUSH
50013: PPUSH
50014: PPUSH
50015: PPUSH
50016: PPUSH
50017: PPUSH
50018: PPUSH
// if not list then
50019: LD_VAR 0 1
50023: NOT
50024: IFFALSE 50028
// exit ;
50026: GO 54687
// base := list [ 1 ] ;
50028: LD_ADDR_VAR 0 3
50032: PUSH
50033: LD_VAR 0 1
50037: PUSH
50038: LD_INT 1
50040: ARRAY
50041: ST_TO_ADDR
// group := list [ 2 ] ;
50042: LD_ADDR_VAR 0 4
50046: PUSH
50047: LD_VAR 0 1
50051: PUSH
50052: LD_INT 2
50054: ARRAY
50055: ST_TO_ADDR
// path := list [ 3 ] ;
50056: LD_ADDR_VAR 0 5
50060: PUSH
50061: LD_VAR 0 1
50065: PUSH
50066: LD_INT 3
50068: ARRAY
50069: ST_TO_ADDR
// flags := list [ 4 ] ;
50070: LD_ADDR_VAR 0 6
50074: PUSH
50075: LD_VAR 0 1
50079: PUSH
50080: LD_INT 4
50082: ARRAY
50083: ST_TO_ADDR
// mined := [ ] ;
50084: LD_ADDR_VAR 0 27
50088: PUSH
50089: EMPTY
50090: ST_TO_ADDR
// bombed := [ ] ;
50091: LD_ADDR_VAR 0 28
50095: PUSH
50096: EMPTY
50097: ST_TO_ADDR
// healers := [ ] ;
50098: LD_ADDR_VAR 0 31
50102: PUSH
50103: EMPTY
50104: ST_TO_ADDR
// to_heal := [ ] ;
50105: LD_ADDR_VAR 0 30
50109: PUSH
50110: EMPTY
50111: ST_TO_ADDR
// repairs := [ ] ;
50112: LD_ADDR_VAR 0 33
50116: PUSH
50117: EMPTY
50118: ST_TO_ADDR
// to_repair := [ ] ;
50119: LD_ADDR_VAR 0 32
50123: PUSH
50124: EMPTY
50125: ST_TO_ADDR
// if not group or not path then
50126: LD_VAR 0 4
50130: NOT
50131: PUSH
50132: LD_VAR 0 5
50136: NOT
50137: OR
50138: IFFALSE 50142
// exit ;
50140: GO 54687
// side := GetSide ( group [ 1 ] ) ;
50142: LD_ADDR_VAR 0 35
50146: PUSH
50147: LD_VAR 0 4
50151: PUSH
50152: LD_INT 1
50154: ARRAY
50155: PPUSH
50156: CALL_OW 255
50160: ST_TO_ADDR
// if flags then
50161: LD_VAR 0 6
50165: IFFALSE 50309
// begin f_ignore_area := flags [ 1 ] ;
50167: LD_ADDR_VAR 0 17
50171: PUSH
50172: LD_VAR 0 6
50176: PUSH
50177: LD_INT 1
50179: ARRAY
50180: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50181: LD_ADDR_VAR 0 18
50185: PUSH
50186: LD_VAR 0 6
50190: PUSH
50191: LD_INT 2
50193: ARRAY
50194: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50195: LD_ADDR_VAR 0 19
50199: PUSH
50200: LD_VAR 0 6
50204: PUSH
50205: LD_INT 3
50207: ARRAY
50208: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50209: LD_ADDR_VAR 0 20
50213: PUSH
50214: LD_VAR 0 6
50218: PUSH
50219: LD_INT 4
50221: ARRAY
50222: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50223: LD_ADDR_VAR 0 21
50227: PUSH
50228: LD_VAR 0 6
50232: PUSH
50233: LD_INT 5
50235: ARRAY
50236: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50237: LD_ADDR_VAR 0 22
50241: PUSH
50242: LD_VAR 0 6
50246: PUSH
50247: LD_INT 6
50249: ARRAY
50250: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50251: LD_ADDR_VAR 0 23
50255: PUSH
50256: LD_VAR 0 6
50260: PUSH
50261: LD_INT 7
50263: ARRAY
50264: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50265: LD_ADDR_VAR 0 24
50269: PUSH
50270: LD_VAR 0 6
50274: PUSH
50275: LD_INT 8
50277: ARRAY
50278: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50279: LD_ADDR_VAR 0 25
50283: PUSH
50284: LD_VAR 0 6
50288: PUSH
50289: LD_INT 9
50291: ARRAY
50292: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50293: LD_ADDR_VAR 0 26
50297: PUSH
50298: LD_VAR 0 6
50302: PUSH
50303: LD_INT 10
50305: ARRAY
50306: ST_TO_ADDR
// end else
50307: GO 50389
// begin f_ignore_area := false ;
50309: LD_ADDR_VAR 0 17
50313: PUSH
50314: LD_INT 0
50316: ST_TO_ADDR
// f_capture := false ;
50317: LD_ADDR_VAR 0 18
50321: PUSH
50322: LD_INT 0
50324: ST_TO_ADDR
// f_ignore_civ := false ;
50325: LD_ADDR_VAR 0 19
50329: PUSH
50330: LD_INT 0
50332: ST_TO_ADDR
// f_murder := false ;
50333: LD_ADDR_VAR 0 20
50337: PUSH
50338: LD_INT 0
50340: ST_TO_ADDR
// f_mines := false ;
50341: LD_ADDR_VAR 0 21
50345: PUSH
50346: LD_INT 0
50348: ST_TO_ADDR
// f_repair := false ;
50349: LD_ADDR_VAR 0 22
50353: PUSH
50354: LD_INT 0
50356: ST_TO_ADDR
// f_heal := false ;
50357: LD_ADDR_VAR 0 23
50361: PUSH
50362: LD_INT 0
50364: ST_TO_ADDR
// f_spacetime := false ;
50365: LD_ADDR_VAR 0 24
50369: PUSH
50370: LD_INT 0
50372: ST_TO_ADDR
// f_attack_depot := false ;
50373: LD_ADDR_VAR 0 25
50377: PUSH
50378: LD_INT 0
50380: ST_TO_ADDR
// f_crawl := false ;
50381: LD_ADDR_VAR 0 26
50385: PUSH
50386: LD_INT 0
50388: ST_TO_ADDR
// end ; if f_heal then
50389: LD_VAR 0 23
50393: IFFALSE 50420
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50395: LD_ADDR_VAR 0 31
50399: PUSH
50400: LD_VAR 0 4
50404: PPUSH
50405: LD_INT 25
50407: PUSH
50408: LD_INT 4
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: PPUSH
50415: CALL_OW 72
50419: ST_TO_ADDR
// if f_repair then
50420: LD_VAR 0 22
50424: IFFALSE 50451
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50426: LD_ADDR_VAR 0 33
50430: PUSH
50431: LD_VAR 0 4
50435: PPUSH
50436: LD_INT 25
50438: PUSH
50439: LD_INT 3
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: PPUSH
50446: CALL_OW 72
50450: ST_TO_ADDR
// units_path := [ ] ;
50451: LD_ADDR_VAR 0 16
50455: PUSH
50456: EMPTY
50457: ST_TO_ADDR
// for i = 1 to group do
50458: LD_ADDR_VAR 0 7
50462: PUSH
50463: DOUBLE
50464: LD_INT 1
50466: DEC
50467: ST_TO_ADDR
50468: LD_VAR 0 4
50472: PUSH
50473: FOR_TO
50474: IFFALSE 50503
// units_path := Replace ( units_path , i , path ) ;
50476: LD_ADDR_VAR 0 16
50480: PUSH
50481: LD_VAR 0 16
50485: PPUSH
50486: LD_VAR 0 7
50490: PPUSH
50491: LD_VAR 0 5
50495: PPUSH
50496: CALL_OW 1
50500: ST_TO_ADDR
50501: GO 50473
50503: POP
50504: POP
// repeat for i = group downto 1 do
50505: LD_ADDR_VAR 0 7
50509: PUSH
50510: DOUBLE
50511: LD_VAR 0 4
50515: INC
50516: ST_TO_ADDR
50517: LD_INT 1
50519: PUSH
50520: FOR_DOWNTO
50521: IFFALSE 54643
// begin wait ( 5 ) ;
50523: LD_INT 5
50525: PPUSH
50526: CALL_OW 67
// tmp := [ ] ;
50530: LD_ADDR_VAR 0 14
50534: PUSH
50535: EMPTY
50536: ST_TO_ADDR
// attacking := false ;
50537: LD_ADDR_VAR 0 29
50541: PUSH
50542: LD_INT 0
50544: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50545: LD_VAR 0 4
50549: PUSH
50550: LD_VAR 0 7
50554: ARRAY
50555: PPUSH
50556: CALL_OW 301
50560: PUSH
50561: LD_VAR 0 4
50565: PUSH
50566: LD_VAR 0 7
50570: ARRAY
50571: NOT
50572: OR
50573: IFFALSE 50682
// begin if GetType ( group [ i ] ) = unit_human then
50575: LD_VAR 0 4
50579: PUSH
50580: LD_VAR 0 7
50584: ARRAY
50585: PPUSH
50586: CALL_OW 247
50590: PUSH
50591: LD_INT 1
50593: EQUAL
50594: IFFALSE 50640
// begin to_heal := to_heal diff group [ i ] ;
50596: LD_ADDR_VAR 0 30
50600: PUSH
50601: LD_VAR 0 30
50605: PUSH
50606: LD_VAR 0 4
50610: PUSH
50611: LD_VAR 0 7
50615: ARRAY
50616: DIFF
50617: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50618: LD_ADDR_VAR 0 31
50622: PUSH
50623: LD_VAR 0 31
50627: PUSH
50628: LD_VAR 0 4
50632: PUSH
50633: LD_VAR 0 7
50637: ARRAY
50638: DIFF
50639: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50640: LD_ADDR_VAR 0 4
50644: PUSH
50645: LD_VAR 0 4
50649: PPUSH
50650: LD_VAR 0 7
50654: PPUSH
50655: CALL_OW 3
50659: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50660: LD_ADDR_VAR 0 16
50664: PUSH
50665: LD_VAR 0 16
50669: PPUSH
50670: LD_VAR 0 7
50674: PPUSH
50675: CALL_OW 3
50679: ST_TO_ADDR
// continue ;
50680: GO 50520
// end ; if f_repair then
50682: LD_VAR 0 22
50686: IFFALSE 51175
// begin if GetType ( group [ i ] ) = unit_vehicle then
50688: LD_VAR 0 4
50692: PUSH
50693: LD_VAR 0 7
50697: ARRAY
50698: PPUSH
50699: CALL_OW 247
50703: PUSH
50704: LD_INT 2
50706: EQUAL
50707: IFFALSE 50897
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50709: LD_VAR 0 4
50713: PUSH
50714: LD_VAR 0 7
50718: ARRAY
50719: PPUSH
50720: CALL_OW 256
50724: PUSH
50725: LD_INT 700
50727: LESS
50728: PUSH
50729: LD_VAR 0 4
50733: PUSH
50734: LD_VAR 0 7
50738: ARRAY
50739: PUSH
50740: LD_VAR 0 32
50744: IN
50745: NOT
50746: AND
50747: IFFALSE 50771
// to_repair := to_repair union group [ i ] ;
50749: LD_ADDR_VAR 0 32
50753: PUSH
50754: LD_VAR 0 32
50758: PUSH
50759: LD_VAR 0 4
50763: PUSH
50764: LD_VAR 0 7
50768: ARRAY
50769: UNION
50770: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50771: LD_VAR 0 4
50775: PUSH
50776: LD_VAR 0 7
50780: ARRAY
50781: PPUSH
50782: CALL_OW 256
50786: PUSH
50787: LD_INT 1000
50789: EQUAL
50790: PUSH
50791: LD_VAR 0 4
50795: PUSH
50796: LD_VAR 0 7
50800: ARRAY
50801: PUSH
50802: LD_VAR 0 32
50806: IN
50807: AND
50808: IFFALSE 50832
// to_repair := to_repair diff group [ i ] ;
50810: LD_ADDR_VAR 0 32
50814: PUSH
50815: LD_VAR 0 32
50819: PUSH
50820: LD_VAR 0 4
50824: PUSH
50825: LD_VAR 0 7
50829: ARRAY
50830: DIFF
50831: ST_TO_ADDR
// if group [ i ] in to_repair then
50832: LD_VAR 0 4
50836: PUSH
50837: LD_VAR 0 7
50841: ARRAY
50842: PUSH
50843: LD_VAR 0 32
50847: IN
50848: IFFALSE 50895
// begin if not IsInArea ( group [ i ] , f_repair ) then
50850: LD_VAR 0 4
50854: PUSH
50855: LD_VAR 0 7
50859: ARRAY
50860: PPUSH
50861: LD_VAR 0 22
50865: PPUSH
50866: CALL_OW 308
50870: NOT
50871: IFFALSE 50893
// ComMoveToArea ( group [ i ] , f_repair ) ;
50873: LD_VAR 0 4
50877: PUSH
50878: LD_VAR 0 7
50882: ARRAY
50883: PPUSH
50884: LD_VAR 0 22
50888: PPUSH
50889: CALL_OW 113
// continue ;
50893: GO 50520
// end ; end else
50895: GO 51175
// if group [ i ] in repairs then
50897: LD_VAR 0 4
50901: PUSH
50902: LD_VAR 0 7
50906: ARRAY
50907: PUSH
50908: LD_VAR 0 33
50912: IN
50913: IFFALSE 51175
// begin if IsInUnit ( group [ i ] ) then
50915: LD_VAR 0 4
50919: PUSH
50920: LD_VAR 0 7
50924: ARRAY
50925: PPUSH
50926: CALL_OW 310
50930: IFFALSE 50998
// begin z := IsInUnit ( group [ i ] ) ;
50932: LD_ADDR_VAR 0 13
50936: PUSH
50937: LD_VAR 0 4
50941: PUSH
50942: LD_VAR 0 7
50946: ARRAY
50947: PPUSH
50948: CALL_OW 310
50952: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50953: LD_VAR 0 13
50957: PUSH
50958: LD_VAR 0 32
50962: IN
50963: PUSH
50964: LD_VAR 0 13
50968: PPUSH
50969: LD_VAR 0 22
50973: PPUSH
50974: CALL_OW 308
50978: AND
50979: IFFALSE 50996
// ComExitVehicle ( group [ i ] ) ;
50981: LD_VAR 0 4
50985: PUSH
50986: LD_VAR 0 7
50990: ARRAY
50991: PPUSH
50992: CALL_OW 121
// end else
50996: GO 51175
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50998: LD_ADDR_VAR 0 13
51002: PUSH
51003: LD_VAR 0 4
51007: PPUSH
51008: LD_INT 95
51010: PUSH
51011: LD_VAR 0 22
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 58
51022: PUSH
51023: EMPTY
51024: LIST
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PPUSH
51030: CALL_OW 72
51034: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51035: LD_VAR 0 4
51039: PUSH
51040: LD_VAR 0 7
51044: ARRAY
51045: PPUSH
51046: CALL_OW 314
51050: NOT
51051: IFFALSE 51173
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51053: LD_ADDR_VAR 0 10
51057: PUSH
51058: LD_VAR 0 13
51062: PPUSH
51063: LD_VAR 0 4
51067: PUSH
51068: LD_VAR 0 7
51072: ARRAY
51073: PPUSH
51074: CALL_OW 74
51078: ST_TO_ADDR
// if not x then
51079: LD_VAR 0 10
51083: NOT
51084: IFFALSE 51088
// continue ;
51086: GO 50520
// if GetLives ( x ) < 1000 then
51088: LD_VAR 0 10
51092: PPUSH
51093: CALL_OW 256
51097: PUSH
51098: LD_INT 1000
51100: LESS
51101: IFFALSE 51125
// ComRepairVehicle ( group [ i ] , x ) else
51103: LD_VAR 0 4
51107: PUSH
51108: LD_VAR 0 7
51112: ARRAY
51113: PPUSH
51114: LD_VAR 0 10
51118: PPUSH
51119: CALL_OW 129
51123: GO 51173
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51125: LD_VAR 0 23
51129: PUSH
51130: LD_VAR 0 4
51134: PUSH
51135: LD_VAR 0 7
51139: ARRAY
51140: PPUSH
51141: CALL_OW 256
51145: PUSH
51146: LD_INT 1000
51148: LESS
51149: AND
51150: NOT
51151: IFFALSE 51173
// ComEnterUnit ( group [ i ] , x ) ;
51153: LD_VAR 0 4
51157: PUSH
51158: LD_VAR 0 7
51162: ARRAY
51163: PPUSH
51164: LD_VAR 0 10
51168: PPUSH
51169: CALL_OW 120
// end ; continue ;
51173: GO 50520
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51175: LD_VAR 0 23
51179: PUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_VAR 0 7
51189: ARRAY
51190: PPUSH
51191: CALL_OW 247
51195: PUSH
51196: LD_INT 1
51198: EQUAL
51199: AND
51200: IFFALSE 51678
// begin if group [ i ] in healers then
51202: LD_VAR 0 4
51206: PUSH
51207: LD_VAR 0 7
51211: ARRAY
51212: PUSH
51213: LD_VAR 0 31
51217: IN
51218: IFFALSE 51491
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51220: LD_VAR 0 4
51224: PUSH
51225: LD_VAR 0 7
51229: ARRAY
51230: PPUSH
51231: LD_VAR 0 23
51235: PPUSH
51236: CALL_OW 308
51240: NOT
51241: PUSH
51242: LD_VAR 0 4
51246: PUSH
51247: LD_VAR 0 7
51251: ARRAY
51252: PPUSH
51253: CALL_OW 314
51257: NOT
51258: AND
51259: IFFALSE 51283
// ComMoveToArea ( group [ i ] , f_heal ) else
51261: LD_VAR 0 4
51265: PUSH
51266: LD_VAR 0 7
51270: ARRAY
51271: PPUSH
51272: LD_VAR 0 23
51276: PPUSH
51277: CALL_OW 113
51281: GO 51489
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51283: LD_VAR 0 4
51287: PUSH
51288: LD_VAR 0 7
51292: ARRAY
51293: PPUSH
51294: CALL 49901 0 1
51298: PPUSH
51299: CALL_OW 256
51303: PUSH
51304: LD_INT 1000
51306: EQUAL
51307: IFFALSE 51326
// ComStop ( group [ i ] ) else
51309: LD_VAR 0 4
51313: PUSH
51314: LD_VAR 0 7
51318: ARRAY
51319: PPUSH
51320: CALL_OW 141
51324: GO 51489
// if not HasTask ( group [ i ] ) and to_heal then
51326: LD_VAR 0 4
51330: PUSH
51331: LD_VAR 0 7
51335: ARRAY
51336: PPUSH
51337: CALL_OW 314
51341: NOT
51342: PUSH
51343: LD_VAR 0 30
51347: AND
51348: IFFALSE 51489
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51350: LD_ADDR_VAR 0 13
51354: PUSH
51355: LD_VAR 0 30
51359: PPUSH
51360: LD_INT 3
51362: PUSH
51363: LD_INT 54
51365: PUSH
51366: EMPTY
51367: LIST
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: PPUSH
51373: CALL_OW 72
51377: PPUSH
51378: LD_VAR 0 4
51382: PUSH
51383: LD_VAR 0 7
51387: ARRAY
51388: PPUSH
51389: CALL_OW 74
51393: ST_TO_ADDR
// if z then
51394: LD_VAR 0 13
51398: IFFALSE 51489
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51400: LD_INT 91
51402: PUSH
51403: LD_VAR 0 13
51407: PUSH
51408: LD_INT 10
51410: PUSH
51411: EMPTY
51412: LIST
51413: LIST
51414: LIST
51415: PUSH
51416: LD_INT 81
51418: PUSH
51419: LD_VAR 0 13
51423: PPUSH
51424: CALL_OW 255
51428: PUSH
51429: EMPTY
51430: LIST
51431: LIST
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PPUSH
51437: CALL_OW 69
51441: PUSH
51442: LD_INT 0
51444: EQUAL
51445: IFFALSE 51469
// ComHeal ( group [ i ] , z ) else
51447: LD_VAR 0 4
51451: PUSH
51452: LD_VAR 0 7
51456: ARRAY
51457: PPUSH
51458: LD_VAR 0 13
51462: PPUSH
51463: CALL_OW 128
51467: GO 51489
// ComMoveToArea ( group [ i ] , f_heal ) ;
51469: LD_VAR 0 4
51473: PUSH
51474: LD_VAR 0 7
51478: ARRAY
51479: PPUSH
51480: LD_VAR 0 23
51484: PPUSH
51485: CALL_OW 113
// end ; continue ;
51489: GO 50520
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51491: LD_VAR 0 4
51495: PUSH
51496: LD_VAR 0 7
51500: ARRAY
51501: PPUSH
51502: CALL_OW 256
51506: PUSH
51507: LD_INT 700
51509: LESS
51510: PUSH
51511: LD_VAR 0 4
51515: PUSH
51516: LD_VAR 0 7
51520: ARRAY
51521: PUSH
51522: LD_VAR 0 30
51526: IN
51527: NOT
51528: AND
51529: IFFALSE 51553
// to_heal := to_heal union group [ i ] ;
51531: LD_ADDR_VAR 0 30
51535: PUSH
51536: LD_VAR 0 30
51540: PUSH
51541: LD_VAR 0 4
51545: PUSH
51546: LD_VAR 0 7
51550: ARRAY
51551: UNION
51552: ST_TO_ADDR
// if group [ i ] in to_heal then
51553: LD_VAR 0 4
51557: PUSH
51558: LD_VAR 0 7
51562: ARRAY
51563: PUSH
51564: LD_VAR 0 30
51568: IN
51569: IFFALSE 51678
// begin if GetLives ( group [ i ] ) = 1000 then
51571: LD_VAR 0 4
51575: PUSH
51576: LD_VAR 0 7
51580: ARRAY
51581: PPUSH
51582: CALL_OW 256
51586: PUSH
51587: LD_INT 1000
51589: EQUAL
51590: IFFALSE 51616
// to_heal := to_heal diff group [ i ] else
51592: LD_ADDR_VAR 0 30
51596: PUSH
51597: LD_VAR 0 30
51601: PUSH
51602: LD_VAR 0 4
51606: PUSH
51607: LD_VAR 0 7
51611: ARRAY
51612: DIFF
51613: ST_TO_ADDR
51614: GO 51678
// begin if not IsInArea ( group [ i ] , to_heal ) then
51616: LD_VAR 0 4
51620: PUSH
51621: LD_VAR 0 7
51625: ARRAY
51626: PPUSH
51627: LD_VAR 0 30
51631: PPUSH
51632: CALL_OW 308
51636: NOT
51637: IFFALSE 51661
// ComMoveToArea ( group [ i ] , f_heal ) else
51639: LD_VAR 0 4
51643: PUSH
51644: LD_VAR 0 7
51648: ARRAY
51649: PPUSH
51650: LD_VAR 0 23
51654: PPUSH
51655: CALL_OW 113
51659: GO 51676
// ComHold ( group [ i ] ) ;
51661: LD_VAR 0 4
51665: PUSH
51666: LD_VAR 0 7
51670: ARRAY
51671: PPUSH
51672: CALL_OW 140
// continue ;
51676: GO 50520
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 7
51687: ARRAY
51688: PPUSH
51689: LD_INT 10
51691: PPUSH
51692: CALL 48321 0 2
51696: NOT
51697: PUSH
51698: LD_VAR 0 16
51702: PUSH
51703: LD_VAR 0 7
51707: ARRAY
51708: PUSH
51709: EMPTY
51710: EQUAL
51711: NOT
51712: AND
51713: IFFALSE 51979
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51715: LD_VAR 0 4
51719: PUSH
51720: LD_VAR 0 7
51724: ARRAY
51725: PPUSH
51726: CALL_OW 262
51730: PUSH
51731: LD_INT 1
51733: PUSH
51734: LD_INT 2
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: IN
51741: IFFALSE 51782
// if GetFuel ( group [ i ] ) < 10 then
51743: LD_VAR 0 4
51747: PUSH
51748: LD_VAR 0 7
51752: ARRAY
51753: PPUSH
51754: CALL_OW 261
51758: PUSH
51759: LD_INT 10
51761: LESS
51762: IFFALSE 51782
// SetFuel ( group [ i ] , 12 ) ;
51764: LD_VAR 0 4
51768: PUSH
51769: LD_VAR 0 7
51773: ARRAY
51774: PPUSH
51775: LD_INT 12
51777: PPUSH
51778: CALL_OW 240
// if units_path [ i ] then
51782: LD_VAR 0 16
51786: PUSH
51787: LD_VAR 0 7
51791: ARRAY
51792: IFFALSE 51977
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51794: LD_VAR 0 4
51798: PUSH
51799: LD_VAR 0 7
51803: ARRAY
51804: PPUSH
51805: LD_VAR 0 16
51809: PUSH
51810: LD_VAR 0 7
51814: ARRAY
51815: PUSH
51816: LD_INT 1
51818: ARRAY
51819: PUSH
51820: LD_INT 1
51822: ARRAY
51823: PPUSH
51824: LD_VAR 0 16
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PUSH
51835: LD_INT 1
51837: ARRAY
51838: PUSH
51839: LD_INT 2
51841: ARRAY
51842: PPUSH
51843: CALL_OW 297
51847: PUSH
51848: LD_INT 6
51850: GREATER
51851: IFFALSE 51926
// begin if not HasTask ( group [ i ] ) then
51853: LD_VAR 0 4
51857: PUSH
51858: LD_VAR 0 7
51862: ARRAY
51863: PPUSH
51864: CALL_OW 314
51868: NOT
51869: IFFALSE 51924
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51871: LD_VAR 0 4
51875: PUSH
51876: LD_VAR 0 7
51880: ARRAY
51881: PPUSH
51882: LD_VAR 0 16
51886: PUSH
51887: LD_VAR 0 7
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PUSH
51897: LD_INT 1
51899: ARRAY
51900: PPUSH
51901: LD_VAR 0 16
51905: PUSH
51906: LD_VAR 0 7
51910: ARRAY
51911: PUSH
51912: LD_INT 1
51914: ARRAY
51915: PUSH
51916: LD_INT 2
51918: ARRAY
51919: PPUSH
51920: CALL_OW 114
// end else
51924: GO 51977
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51926: LD_ADDR_VAR 0 15
51930: PUSH
51931: LD_VAR 0 16
51935: PUSH
51936: LD_VAR 0 7
51940: ARRAY
51941: PPUSH
51942: LD_INT 1
51944: PPUSH
51945: CALL_OW 3
51949: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51950: LD_ADDR_VAR 0 16
51954: PUSH
51955: LD_VAR 0 16
51959: PPUSH
51960: LD_VAR 0 7
51964: PPUSH
51965: LD_VAR 0 15
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// continue ;
51975: GO 50520
// end ; end ; end else
51977: GO 54641
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51979: LD_ADDR_VAR 0 14
51983: PUSH
51984: LD_INT 81
51986: PUSH
51987: LD_VAR 0 4
51991: PUSH
51992: LD_VAR 0 7
51996: ARRAY
51997: PPUSH
51998: CALL_OW 255
52002: PUSH
52003: EMPTY
52004: LIST
52005: LIST
52006: PPUSH
52007: CALL_OW 69
52011: ST_TO_ADDR
// if not tmp then
52012: LD_VAR 0 14
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 50520
// if f_ignore_area then
52021: LD_VAR 0 17
52025: IFFALSE 52113
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52027: LD_ADDR_VAR 0 15
52031: PUSH
52032: LD_VAR 0 14
52036: PPUSH
52037: LD_INT 3
52039: PUSH
52040: LD_INT 92
52042: PUSH
52043: LD_VAR 0 17
52047: PUSH
52048: LD_INT 1
52050: ARRAY
52051: PUSH
52052: LD_VAR 0 17
52056: PUSH
52057: LD_INT 2
52059: ARRAY
52060: PUSH
52061: LD_VAR 0 17
52065: PUSH
52066: LD_INT 3
52068: ARRAY
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: LIST
52074: LIST
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PPUSH
52080: CALL_OW 72
52084: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52085: LD_VAR 0 14
52089: PUSH
52090: LD_VAR 0 15
52094: DIFF
52095: IFFALSE 52113
// tmp := tmp diff tmp2 ;
52097: LD_ADDR_VAR 0 14
52101: PUSH
52102: LD_VAR 0 14
52106: PUSH
52107: LD_VAR 0 15
52111: DIFF
52112: ST_TO_ADDR
// end ; if not f_murder then
52113: LD_VAR 0 20
52117: NOT
52118: IFFALSE 52176
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52120: LD_ADDR_VAR 0 15
52124: PUSH
52125: LD_VAR 0 14
52129: PPUSH
52130: LD_INT 3
52132: PUSH
52133: LD_INT 50
52135: PUSH
52136: EMPTY
52137: LIST
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: PPUSH
52143: CALL_OW 72
52147: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52148: LD_VAR 0 14
52152: PUSH
52153: LD_VAR 0 15
52157: DIFF
52158: IFFALSE 52176
// tmp := tmp diff tmp2 ;
52160: LD_ADDR_VAR 0 14
52164: PUSH
52165: LD_VAR 0 14
52169: PUSH
52170: LD_VAR 0 15
52174: DIFF
52175: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52176: LD_ADDR_VAR 0 14
52180: PUSH
52181: LD_VAR 0 4
52185: PUSH
52186: LD_VAR 0 7
52190: ARRAY
52191: PPUSH
52192: LD_VAR 0 14
52196: PPUSH
52197: LD_INT 1
52199: PPUSH
52200: LD_INT 1
52202: PPUSH
52203: CALL 21964 0 4
52207: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52208: LD_VAR 0 4
52212: PUSH
52213: LD_VAR 0 7
52217: ARRAY
52218: PPUSH
52219: CALL_OW 257
52223: PUSH
52224: LD_INT 1
52226: EQUAL
52227: IFFALSE 52675
// begin if WantPlant ( group [ i ] ) then
52229: LD_VAR 0 4
52233: PUSH
52234: LD_VAR 0 7
52238: ARRAY
52239: PPUSH
52240: CALL 21465 0 1
52244: IFFALSE 52248
// continue ;
52246: GO 50520
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52248: LD_VAR 0 18
52252: PUSH
52253: LD_VAR 0 4
52257: PUSH
52258: LD_VAR 0 7
52262: ARRAY
52263: PPUSH
52264: CALL_OW 310
52268: NOT
52269: AND
52270: PUSH
52271: LD_VAR 0 14
52275: PUSH
52276: LD_INT 1
52278: ARRAY
52279: PUSH
52280: LD_VAR 0 14
52284: PPUSH
52285: LD_INT 21
52287: PUSH
52288: LD_INT 2
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: PUSH
52295: LD_INT 58
52297: PUSH
52298: EMPTY
52299: LIST
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: PPUSH
52305: CALL_OW 72
52309: IN
52310: AND
52311: IFFALSE 52347
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52313: LD_VAR 0 4
52317: PUSH
52318: LD_VAR 0 7
52322: ARRAY
52323: PPUSH
52324: LD_VAR 0 14
52328: PUSH
52329: LD_INT 1
52331: ARRAY
52332: PPUSH
52333: CALL_OW 120
// attacking := true ;
52337: LD_ADDR_VAR 0 29
52341: PUSH
52342: LD_INT 1
52344: ST_TO_ADDR
// continue ;
52345: GO 50520
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52347: LD_VAR 0 26
52351: PUSH
52352: LD_VAR 0 4
52356: PUSH
52357: LD_VAR 0 7
52361: ARRAY
52362: PPUSH
52363: CALL_OW 257
52367: PUSH
52368: LD_INT 1
52370: EQUAL
52371: AND
52372: PUSH
52373: LD_VAR 0 4
52377: PUSH
52378: LD_VAR 0 7
52382: ARRAY
52383: PPUSH
52384: CALL_OW 256
52388: PUSH
52389: LD_INT 800
52391: LESS
52392: AND
52393: PUSH
52394: LD_VAR 0 4
52398: PUSH
52399: LD_VAR 0 7
52403: ARRAY
52404: PPUSH
52405: CALL_OW 318
52409: NOT
52410: AND
52411: IFFALSE 52428
// ComCrawl ( group [ i ] ) ;
52413: LD_VAR 0 4
52417: PUSH
52418: LD_VAR 0 7
52422: ARRAY
52423: PPUSH
52424: CALL_OW 137
// if f_mines then
52428: LD_VAR 0 21
52432: IFFALSE 52675
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52434: LD_VAR 0 14
52438: PUSH
52439: LD_INT 1
52441: ARRAY
52442: PPUSH
52443: CALL_OW 247
52447: PUSH
52448: LD_INT 3
52450: EQUAL
52451: PUSH
52452: LD_VAR 0 14
52456: PUSH
52457: LD_INT 1
52459: ARRAY
52460: PUSH
52461: LD_VAR 0 27
52465: IN
52466: NOT
52467: AND
52468: IFFALSE 52675
// begin x := GetX ( tmp [ 1 ] ) ;
52470: LD_ADDR_VAR 0 10
52474: PUSH
52475: LD_VAR 0 14
52479: PUSH
52480: LD_INT 1
52482: ARRAY
52483: PPUSH
52484: CALL_OW 250
52488: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52489: LD_ADDR_VAR 0 11
52493: PUSH
52494: LD_VAR 0 14
52498: PUSH
52499: LD_INT 1
52501: ARRAY
52502: PPUSH
52503: CALL_OW 251
52507: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52508: LD_ADDR_VAR 0 12
52512: PUSH
52513: LD_VAR 0 4
52517: PUSH
52518: LD_VAR 0 7
52522: ARRAY
52523: PPUSH
52524: CALL 48406 0 1
52528: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52529: LD_VAR 0 4
52533: PUSH
52534: LD_VAR 0 7
52538: ARRAY
52539: PPUSH
52540: LD_VAR 0 10
52544: PPUSH
52545: LD_VAR 0 11
52549: PPUSH
52550: LD_VAR 0 14
52554: PUSH
52555: LD_INT 1
52557: ARRAY
52558: PPUSH
52559: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52563: LD_VAR 0 4
52567: PUSH
52568: LD_VAR 0 7
52572: ARRAY
52573: PPUSH
52574: LD_VAR 0 10
52578: PPUSH
52579: LD_VAR 0 12
52583: PPUSH
52584: LD_INT 7
52586: PPUSH
52587: CALL_OW 272
52591: PPUSH
52592: LD_VAR 0 11
52596: PPUSH
52597: LD_VAR 0 12
52601: PPUSH
52602: LD_INT 7
52604: PPUSH
52605: CALL_OW 273
52609: PPUSH
52610: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52614: LD_VAR 0 4
52618: PUSH
52619: LD_VAR 0 7
52623: ARRAY
52624: PPUSH
52625: LD_INT 71
52627: PPUSH
52628: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52632: LD_ADDR_VAR 0 27
52636: PUSH
52637: LD_VAR 0 27
52641: PPUSH
52642: LD_VAR 0 27
52646: PUSH
52647: LD_INT 1
52649: PLUS
52650: PPUSH
52651: LD_VAR 0 14
52655: PUSH
52656: LD_INT 1
52658: ARRAY
52659: PPUSH
52660: CALL_OW 1
52664: ST_TO_ADDR
// attacking := true ;
52665: LD_ADDR_VAR 0 29
52669: PUSH
52670: LD_INT 1
52672: ST_TO_ADDR
// continue ;
52673: GO 50520
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52675: LD_VAR 0 4
52679: PUSH
52680: LD_VAR 0 7
52684: ARRAY
52685: PPUSH
52686: CALL_OW 257
52690: PUSH
52691: LD_INT 17
52693: EQUAL
52694: PUSH
52695: LD_VAR 0 4
52699: PUSH
52700: LD_VAR 0 7
52704: ARRAY
52705: PPUSH
52706: CALL_OW 110
52710: PUSH
52711: LD_INT 71
52713: EQUAL
52714: NOT
52715: AND
52716: IFFALSE 52862
// begin attacking := false ;
52718: LD_ADDR_VAR 0 29
52722: PUSH
52723: LD_INT 0
52725: ST_TO_ADDR
// k := 5 ;
52726: LD_ADDR_VAR 0 9
52730: PUSH
52731: LD_INT 5
52733: ST_TO_ADDR
// if tmp < k then
52734: LD_VAR 0 14
52738: PUSH
52739: LD_VAR 0 9
52743: LESS
52744: IFFALSE 52756
// k := tmp ;
52746: LD_ADDR_VAR 0 9
52750: PUSH
52751: LD_VAR 0 14
52755: ST_TO_ADDR
// for j = 1 to k do
52756: LD_ADDR_VAR 0 8
52760: PUSH
52761: DOUBLE
52762: LD_INT 1
52764: DEC
52765: ST_TO_ADDR
52766: LD_VAR 0 9
52770: PUSH
52771: FOR_TO
52772: IFFALSE 52860
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52774: LD_VAR 0 14
52778: PUSH
52779: LD_VAR 0 8
52783: ARRAY
52784: PUSH
52785: LD_VAR 0 14
52789: PPUSH
52790: LD_INT 58
52792: PUSH
52793: EMPTY
52794: LIST
52795: PPUSH
52796: CALL_OW 72
52800: IN
52801: NOT
52802: IFFALSE 52858
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52804: LD_VAR 0 4
52808: PUSH
52809: LD_VAR 0 7
52813: ARRAY
52814: PPUSH
52815: LD_VAR 0 14
52819: PUSH
52820: LD_VAR 0 8
52824: ARRAY
52825: PPUSH
52826: CALL_OW 115
// attacking := true ;
52830: LD_ADDR_VAR 0 29
52834: PUSH
52835: LD_INT 1
52837: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52838: LD_VAR 0 4
52842: PUSH
52843: LD_VAR 0 7
52847: ARRAY
52848: PPUSH
52849: LD_INT 71
52851: PPUSH
52852: CALL_OW 109
// continue ;
52856: GO 52771
// end ; end ;
52858: GO 52771
52860: POP
52861: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52862: LD_VAR 0 4
52866: PUSH
52867: LD_VAR 0 7
52871: ARRAY
52872: PPUSH
52873: CALL_OW 257
52877: PUSH
52878: LD_INT 8
52880: EQUAL
52881: PUSH
52882: LD_VAR 0 4
52886: PUSH
52887: LD_VAR 0 7
52891: ARRAY
52892: PPUSH
52893: CALL_OW 264
52897: PUSH
52898: LD_INT 28
52900: PUSH
52901: LD_INT 45
52903: PUSH
52904: LD_INT 7
52906: PUSH
52907: LD_INT 47
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: LIST
52914: LIST
52915: IN
52916: OR
52917: IFFALSE 53173
// begin attacking := false ;
52919: LD_ADDR_VAR 0 29
52923: PUSH
52924: LD_INT 0
52926: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52927: LD_VAR 0 14
52931: PUSH
52932: LD_INT 1
52934: ARRAY
52935: PPUSH
52936: CALL_OW 266
52940: PUSH
52941: LD_INT 32
52943: PUSH
52944: LD_INT 31
52946: PUSH
52947: LD_INT 33
52949: PUSH
52950: LD_INT 4
52952: PUSH
52953: LD_INT 5
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: LIST
52962: IN
52963: IFFALSE 53149
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52965: LD_ADDR_VAR 0 9
52969: PUSH
52970: LD_VAR 0 14
52974: PUSH
52975: LD_INT 1
52977: ARRAY
52978: PPUSH
52979: CALL_OW 266
52983: PPUSH
52984: LD_VAR 0 14
52988: PUSH
52989: LD_INT 1
52991: ARRAY
52992: PPUSH
52993: CALL_OW 250
52997: PPUSH
52998: LD_VAR 0 14
53002: PUSH
53003: LD_INT 1
53005: ARRAY
53006: PPUSH
53007: CALL_OW 251
53011: PPUSH
53012: LD_VAR 0 14
53016: PUSH
53017: LD_INT 1
53019: ARRAY
53020: PPUSH
53021: CALL_OW 254
53025: PPUSH
53026: LD_VAR 0 14
53030: PUSH
53031: LD_INT 1
53033: ARRAY
53034: PPUSH
53035: CALL_OW 248
53039: PPUSH
53040: LD_INT 0
53042: PPUSH
53043: CALL 29776 0 6
53047: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53048: LD_ADDR_VAR 0 8
53052: PUSH
53053: LD_VAR 0 4
53057: PUSH
53058: LD_VAR 0 7
53062: ARRAY
53063: PPUSH
53064: LD_VAR 0 9
53068: PPUSH
53069: CALL 48446 0 2
53073: ST_TO_ADDR
// if j then
53074: LD_VAR 0 8
53078: IFFALSE 53147
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53080: LD_VAR 0 8
53084: PUSH
53085: LD_INT 1
53087: ARRAY
53088: PPUSH
53089: LD_VAR 0 8
53093: PUSH
53094: LD_INT 2
53096: ARRAY
53097: PPUSH
53098: CALL_OW 488
53102: IFFALSE 53147
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53104: LD_VAR 0 4
53108: PUSH
53109: LD_VAR 0 7
53113: ARRAY
53114: PPUSH
53115: LD_VAR 0 8
53119: PUSH
53120: LD_INT 1
53122: ARRAY
53123: PPUSH
53124: LD_VAR 0 8
53128: PUSH
53129: LD_INT 2
53131: ARRAY
53132: PPUSH
53133: CALL_OW 116
// attacking := true ;
53137: LD_ADDR_VAR 0 29
53141: PUSH
53142: LD_INT 1
53144: ST_TO_ADDR
// continue ;
53145: GO 50520
// end ; end else
53147: GO 53173
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53149: LD_VAR 0 4
53153: PUSH
53154: LD_VAR 0 7
53158: ARRAY
53159: PPUSH
53160: LD_VAR 0 14
53164: PUSH
53165: LD_INT 1
53167: ARRAY
53168: PPUSH
53169: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 7
53182: ARRAY
53183: PPUSH
53184: CALL_OW 265
53188: PUSH
53189: LD_INT 11
53191: EQUAL
53192: IFFALSE 53470
// begin k := 10 ;
53194: LD_ADDR_VAR 0 9
53198: PUSH
53199: LD_INT 10
53201: ST_TO_ADDR
// x := 0 ;
53202: LD_ADDR_VAR 0 10
53206: PUSH
53207: LD_INT 0
53209: ST_TO_ADDR
// if tmp < k then
53210: LD_VAR 0 14
53214: PUSH
53215: LD_VAR 0 9
53219: LESS
53220: IFFALSE 53232
// k := tmp ;
53222: LD_ADDR_VAR 0 9
53226: PUSH
53227: LD_VAR 0 14
53231: ST_TO_ADDR
// for j = k downto 1 do
53232: LD_ADDR_VAR 0 8
53236: PUSH
53237: DOUBLE
53238: LD_VAR 0 9
53242: INC
53243: ST_TO_ADDR
53244: LD_INT 1
53246: PUSH
53247: FOR_DOWNTO
53248: IFFALSE 53323
// begin if GetType ( tmp [ j ] ) = unit_human then
53250: LD_VAR 0 14
53254: PUSH
53255: LD_VAR 0 8
53259: ARRAY
53260: PPUSH
53261: CALL_OW 247
53265: PUSH
53266: LD_INT 1
53268: EQUAL
53269: IFFALSE 53321
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53271: LD_VAR 0 4
53275: PUSH
53276: LD_VAR 0 7
53280: ARRAY
53281: PPUSH
53282: LD_VAR 0 14
53286: PUSH
53287: LD_VAR 0 8
53291: ARRAY
53292: PPUSH
53293: CALL 48717 0 2
// x := tmp [ j ] ;
53297: LD_ADDR_VAR 0 10
53301: PUSH
53302: LD_VAR 0 14
53306: PUSH
53307: LD_VAR 0 8
53311: ARRAY
53312: ST_TO_ADDR
// attacking := true ;
53313: LD_ADDR_VAR 0 29
53317: PUSH
53318: LD_INT 1
53320: ST_TO_ADDR
// end ; end ;
53321: GO 53247
53323: POP
53324: POP
// if not x then
53325: LD_VAR 0 10
53329: NOT
53330: IFFALSE 53470
// begin attacking := true ;
53332: LD_ADDR_VAR 0 29
53336: PUSH
53337: LD_INT 1
53339: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53340: LD_VAR 0 4
53344: PUSH
53345: LD_VAR 0 7
53349: ARRAY
53350: PPUSH
53351: CALL_OW 250
53355: PPUSH
53356: LD_VAR 0 4
53360: PUSH
53361: LD_VAR 0 7
53365: ARRAY
53366: PPUSH
53367: CALL_OW 251
53371: PPUSH
53372: CALL_OW 546
53376: PUSH
53377: LD_INT 2
53379: ARRAY
53380: PUSH
53381: LD_VAR 0 14
53385: PUSH
53386: LD_INT 1
53388: ARRAY
53389: PPUSH
53390: CALL_OW 250
53394: PPUSH
53395: LD_VAR 0 14
53399: PUSH
53400: LD_INT 1
53402: ARRAY
53403: PPUSH
53404: CALL_OW 251
53408: PPUSH
53409: CALL_OW 546
53413: PUSH
53414: LD_INT 2
53416: ARRAY
53417: EQUAL
53418: IFFALSE 53446
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53420: LD_VAR 0 4
53424: PUSH
53425: LD_VAR 0 7
53429: ARRAY
53430: PPUSH
53431: LD_VAR 0 14
53435: PUSH
53436: LD_INT 1
53438: ARRAY
53439: PPUSH
53440: CALL 48717 0 2
53444: GO 53470
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53446: LD_VAR 0 4
53450: PUSH
53451: LD_VAR 0 7
53455: ARRAY
53456: PPUSH
53457: LD_VAR 0 14
53461: PUSH
53462: LD_INT 1
53464: ARRAY
53465: PPUSH
53466: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53470: LD_VAR 0 4
53474: PUSH
53475: LD_VAR 0 7
53479: ARRAY
53480: PPUSH
53481: CALL_OW 264
53485: PUSH
53486: LD_INT 29
53488: EQUAL
53489: IFFALSE 53855
// begin if WantsToAttack ( group [ i ] ) in bombed then
53491: LD_VAR 0 4
53495: PUSH
53496: LD_VAR 0 7
53500: ARRAY
53501: PPUSH
53502: CALL_OW 319
53506: PUSH
53507: LD_VAR 0 28
53511: IN
53512: IFFALSE 53516
// continue ;
53514: GO 50520
// k := 8 ;
53516: LD_ADDR_VAR 0 9
53520: PUSH
53521: LD_INT 8
53523: ST_TO_ADDR
// x := 0 ;
53524: LD_ADDR_VAR 0 10
53528: PUSH
53529: LD_INT 0
53531: ST_TO_ADDR
// if tmp < k then
53532: LD_VAR 0 14
53536: PUSH
53537: LD_VAR 0 9
53541: LESS
53542: IFFALSE 53554
// k := tmp ;
53544: LD_ADDR_VAR 0 9
53548: PUSH
53549: LD_VAR 0 14
53553: ST_TO_ADDR
// for j = 1 to k do
53554: LD_ADDR_VAR 0 8
53558: PUSH
53559: DOUBLE
53560: LD_INT 1
53562: DEC
53563: ST_TO_ADDR
53564: LD_VAR 0 9
53568: PUSH
53569: FOR_TO
53570: IFFALSE 53702
// begin if GetType ( tmp [ j ] ) = unit_building then
53572: LD_VAR 0 14
53576: PUSH
53577: LD_VAR 0 8
53581: ARRAY
53582: PPUSH
53583: CALL_OW 247
53587: PUSH
53588: LD_INT 3
53590: EQUAL
53591: IFFALSE 53700
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53593: LD_VAR 0 14
53597: PUSH
53598: LD_VAR 0 8
53602: ARRAY
53603: PUSH
53604: LD_VAR 0 28
53608: IN
53609: NOT
53610: PUSH
53611: LD_VAR 0 14
53615: PUSH
53616: LD_VAR 0 8
53620: ARRAY
53621: PPUSH
53622: CALL_OW 313
53626: AND
53627: IFFALSE 53700
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53629: LD_VAR 0 4
53633: PUSH
53634: LD_VAR 0 7
53638: ARRAY
53639: PPUSH
53640: LD_VAR 0 14
53644: PUSH
53645: LD_VAR 0 8
53649: ARRAY
53650: PPUSH
53651: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53655: LD_ADDR_VAR 0 28
53659: PUSH
53660: LD_VAR 0 28
53664: PPUSH
53665: LD_VAR 0 28
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PPUSH
53674: LD_VAR 0 14
53678: PUSH
53679: LD_VAR 0 8
53683: ARRAY
53684: PPUSH
53685: CALL_OW 1
53689: ST_TO_ADDR
// attacking := true ;
53690: LD_ADDR_VAR 0 29
53694: PUSH
53695: LD_INT 1
53697: ST_TO_ADDR
// break ;
53698: GO 53702
// end ; end ;
53700: GO 53569
53702: POP
53703: POP
// if not attacking and f_attack_depot then
53704: LD_VAR 0 29
53708: NOT
53709: PUSH
53710: LD_VAR 0 25
53714: AND
53715: IFFALSE 53810
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53717: LD_ADDR_VAR 0 13
53721: PUSH
53722: LD_VAR 0 14
53726: PPUSH
53727: LD_INT 2
53729: PUSH
53730: LD_INT 30
53732: PUSH
53733: LD_INT 0
53735: PUSH
53736: EMPTY
53737: LIST
53738: LIST
53739: PUSH
53740: LD_INT 30
53742: PUSH
53743: LD_INT 1
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: EMPTY
53751: LIST
53752: LIST
53753: LIST
53754: PPUSH
53755: CALL_OW 72
53759: ST_TO_ADDR
// if z then
53760: LD_VAR 0 13
53764: IFFALSE 53810
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53766: LD_VAR 0 4
53770: PUSH
53771: LD_VAR 0 7
53775: ARRAY
53776: PPUSH
53777: LD_VAR 0 13
53781: PPUSH
53782: LD_VAR 0 4
53786: PUSH
53787: LD_VAR 0 7
53791: ARRAY
53792: PPUSH
53793: CALL_OW 74
53797: PPUSH
53798: CALL_OW 115
// attacking := true ;
53802: LD_ADDR_VAR 0 29
53806: PUSH
53807: LD_INT 1
53809: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53810: LD_VAR 0 4
53814: PUSH
53815: LD_VAR 0 7
53819: ARRAY
53820: PPUSH
53821: CALL_OW 256
53825: PUSH
53826: LD_INT 500
53828: LESS
53829: IFFALSE 53855
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53831: LD_VAR 0 4
53835: PUSH
53836: LD_VAR 0 7
53840: ARRAY
53841: PPUSH
53842: LD_VAR 0 14
53846: PUSH
53847: LD_INT 1
53849: ARRAY
53850: PPUSH
53851: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53855: LD_VAR 0 4
53859: PUSH
53860: LD_VAR 0 7
53864: ARRAY
53865: PPUSH
53866: CALL_OW 264
53870: PUSH
53871: LD_INT 49
53873: EQUAL
53874: IFFALSE 53995
// begin if not HasTask ( group [ i ] ) then
53876: LD_VAR 0 4
53880: PUSH
53881: LD_VAR 0 7
53885: ARRAY
53886: PPUSH
53887: CALL_OW 314
53891: NOT
53892: IFFALSE 53995
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53894: LD_ADDR_VAR 0 9
53898: PUSH
53899: LD_INT 81
53901: PUSH
53902: LD_VAR 0 4
53906: PUSH
53907: LD_VAR 0 7
53911: ARRAY
53912: PPUSH
53913: CALL_OW 255
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: PPUSH
53922: CALL_OW 69
53926: PPUSH
53927: LD_VAR 0 4
53931: PUSH
53932: LD_VAR 0 7
53936: ARRAY
53937: PPUSH
53938: CALL_OW 74
53942: ST_TO_ADDR
// if k then
53943: LD_VAR 0 9
53947: IFFALSE 53995
// if GetDistUnits ( group [ i ] , k ) > 10 then
53949: LD_VAR 0 4
53953: PUSH
53954: LD_VAR 0 7
53958: ARRAY
53959: PPUSH
53960: LD_VAR 0 9
53964: PPUSH
53965: CALL_OW 296
53969: PUSH
53970: LD_INT 10
53972: GREATER
53973: IFFALSE 53995
// ComMoveUnit ( group [ i ] , k ) ;
53975: LD_VAR 0 4
53979: PUSH
53980: LD_VAR 0 7
53984: ARRAY
53985: PPUSH
53986: LD_VAR 0 9
53990: PPUSH
53991: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53995: LD_VAR 0 4
53999: PUSH
54000: LD_VAR 0 7
54004: ARRAY
54005: PPUSH
54006: CALL_OW 256
54010: PUSH
54011: LD_INT 250
54013: LESS
54014: PUSH
54015: LD_VAR 0 4
54019: PUSH
54020: LD_VAR 0 7
54024: ARRAY
54025: PUSH
54026: LD_INT 21
54028: PUSH
54029: LD_INT 2
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PUSH
54036: LD_INT 23
54038: PUSH
54039: LD_INT 2
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: PUSH
54046: EMPTY
54047: LIST
54048: LIST
54049: PPUSH
54050: CALL_OW 69
54054: IN
54055: AND
54056: IFFALSE 54181
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54058: LD_ADDR_VAR 0 9
54062: PUSH
54063: LD_OWVAR 3
54067: PUSH
54068: LD_VAR 0 4
54072: PUSH
54073: LD_VAR 0 7
54077: ARRAY
54078: DIFF
54079: PPUSH
54080: LD_VAR 0 4
54084: PUSH
54085: LD_VAR 0 7
54089: ARRAY
54090: PPUSH
54091: CALL_OW 74
54095: ST_TO_ADDR
// if not k then
54096: LD_VAR 0 9
54100: NOT
54101: IFFALSE 54105
// continue ;
54103: GO 50520
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54105: LD_VAR 0 9
54109: PUSH
54110: LD_INT 81
54112: PUSH
54113: LD_VAR 0 4
54117: PUSH
54118: LD_VAR 0 7
54122: ARRAY
54123: PPUSH
54124: CALL_OW 255
54128: PUSH
54129: EMPTY
54130: LIST
54131: LIST
54132: PPUSH
54133: CALL_OW 69
54137: IN
54138: PUSH
54139: LD_VAR 0 9
54143: PPUSH
54144: LD_VAR 0 4
54148: PUSH
54149: LD_VAR 0 7
54153: ARRAY
54154: PPUSH
54155: CALL_OW 296
54159: PUSH
54160: LD_INT 5
54162: LESS
54163: AND
54164: IFFALSE 54181
// ComAutodestruct ( group [ i ] ) ;
54166: LD_VAR 0 4
54170: PUSH
54171: LD_VAR 0 7
54175: ARRAY
54176: PPUSH
54177: CALL 48615 0 1
// end ; if f_attack_depot then
54181: LD_VAR 0 25
54185: IFFALSE 54297
// begin k := 6 ;
54187: LD_ADDR_VAR 0 9
54191: PUSH
54192: LD_INT 6
54194: ST_TO_ADDR
// if tmp < k then
54195: LD_VAR 0 14
54199: PUSH
54200: LD_VAR 0 9
54204: LESS
54205: IFFALSE 54217
// k := tmp ;
54207: LD_ADDR_VAR 0 9
54211: PUSH
54212: LD_VAR 0 14
54216: ST_TO_ADDR
// for j = 1 to k do
54217: LD_ADDR_VAR 0 8
54221: PUSH
54222: DOUBLE
54223: LD_INT 1
54225: DEC
54226: ST_TO_ADDR
54227: LD_VAR 0 9
54231: PUSH
54232: FOR_TO
54233: IFFALSE 54295
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54235: LD_VAR 0 8
54239: PPUSH
54240: CALL_OW 266
54244: PUSH
54245: LD_INT 0
54247: PUSH
54248: LD_INT 1
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: IN
54255: IFFALSE 54293
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54257: LD_VAR 0 4
54261: PUSH
54262: LD_VAR 0 7
54266: ARRAY
54267: PPUSH
54268: LD_VAR 0 14
54272: PUSH
54273: LD_VAR 0 8
54277: ARRAY
54278: PPUSH
54279: CALL_OW 115
// attacking := true ;
54283: LD_ADDR_VAR 0 29
54287: PUSH
54288: LD_INT 1
54290: ST_TO_ADDR
// break ;
54291: GO 54295
// end ;
54293: GO 54232
54295: POP
54296: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54297: LD_VAR 0 4
54301: PUSH
54302: LD_VAR 0 7
54306: ARRAY
54307: PPUSH
54308: CALL_OW 302
54312: PUSH
54313: LD_VAR 0 29
54317: NOT
54318: AND
54319: IFFALSE 54641
// begin if GetTag ( group [ i ] ) = 71 then
54321: LD_VAR 0 4
54325: PUSH
54326: LD_VAR 0 7
54330: ARRAY
54331: PPUSH
54332: CALL_OW 110
54336: PUSH
54337: LD_INT 71
54339: EQUAL
54340: IFFALSE 54381
// begin if HasTask ( group [ i ] ) then
54342: LD_VAR 0 4
54346: PUSH
54347: LD_VAR 0 7
54351: ARRAY
54352: PPUSH
54353: CALL_OW 314
54357: IFFALSE 54363
// continue else
54359: GO 50520
54361: GO 54381
// SetTag ( group [ i ] , 0 ) ;
54363: LD_VAR 0 4
54367: PUSH
54368: LD_VAR 0 7
54372: ARRAY
54373: PPUSH
54374: LD_INT 0
54376: PPUSH
54377: CALL_OW 109
// end ; k := 8 ;
54381: LD_ADDR_VAR 0 9
54385: PUSH
54386: LD_INT 8
54388: ST_TO_ADDR
// x := 0 ;
54389: LD_ADDR_VAR 0 10
54393: PUSH
54394: LD_INT 0
54396: ST_TO_ADDR
// if tmp < k then
54397: LD_VAR 0 14
54401: PUSH
54402: LD_VAR 0 9
54406: LESS
54407: IFFALSE 54419
// k := tmp ;
54409: LD_ADDR_VAR 0 9
54413: PUSH
54414: LD_VAR 0 14
54418: ST_TO_ADDR
// for j = 1 to k do
54419: LD_ADDR_VAR 0 8
54423: PUSH
54424: DOUBLE
54425: LD_INT 1
54427: DEC
54428: ST_TO_ADDR
54429: LD_VAR 0 9
54433: PUSH
54434: FOR_TO
54435: IFFALSE 54533
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54437: LD_VAR 0 14
54441: PUSH
54442: LD_VAR 0 8
54446: ARRAY
54447: PPUSH
54448: CALL_OW 247
54452: PUSH
54453: LD_INT 1
54455: EQUAL
54456: PUSH
54457: LD_VAR 0 14
54461: PUSH
54462: LD_VAR 0 8
54466: ARRAY
54467: PPUSH
54468: CALL_OW 256
54472: PUSH
54473: LD_INT 250
54475: LESS
54476: PUSH
54477: LD_VAR 0 20
54481: AND
54482: PUSH
54483: LD_VAR 0 20
54487: NOT
54488: PUSH
54489: LD_VAR 0 14
54493: PUSH
54494: LD_VAR 0 8
54498: ARRAY
54499: PPUSH
54500: CALL_OW 256
54504: PUSH
54505: LD_INT 250
54507: GREATEREQUAL
54508: AND
54509: OR
54510: AND
54511: IFFALSE 54531
// begin x := tmp [ j ] ;
54513: LD_ADDR_VAR 0 10
54517: PUSH
54518: LD_VAR 0 14
54522: PUSH
54523: LD_VAR 0 8
54527: ARRAY
54528: ST_TO_ADDR
// break ;
54529: GO 54533
// end ;
54531: GO 54434
54533: POP
54534: POP
// if x then
54535: LD_VAR 0 10
54539: IFFALSE 54563
// ComAttackUnit ( group [ i ] , x ) else
54541: LD_VAR 0 4
54545: PUSH
54546: LD_VAR 0 7
54550: ARRAY
54551: PPUSH
54552: LD_VAR 0 10
54556: PPUSH
54557: CALL_OW 115
54561: GO 54587
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54563: LD_VAR 0 4
54567: PUSH
54568: LD_VAR 0 7
54572: ARRAY
54573: PPUSH
54574: LD_VAR 0 14
54578: PUSH
54579: LD_INT 1
54581: ARRAY
54582: PPUSH
54583: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54587: LD_VAR 0 4
54591: PUSH
54592: LD_VAR 0 7
54596: ARRAY
54597: PPUSH
54598: CALL_OW 314
54602: NOT
54603: IFFALSE 54641
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54605: LD_VAR 0 4
54609: PUSH
54610: LD_VAR 0 7
54614: ARRAY
54615: PPUSH
54616: LD_VAR 0 14
54620: PPUSH
54621: LD_VAR 0 4
54625: PUSH
54626: LD_VAR 0 7
54630: ARRAY
54631: PPUSH
54632: CALL_OW 74
54636: PPUSH
54637: CALL_OW 115
// end ; end ; end ;
54641: GO 50520
54643: POP
54644: POP
// wait ( 0 0$2 ) ;
54645: LD_INT 70
54647: PPUSH
54648: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54652: LD_VAR 0 4
54656: NOT
54657: PUSH
54658: LD_VAR 0 4
54662: PUSH
54663: EMPTY
54664: EQUAL
54665: OR
54666: PUSH
54667: LD_INT 81
54669: PUSH
54670: LD_VAR 0 35
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: PPUSH
54679: CALL_OW 69
54683: NOT
54684: OR
54685: IFFALSE 50505
// end ;
54687: LD_VAR 0 2
54691: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54692: LD_INT 0
54694: PPUSH
54695: PPUSH
54696: PPUSH
54697: PPUSH
// if not base_units then
54698: LD_VAR 0 1
54702: NOT
54703: IFFALSE 54707
// exit ;
54705: GO 54794
// result := false ;
54707: LD_ADDR_VAR 0 2
54711: PUSH
54712: LD_INT 0
54714: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54715: LD_ADDR_VAR 0 5
54719: PUSH
54720: LD_VAR 0 1
54724: PPUSH
54725: LD_INT 21
54727: PUSH
54728: LD_INT 3
54730: PUSH
54731: EMPTY
54732: LIST
54733: LIST
54734: PPUSH
54735: CALL_OW 72
54739: ST_TO_ADDR
// if not tmp then
54740: LD_VAR 0 5
54744: NOT
54745: IFFALSE 54749
// exit ;
54747: GO 54794
// for i in tmp do
54749: LD_ADDR_VAR 0 3
54753: PUSH
54754: LD_VAR 0 5
54758: PUSH
54759: FOR_IN
54760: IFFALSE 54792
// begin result := EnemyInRange ( i , 22 ) ;
54762: LD_ADDR_VAR 0 2
54766: PUSH
54767: LD_VAR 0 3
54771: PPUSH
54772: LD_INT 22
54774: PPUSH
54775: CALL 48321 0 2
54779: ST_TO_ADDR
// if result then
54780: LD_VAR 0 2
54784: IFFALSE 54790
// exit ;
54786: POP
54787: POP
54788: GO 54794
// end ;
54790: GO 54759
54792: POP
54793: POP
// end ;
54794: LD_VAR 0 2
54798: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54799: LD_INT 0
54801: PPUSH
54802: PPUSH
// if not units then
54803: LD_VAR 0 1
54807: NOT
54808: IFFALSE 54812
// exit ;
54810: GO 54882
// result := [ ] ;
54812: LD_ADDR_VAR 0 3
54816: PUSH
54817: EMPTY
54818: ST_TO_ADDR
// for i in units do
54819: LD_ADDR_VAR 0 4
54823: PUSH
54824: LD_VAR 0 1
54828: PUSH
54829: FOR_IN
54830: IFFALSE 54880
// if GetTag ( i ) = tag then
54832: LD_VAR 0 4
54836: PPUSH
54837: CALL_OW 110
54841: PUSH
54842: LD_VAR 0 2
54846: EQUAL
54847: IFFALSE 54878
// result := Insert ( result , result + 1 , i ) ;
54849: LD_ADDR_VAR 0 3
54853: PUSH
54854: LD_VAR 0 3
54858: PPUSH
54859: LD_VAR 0 3
54863: PUSH
54864: LD_INT 1
54866: PLUS
54867: PPUSH
54868: LD_VAR 0 4
54872: PPUSH
54873: CALL_OW 2
54877: ST_TO_ADDR
54878: GO 54829
54880: POP
54881: POP
// end ;
54882: LD_VAR 0 3
54886: RET
// export function IsDriver ( un ) ; begin
54887: LD_INT 0
54889: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54890: LD_ADDR_VAR 0 2
54894: PUSH
54895: LD_VAR 0 1
54899: PUSH
54900: LD_INT 55
54902: PUSH
54903: EMPTY
54904: LIST
54905: PPUSH
54906: CALL_OW 69
54910: IN
54911: ST_TO_ADDR
// end ;
54912: LD_VAR 0 2
54916: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54917: LD_INT 0
54919: PPUSH
54920: PPUSH
// list := [ ] ;
54921: LD_ADDR_VAR 0 5
54925: PUSH
54926: EMPTY
54927: ST_TO_ADDR
// case d of 0 :
54928: LD_VAR 0 3
54932: PUSH
54933: LD_INT 0
54935: DOUBLE
54936: EQUAL
54937: IFTRUE 54941
54939: GO 55074
54941: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54942: LD_ADDR_VAR 0 5
54946: PUSH
54947: LD_VAR 0 1
54951: PUSH
54952: LD_INT 4
54954: MINUS
54955: PUSH
54956: LD_VAR 0 2
54960: PUSH
54961: LD_INT 4
54963: MINUS
54964: PUSH
54965: LD_INT 2
54967: PUSH
54968: EMPTY
54969: LIST
54970: LIST
54971: LIST
54972: PUSH
54973: LD_VAR 0 1
54977: PUSH
54978: LD_INT 3
54980: MINUS
54981: PUSH
54982: LD_VAR 0 2
54986: PUSH
54987: LD_INT 1
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: PUSH
54995: LD_VAR 0 1
54999: PUSH
55000: LD_INT 4
55002: PLUS
55003: PUSH
55004: LD_VAR 0 2
55008: PUSH
55009: LD_INT 4
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: LIST
55016: PUSH
55017: LD_VAR 0 1
55021: PUSH
55022: LD_INT 3
55024: PLUS
55025: PUSH
55026: LD_VAR 0 2
55030: PUSH
55031: LD_INT 3
55033: PLUS
55034: PUSH
55035: LD_INT 5
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: LIST
55042: PUSH
55043: LD_VAR 0 1
55047: PUSH
55048: LD_VAR 0 2
55052: PUSH
55053: LD_INT 4
55055: PLUS
55056: PUSH
55057: LD_INT 0
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: LIST
55069: LIST
55070: LIST
55071: ST_TO_ADDR
// end ; 1 :
55072: GO 55772
55074: LD_INT 1
55076: DOUBLE
55077: EQUAL
55078: IFTRUE 55082
55080: GO 55215
55082: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55083: LD_ADDR_VAR 0 5
55087: PUSH
55088: LD_VAR 0 1
55092: PUSH
55093: LD_VAR 0 2
55097: PUSH
55098: LD_INT 4
55100: MINUS
55101: PUSH
55102: LD_INT 3
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: LIST
55109: PUSH
55110: LD_VAR 0 1
55114: PUSH
55115: LD_INT 3
55117: MINUS
55118: PUSH
55119: LD_VAR 0 2
55123: PUSH
55124: LD_INT 3
55126: MINUS
55127: PUSH
55128: LD_INT 2
55130: PUSH
55131: EMPTY
55132: LIST
55133: LIST
55134: LIST
55135: PUSH
55136: LD_VAR 0 1
55140: PUSH
55141: LD_INT 4
55143: MINUS
55144: PUSH
55145: LD_VAR 0 2
55149: PUSH
55150: LD_INT 1
55152: PUSH
55153: EMPTY
55154: LIST
55155: LIST
55156: LIST
55157: PUSH
55158: LD_VAR 0 1
55162: PUSH
55163: LD_VAR 0 2
55167: PUSH
55168: LD_INT 3
55170: PLUS
55171: PUSH
55172: LD_INT 0
55174: PUSH
55175: EMPTY
55176: LIST
55177: LIST
55178: LIST
55179: PUSH
55180: LD_VAR 0 1
55184: PUSH
55185: LD_INT 4
55187: PLUS
55188: PUSH
55189: LD_VAR 0 2
55193: PUSH
55194: LD_INT 4
55196: PLUS
55197: PUSH
55198: LD_INT 5
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: LIST
55205: PUSH
55206: EMPTY
55207: LIST
55208: LIST
55209: LIST
55210: LIST
55211: LIST
55212: ST_TO_ADDR
// end ; 2 :
55213: GO 55772
55215: LD_INT 2
55217: DOUBLE
55218: EQUAL
55219: IFTRUE 55223
55221: GO 55352
55223: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55224: LD_ADDR_VAR 0 5
55228: PUSH
55229: LD_VAR 0 1
55233: PUSH
55234: LD_VAR 0 2
55238: PUSH
55239: LD_INT 3
55241: MINUS
55242: PUSH
55243: LD_INT 3
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: LIST
55250: PUSH
55251: LD_VAR 0 1
55255: PUSH
55256: LD_INT 4
55258: PLUS
55259: PUSH
55260: LD_VAR 0 2
55264: PUSH
55265: LD_INT 4
55267: PUSH
55268: EMPTY
55269: LIST
55270: LIST
55271: LIST
55272: PUSH
55273: LD_VAR 0 1
55277: PUSH
55278: LD_VAR 0 2
55282: PUSH
55283: LD_INT 4
55285: PLUS
55286: PUSH
55287: LD_INT 0
55289: PUSH
55290: EMPTY
55291: LIST
55292: LIST
55293: LIST
55294: PUSH
55295: LD_VAR 0 1
55299: PUSH
55300: LD_INT 3
55302: MINUS
55303: PUSH
55304: LD_VAR 0 2
55308: PUSH
55309: LD_INT 1
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: LIST
55316: PUSH
55317: LD_VAR 0 1
55321: PUSH
55322: LD_INT 4
55324: MINUS
55325: PUSH
55326: LD_VAR 0 2
55330: PUSH
55331: LD_INT 4
55333: MINUS
55334: PUSH
55335: LD_INT 2
55337: PUSH
55338: EMPTY
55339: LIST
55340: LIST
55341: LIST
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: LIST
55347: LIST
55348: LIST
55349: ST_TO_ADDR
// end ; 3 :
55350: GO 55772
55352: LD_INT 3
55354: DOUBLE
55355: EQUAL
55356: IFTRUE 55360
55358: GO 55493
55360: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55361: LD_ADDR_VAR 0 5
55365: PUSH
55366: LD_VAR 0 1
55370: PUSH
55371: LD_INT 3
55373: PLUS
55374: PUSH
55375: LD_VAR 0 2
55379: PUSH
55380: LD_INT 4
55382: PUSH
55383: EMPTY
55384: LIST
55385: LIST
55386: LIST
55387: PUSH
55388: LD_VAR 0 1
55392: PUSH
55393: LD_INT 4
55395: PLUS
55396: PUSH
55397: LD_VAR 0 2
55401: PUSH
55402: LD_INT 4
55404: PLUS
55405: PUSH
55406: LD_INT 5
55408: PUSH
55409: EMPTY
55410: LIST
55411: LIST
55412: LIST
55413: PUSH
55414: LD_VAR 0 1
55418: PUSH
55419: LD_INT 4
55421: MINUS
55422: PUSH
55423: LD_VAR 0 2
55427: PUSH
55428: LD_INT 1
55430: PUSH
55431: EMPTY
55432: LIST
55433: LIST
55434: LIST
55435: PUSH
55436: LD_VAR 0 1
55440: PUSH
55441: LD_VAR 0 2
55445: PUSH
55446: LD_INT 4
55448: MINUS
55449: PUSH
55450: LD_INT 3
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: LIST
55457: PUSH
55458: LD_VAR 0 1
55462: PUSH
55463: LD_INT 3
55465: MINUS
55466: PUSH
55467: LD_VAR 0 2
55471: PUSH
55472: LD_INT 3
55474: MINUS
55475: PUSH
55476: LD_INT 2
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: LIST
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: LIST
55488: LIST
55489: LIST
55490: ST_TO_ADDR
// end ; 4 :
55491: GO 55772
55493: LD_INT 4
55495: DOUBLE
55496: EQUAL
55497: IFTRUE 55501
55499: GO 55634
55501: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55502: LD_ADDR_VAR 0 5
55506: PUSH
55507: LD_VAR 0 1
55511: PUSH
55512: LD_VAR 0 2
55516: PUSH
55517: LD_INT 4
55519: PLUS
55520: PUSH
55521: LD_INT 0
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: LIST
55528: PUSH
55529: LD_VAR 0 1
55533: PUSH
55534: LD_INT 3
55536: PLUS
55537: PUSH
55538: LD_VAR 0 2
55542: PUSH
55543: LD_INT 3
55545: PLUS
55546: PUSH
55547: LD_INT 5
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: LIST
55554: PUSH
55555: LD_VAR 0 1
55559: PUSH
55560: LD_INT 4
55562: PLUS
55563: PUSH
55564: LD_VAR 0 2
55568: PUSH
55569: LD_INT 4
55571: PUSH
55572: EMPTY
55573: LIST
55574: LIST
55575: LIST
55576: PUSH
55577: LD_VAR 0 1
55581: PUSH
55582: LD_VAR 0 2
55586: PUSH
55587: LD_INT 3
55589: MINUS
55590: PUSH
55591: LD_INT 3
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: PUSH
55599: LD_VAR 0 1
55603: PUSH
55604: LD_INT 4
55606: MINUS
55607: PUSH
55608: LD_VAR 0 2
55612: PUSH
55613: LD_INT 4
55615: MINUS
55616: PUSH
55617: LD_INT 2
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: LIST
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: LIST
55629: LIST
55630: LIST
55631: ST_TO_ADDR
// end ; 5 :
55632: GO 55772
55634: LD_INT 5
55636: DOUBLE
55637: EQUAL
55638: IFTRUE 55642
55640: GO 55771
55642: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55643: LD_ADDR_VAR 0 5
55647: PUSH
55648: LD_VAR 0 1
55652: PUSH
55653: LD_INT 4
55655: MINUS
55656: PUSH
55657: LD_VAR 0 2
55661: PUSH
55662: LD_INT 1
55664: PUSH
55665: EMPTY
55666: LIST
55667: LIST
55668: LIST
55669: PUSH
55670: LD_VAR 0 1
55674: PUSH
55675: LD_VAR 0 2
55679: PUSH
55680: LD_INT 4
55682: MINUS
55683: PUSH
55684: LD_INT 3
55686: PUSH
55687: EMPTY
55688: LIST
55689: LIST
55690: LIST
55691: PUSH
55692: LD_VAR 0 1
55696: PUSH
55697: LD_INT 4
55699: PLUS
55700: PUSH
55701: LD_VAR 0 2
55705: PUSH
55706: LD_INT 4
55708: PLUS
55709: PUSH
55710: LD_INT 5
55712: PUSH
55713: EMPTY
55714: LIST
55715: LIST
55716: LIST
55717: PUSH
55718: LD_VAR 0 1
55722: PUSH
55723: LD_INT 3
55725: PLUS
55726: PUSH
55727: LD_VAR 0 2
55731: PUSH
55732: LD_INT 4
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: LIST
55739: PUSH
55740: LD_VAR 0 1
55744: PUSH
55745: LD_VAR 0 2
55749: PUSH
55750: LD_INT 3
55752: PLUS
55753: PUSH
55754: LD_INT 0
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: LIST
55761: PUSH
55762: EMPTY
55763: LIST
55764: LIST
55765: LIST
55766: LIST
55767: LIST
55768: ST_TO_ADDR
// end ; end ;
55769: GO 55772
55771: POP
// result := list ;
55772: LD_ADDR_VAR 0 4
55776: PUSH
55777: LD_VAR 0 5
55781: ST_TO_ADDR
// end ;
55782: LD_VAR 0 4
55786: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55787: LD_INT 0
55789: PPUSH
55790: PPUSH
55791: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55792: LD_VAR 0 1
55796: NOT
55797: PUSH
55798: LD_VAR 0 2
55802: PUSH
55803: LD_INT 1
55805: PUSH
55806: LD_INT 2
55808: PUSH
55809: LD_INT 3
55811: PUSH
55812: LD_INT 4
55814: PUSH
55815: EMPTY
55816: LIST
55817: LIST
55818: LIST
55819: LIST
55820: IN
55821: NOT
55822: OR
55823: IFFALSE 55827
// exit ;
55825: GO 55919
// tmp := [ ] ;
55827: LD_ADDR_VAR 0 5
55831: PUSH
55832: EMPTY
55833: ST_TO_ADDR
// for i in units do
55834: LD_ADDR_VAR 0 4
55838: PUSH
55839: LD_VAR 0 1
55843: PUSH
55844: FOR_IN
55845: IFFALSE 55888
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55847: LD_ADDR_VAR 0 5
55851: PUSH
55852: LD_VAR 0 5
55856: PPUSH
55857: LD_VAR 0 5
55861: PUSH
55862: LD_INT 1
55864: PLUS
55865: PPUSH
55866: LD_VAR 0 4
55870: PPUSH
55871: LD_VAR 0 2
55875: PPUSH
55876: CALL_OW 259
55880: PPUSH
55881: CALL_OW 2
55885: ST_TO_ADDR
55886: GO 55844
55888: POP
55889: POP
// if not tmp then
55890: LD_VAR 0 5
55894: NOT
55895: IFFALSE 55899
// exit ;
55897: GO 55919
// result := SortListByListDesc ( units , tmp ) ;
55899: LD_ADDR_VAR 0 3
55903: PUSH
55904: LD_VAR 0 1
55908: PPUSH
55909: LD_VAR 0 5
55913: PPUSH
55914: CALL_OW 77
55918: ST_TO_ADDR
// end ;
55919: LD_VAR 0 3
55923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55924: LD_INT 0
55926: PPUSH
55927: PPUSH
55928: PPUSH
// x := GetX ( building ) ;
55929: LD_ADDR_VAR 0 4
55933: PUSH
55934: LD_VAR 0 2
55938: PPUSH
55939: CALL_OW 250
55943: ST_TO_ADDR
// y := GetY ( building ) ;
55944: LD_ADDR_VAR 0 5
55948: PUSH
55949: LD_VAR 0 2
55953: PPUSH
55954: CALL_OW 251
55958: ST_TO_ADDR
// if GetTaskList ( unit ) then
55959: LD_VAR 0 1
55963: PPUSH
55964: CALL_OW 437
55968: IFFALSE 56063
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55970: LD_STRING e
55972: PUSH
55973: LD_VAR 0 1
55977: PPUSH
55978: CALL_OW 437
55982: PUSH
55983: LD_INT 1
55985: ARRAY
55986: PUSH
55987: LD_INT 1
55989: ARRAY
55990: EQUAL
55991: PUSH
55992: LD_VAR 0 4
55996: PUSH
55997: LD_VAR 0 1
56001: PPUSH
56002: CALL_OW 437
56006: PUSH
56007: LD_INT 1
56009: ARRAY
56010: PUSH
56011: LD_INT 2
56013: ARRAY
56014: EQUAL
56015: AND
56016: PUSH
56017: LD_VAR 0 5
56021: PUSH
56022: LD_VAR 0 1
56026: PPUSH
56027: CALL_OW 437
56031: PUSH
56032: LD_INT 1
56034: ARRAY
56035: PUSH
56036: LD_INT 3
56038: ARRAY
56039: EQUAL
56040: AND
56041: IFFALSE 56053
// result := true else
56043: LD_ADDR_VAR 0 3
56047: PUSH
56048: LD_INT 1
56050: ST_TO_ADDR
56051: GO 56061
// result := false ;
56053: LD_ADDR_VAR 0 3
56057: PUSH
56058: LD_INT 0
56060: ST_TO_ADDR
// end else
56061: GO 56071
// result := false ;
56063: LD_ADDR_VAR 0 3
56067: PUSH
56068: LD_INT 0
56070: ST_TO_ADDR
// end ;
56071: LD_VAR 0 3
56075: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56076: LD_INT 0
56078: PPUSH
56079: PPUSH
56080: PPUSH
56081: PPUSH
// if not unit or not area then
56082: LD_VAR 0 1
56086: NOT
56087: PUSH
56088: LD_VAR 0 2
56092: NOT
56093: OR
56094: IFFALSE 56098
// exit ;
56096: GO 56262
// tmp := AreaToList ( area , i ) ;
56098: LD_ADDR_VAR 0 6
56102: PUSH
56103: LD_VAR 0 2
56107: PPUSH
56108: LD_VAR 0 5
56112: PPUSH
56113: CALL_OW 517
56117: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56118: LD_ADDR_VAR 0 5
56122: PUSH
56123: DOUBLE
56124: LD_INT 1
56126: DEC
56127: ST_TO_ADDR
56128: LD_VAR 0 6
56132: PUSH
56133: LD_INT 1
56135: ARRAY
56136: PUSH
56137: FOR_TO
56138: IFFALSE 56260
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56140: LD_ADDR_VAR 0 7
56144: PUSH
56145: LD_VAR 0 6
56149: PUSH
56150: LD_INT 1
56152: ARRAY
56153: PUSH
56154: LD_VAR 0 5
56158: ARRAY
56159: PUSH
56160: LD_VAR 0 6
56164: PUSH
56165: LD_INT 2
56167: ARRAY
56168: PUSH
56169: LD_VAR 0 5
56173: ARRAY
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56179: LD_VAR 0 7
56183: PUSH
56184: LD_INT 1
56186: ARRAY
56187: PPUSH
56188: LD_VAR 0 7
56192: PUSH
56193: LD_INT 2
56195: ARRAY
56196: PPUSH
56197: CALL_OW 428
56201: PUSH
56202: LD_INT 0
56204: EQUAL
56205: IFFALSE 56258
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56207: LD_VAR 0 1
56211: PPUSH
56212: LD_VAR 0 7
56216: PUSH
56217: LD_INT 1
56219: ARRAY
56220: PPUSH
56221: LD_VAR 0 7
56225: PUSH
56226: LD_INT 2
56228: ARRAY
56229: PPUSH
56230: LD_VAR 0 3
56234: PPUSH
56235: CALL_OW 48
// result := IsPlaced ( unit ) ;
56239: LD_ADDR_VAR 0 4
56243: PUSH
56244: LD_VAR 0 1
56248: PPUSH
56249: CALL_OW 305
56253: ST_TO_ADDR
// exit ;
56254: POP
56255: POP
56256: GO 56262
// end ; end ;
56258: GO 56137
56260: POP
56261: POP
// end ;
56262: LD_VAR 0 4
56266: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56267: LD_INT 0
56269: PPUSH
56270: PPUSH
56271: PPUSH
// if not side or side > 8 then
56272: LD_VAR 0 1
56276: NOT
56277: PUSH
56278: LD_VAR 0 1
56282: PUSH
56283: LD_INT 8
56285: GREATER
56286: OR
56287: IFFALSE 56291
// exit ;
56289: GO 56478
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56291: LD_ADDR_VAR 0 4
56295: PUSH
56296: LD_INT 22
56298: PUSH
56299: LD_VAR 0 1
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PUSH
56308: LD_INT 21
56310: PUSH
56311: LD_INT 3
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: PPUSH
56322: CALL_OW 69
56326: ST_TO_ADDR
// if not tmp then
56327: LD_VAR 0 4
56331: NOT
56332: IFFALSE 56336
// exit ;
56334: GO 56478
// enable_addtolog := true ;
56336: LD_ADDR_OWVAR 81
56340: PUSH
56341: LD_INT 1
56343: ST_TO_ADDR
// AddToLog ( [ ) ;
56344: LD_STRING [
56346: PPUSH
56347: CALL_OW 561
// for i in tmp do
56351: LD_ADDR_VAR 0 3
56355: PUSH
56356: LD_VAR 0 4
56360: PUSH
56361: FOR_IN
56362: IFFALSE 56469
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56364: LD_STRING [
56366: PUSH
56367: LD_VAR 0 3
56371: PPUSH
56372: CALL_OW 266
56376: STR
56377: PUSH
56378: LD_STRING , 
56380: STR
56381: PUSH
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 250
56391: STR
56392: PUSH
56393: LD_STRING , 
56395: STR
56396: PUSH
56397: LD_VAR 0 3
56401: PPUSH
56402: CALL_OW 251
56406: STR
56407: PUSH
56408: LD_STRING , 
56410: STR
56411: PUSH
56412: LD_VAR 0 3
56416: PPUSH
56417: CALL_OW 254
56421: STR
56422: PUSH
56423: LD_STRING , 
56425: STR
56426: PUSH
56427: LD_VAR 0 3
56431: PPUSH
56432: LD_INT 1
56434: PPUSH
56435: CALL_OW 268
56439: STR
56440: PUSH
56441: LD_STRING , 
56443: STR
56444: PUSH
56445: LD_VAR 0 3
56449: PPUSH
56450: LD_INT 2
56452: PPUSH
56453: CALL_OW 268
56457: STR
56458: PUSH
56459: LD_STRING ],
56461: STR
56462: PPUSH
56463: CALL_OW 561
// end ;
56467: GO 56361
56469: POP
56470: POP
// AddToLog ( ]; ) ;
56471: LD_STRING ];
56473: PPUSH
56474: CALL_OW 561
// end ;
56478: LD_VAR 0 2
56482: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56483: LD_INT 0
56485: PPUSH
56486: PPUSH
56487: PPUSH
56488: PPUSH
56489: PPUSH
// if not area or not rate or not max then
56490: LD_VAR 0 1
56494: NOT
56495: PUSH
56496: LD_VAR 0 2
56500: NOT
56501: OR
56502: PUSH
56503: LD_VAR 0 4
56507: NOT
56508: OR
56509: IFFALSE 56513
// exit ;
56511: GO 56705
// while 1 do
56513: LD_INT 1
56515: IFFALSE 56705
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56517: LD_ADDR_VAR 0 9
56521: PUSH
56522: LD_VAR 0 1
56526: PPUSH
56527: LD_INT 1
56529: PPUSH
56530: CALL_OW 287
56534: PUSH
56535: LD_INT 10
56537: MUL
56538: ST_TO_ADDR
// r := rate / 10 ;
56539: LD_ADDR_VAR 0 7
56543: PUSH
56544: LD_VAR 0 2
56548: PUSH
56549: LD_INT 10
56551: DIVREAL
56552: ST_TO_ADDR
// time := 1 1$00 ;
56553: LD_ADDR_VAR 0 8
56557: PUSH
56558: LD_INT 2100
56560: ST_TO_ADDR
// if amount < min then
56561: LD_VAR 0 9
56565: PUSH
56566: LD_VAR 0 3
56570: LESS
56571: IFFALSE 56589
// r := r * 2 else
56573: LD_ADDR_VAR 0 7
56577: PUSH
56578: LD_VAR 0 7
56582: PUSH
56583: LD_INT 2
56585: MUL
56586: ST_TO_ADDR
56587: GO 56615
// if amount > max then
56589: LD_VAR 0 9
56593: PUSH
56594: LD_VAR 0 4
56598: GREATER
56599: IFFALSE 56615
// r := r / 2 ;
56601: LD_ADDR_VAR 0 7
56605: PUSH
56606: LD_VAR 0 7
56610: PUSH
56611: LD_INT 2
56613: DIVREAL
56614: ST_TO_ADDR
// time := time / r ;
56615: LD_ADDR_VAR 0 8
56619: PUSH
56620: LD_VAR 0 8
56624: PUSH
56625: LD_VAR 0 7
56629: DIVREAL
56630: ST_TO_ADDR
// if time < 0 then
56631: LD_VAR 0 8
56635: PUSH
56636: LD_INT 0
56638: LESS
56639: IFFALSE 56656
// time := time * - 1 ;
56641: LD_ADDR_VAR 0 8
56645: PUSH
56646: LD_VAR 0 8
56650: PUSH
56651: LD_INT 1
56653: NEG
56654: MUL
56655: ST_TO_ADDR
// wait ( time ) ;
56656: LD_VAR 0 8
56660: PPUSH
56661: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56665: LD_INT 35
56667: PPUSH
56668: LD_INT 875
56670: PPUSH
56671: CALL_OW 12
56675: PPUSH
56676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56680: LD_INT 1
56682: PPUSH
56683: LD_INT 5
56685: PPUSH
56686: CALL_OW 12
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: LD_INT 1
56698: PPUSH
56699: CALL_OW 55
// end ;
56703: GO 56513
// end ;
56705: LD_VAR 0 5
56709: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56710: LD_INT 0
56712: PPUSH
56713: PPUSH
56714: PPUSH
56715: PPUSH
56716: PPUSH
56717: PPUSH
56718: PPUSH
56719: PPUSH
// if not turrets or not factories then
56720: LD_VAR 0 1
56724: NOT
56725: PUSH
56726: LD_VAR 0 2
56730: NOT
56731: OR
56732: IFFALSE 56736
// exit ;
56734: GO 57043
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56736: LD_ADDR_VAR 0 10
56740: PUSH
56741: LD_INT 5
56743: PUSH
56744: LD_INT 6
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PUSH
56751: LD_INT 2
56753: PUSH
56754: LD_INT 4
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PUSH
56761: LD_INT 3
56763: PUSH
56764: LD_INT 5
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: LIST
56775: PUSH
56776: LD_INT 24
56778: PUSH
56779: LD_INT 25
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: PUSH
56786: LD_INT 23
56788: PUSH
56789: LD_INT 27
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: LD_INT 42
56802: PUSH
56803: LD_INT 43
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: PUSH
56810: LD_INT 44
56812: PUSH
56813: LD_INT 46
56815: PUSH
56816: EMPTY
56817: LIST
56818: LIST
56819: PUSH
56820: LD_INT 45
56822: PUSH
56823: LD_INT 47
56825: PUSH
56826: EMPTY
56827: LIST
56828: LIST
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: LIST
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: ST_TO_ADDR
// result := [ ] ;
56840: LD_ADDR_VAR 0 3
56844: PUSH
56845: EMPTY
56846: ST_TO_ADDR
// for i in turrets do
56847: LD_ADDR_VAR 0 4
56851: PUSH
56852: LD_VAR 0 1
56856: PUSH
56857: FOR_IN
56858: IFFALSE 57041
// begin nat := GetNation ( i ) ;
56860: LD_ADDR_VAR 0 7
56864: PUSH
56865: LD_VAR 0 4
56869: PPUSH
56870: CALL_OW 248
56874: ST_TO_ADDR
// weapon := 0 ;
56875: LD_ADDR_VAR 0 8
56879: PUSH
56880: LD_INT 0
56882: ST_TO_ADDR
// if not nat then
56883: LD_VAR 0 7
56887: NOT
56888: IFFALSE 56892
// continue ;
56890: GO 56857
// for j in list [ nat ] do
56892: LD_ADDR_VAR 0 5
56896: PUSH
56897: LD_VAR 0 10
56901: PUSH
56902: LD_VAR 0 7
56906: ARRAY
56907: PUSH
56908: FOR_IN
56909: IFFALSE 56950
// if GetBWeapon ( i ) = j [ 1 ] then
56911: LD_VAR 0 4
56915: PPUSH
56916: CALL_OW 269
56920: PUSH
56921: LD_VAR 0 5
56925: PUSH
56926: LD_INT 1
56928: ARRAY
56929: EQUAL
56930: IFFALSE 56948
// begin weapon := j [ 2 ] ;
56932: LD_ADDR_VAR 0 8
56936: PUSH
56937: LD_VAR 0 5
56941: PUSH
56942: LD_INT 2
56944: ARRAY
56945: ST_TO_ADDR
// break ;
56946: GO 56950
// end ;
56948: GO 56908
56950: POP
56951: POP
// if not weapon then
56952: LD_VAR 0 8
56956: NOT
56957: IFFALSE 56961
// continue ;
56959: GO 56857
// for k in factories do
56961: LD_ADDR_VAR 0 6
56965: PUSH
56966: LD_VAR 0 2
56970: PUSH
56971: FOR_IN
56972: IFFALSE 57037
// begin weapons := AvailableWeaponList ( k ) ;
56974: LD_ADDR_VAR 0 9
56978: PUSH
56979: LD_VAR 0 6
56983: PPUSH
56984: CALL_OW 478
56988: ST_TO_ADDR
// if not weapons then
56989: LD_VAR 0 9
56993: NOT
56994: IFFALSE 56998
// continue ;
56996: GO 56971
// if weapon in weapons then
56998: LD_VAR 0 8
57002: PUSH
57003: LD_VAR 0 9
57007: IN
57008: IFFALSE 57035
// begin result := [ i , weapon ] ;
57010: LD_ADDR_VAR 0 3
57014: PUSH
57015: LD_VAR 0 4
57019: PUSH
57020: LD_VAR 0 8
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: ST_TO_ADDR
// exit ;
57029: POP
57030: POP
57031: POP
57032: POP
57033: GO 57043
// end ; end ;
57035: GO 56971
57037: POP
57038: POP
// end ;
57039: GO 56857
57041: POP
57042: POP
// end ;
57043: LD_VAR 0 3
57047: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57048: LD_INT 0
57050: PPUSH
// if not side or side > 8 then
57051: LD_VAR 0 3
57055: NOT
57056: PUSH
57057: LD_VAR 0 3
57061: PUSH
57062: LD_INT 8
57064: GREATER
57065: OR
57066: IFFALSE 57070
// exit ;
57068: GO 57129
// if not range then
57070: LD_VAR 0 4
57074: NOT
57075: IFFALSE 57086
// range := - 12 ;
57077: LD_ADDR_VAR 0 4
57081: PUSH
57082: LD_INT 12
57084: NEG
57085: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57086: LD_VAR 0 1
57090: PPUSH
57091: LD_VAR 0 2
57095: PPUSH
57096: LD_VAR 0 3
57100: PPUSH
57101: LD_VAR 0 4
57105: PPUSH
57106: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57110: LD_VAR 0 1
57114: PPUSH
57115: LD_VAR 0 2
57119: PPUSH
57120: LD_VAR 0 3
57124: PPUSH
57125: CALL_OW 331
// end ;
57129: LD_VAR 0 5
57133: RET
// export function Video ( mode ) ; begin
57134: LD_INT 0
57136: PPUSH
// ingame_video = mode ;
57137: LD_ADDR_OWVAR 52
57141: PUSH
57142: LD_VAR 0 1
57146: ST_TO_ADDR
// interface_hidden = mode ;
57147: LD_ADDR_OWVAR 54
57151: PUSH
57152: LD_VAR 0 1
57156: ST_TO_ADDR
// end ;
57157: LD_VAR 0 2
57161: RET
// export function Join ( array , element ) ; begin
57162: LD_INT 0
57164: PPUSH
// result := array ^ element ;
57165: LD_ADDR_VAR 0 3
57169: PUSH
57170: LD_VAR 0 1
57174: PUSH
57175: LD_VAR 0 2
57179: ADD
57180: ST_TO_ADDR
// end ;
57181: LD_VAR 0 3
57185: RET
// export function JoinUnion ( array , element ) ; begin
57186: LD_INT 0
57188: PPUSH
// result := array union element ;
57189: LD_ADDR_VAR 0 3
57193: PUSH
57194: LD_VAR 0 1
57198: PUSH
57199: LD_VAR 0 2
57203: UNION
57204: ST_TO_ADDR
// end ;
57205: LD_VAR 0 3
57209: RET
// export function GetBehemoths ( side ) ; begin
57210: LD_INT 0
57212: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57213: LD_ADDR_VAR 0 2
57217: PUSH
57218: LD_INT 22
57220: PUSH
57221: LD_VAR 0 1
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: PUSH
57230: LD_INT 31
57232: PUSH
57233: LD_INT 25
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PPUSH
57244: CALL_OW 69
57248: ST_TO_ADDR
// end ;
57249: LD_VAR 0 2
57253: RET
// export function Shuffle ( array ) ; var i , index ; begin
57254: LD_INT 0
57256: PPUSH
57257: PPUSH
57258: PPUSH
// result := [ ] ;
57259: LD_ADDR_VAR 0 2
57263: PUSH
57264: EMPTY
57265: ST_TO_ADDR
// if not array then
57266: LD_VAR 0 1
57270: NOT
57271: IFFALSE 57275
// exit ;
57273: GO 57374
// Randomize ;
57275: CALL_OW 10
// for i = array downto 1 do
57279: LD_ADDR_VAR 0 3
57283: PUSH
57284: DOUBLE
57285: LD_VAR 0 1
57289: INC
57290: ST_TO_ADDR
57291: LD_INT 1
57293: PUSH
57294: FOR_DOWNTO
57295: IFFALSE 57372
// begin index := rand ( 1 , array ) ;
57297: LD_ADDR_VAR 0 4
57301: PUSH
57302: LD_INT 1
57304: PPUSH
57305: LD_VAR 0 1
57309: PPUSH
57310: CALL_OW 12
57314: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57315: LD_ADDR_VAR 0 2
57319: PUSH
57320: LD_VAR 0 2
57324: PPUSH
57325: LD_VAR 0 2
57329: PUSH
57330: LD_INT 1
57332: PLUS
57333: PPUSH
57334: LD_VAR 0 1
57338: PUSH
57339: LD_VAR 0 4
57343: ARRAY
57344: PPUSH
57345: CALL_OW 2
57349: ST_TO_ADDR
// array := Delete ( array , index ) ;
57350: LD_ADDR_VAR 0 1
57354: PUSH
57355: LD_VAR 0 1
57359: PPUSH
57360: LD_VAR 0 4
57364: PPUSH
57365: CALL_OW 3
57369: ST_TO_ADDR
// end ;
57370: GO 57294
57372: POP
57373: POP
// end ;
57374: LD_VAR 0 2
57378: RET
// export function GetBaseMaterials ( base ) ; begin
57379: LD_INT 0
57381: PPUSH
// result := [ 0 , 0 , 0 ] ;
57382: LD_ADDR_VAR 0 2
57386: PUSH
57387: LD_INT 0
57389: PUSH
57390: LD_INT 0
57392: PUSH
57393: LD_INT 0
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: LIST
57400: ST_TO_ADDR
// if not base then
57401: LD_VAR 0 1
57405: NOT
57406: IFFALSE 57410
// exit ;
57408: GO 57459
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57410: LD_ADDR_VAR 0 2
57414: PUSH
57415: LD_VAR 0 1
57419: PPUSH
57420: LD_INT 1
57422: PPUSH
57423: CALL_OW 275
57427: PUSH
57428: LD_VAR 0 1
57432: PPUSH
57433: LD_INT 2
57435: PPUSH
57436: CALL_OW 275
57440: PUSH
57441: LD_VAR 0 1
57445: PPUSH
57446: LD_INT 3
57448: PPUSH
57449: CALL_OW 275
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: LIST
57458: ST_TO_ADDR
// end ; end_of_file
57459: LD_VAR 0 2
57463: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57464: LD_INT 0
57466: PPUSH
57467: PPUSH
// skirmish := false ;
57468: LD_ADDR_EXP 57
57472: PUSH
57473: LD_INT 0
57475: ST_TO_ADDR
// debug_mc := false ;
57476: LD_ADDR_EXP 58
57480: PUSH
57481: LD_INT 0
57483: ST_TO_ADDR
// mc_bases := [ ] ;
57484: LD_ADDR_EXP 59
57488: PUSH
57489: EMPTY
57490: ST_TO_ADDR
// mc_sides := [ ] ;
57491: LD_ADDR_EXP 85
57495: PUSH
57496: EMPTY
57497: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57498: LD_ADDR_EXP 60
57502: PUSH
57503: EMPTY
57504: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57505: LD_ADDR_EXP 61
57509: PUSH
57510: EMPTY
57511: ST_TO_ADDR
// mc_need_heal := [ ] ;
57512: LD_ADDR_EXP 62
57516: PUSH
57517: EMPTY
57518: ST_TO_ADDR
// mc_healers := [ ] ;
57519: LD_ADDR_EXP 63
57523: PUSH
57524: EMPTY
57525: ST_TO_ADDR
// mc_build_list := [ ] ;
57526: LD_ADDR_EXP 64
57530: PUSH
57531: EMPTY
57532: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57533: LD_ADDR_EXP 91
57537: PUSH
57538: EMPTY
57539: ST_TO_ADDR
// mc_builders := [ ] ;
57540: LD_ADDR_EXP 65
57544: PUSH
57545: EMPTY
57546: ST_TO_ADDR
// mc_construct_list := [ ] ;
57547: LD_ADDR_EXP 66
57551: PUSH
57552: EMPTY
57553: ST_TO_ADDR
// mc_turret_list := [ ] ;
57554: LD_ADDR_EXP 67
57558: PUSH
57559: EMPTY
57560: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57561: LD_ADDR_EXP 68
57565: PUSH
57566: EMPTY
57567: ST_TO_ADDR
// mc_miners := [ ] ;
57568: LD_ADDR_EXP 73
57572: PUSH
57573: EMPTY
57574: ST_TO_ADDR
// mc_mines := [ ] ;
57575: LD_ADDR_EXP 72
57579: PUSH
57580: EMPTY
57581: ST_TO_ADDR
// mc_minefields := [ ] ;
57582: LD_ADDR_EXP 74
57586: PUSH
57587: EMPTY
57588: ST_TO_ADDR
// mc_crates := [ ] ;
57589: LD_ADDR_EXP 75
57593: PUSH
57594: EMPTY
57595: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57596: LD_ADDR_EXP 76
57600: PUSH
57601: EMPTY
57602: ST_TO_ADDR
// mc_crates_area := [ ] ;
57603: LD_ADDR_EXP 77
57607: PUSH
57608: EMPTY
57609: ST_TO_ADDR
// mc_vehicles := [ ] ;
57610: LD_ADDR_EXP 78
57614: PUSH
57615: EMPTY
57616: ST_TO_ADDR
// mc_attack := [ ] ;
57617: LD_ADDR_EXP 79
57621: PUSH
57622: EMPTY
57623: ST_TO_ADDR
// mc_produce := [ ] ;
57624: LD_ADDR_EXP 80
57628: PUSH
57629: EMPTY
57630: ST_TO_ADDR
// mc_defender := [ ] ;
57631: LD_ADDR_EXP 81
57635: PUSH
57636: EMPTY
57637: ST_TO_ADDR
// mc_parking := [ ] ;
57638: LD_ADDR_EXP 83
57642: PUSH
57643: EMPTY
57644: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57645: LD_ADDR_EXP 69
57649: PUSH
57650: EMPTY
57651: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57652: LD_ADDR_EXP 71
57656: PUSH
57657: EMPTY
57658: ST_TO_ADDR
// mc_scan := [ ] ;
57659: LD_ADDR_EXP 82
57663: PUSH
57664: EMPTY
57665: ST_TO_ADDR
// mc_scan_area := [ ] ;
57666: LD_ADDR_EXP 84
57670: PUSH
57671: EMPTY
57672: ST_TO_ADDR
// mc_tech := [ ] ;
57673: LD_ADDR_EXP 86
57677: PUSH
57678: EMPTY
57679: ST_TO_ADDR
// mc_class := [ ] ;
57680: LD_ADDR_EXP 100
57684: PUSH
57685: EMPTY
57686: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57687: LD_ADDR_EXP 101
57691: PUSH
57692: EMPTY
57693: ST_TO_ADDR
// end ;
57694: LD_VAR 0 1
57698: RET
// export function MC_Kill ( base ) ; begin
57699: LD_INT 0
57701: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57702: LD_ADDR_EXP 59
57706: PUSH
57707: LD_EXP 59
57711: PPUSH
57712: LD_VAR 0 1
57716: PPUSH
57717: EMPTY
57718: PPUSH
57719: CALL_OW 1
57723: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57724: LD_ADDR_EXP 60
57728: PUSH
57729: LD_EXP 60
57733: PPUSH
57734: LD_VAR 0 1
57738: PPUSH
57739: EMPTY
57740: PPUSH
57741: CALL_OW 1
57745: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57746: LD_ADDR_EXP 61
57750: PUSH
57751: LD_EXP 61
57755: PPUSH
57756: LD_VAR 0 1
57760: PPUSH
57761: EMPTY
57762: PPUSH
57763: CALL_OW 1
57767: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57768: LD_ADDR_EXP 62
57772: PUSH
57773: LD_EXP 62
57777: PPUSH
57778: LD_VAR 0 1
57782: PPUSH
57783: EMPTY
57784: PPUSH
57785: CALL_OW 1
57789: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57790: LD_ADDR_EXP 63
57794: PUSH
57795: LD_EXP 63
57799: PPUSH
57800: LD_VAR 0 1
57804: PPUSH
57805: EMPTY
57806: PPUSH
57807: CALL_OW 1
57811: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57812: LD_ADDR_EXP 64
57816: PUSH
57817: LD_EXP 64
57821: PPUSH
57822: LD_VAR 0 1
57826: PPUSH
57827: EMPTY
57828: PPUSH
57829: CALL_OW 1
57833: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57834: LD_ADDR_EXP 65
57838: PUSH
57839: LD_EXP 65
57843: PPUSH
57844: LD_VAR 0 1
57848: PPUSH
57849: EMPTY
57850: PPUSH
57851: CALL_OW 1
57855: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57856: LD_ADDR_EXP 66
57860: PUSH
57861: LD_EXP 66
57865: PPUSH
57866: LD_VAR 0 1
57870: PPUSH
57871: EMPTY
57872: PPUSH
57873: CALL_OW 1
57877: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57878: LD_ADDR_EXP 67
57882: PUSH
57883: LD_EXP 67
57887: PPUSH
57888: LD_VAR 0 1
57892: PPUSH
57893: EMPTY
57894: PPUSH
57895: CALL_OW 1
57899: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57900: LD_ADDR_EXP 68
57904: PUSH
57905: LD_EXP 68
57909: PPUSH
57910: LD_VAR 0 1
57914: PPUSH
57915: EMPTY
57916: PPUSH
57917: CALL_OW 1
57921: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57922: LD_ADDR_EXP 69
57926: PUSH
57927: LD_EXP 69
57931: PPUSH
57932: LD_VAR 0 1
57936: PPUSH
57937: EMPTY
57938: PPUSH
57939: CALL_OW 1
57943: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57944: LD_ADDR_EXP 70
57948: PUSH
57949: LD_EXP 70
57953: PPUSH
57954: LD_VAR 0 1
57958: PPUSH
57959: LD_INT 0
57961: PPUSH
57962: CALL_OW 1
57966: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57967: LD_ADDR_EXP 71
57971: PUSH
57972: LD_EXP 71
57976: PPUSH
57977: LD_VAR 0 1
57981: PPUSH
57982: EMPTY
57983: PPUSH
57984: CALL_OW 1
57988: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57989: LD_ADDR_EXP 72
57993: PUSH
57994: LD_EXP 72
57998: PPUSH
57999: LD_VAR 0 1
58003: PPUSH
58004: EMPTY
58005: PPUSH
58006: CALL_OW 1
58010: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58011: LD_ADDR_EXP 73
58015: PUSH
58016: LD_EXP 73
58020: PPUSH
58021: LD_VAR 0 1
58025: PPUSH
58026: EMPTY
58027: PPUSH
58028: CALL_OW 1
58032: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58033: LD_ADDR_EXP 74
58037: PUSH
58038: LD_EXP 74
58042: PPUSH
58043: LD_VAR 0 1
58047: PPUSH
58048: EMPTY
58049: PPUSH
58050: CALL_OW 1
58054: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58055: LD_ADDR_EXP 75
58059: PUSH
58060: LD_EXP 75
58064: PPUSH
58065: LD_VAR 0 1
58069: PPUSH
58070: EMPTY
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58077: LD_ADDR_EXP 76
58081: PUSH
58082: LD_EXP 76
58086: PPUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: EMPTY
58093: PPUSH
58094: CALL_OW 1
58098: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58099: LD_ADDR_EXP 77
58103: PUSH
58104: LD_EXP 77
58108: PPUSH
58109: LD_VAR 0 1
58113: PPUSH
58114: EMPTY
58115: PPUSH
58116: CALL_OW 1
58120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58121: LD_ADDR_EXP 78
58125: PUSH
58126: LD_EXP 78
58130: PPUSH
58131: LD_VAR 0 1
58135: PPUSH
58136: EMPTY
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58143: LD_ADDR_EXP 79
58147: PUSH
58148: LD_EXP 79
58152: PPUSH
58153: LD_VAR 0 1
58157: PPUSH
58158: EMPTY
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58165: LD_ADDR_EXP 80
58169: PUSH
58170: LD_EXP 80
58174: PPUSH
58175: LD_VAR 0 1
58179: PPUSH
58180: EMPTY
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58187: LD_ADDR_EXP 81
58191: PUSH
58192: LD_EXP 81
58196: PPUSH
58197: LD_VAR 0 1
58201: PPUSH
58202: EMPTY
58203: PPUSH
58204: CALL_OW 1
58208: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58209: LD_ADDR_EXP 82
58213: PUSH
58214: LD_EXP 82
58218: PPUSH
58219: LD_VAR 0 1
58223: PPUSH
58224: EMPTY
58225: PPUSH
58226: CALL_OW 1
58230: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58231: LD_ADDR_EXP 83
58235: PUSH
58236: LD_EXP 83
58240: PPUSH
58241: LD_VAR 0 1
58245: PPUSH
58246: EMPTY
58247: PPUSH
58248: CALL_OW 1
58252: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58253: LD_ADDR_EXP 84
58257: PUSH
58258: LD_EXP 84
58262: PPUSH
58263: LD_VAR 0 1
58267: PPUSH
58268: EMPTY
58269: PPUSH
58270: CALL_OW 1
58274: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58275: LD_ADDR_EXP 86
58279: PUSH
58280: LD_EXP 86
58284: PPUSH
58285: LD_VAR 0 1
58289: PPUSH
58290: EMPTY
58291: PPUSH
58292: CALL_OW 1
58296: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58297: LD_ADDR_EXP 88
58301: PUSH
58302: LD_EXP 88
58306: PPUSH
58307: LD_VAR 0 1
58311: PPUSH
58312: EMPTY
58313: PPUSH
58314: CALL_OW 1
58318: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58319: LD_ADDR_EXP 89
58323: PUSH
58324: LD_EXP 89
58328: PPUSH
58329: LD_VAR 0 1
58333: PPUSH
58334: EMPTY
58335: PPUSH
58336: CALL_OW 1
58340: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58341: LD_ADDR_EXP 90
58345: PUSH
58346: LD_EXP 90
58350: PPUSH
58351: LD_VAR 0 1
58355: PPUSH
58356: EMPTY
58357: PPUSH
58358: CALL_OW 1
58362: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58363: LD_ADDR_EXP 91
58367: PUSH
58368: LD_EXP 91
58372: PPUSH
58373: LD_VAR 0 1
58377: PPUSH
58378: EMPTY
58379: PPUSH
58380: CALL_OW 1
58384: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58385: LD_ADDR_EXP 92
58389: PUSH
58390: LD_EXP 92
58394: PPUSH
58395: LD_VAR 0 1
58399: PPUSH
58400: EMPTY
58401: PPUSH
58402: CALL_OW 1
58406: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58407: LD_ADDR_EXP 93
58411: PUSH
58412: LD_EXP 93
58416: PPUSH
58417: LD_VAR 0 1
58421: PPUSH
58422: EMPTY
58423: PPUSH
58424: CALL_OW 1
58428: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58429: LD_ADDR_EXP 94
58433: PUSH
58434: LD_EXP 94
58438: PPUSH
58439: LD_VAR 0 1
58443: PPUSH
58444: EMPTY
58445: PPUSH
58446: CALL_OW 1
58450: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58451: LD_ADDR_EXP 95
58455: PUSH
58456: LD_EXP 95
58460: PPUSH
58461: LD_VAR 0 1
58465: PPUSH
58466: EMPTY
58467: PPUSH
58468: CALL_OW 1
58472: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58473: LD_ADDR_EXP 96
58477: PUSH
58478: LD_EXP 96
58482: PPUSH
58483: LD_VAR 0 1
58487: PPUSH
58488: EMPTY
58489: PPUSH
58490: CALL_OW 1
58494: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58495: LD_ADDR_EXP 97
58499: PUSH
58500: LD_EXP 97
58504: PPUSH
58505: LD_VAR 0 1
58509: PPUSH
58510: EMPTY
58511: PPUSH
58512: CALL_OW 1
58516: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58517: LD_ADDR_EXP 98
58521: PUSH
58522: LD_EXP 98
58526: PPUSH
58527: LD_VAR 0 1
58531: PPUSH
58532: EMPTY
58533: PPUSH
58534: CALL_OW 1
58538: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58539: LD_ADDR_EXP 99
58543: PUSH
58544: LD_EXP 99
58548: PPUSH
58549: LD_VAR 0 1
58553: PPUSH
58554: EMPTY
58555: PPUSH
58556: CALL_OW 1
58560: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58561: LD_ADDR_EXP 100
58565: PUSH
58566: LD_EXP 100
58570: PPUSH
58571: LD_VAR 0 1
58575: PPUSH
58576: EMPTY
58577: PPUSH
58578: CALL_OW 1
58582: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58583: LD_ADDR_EXP 101
58587: PUSH
58588: LD_EXP 101
58592: PPUSH
58593: LD_VAR 0 1
58597: PPUSH
58598: LD_INT 0
58600: PPUSH
58601: CALL_OW 1
58605: ST_TO_ADDR
// end ;
58606: LD_VAR 0 2
58610: RET
// export function MC_Add ( side , units ) ; var base ; begin
58611: LD_INT 0
58613: PPUSH
58614: PPUSH
// base := mc_bases + 1 ;
58615: LD_ADDR_VAR 0 4
58619: PUSH
58620: LD_EXP 59
58624: PUSH
58625: LD_INT 1
58627: PLUS
58628: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58629: LD_ADDR_EXP 85
58633: PUSH
58634: LD_EXP 85
58638: PPUSH
58639: LD_VAR 0 4
58643: PPUSH
58644: LD_VAR 0 1
58648: PPUSH
58649: CALL_OW 1
58653: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58654: LD_ADDR_EXP 59
58658: PUSH
58659: LD_EXP 59
58663: PPUSH
58664: LD_VAR 0 4
58668: PPUSH
58669: LD_VAR 0 2
58673: PPUSH
58674: CALL_OW 1
58678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58679: LD_ADDR_EXP 60
58683: PUSH
58684: LD_EXP 60
58688: PPUSH
58689: LD_VAR 0 4
58693: PPUSH
58694: EMPTY
58695: PPUSH
58696: CALL_OW 1
58700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58701: LD_ADDR_EXP 61
58705: PUSH
58706: LD_EXP 61
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: EMPTY
58717: PPUSH
58718: CALL_OW 1
58722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58723: LD_ADDR_EXP 62
58727: PUSH
58728: LD_EXP 62
58732: PPUSH
58733: LD_VAR 0 4
58737: PPUSH
58738: EMPTY
58739: PPUSH
58740: CALL_OW 1
58744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58745: LD_ADDR_EXP 63
58749: PUSH
58750: LD_EXP 63
58754: PPUSH
58755: LD_VAR 0 4
58759: PPUSH
58760: EMPTY
58761: PPUSH
58762: CALL_OW 1
58766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58767: LD_ADDR_EXP 64
58771: PUSH
58772: LD_EXP 64
58776: PPUSH
58777: LD_VAR 0 4
58781: PPUSH
58782: EMPTY
58783: PPUSH
58784: CALL_OW 1
58788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58789: LD_ADDR_EXP 65
58793: PUSH
58794: LD_EXP 65
58798: PPUSH
58799: LD_VAR 0 4
58803: PPUSH
58804: EMPTY
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58811: LD_ADDR_EXP 66
58815: PUSH
58816: LD_EXP 66
58820: PPUSH
58821: LD_VAR 0 4
58825: PPUSH
58826: EMPTY
58827: PPUSH
58828: CALL_OW 1
58832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58833: LD_ADDR_EXP 67
58837: PUSH
58838: LD_EXP 67
58842: PPUSH
58843: LD_VAR 0 4
58847: PPUSH
58848: EMPTY
58849: PPUSH
58850: CALL_OW 1
58854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58855: LD_ADDR_EXP 68
58859: PUSH
58860: LD_EXP 68
58864: PPUSH
58865: LD_VAR 0 4
58869: PPUSH
58870: EMPTY
58871: PPUSH
58872: CALL_OW 1
58876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58877: LD_ADDR_EXP 69
58881: PUSH
58882: LD_EXP 69
58886: PPUSH
58887: LD_VAR 0 4
58891: PPUSH
58892: EMPTY
58893: PPUSH
58894: CALL_OW 1
58898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58899: LD_ADDR_EXP 70
58903: PUSH
58904: LD_EXP 70
58908: PPUSH
58909: LD_VAR 0 4
58913: PPUSH
58914: LD_INT 0
58916: PPUSH
58917: CALL_OW 1
58921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58922: LD_ADDR_EXP 71
58926: PUSH
58927: LD_EXP 71
58931: PPUSH
58932: LD_VAR 0 4
58936: PPUSH
58937: EMPTY
58938: PPUSH
58939: CALL_OW 1
58943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58944: LD_ADDR_EXP 72
58948: PUSH
58949: LD_EXP 72
58953: PPUSH
58954: LD_VAR 0 4
58958: PPUSH
58959: EMPTY
58960: PPUSH
58961: CALL_OW 1
58965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58966: LD_ADDR_EXP 73
58970: PUSH
58971: LD_EXP 73
58975: PPUSH
58976: LD_VAR 0 4
58980: PPUSH
58981: EMPTY
58982: PPUSH
58983: CALL_OW 1
58987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58988: LD_ADDR_EXP 74
58992: PUSH
58993: LD_EXP 74
58997: PPUSH
58998: LD_VAR 0 4
59002: PPUSH
59003: EMPTY
59004: PPUSH
59005: CALL_OW 1
59009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59010: LD_ADDR_EXP 75
59014: PUSH
59015: LD_EXP 75
59019: PPUSH
59020: LD_VAR 0 4
59024: PPUSH
59025: EMPTY
59026: PPUSH
59027: CALL_OW 1
59031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59032: LD_ADDR_EXP 76
59036: PUSH
59037: LD_EXP 76
59041: PPUSH
59042: LD_VAR 0 4
59046: PPUSH
59047: EMPTY
59048: PPUSH
59049: CALL_OW 1
59053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59054: LD_ADDR_EXP 77
59058: PUSH
59059: LD_EXP 77
59063: PPUSH
59064: LD_VAR 0 4
59068: PPUSH
59069: EMPTY
59070: PPUSH
59071: CALL_OW 1
59075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59076: LD_ADDR_EXP 78
59080: PUSH
59081: LD_EXP 78
59085: PPUSH
59086: LD_VAR 0 4
59090: PPUSH
59091: EMPTY
59092: PPUSH
59093: CALL_OW 1
59097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59098: LD_ADDR_EXP 79
59102: PUSH
59103: LD_EXP 79
59107: PPUSH
59108: LD_VAR 0 4
59112: PPUSH
59113: EMPTY
59114: PPUSH
59115: CALL_OW 1
59119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59120: LD_ADDR_EXP 80
59124: PUSH
59125: LD_EXP 80
59129: PPUSH
59130: LD_VAR 0 4
59134: PPUSH
59135: EMPTY
59136: PPUSH
59137: CALL_OW 1
59141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59142: LD_ADDR_EXP 81
59146: PUSH
59147: LD_EXP 81
59151: PPUSH
59152: LD_VAR 0 4
59156: PPUSH
59157: EMPTY
59158: PPUSH
59159: CALL_OW 1
59163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59164: LD_ADDR_EXP 82
59168: PUSH
59169: LD_EXP 82
59173: PPUSH
59174: LD_VAR 0 4
59178: PPUSH
59179: EMPTY
59180: PPUSH
59181: CALL_OW 1
59185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59186: LD_ADDR_EXP 83
59190: PUSH
59191: LD_EXP 83
59195: PPUSH
59196: LD_VAR 0 4
59200: PPUSH
59201: EMPTY
59202: PPUSH
59203: CALL_OW 1
59207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59208: LD_ADDR_EXP 84
59212: PUSH
59213: LD_EXP 84
59217: PPUSH
59218: LD_VAR 0 4
59222: PPUSH
59223: EMPTY
59224: PPUSH
59225: CALL_OW 1
59229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59230: LD_ADDR_EXP 86
59234: PUSH
59235: LD_EXP 86
59239: PPUSH
59240: LD_VAR 0 4
59244: PPUSH
59245: EMPTY
59246: PPUSH
59247: CALL_OW 1
59251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59252: LD_ADDR_EXP 88
59256: PUSH
59257: LD_EXP 88
59261: PPUSH
59262: LD_VAR 0 4
59266: PPUSH
59267: EMPTY
59268: PPUSH
59269: CALL_OW 1
59273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59274: LD_ADDR_EXP 89
59278: PUSH
59279: LD_EXP 89
59283: PPUSH
59284: LD_VAR 0 4
59288: PPUSH
59289: EMPTY
59290: PPUSH
59291: CALL_OW 1
59295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59296: LD_ADDR_EXP 90
59300: PUSH
59301: LD_EXP 90
59305: PPUSH
59306: LD_VAR 0 4
59310: PPUSH
59311: EMPTY
59312: PPUSH
59313: CALL_OW 1
59317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59318: LD_ADDR_EXP 91
59322: PUSH
59323: LD_EXP 91
59327: PPUSH
59328: LD_VAR 0 4
59332: PPUSH
59333: EMPTY
59334: PPUSH
59335: CALL_OW 1
59339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59340: LD_ADDR_EXP 92
59344: PUSH
59345: LD_EXP 92
59349: PPUSH
59350: LD_VAR 0 4
59354: PPUSH
59355: EMPTY
59356: PPUSH
59357: CALL_OW 1
59361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59362: LD_ADDR_EXP 93
59366: PUSH
59367: LD_EXP 93
59371: PPUSH
59372: LD_VAR 0 4
59376: PPUSH
59377: EMPTY
59378: PPUSH
59379: CALL_OW 1
59383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59384: LD_ADDR_EXP 94
59388: PUSH
59389: LD_EXP 94
59393: PPUSH
59394: LD_VAR 0 4
59398: PPUSH
59399: EMPTY
59400: PPUSH
59401: CALL_OW 1
59405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59406: LD_ADDR_EXP 95
59410: PUSH
59411: LD_EXP 95
59415: PPUSH
59416: LD_VAR 0 4
59420: PPUSH
59421: EMPTY
59422: PPUSH
59423: CALL_OW 1
59427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59428: LD_ADDR_EXP 96
59432: PUSH
59433: LD_EXP 96
59437: PPUSH
59438: LD_VAR 0 4
59442: PPUSH
59443: EMPTY
59444: PPUSH
59445: CALL_OW 1
59449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59450: LD_ADDR_EXP 97
59454: PUSH
59455: LD_EXP 97
59459: PPUSH
59460: LD_VAR 0 4
59464: PPUSH
59465: EMPTY
59466: PPUSH
59467: CALL_OW 1
59471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59472: LD_ADDR_EXP 98
59476: PUSH
59477: LD_EXP 98
59481: PPUSH
59482: LD_VAR 0 4
59486: PPUSH
59487: EMPTY
59488: PPUSH
59489: CALL_OW 1
59493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59494: LD_ADDR_EXP 99
59498: PUSH
59499: LD_EXP 99
59503: PPUSH
59504: LD_VAR 0 4
59508: PPUSH
59509: EMPTY
59510: PPUSH
59511: CALL_OW 1
59515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59516: LD_ADDR_EXP 100
59520: PUSH
59521: LD_EXP 100
59525: PPUSH
59526: LD_VAR 0 4
59530: PPUSH
59531: EMPTY
59532: PPUSH
59533: CALL_OW 1
59537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59538: LD_ADDR_EXP 101
59542: PUSH
59543: LD_EXP 101
59547: PPUSH
59548: LD_VAR 0 4
59552: PPUSH
59553: LD_INT 0
59555: PPUSH
59556: CALL_OW 1
59560: ST_TO_ADDR
// result := base ;
59561: LD_ADDR_VAR 0 3
59565: PUSH
59566: LD_VAR 0 4
59570: ST_TO_ADDR
// end ;
59571: LD_VAR 0 3
59575: RET
// export function MC_Start ( ) ; var i ; begin
59576: LD_INT 0
59578: PPUSH
59579: PPUSH
// for i = 1 to mc_bases do
59580: LD_ADDR_VAR 0 2
59584: PUSH
59585: DOUBLE
59586: LD_INT 1
59588: DEC
59589: ST_TO_ADDR
59590: LD_EXP 59
59594: PUSH
59595: FOR_TO
59596: IFFALSE 60673
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59598: LD_ADDR_EXP 59
59602: PUSH
59603: LD_EXP 59
59607: PPUSH
59608: LD_VAR 0 2
59612: PPUSH
59613: LD_EXP 59
59617: PUSH
59618: LD_VAR 0 2
59622: ARRAY
59623: PUSH
59624: LD_INT 0
59626: DIFF
59627: PPUSH
59628: CALL_OW 1
59632: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59633: LD_ADDR_EXP 60
59637: PUSH
59638: LD_EXP 60
59642: PPUSH
59643: LD_VAR 0 2
59647: PPUSH
59648: EMPTY
59649: PPUSH
59650: CALL_OW 1
59654: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59655: LD_ADDR_EXP 61
59659: PUSH
59660: LD_EXP 61
59664: PPUSH
59665: LD_VAR 0 2
59669: PPUSH
59670: EMPTY
59671: PPUSH
59672: CALL_OW 1
59676: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59677: LD_ADDR_EXP 62
59681: PUSH
59682: LD_EXP 62
59686: PPUSH
59687: LD_VAR 0 2
59691: PPUSH
59692: EMPTY
59693: PPUSH
59694: CALL_OW 1
59698: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59699: LD_ADDR_EXP 63
59703: PUSH
59704: LD_EXP 63
59708: PPUSH
59709: LD_VAR 0 2
59713: PPUSH
59714: EMPTY
59715: PUSH
59716: EMPTY
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PPUSH
59722: CALL_OW 1
59726: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59727: LD_ADDR_EXP 64
59731: PUSH
59732: LD_EXP 64
59736: PPUSH
59737: LD_VAR 0 2
59741: PPUSH
59742: EMPTY
59743: PPUSH
59744: CALL_OW 1
59748: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59749: LD_ADDR_EXP 91
59753: PUSH
59754: LD_EXP 91
59758: PPUSH
59759: LD_VAR 0 2
59763: PPUSH
59764: EMPTY
59765: PPUSH
59766: CALL_OW 1
59770: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59771: LD_ADDR_EXP 65
59775: PUSH
59776: LD_EXP 65
59780: PPUSH
59781: LD_VAR 0 2
59785: PPUSH
59786: EMPTY
59787: PPUSH
59788: CALL_OW 1
59792: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59793: LD_ADDR_EXP 66
59797: PUSH
59798: LD_EXP 66
59802: PPUSH
59803: LD_VAR 0 2
59807: PPUSH
59808: EMPTY
59809: PPUSH
59810: CALL_OW 1
59814: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59815: LD_ADDR_EXP 67
59819: PUSH
59820: LD_EXP 67
59824: PPUSH
59825: LD_VAR 0 2
59829: PPUSH
59830: LD_EXP 59
59834: PUSH
59835: LD_VAR 0 2
59839: ARRAY
59840: PPUSH
59841: LD_INT 2
59843: PUSH
59844: LD_INT 30
59846: PUSH
59847: LD_INT 32
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PUSH
59854: LD_INT 30
59856: PUSH
59857: LD_INT 33
59859: PUSH
59860: EMPTY
59861: LIST
59862: LIST
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: LIST
59868: PPUSH
59869: CALL_OW 72
59873: PPUSH
59874: CALL_OW 1
59878: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59879: LD_ADDR_EXP 68
59883: PUSH
59884: LD_EXP 68
59888: PPUSH
59889: LD_VAR 0 2
59893: PPUSH
59894: LD_EXP 59
59898: PUSH
59899: LD_VAR 0 2
59903: ARRAY
59904: PPUSH
59905: LD_INT 2
59907: PUSH
59908: LD_INT 30
59910: PUSH
59911: LD_INT 32
59913: PUSH
59914: EMPTY
59915: LIST
59916: LIST
59917: PUSH
59918: LD_INT 30
59920: PUSH
59921: LD_INT 31
59923: PUSH
59924: EMPTY
59925: LIST
59926: LIST
59927: PUSH
59928: EMPTY
59929: LIST
59930: LIST
59931: LIST
59932: PUSH
59933: LD_INT 58
59935: PUSH
59936: EMPTY
59937: LIST
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: PPUSH
59943: CALL_OW 72
59947: PPUSH
59948: CALL_OW 1
59952: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59953: LD_ADDR_EXP 69
59957: PUSH
59958: LD_EXP 69
59962: PPUSH
59963: LD_VAR 0 2
59967: PPUSH
59968: EMPTY
59969: PPUSH
59970: CALL_OW 1
59974: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59975: LD_ADDR_EXP 73
59979: PUSH
59980: LD_EXP 73
59984: PPUSH
59985: LD_VAR 0 2
59989: PPUSH
59990: EMPTY
59991: PPUSH
59992: CALL_OW 1
59996: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59997: LD_ADDR_EXP 72
60001: PUSH
60002: LD_EXP 72
60006: PPUSH
60007: LD_VAR 0 2
60011: PPUSH
60012: EMPTY
60013: PPUSH
60014: CALL_OW 1
60018: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60019: LD_ADDR_EXP 74
60023: PUSH
60024: LD_EXP 74
60028: PPUSH
60029: LD_VAR 0 2
60033: PPUSH
60034: EMPTY
60035: PPUSH
60036: CALL_OW 1
60040: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60041: LD_ADDR_EXP 75
60045: PUSH
60046: LD_EXP 75
60050: PPUSH
60051: LD_VAR 0 2
60055: PPUSH
60056: EMPTY
60057: PPUSH
60058: CALL_OW 1
60062: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60063: LD_ADDR_EXP 76
60067: PUSH
60068: LD_EXP 76
60072: PPUSH
60073: LD_VAR 0 2
60077: PPUSH
60078: EMPTY
60079: PPUSH
60080: CALL_OW 1
60084: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60085: LD_ADDR_EXP 77
60089: PUSH
60090: LD_EXP 77
60094: PPUSH
60095: LD_VAR 0 2
60099: PPUSH
60100: EMPTY
60101: PPUSH
60102: CALL_OW 1
60106: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60107: LD_ADDR_EXP 78
60111: PUSH
60112: LD_EXP 78
60116: PPUSH
60117: LD_VAR 0 2
60121: PPUSH
60122: EMPTY
60123: PPUSH
60124: CALL_OW 1
60128: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60129: LD_ADDR_EXP 79
60133: PUSH
60134: LD_EXP 79
60138: PPUSH
60139: LD_VAR 0 2
60143: PPUSH
60144: EMPTY
60145: PPUSH
60146: CALL_OW 1
60150: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60151: LD_ADDR_EXP 80
60155: PUSH
60156: LD_EXP 80
60160: PPUSH
60161: LD_VAR 0 2
60165: PPUSH
60166: EMPTY
60167: PPUSH
60168: CALL_OW 1
60172: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60173: LD_ADDR_EXP 81
60177: PUSH
60178: LD_EXP 81
60182: PPUSH
60183: LD_VAR 0 2
60187: PPUSH
60188: EMPTY
60189: PPUSH
60190: CALL_OW 1
60194: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60195: LD_ADDR_EXP 70
60199: PUSH
60200: LD_EXP 70
60204: PPUSH
60205: LD_VAR 0 2
60209: PPUSH
60210: LD_INT 0
60212: PPUSH
60213: CALL_OW 1
60217: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60218: LD_ADDR_EXP 83
60222: PUSH
60223: LD_EXP 83
60227: PPUSH
60228: LD_VAR 0 2
60232: PPUSH
60233: LD_INT 0
60235: PPUSH
60236: CALL_OW 1
60240: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60241: LD_ADDR_EXP 71
60245: PUSH
60246: LD_EXP 71
60250: PPUSH
60251: LD_VAR 0 2
60255: PPUSH
60256: EMPTY
60257: PPUSH
60258: CALL_OW 1
60262: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60263: LD_ADDR_EXP 82
60267: PUSH
60268: LD_EXP 82
60272: PPUSH
60273: LD_VAR 0 2
60277: PPUSH
60278: LD_INT 0
60280: PPUSH
60281: CALL_OW 1
60285: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60286: LD_ADDR_EXP 84
60290: PUSH
60291: LD_EXP 84
60295: PPUSH
60296: LD_VAR 0 2
60300: PPUSH
60301: EMPTY
60302: PPUSH
60303: CALL_OW 1
60307: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60308: LD_ADDR_EXP 87
60312: PUSH
60313: LD_EXP 87
60317: PPUSH
60318: LD_VAR 0 2
60322: PPUSH
60323: LD_INT 0
60325: PPUSH
60326: CALL_OW 1
60330: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60331: LD_ADDR_EXP 88
60335: PUSH
60336: LD_EXP 88
60340: PPUSH
60341: LD_VAR 0 2
60345: PPUSH
60346: EMPTY
60347: PPUSH
60348: CALL_OW 1
60352: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60353: LD_ADDR_EXP 89
60357: PUSH
60358: LD_EXP 89
60362: PPUSH
60363: LD_VAR 0 2
60367: PPUSH
60368: EMPTY
60369: PPUSH
60370: CALL_OW 1
60374: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60375: LD_ADDR_EXP 90
60379: PUSH
60380: LD_EXP 90
60384: PPUSH
60385: LD_VAR 0 2
60389: PPUSH
60390: EMPTY
60391: PPUSH
60392: CALL_OW 1
60396: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60397: LD_ADDR_EXP 92
60401: PUSH
60402: LD_EXP 92
60406: PPUSH
60407: LD_VAR 0 2
60411: PPUSH
60412: LD_EXP 59
60416: PUSH
60417: LD_VAR 0 2
60421: ARRAY
60422: PPUSH
60423: LD_INT 2
60425: PUSH
60426: LD_INT 30
60428: PUSH
60429: LD_INT 6
60431: PUSH
60432: EMPTY
60433: LIST
60434: LIST
60435: PUSH
60436: LD_INT 30
60438: PUSH
60439: LD_INT 7
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 30
60448: PUSH
60449: LD_INT 8
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: LIST
60460: LIST
60461: PPUSH
60462: CALL_OW 72
60466: PPUSH
60467: CALL_OW 1
60471: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60472: LD_ADDR_EXP 93
60476: PUSH
60477: LD_EXP 93
60481: PPUSH
60482: LD_VAR 0 2
60486: PPUSH
60487: EMPTY
60488: PPUSH
60489: CALL_OW 1
60493: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60494: LD_ADDR_EXP 94
60498: PUSH
60499: LD_EXP 94
60503: PPUSH
60504: LD_VAR 0 2
60508: PPUSH
60509: EMPTY
60510: PPUSH
60511: CALL_OW 1
60515: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60516: LD_ADDR_EXP 95
60520: PUSH
60521: LD_EXP 95
60525: PPUSH
60526: LD_VAR 0 2
60530: PPUSH
60531: EMPTY
60532: PPUSH
60533: CALL_OW 1
60537: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60538: LD_ADDR_EXP 96
60542: PUSH
60543: LD_EXP 96
60547: PPUSH
60548: LD_VAR 0 2
60552: PPUSH
60553: EMPTY
60554: PPUSH
60555: CALL_OW 1
60559: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60560: LD_ADDR_EXP 97
60564: PUSH
60565: LD_EXP 97
60569: PPUSH
60570: LD_VAR 0 2
60574: PPUSH
60575: EMPTY
60576: PPUSH
60577: CALL_OW 1
60581: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60582: LD_ADDR_EXP 98
60586: PUSH
60587: LD_EXP 98
60591: PPUSH
60592: LD_VAR 0 2
60596: PPUSH
60597: EMPTY
60598: PPUSH
60599: CALL_OW 1
60603: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60604: LD_ADDR_EXP 99
60608: PUSH
60609: LD_EXP 99
60613: PPUSH
60614: LD_VAR 0 2
60618: PPUSH
60619: EMPTY
60620: PPUSH
60621: CALL_OW 1
60625: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60626: LD_ADDR_EXP 100
60630: PUSH
60631: LD_EXP 100
60635: PPUSH
60636: LD_VAR 0 2
60640: PPUSH
60641: EMPTY
60642: PPUSH
60643: CALL_OW 1
60647: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60648: LD_ADDR_EXP 101
60652: PUSH
60653: LD_EXP 101
60657: PPUSH
60658: LD_VAR 0 2
60662: PPUSH
60663: LD_INT 0
60665: PPUSH
60666: CALL_OW 1
60670: ST_TO_ADDR
// end ;
60671: GO 59595
60673: POP
60674: POP
// MC_InitSides ( ) ;
60675: CALL 60961 0 0
// MC_InitResearch ( ) ;
60679: CALL 60700 0 0
// CustomInitMacro ( ) ;
60683: CALL 181 0 0
// skirmish := true ;
60687: LD_ADDR_EXP 57
60691: PUSH
60692: LD_INT 1
60694: ST_TO_ADDR
// end ;
60695: LD_VAR 0 1
60699: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60700: LD_INT 0
60702: PPUSH
60703: PPUSH
60704: PPUSH
60705: PPUSH
60706: PPUSH
60707: PPUSH
// if not mc_bases then
60708: LD_EXP 59
60712: NOT
60713: IFFALSE 60717
// exit ;
60715: GO 60956
// for i = 1 to 8 do
60717: LD_ADDR_VAR 0 2
60721: PUSH
60722: DOUBLE
60723: LD_INT 1
60725: DEC
60726: ST_TO_ADDR
60727: LD_INT 8
60729: PUSH
60730: FOR_TO
60731: IFFALSE 60757
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60733: LD_ADDR_EXP 86
60737: PUSH
60738: LD_EXP 86
60742: PPUSH
60743: LD_VAR 0 2
60747: PPUSH
60748: EMPTY
60749: PPUSH
60750: CALL_OW 1
60754: ST_TO_ADDR
60755: GO 60730
60757: POP
60758: POP
// tmp := [ ] ;
60759: LD_ADDR_VAR 0 5
60763: PUSH
60764: EMPTY
60765: ST_TO_ADDR
// for i = 1 to mc_sides do
60766: LD_ADDR_VAR 0 2
60770: PUSH
60771: DOUBLE
60772: LD_INT 1
60774: DEC
60775: ST_TO_ADDR
60776: LD_EXP 85
60780: PUSH
60781: FOR_TO
60782: IFFALSE 60840
// if not mc_sides [ i ] in tmp then
60784: LD_EXP 85
60788: PUSH
60789: LD_VAR 0 2
60793: ARRAY
60794: PUSH
60795: LD_VAR 0 5
60799: IN
60800: NOT
60801: IFFALSE 60838
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60803: LD_ADDR_VAR 0 5
60807: PUSH
60808: LD_VAR 0 5
60812: PPUSH
60813: LD_VAR 0 5
60817: PUSH
60818: LD_INT 1
60820: PLUS
60821: PPUSH
60822: LD_EXP 85
60826: PUSH
60827: LD_VAR 0 2
60831: ARRAY
60832: PPUSH
60833: CALL_OW 2
60837: ST_TO_ADDR
60838: GO 60781
60840: POP
60841: POP
// if not tmp then
60842: LD_VAR 0 5
60846: NOT
60847: IFFALSE 60851
// exit ;
60849: GO 60956
// for j in tmp do
60851: LD_ADDR_VAR 0 3
60855: PUSH
60856: LD_VAR 0 5
60860: PUSH
60861: FOR_IN
60862: IFFALSE 60954
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60864: LD_ADDR_VAR 0 6
60868: PUSH
60869: LD_INT 22
60871: PUSH
60872: LD_VAR 0 3
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PPUSH
60881: CALL_OW 69
60885: ST_TO_ADDR
// if not un then
60886: LD_VAR 0 6
60890: NOT
60891: IFFALSE 60895
// continue ;
60893: GO 60861
// nation := GetNation ( un [ 1 ] ) ;
60895: LD_ADDR_VAR 0 4
60899: PUSH
60900: LD_VAR 0 6
60904: PUSH
60905: LD_INT 1
60907: ARRAY
60908: PPUSH
60909: CALL_OW 248
60913: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60914: LD_ADDR_EXP 86
60918: PUSH
60919: LD_EXP 86
60923: PPUSH
60924: LD_VAR 0 3
60928: PPUSH
60929: LD_VAR 0 3
60933: PPUSH
60934: LD_VAR 0 4
60938: PPUSH
60939: LD_INT 1
60941: PPUSH
60942: CALL 14355 0 3
60946: PPUSH
60947: CALL_OW 1
60951: ST_TO_ADDR
// end ;
60952: GO 60861
60954: POP
60955: POP
// end ;
60956: LD_VAR 0 1
60960: RET
// export function MC_InitSides ( ) ; var i ; begin
60961: LD_INT 0
60963: PPUSH
60964: PPUSH
// if not mc_bases then
60965: LD_EXP 59
60969: NOT
60970: IFFALSE 60974
// exit ;
60972: GO 61048
// for i = 1 to mc_bases do
60974: LD_ADDR_VAR 0 2
60978: PUSH
60979: DOUBLE
60980: LD_INT 1
60982: DEC
60983: ST_TO_ADDR
60984: LD_EXP 59
60988: PUSH
60989: FOR_TO
60990: IFFALSE 61046
// if mc_bases [ i ] then
60992: LD_EXP 59
60996: PUSH
60997: LD_VAR 0 2
61001: ARRAY
61002: IFFALSE 61044
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61004: LD_ADDR_EXP 85
61008: PUSH
61009: LD_EXP 85
61013: PPUSH
61014: LD_VAR 0 2
61018: PPUSH
61019: LD_EXP 59
61023: PUSH
61024: LD_VAR 0 2
61028: ARRAY
61029: PUSH
61030: LD_INT 1
61032: ARRAY
61033: PPUSH
61034: CALL_OW 255
61038: PPUSH
61039: CALL_OW 1
61043: ST_TO_ADDR
61044: GO 60989
61046: POP
61047: POP
// end ;
61048: LD_VAR 0 1
61052: RET
// every 0 0$01 trigger skirmish do
61053: LD_EXP 57
61057: IFFALSE 61211
61059: GO 61061
61061: DISABLE
// begin enable ;
61062: ENABLE
// MC_CheckBuildings ( ) ;
61063: CALL 65709 0 0
// MC_CheckPeopleLife ( ) ;
61067: CALL 65834 0 0
// RaiseSailEvent ( 100 ) ;
61071: LD_INT 100
61073: PPUSH
61074: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61078: LD_INT 103
61080: PPUSH
61081: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61085: LD_INT 104
61087: PPUSH
61088: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61092: LD_INT 105
61094: PPUSH
61095: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61099: LD_INT 106
61101: PPUSH
61102: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61106: LD_INT 107
61108: PPUSH
61109: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61113: LD_INT 108
61115: PPUSH
61116: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61120: LD_INT 109
61122: PPUSH
61123: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61127: LD_INT 110
61129: PPUSH
61130: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61134: LD_INT 111
61136: PPUSH
61137: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61141: LD_INT 112
61143: PPUSH
61144: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61148: LD_INT 113
61150: PPUSH
61151: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61155: LD_INT 120
61157: PPUSH
61158: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61162: LD_INT 121
61164: PPUSH
61165: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61169: LD_INT 122
61171: PPUSH
61172: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61176: LD_INT 123
61178: PPUSH
61179: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61183: LD_INT 124
61185: PPUSH
61186: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61190: LD_INT 125
61192: PPUSH
61193: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61197: LD_INT 126
61199: PPUSH
61200: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61204: LD_INT 200
61206: PPUSH
61207: CALL_OW 427
// end ;
61211: END
// on SailEvent ( event ) do begin if event < 100 then
61212: LD_VAR 0 1
61216: PUSH
61217: LD_INT 100
61219: LESS
61220: IFFALSE 61231
// CustomEvent ( event ) ;
61222: LD_VAR 0 1
61226: PPUSH
61227: CALL 13013 0 1
// if event = 100 then
61231: LD_VAR 0 1
61235: PUSH
61236: LD_INT 100
61238: EQUAL
61239: IFFALSE 61245
// MC_ClassManager ( ) ;
61241: CALL 61637 0 0
// if event = 101 then
61245: LD_VAR 0 1
61249: PUSH
61250: LD_INT 101
61252: EQUAL
61253: IFFALSE 61259
// MC_RepairBuildings ( ) ;
61255: CALL 66430 0 0
// if event = 102 then
61259: LD_VAR 0 1
61263: PUSH
61264: LD_INT 102
61266: EQUAL
61267: IFFALSE 61273
// MC_Heal ( ) ;
61269: CALL 67294 0 0
// if event = 103 then
61273: LD_VAR 0 1
61277: PUSH
61278: LD_INT 103
61280: EQUAL
61281: IFFALSE 61287
// MC_Build ( ) ;
61283: CALL 67716 0 0
// if event = 104 then
61287: LD_VAR 0 1
61291: PUSH
61292: LD_INT 104
61294: EQUAL
61295: IFFALSE 61301
// MC_TurretWeapon ( ) ;
61297: CALL 69329 0 0
// if event = 105 then
61301: LD_VAR 0 1
61305: PUSH
61306: LD_INT 105
61308: EQUAL
61309: IFFALSE 61315
// MC_BuildUpgrade ( ) ;
61311: CALL 68880 0 0
// if event = 106 then
61315: LD_VAR 0 1
61319: PUSH
61320: LD_INT 106
61322: EQUAL
61323: IFFALSE 61329
// MC_PlantMines ( ) ;
61325: CALL 69759 0 0
// if event = 107 then
61329: LD_VAR 0 1
61333: PUSH
61334: LD_INT 107
61336: EQUAL
61337: IFFALSE 61343
// MC_CollectCrates ( ) ;
61339: CALL 70557 0 0
// if event = 108 then
61343: LD_VAR 0 1
61347: PUSH
61348: LD_INT 108
61350: EQUAL
61351: IFFALSE 61357
// MC_LinkRemoteControl ( ) ;
61353: CALL 72333 0 0
// if event = 109 then
61357: LD_VAR 0 1
61361: PUSH
61362: LD_INT 109
61364: EQUAL
61365: IFFALSE 61371
// MC_ProduceVehicle ( ) ;
61367: CALL 72514 0 0
// if event = 110 then
61371: LD_VAR 0 1
61375: PUSH
61376: LD_INT 110
61378: EQUAL
61379: IFFALSE 61385
// MC_SendAttack ( ) ;
61381: CALL 72980 0 0
// if event = 111 then
61385: LD_VAR 0 1
61389: PUSH
61390: LD_INT 111
61392: EQUAL
61393: IFFALSE 61399
// MC_Defend ( ) ;
61395: CALL 73088 0 0
// if event = 112 then
61399: LD_VAR 0 1
61403: PUSH
61404: LD_INT 112
61406: EQUAL
61407: IFFALSE 61413
// MC_Research ( ) ;
61409: CALL 73693 0 0
// if event = 113 then
61413: LD_VAR 0 1
61417: PUSH
61418: LD_INT 113
61420: EQUAL
61421: IFFALSE 61427
// MC_MinesTrigger ( ) ;
61423: CALL 74807 0 0
// if event = 120 then
61427: LD_VAR 0 1
61431: PUSH
61432: LD_INT 120
61434: EQUAL
61435: IFFALSE 61441
// MC_RepairVehicle ( ) ;
61437: CALL 74906 0 0
// if event = 121 then
61441: LD_VAR 0 1
61445: PUSH
61446: LD_INT 121
61448: EQUAL
61449: IFFALSE 61455
// MC_TameApe ( ) ;
61451: CALL 75636 0 0
// if event = 122 then
61455: LD_VAR 0 1
61459: PUSH
61460: LD_INT 122
61462: EQUAL
61463: IFFALSE 61469
// MC_ChangeApeClass ( ) ;
61465: CALL 76465 0 0
// if event = 123 then
61469: LD_VAR 0 1
61473: PUSH
61474: LD_INT 123
61476: EQUAL
61477: IFFALSE 61483
// MC_Bazooka ( ) ;
61479: CALL 77115 0 0
// if event = 124 then
61483: LD_VAR 0 1
61487: PUSH
61488: LD_INT 124
61490: EQUAL
61491: IFFALSE 61497
// MC_TeleportExit ( ) ;
61493: CALL 77313 0 0
// if event = 125 then
61497: LD_VAR 0 1
61501: PUSH
61502: LD_INT 125
61504: EQUAL
61505: IFFALSE 61511
// MC_Deposits ( ) ;
61507: CALL 77960 0 0
// if event = 126 then
61511: LD_VAR 0 1
61515: PUSH
61516: LD_INT 126
61518: EQUAL
61519: IFFALSE 61525
// MC_RemoteDriver ( ) ;
61521: CALL 78585 0 0
// if event = 200 then
61525: LD_VAR 0 1
61529: PUSH
61530: LD_INT 200
61532: EQUAL
61533: IFFALSE 61539
// MC_Idle ( ) ;
61535: CALL 80534 0 0
// end ;
61539: PPOPN 1
61541: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61542: LD_INT 0
61544: PPUSH
61545: PPUSH
// if not mc_bases [ base ] or not tag then
61546: LD_EXP 59
61550: PUSH
61551: LD_VAR 0 1
61555: ARRAY
61556: NOT
61557: PUSH
61558: LD_VAR 0 2
61562: NOT
61563: OR
61564: IFFALSE 61568
// exit ;
61566: GO 61632
// for i in mc_bases [ base ] union mc_ape [ base ] do
61568: LD_ADDR_VAR 0 4
61572: PUSH
61573: LD_EXP 59
61577: PUSH
61578: LD_VAR 0 1
61582: ARRAY
61583: PUSH
61584: LD_EXP 88
61588: PUSH
61589: LD_VAR 0 1
61593: ARRAY
61594: UNION
61595: PUSH
61596: FOR_IN
61597: IFFALSE 61630
// if GetTag ( i ) = tag then
61599: LD_VAR 0 4
61603: PPUSH
61604: CALL_OW 110
61608: PUSH
61609: LD_VAR 0 2
61613: EQUAL
61614: IFFALSE 61628
// SetTag ( i , 0 ) ;
61616: LD_VAR 0 4
61620: PPUSH
61621: LD_INT 0
61623: PPUSH
61624: CALL_OW 109
61628: GO 61596
61630: POP
61631: POP
// end ;
61632: LD_VAR 0 3
61636: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61637: LD_INT 0
61639: PPUSH
61640: PPUSH
61641: PPUSH
61642: PPUSH
61643: PPUSH
61644: PPUSH
61645: PPUSH
61646: PPUSH
// if not mc_bases then
61647: LD_EXP 59
61651: NOT
61652: IFFALSE 61656
// exit ;
61654: GO 62114
// for i = 1 to mc_bases do
61656: LD_ADDR_VAR 0 2
61660: PUSH
61661: DOUBLE
61662: LD_INT 1
61664: DEC
61665: ST_TO_ADDR
61666: LD_EXP 59
61670: PUSH
61671: FOR_TO
61672: IFFALSE 62112
// begin tmp := MC_ClassCheckReq ( i ) ;
61674: LD_ADDR_VAR 0 4
61678: PUSH
61679: LD_VAR 0 2
61683: PPUSH
61684: CALL 62119 0 1
61688: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61689: LD_ADDR_EXP 100
61693: PUSH
61694: LD_EXP 100
61698: PPUSH
61699: LD_VAR 0 2
61703: PPUSH
61704: LD_VAR 0 4
61708: PPUSH
61709: CALL_OW 1
61713: ST_TO_ADDR
// if not tmp then
61714: LD_VAR 0 4
61718: NOT
61719: IFFALSE 61723
// continue ;
61721: GO 61671
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61723: LD_ADDR_VAR 0 6
61727: PUSH
61728: LD_EXP 59
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PPUSH
61739: LD_INT 2
61741: PUSH
61742: LD_INT 30
61744: PUSH
61745: LD_INT 4
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: PUSH
61752: LD_INT 30
61754: PUSH
61755: LD_INT 5
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: LIST
61766: PPUSH
61767: CALL_OW 72
61771: PUSH
61772: LD_EXP 59
61776: PUSH
61777: LD_VAR 0 2
61781: ARRAY
61782: PPUSH
61783: LD_INT 2
61785: PUSH
61786: LD_INT 30
61788: PUSH
61789: LD_INT 0
61791: PUSH
61792: EMPTY
61793: LIST
61794: LIST
61795: PUSH
61796: LD_INT 30
61798: PUSH
61799: LD_INT 1
61801: PUSH
61802: EMPTY
61803: LIST
61804: LIST
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: LIST
61810: PPUSH
61811: CALL_OW 72
61815: PUSH
61816: LD_EXP 59
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PPUSH
61827: LD_INT 30
61829: PUSH
61830: LD_INT 3
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: PPUSH
61837: CALL_OW 72
61841: PUSH
61842: LD_EXP 59
61846: PUSH
61847: LD_VAR 0 2
61851: ARRAY
61852: PPUSH
61853: LD_INT 2
61855: PUSH
61856: LD_INT 30
61858: PUSH
61859: LD_INT 6
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 30
61868: PUSH
61869: LD_INT 7
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: PUSH
61876: LD_INT 30
61878: PUSH
61879: LD_INT 8
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: LIST
61890: LIST
61891: PPUSH
61892: CALL_OW 72
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: ST_TO_ADDR
// for j = 1 to 4 do
61903: LD_ADDR_VAR 0 3
61907: PUSH
61908: DOUBLE
61909: LD_INT 1
61911: DEC
61912: ST_TO_ADDR
61913: LD_INT 4
61915: PUSH
61916: FOR_TO
61917: IFFALSE 62108
// begin if not tmp [ j ] then
61919: LD_VAR 0 4
61923: PUSH
61924: LD_VAR 0 3
61928: ARRAY
61929: NOT
61930: IFFALSE 61934
// continue ;
61932: GO 61916
// for p in tmp [ j ] do
61934: LD_ADDR_VAR 0 5
61938: PUSH
61939: LD_VAR 0 4
61943: PUSH
61944: LD_VAR 0 3
61948: ARRAY
61949: PUSH
61950: FOR_IN
61951: IFFALSE 62104
// begin if not b [ j ] then
61953: LD_VAR 0 6
61957: PUSH
61958: LD_VAR 0 3
61962: ARRAY
61963: NOT
61964: IFFALSE 61968
// break ;
61966: GO 62104
// e := 0 ;
61968: LD_ADDR_VAR 0 7
61972: PUSH
61973: LD_INT 0
61975: ST_TO_ADDR
// for k in b [ j ] do
61976: LD_ADDR_VAR 0 8
61980: PUSH
61981: LD_VAR 0 6
61985: PUSH
61986: LD_VAR 0 3
61990: ARRAY
61991: PUSH
61992: FOR_IN
61993: IFFALSE 62020
// if IsNotFull ( k ) then
61995: LD_VAR 0 8
61999: PPUSH
62000: CALL 18795 0 1
62004: IFFALSE 62018
// begin e := k ;
62006: LD_ADDR_VAR 0 7
62010: PUSH
62011: LD_VAR 0 8
62015: ST_TO_ADDR
// break ;
62016: GO 62020
// end ;
62018: GO 61992
62020: POP
62021: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62022: LD_VAR 0 7
62026: PUSH
62027: LD_VAR 0 5
62031: PPUSH
62032: LD_VAR 0 7
62036: PPUSH
62037: CALL 55924 0 2
62041: NOT
62042: AND
62043: IFFALSE 62102
// begin if IsInUnit ( p ) then
62045: LD_VAR 0 5
62049: PPUSH
62050: CALL_OW 310
62054: IFFALSE 62065
// ComExitBuilding ( p ) ;
62056: LD_VAR 0 5
62060: PPUSH
62061: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62065: LD_VAR 0 5
62069: PPUSH
62070: LD_VAR 0 7
62074: PPUSH
62075: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62079: LD_VAR 0 5
62083: PPUSH
62084: LD_VAR 0 3
62088: PPUSH
62089: CALL_OW 183
// AddComExitBuilding ( p ) ;
62093: LD_VAR 0 5
62097: PPUSH
62098: CALL_OW 182
// end ; end ;
62102: GO 61950
62104: POP
62105: POP
// end ;
62106: GO 61916
62108: POP
62109: POP
// end ;
62110: GO 61671
62112: POP
62113: POP
// end ;
62114: LD_VAR 0 1
62118: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62119: LD_INT 0
62121: PPUSH
62122: PPUSH
62123: PPUSH
62124: PPUSH
62125: PPUSH
62126: PPUSH
62127: PPUSH
62128: PPUSH
62129: PPUSH
62130: PPUSH
62131: PPUSH
62132: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62133: LD_VAR 0 1
62137: NOT
62138: PUSH
62139: LD_EXP 59
62143: PUSH
62144: LD_VAR 0 1
62148: ARRAY
62149: NOT
62150: OR
62151: PUSH
62152: LD_EXP 59
62156: PUSH
62157: LD_VAR 0 1
62161: ARRAY
62162: PPUSH
62163: LD_INT 2
62165: PUSH
62166: LD_INT 30
62168: PUSH
62169: LD_INT 0
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PUSH
62176: LD_INT 30
62178: PUSH
62179: LD_INT 1
62181: PUSH
62182: EMPTY
62183: LIST
62184: LIST
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: LIST
62190: PPUSH
62191: CALL_OW 72
62195: NOT
62196: OR
62197: IFFALSE 62201
// exit ;
62199: GO 65704
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62201: LD_ADDR_VAR 0 4
62205: PUSH
62206: LD_EXP 59
62210: PUSH
62211: LD_VAR 0 1
62215: ARRAY
62216: PPUSH
62217: LD_INT 2
62219: PUSH
62220: LD_INT 25
62222: PUSH
62223: LD_INT 1
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PUSH
62230: LD_INT 25
62232: PUSH
62233: LD_INT 2
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: LD_INT 25
62242: PUSH
62243: LD_INT 3
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: PUSH
62250: LD_INT 25
62252: PUSH
62253: LD_INT 4
62255: PUSH
62256: EMPTY
62257: LIST
62258: LIST
62259: PUSH
62260: LD_INT 25
62262: PUSH
62263: LD_INT 5
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: PUSH
62270: LD_INT 25
62272: PUSH
62273: LD_INT 8
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: PUSH
62280: LD_INT 25
62282: PUSH
62283: LD_INT 9
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: LIST
62294: LIST
62295: LIST
62296: LIST
62297: LIST
62298: LIST
62299: PPUSH
62300: CALL_OW 72
62304: ST_TO_ADDR
// if not tmp then
62305: LD_VAR 0 4
62309: NOT
62310: IFFALSE 62314
// exit ;
62312: GO 65704
// for i in tmp do
62314: LD_ADDR_VAR 0 3
62318: PUSH
62319: LD_VAR 0 4
62323: PUSH
62324: FOR_IN
62325: IFFALSE 62356
// if GetTag ( i ) then
62327: LD_VAR 0 3
62331: PPUSH
62332: CALL_OW 110
62336: IFFALSE 62354
// tmp := tmp diff i ;
62338: LD_ADDR_VAR 0 4
62342: PUSH
62343: LD_VAR 0 4
62347: PUSH
62348: LD_VAR 0 3
62352: DIFF
62353: ST_TO_ADDR
62354: GO 62324
62356: POP
62357: POP
// if not tmp then
62358: LD_VAR 0 4
62362: NOT
62363: IFFALSE 62367
// exit ;
62365: GO 65704
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62367: LD_ADDR_VAR 0 5
62371: PUSH
62372: LD_EXP 59
62376: PUSH
62377: LD_VAR 0 1
62381: ARRAY
62382: PPUSH
62383: LD_INT 2
62385: PUSH
62386: LD_INT 25
62388: PUSH
62389: LD_INT 1
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: PUSH
62396: LD_INT 25
62398: PUSH
62399: LD_INT 5
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: LD_INT 25
62408: PUSH
62409: LD_INT 8
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: PUSH
62416: LD_INT 25
62418: PUSH
62419: LD_INT 9
62421: PUSH
62422: EMPTY
62423: LIST
62424: LIST
62425: PUSH
62426: EMPTY
62427: LIST
62428: LIST
62429: LIST
62430: LIST
62431: LIST
62432: PPUSH
62433: CALL_OW 72
62437: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62438: LD_ADDR_VAR 0 6
62442: PUSH
62443: LD_EXP 59
62447: PUSH
62448: LD_VAR 0 1
62452: ARRAY
62453: PPUSH
62454: LD_INT 25
62456: PUSH
62457: LD_INT 2
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: PPUSH
62464: CALL_OW 72
62468: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62469: LD_ADDR_VAR 0 7
62473: PUSH
62474: LD_EXP 59
62478: PUSH
62479: LD_VAR 0 1
62483: ARRAY
62484: PPUSH
62485: LD_INT 25
62487: PUSH
62488: LD_INT 3
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: PPUSH
62495: CALL_OW 72
62499: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62500: LD_ADDR_VAR 0 8
62504: PUSH
62505: LD_EXP 59
62509: PUSH
62510: LD_VAR 0 1
62514: ARRAY
62515: PPUSH
62516: LD_INT 25
62518: PUSH
62519: LD_INT 4
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PUSH
62526: LD_INT 24
62528: PUSH
62529: LD_INT 251
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: PPUSH
62540: CALL_OW 72
62544: ST_TO_ADDR
// if mc_scan [ base ] then
62545: LD_EXP 82
62549: PUSH
62550: LD_VAR 0 1
62554: ARRAY
62555: IFFALSE 63016
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62557: LD_ADDR_EXP 101
62561: PUSH
62562: LD_EXP 101
62566: PPUSH
62567: LD_VAR 0 1
62571: PPUSH
62572: LD_INT 4
62574: PPUSH
62575: CALL_OW 1
62579: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62580: LD_ADDR_VAR 0 12
62584: PUSH
62585: LD_EXP 59
62589: PUSH
62590: LD_VAR 0 1
62594: ARRAY
62595: PPUSH
62596: LD_INT 2
62598: PUSH
62599: LD_INT 30
62601: PUSH
62602: LD_INT 4
62604: PUSH
62605: EMPTY
62606: LIST
62607: LIST
62608: PUSH
62609: LD_INT 30
62611: PUSH
62612: LD_INT 5
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PUSH
62619: EMPTY
62620: LIST
62621: LIST
62622: LIST
62623: PPUSH
62624: CALL_OW 72
62628: ST_TO_ADDR
// if not b then
62629: LD_VAR 0 12
62633: NOT
62634: IFFALSE 62638
// exit ;
62636: GO 65704
// p := [ ] ;
62638: LD_ADDR_VAR 0 11
62642: PUSH
62643: EMPTY
62644: ST_TO_ADDR
// if sci >= 2 then
62645: LD_VAR 0 8
62649: PUSH
62650: LD_INT 2
62652: GREATEREQUAL
62653: IFFALSE 62684
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62655: LD_ADDR_VAR 0 8
62659: PUSH
62660: LD_VAR 0 8
62664: PUSH
62665: LD_INT 1
62667: ARRAY
62668: PUSH
62669: LD_VAR 0 8
62673: PUSH
62674: LD_INT 2
62676: ARRAY
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: ST_TO_ADDR
62682: GO 62745
// if sci = 1 then
62684: LD_VAR 0 8
62688: PUSH
62689: LD_INT 1
62691: EQUAL
62692: IFFALSE 62713
// sci := [ sci [ 1 ] ] else
62694: LD_ADDR_VAR 0 8
62698: PUSH
62699: LD_VAR 0 8
62703: PUSH
62704: LD_INT 1
62706: ARRAY
62707: PUSH
62708: EMPTY
62709: LIST
62710: ST_TO_ADDR
62711: GO 62745
// if sci = 0 then
62713: LD_VAR 0 8
62717: PUSH
62718: LD_INT 0
62720: EQUAL
62721: IFFALSE 62745
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62723: LD_ADDR_VAR 0 11
62727: PUSH
62728: LD_VAR 0 4
62732: PPUSH
62733: LD_INT 4
62735: PPUSH
62736: CALL 55787 0 2
62740: PUSH
62741: LD_INT 1
62743: ARRAY
62744: ST_TO_ADDR
// if eng > 4 then
62745: LD_VAR 0 6
62749: PUSH
62750: LD_INT 4
62752: GREATER
62753: IFFALSE 62799
// for i = eng downto 4 do
62755: LD_ADDR_VAR 0 3
62759: PUSH
62760: DOUBLE
62761: LD_VAR 0 6
62765: INC
62766: ST_TO_ADDR
62767: LD_INT 4
62769: PUSH
62770: FOR_DOWNTO
62771: IFFALSE 62797
// eng := eng diff eng [ i ] ;
62773: LD_ADDR_VAR 0 6
62777: PUSH
62778: LD_VAR 0 6
62782: PUSH
62783: LD_VAR 0 6
62787: PUSH
62788: LD_VAR 0 3
62792: ARRAY
62793: DIFF
62794: ST_TO_ADDR
62795: GO 62770
62797: POP
62798: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62799: LD_ADDR_VAR 0 4
62803: PUSH
62804: LD_VAR 0 4
62808: PUSH
62809: LD_VAR 0 5
62813: PUSH
62814: LD_VAR 0 6
62818: UNION
62819: PUSH
62820: LD_VAR 0 7
62824: UNION
62825: PUSH
62826: LD_VAR 0 8
62830: UNION
62831: DIFF
62832: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62833: LD_ADDR_VAR 0 13
62837: PUSH
62838: LD_EXP 59
62842: PUSH
62843: LD_VAR 0 1
62847: ARRAY
62848: PPUSH
62849: LD_INT 2
62851: PUSH
62852: LD_INT 30
62854: PUSH
62855: LD_INT 32
62857: PUSH
62858: EMPTY
62859: LIST
62860: LIST
62861: PUSH
62862: LD_INT 30
62864: PUSH
62865: LD_INT 31
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: LIST
62876: PPUSH
62877: CALL_OW 72
62881: PUSH
62882: LD_EXP 59
62886: PUSH
62887: LD_VAR 0 1
62891: ARRAY
62892: PPUSH
62893: LD_INT 2
62895: PUSH
62896: LD_INT 30
62898: PUSH
62899: LD_INT 4
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 30
62908: PUSH
62909: LD_INT 5
62911: PUSH
62912: EMPTY
62913: LIST
62914: LIST
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: LIST
62920: PPUSH
62921: CALL_OW 72
62925: PUSH
62926: LD_INT 6
62928: MUL
62929: PLUS
62930: ST_TO_ADDR
// if bcount < tmp then
62931: LD_VAR 0 13
62935: PUSH
62936: LD_VAR 0 4
62940: LESS
62941: IFFALSE 62987
// for i = tmp downto bcount do
62943: LD_ADDR_VAR 0 3
62947: PUSH
62948: DOUBLE
62949: LD_VAR 0 4
62953: INC
62954: ST_TO_ADDR
62955: LD_VAR 0 13
62959: PUSH
62960: FOR_DOWNTO
62961: IFFALSE 62985
// tmp := Delete ( tmp , tmp ) ;
62963: LD_ADDR_VAR 0 4
62967: PUSH
62968: LD_VAR 0 4
62972: PPUSH
62973: LD_VAR 0 4
62977: PPUSH
62978: CALL_OW 3
62982: ST_TO_ADDR
62983: GO 62960
62985: POP
62986: POP
// result := [ tmp , 0 , 0 , p ] ;
62987: LD_ADDR_VAR 0 2
62991: PUSH
62992: LD_VAR 0 4
62996: PUSH
62997: LD_INT 0
62999: PUSH
63000: LD_INT 0
63002: PUSH
63003: LD_VAR 0 11
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: ST_TO_ADDR
// exit ;
63014: GO 65704
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63016: LD_EXP 59
63020: PUSH
63021: LD_VAR 0 1
63025: ARRAY
63026: PPUSH
63027: LD_INT 2
63029: PUSH
63030: LD_INT 30
63032: PUSH
63033: LD_INT 6
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PUSH
63040: LD_INT 30
63042: PUSH
63043: LD_INT 7
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: PUSH
63050: LD_INT 30
63052: PUSH
63053: LD_INT 8
63055: PUSH
63056: EMPTY
63057: LIST
63058: LIST
63059: PUSH
63060: EMPTY
63061: LIST
63062: LIST
63063: LIST
63064: LIST
63065: PPUSH
63066: CALL_OW 72
63070: NOT
63071: PUSH
63072: LD_EXP 59
63076: PUSH
63077: LD_VAR 0 1
63081: ARRAY
63082: PPUSH
63083: LD_INT 30
63085: PUSH
63086: LD_INT 3
63088: PUSH
63089: EMPTY
63090: LIST
63091: LIST
63092: PPUSH
63093: CALL_OW 72
63097: NOT
63098: AND
63099: IFFALSE 63171
// begin if eng = tmp then
63101: LD_VAR 0 6
63105: PUSH
63106: LD_VAR 0 4
63110: EQUAL
63111: IFFALSE 63115
// exit ;
63113: GO 65704
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63115: LD_ADDR_EXP 101
63119: PUSH
63120: LD_EXP 101
63124: PPUSH
63125: LD_VAR 0 1
63129: PPUSH
63130: LD_INT 1
63132: PPUSH
63133: CALL_OW 1
63137: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63138: LD_ADDR_VAR 0 2
63142: PUSH
63143: LD_INT 0
63145: PUSH
63146: LD_VAR 0 4
63150: PUSH
63151: LD_VAR 0 6
63155: DIFF
63156: PUSH
63157: LD_INT 0
63159: PUSH
63160: LD_INT 0
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: ST_TO_ADDR
// exit ;
63169: GO 65704
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63171: LD_EXP 86
63175: PUSH
63176: LD_EXP 85
63180: PUSH
63181: LD_VAR 0 1
63185: ARRAY
63186: ARRAY
63187: PUSH
63188: LD_EXP 59
63192: PUSH
63193: LD_VAR 0 1
63197: ARRAY
63198: PPUSH
63199: LD_INT 2
63201: PUSH
63202: LD_INT 30
63204: PUSH
63205: LD_INT 6
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: PUSH
63212: LD_INT 30
63214: PUSH
63215: LD_INT 7
63217: PUSH
63218: EMPTY
63219: LIST
63220: LIST
63221: PUSH
63222: LD_INT 30
63224: PUSH
63225: LD_INT 8
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: PPUSH
63238: CALL_OW 72
63242: AND
63243: PUSH
63244: LD_EXP 59
63248: PUSH
63249: LD_VAR 0 1
63253: ARRAY
63254: PPUSH
63255: LD_INT 30
63257: PUSH
63258: LD_INT 3
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: PPUSH
63265: CALL_OW 72
63269: NOT
63270: AND
63271: IFFALSE 63485
// begin if sci >= 6 then
63273: LD_VAR 0 8
63277: PUSH
63278: LD_INT 6
63280: GREATEREQUAL
63281: IFFALSE 63285
// exit ;
63283: GO 65704
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63285: LD_ADDR_EXP 101
63289: PUSH
63290: LD_EXP 101
63294: PPUSH
63295: LD_VAR 0 1
63299: PPUSH
63300: LD_INT 2
63302: PPUSH
63303: CALL_OW 1
63307: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63308: LD_ADDR_VAR 0 9
63312: PUSH
63313: LD_VAR 0 4
63317: PUSH
63318: LD_VAR 0 8
63322: DIFF
63323: PPUSH
63324: LD_INT 4
63326: PPUSH
63327: CALL 55787 0 2
63331: ST_TO_ADDR
// p := [ ] ;
63332: LD_ADDR_VAR 0 11
63336: PUSH
63337: EMPTY
63338: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63339: LD_VAR 0 8
63343: PUSH
63344: LD_INT 6
63346: LESS
63347: PUSH
63348: LD_VAR 0 9
63352: PUSH
63353: LD_INT 6
63355: GREATER
63356: AND
63357: IFFALSE 63438
// begin for i = 1 to 6 - sci do
63359: LD_ADDR_VAR 0 3
63363: PUSH
63364: DOUBLE
63365: LD_INT 1
63367: DEC
63368: ST_TO_ADDR
63369: LD_INT 6
63371: PUSH
63372: LD_VAR 0 8
63376: MINUS
63377: PUSH
63378: FOR_TO
63379: IFFALSE 63434
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63381: LD_ADDR_VAR 0 11
63385: PUSH
63386: LD_VAR 0 11
63390: PPUSH
63391: LD_VAR 0 11
63395: PUSH
63396: LD_INT 1
63398: PLUS
63399: PPUSH
63400: LD_VAR 0 9
63404: PUSH
63405: LD_INT 1
63407: ARRAY
63408: PPUSH
63409: CALL_OW 2
63413: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63414: LD_ADDR_VAR 0 9
63418: PUSH
63419: LD_VAR 0 9
63423: PPUSH
63424: LD_INT 1
63426: PPUSH
63427: CALL_OW 3
63431: ST_TO_ADDR
// end ;
63432: GO 63378
63434: POP
63435: POP
// end else
63436: GO 63458
// if sort then
63438: LD_VAR 0 9
63442: IFFALSE 63458
// p := sort [ 1 ] ;
63444: LD_ADDR_VAR 0 11
63448: PUSH
63449: LD_VAR 0 9
63453: PUSH
63454: LD_INT 1
63456: ARRAY
63457: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63458: LD_ADDR_VAR 0 2
63462: PUSH
63463: LD_INT 0
63465: PUSH
63466: LD_INT 0
63468: PUSH
63469: LD_INT 0
63471: PUSH
63472: LD_VAR 0 11
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: LIST
63481: LIST
63482: ST_TO_ADDR
// exit ;
63483: GO 65704
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63485: LD_EXP 86
63489: PUSH
63490: LD_EXP 85
63494: PUSH
63495: LD_VAR 0 1
63499: ARRAY
63500: ARRAY
63501: PUSH
63502: LD_EXP 59
63506: PUSH
63507: LD_VAR 0 1
63511: ARRAY
63512: PPUSH
63513: LD_INT 2
63515: PUSH
63516: LD_INT 30
63518: PUSH
63519: LD_INT 6
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PUSH
63526: LD_INT 30
63528: PUSH
63529: LD_INT 7
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 30
63538: PUSH
63539: LD_INT 8
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: PPUSH
63552: CALL_OW 72
63556: AND
63557: PUSH
63558: LD_EXP 59
63562: PUSH
63563: LD_VAR 0 1
63567: ARRAY
63568: PPUSH
63569: LD_INT 30
63571: PUSH
63572: LD_INT 3
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PPUSH
63579: CALL_OW 72
63583: AND
63584: IFFALSE 64318
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63586: LD_ADDR_EXP 101
63590: PUSH
63591: LD_EXP 101
63595: PPUSH
63596: LD_VAR 0 1
63600: PPUSH
63601: LD_INT 3
63603: PPUSH
63604: CALL_OW 1
63608: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63609: LD_ADDR_VAR 0 2
63613: PUSH
63614: LD_INT 0
63616: PUSH
63617: LD_INT 0
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: LD_INT 0
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: ST_TO_ADDR
// if not eng then
63632: LD_VAR 0 6
63636: NOT
63637: IFFALSE 63700
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63639: LD_ADDR_VAR 0 11
63643: PUSH
63644: LD_VAR 0 4
63648: PPUSH
63649: LD_INT 2
63651: PPUSH
63652: CALL 55787 0 2
63656: PUSH
63657: LD_INT 1
63659: ARRAY
63660: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63661: LD_ADDR_VAR 0 2
63665: PUSH
63666: LD_VAR 0 2
63670: PPUSH
63671: LD_INT 2
63673: PPUSH
63674: LD_VAR 0 11
63678: PPUSH
63679: CALL_OW 1
63683: ST_TO_ADDR
// tmp := tmp diff p ;
63684: LD_ADDR_VAR 0 4
63688: PUSH
63689: LD_VAR 0 4
63693: PUSH
63694: LD_VAR 0 11
63698: DIFF
63699: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63700: LD_VAR 0 4
63704: PUSH
63705: LD_VAR 0 8
63709: PUSH
63710: LD_INT 6
63712: LESS
63713: AND
63714: IFFALSE 63902
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63716: LD_ADDR_VAR 0 9
63720: PUSH
63721: LD_VAR 0 4
63725: PUSH
63726: LD_VAR 0 8
63730: PUSH
63731: LD_VAR 0 7
63735: UNION
63736: DIFF
63737: PPUSH
63738: LD_INT 4
63740: PPUSH
63741: CALL 55787 0 2
63745: ST_TO_ADDR
// p := [ ] ;
63746: LD_ADDR_VAR 0 11
63750: PUSH
63751: EMPTY
63752: ST_TO_ADDR
// if sort then
63753: LD_VAR 0 9
63757: IFFALSE 63873
// for i = 1 to 6 - sci do
63759: LD_ADDR_VAR 0 3
63763: PUSH
63764: DOUBLE
63765: LD_INT 1
63767: DEC
63768: ST_TO_ADDR
63769: LD_INT 6
63771: PUSH
63772: LD_VAR 0 8
63776: MINUS
63777: PUSH
63778: FOR_TO
63779: IFFALSE 63871
// begin if i = sort then
63781: LD_VAR 0 3
63785: PUSH
63786: LD_VAR 0 9
63790: EQUAL
63791: IFFALSE 63795
// break ;
63793: GO 63871
// if GetClass ( i ) = 4 then
63795: LD_VAR 0 3
63799: PPUSH
63800: CALL_OW 257
63804: PUSH
63805: LD_INT 4
63807: EQUAL
63808: IFFALSE 63812
// continue ;
63810: GO 63778
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63812: LD_ADDR_VAR 0 11
63816: PUSH
63817: LD_VAR 0 11
63821: PPUSH
63822: LD_VAR 0 11
63826: PUSH
63827: LD_INT 1
63829: PLUS
63830: PPUSH
63831: LD_VAR 0 9
63835: PUSH
63836: LD_VAR 0 3
63840: ARRAY
63841: PPUSH
63842: CALL_OW 2
63846: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63847: LD_ADDR_VAR 0 4
63851: PUSH
63852: LD_VAR 0 4
63856: PUSH
63857: LD_VAR 0 9
63861: PUSH
63862: LD_VAR 0 3
63866: ARRAY
63867: DIFF
63868: ST_TO_ADDR
// end ;
63869: GO 63778
63871: POP
63872: POP
// if p then
63873: LD_VAR 0 11
63877: IFFALSE 63902
// result := Replace ( result , 4 , p ) ;
63879: LD_ADDR_VAR 0 2
63883: PUSH
63884: LD_VAR 0 2
63888: PPUSH
63889: LD_INT 4
63891: PPUSH
63892: LD_VAR 0 11
63896: PPUSH
63897: CALL_OW 1
63901: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63902: LD_VAR 0 4
63906: PUSH
63907: LD_VAR 0 7
63911: PUSH
63912: LD_INT 6
63914: LESS
63915: AND
63916: IFFALSE 64104
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63918: LD_ADDR_VAR 0 9
63922: PUSH
63923: LD_VAR 0 4
63927: PUSH
63928: LD_VAR 0 8
63932: PUSH
63933: LD_VAR 0 7
63937: UNION
63938: DIFF
63939: PPUSH
63940: LD_INT 3
63942: PPUSH
63943: CALL 55787 0 2
63947: ST_TO_ADDR
// p := [ ] ;
63948: LD_ADDR_VAR 0 11
63952: PUSH
63953: EMPTY
63954: ST_TO_ADDR
// if sort then
63955: LD_VAR 0 9
63959: IFFALSE 64075
// for i = 1 to 6 - mech do
63961: LD_ADDR_VAR 0 3
63965: PUSH
63966: DOUBLE
63967: LD_INT 1
63969: DEC
63970: ST_TO_ADDR
63971: LD_INT 6
63973: PUSH
63974: LD_VAR 0 7
63978: MINUS
63979: PUSH
63980: FOR_TO
63981: IFFALSE 64073
// begin if i = sort then
63983: LD_VAR 0 3
63987: PUSH
63988: LD_VAR 0 9
63992: EQUAL
63993: IFFALSE 63997
// break ;
63995: GO 64073
// if GetClass ( i ) = 3 then
63997: LD_VAR 0 3
64001: PPUSH
64002: CALL_OW 257
64006: PUSH
64007: LD_INT 3
64009: EQUAL
64010: IFFALSE 64014
// continue ;
64012: GO 63980
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64014: LD_ADDR_VAR 0 11
64018: PUSH
64019: LD_VAR 0 11
64023: PPUSH
64024: LD_VAR 0 11
64028: PUSH
64029: LD_INT 1
64031: PLUS
64032: PPUSH
64033: LD_VAR 0 9
64037: PUSH
64038: LD_VAR 0 3
64042: ARRAY
64043: PPUSH
64044: CALL_OW 2
64048: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64049: LD_ADDR_VAR 0 4
64053: PUSH
64054: LD_VAR 0 4
64058: PUSH
64059: LD_VAR 0 9
64063: PUSH
64064: LD_VAR 0 3
64068: ARRAY
64069: DIFF
64070: ST_TO_ADDR
// end ;
64071: GO 63980
64073: POP
64074: POP
// if p then
64075: LD_VAR 0 11
64079: IFFALSE 64104
// result := Replace ( result , 3 , p ) ;
64081: LD_ADDR_VAR 0 2
64085: PUSH
64086: LD_VAR 0 2
64090: PPUSH
64091: LD_INT 3
64093: PPUSH
64094: LD_VAR 0 11
64098: PPUSH
64099: CALL_OW 1
64103: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64104: LD_VAR 0 4
64108: PUSH
64109: LD_INT 6
64111: GREATER
64112: PUSH
64113: LD_VAR 0 6
64117: PUSH
64118: LD_INT 6
64120: LESS
64121: AND
64122: IFFALSE 64316
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64124: LD_ADDR_VAR 0 9
64128: PUSH
64129: LD_VAR 0 4
64133: PUSH
64134: LD_VAR 0 8
64138: PUSH
64139: LD_VAR 0 7
64143: UNION
64144: PUSH
64145: LD_VAR 0 6
64149: UNION
64150: DIFF
64151: PPUSH
64152: LD_INT 2
64154: PPUSH
64155: CALL 55787 0 2
64159: ST_TO_ADDR
// p := [ ] ;
64160: LD_ADDR_VAR 0 11
64164: PUSH
64165: EMPTY
64166: ST_TO_ADDR
// if sort then
64167: LD_VAR 0 9
64171: IFFALSE 64287
// for i = 1 to 6 - eng do
64173: LD_ADDR_VAR 0 3
64177: PUSH
64178: DOUBLE
64179: LD_INT 1
64181: DEC
64182: ST_TO_ADDR
64183: LD_INT 6
64185: PUSH
64186: LD_VAR 0 6
64190: MINUS
64191: PUSH
64192: FOR_TO
64193: IFFALSE 64285
// begin if i = sort then
64195: LD_VAR 0 3
64199: PUSH
64200: LD_VAR 0 9
64204: EQUAL
64205: IFFALSE 64209
// break ;
64207: GO 64285
// if GetClass ( i ) = 2 then
64209: LD_VAR 0 3
64213: PPUSH
64214: CALL_OW 257
64218: PUSH
64219: LD_INT 2
64221: EQUAL
64222: IFFALSE 64226
// continue ;
64224: GO 64192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64226: LD_ADDR_VAR 0 11
64230: PUSH
64231: LD_VAR 0 11
64235: PPUSH
64236: LD_VAR 0 11
64240: PUSH
64241: LD_INT 1
64243: PLUS
64244: PPUSH
64245: LD_VAR 0 9
64249: PUSH
64250: LD_VAR 0 3
64254: ARRAY
64255: PPUSH
64256: CALL_OW 2
64260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64261: LD_ADDR_VAR 0 4
64265: PUSH
64266: LD_VAR 0 4
64270: PUSH
64271: LD_VAR 0 9
64275: PUSH
64276: LD_VAR 0 3
64280: ARRAY
64281: DIFF
64282: ST_TO_ADDR
// end ;
64283: GO 64192
64285: POP
64286: POP
// if p then
64287: LD_VAR 0 11
64291: IFFALSE 64316
// result := Replace ( result , 2 , p ) ;
64293: LD_ADDR_VAR 0 2
64297: PUSH
64298: LD_VAR 0 2
64302: PPUSH
64303: LD_INT 2
64305: PPUSH
64306: LD_VAR 0 11
64310: PPUSH
64311: CALL_OW 1
64315: ST_TO_ADDR
// end ; exit ;
64316: GO 65704
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64318: LD_EXP 86
64322: PUSH
64323: LD_EXP 85
64327: PUSH
64328: LD_VAR 0 1
64332: ARRAY
64333: ARRAY
64334: NOT
64335: PUSH
64336: LD_EXP 59
64340: PUSH
64341: LD_VAR 0 1
64345: ARRAY
64346: PPUSH
64347: LD_INT 30
64349: PUSH
64350: LD_INT 3
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PPUSH
64357: CALL_OW 72
64361: AND
64362: PUSH
64363: LD_EXP 64
64367: PUSH
64368: LD_VAR 0 1
64372: ARRAY
64373: AND
64374: IFFALSE 64982
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64376: LD_ADDR_EXP 101
64380: PUSH
64381: LD_EXP 101
64385: PPUSH
64386: LD_VAR 0 1
64390: PPUSH
64391: LD_INT 5
64393: PPUSH
64394: CALL_OW 1
64398: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64399: LD_ADDR_VAR 0 2
64403: PUSH
64404: LD_INT 0
64406: PUSH
64407: LD_INT 0
64409: PUSH
64410: LD_INT 0
64412: PUSH
64413: LD_INT 0
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: LIST
64420: LIST
64421: ST_TO_ADDR
// if sci > 1 then
64422: LD_VAR 0 8
64426: PUSH
64427: LD_INT 1
64429: GREATER
64430: IFFALSE 64458
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64432: LD_ADDR_VAR 0 4
64436: PUSH
64437: LD_VAR 0 4
64441: PUSH
64442: LD_VAR 0 8
64446: PUSH
64447: LD_VAR 0 8
64451: PUSH
64452: LD_INT 1
64454: ARRAY
64455: DIFF
64456: DIFF
64457: ST_TO_ADDR
// if tmp and not sci then
64458: LD_VAR 0 4
64462: PUSH
64463: LD_VAR 0 8
64467: NOT
64468: AND
64469: IFFALSE 64538
// begin sort := SortBySkill ( tmp , 4 ) ;
64471: LD_ADDR_VAR 0 9
64475: PUSH
64476: LD_VAR 0 4
64480: PPUSH
64481: LD_INT 4
64483: PPUSH
64484: CALL 55787 0 2
64488: ST_TO_ADDR
// if sort then
64489: LD_VAR 0 9
64493: IFFALSE 64509
// p := sort [ 1 ] ;
64495: LD_ADDR_VAR 0 11
64499: PUSH
64500: LD_VAR 0 9
64504: PUSH
64505: LD_INT 1
64507: ARRAY
64508: ST_TO_ADDR
// if p then
64509: LD_VAR 0 11
64513: IFFALSE 64538
// result := Replace ( result , 4 , p ) ;
64515: LD_ADDR_VAR 0 2
64519: PUSH
64520: LD_VAR 0 2
64524: PPUSH
64525: LD_INT 4
64527: PPUSH
64528: LD_VAR 0 11
64532: PPUSH
64533: CALL_OW 1
64537: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64538: LD_ADDR_VAR 0 4
64542: PUSH
64543: LD_VAR 0 4
64547: PUSH
64548: LD_VAR 0 7
64552: DIFF
64553: ST_TO_ADDR
// if tmp and mech < 6 then
64554: LD_VAR 0 4
64558: PUSH
64559: LD_VAR 0 7
64563: PUSH
64564: LD_INT 6
64566: LESS
64567: AND
64568: IFFALSE 64756
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64570: LD_ADDR_VAR 0 9
64574: PUSH
64575: LD_VAR 0 4
64579: PUSH
64580: LD_VAR 0 8
64584: PUSH
64585: LD_VAR 0 7
64589: UNION
64590: DIFF
64591: PPUSH
64592: LD_INT 3
64594: PPUSH
64595: CALL 55787 0 2
64599: ST_TO_ADDR
// p := [ ] ;
64600: LD_ADDR_VAR 0 11
64604: PUSH
64605: EMPTY
64606: ST_TO_ADDR
// if sort then
64607: LD_VAR 0 9
64611: IFFALSE 64727
// for i = 1 to 6 - mech do
64613: LD_ADDR_VAR 0 3
64617: PUSH
64618: DOUBLE
64619: LD_INT 1
64621: DEC
64622: ST_TO_ADDR
64623: LD_INT 6
64625: PUSH
64626: LD_VAR 0 7
64630: MINUS
64631: PUSH
64632: FOR_TO
64633: IFFALSE 64725
// begin if i = sort then
64635: LD_VAR 0 3
64639: PUSH
64640: LD_VAR 0 9
64644: EQUAL
64645: IFFALSE 64649
// break ;
64647: GO 64725
// if GetClass ( i ) = 3 then
64649: LD_VAR 0 3
64653: PPUSH
64654: CALL_OW 257
64658: PUSH
64659: LD_INT 3
64661: EQUAL
64662: IFFALSE 64666
// continue ;
64664: GO 64632
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64666: LD_ADDR_VAR 0 11
64670: PUSH
64671: LD_VAR 0 11
64675: PPUSH
64676: LD_VAR 0 11
64680: PUSH
64681: LD_INT 1
64683: PLUS
64684: PPUSH
64685: LD_VAR 0 9
64689: PUSH
64690: LD_VAR 0 3
64694: ARRAY
64695: PPUSH
64696: CALL_OW 2
64700: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64701: LD_ADDR_VAR 0 4
64705: PUSH
64706: LD_VAR 0 4
64710: PUSH
64711: LD_VAR 0 9
64715: PUSH
64716: LD_VAR 0 3
64720: ARRAY
64721: DIFF
64722: ST_TO_ADDR
// end ;
64723: GO 64632
64725: POP
64726: POP
// if p then
64727: LD_VAR 0 11
64731: IFFALSE 64756
// result := Replace ( result , 3 , p ) ;
64733: LD_ADDR_VAR 0 2
64737: PUSH
64738: LD_VAR 0 2
64742: PPUSH
64743: LD_INT 3
64745: PPUSH
64746: LD_VAR 0 11
64750: PPUSH
64751: CALL_OW 1
64755: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64756: LD_ADDR_VAR 0 4
64760: PUSH
64761: LD_VAR 0 4
64765: PUSH
64766: LD_VAR 0 6
64770: DIFF
64771: ST_TO_ADDR
// if tmp and eng < 6 then
64772: LD_VAR 0 4
64776: PUSH
64777: LD_VAR 0 6
64781: PUSH
64782: LD_INT 6
64784: LESS
64785: AND
64786: IFFALSE 64980
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64788: LD_ADDR_VAR 0 9
64792: PUSH
64793: LD_VAR 0 4
64797: PUSH
64798: LD_VAR 0 8
64802: PUSH
64803: LD_VAR 0 7
64807: UNION
64808: PUSH
64809: LD_VAR 0 6
64813: UNION
64814: DIFF
64815: PPUSH
64816: LD_INT 2
64818: PPUSH
64819: CALL 55787 0 2
64823: ST_TO_ADDR
// p := [ ] ;
64824: LD_ADDR_VAR 0 11
64828: PUSH
64829: EMPTY
64830: ST_TO_ADDR
// if sort then
64831: LD_VAR 0 9
64835: IFFALSE 64951
// for i = 1 to 6 - eng do
64837: LD_ADDR_VAR 0 3
64841: PUSH
64842: DOUBLE
64843: LD_INT 1
64845: DEC
64846: ST_TO_ADDR
64847: LD_INT 6
64849: PUSH
64850: LD_VAR 0 6
64854: MINUS
64855: PUSH
64856: FOR_TO
64857: IFFALSE 64949
// begin if i = sort then
64859: LD_VAR 0 3
64863: PUSH
64864: LD_VAR 0 9
64868: EQUAL
64869: IFFALSE 64873
// break ;
64871: GO 64949
// if GetClass ( i ) = 2 then
64873: LD_VAR 0 3
64877: PPUSH
64878: CALL_OW 257
64882: PUSH
64883: LD_INT 2
64885: EQUAL
64886: IFFALSE 64890
// continue ;
64888: GO 64856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64890: LD_ADDR_VAR 0 11
64894: PUSH
64895: LD_VAR 0 11
64899: PPUSH
64900: LD_VAR 0 11
64904: PUSH
64905: LD_INT 1
64907: PLUS
64908: PPUSH
64909: LD_VAR 0 9
64913: PUSH
64914: LD_VAR 0 3
64918: ARRAY
64919: PPUSH
64920: CALL_OW 2
64924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64925: LD_ADDR_VAR 0 4
64929: PUSH
64930: LD_VAR 0 4
64934: PUSH
64935: LD_VAR 0 9
64939: PUSH
64940: LD_VAR 0 3
64944: ARRAY
64945: DIFF
64946: ST_TO_ADDR
// end ;
64947: GO 64856
64949: POP
64950: POP
// if p then
64951: LD_VAR 0 11
64955: IFFALSE 64980
// result := Replace ( result , 2 , p ) ;
64957: LD_ADDR_VAR 0 2
64961: PUSH
64962: LD_VAR 0 2
64966: PPUSH
64967: LD_INT 2
64969: PPUSH
64970: LD_VAR 0 11
64974: PPUSH
64975: CALL_OW 1
64979: ST_TO_ADDR
// end ; exit ;
64980: GO 65704
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64982: LD_EXP 86
64986: PUSH
64987: LD_EXP 85
64991: PUSH
64992: LD_VAR 0 1
64996: ARRAY
64997: ARRAY
64998: NOT
64999: PUSH
65000: LD_EXP 59
65004: PUSH
65005: LD_VAR 0 1
65009: ARRAY
65010: PPUSH
65011: LD_INT 30
65013: PUSH
65014: LD_INT 3
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PPUSH
65021: CALL_OW 72
65025: AND
65026: PUSH
65027: LD_EXP 64
65031: PUSH
65032: LD_VAR 0 1
65036: ARRAY
65037: NOT
65038: AND
65039: IFFALSE 65704
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65041: LD_ADDR_EXP 101
65045: PUSH
65046: LD_EXP 101
65050: PPUSH
65051: LD_VAR 0 1
65055: PPUSH
65056: LD_INT 6
65058: PPUSH
65059: CALL_OW 1
65063: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65064: LD_ADDR_VAR 0 2
65068: PUSH
65069: LD_INT 0
65071: PUSH
65072: LD_INT 0
65074: PUSH
65075: LD_INT 0
65077: PUSH
65078: LD_INT 0
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: ST_TO_ADDR
// if sci >= 1 then
65087: LD_VAR 0 8
65091: PUSH
65092: LD_INT 1
65094: GREATEREQUAL
65095: IFFALSE 65117
// tmp := tmp diff sci [ 1 ] ;
65097: LD_ADDR_VAR 0 4
65101: PUSH
65102: LD_VAR 0 4
65106: PUSH
65107: LD_VAR 0 8
65111: PUSH
65112: LD_INT 1
65114: ARRAY
65115: DIFF
65116: ST_TO_ADDR
// if tmp and not sci then
65117: LD_VAR 0 4
65121: PUSH
65122: LD_VAR 0 8
65126: NOT
65127: AND
65128: IFFALSE 65197
// begin sort := SortBySkill ( tmp , 4 ) ;
65130: LD_ADDR_VAR 0 9
65134: PUSH
65135: LD_VAR 0 4
65139: PPUSH
65140: LD_INT 4
65142: PPUSH
65143: CALL 55787 0 2
65147: ST_TO_ADDR
// if sort then
65148: LD_VAR 0 9
65152: IFFALSE 65168
// p := sort [ 1 ] ;
65154: LD_ADDR_VAR 0 11
65158: PUSH
65159: LD_VAR 0 9
65163: PUSH
65164: LD_INT 1
65166: ARRAY
65167: ST_TO_ADDR
// if p then
65168: LD_VAR 0 11
65172: IFFALSE 65197
// result := Replace ( result , 4 , p ) ;
65174: LD_ADDR_VAR 0 2
65178: PUSH
65179: LD_VAR 0 2
65183: PPUSH
65184: LD_INT 4
65186: PPUSH
65187: LD_VAR 0 11
65191: PPUSH
65192: CALL_OW 1
65196: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65197: LD_ADDR_VAR 0 4
65201: PUSH
65202: LD_VAR 0 4
65206: PUSH
65207: LD_VAR 0 7
65211: DIFF
65212: ST_TO_ADDR
// if tmp and mech < 6 then
65213: LD_VAR 0 4
65217: PUSH
65218: LD_VAR 0 7
65222: PUSH
65223: LD_INT 6
65225: LESS
65226: AND
65227: IFFALSE 65409
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65229: LD_ADDR_VAR 0 9
65233: PUSH
65234: LD_VAR 0 4
65238: PUSH
65239: LD_VAR 0 7
65243: DIFF
65244: PPUSH
65245: LD_INT 3
65247: PPUSH
65248: CALL 55787 0 2
65252: ST_TO_ADDR
// p := [ ] ;
65253: LD_ADDR_VAR 0 11
65257: PUSH
65258: EMPTY
65259: ST_TO_ADDR
// if sort then
65260: LD_VAR 0 9
65264: IFFALSE 65380
// for i = 1 to 6 - mech do
65266: LD_ADDR_VAR 0 3
65270: PUSH
65271: DOUBLE
65272: LD_INT 1
65274: DEC
65275: ST_TO_ADDR
65276: LD_INT 6
65278: PUSH
65279: LD_VAR 0 7
65283: MINUS
65284: PUSH
65285: FOR_TO
65286: IFFALSE 65378
// begin if i = sort then
65288: LD_VAR 0 3
65292: PUSH
65293: LD_VAR 0 9
65297: EQUAL
65298: IFFALSE 65302
// break ;
65300: GO 65378
// if GetClass ( i ) = 3 then
65302: LD_VAR 0 3
65306: PPUSH
65307: CALL_OW 257
65311: PUSH
65312: LD_INT 3
65314: EQUAL
65315: IFFALSE 65319
// continue ;
65317: GO 65285
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65319: LD_ADDR_VAR 0 11
65323: PUSH
65324: LD_VAR 0 11
65328: PPUSH
65329: LD_VAR 0 11
65333: PUSH
65334: LD_INT 1
65336: PLUS
65337: PPUSH
65338: LD_VAR 0 9
65342: PUSH
65343: LD_VAR 0 3
65347: ARRAY
65348: PPUSH
65349: CALL_OW 2
65353: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65354: LD_ADDR_VAR 0 4
65358: PUSH
65359: LD_VAR 0 4
65363: PUSH
65364: LD_VAR 0 9
65368: PUSH
65369: LD_VAR 0 3
65373: ARRAY
65374: DIFF
65375: ST_TO_ADDR
// end ;
65376: GO 65285
65378: POP
65379: POP
// if p then
65380: LD_VAR 0 11
65384: IFFALSE 65409
// result := Replace ( result , 3 , p ) ;
65386: LD_ADDR_VAR 0 2
65390: PUSH
65391: LD_VAR 0 2
65395: PPUSH
65396: LD_INT 3
65398: PPUSH
65399: LD_VAR 0 11
65403: PPUSH
65404: CALL_OW 1
65408: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65409: LD_ADDR_VAR 0 4
65413: PUSH
65414: LD_VAR 0 4
65418: PUSH
65419: LD_VAR 0 6
65423: DIFF
65424: ST_TO_ADDR
// if tmp and eng < 4 then
65425: LD_VAR 0 4
65429: PUSH
65430: LD_VAR 0 6
65434: PUSH
65435: LD_INT 4
65437: LESS
65438: AND
65439: IFFALSE 65629
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65441: LD_ADDR_VAR 0 9
65445: PUSH
65446: LD_VAR 0 4
65450: PUSH
65451: LD_VAR 0 7
65455: PUSH
65456: LD_VAR 0 6
65460: UNION
65461: DIFF
65462: PPUSH
65463: LD_INT 2
65465: PPUSH
65466: CALL 55787 0 2
65470: ST_TO_ADDR
// p := [ ] ;
65471: LD_ADDR_VAR 0 11
65475: PUSH
65476: EMPTY
65477: ST_TO_ADDR
// if sort then
65478: LD_VAR 0 9
65482: IFFALSE 65598
// for i = 1 to 4 - eng do
65484: LD_ADDR_VAR 0 3
65488: PUSH
65489: DOUBLE
65490: LD_INT 1
65492: DEC
65493: ST_TO_ADDR
65494: LD_INT 4
65496: PUSH
65497: LD_VAR 0 6
65501: MINUS
65502: PUSH
65503: FOR_TO
65504: IFFALSE 65596
// begin if i = sort then
65506: LD_VAR 0 3
65510: PUSH
65511: LD_VAR 0 9
65515: EQUAL
65516: IFFALSE 65520
// break ;
65518: GO 65596
// if GetClass ( i ) = 2 then
65520: LD_VAR 0 3
65524: PPUSH
65525: CALL_OW 257
65529: PUSH
65530: LD_INT 2
65532: EQUAL
65533: IFFALSE 65537
// continue ;
65535: GO 65503
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65537: LD_ADDR_VAR 0 11
65541: PUSH
65542: LD_VAR 0 11
65546: PPUSH
65547: LD_VAR 0 11
65551: PUSH
65552: LD_INT 1
65554: PLUS
65555: PPUSH
65556: LD_VAR 0 9
65560: PUSH
65561: LD_VAR 0 3
65565: ARRAY
65566: PPUSH
65567: CALL_OW 2
65571: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65572: LD_ADDR_VAR 0 4
65576: PUSH
65577: LD_VAR 0 4
65581: PUSH
65582: LD_VAR 0 9
65586: PUSH
65587: LD_VAR 0 3
65591: ARRAY
65592: DIFF
65593: ST_TO_ADDR
// end ;
65594: GO 65503
65596: POP
65597: POP
// if p then
65598: LD_VAR 0 11
65602: IFFALSE 65627
// result := Replace ( result , 2 , p ) ;
65604: LD_ADDR_VAR 0 2
65608: PUSH
65609: LD_VAR 0 2
65613: PPUSH
65614: LD_INT 2
65616: PPUSH
65617: LD_VAR 0 11
65621: PPUSH
65622: CALL_OW 1
65626: ST_TO_ADDR
// end else
65627: GO 65673
// for i = eng downto 5 do
65629: LD_ADDR_VAR 0 3
65633: PUSH
65634: DOUBLE
65635: LD_VAR 0 6
65639: INC
65640: ST_TO_ADDR
65641: LD_INT 5
65643: PUSH
65644: FOR_DOWNTO
65645: IFFALSE 65671
// tmp := tmp union eng [ i ] ;
65647: LD_ADDR_VAR 0 4
65651: PUSH
65652: LD_VAR 0 4
65656: PUSH
65657: LD_VAR 0 6
65661: PUSH
65662: LD_VAR 0 3
65666: ARRAY
65667: UNION
65668: ST_TO_ADDR
65669: GO 65644
65671: POP
65672: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65673: LD_ADDR_VAR 0 2
65677: PUSH
65678: LD_VAR 0 2
65682: PPUSH
65683: LD_INT 1
65685: PPUSH
65686: LD_VAR 0 4
65690: PUSH
65691: LD_VAR 0 5
65695: DIFF
65696: PPUSH
65697: CALL_OW 1
65701: ST_TO_ADDR
// exit ;
65702: GO 65704
// end ; end ;
65704: LD_VAR 0 2
65708: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65709: LD_INT 0
65711: PPUSH
65712: PPUSH
65713: PPUSH
// if not mc_bases then
65714: LD_EXP 59
65718: NOT
65719: IFFALSE 65723
// exit ;
65721: GO 65829
// for i = 1 to mc_bases do
65723: LD_ADDR_VAR 0 2
65727: PUSH
65728: DOUBLE
65729: LD_INT 1
65731: DEC
65732: ST_TO_ADDR
65733: LD_EXP 59
65737: PUSH
65738: FOR_TO
65739: IFFALSE 65820
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65741: LD_ADDR_VAR 0 3
65745: PUSH
65746: LD_EXP 59
65750: PUSH
65751: LD_VAR 0 2
65755: ARRAY
65756: PPUSH
65757: LD_INT 21
65759: PUSH
65760: LD_INT 3
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 3
65769: PUSH
65770: LD_INT 24
65772: PUSH
65773: LD_INT 1000
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PPUSH
65788: CALL_OW 72
65792: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65793: LD_ADDR_EXP 60
65797: PUSH
65798: LD_EXP 60
65802: PPUSH
65803: LD_VAR 0 2
65807: PPUSH
65808: LD_VAR 0 3
65812: PPUSH
65813: CALL_OW 1
65817: ST_TO_ADDR
// end ;
65818: GO 65738
65820: POP
65821: POP
// RaiseSailEvent ( 101 ) ;
65822: LD_INT 101
65824: PPUSH
65825: CALL_OW 427
// end ;
65829: LD_VAR 0 1
65833: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65834: LD_INT 0
65836: PPUSH
65837: PPUSH
65838: PPUSH
65839: PPUSH
65840: PPUSH
65841: PPUSH
65842: PPUSH
// if not mc_bases then
65843: LD_EXP 59
65847: NOT
65848: IFFALSE 65852
// exit ;
65850: GO 66425
// for i = 1 to mc_bases do
65852: LD_ADDR_VAR 0 2
65856: PUSH
65857: DOUBLE
65858: LD_INT 1
65860: DEC
65861: ST_TO_ADDR
65862: LD_EXP 59
65866: PUSH
65867: FOR_TO
65868: IFFALSE 66416
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65870: LD_ADDR_VAR 0 5
65874: PUSH
65875: LD_EXP 59
65879: PUSH
65880: LD_VAR 0 2
65884: ARRAY
65885: PUSH
65886: LD_EXP 88
65890: PUSH
65891: LD_VAR 0 2
65895: ARRAY
65896: UNION
65897: PPUSH
65898: LD_INT 21
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 1
65910: PUSH
65911: LD_INT 3
65913: PUSH
65914: LD_INT 54
65916: PUSH
65917: EMPTY
65918: LIST
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 3
65926: PUSH
65927: LD_INT 24
65929: PUSH
65930: LD_INT 800
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: LIST
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PPUSH
65950: CALL_OW 72
65954: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65955: LD_ADDR_VAR 0 6
65959: PUSH
65960: LD_EXP 59
65964: PUSH
65965: LD_VAR 0 2
65969: ARRAY
65970: PPUSH
65971: LD_INT 21
65973: PUSH
65974: LD_INT 1
65976: PUSH
65977: EMPTY
65978: LIST
65979: LIST
65980: PUSH
65981: LD_INT 1
65983: PUSH
65984: LD_INT 3
65986: PUSH
65987: LD_INT 54
65989: PUSH
65990: EMPTY
65991: LIST
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: LD_INT 3
65999: PUSH
66000: LD_INT 24
66002: PUSH
66003: LD_INT 250
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: LIST
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PPUSH
66023: CALL_OW 72
66027: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66028: LD_ADDR_VAR 0 7
66032: PUSH
66033: LD_VAR 0 5
66037: PUSH
66038: LD_VAR 0 6
66042: DIFF
66043: ST_TO_ADDR
// if not need_heal_1 then
66044: LD_VAR 0 6
66048: NOT
66049: IFFALSE 66082
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66051: LD_ADDR_EXP 62
66055: PUSH
66056: LD_EXP 62
66060: PPUSH
66061: LD_VAR 0 2
66065: PUSH
66066: LD_INT 1
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PPUSH
66073: EMPTY
66074: PPUSH
66075: CALL 21529 0 3
66079: ST_TO_ADDR
66080: GO 66152
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66082: LD_ADDR_EXP 62
66086: PUSH
66087: LD_EXP 62
66091: PPUSH
66092: LD_VAR 0 2
66096: PUSH
66097: LD_INT 1
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PPUSH
66104: LD_EXP 62
66108: PUSH
66109: LD_VAR 0 2
66113: ARRAY
66114: PUSH
66115: LD_INT 1
66117: ARRAY
66118: PPUSH
66119: LD_INT 3
66121: PUSH
66122: LD_INT 24
66124: PUSH
66125: LD_INT 1000
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PPUSH
66136: CALL_OW 72
66140: PUSH
66141: LD_VAR 0 6
66145: UNION
66146: PPUSH
66147: CALL 21529 0 3
66151: ST_TO_ADDR
// if not need_heal_2 then
66152: LD_VAR 0 7
66156: NOT
66157: IFFALSE 66190
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66159: LD_ADDR_EXP 62
66163: PUSH
66164: LD_EXP 62
66168: PPUSH
66169: LD_VAR 0 2
66173: PUSH
66174: LD_INT 2
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PPUSH
66181: EMPTY
66182: PPUSH
66183: CALL 21529 0 3
66187: ST_TO_ADDR
66188: GO 66222
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66190: LD_ADDR_EXP 62
66194: PUSH
66195: LD_EXP 62
66199: PPUSH
66200: LD_VAR 0 2
66204: PUSH
66205: LD_INT 2
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PPUSH
66212: LD_VAR 0 7
66216: PPUSH
66217: CALL 21529 0 3
66221: ST_TO_ADDR
// if need_heal_2 then
66222: LD_VAR 0 7
66226: IFFALSE 66398
// for j in need_heal_2 do
66228: LD_ADDR_VAR 0 3
66232: PUSH
66233: LD_VAR 0 7
66237: PUSH
66238: FOR_IN
66239: IFFALSE 66396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66241: LD_ADDR_VAR 0 5
66245: PUSH
66246: LD_EXP 59
66250: PUSH
66251: LD_VAR 0 2
66255: ARRAY
66256: PPUSH
66257: LD_INT 2
66259: PUSH
66260: LD_INT 30
66262: PUSH
66263: LD_INT 6
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 30
66272: PUSH
66273: LD_INT 7
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 30
66282: PUSH
66283: LD_INT 8
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 30
66292: PUSH
66293: LD_INT 0
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 30
66302: PUSH
66303: LD_INT 1
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 25
66312: PUSH
66313: LD_INT 4
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: PPUSH
66329: CALL_OW 72
66333: ST_TO_ADDR
// if tmp then
66334: LD_VAR 0 5
66338: IFFALSE 66394
// begin k := NearestUnitToUnit ( tmp , j ) ;
66340: LD_ADDR_VAR 0 4
66344: PUSH
66345: LD_VAR 0 5
66349: PPUSH
66350: LD_VAR 0 3
66354: PPUSH
66355: CALL_OW 74
66359: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66360: LD_VAR 0 3
66364: PPUSH
66365: LD_VAR 0 4
66369: PPUSH
66370: CALL_OW 296
66374: PUSH
66375: LD_INT 7
66377: GREATER
66378: IFFALSE 66394
// ComMoveUnit ( j , k ) ;
66380: LD_VAR 0 3
66384: PPUSH
66385: LD_VAR 0 4
66389: PPUSH
66390: CALL_OW 112
// end ; end ;
66394: GO 66238
66396: POP
66397: POP
// if not need_heal_1 and not need_heal_2 then
66398: LD_VAR 0 6
66402: NOT
66403: PUSH
66404: LD_VAR 0 7
66408: NOT
66409: AND
66410: IFFALSE 66414
// continue ;
66412: GO 65867
// end ;
66414: GO 65867
66416: POP
66417: POP
// RaiseSailEvent ( 102 ) ;
66418: LD_INT 102
66420: PPUSH
66421: CALL_OW 427
// end ;
66425: LD_VAR 0 1
66429: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66430: LD_INT 0
66432: PPUSH
66433: PPUSH
66434: PPUSH
66435: PPUSH
66436: PPUSH
66437: PPUSH
66438: PPUSH
66439: PPUSH
// if not mc_bases then
66440: LD_EXP 59
66444: NOT
66445: IFFALSE 66449
// exit ;
66447: GO 67289
// for i = 1 to mc_bases do
66449: LD_ADDR_VAR 0 2
66453: PUSH
66454: DOUBLE
66455: LD_INT 1
66457: DEC
66458: ST_TO_ADDR
66459: LD_EXP 59
66463: PUSH
66464: FOR_TO
66465: IFFALSE 67287
// begin if not mc_building_need_repair [ i ] then
66467: LD_EXP 60
66471: PUSH
66472: LD_VAR 0 2
66476: ARRAY
66477: NOT
66478: IFFALSE 66652
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66480: LD_ADDR_VAR 0 6
66484: PUSH
66485: LD_EXP 78
66489: PUSH
66490: LD_VAR 0 2
66494: ARRAY
66495: PPUSH
66496: LD_INT 3
66498: PUSH
66499: LD_INT 24
66501: PUSH
66502: LD_INT 1000
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 2
66515: PUSH
66516: LD_INT 34
66518: PUSH
66519: LD_INT 13
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 34
66528: PUSH
66529: LD_INT 52
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: LIST
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PPUSH
66545: CALL_OW 72
66549: ST_TO_ADDR
// if cranes then
66550: LD_VAR 0 6
66554: IFFALSE 66616
// for j in cranes do
66556: LD_ADDR_VAR 0 3
66560: PUSH
66561: LD_VAR 0 6
66565: PUSH
66566: FOR_IN
66567: IFFALSE 66614
// if not IsInArea ( j , mc_parking [ i ] ) then
66569: LD_VAR 0 3
66573: PPUSH
66574: LD_EXP 83
66578: PUSH
66579: LD_VAR 0 2
66583: ARRAY
66584: PPUSH
66585: CALL_OW 308
66589: NOT
66590: IFFALSE 66612
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66592: LD_VAR 0 3
66596: PPUSH
66597: LD_EXP 83
66601: PUSH
66602: LD_VAR 0 2
66606: ARRAY
66607: PPUSH
66608: CALL_OW 113
66612: GO 66566
66614: POP
66615: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66616: LD_ADDR_EXP 61
66620: PUSH
66621: LD_EXP 61
66625: PPUSH
66626: LD_VAR 0 2
66630: PPUSH
66631: EMPTY
66632: PPUSH
66633: CALL_OW 1
66637: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66638: LD_VAR 0 2
66642: PPUSH
66643: LD_INT 101
66645: PPUSH
66646: CALL 61542 0 2
// continue ;
66650: GO 66464
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66652: LD_ADDR_EXP 65
66656: PUSH
66657: LD_EXP 65
66661: PPUSH
66662: LD_VAR 0 2
66666: PPUSH
66667: EMPTY
66668: PPUSH
66669: CALL_OW 1
66673: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66674: LD_VAR 0 2
66678: PPUSH
66679: LD_INT 103
66681: PPUSH
66682: CALL 61542 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66686: LD_ADDR_VAR 0 5
66690: PUSH
66691: LD_EXP 59
66695: PUSH
66696: LD_VAR 0 2
66700: ARRAY
66701: PUSH
66702: LD_EXP 88
66706: PUSH
66707: LD_VAR 0 2
66711: ARRAY
66712: UNION
66713: PPUSH
66714: LD_INT 2
66716: PUSH
66717: LD_INT 25
66719: PUSH
66720: LD_INT 2
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 25
66729: PUSH
66730: LD_INT 16
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: LIST
66741: PUSH
66742: EMPTY
66743: LIST
66744: PPUSH
66745: CALL_OW 72
66749: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66750: LD_ADDR_VAR 0 6
66754: PUSH
66755: LD_EXP 78
66759: PUSH
66760: LD_VAR 0 2
66764: ARRAY
66765: PPUSH
66766: LD_INT 2
66768: PUSH
66769: LD_INT 34
66771: PUSH
66772: LD_INT 13
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: LD_INT 34
66781: PUSH
66782: LD_INT 52
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: LIST
66793: PPUSH
66794: CALL_OW 72
66798: ST_TO_ADDR
// if cranes then
66799: LD_VAR 0 6
66803: IFFALSE 66939
// begin for j in cranes do
66805: LD_ADDR_VAR 0 3
66809: PUSH
66810: LD_VAR 0 6
66814: PUSH
66815: FOR_IN
66816: IFFALSE 66937
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66818: LD_VAR 0 3
66822: PPUSH
66823: CALL_OW 256
66827: PUSH
66828: LD_INT 500
66830: GREATEREQUAL
66831: PUSH
66832: LD_VAR 0 3
66836: PPUSH
66837: CALL_OW 314
66841: NOT
66842: AND
66843: IFFALSE 66877
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66845: LD_VAR 0 3
66849: PPUSH
66850: LD_EXP 60
66854: PUSH
66855: LD_VAR 0 2
66859: ARRAY
66860: PPUSH
66861: LD_VAR 0 3
66865: PPUSH
66866: CALL_OW 74
66870: PPUSH
66871: CALL_OW 130
66875: GO 66935
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66877: LD_VAR 0 3
66881: PPUSH
66882: CALL_OW 256
66886: PUSH
66887: LD_INT 500
66889: LESS
66890: PUSH
66891: LD_VAR 0 3
66895: PPUSH
66896: LD_EXP 83
66900: PUSH
66901: LD_VAR 0 2
66905: ARRAY
66906: PPUSH
66907: CALL_OW 308
66911: NOT
66912: AND
66913: IFFALSE 66935
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66915: LD_VAR 0 3
66919: PPUSH
66920: LD_EXP 83
66924: PUSH
66925: LD_VAR 0 2
66929: ARRAY
66930: PPUSH
66931: CALL_OW 113
66935: GO 66815
66937: POP
66938: POP
// end ; if not tmp then
66939: LD_VAR 0 5
66943: NOT
66944: IFFALSE 66948
// continue ;
66946: GO 66464
// for j in tmp do
66948: LD_ADDR_VAR 0 3
66952: PUSH
66953: LD_VAR 0 5
66957: PUSH
66958: FOR_IN
66959: IFFALSE 67283
// begin if mc_need_heal [ i ] then
66961: LD_EXP 62
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: IFFALSE 67019
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66973: LD_VAR 0 3
66977: PUSH
66978: LD_EXP 62
66982: PUSH
66983: LD_VAR 0 2
66987: ARRAY
66988: PUSH
66989: LD_INT 1
66991: ARRAY
66992: IN
66993: PUSH
66994: LD_VAR 0 3
66998: PUSH
66999: LD_EXP 62
67003: PUSH
67004: LD_VAR 0 2
67008: ARRAY
67009: PUSH
67010: LD_INT 2
67012: ARRAY
67013: IN
67014: OR
67015: IFFALSE 67019
// continue ;
67017: GO 66958
// if IsInUnit ( j ) then
67019: LD_VAR 0 3
67023: PPUSH
67024: CALL_OW 310
67028: IFFALSE 67039
// ComExitBuilding ( j ) ;
67030: LD_VAR 0 3
67034: PPUSH
67035: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67039: LD_VAR 0 3
67043: PUSH
67044: LD_EXP 61
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: IN
67055: NOT
67056: IFFALSE 67114
// begin SetTag ( j , 101 ) ;
67058: LD_VAR 0 3
67062: PPUSH
67063: LD_INT 101
67065: PPUSH
67066: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67070: LD_ADDR_EXP 61
67074: PUSH
67075: LD_EXP 61
67079: PPUSH
67080: LD_VAR 0 2
67084: PUSH
67085: LD_EXP 61
67089: PUSH
67090: LD_VAR 0 2
67094: ARRAY
67095: PUSH
67096: LD_INT 1
67098: PLUS
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PPUSH
67104: LD_VAR 0 3
67108: PPUSH
67109: CALL 21529 0 3
67113: ST_TO_ADDR
// end ; wait ( 1 ) ;
67114: LD_INT 1
67116: PPUSH
67117: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67121: LD_ADDR_VAR 0 7
67125: PUSH
67126: LD_EXP 60
67130: PUSH
67131: LD_VAR 0 2
67135: ARRAY
67136: ST_TO_ADDR
// if mc_scan [ i ] then
67137: LD_EXP 82
67141: PUSH
67142: LD_VAR 0 2
67146: ARRAY
67147: IFFALSE 67216
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67149: LD_ADDR_VAR 0 7
67153: PUSH
67154: LD_EXP 60
67158: PUSH
67159: LD_VAR 0 2
67163: ARRAY
67164: PPUSH
67165: LD_INT 3
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: LD_INT 30
67173: PUSH
67174: LD_INT 32
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 30
67183: PUSH
67184: LD_INT 33
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 30
67193: PUSH
67194: LD_INT 31
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PPUSH
67211: CALL_OW 72
67215: ST_TO_ADDR
// if not to_repair_tmp then
67216: LD_VAR 0 7
67220: NOT
67221: IFFALSE 67225
// continue ;
67223: GO 66958
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67225: LD_ADDR_VAR 0 8
67229: PUSH
67230: LD_VAR 0 7
67234: PPUSH
67235: LD_VAR 0 3
67239: PPUSH
67240: CALL_OW 74
67244: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67245: LD_VAR 0 8
67249: PPUSH
67250: LD_INT 14
67252: PPUSH
67253: CALL 24122 0 2
67257: PUSH
67258: LD_INT 4
67260: ARRAY
67261: PUSH
67262: LD_INT 5
67264: LESS
67265: IFFALSE 67281
// ComRepairBuilding ( j , to_repair ) ;
67267: LD_VAR 0 3
67271: PPUSH
67272: LD_VAR 0 8
67276: PPUSH
67277: CALL_OW 130
// end ;
67281: GO 66958
67283: POP
67284: POP
// end ;
67285: GO 66464
67287: POP
67288: POP
// end ;
67289: LD_VAR 0 1
67293: RET
// export function MC_Heal ; var i , j , tmp ; begin
67294: LD_INT 0
67296: PPUSH
67297: PPUSH
67298: PPUSH
67299: PPUSH
// if not mc_bases then
67300: LD_EXP 59
67304: NOT
67305: IFFALSE 67309
// exit ;
67307: GO 67711
// for i = 1 to mc_bases do
67309: LD_ADDR_VAR 0 2
67313: PUSH
67314: DOUBLE
67315: LD_INT 1
67317: DEC
67318: ST_TO_ADDR
67319: LD_EXP 59
67323: PUSH
67324: FOR_TO
67325: IFFALSE 67709
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67327: LD_EXP 62
67331: PUSH
67332: LD_VAR 0 2
67336: ARRAY
67337: PUSH
67338: LD_INT 1
67340: ARRAY
67341: NOT
67342: PUSH
67343: LD_EXP 62
67347: PUSH
67348: LD_VAR 0 2
67352: ARRAY
67353: PUSH
67354: LD_INT 2
67356: ARRAY
67357: NOT
67358: AND
67359: IFFALSE 67397
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67361: LD_ADDR_EXP 63
67365: PUSH
67366: LD_EXP 63
67370: PPUSH
67371: LD_VAR 0 2
67375: PPUSH
67376: EMPTY
67377: PPUSH
67378: CALL_OW 1
67382: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67383: LD_VAR 0 2
67387: PPUSH
67388: LD_INT 102
67390: PPUSH
67391: CALL 61542 0 2
// continue ;
67395: GO 67324
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67397: LD_ADDR_VAR 0 4
67401: PUSH
67402: LD_EXP 59
67406: PUSH
67407: LD_VAR 0 2
67411: ARRAY
67412: PPUSH
67413: LD_INT 25
67415: PUSH
67416: LD_INT 4
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PPUSH
67423: CALL_OW 72
67427: ST_TO_ADDR
// if not tmp then
67428: LD_VAR 0 4
67432: NOT
67433: IFFALSE 67437
// continue ;
67435: GO 67324
// if mc_taming [ i ] then
67437: LD_EXP 90
67441: PUSH
67442: LD_VAR 0 2
67446: ARRAY
67447: IFFALSE 67471
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67449: LD_ADDR_EXP 90
67453: PUSH
67454: LD_EXP 90
67458: PPUSH
67459: LD_VAR 0 2
67463: PPUSH
67464: EMPTY
67465: PPUSH
67466: CALL_OW 1
67470: ST_TO_ADDR
// for j in tmp do
67471: LD_ADDR_VAR 0 3
67475: PUSH
67476: LD_VAR 0 4
67480: PUSH
67481: FOR_IN
67482: IFFALSE 67705
// begin if IsInUnit ( j ) then
67484: LD_VAR 0 3
67488: PPUSH
67489: CALL_OW 310
67493: IFFALSE 67504
// ComExitBuilding ( j ) ;
67495: LD_VAR 0 3
67499: PPUSH
67500: CALL_OW 122
// if not j in mc_healers [ i ] then
67504: LD_VAR 0 3
67508: PUSH
67509: LD_EXP 63
67513: PUSH
67514: LD_VAR 0 2
67518: ARRAY
67519: IN
67520: NOT
67521: IFFALSE 67567
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67523: LD_ADDR_EXP 63
67527: PUSH
67528: LD_EXP 63
67532: PPUSH
67533: LD_VAR 0 2
67537: PUSH
67538: LD_EXP 63
67542: PUSH
67543: LD_VAR 0 2
67547: ARRAY
67548: PUSH
67549: LD_INT 1
67551: PLUS
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PPUSH
67557: LD_VAR 0 3
67561: PPUSH
67562: CALL 21529 0 3
67566: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67567: LD_VAR 0 3
67571: PPUSH
67572: CALL_OW 110
67576: PUSH
67577: LD_INT 102
67579: NONEQUAL
67580: IFFALSE 67594
// SetTag ( j , 102 ) ;
67582: LD_VAR 0 3
67586: PPUSH
67587: LD_INT 102
67589: PPUSH
67590: CALL_OW 109
// Wait ( 3 ) ;
67594: LD_INT 3
67596: PPUSH
67597: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67601: LD_EXP 62
67605: PUSH
67606: LD_VAR 0 2
67610: ARRAY
67611: PUSH
67612: LD_INT 1
67614: ARRAY
67615: IFFALSE 67647
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67617: LD_VAR 0 3
67621: PPUSH
67622: LD_EXP 62
67626: PUSH
67627: LD_VAR 0 2
67631: ARRAY
67632: PUSH
67633: LD_INT 1
67635: ARRAY
67636: PUSH
67637: LD_INT 1
67639: ARRAY
67640: PPUSH
67641: CALL_OW 128
67645: GO 67703
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67647: LD_VAR 0 3
67651: PPUSH
67652: CALL_OW 314
67656: NOT
67657: PUSH
67658: LD_EXP 62
67662: PUSH
67663: LD_VAR 0 2
67667: ARRAY
67668: PUSH
67669: LD_INT 2
67671: ARRAY
67672: AND
67673: IFFALSE 67703
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67675: LD_VAR 0 3
67679: PPUSH
67680: LD_EXP 62
67684: PUSH
67685: LD_VAR 0 2
67689: ARRAY
67690: PUSH
67691: LD_INT 2
67693: ARRAY
67694: PUSH
67695: LD_INT 1
67697: ARRAY
67698: PPUSH
67699: CALL_OW 128
// end ;
67703: GO 67481
67705: POP
67706: POP
// end ;
67707: GO 67324
67709: POP
67710: POP
// end ;
67711: LD_VAR 0 1
67715: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67716: LD_INT 0
67718: PPUSH
67719: PPUSH
67720: PPUSH
67721: PPUSH
67722: PPUSH
// if not mc_bases then
67723: LD_EXP 59
67727: NOT
67728: IFFALSE 67732
// exit ;
67730: GO 68875
// for i = 1 to mc_bases do
67732: LD_ADDR_VAR 0 2
67736: PUSH
67737: DOUBLE
67738: LD_INT 1
67740: DEC
67741: ST_TO_ADDR
67742: LD_EXP 59
67746: PUSH
67747: FOR_TO
67748: IFFALSE 68873
// begin if mc_scan [ i ] then
67750: LD_EXP 82
67754: PUSH
67755: LD_VAR 0 2
67759: ARRAY
67760: IFFALSE 67764
// continue ;
67762: GO 67747
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67764: LD_EXP 64
67768: PUSH
67769: LD_VAR 0 2
67773: ARRAY
67774: NOT
67775: PUSH
67776: LD_EXP 66
67780: PUSH
67781: LD_VAR 0 2
67785: ARRAY
67786: NOT
67787: AND
67788: PUSH
67789: LD_EXP 65
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: AND
67800: IFFALSE 67838
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67802: LD_ADDR_EXP 65
67806: PUSH
67807: LD_EXP 65
67811: PPUSH
67812: LD_VAR 0 2
67816: PPUSH
67817: EMPTY
67818: PPUSH
67819: CALL_OW 1
67823: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67824: LD_VAR 0 2
67828: PPUSH
67829: LD_INT 103
67831: PPUSH
67832: CALL 61542 0 2
// continue ;
67836: GO 67747
// end ; if mc_construct_list [ i ] then
67838: LD_EXP 66
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: IFFALSE 68068
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67850: LD_ADDR_VAR 0 4
67854: PUSH
67855: LD_EXP 59
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: PPUSH
67866: LD_INT 25
67868: PUSH
67869: LD_INT 2
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: CALL_OW 72
67880: PUSH
67881: LD_EXP 61
67885: PUSH
67886: LD_VAR 0 2
67890: ARRAY
67891: DIFF
67892: ST_TO_ADDR
// if not tmp then
67893: LD_VAR 0 4
67897: NOT
67898: IFFALSE 67902
// continue ;
67900: GO 67747
// for j in tmp do
67902: LD_ADDR_VAR 0 3
67906: PUSH
67907: LD_VAR 0 4
67911: PUSH
67912: FOR_IN
67913: IFFALSE 68064
// begin if not mc_builders [ i ] then
67915: LD_EXP 65
67919: PUSH
67920: LD_VAR 0 2
67924: ARRAY
67925: NOT
67926: IFFALSE 67984
// begin SetTag ( j , 103 ) ;
67928: LD_VAR 0 3
67932: PPUSH
67933: LD_INT 103
67935: PPUSH
67936: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67940: LD_ADDR_EXP 65
67944: PUSH
67945: LD_EXP 65
67949: PPUSH
67950: LD_VAR 0 2
67954: PUSH
67955: LD_EXP 65
67959: PUSH
67960: LD_VAR 0 2
67964: ARRAY
67965: PUSH
67966: LD_INT 1
67968: PLUS
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PPUSH
67974: LD_VAR 0 3
67978: PPUSH
67979: CALL 21529 0 3
67983: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67984: LD_VAR 0 3
67988: PPUSH
67989: CALL_OW 310
67993: IFFALSE 68004
// ComExitBuilding ( j ) ;
67995: LD_VAR 0 3
67999: PPUSH
68000: CALL_OW 122
// wait ( 3 ) ;
68004: LD_INT 3
68006: PPUSH
68007: CALL_OW 67
// if not mc_construct_list [ i ] then
68011: LD_EXP 66
68015: PUSH
68016: LD_VAR 0 2
68020: ARRAY
68021: NOT
68022: IFFALSE 68026
// break ;
68024: GO 68064
// if not HasTask ( j ) then
68026: LD_VAR 0 3
68030: PPUSH
68031: CALL_OW 314
68035: NOT
68036: IFFALSE 68062
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68038: LD_VAR 0 3
68042: PPUSH
68043: LD_EXP 66
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PUSH
68054: LD_INT 1
68056: ARRAY
68057: PPUSH
68058: CALL 24380 0 2
// end ;
68062: GO 67912
68064: POP
68065: POP
// end else
68066: GO 68871
// if mc_build_list [ i ] then
68068: LD_EXP 64
68072: PUSH
68073: LD_VAR 0 2
68077: ARRAY
68078: IFFALSE 68871
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68080: LD_ADDR_VAR 0 5
68084: PUSH
68085: LD_EXP 59
68089: PUSH
68090: LD_VAR 0 2
68094: ARRAY
68095: PPUSH
68096: LD_INT 2
68098: PUSH
68099: LD_INT 30
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 30
68111: PUSH
68112: LD_INT 1
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: LIST
68123: PPUSH
68124: CALL_OW 72
68128: ST_TO_ADDR
// if depot then
68129: LD_VAR 0 5
68133: IFFALSE 68151
// depot := depot [ 1 ] else
68135: LD_ADDR_VAR 0 5
68139: PUSH
68140: LD_VAR 0 5
68144: PUSH
68145: LD_INT 1
68147: ARRAY
68148: ST_TO_ADDR
68149: GO 68159
// depot := 0 ;
68151: LD_ADDR_VAR 0 5
68155: PUSH
68156: LD_INT 0
68158: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68159: LD_EXP 64
68163: PUSH
68164: LD_VAR 0 2
68168: ARRAY
68169: PUSH
68170: LD_INT 1
68172: ARRAY
68173: PUSH
68174: LD_INT 1
68176: ARRAY
68177: PPUSH
68178: CALL 24210 0 1
68182: PUSH
68183: LD_EXP 59
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: PPUSH
68194: LD_INT 2
68196: PUSH
68197: LD_INT 30
68199: PUSH
68200: LD_INT 2
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 30
68209: PUSH
68210: LD_INT 3
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: LIST
68221: PPUSH
68222: CALL_OW 72
68226: NOT
68227: AND
68228: IFFALSE 68333
// begin for j = 1 to mc_build_list [ i ] do
68230: LD_ADDR_VAR 0 3
68234: PUSH
68235: DOUBLE
68236: LD_INT 1
68238: DEC
68239: ST_TO_ADDR
68240: LD_EXP 64
68244: PUSH
68245: LD_VAR 0 2
68249: ARRAY
68250: PUSH
68251: FOR_TO
68252: IFFALSE 68331
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68254: LD_EXP 64
68258: PUSH
68259: LD_VAR 0 2
68263: ARRAY
68264: PUSH
68265: LD_VAR 0 3
68269: ARRAY
68270: PUSH
68271: LD_INT 1
68273: ARRAY
68274: PUSH
68275: LD_INT 2
68277: EQUAL
68278: IFFALSE 68329
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68280: LD_ADDR_EXP 64
68284: PUSH
68285: LD_EXP 64
68289: PPUSH
68290: LD_VAR 0 2
68294: PPUSH
68295: LD_EXP 64
68299: PUSH
68300: LD_VAR 0 2
68304: ARRAY
68305: PPUSH
68306: LD_VAR 0 3
68310: PPUSH
68311: LD_INT 1
68313: PPUSH
68314: LD_INT 0
68316: PPUSH
68317: CALL 20947 0 4
68321: PPUSH
68322: CALL_OW 1
68326: ST_TO_ADDR
// break ;
68327: GO 68331
// end ;
68329: GO 68251
68331: POP
68332: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68333: LD_EXP 64
68337: PUSH
68338: LD_VAR 0 2
68342: ARRAY
68343: PUSH
68344: LD_INT 1
68346: ARRAY
68347: PUSH
68348: LD_INT 1
68350: ARRAY
68351: PUSH
68352: LD_INT 0
68354: EQUAL
68355: PUSH
68356: LD_VAR 0 5
68360: PUSH
68361: LD_VAR 0 5
68365: PPUSH
68366: LD_EXP 64
68370: PUSH
68371: LD_VAR 0 2
68375: ARRAY
68376: PUSH
68377: LD_INT 1
68379: ARRAY
68380: PUSH
68381: LD_INT 1
68383: ARRAY
68384: PPUSH
68385: LD_EXP 64
68389: PUSH
68390: LD_VAR 0 2
68394: ARRAY
68395: PUSH
68396: LD_INT 1
68398: ARRAY
68399: PUSH
68400: LD_INT 2
68402: ARRAY
68403: PPUSH
68404: LD_EXP 64
68408: PUSH
68409: LD_VAR 0 2
68413: ARRAY
68414: PUSH
68415: LD_INT 1
68417: ARRAY
68418: PUSH
68419: LD_INT 3
68421: ARRAY
68422: PPUSH
68423: LD_EXP 64
68427: PUSH
68428: LD_VAR 0 2
68432: ARRAY
68433: PUSH
68434: LD_INT 1
68436: ARRAY
68437: PUSH
68438: LD_INT 4
68440: ARRAY
68441: PPUSH
68442: CALL 28944 0 5
68446: AND
68447: OR
68448: IFFALSE 68729
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68450: LD_ADDR_VAR 0 4
68454: PUSH
68455: LD_EXP 59
68459: PUSH
68460: LD_VAR 0 2
68464: ARRAY
68465: PPUSH
68466: LD_INT 25
68468: PUSH
68469: LD_INT 2
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PPUSH
68476: CALL_OW 72
68480: PUSH
68481: LD_EXP 61
68485: PUSH
68486: LD_VAR 0 2
68490: ARRAY
68491: DIFF
68492: ST_TO_ADDR
// if not tmp then
68493: LD_VAR 0 4
68497: NOT
68498: IFFALSE 68502
// continue ;
68500: GO 67747
// for j in tmp do
68502: LD_ADDR_VAR 0 3
68506: PUSH
68507: LD_VAR 0 4
68511: PUSH
68512: FOR_IN
68513: IFFALSE 68725
// begin if not mc_builders [ i ] then
68515: LD_EXP 65
68519: PUSH
68520: LD_VAR 0 2
68524: ARRAY
68525: NOT
68526: IFFALSE 68584
// begin SetTag ( j , 103 ) ;
68528: LD_VAR 0 3
68532: PPUSH
68533: LD_INT 103
68535: PPUSH
68536: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68540: LD_ADDR_EXP 65
68544: PUSH
68545: LD_EXP 65
68549: PPUSH
68550: LD_VAR 0 2
68554: PUSH
68555: LD_EXP 65
68559: PUSH
68560: LD_VAR 0 2
68564: ARRAY
68565: PUSH
68566: LD_INT 1
68568: PLUS
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PPUSH
68574: LD_VAR 0 3
68578: PPUSH
68579: CALL 21529 0 3
68583: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68584: LD_VAR 0 3
68588: PPUSH
68589: CALL_OW 310
68593: IFFALSE 68604
// ComExitBuilding ( j ) ;
68595: LD_VAR 0 3
68599: PPUSH
68600: CALL_OW 122
// wait ( 3 ) ;
68604: LD_INT 3
68606: PPUSH
68607: CALL_OW 67
// if not mc_build_list [ i ] then
68611: LD_EXP 64
68615: PUSH
68616: LD_VAR 0 2
68620: ARRAY
68621: NOT
68622: IFFALSE 68626
// break ;
68624: GO 68725
// if not HasTask ( j ) then
68626: LD_VAR 0 3
68630: PPUSH
68631: CALL_OW 314
68635: NOT
68636: IFFALSE 68723
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68638: LD_VAR 0 3
68642: PPUSH
68643: LD_EXP 64
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PUSH
68654: LD_INT 1
68656: ARRAY
68657: PUSH
68658: LD_INT 1
68660: ARRAY
68661: PPUSH
68662: LD_EXP 64
68666: PUSH
68667: LD_VAR 0 2
68671: ARRAY
68672: PUSH
68673: LD_INT 1
68675: ARRAY
68676: PUSH
68677: LD_INT 2
68679: ARRAY
68680: PPUSH
68681: LD_EXP 64
68685: PUSH
68686: LD_VAR 0 2
68690: ARRAY
68691: PUSH
68692: LD_INT 1
68694: ARRAY
68695: PUSH
68696: LD_INT 3
68698: ARRAY
68699: PPUSH
68700: LD_EXP 64
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: PUSH
68711: LD_INT 1
68713: ARRAY
68714: PUSH
68715: LD_INT 4
68717: ARRAY
68718: PPUSH
68719: CALL_OW 145
// end ;
68723: GO 68512
68725: POP
68726: POP
// end else
68727: GO 68871
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68729: LD_EXP 59
68733: PUSH
68734: LD_VAR 0 2
68738: ARRAY
68739: PPUSH
68740: LD_EXP 64
68744: PUSH
68745: LD_VAR 0 2
68749: ARRAY
68750: PUSH
68751: LD_INT 1
68753: ARRAY
68754: PUSH
68755: LD_INT 1
68757: ARRAY
68758: PPUSH
68759: LD_EXP 64
68763: PUSH
68764: LD_VAR 0 2
68768: ARRAY
68769: PUSH
68770: LD_INT 1
68772: ARRAY
68773: PUSH
68774: LD_INT 2
68776: ARRAY
68777: PPUSH
68778: LD_EXP 64
68782: PUSH
68783: LD_VAR 0 2
68787: ARRAY
68788: PUSH
68789: LD_INT 1
68791: ARRAY
68792: PUSH
68793: LD_INT 3
68795: ARRAY
68796: PPUSH
68797: LD_EXP 64
68801: PUSH
68802: LD_VAR 0 2
68806: ARRAY
68807: PUSH
68808: LD_INT 1
68810: ARRAY
68811: PUSH
68812: LD_INT 4
68814: ARRAY
68815: PPUSH
68816: CALL 28280 0 5
68820: NOT
68821: IFFALSE 68871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68823: LD_ADDR_EXP 64
68827: PUSH
68828: LD_EXP 64
68832: PPUSH
68833: LD_VAR 0 2
68837: PPUSH
68838: LD_EXP 64
68842: PUSH
68843: LD_VAR 0 2
68847: ARRAY
68848: PPUSH
68849: LD_INT 1
68851: PPUSH
68852: LD_INT 1
68854: NEG
68855: PPUSH
68856: LD_INT 0
68858: PPUSH
68859: CALL 20947 0 4
68863: PPUSH
68864: CALL_OW 1
68868: ST_TO_ADDR
// continue ;
68869: GO 67747
// end ; end ; end ;
68871: GO 67747
68873: POP
68874: POP
// end ;
68875: LD_VAR 0 1
68879: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68880: LD_INT 0
68882: PPUSH
68883: PPUSH
68884: PPUSH
68885: PPUSH
68886: PPUSH
68887: PPUSH
// if not mc_bases then
68888: LD_EXP 59
68892: NOT
68893: IFFALSE 68897
// exit ;
68895: GO 69324
// for i = 1 to mc_bases do
68897: LD_ADDR_VAR 0 2
68901: PUSH
68902: DOUBLE
68903: LD_INT 1
68905: DEC
68906: ST_TO_ADDR
68907: LD_EXP 59
68911: PUSH
68912: FOR_TO
68913: IFFALSE 69322
// begin tmp := mc_build_upgrade [ i ] ;
68915: LD_ADDR_VAR 0 4
68919: PUSH
68920: LD_EXP 91
68924: PUSH
68925: LD_VAR 0 2
68929: ARRAY
68930: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68931: LD_ADDR_VAR 0 6
68935: PUSH
68936: LD_EXP 92
68940: PUSH
68941: LD_VAR 0 2
68945: ARRAY
68946: PPUSH
68947: LD_INT 2
68949: PUSH
68950: LD_INT 30
68952: PUSH
68953: LD_INT 6
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: LD_INT 30
68962: PUSH
68963: LD_INT 7
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: LIST
68974: PPUSH
68975: CALL_OW 72
68979: ST_TO_ADDR
// if not tmp and not lab then
68980: LD_VAR 0 4
68984: NOT
68985: PUSH
68986: LD_VAR 0 6
68990: NOT
68991: AND
68992: IFFALSE 68996
// continue ;
68994: GO 68912
// if tmp then
68996: LD_VAR 0 4
69000: IFFALSE 69120
// for j in tmp do
69002: LD_ADDR_VAR 0 3
69006: PUSH
69007: LD_VAR 0 4
69011: PUSH
69012: FOR_IN
69013: IFFALSE 69118
// begin if UpgradeCost ( j ) then
69015: LD_VAR 0 3
69019: PPUSH
69020: CALL 27940 0 1
69024: IFFALSE 69116
// begin ComUpgrade ( j ) ;
69026: LD_VAR 0 3
69030: PPUSH
69031: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69035: LD_ADDR_EXP 91
69039: PUSH
69040: LD_EXP 91
69044: PPUSH
69045: LD_VAR 0 2
69049: PPUSH
69050: LD_EXP 91
69054: PUSH
69055: LD_VAR 0 2
69059: ARRAY
69060: PUSH
69061: LD_VAR 0 3
69065: DIFF
69066: PPUSH
69067: CALL_OW 1
69071: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69072: LD_ADDR_EXP 66
69076: PUSH
69077: LD_EXP 66
69081: PPUSH
69082: LD_VAR 0 2
69086: PUSH
69087: LD_EXP 66
69091: PUSH
69092: LD_VAR 0 2
69096: ARRAY
69097: PUSH
69098: LD_INT 1
69100: PLUS
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PPUSH
69106: LD_VAR 0 3
69110: PPUSH
69111: CALL 21529 0 3
69115: ST_TO_ADDR
// end ; end ;
69116: GO 69012
69118: POP
69119: POP
// if not lab or not mc_lab_upgrade [ i ] then
69120: LD_VAR 0 6
69124: NOT
69125: PUSH
69126: LD_EXP 93
69130: PUSH
69131: LD_VAR 0 2
69135: ARRAY
69136: NOT
69137: OR
69138: IFFALSE 69142
// continue ;
69140: GO 68912
// for j in lab do
69142: LD_ADDR_VAR 0 3
69146: PUSH
69147: LD_VAR 0 6
69151: PUSH
69152: FOR_IN
69153: IFFALSE 69318
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69155: LD_VAR 0 3
69159: PPUSH
69160: CALL_OW 266
69164: PUSH
69165: LD_INT 6
69167: PUSH
69168: LD_INT 7
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: IN
69175: PUSH
69176: LD_VAR 0 3
69180: PPUSH
69181: CALL_OW 461
69185: PUSH
69186: LD_INT 1
69188: NONEQUAL
69189: AND
69190: IFFALSE 69316
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69192: LD_VAR 0 3
69196: PPUSH
69197: LD_EXP 93
69201: PUSH
69202: LD_VAR 0 2
69206: ARRAY
69207: PUSH
69208: LD_INT 1
69210: ARRAY
69211: PPUSH
69212: CALL 28145 0 2
69216: IFFALSE 69316
// begin ComCancel ( j ) ;
69218: LD_VAR 0 3
69222: PPUSH
69223: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69227: LD_VAR 0 3
69231: PPUSH
69232: LD_EXP 93
69236: PUSH
69237: LD_VAR 0 2
69241: ARRAY
69242: PUSH
69243: LD_INT 1
69245: ARRAY
69246: PPUSH
69247: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69251: LD_VAR 0 3
69255: PUSH
69256: LD_EXP 66
69260: PUSH
69261: LD_VAR 0 2
69265: ARRAY
69266: IN
69267: NOT
69268: IFFALSE 69314
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69270: LD_ADDR_EXP 66
69274: PUSH
69275: LD_EXP 66
69279: PPUSH
69280: LD_VAR 0 2
69284: PUSH
69285: LD_EXP 66
69289: PUSH
69290: LD_VAR 0 2
69294: ARRAY
69295: PUSH
69296: LD_INT 1
69298: PLUS
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PPUSH
69304: LD_VAR 0 3
69308: PPUSH
69309: CALL 21529 0 3
69313: ST_TO_ADDR
// break ;
69314: GO 69318
// end ; end ; end ;
69316: GO 69152
69318: POP
69319: POP
// end ;
69320: GO 68912
69322: POP
69323: POP
// end ;
69324: LD_VAR 0 1
69328: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69329: LD_INT 0
69331: PPUSH
69332: PPUSH
69333: PPUSH
69334: PPUSH
69335: PPUSH
69336: PPUSH
69337: PPUSH
69338: PPUSH
69339: PPUSH
// if not mc_bases then
69340: LD_EXP 59
69344: NOT
69345: IFFALSE 69349
// exit ;
69347: GO 69754
// for i = 1 to mc_bases do
69349: LD_ADDR_VAR 0 2
69353: PUSH
69354: DOUBLE
69355: LD_INT 1
69357: DEC
69358: ST_TO_ADDR
69359: LD_EXP 59
69363: PUSH
69364: FOR_TO
69365: IFFALSE 69752
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69367: LD_EXP 67
69371: PUSH
69372: LD_VAR 0 2
69376: ARRAY
69377: NOT
69378: PUSH
69379: LD_EXP 59
69383: PUSH
69384: LD_VAR 0 2
69388: ARRAY
69389: PPUSH
69390: LD_INT 30
69392: PUSH
69393: LD_INT 3
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PPUSH
69400: CALL_OW 72
69404: NOT
69405: OR
69406: IFFALSE 69410
// continue ;
69408: GO 69364
// busy := false ;
69410: LD_ADDR_VAR 0 8
69414: PUSH
69415: LD_INT 0
69417: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69418: LD_ADDR_VAR 0 4
69422: PUSH
69423: LD_EXP 59
69427: PUSH
69428: LD_VAR 0 2
69432: ARRAY
69433: PPUSH
69434: LD_INT 30
69436: PUSH
69437: LD_INT 3
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PPUSH
69444: CALL_OW 72
69448: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69449: LD_ADDR_VAR 0 6
69453: PUSH
69454: LD_EXP 67
69458: PUSH
69459: LD_VAR 0 2
69463: ARRAY
69464: PPUSH
69465: LD_INT 2
69467: PUSH
69468: LD_INT 30
69470: PUSH
69471: LD_INT 32
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 30
69480: PUSH
69481: LD_INT 33
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: LIST
69492: PPUSH
69493: CALL_OW 72
69497: ST_TO_ADDR
// if not t then
69498: LD_VAR 0 6
69502: NOT
69503: IFFALSE 69507
// continue ;
69505: GO 69364
// for j in tmp do
69507: LD_ADDR_VAR 0 3
69511: PUSH
69512: LD_VAR 0 4
69516: PUSH
69517: FOR_IN
69518: IFFALSE 69548
// if not BuildingStatus ( j ) = bs_idle then
69520: LD_VAR 0 3
69524: PPUSH
69525: CALL_OW 461
69529: PUSH
69530: LD_INT 2
69532: EQUAL
69533: NOT
69534: IFFALSE 69546
// begin busy := true ;
69536: LD_ADDR_VAR 0 8
69540: PUSH
69541: LD_INT 1
69543: ST_TO_ADDR
// break ;
69544: GO 69548
// end ;
69546: GO 69517
69548: POP
69549: POP
// if busy then
69550: LD_VAR 0 8
69554: IFFALSE 69558
// continue ;
69556: GO 69364
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69558: LD_ADDR_VAR 0 7
69562: PUSH
69563: LD_VAR 0 6
69567: PPUSH
69568: LD_INT 35
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PPUSH
69578: CALL_OW 72
69582: ST_TO_ADDR
// if tw then
69583: LD_VAR 0 7
69587: IFFALSE 69664
// begin tw := tw [ 1 ] ;
69589: LD_ADDR_VAR 0 7
69593: PUSH
69594: LD_VAR 0 7
69598: PUSH
69599: LD_INT 1
69601: ARRAY
69602: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69603: LD_ADDR_VAR 0 9
69607: PUSH
69608: LD_VAR 0 7
69612: PPUSH
69613: LD_EXP 84
69617: PUSH
69618: LD_VAR 0 2
69622: ARRAY
69623: PPUSH
69624: CALL 26499 0 2
69628: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69629: LD_EXP 98
69633: PUSH
69634: LD_VAR 0 2
69638: ARRAY
69639: IFFALSE 69662
// if not weapon in mc_allowed_tower_weapons [ i ] then
69641: LD_VAR 0 9
69645: PUSH
69646: LD_EXP 98
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: IN
69657: NOT
69658: IFFALSE 69662
// continue ;
69660: GO 69364
// end else
69662: GO 69727
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69664: LD_ADDR_VAR 0 5
69668: PUSH
69669: LD_EXP 67
69673: PUSH
69674: LD_VAR 0 2
69678: ARRAY
69679: PPUSH
69680: LD_VAR 0 4
69684: PPUSH
69685: CALL 56710 0 2
69689: ST_TO_ADDR
// if not tmp2 then
69690: LD_VAR 0 5
69694: NOT
69695: IFFALSE 69699
// continue ;
69697: GO 69364
// tw := tmp2 [ 1 ] ;
69699: LD_ADDR_VAR 0 7
69703: PUSH
69704: LD_VAR 0 5
69708: PUSH
69709: LD_INT 1
69711: ARRAY
69712: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69713: LD_ADDR_VAR 0 9
69717: PUSH
69718: LD_VAR 0 5
69722: PUSH
69723: LD_INT 2
69725: ARRAY
69726: ST_TO_ADDR
// end ; if not weapon then
69727: LD_VAR 0 9
69731: NOT
69732: IFFALSE 69736
// continue ;
69734: GO 69364
// ComPlaceWeapon ( tw , weapon ) ;
69736: LD_VAR 0 7
69740: PPUSH
69741: LD_VAR 0 9
69745: PPUSH
69746: CALL_OW 148
// end ;
69750: GO 69364
69752: POP
69753: POP
// end ;
69754: LD_VAR 0 1
69758: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69759: LD_INT 0
69761: PPUSH
69762: PPUSH
69763: PPUSH
69764: PPUSH
69765: PPUSH
69766: PPUSH
// if not mc_bases then
69767: LD_EXP 59
69771: NOT
69772: IFFALSE 69776
// exit ;
69774: GO 70552
// for i = 1 to mc_bases do
69776: LD_ADDR_VAR 0 2
69780: PUSH
69781: DOUBLE
69782: LD_INT 1
69784: DEC
69785: ST_TO_ADDR
69786: LD_EXP 59
69790: PUSH
69791: FOR_TO
69792: IFFALSE 70550
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69794: LD_EXP 72
69798: PUSH
69799: LD_VAR 0 2
69803: ARRAY
69804: NOT
69805: PUSH
69806: LD_EXP 72
69810: PUSH
69811: LD_VAR 0 2
69815: ARRAY
69816: PUSH
69817: LD_EXP 73
69821: PUSH
69822: LD_VAR 0 2
69826: ARRAY
69827: EQUAL
69828: OR
69829: PUSH
69830: LD_EXP 82
69834: PUSH
69835: LD_VAR 0 2
69839: ARRAY
69840: OR
69841: IFFALSE 69845
// continue ;
69843: GO 69791
// if mc_miners [ i ] then
69845: LD_EXP 73
69849: PUSH
69850: LD_VAR 0 2
69854: ARRAY
69855: IFFALSE 70237
// begin for j = mc_miners [ i ] downto 1 do
69857: LD_ADDR_VAR 0 3
69861: PUSH
69862: DOUBLE
69863: LD_EXP 73
69867: PUSH
69868: LD_VAR 0 2
69872: ARRAY
69873: INC
69874: ST_TO_ADDR
69875: LD_INT 1
69877: PUSH
69878: FOR_DOWNTO
69879: IFFALSE 70235
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69881: LD_EXP 73
69885: PUSH
69886: LD_VAR 0 2
69890: ARRAY
69891: PUSH
69892: LD_VAR 0 3
69896: ARRAY
69897: PPUSH
69898: CALL_OW 301
69902: PUSH
69903: LD_EXP 73
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PUSH
69914: LD_VAR 0 3
69918: ARRAY
69919: PPUSH
69920: CALL_OW 257
69924: PUSH
69925: LD_INT 1
69927: NONEQUAL
69928: OR
69929: IFFALSE 69992
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69931: LD_ADDR_VAR 0 5
69935: PUSH
69936: LD_EXP 73
69940: PUSH
69941: LD_VAR 0 2
69945: ARRAY
69946: PUSH
69947: LD_EXP 73
69951: PUSH
69952: LD_VAR 0 2
69956: ARRAY
69957: PUSH
69958: LD_VAR 0 3
69962: ARRAY
69963: DIFF
69964: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69965: LD_ADDR_EXP 73
69969: PUSH
69970: LD_EXP 73
69974: PPUSH
69975: LD_VAR 0 2
69979: PPUSH
69980: LD_VAR 0 5
69984: PPUSH
69985: CALL_OW 1
69989: ST_TO_ADDR
// continue ;
69990: GO 69878
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69992: LD_EXP 73
69996: PUSH
69997: LD_VAR 0 2
70001: ARRAY
70002: PUSH
70003: LD_VAR 0 3
70007: ARRAY
70008: PPUSH
70009: CALL_OW 257
70013: PUSH
70014: LD_INT 1
70016: EQUAL
70017: PUSH
70018: LD_EXP 73
70022: PUSH
70023: LD_VAR 0 2
70027: ARRAY
70028: PUSH
70029: LD_VAR 0 3
70033: ARRAY
70034: PPUSH
70035: CALL_OW 459
70039: NOT
70040: AND
70041: PUSH
70042: LD_EXP 73
70046: PUSH
70047: LD_VAR 0 2
70051: ARRAY
70052: PUSH
70053: LD_VAR 0 3
70057: ARRAY
70058: PPUSH
70059: CALL_OW 314
70063: NOT
70064: AND
70065: IFFALSE 70233
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70067: LD_EXP 73
70071: PUSH
70072: LD_VAR 0 2
70076: ARRAY
70077: PUSH
70078: LD_VAR 0 3
70082: ARRAY
70083: PPUSH
70084: CALL_OW 310
70088: IFFALSE 70111
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70090: LD_EXP 73
70094: PUSH
70095: LD_VAR 0 2
70099: ARRAY
70100: PUSH
70101: LD_VAR 0 3
70105: ARRAY
70106: PPUSH
70107: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70111: LD_EXP 73
70115: PUSH
70116: LD_VAR 0 2
70120: ARRAY
70121: PUSH
70122: LD_VAR 0 3
70126: ARRAY
70127: PPUSH
70128: CALL_OW 314
70132: NOT
70133: IFFALSE 70233
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70135: LD_EXP 73
70139: PUSH
70140: LD_VAR 0 2
70144: ARRAY
70145: PUSH
70146: LD_VAR 0 3
70150: ARRAY
70151: PPUSH
70152: LD_EXP 72
70156: PUSH
70157: LD_VAR 0 2
70161: ARRAY
70162: PUSH
70163: LD_VAR 0 3
70167: PUSH
70168: LD_EXP 72
70172: PUSH
70173: LD_VAR 0 2
70177: ARRAY
70178: MOD
70179: PUSH
70180: LD_INT 1
70182: PLUS
70183: ARRAY
70184: PUSH
70185: LD_INT 1
70187: ARRAY
70188: PPUSH
70189: LD_EXP 72
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PUSH
70200: LD_VAR 0 3
70204: PUSH
70205: LD_EXP 72
70209: PUSH
70210: LD_VAR 0 2
70214: ARRAY
70215: MOD
70216: PUSH
70217: LD_INT 1
70219: PLUS
70220: ARRAY
70221: PUSH
70222: LD_INT 2
70224: ARRAY
70225: PPUSH
70226: LD_INT 0
70228: PPUSH
70229: CALL_OW 193
// end ; end ;
70233: GO 69878
70235: POP
70236: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70237: LD_ADDR_VAR 0 5
70241: PUSH
70242: LD_EXP 59
70246: PUSH
70247: LD_VAR 0 2
70251: ARRAY
70252: PPUSH
70253: LD_INT 2
70255: PUSH
70256: LD_INT 30
70258: PUSH
70259: LD_INT 4
70261: PUSH
70262: EMPTY
70263: LIST
70264: LIST
70265: PUSH
70266: LD_INT 30
70268: PUSH
70269: LD_INT 5
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 30
70278: PUSH
70279: LD_INT 32
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: PPUSH
70292: CALL_OW 72
70296: ST_TO_ADDR
// if not tmp then
70297: LD_VAR 0 5
70301: NOT
70302: IFFALSE 70306
// continue ;
70304: GO 69791
// list := [ ] ;
70306: LD_ADDR_VAR 0 6
70310: PUSH
70311: EMPTY
70312: ST_TO_ADDR
// for j in tmp do
70313: LD_ADDR_VAR 0 3
70317: PUSH
70318: LD_VAR 0 5
70322: PUSH
70323: FOR_IN
70324: IFFALSE 70393
// begin for k in UnitsInside ( j ) do
70326: LD_ADDR_VAR 0 4
70330: PUSH
70331: LD_VAR 0 3
70335: PPUSH
70336: CALL_OW 313
70340: PUSH
70341: FOR_IN
70342: IFFALSE 70389
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70344: LD_VAR 0 4
70348: PPUSH
70349: CALL_OW 257
70353: PUSH
70354: LD_INT 1
70356: EQUAL
70357: PUSH
70358: LD_VAR 0 4
70362: PPUSH
70363: CALL_OW 459
70367: NOT
70368: AND
70369: IFFALSE 70387
// list := list ^ k ;
70371: LD_ADDR_VAR 0 6
70375: PUSH
70376: LD_VAR 0 6
70380: PUSH
70381: LD_VAR 0 4
70385: ADD
70386: ST_TO_ADDR
70387: GO 70341
70389: POP
70390: POP
// end ;
70391: GO 70323
70393: POP
70394: POP
// list := list diff mc_miners [ i ] ;
70395: LD_ADDR_VAR 0 6
70399: PUSH
70400: LD_VAR 0 6
70404: PUSH
70405: LD_EXP 73
70409: PUSH
70410: LD_VAR 0 2
70414: ARRAY
70415: DIFF
70416: ST_TO_ADDR
// if not list then
70417: LD_VAR 0 6
70421: NOT
70422: IFFALSE 70426
// continue ;
70424: GO 69791
// k := mc_mines [ i ] - mc_miners [ i ] ;
70426: LD_ADDR_VAR 0 4
70430: PUSH
70431: LD_EXP 72
70435: PUSH
70436: LD_VAR 0 2
70440: ARRAY
70441: PUSH
70442: LD_EXP 73
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: MINUS
70453: ST_TO_ADDR
// if k > list then
70454: LD_VAR 0 4
70458: PUSH
70459: LD_VAR 0 6
70463: GREATER
70464: IFFALSE 70476
// k := list ;
70466: LD_ADDR_VAR 0 4
70470: PUSH
70471: LD_VAR 0 6
70475: ST_TO_ADDR
// for j = 1 to k do
70476: LD_ADDR_VAR 0 3
70480: PUSH
70481: DOUBLE
70482: LD_INT 1
70484: DEC
70485: ST_TO_ADDR
70486: LD_VAR 0 4
70490: PUSH
70491: FOR_TO
70492: IFFALSE 70546
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70494: LD_ADDR_EXP 73
70498: PUSH
70499: LD_EXP 73
70503: PPUSH
70504: LD_VAR 0 2
70508: PUSH
70509: LD_EXP 73
70513: PUSH
70514: LD_VAR 0 2
70518: ARRAY
70519: PUSH
70520: LD_INT 1
70522: PLUS
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PPUSH
70528: LD_VAR 0 6
70532: PUSH
70533: LD_VAR 0 3
70537: ARRAY
70538: PPUSH
70539: CALL 21529 0 3
70543: ST_TO_ADDR
70544: GO 70491
70546: POP
70547: POP
// end ;
70548: GO 69791
70550: POP
70551: POP
// end ;
70552: LD_VAR 0 1
70556: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70557: LD_INT 0
70559: PPUSH
70560: PPUSH
70561: PPUSH
70562: PPUSH
70563: PPUSH
70564: PPUSH
70565: PPUSH
70566: PPUSH
70567: PPUSH
70568: PPUSH
// if not mc_bases then
70569: LD_EXP 59
70573: NOT
70574: IFFALSE 70578
// exit ;
70576: GO 72328
// for i = 1 to mc_bases do
70578: LD_ADDR_VAR 0 2
70582: PUSH
70583: DOUBLE
70584: LD_INT 1
70586: DEC
70587: ST_TO_ADDR
70588: LD_EXP 59
70592: PUSH
70593: FOR_TO
70594: IFFALSE 72326
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70596: LD_EXP 59
70600: PUSH
70601: LD_VAR 0 2
70605: ARRAY
70606: NOT
70607: PUSH
70608: LD_EXP 66
70612: PUSH
70613: LD_VAR 0 2
70617: ARRAY
70618: OR
70619: IFFALSE 70623
// continue ;
70621: GO 70593
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70623: LD_EXP 75
70627: PUSH
70628: LD_VAR 0 2
70632: ARRAY
70633: NOT
70634: PUSH
70635: LD_EXP 76
70639: PUSH
70640: LD_VAR 0 2
70644: ARRAY
70645: AND
70646: IFFALSE 70684
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70648: LD_ADDR_EXP 76
70652: PUSH
70653: LD_EXP 76
70657: PPUSH
70658: LD_VAR 0 2
70662: PPUSH
70663: EMPTY
70664: PPUSH
70665: CALL_OW 1
70669: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70670: LD_VAR 0 2
70674: PPUSH
70675: LD_INT 107
70677: PPUSH
70678: CALL 61542 0 2
// continue ;
70682: GO 70593
// end ; target := [ ] ;
70684: LD_ADDR_VAR 0 6
70688: PUSH
70689: EMPTY
70690: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: DOUBLE
70697: LD_EXP 75
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: INC
70708: ST_TO_ADDR
70709: LD_INT 1
70711: PUSH
70712: FOR_DOWNTO
70713: IFFALSE 70973
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70715: LD_EXP 75
70719: PUSH
70720: LD_VAR 0 2
70724: ARRAY
70725: PUSH
70726: LD_VAR 0 3
70730: ARRAY
70731: PUSH
70732: LD_INT 2
70734: ARRAY
70735: PPUSH
70736: LD_EXP 75
70740: PUSH
70741: LD_VAR 0 2
70745: ARRAY
70746: PUSH
70747: LD_VAR 0 3
70751: ARRAY
70752: PUSH
70753: LD_INT 3
70755: ARRAY
70756: PPUSH
70757: CALL_OW 488
70761: PUSH
70762: LD_EXP 75
70766: PUSH
70767: LD_VAR 0 2
70771: ARRAY
70772: PUSH
70773: LD_VAR 0 3
70777: ARRAY
70778: PUSH
70779: LD_INT 2
70781: ARRAY
70782: PPUSH
70783: LD_EXP 75
70787: PUSH
70788: LD_VAR 0 2
70792: ARRAY
70793: PUSH
70794: LD_VAR 0 3
70798: ARRAY
70799: PUSH
70800: LD_INT 3
70802: ARRAY
70803: PPUSH
70804: CALL_OW 284
70808: PUSH
70809: LD_INT 0
70811: EQUAL
70812: AND
70813: IFFALSE 70868
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70815: LD_ADDR_VAR 0 5
70819: PUSH
70820: LD_EXP 75
70824: PUSH
70825: LD_VAR 0 2
70829: ARRAY
70830: PPUSH
70831: LD_VAR 0 3
70835: PPUSH
70836: CALL_OW 3
70840: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70841: LD_ADDR_EXP 75
70845: PUSH
70846: LD_EXP 75
70850: PPUSH
70851: LD_VAR 0 2
70855: PPUSH
70856: LD_VAR 0 5
70860: PPUSH
70861: CALL_OW 1
70865: ST_TO_ADDR
// continue ;
70866: GO 70712
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70868: LD_EXP 59
70872: PUSH
70873: LD_VAR 0 2
70877: ARRAY
70878: PUSH
70879: LD_INT 1
70881: ARRAY
70882: PPUSH
70883: CALL_OW 255
70887: PPUSH
70888: LD_EXP 75
70892: PUSH
70893: LD_VAR 0 2
70897: ARRAY
70898: PUSH
70899: LD_VAR 0 3
70903: ARRAY
70904: PUSH
70905: LD_INT 2
70907: ARRAY
70908: PPUSH
70909: LD_EXP 75
70913: PUSH
70914: LD_VAR 0 2
70918: ARRAY
70919: PUSH
70920: LD_VAR 0 3
70924: ARRAY
70925: PUSH
70926: LD_INT 3
70928: ARRAY
70929: PPUSH
70930: LD_INT 30
70932: PPUSH
70933: CALL 22425 0 4
70937: PUSH
70938: LD_INT 4
70940: ARRAY
70941: PUSH
70942: LD_INT 0
70944: EQUAL
70945: IFFALSE 70971
// begin target := mc_crates [ i ] [ j ] ;
70947: LD_ADDR_VAR 0 6
70951: PUSH
70952: LD_EXP 75
70956: PUSH
70957: LD_VAR 0 2
70961: ARRAY
70962: PUSH
70963: LD_VAR 0 3
70967: ARRAY
70968: ST_TO_ADDR
// break ;
70969: GO 70973
// end ; end ;
70971: GO 70712
70973: POP
70974: POP
// if not target then
70975: LD_VAR 0 6
70979: NOT
70980: IFFALSE 70984
// continue ;
70982: GO 70593
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70984: LD_ADDR_VAR 0 7
70988: PUSH
70989: LD_EXP 78
70993: PUSH
70994: LD_VAR 0 2
70998: ARRAY
70999: PPUSH
71000: LD_INT 2
71002: PUSH
71003: LD_INT 3
71005: PUSH
71006: LD_INT 58
71008: PUSH
71009: EMPTY
71010: LIST
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 61
71018: PUSH
71019: EMPTY
71020: LIST
71021: PUSH
71022: LD_INT 33
71024: PUSH
71025: LD_INT 5
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 33
71034: PUSH
71035: LD_INT 3
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 2
71051: PUSH
71052: LD_INT 34
71054: PUSH
71055: LD_INT 32
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 34
71064: PUSH
71065: LD_INT 51
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 34
71074: PUSH
71075: LD_INT 12
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PPUSH
71092: CALL_OW 72
71096: ST_TO_ADDR
// if not cargo then
71097: LD_VAR 0 7
71101: NOT
71102: IFFALSE 71745
// begin if mc_crates_collector [ i ] < 5 then
71104: LD_EXP 76
71108: PUSH
71109: LD_VAR 0 2
71113: ARRAY
71114: PUSH
71115: LD_INT 5
71117: LESS
71118: IFFALSE 71484
// begin if mc_ape [ i ] then
71120: LD_EXP 88
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: IFFALSE 71177
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71132: LD_ADDR_VAR 0 5
71136: PUSH
71137: LD_EXP 88
71141: PUSH
71142: LD_VAR 0 2
71146: ARRAY
71147: PPUSH
71148: LD_INT 25
71150: PUSH
71151: LD_INT 16
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 24
71160: PUSH
71161: LD_INT 750
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PPUSH
71172: CALL_OW 72
71176: ST_TO_ADDR
// if not tmp then
71177: LD_VAR 0 5
71181: NOT
71182: IFFALSE 71229
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71184: LD_ADDR_VAR 0 5
71188: PUSH
71189: LD_EXP 59
71193: PUSH
71194: LD_VAR 0 2
71198: ARRAY
71199: PPUSH
71200: LD_INT 25
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 24
71212: PUSH
71213: LD_INT 750
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PPUSH
71224: CALL_OW 72
71228: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71229: LD_EXP 88
71233: PUSH
71234: LD_VAR 0 2
71238: ARRAY
71239: PUSH
71240: LD_EXP 59
71244: PUSH
71245: LD_VAR 0 2
71249: ARRAY
71250: PPUSH
71251: LD_INT 25
71253: PUSH
71254: LD_INT 2
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 24
71263: PUSH
71264: LD_INT 750
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PPUSH
71275: CALL_OW 72
71279: AND
71280: PUSH
71281: LD_VAR 0 5
71285: PUSH
71286: LD_INT 5
71288: LESS
71289: AND
71290: IFFALSE 71372
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71292: LD_ADDR_VAR 0 3
71296: PUSH
71297: LD_EXP 59
71301: PUSH
71302: LD_VAR 0 2
71306: ARRAY
71307: PPUSH
71308: LD_INT 25
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 24
71320: PUSH
71321: LD_INT 750
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PPUSH
71332: CALL_OW 72
71336: PUSH
71337: FOR_IN
71338: IFFALSE 71370
// begin tmp := tmp union j ;
71340: LD_ADDR_VAR 0 5
71344: PUSH
71345: LD_VAR 0 5
71349: PUSH
71350: LD_VAR 0 3
71354: UNION
71355: ST_TO_ADDR
// if tmp >= 5 then
71356: LD_VAR 0 5
71360: PUSH
71361: LD_INT 5
71363: GREATEREQUAL
71364: IFFALSE 71368
// break ;
71366: GO 71370
// end ;
71368: GO 71337
71370: POP
71371: POP
// end ; if not tmp then
71372: LD_VAR 0 5
71376: NOT
71377: IFFALSE 71381
// continue ;
71379: GO 70593
// for j in tmp do
71381: LD_ADDR_VAR 0 3
71385: PUSH
71386: LD_VAR 0 5
71390: PUSH
71391: FOR_IN
71392: IFFALSE 71482
// if not GetTag ( j ) then
71394: LD_VAR 0 3
71398: PPUSH
71399: CALL_OW 110
71403: NOT
71404: IFFALSE 71480
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71406: LD_ADDR_EXP 76
71410: PUSH
71411: LD_EXP 76
71415: PPUSH
71416: LD_VAR 0 2
71420: PUSH
71421: LD_EXP 76
71425: PUSH
71426: LD_VAR 0 2
71430: ARRAY
71431: PUSH
71432: LD_INT 1
71434: PLUS
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PPUSH
71440: LD_VAR 0 3
71444: PPUSH
71445: CALL 21529 0 3
71449: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71450: LD_VAR 0 3
71454: PPUSH
71455: LD_INT 107
71457: PPUSH
71458: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71462: LD_EXP 76
71466: PUSH
71467: LD_VAR 0 2
71471: ARRAY
71472: PUSH
71473: LD_INT 5
71475: GREATEREQUAL
71476: IFFALSE 71480
// break ;
71478: GO 71482
// end ;
71480: GO 71391
71482: POP
71483: POP
// end ; if mc_crates_collector [ i ] and target then
71484: LD_EXP 76
71488: PUSH
71489: LD_VAR 0 2
71493: ARRAY
71494: PUSH
71495: LD_VAR 0 6
71499: AND
71500: IFFALSE 71743
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71502: LD_EXP 76
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: PUSH
71513: LD_VAR 0 6
71517: PUSH
71518: LD_INT 1
71520: ARRAY
71521: LESS
71522: IFFALSE 71542
// tmp := mc_crates_collector [ i ] else
71524: LD_ADDR_VAR 0 5
71528: PUSH
71529: LD_EXP 76
71533: PUSH
71534: LD_VAR 0 2
71538: ARRAY
71539: ST_TO_ADDR
71540: GO 71556
// tmp := target [ 1 ] ;
71542: LD_ADDR_VAR 0 5
71546: PUSH
71547: LD_VAR 0 6
71551: PUSH
71552: LD_INT 1
71554: ARRAY
71555: ST_TO_ADDR
// k := 0 ;
71556: LD_ADDR_VAR 0 4
71560: PUSH
71561: LD_INT 0
71563: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71564: LD_ADDR_VAR 0 3
71568: PUSH
71569: LD_EXP 76
71573: PUSH
71574: LD_VAR 0 2
71578: ARRAY
71579: PUSH
71580: FOR_IN
71581: IFFALSE 71741
// begin k := k + 1 ;
71583: LD_ADDR_VAR 0 4
71587: PUSH
71588: LD_VAR 0 4
71592: PUSH
71593: LD_INT 1
71595: PLUS
71596: ST_TO_ADDR
// if k > tmp then
71597: LD_VAR 0 4
71601: PUSH
71602: LD_VAR 0 5
71606: GREATER
71607: IFFALSE 71611
// break ;
71609: GO 71741
// if not GetClass ( j ) in [ 2 , 16 ] then
71611: LD_VAR 0 3
71615: PPUSH
71616: CALL_OW 257
71620: PUSH
71621: LD_INT 2
71623: PUSH
71624: LD_INT 16
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: IN
71631: NOT
71632: IFFALSE 71685
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71634: LD_ADDR_EXP 76
71638: PUSH
71639: LD_EXP 76
71643: PPUSH
71644: LD_VAR 0 2
71648: PPUSH
71649: LD_EXP 76
71653: PUSH
71654: LD_VAR 0 2
71658: ARRAY
71659: PUSH
71660: LD_VAR 0 3
71664: DIFF
71665: PPUSH
71666: CALL_OW 1
71670: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71671: LD_VAR 0 3
71675: PPUSH
71676: LD_INT 0
71678: PPUSH
71679: CALL_OW 109
// continue ;
71683: GO 71580
// end ; if IsInUnit ( j ) then
71685: LD_VAR 0 3
71689: PPUSH
71690: CALL_OW 310
71694: IFFALSE 71705
// ComExitBuilding ( j ) ;
71696: LD_VAR 0 3
71700: PPUSH
71701: CALL_OW 122
// wait ( 3 ) ;
71705: LD_INT 3
71707: PPUSH
71708: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71712: LD_VAR 0 3
71716: PPUSH
71717: LD_VAR 0 6
71721: PUSH
71722: LD_INT 2
71724: ARRAY
71725: PPUSH
71726: LD_VAR 0 6
71730: PUSH
71731: LD_INT 3
71733: ARRAY
71734: PPUSH
71735: CALL_OW 117
// end ;
71739: GO 71580
71741: POP
71742: POP
// end ; end else
71743: GO 72324
// begin for j in cargo do
71745: LD_ADDR_VAR 0 3
71749: PUSH
71750: LD_VAR 0 7
71754: PUSH
71755: FOR_IN
71756: IFFALSE 72322
// begin if GetTag ( j ) <> 0 then
71758: LD_VAR 0 3
71762: PPUSH
71763: CALL_OW 110
71767: PUSH
71768: LD_INT 0
71770: NONEQUAL
71771: IFFALSE 71775
// continue ;
71773: GO 71755
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71775: LD_VAR 0 3
71779: PPUSH
71780: CALL_OW 256
71784: PUSH
71785: LD_INT 1000
71787: LESS
71788: PUSH
71789: LD_VAR 0 3
71793: PPUSH
71794: LD_EXP 83
71798: PUSH
71799: LD_VAR 0 2
71803: ARRAY
71804: PPUSH
71805: CALL_OW 308
71809: NOT
71810: AND
71811: IFFALSE 71833
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71813: LD_VAR 0 3
71817: PPUSH
71818: LD_EXP 83
71822: PUSH
71823: LD_VAR 0 2
71827: ARRAY
71828: PPUSH
71829: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71833: LD_VAR 0 3
71837: PPUSH
71838: CALL_OW 256
71842: PUSH
71843: LD_INT 1000
71845: LESS
71846: PUSH
71847: LD_VAR 0 3
71851: PPUSH
71852: LD_EXP 83
71856: PUSH
71857: LD_VAR 0 2
71861: ARRAY
71862: PPUSH
71863: CALL_OW 308
71867: AND
71868: IFFALSE 71872
// continue ;
71870: GO 71755
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71872: LD_VAR 0 3
71876: PPUSH
71877: CALL_OW 262
71881: PUSH
71882: LD_INT 2
71884: EQUAL
71885: PUSH
71886: LD_VAR 0 3
71890: PPUSH
71891: CALL_OW 261
71895: PUSH
71896: LD_INT 15
71898: LESS
71899: AND
71900: IFFALSE 71904
// continue ;
71902: GO 71755
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71904: LD_VAR 0 3
71908: PPUSH
71909: CALL_OW 262
71913: PUSH
71914: LD_INT 1
71916: EQUAL
71917: PUSH
71918: LD_VAR 0 3
71922: PPUSH
71923: CALL_OW 261
71927: PUSH
71928: LD_INT 10
71930: LESS
71931: AND
71932: IFFALSE 72261
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71934: LD_ADDR_VAR 0 8
71938: PUSH
71939: LD_EXP 59
71943: PUSH
71944: LD_VAR 0 2
71948: ARRAY
71949: PPUSH
71950: LD_INT 2
71952: PUSH
71953: LD_INT 30
71955: PUSH
71956: LD_INT 0
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 30
71965: PUSH
71966: LD_INT 1
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: LIST
71977: PPUSH
71978: CALL_OW 72
71982: ST_TO_ADDR
// if not depot then
71983: LD_VAR 0 8
71987: NOT
71988: IFFALSE 71992
// continue ;
71990: GO 71755
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71992: LD_VAR 0 3
71996: PPUSH
71997: LD_VAR 0 8
72001: PPUSH
72002: LD_VAR 0 3
72006: PPUSH
72007: CALL_OW 74
72011: PPUSH
72012: CALL_OW 296
72016: PUSH
72017: LD_INT 6
72019: LESS
72020: IFFALSE 72036
// SetFuel ( j , 100 ) else
72022: LD_VAR 0 3
72026: PPUSH
72027: LD_INT 100
72029: PPUSH
72030: CALL_OW 240
72034: GO 72261
// if GetFuel ( j ) = 0 then
72036: LD_VAR 0 3
72040: PPUSH
72041: CALL_OW 261
72045: PUSH
72046: LD_INT 0
72048: EQUAL
72049: IFFALSE 72261
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72051: LD_ADDR_EXP 78
72055: PUSH
72056: LD_EXP 78
72060: PPUSH
72061: LD_VAR 0 2
72065: PPUSH
72066: LD_EXP 78
72070: PUSH
72071: LD_VAR 0 2
72075: ARRAY
72076: PUSH
72077: LD_VAR 0 3
72081: DIFF
72082: PPUSH
72083: CALL_OW 1
72087: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72088: LD_VAR 0 3
72092: PPUSH
72093: CALL_OW 263
72097: PUSH
72098: LD_INT 1
72100: EQUAL
72101: IFFALSE 72117
// ComExitVehicle ( IsInUnit ( j ) ) ;
72103: LD_VAR 0 3
72107: PPUSH
72108: CALL_OW 310
72112: PPUSH
72113: CALL_OW 121
// if GetControl ( j ) = control_remote then
72117: LD_VAR 0 3
72121: PPUSH
72122: CALL_OW 263
72126: PUSH
72127: LD_INT 2
72129: EQUAL
72130: IFFALSE 72141
// ComUnlink ( j ) ;
72132: LD_VAR 0 3
72136: PPUSH
72137: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72141: LD_ADDR_VAR 0 9
72145: PUSH
72146: LD_VAR 0 2
72150: PPUSH
72151: LD_INT 3
72153: PPUSH
72154: CALL 81614 0 2
72158: ST_TO_ADDR
// if fac then
72159: LD_VAR 0 9
72163: IFFALSE 72259
// begin for k in fac do
72165: LD_ADDR_VAR 0 4
72169: PUSH
72170: LD_VAR 0 9
72174: PUSH
72175: FOR_IN
72176: IFFALSE 72257
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72178: LD_ADDR_VAR 0 10
72182: PUSH
72183: LD_VAR 0 9
72187: PPUSH
72188: LD_VAR 0 3
72192: PPUSH
72193: CALL_OW 265
72197: PPUSH
72198: LD_VAR 0 3
72202: PPUSH
72203: CALL_OW 262
72207: PPUSH
72208: LD_VAR 0 3
72212: PPUSH
72213: CALL_OW 263
72217: PPUSH
72218: LD_VAR 0 3
72222: PPUSH
72223: CALL_OW 264
72227: PPUSH
72228: CALL 19061 0 5
72232: ST_TO_ADDR
// if components then
72233: LD_VAR 0 10
72237: IFFALSE 72255
// begin MC_InsertProduceList ( i , components ) ;
72239: LD_VAR 0 2
72243: PPUSH
72244: LD_VAR 0 10
72248: PPUSH
72249: CALL 81159 0 2
// break ;
72253: GO 72257
// end ; end ;
72255: GO 72175
72257: POP
72258: POP
// end ; continue ;
72259: GO 71755
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72261: LD_VAR 0 3
72265: PPUSH
72266: LD_INT 1
72268: PPUSH
72269: CALL_OW 289
72273: PUSH
72274: LD_INT 100
72276: LESS
72277: PUSH
72278: LD_VAR 0 3
72282: PPUSH
72283: CALL_OW 314
72287: NOT
72288: AND
72289: IFFALSE 72318
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72291: LD_VAR 0 3
72295: PPUSH
72296: LD_VAR 0 6
72300: PUSH
72301: LD_INT 2
72303: ARRAY
72304: PPUSH
72305: LD_VAR 0 6
72309: PUSH
72310: LD_INT 3
72312: ARRAY
72313: PPUSH
72314: CALL_OW 117
// break ;
72318: GO 72322
// end ;
72320: GO 71755
72322: POP
72323: POP
// end ; end ;
72324: GO 70593
72326: POP
72327: POP
// end ;
72328: LD_VAR 0 1
72332: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72333: LD_INT 0
72335: PPUSH
72336: PPUSH
72337: PPUSH
72338: PPUSH
// if not mc_bases then
72339: LD_EXP 59
72343: NOT
72344: IFFALSE 72348
// exit ;
72346: GO 72509
// for i = 1 to mc_bases do
72348: LD_ADDR_VAR 0 2
72352: PUSH
72353: DOUBLE
72354: LD_INT 1
72356: DEC
72357: ST_TO_ADDR
72358: LD_EXP 59
72362: PUSH
72363: FOR_TO
72364: IFFALSE 72507
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72366: LD_ADDR_VAR 0 4
72370: PUSH
72371: LD_EXP 78
72375: PUSH
72376: LD_VAR 0 2
72380: ARRAY
72381: PUSH
72382: LD_EXP 81
72386: PUSH
72387: LD_VAR 0 2
72391: ARRAY
72392: UNION
72393: PPUSH
72394: LD_INT 33
72396: PUSH
72397: LD_INT 2
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PPUSH
72404: CALL_OW 72
72408: ST_TO_ADDR
// if tmp then
72409: LD_VAR 0 4
72413: IFFALSE 72505
// for j in tmp do
72415: LD_ADDR_VAR 0 3
72419: PUSH
72420: LD_VAR 0 4
72424: PUSH
72425: FOR_IN
72426: IFFALSE 72503
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72428: LD_VAR 0 3
72432: PPUSH
72433: CALL_OW 312
72437: NOT
72438: PUSH
72439: LD_VAR 0 3
72443: PPUSH
72444: CALL_OW 256
72448: PUSH
72449: LD_INT 250
72451: GREATEREQUAL
72452: AND
72453: IFFALSE 72466
// Connect ( j ) else
72455: LD_VAR 0 3
72459: PPUSH
72460: CALL 24462 0 1
72464: GO 72501
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72466: LD_VAR 0 3
72470: PPUSH
72471: CALL_OW 256
72475: PUSH
72476: LD_INT 250
72478: LESS
72479: PUSH
72480: LD_VAR 0 3
72484: PPUSH
72485: CALL_OW 312
72489: AND
72490: IFFALSE 72501
// ComUnlink ( j ) ;
72492: LD_VAR 0 3
72496: PPUSH
72497: CALL_OW 136
72501: GO 72425
72503: POP
72504: POP
// end ;
72505: GO 72363
72507: POP
72508: POP
// end ;
72509: LD_VAR 0 1
72513: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72514: LD_INT 0
72516: PPUSH
72517: PPUSH
72518: PPUSH
72519: PPUSH
72520: PPUSH
// if not mc_bases then
72521: LD_EXP 59
72525: NOT
72526: IFFALSE 72530
// exit ;
72528: GO 72975
// for i = 1 to mc_bases do
72530: LD_ADDR_VAR 0 2
72534: PUSH
72535: DOUBLE
72536: LD_INT 1
72538: DEC
72539: ST_TO_ADDR
72540: LD_EXP 59
72544: PUSH
72545: FOR_TO
72546: IFFALSE 72973
// begin if not mc_produce [ i ] then
72548: LD_EXP 80
72552: PUSH
72553: LD_VAR 0 2
72557: ARRAY
72558: NOT
72559: IFFALSE 72563
// continue ;
72561: GO 72545
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72563: LD_ADDR_VAR 0 5
72567: PUSH
72568: LD_EXP 59
72572: PUSH
72573: LD_VAR 0 2
72577: ARRAY
72578: PPUSH
72579: LD_INT 30
72581: PUSH
72582: LD_INT 3
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PPUSH
72589: CALL_OW 72
72593: ST_TO_ADDR
// if not fac then
72594: LD_VAR 0 5
72598: NOT
72599: IFFALSE 72603
// continue ;
72601: GO 72545
// for j in fac do
72603: LD_ADDR_VAR 0 3
72607: PUSH
72608: LD_VAR 0 5
72612: PUSH
72613: FOR_IN
72614: IFFALSE 72969
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72616: LD_VAR 0 3
72620: PPUSH
72621: CALL_OW 461
72625: PUSH
72626: LD_INT 2
72628: NONEQUAL
72629: PUSH
72630: LD_VAR 0 3
72634: PPUSH
72635: LD_INT 15
72637: PPUSH
72638: CALL 24122 0 2
72642: PUSH
72643: LD_INT 4
72645: ARRAY
72646: OR
72647: IFFALSE 72651
// continue ;
72649: GO 72613
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72651: LD_VAR 0 3
72655: PPUSH
72656: LD_EXP 80
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: PUSH
72667: LD_INT 1
72669: ARRAY
72670: PUSH
72671: LD_INT 1
72673: ARRAY
72674: PPUSH
72675: LD_EXP 80
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: PUSH
72686: LD_INT 1
72688: ARRAY
72689: PUSH
72690: LD_INT 2
72692: ARRAY
72693: PPUSH
72694: LD_EXP 80
72698: PUSH
72699: LD_VAR 0 2
72703: ARRAY
72704: PUSH
72705: LD_INT 1
72707: ARRAY
72708: PUSH
72709: LD_INT 3
72711: ARRAY
72712: PPUSH
72713: LD_EXP 80
72717: PUSH
72718: LD_VAR 0 2
72722: ARRAY
72723: PUSH
72724: LD_INT 1
72726: ARRAY
72727: PUSH
72728: LD_INT 4
72730: ARRAY
72731: PPUSH
72732: CALL_OW 448
72736: PUSH
72737: LD_VAR 0 3
72741: PPUSH
72742: LD_EXP 80
72746: PUSH
72747: LD_VAR 0 2
72751: ARRAY
72752: PUSH
72753: LD_INT 1
72755: ARRAY
72756: PUSH
72757: LD_INT 1
72759: ARRAY
72760: PUSH
72761: LD_EXP 80
72765: PUSH
72766: LD_VAR 0 2
72770: ARRAY
72771: PUSH
72772: LD_INT 1
72774: ARRAY
72775: PUSH
72776: LD_INT 2
72778: ARRAY
72779: PUSH
72780: LD_EXP 80
72784: PUSH
72785: LD_VAR 0 2
72789: ARRAY
72790: PUSH
72791: LD_INT 1
72793: ARRAY
72794: PUSH
72795: LD_INT 3
72797: ARRAY
72798: PUSH
72799: LD_EXP 80
72803: PUSH
72804: LD_VAR 0 2
72808: ARRAY
72809: PUSH
72810: LD_INT 1
72812: ARRAY
72813: PUSH
72814: LD_INT 4
72816: ARRAY
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: PPUSH
72824: CALL 27793 0 2
72828: AND
72829: IFFALSE 72967
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72831: LD_VAR 0 3
72835: PPUSH
72836: LD_EXP 80
72840: PUSH
72841: LD_VAR 0 2
72845: ARRAY
72846: PUSH
72847: LD_INT 1
72849: ARRAY
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: PPUSH
72855: LD_EXP 80
72859: PUSH
72860: LD_VAR 0 2
72864: ARRAY
72865: PUSH
72866: LD_INT 1
72868: ARRAY
72869: PUSH
72870: LD_INT 2
72872: ARRAY
72873: PPUSH
72874: LD_EXP 80
72878: PUSH
72879: LD_VAR 0 2
72883: ARRAY
72884: PUSH
72885: LD_INT 1
72887: ARRAY
72888: PUSH
72889: LD_INT 3
72891: ARRAY
72892: PPUSH
72893: LD_EXP 80
72897: PUSH
72898: LD_VAR 0 2
72902: ARRAY
72903: PUSH
72904: LD_INT 1
72906: ARRAY
72907: PUSH
72908: LD_INT 4
72910: ARRAY
72911: PPUSH
72912: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72916: LD_ADDR_VAR 0 4
72920: PUSH
72921: LD_EXP 80
72925: PUSH
72926: LD_VAR 0 2
72930: ARRAY
72931: PPUSH
72932: LD_INT 1
72934: PPUSH
72935: CALL_OW 3
72939: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72940: LD_ADDR_EXP 80
72944: PUSH
72945: LD_EXP 80
72949: PPUSH
72950: LD_VAR 0 2
72954: PPUSH
72955: LD_VAR 0 4
72959: PPUSH
72960: CALL_OW 1
72964: ST_TO_ADDR
// break ;
72965: GO 72969
// end ; end ;
72967: GO 72613
72969: POP
72970: POP
// end ;
72971: GO 72545
72973: POP
72974: POP
// end ;
72975: LD_VAR 0 1
72979: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72980: LD_INT 0
72982: PPUSH
72983: PPUSH
72984: PPUSH
// if not mc_bases then
72985: LD_EXP 59
72989: NOT
72990: IFFALSE 72994
// exit ;
72992: GO 73083
// for i = 1 to mc_bases do
72994: LD_ADDR_VAR 0 2
72998: PUSH
72999: DOUBLE
73000: LD_INT 1
73002: DEC
73003: ST_TO_ADDR
73004: LD_EXP 59
73008: PUSH
73009: FOR_TO
73010: IFFALSE 73081
// begin if mc_attack [ i ] then
73012: LD_EXP 79
73016: PUSH
73017: LD_VAR 0 2
73021: ARRAY
73022: IFFALSE 73079
// begin tmp := mc_attack [ i ] [ 1 ] ;
73024: LD_ADDR_VAR 0 3
73028: PUSH
73029: LD_EXP 79
73033: PUSH
73034: LD_VAR 0 2
73038: ARRAY
73039: PUSH
73040: LD_INT 1
73042: ARRAY
73043: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73044: LD_ADDR_EXP 79
73048: PUSH
73049: LD_EXP 79
73053: PPUSH
73054: LD_VAR 0 2
73058: PPUSH
73059: EMPTY
73060: PPUSH
73061: CALL_OW 1
73065: ST_TO_ADDR
// Attack ( tmp ) ;
73066: LD_VAR 0 3
73070: PPUSH
73071: CALL 49983 0 1
// exit ;
73075: POP
73076: POP
73077: GO 73083
// end ; end ;
73079: GO 73009
73081: POP
73082: POP
// end ;
73083: LD_VAR 0 1
73087: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73088: LD_INT 0
73090: PPUSH
73091: PPUSH
73092: PPUSH
73093: PPUSH
73094: PPUSH
73095: PPUSH
73096: PPUSH
// if not mc_bases then
73097: LD_EXP 59
73101: NOT
73102: IFFALSE 73106
// exit ;
73104: GO 73688
// for i = 1 to mc_bases do
73106: LD_ADDR_VAR 0 2
73110: PUSH
73111: DOUBLE
73112: LD_INT 1
73114: DEC
73115: ST_TO_ADDR
73116: LD_EXP 59
73120: PUSH
73121: FOR_TO
73122: IFFALSE 73686
// begin if not mc_bases [ i ] then
73124: LD_EXP 59
73128: PUSH
73129: LD_VAR 0 2
73133: ARRAY
73134: NOT
73135: IFFALSE 73139
// continue ;
73137: GO 73121
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73139: LD_ADDR_VAR 0 7
73143: PUSH
73144: LD_EXP 59
73148: PUSH
73149: LD_VAR 0 2
73153: ARRAY
73154: PUSH
73155: LD_INT 1
73157: ARRAY
73158: PPUSH
73159: CALL 18365 0 1
73163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73164: LD_ADDR_EXP 82
73168: PUSH
73169: LD_EXP 82
73173: PPUSH
73174: LD_VAR 0 2
73178: PPUSH
73179: LD_EXP 59
73183: PUSH
73184: LD_VAR 0 2
73188: ARRAY
73189: PUSH
73190: LD_INT 1
73192: ARRAY
73193: PPUSH
73194: CALL_OW 255
73198: PPUSH
73199: LD_EXP 84
73203: PUSH
73204: LD_VAR 0 2
73208: ARRAY
73209: PPUSH
73210: CALL 15919 0 2
73214: PPUSH
73215: CALL_OW 1
73219: ST_TO_ADDR
// if not mc_scan [ i ] then
73220: LD_EXP 82
73224: PUSH
73225: LD_VAR 0 2
73229: ARRAY
73230: NOT
73231: IFFALSE 73386
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73233: LD_ADDR_VAR 0 4
73237: PUSH
73238: LD_EXP 59
73242: PUSH
73243: LD_VAR 0 2
73247: ARRAY
73248: PPUSH
73249: LD_INT 2
73251: PUSH
73252: LD_INT 25
73254: PUSH
73255: LD_INT 5
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 25
73264: PUSH
73265: LD_INT 8
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 25
73274: PUSH
73275: LD_INT 9
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: PPUSH
73288: CALL_OW 72
73292: ST_TO_ADDR
// if not tmp then
73293: LD_VAR 0 4
73297: NOT
73298: IFFALSE 73302
// continue ;
73300: GO 73121
// for j in tmp do
73302: LD_ADDR_VAR 0 3
73306: PUSH
73307: LD_VAR 0 4
73311: PUSH
73312: FOR_IN
73313: IFFALSE 73384
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73315: LD_VAR 0 3
73319: PPUSH
73320: CALL_OW 310
73324: PPUSH
73325: CALL_OW 266
73329: PUSH
73330: LD_INT 5
73332: EQUAL
73333: PUSH
73334: LD_VAR 0 3
73338: PPUSH
73339: CALL_OW 257
73343: PUSH
73344: LD_INT 1
73346: EQUAL
73347: AND
73348: PUSH
73349: LD_VAR 0 3
73353: PPUSH
73354: CALL_OW 459
73358: NOT
73359: AND
73360: PUSH
73361: LD_VAR 0 7
73365: AND
73366: IFFALSE 73382
// ComChangeProfession ( j , class ) ;
73368: LD_VAR 0 3
73372: PPUSH
73373: LD_VAR 0 7
73377: PPUSH
73378: CALL_OW 123
73382: GO 73312
73384: POP
73385: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73386: LD_EXP 82
73390: PUSH
73391: LD_VAR 0 2
73395: ARRAY
73396: PUSH
73397: LD_EXP 81
73401: PUSH
73402: LD_VAR 0 2
73406: ARRAY
73407: NOT
73408: AND
73409: PUSH
73410: LD_EXP 59
73414: PUSH
73415: LD_VAR 0 2
73419: ARRAY
73420: PPUSH
73421: LD_INT 30
73423: PUSH
73424: LD_INT 32
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PPUSH
73431: CALL_OW 72
73435: NOT
73436: AND
73437: PUSH
73438: LD_EXP 59
73442: PUSH
73443: LD_VAR 0 2
73447: ARRAY
73448: PPUSH
73449: LD_INT 2
73451: PUSH
73452: LD_INT 30
73454: PUSH
73455: LD_INT 4
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 30
73464: PUSH
73465: LD_INT 5
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: LIST
73476: PPUSH
73477: CALL_OW 72
73481: NOT
73482: AND
73483: IFFALSE 73615
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73485: LD_ADDR_VAR 0 4
73489: PUSH
73490: LD_EXP 59
73494: PUSH
73495: LD_VAR 0 2
73499: ARRAY
73500: PPUSH
73501: LD_INT 2
73503: PUSH
73504: LD_INT 25
73506: PUSH
73507: LD_INT 1
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 25
73516: PUSH
73517: LD_INT 5
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 25
73526: PUSH
73527: LD_INT 8
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 25
73536: PUSH
73537: LD_INT 9
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: PPUSH
73551: CALL_OW 72
73555: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73556: LD_ADDR_VAR 0 4
73560: PUSH
73561: LD_VAR 0 4
73565: PUSH
73566: LD_VAR 0 4
73570: PPUSH
73571: LD_INT 18
73573: PPUSH
73574: CALL 54799 0 2
73578: DIFF
73579: ST_TO_ADDR
// if tmp then
73580: LD_VAR 0 4
73584: IFFALSE 73615
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73586: LD_VAR 0 2
73590: PPUSH
73591: LD_VAR 0 4
73595: PPUSH
73596: LD_EXP 84
73600: PUSH
73601: LD_VAR 0 2
73605: ARRAY
73606: PPUSH
73607: CALL 15954 0 3
// exit ;
73611: POP
73612: POP
73613: GO 73688
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73615: LD_EXP 82
73619: PUSH
73620: LD_VAR 0 2
73624: ARRAY
73625: PUSH
73626: LD_EXP 81
73630: PUSH
73631: LD_VAR 0 2
73635: ARRAY
73636: AND
73637: IFFALSE 73684
// begin tmp := mc_defender [ i ] ;
73639: LD_ADDR_VAR 0 4
73643: PUSH
73644: LD_EXP 81
73648: PUSH
73649: LD_VAR 0 2
73653: ARRAY
73654: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73655: LD_VAR 0 2
73659: PPUSH
73660: LD_VAR 0 4
73664: PPUSH
73665: LD_EXP 82
73669: PUSH
73670: LD_VAR 0 2
73674: ARRAY
73675: PPUSH
73676: CALL 16515 0 3
// exit ;
73680: POP
73681: POP
73682: GO 73688
// end ; end ;
73684: GO 73121
73686: POP
73687: POP
// end ;
73688: LD_VAR 0 1
73692: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73693: LD_INT 0
73695: PPUSH
73696: PPUSH
73697: PPUSH
73698: PPUSH
73699: PPUSH
73700: PPUSH
73701: PPUSH
73702: PPUSH
73703: PPUSH
73704: PPUSH
73705: PPUSH
// if not mc_bases then
73706: LD_EXP 59
73710: NOT
73711: IFFALSE 73715
// exit ;
73713: GO 74802
// for i = 1 to mc_bases do
73715: LD_ADDR_VAR 0 2
73719: PUSH
73720: DOUBLE
73721: LD_INT 1
73723: DEC
73724: ST_TO_ADDR
73725: LD_EXP 59
73729: PUSH
73730: FOR_TO
73731: IFFALSE 74800
// begin tmp := mc_lab [ i ] ;
73733: LD_ADDR_VAR 0 6
73737: PUSH
73738: LD_EXP 92
73742: PUSH
73743: LD_VAR 0 2
73747: ARRAY
73748: ST_TO_ADDR
// if not tmp then
73749: LD_VAR 0 6
73753: NOT
73754: IFFALSE 73758
// continue ;
73756: GO 73730
// idle_lab := 0 ;
73758: LD_ADDR_VAR 0 11
73762: PUSH
73763: LD_INT 0
73765: ST_TO_ADDR
// for j in tmp do
73766: LD_ADDR_VAR 0 3
73770: PUSH
73771: LD_VAR 0 6
73775: PUSH
73776: FOR_IN
73777: IFFALSE 74796
// begin researching := false ;
73779: LD_ADDR_VAR 0 10
73783: PUSH
73784: LD_INT 0
73786: ST_TO_ADDR
// side := GetSide ( j ) ;
73787: LD_ADDR_VAR 0 4
73791: PUSH
73792: LD_VAR 0 3
73796: PPUSH
73797: CALL_OW 255
73801: ST_TO_ADDR
// if not mc_tech [ side ] then
73802: LD_EXP 86
73806: PUSH
73807: LD_VAR 0 4
73811: ARRAY
73812: NOT
73813: IFFALSE 73817
// continue ;
73815: GO 73776
// if BuildingStatus ( j ) = bs_idle then
73817: LD_VAR 0 3
73821: PPUSH
73822: CALL_OW 461
73826: PUSH
73827: LD_INT 2
73829: EQUAL
73830: IFFALSE 74018
// begin if idle_lab and UnitsInside ( j ) < 6 then
73832: LD_VAR 0 11
73836: PUSH
73837: LD_VAR 0 3
73841: PPUSH
73842: CALL_OW 313
73846: PUSH
73847: LD_INT 6
73849: LESS
73850: AND
73851: IFFALSE 73922
// begin tmp2 := UnitsInside ( idle_lab ) ;
73853: LD_ADDR_VAR 0 9
73857: PUSH
73858: LD_VAR 0 11
73862: PPUSH
73863: CALL_OW 313
73867: ST_TO_ADDR
// if tmp2 then
73868: LD_VAR 0 9
73872: IFFALSE 73914
// for x in tmp2 do
73874: LD_ADDR_VAR 0 7
73878: PUSH
73879: LD_VAR 0 9
73883: PUSH
73884: FOR_IN
73885: IFFALSE 73912
// begin ComExitBuilding ( x ) ;
73887: LD_VAR 0 7
73891: PPUSH
73892: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73896: LD_VAR 0 7
73900: PPUSH
73901: LD_VAR 0 3
73905: PPUSH
73906: CALL_OW 180
// end ;
73910: GO 73884
73912: POP
73913: POP
// idle_lab := 0 ;
73914: LD_ADDR_VAR 0 11
73918: PUSH
73919: LD_INT 0
73921: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73922: LD_ADDR_VAR 0 5
73926: PUSH
73927: LD_EXP 86
73931: PUSH
73932: LD_VAR 0 4
73936: ARRAY
73937: PUSH
73938: FOR_IN
73939: IFFALSE 73999
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73941: LD_VAR 0 3
73945: PPUSH
73946: LD_VAR 0 5
73950: PPUSH
73951: CALL_OW 430
73955: PUSH
73956: LD_VAR 0 4
73960: PPUSH
73961: LD_VAR 0 5
73965: PPUSH
73966: CALL 15024 0 2
73970: AND
73971: IFFALSE 73997
// begin researching := true ;
73973: LD_ADDR_VAR 0 10
73977: PUSH
73978: LD_INT 1
73980: ST_TO_ADDR
// ComResearch ( j , t ) ;
73981: LD_VAR 0 3
73985: PPUSH
73986: LD_VAR 0 5
73990: PPUSH
73991: CALL_OW 124
// break ;
73995: GO 73999
// end ;
73997: GO 73938
73999: POP
74000: POP
// if not researching then
74001: LD_VAR 0 10
74005: NOT
74006: IFFALSE 74018
// idle_lab := j ;
74008: LD_ADDR_VAR 0 11
74012: PUSH
74013: LD_VAR 0 3
74017: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74018: LD_VAR 0 3
74022: PPUSH
74023: CALL_OW 461
74027: PUSH
74028: LD_INT 10
74030: EQUAL
74031: IFFALSE 74619
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74033: LD_EXP 88
74037: PUSH
74038: LD_VAR 0 2
74042: ARRAY
74043: NOT
74044: PUSH
74045: LD_EXP 89
74049: PUSH
74050: LD_VAR 0 2
74054: ARRAY
74055: NOT
74056: AND
74057: PUSH
74058: LD_EXP 86
74062: PUSH
74063: LD_VAR 0 4
74067: ARRAY
74068: PUSH
74069: LD_INT 1
74071: GREATER
74072: AND
74073: IFFALSE 74204
// begin ComCancel ( j ) ;
74075: LD_VAR 0 3
74079: PPUSH
74080: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74084: LD_ADDR_EXP 86
74088: PUSH
74089: LD_EXP 86
74093: PPUSH
74094: LD_VAR 0 4
74098: PPUSH
74099: LD_EXP 86
74103: PUSH
74104: LD_VAR 0 4
74108: ARRAY
74109: PPUSH
74110: LD_EXP 86
74114: PUSH
74115: LD_VAR 0 4
74119: ARRAY
74120: PUSH
74121: LD_INT 1
74123: MINUS
74124: PPUSH
74125: LD_EXP 86
74129: PUSH
74130: LD_VAR 0 4
74134: ARRAY
74135: PPUSH
74136: LD_INT 0
74138: PPUSH
74139: CALL 20947 0 4
74143: PPUSH
74144: CALL_OW 1
74148: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74149: LD_ADDR_EXP 86
74153: PUSH
74154: LD_EXP 86
74158: PPUSH
74159: LD_VAR 0 4
74163: PPUSH
74164: LD_EXP 86
74168: PUSH
74169: LD_VAR 0 4
74173: ARRAY
74174: PPUSH
74175: LD_EXP 86
74179: PUSH
74180: LD_VAR 0 4
74184: ARRAY
74185: PPUSH
74186: LD_INT 1
74188: PPUSH
74189: LD_INT 0
74191: PPUSH
74192: CALL 20947 0 4
74196: PPUSH
74197: CALL_OW 1
74201: ST_TO_ADDR
// continue ;
74202: GO 73776
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74204: LD_EXP 88
74208: PUSH
74209: LD_VAR 0 2
74213: ARRAY
74214: PUSH
74215: LD_EXP 89
74219: PUSH
74220: LD_VAR 0 2
74224: ARRAY
74225: NOT
74226: AND
74227: IFFALSE 74354
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74229: LD_ADDR_EXP 89
74233: PUSH
74234: LD_EXP 89
74238: PPUSH
74239: LD_VAR 0 2
74243: PUSH
74244: LD_EXP 89
74248: PUSH
74249: LD_VAR 0 2
74253: ARRAY
74254: PUSH
74255: LD_INT 1
74257: PLUS
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PPUSH
74263: LD_EXP 88
74267: PUSH
74268: LD_VAR 0 2
74272: ARRAY
74273: PUSH
74274: LD_INT 1
74276: ARRAY
74277: PPUSH
74278: CALL 21529 0 3
74282: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74283: LD_EXP 88
74287: PUSH
74288: LD_VAR 0 2
74292: ARRAY
74293: PUSH
74294: LD_INT 1
74296: ARRAY
74297: PPUSH
74298: LD_INT 112
74300: PPUSH
74301: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74305: LD_ADDR_VAR 0 9
74309: PUSH
74310: LD_EXP 88
74314: PUSH
74315: LD_VAR 0 2
74319: ARRAY
74320: PPUSH
74321: LD_INT 1
74323: PPUSH
74324: CALL_OW 3
74328: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74329: LD_ADDR_EXP 88
74333: PUSH
74334: LD_EXP 88
74338: PPUSH
74339: LD_VAR 0 2
74343: PPUSH
74344: LD_VAR 0 9
74348: PPUSH
74349: CALL_OW 1
74353: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74354: LD_EXP 88
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: PUSH
74365: LD_EXP 89
74369: PUSH
74370: LD_VAR 0 2
74374: ARRAY
74375: AND
74376: PUSH
74377: LD_EXP 89
74381: PUSH
74382: LD_VAR 0 2
74386: ARRAY
74387: PUSH
74388: LD_INT 1
74390: ARRAY
74391: PPUSH
74392: CALL_OW 310
74396: NOT
74397: AND
74398: PUSH
74399: LD_VAR 0 3
74403: PPUSH
74404: CALL_OW 313
74408: PUSH
74409: LD_INT 6
74411: EQUAL
74412: AND
74413: IFFALSE 74469
// begin tmp2 := UnitsInside ( j ) ;
74415: LD_ADDR_VAR 0 9
74419: PUSH
74420: LD_VAR 0 3
74424: PPUSH
74425: CALL_OW 313
74429: ST_TO_ADDR
// if tmp2 = 6 then
74430: LD_VAR 0 9
74434: PUSH
74435: LD_INT 6
74437: EQUAL
74438: IFFALSE 74469
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74440: LD_VAR 0 9
74444: PUSH
74445: LD_INT 1
74447: ARRAY
74448: PPUSH
74449: LD_INT 112
74451: PPUSH
74452: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74456: LD_VAR 0 9
74460: PUSH
74461: LD_INT 1
74463: ARRAY
74464: PPUSH
74465: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74469: LD_EXP 89
74473: PUSH
74474: LD_VAR 0 2
74478: ARRAY
74479: PUSH
74480: LD_EXP 89
74484: PUSH
74485: LD_VAR 0 2
74489: ARRAY
74490: PUSH
74491: LD_INT 1
74493: ARRAY
74494: PPUSH
74495: CALL_OW 314
74499: NOT
74500: AND
74501: PUSH
74502: LD_EXP 89
74506: PUSH
74507: LD_VAR 0 2
74511: ARRAY
74512: PUSH
74513: LD_INT 1
74515: ARRAY
74516: PPUSH
74517: CALL_OW 310
74521: NOT
74522: AND
74523: IFFALSE 74549
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74525: LD_EXP 89
74529: PUSH
74530: LD_VAR 0 2
74534: ARRAY
74535: PUSH
74536: LD_INT 1
74538: ARRAY
74539: PPUSH
74540: LD_VAR 0 3
74544: PPUSH
74545: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74549: LD_EXP 89
74553: PUSH
74554: LD_VAR 0 2
74558: ARRAY
74559: PUSH
74560: LD_INT 1
74562: ARRAY
74563: PPUSH
74564: CALL_OW 310
74568: PUSH
74569: LD_EXP 89
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: PUSH
74580: LD_INT 1
74582: ARRAY
74583: PPUSH
74584: CALL_OW 310
74588: PPUSH
74589: CALL_OW 461
74593: PUSH
74594: LD_INT 3
74596: NONEQUAL
74597: AND
74598: IFFALSE 74619
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74600: LD_EXP 89
74604: PUSH
74605: LD_VAR 0 2
74609: ARRAY
74610: PUSH
74611: LD_INT 1
74613: ARRAY
74614: PPUSH
74615: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74619: LD_VAR 0 3
74623: PPUSH
74624: CALL_OW 461
74628: PUSH
74629: LD_INT 6
74631: EQUAL
74632: PUSH
74633: LD_VAR 0 6
74637: PUSH
74638: LD_INT 1
74640: GREATER
74641: AND
74642: IFFALSE 74794
// begin sci := [ ] ;
74644: LD_ADDR_VAR 0 8
74648: PUSH
74649: EMPTY
74650: ST_TO_ADDR
// for x in ( tmp diff j ) do
74651: LD_ADDR_VAR 0 7
74655: PUSH
74656: LD_VAR 0 6
74660: PUSH
74661: LD_VAR 0 3
74665: DIFF
74666: PUSH
74667: FOR_IN
74668: IFFALSE 74720
// begin if sci = 6 then
74670: LD_VAR 0 8
74674: PUSH
74675: LD_INT 6
74677: EQUAL
74678: IFFALSE 74682
// break ;
74680: GO 74720
// if BuildingStatus ( x ) = bs_idle then
74682: LD_VAR 0 7
74686: PPUSH
74687: CALL_OW 461
74691: PUSH
74692: LD_INT 2
74694: EQUAL
74695: IFFALSE 74718
// sci := sci ^ UnitsInside ( x ) ;
74697: LD_ADDR_VAR 0 8
74701: PUSH
74702: LD_VAR 0 8
74706: PUSH
74707: LD_VAR 0 7
74711: PPUSH
74712: CALL_OW 313
74716: ADD
74717: ST_TO_ADDR
// end ;
74718: GO 74667
74720: POP
74721: POP
// if not sci then
74722: LD_VAR 0 8
74726: NOT
74727: IFFALSE 74731
// continue ;
74729: GO 73776
// for x in sci do
74731: LD_ADDR_VAR 0 7
74735: PUSH
74736: LD_VAR 0 8
74740: PUSH
74741: FOR_IN
74742: IFFALSE 74792
// if IsInUnit ( x ) and not HasTask ( x ) then
74744: LD_VAR 0 7
74748: PPUSH
74749: CALL_OW 310
74753: PUSH
74754: LD_VAR 0 7
74758: PPUSH
74759: CALL_OW 314
74763: NOT
74764: AND
74765: IFFALSE 74790
// begin ComExitBuilding ( x ) ;
74767: LD_VAR 0 7
74771: PPUSH
74772: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74776: LD_VAR 0 7
74780: PPUSH
74781: LD_VAR 0 3
74785: PPUSH
74786: CALL_OW 180
// end ;
74790: GO 74741
74792: POP
74793: POP
// end ; end ;
74794: GO 73776
74796: POP
74797: POP
// end ;
74798: GO 73730
74800: POP
74801: POP
// end ;
74802: LD_VAR 0 1
74806: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74807: LD_INT 0
74809: PPUSH
74810: PPUSH
// if not mc_bases then
74811: LD_EXP 59
74815: NOT
74816: IFFALSE 74820
// exit ;
74818: GO 74901
// for i = 1 to mc_bases do
74820: LD_ADDR_VAR 0 2
74824: PUSH
74825: DOUBLE
74826: LD_INT 1
74828: DEC
74829: ST_TO_ADDR
74830: LD_EXP 59
74834: PUSH
74835: FOR_TO
74836: IFFALSE 74899
// if mc_mines [ i ] and mc_miners [ i ] then
74838: LD_EXP 72
74842: PUSH
74843: LD_VAR 0 2
74847: ARRAY
74848: PUSH
74849: LD_EXP 73
74853: PUSH
74854: LD_VAR 0 2
74858: ARRAY
74859: AND
74860: IFFALSE 74897
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74862: LD_EXP 73
74866: PUSH
74867: LD_VAR 0 2
74871: ARRAY
74872: PUSH
74873: LD_INT 1
74875: ARRAY
74876: PPUSH
74877: CALL_OW 255
74881: PPUSH
74882: LD_EXP 72
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: PPUSH
74893: CALL 18518 0 2
74897: GO 74835
74899: POP
74900: POP
// end ;
74901: LD_VAR 0 1
74905: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74906: LD_INT 0
74908: PPUSH
74909: PPUSH
74910: PPUSH
74911: PPUSH
74912: PPUSH
74913: PPUSH
74914: PPUSH
74915: PPUSH
// if not mc_bases or not mc_parking then
74916: LD_EXP 59
74920: NOT
74921: PUSH
74922: LD_EXP 83
74926: NOT
74927: OR
74928: IFFALSE 74932
// exit ;
74930: GO 75631
// for i = 1 to mc_bases do
74932: LD_ADDR_VAR 0 2
74936: PUSH
74937: DOUBLE
74938: LD_INT 1
74940: DEC
74941: ST_TO_ADDR
74942: LD_EXP 59
74946: PUSH
74947: FOR_TO
74948: IFFALSE 75629
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74950: LD_EXP 59
74954: PUSH
74955: LD_VAR 0 2
74959: ARRAY
74960: NOT
74961: PUSH
74962: LD_EXP 83
74966: PUSH
74967: LD_VAR 0 2
74971: ARRAY
74972: NOT
74973: OR
74974: IFFALSE 74978
// continue ;
74976: GO 74947
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74978: LD_ADDR_VAR 0 5
74982: PUSH
74983: LD_EXP 59
74987: PUSH
74988: LD_VAR 0 2
74992: ARRAY
74993: PUSH
74994: LD_INT 1
74996: ARRAY
74997: PPUSH
74998: CALL_OW 255
75002: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75003: LD_ADDR_VAR 0 6
75007: PUSH
75008: LD_EXP 59
75012: PUSH
75013: LD_VAR 0 2
75017: ARRAY
75018: PPUSH
75019: LD_INT 30
75021: PUSH
75022: LD_INT 3
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PPUSH
75029: CALL_OW 72
75033: ST_TO_ADDR
// if not fac then
75034: LD_VAR 0 6
75038: NOT
75039: IFFALSE 75090
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75041: LD_ADDR_VAR 0 6
75045: PUSH
75046: LD_EXP 59
75050: PUSH
75051: LD_VAR 0 2
75055: ARRAY
75056: PPUSH
75057: LD_INT 2
75059: PUSH
75060: LD_INT 30
75062: PUSH
75063: LD_INT 0
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 30
75072: PUSH
75073: LD_INT 1
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: LIST
75084: PPUSH
75085: CALL_OW 72
75089: ST_TO_ADDR
// if not fac then
75090: LD_VAR 0 6
75094: NOT
75095: IFFALSE 75099
// continue ;
75097: GO 74947
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75099: LD_ADDR_VAR 0 7
75103: PUSH
75104: LD_EXP 83
75108: PUSH
75109: LD_VAR 0 2
75113: ARRAY
75114: PPUSH
75115: LD_INT 22
75117: PUSH
75118: LD_VAR 0 5
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 21
75129: PUSH
75130: LD_INT 2
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 3
75139: PUSH
75140: LD_INT 24
75142: PUSH
75143: LD_INT 1000
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: LIST
75158: PPUSH
75159: CALL_OW 70
75163: ST_TO_ADDR
// for j in fac do
75164: LD_ADDR_VAR 0 3
75168: PUSH
75169: LD_VAR 0 6
75173: PUSH
75174: FOR_IN
75175: IFFALSE 75256
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75177: LD_ADDR_VAR 0 7
75181: PUSH
75182: LD_VAR 0 7
75186: PUSH
75187: LD_INT 22
75189: PUSH
75190: LD_VAR 0 5
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 91
75201: PUSH
75202: LD_VAR 0 3
75206: PUSH
75207: LD_INT 15
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 21
75217: PUSH
75218: LD_INT 2
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 3
75227: PUSH
75228: LD_INT 24
75230: PUSH
75231: LD_INT 1000
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: LIST
75246: LIST
75247: PPUSH
75248: CALL_OW 69
75252: UNION
75253: ST_TO_ADDR
75254: GO 75174
75256: POP
75257: POP
// if not vehs then
75258: LD_VAR 0 7
75262: NOT
75263: IFFALSE 75289
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75265: LD_ADDR_EXP 71
75269: PUSH
75270: LD_EXP 71
75274: PPUSH
75275: LD_VAR 0 2
75279: PPUSH
75280: EMPTY
75281: PPUSH
75282: CALL_OW 1
75286: ST_TO_ADDR
// continue ;
75287: GO 74947
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75289: LD_ADDR_VAR 0 8
75293: PUSH
75294: LD_EXP 59
75298: PUSH
75299: LD_VAR 0 2
75303: ARRAY
75304: PPUSH
75305: LD_INT 30
75307: PUSH
75308: LD_INT 3
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PPUSH
75315: CALL_OW 72
75319: ST_TO_ADDR
// if tmp then
75320: LD_VAR 0 8
75324: IFFALSE 75427
// begin for j in tmp do
75326: LD_ADDR_VAR 0 3
75330: PUSH
75331: LD_VAR 0 8
75335: PUSH
75336: FOR_IN
75337: IFFALSE 75425
// for k in UnitsInside ( j ) do
75339: LD_ADDR_VAR 0 4
75343: PUSH
75344: LD_VAR 0 3
75348: PPUSH
75349: CALL_OW 313
75353: PUSH
75354: FOR_IN
75355: IFFALSE 75421
// if k then
75357: LD_VAR 0 4
75361: IFFALSE 75419
// if not k in mc_repair_vehicle [ i ] then
75363: LD_VAR 0 4
75367: PUSH
75368: LD_EXP 71
75372: PUSH
75373: LD_VAR 0 2
75377: ARRAY
75378: IN
75379: NOT
75380: IFFALSE 75419
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75382: LD_ADDR_EXP 71
75386: PUSH
75387: LD_EXP 71
75391: PPUSH
75392: LD_VAR 0 2
75396: PPUSH
75397: LD_EXP 71
75401: PUSH
75402: LD_VAR 0 2
75406: ARRAY
75407: PUSH
75408: LD_VAR 0 4
75412: UNION
75413: PPUSH
75414: CALL_OW 1
75418: ST_TO_ADDR
75419: GO 75354
75421: POP
75422: POP
75423: GO 75336
75425: POP
75426: POP
// end ; if not mc_repair_vehicle [ i ] then
75427: LD_EXP 71
75431: PUSH
75432: LD_VAR 0 2
75436: ARRAY
75437: NOT
75438: IFFALSE 75442
// continue ;
75440: GO 74947
// for j in mc_repair_vehicle [ i ] do
75442: LD_ADDR_VAR 0 3
75446: PUSH
75447: LD_EXP 71
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PUSH
75458: FOR_IN
75459: IFFALSE 75625
// begin if GetClass ( j ) <> 3 then
75461: LD_VAR 0 3
75465: PPUSH
75466: CALL_OW 257
75470: PUSH
75471: LD_INT 3
75473: NONEQUAL
75474: IFFALSE 75515
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75476: LD_ADDR_EXP 71
75480: PUSH
75481: LD_EXP 71
75485: PPUSH
75486: LD_VAR 0 2
75490: PPUSH
75491: LD_EXP 71
75495: PUSH
75496: LD_VAR 0 2
75500: ARRAY
75501: PUSH
75502: LD_VAR 0 3
75506: DIFF
75507: PPUSH
75508: CALL_OW 1
75512: ST_TO_ADDR
// continue ;
75513: GO 75458
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75515: LD_VAR 0 3
75519: PPUSH
75520: CALL_OW 311
75524: NOT
75525: PUSH
75526: LD_VAR 0 3
75530: PUSH
75531: LD_EXP 62
75535: PUSH
75536: LD_VAR 0 2
75540: ARRAY
75541: PUSH
75542: LD_INT 1
75544: ARRAY
75545: IN
75546: NOT
75547: AND
75548: PUSH
75549: LD_VAR 0 3
75553: PUSH
75554: LD_EXP 62
75558: PUSH
75559: LD_VAR 0 2
75563: ARRAY
75564: PUSH
75565: LD_INT 2
75567: ARRAY
75568: IN
75569: NOT
75570: AND
75571: IFFALSE 75623
// begin if IsInUnit ( j ) then
75573: LD_VAR 0 3
75577: PPUSH
75578: CALL_OW 310
75582: IFFALSE 75593
// ComExitBuilding ( j ) ;
75584: LD_VAR 0 3
75588: PPUSH
75589: CALL_OW 122
// if not HasTask ( j ) then
75593: LD_VAR 0 3
75597: PPUSH
75598: CALL_OW 314
75602: NOT
75603: IFFALSE 75623
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75605: LD_VAR 0 3
75609: PPUSH
75610: LD_VAR 0 7
75614: PUSH
75615: LD_INT 1
75617: ARRAY
75618: PPUSH
75619: CALL_OW 189
// end ; end ;
75623: GO 75458
75625: POP
75626: POP
// end ;
75627: GO 74947
75629: POP
75630: POP
// end ;
75631: LD_VAR 0 1
75635: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75636: LD_INT 0
75638: PPUSH
75639: PPUSH
75640: PPUSH
75641: PPUSH
75642: PPUSH
75643: PPUSH
75644: PPUSH
75645: PPUSH
75646: PPUSH
75647: PPUSH
75648: PPUSH
// if not mc_bases then
75649: LD_EXP 59
75653: NOT
75654: IFFALSE 75658
// exit ;
75656: GO 76460
// for i = 1 to mc_bases do
75658: LD_ADDR_VAR 0 2
75662: PUSH
75663: DOUBLE
75664: LD_INT 1
75666: DEC
75667: ST_TO_ADDR
75668: LD_EXP 59
75672: PUSH
75673: FOR_TO
75674: IFFALSE 76458
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75676: LD_EXP 87
75680: PUSH
75681: LD_VAR 0 2
75685: ARRAY
75686: NOT
75687: PUSH
75688: LD_EXP 62
75692: PUSH
75693: LD_VAR 0 2
75697: ARRAY
75698: PUSH
75699: LD_INT 1
75701: ARRAY
75702: OR
75703: PUSH
75704: LD_EXP 62
75708: PUSH
75709: LD_VAR 0 2
75713: ARRAY
75714: PUSH
75715: LD_INT 2
75717: ARRAY
75718: OR
75719: PUSH
75720: LD_EXP 85
75724: PUSH
75725: LD_VAR 0 2
75729: ARRAY
75730: PPUSH
75731: LD_INT 1
75733: PPUSH
75734: CALL_OW 325
75738: NOT
75739: OR
75740: PUSH
75741: LD_EXP 82
75745: PUSH
75746: LD_VAR 0 2
75750: ARRAY
75751: OR
75752: IFFALSE 75756
// continue ;
75754: GO 75673
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75756: LD_ADDR_VAR 0 8
75760: PUSH
75761: LD_EXP 59
75765: PUSH
75766: LD_VAR 0 2
75770: ARRAY
75771: PPUSH
75772: LD_INT 25
75774: PUSH
75775: LD_INT 4
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 50
75784: PUSH
75785: EMPTY
75786: LIST
75787: PUSH
75788: LD_INT 3
75790: PUSH
75791: LD_INT 60
75793: PUSH
75794: EMPTY
75795: LIST
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: LIST
75805: PPUSH
75806: CALL_OW 72
75810: PUSH
75811: LD_EXP 63
75815: PUSH
75816: LD_VAR 0 2
75820: ARRAY
75821: DIFF
75822: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75823: LD_ADDR_VAR 0 9
75827: PUSH
75828: LD_EXP 59
75832: PUSH
75833: LD_VAR 0 2
75837: ARRAY
75838: PPUSH
75839: LD_INT 2
75841: PUSH
75842: LD_INT 30
75844: PUSH
75845: LD_INT 0
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 30
75854: PUSH
75855: LD_INT 1
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: LIST
75866: PPUSH
75867: CALL_OW 72
75871: ST_TO_ADDR
// if not tmp or not dep then
75872: LD_VAR 0 8
75876: NOT
75877: PUSH
75878: LD_VAR 0 9
75882: NOT
75883: OR
75884: IFFALSE 75888
// continue ;
75886: GO 75673
// side := GetSide ( tmp [ 1 ] ) ;
75888: LD_ADDR_VAR 0 11
75892: PUSH
75893: LD_VAR 0 8
75897: PUSH
75898: LD_INT 1
75900: ARRAY
75901: PPUSH
75902: CALL_OW 255
75906: ST_TO_ADDR
// dep := dep [ 1 ] ;
75907: LD_ADDR_VAR 0 9
75911: PUSH
75912: LD_VAR 0 9
75916: PUSH
75917: LD_INT 1
75919: ARRAY
75920: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75921: LD_ADDR_VAR 0 7
75925: PUSH
75926: LD_EXP 87
75930: PUSH
75931: LD_VAR 0 2
75935: ARRAY
75936: PPUSH
75937: LD_INT 22
75939: PUSH
75940: LD_INT 0
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 25
75949: PUSH
75950: LD_INT 12
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PPUSH
75961: CALL_OW 70
75965: PUSH
75966: LD_INT 22
75968: PUSH
75969: LD_INT 0
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 25
75978: PUSH
75979: LD_INT 12
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 91
75988: PUSH
75989: LD_VAR 0 9
75993: PUSH
75994: LD_INT 20
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: LIST
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: LIST
76006: PPUSH
76007: CALL_OW 69
76011: UNION
76012: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76013: LD_ADDR_VAR 0 10
76017: PUSH
76018: LD_EXP 87
76022: PUSH
76023: LD_VAR 0 2
76027: ARRAY
76028: PPUSH
76029: LD_INT 81
76031: PUSH
76032: LD_VAR 0 11
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PPUSH
76041: CALL_OW 70
76045: ST_TO_ADDR
// if not apes or danger_at_area then
76046: LD_VAR 0 7
76050: NOT
76051: PUSH
76052: LD_VAR 0 10
76056: OR
76057: IFFALSE 76107
// begin if mc_taming [ i ] then
76059: LD_EXP 90
76063: PUSH
76064: LD_VAR 0 2
76068: ARRAY
76069: IFFALSE 76105
// begin MC_Reset ( i , 121 ) ;
76071: LD_VAR 0 2
76075: PPUSH
76076: LD_INT 121
76078: PPUSH
76079: CALL 61542 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76083: LD_ADDR_EXP 90
76087: PUSH
76088: LD_EXP 90
76092: PPUSH
76093: LD_VAR 0 2
76097: PPUSH
76098: EMPTY
76099: PPUSH
76100: CALL_OW 1
76104: ST_TO_ADDR
// end ; continue ;
76105: GO 75673
// end ; for j in tmp do
76107: LD_ADDR_VAR 0 3
76111: PUSH
76112: LD_VAR 0 8
76116: PUSH
76117: FOR_IN
76118: IFFALSE 76454
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76120: LD_VAR 0 3
76124: PUSH
76125: LD_EXP 90
76129: PUSH
76130: LD_VAR 0 2
76134: ARRAY
76135: IN
76136: NOT
76137: PUSH
76138: LD_EXP 90
76142: PUSH
76143: LD_VAR 0 2
76147: ARRAY
76148: PUSH
76149: LD_INT 3
76151: LESS
76152: AND
76153: IFFALSE 76211
// begin SetTag ( j , 121 ) ;
76155: LD_VAR 0 3
76159: PPUSH
76160: LD_INT 121
76162: PPUSH
76163: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76167: LD_ADDR_EXP 90
76171: PUSH
76172: LD_EXP 90
76176: PPUSH
76177: LD_VAR 0 2
76181: PUSH
76182: LD_EXP 90
76186: PUSH
76187: LD_VAR 0 2
76191: ARRAY
76192: PUSH
76193: LD_INT 1
76195: PLUS
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: PPUSH
76201: LD_VAR 0 3
76205: PPUSH
76206: CALL 21529 0 3
76210: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76211: LD_VAR 0 3
76215: PUSH
76216: LD_EXP 90
76220: PUSH
76221: LD_VAR 0 2
76225: ARRAY
76226: IN
76227: IFFALSE 76452
// begin if GetClass ( j ) <> 4 then
76229: LD_VAR 0 3
76233: PPUSH
76234: CALL_OW 257
76238: PUSH
76239: LD_INT 4
76241: NONEQUAL
76242: IFFALSE 76295
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76244: LD_ADDR_EXP 90
76248: PUSH
76249: LD_EXP 90
76253: PPUSH
76254: LD_VAR 0 2
76258: PPUSH
76259: LD_EXP 90
76263: PUSH
76264: LD_VAR 0 2
76268: ARRAY
76269: PUSH
76270: LD_VAR 0 3
76274: DIFF
76275: PPUSH
76276: CALL_OW 1
76280: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76281: LD_VAR 0 3
76285: PPUSH
76286: LD_INT 0
76288: PPUSH
76289: CALL_OW 109
// continue ;
76293: GO 76117
// end ; if IsInUnit ( j ) then
76295: LD_VAR 0 3
76299: PPUSH
76300: CALL_OW 310
76304: IFFALSE 76315
// ComExitBuilding ( j ) ;
76306: LD_VAR 0 3
76310: PPUSH
76311: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76315: LD_ADDR_VAR 0 6
76319: PUSH
76320: LD_VAR 0 7
76324: PPUSH
76325: LD_VAR 0 3
76329: PPUSH
76330: CALL_OW 74
76334: ST_TO_ADDR
// if not ape then
76335: LD_VAR 0 6
76339: NOT
76340: IFFALSE 76344
// break ;
76342: GO 76454
// x := GetX ( ape ) ;
76344: LD_ADDR_VAR 0 4
76348: PUSH
76349: LD_VAR 0 6
76353: PPUSH
76354: CALL_OW 250
76358: ST_TO_ADDR
// y := GetY ( ape ) ;
76359: LD_ADDR_VAR 0 5
76363: PUSH
76364: LD_VAR 0 6
76368: PPUSH
76369: CALL_OW 251
76373: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76374: LD_VAR 0 4
76378: PPUSH
76379: LD_VAR 0 5
76383: PPUSH
76384: CALL_OW 488
76388: NOT
76389: PUSH
76390: LD_VAR 0 11
76394: PPUSH
76395: LD_VAR 0 4
76399: PPUSH
76400: LD_VAR 0 5
76404: PPUSH
76405: LD_INT 20
76407: PPUSH
76408: CALL 22425 0 4
76412: PUSH
76413: LD_INT 4
76415: ARRAY
76416: OR
76417: IFFALSE 76421
// break ;
76419: GO 76454
// if not HasTask ( j ) then
76421: LD_VAR 0 3
76425: PPUSH
76426: CALL_OW 314
76430: NOT
76431: IFFALSE 76452
// ComTameXY ( j , x , y ) ;
76433: LD_VAR 0 3
76437: PPUSH
76438: LD_VAR 0 4
76442: PPUSH
76443: LD_VAR 0 5
76447: PPUSH
76448: CALL_OW 131
// end ; end ;
76452: GO 76117
76454: POP
76455: POP
// end ;
76456: GO 75673
76458: POP
76459: POP
// end ;
76460: LD_VAR 0 1
76464: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76465: LD_INT 0
76467: PPUSH
76468: PPUSH
76469: PPUSH
76470: PPUSH
76471: PPUSH
76472: PPUSH
76473: PPUSH
76474: PPUSH
// if not mc_bases then
76475: LD_EXP 59
76479: NOT
76480: IFFALSE 76484
// exit ;
76482: GO 77110
// for i = 1 to mc_bases do
76484: LD_ADDR_VAR 0 2
76488: PUSH
76489: DOUBLE
76490: LD_INT 1
76492: DEC
76493: ST_TO_ADDR
76494: LD_EXP 59
76498: PUSH
76499: FOR_TO
76500: IFFALSE 77108
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76502: LD_EXP 88
76506: PUSH
76507: LD_VAR 0 2
76511: ARRAY
76512: NOT
76513: PUSH
76514: LD_EXP 88
76518: PUSH
76519: LD_VAR 0 2
76523: ARRAY
76524: PPUSH
76525: LD_INT 25
76527: PUSH
76528: LD_INT 12
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PPUSH
76535: CALL_OW 72
76539: NOT
76540: OR
76541: IFFALSE 76545
// continue ;
76543: GO 76499
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76545: LD_ADDR_VAR 0 5
76549: PUSH
76550: LD_EXP 88
76554: PUSH
76555: LD_VAR 0 2
76559: ARRAY
76560: PUSH
76561: LD_INT 1
76563: ARRAY
76564: PPUSH
76565: CALL_OW 255
76569: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76570: LD_VAR 0 5
76574: PPUSH
76575: LD_INT 2
76577: PPUSH
76578: CALL_OW 325
76582: IFFALSE 76835
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76584: LD_ADDR_VAR 0 4
76588: PUSH
76589: LD_EXP 88
76593: PUSH
76594: LD_VAR 0 2
76598: ARRAY
76599: PPUSH
76600: LD_INT 25
76602: PUSH
76603: LD_INT 16
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PPUSH
76610: CALL_OW 72
76614: ST_TO_ADDR
// if tmp < 6 then
76615: LD_VAR 0 4
76619: PUSH
76620: LD_INT 6
76622: LESS
76623: IFFALSE 76835
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76625: LD_ADDR_VAR 0 6
76629: PUSH
76630: LD_EXP 59
76634: PUSH
76635: LD_VAR 0 2
76639: ARRAY
76640: PPUSH
76641: LD_INT 2
76643: PUSH
76644: LD_INT 30
76646: PUSH
76647: LD_INT 0
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 30
76656: PUSH
76657: LD_INT 1
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: LIST
76668: PPUSH
76669: CALL_OW 72
76673: ST_TO_ADDR
// if depot then
76674: LD_VAR 0 6
76678: IFFALSE 76835
// begin selected := 0 ;
76680: LD_ADDR_VAR 0 7
76684: PUSH
76685: LD_INT 0
76687: ST_TO_ADDR
// for j in depot do
76688: LD_ADDR_VAR 0 3
76692: PUSH
76693: LD_VAR 0 6
76697: PUSH
76698: FOR_IN
76699: IFFALSE 76730
// begin if UnitsInside ( j ) < 6 then
76701: LD_VAR 0 3
76705: PPUSH
76706: CALL_OW 313
76710: PUSH
76711: LD_INT 6
76713: LESS
76714: IFFALSE 76728
// begin selected := j ;
76716: LD_ADDR_VAR 0 7
76720: PUSH
76721: LD_VAR 0 3
76725: ST_TO_ADDR
// break ;
76726: GO 76730
// end ; end ;
76728: GO 76698
76730: POP
76731: POP
// if selected then
76732: LD_VAR 0 7
76736: IFFALSE 76835
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76738: LD_ADDR_VAR 0 3
76742: PUSH
76743: LD_EXP 88
76747: PUSH
76748: LD_VAR 0 2
76752: ARRAY
76753: PPUSH
76754: LD_INT 25
76756: PUSH
76757: LD_INT 12
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PPUSH
76764: CALL_OW 72
76768: PUSH
76769: FOR_IN
76770: IFFALSE 76833
// if not HasTask ( j ) then
76772: LD_VAR 0 3
76776: PPUSH
76777: CALL_OW 314
76781: NOT
76782: IFFALSE 76831
// begin if not IsInUnit ( j ) then
76784: LD_VAR 0 3
76788: PPUSH
76789: CALL_OW 310
76793: NOT
76794: IFFALSE 76810
// ComEnterUnit ( j , selected ) ;
76796: LD_VAR 0 3
76800: PPUSH
76801: LD_VAR 0 7
76805: PPUSH
76806: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76810: LD_VAR 0 3
76814: PPUSH
76815: LD_INT 16
76817: PPUSH
76818: CALL_OW 183
// AddComExitBuilding ( j ) ;
76822: LD_VAR 0 3
76826: PPUSH
76827: CALL_OW 182
// end ;
76831: GO 76769
76833: POP
76834: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76835: LD_VAR 0 5
76839: PPUSH
76840: LD_INT 11
76842: PPUSH
76843: CALL_OW 325
76847: IFFALSE 77106
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76849: LD_ADDR_VAR 0 4
76853: PUSH
76854: LD_EXP 88
76858: PUSH
76859: LD_VAR 0 2
76863: ARRAY
76864: PPUSH
76865: LD_INT 25
76867: PUSH
76868: LD_INT 16
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PPUSH
76875: CALL_OW 72
76879: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76880: LD_VAR 0 4
76884: PUSH
76885: LD_INT 6
76887: GREATEREQUAL
76888: PUSH
76889: LD_VAR 0 5
76893: PPUSH
76894: LD_INT 2
76896: PPUSH
76897: CALL_OW 325
76901: NOT
76902: OR
76903: IFFALSE 77106
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76905: LD_ADDR_VAR 0 8
76909: PUSH
76910: LD_EXP 59
76914: PUSH
76915: LD_VAR 0 2
76919: ARRAY
76920: PPUSH
76921: LD_INT 2
76923: PUSH
76924: LD_INT 30
76926: PUSH
76927: LD_INT 4
76929: PUSH
76930: EMPTY
76931: LIST
76932: LIST
76933: PUSH
76934: LD_INT 30
76936: PUSH
76937: LD_INT 5
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: LIST
76948: PPUSH
76949: CALL_OW 72
76953: ST_TO_ADDR
// if barracks then
76954: LD_VAR 0 8
76958: IFFALSE 77106
// begin selected := 0 ;
76960: LD_ADDR_VAR 0 7
76964: PUSH
76965: LD_INT 0
76967: ST_TO_ADDR
// for j in barracks do
76968: LD_ADDR_VAR 0 3
76972: PUSH
76973: LD_VAR 0 8
76977: PUSH
76978: FOR_IN
76979: IFFALSE 77010
// begin if UnitsInside ( j ) < 6 then
76981: LD_VAR 0 3
76985: PPUSH
76986: CALL_OW 313
76990: PUSH
76991: LD_INT 6
76993: LESS
76994: IFFALSE 77008
// begin selected := j ;
76996: LD_ADDR_VAR 0 7
77000: PUSH
77001: LD_VAR 0 3
77005: ST_TO_ADDR
// break ;
77006: GO 77010
// end ; end ;
77008: GO 76978
77010: POP
77011: POP
// if selected then
77012: LD_VAR 0 7
77016: IFFALSE 77106
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77018: LD_ADDR_VAR 0 3
77022: PUSH
77023: LD_EXP 88
77027: PUSH
77028: LD_VAR 0 2
77032: ARRAY
77033: PPUSH
77034: LD_INT 25
77036: PUSH
77037: LD_INT 12
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PPUSH
77044: CALL_OW 72
77048: PUSH
77049: FOR_IN
77050: IFFALSE 77104
// if not IsInUnit ( j ) and not HasTask ( j ) then
77052: LD_VAR 0 3
77056: PPUSH
77057: CALL_OW 310
77061: NOT
77062: PUSH
77063: LD_VAR 0 3
77067: PPUSH
77068: CALL_OW 314
77072: NOT
77073: AND
77074: IFFALSE 77102
// begin ComEnterUnit ( j , selected ) ;
77076: LD_VAR 0 3
77080: PPUSH
77081: LD_VAR 0 7
77085: PPUSH
77086: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77090: LD_VAR 0 3
77094: PPUSH
77095: LD_INT 15
77097: PPUSH
77098: CALL_OW 183
// end ;
77102: GO 77049
77104: POP
77105: POP
// end ; end ; end ; end ; end ;
77106: GO 76499
77108: POP
77109: POP
// end ;
77110: LD_VAR 0 1
77114: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77115: LD_INT 0
77117: PPUSH
77118: PPUSH
77119: PPUSH
77120: PPUSH
// if not mc_bases then
77121: LD_EXP 59
77125: NOT
77126: IFFALSE 77130
// exit ;
77128: GO 77308
// for i = 1 to mc_bases do
77130: LD_ADDR_VAR 0 2
77134: PUSH
77135: DOUBLE
77136: LD_INT 1
77138: DEC
77139: ST_TO_ADDR
77140: LD_EXP 59
77144: PUSH
77145: FOR_TO
77146: IFFALSE 77306
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77148: LD_ADDR_VAR 0 4
77152: PUSH
77153: LD_EXP 59
77157: PUSH
77158: LD_VAR 0 2
77162: ARRAY
77163: PPUSH
77164: LD_INT 25
77166: PUSH
77167: LD_INT 9
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PPUSH
77174: CALL_OW 72
77178: ST_TO_ADDR
// if not tmp then
77179: LD_VAR 0 4
77183: NOT
77184: IFFALSE 77188
// continue ;
77186: GO 77145
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77188: LD_EXP 85
77192: PUSH
77193: LD_VAR 0 2
77197: ARRAY
77198: PPUSH
77199: LD_INT 29
77201: PPUSH
77202: CALL_OW 325
77206: NOT
77207: PUSH
77208: LD_EXP 85
77212: PUSH
77213: LD_VAR 0 2
77217: ARRAY
77218: PPUSH
77219: LD_INT 28
77221: PPUSH
77222: CALL_OW 325
77226: NOT
77227: AND
77228: IFFALSE 77232
// continue ;
77230: GO 77145
// for j in tmp do
77232: LD_ADDR_VAR 0 3
77236: PUSH
77237: LD_VAR 0 4
77241: PUSH
77242: FOR_IN
77243: IFFALSE 77302
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77245: LD_VAR 0 3
77249: PUSH
77250: LD_EXP 62
77254: PUSH
77255: LD_VAR 0 2
77259: ARRAY
77260: PUSH
77261: LD_INT 1
77263: ARRAY
77264: IN
77265: NOT
77266: PUSH
77267: LD_VAR 0 3
77271: PUSH
77272: LD_EXP 62
77276: PUSH
77277: LD_VAR 0 2
77281: ARRAY
77282: PUSH
77283: LD_INT 2
77285: ARRAY
77286: IN
77287: NOT
77288: AND
77289: IFFALSE 77300
// ComSpaceTimeShoot ( j ) ;
77291: LD_VAR 0 3
77295: PPUSH
77296: CALL 15115 0 1
77300: GO 77242
77302: POP
77303: POP
// end ;
77304: GO 77145
77306: POP
77307: POP
// end ;
77308: LD_VAR 0 1
77312: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77313: LD_INT 0
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
// if not mc_bases then
77324: LD_EXP 59
77328: NOT
77329: IFFALSE 77333
// exit ;
77331: GO 77955
// for i = 1 to mc_bases do
77333: LD_ADDR_VAR 0 2
77337: PUSH
77338: DOUBLE
77339: LD_INT 1
77341: DEC
77342: ST_TO_ADDR
77343: LD_EXP 59
77347: PUSH
77348: FOR_TO
77349: IFFALSE 77953
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77351: LD_EXP 94
77355: PUSH
77356: LD_VAR 0 2
77360: ARRAY
77361: NOT
77362: PUSH
77363: LD_INT 38
77365: PPUSH
77366: LD_EXP 85
77370: PUSH
77371: LD_VAR 0 2
77375: ARRAY
77376: PPUSH
77377: CALL_OW 321
77381: PUSH
77382: LD_INT 2
77384: NONEQUAL
77385: OR
77386: IFFALSE 77390
// continue ;
77388: GO 77348
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77390: LD_ADDR_VAR 0 8
77394: PUSH
77395: LD_EXP 59
77399: PUSH
77400: LD_VAR 0 2
77404: ARRAY
77405: PPUSH
77406: LD_INT 30
77408: PUSH
77409: LD_INT 34
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PPUSH
77416: CALL_OW 72
77420: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77421: LD_ADDR_VAR 0 9
77425: PUSH
77426: LD_EXP 59
77430: PUSH
77431: LD_VAR 0 2
77435: ARRAY
77436: PPUSH
77437: LD_INT 25
77439: PUSH
77440: LD_INT 4
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PPUSH
77447: CALL_OW 72
77451: PPUSH
77452: LD_INT 0
77454: PPUSH
77455: CALL 54799 0 2
77459: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77460: LD_VAR 0 9
77464: NOT
77465: PUSH
77466: LD_VAR 0 8
77470: NOT
77471: OR
77472: PUSH
77473: LD_EXP 59
77477: PUSH
77478: LD_VAR 0 2
77482: ARRAY
77483: PPUSH
77484: LD_INT 124
77486: PPUSH
77487: CALL 54799 0 2
77491: OR
77492: IFFALSE 77496
// continue ;
77494: GO 77348
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77496: LD_EXP 95
77500: PUSH
77501: LD_VAR 0 2
77505: ARRAY
77506: PUSH
77507: LD_EXP 94
77511: PUSH
77512: LD_VAR 0 2
77516: ARRAY
77517: LESS
77518: PUSH
77519: LD_EXP 95
77523: PUSH
77524: LD_VAR 0 2
77528: ARRAY
77529: PUSH
77530: LD_VAR 0 8
77534: LESS
77535: AND
77536: IFFALSE 77951
// begin tmp := sci [ 1 ] ;
77538: LD_ADDR_VAR 0 7
77542: PUSH
77543: LD_VAR 0 9
77547: PUSH
77548: LD_INT 1
77550: ARRAY
77551: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77552: LD_VAR 0 7
77556: PPUSH
77557: LD_INT 124
77559: PPUSH
77560: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77564: LD_ADDR_VAR 0 3
77568: PUSH
77569: DOUBLE
77570: LD_EXP 94
77574: PUSH
77575: LD_VAR 0 2
77579: ARRAY
77580: INC
77581: ST_TO_ADDR
77582: LD_EXP 94
77586: PUSH
77587: LD_VAR 0 2
77591: ARRAY
77592: PUSH
77593: FOR_DOWNTO
77594: IFFALSE 77937
// begin if IsInUnit ( tmp ) then
77596: LD_VAR 0 7
77600: PPUSH
77601: CALL_OW 310
77605: IFFALSE 77616
// ComExitBuilding ( tmp ) ;
77607: LD_VAR 0 7
77611: PPUSH
77612: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77616: LD_INT 35
77618: PPUSH
77619: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77623: LD_VAR 0 7
77627: PPUSH
77628: CALL_OW 310
77632: NOT
77633: PUSH
77634: LD_VAR 0 7
77638: PPUSH
77639: CALL_OW 314
77643: NOT
77644: AND
77645: IFFALSE 77616
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77647: LD_ADDR_VAR 0 6
77651: PUSH
77652: LD_VAR 0 7
77656: PPUSH
77657: CALL_OW 250
77661: PUSH
77662: LD_VAR 0 7
77666: PPUSH
77667: CALL_OW 251
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77676: LD_INT 35
77678: PPUSH
77679: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77683: LD_ADDR_VAR 0 4
77687: PUSH
77688: LD_EXP 94
77692: PUSH
77693: LD_VAR 0 2
77697: ARRAY
77698: PUSH
77699: LD_VAR 0 3
77703: ARRAY
77704: PUSH
77705: LD_INT 1
77707: ARRAY
77708: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77709: LD_ADDR_VAR 0 5
77713: PUSH
77714: LD_EXP 94
77718: PUSH
77719: LD_VAR 0 2
77723: ARRAY
77724: PUSH
77725: LD_VAR 0 3
77729: ARRAY
77730: PUSH
77731: LD_INT 2
77733: ARRAY
77734: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77735: LD_VAR 0 7
77739: PPUSH
77740: LD_INT 10
77742: PPUSH
77743: CALL 24122 0 2
77747: PUSH
77748: LD_INT 4
77750: ARRAY
77751: IFFALSE 77789
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77753: LD_VAR 0 7
77757: PPUSH
77758: LD_VAR 0 6
77762: PUSH
77763: LD_INT 1
77765: ARRAY
77766: PPUSH
77767: LD_VAR 0 6
77771: PUSH
77772: LD_INT 2
77774: ARRAY
77775: PPUSH
77776: CALL_OW 111
// wait ( 0 0$10 ) ;
77780: LD_INT 350
77782: PPUSH
77783: CALL_OW 67
// end else
77787: GO 77815
// begin ComMoveXY ( tmp , x , y ) ;
77789: LD_VAR 0 7
77793: PPUSH
77794: LD_VAR 0 4
77798: PPUSH
77799: LD_VAR 0 5
77803: PPUSH
77804: CALL_OW 111
// wait ( 0 0$3 ) ;
77808: LD_INT 105
77810: PPUSH
77811: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77815: LD_VAR 0 7
77819: PPUSH
77820: LD_VAR 0 4
77824: PPUSH
77825: LD_VAR 0 5
77829: PPUSH
77830: CALL_OW 307
77834: IFFALSE 77676
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77836: LD_VAR 0 7
77840: PPUSH
77841: LD_VAR 0 4
77845: PPUSH
77846: LD_VAR 0 5
77850: PPUSH
77851: LD_VAR 0 8
77855: PUSH
77856: LD_VAR 0 3
77860: ARRAY
77861: PPUSH
77862: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77866: LD_INT 35
77868: PPUSH
77869: CALL_OW 67
// until not HasTask ( tmp ) ;
77873: LD_VAR 0 7
77877: PPUSH
77878: CALL_OW 314
77882: NOT
77883: IFFALSE 77866
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77885: LD_ADDR_EXP 95
77889: PUSH
77890: LD_EXP 95
77894: PPUSH
77895: LD_VAR 0 2
77899: PUSH
77900: LD_EXP 95
77904: PUSH
77905: LD_VAR 0 2
77909: ARRAY
77910: PUSH
77911: LD_INT 1
77913: PLUS
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PPUSH
77919: LD_VAR 0 8
77923: PUSH
77924: LD_VAR 0 3
77928: ARRAY
77929: PPUSH
77930: CALL 21529 0 3
77934: ST_TO_ADDR
// end ;
77935: GO 77593
77937: POP
77938: POP
// MC_Reset ( i , 124 ) ;
77939: LD_VAR 0 2
77943: PPUSH
77944: LD_INT 124
77946: PPUSH
77947: CALL 61542 0 2
// end ; end ;
77951: GO 77348
77953: POP
77954: POP
// end ;
77955: LD_VAR 0 1
77959: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77960: LD_INT 0
77962: PPUSH
77963: PPUSH
77964: PPUSH
// if not mc_bases then
77965: LD_EXP 59
77969: NOT
77970: IFFALSE 77974
// exit ;
77972: GO 78580
// for i = 1 to mc_bases do
77974: LD_ADDR_VAR 0 2
77978: PUSH
77979: DOUBLE
77980: LD_INT 1
77982: DEC
77983: ST_TO_ADDR
77984: LD_EXP 59
77988: PUSH
77989: FOR_TO
77990: IFFALSE 78578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77992: LD_ADDR_VAR 0 3
77996: PUSH
77997: LD_EXP 59
78001: PUSH
78002: LD_VAR 0 2
78006: ARRAY
78007: PPUSH
78008: LD_INT 25
78010: PUSH
78011: LD_INT 4
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PPUSH
78018: CALL_OW 72
78022: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78023: LD_VAR 0 3
78027: NOT
78028: PUSH
78029: LD_EXP 96
78033: PUSH
78034: LD_VAR 0 2
78038: ARRAY
78039: NOT
78040: OR
78041: PUSH
78042: LD_EXP 59
78046: PUSH
78047: LD_VAR 0 2
78051: ARRAY
78052: PPUSH
78053: LD_INT 2
78055: PUSH
78056: LD_INT 30
78058: PUSH
78059: LD_INT 0
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 30
78068: PUSH
78069: LD_INT 1
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: LIST
78080: PPUSH
78081: CALL_OW 72
78085: NOT
78086: OR
78087: IFFALSE 78137
// begin if mc_deposits_finder [ i ] then
78089: LD_EXP 97
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: IFFALSE 78135
// begin MC_Reset ( i , 125 ) ;
78101: LD_VAR 0 2
78105: PPUSH
78106: LD_INT 125
78108: PPUSH
78109: CALL 61542 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78113: LD_ADDR_EXP 97
78117: PUSH
78118: LD_EXP 97
78122: PPUSH
78123: LD_VAR 0 2
78127: PPUSH
78128: EMPTY
78129: PPUSH
78130: CALL_OW 1
78134: ST_TO_ADDR
// end ; continue ;
78135: GO 77989
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78137: LD_EXP 96
78141: PUSH
78142: LD_VAR 0 2
78146: ARRAY
78147: PUSH
78148: LD_INT 1
78150: ARRAY
78151: PUSH
78152: LD_INT 3
78154: ARRAY
78155: PUSH
78156: LD_INT 1
78158: EQUAL
78159: PUSH
78160: LD_INT 20
78162: PPUSH
78163: LD_EXP 85
78167: PUSH
78168: LD_VAR 0 2
78172: ARRAY
78173: PPUSH
78174: CALL_OW 321
78178: PUSH
78179: LD_INT 2
78181: NONEQUAL
78182: AND
78183: IFFALSE 78233
// begin if mc_deposits_finder [ i ] then
78185: LD_EXP 97
78189: PUSH
78190: LD_VAR 0 2
78194: ARRAY
78195: IFFALSE 78231
// begin MC_Reset ( i , 125 ) ;
78197: LD_VAR 0 2
78201: PPUSH
78202: LD_INT 125
78204: PPUSH
78205: CALL 61542 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78209: LD_ADDR_EXP 97
78213: PUSH
78214: LD_EXP 97
78218: PPUSH
78219: LD_VAR 0 2
78223: PPUSH
78224: EMPTY
78225: PPUSH
78226: CALL_OW 1
78230: ST_TO_ADDR
// end ; continue ;
78231: GO 77989
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78233: LD_EXP 96
78237: PUSH
78238: LD_VAR 0 2
78242: ARRAY
78243: PUSH
78244: LD_INT 1
78246: ARRAY
78247: PUSH
78248: LD_INT 1
78250: ARRAY
78251: PPUSH
78252: LD_EXP 96
78256: PUSH
78257: LD_VAR 0 2
78261: ARRAY
78262: PUSH
78263: LD_INT 1
78265: ARRAY
78266: PUSH
78267: LD_INT 2
78269: ARRAY
78270: PPUSH
78271: LD_EXP 85
78275: PUSH
78276: LD_VAR 0 2
78280: ARRAY
78281: PPUSH
78282: CALL_OW 440
78286: IFFALSE 78329
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78288: LD_ADDR_EXP 96
78292: PUSH
78293: LD_EXP 96
78297: PPUSH
78298: LD_VAR 0 2
78302: PPUSH
78303: LD_EXP 96
78307: PUSH
78308: LD_VAR 0 2
78312: ARRAY
78313: PPUSH
78314: LD_INT 1
78316: PPUSH
78317: CALL_OW 3
78321: PPUSH
78322: CALL_OW 1
78326: ST_TO_ADDR
78327: GO 78576
// begin if not mc_deposits_finder [ i ] then
78329: LD_EXP 97
78333: PUSH
78334: LD_VAR 0 2
78338: ARRAY
78339: NOT
78340: IFFALSE 78392
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78342: LD_ADDR_EXP 97
78346: PUSH
78347: LD_EXP 97
78351: PPUSH
78352: LD_VAR 0 2
78356: PPUSH
78357: LD_VAR 0 3
78361: PUSH
78362: LD_INT 1
78364: ARRAY
78365: PUSH
78366: EMPTY
78367: LIST
78368: PPUSH
78369: CALL_OW 1
78373: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78374: LD_VAR 0 3
78378: PUSH
78379: LD_INT 1
78381: ARRAY
78382: PPUSH
78383: LD_INT 125
78385: PPUSH
78386: CALL_OW 109
// end else
78390: GO 78576
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78392: LD_EXP 97
78396: PUSH
78397: LD_VAR 0 2
78401: ARRAY
78402: PUSH
78403: LD_INT 1
78405: ARRAY
78406: PPUSH
78407: CALL_OW 310
78411: IFFALSE 78434
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78413: LD_EXP 97
78417: PUSH
78418: LD_VAR 0 2
78422: ARRAY
78423: PUSH
78424: LD_INT 1
78426: ARRAY
78427: PPUSH
78428: CALL_OW 122
78432: GO 78576
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78434: LD_EXP 97
78438: PUSH
78439: LD_VAR 0 2
78443: ARRAY
78444: PUSH
78445: LD_INT 1
78447: ARRAY
78448: PPUSH
78449: CALL_OW 314
78453: NOT
78454: PUSH
78455: LD_EXP 97
78459: PUSH
78460: LD_VAR 0 2
78464: ARRAY
78465: PUSH
78466: LD_INT 1
78468: ARRAY
78469: PPUSH
78470: LD_EXP 96
78474: PUSH
78475: LD_VAR 0 2
78479: ARRAY
78480: PUSH
78481: LD_INT 1
78483: ARRAY
78484: PUSH
78485: LD_INT 1
78487: ARRAY
78488: PPUSH
78489: LD_EXP 96
78493: PUSH
78494: LD_VAR 0 2
78498: ARRAY
78499: PUSH
78500: LD_INT 1
78502: ARRAY
78503: PUSH
78504: LD_INT 2
78506: ARRAY
78507: PPUSH
78508: CALL_OW 297
78512: PUSH
78513: LD_INT 6
78515: GREATER
78516: AND
78517: IFFALSE 78576
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78519: LD_EXP 97
78523: PUSH
78524: LD_VAR 0 2
78528: ARRAY
78529: PUSH
78530: LD_INT 1
78532: ARRAY
78533: PPUSH
78534: LD_EXP 96
78538: PUSH
78539: LD_VAR 0 2
78543: ARRAY
78544: PUSH
78545: LD_INT 1
78547: ARRAY
78548: PUSH
78549: LD_INT 1
78551: ARRAY
78552: PPUSH
78553: LD_EXP 96
78557: PUSH
78558: LD_VAR 0 2
78562: ARRAY
78563: PUSH
78564: LD_INT 1
78566: ARRAY
78567: PUSH
78568: LD_INT 2
78570: ARRAY
78571: PPUSH
78572: CALL_OW 111
// end ; end ; end ;
78576: GO 77989
78578: POP
78579: POP
// end ;
78580: LD_VAR 0 1
78584: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78585: LD_INT 0
78587: PPUSH
78588: PPUSH
78589: PPUSH
78590: PPUSH
78591: PPUSH
78592: PPUSH
78593: PPUSH
78594: PPUSH
78595: PPUSH
78596: PPUSH
78597: PPUSH
// if not mc_bases then
78598: LD_EXP 59
78602: NOT
78603: IFFALSE 78607
// exit ;
78605: GO 79547
// for i = 1 to mc_bases do
78607: LD_ADDR_VAR 0 2
78611: PUSH
78612: DOUBLE
78613: LD_INT 1
78615: DEC
78616: ST_TO_ADDR
78617: LD_EXP 59
78621: PUSH
78622: FOR_TO
78623: IFFALSE 79545
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78625: LD_EXP 59
78629: PUSH
78630: LD_VAR 0 2
78634: ARRAY
78635: NOT
78636: PUSH
78637: LD_EXP 82
78641: PUSH
78642: LD_VAR 0 2
78646: ARRAY
78647: OR
78648: IFFALSE 78652
// continue ;
78650: GO 78622
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78652: LD_ADDR_VAR 0 7
78656: PUSH
78657: LD_EXP 59
78661: PUSH
78662: LD_VAR 0 2
78666: ARRAY
78667: PUSH
78668: LD_INT 1
78670: ARRAY
78671: PPUSH
78672: CALL_OW 248
78676: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78677: LD_VAR 0 7
78681: PUSH
78682: LD_INT 3
78684: EQUAL
78685: PUSH
78686: LD_EXP 78
78690: PUSH
78691: LD_VAR 0 2
78695: ARRAY
78696: PUSH
78697: LD_EXP 81
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: UNION
78708: PPUSH
78709: LD_INT 33
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PPUSH
78719: CALL_OW 72
78723: NOT
78724: OR
78725: IFFALSE 78729
// continue ;
78727: GO 78622
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78729: LD_ADDR_VAR 0 9
78733: PUSH
78734: LD_EXP 59
78738: PUSH
78739: LD_VAR 0 2
78743: ARRAY
78744: PPUSH
78745: LD_INT 30
78747: PUSH
78748: LD_INT 36
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PPUSH
78755: CALL_OW 72
78759: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78760: LD_ADDR_VAR 0 10
78764: PUSH
78765: LD_EXP 78
78769: PUSH
78770: LD_VAR 0 2
78774: ARRAY
78775: PPUSH
78776: LD_INT 34
78778: PUSH
78779: LD_INT 31
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PPUSH
78786: CALL_OW 72
78790: ST_TO_ADDR
// if not cts and not mcts then
78791: LD_VAR 0 9
78795: NOT
78796: PUSH
78797: LD_VAR 0 10
78801: NOT
78802: AND
78803: IFFALSE 78807
// continue ;
78805: GO 78622
// x := cts ;
78807: LD_ADDR_VAR 0 11
78811: PUSH
78812: LD_VAR 0 9
78816: ST_TO_ADDR
// if not x then
78817: LD_VAR 0 11
78821: NOT
78822: IFFALSE 78834
// x := mcts ;
78824: LD_ADDR_VAR 0 11
78828: PUSH
78829: LD_VAR 0 10
78833: ST_TO_ADDR
// if not x then
78834: LD_VAR 0 11
78838: NOT
78839: IFFALSE 78843
// continue ;
78841: GO 78622
// if mc_remote_driver [ i ] then
78843: LD_EXP 99
78847: PUSH
78848: LD_VAR 0 2
78852: ARRAY
78853: IFFALSE 79240
// for j in mc_remote_driver [ i ] do
78855: LD_ADDR_VAR 0 3
78859: PUSH
78860: LD_EXP 99
78864: PUSH
78865: LD_VAR 0 2
78869: ARRAY
78870: PUSH
78871: FOR_IN
78872: IFFALSE 79238
// begin if GetClass ( j ) <> 3 then
78874: LD_VAR 0 3
78878: PPUSH
78879: CALL_OW 257
78883: PUSH
78884: LD_INT 3
78886: NONEQUAL
78887: IFFALSE 78940
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78889: LD_ADDR_EXP 99
78893: PUSH
78894: LD_EXP 99
78898: PPUSH
78899: LD_VAR 0 2
78903: PPUSH
78904: LD_EXP 99
78908: PUSH
78909: LD_VAR 0 2
78913: ARRAY
78914: PUSH
78915: LD_VAR 0 3
78919: DIFF
78920: PPUSH
78921: CALL_OW 1
78925: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78926: LD_VAR 0 3
78930: PPUSH
78931: LD_INT 0
78933: PPUSH
78934: CALL_OW 109
// continue ;
78938: GO 78871
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78940: LD_EXP 78
78944: PUSH
78945: LD_VAR 0 2
78949: ARRAY
78950: PPUSH
78951: LD_INT 34
78953: PUSH
78954: LD_INT 31
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 58
78963: PUSH
78964: EMPTY
78965: LIST
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PPUSH
78971: CALL_OW 72
78975: PUSH
78976: LD_VAR 0 3
78980: PPUSH
78981: CALL 54887 0 1
78985: NOT
78986: AND
78987: IFFALSE 79058
// begin if IsInUnit ( j ) then
78989: LD_VAR 0 3
78993: PPUSH
78994: CALL_OW 310
78998: IFFALSE 79009
// ComExitBuilding ( j ) ;
79000: LD_VAR 0 3
79004: PPUSH
79005: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79009: LD_VAR 0 3
79013: PPUSH
79014: LD_EXP 78
79018: PUSH
79019: LD_VAR 0 2
79023: ARRAY
79024: PPUSH
79025: LD_INT 34
79027: PUSH
79028: LD_INT 31
79030: PUSH
79031: EMPTY
79032: LIST
79033: LIST
79034: PUSH
79035: LD_INT 58
79037: PUSH
79038: EMPTY
79039: LIST
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PPUSH
79045: CALL_OW 72
79049: PUSH
79050: LD_INT 1
79052: ARRAY
79053: PPUSH
79054: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79058: LD_VAR 0 3
79062: PPUSH
79063: CALL_OW 310
79067: NOT
79068: PUSH
79069: LD_VAR 0 3
79073: PPUSH
79074: CALL_OW 310
79078: PPUSH
79079: CALL_OW 266
79083: PUSH
79084: LD_INT 36
79086: NONEQUAL
79087: PUSH
79088: LD_VAR 0 3
79092: PPUSH
79093: CALL 54887 0 1
79097: NOT
79098: AND
79099: OR
79100: IFFALSE 79236
// begin if IsInUnit ( j ) then
79102: LD_VAR 0 3
79106: PPUSH
79107: CALL_OW 310
79111: IFFALSE 79122
// ComExitBuilding ( j ) ;
79113: LD_VAR 0 3
79117: PPUSH
79118: CALL_OW 122
// ct := 0 ;
79122: LD_ADDR_VAR 0 8
79126: PUSH
79127: LD_INT 0
79129: ST_TO_ADDR
// for k in x do
79130: LD_ADDR_VAR 0 4
79134: PUSH
79135: LD_VAR 0 11
79139: PUSH
79140: FOR_IN
79141: IFFALSE 79214
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79143: LD_VAR 0 4
79147: PPUSH
79148: CALL_OW 264
79152: PUSH
79153: LD_INT 31
79155: EQUAL
79156: PUSH
79157: LD_VAR 0 4
79161: PPUSH
79162: CALL_OW 311
79166: NOT
79167: AND
79168: PUSH
79169: LD_VAR 0 4
79173: PPUSH
79174: CALL_OW 266
79178: PUSH
79179: LD_INT 36
79181: EQUAL
79182: PUSH
79183: LD_VAR 0 4
79187: PPUSH
79188: CALL_OW 313
79192: PUSH
79193: LD_INT 3
79195: LESS
79196: AND
79197: OR
79198: IFFALSE 79212
// begin ct := k ;
79200: LD_ADDR_VAR 0 8
79204: PUSH
79205: LD_VAR 0 4
79209: ST_TO_ADDR
// break ;
79210: GO 79214
// end ;
79212: GO 79140
79214: POP
79215: POP
// if ct then
79216: LD_VAR 0 8
79220: IFFALSE 79236
// ComEnterUnit ( j , ct ) ;
79222: LD_VAR 0 3
79226: PPUSH
79227: LD_VAR 0 8
79231: PPUSH
79232: CALL_OW 120
// end ; end ;
79236: GO 78871
79238: POP
79239: POP
// places := 0 ;
79240: LD_ADDR_VAR 0 5
79244: PUSH
79245: LD_INT 0
79247: ST_TO_ADDR
// for j = 1 to x do
79248: LD_ADDR_VAR 0 3
79252: PUSH
79253: DOUBLE
79254: LD_INT 1
79256: DEC
79257: ST_TO_ADDR
79258: LD_VAR 0 11
79262: PUSH
79263: FOR_TO
79264: IFFALSE 79340
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79266: LD_VAR 0 11
79270: PUSH
79271: LD_VAR 0 3
79275: ARRAY
79276: PPUSH
79277: CALL_OW 264
79281: PUSH
79282: LD_INT 31
79284: EQUAL
79285: IFFALSE 79303
// places := places + 1 else
79287: LD_ADDR_VAR 0 5
79291: PUSH
79292: LD_VAR 0 5
79296: PUSH
79297: LD_INT 1
79299: PLUS
79300: ST_TO_ADDR
79301: GO 79338
// if GetBType ( x [ j ] ) = b_control_tower then
79303: LD_VAR 0 11
79307: PUSH
79308: LD_VAR 0 3
79312: ARRAY
79313: PPUSH
79314: CALL_OW 266
79318: PUSH
79319: LD_INT 36
79321: EQUAL
79322: IFFALSE 79338
// places := places + 3 ;
79324: LD_ADDR_VAR 0 5
79328: PUSH
79329: LD_VAR 0 5
79333: PUSH
79334: LD_INT 3
79336: PLUS
79337: ST_TO_ADDR
79338: GO 79263
79340: POP
79341: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79342: LD_VAR 0 5
79346: PUSH
79347: LD_INT 0
79349: EQUAL
79350: PUSH
79351: LD_VAR 0 5
79355: PUSH
79356: LD_EXP 99
79360: PUSH
79361: LD_VAR 0 2
79365: ARRAY
79366: LESSEQUAL
79367: OR
79368: IFFALSE 79372
// continue ;
79370: GO 78622
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79372: LD_ADDR_VAR 0 6
79376: PUSH
79377: LD_EXP 59
79381: PUSH
79382: LD_VAR 0 2
79386: ARRAY
79387: PPUSH
79388: LD_INT 25
79390: PUSH
79391: LD_INT 3
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PPUSH
79398: CALL_OW 72
79402: PUSH
79403: LD_EXP 99
79407: PUSH
79408: LD_VAR 0 2
79412: ARRAY
79413: DIFF
79414: PPUSH
79415: LD_INT 3
79417: PPUSH
79418: CALL 55787 0 2
79422: ST_TO_ADDR
// for j in tmp do
79423: LD_ADDR_VAR 0 3
79427: PUSH
79428: LD_VAR 0 6
79432: PUSH
79433: FOR_IN
79434: IFFALSE 79469
// if GetTag ( j ) > 0 then
79436: LD_VAR 0 3
79440: PPUSH
79441: CALL_OW 110
79445: PUSH
79446: LD_INT 0
79448: GREATER
79449: IFFALSE 79467
// tmp := tmp diff j ;
79451: LD_ADDR_VAR 0 6
79455: PUSH
79456: LD_VAR 0 6
79460: PUSH
79461: LD_VAR 0 3
79465: DIFF
79466: ST_TO_ADDR
79467: GO 79433
79469: POP
79470: POP
// if not tmp then
79471: LD_VAR 0 6
79475: NOT
79476: IFFALSE 79480
// continue ;
79478: GO 78622
// if places then
79480: LD_VAR 0 5
79484: IFFALSE 79543
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79486: LD_ADDR_EXP 99
79490: PUSH
79491: LD_EXP 99
79495: PPUSH
79496: LD_VAR 0 2
79500: PPUSH
79501: LD_EXP 99
79505: PUSH
79506: LD_VAR 0 2
79510: ARRAY
79511: PUSH
79512: LD_VAR 0 6
79516: PUSH
79517: LD_INT 1
79519: ARRAY
79520: UNION
79521: PPUSH
79522: CALL_OW 1
79526: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79527: LD_VAR 0 6
79531: PUSH
79532: LD_INT 1
79534: ARRAY
79535: PPUSH
79536: LD_INT 126
79538: PPUSH
79539: CALL_OW 109
// end ; end ;
79543: GO 78622
79545: POP
79546: POP
// end ;
79547: LD_VAR 0 1
79551: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79552: LD_INT 0
79554: PPUSH
79555: PPUSH
79556: PPUSH
79557: PPUSH
79558: PPUSH
79559: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79560: LD_VAR 0 1
79564: NOT
79565: PUSH
79566: LD_VAR 0 2
79570: NOT
79571: OR
79572: PUSH
79573: LD_VAR 0 3
79577: NOT
79578: OR
79579: PUSH
79580: LD_VAR 0 4
79584: PUSH
79585: LD_INT 1
79587: PUSH
79588: LD_INT 2
79590: PUSH
79591: LD_INT 3
79593: PUSH
79594: LD_INT 4
79596: PUSH
79597: LD_INT 5
79599: PUSH
79600: LD_INT 8
79602: PUSH
79603: LD_INT 9
79605: PUSH
79606: LD_INT 15
79608: PUSH
79609: LD_INT 16
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: IN
79623: NOT
79624: OR
79625: IFFALSE 79629
// exit ;
79627: GO 80529
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79629: LD_ADDR_VAR 0 2
79633: PUSH
79634: LD_VAR 0 2
79638: PPUSH
79639: LD_INT 21
79641: PUSH
79642: LD_INT 3
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 24
79651: PUSH
79652: LD_INT 250
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PPUSH
79663: CALL_OW 72
79667: ST_TO_ADDR
// case class of 1 , 15 :
79668: LD_VAR 0 4
79672: PUSH
79673: LD_INT 1
79675: DOUBLE
79676: EQUAL
79677: IFTRUE 79687
79679: LD_INT 15
79681: DOUBLE
79682: EQUAL
79683: IFTRUE 79687
79685: GO 79772
79687: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79688: LD_ADDR_VAR 0 8
79692: PUSH
79693: LD_VAR 0 2
79697: PPUSH
79698: LD_INT 2
79700: PUSH
79701: LD_INT 30
79703: PUSH
79704: LD_INT 32
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 30
79713: PUSH
79714: LD_INT 31
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: LIST
79725: PPUSH
79726: CALL_OW 72
79730: PUSH
79731: LD_VAR 0 2
79735: PPUSH
79736: LD_INT 2
79738: PUSH
79739: LD_INT 30
79741: PUSH
79742: LD_INT 4
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 30
79751: PUSH
79752: LD_INT 5
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: LIST
79763: PPUSH
79764: CALL_OW 72
79768: ADD
79769: ST_TO_ADDR
79770: GO 80018
79772: LD_INT 2
79774: DOUBLE
79775: EQUAL
79776: IFTRUE 79786
79778: LD_INT 16
79780: DOUBLE
79781: EQUAL
79782: IFTRUE 79786
79784: GO 79832
79786: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79787: LD_ADDR_VAR 0 8
79791: PUSH
79792: LD_VAR 0 2
79796: PPUSH
79797: LD_INT 2
79799: PUSH
79800: LD_INT 30
79802: PUSH
79803: LD_INT 0
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 30
79812: PUSH
79813: LD_INT 1
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: LIST
79824: PPUSH
79825: CALL_OW 72
79829: ST_TO_ADDR
79830: GO 80018
79832: LD_INT 3
79834: DOUBLE
79835: EQUAL
79836: IFTRUE 79840
79838: GO 79886
79840: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79841: LD_ADDR_VAR 0 8
79845: PUSH
79846: LD_VAR 0 2
79850: PPUSH
79851: LD_INT 2
79853: PUSH
79854: LD_INT 30
79856: PUSH
79857: LD_INT 2
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 30
79866: PUSH
79867: LD_INT 3
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: LIST
79878: PPUSH
79879: CALL_OW 72
79883: ST_TO_ADDR
79884: GO 80018
79886: LD_INT 4
79888: DOUBLE
79889: EQUAL
79890: IFTRUE 79894
79892: GO 79951
79894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79895: LD_ADDR_VAR 0 8
79899: PUSH
79900: LD_VAR 0 2
79904: PPUSH
79905: LD_INT 2
79907: PUSH
79908: LD_INT 30
79910: PUSH
79911: LD_INT 6
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 30
79920: PUSH
79921: LD_INT 7
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 30
79930: PUSH
79931: LD_INT 8
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: PPUSH
79944: CALL_OW 72
79948: ST_TO_ADDR
79949: GO 80018
79951: LD_INT 5
79953: DOUBLE
79954: EQUAL
79955: IFTRUE 79971
79957: LD_INT 8
79959: DOUBLE
79960: EQUAL
79961: IFTRUE 79971
79963: LD_INT 9
79965: DOUBLE
79966: EQUAL
79967: IFTRUE 79971
79969: GO 80017
79971: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79972: LD_ADDR_VAR 0 8
79976: PUSH
79977: LD_VAR 0 2
79981: PPUSH
79982: LD_INT 2
79984: PUSH
79985: LD_INT 30
79987: PUSH
79988: LD_INT 4
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 30
79997: PUSH
79998: LD_INT 5
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: LIST
80009: PPUSH
80010: CALL_OW 72
80014: ST_TO_ADDR
80015: GO 80018
80017: POP
// if not tmp then
80018: LD_VAR 0 8
80022: NOT
80023: IFFALSE 80027
// exit ;
80025: GO 80529
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80027: LD_VAR 0 4
80031: PUSH
80032: LD_INT 1
80034: PUSH
80035: LD_INT 15
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: IN
80042: PUSH
80043: LD_EXP 68
80047: PUSH
80048: LD_VAR 0 1
80052: ARRAY
80053: AND
80054: IFFALSE 80210
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80056: LD_ADDR_VAR 0 9
80060: PUSH
80061: LD_EXP 68
80065: PUSH
80066: LD_VAR 0 1
80070: ARRAY
80071: PUSH
80072: LD_INT 1
80074: ARRAY
80075: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80076: LD_VAR 0 9
80080: PUSH
80081: LD_EXP 69
80085: PUSH
80086: LD_VAR 0 1
80090: ARRAY
80091: IN
80092: NOT
80093: IFFALSE 80208
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80095: LD_ADDR_EXP 69
80099: PUSH
80100: LD_EXP 69
80104: PPUSH
80105: LD_VAR 0 1
80109: PUSH
80110: LD_EXP 69
80114: PUSH
80115: LD_VAR 0 1
80119: ARRAY
80120: PUSH
80121: LD_INT 1
80123: PLUS
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PPUSH
80129: LD_VAR 0 9
80133: PPUSH
80134: CALL 21529 0 3
80138: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80139: LD_ADDR_EXP 68
80143: PUSH
80144: LD_EXP 68
80148: PPUSH
80149: LD_VAR 0 1
80153: PPUSH
80154: LD_EXP 68
80158: PUSH
80159: LD_VAR 0 1
80163: ARRAY
80164: PUSH
80165: LD_VAR 0 9
80169: DIFF
80170: PPUSH
80171: CALL_OW 1
80175: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80176: LD_VAR 0 3
80180: PPUSH
80181: LD_EXP 69
80185: PUSH
80186: LD_VAR 0 1
80190: ARRAY
80191: PUSH
80192: LD_EXP 69
80196: PUSH
80197: LD_VAR 0 1
80201: ARRAY
80202: ARRAY
80203: PPUSH
80204: CALL_OW 120
// end ; exit ;
80208: GO 80529
// end ; if tmp > 1 then
80210: LD_VAR 0 8
80214: PUSH
80215: LD_INT 1
80217: GREATER
80218: IFFALSE 80322
// for i = 2 to tmp do
80220: LD_ADDR_VAR 0 6
80224: PUSH
80225: DOUBLE
80226: LD_INT 2
80228: DEC
80229: ST_TO_ADDR
80230: LD_VAR 0 8
80234: PUSH
80235: FOR_TO
80236: IFFALSE 80320
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80238: LD_VAR 0 8
80242: PUSH
80243: LD_VAR 0 6
80247: ARRAY
80248: PPUSH
80249: CALL_OW 461
80253: PUSH
80254: LD_INT 6
80256: EQUAL
80257: IFFALSE 80318
// begin x := tmp [ i ] ;
80259: LD_ADDR_VAR 0 9
80263: PUSH
80264: LD_VAR 0 8
80268: PUSH
80269: LD_VAR 0 6
80273: ARRAY
80274: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80275: LD_ADDR_VAR 0 8
80279: PUSH
80280: LD_VAR 0 8
80284: PPUSH
80285: LD_VAR 0 6
80289: PPUSH
80290: CALL_OW 3
80294: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80295: LD_ADDR_VAR 0 8
80299: PUSH
80300: LD_VAR 0 8
80304: PPUSH
80305: LD_INT 1
80307: PPUSH
80308: LD_VAR 0 9
80312: PPUSH
80313: CALL_OW 2
80317: ST_TO_ADDR
// end ;
80318: GO 80235
80320: POP
80321: POP
// for i in tmp do
80322: LD_ADDR_VAR 0 6
80326: PUSH
80327: LD_VAR 0 8
80331: PUSH
80332: FOR_IN
80333: IFFALSE 80402
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80335: LD_VAR 0 6
80339: PPUSH
80340: CALL_OW 313
80344: PUSH
80345: LD_INT 6
80347: LESS
80348: PUSH
80349: LD_VAR 0 6
80353: PPUSH
80354: CALL_OW 266
80358: PUSH
80359: LD_INT 31
80361: PUSH
80362: LD_INT 32
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: IN
80369: NOT
80370: AND
80371: PUSH
80372: LD_VAR 0 6
80376: PPUSH
80377: CALL_OW 313
80381: PUSH
80382: LD_INT 0
80384: EQUAL
80385: OR
80386: IFFALSE 80400
// begin j := i ;
80388: LD_ADDR_VAR 0 7
80392: PUSH
80393: LD_VAR 0 6
80397: ST_TO_ADDR
// break ;
80398: GO 80402
// end ; end ;
80400: GO 80332
80402: POP
80403: POP
// if j then
80404: LD_VAR 0 7
80408: IFFALSE 80426
// ComEnterUnit ( unit , j ) else
80410: LD_VAR 0 3
80414: PPUSH
80415: LD_VAR 0 7
80419: PPUSH
80420: CALL_OW 120
80424: GO 80529
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80426: LD_ADDR_VAR 0 10
80430: PUSH
80431: LD_VAR 0 2
80435: PPUSH
80436: LD_INT 2
80438: PUSH
80439: LD_INT 30
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 30
80451: PUSH
80452: LD_INT 1
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: LIST
80463: PPUSH
80464: CALL_OW 72
80468: ST_TO_ADDR
// if depot then
80469: LD_VAR 0 10
80473: IFFALSE 80529
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80475: LD_ADDR_VAR 0 10
80479: PUSH
80480: LD_VAR 0 10
80484: PPUSH
80485: LD_VAR 0 3
80489: PPUSH
80490: CALL_OW 74
80494: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80495: LD_VAR 0 3
80499: PPUSH
80500: LD_VAR 0 10
80504: PPUSH
80505: CALL_OW 296
80509: PUSH
80510: LD_INT 10
80512: GREATER
80513: IFFALSE 80529
// ComStandNearbyBuilding ( unit , depot ) ;
80515: LD_VAR 0 3
80519: PPUSH
80520: LD_VAR 0 10
80524: PPUSH
80525: CALL 15732 0 2
// end ; end ; end ;
80529: LD_VAR 0 5
80533: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80534: LD_INT 0
80536: PPUSH
80537: PPUSH
80538: PPUSH
80539: PPUSH
// if not mc_bases then
80540: LD_EXP 59
80544: NOT
80545: IFFALSE 80549
// exit ;
80547: GO 80788
// for i = 1 to mc_bases do
80549: LD_ADDR_VAR 0 2
80553: PUSH
80554: DOUBLE
80555: LD_INT 1
80557: DEC
80558: ST_TO_ADDR
80559: LD_EXP 59
80563: PUSH
80564: FOR_TO
80565: IFFALSE 80786
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80567: LD_ADDR_VAR 0 4
80571: PUSH
80572: LD_EXP 59
80576: PUSH
80577: LD_VAR 0 2
80581: ARRAY
80582: PPUSH
80583: LD_INT 21
80585: PUSH
80586: LD_INT 1
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PPUSH
80593: CALL_OW 72
80597: PUSH
80598: LD_EXP 88
80602: PUSH
80603: LD_VAR 0 2
80607: ARRAY
80608: UNION
80609: ST_TO_ADDR
// if not tmp then
80610: LD_VAR 0 4
80614: NOT
80615: IFFALSE 80619
// continue ;
80617: GO 80564
// for j in tmp do
80619: LD_ADDR_VAR 0 3
80623: PUSH
80624: LD_VAR 0 4
80628: PUSH
80629: FOR_IN
80630: IFFALSE 80782
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80632: LD_VAR 0 3
80636: PPUSH
80637: CALL_OW 110
80641: NOT
80642: PUSH
80643: LD_VAR 0 3
80647: PPUSH
80648: CALL_OW 314
80652: NOT
80653: AND
80654: PUSH
80655: LD_VAR 0 3
80659: PPUSH
80660: CALL_OW 311
80664: NOT
80665: AND
80666: PUSH
80667: LD_VAR 0 3
80671: PPUSH
80672: CALL_OW 310
80676: NOT
80677: AND
80678: PUSH
80679: LD_VAR 0 3
80683: PUSH
80684: LD_EXP 62
80688: PUSH
80689: LD_VAR 0 2
80693: ARRAY
80694: PUSH
80695: LD_INT 1
80697: ARRAY
80698: IN
80699: NOT
80700: AND
80701: PUSH
80702: LD_VAR 0 3
80706: PUSH
80707: LD_EXP 62
80711: PUSH
80712: LD_VAR 0 2
80716: ARRAY
80717: PUSH
80718: LD_INT 2
80720: ARRAY
80721: IN
80722: NOT
80723: AND
80724: PUSH
80725: LD_VAR 0 3
80729: PUSH
80730: LD_EXP 71
80734: PUSH
80735: LD_VAR 0 2
80739: ARRAY
80740: IN
80741: NOT
80742: AND
80743: IFFALSE 80780
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80745: LD_VAR 0 2
80749: PPUSH
80750: LD_EXP 59
80754: PUSH
80755: LD_VAR 0 2
80759: ARRAY
80760: PPUSH
80761: LD_VAR 0 3
80765: PPUSH
80766: LD_VAR 0 3
80770: PPUSH
80771: CALL_OW 257
80775: PPUSH
80776: CALL 79552 0 4
// end ;
80780: GO 80629
80782: POP
80783: POP
// end ;
80784: GO 80564
80786: POP
80787: POP
// end ;
80788: LD_VAR 0 1
80792: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80793: LD_INT 0
80795: PPUSH
80796: PPUSH
80797: PPUSH
80798: PPUSH
80799: PPUSH
80800: PPUSH
// if not mc_bases [ base ] then
80801: LD_EXP 59
80805: PUSH
80806: LD_VAR 0 1
80810: ARRAY
80811: NOT
80812: IFFALSE 80816
// exit ;
80814: GO 80998
// tmp := [ ] ;
80816: LD_ADDR_VAR 0 6
80820: PUSH
80821: EMPTY
80822: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80823: LD_ADDR_VAR 0 7
80827: PUSH
80828: LD_VAR 0 3
80832: PPUSH
80833: LD_INT 0
80835: PPUSH
80836: CALL_OW 517
80840: ST_TO_ADDR
// if not list then
80841: LD_VAR 0 7
80845: NOT
80846: IFFALSE 80850
// exit ;
80848: GO 80998
// for i = 1 to amount do
80850: LD_ADDR_VAR 0 5
80854: PUSH
80855: DOUBLE
80856: LD_INT 1
80858: DEC
80859: ST_TO_ADDR
80860: LD_VAR 0 2
80864: PUSH
80865: FOR_TO
80866: IFFALSE 80946
// begin x := rand ( 1 , list [ 1 ] ) ;
80868: LD_ADDR_VAR 0 8
80872: PUSH
80873: LD_INT 1
80875: PPUSH
80876: LD_VAR 0 7
80880: PUSH
80881: LD_INT 1
80883: ARRAY
80884: PPUSH
80885: CALL_OW 12
80889: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80890: LD_ADDR_VAR 0 6
80894: PUSH
80895: LD_VAR 0 6
80899: PPUSH
80900: LD_VAR 0 5
80904: PPUSH
80905: LD_VAR 0 7
80909: PUSH
80910: LD_INT 1
80912: ARRAY
80913: PUSH
80914: LD_VAR 0 8
80918: ARRAY
80919: PUSH
80920: LD_VAR 0 7
80924: PUSH
80925: LD_INT 2
80927: ARRAY
80928: PUSH
80929: LD_VAR 0 8
80933: ARRAY
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PPUSH
80939: CALL_OW 1
80943: ST_TO_ADDR
// end ;
80944: GO 80865
80946: POP
80947: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80948: LD_ADDR_EXP 72
80952: PUSH
80953: LD_EXP 72
80957: PPUSH
80958: LD_VAR 0 1
80962: PPUSH
80963: LD_VAR 0 6
80967: PPUSH
80968: CALL_OW 1
80972: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80973: LD_ADDR_EXP 74
80977: PUSH
80978: LD_EXP 74
80982: PPUSH
80983: LD_VAR 0 1
80987: PPUSH
80988: LD_VAR 0 3
80992: PPUSH
80993: CALL_OW 1
80997: ST_TO_ADDR
// end ;
80998: LD_VAR 0 4
81002: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81003: LD_INT 0
81005: PPUSH
// if not mc_bases [ base ] then
81006: LD_EXP 59
81010: PUSH
81011: LD_VAR 0 1
81015: ARRAY
81016: NOT
81017: IFFALSE 81021
// exit ;
81019: GO 81046
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81021: LD_ADDR_EXP 64
81025: PUSH
81026: LD_EXP 64
81030: PPUSH
81031: LD_VAR 0 1
81035: PPUSH
81036: LD_VAR 0 2
81040: PPUSH
81041: CALL_OW 1
81045: ST_TO_ADDR
// end ;
81046: LD_VAR 0 3
81050: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81051: LD_INT 0
81053: PPUSH
// if not mc_bases [ base ] then
81054: LD_EXP 59
81058: PUSH
81059: LD_VAR 0 1
81063: ARRAY
81064: NOT
81065: IFFALSE 81069
// exit ;
81067: GO 81106
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81069: LD_ADDR_EXP 64
81073: PUSH
81074: LD_EXP 64
81078: PPUSH
81079: LD_VAR 0 1
81083: PPUSH
81084: LD_EXP 64
81088: PUSH
81089: LD_VAR 0 1
81093: ARRAY
81094: PUSH
81095: LD_VAR 0 2
81099: UNION
81100: PPUSH
81101: CALL_OW 1
81105: ST_TO_ADDR
// end ;
81106: LD_VAR 0 3
81110: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81111: LD_INT 0
81113: PPUSH
// if not mc_bases [ base ] then
81114: LD_EXP 59
81118: PUSH
81119: LD_VAR 0 1
81123: ARRAY
81124: NOT
81125: IFFALSE 81129
// exit ;
81127: GO 81154
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81129: LD_ADDR_EXP 80
81133: PUSH
81134: LD_EXP 80
81138: PPUSH
81139: LD_VAR 0 1
81143: PPUSH
81144: LD_VAR 0 2
81148: PPUSH
81149: CALL_OW 1
81153: ST_TO_ADDR
// end ;
81154: LD_VAR 0 3
81158: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81159: LD_INT 0
81161: PPUSH
// if not mc_bases [ base ] then
81162: LD_EXP 59
81166: PUSH
81167: LD_VAR 0 1
81171: ARRAY
81172: NOT
81173: IFFALSE 81177
// exit ;
81175: GO 81214
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81177: LD_ADDR_EXP 80
81181: PUSH
81182: LD_EXP 80
81186: PPUSH
81187: LD_VAR 0 1
81191: PPUSH
81192: LD_EXP 80
81196: PUSH
81197: LD_VAR 0 1
81201: ARRAY
81202: PUSH
81203: LD_VAR 0 2
81207: ADD
81208: PPUSH
81209: CALL_OW 1
81213: ST_TO_ADDR
// end ;
81214: LD_VAR 0 3
81218: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81219: LD_INT 0
81221: PPUSH
// if not mc_bases [ base ] then
81222: LD_EXP 59
81226: PUSH
81227: LD_VAR 0 1
81231: ARRAY
81232: NOT
81233: IFFALSE 81237
// exit ;
81235: GO 81291
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81237: LD_ADDR_EXP 81
81241: PUSH
81242: LD_EXP 81
81246: PPUSH
81247: LD_VAR 0 1
81251: PPUSH
81252: LD_VAR 0 2
81256: PPUSH
81257: CALL_OW 1
81261: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81262: LD_ADDR_EXP 70
81266: PUSH
81267: LD_EXP 70
81271: PPUSH
81272: LD_VAR 0 1
81276: PPUSH
81277: LD_VAR 0 2
81281: PUSH
81282: LD_INT 0
81284: PLUS
81285: PPUSH
81286: CALL_OW 1
81290: ST_TO_ADDR
// end ;
81291: LD_VAR 0 3
81295: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81296: LD_INT 0
81298: PPUSH
// if not mc_bases [ base ] then
81299: LD_EXP 59
81303: PUSH
81304: LD_VAR 0 1
81308: ARRAY
81309: NOT
81310: IFFALSE 81314
// exit ;
81312: GO 81339
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81314: LD_ADDR_EXP 70
81318: PUSH
81319: LD_EXP 70
81323: PPUSH
81324: LD_VAR 0 1
81328: PPUSH
81329: LD_VAR 0 2
81333: PPUSH
81334: CALL_OW 1
81338: ST_TO_ADDR
// end ;
81339: LD_VAR 0 3
81343: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81344: LD_INT 0
81346: PPUSH
81347: PPUSH
81348: PPUSH
81349: PPUSH
// if not mc_bases [ base ] then
81350: LD_EXP 59
81354: PUSH
81355: LD_VAR 0 1
81359: ARRAY
81360: NOT
81361: IFFALSE 81365
// exit ;
81363: GO 81430
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81365: LD_ADDR_EXP 79
81369: PUSH
81370: LD_EXP 79
81374: PPUSH
81375: LD_VAR 0 1
81379: PUSH
81380: LD_EXP 79
81384: PUSH
81385: LD_VAR 0 1
81389: ARRAY
81390: PUSH
81391: LD_INT 1
81393: PLUS
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PPUSH
81399: LD_VAR 0 1
81403: PUSH
81404: LD_VAR 0 2
81408: PUSH
81409: LD_VAR 0 3
81413: PUSH
81414: LD_VAR 0 4
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: PPUSH
81425: CALL 21529 0 3
81429: ST_TO_ADDR
// end ;
81430: LD_VAR 0 5
81434: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81435: LD_INT 0
81437: PPUSH
// if not mc_bases [ base ] then
81438: LD_EXP 59
81442: PUSH
81443: LD_VAR 0 1
81447: ARRAY
81448: NOT
81449: IFFALSE 81453
// exit ;
81451: GO 81478
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81453: LD_ADDR_EXP 96
81457: PUSH
81458: LD_EXP 96
81462: PPUSH
81463: LD_VAR 0 1
81467: PPUSH
81468: LD_VAR 0 2
81472: PPUSH
81473: CALL_OW 1
81477: ST_TO_ADDR
// end ;
81478: LD_VAR 0 3
81482: RET
// export function MC_GetMinesField ( base ) ; begin
81483: LD_INT 0
81485: PPUSH
// result := mc_mines [ base ] ;
81486: LD_ADDR_VAR 0 2
81490: PUSH
81491: LD_EXP 72
81495: PUSH
81496: LD_VAR 0 1
81500: ARRAY
81501: ST_TO_ADDR
// end ;
81502: LD_VAR 0 2
81506: RET
// export function MC_GetProduceList ( base ) ; begin
81507: LD_INT 0
81509: PPUSH
// result := mc_produce [ base ] ;
81510: LD_ADDR_VAR 0 2
81514: PUSH
81515: LD_EXP 80
81519: PUSH
81520: LD_VAR 0 1
81524: ARRAY
81525: ST_TO_ADDR
// end ;
81526: LD_VAR 0 2
81530: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81531: LD_INT 0
81533: PPUSH
81534: PPUSH
// if not mc_bases then
81535: LD_EXP 59
81539: NOT
81540: IFFALSE 81544
// exit ;
81542: GO 81609
// if mc_bases [ base ] then
81544: LD_EXP 59
81548: PUSH
81549: LD_VAR 0 1
81553: ARRAY
81554: IFFALSE 81609
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81556: LD_ADDR_VAR 0 3
81560: PUSH
81561: LD_EXP 59
81565: PUSH
81566: LD_VAR 0 1
81570: ARRAY
81571: PPUSH
81572: LD_INT 30
81574: PUSH
81575: LD_VAR 0 2
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PPUSH
81584: CALL_OW 72
81588: ST_TO_ADDR
// if result then
81589: LD_VAR 0 3
81593: IFFALSE 81609
// result := result [ 1 ] ;
81595: LD_ADDR_VAR 0 3
81599: PUSH
81600: LD_VAR 0 3
81604: PUSH
81605: LD_INT 1
81607: ARRAY
81608: ST_TO_ADDR
// end ; end ;
81609: LD_VAR 0 3
81613: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81614: LD_INT 0
81616: PPUSH
81617: PPUSH
// if not mc_bases then
81618: LD_EXP 59
81622: NOT
81623: IFFALSE 81627
// exit ;
81625: GO 81672
// if mc_bases [ base ] then
81627: LD_EXP 59
81631: PUSH
81632: LD_VAR 0 1
81636: ARRAY
81637: IFFALSE 81672
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81639: LD_ADDR_VAR 0 3
81643: PUSH
81644: LD_EXP 59
81648: PUSH
81649: LD_VAR 0 1
81653: ARRAY
81654: PPUSH
81655: LD_INT 30
81657: PUSH
81658: LD_VAR 0 2
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PPUSH
81667: CALL_OW 72
81671: ST_TO_ADDR
// end ;
81672: LD_VAR 0 3
81676: RET
// export function MC_SetTame ( base , area ) ; begin
81677: LD_INT 0
81679: PPUSH
// if not mc_bases or not base then
81680: LD_EXP 59
81684: NOT
81685: PUSH
81686: LD_VAR 0 1
81690: NOT
81691: OR
81692: IFFALSE 81696
// exit ;
81694: GO 81721
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81696: LD_ADDR_EXP 87
81700: PUSH
81701: LD_EXP 87
81705: PPUSH
81706: LD_VAR 0 1
81710: PPUSH
81711: LD_VAR 0 2
81715: PPUSH
81716: CALL_OW 1
81720: ST_TO_ADDR
// end ;
81721: LD_VAR 0 3
81725: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81726: LD_INT 0
81728: PPUSH
81729: PPUSH
// if not mc_bases or not base then
81730: LD_EXP 59
81734: NOT
81735: PUSH
81736: LD_VAR 0 1
81740: NOT
81741: OR
81742: IFFALSE 81746
// exit ;
81744: GO 81848
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81746: LD_ADDR_VAR 0 4
81750: PUSH
81751: LD_EXP 59
81755: PUSH
81756: LD_VAR 0 1
81760: ARRAY
81761: PPUSH
81762: LD_INT 30
81764: PUSH
81765: LD_VAR 0 2
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PPUSH
81774: CALL_OW 72
81778: ST_TO_ADDR
// if not tmp then
81779: LD_VAR 0 4
81783: NOT
81784: IFFALSE 81788
// exit ;
81786: GO 81848
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81788: LD_ADDR_EXP 91
81792: PUSH
81793: LD_EXP 91
81797: PPUSH
81798: LD_VAR 0 1
81802: PPUSH
81803: LD_EXP 91
81807: PUSH
81808: LD_VAR 0 1
81812: ARRAY
81813: PPUSH
81814: LD_EXP 91
81818: PUSH
81819: LD_VAR 0 1
81823: ARRAY
81824: PUSH
81825: LD_INT 1
81827: PLUS
81828: PPUSH
81829: LD_VAR 0 4
81833: PUSH
81834: LD_INT 1
81836: ARRAY
81837: PPUSH
81838: CALL_OW 2
81842: PPUSH
81843: CALL_OW 1
81847: ST_TO_ADDR
// end ;
81848: LD_VAR 0 3
81852: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81853: LD_INT 0
81855: PPUSH
81856: PPUSH
// if not mc_bases or not base or not kinds then
81857: LD_EXP 59
81861: NOT
81862: PUSH
81863: LD_VAR 0 1
81867: NOT
81868: OR
81869: PUSH
81870: LD_VAR 0 2
81874: NOT
81875: OR
81876: IFFALSE 81880
// exit ;
81878: GO 81941
// for i in kinds do
81880: LD_ADDR_VAR 0 4
81884: PUSH
81885: LD_VAR 0 2
81889: PUSH
81890: FOR_IN
81891: IFFALSE 81939
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81893: LD_ADDR_EXP 93
81897: PUSH
81898: LD_EXP 93
81902: PPUSH
81903: LD_VAR 0 1
81907: PUSH
81908: LD_EXP 93
81912: PUSH
81913: LD_VAR 0 1
81917: ARRAY
81918: PUSH
81919: LD_INT 1
81921: PLUS
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PPUSH
81927: LD_VAR 0 4
81931: PPUSH
81932: CALL 21529 0 3
81936: ST_TO_ADDR
81937: GO 81890
81939: POP
81940: POP
// end ;
81941: LD_VAR 0 3
81945: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81946: LD_INT 0
81948: PPUSH
// if not mc_bases or not base or not areas then
81949: LD_EXP 59
81953: NOT
81954: PUSH
81955: LD_VAR 0 1
81959: NOT
81960: OR
81961: PUSH
81962: LD_VAR 0 2
81966: NOT
81967: OR
81968: IFFALSE 81972
// exit ;
81970: GO 81997
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81972: LD_ADDR_EXP 77
81976: PUSH
81977: LD_EXP 77
81981: PPUSH
81982: LD_VAR 0 1
81986: PPUSH
81987: LD_VAR 0 2
81991: PPUSH
81992: CALL_OW 1
81996: ST_TO_ADDR
// end ;
81997: LD_VAR 0 3
82001: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82002: LD_INT 0
82004: PPUSH
// if not mc_bases or not base or not teleports_exit then
82005: LD_EXP 59
82009: NOT
82010: PUSH
82011: LD_VAR 0 1
82015: NOT
82016: OR
82017: PUSH
82018: LD_VAR 0 2
82022: NOT
82023: OR
82024: IFFALSE 82028
// exit ;
82026: GO 82053
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82028: LD_ADDR_EXP 94
82032: PUSH
82033: LD_EXP 94
82037: PPUSH
82038: LD_VAR 0 1
82042: PPUSH
82043: LD_VAR 0 2
82047: PPUSH
82048: CALL_OW 1
82052: ST_TO_ADDR
// end ;
82053: LD_VAR 0 3
82057: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82058: LD_INT 0
82060: PPUSH
82061: PPUSH
82062: PPUSH
// if not mc_bases or not base or not ext_list then
82063: LD_EXP 59
82067: NOT
82068: PUSH
82069: LD_VAR 0 1
82073: NOT
82074: OR
82075: PUSH
82076: LD_VAR 0 5
82080: NOT
82081: OR
82082: IFFALSE 82086
// exit ;
82084: GO 82259
// tmp := GetFacExtXYD ( x , y , d ) ;
82086: LD_ADDR_VAR 0 8
82090: PUSH
82091: LD_VAR 0 2
82095: PPUSH
82096: LD_VAR 0 3
82100: PPUSH
82101: LD_VAR 0 4
82105: PPUSH
82106: CALL 54917 0 3
82110: ST_TO_ADDR
// if not tmp then
82111: LD_VAR 0 8
82115: NOT
82116: IFFALSE 82120
// exit ;
82118: GO 82259
// for i in tmp do
82120: LD_ADDR_VAR 0 7
82124: PUSH
82125: LD_VAR 0 8
82129: PUSH
82130: FOR_IN
82131: IFFALSE 82257
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82133: LD_ADDR_EXP 64
82137: PUSH
82138: LD_EXP 64
82142: PPUSH
82143: LD_VAR 0 1
82147: PPUSH
82148: LD_EXP 64
82152: PUSH
82153: LD_VAR 0 1
82157: ARRAY
82158: PPUSH
82159: LD_EXP 64
82163: PUSH
82164: LD_VAR 0 1
82168: ARRAY
82169: PUSH
82170: LD_INT 1
82172: PLUS
82173: PPUSH
82174: LD_VAR 0 5
82178: PUSH
82179: LD_INT 1
82181: ARRAY
82182: PUSH
82183: LD_VAR 0 7
82187: PUSH
82188: LD_INT 1
82190: ARRAY
82191: PUSH
82192: LD_VAR 0 7
82196: PUSH
82197: LD_INT 2
82199: ARRAY
82200: PUSH
82201: LD_VAR 0 7
82205: PUSH
82206: LD_INT 3
82208: ARRAY
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: PPUSH
82216: CALL_OW 2
82220: PPUSH
82221: CALL_OW 1
82225: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82226: LD_ADDR_VAR 0 5
82230: PUSH
82231: LD_VAR 0 5
82235: PPUSH
82236: LD_INT 1
82238: PPUSH
82239: CALL_OW 3
82243: ST_TO_ADDR
// if not ext_list then
82244: LD_VAR 0 5
82248: NOT
82249: IFFALSE 82255
// exit ;
82251: POP
82252: POP
82253: GO 82259
// end ;
82255: GO 82130
82257: POP
82258: POP
// end ;
82259: LD_VAR 0 6
82263: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82264: LD_INT 0
82266: PPUSH
// if not mc_bases or not base or not weapon_list then
82267: LD_EXP 59
82271: NOT
82272: PUSH
82273: LD_VAR 0 1
82277: NOT
82278: OR
82279: PUSH
82280: LD_VAR 0 2
82284: NOT
82285: OR
82286: IFFALSE 82290
// exit ;
82288: GO 82315
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82290: LD_ADDR_EXP 98
82294: PUSH
82295: LD_EXP 98
82299: PPUSH
82300: LD_VAR 0 1
82304: PPUSH
82305: LD_VAR 0 2
82309: PPUSH
82310: CALL_OW 1
82314: ST_TO_ADDR
// end ;
82315: LD_VAR 0 3
82319: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82320: LD_INT 0
82322: PPUSH
// if not mc_bases or not base or not tech_list then
82323: LD_EXP 59
82327: NOT
82328: PUSH
82329: LD_VAR 0 1
82333: NOT
82334: OR
82335: PUSH
82336: LD_VAR 0 2
82340: NOT
82341: OR
82342: IFFALSE 82346
// exit ;
82344: GO 82371
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82346: LD_ADDR_EXP 86
82350: PUSH
82351: LD_EXP 86
82355: PPUSH
82356: LD_VAR 0 1
82360: PPUSH
82361: LD_VAR 0 2
82365: PPUSH
82366: CALL_OW 1
82370: ST_TO_ADDR
// end ;
82371: LD_VAR 0 3
82375: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82376: LD_INT 0
82378: PPUSH
// if not mc_bases or not parking_area or not base then
82379: LD_EXP 59
82383: NOT
82384: PUSH
82385: LD_VAR 0 2
82389: NOT
82390: OR
82391: PUSH
82392: LD_VAR 0 1
82396: NOT
82397: OR
82398: IFFALSE 82402
// exit ;
82400: GO 82427
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82402: LD_ADDR_EXP 83
82406: PUSH
82407: LD_EXP 83
82411: PPUSH
82412: LD_VAR 0 1
82416: PPUSH
82417: LD_VAR 0 2
82421: PPUSH
82422: CALL_OW 1
82426: ST_TO_ADDR
// end ;
82427: LD_VAR 0 3
82431: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82432: LD_INT 0
82434: PPUSH
// if not mc_bases or not base or not scan_area then
82435: LD_EXP 59
82439: NOT
82440: PUSH
82441: LD_VAR 0 1
82445: NOT
82446: OR
82447: PUSH
82448: LD_VAR 0 2
82452: NOT
82453: OR
82454: IFFALSE 82458
// exit ;
82456: GO 82483
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82458: LD_ADDR_EXP 84
82462: PUSH
82463: LD_EXP 84
82467: PPUSH
82468: LD_VAR 0 1
82472: PPUSH
82473: LD_VAR 0 2
82477: PPUSH
82478: CALL_OW 1
82482: ST_TO_ADDR
// end ;
82483: LD_VAR 0 3
82487: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82488: LD_INT 0
82490: PPUSH
82491: PPUSH
// if not mc_bases or not base then
82492: LD_EXP 59
82496: NOT
82497: PUSH
82498: LD_VAR 0 1
82502: NOT
82503: OR
82504: IFFALSE 82508
// exit ;
82506: GO 82572
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82508: LD_ADDR_VAR 0 3
82512: PUSH
82513: LD_INT 1
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: LD_INT 3
82521: PUSH
82522: LD_INT 4
82524: PUSH
82525: LD_INT 11
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82535: LD_ADDR_EXP 86
82539: PUSH
82540: LD_EXP 86
82544: PPUSH
82545: LD_VAR 0 1
82549: PPUSH
82550: LD_EXP 86
82554: PUSH
82555: LD_VAR 0 1
82559: ARRAY
82560: PUSH
82561: LD_VAR 0 3
82565: DIFF
82566: PPUSH
82567: CALL_OW 1
82571: ST_TO_ADDR
// end ;
82572: LD_VAR 0 2
82576: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82577: LD_INT 0
82579: PPUSH
// result := mc_vehicles [ base ] ;
82580: LD_ADDR_VAR 0 3
82584: PUSH
82585: LD_EXP 78
82589: PUSH
82590: LD_VAR 0 1
82594: ARRAY
82595: ST_TO_ADDR
// if onlyCombat then
82596: LD_VAR 0 2
82600: IFFALSE 82765
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82602: LD_ADDR_VAR 0 3
82606: PUSH
82607: LD_VAR 0 3
82611: PUSH
82612: LD_VAR 0 3
82616: PPUSH
82617: LD_INT 2
82619: PUSH
82620: LD_INT 34
82622: PUSH
82623: LD_INT 12
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 34
82632: PUSH
82633: LD_INT 51
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 34
82642: PUSH
82643: LD_EXP 103
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 34
82654: PUSH
82655: LD_INT 32
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 34
82664: PUSH
82665: LD_INT 13
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 34
82674: PUSH
82675: LD_INT 52
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 34
82684: PUSH
82685: LD_INT 14
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 34
82694: PUSH
82695: LD_INT 53
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 34
82704: PUSH
82705: LD_EXP 102
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 34
82716: PUSH
82717: LD_INT 31
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 34
82726: PUSH
82727: LD_INT 48
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 34
82736: PUSH
82737: LD_INT 8
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: PPUSH
82759: CALL_OW 72
82763: DIFF
82764: ST_TO_ADDR
// end ; end_of_file
82765: LD_VAR 0 3
82769: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82770: LD_INT 0
82772: PPUSH
82773: PPUSH
82774: PPUSH
// if not mc_bases or not skirmish then
82775: LD_EXP 59
82779: NOT
82780: PUSH
82781: LD_EXP 57
82785: NOT
82786: OR
82787: IFFALSE 82791
// exit ;
82789: GO 82956
// for i = 1 to mc_bases do
82791: LD_ADDR_VAR 0 4
82795: PUSH
82796: DOUBLE
82797: LD_INT 1
82799: DEC
82800: ST_TO_ADDR
82801: LD_EXP 59
82805: PUSH
82806: FOR_TO
82807: IFFALSE 82954
// begin if sci in mc_bases [ i ] then
82809: LD_VAR 0 2
82813: PUSH
82814: LD_EXP 59
82818: PUSH
82819: LD_VAR 0 4
82823: ARRAY
82824: IN
82825: IFFALSE 82952
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82827: LD_ADDR_EXP 88
82831: PUSH
82832: LD_EXP 88
82836: PPUSH
82837: LD_VAR 0 4
82841: PUSH
82842: LD_EXP 88
82846: PUSH
82847: LD_VAR 0 4
82851: ARRAY
82852: PUSH
82853: LD_INT 1
82855: PLUS
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PPUSH
82861: LD_VAR 0 1
82865: PPUSH
82866: CALL 21529 0 3
82870: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82871: LD_ADDR_VAR 0 5
82875: PUSH
82876: LD_EXP 59
82880: PUSH
82881: LD_VAR 0 4
82885: ARRAY
82886: PPUSH
82887: LD_INT 2
82889: PUSH
82890: LD_INT 30
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 30
82902: PUSH
82903: LD_INT 1
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: LIST
82914: PPUSH
82915: CALL_OW 72
82919: PPUSH
82920: LD_VAR 0 1
82924: PPUSH
82925: CALL_OW 74
82929: ST_TO_ADDR
// if tmp then
82930: LD_VAR 0 5
82934: IFFALSE 82950
// ComStandNearbyBuilding ( ape , tmp ) ;
82936: LD_VAR 0 1
82940: PPUSH
82941: LD_VAR 0 5
82945: PPUSH
82946: CALL 15732 0 2
// break ;
82950: GO 82954
// end ; end ;
82952: GO 82806
82954: POP
82955: POP
// end ;
82956: LD_VAR 0 3
82960: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82961: LD_INT 0
82963: PPUSH
82964: PPUSH
82965: PPUSH
// if not mc_bases or not skirmish then
82966: LD_EXP 59
82970: NOT
82971: PUSH
82972: LD_EXP 57
82976: NOT
82977: OR
82978: IFFALSE 82982
// exit ;
82980: GO 83071
// for i = 1 to mc_bases do
82982: LD_ADDR_VAR 0 4
82986: PUSH
82987: DOUBLE
82988: LD_INT 1
82990: DEC
82991: ST_TO_ADDR
82992: LD_EXP 59
82996: PUSH
82997: FOR_TO
82998: IFFALSE 83069
// begin if building in mc_busy_turret_list [ i ] then
83000: LD_VAR 0 1
83004: PUSH
83005: LD_EXP 69
83009: PUSH
83010: LD_VAR 0 4
83014: ARRAY
83015: IN
83016: IFFALSE 83067
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83018: LD_ADDR_VAR 0 5
83022: PUSH
83023: LD_EXP 69
83027: PUSH
83028: LD_VAR 0 4
83032: ARRAY
83033: PUSH
83034: LD_VAR 0 1
83038: DIFF
83039: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83040: LD_ADDR_EXP 69
83044: PUSH
83045: LD_EXP 69
83049: PPUSH
83050: LD_VAR 0 4
83054: PPUSH
83055: LD_VAR 0 5
83059: PPUSH
83060: CALL_OW 1
83064: ST_TO_ADDR
// break ;
83065: GO 83069
// end ; end ;
83067: GO 82997
83069: POP
83070: POP
// end ;
83071: LD_VAR 0 3
83075: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83076: LD_INT 0
83078: PPUSH
83079: PPUSH
83080: PPUSH
// if not mc_bases or not skirmish then
83081: LD_EXP 59
83085: NOT
83086: PUSH
83087: LD_EXP 57
83091: NOT
83092: OR
83093: IFFALSE 83097
// exit ;
83095: GO 83296
// for i = 1 to mc_bases do
83097: LD_ADDR_VAR 0 5
83101: PUSH
83102: DOUBLE
83103: LD_INT 1
83105: DEC
83106: ST_TO_ADDR
83107: LD_EXP 59
83111: PUSH
83112: FOR_TO
83113: IFFALSE 83294
// if building in mc_bases [ i ] then
83115: LD_VAR 0 1
83119: PUSH
83120: LD_EXP 59
83124: PUSH
83125: LD_VAR 0 5
83129: ARRAY
83130: IN
83131: IFFALSE 83292
// begin tmp := mc_bases [ i ] diff building ;
83133: LD_ADDR_VAR 0 6
83137: PUSH
83138: LD_EXP 59
83142: PUSH
83143: LD_VAR 0 5
83147: ARRAY
83148: PUSH
83149: LD_VAR 0 1
83153: DIFF
83154: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83155: LD_ADDR_EXP 59
83159: PUSH
83160: LD_EXP 59
83164: PPUSH
83165: LD_VAR 0 5
83169: PPUSH
83170: LD_VAR 0 6
83174: PPUSH
83175: CALL_OW 1
83179: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83180: LD_VAR 0 1
83184: PUSH
83185: LD_EXP 67
83189: PUSH
83190: LD_VAR 0 5
83194: ARRAY
83195: IN
83196: IFFALSE 83235
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83198: LD_ADDR_EXP 67
83202: PUSH
83203: LD_EXP 67
83207: PPUSH
83208: LD_VAR 0 5
83212: PPUSH
83213: LD_EXP 67
83217: PUSH
83218: LD_VAR 0 5
83222: ARRAY
83223: PUSH
83224: LD_VAR 0 1
83228: DIFF
83229: PPUSH
83230: CALL_OW 1
83234: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83235: LD_VAR 0 1
83239: PUSH
83240: LD_EXP 68
83244: PUSH
83245: LD_VAR 0 5
83249: ARRAY
83250: IN
83251: IFFALSE 83290
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83253: LD_ADDR_EXP 68
83257: PUSH
83258: LD_EXP 68
83262: PPUSH
83263: LD_VAR 0 5
83267: PPUSH
83268: LD_EXP 68
83272: PUSH
83273: LD_VAR 0 5
83277: ARRAY
83278: PUSH
83279: LD_VAR 0 1
83283: DIFF
83284: PPUSH
83285: CALL_OW 1
83289: ST_TO_ADDR
// break ;
83290: GO 83294
// end ;
83292: GO 83112
83294: POP
83295: POP
// end ;
83296: LD_VAR 0 4
83300: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83301: LD_INT 0
83303: PPUSH
83304: PPUSH
83305: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83306: LD_EXP 59
83310: NOT
83311: PUSH
83312: LD_EXP 57
83316: NOT
83317: OR
83318: PUSH
83319: LD_VAR 0 3
83323: PUSH
83324: LD_EXP 85
83328: IN
83329: NOT
83330: OR
83331: IFFALSE 83335
// exit ;
83333: GO 83458
// for i = 1 to mc_vehicles do
83335: LD_ADDR_VAR 0 6
83339: PUSH
83340: DOUBLE
83341: LD_INT 1
83343: DEC
83344: ST_TO_ADDR
83345: LD_EXP 78
83349: PUSH
83350: FOR_TO
83351: IFFALSE 83456
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83353: LD_VAR 0 2
83357: PUSH
83358: LD_EXP 78
83362: PUSH
83363: LD_VAR 0 6
83367: ARRAY
83368: IN
83369: PUSH
83370: LD_VAR 0 1
83374: PUSH
83375: LD_EXP 78
83379: PUSH
83380: LD_VAR 0 6
83384: ARRAY
83385: IN
83386: OR
83387: IFFALSE 83454
// begin tmp := mc_vehicles [ i ] diff old ;
83389: LD_ADDR_VAR 0 7
83393: PUSH
83394: LD_EXP 78
83398: PUSH
83399: LD_VAR 0 6
83403: ARRAY
83404: PUSH
83405: LD_VAR 0 2
83409: DIFF
83410: ST_TO_ADDR
// tmp := tmp diff new ;
83411: LD_ADDR_VAR 0 7
83415: PUSH
83416: LD_VAR 0 7
83420: PUSH
83421: LD_VAR 0 1
83425: DIFF
83426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83427: LD_ADDR_EXP 78
83431: PUSH
83432: LD_EXP 78
83436: PPUSH
83437: LD_VAR 0 6
83441: PPUSH
83442: LD_VAR 0 7
83446: PPUSH
83447: CALL_OW 1
83451: ST_TO_ADDR
// break ;
83452: GO 83456
// end ;
83454: GO 83350
83456: POP
83457: POP
// end ;
83458: LD_VAR 0 5
83462: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83463: LD_INT 0
83465: PPUSH
83466: PPUSH
83467: PPUSH
83468: PPUSH
// if not mc_bases or not skirmish then
83469: LD_EXP 59
83473: NOT
83474: PUSH
83475: LD_EXP 57
83479: NOT
83480: OR
83481: IFFALSE 83485
// exit ;
83483: GO 83862
// side := GetSide ( vehicle ) ;
83485: LD_ADDR_VAR 0 5
83489: PUSH
83490: LD_VAR 0 1
83494: PPUSH
83495: CALL_OW 255
83499: ST_TO_ADDR
// for i = 1 to mc_bases do
83500: LD_ADDR_VAR 0 4
83504: PUSH
83505: DOUBLE
83506: LD_INT 1
83508: DEC
83509: ST_TO_ADDR
83510: LD_EXP 59
83514: PUSH
83515: FOR_TO
83516: IFFALSE 83860
// begin if factory in mc_bases [ i ] then
83518: LD_VAR 0 2
83522: PUSH
83523: LD_EXP 59
83527: PUSH
83528: LD_VAR 0 4
83532: ARRAY
83533: IN
83534: IFFALSE 83858
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83536: LD_EXP 81
83540: PUSH
83541: LD_VAR 0 4
83545: ARRAY
83546: PUSH
83547: LD_EXP 70
83551: PUSH
83552: LD_VAR 0 4
83556: ARRAY
83557: LESS
83558: PUSH
83559: LD_VAR 0 1
83563: PPUSH
83564: CALL_OW 264
83568: PUSH
83569: LD_INT 31
83571: PUSH
83572: LD_INT 32
83574: PUSH
83575: LD_INT 51
83577: PUSH
83578: LD_EXP 103
83582: PUSH
83583: LD_INT 12
83585: PUSH
83586: LD_INT 30
83588: PUSH
83589: LD_EXP 102
83593: PUSH
83594: LD_INT 11
83596: PUSH
83597: LD_INT 53
83599: PUSH
83600: LD_INT 14
83602: PUSH
83603: LD_EXP 106
83607: PUSH
83608: LD_INT 29
83610: PUSH
83611: LD_EXP 104
83615: PUSH
83616: LD_INT 13
83618: PUSH
83619: LD_INT 52
83621: PUSH
83622: LD_INT 48
83624: PUSH
83625: LD_INT 8
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: IN
83647: NOT
83648: AND
83649: IFFALSE 83697
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83651: LD_ADDR_EXP 81
83655: PUSH
83656: LD_EXP 81
83660: PPUSH
83661: LD_VAR 0 4
83665: PUSH
83666: LD_EXP 81
83670: PUSH
83671: LD_VAR 0 4
83675: ARRAY
83676: PUSH
83677: LD_INT 1
83679: PLUS
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PPUSH
83685: LD_VAR 0 1
83689: PPUSH
83690: CALL 21529 0 3
83694: ST_TO_ADDR
83695: GO 83741
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83697: LD_ADDR_EXP 78
83701: PUSH
83702: LD_EXP 78
83706: PPUSH
83707: LD_VAR 0 4
83711: PUSH
83712: LD_EXP 78
83716: PUSH
83717: LD_VAR 0 4
83721: ARRAY
83722: PUSH
83723: LD_INT 1
83725: PLUS
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PPUSH
83731: LD_VAR 0 1
83735: PPUSH
83736: CALL 21529 0 3
83740: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83741: LD_VAR 0 1
83745: PPUSH
83746: CALL_OW 263
83750: PUSH
83751: LD_INT 2
83753: EQUAL
83754: IFFALSE 83774
// begin repeat wait ( 0 0$1 ) ;
83756: LD_INT 35
83758: PPUSH
83759: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83763: LD_VAR 0 1
83767: PPUSH
83768: CALL_OW 312
83772: IFFALSE 83756
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83774: LD_VAR 0 1
83778: PPUSH
83779: LD_EXP 83
83783: PUSH
83784: LD_VAR 0 4
83788: ARRAY
83789: PPUSH
83790: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83794: LD_VAR 0 1
83798: PPUSH
83799: CALL_OW 263
83803: PUSH
83804: LD_INT 1
83806: NONEQUAL
83807: IFFALSE 83811
// break ;
83809: GO 83860
// repeat wait ( 0 0$1 ) ;
83811: LD_INT 35
83813: PPUSH
83814: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83818: LD_VAR 0 1
83822: PPUSH
83823: LD_EXP 83
83827: PUSH
83828: LD_VAR 0 4
83832: ARRAY
83833: PPUSH
83834: CALL_OW 308
83838: IFFALSE 83811
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83840: LD_VAR 0 1
83844: PPUSH
83845: CALL_OW 311
83849: PPUSH
83850: CALL_OW 121
// exit ;
83854: POP
83855: POP
83856: GO 83862
// end ; end ;
83858: GO 83515
83860: POP
83861: POP
// end ;
83862: LD_VAR 0 3
83866: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83867: LD_INT 0
83869: PPUSH
83870: PPUSH
83871: PPUSH
83872: PPUSH
// if not mc_bases or not skirmish then
83873: LD_EXP 59
83877: NOT
83878: PUSH
83879: LD_EXP 57
83883: NOT
83884: OR
83885: IFFALSE 83889
// exit ;
83887: GO 84242
// repeat wait ( 0 0$1 ) ;
83889: LD_INT 35
83891: PPUSH
83892: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83896: LD_VAR 0 2
83900: PPUSH
83901: LD_VAR 0 3
83905: PPUSH
83906: CALL_OW 284
83910: IFFALSE 83889
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83912: LD_VAR 0 2
83916: PPUSH
83917: LD_VAR 0 3
83921: PPUSH
83922: CALL_OW 283
83926: PUSH
83927: LD_INT 4
83929: EQUAL
83930: IFFALSE 83934
// exit ;
83932: GO 84242
// for i = 1 to mc_bases do
83934: LD_ADDR_VAR 0 7
83938: PUSH
83939: DOUBLE
83940: LD_INT 1
83942: DEC
83943: ST_TO_ADDR
83944: LD_EXP 59
83948: PUSH
83949: FOR_TO
83950: IFFALSE 84240
// begin if mc_crates_area [ i ] then
83952: LD_EXP 77
83956: PUSH
83957: LD_VAR 0 7
83961: ARRAY
83962: IFFALSE 84073
// for j in mc_crates_area [ i ] do
83964: LD_ADDR_VAR 0 8
83968: PUSH
83969: LD_EXP 77
83973: PUSH
83974: LD_VAR 0 7
83978: ARRAY
83979: PUSH
83980: FOR_IN
83981: IFFALSE 84071
// if InArea ( x , y , j ) then
83983: LD_VAR 0 2
83987: PPUSH
83988: LD_VAR 0 3
83992: PPUSH
83993: LD_VAR 0 8
83997: PPUSH
83998: CALL_OW 309
84002: IFFALSE 84069
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84004: LD_ADDR_EXP 75
84008: PUSH
84009: LD_EXP 75
84013: PPUSH
84014: LD_VAR 0 7
84018: PUSH
84019: LD_EXP 75
84023: PUSH
84024: LD_VAR 0 7
84028: ARRAY
84029: PUSH
84030: LD_INT 1
84032: PLUS
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PPUSH
84038: LD_VAR 0 4
84042: PUSH
84043: LD_VAR 0 2
84047: PUSH
84048: LD_VAR 0 3
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: LIST
84057: PPUSH
84058: CALL 21529 0 3
84062: ST_TO_ADDR
// exit ;
84063: POP
84064: POP
84065: POP
84066: POP
84067: GO 84242
// end ;
84069: GO 83980
84071: POP
84072: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84073: LD_ADDR_VAR 0 9
84077: PUSH
84078: LD_EXP 59
84082: PUSH
84083: LD_VAR 0 7
84087: ARRAY
84088: PPUSH
84089: LD_INT 2
84091: PUSH
84092: LD_INT 30
84094: PUSH
84095: LD_INT 0
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 30
84104: PUSH
84105: LD_INT 1
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: LIST
84116: PPUSH
84117: CALL_OW 72
84121: ST_TO_ADDR
// if not depot then
84122: LD_VAR 0 9
84126: NOT
84127: IFFALSE 84131
// continue ;
84129: GO 83949
// for j in depot do
84131: LD_ADDR_VAR 0 8
84135: PUSH
84136: LD_VAR 0 9
84140: PUSH
84141: FOR_IN
84142: IFFALSE 84236
// if GetDistUnitXY ( j , x , y ) < 30 then
84144: LD_VAR 0 8
84148: PPUSH
84149: LD_VAR 0 2
84153: PPUSH
84154: LD_VAR 0 3
84158: PPUSH
84159: CALL_OW 297
84163: PUSH
84164: LD_INT 30
84166: LESS
84167: IFFALSE 84234
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84169: LD_ADDR_EXP 75
84173: PUSH
84174: LD_EXP 75
84178: PPUSH
84179: LD_VAR 0 7
84183: PUSH
84184: LD_EXP 75
84188: PUSH
84189: LD_VAR 0 7
84193: ARRAY
84194: PUSH
84195: LD_INT 1
84197: PLUS
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PPUSH
84203: LD_VAR 0 4
84207: PUSH
84208: LD_VAR 0 2
84212: PUSH
84213: LD_VAR 0 3
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: LIST
84222: PPUSH
84223: CALL 21529 0 3
84227: ST_TO_ADDR
// exit ;
84228: POP
84229: POP
84230: POP
84231: POP
84232: GO 84242
// end ;
84234: GO 84141
84236: POP
84237: POP
// end ;
84238: GO 83949
84240: POP
84241: POP
// end ;
84242: LD_VAR 0 6
84246: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84247: LD_INT 0
84249: PPUSH
84250: PPUSH
84251: PPUSH
84252: PPUSH
// if not mc_bases or not skirmish then
84253: LD_EXP 59
84257: NOT
84258: PUSH
84259: LD_EXP 57
84263: NOT
84264: OR
84265: IFFALSE 84269
// exit ;
84267: GO 84546
// side := GetSide ( lab ) ;
84269: LD_ADDR_VAR 0 4
84273: PUSH
84274: LD_VAR 0 2
84278: PPUSH
84279: CALL_OW 255
84283: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84284: LD_VAR 0 4
84288: PUSH
84289: LD_EXP 85
84293: IN
84294: NOT
84295: PUSH
84296: LD_EXP 86
84300: NOT
84301: OR
84302: PUSH
84303: LD_EXP 59
84307: NOT
84308: OR
84309: IFFALSE 84313
// exit ;
84311: GO 84546
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84313: LD_ADDR_EXP 86
84317: PUSH
84318: LD_EXP 86
84322: PPUSH
84323: LD_VAR 0 4
84327: PPUSH
84328: LD_EXP 86
84332: PUSH
84333: LD_VAR 0 4
84337: ARRAY
84338: PUSH
84339: LD_VAR 0 1
84343: DIFF
84344: PPUSH
84345: CALL_OW 1
84349: ST_TO_ADDR
// for i = 1 to mc_bases do
84350: LD_ADDR_VAR 0 5
84354: PUSH
84355: DOUBLE
84356: LD_INT 1
84358: DEC
84359: ST_TO_ADDR
84360: LD_EXP 59
84364: PUSH
84365: FOR_TO
84366: IFFALSE 84544
// begin if lab in mc_bases [ i ] then
84368: LD_VAR 0 2
84372: PUSH
84373: LD_EXP 59
84377: PUSH
84378: LD_VAR 0 5
84382: ARRAY
84383: IN
84384: IFFALSE 84542
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84386: LD_VAR 0 1
84390: PUSH
84391: LD_INT 11
84393: PUSH
84394: LD_INT 4
84396: PUSH
84397: LD_INT 3
84399: PUSH
84400: LD_INT 2
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: IN
84409: PUSH
84410: LD_EXP 89
84414: PUSH
84415: LD_VAR 0 5
84419: ARRAY
84420: AND
84421: IFFALSE 84542
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84423: LD_ADDR_VAR 0 6
84427: PUSH
84428: LD_EXP 89
84432: PUSH
84433: LD_VAR 0 5
84437: ARRAY
84438: PUSH
84439: LD_INT 1
84441: ARRAY
84442: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84443: LD_ADDR_EXP 89
84447: PUSH
84448: LD_EXP 89
84452: PPUSH
84453: LD_VAR 0 5
84457: PPUSH
84458: EMPTY
84459: PPUSH
84460: CALL_OW 1
84464: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84465: LD_VAR 0 6
84469: PPUSH
84470: LD_INT 0
84472: PPUSH
84473: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84477: LD_VAR 0 6
84481: PPUSH
84482: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84486: LD_ADDR_EXP 88
84490: PUSH
84491: LD_EXP 88
84495: PPUSH
84496: LD_VAR 0 5
84500: PPUSH
84501: LD_EXP 88
84505: PUSH
84506: LD_VAR 0 5
84510: ARRAY
84511: PPUSH
84512: LD_INT 1
84514: PPUSH
84515: LD_VAR 0 6
84519: PPUSH
84520: CALL_OW 2
84524: PPUSH
84525: CALL_OW 1
84529: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84530: LD_VAR 0 5
84534: PPUSH
84535: LD_INT 112
84537: PPUSH
84538: CALL 61542 0 2
// end ; end ; end ;
84542: GO 84365
84544: POP
84545: POP
// end ;
84546: LD_VAR 0 3
84550: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84551: LD_INT 0
84553: PPUSH
84554: PPUSH
84555: PPUSH
84556: PPUSH
84557: PPUSH
84558: PPUSH
84559: PPUSH
84560: PPUSH
// if not mc_bases or not skirmish then
84561: LD_EXP 59
84565: NOT
84566: PUSH
84567: LD_EXP 57
84571: NOT
84572: OR
84573: IFFALSE 84577
// exit ;
84575: GO 85948
// for i = 1 to mc_bases do
84577: LD_ADDR_VAR 0 3
84581: PUSH
84582: DOUBLE
84583: LD_INT 1
84585: DEC
84586: ST_TO_ADDR
84587: LD_EXP 59
84591: PUSH
84592: FOR_TO
84593: IFFALSE 85946
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84595: LD_VAR 0 1
84599: PUSH
84600: LD_EXP 59
84604: PUSH
84605: LD_VAR 0 3
84609: ARRAY
84610: IN
84611: PUSH
84612: LD_VAR 0 1
84616: PUSH
84617: LD_EXP 66
84621: PUSH
84622: LD_VAR 0 3
84626: ARRAY
84627: IN
84628: OR
84629: PUSH
84630: LD_VAR 0 1
84634: PUSH
84635: LD_EXP 81
84639: PUSH
84640: LD_VAR 0 3
84644: ARRAY
84645: IN
84646: OR
84647: PUSH
84648: LD_VAR 0 1
84652: PUSH
84653: LD_EXP 78
84657: PUSH
84658: LD_VAR 0 3
84662: ARRAY
84663: IN
84664: OR
84665: PUSH
84666: LD_VAR 0 1
84670: PUSH
84671: LD_EXP 88
84675: PUSH
84676: LD_VAR 0 3
84680: ARRAY
84681: IN
84682: OR
84683: PUSH
84684: LD_VAR 0 1
84688: PUSH
84689: LD_EXP 89
84693: PUSH
84694: LD_VAR 0 3
84698: ARRAY
84699: IN
84700: OR
84701: IFFALSE 85944
// begin if un in mc_ape [ i ] then
84703: LD_VAR 0 1
84707: PUSH
84708: LD_EXP 88
84712: PUSH
84713: LD_VAR 0 3
84717: ARRAY
84718: IN
84719: IFFALSE 84758
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84721: LD_ADDR_EXP 88
84725: PUSH
84726: LD_EXP 88
84730: PPUSH
84731: LD_VAR 0 3
84735: PPUSH
84736: LD_EXP 88
84740: PUSH
84741: LD_VAR 0 3
84745: ARRAY
84746: PUSH
84747: LD_VAR 0 1
84751: DIFF
84752: PPUSH
84753: CALL_OW 1
84757: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84758: LD_VAR 0 1
84762: PUSH
84763: LD_EXP 89
84767: PUSH
84768: LD_VAR 0 3
84772: ARRAY
84773: IN
84774: IFFALSE 84798
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84776: LD_ADDR_EXP 89
84780: PUSH
84781: LD_EXP 89
84785: PPUSH
84786: LD_VAR 0 3
84790: PPUSH
84791: EMPTY
84792: PPUSH
84793: CALL_OW 1
84797: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84798: LD_VAR 0 1
84802: PPUSH
84803: CALL_OW 247
84807: PUSH
84808: LD_INT 2
84810: EQUAL
84811: PUSH
84812: LD_VAR 0 1
84816: PPUSH
84817: CALL_OW 110
84821: PUSH
84822: LD_INT 20
84824: EQUAL
84825: PUSH
84826: LD_VAR 0 1
84830: PUSH
84831: LD_EXP 81
84835: PUSH
84836: LD_VAR 0 3
84840: ARRAY
84841: IN
84842: OR
84843: PUSH
84844: LD_VAR 0 1
84848: PPUSH
84849: CALL_OW 264
84853: PUSH
84854: LD_INT 12
84856: PUSH
84857: LD_INT 51
84859: PUSH
84860: LD_EXP 103
84864: PUSH
84865: LD_INT 32
84867: PUSH
84868: LD_INT 13
84870: PUSH
84871: LD_INT 52
84873: PUSH
84874: LD_INT 31
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: IN
84886: OR
84887: AND
84888: IFFALSE 85196
// begin if un in mc_defender [ i ] then
84890: LD_VAR 0 1
84894: PUSH
84895: LD_EXP 81
84899: PUSH
84900: LD_VAR 0 3
84904: ARRAY
84905: IN
84906: IFFALSE 84945
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84908: LD_ADDR_EXP 81
84912: PUSH
84913: LD_EXP 81
84917: PPUSH
84918: LD_VAR 0 3
84922: PPUSH
84923: LD_EXP 81
84927: PUSH
84928: LD_VAR 0 3
84932: ARRAY
84933: PUSH
84934: LD_VAR 0 1
84938: DIFF
84939: PPUSH
84940: CALL_OW 1
84944: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84945: LD_ADDR_VAR 0 8
84949: PUSH
84950: LD_VAR 0 3
84954: PPUSH
84955: LD_INT 3
84957: PPUSH
84958: CALL 81614 0 2
84962: ST_TO_ADDR
// if fac then
84963: LD_VAR 0 8
84967: IFFALSE 85196
// begin for j in fac do
84969: LD_ADDR_VAR 0 4
84973: PUSH
84974: LD_VAR 0 8
84978: PUSH
84979: FOR_IN
84980: IFFALSE 85194
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84982: LD_ADDR_VAR 0 9
84986: PUSH
84987: LD_VAR 0 8
84991: PPUSH
84992: LD_VAR 0 1
84996: PPUSH
84997: CALL_OW 265
85001: PPUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 262
85011: PPUSH
85012: LD_VAR 0 1
85016: PPUSH
85017: CALL_OW 263
85021: PPUSH
85022: LD_VAR 0 1
85026: PPUSH
85027: CALL_OW 264
85031: PPUSH
85032: CALL 19061 0 5
85036: ST_TO_ADDR
// if components then
85037: LD_VAR 0 9
85041: IFFALSE 85192
// begin if GetWeapon ( un ) = ar_control_tower then
85043: LD_VAR 0 1
85047: PPUSH
85048: CALL_OW 264
85052: PUSH
85053: LD_INT 31
85055: EQUAL
85056: IFFALSE 85173
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85058: LD_VAR 0 1
85062: PPUSH
85063: CALL_OW 311
85067: PPUSH
85068: LD_INT 0
85070: PPUSH
85071: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85075: LD_ADDR_EXP 99
85079: PUSH
85080: LD_EXP 99
85084: PPUSH
85085: LD_VAR 0 3
85089: PPUSH
85090: LD_EXP 99
85094: PUSH
85095: LD_VAR 0 3
85099: ARRAY
85100: PUSH
85101: LD_VAR 0 1
85105: PPUSH
85106: CALL_OW 311
85110: DIFF
85111: PPUSH
85112: CALL_OW 1
85116: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85117: LD_ADDR_VAR 0 7
85121: PUSH
85122: LD_EXP 80
85126: PUSH
85127: LD_VAR 0 3
85131: ARRAY
85132: PPUSH
85133: LD_INT 1
85135: PPUSH
85136: LD_VAR 0 9
85140: PPUSH
85141: CALL_OW 2
85145: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85146: LD_ADDR_EXP 80
85150: PUSH
85151: LD_EXP 80
85155: PPUSH
85156: LD_VAR 0 3
85160: PPUSH
85161: LD_VAR 0 7
85165: PPUSH
85166: CALL_OW 1
85170: ST_TO_ADDR
// end else
85171: GO 85190
// MC_InsertProduceList ( i , [ components ] ) ;
85173: LD_VAR 0 3
85177: PPUSH
85178: LD_VAR 0 9
85182: PUSH
85183: EMPTY
85184: LIST
85185: PPUSH
85186: CALL 81159 0 2
// break ;
85190: GO 85194
// end ; end ;
85192: GO 84979
85194: POP
85195: POP
// end ; end ; if GetType ( un ) = unit_building then
85196: LD_VAR 0 1
85200: PPUSH
85201: CALL_OW 247
85205: PUSH
85206: LD_INT 3
85208: EQUAL
85209: IFFALSE 85612
// begin btype := GetBType ( un ) ;
85211: LD_ADDR_VAR 0 5
85215: PUSH
85216: LD_VAR 0 1
85220: PPUSH
85221: CALL_OW 266
85225: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85226: LD_VAR 0 5
85230: PUSH
85231: LD_INT 29
85233: PUSH
85234: LD_INT 30
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: IN
85241: IFFALSE 85314
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85243: LD_VAR 0 1
85247: PPUSH
85248: CALL_OW 250
85252: PPUSH
85253: LD_VAR 0 1
85257: PPUSH
85258: CALL_OW 251
85262: PPUSH
85263: LD_VAR 0 1
85267: PPUSH
85268: CALL_OW 255
85272: PPUSH
85273: CALL_OW 440
85277: NOT
85278: IFFALSE 85314
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85280: LD_VAR 0 1
85284: PPUSH
85285: CALL_OW 250
85289: PPUSH
85290: LD_VAR 0 1
85294: PPUSH
85295: CALL_OW 251
85299: PPUSH
85300: LD_VAR 0 1
85304: PPUSH
85305: CALL_OW 255
85309: PPUSH
85310: CALL_OW 441
// end ; if btype = b_warehouse then
85314: LD_VAR 0 5
85318: PUSH
85319: LD_INT 1
85321: EQUAL
85322: IFFALSE 85340
// begin btype := b_depot ;
85324: LD_ADDR_VAR 0 5
85328: PUSH
85329: LD_INT 0
85331: ST_TO_ADDR
// pos := 1 ;
85332: LD_ADDR_VAR 0 6
85336: PUSH
85337: LD_INT 1
85339: ST_TO_ADDR
// end ; if btype = b_factory then
85340: LD_VAR 0 5
85344: PUSH
85345: LD_INT 3
85347: EQUAL
85348: IFFALSE 85366
// begin btype := b_workshop ;
85350: LD_ADDR_VAR 0 5
85354: PUSH
85355: LD_INT 2
85357: ST_TO_ADDR
// pos := 1 ;
85358: LD_ADDR_VAR 0 6
85362: PUSH
85363: LD_INT 1
85365: ST_TO_ADDR
// end ; if btype = b_barracks then
85366: LD_VAR 0 5
85370: PUSH
85371: LD_INT 5
85373: EQUAL
85374: IFFALSE 85384
// btype := b_armoury ;
85376: LD_ADDR_VAR 0 5
85380: PUSH
85381: LD_INT 4
85383: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85384: LD_VAR 0 5
85388: PUSH
85389: LD_INT 7
85391: PUSH
85392: LD_INT 8
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: IN
85399: IFFALSE 85409
// btype := b_lab ;
85401: LD_ADDR_VAR 0 5
85405: PUSH
85406: LD_INT 6
85408: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85409: LD_ADDR_EXP 64
85413: PUSH
85414: LD_EXP 64
85418: PPUSH
85419: LD_VAR 0 3
85423: PUSH
85424: LD_EXP 64
85428: PUSH
85429: LD_VAR 0 3
85433: ARRAY
85434: PUSH
85435: LD_INT 1
85437: PLUS
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PPUSH
85443: LD_VAR 0 5
85447: PUSH
85448: LD_VAR 0 1
85452: PPUSH
85453: CALL_OW 250
85457: PUSH
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL_OW 251
85467: PUSH
85468: LD_VAR 0 1
85472: PPUSH
85473: CALL_OW 254
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: PPUSH
85484: CALL 21529 0 3
85488: ST_TO_ADDR
// if pos = 1 then
85489: LD_VAR 0 6
85493: PUSH
85494: LD_INT 1
85496: EQUAL
85497: IFFALSE 85612
// begin tmp := mc_build_list [ i ] ;
85499: LD_ADDR_VAR 0 7
85503: PUSH
85504: LD_EXP 64
85508: PUSH
85509: LD_VAR 0 3
85513: ARRAY
85514: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85515: LD_VAR 0 7
85519: PPUSH
85520: LD_INT 2
85522: PUSH
85523: LD_INT 30
85525: PUSH
85526: LD_INT 0
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 30
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: LIST
85547: PPUSH
85548: CALL_OW 72
85552: IFFALSE 85562
// pos := 2 ;
85554: LD_ADDR_VAR 0 6
85558: PUSH
85559: LD_INT 2
85561: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85562: LD_ADDR_VAR 0 7
85566: PUSH
85567: LD_VAR 0 7
85571: PPUSH
85572: LD_VAR 0 6
85576: PPUSH
85577: LD_VAR 0 7
85581: PPUSH
85582: CALL 21855 0 3
85586: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85587: LD_ADDR_EXP 64
85591: PUSH
85592: LD_EXP 64
85596: PPUSH
85597: LD_VAR 0 3
85601: PPUSH
85602: LD_VAR 0 7
85606: PPUSH
85607: CALL_OW 1
85611: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85612: LD_VAR 0 1
85616: PUSH
85617: LD_EXP 59
85621: PUSH
85622: LD_VAR 0 3
85626: ARRAY
85627: IN
85628: IFFALSE 85667
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85630: LD_ADDR_EXP 59
85634: PUSH
85635: LD_EXP 59
85639: PPUSH
85640: LD_VAR 0 3
85644: PPUSH
85645: LD_EXP 59
85649: PUSH
85650: LD_VAR 0 3
85654: ARRAY
85655: PUSH
85656: LD_VAR 0 1
85660: DIFF
85661: PPUSH
85662: CALL_OW 1
85666: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85667: LD_VAR 0 1
85671: PUSH
85672: LD_EXP 66
85676: PUSH
85677: LD_VAR 0 3
85681: ARRAY
85682: IN
85683: IFFALSE 85722
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85685: LD_ADDR_EXP 66
85689: PUSH
85690: LD_EXP 66
85694: PPUSH
85695: LD_VAR 0 3
85699: PPUSH
85700: LD_EXP 66
85704: PUSH
85705: LD_VAR 0 3
85709: ARRAY
85710: PUSH
85711: LD_VAR 0 1
85715: DIFF
85716: PPUSH
85717: CALL_OW 1
85721: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85722: LD_VAR 0 1
85726: PUSH
85727: LD_EXP 78
85731: PUSH
85732: LD_VAR 0 3
85736: ARRAY
85737: IN
85738: IFFALSE 85777
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85740: LD_ADDR_EXP 78
85744: PUSH
85745: LD_EXP 78
85749: PPUSH
85750: LD_VAR 0 3
85754: PPUSH
85755: LD_EXP 78
85759: PUSH
85760: LD_VAR 0 3
85764: ARRAY
85765: PUSH
85766: LD_VAR 0 1
85770: DIFF
85771: PPUSH
85772: CALL_OW 1
85776: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85777: LD_VAR 0 1
85781: PUSH
85782: LD_EXP 81
85786: PUSH
85787: LD_VAR 0 3
85791: ARRAY
85792: IN
85793: IFFALSE 85832
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85795: LD_ADDR_EXP 81
85799: PUSH
85800: LD_EXP 81
85804: PPUSH
85805: LD_VAR 0 3
85809: PPUSH
85810: LD_EXP 81
85814: PUSH
85815: LD_VAR 0 3
85819: ARRAY
85820: PUSH
85821: LD_VAR 0 1
85825: DIFF
85826: PPUSH
85827: CALL_OW 1
85831: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85832: LD_VAR 0 1
85836: PUSH
85837: LD_EXP 68
85841: PUSH
85842: LD_VAR 0 3
85846: ARRAY
85847: IN
85848: IFFALSE 85887
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85850: LD_ADDR_EXP 68
85854: PUSH
85855: LD_EXP 68
85859: PPUSH
85860: LD_VAR 0 3
85864: PPUSH
85865: LD_EXP 68
85869: PUSH
85870: LD_VAR 0 3
85874: ARRAY
85875: PUSH
85876: LD_VAR 0 1
85880: DIFF
85881: PPUSH
85882: CALL_OW 1
85886: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85887: LD_VAR 0 1
85891: PUSH
85892: LD_EXP 67
85896: PUSH
85897: LD_VAR 0 3
85901: ARRAY
85902: IN
85903: IFFALSE 85942
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85905: LD_ADDR_EXP 67
85909: PUSH
85910: LD_EXP 67
85914: PPUSH
85915: LD_VAR 0 3
85919: PPUSH
85920: LD_EXP 67
85924: PUSH
85925: LD_VAR 0 3
85929: ARRAY
85930: PUSH
85931: LD_VAR 0 1
85935: DIFF
85936: PPUSH
85937: CALL_OW 1
85941: ST_TO_ADDR
// end ; break ;
85942: GO 85946
// end ;
85944: GO 84592
85946: POP
85947: POP
// end ;
85948: LD_VAR 0 2
85952: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85953: LD_INT 0
85955: PPUSH
85956: PPUSH
85957: PPUSH
// if not mc_bases or not skirmish then
85958: LD_EXP 59
85962: NOT
85963: PUSH
85964: LD_EXP 57
85968: NOT
85969: OR
85970: IFFALSE 85974
// exit ;
85972: GO 86189
// for i = 1 to mc_bases do
85974: LD_ADDR_VAR 0 3
85978: PUSH
85979: DOUBLE
85980: LD_INT 1
85982: DEC
85983: ST_TO_ADDR
85984: LD_EXP 59
85988: PUSH
85989: FOR_TO
85990: IFFALSE 86187
// begin if building in mc_construct_list [ i ] then
85992: LD_VAR 0 1
85996: PUSH
85997: LD_EXP 66
86001: PUSH
86002: LD_VAR 0 3
86006: ARRAY
86007: IN
86008: IFFALSE 86185
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86010: LD_ADDR_EXP 66
86014: PUSH
86015: LD_EXP 66
86019: PPUSH
86020: LD_VAR 0 3
86024: PPUSH
86025: LD_EXP 66
86029: PUSH
86030: LD_VAR 0 3
86034: ARRAY
86035: PUSH
86036: LD_VAR 0 1
86040: DIFF
86041: PPUSH
86042: CALL_OW 1
86046: ST_TO_ADDR
// if building in mc_lab [ i ] then
86047: LD_VAR 0 1
86051: PUSH
86052: LD_EXP 92
86056: PUSH
86057: LD_VAR 0 3
86061: ARRAY
86062: IN
86063: IFFALSE 86118
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86065: LD_ADDR_EXP 93
86069: PUSH
86070: LD_EXP 93
86074: PPUSH
86075: LD_VAR 0 3
86079: PPUSH
86080: LD_EXP 93
86084: PUSH
86085: LD_VAR 0 3
86089: ARRAY
86090: PPUSH
86091: LD_INT 1
86093: PPUSH
86094: LD_EXP 93
86098: PUSH
86099: LD_VAR 0 3
86103: ARRAY
86104: PPUSH
86105: LD_INT 0
86107: PPUSH
86108: CALL 20947 0 4
86112: PPUSH
86113: CALL_OW 1
86117: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86118: LD_VAR 0 1
86122: PUSH
86123: LD_EXP 59
86127: PUSH
86128: LD_VAR 0 3
86132: ARRAY
86133: IN
86134: NOT
86135: IFFALSE 86181
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86137: LD_ADDR_EXP 59
86141: PUSH
86142: LD_EXP 59
86146: PPUSH
86147: LD_VAR 0 3
86151: PUSH
86152: LD_EXP 59
86156: PUSH
86157: LD_VAR 0 3
86161: ARRAY
86162: PUSH
86163: LD_INT 1
86165: PLUS
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PPUSH
86171: LD_VAR 0 1
86175: PPUSH
86176: CALL 21529 0 3
86180: ST_TO_ADDR
// exit ;
86181: POP
86182: POP
86183: GO 86189
// end ; end ;
86185: GO 85989
86187: POP
86188: POP
// end ;
86189: LD_VAR 0 2
86193: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86194: LD_INT 0
86196: PPUSH
86197: PPUSH
86198: PPUSH
86199: PPUSH
86200: PPUSH
86201: PPUSH
86202: PPUSH
// if not mc_bases or not skirmish then
86203: LD_EXP 59
86207: NOT
86208: PUSH
86209: LD_EXP 57
86213: NOT
86214: OR
86215: IFFALSE 86219
// exit ;
86217: GO 86880
// for i = 1 to mc_bases do
86219: LD_ADDR_VAR 0 3
86223: PUSH
86224: DOUBLE
86225: LD_INT 1
86227: DEC
86228: ST_TO_ADDR
86229: LD_EXP 59
86233: PUSH
86234: FOR_TO
86235: IFFALSE 86878
// begin if building in mc_construct_list [ i ] then
86237: LD_VAR 0 1
86241: PUSH
86242: LD_EXP 66
86246: PUSH
86247: LD_VAR 0 3
86251: ARRAY
86252: IN
86253: IFFALSE 86876
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86255: LD_ADDR_EXP 66
86259: PUSH
86260: LD_EXP 66
86264: PPUSH
86265: LD_VAR 0 3
86269: PPUSH
86270: LD_EXP 66
86274: PUSH
86275: LD_VAR 0 3
86279: ARRAY
86280: PUSH
86281: LD_VAR 0 1
86285: DIFF
86286: PPUSH
86287: CALL_OW 1
86291: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86292: LD_ADDR_EXP 59
86296: PUSH
86297: LD_EXP 59
86301: PPUSH
86302: LD_VAR 0 3
86306: PUSH
86307: LD_EXP 59
86311: PUSH
86312: LD_VAR 0 3
86316: ARRAY
86317: PUSH
86318: LD_INT 1
86320: PLUS
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PPUSH
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL 21529 0 3
86335: ST_TO_ADDR
// btype := GetBType ( building ) ;
86336: LD_ADDR_VAR 0 5
86340: PUSH
86341: LD_VAR 0 1
86345: PPUSH
86346: CALL_OW 266
86350: ST_TO_ADDR
// side := GetSide ( building ) ;
86351: LD_ADDR_VAR 0 8
86355: PUSH
86356: LD_VAR 0 1
86360: PPUSH
86361: CALL_OW 255
86365: ST_TO_ADDR
// if btype = b_lab then
86366: LD_VAR 0 5
86370: PUSH
86371: LD_INT 6
86373: EQUAL
86374: IFFALSE 86424
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86376: LD_ADDR_EXP 92
86380: PUSH
86381: LD_EXP 92
86385: PPUSH
86386: LD_VAR 0 3
86390: PUSH
86391: LD_EXP 92
86395: PUSH
86396: LD_VAR 0 3
86400: ARRAY
86401: PUSH
86402: LD_INT 1
86404: PLUS
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PPUSH
86410: LD_VAR 0 1
86414: PPUSH
86415: CALL 21529 0 3
86419: ST_TO_ADDR
// exit ;
86420: POP
86421: POP
86422: GO 86880
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86424: LD_VAR 0 5
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: LD_INT 2
86434: PUSH
86435: LD_INT 4
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: LIST
86442: IN
86443: IFFALSE 86567
// begin if btype = b_armoury then
86445: LD_VAR 0 5
86449: PUSH
86450: LD_INT 4
86452: EQUAL
86453: IFFALSE 86463
// btype := b_barracks ;
86455: LD_ADDR_VAR 0 5
86459: PUSH
86460: LD_INT 5
86462: ST_TO_ADDR
// if btype = b_depot then
86463: LD_VAR 0 5
86467: PUSH
86468: LD_INT 0
86470: EQUAL
86471: IFFALSE 86481
// btype := b_warehouse ;
86473: LD_ADDR_VAR 0 5
86477: PUSH
86478: LD_INT 1
86480: ST_TO_ADDR
// if btype = b_workshop then
86481: LD_VAR 0 5
86485: PUSH
86486: LD_INT 2
86488: EQUAL
86489: IFFALSE 86499
// btype := b_factory ;
86491: LD_ADDR_VAR 0 5
86495: PUSH
86496: LD_INT 3
86498: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86499: LD_VAR 0 5
86503: PPUSH
86504: LD_VAR 0 8
86508: PPUSH
86509: CALL_OW 323
86513: PUSH
86514: LD_INT 1
86516: EQUAL
86517: IFFALSE 86563
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86519: LD_ADDR_EXP 91
86523: PUSH
86524: LD_EXP 91
86528: PPUSH
86529: LD_VAR 0 3
86533: PUSH
86534: LD_EXP 91
86538: PUSH
86539: LD_VAR 0 3
86543: ARRAY
86544: PUSH
86545: LD_INT 1
86547: PLUS
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PPUSH
86553: LD_VAR 0 1
86557: PPUSH
86558: CALL 21529 0 3
86562: ST_TO_ADDR
// exit ;
86563: POP
86564: POP
86565: GO 86880
// end ; if btype in [ b_bunker , b_turret ] then
86567: LD_VAR 0 5
86571: PUSH
86572: LD_INT 32
86574: PUSH
86575: LD_INT 33
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: IN
86582: IFFALSE 86872
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86584: LD_ADDR_EXP 67
86588: PUSH
86589: LD_EXP 67
86593: PPUSH
86594: LD_VAR 0 3
86598: PUSH
86599: LD_EXP 67
86603: PUSH
86604: LD_VAR 0 3
86608: ARRAY
86609: PUSH
86610: LD_INT 1
86612: PLUS
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PPUSH
86618: LD_VAR 0 1
86622: PPUSH
86623: CALL 21529 0 3
86627: ST_TO_ADDR
// if btype = b_bunker then
86628: LD_VAR 0 5
86632: PUSH
86633: LD_INT 32
86635: EQUAL
86636: IFFALSE 86872
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86638: LD_ADDR_EXP 68
86642: PUSH
86643: LD_EXP 68
86647: PPUSH
86648: LD_VAR 0 3
86652: PUSH
86653: LD_EXP 68
86657: PUSH
86658: LD_VAR 0 3
86662: ARRAY
86663: PUSH
86664: LD_INT 1
86666: PLUS
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PPUSH
86672: LD_VAR 0 1
86676: PPUSH
86677: CALL 21529 0 3
86681: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86682: LD_ADDR_VAR 0 6
86686: PUSH
86687: LD_EXP 59
86691: PUSH
86692: LD_VAR 0 3
86696: ARRAY
86697: PPUSH
86698: LD_INT 25
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 3
86710: PUSH
86711: LD_INT 54
86713: PUSH
86714: EMPTY
86715: LIST
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PPUSH
86725: CALL_OW 72
86729: ST_TO_ADDR
// if tmp then
86730: LD_VAR 0 6
86734: IFFALSE 86740
// exit ;
86736: POP
86737: POP
86738: GO 86880
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86740: LD_ADDR_VAR 0 6
86744: PUSH
86745: LD_EXP 59
86749: PUSH
86750: LD_VAR 0 3
86754: ARRAY
86755: PPUSH
86756: LD_INT 2
86758: PUSH
86759: LD_INT 30
86761: PUSH
86762: LD_INT 4
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 30
86771: PUSH
86772: LD_INT 5
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: LIST
86783: PPUSH
86784: CALL_OW 72
86788: ST_TO_ADDR
// if not tmp then
86789: LD_VAR 0 6
86793: NOT
86794: IFFALSE 86800
// exit ;
86796: POP
86797: POP
86798: GO 86880
// for j in tmp do
86800: LD_ADDR_VAR 0 4
86804: PUSH
86805: LD_VAR 0 6
86809: PUSH
86810: FOR_IN
86811: IFFALSE 86870
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86813: LD_ADDR_VAR 0 7
86817: PUSH
86818: LD_VAR 0 4
86822: PPUSH
86823: CALL_OW 313
86827: PPUSH
86828: LD_INT 25
86830: PUSH
86831: LD_INT 1
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PPUSH
86838: CALL_OW 72
86842: ST_TO_ADDR
// if units then
86843: LD_VAR 0 7
86847: IFFALSE 86868
// begin ComExitBuilding ( units [ 1 ] ) ;
86849: LD_VAR 0 7
86853: PUSH
86854: LD_INT 1
86856: ARRAY
86857: PPUSH
86858: CALL_OW 122
// exit ;
86862: POP
86863: POP
86864: POP
86865: POP
86866: GO 86880
// end ; end ;
86868: GO 86810
86870: POP
86871: POP
// end ; end ; exit ;
86872: POP
86873: POP
86874: GO 86880
// end ; end ;
86876: GO 86234
86878: POP
86879: POP
// end ;
86880: LD_VAR 0 2
86884: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86885: LD_INT 0
86887: PPUSH
86888: PPUSH
86889: PPUSH
86890: PPUSH
86891: PPUSH
86892: PPUSH
86893: PPUSH
// if not mc_bases or not skirmish then
86894: LD_EXP 59
86898: NOT
86899: PUSH
86900: LD_EXP 57
86904: NOT
86905: OR
86906: IFFALSE 86910
// exit ;
86908: GO 87141
// btype := GetBType ( building ) ;
86910: LD_ADDR_VAR 0 6
86914: PUSH
86915: LD_VAR 0 1
86919: PPUSH
86920: CALL_OW 266
86924: ST_TO_ADDR
// x := GetX ( building ) ;
86925: LD_ADDR_VAR 0 7
86929: PUSH
86930: LD_VAR 0 1
86934: PPUSH
86935: CALL_OW 250
86939: ST_TO_ADDR
// y := GetY ( building ) ;
86940: LD_ADDR_VAR 0 8
86944: PUSH
86945: LD_VAR 0 1
86949: PPUSH
86950: CALL_OW 251
86954: ST_TO_ADDR
// d := GetDir ( building ) ;
86955: LD_ADDR_VAR 0 9
86959: PUSH
86960: LD_VAR 0 1
86964: PPUSH
86965: CALL_OW 254
86969: ST_TO_ADDR
// for i = 1 to mc_bases do
86970: LD_ADDR_VAR 0 4
86974: PUSH
86975: DOUBLE
86976: LD_INT 1
86978: DEC
86979: ST_TO_ADDR
86980: LD_EXP 59
86984: PUSH
86985: FOR_TO
86986: IFFALSE 87139
// begin if not mc_build_list [ i ] then
86988: LD_EXP 64
86992: PUSH
86993: LD_VAR 0 4
86997: ARRAY
86998: NOT
86999: IFFALSE 87003
// continue ;
87001: GO 86985
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
87003: LD_VAR 0 6
87007: PUSH
87008: LD_VAR 0 7
87012: PUSH
87013: LD_VAR 0 8
87017: PUSH
87018: LD_VAR 0 9
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: PPUSH
87029: LD_EXP 64
87033: PUSH
87034: LD_VAR 0 4
87038: ARRAY
87039: PUSH
87040: LD_INT 1
87042: ARRAY
87043: PPUSH
87044: CALL 27698 0 2
87048: IFFALSE 87137
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87050: LD_ADDR_EXP 64
87054: PUSH
87055: LD_EXP 64
87059: PPUSH
87060: LD_VAR 0 4
87064: PPUSH
87065: LD_EXP 64
87069: PUSH
87070: LD_VAR 0 4
87074: ARRAY
87075: PPUSH
87076: LD_INT 1
87078: PPUSH
87079: CALL_OW 3
87083: PPUSH
87084: CALL_OW 1
87088: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87089: LD_ADDR_EXP 66
87093: PUSH
87094: LD_EXP 66
87098: PPUSH
87099: LD_VAR 0 4
87103: PUSH
87104: LD_EXP 66
87108: PUSH
87109: LD_VAR 0 4
87113: ARRAY
87114: PUSH
87115: LD_INT 1
87117: PLUS
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PPUSH
87123: LD_VAR 0 1
87127: PPUSH
87128: CALL 21529 0 3
87132: ST_TO_ADDR
// exit ;
87133: POP
87134: POP
87135: GO 87141
// end ; end ;
87137: GO 86985
87139: POP
87140: POP
// end ;
87141: LD_VAR 0 3
87145: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87146: LD_INT 0
87148: PPUSH
87149: PPUSH
87150: PPUSH
// if not mc_bases or not skirmish then
87151: LD_EXP 59
87155: NOT
87156: PUSH
87157: LD_EXP 57
87161: NOT
87162: OR
87163: IFFALSE 87167
// exit ;
87165: GO 87357
// for i = 1 to mc_bases do
87167: LD_ADDR_VAR 0 4
87171: PUSH
87172: DOUBLE
87173: LD_INT 1
87175: DEC
87176: ST_TO_ADDR
87177: LD_EXP 59
87181: PUSH
87182: FOR_TO
87183: IFFALSE 87270
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87185: LD_VAR 0 1
87189: PUSH
87190: LD_EXP 67
87194: PUSH
87195: LD_VAR 0 4
87199: ARRAY
87200: IN
87201: PUSH
87202: LD_VAR 0 1
87206: PUSH
87207: LD_EXP 68
87211: PUSH
87212: LD_VAR 0 4
87216: ARRAY
87217: IN
87218: NOT
87219: AND
87220: IFFALSE 87268
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87222: LD_ADDR_EXP 68
87226: PUSH
87227: LD_EXP 68
87231: PPUSH
87232: LD_VAR 0 4
87236: PUSH
87237: LD_EXP 68
87241: PUSH
87242: LD_VAR 0 4
87246: ARRAY
87247: PUSH
87248: LD_INT 1
87250: PLUS
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PPUSH
87256: LD_VAR 0 1
87260: PPUSH
87261: CALL 21529 0 3
87265: ST_TO_ADDR
// break ;
87266: GO 87270
// end ; end ;
87268: GO 87182
87270: POP
87271: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87272: LD_VAR 0 1
87276: PPUSH
87277: CALL_OW 257
87281: PUSH
87282: LD_EXP 85
87286: IN
87287: PUSH
87288: LD_VAR 0 1
87292: PPUSH
87293: CALL_OW 266
87297: PUSH
87298: LD_INT 5
87300: EQUAL
87301: AND
87302: PUSH
87303: LD_VAR 0 2
87307: PPUSH
87308: CALL_OW 110
87312: PUSH
87313: LD_INT 18
87315: NONEQUAL
87316: AND
87317: IFFALSE 87357
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87319: LD_VAR 0 2
87323: PPUSH
87324: CALL_OW 257
87328: PUSH
87329: LD_INT 5
87331: PUSH
87332: LD_INT 8
87334: PUSH
87335: LD_INT 9
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: LIST
87342: IN
87343: IFFALSE 87357
// SetClass ( unit , 1 ) ;
87345: LD_VAR 0 2
87349: PPUSH
87350: LD_INT 1
87352: PPUSH
87353: CALL_OW 336
// end ;
87357: LD_VAR 0 3
87361: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87362: LD_INT 0
87364: PPUSH
87365: PPUSH
// if not mc_bases or not skirmish then
87366: LD_EXP 59
87370: NOT
87371: PUSH
87372: LD_EXP 57
87376: NOT
87377: OR
87378: IFFALSE 87382
// exit ;
87380: GO 87498
// if GetLives ( abandoned_vehicle ) > 250 then
87382: LD_VAR 0 2
87386: PPUSH
87387: CALL_OW 256
87391: PUSH
87392: LD_INT 250
87394: GREATER
87395: IFFALSE 87399
// exit ;
87397: GO 87498
// for i = 1 to mc_bases do
87399: LD_ADDR_VAR 0 6
87403: PUSH
87404: DOUBLE
87405: LD_INT 1
87407: DEC
87408: ST_TO_ADDR
87409: LD_EXP 59
87413: PUSH
87414: FOR_TO
87415: IFFALSE 87496
// begin if driver in mc_bases [ i ] then
87417: LD_VAR 0 1
87421: PUSH
87422: LD_EXP 59
87426: PUSH
87427: LD_VAR 0 6
87431: ARRAY
87432: IN
87433: IFFALSE 87494
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87435: LD_VAR 0 1
87439: PPUSH
87440: LD_EXP 59
87444: PUSH
87445: LD_VAR 0 6
87449: ARRAY
87450: PPUSH
87451: LD_INT 2
87453: PUSH
87454: LD_INT 30
87456: PUSH
87457: LD_INT 0
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 30
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: LIST
87478: PPUSH
87479: CALL_OW 72
87483: PUSH
87484: LD_INT 1
87486: ARRAY
87487: PPUSH
87488: CALL_OW 112
// break ;
87492: GO 87496
// end ; end ;
87494: GO 87414
87496: POP
87497: POP
// end ; end_of_file
87498: LD_VAR 0 5
87502: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87503: GO 87505
87505: DISABLE
// begin ru_radar := 98 ;
87506: LD_ADDR_EXP 102
87510: PUSH
87511: LD_INT 98
87513: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87514: LD_ADDR_EXP 103
87518: PUSH
87519: LD_INT 89
87521: ST_TO_ADDR
// us_hack := 99 ;
87522: LD_ADDR_EXP 104
87526: PUSH
87527: LD_INT 99
87529: ST_TO_ADDR
// us_artillery := 97 ;
87530: LD_ADDR_EXP 105
87534: PUSH
87535: LD_INT 97
87537: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87538: LD_ADDR_EXP 106
87542: PUSH
87543: LD_INT 91
87545: ST_TO_ADDR
// end ; end_of_file end_of_file
87546: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87547: GO 87549
87549: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87550: LD_STRING initStreamRollete();
87552: PPUSH
87553: CALL_OW 559
// InitStreamMode ;
87557: CALL 87566 0 0
// DefineStreamItems ( ) ;
87561: CALL 88006 0 0
// end ;
87565: END
// function InitStreamMode ; begin
87566: LD_INT 0
87568: PPUSH
// streamModeActive := false ;
87569: LD_ADDR_EXP 107
87573: PUSH
87574: LD_INT 0
87576: ST_TO_ADDR
// normalCounter := 26 ;
87577: LD_ADDR_EXP 108
87581: PUSH
87582: LD_INT 26
87584: ST_TO_ADDR
// hardcoreCounter := 12 ;
87585: LD_ADDR_EXP 109
87589: PUSH
87590: LD_INT 12
87592: ST_TO_ADDR
// sRocket := false ;
87593: LD_ADDR_EXP 112
87597: PUSH
87598: LD_INT 0
87600: ST_TO_ADDR
// sSpeed := false ;
87601: LD_ADDR_EXP 111
87605: PUSH
87606: LD_INT 0
87608: ST_TO_ADDR
// sEngine := false ;
87609: LD_ADDR_EXP 113
87613: PUSH
87614: LD_INT 0
87616: ST_TO_ADDR
// sSpec := false ;
87617: LD_ADDR_EXP 110
87621: PUSH
87622: LD_INT 0
87624: ST_TO_ADDR
// sLevel := false ;
87625: LD_ADDR_EXP 114
87629: PUSH
87630: LD_INT 0
87632: ST_TO_ADDR
// sArmoury := false ;
87633: LD_ADDR_EXP 115
87637: PUSH
87638: LD_INT 0
87640: ST_TO_ADDR
// sRadar := false ;
87641: LD_ADDR_EXP 116
87645: PUSH
87646: LD_INT 0
87648: ST_TO_ADDR
// sBunker := false ;
87649: LD_ADDR_EXP 117
87653: PUSH
87654: LD_INT 0
87656: ST_TO_ADDR
// sHack := false ;
87657: LD_ADDR_EXP 118
87661: PUSH
87662: LD_INT 0
87664: ST_TO_ADDR
// sFire := false ;
87665: LD_ADDR_EXP 119
87669: PUSH
87670: LD_INT 0
87672: ST_TO_ADDR
// sRefresh := false ;
87673: LD_ADDR_EXP 120
87677: PUSH
87678: LD_INT 0
87680: ST_TO_ADDR
// sExp := false ;
87681: LD_ADDR_EXP 121
87685: PUSH
87686: LD_INT 0
87688: ST_TO_ADDR
// sDepot := false ;
87689: LD_ADDR_EXP 122
87693: PUSH
87694: LD_INT 0
87696: ST_TO_ADDR
// sFlag := false ;
87697: LD_ADDR_EXP 123
87701: PUSH
87702: LD_INT 0
87704: ST_TO_ADDR
// sKamikadze := false ;
87705: LD_ADDR_EXP 131
87709: PUSH
87710: LD_INT 0
87712: ST_TO_ADDR
// sTroll := false ;
87713: LD_ADDR_EXP 132
87717: PUSH
87718: LD_INT 0
87720: ST_TO_ADDR
// sSlow := false ;
87721: LD_ADDR_EXP 133
87725: PUSH
87726: LD_INT 0
87728: ST_TO_ADDR
// sLack := false ;
87729: LD_ADDR_EXP 134
87733: PUSH
87734: LD_INT 0
87736: ST_TO_ADDR
// sTank := false ;
87737: LD_ADDR_EXP 136
87741: PUSH
87742: LD_INT 0
87744: ST_TO_ADDR
// sRemote := false ;
87745: LD_ADDR_EXP 137
87749: PUSH
87750: LD_INT 0
87752: ST_TO_ADDR
// sPowell := false ;
87753: LD_ADDR_EXP 138
87757: PUSH
87758: LD_INT 0
87760: ST_TO_ADDR
// sTeleport := false ;
87761: LD_ADDR_EXP 141
87765: PUSH
87766: LD_INT 0
87768: ST_TO_ADDR
// sOilTower := false ;
87769: LD_ADDR_EXP 143
87773: PUSH
87774: LD_INT 0
87776: ST_TO_ADDR
// sShovel := false ;
87777: LD_ADDR_EXP 144
87781: PUSH
87782: LD_INT 0
87784: ST_TO_ADDR
// sSheik := false ;
87785: LD_ADDR_EXP 145
87789: PUSH
87790: LD_INT 0
87792: ST_TO_ADDR
// sEarthquake := false ;
87793: LD_ADDR_EXP 147
87797: PUSH
87798: LD_INT 0
87800: ST_TO_ADDR
// sAI := false ;
87801: LD_ADDR_EXP 148
87805: PUSH
87806: LD_INT 0
87808: ST_TO_ADDR
// sCargo := false ;
87809: LD_ADDR_EXP 151
87813: PUSH
87814: LD_INT 0
87816: ST_TO_ADDR
// sDLaser := false ;
87817: LD_ADDR_EXP 152
87821: PUSH
87822: LD_INT 0
87824: ST_TO_ADDR
// sExchange := false ;
87825: LD_ADDR_EXP 153
87829: PUSH
87830: LD_INT 0
87832: ST_TO_ADDR
// sFac := false ;
87833: LD_ADDR_EXP 154
87837: PUSH
87838: LD_INT 0
87840: ST_TO_ADDR
// sPower := false ;
87841: LD_ADDR_EXP 155
87845: PUSH
87846: LD_INT 0
87848: ST_TO_ADDR
// sRandom := false ;
87849: LD_ADDR_EXP 156
87853: PUSH
87854: LD_INT 0
87856: ST_TO_ADDR
// sShield := false ;
87857: LD_ADDR_EXP 157
87861: PUSH
87862: LD_INT 0
87864: ST_TO_ADDR
// sTime := false ;
87865: LD_ADDR_EXP 158
87869: PUSH
87870: LD_INT 0
87872: ST_TO_ADDR
// sTools := false ;
87873: LD_ADDR_EXP 159
87877: PUSH
87878: LD_INT 0
87880: ST_TO_ADDR
// sSold := false ;
87881: LD_ADDR_EXP 124
87885: PUSH
87886: LD_INT 0
87888: ST_TO_ADDR
// sDiff := false ;
87889: LD_ADDR_EXP 125
87893: PUSH
87894: LD_INT 0
87896: ST_TO_ADDR
// sFog := false ;
87897: LD_ADDR_EXP 128
87901: PUSH
87902: LD_INT 0
87904: ST_TO_ADDR
// sReset := false ;
87905: LD_ADDR_EXP 129
87909: PUSH
87910: LD_INT 0
87912: ST_TO_ADDR
// sSun := false ;
87913: LD_ADDR_EXP 130
87917: PUSH
87918: LD_INT 0
87920: ST_TO_ADDR
// sTiger := false ;
87921: LD_ADDR_EXP 126
87925: PUSH
87926: LD_INT 0
87928: ST_TO_ADDR
// sBomb := false ;
87929: LD_ADDR_EXP 127
87933: PUSH
87934: LD_INT 0
87936: ST_TO_ADDR
// sWound := false ;
87937: LD_ADDR_EXP 135
87941: PUSH
87942: LD_INT 0
87944: ST_TO_ADDR
// sBetray := false ;
87945: LD_ADDR_EXP 139
87949: PUSH
87950: LD_INT 0
87952: ST_TO_ADDR
// sContamin := false ;
87953: LD_ADDR_EXP 140
87957: PUSH
87958: LD_INT 0
87960: ST_TO_ADDR
// sOil := false ;
87961: LD_ADDR_EXP 142
87965: PUSH
87966: LD_INT 0
87968: ST_TO_ADDR
// sStu := false ;
87969: LD_ADDR_EXP 146
87973: PUSH
87974: LD_INT 0
87976: ST_TO_ADDR
// sBazooka := false ;
87977: LD_ADDR_EXP 149
87981: PUSH
87982: LD_INT 0
87984: ST_TO_ADDR
// sMortar := false ;
87985: LD_ADDR_EXP 150
87989: PUSH
87990: LD_INT 0
87992: ST_TO_ADDR
// sRanger := false ;
87993: LD_ADDR_EXP 160
87997: PUSH
87998: LD_INT 0
88000: ST_TO_ADDR
// end ;
88001: LD_VAR 0 1
88005: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88006: LD_INT 0
88008: PPUSH
88009: PPUSH
88010: PPUSH
88011: PPUSH
88012: PPUSH
// result := [ ] ;
88013: LD_ADDR_VAR 0 1
88017: PUSH
88018: EMPTY
88019: ST_TO_ADDR
// if campaign_id = 1 then
88020: LD_OWVAR 69
88024: PUSH
88025: LD_INT 1
88027: EQUAL
88028: IFFALSE 90964
// begin case mission_number of 1 :
88030: LD_OWVAR 70
88034: PUSH
88035: LD_INT 1
88037: DOUBLE
88038: EQUAL
88039: IFTRUE 88043
88041: GO 88107
88043: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88044: LD_ADDR_VAR 0 1
88048: PUSH
88049: LD_INT 2
88051: PUSH
88052: LD_INT 4
88054: PUSH
88055: LD_INT 11
88057: PUSH
88058: LD_INT 12
88060: PUSH
88061: LD_INT 15
88063: PUSH
88064: LD_INT 16
88066: PUSH
88067: LD_INT 22
88069: PUSH
88070: LD_INT 23
88072: PUSH
88073: LD_INT 26
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 101
88089: PUSH
88090: LD_INT 102
88092: PUSH
88093: LD_INT 106
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: LIST
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: ST_TO_ADDR
88105: GO 90964
88107: LD_INT 2
88109: DOUBLE
88110: EQUAL
88111: IFTRUE 88115
88113: GO 88187
88115: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88116: LD_ADDR_VAR 0 1
88120: PUSH
88121: LD_INT 2
88123: PUSH
88124: LD_INT 4
88126: PUSH
88127: LD_INT 11
88129: PUSH
88130: LD_INT 12
88132: PUSH
88133: LD_INT 15
88135: PUSH
88136: LD_INT 16
88138: PUSH
88139: LD_INT 22
88141: PUSH
88142: LD_INT 23
88144: PUSH
88145: LD_INT 26
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 101
88161: PUSH
88162: LD_INT 102
88164: PUSH
88165: LD_INT 105
88167: PUSH
88168: LD_INT 106
88170: PUSH
88171: LD_INT 108
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: ST_TO_ADDR
88185: GO 90964
88187: LD_INT 3
88189: DOUBLE
88190: EQUAL
88191: IFTRUE 88195
88193: GO 88271
88195: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88196: LD_ADDR_VAR 0 1
88200: PUSH
88201: LD_INT 2
88203: PUSH
88204: LD_INT 4
88206: PUSH
88207: LD_INT 5
88209: PUSH
88210: LD_INT 11
88212: PUSH
88213: LD_INT 12
88215: PUSH
88216: LD_INT 15
88218: PUSH
88219: LD_INT 16
88221: PUSH
88222: LD_INT 22
88224: PUSH
88225: LD_INT 26
88227: PUSH
88228: LD_INT 36
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 101
88245: PUSH
88246: LD_INT 102
88248: PUSH
88249: LD_INT 105
88251: PUSH
88252: LD_INT 106
88254: PUSH
88255: LD_INT 108
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: ST_TO_ADDR
88269: GO 90964
88271: LD_INT 4
88273: DOUBLE
88274: EQUAL
88275: IFTRUE 88279
88277: GO 88363
88279: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
88280: LD_ADDR_VAR 0 1
88284: PUSH
88285: LD_INT 2
88287: PUSH
88288: LD_INT 4
88290: PUSH
88291: LD_INT 5
88293: PUSH
88294: LD_INT 8
88296: PUSH
88297: LD_INT 11
88299: PUSH
88300: LD_INT 12
88302: PUSH
88303: LD_INT 15
88305: PUSH
88306: LD_INT 16
88308: PUSH
88309: LD_INT 22
88311: PUSH
88312: LD_INT 23
88314: PUSH
88315: LD_INT 26
88317: PUSH
88318: LD_INT 36
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: PUSH
88335: LD_INT 101
88337: PUSH
88338: LD_INT 102
88340: PUSH
88341: LD_INT 105
88343: PUSH
88344: LD_INT 106
88346: PUSH
88347: LD_INT 108
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: ST_TO_ADDR
88361: GO 90964
88363: LD_INT 5
88365: DOUBLE
88366: EQUAL
88367: IFTRUE 88371
88369: GO 88471
88371: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
88372: LD_ADDR_VAR 0 1
88376: PUSH
88377: LD_INT 2
88379: PUSH
88380: LD_INT 4
88382: PUSH
88383: LD_INT 5
88385: PUSH
88386: LD_INT 6
88388: PUSH
88389: LD_INT 8
88391: PUSH
88392: LD_INT 11
88394: PUSH
88395: LD_INT 12
88397: PUSH
88398: LD_INT 15
88400: PUSH
88401: LD_INT 16
88403: PUSH
88404: LD_INT 22
88406: PUSH
88407: LD_INT 23
88409: PUSH
88410: LD_INT 25
88412: PUSH
88413: LD_INT 26
88415: PUSH
88416: LD_INT 36
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 101
88437: PUSH
88438: LD_INT 102
88440: PUSH
88441: LD_INT 105
88443: PUSH
88444: LD_INT 106
88446: PUSH
88447: LD_INT 108
88449: PUSH
88450: LD_INT 109
88452: PUSH
88453: LD_INT 112
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: ST_TO_ADDR
88469: GO 90964
88471: LD_INT 6
88473: DOUBLE
88474: EQUAL
88475: IFTRUE 88479
88477: GO 88599
88479: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
88480: LD_ADDR_VAR 0 1
88484: PUSH
88485: LD_INT 2
88487: PUSH
88488: LD_INT 4
88490: PUSH
88491: LD_INT 5
88493: PUSH
88494: LD_INT 6
88496: PUSH
88497: LD_INT 8
88499: PUSH
88500: LD_INT 11
88502: PUSH
88503: LD_INT 12
88505: PUSH
88506: LD_INT 15
88508: PUSH
88509: LD_INT 16
88511: PUSH
88512: LD_INT 20
88514: PUSH
88515: LD_INT 21
88517: PUSH
88518: LD_INT 22
88520: PUSH
88521: LD_INT 23
88523: PUSH
88524: LD_INT 25
88526: PUSH
88527: LD_INT 26
88529: PUSH
88530: LD_INT 30
88532: PUSH
88533: LD_INT 31
88535: PUSH
88536: LD_INT 32
88538: PUSH
88539: LD_INT 36
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 101
88565: PUSH
88566: LD_INT 102
88568: PUSH
88569: LD_INT 105
88571: PUSH
88572: LD_INT 106
88574: PUSH
88575: LD_INT 108
88577: PUSH
88578: LD_INT 109
88580: PUSH
88581: LD_INT 112
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: ST_TO_ADDR
88597: GO 90964
88599: LD_INT 7
88601: DOUBLE
88602: EQUAL
88603: IFTRUE 88607
88605: GO 88707
88607: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88608: LD_ADDR_VAR 0 1
88612: PUSH
88613: LD_INT 2
88615: PUSH
88616: LD_INT 4
88618: PUSH
88619: LD_INT 5
88621: PUSH
88622: LD_INT 7
88624: PUSH
88625: LD_INT 11
88627: PUSH
88628: LD_INT 12
88630: PUSH
88631: LD_INT 15
88633: PUSH
88634: LD_INT 16
88636: PUSH
88637: LD_INT 20
88639: PUSH
88640: LD_INT 21
88642: PUSH
88643: LD_INT 22
88645: PUSH
88646: LD_INT 23
88648: PUSH
88649: LD_INT 25
88651: PUSH
88652: LD_INT 26
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 101
88673: PUSH
88674: LD_INT 102
88676: PUSH
88677: LD_INT 103
88679: PUSH
88680: LD_INT 105
88682: PUSH
88683: LD_INT 106
88685: PUSH
88686: LD_INT 108
88688: PUSH
88689: LD_INT 112
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: ST_TO_ADDR
88705: GO 90964
88707: LD_INT 8
88709: DOUBLE
88710: EQUAL
88711: IFTRUE 88715
88713: GO 88843
88715: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88716: LD_ADDR_VAR 0 1
88720: PUSH
88721: LD_INT 2
88723: PUSH
88724: LD_INT 4
88726: PUSH
88727: LD_INT 5
88729: PUSH
88730: LD_INT 6
88732: PUSH
88733: LD_INT 7
88735: PUSH
88736: LD_INT 8
88738: PUSH
88739: LD_INT 11
88741: PUSH
88742: LD_INT 12
88744: PUSH
88745: LD_INT 15
88747: PUSH
88748: LD_INT 16
88750: PUSH
88751: LD_INT 20
88753: PUSH
88754: LD_INT 21
88756: PUSH
88757: LD_INT 22
88759: PUSH
88760: LD_INT 23
88762: PUSH
88763: LD_INT 25
88765: PUSH
88766: LD_INT 26
88768: PUSH
88769: LD_INT 30
88771: PUSH
88772: LD_INT 31
88774: PUSH
88775: LD_INT 32
88777: PUSH
88778: LD_INT 36
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 101
88805: PUSH
88806: LD_INT 102
88808: PUSH
88809: LD_INT 103
88811: PUSH
88812: LD_INT 105
88814: PUSH
88815: LD_INT 106
88817: PUSH
88818: LD_INT 108
88820: PUSH
88821: LD_INT 109
88823: PUSH
88824: LD_INT 112
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: ST_TO_ADDR
88841: GO 90964
88843: LD_INT 9
88845: DOUBLE
88846: EQUAL
88847: IFTRUE 88851
88849: GO 88987
88851: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88852: LD_ADDR_VAR 0 1
88856: PUSH
88857: LD_INT 2
88859: PUSH
88860: LD_INT 4
88862: PUSH
88863: LD_INT 5
88865: PUSH
88866: LD_INT 6
88868: PUSH
88869: LD_INT 7
88871: PUSH
88872: LD_INT 8
88874: PUSH
88875: LD_INT 11
88877: PUSH
88878: LD_INT 12
88880: PUSH
88881: LD_INT 15
88883: PUSH
88884: LD_INT 16
88886: PUSH
88887: LD_INT 20
88889: PUSH
88890: LD_INT 21
88892: PUSH
88893: LD_INT 22
88895: PUSH
88896: LD_INT 23
88898: PUSH
88899: LD_INT 25
88901: PUSH
88902: LD_INT 26
88904: PUSH
88905: LD_INT 28
88907: PUSH
88908: LD_INT 30
88910: PUSH
88911: LD_INT 31
88913: PUSH
88914: LD_INT 32
88916: PUSH
88917: LD_INT 36
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 101
88945: PUSH
88946: LD_INT 102
88948: PUSH
88949: LD_INT 103
88951: PUSH
88952: LD_INT 105
88954: PUSH
88955: LD_INT 106
88957: PUSH
88958: LD_INT 108
88960: PUSH
88961: LD_INT 109
88963: PUSH
88964: LD_INT 112
88966: PUSH
88967: LD_INT 114
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: ST_TO_ADDR
88985: GO 90964
88987: LD_INT 10
88989: DOUBLE
88990: EQUAL
88991: IFTRUE 88995
88993: GO 89179
88995: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
88996: LD_ADDR_VAR 0 1
89000: PUSH
89001: LD_INT 2
89003: PUSH
89004: LD_INT 4
89006: PUSH
89007: LD_INT 5
89009: PUSH
89010: LD_INT 6
89012: PUSH
89013: LD_INT 7
89015: PUSH
89016: LD_INT 8
89018: PUSH
89019: LD_INT 9
89021: PUSH
89022: LD_INT 10
89024: PUSH
89025: LD_INT 11
89027: PUSH
89028: LD_INT 12
89030: PUSH
89031: LD_INT 13
89033: PUSH
89034: LD_INT 14
89036: PUSH
89037: LD_INT 15
89039: PUSH
89040: LD_INT 16
89042: PUSH
89043: LD_INT 17
89045: PUSH
89046: LD_INT 18
89048: PUSH
89049: LD_INT 19
89051: PUSH
89052: LD_INT 20
89054: PUSH
89055: LD_INT 21
89057: PUSH
89058: LD_INT 22
89060: PUSH
89061: LD_INT 23
89063: PUSH
89064: LD_INT 24
89066: PUSH
89067: LD_INT 25
89069: PUSH
89070: LD_INT 26
89072: PUSH
89073: LD_INT 28
89075: PUSH
89076: LD_INT 30
89078: PUSH
89079: LD_INT 31
89081: PUSH
89082: LD_INT 32
89084: PUSH
89085: LD_INT 36
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 101
89121: PUSH
89122: LD_INT 102
89124: PUSH
89125: LD_INT 103
89127: PUSH
89128: LD_INT 104
89130: PUSH
89131: LD_INT 105
89133: PUSH
89134: LD_INT 106
89136: PUSH
89137: LD_INT 107
89139: PUSH
89140: LD_INT 108
89142: PUSH
89143: LD_INT 109
89145: PUSH
89146: LD_INT 110
89148: PUSH
89149: LD_INT 111
89151: PUSH
89152: LD_INT 112
89154: PUSH
89155: LD_INT 114
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: ST_TO_ADDR
89177: GO 90964
89179: LD_INT 11
89181: DOUBLE
89182: EQUAL
89183: IFTRUE 89187
89185: GO 89379
89187: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89188: LD_ADDR_VAR 0 1
89192: PUSH
89193: LD_INT 2
89195: PUSH
89196: LD_INT 3
89198: PUSH
89199: LD_INT 4
89201: PUSH
89202: LD_INT 5
89204: PUSH
89205: LD_INT 6
89207: PUSH
89208: LD_INT 7
89210: PUSH
89211: LD_INT 8
89213: PUSH
89214: LD_INT 9
89216: PUSH
89217: LD_INT 10
89219: PUSH
89220: LD_INT 11
89222: PUSH
89223: LD_INT 12
89225: PUSH
89226: LD_INT 13
89228: PUSH
89229: LD_INT 14
89231: PUSH
89232: LD_INT 15
89234: PUSH
89235: LD_INT 16
89237: PUSH
89238: LD_INT 17
89240: PUSH
89241: LD_INT 18
89243: PUSH
89244: LD_INT 19
89246: PUSH
89247: LD_INT 20
89249: PUSH
89250: LD_INT 21
89252: PUSH
89253: LD_INT 22
89255: PUSH
89256: LD_INT 23
89258: PUSH
89259: LD_INT 24
89261: PUSH
89262: LD_INT 25
89264: PUSH
89265: LD_INT 26
89267: PUSH
89268: LD_INT 28
89270: PUSH
89271: LD_INT 30
89273: PUSH
89274: LD_INT 31
89276: PUSH
89277: LD_INT 32
89279: PUSH
89280: LD_INT 34
89282: PUSH
89283: LD_INT 36
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: PUSH
89319: LD_INT 101
89321: PUSH
89322: LD_INT 102
89324: PUSH
89325: LD_INT 103
89327: PUSH
89328: LD_INT 104
89330: PUSH
89331: LD_INT 105
89333: PUSH
89334: LD_INT 106
89336: PUSH
89337: LD_INT 107
89339: PUSH
89340: LD_INT 108
89342: PUSH
89343: LD_INT 109
89345: PUSH
89346: LD_INT 110
89348: PUSH
89349: LD_INT 111
89351: PUSH
89352: LD_INT 112
89354: PUSH
89355: LD_INT 114
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: ST_TO_ADDR
89377: GO 90964
89379: LD_INT 12
89381: DOUBLE
89382: EQUAL
89383: IFTRUE 89387
89385: GO 89595
89387: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
89388: LD_ADDR_VAR 0 1
89392: PUSH
89393: LD_INT 1
89395: PUSH
89396: LD_INT 2
89398: PUSH
89399: LD_INT 3
89401: PUSH
89402: LD_INT 4
89404: PUSH
89405: LD_INT 5
89407: PUSH
89408: LD_INT 6
89410: PUSH
89411: LD_INT 7
89413: PUSH
89414: LD_INT 8
89416: PUSH
89417: LD_INT 9
89419: PUSH
89420: LD_INT 10
89422: PUSH
89423: LD_INT 11
89425: PUSH
89426: LD_INT 12
89428: PUSH
89429: LD_INT 13
89431: PUSH
89432: LD_INT 14
89434: PUSH
89435: LD_INT 15
89437: PUSH
89438: LD_INT 16
89440: PUSH
89441: LD_INT 17
89443: PUSH
89444: LD_INT 18
89446: PUSH
89447: LD_INT 19
89449: PUSH
89450: LD_INT 20
89452: PUSH
89453: LD_INT 21
89455: PUSH
89456: LD_INT 22
89458: PUSH
89459: LD_INT 23
89461: PUSH
89462: LD_INT 24
89464: PUSH
89465: LD_INT 25
89467: PUSH
89468: LD_INT 26
89470: PUSH
89471: LD_INT 27
89473: PUSH
89474: LD_INT 28
89476: PUSH
89477: LD_INT 30
89479: PUSH
89480: LD_INT 31
89482: PUSH
89483: LD_INT 32
89485: PUSH
89486: LD_INT 33
89488: PUSH
89489: LD_INT 34
89491: PUSH
89492: LD_INT 36
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 101
89533: PUSH
89534: LD_INT 102
89536: PUSH
89537: LD_INT 103
89539: PUSH
89540: LD_INT 104
89542: PUSH
89543: LD_INT 105
89545: PUSH
89546: LD_INT 106
89548: PUSH
89549: LD_INT 107
89551: PUSH
89552: LD_INT 108
89554: PUSH
89555: LD_INT 109
89557: PUSH
89558: LD_INT 110
89560: PUSH
89561: LD_INT 111
89563: PUSH
89564: LD_INT 112
89566: PUSH
89567: LD_INT 113
89569: PUSH
89570: LD_INT 114
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: ST_TO_ADDR
89593: GO 90964
89595: LD_INT 13
89597: DOUBLE
89598: EQUAL
89599: IFTRUE 89603
89601: GO 89799
89603: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89604: LD_ADDR_VAR 0 1
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: LD_INT 2
89614: PUSH
89615: LD_INT 3
89617: PUSH
89618: LD_INT 4
89620: PUSH
89621: LD_INT 5
89623: PUSH
89624: LD_INT 8
89626: PUSH
89627: LD_INT 9
89629: PUSH
89630: LD_INT 10
89632: PUSH
89633: LD_INT 11
89635: PUSH
89636: LD_INT 12
89638: PUSH
89639: LD_INT 14
89641: PUSH
89642: LD_INT 15
89644: PUSH
89645: LD_INT 16
89647: PUSH
89648: LD_INT 17
89650: PUSH
89651: LD_INT 18
89653: PUSH
89654: LD_INT 19
89656: PUSH
89657: LD_INT 20
89659: PUSH
89660: LD_INT 21
89662: PUSH
89663: LD_INT 22
89665: PUSH
89666: LD_INT 23
89668: PUSH
89669: LD_INT 24
89671: PUSH
89672: LD_INT 25
89674: PUSH
89675: LD_INT 26
89677: PUSH
89678: LD_INT 27
89680: PUSH
89681: LD_INT 28
89683: PUSH
89684: LD_INT 30
89686: PUSH
89687: LD_INT 31
89689: PUSH
89690: LD_INT 32
89692: PUSH
89693: LD_INT 33
89695: PUSH
89696: LD_INT 34
89698: PUSH
89699: LD_INT 36
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 101
89737: PUSH
89738: LD_INT 102
89740: PUSH
89741: LD_INT 103
89743: PUSH
89744: LD_INT 104
89746: PUSH
89747: LD_INT 105
89749: PUSH
89750: LD_INT 106
89752: PUSH
89753: LD_INT 107
89755: PUSH
89756: LD_INT 108
89758: PUSH
89759: LD_INT 109
89761: PUSH
89762: LD_INT 110
89764: PUSH
89765: LD_INT 111
89767: PUSH
89768: LD_INT 112
89770: PUSH
89771: LD_INT 113
89773: PUSH
89774: LD_INT 114
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: ST_TO_ADDR
89797: GO 90964
89799: LD_INT 14
89801: DOUBLE
89802: EQUAL
89803: IFTRUE 89807
89805: GO 90019
89807: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89808: LD_ADDR_VAR 0 1
89812: PUSH
89813: LD_INT 1
89815: PUSH
89816: LD_INT 2
89818: PUSH
89819: LD_INT 3
89821: PUSH
89822: LD_INT 4
89824: PUSH
89825: LD_INT 5
89827: PUSH
89828: LD_INT 6
89830: PUSH
89831: LD_INT 7
89833: PUSH
89834: LD_INT 8
89836: PUSH
89837: LD_INT 9
89839: PUSH
89840: LD_INT 10
89842: PUSH
89843: LD_INT 11
89845: PUSH
89846: LD_INT 12
89848: PUSH
89849: LD_INT 13
89851: PUSH
89852: LD_INT 14
89854: PUSH
89855: LD_INT 15
89857: PUSH
89858: LD_INT 16
89860: PUSH
89861: LD_INT 17
89863: PUSH
89864: LD_INT 18
89866: PUSH
89867: LD_INT 19
89869: PUSH
89870: LD_INT 20
89872: PUSH
89873: LD_INT 21
89875: PUSH
89876: LD_INT 22
89878: PUSH
89879: LD_INT 23
89881: PUSH
89882: LD_INT 24
89884: PUSH
89885: LD_INT 25
89887: PUSH
89888: LD_INT 26
89890: PUSH
89891: LD_INT 27
89893: PUSH
89894: LD_INT 28
89896: PUSH
89897: LD_INT 29
89899: PUSH
89900: LD_INT 30
89902: PUSH
89903: LD_INT 31
89905: PUSH
89906: LD_INT 32
89908: PUSH
89909: LD_INT 33
89911: PUSH
89912: LD_INT 34
89914: PUSH
89915: LD_INT 36
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 101
89957: PUSH
89958: LD_INT 102
89960: PUSH
89961: LD_INT 103
89963: PUSH
89964: LD_INT 104
89966: PUSH
89967: LD_INT 105
89969: PUSH
89970: LD_INT 106
89972: PUSH
89973: LD_INT 107
89975: PUSH
89976: LD_INT 108
89978: PUSH
89979: LD_INT 109
89981: PUSH
89982: LD_INT 110
89984: PUSH
89985: LD_INT 111
89987: PUSH
89988: LD_INT 112
89990: PUSH
89991: LD_INT 113
89993: PUSH
89994: LD_INT 114
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: ST_TO_ADDR
90017: GO 90964
90019: LD_INT 15
90021: DOUBLE
90022: EQUAL
90023: IFTRUE 90027
90025: GO 90239
90027: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90028: LD_ADDR_VAR 0 1
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: LD_INT 2
90038: PUSH
90039: LD_INT 3
90041: PUSH
90042: LD_INT 4
90044: PUSH
90045: LD_INT 5
90047: PUSH
90048: LD_INT 6
90050: PUSH
90051: LD_INT 7
90053: PUSH
90054: LD_INT 8
90056: PUSH
90057: LD_INT 9
90059: PUSH
90060: LD_INT 10
90062: PUSH
90063: LD_INT 11
90065: PUSH
90066: LD_INT 12
90068: PUSH
90069: LD_INT 13
90071: PUSH
90072: LD_INT 14
90074: PUSH
90075: LD_INT 15
90077: PUSH
90078: LD_INT 16
90080: PUSH
90081: LD_INT 17
90083: PUSH
90084: LD_INT 18
90086: PUSH
90087: LD_INT 19
90089: PUSH
90090: LD_INT 20
90092: PUSH
90093: LD_INT 21
90095: PUSH
90096: LD_INT 22
90098: PUSH
90099: LD_INT 23
90101: PUSH
90102: LD_INT 24
90104: PUSH
90105: LD_INT 25
90107: PUSH
90108: LD_INT 26
90110: PUSH
90111: LD_INT 27
90113: PUSH
90114: LD_INT 28
90116: PUSH
90117: LD_INT 29
90119: PUSH
90120: LD_INT 30
90122: PUSH
90123: LD_INT 31
90125: PUSH
90126: LD_INT 32
90128: PUSH
90129: LD_INT 33
90131: PUSH
90132: LD_INT 34
90134: PUSH
90135: LD_INT 36
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: PUSH
90175: LD_INT 101
90177: PUSH
90178: LD_INT 102
90180: PUSH
90181: LD_INT 103
90183: PUSH
90184: LD_INT 104
90186: PUSH
90187: LD_INT 105
90189: PUSH
90190: LD_INT 106
90192: PUSH
90193: LD_INT 107
90195: PUSH
90196: LD_INT 108
90198: PUSH
90199: LD_INT 109
90201: PUSH
90202: LD_INT 110
90204: PUSH
90205: LD_INT 111
90207: PUSH
90208: LD_INT 112
90210: PUSH
90211: LD_INT 113
90213: PUSH
90214: LD_INT 114
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: ST_TO_ADDR
90237: GO 90964
90239: LD_INT 16
90241: DOUBLE
90242: EQUAL
90243: IFTRUE 90247
90245: GO 90371
90247: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
90248: LD_ADDR_VAR 0 1
90252: PUSH
90253: LD_INT 2
90255: PUSH
90256: LD_INT 4
90258: PUSH
90259: LD_INT 5
90261: PUSH
90262: LD_INT 7
90264: PUSH
90265: LD_INT 11
90267: PUSH
90268: LD_INT 12
90270: PUSH
90271: LD_INT 15
90273: PUSH
90274: LD_INT 16
90276: PUSH
90277: LD_INT 20
90279: PUSH
90280: LD_INT 21
90282: PUSH
90283: LD_INT 22
90285: PUSH
90286: LD_INT 23
90288: PUSH
90289: LD_INT 25
90291: PUSH
90292: LD_INT 26
90294: PUSH
90295: LD_INT 30
90297: PUSH
90298: LD_INT 31
90300: PUSH
90301: LD_INT 32
90303: PUSH
90304: LD_INT 33
90306: PUSH
90307: LD_INT 34
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 101
90333: PUSH
90334: LD_INT 102
90336: PUSH
90337: LD_INT 103
90339: PUSH
90340: LD_INT 106
90342: PUSH
90343: LD_INT 108
90345: PUSH
90346: LD_INT 112
90348: PUSH
90349: LD_INT 113
90351: PUSH
90352: LD_INT 114
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: ST_TO_ADDR
90369: GO 90964
90371: LD_INT 17
90373: DOUBLE
90374: EQUAL
90375: IFTRUE 90379
90377: GO 90591
90379: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
90380: LD_ADDR_VAR 0 1
90384: PUSH
90385: LD_INT 1
90387: PUSH
90388: LD_INT 2
90390: PUSH
90391: LD_INT 3
90393: PUSH
90394: LD_INT 4
90396: PUSH
90397: LD_INT 5
90399: PUSH
90400: LD_INT 6
90402: PUSH
90403: LD_INT 7
90405: PUSH
90406: LD_INT 8
90408: PUSH
90409: LD_INT 9
90411: PUSH
90412: LD_INT 10
90414: PUSH
90415: LD_INT 11
90417: PUSH
90418: LD_INT 12
90420: PUSH
90421: LD_INT 13
90423: PUSH
90424: LD_INT 14
90426: PUSH
90427: LD_INT 15
90429: PUSH
90430: LD_INT 16
90432: PUSH
90433: LD_INT 17
90435: PUSH
90436: LD_INT 18
90438: PUSH
90439: LD_INT 19
90441: PUSH
90442: LD_INT 20
90444: PUSH
90445: LD_INT 21
90447: PUSH
90448: LD_INT 22
90450: PUSH
90451: LD_INT 23
90453: PUSH
90454: LD_INT 24
90456: PUSH
90457: LD_INT 25
90459: PUSH
90460: LD_INT 26
90462: PUSH
90463: LD_INT 27
90465: PUSH
90466: LD_INT 28
90468: PUSH
90469: LD_INT 29
90471: PUSH
90472: LD_INT 30
90474: PUSH
90475: LD_INT 31
90477: PUSH
90478: LD_INT 32
90480: PUSH
90481: LD_INT 33
90483: PUSH
90484: LD_INT 34
90486: PUSH
90487: LD_INT 36
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 101
90529: PUSH
90530: LD_INT 102
90532: PUSH
90533: LD_INT 103
90535: PUSH
90536: LD_INT 104
90538: PUSH
90539: LD_INT 105
90541: PUSH
90542: LD_INT 106
90544: PUSH
90545: LD_INT 107
90547: PUSH
90548: LD_INT 108
90550: PUSH
90551: LD_INT 109
90553: PUSH
90554: LD_INT 110
90556: PUSH
90557: LD_INT 111
90559: PUSH
90560: LD_INT 112
90562: PUSH
90563: LD_INT 113
90565: PUSH
90566: LD_INT 114
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: ST_TO_ADDR
90589: GO 90964
90591: LD_INT 18
90593: DOUBLE
90594: EQUAL
90595: IFTRUE 90599
90597: GO 90735
90599: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90600: LD_ADDR_VAR 0 1
90604: PUSH
90605: LD_INT 2
90607: PUSH
90608: LD_INT 4
90610: PUSH
90611: LD_INT 5
90613: PUSH
90614: LD_INT 7
90616: PUSH
90617: LD_INT 11
90619: PUSH
90620: LD_INT 12
90622: PUSH
90623: LD_INT 15
90625: PUSH
90626: LD_INT 16
90628: PUSH
90629: LD_INT 20
90631: PUSH
90632: LD_INT 21
90634: PUSH
90635: LD_INT 22
90637: PUSH
90638: LD_INT 23
90640: PUSH
90641: LD_INT 25
90643: PUSH
90644: LD_INT 26
90646: PUSH
90647: LD_INT 30
90649: PUSH
90650: LD_INT 31
90652: PUSH
90653: LD_INT 32
90655: PUSH
90656: LD_INT 33
90658: PUSH
90659: LD_INT 34
90661: PUSH
90662: LD_INT 35
90664: PUSH
90665: LD_INT 36
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 101
90693: PUSH
90694: LD_INT 102
90696: PUSH
90697: LD_INT 103
90699: PUSH
90700: LD_INT 106
90702: PUSH
90703: LD_INT 108
90705: PUSH
90706: LD_INT 112
90708: PUSH
90709: LD_INT 113
90711: PUSH
90712: LD_INT 114
90714: PUSH
90715: LD_INT 115
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: LIST
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: ST_TO_ADDR
90733: GO 90964
90735: LD_INT 19
90737: DOUBLE
90738: EQUAL
90739: IFTRUE 90743
90741: GO 90963
90743: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90744: LD_ADDR_VAR 0 1
90748: PUSH
90749: LD_INT 1
90751: PUSH
90752: LD_INT 2
90754: PUSH
90755: LD_INT 3
90757: PUSH
90758: LD_INT 4
90760: PUSH
90761: LD_INT 5
90763: PUSH
90764: LD_INT 6
90766: PUSH
90767: LD_INT 7
90769: PUSH
90770: LD_INT 8
90772: PUSH
90773: LD_INT 9
90775: PUSH
90776: LD_INT 10
90778: PUSH
90779: LD_INT 11
90781: PUSH
90782: LD_INT 12
90784: PUSH
90785: LD_INT 13
90787: PUSH
90788: LD_INT 14
90790: PUSH
90791: LD_INT 15
90793: PUSH
90794: LD_INT 16
90796: PUSH
90797: LD_INT 17
90799: PUSH
90800: LD_INT 18
90802: PUSH
90803: LD_INT 19
90805: PUSH
90806: LD_INT 20
90808: PUSH
90809: LD_INT 21
90811: PUSH
90812: LD_INT 22
90814: PUSH
90815: LD_INT 23
90817: PUSH
90818: LD_INT 24
90820: PUSH
90821: LD_INT 25
90823: PUSH
90824: LD_INT 26
90826: PUSH
90827: LD_INT 27
90829: PUSH
90830: LD_INT 28
90832: PUSH
90833: LD_INT 29
90835: PUSH
90836: LD_INT 30
90838: PUSH
90839: LD_INT 31
90841: PUSH
90842: LD_INT 32
90844: PUSH
90845: LD_INT 33
90847: PUSH
90848: LD_INT 34
90850: PUSH
90851: LD_INT 35
90853: PUSH
90854: LD_INT 36
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 101
90897: PUSH
90898: LD_INT 102
90900: PUSH
90901: LD_INT 103
90903: PUSH
90904: LD_INT 104
90906: PUSH
90907: LD_INT 105
90909: PUSH
90910: LD_INT 106
90912: PUSH
90913: LD_INT 107
90915: PUSH
90916: LD_INT 108
90918: PUSH
90919: LD_INT 109
90921: PUSH
90922: LD_INT 110
90924: PUSH
90925: LD_INT 111
90927: PUSH
90928: LD_INT 112
90930: PUSH
90931: LD_INT 113
90933: PUSH
90934: LD_INT 114
90936: PUSH
90937: LD_INT 115
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: ST_TO_ADDR
90961: GO 90964
90963: POP
// end ; if result then
90964: LD_VAR 0 1
90968: IFFALSE 91257
// begin normal :=  ;
90970: LD_ADDR_VAR 0 3
90974: PUSH
90975: LD_STRING 
90977: ST_TO_ADDR
// hardcore :=  ;
90978: LD_ADDR_VAR 0 4
90982: PUSH
90983: LD_STRING 
90985: ST_TO_ADDR
// for i = 1 to normalCounter do
90986: LD_ADDR_VAR 0 5
90990: PUSH
90991: DOUBLE
90992: LD_INT 1
90994: DEC
90995: ST_TO_ADDR
90996: LD_EXP 108
91000: PUSH
91001: FOR_TO
91002: IFFALSE 91103
// begin tmp := 0 ;
91004: LD_ADDR_VAR 0 2
91008: PUSH
91009: LD_STRING 0
91011: ST_TO_ADDR
// if result [ 1 ] then
91012: LD_VAR 0 1
91016: PUSH
91017: LD_INT 1
91019: ARRAY
91020: IFFALSE 91085
// if result [ 1 ] [ 1 ] = i then
91022: LD_VAR 0 1
91026: PUSH
91027: LD_INT 1
91029: ARRAY
91030: PUSH
91031: LD_INT 1
91033: ARRAY
91034: PUSH
91035: LD_VAR 0 5
91039: EQUAL
91040: IFFALSE 91085
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91042: LD_ADDR_VAR 0 1
91046: PUSH
91047: LD_VAR 0 1
91051: PPUSH
91052: LD_INT 1
91054: PPUSH
91055: LD_VAR 0 1
91059: PUSH
91060: LD_INT 1
91062: ARRAY
91063: PPUSH
91064: LD_INT 1
91066: PPUSH
91067: CALL_OW 3
91071: PPUSH
91072: CALL_OW 1
91076: ST_TO_ADDR
// tmp := 1 ;
91077: LD_ADDR_VAR 0 2
91081: PUSH
91082: LD_STRING 1
91084: ST_TO_ADDR
// end ; normal := normal & tmp ;
91085: LD_ADDR_VAR 0 3
91089: PUSH
91090: LD_VAR 0 3
91094: PUSH
91095: LD_VAR 0 2
91099: STR
91100: ST_TO_ADDR
// end ;
91101: GO 91001
91103: POP
91104: POP
// for i = 1 to hardcoreCounter do
91105: LD_ADDR_VAR 0 5
91109: PUSH
91110: DOUBLE
91111: LD_INT 1
91113: DEC
91114: ST_TO_ADDR
91115: LD_EXP 109
91119: PUSH
91120: FOR_TO
91121: IFFALSE 91226
// begin tmp := 0 ;
91123: LD_ADDR_VAR 0 2
91127: PUSH
91128: LD_STRING 0
91130: ST_TO_ADDR
// if result [ 2 ] then
91131: LD_VAR 0 1
91135: PUSH
91136: LD_INT 2
91138: ARRAY
91139: IFFALSE 91208
// if result [ 2 ] [ 1 ] = 100 + i then
91141: LD_VAR 0 1
91145: PUSH
91146: LD_INT 2
91148: ARRAY
91149: PUSH
91150: LD_INT 1
91152: ARRAY
91153: PUSH
91154: LD_INT 100
91156: PUSH
91157: LD_VAR 0 5
91161: PLUS
91162: EQUAL
91163: IFFALSE 91208
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91165: LD_ADDR_VAR 0 1
91169: PUSH
91170: LD_VAR 0 1
91174: PPUSH
91175: LD_INT 2
91177: PPUSH
91178: LD_VAR 0 1
91182: PUSH
91183: LD_INT 2
91185: ARRAY
91186: PPUSH
91187: LD_INT 1
91189: PPUSH
91190: CALL_OW 3
91194: PPUSH
91195: CALL_OW 1
91199: ST_TO_ADDR
// tmp := 1 ;
91200: LD_ADDR_VAR 0 2
91204: PUSH
91205: LD_STRING 1
91207: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91208: LD_ADDR_VAR 0 4
91212: PUSH
91213: LD_VAR 0 4
91217: PUSH
91218: LD_VAR 0 2
91222: STR
91223: ST_TO_ADDR
// end ;
91224: GO 91120
91226: POP
91227: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
91228: LD_STRING getStreamItemsFromMission("
91230: PUSH
91231: LD_VAR 0 3
91235: STR
91236: PUSH
91237: LD_STRING ","
91239: STR
91240: PUSH
91241: LD_VAR 0 4
91245: STR
91246: PUSH
91247: LD_STRING ")
91249: STR
91250: PPUSH
91251: CALL_OW 559
// end else
91255: GO 91264
// ToLua ( getStreamItemsFromMission("","") ) ;
91257: LD_STRING getStreamItemsFromMission("","")
91259: PPUSH
91260: CALL_OW 559
// end ;
91264: LD_VAR 0 1
91268: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
91269: LD_VAR 0 2
91273: PUSH
91274: LD_INT 100
91276: EQUAL
91277: IFFALSE 92226
// begin if not StreamModeActive then
91279: LD_EXP 107
91283: NOT
91284: IFFALSE 91294
// StreamModeActive := true ;
91286: LD_ADDR_EXP 107
91290: PUSH
91291: LD_INT 1
91293: ST_TO_ADDR
// if p3 = 0 then
91294: LD_VAR 0 3
91298: PUSH
91299: LD_INT 0
91301: EQUAL
91302: IFFALSE 91308
// InitStreamMode ;
91304: CALL 87566 0 0
// if p3 = 1 then
91308: LD_VAR 0 3
91312: PUSH
91313: LD_INT 1
91315: EQUAL
91316: IFFALSE 91326
// sRocket := true ;
91318: LD_ADDR_EXP 112
91322: PUSH
91323: LD_INT 1
91325: ST_TO_ADDR
// if p3 = 2 then
91326: LD_VAR 0 3
91330: PUSH
91331: LD_INT 2
91333: EQUAL
91334: IFFALSE 91344
// sSpeed := true ;
91336: LD_ADDR_EXP 111
91340: PUSH
91341: LD_INT 1
91343: ST_TO_ADDR
// if p3 = 3 then
91344: LD_VAR 0 3
91348: PUSH
91349: LD_INT 3
91351: EQUAL
91352: IFFALSE 91362
// sEngine := true ;
91354: LD_ADDR_EXP 113
91358: PUSH
91359: LD_INT 1
91361: ST_TO_ADDR
// if p3 = 4 then
91362: LD_VAR 0 3
91366: PUSH
91367: LD_INT 4
91369: EQUAL
91370: IFFALSE 91380
// sSpec := true ;
91372: LD_ADDR_EXP 110
91376: PUSH
91377: LD_INT 1
91379: ST_TO_ADDR
// if p3 = 5 then
91380: LD_VAR 0 3
91384: PUSH
91385: LD_INT 5
91387: EQUAL
91388: IFFALSE 91398
// sLevel := true ;
91390: LD_ADDR_EXP 114
91394: PUSH
91395: LD_INT 1
91397: ST_TO_ADDR
// if p3 = 6 then
91398: LD_VAR 0 3
91402: PUSH
91403: LD_INT 6
91405: EQUAL
91406: IFFALSE 91416
// sArmoury := true ;
91408: LD_ADDR_EXP 115
91412: PUSH
91413: LD_INT 1
91415: ST_TO_ADDR
// if p3 = 7 then
91416: LD_VAR 0 3
91420: PUSH
91421: LD_INT 7
91423: EQUAL
91424: IFFALSE 91434
// sRadar := true ;
91426: LD_ADDR_EXP 116
91430: PUSH
91431: LD_INT 1
91433: ST_TO_ADDR
// if p3 = 8 then
91434: LD_VAR 0 3
91438: PUSH
91439: LD_INT 8
91441: EQUAL
91442: IFFALSE 91452
// sBunker := true ;
91444: LD_ADDR_EXP 117
91448: PUSH
91449: LD_INT 1
91451: ST_TO_ADDR
// if p3 = 9 then
91452: LD_VAR 0 3
91456: PUSH
91457: LD_INT 9
91459: EQUAL
91460: IFFALSE 91470
// sHack := true ;
91462: LD_ADDR_EXP 118
91466: PUSH
91467: LD_INT 1
91469: ST_TO_ADDR
// if p3 = 10 then
91470: LD_VAR 0 3
91474: PUSH
91475: LD_INT 10
91477: EQUAL
91478: IFFALSE 91488
// sFire := true ;
91480: LD_ADDR_EXP 119
91484: PUSH
91485: LD_INT 1
91487: ST_TO_ADDR
// if p3 = 11 then
91488: LD_VAR 0 3
91492: PUSH
91493: LD_INT 11
91495: EQUAL
91496: IFFALSE 91506
// sRefresh := true ;
91498: LD_ADDR_EXP 120
91502: PUSH
91503: LD_INT 1
91505: ST_TO_ADDR
// if p3 = 12 then
91506: LD_VAR 0 3
91510: PUSH
91511: LD_INT 12
91513: EQUAL
91514: IFFALSE 91524
// sExp := true ;
91516: LD_ADDR_EXP 121
91520: PUSH
91521: LD_INT 1
91523: ST_TO_ADDR
// if p3 = 13 then
91524: LD_VAR 0 3
91528: PUSH
91529: LD_INT 13
91531: EQUAL
91532: IFFALSE 91542
// sDepot := true ;
91534: LD_ADDR_EXP 122
91538: PUSH
91539: LD_INT 1
91541: ST_TO_ADDR
// if p3 = 14 then
91542: LD_VAR 0 3
91546: PUSH
91547: LD_INT 14
91549: EQUAL
91550: IFFALSE 91560
// sFlag := true ;
91552: LD_ADDR_EXP 123
91556: PUSH
91557: LD_INT 1
91559: ST_TO_ADDR
// if p3 = 15 then
91560: LD_VAR 0 3
91564: PUSH
91565: LD_INT 15
91567: EQUAL
91568: IFFALSE 91578
// sKamikadze := true ;
91570: LD_ADDR_EXP 131
91574: PUSH
91575: LD_INT 1
91577: ST_TO_ADDR
// if p3 = 16 then
91578: LD_VAR 0 3
91582: PUSH
91583: LD_INT 16
91585: EQUAL
91586: IFFALSE 91596
// sTroll := true ;
91588: LD_ADDR_EXP 132
91592: PUSH
91593: LD_INT 1
91595: ST_TO_ADDR
// if p3 = 17 then
91596: LD_VAR 0 3
91600: PUSH
91601: LD_INT 17
91603: EQUAL
91604: IFFALSE 91614
// sSlow := true ;
91606: LD_ADDR_EXP 133
91610: PUSH
91611: LD_INT 1
91613: ST_TO_ADDR
// if p3 = 18 then
91614: LD_VAR 0 3
91618: PUSH
91619: LD_INT 18
91621: EQUAL
91622: IFFALSE 91632
// sLack := true ;
91624: LD_ADDR_EXP 134
91628: PUSH
91629: LD_INT 1
91631: ST_TO_ADDR
// if p3 = 19 then
91632: LD_VAR 0 3
91636: PUSH
91637: LD_INT 19
91639: EQUAL
91640: IFFALSE 91650
// sTank := true ;
91642: LD_ADDR_EXP 136
91646: PUSH
91647: LD_INT 1
91649: ST_TO_ADDR
// if p3 = 20 then
91650: LD_VAR 0 3
91654: PUSH
91655: LD_INT 20
91657: EQUAL
91658: IFFALSE 91668
// sRemote := true ;
91660: LD_ADDR_EXP 137
91664: PUSH
91665: LD_INT 1
91667: ST_TO_ADDR
// if p3 = 21 then
91668: LD_VAR 0 3
91672: PUSH
91673: LD_INT 21
91675: EQUAL
91676: IFFALSE 91686
// sPowell := true ;
91678: LD_ADDR_EXP 138
91682: PUSH
91683: LD_INT 1
91685: ST_TO_ADDR
// if p3 = 22 then
91686: LD_VAR 0 3
91690: PUSH
91691: LD_INT 22
91693: EQUAL
91694: IFFALSE 91704
// sTeleport := true ;
91696: LD_ADDR_EXP 141
91700: PUSH
91701: LD_INT 1
91703: ST_TO_ADDR
// if p3 = 23 then
91704: LD_VAR 0 3
91708: PUSH
91709: LD_INT 23
91711: EQUAL
91712: IFFALSE 91722
// sOilTower := true ;
91714: LD_ADDR_EXP 143
91718: PUSH
91719: LD_INT 1
91721: ST_TO_ADDR
// if p3 = 24 then
91722: LD_VAR 0 3
91726: PUSH
91727: LD_INT 24
91729: EQUAL
91730: IFFALSE 91740
// sShovel := true ;
91732: LD_ADDR_EXP 144
91736: PUSH
91737: LD_INT 1
91739: ST_TO_ADDR
// if p3 = 25 then
91740: LD_VAR 0 3
91744: PUSH
91745: LD_INT 25
91747: EQUAL
91748: IFFALSE 91758
// sSheik := true ;
91750: LD_ADDR_EXP 145
91754: PUSH
91755: LD_INT 1
91757: ST_TO_ADDR
// if p3 = 26 then
91758: LD_VAR 0 3
91762: PUSH
91763: LD_INT 26
91765: EQUAL
91766: IFFALSE 91776
// sEarthquake := true ;
91768: LD_ADDR_EXP 147
91772: PUSH
91773: LD_INT 1
91775: ST_TO_ADDR
// if p3 = 27 then
91776: LD_VAR 0 3
91780: PUSH
91781: LD_INT 27
91783: EQUAL
91784: IFFALSE 91794
// sAI := true ;
91786: LD_ADDR_EXP 148
91790: PUSH
91791: LD_INT 1
91793: ST_TO_ADDR
// if p3 = 28 then
91794: LD_VAR 0 3
91798: PUSH
91799: LD_INT 28
91801: EQUAL
91802: IFFALSE 91812
// sCargo := true ;
91804: LD_ADDR_EXP 151
91808: PUSH
91809: LD_INT 1
91811: ST_TO_ADDR
// if p3 = 29 then
91812: LD_VAR 0 3
91816: PUSH
91817: LD_INT 29
91819: EQUAL
91820: IFFALSE 91830
// sDLaser := true ;
91822: LD_ADDR_EXP 152
91826: PUSH
91827: LD_INT 1
91829: ST_TO_ADDR
// if p3 = 30 then
91830: LD_VAR 0 3
91834: PUSH
91835: LD_INT 30
91837: EQUAL
91838: IFFALSE 91848
// sExchange := true ;
91840: LD_ADDR_EXP 153
91844: PUSH
91845: LD_INT 1
91847: ST_TO_ADDR
// if p3 = 31 then
91848: LD_VAR 0 3
91852: PUSH
91853: LD_INT 31
91855: EQUAL
91856: IFFALSE 91866
// sFac := true ;
91858: LD_ADDR_EXP 154
91862: PUSH
91863: LD_INT 1
91865: ST_TO_ADDR
// if p3 = 32 then
91866: LD_VAR 0 3
91870: PUSH
91871: LD_INT 32
91873: EQUAL
91874: IFFALSE 91884
// sPower := true ;
91876: LD_ADDR_EXP 155
91880: PUSH
91881: LD_INT 1
91883: ST_TO_ADDR
// if p3 = 33 then
91884: LD_VAR 0 3
91888: PUSH
91889: LD_INT 33
91891: EQUAL
91892: IFFALSE 91902
// sRandom := true ;
91894: LD_ADDR_EXP 156
91898: PUSH
91899: LD_INT 1
91901: ST_TO_ADDR
// if p3 = 34 then
91902: LD_VAR 0 3
91906: PUSH
91907: LD_INT 34
91909: EQUAL
91910: IFFALSE 91920
// sShield := true ;
91912: LD_ADDR_EXP 157
91916: PUSH
91917: LD_INT 1
91919: ST_TO_ADDR
// if p3 = 35 then
91920: LD_VAR 0 3
91924: PUSH
91925: LD_INT 35
91927: EQUAL
91928: IFFALSE 91938
// sTime := true ;
91930: LD_ADDR_EXP 158
91934: PUSH
91935: LD_INT 1
91937: ST_TO_ADDR
// if p3 = 36 then
91938: LD_VAR 0 3
91942: PUSH
91943: LD_INT 36
91945: EQUAL
91946: IFFALSE 91956
// sTools := true ;
91948: LD_ADDR_EXP 159
91952: PUSH
91953: LD_INT 1
91955: ST_TO_ADDR
// if p3 = 101 then
91956: LD_VAR 0 3
91960: PUSH
91961: LD_INT 101
91963: EQUAL
91964: IFFALSE 91974
// sSold := true ;
91966: LD_ADDR_EXP 124
91970: PUSH
91971: LD_INT 1
91973: ST_TO_ADDR
// if p3 = 102 then
91974: LD_VAR 0 3
91978: PUSH
91979: LD_INT 102
91981: EQUAL
91982: IFFALSE 91992
// sDiff := true ;
91984: LD_ADDR_EXP 125
91988: PUSH
91989: LD_INT 1
91991: ST_TO_ADDR
// if p3 = 103 then
91992: LD_VAR 0 3
91996: PUSH
91997: LD_INT 103
91999: EQUAL
92000: IFFALSE 92010
// sFog := true ;
92002: LD_ADDR_EXP 128
92006: PUSH
92007: LD_INT 1
92009: ST_TO_ADDR
// if p3 = 104 then
92010: LD_VAR 0 3
92014: PUSH
92015: LD_INT 104
92017: EQUAL
92018: IFFALSE 92028
// sReset := true ;
92020: LD_ADDR_EXP 129
92024: PUSH
92025: LD_INT 1
92027: ST_TO_ADDR
// if p3 = 105 then
92028: LD_VAR 0 3
92032: PUSH
92033: LD_INT 105
92035: EQUAL
92036: IFFALSE 92046
// sSun := true ;
92038: LD_ADDR_EXP 130
92042: PUSH
92043: LD_INT 1
92045: ST_TO_ADDR
// if p3 = 106 then
92046: LD_VAR 0 3
92050: PUSH
92051: LD_INT 106
92053: EQUAL
92054: IFFALSE 92064
// sTiger := true ;
92056: LD_ADDR_EXP 126
92060: PUSH
92061: LD_INT 1
92063: ST_TO_ADDR
// if p3 = 107 then
92064: LD_VAR 0 3
92068: PUSH
92069: LD_INT 107
92071: EQUAL
92072: IFFALSE 92082
// sBomb := true ;
92074: LD_ADDR_EXP 127
92078: PUSH
92079: LD_INT 1
92081: ST_TO_ADDR
// if p3 = 108 then
92082: LD_VAR 0 3
92086: PUSH
92087: LD_INT 108
92089: EQUAL
92090: IFFALSE 92100
// sWound := true ;
92092: LD_ADDR_EXP 135
92096: PUSH
92097: LD_INT 1
92099: ST_TO_ADDR
// if p3 = 109 then
92100: LD_VAR 0 3
92104: PUSH
92105: LD_INT 109
92107: EQUAL
92108: IFFALSE 92118
// sBetray := true ;
92110: LD_ADDR_EXP 139
92114: PUSH
92115: LD_INT 1
92117: ST_TO_ADDR
// if p3 = 110 then
92118: LD_VAR 0 3
92122: PUSH
92123: LD_INT 110
92125: EQUAL
92126: IFFALSE 92136
// sContamin := true ;
92128: LD_ADDR_EXP 140
92132: PUSH
92133: LD_INT 1
92135: ST_TO_ADDR
// if p3 = 111 then
92136: LD_VAR 0 3
92140: PUSH
92141: LD_INT 111
92143: EQUAL
92144: IFFALSE 92154
// sOil := true ;
92146: LD_ADDR_EXP 142
92150: PUSH
92151: LD_INT 1
92153: ST_TO_ADDR
// if p3 = 112 then
92154: LD_VAR 0 3
92158: PUSH
92159: LD_INT 112
92161: EQUAL
92162: IFFALSE 92172
// sStu := true ;
92164: LD_ADDR_EXP 146
92168: PUSH
92169: LD_INT 1
92171: ST_TO_ADDR
// if p3 = 113 then
92172: LD_VAR 0 3
92176: PUSH
92177: LD_INT 113
92179: EQUAL
92180: IFFALSE 92190
// sBazooka := true ;
92182: LD_ADDR_EXP 149
92186: PUSH
92187: LD_INT 1
92189: ST_TO_ADDR
// if p3 = 114 then
92190: LD_VAR 0 3
92194: PUSH
92195: LD_INT 114
92197: EQUAL
92198: IFFALSE 92208
// sMortar := true ;
92200: LD_ADDR_EXP 150
92204: PUSH
92205: LD_INT 1
92207: ST_TO_ADDR
// if p3 = 115 then
92208: LD_VAR 0 3
92212: PUSH
92213: LD_INT 115
92215: EQUAL
92216: IFFALSE 92226
// sRanger := true ;
92218: LD_ADDR_EXP 160
92222: PUSH
92223: LD_INT 1
92225: ST_TO_ADDR
// end ; end ;
92226: PPOPN 6
92228: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92229: LD_EXP 107
92233: PUSH
92234: LD_EXP 112
92238: AND
92239: IFFALSE 92363
92241: GO 92243
92243: DISABLE
92244: LD_INT 0
92246: PPUSH
92247: PPUSH
// begin enable ;
92248: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92249: LD_ADDR_VAR 0 2
92253: PUSH
92254: LD_INT 22
92256: PUSH
92257: LD_OWVAR 2
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 2
92268: PUSH
92269: LD_INT 34
92271: PUSH
92272: LD_INT 7
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 34
92281: PUSH
92282: LD_INT 45
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 34
92291: PUSH
92292: LD_INT 28
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 34
92301: PUSH
92302: LD_INT 47
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PPUSH
92320: CALL_OW 69
92324: ST_TO_ADDR
// if not tmp then
92325: LD_VAR 0 2
92329: NOT
92330: IFFALSE 92334
// exit ;
92332: GO 92363
// for i in tmp do
92334: LD_ADDR_VAR 0 1
92338: PUSH
92339: LD_VAR 0 2
92343: PUSH
92344: FOR_IN
92345: IFFALSE 92361
// begin SetLives ( i , 0 ) ;
92347: LD_VAR 0 1
92351: PPUSH
92352: LD_INT 0
92354: PPUSH
92355: CALL_OW 234
// end ;
92359: GO 92344
92361: POP
92362: POP
// end ;
92363: PPOPN 2
92365: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92366: LD_EXP 107
92370: PUSH
92371: LD_EXP 113
92375: AND
92376: IFFALSE 92460
92378: GO 92380
92380: DISABLE
92381: LD_INT 0
92383: PPUSH
92384: PPUSH
// begin enable ;
92385: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92386: LD_ADDR_VAR 0 2
92390: PUSH
92391: LD_INT 22
92393: PUSH
92394: LD_OWVAR 2
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 32
92405: PUSH
92406: LD_INT 3
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PPUSH
92417: CALL_OW 69
92421: ST_TO_ADDR
// if not tmp then
92422: LD_VAR 0 2
92426: NOT
92427: IFFALSE 92431
// exit ;
92429: GO 92460
// for i in tmp do
92431: LD_ADDR_VAR 0 1
92435: PUSH
92436: LD_VAR 0 2
92440: PUSH
92441: FOR_IN
92442: IFFALSE 92458
// begin SetLives ( i , 0 ) ;
92444: LD_VAR 0 1
92448: PPUSH
92449: LD_INT 0
92451: PPUSH
92452: CALL_OW 234
// end ;
92456: GO 92441
92458: POP
92459: POP
// end ;
92460: PPOPN 2
92462: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92463: LD_EXP 107
92467: PUSH
92468: LD_EXP 110
92472: AND
92473: IFFALSE 92566
92475: GO 92477
92477: DISABLE
92478: LD_INT 0
92480: PPUSH
// begin enable ;
92481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92482: LD_ADDR_VAR 0 1
92486: PUSH
92487: LD_INT 22
92489: PUSH
92490: LD_OWVAR 2
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 2
92501: PUSH
92502: LD_INT 25
92504: PUSH
92505: LD_INT 5
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 25
92514: PUSH
92515: LD_INT 9
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 25
92524: PUSH
92525: LD_INT 8
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PPUSH
92542: CALL_OW 69
92546: PUSH
92547: FOR_IN
92548: IFFALSE 92564
// begin SetClass ( i , 1 ) ;
92550: LD_VAR 0 1
92554: PPUSH
92555: LD_INT 1
92557: PPUSH
92558: CALL_OW 336
// end ;
92562: GO 92547
92564: POP
92565: POP
// end ;
92566: PPOPN 1
92568: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92569: LD_EXP 107
92573: PUSH
92574: LD_EXP 111
92578: AND
92579: PUSH
92580: LD_OWVAR 65
92584: PUSH
92585: LD_INT 7
92587: LESS
92588: AND
92589: IFFALSE 92603
92591: GO 92593
92593: DISABLE
// begin enable ;
92594: ENABLE
// game_speed := 7 ;
92595: LD_ADDR_OWVAR 65
92599: PUSH
92600: LD_INT 7
92602: ST_TO_ADDR
// end ;
92603: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92604: LD_EXP 107
92608: PUSH
92609: LD_EXP 114
92613: AND
92614: IFFALSE 92816
92616: GO 92618
92618: DISABLE
92619: LD_INT 0
92621: PPUSH
92622: PPUSH
92623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92624: LD_ADDR_VAR 0 3
92628: PUSH
92629: LD_INT 81
92631: PUSH
92632: LD_OWVAR 2
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 21
92643: PUSH
92644: LD_INT 1
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PPUSH
92655: CALL_OW 69
92659: ST_TO_ADDR
// if not tmp then
92660: LD_VAR 0 3
92664: NOT
92665: IFFALSE 92669
// exit ;
92667: GO 92816
// if tmp > 5 then
92669: LD_VAR 0 3
92673: PUSH
92674: LD_INT 5
92676: GREATER
92677: IFFALSE 92689
// k := 5 else
92679: LD_ADDR_VAR 0 2
92683: PUSH
92684: LD_INT 5
92686: ST_TO_ADDR
92687: GO 92699
// k := tmp ;
92689: LD_ADDR_VAR 0 2
92693: PUSH
92694: LD_VAR 0 3
92698: ST_TO_ADDR
// for i := 1 to k do
92699: LD_ADDR_VAR 0 1
92703: PUSH
92704: DOUBLE
92705: LD_INT 1
92707: DEC
92708: ST_TO_ADDR
92709: LD_VAR 0 2
92713: PUSH
92714: FOR_TO
92715: IFFALSE 92814
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92717: LD_VAR 0 3
92721: PUSH
92722: LD_VAR 0 1
92726: ARRAY
92727: PPUSH
92728: LD_VAR 0 1
92732: PUSH
92733: LD_INT 4
92735: MOD
92736: PUSH
92737: LD_INT 1
92739: PLUS
92740: PPUSH
92741: CALL_OW 259
92745: PUSH
92746: LD_INT 10
92748: LESS
92749: IFFALSE 92812
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92751: LD_VAR 0 3
92755: PUSH
92756: LD_VAR 0 1
92760: ARRAY
92761: PPUSH
92762: LD_VAR 0 1
92766: PUSH
92767: LD_INT 4
92769: MOD
92770: PUSH
92771: LD_INT 1
92773: PLUS
92774: PPUSH
92775: LD_VAR 0 3
92779: PUSH
92780: LD_VAR 0 1
92784: ARRAY
92785: PPUSH
92786: LD_VAR 0 1
92790: PUSH
92791: LD_INT 4
92793: MOD
92794: PUSH
92795: LD_INT 1
92797: PLUS
92798: PPUSH
92799: CALL_OW 259
92803: PUSH
92804: LD_INT 1
92806: PLUS
92807: PPUSH
92808: CALL_OW 237
92812: GO 92714
92814: POP
92815: POP
// end ;
92816: PPOPN 3
92818: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92819: LD_EXP 107
92823: PUSH
92824: LD_EXP 115
92828: AND
92829: IFFALSE 92849
92831: GO 92833
92833: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92834: LD_INT 4
92836: PPUSH
92837: LD_OWVAR 2
92841: PPUSH
92842: LD_INT 0
92844: PPUSH
92845: CALL_OW 324
92849: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92850: LD_EXP 107
92854: PUSH
92855: LD_EXP 144
92859: AND
92860: IFFALSE 92880
92862: GO 92864
92864: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92865: LD_INT 19
92867: PPUSH
92868: LD_OWVAR 2
92872: PPUSH
92873: LD_INT 0
92875: PPUSH
92876: CALL_OW 324
92880: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92881: LD_EXP 107
92885: PUSH
92886: LD_EXP 116
92890: AND
92891: IFFALSE 92993
92893: GO 92895
92895: DISABLE
92896: LD_INT 0
92898: PPUSH
92899: PPUSH
// begin enable ;
92900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92901: LD_ADDR_VAR 0 2
92905: PUSH
92906: LD_INT 22
92908: PUSH
92909: LD_OWVAR 2
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 2
92920: PUSH
92921: LD_INT 34
92923: PUSH
92924: LD_INT 11
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 34
92933: PUSH
92934: LD_INT 30
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: LIST
92945: PUSH
92946: EMPTY
92947: LIST
92948: LIST
92949: PPUSH
92950: CALL_OW 69
92954: ST_TO_ADDR
// if not tmp then
92955: LD_VAR 0 2
92959: NOT
92960: IFFALSE 92964
// exit ;
92962: GO 92993
// for i in tmp do
92964: LD_ADDR_VAR 0 1
92968: PUSH
92969: LD_VAR 0 2
92973: PUSH
92974: FOR_IN
92975: IFFALSE 92991
// begin SetLives ( i , 0 ) ;
92977: LD_VAR 0 1
92981: PPUSH
92982: LD_INT 0
92984: PPUSH
92985: CALL_OW 234
// end ;
92989: GO 92974
92991: POP
92992: POP
// end ;
92993: PPOPN 2
92995: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92996: LD_EXP 107
93000: PUSH
93001: LD_EXP 117
93005: AND
93006: IFFALSE 93026
93008: GO 93010
93010: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93011: LD_INT 32
93013: PPUSH
93014: LD_OWVAR 2
93018: PPUSH
93019: LD_INT 0
93021: PPUSH
93022: CALL_OW 324
93026: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93027: LD_EXP 107
93031: PUSH
93032: LD_EXP 118
93036: AND
93037: IFFALSE 93218
93039: GO 93041
93041: DISABLE
93042: LD_INT 0
93044: PPUSH
93045: PPUSH
93046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93047: LD_ADDR_VAR 0 2
93051: PUSH
93052: LD_INT 22
93054: PUSH
93055: LD_OWVAR 2
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 33
93066: PUSH
93067: LD_INT 3
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PPUSH
93078: CALL_OW 69
93082: ST_TO_ADDR
// if not tmp then
93083: LD_VAR 0 2
93087: NOT
93088: IFFALSE 93092
// exit ;
93090: GO 93218
// side := 0 ;
93092: LD_ADDR_VAR 0 3
93096: PUSH
93097: LD_INT 0
93099: ST_TO_ADDR
// for i := 1 to 8 do
93100: LD_ADDR_VAR 0 1
93104: PUSH
93105: DOUBLE
93106: LD_INT 1
93108: DEC
93109: ST_TO_ADDR
93110: LD_INT 8
93112: PUSH
93113: FOR_TO
93114: IFFALSE 93162
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93116: LD_OWVAR 2
93120: PUSH
93121: LD_VAR 0 1
93125: NONEQUAL
93126: PUSH
93127: LD_OWVAR 2
93131: PPUSH
93132: LD_VAR 0 1
93136: PPUSH
93137: CALL_OW 81
93141: PUSH
93142: LD_INT 2
93144: EQUAL
93145: AND
93146: IFFALSE 93160
// begin side := i ;
93148: LD_ADDR_VAR 0 3
93152: PUSH
93153: LD_VAR 0 1
93157: ST_TO_ADDR
// break ;
93158: GO 93162
// end ;
93160: GO 93113
93162: POP
93163: POP
// if not side then
93164: LD_VAR 0 3
93168: NOT
93169: IFFALSE 93173
// exit ;
93171: GO 93218
// for i := 1 to tmp do
93173: LD_ADDR_VAR 0 1
93177: PUSH
93178: DOUBLE
93179: LD_INT 1
93181: DEC
93182: ST_TO_ADDR
93183: LD_VAR 0 2
93187: PUSH
93188: FOR_TO
93189: IFFALSE 93216
// if Prob ( 60 ) then
93191: LD_INT 60
93193: PPUSH
93194: CALL_OW 13
93198: IFFALSE 93214
// SetSide ( i , side ) ;
93200: LD_VAR 0 1
93204: PPUSH
93205: LD_VAR 0 3
93209: PPUSH
93210: CALL_OW 235
93214: GO 93188
93216: POP
93217: POP
// end ;
93218: PPOPN 3
93220: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93221: LD_EXP 107
93225: PUSH
93226: LD_EXP 120
93230: AND
93231: IFFALSE 93350
93233: GO 93235
93235: DISABLE
93236: LD_INT 0
93238: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93239: LD_ADDR_VAR 0 1
93243: PUSH
93244: LD_INT 22
93246: PUSH
93247: LD_OWVAR 2
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 21
93258: PUSH
93259: LD_INT 1
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_INT 3
93268: PUSH
93269: LD_INT 23
93271: PUSH
93272: LD_INT 0
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: LIST
93287: PPUSH
93288: CALL_OW 69
93292: PUSH
93293: FOR_IN
93294: IFFALSE 93348
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93296: LD_VAR 0 1
93300: PPUSH
93301: CALL_OW 257
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: LD_INT 2
93311: PUSH
93312: LD_INT 3
93314: PUSH
93315: LD_INT 4
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: IN
93324: IFFALSE 93346
// SetClass ( un , rand ( 1 , 4 ) ) ;
93326: LD_VAR 0 1
93330: PPUSH
93331: LD_INT 1
93333: PPUSH
93334: LD_INT 4
93336: PPUSH
93337: CALL_OW 12
93341: PPUSH
93342: CALL_OW 336
93346: GO 93293
93348: POP
93349: POP
// end ;
93350: PPOPN 1
93352: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93353: LD_EXP 107
93357: PUSH
93358: LD_EXP 119
93362: AND
93363: IFFALSE 93442
93365: GO 93367
93367: DISABLE
93368: LD_INT 0
93370: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93371: LD_ADDR_VAR 0 1
93375: PUSH
93376: LD_INT 22
93378: PUSH
93379: LD_OWVAR 2
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 21
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PPUSH
93402: CALL_OW 69
93406: ST_TO_ADDR
// if not tmp then
93407: LD_VAR 0 1
93411: NOT
93412: IFFALSE 93416
// exit ;
93414: GO 93442
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93416: LD_VAR 0 1
93420: PUSH
93421: LD_INT 1
93423: PPUSH
93424: LD_VAR 0 1
93428: PPUSH
93429: CALL_OW 12
93433: ARRAY
93434: PPUSH
93435: LD_INT 100
93437: PPUSH
93438: CALL_OW 234
// end ;
93442: PPOPN 1
93444: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93445: LD_EXP 107
93449: PUSH
93450: LD_EXP 121
93454: AND
93455: IFFALSE 93553
93457: GO 93459
93459: DISABLE
93460: LD_INT 0
93462: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93463: LD_ADDR_VAR 0 1
93467: PUSH
93468: LD_INT 22
93470: PUSH
93471: LD_OWVAR 2
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 21
93482: PUSH
93483: LD_INT 1
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PPUSH
93494: CALL_OW 69
93498: ST_TO_ADDR
// if not tmp then
93499: LD_VAR 0 1
93503: NOT
93504: IFFALSE 93508
// exit ;
93506: GO 93553
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93508: LD_VAR 0 1
93512: PUSH
93513: LD_INT 1
93515: PPUSH
93516: LD_VAR 0 1
93520: PPUSH
93521: CALL_OW 12
93525: ARRAY
93526: PPUSH
93527: LD_INT 1
93529: PPUSH
93530: LD_INT 4
93532: PPUSH
93533: CALL_OW 12
93537: PPUSH
93538: LD_INT 3000
93540: PPUSH
93541: LD_INT 9000
93543: PPUSH
93544: CALL_OW 12
93548: PPUSH
93549: CALL_OW 492
// end ;
93553: PPOPN 1
93555: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93556: LD_EXP 107
93560: PUSH
93561: LD_EXP 122
93565: AND
93566: IFFALSE 93586
93568: GO 93570
93570: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93571: LD_INT 1
93573: PPUSH
93574: LD_OWVAR 2
93578: PPUSH
93579: LD_INT 0
93581: PPUSH
93582: CALL_OW 324
93586: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93587: LD_EXP 107
93591: PUSH
93592: LD_EXP 123
93596: AND
93597: IFFALSE 93680
93599: GO 93601
93601: DISABLE
93602: LD_INT 0
93604: PPUSH
93605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93606: LD_ADDR_VAR 0 2
93610: PUSH
93611: LD_INT 22
93613: PUSH
93614: LD_OWVAR 2
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 21
93625: PUSH
93626: LD_INT 3
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PPUSH
93637: CALL_OW 69
93641: ST_TO_ADDR
// if not tmp then
93642: LD_VAR 0 2
93646: NOT
93647: IFFALSE 93651
// exit ;
93649: GO 93680
// for i in tmp do
93651: LD_ADDR_VAR 0 1
93655: PUSH
93656: LD_VAR 0 2
93660: PUSH
93661: FOR_IN
93662: IFFALSE 93678
// SetBLevel ( i , 10 ) ;
93664: LD_VAR 0 1
93668: PPUSH
93669: LD_INT 10
93671: PPUSH
93672: CALL_OW 241
93676: GO 93661
93678: POP
93679: POP
// end ;
93680: PPOPN 2
93682: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93683: LD_EXP 107
93687: PUSH
93688: LD_EXP 124
93692: AND
93693: IFFALSE 93804
93695: GO 93697
93697: DISABLE
93698: LD_INT 0
93700: PPUSH
93701: PPUSH
93702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93703: LD_ADDR_VAR 0 3
93707: PUSH
93708: LD_INT 22
93710: PUSH
93711: LD_OWVAR 2
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: PUSH
93720: LD_INT 25
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PPUSH
93734: CALL_OW 69
93738: ST_TO_ADDR
// if not tmp then
93739: LD_VAR 0 3
93743: NOT
93744: IFFALSE 93748
// exit ;
93746: GO 93804
// un := tmp [ rand ( 1 , tmp ) ] ;
93748: LD_ADDR_VAR 0 2
93752: PUSH
93753: LD_VAR 0 3
93757: PUSH
93758: LD_INT 1
93760: PPUSH
93761: LD_VAR 0 3
93765: PPUSH
93766: CALL_OW 12
93770: ARRAY
93771: ST_TO_ADDR
// if Crawls ( un ) then
93772: LD_VAR 0 2
93776: PPUSH
93777: CALL_OW 318
93781: IFFALSE 93792
// ComWalk ( un ) ;
93783: LD_VAR 0 2
93787: PPUSH
93788: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93792: LD_VAR 0 2
93796: PPUSH
93797: LD_INT 5
93799: PPUSH
93800: CALL_OW 336
// end ;
93804: PPOPN 3
93806: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93807: LD_EXP 107
93811: PUSH
93812: LD_EXP 125
93816: AND
93817: PUSH
93818: LD_OWVAR 67
93822: PUSH
93823: LD_INT 3
93825: LESS
93826: AND
93827: IFFALSE 93846
93829: GO 93831
93831: DISABLE
// Difficulty := Difficulty + 1 ;
93832: LD_ADDR_OWVAR 67
93836: PUSH
93837: LD_OWVAR 67
93841: PUSH
93842: LD_INT 1
93844: PLUS
93845: ST_TO_ADDR
93846: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93847: LD_EXP 107
93851: PUSH
93852: LD_EXP 126
93856: AND
93857: IFFALSE 93960
93859: GO 93861
93861: DISABLE
93862: LD_INT 0
93864: PPUSH
// begin for i := 1 to 5 do
93865: LD_ADDR_VAR 0 1
93869: PUSH
93870: DOUBLE
93871: LD_INT 1
93873: DEC
93874: ST_TO_ADDR
93875: LD_INT 5
93877: PUSH
93878: FOR_TO
93879: IFFALSE 93958
// begin uc_nation := nation_nature ;
93881: LD_ADDR_OWVAR 21
93885: PUSH
93886: LD_INT 0
93888: ST_TO_ADDR
// uc_side := 0 ;
93889: LD_ADDR_OWVAR 20
93893: PUSH
93894: LD_INT 0
93896: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93897: LD_ADDR_OWVAR 29
93901: PUSH
93902: LD_INT 12
93904: PUSH
93905: LD_INT 12
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: ST_TO_ADDR
// hc_agressivity := 20 ;
93912: LD_ADDR_OWVAR 35
93916: PUSH
93917: LD_INT 20
93919: ST_TO_ADDR
// hc_class := class_tiger ;
93920: LD_ADDR_OWVAR 28
93924: PUSH
93925: LD_INT 14
93927: ST_TO_ADDR
// hc_gallery :=  ;
93928: LD_ADDR_OWVAR 33
93932: PUSH
93933: LD_STRING 
93935: ST_TO_ADDR
// hc_name :=  ;
93936: LD_ADDR_OWVAR 26
93940: PUSH
93941: LD_STRING 
93943: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93944: CALL_OW 44
93948: PPUSH
93949: LD_INT 0
93951: PPUSH
93952: CALL_OW 51
// end ;
93956: GO 93878
93958: POP
93959: POP
// end ;
93960: PPOPN 1
93962: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93963: LD_EXP 107
93967: PUSH
93968: LD_EXP 127
93972: AND
93973: IFFALSE 93982
93975: GO 93977
93977: DISABLE
// StreamSibBomb ;
93978: CALL 93983 0 0
93982: END
// export function StreamSibBomb ; var i , x , y ; begin
93983: LD_INT 0
93985: PPUSH
93986: PPUSH
93987: PPUSH
93988: PPUSH
// result := false ;
93989: LD_ADDR_VAR 0 1
93993: PUSH
93994: LD_INT 0
93996: ST_TO_ADDR
// for i := 1 to 16 do
93997: LD_ADDR_VAR 0 2
94001: PUSH
94002: DOUBLE
94003: LD_INT 1
94005: DEC
94006: ST_TO_ADDR
94007: LD_INT 16
94009: PUSH
94010: FOR_TO
94011: IFFALSE 94210
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94013: LD_ADDR_VAR 0 3
94017: PUSH
94018: LD_INT 10
94020: PUSH
94021: LD_INT 20
94023: PUSH
94024: LD_INT 30
94026: PUSH
94027: LD_INT 40
94029: PUSH
94030: LD_INT 50
94032: PUSH
94033: LD_INT 60
94035: PUSH
94036: LD_INT 70
94038: PUSH
94039: LD_INT 80
94041: PUSH
94042: LD_INT 90
94044: PUSH
94045: LD_INT 100
94047: PUSH
94048: LD_INT 110
94050: PUSH
94051: LD_INT 120
94053: PUSH
94054: LD_INT 130
94056: PUSH
94057: LD_INT 140
94059: PUSH
94060: LD_INT 150
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 1
94082: PPUSH
94083: LD_INT 15
94085: PPUSH
94086: CALL_OW 12
94090: ARRAY
94091: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94092: LD_ADDR_VAR 0 4
94096: PUSH
94097: LD_INT 10
94099: PUSH
94100: LD_INT 20
94102: PUSH
94103: LD_INT 30
94105: PUSH
94106: LD_INT 40
94108: PUSH
94109: LD_INT 50
94111: PUSH
94112: LD_INT 60
94114: PUSH
94115: LD_INT 70
94117: PUSH
94118: LD_INT 80
94120: PUSH
94121: LD_INT 90
94123: PUSH
94124: LD_INT 100
94126: PUSH
94127: LD_INT 110
94129: PUSH
94130: LD_INT 120
94132: PUSH
94133: LD_INT 130
94135: PUSH
94136: LD_INT 140
94138: PUSH
94139: LD_INT 150
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 1
94161: PPUSH
94162: LD_INT 15
94164: PPUSH
94165: CALL_OW 12
94169: ARRAY
94170: ST_TO_ADDR
// if ValidHex ( x , y ) then
94171: LD_VAR 0 3
94175: PPUSH
94176: LD_VAR 0 4
94180: PPUSH
94181: CALL_OW 488
94185: IFFALSE 94208
// begin result := [ x , y ] ;
94187: LD_ADDR_VAR 0 1
94191: PUSH
94192: LD_VAR 0 3
94196: PUSH
94197: LD_VAR 0 4
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: ST_TO_ADDR
// break ;
94206: GO 94210
// end ; end ;
94208: GO 94010
94210: POP
94211: POP
// if result then
94212: LD_VAR 0 1
94216: IFFALSE 94276
// begin ToLua ( playSibBomb() ) ;
94218: LD_STRING playSibBomb()
94220: PPUSH
94221: CALL_OW 559
// wait ( 0 0$14 ) ;
94225: LD_INT 490
94227: PPUSH
94228: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94232: LD_VAR 0 1
94236: PUSH
94237: LD_INT 1
94239: ARRAY
94240: PPUSH
94241: LD_VAR 0 1
94245: PUSH
94246: LD_INT 2
94248: ARRAY
94249: PPUSH
94250: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94254: LD_VAR 0 1
94258: PUSH
94259: LD_INT 1
94261: ARRAY
94262: PPUSH
94263: LD_VAR 0 1
94267: PUSH
94268: LD_INT 2
94270: ARRAY
94271: PPUSH
94272: CALL_OW 429
// end ; end ;
94276: LD_VAR 0 1
94280: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94281: LD_EXP 107
94285: PUSH
94286: LD_EXP 129
94290: AND
94291: IFFALSE 94303
94293: GO 94295
94295: DISABLE
// YouLost (  ) ;
94296: LD_STRING 
94298: PPUSH
94299: CALL_OW 104
94303: END
// every 0 0$1 trigger StreamModeActive and sFog do
94304: LD_EXP 107
94308: PUSH
94309: LD_EXP 128
94313: AND
94314: IFFALSE 94328
94316: GO 94318
94318: DISABLE
// FogOff ( your_side ) ;
94319: LD_OWVAR 2
94323: PPUSH
94324: CALL_OW 344
94328: END
// every 0 0$1 trigger StreamModeActive and sSun do
94329: LD_EXP 107
94333: PUSH
94334: LD_EXP 130
94338: AND
94339: IFFALSE 94367
94341: GO 94343
94343: DISABLE
// begin solar_recharge_percent := 0 ;
94344: LD_ADDR_OWVAR 79
94348: PUSH
94349: LD_INT 0
94351: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94352: LD_INT 10500
94354: PPUSH
94355: CALL_OW 67
// solar_recharge_percent := 100 ;
94359: LD_ADDR_OWVAR 79
94363: PUSH
94364: LD_INT 100
94366: ST_TO_ADDR
// end ;
94367: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94368: LD_EXP 107
94372: PUSH
94373: LD_EXP 131
94377: AND
94378: IFFALSE 94617
94380: GO 94382
94382: DISABLE
94383: LD_INT 0
94385: PPUSH
94386: PPUSH
94387: PPUSH
// begin tmp := [ ] ;
94388: LD_ADDR_VAR 0 3
94392: PUSH
94393: EMPTY
94394: ST_TO_ADDR
// for i := 1 to 6 do
94395: LD_ADDR_VAR 0 1
94399: PUSH
94400: DOUBLE
94401: LD_INT 1
94403: DEC
94404: ST_TO_ADDR
94405: LD_INT 6
94407: PUSH
94408: FOR_TO
94409: IFFALSE 94514
// begin uc_nation := nation_nature ;
94411: LD_ADDR_OWVAR 21
94415: PUSH
94416: LD_INT 0
94418: ST_TO_ADDR
// uc_side := 0 ;
94419: LD_ADDR_OWVAR 20
94423: PUSH
94424: LD_INT 0
94426: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94427: LD_ADDR_OWVAR 29
94431: PUSH
94432: LD_INT 12
94434: PUSH
94435: LD_INT 12
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: ST_TO_ADDR
// hc_agressivity := 20 ;
94442: LD_ADDR_OWVAR 35
94446: PUSH
94447: LD_INT 20
94449: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94450: LD_ADDR_OWVAR 28
94454: PUSH
94455: LD_INT 17
94457: ST_TO_ADDR
// hc_gallery :=  ;
94458: LD_ADDR_OWVAR 33
94462: PUSH
94463: LD_STRING 
94465: ST_TO_ADDR
// hc_name :=  ;
94466: LD_ADDR_OWVAR 26
94470: PUSH
94471: LD_STRING 
94473: ST_TO_ADDR
// un := CreateHuman ;
94474: LD_ADDR_VAR 0 2
94478: PUSH
94479: CALL_OW 44
94483: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94484: LD_VAR 0 2
94488: PPUSH
94489: LD_INT 1
94491: PPUSH
94492: CALL_OW 51
// tmp := tmp ^ un ;
94496: LD_ADDR_VAR 0 3
94500: PUSH
94501: LD_VAR 0 3
94505: PUSH
94506: LD_VAR 0 2
94510: ADD
94511: ST_TO_ADDR
// end ;
94512: GO 94408
94514: POP
94515: POP
// repeat wait ( 0 0$1 ) ;
94516: LD_INT 35
94518: PPUSH
94519: CALL_OW 67
// for un in tmp do
94523: LD_ADDR_VAR 0 2
94527: PUSH
94528: LD_VAR 0 3
94532: PUSH
94533: FOR_IN
94534: IFFALSE 94608
// begin if IsDead ( un ) then
94536: LD_VAR 0 2
94540: PPUSH
94541: CALL_OW 301
94545: IFFALSE 94565
// begin tmp := tmp diff un ;
94547: LD_ADDR_VAR 0 3
94551: PUSH
94552: LD_VAR 0 3
94556: PUSH
94557: LD_VAR 0 2
94561: DIFF
94562: ST_TO_ADDR
// continue ;
94563: GO 94533
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94565: LD_VAR 0 2
94569: PPUSH
94570: LD_INT 3
94572: PUSH
94573: LD_INT 22
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: PPUSH
94587: CALL_OW 69
94591: PPUSH
94592: LD_VAR 0 2
94596: PPUSH
94597: CALL_OW 74
94601: PPUSH
94602: CALL_OW 115
// end ;
94606: GO 94533
94608: POP
94609: POP
// until not tmp ;
94610: LD_VAR 0 3
94614: NOT
94615: IFFALSE 94516
// end ;
94617: PPOPN 3
94619: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94620: LD_EXP 107
94624: PUSH
94625: LD_EXP 132
94629: AND
94630: IFFALSE 94684
94632: GO 94634
94634: DISABLE
// begin ToLua ( displayTroll(); ) ;
94635: LD_STRING displayTroll();
94637: PPUSH
94638: CALL_OW 559
// wait ( 3 3$00 ) ;
94642: LD_INT 6300
94644: PPUSH
94645: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94649: LD_STRING hideTroll();
94651: PPUSH
94652: CALL_OW 559
// wait ( 1 1$00 ) ;
94656: LD_INT 2100
94658: PPUSH
94659: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94663: LD_STRING displayTroll();
94665: PPUSH
94666: CALL_OW 559
// wait ( 1 1$00 ) ;
94670: LD_INT 2100
94672: PPUSH
94673: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94677: LD_STRING hideTroll();
94679: PPUSH
94680: CALL_OW 559
// end ;
94684: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94685: LD_EXP 107
94689: PUSH
94690: LD_EXP 133
94694: AND
94695: IFFALSE 94758
94697: GO 94699
94699: DISABLE
94700: LD_INT 0
94702: PPUSH
// begin p := 0 ;
94703: LD_ADDR_VAR 0 1
94707: PUSH
94708: LD_INT 0
94710: ST_TO_ADDR
// repeat game_speed := 1 ;
94711: LD_ADDR_OWVAR 65
94715: PUSH
94716: LD_INT 1
94718: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94719: LD_INT 35
94721: PPUSH
94722: CALL_OW 67
// p := p + 1 ;
94726: LD_ADDR_VAR 0 1
94730: PUSH
94731: LD_VAR 0 1
94735: PUSH
94736: LD_INT 1
94738: PLUS
94739: ST_TO_ADDR
// until p >= 60 ;
94740: LD_VAR 0 1
94744: PUSH
94745: LD_INT 60
94747: GREATEREQUAL
94748: IFFALSE 94711
// game_speed := 4 ;
94750: LD_ADDR_OWVAR 65
94754: PUSH
94755: LD_INT 4
94757: ST_TO_ADDR
// end ;
94758: PPOPN 1
94760: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94761: LD_EXP 107
94765: PUSH
94766: LD_EXP 134
94770: AND
94771: IFFALSE 94917
94773: GO 94775
94775: DISABLE
94776: LD_INT 0
94778: PPUSH
94779: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94780: LD_ADDR_VAR 0 1
94784: PUSH
94785: LD_INT 22
94787: PUSH
94788: LD_OWVAR 2
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: PUSH
94797: LD_INT 2
94799: PUSH
94800: LD_INT 30
94802: PUSH
94803: LD_INT 0
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 30
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: LIST
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PPUSH
94829: CALL_OW 69
94833: ST_TO_ADDR
// if not depot then
94834: LD_VAR 0 1
94838: NOT
94839: IFFALSE 94843
// exit ;
94841: GO 94917
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94843: LD_ADDR_VAR 0 2
94847: PUSH
94848: LD_VAR 0 1
94852: PUSH
94853: LD_INT 1
94855: PPUSH
94856: LD_VAR 0 1
94860: PPUSH
94861: CALL_OW 12
94865: ARRAY
94866: PPUSH
94867: CALL_OW 274
94871: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94872: LD_VAR 0 2
94876: PPUSH
94877: LD_INT 1
94879: PPUSH
94880: LD_INT 0
94882: PPUSH
94883: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94887: LD_VAR 0 2
94891: PPUSH
94892: LD_INT 2
94894: PPUSH
94895: LD_INT 0
94897: PPUSH
94898: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94902: LD_VAR 0 2
94906: PPUSH
94907: LD_INT 3
94909: PPUSH
94910: LD_INT 0
94912: PPUSH
94913: CALL_OW 277
// end ;
94917: PPOPN 2
94919: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94920: LD_EXP 107
94924: PUSH
94925: LD_EXP 135
94929: AND
94930: IFFALSE 95027
94932: GO 94934
94934: DISABLE
94935: LD_INT 0
94937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94938: LD_ADDR_VAR 0 1
94942: PUSH
94943: LD_INT 22
94945: PUSH
94946: LD_OWVAR 2
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 21
94957: PUSH
94958: LD_INT 1
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 3
94967: PUSH
94968: LD_INT 23
94970: PUSH
94971: LD_INT 0
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: LIST
94986: PPUSH
94987: CALL_OW 69
94991: ST_TO_ADDR
// if not tmp then
94992: LD_VAR 0 1
94996: NOT
94997: IFFALSE 95001
// exit ;
94999: GO 95027
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95001: LD_VAR 0 1
95005: PUSH
95006: LD_INT 1
95008: PPUSH
95009: LD_VAR 0 1
95013: PPUSH
95014: CALL_OW 12
95018: ARRAY
95019: PPUSH
95020: LD_INT 200
95022: PPUSH
95023: CALL_OW 234
// end ;
95027: PPOPN 1
95029: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95030: LD_EXP 107
95034: PUSH
95035: LD_EXP 136
95039: AND
95040: IFFALSE 95119
95042: GO 95044
95044: DISABLE
95045: LD_INT 0
95047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95048: LD_ADDR_VAR 0 1
95052: PUSH
95053: LD_INT 22
95055: PUSH
95056: LD_OWVAR 2
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 21
95067: PUSH
95068: LD_INT 2
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PPUSH
95079: CALL_OW 69
95083: ST_TO_ADDR
// if not tmp then
95084: LD_VAR 0 1
95088: NOT
95089: IFFALSE 95093
// exit ;
95091: GO 95119
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95093: LD_VAR 0 1
95097: PUSH
95098: LD_INT 1
95100: PPUSH
95101: LD_VAR 0 1
95105: PPUSH
95106: CALL_OW 12
95110: ARRAY
95111: PPUSH
95112: LD_INT 60
95114: PPUSH
95115: CALL_OW 234
// end ;
95119: PPOPN 1
95121: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95122: LD_EXP 107
95126: PUSH
95127: LD_EXP 137
95131: AND
95132: IFFALSE 95231
95134: GO 95136
95136: DISABLE
95137: LD_INT 0
95139: PPUSH
95140: PPUSH
// begin enable ;
95141: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95142: LD_ADDR_VAR 0 1
95146: PUSH
95147: LD_INT 22
95149: PUSH
95150: LD_OWVAR 2
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: LD_INT 61
95161: PUSH
95162: EMPTY
95163: LIST
95164: PUSH
95165: LD_INT 33
95167: PUSH
95168: LD_INT 2
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: LIST
95179: PPUSH
95180: CALL_OW 69
95184: ST_TO_ADDR
// if not tmp then
95185: LD_VAR 0 1
95189: NOT
95190: IFFALSE 95194
// exit ;
95192: GO 95231
// for i in tmp do
95194: LD_ADDR_VAR 0 2
95198: PUSH
95199: LD_VAR 0 1
95203: PUSH
95204: FOR_IN
95205: IFFALSE 95229
// if IsControledBy ( i ) then
95207: LD_VAR 0 2
95211: PPUSH
95212: CALL_OW 312
95216: IFFALSE 95227
// ComUnlink ( i ) ;
95218: LD_VAR 0 2
95222: PPUSH
95223: CALL_OW 136
95227: GO 95204
95229: POP
95230: POP
// end ;
95231: PPOPN 2
95233: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95234: LD_EXP 107
95238: PUSH
95239: LD_EXP 138
95243: AND
95244: IFFALSE 95384
95246: GO 95248
95248: DISABLE
95249: LD_INT 0
95251: PPUSH
95252: PPUSH
// begin ToLua ( displayPowell(); ) ;
95253: LD_STRING displayPowell();
95255: PPUSH
95256: CALL_OW 559
// uc_side := 0 ;
95260: LD_ADDR_OWVAR 20
95264: PUSH
95265: LD_INT 0
95267: ST_TO_ADDR
// uc_nation := 2 ;
95268: LD_ADDR_OWVAR 21
95272: PUSH
95273: LD_INT 2
95275: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95276: LD_ADDR_OWVAR 37
95280: PUSH
95281: LD_INT 14
95283: ST_TO_ADDR
// vc_engine := engine_siberite ;
95284: LD_ADDR_OWVAR 39
95288: PUSH
95289: LD_INT 3
95291: ST_TO_ADDR
// vc_control := control_apeman ;
95292: LD_ADDR_OWVAR 38
95296: PUSH
95297: LD_INT 5
95299: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95300: LD_ADDR_OWVAR 40
95304: PUSH
95305: LD_INT 29
95307: ST_TO_ADDR
// un := CreateVehicle ;
95308: LD_ADDR_VAR 0 2
95312: PUSH
95313: CALL_OW 45
95317: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95318: LD_VAR 0 2
95322: PPUSH
95323: LD_INT 1
95325: PPUSH
95326: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95330: LD_INT 35
95332: PPUSH
95333: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95337: LD_VAR 0 2
95341: PPUSH
95342: LD_INT 22
95344: PUSH
95345: LD_OWVAR 2
95349: PUSH
95350: EMPTY
95351: LIST
95352: LIST
95353: PPUSH
95354: CALL_OW 69
95358: PPUSH
95359: LD_VAR 0 2
95363: PPUSH
95364: CALL_OW 74
95368: PPUSH
95369: CALL_OW 115
// until IsDead ( un ) ;
95373: LD_VAR 0 2
95377: PPUSH
95378: CALL_OW 301
95382: IFFALSE 95330
// end ;
95384: PPOPN 2
95386: END
// every 0 0$1 trigger StreamModeActive and sStu do
95387: LD_EXP 107
95391: PUSH
95392: LD_EXP 146
95396: AND
95397: IFFALSE 95413
95399: GO 95401
95401: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95402: LD_STRING displayStucuk();
95404: PPUSH
95405: CALL_OW 559
// ResetFog ;
95409: CALL_OW 335
// end ;
95413: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95414: LD_EXP 107
95418: PUSH
95419: LD_EXP 139
95423: AND
95424: IFFALSE 95565
95426: GO 95428
95428: DISABLE
95429: LD_INT 0
95431: PPUSH
95432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95433: LD_ADDR_VAR 0 2
95437: PUSH
95438: LD_INT 22
95440: PUSH
95441: LD_OWVAR 2
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 21
95452: PUSH
95453: LD_INT 1
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PPUSH
95464: CALL_OW 69
95468: ST_TO_ADDR
// if not tmp then
95469: LD_VAR 0 2
95473: NOT
95474: IFFALSE 95478
// exit ;
95476: GO 95565
// un := tmp [ rand ( 1 , tmp ) ] ;
95478: LD_ADDR_VAR 0 1
95482: PUSH
95483: LD_VAR 0 2
95487: PUSH
95488: LD_INT 1
95490: PPUSH
95491: LD_VAR 0 2
95495: PPUSH
95496: CALL_OW 12
95500: ARRAY
95501: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95502: LD_VAR 0 1
95506: PPUSH
95507: LD_INT 0
95509: PPUSH
95510: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95514: LD_VAR 0 1
95518: PPUSH
95519: LD_OWVAR 3
95523: PUSH
95524: LD_VAR 0 1
95528: DIFF
95529: PPUSH
95530: LD_VAR 0 1
95534: PPUSH
95535: CALL_OW 74
95539: PPUSH
95540: CALL_OW 115
// wait ( 0 0$20 ) ;
95544: LD_INT 700
95546: PPUSH
95547: CALL_OW 67
// SetSide ( un , your_side ) ;
95551: LD_VAR 0 1
95555: PPUSH
95556: LD_OWVAR 2
95560: PPUSH
95561: CALL_OW 235
// end ;
95565: PPOPN 2
95567: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95568: LD_EXP 107
95572: PUSH
95573: LD_EXP 140
95577: AND
95578: IFFALSE 95684
95580: GO 95582
95582: DISABLE
95583: LD_INT 0
95585: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95586: LD_ADDR_VAR 0 1
95590: PUSH
95591: LD_INT 22
95593: PUSH
95594: LD_OWVAR 2
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 2
95605: PUSH
95606: LD_INT 30
95608: PUSH
95609: LD_INT 0
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 30
95618: PUSH
95619: LD_INT 1
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: EMPTY
95627: LIST
95628: LIST
95629: LIST
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PPUSH
95635: CALL_OW 69
95639: ST_TO_ADDR
// if not depot then
95640: LD_VAR 0 1
95644: NOT
95645: IFFALSE 95649
// exit ;
95647: GO 95684
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95649: LD_VAR 0 1
95653: PUSH
95654: LD_INT 1
95656: ARRAY
95657: PPUSH
95658: CALL_OW 250
95662: PPUSH
95663: LD_VAR 0 1
95667: PUSH
95668: LD_INT 1
95670: ARRAY
95671: PPUSH
95672: CALL_OW 251
95676: PPUSH
95677: LD_INT 70
95679: PPUSH
95680: CALL_OW 495
// end ;
95684: PPOPN 1
95686: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95687: LD_EXP 107
95691: PUSH
95692: LD_EXP 141
95696: AND
95697: IFFALSE 95908
95699: GO 95701
95701: DISABLE
95702: LD_INT 0
95704: PPUSH
95705: PPUSH
95706: PPUSH
95707: PPUSH
95708: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95709: LD_ADDR_VAR 0 5
95713: PUSH
95714: LD_INT 22
95716: PUSH
95717: LD_OWVAR 2
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 21
95728: PUSH
95729: LD_INT 1
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PPUSH
95740: CALL_OW 69
95744: ST_TO_ADDR
// if not tmp then
95745: LD_VAR 0 5
95749: NOT
95750: IFFALSE 95754
// exit ;
95752: GO 95908
// for i in tmp do
95754: LD_ADDR_VAR 0 1
95758: PUSH
95759: LD_VAR 0 5
95763: PUSH
95764: FOR_IN
95765: IFFALSE 95906
// begin d := rand ( 0 , 5 ) ;
95767: LD_ADDR_VAR 0 4
95771: PUSH
95772: LD_INT 0
95774: PPUSH
95775: LD_INT 5
95777: PPUSH
95778: CALL_OW 12
95782: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95783: LD_ADDR_VAR 0 2
95787: PUSH
95788: LD_VAR 0 1
95792: PPUSH
95793: CALL_OW 250
95797: PPUSH
95798: LD_VAR 0 4
95802: PPUSH
95803: LD_INT 3
95805: PPUSH
95806: LD_INT 12
95808: PPUSH
95809: CALL_OW 12
95813: PPUSH
95814: CALL_OW 272
95818: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95819: LD_ADDR_VAR 0 3
95823: PUSH
95824: LD_VAR 0 1
95828: PPUSH
95829: CALL_OW 251
95833: PPUSH
95834: LD_VAR 0 4
95838: PPUSH
95839: LD_INT 3
95841: PPUSH
95842: LD_INT 12
95844: PPUSH
95845: CALL_OW 12
95849: PPUSH
95850: CALL_OW 273
95854: ST_TO_ADDR
// if ValidHex ( x , y ) then
95855: LD_VAR 0 2
95859: PPUSH
95860: LD_VAR 0 3
95864: PPUSH
95865: CALL_OW 488
95869: IFFALSE 95904
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95871: LD_VAR 0 1
95875: PPUSH
95876: LD_VAR 0 2
95880: PPUSH
95881: LD_VAR 0 3
95885: PPUSH
95886: LD_INT 3
95888: PPUSH
95889: LD_INT 6
95891: PPUSH
95892: CALL_OW 12
95896: PPUSH
95897: LD_INT 1
95899: PPUSH
95900: CALL_OW 483
// end ;
95904: GO 95764
95906: POP
95907: POP
// end ;
95908: PPOPN 5
95910: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95911: LD_EXP 107
95915: PUSH
95916: LD_EXP 142
95920: AND
95921: IFFALSE 96015
95923: GO 95925
95925: DISABLE
95926: LD_INT 0
95928: PPUSH
95929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95930: LD_ADDR_VAR 0 2
95934: PUSH
95935: LD_INT 22
95937: PUSH
95938: LD_OWVAR 2
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: PUSH
95947: LD_INT 32
95949: PUSH
95950: LD_INT 1
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: LD_INT 21
95959: PUSH
95960: LD_INT 2
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: LIST
95971: PPUSH
95972: CALL_OW 69
95976: ST_TO_ADDR
// if not tmp then
95977: LD_VAR 0 2
95981: NOT
95982: IFFALSE 95986
// exit ;
95984: GO 96015
// for i in tmp do
95986: LD_ADDR_VAR 0 1
95990: PUSH
95991: LD_VAR 0 2
95995: PUSH
95996: FOR_IN
95997: IFFALSE 96013
// SetFuel ( i , 0 ) ;
95999: LD_VAR 0 1
96003: PPUSH
96004: LD_INT 0
96006: PPUSH
96007: CALL_OW 240
96011: GO 95996
96013: POP
96014: POP
// end ;
96015: PPOPN 2
96017: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96018: LD_EXP 107
96022: PUSH
96023: LD_EXP 143
96027: AND
96028: IFFALSE 96094
96030: GO 96032
96032: DISABLE
96033: LD_INT 0
96035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96036: LD_ADDR_VAR 0 1
96040: PUSH
96041: LD_INT 22
96043: PUSH
96044: LD_OWVAR 2
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 30
96055: PUSH
96056: LD_INT 29
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: PPUSH
96067: CALL_OW 69
96071: ST_TO_ADDR
// if not tmp then
96072: LD_VAR 0 1
96076: NOT
96077: IFFALSE 96081
// exit ;
96079: GO 96094
// DestroyUnit ( tmp [ 1 ] ) ;
96081: LD_VAR 0 1
96085: PUSH
96086: LD_INT 1
96088: ARRAY
96089: PPUSH
96090: CALL_OW 65
// end ;
96094: PPOPN 1
96096: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96097: LD_EXP 107
96101: PUSH
96102: LD_EXP 145
96106: AND
96107: IFFALSE 96236
96109: GO 96111
96111: DISABLE
96112: LD_INT 0
96114: PPUSH
// begin uc_side := 0 ;
96115: LD_ADDR_OWVAR 20
96119: PUSH
96120: LD_INT 0
96122: ST_TO_ADDR
// uc_nation := nation_arabian ;
96123: LD_ADDR_OWVAR 21
96127: PUSH
96128: LD_INT 2
96130: ST_TO_ADDR
// hc_gallery :=  ;
96131: LD_ADDR_OWVAR 33
96135: PUSH
96136: LD_STRING 
96138: ST_TO_ADDR
// hc_name :=  ;
96139: LD_ADDR_OWVAR 26
96143: PUSH
96144: LD_STRING 
96146: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96147: LD_INT 1
96149: PPUSH
96150: LD_INT 11
96152: PPUSH
96153: LD_INT 10
96155: PPUSH
96156: CALL_OW 380
// un := CreateHuman ;
96160: LD_ADDR_VAR 0 1
96164: PUSH
96165: CALL_OW 44
96169: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96170: LD_VAR 0 1
96174: PPUSH
96175: LD_INT 1
96177: PPUSH
96178: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96182: LD_INT 35
96184: PPUSH
96185: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96189: LD_VAR 0 1
96193: PPUSH
96194: LD_INT 22
96196: PUSH
96197: LD_OWVAR 2
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PPUSH
96206: CALL_OW 69
96210: PPUSH
96211: LD_VAR 0 1
96215: PPUSH
96216: CALL_OW 74
96220: PPUSH
96221: CALL_OW 115
// until IsDead ( un ) ;
96225: LD_VAR 0 1
96229: PPUSH
96230: CALL_OW 301
96234: IFFALSE 96182
// end ;
96236: PPOPN 1
96238: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96239: LD_EXP 107
96243: PUSH
96244: LD_EXP 147
96248: AND
96249: IFFALSE 96261
96251: GO 96253
96253: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96254: LD_STRING earthquake(getX(game), 0, 32)
96256: PPUSH
96257: CALL_OW 559
96261: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96262: LD_EXP 107
96266: PUSH
96267: LD_EXP 148
96271: AND
96272: IFFALSE 96363
96274: GO 96276
96276: DISABLE
96277: LD_INT 0
96279: PPUSH
// begin enable ;
96280: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96281: LD_ADDR_VAR 0 1
96285: PUSH
96286: LD_INT 22
96288: PUSH
96289: LD_OWVAR 2
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: PUSH
96298: LD_INT 21
96300: PUSH
96301: LD_INT 2
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: PUSH
96308: LD_INT 33
96310: PUSH
96311: LD_INT 3
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: LIST
96322: PPUSH
96323: CALL_OW 69
96327: ST_TO_ADDR
// if not tmp then
96328: LD_VAR 0 1
96332: NOT
96333: IFFALSE 96337
// exit ;
96335: GO 96363
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96337: LD_VAR 0 1
96341: PUSH
96342: LD_INT 1
96344: PPUSH
96345: LD_VAR 0 1
96349: PPUSH
96350: CALL_OW 12
96354: ARRAY
96355: PPUSH
96356: LD_INT 1
96358: PPUSH
96359: CALL_OW 234
// end ;
96363: PPOPN 1
96365: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96366: LD_EXP 107
96370: PUSH
96371: LD_EXP 149
96375: AND
96376: IFFALSE 96517
96378: GO 96380
96380: DISABLE
96381: LD_INT 0
96383: PPUSH
96384: PPUSH
96385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96386: LD_ADDR_VAR 0 3
96390: PUSH
96391: LD_INT 22
96393: PUSH
96394: LD_OWVAR 2
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 25
96405: PUSH
96406: LD_INT 1
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PPUSH
96417: CALL_OW 69
96421: ST_TO_ADDR
// if not tmp then
96422: LD_VAR 0 3
96426: NOT
96427: IFFALSE 96431
// exit ;
96429: GO 96517
// un := tmp [ rand ( 1 , tmp ) ] ;
96431: LD_ADDR_VAR 0 2
96435: PUSH
96436: LD_VAR 0 3
96440: PUSH
96441: LD_INT 1
96443: PPUSH
96444: LD_VAR 0 3
96448: PPUSH
96449: CALL_OW 12
96453: ARRAY
96454: ST_TO_ADDR
// if Crawls ( un ) then
96455: LD_VAR 0 2
96459: PPUSH
96460: CALL_OW 318
96464: IFFALSE 96475
// ComWalk ( un ) ;
96466: LD_VAR 0 2
96470: PPUSH
96471: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96475: LD_VAR 0 2
96479: PPUSH
96480: LD_INT 9
96482: PPUSH
96483: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96487: LD_INT 28
96489: PPUSH
96490: LD_OWVAR 2
96494: PPUSH
96495: LD_INT 2
96497: PPUSH
96498: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96502: LD_INT 29
96504: PPUSH
96505: LD_OWVAR 2
96509: PPUSH
96510: LD_INT 2
96512: PPUSH
96513: CALL_OW 322
// end ;
96517: PPOPN 3
96519: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96520: LD_EXP 107
96524: PUSH
96525: LD_EXP 150
96529: AND
96530: IFFALSE 96641
96532: GO 96534
96534: DISABLE
96535: LD_INT 0
96537: PPUSH
96538: PPUSH
96539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96540: LD_ADDR_VAR 0 3
96544: PUSH
96545: LD_INT 22
96547: PUSH
96548: LD_OWVAR 2
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 25
96559: PUSH
96560: LD_INT 1
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PPUSH
96571: CALL_OW 69
96575: ST_TO_ADDR
// if not tmp then
96576: LD_VAR 0 3
96580: NOT
96581: IFFALSE 96585
// exit ;
96583: GO 96641
// un := tmp [ rand ( 1 , tmp ) ] ;
96585: LD_ADDR_VAR 0 2
96589: PUSH
96590: LD_VAR 0 3
96594: PUSH
96595: LD_INT 1
96597: PPUSH
96598: LD_VAR 0 3
96602: PPUSH
96603: CALL_OW 12
96607: ARRAY
96608: ST_TO_ADDR
// if Crawls ( un ) then
96609: LD_VAR 0 2
96613: PPUSH
96614: CALL_OW 318
96618: IFFALSE 96629
// ComWalk ( un ) ;
96620: LD_VAR 0 2
96624: PPUSH
96625: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96629: LD_VAR 0 2
96633: PPUSH
96634: LD_INT 8
96636: PPUSH
96637: CALL_OW 336
// end ;
96641: PPOPN 3
96643: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96644: LD_EXP 107
96648: PUSH
96649: LD_EXP 151
96653: AND
96654: IFFALSE 96798
96656: GO 96658
96658: DISABLE
96659: LD_INT 0
96661: PPUSH
96662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96663: LD_ADDR_VAR 0 2
96667: PUSH
96668: LD_INT 22
96670: PUSH
96671: LD_OWVAR 2
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 21
96682: PUSH
96683: LD_INT 2
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 2
96692: PUSH
96693: LD_INT 34
96695: PUSH
96696: LD_INT 12
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 34
96705: PUSH
96706: LD_INT 51
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 34
96715: PUSH
96716: LD_INT 32
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: LIST
96733: PPUSH
96734: CALL_OW 69
96738: ST_TO_ADDR
// if not tmp then
96739: LD_VAR 0 2
96743: NOT
96744: IFFALSE 96748
// exit ;
96746: GO 96798
// for i in tmp do
96748: LD_ADDR_VAR 0 1
96752: PUSH
96753: LD_VAR 0 2
96757: PUSH
96758: FOR_IN
96759: IFFALSE 96796
// if GetCargo ( i , mat_artifact ) = 0 then
96761: LD_VAR 0 1
96765: PPUSH
96766: LD_INT 4
96768: PPUSH
96769: CALL_OW 289
96773: PUSH
96774: LD_INT 0
96776: EQUAL
96777: IFFALSE 96794
// SetCargo ( i , mat_siberit , 100 ) ;
96779: LD_VAR 0 1
96783: PPUSH
96784: LD_INT 3
96786: PPUSH
96787: LD_INT 100
96789: PPUSH
96790: CALL_OW 290
96794: GO 96758
96796: POP
96797: POP
// end ;
96798: PPOPN 2
96800: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96801: LD_EXP 107
96805: PUSH
96806: LD_EXP 152
96810: AND
96811: IFFALSE 96964
96813: GO 96815
96815: DISABLE
96816: LD_INT 0
96818: PPUSH
96819: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96820: LD_ADDR_VAR 0 2
96824: PUSH
96825: LD_INT 22
96827: PUSH
96828: LD_OWVAR 2
96832: PUSH
96833: EMPTY
96834: LIST
96835: LIST
96836: PPUSH
96837: CALL_OW 69
96841: ST_TO_ADDR
// if not tmp then
96842: LD_VAR 0 2
96846: NOT
96847: IFFALSE 96851
// exit ;
96849: GO 96964
// for i := 1 to 2 do
96851: LD_ADDR_VAR 0 1
96855: PUSH
96856: DOUBLE
96857: LD_INT 1
96859: DEC
96860: ST_TO_ADDR
96861: LD_INT 2
96863: PUSH
96864: FOR_TO
96865: IFFALSE 96962
// begin uc_side := your_side ;
96867: LD_ADDR_OWVAR 20
96871: PUSH
96872: LD_OWVAR 2
96876: ST_TO_ADDR
// uc_nation := nation_american ;
96877: LD_ADDR_OWVAR 21
96881: PUSH
96882: LD_INT 1
96884: ST_TO_ADDR
// vc_chassis := us_morphling ;
96885: LD_ADDR_OWVAR 37
96889: PUSH
96890: LD_INT 5
96892: ST_TO_ADDR
// vc_engine := engine_siberite ;
96893: LD_ADDR_OWVAR 39
96897: PUSH
96898: LD_INT 3
96900: ST_TO_ADDR
// vc_control := control_computer ;
96901: LD_ADDR_OWVAR 38
96905: PUSH
96906: LD_INT 3
96908: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96909: LD_ADDR_OWVAR 40
96913: PUSH
96914: LD_INT 10
96916: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
96917: CALL_OW 45
96921: PPUSH
96922: LD_VAR 0 2
96926: PUSH
96927: LD_INT 1
96929: ARRAY
96930: PPUSH
96931: CALL_OW 250
96935: PPUSH
96936: LD_VAR 0 2
96940: PUSH
96941: LD_INT 1
96943: ARRAY
96944: PPUSH
96945: CALL_OW 251
96949: PPUSH
96950: LD_INT 12
96952: PPUSH
96953: LD_INT 1
96955: PPUSH
96956: CALL_OW 50
// end ;
96960: GO 96864
96962: POP
96963: POP
// end ;
96964: PPOPN 2
96966: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96967: LD_EXP 107
96971: PUSH
96972: LD_EXP 153
96976: AND
96977: IFFALSE 97199
96979: GO 96981
96981: DISABLE
96982: LD_INT 0
96984: PPUSH
96985: PPUSH
96986: PPUSH
96987: PPUSH
96988: PPUSH
96989: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96990: LD_ADDR_VAR 0 6
96994: PUSH
96995: LD_INT 22
96997: PUSH
96998: LD_OWVAR 2
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 21
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 3
97019: PUSH
97020: LD_INT 23
97022: PUSH
97023: LD_INT 0
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: LIST
97038: PPUSH
97039: CALL_OW 69
97043: ST_TO_ADDR
// if not tmp then
97044: LD_VAR 0 6
97048: NOT
97049: IFFALSE 97053
// exit ;
97051: GO 97199
// s1 := rand ( 1 , 4 ) ;
97053: LD_ADDR_VAR 0 2
97057: PUSH
97058: LD_INT 1
97060: PPUSH
97061: LD_INT 4
97063: PPUSH
97064: CALL_OW 12
97068: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97069: LD_ADDR_VAR 0 4
97073: PUSH
97074: LD_VAR 0 6
97078: PUSH
97079: LD_INT 1
97081: ARRAY
97082: PPUSH
97083: LD_VAR 0 2
97087: PPUSH
97088: CALL_OW 259
97092: ST_TO_ADDR
// if s1 = 1 then
97093: LD_VAR 0 2
97097: PUSH
97098: LD_INT 1
97100: EQUAL
97101: IFFALSE 97121
// s2 := rand ( 2 , 4 ) else
97103: LD_ADDR_VAR 0 3
97107: PUSH
97108: LD_INT 2
97110: PPUSH
97111: LD_INT 4
97113: PPUSH
97114: CALL_OW 12
97118: ST_TO_ADDR
97119: GO 97129
// s2 := 1 ;
97121: LD_ADDR_VAR 0 3
97125: PUSH
97126: LD_INT 1
97128: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97129: LD_ADDR_VAR 0 5
97133: PUSH
97134: LD_VAR 0 6
97138: PUSH
97139: LD_INT 1
97141: ARRAY
97142: PPUSH
97143: LD_VAR 0 3
97147: PPUSH
97148: CALL_OW 259
97152: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97153: LD_VAR 0 6
97157: PUSH
97158: LD_INT 1
97160: ARRAY
97161: PPUSH
97162: LD_VAR 0 2
97166: PPUSH
97167: LD_VAR 0 5
97171: PPUSH
97172: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97176: LD_VAR 0 6
97180: PUSH
97181: LD_INT 1
97183: ARRAY
97184: PPUSH
97185: LD_VAR 0 3
97189: PPUSH
97190: LD_VAR 0 4
97194: PPUSH
97195: CALL_OW 237
// end ;
97199: PPOPN 6
97201: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97202: LD_EXP 107
97206: PUSH
97207: LD_EXP 154
97211: AND
97212: IFFALSE 97291
97214: GO 97216
97216: DISABLE
97217: LD_INT 0
97219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97220: LD_ADDR_VAR 0 1
97224: PUSH
97225: LD_INT 22
97227: PUSH
97228: LD_OWVAR 2
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 30
97239: PUSH
97240: LD_INT 3
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: PPUSH
97251: CALL_OW 69
97255: ST_TO_ADDR
// if not tmp then
97256: LD_VAR 0 1
97260: NOT
97261: IFFALSE 97265
// exit ;
97263: GO 97291
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97265: LD_VAR 0 1
97269: PUSH
97270: LD_INT 1
97272: PPUSH
97273: LD_VAR 0 1
97277: PPUSH
97278: CALL_OW 12
97282: ARRAY
97283: PPUSH
97284: LD_INT 1
97286: PPUSH
97287: CALL_OW 234
// end ;
97291: PPOPN 1
97293: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97294: LD_EXP 107
97298: PUSH
97299: LD_EXP 155
97303: AND
97304: IFFALSE 97416
97306: GO 97308
97308: DISABLE
97309: LD_INT 0
97311: PPUSH
97312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97313: LD_ADDR_VAR 0 2
97317: PUSH
97318: LD_INT 22
97320: PUSH
97321: LD_OWVAR 2
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: LD_INT 30
97335: PUSH
97336: LD_INT 27
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PUSH
97343: LD_INT 30
97345: PUSH
97346: LD_INT 26
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: LD_INT 30
97355: PUSH
97356: LD_INT 28
97358: PUSH
97359: EMPTY
97360: LIST
97361: LIST
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PPUSH
97373: CALL_OW 69
97377: ST_TO_ADDR
// if not tmp then
97378: LD_VAR 0 2
97382: NOT
97383: IFFALSE 97387
// exit ;
97385: GO 97416
// for i in tmp do
97387: LD_ADDR_VAR 0 1
97391: PUSH
97392: LD_VAR 0 2
97396: PUSH
97397: FOR_IN
97398: IFFALSE 97414
// SetLives ( i , 1 ) ;
97400: LD_VAR 0 1
97404: PPUSH
97405: LD_INT 1
97407: PPUSH
97408: CALL_OW 234
97412: GO 97397
97414: POP
97415: POP
// end ;
97416: PPOPN 2
97418: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97419: LD_EXP 107
97423: PUSH
97424: LD_EXP 156
97428: AND
97429: IFFALSE 97703
97431: GO 97433
97433: DISABLE
97434: LD_INT 0
97436: PPUSH
97437: PPUSH
97438: PPUSH
// begin i := rand ( 1 , 7 ) ;
97439: LD_ADDR_VAR 0 1
97443: PUSH
97444: LD_INT 1
97446: PPUSH
97447: LD_INT 7
97449: PPUSH
97450: CALL_OW 12
97454: ST_TO_ADDR
// case i of 1 :
97455: LD_VAR 0 1
97459: PUSH
97460: LD_INT 1
97462: DOUBLE
97463: EQUAL
97464: IFTRUE 97468
97466: GO 97478
97468: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97469: LD_STRING earthquake(getX(game), 0, 32)
97471: PPUSH
97472: CALL_OW 559
97476: GO 97703
97478: LD_INT 2
97480: DOUBLE
97481: EQUAL
97482: IFTRUE 97486
97484: GO 97500
97486: POP
// begin ToLua ( displayStucuk(); ) ;
97487: LD_STRING displayStucuk();
97489: PPUSH
97490: CALL_OW 559
// ResetFog ;
97494: CALL_OW 335
// end ; 3 :
97498: GO 97703
97500: LD_INT 3
97502: DOUBLE
97503: EQUAL
97504: IFTRUE 97508
97506: GO 97612
97508: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97509: LD_ADDR_VAR 0 2
97513: PUSH
97514: LD_INT 22
97516: PUSH
97517: LD_OWVAR 2
97521: PUSH
97522: EMPTY
97523: LIST
97524: LIST
97525: PUSH
97526: LD_INT 25
97528: PUSH
97529: LD_INT 1
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PPUSH
97540: CALL_OW 69
97544: ST_TO_ADDR
// if not tmp then
97545: LD_VAR 0 2
97549: NOT
97550: IFFALSE 97554
// exit ;
97552: GO 97703
// un := tmp [ rand ( 1 , tmp ) ] ;
97554: LD_ADDR_VAR 0 3
97558: PUSH
97559: LD_VAR 0 2
97563: PUSH
97564: LD_INT 1
97566: PPUSH
97567: LD_VAR 0 2
97571: PPUSH
97572: CALL_OW 12
97576: ARRAY
97577: ST_TO_ADDR
// if Crawls ( un ) then
97578: LD_VAR 0 3
97582: PPUSH
97583: CALL_OW 318
97587: IFFALSE 97598
// ComWalk ( un ) ;
97589: LD_VAR 0 3
97593: PPUSH
97594: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97598: LD_VAR 0 3
97602: PPUSH
97603: LD_INT 8
97605: PPUSH
97606: CALL_OW 336
// end ; 4 :
97610: GO 97703
97612: LD_INT 4
97614: DOUBLE
97615: EQUAL
97616: IFTRUE 97620
97618: GO 97681
97620: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97621: LD_ADDR_VAR 0 2
97625: PUSH
97626: LD_INT 22
97628: PUSH
97629: LD_OWVAR 2
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PUSH
97638: LD_INT 30
97640: PUSH
97641: LD_INT 29
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: PPUSH
97652: CALL_OW 69
97656: ST_TO_ADDR
// if not tmp then
97657: LD_VAR 0 2
97661: NOT
97662: IFFALSE 97666
// exit ;
97664: GO 97703
// DestroyUnit ( tmp [ 1 ] ) ;
97666: LD_VAR 0 2
97670: PUSH
97671: LD_INT 1
97673: ARRAY
97674: PPUSH
97675: CALL_OW 65
// end ; 5 .. 7 :
97679: GO 97703
97681: LD_INT 5
97683: DOUBLE
97684: GREATEREQUAL
97685: IFFALSE 97693
97687: LD_INT 7
97689: DOUBLE
97690: LESSEQUAL
97691: IFTRUE 97695
97693: GO 97702
97695: POP
// StreamSibBomb ; end ;
97696: CALL 93983 0 0
97700: GO 97703
97702: POP
// end ;
97703: PPOPN 3
97705: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97706: LD_EXP 107
97710: PUSH
97711: LD_EXP 157
97715: AND
97716: IFFALSE 97872
97718: GO 97720
97720: DISABLE
97721: LD_INT 0
97723: PPUSH
97724: PPUSH
97725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97726: LD_ADDR_VAR 0 2
97730: PUSH
97731: LD_INT 81
97733: PUSH
97734: LD_OWVAR 2
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: LD_INT 2
97745: PUSH
97746: LD_INT 21
97748: PUSH
97749: LD_INT 1
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 21
97758: PUSH
97759: LD_INT 2
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: PUSH
97766: EMPTY
97767: LIST
97768: LIST
97769: LIST
97770: PUSH
97771: EMPTY
97772: LIST
97773: LIST
97774: PPUSH
97775: CALL_OW 69
97779: ST_TO_ADDR
// if not tmp then
97780: LD_VAR 0 2
97784: NOT
97785: IFFALSE 97789
// exit ;
97787: GO 97872
// p := 0 ;
97789: LD_ADDR_VAR 0 3
97793: PUSH
97794: LD_INT 0
97796: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97797: LD_INT 35
97799: PPUSH
97800: CALL_OW 67
// p := p + 1 ;
97804: LD_ADDR_VAR 0 3
97808: PUSH
97809: LD_VAR 0 3
97813: PUSH
97814: LD_INT 1
97816: PLUS
97817: ST_TO_ADDR
// for i in tmp do
97818: LD_ADDR_VAR 0 1
97822: PUSH
97823: LD_VAR 0 2
97827: PUSH
97828: FOR_IN
97829: IFFALSE 97860
// if GetLives ( i ) < 1000 then
97831: LD_VAR 0 1
97835: PPUSH
97836: CALL_OW 256
97840: PUSH
97841: LD_INT 1000
97843: LESS
97844: IFFALSE 97858
// SetLives ( i , 1000 ) ;
97846: LD_VAR 0 1
97850: PPUSH
97851: LD_INT 1000
97853: PPUSH
97854: CALL_OW 234
97858: GO 97828
97860: POP
97861: POP
// until p > 20 ;
97862: LD_VAR 0 3
97866: PUSH
97867: LD_INT 20
97869: GREATER
97870: IFFALSE 97797
// end ;
97872: PPOPN 3
97874: END
// every 0 0$1 trigger StreamModeActive and sTime do
97875: LD_EXP 107
97879: PUSH
97880: LD_EXP 158
97884: AND
97885: IFFALSE 97920
97887: GO 97889
97889: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97890: LD_INT 28
97892: PPUSH
97893: LD_OWVAR 2
97897: PPUSH
97898: LD_INT 2
97900: PPUSH
97901: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97905: LD_INT 30
97907: PPUSH
97908: LD_OWVAR 2
97912: PPUSH
97913: LD_INT 2
97915: PPUSH
97916: CALL_OW 322
// end ;
97920: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97921: LD_EXP 107
97925: PUSH
97926: LD_EXP 159
97930: AND
97931: IFFALSE 98052
97933: GO 97935
97935: DISABLE
97936: LD_INT 0
97938: PPUSH
97939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97940: LD_ADDR_VAR 0 2
97944: PUSH
97945: LD_INT 22
97947: PUSH
97948: LD_OWVAR 2
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 21
97959: PUSH
97960: LD_INT 1
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: PUSH
97967: LD_INT 3
97969: PUSH
97970: LD_INT 23
97972: PUSH
97973: LD_INT 0
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: LIST
97988: PPUSH
97989: CALL_OW 69
97993: ST_TO_ADDR
// if not tmp then
97994: LD_VAR 0 2
97998: NOT
97999: IFFALSE 98003
// exit ;
98001: GO 98052
// for i in tmp do
98003: LD_ADDR_VAR 0 1
98007: PUSH
98008: LD_VAR 0 2
98012: PUSH
98013: FOR_IN
98014: IFFALSE 98050
// begin if Crawls ( i ) then
98016: LD_VAR 0 1
98020: PPUSH
98021: CALL_OW 318
98025: IFFALSE 98036
// ComWalk ( i ) ;
98027: LD_VAR 0 1
98031: PPUSH
98032: CALL_OW 138
// SetClass ( i , 2 ) ;
98036: LD_VAR 0 1
98040: PPUSH
98041: LD_INT 2
98043: PPUSH
98044: CALL_OW 336
// end ;
98048: GO 98013
98050: POP
98051: POP
// end ;
98052: PPOPN 2
98054: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98055: LD_EXP 107
98059: PUSH
98060: LD_EXP 160
98064: AND
98065: IFFALSE 98286
98067: GO 98069
98069: DISABLE
98070: LD_INT 0
98072: PPUSH
98073: PPUSH
98074: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98075: LD_OWVAR 2
98079: PPUSH
98080: LD_INT 9
98082: PPUSH
98083: LD_INT 1
98085: PPUSH
98086: LD_INT 1
98088: PPUSH
98089: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98093: LD_INT 9
98095: PPUSH
98096: LD_OWVAR 2
98100: PPUSH
98101: CALL_OW 343
// uc_side := 9 ;
98105: LD_ADDR_OWVAR 20
98109: PUSH
98110: LD_INT 9
98112: ST_TO_ADDR
// uc_nation := 2 ;
98113: LD_ADDR_OWVAR 21
98117: PUSH
98118: LD_INT 2
98120: ST_TO_ADDR
// hc_name := Dark Warrior ;
98121: LD_ADDR_OWVAR 26
98125: PUSH
98126: LD_STRING Dark Warrior
98128: ST_TO_ADDR
// hc_gallery :=  ;
98129: LD_ADDR_OWVAR 33
98133: PUSH
98134: LD_STRING 
98136: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
98137: LD_INT 1
98139: PPUSH
98140: LD_INT 1
98142: PPUSH
98143: LD_INT 10
98145: PPUSH
98146: CALL_OW 380
// un := CreateHuman ;
98150: LD_ADDR_VAR 0 3
98154: PUSH
98155: CALL_OW 44
98159: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98160: LD_VAR 0 3
98164: PPUSH
98165: LD_INT 1
98167: PPUSH
98168: CALL_OW 51
// p := 0 ;
98172: LD_ADDR_VAR 0 2
98176: PUSH
98177: LD_INT 0
98179: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98180: LD_INT 35
98182: PPUSH
98183: CALL_OW 67
// if GetLives ( un ) < 1000 then
98187: LD_VAR 0 3
98191: PPUSH
98192: CALL_OW 256
98196: PUSH
98197: LD_INT 1000
98199: LESS
98200: IFFALSE 98214
// SetLives ( un , 1000 ) ;
98202: LD_VAR 0 3
98206: PPUSH
98207: LD_INT 1000
98209: PPUSH
98210: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
98214: LD_VAR 0 3
98218: PPUSH
98219: LD_INT 81
98221: PUSH
98222: LD_OWVAR 2
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: PPUSH
98231: CALL_OW 69
98235: PPUSH
98236: LD_VAR 0 3
98240: PPUSH
98241: CALL_OW 74
98245: PPUSH
98246: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98250: LD_VAR 0 2
98254: PUSH
98255: LD_INT 60
98257: GREATER
98258: PUSH
98259: LD_VAR 0 3
98263: PPUSH
98264: CALL_OW 301
98268: OR
98269: IFFALSE 98180
// if un then
98271: LD_VAR 0 3
98275: IFFALSE 98286
// RemoveUnit ( un ) ;
98277: LD_VAR 0 3
98281: PPUSH
98282: CALL_OW 64
// end ; end_of_file
98286: PPOPN 3
98288: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
98289: LD_INT 0
98291: PPUSH
98292: PPUSH
98293: PPUSH
98294: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98295: LD_VAR 0 1
98299: PPUSH
98300: CALL_OW 264
98304: PUSH
98305: LD_EXP 106
98309: EQUAL
98310: IFFALSE 98382
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98312: LD_INT 68
98314: PPUSH
98315: LD_VAR 0 1
98319: PPUSH
98320: CALL_OW 255
98324: PPUSH
98325: CALL_OW 321
98329: PUSH
98330: LD_INT 2
98332: EQUAL
98333: IFFALSE 98345
// eff := 70 else
98335: LD_ADDR_VAR 0 6
98339: PUSH
98340: LD_INT 70
98342: ST_TO_ADDR
98343: GO 98353
// eff := 30 ;
98345: LD_ADDR_VAR 0 6
98349: PUSH
98350: LD_INT 30
98352: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98353: LD_VAR 0 1
98357: PPUSH
98358: CALL_OW 250
98362: PPUSH
98363: LD_VAR 0 1
98367: PPUSH
98368: CALL_OW 251
98372: PPUSH
98373: LD_VAR 0 6
98377: PPUSH
98378: CALL_OW 495
// end ; end ;
98382: LD_VAR 0 4
98386: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
98387: LD_INT 0
98389: PPUSH
98390: PPUSH
98391: PPUSH
98392: PPUSH
98393: PPUSH
98394: PPUSH
// if cmd = 124 then
98395: LD_VAR 0 1
98399: PUSH
98400: LD_INT 124
98402: EQUAL
98403: IFFALSE 98609
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
98405: LD_ADDR_VAR 0 5
98409: PUSH
98410: LD_INT 2
98412: PUSH
98413: LD_INT 34
98415: PUSH
98416: LD_INT 53
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: LD_INT 34
98425: PUSH
98426: LD_INT 14
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: LIST
98437: PPUSH
98438: CALL_OW 69
98442: ST_TO_ADDR
// if not tmp then
98443: LD_VAR 0 5
98447: NOT
98448: IFFALSE 98452
// exit ;
98450: GO 98609
// for i in tmp do
98452: LD_ADDR_VAR 0 3
98456: PUSH
98457: LD_VAR 0 5
98461: PUSH
98462: FOR_IN
98463: IFFALSE 98607
// begin taskList := GetTaskList ( i ) ;
98465: LD_ADDR_VAR 0 6
98469: PUSH
98470: LD_VAR 0 3
98474: PPUSH
98475: CALL_OW 437
98479: ST_TO_ADDR
// if not taskList then
98480: LD_VAR 0 6
98484: NOT
98485: IFFALSE 98489
// continue ;
98487: GO 98462
// for j = 1 to taskList do
98489: LD_ADDR_VAR 0 4
98493: PUSH
98494: DOUBLE
98495: LD_INT 1
98497: DEC
98498: ST_TO_ADDR
98499: LD_VAR 0 6
98503: PUSH
98504: FOR_TO
98505: IFFALSE 98603
// if taskList [ j ] [ 1 ] = | then
98507: LD_VAR 0 6
98511: PUSH
98512: LD_VAR 0 4
98516: ARRAY
98517: PUSH
98518: LD_INT 1
98520: ARRAY
98521: PUSH
98522: LD_STRING |
98524: EQUAL
98525: IFFALSE 98601
// begin _taskList := Delete ( taskList , 1 ) ;
98527: LD_ADDR_VAR 0 7
98531: PUSH
98532: LD_VAR 0 6
98536: PPUSH
98537: LD_INT 1
98539: PPUSH
98540: CALL_OW 3
98544: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
98545: LD_VAR 0 3
98549: PPUSH
98550: LD_VAR 0 7
98554: PPUSH
98555: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
98559: LD_VAR 0 3
98563: PPUSH
98564: LD_VAR 0 6
98568: PUSH
98569: LD_VAR 0 4
98573: ARRAY
98574: PUSH
98575: LD_INT 2
98577: ARRAY
98578: PPUSH
98579: LD_VAR 0 6
98583: PUSH
98584: LD_VAR 0 4
98588: ARRAY
98589: PUSH
98590: LD_INT 3
98592: ARRAY
98593: PPUSH
98594: LD_INT 8
98596: PPUSH
98597: CALL 98614 0 4
// end ;
98601: GO 98504
98603: POP
98604: POP
// end ;
98605: GO 98462
98607: POP
98608: POP
// end ; end ;
98609: LD_VAR 0 2
98613: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98614: LD_INT 0
98616: PPUSH
98617: PPUSH
98618: PPUSH
98619: PPUSH
98620: PPUSH
98621: PPUSH
98622: PPUSH
98623: PPUSH
98624: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98625: LD_VAR 0 1
98629: NOT
98630: PUSH
98631: LD_VAR 0 2
98635: PPUSH
98636: LD_VAR 0 3
98640: PPUSH
98641: CALL_OW 488
98645: NOT
98646: OR
98647: PUSH
98648: LD_VAR 0 4
98652: NOT
98653: OR
98654: IFFALSE 98658
// exit ;
98656: GO 98998
// list := [ ] ;
98658: LD_ADDR_VAR 0 13
98662: PUSH
98663: EMPTY
98664: ST_TO_ADDR
// if x - r < 0 then
98665: LD_VAR 0 2
98669: PUSH
98670: LD_VAR 0 4
98674: MINUS
98675: PUSH
98676: LD_INT 0
98678: LESS
98679: IFFALSE 98691
// min_x := 0 else
98681: LD_ADDR_VAR 0 7
98685: PUSH
98686: LD_INT 0
98688: ST_TO_ADDR
98689: GO 98707
// min_x := x - r ;
98691: LD_ADDR_VAR 0 7
98695: PUSH
98696: LD_VAR 0 2
98700: PUSH
98701: LD_VAR 0 4
98705: MINUS
98706: ST_TO_ADDR
// if y - r < 0 then
98707: LD_VAR 0 3
98711: PUSH
98712: LD_VAR 0 4
98716: MINUS
98717: PUSH
98718: LD_INT 0
98720: LESS
98721: IFFALSE 98733
// min_y := 0 else
98723: LD_ADDR_VAR 0 8
98727: PUSH
98728: LD_INT 0
98730: ST_TO_ADDR
98731: GO 98749
// min_y := y - r ;
98733: LD_ADDR_VAR 0 8
98737: PUSH
98738: LD_VAR 0 3
98742: PUSH
98743: LD_VAR 0 4
98747: MINUS
98748: ST_TO_ADDR
// max_x := x + r ;
98749: LD_ADDR_VAR 0 9
98753: PUSH
98754: LD_VAR 0 2
98758: PUSH
98759: LD_VAR 0 4
98763: PLUS
98764: ST_TO_ADDR
// max_y := y + r ;
98765: LD_ADDR_VAR 0 10
98769: PUSH
98770: LD_VAR 0 3
98774: PUSH
98775: LD_VAR 0 4
98779: PLUS
98780: ST_TO_ADDR
// for _x = min_x to max_x do
98781: LD_ADDR_VAR 0 11
98785: PUSH
98786: DOUBLE
98787: LD_VAR 0 7
98791: DEC
98792: ST_TO_ADDR
98793: LD_VAR 0 9
98797: PUSH
98798: FOR_TO
98799: IFFALSE 98916
// for _y = min_y to max_y do
98801: LD_ADDR_VAR 0 12
98805: PUSH
98806: DOUBLE
98807: LD_VAR 0 8
98811: DEC
98812: ST_TO_ADDR
98813: LD_VAR 0 10
98817: PUSH
98818: FOR_TO
98819: IFFALSE 98912
// begin if not ValidHex ( _x , _y ) then
98821: LD_VAR 0 11
98825: PPUSH
98826: LD_VAR 0 12
98830: PPUSH
98831: CALL_OW 488
98835: NOT
98836: IFFALSE 98840
// continue ;
98838: GO 98818
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98840: LD_VAR 0 11
98844: PPUSH
98845: LD_VAR 0 12
98849: PPUSH
98850: CALL_OW 351
98854: PUSH
98855: LD_VAR 0 11
98859: PPUSH
98860: LD_VAR 0 12
98864: PPUSH
98865: CALL_OW 554
98869: AND
98870: IFFALSE 98910
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98872: LD_ADDR_VAR 0 13
98876: PUSH
98877: LD_VAR 0 13
98881: PPUSH
98882: LD_VAR 0 13
98886: PUSH
98887: LD_INT 1
98889: PLUS
98890: PPUSH
98891: LD_VAR 0 11
98895: PUSH
98896: LD_VAR 0 12
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PPUSH
98905: CALL_OW 2
98909: ST_TO_ADDR
// end ;
98910: GO 98818
98912: POP
98913: POP
98914: GO 98798
98916: POP
98917: POP
// if not list then
98918: LD_VAR 0 13
98922: NOT
98923: IFFALSE 98927
// exit ;
98925: GO 98998
// for i in list do
98927: LD_ADDR_VAR 0 6
98931: PUSH
98932: LD_VAR 0 13
98936: PUSH
98937: FOR_IN
98938: IFFALSE 98996
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98940: LD_VAR 0 1
98944: PPUSH
98945: LD_STRING M
98947: PUSH
98948: LD_VAR 0 6
98952: PUSH
98953: LD_INT 1
98955: ARRAY
98956: PUSH
98957: LD_VAR 0 6
98961: PUSH
98962: LD_INT 2
98964: ARRAY
98965: PUSH
98966: LD_INT 0
98968: PUSH
98969: LD_INT 0
98971: PUSH
98972: LD_INT 0
98974: PUSH
98975: LD_INT 0
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: PUSH
98987: EMPTY
98988: LIST
98989: PPUSH
98990: CALL_OW 447
98994: GO 98937
98996: POP
98997: POP
// end ;
98998: LD_VAR 0 5
99002: RET
