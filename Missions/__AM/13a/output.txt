// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56481 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 48333 0 9
// PrepareArabian ;
 140: CALL 3503 0 0
// PrepareRussian ;
 144: CALL 2638 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 58593 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6666 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 79394 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 79820 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 80215 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 80484 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 79760 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 80391 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 79820 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 80215 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 80484 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 79604 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 79760 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13910 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13910 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13910 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13910 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13910 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13910 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13910 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13910 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13910 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13910 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornell
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13910 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13910 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13910 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13910 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13910 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13910 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13910 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20543 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 60
1567: PPUSH
1568: LD_INT 6
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20543 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 3
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 75
1653: PPUSH
1654: LD_INT 6
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
// uc_side := 6 ;
1690: LD_ADDR_OWVAR 20
1694: PUSH
1695: LD_INT 6
1697: ST_TO_ADDR
// uc_nation := 3 ;
1698: LD_ADDR_OWVAR 21
1702: PUSH
1703: LD_INT 3
1705: ST_TO_ADDR
// InitHc ;
1706: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1710: LD_ADDR_EXP 31
1714: PUSH
1715: LD_STRING Gossudarov
1717: PPUSH
1718: CALL_OW 25
1722: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1723: LD_ADDR_EXP 32
1727: PUSH
1728: LD_STRING Kirilenkova
1730: PPUSH
1731: CALL_OW 25
1735: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1736: LD_ADDR_EXP 33
1740: PUSH
1741: LD_STRING Titov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Oblukov
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1762: LD_ADDR_EXP 35
1766: PUSH
1767: LD_STRING Dolgov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1775: LD_ADDR_EXP 36
1779: PUSH
1780: LD_STRING Petrosyan
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1788: LD_ADDR_EXP 37
1792: PUSH
1793: LD_STRING Scholtze
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1801: LD_ADDR_EXP 39
1805: PUSH
1806: LD_STRING Kapitsova
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_EXP 31
1823: PUSH
1824: LD_EXP 32
1828: PUSH
1829: LD_EXP 33
1833: PUSH
1834: LD_EXP 38
1838: PUSH
1839: LD_EXP 35
1843: PUSH
1844: LD_EXP 36
1848: PUSH
1849: LD_EXP 37
1853: PUSH
1854: LD_EXP 39
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 4
1874: PPUSH
1875: LD_INT 8
1877: PPUSH
1878: CALL_OW 380
// un := CreateHuman ;
1882: LD_ADDR_VAR 0 4
1886: PUSH
1887: CALL_OW 44
1891: ST_TO_ADDR
// tmp := tmp ^ un ;
1892: LD_ADDR_VAR 0 2
1896: PUSH
1897: LD_VAR 0 2
1901: PUSH
1902: LD_VAR 0 4
1906: ADD
1907: ST_TO_ADDR
// for i in tmp do
1908: LD_ADDR_VAR 0 3
1912: PUSH
1913: LD_VAR 0 2
1917: PUSH
1918: FOR_IN
1919: IFFALSE 1938
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1921: LD_VAR 0 3
1925: PPUSH
1926: LD_INT 14
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
1936: GO 1918
1938: POP
1939: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1940: LD_VAR 0 2
1944: PPUSH
1945: LD_EXP 3
1949: PPUSH
1950: CALL_OW 250
1954: PPUSH
1955: LD_EXP 3
1959: PPUSH
1960: CALL_OW 251
1964: PPUSH
1965: CALL_OW 111
// end ;
1969: LD_VAR 0 1
1973: RET
// export function PrepareBelkov ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := 4 ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_INT 4
1984: ST_TO_ADDR
// uc_nation := 3 ;
1985: LD_ADDR_OWVAR 21
1989: PUSH
1990: LD_INT 3
1992: ST_TO_ADDR
// InitHc ;
1993: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1997: LD_ADDR_EXP 46
2001: PUSH
2002: LD_STRING Belkov
2004: PPUSH
2005: CALL_OW 25
2009: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2010: LD_EXP 46
2014: PPUSH
2015: LD_INT 14
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: CALL_OW 49
// end ;
2025: LD_VAR 0 1
2029: RET
// export function PrepareGnyevko ; begin
2030: LD_INT 0
2032: PPUSH
// uc_side := 4 ;
2033: LD_ADDR_OWVAR 20
2037: PUSH
2038: LD_INT 4
2040: ST_TO_ADDR
// uc_nation := 3 ;
2041: LD_ADDR_OWVAR 21
2045: PUSH
2046: LD_INT 3
2048: ST_TO_ADDR
// InitHc ;
2049: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2053: LD_ADDR_EXP 47
2057: PUSH
2058: LD_STRING Gnyevko
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2066: LD_EXP 47
2070: PPUSH
2071: LD_INT 14
2073: PPUSH
2074: LD_INT 0
2076: PPUSH
2077: CALL_OW 49
// end ;
2081: LD_VAR 0 1
2085: RET
// export function PrepareBurlak ; var i , tmp ; begin
2086: LD_INT 0
2088: PPUSH
2089: PPUSH
2090: PPUSH
// uc_side := 4 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 4
2098: ST_TO_ADDR
// uc_nation := 3 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 3
2106: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2107: LD_INT 35
2109: PPUSH
2110: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2114: LD_INT 92
2116: PUSH
2117: LD_INT 123
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 3
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: PPUSH
2132: CALL_OW 69
2136: NOT
2137: IFFALSE 2107
// InitHc ;
2139: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Burlak
2150: PPUSH
2151: CALL_OW 25
2155: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2156: LD_INT 24
2158: PUSH
2159: LD_INT 23
2161: PUSH
2162: LD_INT 22
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_OWVAR 67
2174: ARRAY
2175: PPUSH
2176: LD_INT 1
2178: PPUSH
2179: LD_INT 1
2181: PPUSH
2182: LD_INT 45
2184: PUSH
2185: LD_INT 44
2187: PUSH
2188: LD_INT 43
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 0
2204: PPUSH
2205: CALL 20543 0 5
// Masha := CreateVehicle ;
2209: LD_ADDR_EXP 48
2213: PUSH
2214: CALL_OW 45
2218: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2219: LD_EXP 48
2223: PUSH
2224: LD_EXP 45
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PPUSH
2233: LD_INT 499
2235: PPUSH
2236: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2240: LD_EXP 48
2244: PPUSH
2245: LD_INT 3
2247: PPUSH
2248: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2252: LD_EXP 48
2256: PPUSH
2257: LD_INT 1
2259: PPUSH
2260: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2264: LD_EXP 48
2268: PPUSH
2269: LD_INT 18
2271: PPUSH
2272: LD_INT 0
2274: PPUSH
2275: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2279: LD_EXP 45
2283: PPUSH
2284: LD_INT 125
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 0
2292: PPUSH
2293: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2297: LD_EXP 45
2301: PPUSH
2302: LD_EXP 48
2306: PPUSH
2307: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2311: LD_INT 10
2313: PPUSH
2314: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2318: LD_EXP 48
2322: PPUSH
2323: LD_INT 110
2325: PPUSH
2326: LD_INT 10
2328: PPUSH
2329: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2333: LD_ADDR_EXP 41
2337: PUSH
2338: LD_STRING Petrovova
2340: PPUSH
2341: CALL_OW 25
2345: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2346: LD_ADDR_EXP 43
2350: PUSH
2351: LD_STRING Kuzmov
2353: PPUSH
2354: CALL_OW 25
2358: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Kovalyuk
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2372: LD_ADDR_EXP 40
2376: PUSH
2377: LD_STRING Lipshchin
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2385: LD_ADDR_EXP 44
2389: PUSH
2390: LD_STRING Karamazov
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_EXP 41
2407: PUSH
2408: LD_EXP 43
2412: PUSH
2413: LD_EXP 42
2417: PUSH
2418: LD_EXP 40
2422: PUSH
2423: LD_EXP 44
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: ST_TO_ADDR
// for i in tmp do
2435: LD_ADDR_VAR 0 2
2439: PUSH
2440: LD_VAR 0 3
2444: PUSH
2445: FOR_IN
2446: IFFALSE 2485
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2448: LD_VAR 0 2
2452: PPUSH
2453: LD_INT 399
2455: PPUSH
2456: LD_INT 799
2458: PPUSH
2459: CALL_OW 12
2463: PPUSH
2464: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2468: LD_VAR 0 2
2472: PPUSH
2473: LD_INT 19
2475: PPUSH
2476: LD_INT 0
2478: PPUSH
2479: CALL_OW 49
// end ;
2483: GO 2445
2485: POP
2486: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2487: LD_VAR 0 3
2491: PPUSH
2492: LD_INT 116
2494: PPUSH
2495: LD_INT 8
2497: PPUSH
2498: CALL_OW 111
// AddComHold ( tmp ) ;
2502: LD_VAR 0 3
2506: PPUSH
2507: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 3
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 1
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 72
2535: PUSH
2536: FOR_IN
2537: IFFALSE 2577
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2539: LD_VAR 0 2
2543: PPUSH
2544: LD_INT 20
2546: PPUSH
2547: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2551: LD_VAR 0 2
2555: PPUSH
2556: LD_INT 147
2558: PPUSH
2559: LD_INT 45
2561: PPUSH
2562: CALL_OW 178
// AddComCrawl ( i ) ;
2566: LD_VAR 0 2
2570: PPUSH
2571: CALL_OW 197
// end ;
2575: GO 2536
2577: POP
2578: POP
// repeat wait ( 0 0$1 ) ;
2579: LD_INT 35
2581: PPUSH
2582: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2586: LD_EXP 48
2590: PPUSH
2591: LD_INT 110
2593: PPUSH
2594: LD_INT 10
2596: PPUSH
2597: CALL_OW 307
2601: PUSH
2602: LD_EXP 48
2606: PPUSH
2607: CALL_OW 305
2611: NOT
2612: OR
2613: IFFALSE 2579
// ComStop ( Burlak ) ;
2615: LD_EXP 45
2619: PPUSH
2620: CALL_OW 141
// AddComHold ( Burlak ) ;
2624: LD_EXP 45
2628: PPUSH
2629: CALL_OW 200
// end ; end_of_file
2633: LD_VAR 0 1
2637: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2638: LD_INT 0
2640: PPUSH
2641: PPUSH
2642: PPUSH
2643: PPUSH
// uc_side := 3 ;
2644: LD_ADDR_OWVAR 20
2648: PUSH
2649: LD_INT 3
2651: ST_TO_ADDR
// uc_nation := 3 ;
2652: LD_ADDR_OWVAR 21
2656: PUSH
2657: LD_INT 3
2659: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2660: LD_ADDR_EXP 49
2664: PUSH
2665: LD_INT 47
2667: PPUSH
2668: LD_INT 4
2670: PPUSH
2671: LD_STRING 
2673: PPUSH
2674: LD_INT 7
2676: PUSH
2677: LD_INT 8
2679: PUSH
2680: LD_INT 9
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PUSH
2688: LD_OWVAR 67
2692: ARRAY
2693: PPUSH
2694: LD_INT 10000
2696: PUSH
2697: LD_INT 3000
2699: PUSH
2700: LD_INT 300
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 9
2710: PUSH
2711: LD_INT 5
2713: PUSH
2714: LD_INT 6
2716: PUSH
2717: LD_INT 6
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL 23952 0 6
2730: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2731: LD_ADDR_EXP 58
2735: PUSH
2736: LD_EXP 58
2740: PPUSH
2741: LD_INT 2
2743: PPUSH
2744: LD_EXP 49
2748: PPUSH
2749: CALL_OW 1
2753: ST_TO_ADDR
// tmp := [ ] ;
2754: LD_ADDR_VAR 0 4
2758: PUSH
2759: EMPTY
2760: ST_TO_ADDR
// for i = 1 to 4 do
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: DOUBLE
2767: LD_INT 1
2769: DEC
2770: ST_TO_ADDR
2771: LD_INT 4
2773: PUSH
2774: FOR_TO
2775: IFFALSE 2868
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2777: LD_INT 22
2779: PPUSH
2780: LD_INT 3
2782: PPUSH
2783: LD_INT 3
2785: PPUSH
2786: LD_INT 43
2788: PUSH
2789: LD_INT 45
2791: PUSH
2792: LD_INT 45
2794: PUSH
2795: LD_INT 44
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: PUSH
2804: LD_VAR 0 2
2808: PUSH
2809: LD_INT 4
2811: MOD
2812: PUSH
2813: LD_INT 1
2815: PLUS
2816: ARRAY
2817: PPUSH
2818: LD_INT 100
2820: PPUSH
2821: CALL 20543 0 5
// veh := CreateVehicle ;
2825: LD_ADDR_VAR 0 3
2829: PUSH
2830: CALL_OW 45
2834: ST_TO_ADDR
// tmp := tmp ^ veh ;
2835: LD_ADDR_VAR 0 4
2839: PUSH
2840: LD_VAR 0 4
2844: PUSH
2845: LD_VAR 0 3
2849: ADD
2850: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2851: LD_VAR 0 3
2855: PPUSH
2856: LD_INT 2
2858: PPUSH
2859: LD_INT 0
2861: PPUSH
2862: CALL_OW 49
// end ;
2866: GO 2774
2868: POP
2869: POP
// russian_guard := tmp ;
2870: LD_ADDR_EXP 50
2874: PUSH
2875: LD_VAR 0 4
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 1
2884: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2885: LD_INT 47
2887: PPUSH
2888: CALL_OW 302
2892: PUSH
2893: LD_EXP 6
2897: AND
2898: IFFALSE 3500
2900: GO 2902
2902: DISABLE
2903: LD_INT 0
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
// begin enable ;
2911: ENABLE
// base := 2 ;
2912: LD_ADDR_VAR 0 2
2916: PUSH
2917: LD_INT 2
2919: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2920: LD_ADDR_VAR 0 4
2924: PUSH
2925: LD_INT 0
2927: PUSH
2928: LD_INT 0
2930: PUSH
2931: LD_INT 0
2933: PUSH
2934: LD_INT 0
2936: PUSH
2937: LD_INT 0
2939: PUSH
2940: LD_INT 0
2942: PUSH
2943: LD_INT 0
2945: PUSH
2946: LD_INT 0
2948: PUSH
2949: LD_INT 1
2951: PUSH
2952: LD_INT 0
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2967: LD_ADDR_VAR 0 3
2971: PUSH
2972: LD_INT 22
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 3
2980: PUSH
2981: LD_INT 45
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: LD_INT 45
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 22
3010: PUSH
3011: LD_INT 1
3013: PUSH
3014: LD_INT 3
3016: PUSH
3017: LD_INT 45
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: PUSH
3026: LD_INT 23
3028: PUSH
3029: LD_INT 1
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: LD_INT 46
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3050: LD_ADDR_VAR 0 1
3054: PUSH
3055: DOUBLE
3056: LD_INT 1
3058: DEC
3059: ST_TO_ADDR
3060: LD_OWVAR 67
3064: PUSH
3065: LD_OWVAR 1
3069: PUSH
3070: LD_INT 21000
3072: DIV
3073: PLUS
3074: PUSH
3075: FOR_TO
3076: IFFALSE 3164
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: LD_VAR 0 3
3087: PPUSH
3088: LD_VAR 0 3
3092: PUSH
3093: LD_INT 1
3095: PLUS
3096: PPUSH
3097: LD_INT 23
3099: PUSH
3100: LD_INT 24
3102: PUSH
3103: EMPTY
3104: LIST
3105: LIST
3106: PUSH
3107: LD_INT 1
3109: PPUSH
3110: LD_INT 2
3112: PPUSH
3113: CALL_OW 12
3117: ARRAY
3118: PUSH
3119: LD_INT 1
3121: PUSH
3122: LD_INT 3
3124: PUSH
3125: LD_INT 46
3127: PUSH
3128: LD_INT 47
3130: PUSH
3131: LD_INT 45
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 1
3141: PPUSH
3142: LD_INT 3
3144: PPUSH
3145: CALL_OW 12
3149: ARRAY
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: PPUSH
3157: CALL_OW 2
3161: ST_TO_ADDR
3162: GO 3075
3164: POP
3165: POP
// MC_InsertProduceList ( base , tmp ) ;
3166: LD_VAR 0 2
3170: PPUSH
3171: LD_VAR 0 3
3175: PPUSH
3176: CALL 79760 0 2
// repeat wait ( 0 0$1 ) ;
3180: LD_INT 35
3182: PPUSH
3183: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3187: LD_EXP 77
3191: PUSH
3192: LD_VAR 0 2
3196: ARRAY
3197: PUSH
3198: LD_INT 6
3200: GREATER
3201: IFFALSE 3180
// wait ( 0 0$20 ) ;
3203: LD_INT 700
3205: PPUSH
3206: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3210: LD_ADDR_VAR 0 5
3214: PUSH
3215: LD_INT 71
3217: PUSH
3218: LD_INT 19
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 91
3227: PUSH
3228: LD_INT 67
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 52
3237: PUSH
3238: LD_INT 44
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 68
3247: PUSH
3248: LD_INT 48
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3261: LD_ADDR_VAR 0 6
3265: PUSH
3266: LD_EXP 77
3270: PUSH
3271: LD_VAR 0 2
3275: ARRAY
3276: PUSH
3277: LD_EXP 77
3281: PUSH
3282: LD_VAR 0 2
3286: ARRAY
3287: PPUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 34
3293: PUSH
3294: LD_INT 51
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 34
3303: PUSH
3304: LD_INT 52
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PPUSH
3316: CALL_OW 72
3320: DIFF
3321: ST_TO_ADDR
// if not attackers then
3322: LD_VAR 0 6
3326: NOT
3327: IFFALSE 3331
// exit ;
3329: GO 3500
// ru_attackers := attackers ;
3331: LD_ADDR_EXP 51
3335: PUSH
3336: LD_VAR 0 6
3340: ST_TO_ADDR
// for i = 1 to attackers do
3341: LD_ADDR_VAR 0 1
3345: PUSH
3346: DOUBLE
3347: LD_INT 1
3349: DEC
3350: ST_TO_ADDR
3351: LD_VAR 0 6
3355: PUSH
3356: FOR_TO
3357: IFFALSE 3434
// begin case i mod 3 of 0 :
3359: LD_VAR 0 1
3363: PUSH
3364: LD_INT 3
3366: MOD
3367: PUSH
3368: LD_INT 0
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3379
3376: POP
// ; 1 :
3377: GO 3432
3379: LD_INT 1
3381: DOUBLE
3382: EQUAL
3383: IFTRUE 3387
3385: GO 3405
3387: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3388: LD_VAR 0 1
3392: PPUSH
3393: LD_INT 32
3395: PPUSH
3396: LD_INT 49
3398: PPUSH
3399: CALL_OW 114
3403: GO 3432
3405: LD_INT 2
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 117
3421: PPUSH
3422: LD_INT 107
3424: PPUSH
3425: CALL_OW 114
3429: GO 3432
3431: POP
// end ;
3432: GO 3356
3434: POP
3435: POP
// repeat wait ( 0 0$1 ) ;
3436: LD_INT 35
3438: PPUSH
3439: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3443: LD_VAR 0 6
3447: PPUSH
3448: LD_INT 60
3450: PUSH
3451: EMPTY
3452: LIST
3453: PPUSH
3454: CALL_OW 72
3458: NOT
3459: IFFALSE 3436
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3461: LD_VAR 0 2
3465: PPUSH
3466: LD_VAR 0 6
3470: PPUSH
3471: LD_VAR 0 5
3475: PPUSH
3476: LD_VAR 0 4
3480: PPUSH
3481: CALL 79945 0 4
// if not first_attack then
3485: LD_EXP 7
3489: NOT
3490: IFFALSE 3500
// first_attack := true ;
3492: LD_ADDR_EXP 7
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// end ; end_of_file
3500: PPOPN 6
3502: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3503: LD_INT 0
3505: PPUSH
3506: PPUSH
3507: PPUSH
3508: PPUSH
3509: PPUSH
3510: PPUSH
3511: PPUSH
// uc_side := 2 ;
3512: LD_ADDR_OWVAR 20
3516: PUSH
3517: LD_INT 2
3519: ST_TO_ADDR
// uc_nation := 2 ;
3520: LD_ADDR_OWVAR 21
3524: PUSH
3525: LD_INT 2
3527: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3528: LD_ADDR_EXP 54
3532: PUSH
3533: LD_STRING Abdul
3535: PPUSH
3536: CALL_OW 25
3540: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3541: LD_EXP 54
3545: PPUSH
3546: LD_INT 11
3548: PPUSH
3549: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3553: LD_EXP 54
3557: PPUSH
3558: LD_INT 1
3560: PPUSH
3561: CALL_OW 52
// vc_chassis := 31 ;
3565: LD_ADDR_OWVAR 37
3569: PUSH
3570: LD_INT 31
3572: ST_TO_ADDR
// vc_control := control_rider ;
3573: LD_ADDR_OWVAR 38
3577: PUSH
3578: LD_INT 4
3580: ST_TO_ADDR
// mastodont := CreateVehicle ;
3581: LD_ADDR_EXP 55
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3591: LD_EXP 55
3595: PPUSH
3596: LD_INT 153
3598: PPUSH
3599: LD_INT 71
3601: PPUSH
3602: LD_INT 0
3604: PPUSH
3605: CALL_OW 48
// InitVc ;
3609: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3613: LD_ADDR_EXP 52
3617: PUSH
3618: LD_INT 1
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_STRING 
3626: PPUSH
3627: LD_INT 7
3629: PUSH
3630: LD_INT 8
3632: PUSH
3633: LD_INT 9
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: LIST
3640: PUSH
3641: LD_OWVAR 67
3645: ARRAY
3646: PPUSH
3647: LD_INT 5000
3649: PUSH
3650: LD_INT 1000
3652: PUSH
3653: LD_INT 300
3655: PUSH
3656: EMPTY
3657: LIST
3658: LIST
3659: LIST
3660: PPUSH
3661: LD_INT 22
3663: PUSH
3664: LD_INT 5
3666: PUSH
3667: LD_INT 6
3669: PUSH
3670: LD_INT 9
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: PPUSH
3679: CALL 23952 0 6
3683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3684: LD_ADDR_EXP 58
3688: PUSH
3689: LD_EXP 58
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: LD_EXP 52
3701: PPUSH
3702: CALL_OW 1
3706: ST_TO_ADDR
// tmp := [ ] ;
3707: LD_ADDR_VAR 0 4
3711: PUSH
3712: EMPTY
3713: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3714: LD_ADDR_OWVAR 37
3718: PUSH
3719: LD_INT 14
3721: ST_TO_ADDR
// vc_engine := engine_siberite ;
3722: LD_ADDR_OWVAR 39
3726: PUSH
3727: LD_INT 3
3729: ST_TO_ADDR
// vc_control := control_manual ;
3730: LD_ADDR_OWVAR 38
3734: PUSH
3735: LD_INT 1
3737: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3738: LD_ADDR_OWVAR 40
3742: PUSH
3743: LD_INT 31
3745: ST_TO_ADDR
// for i = 1 to 3 do
3746: LD_ADDR_VAR 0 2
3750: PUSH
3751: DOUBLE
3752: LD_INT 1
3754: DEC
3755: ST_TO_ADDR
3756: LD_INT 3
3758: PUSH
3759: FOR_TO
3760: IFFALSE 4004
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_INT 153
3769: PUSH
3770: LD_INT 71
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 155
3779: PUSH
3780: LD_INT 81
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: MOD
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: ARRAY
3804: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3805: LD_INT 0
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_INT 7
3813: PUSH
3814: LD_INT 8
3816: PUSH
3817: LD_INT 9
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_OWVAR 67
3829: ARRAY
3830: PPUSH
3831: CALL_OW 380
// un := CreateVehicle ;
3835: LD_ADDR_VAR 0 6
3839: PUSH
3840: CALL_OW 45
3844: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3845: LD_VAR 0 6
3849: PPUSH
3850: LD_INT 0
3852: PPUSH
3853: LD_INT 5
3855: PPUSH
3856: CALL_OW 12
3860: PPUSH
3861: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_VAR 0 5
3874: PUSH
3875: LD_INT 1
3877: ARRAY
3878: PPUSH
3879: LD_VAR 0 5
3883: PUSH
3884: LD_INT 2
3886: ARRAY
3887: PPUSH
3888: LD_INT 6
3890: PPUSH
3891: LD_INT 0
3893: PPUSH
3894: CALL_OW 50
// un2 := CreateHuman ;
3898: LD_ADDR_VAR 0 7
3902: PUSH
3903: CALL_OW 44
3907: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3908: LD_VAR 0 7
3912: PPUSH
3913: LD_VAR 0 6
3917: PPUSH
3918: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3922: LD_ADDR_EXP 58
3926: PUSH
3927: LD_EXP 58
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_EXP 58
3939: PUSH
3940: LD_INT 1
3942: ARRAY
3943: PUSH
3944: LD_INT 1
3946: PLUS
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PPUSH
3952: LD_VAR 0 6
3956: PPUSH
3957: CALL 20665 0 3
3961: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3962: LD_ADDR_EXP 58
3966: PUSH
3967: LD_EXP 58
3971: PPUSH
3972: LD_INT 1
3974: PUSH
3975: LD_EXP 58
3979: PUSH
3980: LD_INT 1
3982: ARRAY
3983: PUSH
3984: LD_INT 1
3986: PLUS
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: LD_VAR 0 7
3996: PPUSH
3997: CALL 20665 0 3
4001: ST_TO_ADDR
// end ;
4002: GO 3759
4004: POP
4005: POP
// for i = 1 to 5 do
4006: LD_ADDR_VAR 0 2
4010: PUSH
4011: DOUBLE
4012: LD_INT 1
4014: DEC
4015: ST_TO_ADDR
4016: LD_INT 5
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4113
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4022: LD_INT 14
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 25
4033: PUSH
4034: LD_INT 28
4036: PUSH
4037: LD_INT 28
4039: PUSH
4040: LD_INT 26
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: PUSH
4049: LD_VAR 0 2
4053: PUSH
4054: LD_INT 4
4056: MOD
4057: PUSH
4058: LD_INT 1
4060: PLUS
4061: ARRAY
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 20543 0 5
// veh := CreateVehicle ;
4070: LD_ADDR_VAR 0 3
4074: PUSH
4075: CALL_OW 45
4079: ST_TO_ADDR
// tmp := tmp ^ veh ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_VAR 0 4
4089: PUSH
4090: LD_VAR 0 3
4094: ADD
4095: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4096: LD_VAR 0 3
4100: PPUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_INT 0
4106: PPUSH
4107: CALL_OW 49
// end ;
4111: GO 4019
4113: POP
4114: POP
// arabian_guard := tmp ;
4115: LD_ADDR_EXP 53
4119: PUSH
4120: LD_VAR 0 4
4124: ST_TO_ADDR
// end ;
4125: LD_VAR 0 1
4129: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4130: LD_INT 22
4132: PUSH
4133: LD_INT 7
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 91
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: LD_INT 12
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: PPUSH
4158: CALL_OW 69
4162: PUSH
4163: LD_EXP 55
4167: PPUSH
4168: CALL_OW 256
4172: PUSH
4173: LD_INT 990
4175: LESS
4176: OR
4177: PUSH
4178: LD_EXP 54
4182: PPUSH
4183: CALL_OW 256
4187: PUSH
4188: LD_INT 990
4190: LESS
4191: OR
4192: IFFALSE 4335
4194: GO 4196
4196: DISABLE
// begin if IsInUnit ( Abdul ) then
4197: LD_EXP 54
4201: PPUSH
4202: CALL_OW 310
4206: IFFALSE 4217
// ComExitBuilding ( Abdul ) ;
4208: LD_EXP 54
4212: PPUSH
4213: CALL_OW 122
// if Mastodont then
4217: LD_EXP 55
4221: IFFALSE 4238
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4223: LD_EXP 55
4227: PPUSH
4228: LD_INT 205
4230: PPUSH
4231: LD_INT 132
4233: PPUSH
4234: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4238: LD_EXP 54
4242: PPUSH
4243: LD_INT 205
4245: PPUSH
4246: LD_INT 132
4248: PPUSH
4249: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4260: LD_EXP 54
4264: PPUSH
4265: LD_INT 21
4267: PPUSH
4268: CALL_OW 308
4272: IFFALSE 4253
// RemoveUnit ( Abdul ) ;
4274: LD_EXP 54
4278: PPUSH
4279: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4283: LD_INT 35
4285: PPUSH
4286: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4290: LD_EXP 55
4294: PPUSH
4295: LD_INT 21
4297: PPUSH
4298: CALL_OW 308
4302: PUSH
4303: LD_EXP 55
4307: PPUSH
4308: CALL_OW 301
4312: OR
4313: IFFALSE 4283
// if IsOk ( Mastodont ) then
4315: LD_EXP 55
4319: PPUSH
4320: CALL_OW 302
4324: IFFALSE 4335
// RemoveUnit ( Mastodont ) ;
4326: LD_EXP 55
4330: PPUSH
4331: CALL_OW 64
// end ;
4335: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4336: LD_EXP 54
4340: PPUSH
4341: CALL_OW 301
4345: PUSH
4346: LD_INT 22
4348: PUSH
4349: LD_INT 2
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: LD_INT 25
4361: PUSH
4362: LD_INT 1
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: LD_INT 25
4371: PUSH
4372: LD_INT 2
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 25
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 25
4391: PUSH
4392: LD_INT 4
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: PUSH
4399: LD_INT 25
4401: PUSH
4402: LD_INT 8
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 69
4425: PUSH
4426: LD_INT 16
4428: PUSH
4429: LD_INT 19
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_OWVAR 67
4444: ARRAY
4445: LESS
4446: OR
4447: IFFALSE 5120
4449: GO 4451
4451: DISABLE
4452: LD_INT 0
4454: PPUSH
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
// begin MC_Kill ( 1 ) ;
4460: LD_INT 1
4462: PPUSH
4463: CALL 56716 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: LD_INT 22
4474: PUSH
4475: LD_INT 2
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 1
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: LD_INT 25
4497: PUSH
4498: LD_INT 2
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 25
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 25
4517: PUSH
4518: LD_INT 4
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: LD_INT 25
4527: PUSH
4528: LD_INT 8
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// for i in tmp do
4552: LD_ADDR_VAR 0 5
4556: PUSH
4557: LD_VAR 0 2
4561: PUSH
4562: FOR_IN
4563: IFFALSE 4579
// SetTag ( i , 10 ) ;
4565: LD_VAR 0 5
4569: PPUSH
4570: LD_INT 10
4572: PPUSH
4573: CALL_OW 109
4577: GO 4562
4579: POP
4580: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: LD_INT 22
4588: PUSH
4589: LD_INT 2
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 21
4598: PUSH
4599: LD_INT 1
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: EMPTY
4607: LIST
4608: LIST
4609: PPUSH
4610: CALL_OW 69
4614: PUSH
4615: LD_VAR 0 2
4619: DIFF
4620: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4621: LD_ADDR_VAR 0 1
4625: PUSH
4626: LD_INT 22
4628: PUSH
4629: LD_INT 2
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: LD_INT 21
4638: PUSH
4639: LD_INT 2
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 24
4648: PUSH
4649: LD_INT 300
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: LIST
4660: PPUSH
4661: CALL_OW 69
4665: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4666: LD_ADDR_VAR 0 4
4670: PUSH
4671: LD_VAR 0 1
4675: PPUSH
4676: LD_INT 33
4678: PUSH
4679: LD_INT 1
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 58
4688: PUSH
4689: EMPTY
4690: LIST
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PPUSH
4696: CALL_OW 72
4700: ST_TO_ADDR
// for i in tmp do
4701: LD_ADDR_VAR 0 5
4705: PUSH
4706: LD_VAR 0 2
4710: PUSH
4711: FOR_IN
4712: IFFALSE 4896
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4714: LD_VAR 0 5
4718: PUSH
4719: LD_INT 55
4721: PUSH
4722: EMPTY
4723: LIST
4724: PPUSH
4725: CALL_OW 69
4729: IN
4730: IFFALSE 4749
// begin AddComMoveXY ( i , 209 , 132 ) ;
4732: LD_VAR 0 5
4736: PPUSH
4737: LD_INT 209
4739: PPUSH
4740: LD_INT 132
4742: PPUSH
4743: CALL_OW 171
// continue ;
4747: GO 4711
// end ; if IsInUnit ( i ) then
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 310
4758: IFFALSE 4776
// begin ComExitBuilding ( i ) ;
4760: LD_VAR 0 5
4764: PPUSH
4765: CALL_OW 122
// wait ( 3 ) ;
4769: LD_INT 3
4771: PPUSH
4772: CALL_OW 67
// end ; if tmp_empty then
4776: LD_VAR 0 4
4780: IFFALSE 4879
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4782: LD_VAR 0 5
4786: PPUSH
4787: LD_VAR 0 4
4791: PPUSH
4792: LD_VAR 0 5
4796: PPUSH
4797: CALL_OW 74
4801: PPUSH
4802: CALL_OW 296
4806: PUSH
4807: LD_INT 25
4809: LESS
4810: IFFALSE 4879
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4812: LD_ADDR_VAR 0 6
4816: PUSH
4817: LD_VAR 0 4
4821: PPUSH
4822: LD_VAR 0 5
4826: PPUSH
4827: CALL_OW 74
4831: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4832: LD_VAR 0 5
4836: PPUSH
4837: LD_VAR 0 6
4841: PPUSH
4842: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4846: LD_VAR 0 5
4850: PPUSH
4851: LD_INT 209
4853: PPUSH
4854: LD_INT 132
4856: PPUSH
4857: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4861: LD_ADDR_VAR 0 4
4865: PUSH
4866: LD_VAR 0 4
4870: PUSH
4871: LD_VAR 0 6
4875: DIFF
4876: ST_TO_ADDR
// continue ;
4877: GO 4711
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4879: LD_VAR 0 5
4883: PPUSH
4884: LD_INT 201
4886: PPUSH
4887: LD_INT 132
4889: PPUSH
4890: CALL_OW 171
// end ;
4894: GO 4711
4896: POP
4897: POP
// for i in tmp_ape do
4898: LD_ADDR_VAR 0 5
4902: PUSH
4903: LD_VAR 0 3
4907: PUSH
4908: FOR_IN
4909: IFFALSE 4948
// begin if IsInUnit ( i ) then
4911: LD_VAR 0 5
4915: PPUSH
4916: CALL_OW 310
4920: IFFALSE 4931
// ComExitBuilding ( i ) ;
4922: LD_VAR 0 5
4926: PPUSH
4927: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_INT 201
4938: PPUSH
4939: LD_INT 132
4941: PPUSH
4942: CALL_OW 171
// end ;
4946: GO 4908
4948: POP
4949: POP
// repeat wait ( 0 0$1 ) ;
4950: LD_INT 35
4952: PPUSH
4953: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4957: LD_ADDR_VAR 0 5
4961: PUSH
4962: LD_VAR 0 2
4966: PUSH
4967: LD_VAR 0 3
4971: UNION
4972: PUSH
4973: LD_VAR 0 1
4977: UNION
4978: PUSH
4979: FOR_IN
4980: IFFALSE 5011
// if not HasTask ( i ) then
4982: LD_VAR 0 5
4986: PPUSH
4987: CALL_OW 314
4991: NOT
4992: IFFALSE 5009
// ComMoveXY ( i , 201 , 132 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 201
5001: PPUSH
5002: LD_INT 132
5004: PPUSH
5005: CALL_OW 111
5009: GO 4979
5011: POP
5012: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5013: LD_INT 21
5015: PPUSH
5016: LD_INT 22
5018: PUSH
5019: LD_INT 2
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL_OW 70
5030: IFFALSE 5071
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_INT 21
5039: PPUSH
5040: LD_INT 22
5042: PUSH
5043: LD_INT 2
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: PPUSH
5050: CALL_OW 70
5054: PUSH
5055: FOR_IN
5056: IFFALSE 5069
// RemoveUnit ( i ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: CALL_OW 64
5067: GO 5055
5069: POP
5070: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5071: LD_INT 22
5073: PUSH
5074: LD_INT 2
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: LD_INT 21
5086: PUSH
5087: LD_INT 1
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 21
5096: PUSH
5097: LD_INT 2
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PPUSH
5113: CALL_OW 69
5117: NOT
5118: IFFALSE 4950
// end ;
5120: PPOPN 6
5122: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5123: LD_EXP 9
5127: PUSH
5128: LD_INT 92
5130: PPUSH
5131: LD_INT 40
5133: PPUSH
5134: CALL_OW 428
5138: PPUSH
5139: CALL_OW 266
5143: PUSH
5144: LD_INT 30
5146: EQUAL
5147: AND
5148: IFFALSE 5344
5150: GO 5152
5152: DISABLE
5153: LD_INT 0
5155: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_EXP 58
5165: PUSH
5166: LD_INT 1
5168: ARRAY
5169: PPUSH
5170: LD_INT 25
5172: PUSH
5173: LD_INT 4
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 72
5184: ST_TO_ADDR
// if not sci then
5185: LD_VAR 0 1
5189: NOT
5190: IFFALSE 5194
// exit ;
5192: GO 5344
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5194: LD_ADDR_EXP 58
5198: PUSH
5199: LD_EXP 58
5203: PPUSH
5204: LD_INT 1
5206: PPUSH
5207: LD_EXP 58
5211: PUSH
5212: LD_INT 1
5214: ARRAY
5215: PUSH
5216: LD_VAR 0 1
5220: PUSH
5221: LD_INT 1
5223: ARRAY
5224: DIFF
5225: PPUSH
5226: CALL_OW 1
5230: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5231: LD_VAR 0 1
5235: PUSH
5236: LD_INT 1
5238: ARRAY
5239: PPUSH
5240: CALL_OW 310
5244: IFFALSE 5259
// ComExitBuilding ( sci [ 1 ] ) ;
5246: LD_VAR 0 1
5250: PUSH
5251: LD_INT 1
5253: ARRAY
5254: PPUSH
5255: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5259: LD_INT 2
5261: PPUSH
5262: LD_INT 105
5264: PPUSH
5265: LD_INT 14
5267: PPUSH
5268: LD_INT 20
5270: PPUSH
5271: CALL 21561 0 4
5275: PUSH
5276: LD_INT 4
5278: ARRAY
5279: PUSH
5280: LD_INT 10
5282: LESS
5283: IFFALSE 5306
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5285: LD_VAR 0 1
5289: PUSH
5290: LD_INT 1
5292: ARRAY
5293: PPUSH
5294: LD_INT 105
5296: PPUSH
5297: LD_INT 14
5299: PPUSH
5300: CALL_OW 171
5304: GO 5325
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5306: LD_VAR 0 1
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PPUSH
5315: LD_INT 118
5317: PPUSH
5318: LD_INT 77
5320: PPUSH
5321: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5325: LD_VAR 0 1
5329: PUSH
5330: LD_INT 1
5332: ARRAY
5333: PPUSH
5334: LD_INT 92
5336: PPUSH
5337: LD_INT 40
5339: PPUSH
5340: CALL_OW 218
// end ;
5344: PPOPN 1
5346: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5347: LD_INT 1
5349: PPUSH
5350: CALL_OW 302
5354: PUSH
5355: LD_EXP 9
5359: AND
5360: IFFALSE 5819
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
5368: PPUSH
5369: PPUSH
5370: PPUSH
5371: PPUSH
5372: PPUSH
// begin enable ;
5373: ENABLE
// base := 1 ;
5374: LD_ADDR_VAR 0 2
5378: PUSH
5379: LD_INT 1
5381: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5382: LD_ADDR_VAR 0 4
5386: PUSH
5387: LD_INT 0
5389: PUSH
5390: LD_INT 0
5392: PUSH
5393: LD_INT 0
5395: PUSH
5396: LD_INT 0
5398: PUSH
5399: LD_INT 0
5401: PUSH
5402: LD_INT 0
5404: PUSH
5405: LD_INT 0
5407: PUSH
5408: LD_INT 0
5410: PUSH
5411: LD_INT 1
5413: PUSH
5414: LD_INT 0
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: LD_INT 14
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 2
5442: PUSH
5443: LD_INT 26
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: PUSH
5452: LD_INT 14
5454: PUSH
5455: LD_INT 1
5457: PUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 28
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 13
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: LD_INT 2
5478: PUSH
5479: LD_INT 29
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5493: LD_ADDR_VAR 0 1
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_OWVAR 67
5507: PUSH
5508: LD_OWVAR 1
5512: PUSH
5513: LD_INT 21000
5515: DIV
5516: PLUS
5517: PUSH
5518: FOR_TO
5519: IFFALSE 5611
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5521: LD_ADDR_VAR 0 3
5525: PUSH
5526: LD_VAR 0 3
5530: PPUSH
5531: LD_VAR 0 3
5535: PUSH
5536: LD_INT 1
5538: PLUS
5539: PPUSH
5540: LD_INT 13
5542: PUSH
5543: LD_INT 14
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 1
5552: PPUSH
5553: LD_INT 2
5555: PPUSH
5556: CALL_OW 12
5560: ARRAY
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 2
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: LD_INT 29
5573: PUSH
5574: LD_INT 25
5576: PUSH
5577: LD_INT 26
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 1
5588: PPUSH
5589: LD_INT 4
5591: PPUSH
5592: CALL_OW 12
5596: ARRAY
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PPUSH
5604: CALL_OW 2
5608: ST_TO_ADDR
5609: GO 5518
5611: POP
5612: POP
// MC_InsertProduceList ( base , tmp ) ;
5613: LD_VAR 0 2
5617: PPUSH
5618: LD_VAR 0 3
5622: PPUSH
5623: CALL 79760 0 2
// repeat wait ( 0 0$1 ) ;
5627: LD_INT 35
5629: PPUSH
5630: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5634: LD_EXP 77
5638: PUSH
5639: LD_VAR 0 2
5643: ARRAY
5644: PUSH
5645: LD_INT 6
5647: GREATER
5648: IFFALSE 5627
// wait ( 0 0$20 ) ;
5650: LD_INT 700
5652: PPUSH
5653: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5657: LD_ADDR_VAR 0 5
5661: PUSH
5662: LD_INT 124
5664: PUSH
5665: LD_INT 85
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 90
5674: PUSH
5675: LD_INT 61
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 69
5684: PUSH
5685: LD_INT 48
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 68
5694: PUSH
5695: LD_INT 48
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5708: LD_ADDR_VAR 0 6
5712: PUSH
5713: LD_EXP 77
5717: PUSH
5718: LD_VAR 0 2
5722: ARRAY
5723: PUSH
5724: LD_EXP 77
5728: PUSH
5729: LD_VAR 0 2
5733: ARRAY
5734: PPUSH
5735: LD_INT 34
5737: PUSH
5738: LD_INT 32
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PPUSH
5745: CALL_OW 72
5749: DIFF
5750: ST_TO_ADDR
// if not attackers then
5751: LD_VAR 0 6
5755: NOT
5756: IFFALSE 5760
// exit ;
5758: GO 5819
// ar_attackers := attackers ;
5760: LD_ADDR_EXP 10
5764: PUSH
5765: LD_VAR 0 6
5769: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5777: LD_VAR 0 6
5781: PPUSH
5782: LD_INT 60
5784: PUSH
5785: EMPTY
5786: LIST
5787: PPUSH
5788: CALL_OW 72
5792: NOT
5793: IFFALSE 5770
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_VAR 0 6
5804: PPUSH
5805: LD_VAR 0 5
5809: PPUSH
5810: LD_VAR 0 4
5814: PPUSH
5815: CALL 79945 0 4
// end ;
5819: PPOPN 6
5821: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5822: LD_INT 1
5824: PPUSH
5825: CALL_OW 302
5829: PUSH
5830: LD_EXP 9
5834: AND
5835: PUSH
5836: LD_EXP 48
5840: PPUSH
5841: LD_INT 22
5843: PPUSH
5844: CALL_OW 308
5848: AND
5849: PUSH
5850: LD_INT 1
5852: PPUSH
5853: CALL 80108 0 1
5857: PUSH
5858: LD_INT 0
5860: EQUAL
5861: AND
5862: PUSH
5863: LD_EXP 10
5867: NOT
5868: AND
5869: IFFALSE 6333
5871: GO 5873
5873: DISABLE
5874: LD_INT 0
5876: PPUSH
5877: PPUSH
5878: PPUSH
5879: PPUSH
5880: PPUSH
5881: PPUSH
5882: PPUSH
// begin base := 1 ;
5883: LD_ADDR_VAR 0 2
5887: PUSH
5888: LD_INT 1
5890: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_INT 0
5898: PUSH
5899: LD_INT 0
5901: PUSH
5902: LD_INT 0
5904: PUSH
5905: LD_INT 0
5907: PUSH
5908: LD_INT 0
5910: PUSH
5911: LD_INT 0
5913: PUSH
5914: LD_INT 0
5916: PUSH
5917: LD_INT 0
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 0
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 28
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 13
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 27
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 13
5981: PUSH
5982: LD_INT 1
5984: PUSH
5985: LD_INT 2
5987: PUSH
5988: LD_INT 25
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 11
5999: PUSH
6000: LD_INT 2
6002: PUSH
6003: LD_INT 2
6005: PUSH
6006: LD_INT 24
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 11
6017: PUSH
6018: LD_INT 2
6020: PUSH
6021: LD_INT 2
6023: PUSH
6024: LD_INT 24
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6040: LD_VAR 0 2
6044: PPUSH
6045: LD_VAR 0 3
6049: PPUSH
6050: CALL 79760 0 2
// repeat wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6061: LD_EXP 77
6065: PUSH
6066: LD_VAR 0 2
6070: ARRAY
6071: PUSH
6072: LD_INT 6
6074: GREATEREQUAL
6075: IFFALSE 6054
// wait ( 0 0$20 ) ;
6077: LD_INT 700
6079: PPUSH
6080: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 119
6091: PUSH
6092: LD_INT 9
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6102: LD_ADDR_VAR 0 6
6106: PUSH
6107: LD_EXP 77
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_EXP 77
6122: PUSH
6123: LD_VAR 0 2
6127: ARRAY
6128: PPUSH
6129: LD_INT 34
6131: PUSH
6132: LD_INT 32
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PPUSH
6139: CALL_OW 72
6143: DIFF
6144: ST_TO_ADDR
// if not attackers then
6145: LD_VAR 0 6
6149: NOT
6150: IFFALSE 6154
// exit ;
6152: GO 6333
// uc_side := 2 ;
6154: LD_ADDR_OWVAR 20
6158: PUSH
6159: LD_INT 2
6161: ST_TO_ADDR
// uc_nation := 2 ;
6162: LD_ADDR_OWVAR 21
6166: PUSH
6167: LD_INT 2
6169: ST_TO_ADDR
// InitHc ;
6170: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6174: LD_ADDR_VAR 0 1
6178: PUSH
6179: DOUBLE
6180: LD_INT 1
6182: DEC
6183: ST_TO_ADDR
6184: LD_INT 4
6186: PUSH
6187: LD_INT 5
6189: PUSH
6190: LD_INT 6
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PUSH
6198: LD_OWVAR 67
6202: ARRAY
6203: PUSH
6204: FOR_TO
6205: IFFALSE 6282
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 15
6212: PUSH
6213: LD_INT 17
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 1
6222: PPUSH
6223: LD_INT 2
6225: PPUSH
6226: CALL_OW 12
6230: ARRAY
6231: PPUSH
6232: LD_INT 8
6234: PPUSH
6235: CALL_OW 380
// un := CreateHuman ;
6239: LD_ADDR_VAR 0 7
6243: PUSH
6244: CALL_OW 44
6248: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6249: LD_VAR 0 7
6253: PPUSH
6254: LD_INT 23
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// attackers := attackers union un ;
6264: LD_ADDR_VAR 0 6
6268: PUSH
6269: LD_VAR 0 6
6273: PUSH
6274: LD_VAR 0 7
6278: UNION
6279: ST_TO_ADDR
// end ;
6280: GO 6204
6282: POP
6283: POP
// repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6291: LD_VAR 0 6
6295: PPUSH
6296: LD_INT 60
6298: PUSH
6299: EMPTY
6300: LIST
6301: PPUSH
6302: CALL_OW 72
6306: NOT
6307: IFFALSE 6284
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6309: LD_VAR 0 2
6313: PPUSH
6314: LD_VAR 0 6
6318: PPUSH
6319: LD_VAR 0 5
6323: PPUSH
6324: LD_VAR 0 4
6328: PPUSH
6329: CALL 79945 0 4
// end ; end_of_file
6333: PPOPN 7
6335: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6336: LD_INT 0
6338: PPUSH
6339: PPUSH
6340: PPUSH
6341: PPUSH
// uc_side := 1 ;
6342: LD_ADDR_OWVAR 20
6346: PUSH
6347: LD_INT 1
6349: ST_TO_ADDR
// uc_nation := 1 ;
6350: LD_ADDR_OWVAR 21
6354: PUSH
6355: LD_INT 1
6357: ST_TO_ADDR
// InitHc ;
6358: CALL_OW 19
// InitVc ;
6362: CALL_OW 20
// tmp := [ ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: EMPTY
6372: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6373: LD_ADDR_VAR 0 2
6377: PUSH
6378: DOUBLE
6379: LD_INT 1
6381: DEC
6382: ST_TO_ADDR
6383: LD_INT 5
6385: PUSH
6386: LD_INT 6
6388: PUSH
6389: LD_INT 6
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: LIST
6396: PUSH
6397: LD_OWVAR 67
6401: ARRAY
6402: PUSH
6403: FOR_TO
6404: IFFALSE 6541
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6406: LD_INT 2
6408: PUSH
6409: LD_INT 4
6411: PUSH
6412: LD_INT 5
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 1
6422: PPUSH
6423: LD_INT 3
6425: PPUSH
6426: CALL_OW 12
6430: ARRAY
6431: PPUSH
6432: LD_INT 1
6434: PUSH
6435: LD_INT 3
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 1
6444: PPUSH
6445: LD_INT 2
6447: PPUSH
6448: CALL_OW 12
6452: ARRAY
6453: PPUSH
6454: LD_INT 3
6456: PPUSH
6457: LD_INT 9
6459: PUSH
6460: LD_INT 7
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 2
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 78
6481: PPUSH
6482: CALL 20543 0 5
// veh := CreateVehicle ;
6486: LD_ADDR_VAR 0 4
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6496: LD_VAR 0 4
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6508: LD_VAR 0 4
6512: PPUSH
6513: LD_INT 17
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// tmp := tmp ^ veh ;
6523: LD_ADDR_VAR 0 3
6527: PUSH
6528: LD_VAR 0 3
6532: PUSH
6533: LD_VAR 0 4
6537: ADD
6538: ST_TO_ADDR
// end ;
6539: GO 6403
6541: POP
6542: POP
// if not tmp then
6543: LD_VAR 0 3
6547: NOT
6548: IFFALSE 6552
// exit ;
6550: GO 6661
// if not first_powell_attack then
6552: LD_EXP 11
6556: NOT
6557: IFFALSE 6567
// first_powell_attack := true ;
6559: LD_ADDR_EXP 11
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6567: LD_INT 70
6569: PPUSH
6570: CALL_OW 67
// for i in tmp do
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_VAR 0 3
6583: PUSH
6584: FOR_IN
6585: IFFALSE 6652
// if IsOk ( i ) then
6587: LD_VAR 0 2
6591: PPUSH
6592: CALL_OW 302
6596: IFFALSE 6634
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6598: LD_VAR 0 2
6602: PPUSH
6603: LD_INT 81
6605: PUSH
6606: LD_INT 1
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PPUSH
6613: CALL_OW 69
6617: PPUSH
6618: LD_VAR 0 2
6622: PPUSH
6623: CALL_OW 74
6627: PPUSH
6628: CALL_OW 115
6632: GO 6650
// tmp := tmp diff i ;
6634: LD_ADDR_VAR 0 3
6638: PUSH
6639: LD_VAR 0 3
6643: PUSH
6644: LD_VAR 0 2
6648: DIFF
6649: ST_TO_ADDR
6650: GO 6584
6652: POP
6653: POP
// until not tmp ;
6654: LD_VAR 0 3
6658: NOT
6659: IFFALSE 6567
// end ; end_of_file
6661: LD_VAR 0 1
6665: RET
// export function Action ; var tmp , i , un ; begin
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
6671: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6672: LD_INT 68
6674: PPUSH
6675: LD_INT 39
6677: PPUSH
6678: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6682: LD_ADDR_VAR 0 2
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_INT 7
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PPUSH
6697: CALL_OW 69
6701: ST_TO_ADDR
// InGameOn ;
6702: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6706: LD_VAR 0 2
6710: PPUSH
6711: LD_INT 71
6713: PPUSH
6714: LD_INT 49
6716: PPUSH
6717: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6721: LD_INT 35
6723: PPUSH
6724: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6728: LD_INT 7
6730: PPUSH
6731: LD_INT 71
6733: PPUSH
6734: LD_INT 51
6736: PPUSH
6737: CALL_OW 293
6741: IFFALSE 6721
// DialogueOn ;
6743: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6747: LD_EXP 14
6751: PPUSH
6752: LD_STRING D1-JMM-1
6754: PPUSH
6755: CALL_OW 88
// if Joan then
6759: LD_EXP 29
6763: IFFALSE 6777
// Say ( Joan , D1-Joan-1 ) ;
6765: LD_EXP 29
6769: PPUSH
6770: LD_STRING D1-Joan-1
6772: PPUSH
6773: CALL_OW 88
// if Lisa then
6777: LD_EXP 16
6781: IFFALSE 6795
// Say ( Lisa , D1-Lisa-1 ) ;
6783: LD_EXP 16
6787: PPUSH
6788: LD_STRING D1-Lisa-1
6790: PPUSH
6791: CALL_OW 88
// if Joan or Lisa then
6795: LD_EXP 29
6799: PUSH
6800: LD_EXP 16
6804: OR
6805: IFFALSE 6819
// Say ( JMM , D1-JMM-2 ) ;
6807: LD_EXP 14
6811: PPUSH
6812: LD_STRING D1-JMM-2
6814: PPUSH
6815: CALL_OW 88
// DialogueOff ;
6819: CALL_OW 7
// InGameOff ;
6823: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6827: LD_INT 71
6829: PPUSH
6830: LD_INT 50
6832: PPUSH
6833: LD_INT 7
6835: PPUSH
6836: LD_INT 30
6838: NEG
6839: PPUSH
6840: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6844: LD_INT 71
6846: PPUSH
6847: LD_INT 50
6849: PPUSH
6850: LD_INT 7
6852: PPUSH
6853: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6857: LD_STRING M1
6859: PPUSH
6860: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6864: LD_INT 35
6866: PPUSH
6867: CALL_OW 67
// until freedom ;
6871: LD_EXP 3
6875: IFFALSE 6864
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6877: LD_INT 350
6879: PPUSH
6880: LD_INT 700
6882: PPUSH
6883: CALL_OW 12
6887: PPUSH
6888: CALL_OW 67
// PrepareGossudarov ;
6892: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6896: LD_INT 35
6898: PPUSH
6899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6903: LD_INT 22
6905: PUSH
6906: LD_INT 6
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: LD_INT 24
6918: PUSH
6919: LD_INT 1000
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 69
6938: PUSH
6939: LD_INT 7
6941: PPUSH
6942: LD_EXP 31
6946: PPUSH
6947: CALL_OW 292
6951: OR
6952: IFFALSE 6896
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_INT 6
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: PPUSH
6969: CALL_OW 69
6973: ST_TO_ADDR
// for i in tmp do
6974: LD_ADDR_VAR 0 3
6978: PUSH
6979: LD_VAR 0 2
6983: PUSH
6984: FOR_IN
6985: IFFALSE 7001
// SetSide ( i , 7 ) ;
6987: LD_VAR 0 3
6991: PPUSH
6992: LD_INT 7
6994: PPUSH
6995: CALL_OW 235
6999: GO 6984
7001: POP
7002: POP
// DialogueOn ;
7003: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7007: LD_EXP 14
7011: PUSH
7012: LD_EXP 15
7016: PUSH
7017: EMPTY
7018: LIST
7019: LIST
7020: PPUSH
7021: LD_EXP 31
7025: PPUSH
7026: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7030: LD_EXP 31
7034: PPUSH
7035: CALL_OW 87
// if not Roth then
7039: LD_EXP 15
7043: NOT
7044: IFFALSE 7136
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7046: LD_VAR 0 2
7050: PPUSH
7051: LD_INT 3
7053: PUSH
7054: LD_INT 24
7056: PUSH
7057: LD_INT 1000
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PPUSH
7068: CALL_OW 72
7072: IFFALSE 7086
// Say ( JMM , D2-JMM-1 ) ;
7074: LD_EXP 14
7078: PPUSH
7079: LD_STRING D2-JMM-1
7081: PPUSH
7082: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7086: LD_EXP 14
7090: PPUSH
7091: LD_STRING D2-JMM-1b
7093: PPUSH
7094: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7098: LD_EXP 31
7102: PPUSH
7103: LD_STRING D2-Gos-1
7105: PPUSH
7106: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7110: LD_EXP 14
7114: PPUSH
7115: LD_STRING D2-JMM-2
7117: PPUSH
7118: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7122: LD_EXP 31
7126: PPUSH
7127: LD_STRING D2-Gos-2
7129: PPUSH
7130: CALL_OW 88
// end else
7134: GO 7288
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7136: LD_VAR 0 2
7140: PPUSH
7141: LD_INT 3
7143: PUSH
7144: LD_INT 24
7146: PUSH
7147: LD_INT 1000
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PPUSH
7158: CALL_OW 72
7162: IFFALSE 7188
// begin Say ( Roth , D2-Roth-2 ) ;
7164: LD_EXP 15
7168: PPUSH
7169: LD_STRING D2-Roth-2
7171: PPUSH
7172: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7176: LD_EXP 14
7180: PPUSH
7181: LD_STRING D2-JMM-1a
7183: PPUSH
7184: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7188: LD_EXP 15
7192: PPUSH
7193: LD_STRING D2-Roth-2a
7195: PPUSH
7196: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7200: LD_EXP 15
7204: PPUSH
7205: LD_STRING D2-Roth-2b
7207: PPUSH
7208: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7212: LD_EXP 14
7216: PPUSH
7217: LD_STRING D2-JMM-3
7219: PPUSH
7220: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7224: LD_VAR 0 2
7228: PPUSH
7229: LD_INT 3
7231: PUSH
7232: LD_INT 24
7234: PUSH
7235: LD_INT 1000
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: PPUSH
7246: CALL_OW 72
7250: IFFALSE 7288
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7252: LD_EXP 31
7256: PPUSH
7257: LD_STRING D2-Gos-3
7259: PPUSH
7260: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7264: LD_EXP 14
7268: PPUSH
7269: LD_STRING D2-JMM-4
7271: PPUSH
7272: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7276: LD_EXP 31
7280: PPUSH
7281: LD_STRING D2-Gos-4
7283: PPUSH
7284: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7288: LD_EXP 14
7292: PPUSH
7293: LD_STRING D2-JMM-5
7295: PPUSH
7296: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7300: LD_EXP 31
7304: PPUSH
7305: LD_STRING D2-Gos-5
7307: PPUSH
7308: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7312: LD_EXP 14
7316: PPUSH
7317: LD_STRING D2-JMM-6
7319: PPUSH
7320: CALL_OW 88
// DialogueOff ;
7324: CALL_OW 7
// wait ( 0 0$2 ) ;
7328: LD_INT 70
7330: PPUSH
7331: CALL_OW 67
// if Kirilenkova then
7335: LD_EXP 32
7339: IFFALSE 7353
// Say ( Kirilenkova , D3-Kir-1 ) ;
7341: LD_EXP 32
7345: PPUSH
7346: LD_STRING D3-Kir-1
7348: PPUSH
7349: CALL_OW 88
// gossudarov_arrive := true ;
7353: LD_ADDR_EXP 4
7357: PUSH
7358: LD_INT 1
7360: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7361: LD_STRING CombinedForces
7363: PPUSH
7364: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7368: LD_INT 35
7370: PPUSH
7371: CALL_OW 67
// until ru_lab_builded ;
7375: LD_EXP 5
7379: IFFALSE 7368
// if Kirilenkova then
7381: LD_EXP 32
7385: IFFALSE 7401
// Say ( Kirilenkova , D3a-Kir-1 ) else
7387: LD_EXP 32
7391: PPUSH
7392: LD_STRING D3a-Kir-1
7394: PPUSH
7395: CALL_OW 88
7399: GO 7423
// begin un := SciRu ;
7401: LD_ADDR_VAR 0 4
7405: PUSH
7406: CALL 12393 0 0
7410: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7411: LD_VAR 0 4
7415: PPUSH
7416: LD_STRING D3a-Sci1-1
7418: PPUSH
7419: CALL_OW 88
// end ; if Kirilenkova or un then
7423: LD_EXP 32
7427: PUSH
7428: LD_VAR 0 4
7432: OR
7433: IFFALSE 7447
// Say ( JMM , D3a-JMM-1 ) ;
7435: LD_EXP 14
7439: PPUSH
7440: LD_STRING D3a-JMM-1
7442: PPUSH
7443: CALL_OW 88
// end ;
7447: LD_VAR 0 1
7451: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7452: LD_EXP 4
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_INT 7
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: PUSH
7467: LD_INT 2
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 1
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 25
7482: PUSH
7483: LD_INT 2
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 25
7492: PUSH
7493: LD_INT 3
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: LD_INT 25
7502: PUSH
7503: LD_INT 4
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 25
7512: PUSH
7513: LD_INT 5
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 25
7522: PUSH
7523: LD_INT 8
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 25
7532: PUSH
7533: LD_INT 9
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PPUSH
7554: CALL_OW 69
7558: PUSH
7559: LD_INT 7
7561: LESS
7562: AND
7563: IFFALSE 7575
7565: GO 7567
7567: DISABLE
// YouLost ( TooMany ) ;
7568: LD_STRING TooMany
7570: PPUSH
7571: CALL_OW 104
7575: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7576: LD_EXP 31
7580: PPUSH
7581: CALL_OW 255
7585: PUSH
7586: LD_INT 7
7588: EQUAL
7589: IFFALSE 7789
7591: GO 7593
7593: DISABLE
7594: LD_INT 0
7596: PPUSH
7597: PPUSH
7598: PPUSH
// begin uc_side := 3 ;
7599: LD_ADDR_OWVAR 20
7603: PUSH
7604: LD_INT 3
7606: ST_TO_ADDR
// uc_nation := 3 ;
7607: LD_ADDR_OWVAR 21
7611: PUSH
7612: LD_INT 3
7614: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7615: LD_INT 21
7617: PPUSH
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 42
7626: PPUSH
7627: LD_INT 100
7629: PPUSH
7630: CALL 20543 0 5
// un := CreateVehicle ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: CALL_OW 45
7643: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7644: LD_VAR 0 3
7648: PPUSH
7649: LD_INT 15
7651: PPUSH
7652: LD_INT 0
7654: PPUSH
7655: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7659: LD_VAR 0 3
7663: PPUSH
7664: LD_INT 67
7666: PPUSH
7667: LD_INT 45
7669: PPUSH
7670: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7674: LD_VAR 0 3
7678: PPUSH
7679: LD_INT 70
7681: PPUSH
7682: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7686: LD_VAR 0 3
7690: PPUSH
7691: LD_INT 69
7693: PPUSH
7694: LD_INT 18
7696: PPUSH
7697: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7701: LD_VAR 0 3
7705: PPUSH
7706: LD_INT 60
7708: PPUSH
7709: LD_INT 2
7711: PPUSH
7712: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7716: LD_INT 35
7718: PPUSH
7719: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 302
7732: NOT
7733: PUSH
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 17
7741: PPUSH
7742: CALL_OW 308
7746: OR
7747: IFFALSE 7716
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7749: LD_VAR 0 3
7753: PPUSH
7754: LD_INT 17
7756: PPUSH
7757: CALL_OW 308
7761: PUSH
7762: LD_VAR 0 3
7766: PPUSH
7767: LD_INT 60
7769: PPUSH
7770: LD_INT 2
7772: PPUSH
7773: CALL_OW 307
7777: OR
7778: IFFALSE 7789
// RemoveUnit ( un ) ;
7780: LD_VAR 0 3
7784: PPUSH
7785: CALL_OW 64
// end ;
7789: PPOPN 3
7791: END
// every 0 0$2 do var i , un , tmp ;
7792: GO 7794
7794: DISABLE
7795: LD_INT 0
7797: PPUSH
7798: PPUSH
7799: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7800: LD_INT 70
7802: PPUSH
7803: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7807: LD_ADDR_VAR 0 3
7811: PUSH
7812: LD_INT 22
7814: PUSH
7815: LD_INT 7
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PUSH
7822: LD_INT 101
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL_OW 69
7840: ST_TO_ADDR
// until tmp ;
7841: LD_VAR 0 3
7845: IFFALSE 7800
// un := NearestUnitToUnit ( tmp , JMM ) ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 3
7856: PPUSH
7857: LD_EXP 14
7861: PPUSH
7862: CALL_OW 74
7866: ST_TO_ADDR
// player_spotted := true ;
7867: LD_ADDR_EXP 6
7871: PUSH
7872: LD_INT 1
7874: ST_TO_ADDR
// tmp := SciRu ;
7875: LD_ADDR_VAR 0 3
7879: PUSH
7880: CALL 12393 0 0
7884: ST_TO_ADDR
// if not tmp then
7885: LD_VAR 0 3
7889: NOT
7890: IFFALSE 7902
// tmp := SolRu ;
7892: LD_ADDR_VAR 0 3
7896: PUSH
7897: CALL 12540 0 0
7901: ST_TO_ADDR
// DialogueOn ;
7902: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7906: LD_VAR 0 2
7910: PPUSH
7911: CALL_OW 250
7915: PPUSH
7916: LD_VAR 0 2
7920: PPUSH
7921: CALL_OW 251
7925: PPUSH
7926: LD_INT 7
7928: PPUSH
7929: LD_INT 8
7931: NEG
7932: PPUSH
7933: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7937: LD_VAR 0 2
7941: PPUSH
7942: CALL_OW 87
// if tmp then
7946: LD_VAR 0 3
7950: IFFALSE 7964
// Say ( tmp , D4-RSci1-1 ) ;
7952: LD_VAR 0 3
7956: PPUSH
7957: LD_STRING D4-RSci1-1
7959: PPUSH
7960: CALL_OW 88
// if Gossudarov then
7964: LD_EXP 31
7968: IFFALSE 7994
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7970: LD_EXP 31
7974: PPUSH
7975: LD_STRING D4-Gos-1
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7982: LD_EXP 14
7986: PPUSH
7987: LD_STRING D4-JMM-1
7989: PPUSH
7990: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7994: LD_VAR 0 2
7998: PPUSH
7999: CALL_OW 250
8003: PPUSH
8004: LD_VAR 0 2
8008: PPUSH
8009: CALL_OW 251
8013: PPUSH
8014: LD_INT 7
8016: PPUSH
8017: CALL_OW 331
// DialogueOff ;
8021: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8025: LD_STRING M5
8027: PPUSH
8028: CALL_OW 337
// end ;
8032: PPOPN 3
8034: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8035: LD_EXP 6
8039: IFFALSE 8628
8041: GO 8043
8043: DISABLE
8044: LD_INT 0
8046: PPUSH
8047: PPUSH
8048: PPUSH
// begin PrepareBelkov ;
8049: CALL 1974 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8053: LD_EXP 46
8057: PPUSH
8058: LD_INT 118
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: CALL_OW 111
// AddComHold ( Belkov ) ;
8068: LD_EXP 46
8072: PPUSH
8073: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8077: LD_INT 35
8079: PPUSH
8080: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8084: LD_EXP 46
8088: PPUSH
8089: LD_INT 118
8091: PPUSH
8092: LD_INT 106
8094: PPUSH
8095: CALL_OW 307
8099: IFFALSE 8077
// ChangeSideFog ( 4 , 7 ) ;
8101: LD_INT 4
8103: PPUSH
8104: LD_INT 7
8106: PPUSH
8107: CALL_OW 343
// if IsOk ( Belkov ) then
8111: LD_EXP 46
8115: PPUSH
8116: CALL_OW 302
8120: IFFALSE 8204
// begin InGameOn ;
8122: CALL_OW 8
// DialogueOn ;
8126: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8130: LD_EXP 46
8134: PPUSH
8135: LD_STRING D5-Bel-1
8137: PPUSH
8138: CALL_OW 94
// if Gossudarov then
8142: LD_EXP 31
8146: IFFALSE 8196
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8148: LD_EXP 31
8152: PPUSH
8153: LD_STRING D5-Gos-1
8155: PPUSH
8156: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8160: LD_EXP 14
8164: PPUSH
8165: LD_STRING D5-JMM-1
8167: PPUSH
8168: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8172: LD_EXP 31
8176: PPUSH
8177: LD_STRING D5-Gos-2
8179: PPUSH
8180: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8184: LD_EXP 14
8188: PPUSH
8189: LD_STRING D5-JMM-2
8191: PPUSH
8192: CALL_OW 88
// end ; DialogueOff ;
8196: CALL_OW 7
// InGameOff ;
8200: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8204: LD_STRING QSaveBelkov
8206: PPUSH
8207: CALL_OW 97
8211: PUSH
8212: LD_INT 1
8214: DOUBLE
8215: EQUAL
8216: IFTRUE 8220
8218: GO 8270
8220: POP
// begin DialogueOn ;
8221: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8225: LD_EXP 14
8229: PPUSH
8230: LD_STRING D5a-JMM-1
8232: PPUSH
8233: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8237: LD_EXP 46
8241: PPUSH
8242: LD_STRING D5a-Bel-1
8244: PPUSH
8245: CALL_OW 94
// DialogueOff ;
8249: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8253: LD_EXP 46
8257: PPUSH
8258: LD_INT 83
8260: PPUSH
8261: LD_INT 49
8263: PPUSH
8264: CALL_OW 111
// end ; 2 :
8268: GO 8303
8270: LD_INT 2
8272: DOUBLE
8273: EQUAL
8274: IFTRUE 8278
8276: GO 8302
8278: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8279: LD_EXP 14
8283: PPUSH
8284: LD_STRING D5a-JMM-2
8286: PPUSH
8287: CALL_OW 88
// ComHold ( Belkov ) ;
8291: LD_EXP 46
8295: PPUSH
8296: CALL_OW 140
// end ; end ;
8300: GO 8303
8302: POP
// time := 0 0$00 ;
8303: LD_ADDR_VAR 0 1
8307: PUSH
8308: LD_INT 0
8310: ST_TO_ADDR
// vehSpawned := false ;
8311: LD_ADDR_VAR 0 3
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8319: LD_INT 35
8321: PPUSH
8322: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8326: LD_VAR 0 1
8330: PUSH
8331: LD_INT 350
8333: PUSH
8334: LD_INT 175
8336: PUSH
8337: LD_INT 70
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: LD_OWVAR 67
8349: ARRAY
8350: GREATEREQUAL
8351: PUSH
8352: LD_VAR 0 3
8356: NOT
8357: AND
8358: IFFALSE 8448
// begin vehSpawned := true ;
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 1
8367: ST_TO_ADDR
// uc_side := 3 ;
8368: LD_ADDR_OWVAR 20
8372: PUSH
8373: LD_INT 3
8375: ST_TO_ADDR
// uc_nation := 3 ;
8376: LD_ADDR_OWVAR 21
8380: PUSH
8381: LD_INT 3
8383: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8384: LD_INT 22
8386: PPUSH
8387: LD_INT 3
8389: PPUSH
8390: LD_INT 3
8392: PPUSH
8393: LD_INT 43
8395: PPUSH
8396: LD_INT 100
8398: PPUSH
8399: CALL 20543 0 5
// veh := CreateVehicle ;
8403: LD_ADDR_VAR 0 2
8407: PUSH
8408: CALL_OW 45
8412: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8413: LD_VAR 0 2
8417: PPUSH
8418: LD_INT 130
8420: PPUSH
8421: LD_INT 131
8423: PPUSH
8424: LD_INT 0
8426: PPUSH
8427: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_INT 100
8438: PPUSH
8439: LD_INT 82
8441: PPUSH
8442: CALL_OW 114
// end else
8446: GO 8462
// time := time + 0 0$1 ;
8448: LD_ADDR_VAR 0 1
8452: PUSH
8453: LD_VAR 0 1
8457: PUSH
8458: LD_INT 35
8460: PLUS
8461: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8462: LD_EXP 46
8466: PPUSH
8467: CALL_OW 301
8471: PUSH
8472: LD_EXP 46
8476: PPUSH
8477: CALL_OW 255
8481: PUSH
8482: LD_INT 4
8484: EQUAL
8485: AND
8486: PUSH
8487: LD_INT 22
8489: PUSH
8490: LD_INT 7
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PPUSH
8497: CALL_OW 69
8501: PPUSH
8502: LD_EXP 46
8506: PPUSH
8507: CALL_OW 74
8511: PPUSH
8512: LD_EXP 46
8516: PPUSH
8517: CALL_OW 296
8521: PUSH
8522: LD_INT 10
8524: LESS
8525: OR
8526: IFFALSE 8319
// if IsDead ( Belkov ) then
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 301
8537: IFFALSE 8562
// begin CenterNowOnUnits ( Belkov ) ;
8539: LD_EXP 46
8543: PPUSH
8544: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8548: LD_EXP 14
8552: PPUSH
8553: LD_STRING D5a-JMM-2a
8555: PPUSH
8556: CALL_OW 88
// exit ;
8560: GO 8628
// end ; if See ( 7 , Belkov ) then
8562: LD_INT 7
8564: PPUSH
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 292
8574: IFFALSE 8588
// SetSide ( Belkov , 7 ) ;
8576: LD_EXP 46
8580: PPUSH
8581: LD_INT 7
8583: PPUSH
8584: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8588: LD_INT 35
8590: PPUSH
8591: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8595: LD_EXP 46
8599: PPUSH
8600: LD_INT 66
8602: PPUSH
8603: LD_INT 45
8605: PPUSH
8606: CALL_OW 297
8610: PUSH
8611: LD_INT 30
8613: LESS
8614: IFFALSE 8588
// Say ( Belkov , D6-Bel-1 ) ;
8616: LD_EXP 46
8620: PPUSH
8621: LD_STRING D6-Bel-1
8623: PPUSH
8624: CALL_OW 88
// end ;
8628: PPOPN 3
8630: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8631: LD_EXP 46
8635: PPUSH
8636: CALL_OW 302
8640: PUSH
8641: LD_EXP 46
8645: PPUSH
8646: CALL_OW 504
8650: PUSH
8651: LD_INT 2
8653: PUSH
8654: LD_INT 34
8656: PUSH
8657: LD_INT 47
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: PUSH
8664: LD_INT 34
8666: PUSH
8667: LD_INT 45
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: LIST
8678: PPUSH
8679: CALL_OW 69
8683: IN
8684: AND
8685: IFFALSE 8702
8687: GO 8689
8689: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8690: LD_EXP 46
8694: PPUSH
8695: LD_STRING D7-Bel-1
8697: PPUSH
8698: CALL_OW 88
8702: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8703: LD_INT 22
8705: PUSH
8706: LD_INT 7
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: LD_INT 101
8715: PUSH
8716: LD_INT 2
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 69
8731: PUSH
8732: LD_EXP 8
8736: NOT
8737: AND
8738: PUSH
8739: LD_EXP 45
8743: PPUSH
8744: CALL_OW 305
8748: NOT
8749: AND
8750: IFFALSE 9220
8752: GO 8754
8754: DISABLE
8755: LD_INT 0
8757: PPUSH
// begin ar_base_spotted := true ;
8758: LD_ADDR_EXP 8
8762: PUSH
8763: LD_INT 1
8765: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8766: LD_ADDR_VAR 0 1
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_INT 2
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 21
8783: PUSH
8784: LD_INT 3
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8800: LD_ADDR_VAR 0 1
8804: PUSH
8805: LD_VAR 0 1
8809: PPUSH
8810: LD_EXP 14
8814: PPUSH
8815: CALL_OW 74
8819: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8820: LD_INT 7
8822: PPUSH
8823: LD_INT 3
8825: PPUSH
8826: CALL_OW 332
// DialogueOn ;
8830: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 1
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8858: LD_ADDR_VAR 0 1
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 7
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 23
8875: PUSH
8876: LD_INT 1
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: LD_INT 26
8885: PUSH
8886: LD_INT 1
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: PPUSH
8898: CALL_OW 69
8902: PUSH
8903: LD_EXP 14
8907: PUSH
8908: LD_EXP 18
8912: PUSH
8913: LD_EXP 19
8917: PUSH
8918: LD_EXP 26
8922: PUSH
8923: LD_EXP 15
8927: PUSH
8928: LD_EXP 24
8932: PUSH
8933: LD_EXP 20
8937: PUSH
8938: LD_EXP 22
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: DIFF
8953: ST_TO_ADDR
// if not tmp then
8954: LD_VAR 0 1
8958: NOT
8959: IFFALSE 9033
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8961: LD_ADDR_VAR 0 1
8965: PUSH
8966: LD_INT 22
8968: PUSH
8969: LD_INT 7
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 23
8978: PUSH
8979: LD_INT 1
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: LD_INT 26
8988: PUSH
8989: LD_INT 2
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL_OW 69
9005: PUSH
9006: LD_EXP 29
9010: PUSH
9011: LD_EXP 16
9015: PUSH
9016: LD_EXP 27
9020: PUSH
9021: LD_EXP 28
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: DIFF
9032: ST_TO_ADDR
// if tmp then
9033: LD_VAR 0 1
9037: IFFALSE 9108
// case GetSex ( tmp [ 1 ] ) of sex_male :
9039: LD_VAR 0 1
9043: PUSH
9044: LD_INT 1
9046: ARRAY
9047: PPUSH
9048: CALL_OW 258
9052: PUSH
9053: LD_INT 1
9055: DOUBLE
9056: EQUAL
9057: IFTRUE 9061
9059: GO 9080
9061: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9062: LD_VAR 0 1
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PPUSH
9071: LD_STRING D9-Sol1-1
9073: PPUSH
9074: CALL_OW 88
9078: GO 9108
9080: LD_INT 2
9082: DOUBLE
9083: EQUAL
9084: IFTRUE 9088
9086: GO 9107
9088: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9089: LD_VAR 0 1
9093: PUSH
9094: LD_INT 1
9096: ARRAY
9097: PPUSH
9098: LD_STRING D9-FSol1-1
9100: PPUSH
9101: CALL_OW 88
9105: GO 9108
9107: POP
// if Frank then
9108: LD_EXP 26
9112: IFFALSE 9216
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9114: LD_EXP 55
9118: PPUSH
9119: CALL_OW 250
9123: PPUSH
9124: LD_EXP 55
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: LD_INT 7
9136: PPUSH
9137: LD_INT 8
9139: PPUSH
9140: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9144: LD_EXP 55
9148: PPUSH
9149: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9153: LD_EXP 26
9157: PPUSH
9158: LD_STRING D9-Frank-1
9160: PPUSH
9161: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9165: LD_EXP 14
9169: PPUSH
9170: LD_STRING D9-JMM-1
9172: PPUSH
9173: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9177: LD_EXP 26
9181: PPUSH
9182: LD_STRING D9-Frank-2
9184: PPUSH
9185: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9189: LD_EXP 55
9193: PPUSH
9194: CALL_OW 250
9198: PPUSH
9199: LD_EXP 55
9203: PPUSH
9204: CALL_OW 251
9208: PPUSH
9209: LD_INT 7
9211: PPUSH
9212: CALL_OW 331
// end ; DialogueOff ;
9216: CALL_OW 7
// end ;
9220: PPOPN 1
9222: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9223: LD_EXP 7
9227: PUSH
9228: LD_OWVAR 1
9232: PUSH
9233: LD_INT 42000
9235: GREATEREQUAL
9236: OR
9237: IFFALSE 10264
9239: GO 9241
9241: DISABLE
9242: LD_INT 0
9244: PPUSH
9245: PPUSH
// begin selected_option := 1 ;
9246: LD_ADDR_VAR 0 2
9250: PUSH
9251: LD_INT 1
9253: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9254: LD_INT 10500
9256: PPUSH
9257: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9261: LD_INT 35
9263: PPUSH
9264: CALL_OW 67
// until not ru_attackers ;
9268: LD_EXP 51
9272: NOT
9273: IFFALSE 9261
// PrepareBurlak ;
9275: CALL 2086 0 0
// repeat wait ( 0 0$2 ) ;
9279: LD_INT 70
9281: PPUSH
9282: CALL_OW 67
// until not HasTask ( Burlak ) ;
9286: LD_EXP 45
9290: PPUSH
9291: CALL_OW 314
9295: NOT
9296: IFFALSE 9279
// InGameOn ;
9298: CALL_OW 8
// DialogueOn ;
9302: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9306: LD_EXP 48
9310: PPUSH
9311: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9315: LD_EXP 45
9319: PPUSH
9320: LD_STRING D10-Bur-1
9322: PPUSH
9323: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9327: LD_EXP 46
9331: PUSH
9332: LD_EXP 46
9336: PPUSH
9337: CALL_OW 255
9341: PUSH
9342: LD_INT 7
9344: EQUAL
9345: AND
9346: IFFALSE 9360
// Say ( Belkov , D10-Bel-1 ) ;
9348: LD_EXP 46
9352: PPUSH
9353: LD_STRING D10-Bel-1
9355: PPUSH
9356: CALL_OW 88
// if Gossudarov then
9360: LD_EXP 31
9364: IFFALSE 9378
// Say ( Gossudarov , D10-Gos-1 ) ;
9366: LD_EXP 31
9370: PPUSH
9371: LD_STRING D10-Gos-1
9373: PPUSH
9374: CALL_OW 88
// if Kirilenkova then
9378: LD_EXP 32
9382: IFFALSE 9396
// Say ( Kirilenkova , D10-Kir-1 ) ;
9384: LD_EXP 32
9388: PPUSH
9389: LD_STRING D10-Kir-1
9391: PPUSH
9392: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9396: CALL 12540 0 0
9400: PPUSH
9401: LD_STRING D10-RSol1-1
9403: PPUSH
9404: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9408: LD_EXP 45
9412: PPUSH
9413: LD_STRING D10-Bur-2
9415: PPUSH
9416: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9420: LD_EXP 14
9424: PPUSH
9425: LD_STRING D10-JMM-2
9427: PPUSH
9428: CALL_OW 88
// if Kirilenkova then
9432: LD_EXP 32
9436: IFFALSE 9452
// Say ( Kirilenkova , D10-Kir-2 ) else
9438: LD_EXP 32
9442: PPUSH
9443: LD_STRING D10-Kir-2
9445: PPUSH
9446: CALL_OW 88
9450: GO 9464
// Say ( SolRu , D10-RSol1-2 ) ;
9452: CALL 12540 0 0
9456: PPUSH
9457: LD_STRING D10-RSol1-2
9459: PPUSH
9460: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9464: LD_EXP 14
9468: PPUSH
9469: LD_STRING D10-JMM-3
9471: PPUSH
9472: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9476: LD_EXP 45
9480: PPUSH
9481: LD_STRING D10-Bur-3
9483: PPUSH
9484: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9488: LD_EXP 14
9492: PPUSH
9493: LD_STRING D10-JMM-4
9495: PPUSH
9496: CALL_OW 88
// DialogueOff ;
9500: CALL_OW 7
// InGameOff ;
9504: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9508: LD_STRING M2
9510: PPUSH
9511: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9515: LD_INT 35
9517: PPUSH
9518: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9522: LD_INT 22
9524: PUSH
9525: LD_INT 7
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 91
9534: PUSH
9535: LD_EXP 45
9539: PUSH
9540: LD_INT 8
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 69
9556: IFFALSE 9515
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9558: LD_ADDR_VAR 0 1
9562: PUSH
9563: LD_INT 22
9565: PUSH
9566: LD_INT 4
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PPUSH
9573: CALL_OW 69
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9595
// SetSide ( i , 7 ) ;
9581: LD_VAR 0 1
9585: PPUSH
9586: LD_INT 7
9588: PPUSH
9589: CALL_OW 235
9593: GO 9578
9595: POP
9596: POP
// ChangeMissionObjectives ( M3 ) ;
9597: LD_STRING M3
9599: PPUSH
9600: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9604: LD_INT 35
9606: PPUSH
9607: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9611: LD_EXP 14
9615: PPUSH
9616: LD_EXP 45
9620: PPUSH
9621: CALL_OW 296
9625: PUSH
9626: LD_INT 8
9628: LESS
9629: IFFALSE 9604
// ComTurnUnit ( JMM , Burlak ) ;
9631: LD_EXP 14
9635: PPUSH
9636: LD_EXP 45
9640: PPUSH
9641: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9645: LD_EXP 45
9649: PPUSH
9650: LD_EXP 14
9654: PPUSH
9655: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9659: LD_INT 10
9661: PPUSH
9662: CALL_OW 67
// DialogueOn ;
9666: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9670: LD_EXP 14
9674: PPUSH
9675: LD_STRING D11-JMM-1
9677: PPUSH
9678: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9682: LD_EXP 45
9686: PPUSH
9687: LD_STRING D11-Bur-1
9689: PPUSH
9690: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9694: LD_EXP 14
9698: PPUSH
9699: LD_STRING D11-JMM-2
9701: PPUSH
9702: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9706: LD_EXP 45
9710: PPUSH
9711: LD_STRING D11-Bur-2
9713: PPUSH
9714: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9718: LD_EXP 14
9722: PPUSH
9723: LD_STRING D11-JMM-3
9725: PPUSH
9726: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9730: LD_EXP 45
9734: PPUSH
9735: LD_STRING D11-Bur-3
9737: PPUSH
9738: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9742: LD_EXP 14
9746: PPUSH
9747: LD_STRING D11-JMM-4
9749: PPUSH
9750: CALL_OW 88
// if ar_base_spotted then
9754: LD_EXP 8
9758: IFFALSE 9774
// Say ( Burlak , D12-Bur-1 ) else
9760: LD_EXP 45
9764: PPUSH
9765: LD_STRING D12-Bur-1
9767: PPUSH
9768: CALL_OW 88
9772: GO 9813
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9774: LD_INT 7
9776: PPUSH
9777: LD_INT 3
9779: PPUSH
9780: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9784: LD_INT 127
9786: PPUSH
9787: LD_INT 45
9789: PPUSH
9790: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9794: LD_EXP 45
9798: PPUSH
9799: LD_STRING D12-Bur-1a
9801: PPUSH
9802: CALL_OW 88
// dwait ( 0 0$2 ) ;
9806: LD_INT 70
9808: PPUSH
9809: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9813: LD_EXP 45
9817: PPUSH
9818: LD_STRING D12-Bur-1b
9820: PPUSH
9821: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9825: LD_EXP 14
9829: PPUSH
9830: LD_STRING D12-JMM-1
9832: PPUSH
9833: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9837: LD_EXP 45
9841: PPUSH
9842: LD_STRING D12-Bur-2
9844: PPUSH
9845: CALL_OW 88
// if Roth then
9849: LD_EXP 15
9853: IFFALSE 9869
// Say ( Roth , D12-Roth-2 ) else
9855: LD_EXP 15
9859: PPUSH
9860: LD_STRING D12-Roth-2
9862: PPUSH
9863: CALL_OW 88
9867: GO 9881
// Say ( SciRu , D12-RSci1-2 ) ;
9869: CALL 12393 0 0
9873: PPUSH
9874: LD_STRING D12-RSci1-2
9876: PPUSH
9877: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9881: LD_EXP 14
9885: PPUSH
9886: LD_STRING D12-JMM-2
9888: PPUSH
9889: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9893: LD_EXP 45
9897: PPUSH
9898: LD_STRING D12-Bur-3
9900: PPUSH
9901: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9905: LD_EXP 14
9909: PPUSH
9910: LD_STRING D12-JMM-3
9912: PPUSH
9913: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9917: LD_EXP 45
9921: PPUSH
9922: LD_STRING D12-Bur-4
9924: PPUSH
9925: CALL_OW 88
// case Query ( QBase ) of 1 :
9929: LD_STRING QBase
9931: PPUSH
9932: CALL_OW 97
9936: PUSH
9937: LD_INT 1
9939: DOUBLE
9940: EQUAL
9941: IFTRUE 9945
9943: GO 10063
9945: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9946: LD_EXP 14
9950: PPUSH
9951: LD_STRING D13a-JMM-1
9953: PPUSH
9954: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9958: LD_EXP 45
9962: PPUSH
9963: LD_STRING D13a-Bur-1
9965: PPUSH
9966: CALL_OW 88
// if Roth then
9970: LD_EXP 15
9974: IFFALSE 9990
// Say ( Roth , D13a-Roth-1 ) else
9976: LD_EXP 15
9980: PPUSH
9981: LD_STRING D13a-Roth-1
9983: PPUSH
9984: CALL_OW 88
9988: GO 10002
// Say ( SciRu , D13a-RSci1-1 ) ;
9990: CALL 12393 0 0
9994: PPUSH
9995: LD_STRING D13a-RSci1-1
9997: PPUSH
9998: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10002: LD_EXP 14
10006: PPUSH
10007: LD_STRING D13a-JMM-2
10009: PPUSH
10010: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10014: LD_STRING QBaseAgain
10016: PPUSH
10017: CALL_OW 97
10021: PUSH
10022: LD_INT 1
10024: DOUBLE
10025: EQUAL
10026: IFTRUE 10030
10028: GO 10041
10030: POP
// selected_option := 2 ; 2 :
10031: LD_ADDR_VAR 0 2
10035: PUSH
10036: LD_INT 2
10038: ST_TO_ADDR
10039: GO 10061
10041: LD_INT 2
10043: DOUBLE
10044: EQUAL
10045: IFTRUE 10049
10047: GO 10060
10049: POP
// selected_option := 3 ; end ;
10050: LD_ADDR_VAR 0 2
10054: PUSH
10055: LD_INT 3
10057: ST_TO_ADDR
10058: GO 10061
10060: POP
// end ; 2 :
10061: GO 10102
10063: LD_INT 2
10065: DOUBLE
10066: EQUAL
10067: IFTRUE 10071
10069: GO 10082
10071: POP
// selected_option := 2 ; 3 :
10072: LD_ADDR_VAR 0 2
10076: PUSH
10077: LD_INT 2
10079: ST_TO_ADDR
10080: GO 10102
10082: LD_INT 3
10084: DOUBLE
10085: EQUAL
10086: IFTRUE 10090
10088: GO 10101
10090: POP
// selected_option := 3 ; end ;
10091: LD_ADDR_VAR 0 2
10095: PUSH
10096: LD_INT 3
10098: ST_TO_ADDR
10099: GO 10102
10101: POP
// if selected_option = 2 then
10102: LD_VAR 0 2
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10204
// begin Say ( JMM , D13b-JMM-1 ) ;
10112: LD_EXP 14
10116: PPUSH
10117: LD_STRING D13b-JMM-1
10119: PPUSH
10120: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10124: LD_EXP 45
10128: PPUSH
10129: LD_STRING D13b-Bur-1
10131: PPUSH
10132: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10136: LD_EXP 14
10140: PPUSH
10141: LD_STRING D13b-JMM-2
10143: PPUSH
10144: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10148: LD_EXP 54
10152: PPUSH
10153: LD_STRING D13b-Abd-2
10155: PPUSH
10156: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10160: LD_EXP 14
10164: PPUSH
10165: LD_STRING D13b-JMM-3
10167: PPUSH
10168: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10172: LD_EXP 54
10176: PPUSH
10177: LD_STRING D13b-Abd-3
10179: PPUSH
10180: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10184: LD_EXP 14
10188: PPUSH
10189: LD_STRING D13b-JMM-4
10191: PPUSH
10192: CALL_OW 88
// ar_active_attack := true ;
10196: LD_ADDR_EXP 9
10200: PUSH
10201: LD_INT 1
10203: ST_TO_ADDR
// end ; if selected_option = 3 then
10204: LD_VAR 0 2
10208: PUSH
10209: LD_INT 3
10211: EQUAL
10212: IFFALSE 10238
// begin Say ( JMM , D13c-JMM-1 ) ;
10214: LD_EXP 14
10218: PPUSH
10219: LD_STRING D13c-JMM-1
10221: PPUSH
10222: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10226: LD_EXP 45
10230: PPUSH
10231: LD_STRING D13c-Bur-1
10233: PPUSH
10234: CALL_OW 88
// end ; DialogueOff ;
10238: CALL_OW 7
// if not ar_active_attack then
10242: LD_EXP 9
10246: NOT
10247: IFFALSE 10264
// begin wait ( 6 6$00 ) ;
10249: LD_INT 12600
10251: PPUSH
10252: CALL_OW 67
// ar_active_attack := true ;
10256: LD_ADDR_EXP 9
10260: PUSH
10261: LD_INT 1
10263: ST_TO_ADDR
// end ; end ;
10264: PPOPN 2
10266: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10267: LD_EXP 45
10271: PPUSH
10272: CALL_OW 305
10276: PUSH
10277: LD_EXP 45
10281: PPUSH
10282: CALL_OW 255
10286: PUSH
10287: LD_INT 7
10289: EQUAL
10290: AND
10291: IFFALSE 10487
10293: GO 10295
10295: DISABLE
10296: LD_INT 0
10298: PPUSH
// begin wait ( 4 4$40 ) ;
10299: LD_INT 9800
10301: PPUSH
10302: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until not ru_attackers ;
10313: LD_EXP 51
10317: NOT
10318: IFFALSE 10306
// PrepareGnyevko ;
10320: CALL 2030 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10324: LD_EXP 47
10328: PPUSH
10329: LD_INT 124
10331: PPUSH
10332: LD_INT 118
10334: PPUSH
10335: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10339: LD_EXP 47
10343: PPUSH
10344: CALL_OW 200
// time := 0 0$00 ;
10348: LD_ADDR_VAR 0 1
10352: PUSH
10353: LD_INT 0
10355: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10356: LD_INT 35
10358: PPUSH
10359: CALL_OW 67
// time := time + 0 0$1 ;
10363: LD_ADDR_VAR 0 1
10367: PUSH
10368: LD_VAR 0 1
10372: PUSH
10373: LD_INT 35
10375: PLUS
10376: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10377: LD_EXP 47
10381: PPUSH
10382: LD_INT 124
10384: PPUSH
10385: LD_INT 118
10387: PPUSH
10388: CALL_OW 307
10392: PUSH
10393: LD_VAR 0 1
10397: PUSH
10398: LD_INT 1050
10400: GREATEREQUAL
10401: OR
10402: IFFALSE 10356
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING DBelkov-Gny-1
10411: PPUSH
10412: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10416: LD_EXP 45
10420: PPUSH
10421: LD_STRING DBelkov-Bur-1a
10423: PPUSH
10424: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10428: LD_INT 35
10430: PPUSH
10431: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10435: LD_EXP 47
10439: PPUSH
10440: LD_INT 22
10442: PUSH
10443: LD_INT 7
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PPUSH
10450: CALL_OW 69
10454: PPUSH
10455: LD_EXP 47
10459: PPUSH
10460: CALL_OW 74
10464: PPUSH
10465: CALL_OW 296
10469: PUSH
10470: LD_INT 8
10472: LESS
10473: IFFALSE 10428
// SetSide ( Gnyevko , 7 ) ;
10475: LD_EXP 47
10479: PPUSH
10480: LD_INT 7
10482: PPUSH
10483: CALL_OW 235
// end ;
10487: PPOPN 1
10489: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10490: LD_EXP 45
10494: PPUSH
10495: CALL_OW 255
10499: PUSH
10500: LD_INT 7
10502: EQUAL
10503: IFFALSE 10513
10505: GO 10507
10507: DISABLE
// begin enable ;
10508: ENABLE
// PrepareAmericanAttack ;
10509: CALL 6336 0 0
// end ;
10513: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10514: LD_INT 22
10516: PUSH
10517: LD_INT 1
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PPUSH
10524: CALL_OW 69
10528: IFFALSE 10712
10530: GO 10532
10532: DISABLE
10533: LD_INT 0
10535: PPUSH
10536: PPUSH
// begin while true do
10537: LD_INT 1
10539: IFFALSE 10596
// begin wait ( 0 0$1 ) ;
10541: LD_INT 35
10543: PPUSH
10544: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10548: LD_ADDR_VAR 0 2
10552: PUSH
10553: LD_INT 22
10555: PUSH
10556: LD_INT 1
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: PPUSH
10563: CALL_OW 69
10567: PPUSH
10568: LD_EXP 14
10572: PPUSH
10573: CALL_OW 74
10577: ST_TO_ADDR
// if See ( 7 , tmp ) then
10578: LD_INT 7
10580: PPUSH
10581: LD_VAR 0 2
10585: PPUSH
10586: CALL_OW 292
10590: IFFALSE 10594
// break ;
10592: GO 10596
// end ;
10594: GO 10537
// DialogueOn ;
10596: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10609: LD_VAR 0 2
10613: PPUSH
10614: CALL_OW 250
10618: PPUSH
10619: LD_VAR 0 2
10623: PPUSH
10624: CALL_OW 251
10628: PPUSH
10629: LD_INT 7
10631: PPUSH
10632: LD_INT 8
10634: PPUSH
10635: CALL_OW 330
// if Denis then
10639: LD_EXP 20
10643: IFFALSE 10657
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10645: LD_EXP 20
10649: PPUSH
10650: LD_STRING DAmerAttack-Pet-1
10652: PPUSH
10653: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10657: LD_EXP 14
10661: PPUSH
10662: LD_STRING DAmerAttack-JMM-1
10664: PPUSH
10665: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10669: LD_EXP 45
10673: PPUSH
10674: LD_STRING DStop-Bur-1
10676: PPUSH
10677: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10681: LD_VAR 0 2
10685: PPUSH
10686: CALL_OW 250
10690: PPUSH
10691: LD_VAR 0 2
10695: PPUSH
10696: CALL_OW 251
10700: PPUSH
10701: LD_INT 7
10703: PPUSH
10704: CALL_OW 331
// DialogueOff ;
10708: CALL_OW 7
// end ;
10712: PPOPN 2
10714: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10715: LD_INT 22
10717: PUSH
10718: LD_INT 3
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: LD_INT 21
10727: PUSH
10728: LD_INT 1
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: PPUSH
10739: CALL_OW 69
10743: PUSH
10744: LD_INT 0
10746: EQUAL
10747: IFFALSE 10789
10749: GO 10751
10751: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10752: LD_STRING M5a
10754: PPUSH
10755: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10759: LD_EXP 14
10763: PPUSH
10764: LD_STRING D8-JMM-1
10766: PPUSH
10767: CALL_OW 88
// if Gossudarov then
10771: LD_EXP 31
10775: IFFALSE 10789
// Say ( Gossudarov , D8-Gos-1 ) ;
10777: LD_EXP 31
10781: PPUSH
10782: LD_STRING D8-Gos-1
10784: PPUSH
10785: CALL_OW 88
// end ;
10789: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10790: LD_INT 22
10792: PUSH
10793: LD_INT 2
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 21
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: PUSH
10819: LD_INT 0
10821: EQUAL
10822: IFFALSE 10872
10824: GO 10826
10826: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10827: LD_STRING M4c
10829: PPUSH
10830: CALL_OW 337
// if Roth then
10834: LD_EXP 15
10838: IFFALSE 10854
// Say ( Roth , DStop-Roth-1 ) else
10840: LD_EXP 15
10844: PPUSH
10845: LD_STRING DStop-Roth-1
10847: PPUSH
10848: CALL_OW 88
10852: GO 10872
// if Gossudarov then
10854: LD_EXP 31
10858: IFFALSE 10872
// Say ( Gossudarov , D8-Gos-1a ) ;
10860: LD_EXP 31
10864: PPUSH
10865: LD_STRING D8-Gos-1a
10867: PPUSH
10868: CALL_OW 88
// end ;
10872: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10873: LD_INT 7
10875: PPUSH
10876: LD_INT 1
10878: PPUSH
10879: LD_INT 1
10881: PPUSH
10882: CALL 13973 0 3
10886: PUSH
10887: LD_INT 0
10889: EQUAL
10890: PUSH
10891: LD_INT 7
10893: PPUSH
10894: LD_INT 3
10896: PPUSH
10897: LD_INT 1
10899: PPUSH
10900: CALL 13973 0 3
10904: PUSH
10905: LD_INT 0
10907: EQUAL
10908: AND
10909: IFFALSE 10921
10911: GO 10913
10913: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10914: LD_STRING M1a
10916: PPUSH
10917: CALL_OW 337
// end ;
10921: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10922: LD_INT 22
10924: PUSH
10925: LD_INT 2
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 1
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: LD_INT 0
10953: EQUAL
10954: PUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: PUSH
10984: LD_INT 0
10986: EQUAL
10987: AND
10988: PUSH
10989: LD_INT 22
10991: PUSH
10992: LD_INT 1
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: LD_INT 0
11006: EQUAL
11007: AND
11008: PUSH
11009: LD_INT 7
11011: PPUSH
11012: LD_INT 1
11014: PPUSH
11015: LD_INT 1
11017: PPUSH
11018: CALL 13973 0 3
11022: PUSH
11023: LD_INT 0
11025: EQUAL
11026: AND
11027: PUSH
11028: LD_INT 7
11030: PPUSH
11031: LD_INT 3
11033: PPUSH
11034: LD_INT 1
11036: PPUSH
11037: CALL 13973 0 3
11041: PUSH
11042: LD_INT 0
11044: EQUAL
11045: AND
11046: IFFALSE 12390
11048: GO 11050
11050: DISABLE
11051: LD_INT 0
11053: PPUSH
11054: PPUSH
11055: PPUSH
// begin wait ( 0 0$3 ) ;
11056: LD_INT 105
11058: PPUSH
11059: CALL_OW 67
// if not IsDead ( Masha ) then
11063: LD_EXP 48
11067: PPUSH
11068: CALL_OW 301
11072: NOT
11073: IFFALSE 11087
// AddMedal ( Masha , 1 ) else
11075: LD_STRING Masha
11077: PPUSH
11078: LD_INT 1
11080: PPUSH
11081: CALL_OW 101
11085: GO 11098
// AddMedal ( Masha , - 1 ) ;
11087: LD_STRING Masha
11089: PPUSH
11090: LD_INT 1
11092: NEG
11093: PPUSH
11094: CALL_OW 101
// if abdul_escaped then
11098: LD_EXP 12
11102: IFFALSE 11117
// AddMedal ( Abdul , - 1 ) else
11104: LD_STRING Abdul
11106: PPUSH
11107: LD_INT 1
11109: NEG
11110: PPUSH
11111: CALL_OW 101
11115: GO 11127
// AddMedal ( Abdul , 1 ) ;
11117: LD_STRING Abdul
11119: PPUSH
11120: LD_INT 1
11122: PPUSH
11123: CALL_OW 101
// if loss_counter = 0 then
11127: LD_EXP 13
11131: PUSH
11132: LD_INT 0
11134: EQUAL
11135: IFFALSE 11149
// AddMedal ( People , 2 ) else
11137: LD_STRING People
11139: PPUSH
11140: LD_INT 2
11142: PPUSH
11143: CALL_OW 101
11147: GO 11199
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11149: LD_EXP 13
11153: PUSH
11154: LD_INT 3
11156: PUSH
11157: LD_INT 2
11159: PUSH
11160: LD_INT 2
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: PUSH
11168: LD_OWVAR 67
11172: ARRAY
11173: LESSEQUAL
11174: IFFALSE 11188
// AddMedal ( People , 1 ) else
11176: LD_STRING People
11178: PPUSH
11179: LD_INT 1
11181: PPUSH
11182: CALL_OW 101
11186: GO 11199
// AddMedal ( People , - 1 ) ;
11188: LD_STRING People
11190: PPUSH
11191: LD_INT 1
11193: NEG
11194: PPUSH
11195: CALL_OW 101
// GiveMedals ( MAIN ) ;
11199: LD_STRING MAIN
11201: PPUSH
11202: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_INT 22
11213: PUSH
11214: LD_INT 7
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: LD_INT 2
11223: PUSH
11224: LD_INT 25
11226: PUSH
11227: LD_INT 1
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 25
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 25
11246: PUSH
11247: LD_INT 3
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: PUSH
11254: LD_INT 25
11256: PUSH
11257: LD_INT 4
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 25
11266: PUSH
11267: LD_INT 5
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 25
11276: PUSH
11277: LD_INT 8
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PUSH
11284: LD_INT 25
11286: PUSH
11287: LD_INT 9
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PUSH
11304: EMPTY
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11313: LD_VAR 0 2
11317: PPUSH
11318: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11322: LD_ADDR_VAR 0 3
11326: PUSH
11327: LD_EXP 14
11331: PUSH
11332: LD_EXP 15
11336: PUSH
11337: LD_EXP 16
11341: PUSH
11342: LD_EXP 17
11346: PUSH
11347: LD_EXP 18
11351: PUSH
11352: LD_EXP 19
11356: PUSH
11357: LD_EXP 20
11361: PUSH
11362: LD_EXP 21
11366: PUSH
11367: LD_EXP 22
11371: PUSH
11372: LD_EXP 23
11376: PUSH
11377: LD_EXP 24
11381: PUSH
11382: LD_EXP 25
11386: PUSH
11387: LD_EXP 26
11391: PUSH
11392: LD_EXP 27
11396: PUSH
11397: LD_EXP 28
11401: PUSH
11402: LD_EXP 29
11406: PUSH
11407: LD_EXP 30
11411: PUSH
11412: LD_EXP 31
11416: PUSH
11417: LD_EXP 32
11421: PUSH
11422: LD_EXP 33
11426: PUSH
11427: LD_EXP 35
11431: PUSH
11432: LD_EXP 36
11436: PUSH
11437: LD_EXP 37
11441: PUSH
11442: LD_EXP 38
11446: PUSH
11447: LD_EXP 39
11451: PUSH
11452: LD_EXP 40
11456: PUSH
11457: LD_EXP 41
11461: PUSH
11462: LD_EXP 42
11466: PUSH
11467: LD_EXP 43
11471: PUSH
11472: LD_EXP 44
11476: PUSH
11477: LD_EXP 45
11481: PUSH
11482: LD_EXP 46
11486: PUSH
11487: LD_EXP 47
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: ST_TO_ADDR
// if tmp diff tmp2 then
11527: LD_VAR 0 2
11531: PUSH
11532: LD_VAR 0 3
11536: DIFF
11537: IFFALSE 11557
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11539: LD_VAR 0 2
11543: PUSH
11544: LD_VAR 0 3
11548: DIFF
11549: PPUSH
11550: LD_STRING 13a_others
11552: PPUSH
11553: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11557: LD_EXP 14
11561: PPUSH
11562: LD_STRING 13a_JMM
11564: PPUSH
11565: CALL_OW 38
// if Titov then
11569: LD_EXP 33
11573: IFFALSE 11587
// SaveCharacters ( Titov , 13a_Titov ) ;
11575: LD_EXP 33
11579: PPUSH
11580: LD_STRING 13a_Titov
11582: PPUSH
11583: CALL_OW 38
// if Dolgov then
11587: LD_EXP 35
11591: IFFALSE 11605
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11593: LD_EXP 35
11597: PPUSH
11598: LD_STRING 13a_Dolgov
11600: PPUSH
11601: CALL_OW 38
// if Petrosyan then
11605: LD_EXP 36
11609: IFFALSE 11623
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11611: LD_EXP 36
11615: PPUSH
11616: LD_STRING 13a_Petrosyan
11618: PPUSH
11619: CALL_OW 38
// if Scholtze then
11623: LD_EXP 37
11627: IFFALSE 11641
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11629: LD_EXP 37
11633: PPUSH
11634: LD_STRING 13a_Scholtze
11636: PPUSH
11637: CALL_OW 38
// if Oblukov then
11641: LD_EXP 38
11645: IFFALSE 11659
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11647: LD_EXP 38
11651: PPUSH
11652: LD_STRING 13a_Oblukov
11654: PPUSH
11655: CALL_OW 38
// if Kapitsova then
11659: LD_EXP 39
11663: IFFALSE 11677
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11665: LD_EXP 39
11669: PPUSH
11670: LD_STRING 13a_Kapitsova
11672: PPUSH
11673: CALL_OW 38
// if Lipshchin then
11677: LD_EXP 40
11681: IFFALSE 11695
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11683: LD_EXP 40
11687: PPUSH
11688: LD_STRING 13a_Lipshchin
11690: PPUSH
11691: CALL_OW 38
// if Petrovova then
11695: LD_EXP 41
11699: IFFALSE 11713
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11701: LD_EXP 41
11705: PPUSH
11706: LD_STRING 13a_Petrovova
11708: PPUSH
11709: CALL_OW 38
// if Kovalyuk then
11713: LD_EXP 42
11717: IFFALSE 11731
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11719: LD_EXP 42
11723: PPUSH
11724: LD_STRING 13a_Kovalyuk
11726: PPUSH
11727: CALL_OW 38
// if Kuzmov then
11731: LD_EXP 43
11735: IFFALSE 11749
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11737: LD_EXP 43
11741: PPUSH
11742: LD_STRING 13a_Kuzmov
11744: PPUSH
11745: CALL_OW 38
// if Karamazov then
11749: LD_EXP 44
11753: IFFALSE 11767
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11755: LD_EXP 44
11759: PPUSH
11760: LD_STRING 13a_Karamazov
11762: PPUSH
11763: CALL_OW 38
// if Burlak then
11767: LD_EXP 45
11771: IFFALSE 11785
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11773: LD_EXP 45
11777: PPUSH
11778: LD_STRING 13a_Burlak
11780: PPUSH
11781: CALL_OW 38
// if Belkov then
11785: LD_EXP 46
11789: IFFALSE 11803
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11791: LD_EXP 46
11795: PPUSH
11796: LD_STRING 13a_Belkov
11798: PPUSH
11799: CALL_OW 38
// if Gnyevko then
11803: LD_EXP 47
11807: IFFALSE 11821
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11809: LD_EXP 47
11813: PPUSH
11814: LD_STRING 13a_Gnyevko
11816: PPUSH
11817: CALL_OW 38
// if Lisa then
11821: LD_EXP 16
11825: IFFALSE 11839
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11827: LD_EXP 16
11831: PPUSH
11832: LD_STRING 13a_Lisa
11834: PPUSH
11835: CALL_OW 38
// if Donaldson then
11839: LD_EXP 17
11843: IFFALSE 11857
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11845: LD_EXP 17
11849: PPUSH
11850: LD_STRING 13a_Donaldson
11852: PPUSH
11853: CALL_OW 38
// if Bobby then
11857: LD_EXP 18
11861: IFFALSE 11875
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11863: LD_EXP 18
11867: PPUSH
11868: LD_STRING 13a_Bobby
11870: PPUSH
11871: CALL_OW 38
// if Cyrus then
11875: LD_EXP 19
11879: IFFALSE 11893
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11881: LD_EXP 19
11885: PPUSH
11886: LD_STRING 13a_Cyrus
11888: PPUSH
11889: CALL_OW 38
// if Denis then
11893: LD_EXP 20
11897: IFFALSE 11911
// SaveCharacters ( Denis , 13a_Denis ) ;
11899: LD_EXP 20
11903: PPUSH
11904: LD_STRING 13a_Denis
11906: PPUSH
11907: CALL_OW 38
// if Brown then
11911: LD_EXP 21
11915: IFFALSE 11929
// SaveCharacters ( Brown , 13a_Brown ) ;
11917: LD_EXP 21
11921: PPUSH
11922: LD_STRING 13a_Brown
11924: PPUSH
11925: CALL_OW 38
// if Gladstone then
11929: LD_EXP 22
11933: IFFALSE 11947
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11935: LD_EXP 22
11939: PPUSH
11940: LD_STRING 13a_Gladstone
11942: PPUSH
11943: CALL_OW 38
// if Houten then
11947: LD_EXP 23
11951: IFFALSE 11965
// SaveCharacters ( Houten , 13a_Houten ) ;
11953: LD_EXP 23
11957: PPUSH
11958: LD_STRING 13a_Houten
11960: PPUSH
11961: CALL_OW 38
// if Cornel then
11965: LD_EXP 24
11969: IFFALSE 11983
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11971: LD_EXP 24
11975: PPUSH
11976: LD_STRING 13a_Cornel
11978: PPUSH
11979: CALL_OW 38
// if Gary then
11983: LD_EXP 25
11987: IFFALSE 12001
// SaveCharacters ( Gary , 13a_Gary ) ;
11989: LD_EXP 25
11993: PPUSH
11994: LD_STRING 13a_Gary
11996: PPUSH
11997: CALL_OW 38
// if Frank then
12001: LD_EXP 26
12005: IFFALSE 12019
// SaveCharacters ( Frank , 13a_Frank ) ;
12007: LD_EXP 26
12011: PPUSH
12012: LD_STRING 13a_Frank
12014: PPUSH
12015: CALL_OW 38
// if Kikuchi then
12019: LD_EXP 27
12023: IFFALSE 12037
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12025: LD_EXP 27
12029: PPUSH
12030: LD_STRING 13a_Kikuchi
12032: PPUSH
12033: CALL_OW 38
// if Simms then
12037: LD_EXP 28
12041: IFFALSE 12055
// SaveCharacters ( Simms , 13a_Simms ) ;
12043: LD_EXP 28
12047: PPUSH
12048: LD_STRING 13a_Simms
12050: PPUSH
12051: CALL_OW 38
// if Joan then
12055: LD_EXP 29
12059: IFFALSE 12073
// SaveCharacters ( Joan , 13a_Joan ) ;
12061: LD_EXP 29
12065: PPUSH
12066: LD_STRING 13a_Joan
12068: PPUSH
12069: CALL_OW 38
// if DeltaDoctor then
12073: LD_EXP 30
12077: IFFALSE 12091
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12079: LD_EXP 30
12083: PPUSH
12084: LD_STRING 13a_DeltaDoctor
12086: PPUSH
12087: CALL_OW 38
// if Gossudarov then
12091: LD_EXP 31
12095: IFFALSE 12109
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12097: LD_EXP 31
12101: PPUSH
12102: LD_STRING 13a_Gossudarov
12104: PPUSH
12105: CALL_OW 38
// if Kirilenkova then
12109: LD_EXP 32
12113: IFFALSE 12127
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12115: LD_EXP 32
12119: PPUSH
12120: LD_STRING 13a_Kirilenkova
12122: PPUSH
12123: CALL_OW 38
// if Masha then
12127: LD_EXP 48
12131: IFFALSE 12186
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12133: LD_EXP 48
12137: PPUSH
12138: CALL_OW 265
12142: PUSH
12143: LD_EXP 48
12147: PPUSH
12148: CALL_OW 262
12152: PUSH
12153: LD_EXP 48
12157: PPUSH
12158: CALL_OW 263
12162: PUSH
12163: LD_EXP 48
12167: PPUSH
12168: CALL_OW 264
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: PPUSH
12179: LD_STRING 13a_Masha
12181: PPUSH
12182: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12186: LD_ADDR_VAR 0 2
12190: PUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 69
12205: ST_TO_ADDR
// tmp2 := [ ] ;
12206: LD_ADDR_VAR 0 3
12210: PUSH
12211: EMPTY
12212: ST_TO_ADDR
// if tmp then
12213: LD_VAR 0 2
12217: IFFALSE 12368
// for i in tmp do
12219: LD_ADDR_VAR 0 1
12223: PUSH
12224: LD_VAR 0 2
12228: PUSH
12229: FOR_IN
12230: IFFALSE 12366
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12232: LD_ADDR_VAR 0 3
12236: PUSH
12237: LD_VAR 0 3
12241: PUSH
12242: LD_VAR 0 1
12246: PPUSH
12247: CALL_OW 255
12251: PUSH
12252: LD_VAR 0 1
12256: PPUSH
12257: CALL_OW 248
12261: PUSH
12262: LD_VAR 0 1
12266: PPUSH
12267: CALL_OW 266
12271: PUSH
12272: LD_VAR 0 1
12276: PPUSH
12277: CALL_OW 250
12281: PUSH
12282: LD_VAR 0 1
12286: PPUSH
12287: CALL_OW 251
12291: PUSH
12292: LD_VAR 0 1
12296: PPUSH
12297: CALL_OW 254
12301: PUSH
12302: LD_VAR 0 1
12306: PPUSH
12307: CALL_OW 267
12311: PUSH
12312: LD_VAR 0 1
12316: PPUSH
12317: LD_INT 1
12319: PPUSH
12320: CALL_OW 268
12324: PUSH
12325: LD_VAR 0 1
12329: PPUSH
12330: LD_INT 2
12332: PPUSH
12333: CALL_OW 268
12337: PUSH
12338: LD_VAR 0 1
12342: PPUSH
12343: CALL_OW 269
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: ADD
12363: ST_TO_ADDR
12364: GO 12229
12366: POP
12367: POP
// if tmp2 then
12368: LD_VAR 0 3
12372: IFFALSE 12386
// SaveVariable ( tmp2 , 13a_buildings ) ;
12374: LD_VAR 0 3
12378: PPUSH
12379: LD_STRING 13a_buildings
12381: PPUSH
12382: CALL_OW 39
// YouWin ;
12386: CALL_OW 103
// end ;
12390: PPOPN 3
12392: END
// export function SciRu ; var tmp , t ; begin
12393: LD_INT 0
12395: PPUSH
12396: PPUSH
12397: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_EXP 31
12407: PUSH
12408: LD_EXP 45
12412: PUSH
12413: LD_EXP 33
12417: PUSH
12418: LD_EXP 46
12422: PUSH
12423: LD_EXP 47
12427: PUSH
12428: LD_EXP 36
12432: PUSH
12433: LD_EXP 37
12437: PUSH
12438: LD_EXP 35
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12453: LD_ADDR_VAR 0 2
12457: PUSH
12458: LD_INT 22
12460: PUSH
12461: LD_INT 7
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PUSH
12468: LD_INT 23
12470: PUSH
12471: LD_INT 3
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 25
12480: PUSH
12481: LD_INT 4
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 26
12490: PUSH
12491: LD_INT 1
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: PPUSH
12504: CALL_OW 69
12508: PUSH
12509: LD_VAR 0 3
12513: DIFF
12514: ST_TO_ADDR
// if tmp then
12515: LD_VAR 0 2
12519: IFFALSE 12535
// result := tmp [ 1 ] ;
12521: LD_ADDR_VAR 0 1
12525: PUSH
12526: LD_VAR 0 2
12530: PUSH
12531: LD_INT 1
12533: ARRAY
12534: ST_TO_ADDR
// end ;
12535: LD_VAR 0 1
12539: RET
// export function SolRu ; var tmp , t ; begin
12540: LD_INT 0
12542: PPUSH
12543: PPUSH
12544: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12545: LD_ADDR_VAR 0 3
12549: PUSH
12550: LD_EXP 31
12554: PUSH
12555: LD_EXP 45
12559: PUSH
12560: LD_EXP 33
12564: PUSH
12565: LD_EXP 46
12569: PUSH
12570: LD_EXP 47
12574: PUSH
12575: LD_EXP 36
12579: PUSH
12580: LD_EXP 37
12584: PUSH
12585: LD_EXP 35
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12600: LD_ADDR_VAR 0 2
12604: PUSH
12605: LD_INT 22
12607: PUSH
12608: LD_INT 7
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 23
12617: PUSH
12618: LD_INT 3
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 25
12627: PUSH
12628: LD_INT 1
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: LD_INT 26
12637: PUSH
12638: LD_INT 1
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PPUSH
12651: CALL_OW 69
12655: PUSH
12656: LD_VAR 0 3
12660: DIFF
12661: ST_TO_ADDR
// if tmp then
12662: LD_VAR 0 2
12666: IFFALSE 12682
// result := tmp [ 1 ] ;
12668: LD_ADDR_VAR 0 1
12672: PUSH
12673: LD_VAR 0 2
12677: PUSH
12678: LD_INT 1
12680: ARRAY
12681: ST_TO_ADDR
// end ; end_of_file
12682: LD_VAR 0 1
12686: RET
// export function CustomEvent ( event ) ; begin
12687: LD_INT 0
12689: PPUSH
// end ;
12690: LD_VAR 0 2
12694: RET
// on UnitDestroyed ( un ) do var i , side ;
12695: LD_INT 0
12697: PPUSH
12698: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12699: LD_VAR 0 1
12703: PUSH
12704: LD_INT 22
12706: PUSH
12707: LD_INT 7
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PUSH
12714: LD_INT 2
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 1
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 2
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 25
12739: PUSH
12740: LD_INT 3
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 25
12749: PUSH
12750: LD_INT 4
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: LD_INT 25
12759: PUSH
12760: LD_INT 5
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PUSH
12767: LD_INT 25
12769: PUSH
12770: LD_INT 8
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 25
12779: PUSH
12780: LD_INT 9
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: IN
12806: IFFALSE 12822
// loss_counter := loss_counter + 1 ;
12808: LD_ADDR_EXP 13
12812: PUSH
12813: LD_EXP 13
12817: PUSH
12818: LD_INT 1
12820: PLUS
12821: ST_TO_ADDR
// if un = Abdul then
12822: LD_VAR 0 1
12826: PUSH
12827: LD_EXP 54
12831: EQUAL
12832: IFFALSE 12842
// abdul_escaped := false ;
12834: LD_ADDR_EXP 12
12838: PUSH
12839: LD_INT 0
12841: ST_TO_ADDR
// if un in ru_attackers then
12842: LD_VAR 0 1
12846: PUSH
12847: LD_EXP 51
12851: IN
12852: IFFALSE 12870
// ru_attackers := ru_attackers diff un ;
12854: LD_ADDR_EXP 51
12858: PUSH
12859: LD_EXP 51
12863: PUSH
12864: LD_VAR 0 1
12868: DIFF
12869: ST_TO_ADDR
// if un in ar_attackers then
12870: LD_VAR 0 1
12874: PUSH
12875: LD_EXP 10
12879: IN
12880: IFFALSE 12898
// ar_attackers := ar_attackers diff un ;
12882: LD_ADDR_EXP 10
12886: PUSH
12887: LD_EXP 10
12891: PUSH
12892: LD_VAR 0 1
12896: DIFF
12897: ST_TO_ADDR
// if un = JMM then
12898: LD_VAR 0 1
12902: PUSH
12903: LD_EXP 14
12907: EQUAL
12908: IFFALSE 12919
// begin YouLost ( JMM ) ;
12910: LD_STRING JMM
12912: PPUSH
12913: CALL_OW 104
// exit ;
12917: GO 13008
// end ; if un = Burlak then
12919: LD_VAR 0 1
12923: PUSH
12924: LD_EXP 45
12928: EQUAL
12929: IFFALSE 12940
// begin YouLost ( Burlak ) ;
12931: LD_STRING Burlak
12933: PPUSH
12934: CALL_OW 104
// exit ;
12938: GO 13008
// end ; if un = freedom then
12940: LD_VAR 0 1
12944: PUSH
12945: LD_EXP 3
12949: EQUAL
12950: IFFALSE 12961
// begin YouLost ( Destroyed ) ;
12952: LD_STRING Destroyed
12954: PPUSH
12955: CALL_OW 104
// exit ;
12959: GO 13008
// end ; if un = Masha then
12961: LD_VAR 0 1
12965: PUSH
12966: LD_EXP 48
12970: EQUAL
12971: IFFALSE 12980
// ChangeMissionObjectives ( M4b ) ;
12973: LD_STRING M4b
12975: PPUSH
12976: CALL_OW 337
// if un = Mastodont then
12980: LD_VAR 0 1
12984: PUSH
12985: LD_EXP 55
12989: EQUAL
12990: IFFALSE 12999
// ChangeMissionObjectives ( M4a ) ;
12992: LD_STRING M4a
12994: PPUSH
12995: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12999: LD_VAR 0 1
13003: PPUSH
13004: CALL 83095 0 1
// end ;
13008: PPOPN 3
13010: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13011: LD_VAR 0 1
13015: PPUSH
13016: LD_VAR 0 2
13020: PPUSH
13021: CALL 85074 0 2
// end ;
13025: PPOPN 2
13027: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13028: LD_VAR 0 1
13032: PPUSH
13033: CALL 84142 0 1
// end ;
13037: PPOPN 1
13039: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13040: LD_VAR 0 1
13044: PUSH
13045: LD_INT 22
13047: PUSH
13048: LD_INT 7
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: LD_INT 30
13057: PUSH
13058: LD_INT 0
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PPUSH
13069: CALL_OW 69
13073: IN
13074: IFFALSE 13113
// begin SetBName ( building , freedom ) ;
13076: LD_VAR 0 1
13080: PPUSH
13081: LD_STRING freedom
13083: PPUSH
13084: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13088: LD_INT 0
13090: PPUSH
13091: LD_INT 7
13093: PPUSH
13094: LD_INT 0
13096: PPUSH
13097: CALL_OW 324
// freedom := building ;
13101: LD_ADDR_EXP 3
13105: PUSH
13106: LD_VAR 0 1
13110: ST_TO_ADDR
// exit ;
13111: GO 13179
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13113: LD_VAR 0 1
13117: PUSH
13118: LD_INT 22
13120: PUSH
13121: LD_INT 7
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 23
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 30
13140: PUSH
13141: LD_INT 6
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: PPUSH
13153: CALL_OW 69
13157: IN
13158: IFFALSE 13170
// begin ru_lab_builded := true ;
13160: LD_ADDR_EXP 5
13164: PUSH
13165: LD_INT 1
13167: ST_TO_ADDR
// exit ;
13168: GO 13179
// end ; MCE_BuildingComplete ( building ) ;
13170: LD_VAR 0 1
13174: PPUSH
13175: CALL 84383 0 1
// end ;
13179: PPOPN 1
13181: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13182: LD_VAR 0 1
13186: PPUSH
13187: LD_VAR 0 2
13191: PPUSH
13192: CALL 82791 0 2
// end ;
13196: PPOPN 2
13198: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13199: LD_VAR 0 1
13203: PPUSH
13204: LD_VAR 0 2
13208: PPUSH
13209: LD_VAR 0 3
13213: PPUSH
13214: LD_VAR 0 4
13218: PPUSH
13219: LD_VAR 0 5
13223: PPUSH
13224: CALL 82411 0 5
// end ;
13228: PPOPN 5
13230: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13231: LD_VAR 0 1
13235: PPUSH
13236: LD_VAR 0 2
13240: PPUSH
13241: CALL 82001 0 2
// end ;
13245: PPOPN 2
13247: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13248: LD_VAR 0 1
13252: PPUSH
13253: LD_VAR 0 2
13257: PPUSH
13258: LD_VAR 0 3
13262: PPUSH
13263: LD_VAR 0 4
13267: PPUSH
13268: CALL 81839 0 4
// end ;
13272: PPOPN 4
13274: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_VAR 0 2
13284: PPUSH
13285: LD_VAR 0 3
13289: PPUSH
13290: CALL 81614 0 3
// end ;
13294: PPOPN 3
13296: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13297: LD_VAR 0 1
13301: PPUSH
13302: LD_VAR 0 2
13306: PPUSH
13307: CALL 81499 0 2
// end ;
13311: PPOPN 2
13313: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13314: LD_VAR 0 1
13318: PPUSH
13319: LD_VAR 0 2
13323: PPUSH
13324: CALL 85335 0 2
// end ;
13328: PPOPN 2
13330: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_VAR 0 2
13340: PPUSH
13341: LD_VAR 0 3
13345: PPUSH
13346: LD_VAR 0 4
13350: PPUSH
13351: CALL 85551 0 4
// end ;
13355: PPOPN 4
13357: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13358: LD_VAR 0 1
13362: PPUSH
13363: LD_VAR 0 2
13367: PPUSH
13368: CALL 81308 0 2
// end ; end_of_file
13372: PPOPN 2
13374: END
// every 0 0$30 do var cr , time ;
13375: GO 13377
13377: DISABLE
13378: LD_INT 0
13380: PPUSH
13381: PPUSH
// begin time := 0 0$30 ;
13382: LD_ADDR_VAR 0 2
13386: PUSH
13387: LD_INT 1050
13389: ST_TO_ADDR
// while game do
13390: LD_EXP 2
13394: IFFALSE 13493
// begin wait ( time ) ;
13396: LD_VAR 0 2
13400: PPUSH
13401: CALL_OW 67
// if tick > 2 2$00 then
13405: LD_OWVAR 1
13409: PUSH
13410: LD_INT 4200
13412: GREATER
13413: IFFALSE 13446
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13415: LD_ADDR_VAR 0 2
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_INT 280
13427: PUSH
13428: LD_INT 420
13430: PUSH
13431: LD_INT 630
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: LIST
13438: PUSH
13439: LD_OWVAR 67
13443: ARRAY
13444: PLUS
13445: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13446: LD_INT 1
13448: PPUSH
13449: LD_INT 5
13451: PPUSH
13452: CALL_OW 12
13456: PPUSH
13457: LD_INT 70
13459: PPUSH
13460: LD_INT 49
13462: PPUSH
13463: LD_INT 25
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 56
// if time > 5 5$00 then
13473: LD_VAR 0 2
13477: PUSH
13478: LD_INT 10500
13480: GREATER
13481: IFFALSE 13491
// time := 0 0$30 ;
13483: LD_ADDR_VAR 0 2
13487: PUSH
13488: LD_INT 1050
13490: ST_TO_ADDR
// end ;
13491: GO 13390
// end ;
13493: PPOPN 2
13495: END
// every 0 0$30 do var cr , time ;
13496: GO 13498
13498: DISABLE
13499: LD_INT 0
13501: PPUSH
13502: PPUSH
// begin time := 0 0$20 ;
13503: LD_ADDR_VAR 0 2
13507: PUSH
13508: LD_INT 700
13510: ST_TO_ADDR
// while game do
13511: LD_EXP 2
13515: IFFALSE 13604
// begin wait ( time ) ;
13517: LD_VAR 0 2
13521: PPUSH
13522: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13526: LD_ADDR_VAR 0 2
13530: PUSH
13531: LD_VAR 0 2
13535: PUSH
13536: LD_INT 490
13538: PUSH
13539: LD_INT 525
13541: PUSH
13542: LD_INT 560
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: LIST
13549: PUSH
13550: LD_OWVAR 67
13554: ARRAY
13555: PLUS
13556: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13557: LD_INT 3
13559: PPUSH
13560: LD_INT 5
13562: PPUSH
13563: CALL_OW 12
13567: PPUSH
13568: LD_INT 26
13570: PPUSH
13571: LD_INT 9
13573: PPUSH
13574: LD_INT 30
13576: PPUSH
13577: LD_INT 1
13579: PPUSH
13580: CALL_OW 56
// if time > 3 3$00 then
13584: LD_VAR 0 2
13588: PUSH
13589: LD_INT 6300
13591: GREATER
13592: IFFALSE 13602
// time := 0 0$20 ;
13594: LD_ADDR_VAR 0 2
13598: PUSH
13599: LD_INT 700
13601: ST_TO_ADDR
// end ;
13602: GO 13511
// end ;
13604: PPOPN 2
13606: END
// every 0 0$30 do var cr , time ;
13607: GO 13609
13609: DISABLE
13610: LD_INT 0
13612: PPUSH
13613: PPUSH
// begin time := 0 0$20 ;
13614: LD_ADDR_VAR 0 2
13618: PUSH
13619: LD_INT 700
13621: ST_TO_ADDR
// while game do
13622: LD_EXP 2
13626: IFFALSE 13751
// begin wait ( time ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13637: LD_ADDR_VAR 0 2
13641: PUSH
13642: LD_VAR 0 2
13646: PUSH
13647: LD_INT 175
13649: PUSH
13650: LD_INT 210
13652: PUSH
13653: LD_INT 280
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: LD_OWVAR 67
13665: ARRAY
13666: PLUS
13667: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13668: LD_INT 1
13670: PPUSH
13671: LD_INT 5
13673: PPUSH
13674: CALL_OW 12
13678: PPUSH
13679: LD_INT 179
13681: PPUSH
13682: LD_INT 101
13684: PPUSH
13685: LD_INT 20
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13695: LD_INT 350
13697: PPUSH
13698: LD_INT 525
13700: PPUSH
13701: CALL_OW 12
13705: PPUSH
13706: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 5
13715: PPUSH
13716: CALL_OW 12
13720: PPUSH
13721: LD_INT 9
13723: PPUSH
13724: LD_INT 1
13726: PPUSH
13727: CALL_OW 55
// if time > 4 4$00 then
13731: LD_VAR 0 2
13735: PUSH
13736: LD_INT 8400
13738: GREATER
13739: IFFALSE 13749
// time := 0 0$30 ;
13741: LD_ADDR_VAR 0 2
13745: PUSH
13746: LD_INT 1050
13748: ST_TO_ADDR
// end ;
13749: GO 13622
// end ;
13751: PPOPN 2
13753: END
// every 0 0$30 do var cr , time ;
13754: GO 13756
13756: DISABLE
13757: LD_INT 0
13759: PPUSH
13760: PPUSH
// begin time := 0 0$10 ;
13761: LD_ADDR_VAR 0 2
13765: PUSH
13766: LD_INT 350
13768: ST_TO_ADDR
// while game do
13769: LD_EXP 2
13773: IFFALSE 13907
// begin wait ( time ) ;
13775: LD_VAR 0 2
13779: PPUSH
13780: CALL_OW 67
// time := time + 0 0$10 ;
13784: LD_ADDR_VAR 0 2
13788: PUSH
13789: LD_VAR 0 2
13793: PUSH
13794: LD_INT 350
13796: PLUS
13797: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13798: LD_INT 1
13800: PPUSH
13801: LD_INT 5
13803: PPUSH
13804: CALL_OW 12
13808: PPUSH
13809: LD_INT 11
13811: PPUSH
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13819: LD_ADDR_VAR 0 1
13823: PUSH
13824: LD_INT 1
13826: PPUSH
13827: LD_INT 3
13829: PPUSH
13830: CALL_OW 12
13834: ST_TO_ADDR
// if cr = 1 then
13835: LD_VAR 0 1
13839: PUSH
13840: LD_INT 1
13842: EQUAL
13843: IFFALSE 13887
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13845: LD_INT 700
13847: PPUSH
13848: LD_INT 1575
13850: PPUSH
13851: CALL_OW 12
13855: PPUSH
13856: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13860: LD_INT 1
13862: PPUSH
13863: LD_INT 5
13865: PPUSH
13866: CALL_OW 12
13870: PPUSH
13871: LD_INT 34
13873: PPUSH
13874: LD_INT 50
13876: PPUSH
13877: LD_INT 7
13879: PPUSH
13880: LD_INT 1
13882: PPUSH
13883: CALL_OW 56
// end ; if time > 8 8$00 then
13887: LD_VAR 0 2
13891: PUSH
13892: LD_INT 16800
13894: GREATER
13895: IFFALSE 13905
// time := 0 0$40 ;
13897: LD_ADDR_VAR 0 2
13901: PUSH
13902: LD_INT 1400
13904: ST_TO_ADDR
// end ;
13905: GO 13769
// end ; end_of_file
13907: PPOPN 2
13909: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13910: LD_INT 0
13912: PPUSH
13913: PPUSH
// if exist_mode then
13914: LD_VAR 0 2
13918: IFFALSE 13943
// unit := CreateCharacter ( prefix & ident ) else
13920: LD_ADDR_VAR 0 5
13924: PUSH
13925: LD_VAR 0 3
13929: PUSH
13930: LD_VAR 0 1
13934: STR
13935: PPUSH
13936: CALL_OW 34
13940: ST_TO_ADDR
13941: GO 13958
// unit := NewCharacter ( ident ) ;
13943: LD_ADDR_VAR 0 5
13947: PUSH
13948: LD_VAR 0 1
13952: PPUSH
13953: CALL_OW 25
13957: ST_TO_ADDR
// result := unit ;
13958: LD_ADDR_VAR 0 4
13962: PUSH
13963: LD_VAR 0 5
13967: ST_TO_ADDR
// end ;
13968: LD_VAR 0 4
13972: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13973: LD_INT 0
13975: PPUSH
13976: PPUSH
// if not side or not nation then
13977: LD_VAR 0 1
13981: NOT
13982: PUSH
13983: LD_VAR 0 2
13987: NOT
13988: OR
13989: IFFALSE 13993
// exit ;
13991: GO 14629
// case nation of nation_american :
13993: LD_VAR 0 2
13997: PUSH
13998: LD_INT 1
14000: DOUBLE
14001: EQUAL
14002: IFTRUE 14006
14004: GO 14176
14006: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14007: LD_ADDR_VAR 0 4
14011: PUSH
14012: LD_INT 35
14014: PUSH
14015: LD_INT 45
14017: PUSH
14018: LD_INT 46
14020: PUSH
14021: LD_INT 47
14023: PUSH
14024: LD_INT 1
14026: PUSH
14027: LD_INT 2
14029: PUSH
14030: LD_INT 6
14032: PUSH
14033: LD_INT 15
14035: PUSH
14036: LD_INT 16
14038: PUSH
14039: LD_INT 7
14041: PUSH
14042: LD_INT 12
14044: PUSH
14045: LD_INT 13
14047: PUSH
14048: LD_INT 10
14050: PUSH
14051: LD_INT 14
14053: PUSH
14054: LD_INT 20
14056: PUSH
14057: LD_INT 21
14059: PUSH
14060: LD_INT 22
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 32
14068: PUSH
14069: LD_INT 27
14071: PUSH
14072: LD_INT 36
14074: PUSH
14075: LD_INT 69
14077: PUSH
14078: LD_INT 39
14080: PUSH
14081: LD_INT 34
14083: PUSH
14084: LD_INT 40
14086: PUSH
14087: LD_INT 48
14089: PUSH
14090: LD_INT 49
14092: PUSH
14093: LD_INT 50
14095: PUSH
14096: LD_INT 51
14098: PUSH
14099: LD_INT 52
14101: PUSH
14102: LD_INT 53
14104: PUSH
14105: LD_INT 54
14107: PUSH
14108: LD_INT 55
14110: PUSH
14111: LD_INT 56
14113: PUSH
14114: LD_INT 57
14116: PUSH
14117: LD_INT 58
14119: PUSH
14120: LD_INT 59
14122: PUSH
14123: LD_INT 60
14125: PUSH
14126: LD_INT 61
14128: PUSH
14129: LD_INT 62
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: ST_TO_ADDR
14174: GO 14553
14176: LD_INT 2
14178: DOUBLE
14179: EQUAL
14180: IFTRUE 14184
14182: GO 14362
14184: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14185: LD_ADDR_VAR 0 4
14189: PUSH
14190: LD_INT 35
14192: PUSH
14193: LD_INT 45
14195: PUSH
14196: LD_INT 46
14198: PUSH
14199: LD_INT 47
14201: PUSH
14202: LD_INT 70
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: LD_INT 11
14210: PUSH
14211: LD_INT 3
14213: PUSH
14214: LD_INT 4
14216: PUSH
14217: LD_INT 5
14219: PUSH
14220: LD_INT 6
14222: PUSH
14223: LD_INT 15
14225: PUSH
14226: LD_INT 18
14228: PUSH
14229: LD_INT 7
14231: PUSH
14232: LD_INT 17
14234: PUSH
14235: LD_INT 8
14237: PUSH
14238: LD_INT 20
14240: PUSH
14241: LD_INT 21
14243: PUSH
14244: LD_INT 22
14246: PUSH
14247: LD_INT 72
14249: PUSH
14250: LD_INT 26
14252: PUSH
14253: LD_INT 69
14255: PUSH
14256: LD_INT 39
14258: PUSH
14259: LD_INT 40
14261: PUSH
14262: LD_INT 41
14264: PUSH
14265: LD_INT 42
14267: PUSH
14268: LD_INT 43
14270: PUSH
14271: LD_INT 48
14273: PUSH
14274: LD_INT 49
14276: PUSH
14277: LD_INT 50
14279: PUSH
14280: LD_INT 51
14282: PUSH
14283: LD_INT 52
14285: PUSH
14286: LD_INT 53
14288: PUSH
14289: LD_INT 54
14291: PUSH
14292: LD_INT 55
14294: PUSH
14295: LD_INT 56
14297: PUSH
14298: LD_INT 60
14300: PUSH
14301: LD_INT 61
14303: PUSH
14304: LD_INT 62
14306: PUSH
14307: LD_INT 66
14309: PUSH
14310: LD_INT 67
14312: PUSH
14313: LD_INT 68
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: ST_TO_ADDR
14360: GO 14553
14362: LD_INT 3
14364: DOUBLE
14365: EQUAL
14366: IFTRUE 14370
14368: GO 14552
14370: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14371: LD_ADDR_VAR 0 4
14375: PUSH
14376: LD_INT 46
14378: PUSH
14379: LD_INT 47
14381: PUSH
14382: LD_INT 1
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: LD_INT 11
14390: PUSH
14391: LD_INT 9
14393: PUSH
14394: LD_INT 20
14396: PUSH
14397: LD_INT 19
14399: PUSH
14400: LD_INT 21
14402: PUSH
14403: LD_INT 24
14405: PUSH
14406: LD_INT 22
14408: PUSH
14409: LD_INT 25
14411: PUSH
14412: LD_INT 28
14414: PUSH
14415: LD_INT 29
14417: PUSH
14418: LD_INT 30
14420: PUSH
14421: LD_INT 31
14423: PUSH
14424: LD_INT 37
14426: PUSH
14427: LD_INT 38
14429: PUSH
14430: LD_INT 32
14432: PUSH
14433: LD_INT 27
14435: PUSH
14436: LD_INT 33
14438: PUSH
14439: LD_INT 69
14441: PUSH
14442: LD_INT 39
14444: PUSH
14445: LD_INT 34
14447: PUSH
14448: LD_INT 40
14450: PUSH
14451: LD_INT 71
14453: PUSH
14454: LD_INT 23
14456: PUSH
14457: LD_INT 44
14459: PUSH
14460: LD_INT 48
14462: PUSH
14463: LD_INT 49
14465: PUSH
14466: LD_INT 50
14468: PUSH
14469: LD_INT 51
14471: PUSH
14472: LD_INT 52
14474: PUSH
14475: LD_INT 53
14477: PUSH
14478: LD_INT 54
14480: PUSH
14481: LD_INT 55
14483: PUSH
14484: LD_INT 56
14486: PUSH
14487: LD_INT 57
14489: PUSH
14490: LD_INT 58
14492: PUSH
14493: LD_INT 59
14495: PUSH
14496: LD_INT 63
14498: PUSH
14499: LD_INT 64
14501: PUSH
14502: LD_INT 65
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: ST_TO_ADDR
14550: GO 14553
14552: POP
// if state > - 1 and state < 3 then
14553: LD_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: NEG
14561: GREATER
14562: PUSH
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 3
14570: LESS
14571: AND
14572: IFFALSE 14629
// for i in result do
14574: LD_ADDR_VAR 0 5
14578: PUSH
14579: LD_VAR 0 4
14583: PUSH
14584: FOR_IN
14585: IFFALSE 14627
// if GetTech ( i , side ) <> state then
14587: LD_VAR 0 5
14591: PPUSH
14592: LD_VAR 0 1
14596: PPUSH
14597: CALL_OW 321
14601: PUSH
14602: LD_VAR 0 3
14606: NONEQUAL
14607: IFFALSE 14625
// result := result diff i ;
14609: LD_ADDR_VAR 0 4
14613: PUSH
14614: LD_VAR 0 4
14618: PUSH
14619: LD_VAR 0 5
14623: DIFF
14624: ST_TO_ADDR
14625: GO 14584
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 4
14633: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14634: LD_INT 0
14636: PPUSH
14637: PPUSH
14638: PPUSH
// result := true ;
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 1
14646: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14647: LD_ADDR_VAR 0 5
14651: PUSH
14652: LD_VAR 0 2
14656: PPUSH
14657: CALL_OW 480
14661: ST_TO_ADDR
// if not tmp then
14662: LD_VAR 0 5
14666: NOT
14667: IFFALSE 14671
// exit ;
14669: GO 14720
// for i in tmp do
14671: LD_ADDR_VAR 0 4
14675: PUSH
14676: LD_VAR 0 5
14680: PUSH
14681: FOR_IN
14682: IFFALSE 14718
// if GetTech ( i , side ) <> state_researched then
14684: LD_VAR 0 4
14688: PPUSH
14689: LD_VAR 0 1
14693: PPUSH
14694: CALL_OW 321
14698: PUSH
14699: LD_INT 2
14701: NONEQUAL
14702: IFFALSE 14716
// begin result := false ;
14704: LD_ADDR_VAR 0 3
14708: PUSH
14709: LD_INT 0
14711: ST_TO_ADDR
// exit ;
14712: POP
14713: POP
14714: GO 14720
// end ;
14716: GO 14681
14718: POP
14719: POP
// end ;
14720: LD_VAR 0 3
14724: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14725: LD_INT 0
14727: PPUSH
14728: PPUSH
14729: PPUSH
14730: PPUSH
14731: PPUSH
14732: PPUSH
14733: PPUSH
14734: PPUSH
14735: PPUSH
14736: PPUSH
14737: PPUSH
14738: PPUSH
14739: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14740: LD_VAR 0 1
14744: NOT
14745: PUSH
14746: LD_VAR 0 1
14750: PPUSH
14751: CALL_OW 257
14755: PUSH
14756: LD_INT 9
14758: NONEQUAL
14759: OR
14760: IFFALSE 14764
// exit ;
14762: GO 15337
// side := GetSide ( unit ) ;
14764: LD_ADDR_VAR 0 9
14768: PUSH
14769: LD_VAR 0 1
14773: PPUSH
14774: CALL_OW 255
14778: ST_TO_ADDR
// tech_space := tech_spacanom ;
14779: LD_ADDR_VAR 0 12
14783: PUSH
14784: LD_INT 29
14786: ST_TO_ADDR
// tech_time := tech_taurad ;
14787: LD_ADDR_VAR 0 13
14791: PUSH
14792: LD_INT 28
14794: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14795: LD_ADDR_VAR 0 11
14799: PUSH
14800: LD_VAR 0 1
14804: PPUSH
14805: CALL_OW 310
14809: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14810: LD_VAR 0 11
14814: PPUSH
14815: CALL_OW 247
14819: PUSH
14820: LD_INT 2
14822: EQUAL
14823: IFFALSE 14827
// exit ;
14825: GO 15337
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14827: LD_ADDR_VAR 0 8
14831: PUSH
14832: LD_INT 81
14834: PUSH
14835: LD_VAR 0 9
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 3
14846: PUSH
14847: LD_INT 21
14849: PUSH
14850: LD_INT 3
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PPUSH
14865: CALL_OW 69
14869: ST_TO_ADDR
// if not tmp then
14870: LD_VAR 0 8
14874: NOT
14875: IFFALSE 14879
// exit ;
14877: GO 15337
// if in_unit then
14879: LD_VAR 0 11
14883: IFFALSE 14907
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14885: LD_ADDR_VAR 0 10
14889: PUSH
14890: LD_VAR 0 8
14894: PPUSH
14895: LD_VAR 0 11
14899: PPUSH
14900: CALL_OW 74
14904: ST_TO_ADDR
14905: GO 14927
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14907: LD_ADDR_VAR 0 10
14911: PUSH
14912: LD_VAR 0 8
14916: PPUSH
14917: LD_VAR 0 1
14921: PPUSH
14922: CALL_OW 74
14926: ST_TO_ADDR
// if not enemy then
14927: LD_VAR 0 10
14931: NOT
14932: IFFALSE 14936
// exit ;
14934: GO 15337
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14936: LD_VAR 0 11
14940: PUSH
14941: LD_VAR 0 11
14945: PPUSH
14946: LD_VAR 0 10
14950: PPUSH
14951: CALL_OW 296
14955: PUSH
14956: LD_INT 13
14958: GREATER
14959: AND
14960: PUSH
14961: LD_VAR 0 1
14965: PPUSH
14966: LD_VAR 0 10
14970: PPUSH
14971: CALL_OW 296
14975: PUSH
14976: LD_INT 12
14978: GREATER
14979: OR
14980: IFFALSE 14984
// exit ;
14982: GO 15337
// missile := [ 1 ] ;
14984: LD_ADDR_VAR 0 14
14988: PUSH
14989: LD_INT 1
14991: PUSH
14992: EMPTY
14993: LIST
14994: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14995: LD_VAR 0 9
14999: PPUSH
15000: LD_VAR 0 12
15004: PPUSH
15005: CALL_OW 325
15009: IFFALSE 15038
// missile := Insert ( missile , missile + 1 , 2 ) ;
15011: LD_ADDR_VAR 0 14
15015: PUSH
15016: LD_VAR 0 14
15020: PPUSH
15021: LD_VAR 0 14
15025: PUSH
15026: LD_INT 1
15028: PLUS
15029: PPUSH
15030: LD_INT 2
15032: PPUSH
15033: CALL_OW 2
15037: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15038: LD_VAR 0 9
15042: PPUSH
15043: LD_VAR 0 13
15047: PPUSH
15048: CALL_OW 325
15052: PUSH
15053: LD_VAR 0 10
15057: PPUSH
15058: CALL_OW 255
15062: PPUSH
15063: LD_VAR 0 13
15067: PPUSH
15068: CALL_OW 325
15072: NOT
15073: AND
15074: IFFALSE 15103
// missile := Insert ( missile , missile + 1 , 3 ) ;
15076: LD_ADDR_VAR 0 14
15080: PUSH
15081: LD_VAR 0 14
15085: PPUSH
15086: LD_VAR 0 14
15090: PUSH
15091: LD_INT 1
15093: PLUS
15094: PPUSH
15095: LD_INT 3
15097: PPUSH
15098: CALL_OW 2
15102: ST_TO_ADDR
// if missile < 2 then
15103: LD_VAR 0 14
15107: PUSH
15108: LD_INT 2
15110: LESS
15111: IFFALSE 15115
// exit ;
15113: GO 15337
// x := GetX ( enemy ) ;
15115: LD_ADDR_VAR 0 4
15119: PUSH
15120: LD_VAR 0 10
15124: PPUSH
15125: CALL_OW 250
15129: ST_TO_ADDR
// y := GetY ( enemy ) ;
15130: LD_ADDR_VAR 0 5
15134: PUSH
15135: LD_VAR 0 10
15139: PPUSH
15140: CALL_OW 251
15144: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15145: LD_ADDR_VAR 0 6
15149: PUSH
15150: LD_VAR 0 4
15154: PUSH
15155: LD_INT 1
15157: NEG
15158: PPUSH
15159: LD_INT 1
15161: PPUSH
15162: CALL_OW 12
15166: PLUS
15167: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15168: LD_ADDR_VAR 0 7
15172: PUSH
15173: LD_VAR 0 5
15177: PUSH
15178: LD_INT 1
15180: NEG
15181: PPUSH
15182: LD_INT 1
15184: PPUSH
15185: CALL_OW 12
15189: PLUS
15190: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15191: LD_VAR 0 6
15195: PPUSH
15196: LD_VAR 0 7
15200: PPUSH
15201: CALL_OW 488
15205: NOT
15206: IFFALSE 15228
// begin _x := x ;
15208: LD_ADDR_VAR 0 6
15212: PUSH
15213: LD_VAR 0 4
15217: ST_TO_ADDR
// _y := y ;
15218: LD_ADDR_VAR 0 7
15222: PUSH
15223: LD_VAR 0 5
15227: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15228: LD_ADDR_VAR 0 3
15232: PUSH
15233: LD_INT 1
15235: PPUSH
15236: LD_VAR 0 14
15240: PPUSH
15241: CALL_OW 12
15245: ST_TO_ADDR
// case i of 1 :
15246: LD_VAR 0 3
15250: PUSH
15251: LD_INT 1
15253: DOUBLE
15254: EQUAL
15255: IFTRUE 15259
15257: GO 15276
15259: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15260: LD_VAR 0 1
15264: PPUSH
15265: LD_VAR 0 10
15269: PPUSH
15270: CALL_OW 115
15274: GO 15337
15276: LD_INT 2
15278: DOUBLE
15279: EQUAL
15280: IFTRUE 15284
15282: GO 15306
15284: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15285: LD_VAR 0 1
15289: PPUSH
15290: LD_VAR 0 6
15294: PPUSH
15295: LD_VAR 0 7
15299: PPUSH
15300: CALL_OW 153
15304: GO 15337
15306: LD_INT 3
15308: DOUBLE
15309: EQUAL
15310: IFTRUE 15314
15312: GO 15336
15314: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_VAR 0 6
15324: PPUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: CALL_OW 154
15334: GO 15337
15336: POP
// end ;
15337: LD_VAR 0 2
15341: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15342: LD_INT 0
15344: PPUSH
15345: PPUSH
15346: PPUSH
15347: PPUSH
15348: PPUSH
15349: PPUSH
// if not unit or not building then
15350: LD_VAR 0 1
15354: NOT
15355: PUSH
15356: LD_VAR 0 2
15360: NOT
15361: OR
15362: IFFALSE 15366
// exit ;
15364: GO 15524
// x := GetX ( building ) ;
15366: LD_ADDR_VAR 0 5
15370: PUSH
15371: LD_VAR 0 2
15375: PPUSH
15376: CALL_OW 250
15380: ST_TO_ADDR
// y := GetY ( building ) ;
15381: LD_ADDR_VAR 0 6
15385: PUSH
15386: LD_VAR 0 2
15390: PPUSH
15391: CALL_OW 251
15395: ST_TO_ADDR
// for i = 0 to 5 do
15396: LD_ADDR_VAR 0 4
15400: PUSH
15401: DOUBLE
15402: LD_INT 0
15404: DEC
15405: ST_TO_ADDR
15406: LD_INT 5
15408: PUSH
15409: FOR_TO
15410: IFFALSE 15522
// begin _x := ShiftX ( x , i , 3 ) ;
15412: LD_ADDR_VAR 0 7
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_VAR 0 4
15426: PPUSH
15427: LD_INT 3
15429: PPUSH
15430: CALL_OW 272
15434: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15435: LD_ADDR_VAR 0 8
15439: PUSH
15440: LD_VAR 0 6
15444: PPUSH
15445: LD_VAR 0 4
15449: PPUSH
15450: LD_INT 3
15452: PPUSH
15453: CALL_OW 273
15457: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15458: LD_VAR 0 7
15462: PPUSH
15463: LD_VAR 0 8
15467: PPUSH
15468: CALL_OW 488
15472: NOT
15473: IFFALSE 15477
// continue ;
15475: GO 15409
// if HexInfo ( _x , _y ) = 0 then
15477: LD_VAR 0 7
15481: PPUSH
15482: LD_VAR 0 8
15486: PPUSH
15487: CALL_OW 428
15491: PUSH
15492: LD_INT 0
15494: EQUAL
15495: IFFALSE 15520
// begin ComMoveXY ( unit , _x , _y ) ;
15497: LD_VAR 0 1
15501: PPUSH
15502: LD_VAR 0 7
15506: PPUSH
15507: LD_VAR 0 8
15511: PPUSH
15512: CALL_OW 111
// exit ;
15516: POP
15517: POP
15518: GO 15524
// end ; end ;
15520: GO 15409
15522: POP
15523: POP
// end ;
15524: LD_VAR 0 3
15528: RET
// export function ScanBase ( side , base_area ) ; begin
15529: LD_INT 0
15531: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15532: LD_ADDR_VAR 0 3
15536: PUSH
15537: LD_VAR 0 2
15541: PPUSH
15542: LD_INT 81
15544: PUSH
15545: LD_VAR 0 1
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 70
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 3
15563: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
15568: PPUSH
15569: PPUSH
15570: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15571: LD_VAR 0 1
15575: NOT
15576: PUSH
15577: LD_EXP 58
15581: PUSH
15582: LD_VAR 0 1
15586: ARRAY
15587: NOT
15588: OR
15589: PUSH
15590: LD_VAR 0 2
15594: NOT
15595: OR
15596: PUSH
15597: LD_VAR 0 3
15601: NOT
15602: OR
15603: IFFALSE 15607
// exit ;
15605: GO 16057
// side := mc_sides [ base ] ;
15607: LD_ADDR_VAR 0 6
15611: PUSH
15612: LD_EXP 84
15616: PUSH
15617: LD_VAR 0 1
15621: ARRAY
15622: ST_TO_ADDR
// if not side then
15623: LD_VAR 0 6
15627: NOT
15628: IFFALSE 15632
// exit ;
15630: GO 16057
// for i in solds do
15632: LD_ADDR_VAR 0 7
15636: PUSH
15637: LD_VAR 0 2
15641: PUSH
15642: FOR_IN
15643: IFFALSE 15704
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15645: LD_VAR 0 7
15649: PPUSH
15650: CALL_OW 310
15654: PPUSH
15655: CALL_OW 266
15659: PUSH
15660: LD_INT 32
15662: PUSH
15663: LD_INT 31
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: IN
15670: IFFALSE 15690
// solds := solds diff i else
15672: LD_ADDR_VAR 0 2
15676: PUSH
15677: LD_VAR 0 2
15681: PUSH
15682: LD_VAR 0 7
15686: DIFF
15687: ST_TO_ADDR
15688: GO 15702
// SetTag ( i , 18 ) ;
15690: LD_VAR 0 7
15694: PPUSH
15695: LD_INT 18
15697: PPUSH
15698: CALL_OW 109
15702: GO 15642
15704: POP
15705: POP
// if not solds then
15706: LD_VAR 0 2
15710: NOT
15711: IFFALSE 15715
// exit ;
15713: GO 16057
// repeat wait ( 0 0$1 ) ;
15715: LD_INT 35
15717: PPUSH
15718: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15722: LD_ADDR_VAR 0 5
15726: PUSH
15727: LD_VAR 0 6
15731: PPUSH
15732: LD_VAR 0 3
15736: PPUSH
15737: CALL 15529 0 2
15741: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15742: LD_VAR 0 5
15746: NOT
15747: PUSH
15748: LD_VAR 0 5
15752: PUSH
15753: LD_INT 3
15755: GREATER
15756: OR
15757: PUSH
15758: LD_EXP 80
15762: PUSH
15763: LD_VAR 0 1
15767: ARRAY
15768: OR
15769: IFFALSE 15810
// begin for i in solds do
15771: LD_ADDR_VAR 0 7
15775: PUSH
15776: LD_VAR 0 2
15780: PUSH
15781: FOR_IN
15782: IFFALSE 15806
// if HasTask ( i ) then
15784: LD_VAR 0 7
15788: PPUSH
15789: CALL_OW 314
15793: IFFALSE 15804
// ComStop ( i ) ;
15795: LD_VAR 0 7
15799: PPUSH
15800: CALL_OW 141
15804: GO 15781
15806: POP
15807: POP
// break ;
15808: GO 16045
// end ; for i in solds do
15810: LD_ADDR_VAR 0 7
15814: PUSH
15815: LD_VAR 0 2
15819: PUSH
15820: FOR_IN
15821: IFFALSE 16037
// begin if IsInUnit ( i ) then
15823: LD_VAR 0 7
15827: PPUSH
15828: CALL_OW 310
15832: IFFALSE 15843
// ComExitBuilding ( i ) ;
15834: LD_VAR 0 7
15838: PPUSH
15839: CALL_OW 122
// if GetLives ( i ) > 333 then
15843: LD_VAR 0 7
15847: PPUSH
15848: CALL_OW 256
15852: PUSH
15853: LD_INT 333
15855: GREATER
15856: IFFALSE 15884
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15858: LD_VAR 0 7
15862: PPUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: LD_VAR 0 7
15872: PPUSH
15873: CALL_OW 74
15877: PPUSH
15878: CALL_OW 115
15882: GO 16035
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15884: LD_ADDR_VAR 0 8
15888: PUSH
15889: LD_EXP 58
15893: PUSH
15894: LD_VAR 0 1
15898: ARRAY
15899: PPUSH
15900: LD_INT 2
15902: PUSH
15903: LD_INT 30
15905: PUSH
15906: LD_INT 0
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 30
15915: PUSH
15916: LD_INT 1
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: PUSH
15923: LD_INT 30
15925: PUSH
15926: LD_INT 6
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PPUSH
15944: LD_VAR 0 7
15948: PPUSH
15949: CALL_OW 74
15953: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15954: LD_VAR 0 7
15958: PPUSH
15959: LD_VAR 0 8
15963: PPUSH
15964: CALL_OW 250
15968: PPUSH
15969: LD_INT 3
15971: PPUSH
15972: LD_INT 5
15974: PPUSH
15975: CALL_OW 272
15979: PPUSH
15980: LD_VAR 0 8
15984: PPUSH
15985: CALL_OW 251
15989: PPUSH
15990: LD_INT 3
15992: PPUSH
15993: LD_INT 5
15995: PPUSH
15996: CALL_OW 273
16000: PPUSH
16001: CALL_OW 111
// SetTag ( i , 0 ) ;
16005: LD_VAR 0 7
16009: PPUSH
16010: LD_INT 0
16012: PPUSH
16013: CALL_OW 109
// solds := solds diff i ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_VAR 0 2
16026: PUSH
16027: LD_VAR 0 7
16031: DIFF
16032: ST_TO_ADDR
// continue ;
16033: GO 15820
// end ; end ;
16035: GO 15820
16037: POP
16038: POP
// until solds ;
16039: LD_VAR 0 2
16043: IFFALSE 15715
// MC_Reset ( base , 18 ) ;
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 18
16052: PPUSH
16053: CALL 60559 0 2
// end ;
16057: LD_VAR 0 4
16061: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16062: LD_INT 0
16064: PPUSH
16065: PPUSH
16066: PPUSH
16067: PPUSH
16068: PPUSH
16069: PPUSH
16070: PPUSH
16071: PPUSH
16072: PPUSH
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16080: LD_ADDR_VAR 0 12
16084: PUSH
16085: LD_EXP 58
16089: PUSH
16090: LD_VAR 0 1
16094: ARRAY
16095: PPUSH
16096: LD_INT 25
16098: PUSH
16099: LD_INT 3
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 72
16110: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16111: LD_ADDR_VAR 0 8
16115: PUSH
16116: LD_EXP 58
16120: PUSH
16121: LD_VAR 0 1
16125: ARRAY
16126: PPUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 25
16132: PUSH
16133: LD_INT 1
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 25
16142: PUSH
16143: LD_INT 5
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: LD_INT 25
16152: PUSH
16153: LD_INT 8
16155: PUSH
16156: EMPTY
16157: LIST
16158: LIST
16159: PUSH
16160: LD_INT 25
16162: PUSH
16163: LD_INT 9
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: LIST
16174: LIST
16175: LIST
16176: PPUSH
16177: CALL_OW 72
16181: ST_TO_ADDR
// if not defenders and not solds then
16182: LD_VAR 0 2
16186: NOT
16187: PUSH
16188: LD_VAR 0 8
16192: NOT
16193: AND
16194: IFFALSE 16198
// exit ;
16196: GO 17564
// depot_under_attack := false ;
16198: LD_ADDR_VAR 0 16
16202: PUSH
16203: LD_INT 0
16205: ST_TO_ADDR
// sold_defenders := [ ] ;
16206: LD_ADDR_VAR 0 17
16210: PUSH
16211: EMPTY
16212: ST_TO_ADDR
// if mechs then
16213: LD_VAR 0 12
16217: IFFALSE 16346
// for i in defenders do
16219: LD_ADDR_VAR 0 5
16223: PUSH
16224: LD_VAR 0 2
16228: PUSH
16229: FOR_IN
16230: IFFALSE 16344
// begin SetTag ( i , 20 ) ;
16232: LD_VAR 0 5
16236: PPUSH
16237: LD_INT 20
16239: PPUSH
16240: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16244: LD_VAR 0 5
16248: PPUSH
16249: CALL_OW 263
16253: PUSH
16254: LD_INT 1
16256: EQUAL
16257: PUSH
16258: LD_VAR 0 5
16262: PPUSH
16263: CALL_OW 311
16267: NOT
16268: AND
16269: PUSH
16270: LD_VAR 0 12
16274: AND
16275: IFFALSE 16342
// begin un := mechs [ 1 ] ;
16277: LD_ADDR_VAR 0 10
16281: PUSH
16282: LD_VAR 0 12
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16291: LD_VAR 0 10
16295: PPUSH
16296: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16300: LD_VAR 0 10
16304: PPUSH
16305: LD_VAR 0 5
16309: PPUSH
16310: CALL_OW 180
// SetTag ( un , 19 ) ;
16314: LD_VAR 0 10
16318: PPUSH
16319: LD_INT 19
16321: PPUSH
16322: CALL_OW 109
// mechs := mechs diff un ;
16326: LD_ADDR_VAR 0 12
16330: PUSH
16331: LD_VAR 0 12
16335: PUSH
16336: LD_VAR 0 10
16340: DIFF
16341: ST_TO_ADDR
// end ; end ;
16342: GO 16229
16344: POP
16345: POP
// if solds then
16346: LD_VAR 0 8
16350: IFFALSE 16409
// for i in solds do
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_VAR 0 8
16361: PUSH
16362: FOR_IN
16363: IFFALSE 16407
// if not GetTag ( i ) then
16365: LD_VAR 0 5
16369: PPUSH
16370: CALL_OW 110
16374: NOT
16375: IFFALSE 16405
// begin defenders := defenders union i ;
16377: LD_ADDR_VAR 0 2
16381: PUSH
16382: LD_VAR 0 2
16386: PUSH
16387: LD_VAR 0 5
16391: UNION
16392: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16393: LD_VAR 0 5
16397: PPUSH
16398: LD_INT 18
16400: PPUSH
16401: CALL_OW 109
// end ;
16405: GO 16362
16407: POP
16408: POP
// repeat wait ( 0 0$1 ) ;
16409: LD_INT 35
16411: PPUSH
16412: CALL_OW 67
// enemy := mc_scan [ base ] ;
16416: LD_ADDR_VAR 0 3
16420: PUSH
16421: LD_EXP 81
16425: PUSH
16426: LD_VAR 0 1
16430: ARRAY
16431: ST_TO_ADDR
// for i in defenders do
16432: LD_ADDR_VAR 0 5
16436: PUSH
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_IN
16443: IFFALSE 17128
// begin e := NearestUnitToUnit ( enemy , i ) ;
16445: LD_ADDR_VAR 0 13
16449: PUSH
16450: LD_VAR 0 3
16454: PPUSH
16455: LD_VAR 0 5
16459: PPUSH
16460: CALL_OW 74
16464: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16465: LD_ADDR_VAR 0 16
16469: PUSH
16470: LD_EXP 58
16474: PUSH
16475: LD_VAR 0 1
16479: ARRAY
16480: PPUSH
16481: LD_INT 2
16483: PUSH
16484: LD_INT 30
16486: PUSH
16487: LD_INT 0
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: LD_INT 30
16496: PUSH
16497: LD_INT 1
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: LIST
16508: PPUSH
16509: CALL_OW 72
16513: NOT
16514: PUSH
16515: LD_EXP 58
16519: PUSH
16520: LD_VAR 0 1
16524: ARRAY
16525: PPUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 30
16531: PUSH
16532: LD_INT 0
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: LD_INT 30
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: PPUSH
16554: CALL_OW 72
16558: PPUSH
16559: CALL_OW 256
16563: PUSH
16564: LD_INT 600
16566: LESS
16567: OR
16568: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16569: LD_VAR 0 5
16573: PPUSH
16574: CALL_OW 247
16578: PUSH
16579: LD_INT 2
16581: DOUBLE
16582: EQUAL
16583: IFTRUE 16587
16585: GO 16834
16587: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16588: LD_VAR 0 5
16592: PPUSH
16593: CALL_OW 256
16597: PUSH
16598: LD_INT 650
16600: GREATER
16601: PUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: LD_VAR 0 13
16611: PPUSH
16612: CALL_OW 296
16616: PUSH
16617: LD_INT 40
16619: LESS
16620: AND
16621: IFFALSE 16639
// ComAttackUnit ( i , e ) else
16623: LD_VAR 0 5
16627: PPUSH
16628: LD_VAR 0 13
16632: PPUSH
16633: CALL_OW 115
16637: GO 16717
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16639: LD_VAR 0 5
16643: PPUSH
16644: LD_VAR 0 13
16648: PPUSH
16649: CALL_OW 296
16653: PUSH
16654: LD_INT 30
16656: GREATEREQUAL
16657: PUSH
16658: LD_VAR 0 5
16662: PPUSH
16663: CALL_OW 256
16667: PUSH
16668: LD_INT 650
16670: LESSEQUAL
16671: OR
16672: PUSH
16673: LD_VAR 0 5
16677: PPUSH
16678: LD_EXP 82
16682: PUSH
16683: LD_VAR 0 1
16687: ARRAY
16688: PPUSH
16689: CALL_OW 308
16693: NOT
16694: AND
16695: IFFALSE 16717
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16697: LD_VAR 0 5
16701: PPUSH
16702: LD_EXP 82
16706: PUSH
16707: LD_VAR 0 1
16711: ARRAY
16712: PPUSH
16713: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16717: LD_VAR 0 5
16721: PPUSH
16722: CALL_OW 256
16726: PUSH
16727: LD_INT 998
16729: LESS
16730: PUSH
16731: LD_VAR 0 5
16735: PPUSH
16736: CALL_OW 263
16740: PUSH
16741: LD_INT 1
16743: EQUAL
16744: AND
16745: PUSH
16746: LD_VAR 0 5
16750: PPUSH
16751: CALL_OW 311
16755: AND
16756: PUSH
16757: LD_VAR 0 5
16761: PPUSH
16762: LD_EXP 82
16766: PUSH
16767: LD_VAR 0 1
16771: ARRAY
16772: PPUSH
16773: CALL_OW 308
16777: AND
16778: IFFALSE 16832
// begin mech := IsDrivenBy ( i ) ;
16780: LD_ADDR_VAR 0 9
16784: PUSH
16785: LD_VAR 0 5
16789: PPUSH
16790: CALL_OW 311
16794: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16795: LD_VAR 0 9
16799: PPUSH
16800: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16804: LD_VAR 0 9
16808: PPUSH
16809: LD_VAR 0 5
16813: PPUSH
16814: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16818: LD_VAR 0 9
16822: PPUSH
16823: LD_VAR 0 5
16827: PPUSH
16828: CALL_OW 180
// end ; end ; unit_human :
16832: GO 17099
16834: LD_INT 1
16836: DOUBLE
16837: EQUAL
16838: IFTRUE 16842
16840: GO 17098
16842: POP
// begin b := IsInUnit ( i ) ;
16843: LD_ADDR_VAR 0 18
16847: PUSH
16848: LD_VAR 0 5
16852: PPUSH
16853: CALL_OW 310
16857: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16858: LD_ADDR_VAR 0 19
16862: PUSH
16863: LD_VAR 0 18
16867: NOT
16868: PUSH
16869: LD_VAR 0 18
16873: PPUSH
16874: CALL_OW 266
16878: PUSH
16879: LD_INT 32
16881: PUSH
16882: LD_INT 31
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: IN
16889: OR
16890: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16891: LD_VAR 0 16
16895: PUSH
16896: LD_VAR 0 2
16900: PPUSH
16901: LD_INT 21
16903: PUSH
16904: LD_INT 2
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: PPUSH
16911: CALL_OW 72
16915: PUSH
16916: LD_INT 1
16918: LESSEQUAL
16919: OR
16920: PUSH
16921: LD_VAR 0 19
16925: AND
16926: PUSH
16927: LD_VAR 0 5
16931: PUSH
16932: LD_VAR 0 17
16936: IN
16937: NOT
16938: AND
16939: IFFALSE 17032
// begin if b then
16941: LD_VAR 0 18
16945: IFFALSE 16994
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16947: LD_VAR 0 18
16951: PPUSH
16952: LD_VAR 0 3
16956: PPUSH
16957: LD_VAR 0 18
16961: PPUSH
16962: CALL_OW 74
16966: PPUSH
16967: CALL_OW 296
16971: PUSH
16972: LD_INT 10
16974: LESS
16975: PUSH
16976: LD_VAR 0 18
16980: PPUSH
16981: CALL_OW 461
16985: PUSH
16986: LD_INT 7
16988: NONEQUAL
16989: AND
16990: IFFALSE 16994
// continue ;
16992: GO 16442
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16994: LD_ADDR_VAR 0 17
16998: PUSH
16999: LD_VAR 0 17
17003: PPUSH
17004: LD_VAR 0 17
17008: PUSH
17009: LD_INT 1
17011: PLUS
17012: PPUSH
17013: LD_VAR 0 5
17017: PPUSH
17018: CALL_OW 1
17022: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17023: LD_VAR 0 5
17027: PPUSH
17028: CALL_OW 122
// end ; if sold_defenders then
17032: LD_VAR 0 17
17036: IFFALSE 17096
// if i in sold_defenders then
17038: LD_VAR 0 5
17042: PUSH
17043: LD_VAR 0 17
17047: IN
17048: IFFALSE 17096
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17050: LD_VAR 0 5
17054: PPUSH
17055: CALL_OW 314
17059: NOT
17060: PUSH
17061: LD_VAR 0 5
17065: PPUSH
17066: LD_VAR 0 13
17070: PPUSH
17071: CALL_OW 296
17075: PUSH
17076: LD_INT 30
17078: LESS
17079: AND
17080: IFFALSE 17096
// ComAttackUnit ( i , e ) ;
17082: LD_VAR 0 5
17086: PPUSH
17087: LD_VAR 0 13
17091: PPUSH
17092: CALL_OW 115
// end ; end ; end ;
17096: GO 17099
17098: POP
// if IsDead ( i ) then
17099: LD_VAR 0 5
17103: PPUSH
17104: CALL_OW 301
17108: IFFALSE 17126
// defenders := defenders diff i ;
17110: LD_ADDR_VAR 0 2
17114: PUSH
17115: LD_VAR 0 2
17119: PUSH
17120: LD_VAR 0 5
17124: DIFF
17125: ST_TO_ADDR
// end ;
17126: GO 16442
17128: POP
17129: POP
// until not enemy or not defenders ;
17130: LD_VAR 0 3
17134: NOT
17135: PUSH
17136: LD_VAR 0 2
17140: NOT
17141: OR
17142: IFFALSE 16409
// MC_Reset ( base , 18 ) ;
17144: LD_VAR 0 1
17148: PPUSH
17149: LD_INT 18
17151: PPUSH
17152: CALL 60559 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17156: LD_ADDR_VAR 0 2
17160: PUSH
17161: LD_VAR 0 2
17165: PUSH
17166: LD_VAR 0 2
17170: PPUSH
17171: LD_INT 2
17173: PUSH
17174: LD_INT 25
17176: PUSH
17177: LD_INT 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 25
17186: PUSH
17187: LD_INT 5
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 25
17196: PUSH
17197: LD_INT 8
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 25
17206: PUSH
17207: LD_INT 9
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: PPUSH
17221: CALL_OW 72
17225: DIFF
17226: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17227: LD_VAR 0 3
17231: NOT
17232: PUSH
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_INT 21
17240: PUSH
17241: LD_INT 2
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 72
17252: AND
17253: IFFALSE 17515
// begin tmp := FilterByTag ( defenders , 19 ) ;
17255: LD_ADDR_VAR 0 11
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 19
17267: PPUSH
17268: CALL 53901 0 2
17272: ST_TO_ADDR
// if tmp then
17273: LD_VAR 0 11
17277: IFFALSE 17347
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17279: LD_ADDR_VAR 0 11
17283: PUSH
17284: LD_VAR 0 11
17288: PPUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 3
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PPUSH
17299: CALL_OW 72
17303: ST_TO_ADDR
// if tmp then
17304: LD_VAR 0 11
17308: IFFALSE 17347
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17310: LD_ADDR_EXP 70
17314: PUSH
17315: LD_EXP 70
17319: PPUSH
17320: LD_VAR 0 1
17324: PPUSH
17325: LD_EXP 70
17329: PUSH
17330: LD_VAR 0 1
17334: ARRAY
17335: PUSH
17336: LD_VAR 0 11
17340: UNION
17341: PPUSH
17342: CALL_OW 1
17346: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17347: LD_VAR 0 1
17351: PPUSH
17352: LD_INT 19
17354: PPUSH
17355: CALL 60559 0 2
// repeat wait ( 0 0$1 ) ;
17359: LD_INT 35
17361: PPUSH
17362: CALL_OW 67
// for i in defenders do
17366: LD_ADDR_VAR 0 5
17370: PUSH
17371: LD_VAR 0 2
17375: PUSH
17376: FOR_IN
17377: IFFALSE 17466
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17379: LD_VAR 0 5
17383: PPUSH
17384: LD_EXP 82
17388: PUSH
17389: LD_VAR 0 1
17393: ARRAY
17394: PPUSH
17395: CALL_OW 308
17399: NOT
17400: IFFALSE 17424
// ComMoveToArea ( i , mc_parking [ base ] ) else
17402: LD_VAR 0 5
17406: PPUSH
17407: LD_EXP 82
17411: PUSH
17412: LD_VAR 0 1
17416: ARRAY
17417: PPUSH
17418: CALL_OW 113
17422: GO 17464
// if GetControl ( i ) = control_manual then
17424: LD_VAR 0 5
17428: PPUSH
17429: CALL_OW 263
17433: PUSH
17434: LD_INT 1
17436: EQUAL
17437: IFFALSE 17464
// if IsDrivenBy ( i ) then
17439: LD_VAR 0 5
17443: PPUSH
17444: CALL_OW 311
17448: IFFALSE 17464
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17450: LD_VAR 0 5
17454: PPUSH
17455: CALL_OW 311
17459: PPUSH
17460: CALL_OW 121
// end ;
17464: GO 17376
17466: POP
17467: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17468: LD_VAR 0 2
17472: PPUSH
17473: LD_INT 95
17475: PUSH
17476: LD_EXP 82
17480: PUSH
17481: LD_VAR 0 1
17485: ARRAY
17486: PUSH
17487: EMPTY
17488: LIST
17489: LIST
17490: PPUSH
17491: CALL_OW 72
17495: PUSH
17496: LD_VAR 0 2
17500: EQUAL
17501: PUSH
17502: LD_EXP 81
17506: PUSH
17507: LD_VAR 0 1
17511: ARRAY
17512: OR
17513: IFFALSE 17359
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17515: LD_ADDR_EXP 80
17519: PUSH
17520: LD_EXP 80
17524: PPUSH
17525: LD_VAR 0 1
17529: PPUSH
17530: LD_EXP 80
17534: PUSH
17535: LD_VAR 0 1
17539: ARRAY
17540: PUSH
17541: LD_VAR 0 2
17545: UNION
17546: PPUSH
17547: CALL_OW 1
17551: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17552: LD_VAR 0 1
17556: PPUSH
17557: LD_INT 20
17559: PPUSH
17560: CALL 60559 0 2
// end ;
17564: LD_VAR 0 4
17568: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17569: LD_INT 0
17571: PPUSH
17572: PPUSH
17573: PPUSH
17574: PPUSH
// result := false ;
17575: LD_ADDR_VAR 0 2
17579: PUSH
17580: LD_INT 0
17582: ST_TO_ADDR
// side := GetSide ( unit ) ;
17583: LD_ADDR_VAR 0 3
17587: PUSH
17588: LD_VAR 0 1
17592: PPUSH
17593: CALL_OW 255
17597: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17598: LD_ADDR_VAR 0 4
17602: PUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 248
17612: ST_TO_ADDR
// case nat of 1 :
17613: LD_VAR 0 4
17617: PUSH
17618: LD_INT 1
17620: DOUBLE
17621: EQUAL
17622: IFTRUE 17626
17624: GO 17637
17626: POP
// tech := tech_lassight ; 2 :
17627: LD_ADDR_VAR 0 5
17631: PUSH
17632: LD_INT 12
17634: ST_TO_ADDR
17635: GO 17676
17637: LD_INT 2
17639: DOUBLE
17640: EQUAL
17641: IFTRUE 17645
17643: GO 17656
17645: POP
// tech := tech_mortar ; 3 :
17646: LD_ADDR_VAR 0 5
17650: PUSH
17651: LD_INT 41
17653: ST_TO_ADDR
17654: GO 17676
17656: LD_INT 3
17658: DOUBLE
17659: EQUAL
17660: IFTRUE 17664
17662: GO 17675
17664: POP
// tech := tech_bazooka ; end ;
17665: LD_ADDR_VAR 0 5
17669: PUSH
17670: LD_INT 44
17672: ST_TO_ADDR
17673: GO 17676
17675: POP
// if Researched ( side , tech ) then
17676: LD_VAR 0 3
17680: PPUSH
17681: LD_VAR 0 5
17685: PPUSH
17686: CALL_OW 325
17690: IFFALSE 17717
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17692: LD_ADDR_VAR 0 2
17696: PUSH
17697: LD_INT 5
17699: PUSH
17700: LD_INT 8
17702: PUSH
17703: LD_INT 9
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_VAR 0 4
17715: ARRAY
17716: ST_TO_ADDR
// end ;
17717: LD_VAR 0 2
17721: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17722: LD_INT 0
17724: PPUSH
17725: PPUSH
17726: PPUSH
// if not mines then
17727: LD_VAR 0 2
17731: NOT
17732: IFFALSE 17736
// exit ;
17734: GO 17880
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17736: LD_ADDR_VAR 0 5
17740: PUSH
17741: LD_INT 81
17743: PUSH
17744: LD_VAR 0 1
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PUSH
17753: LD_INT 3
17755: PUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 3
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 69
17778: ST_TO_ADDR
// for i in mines do
17779: LD_ADDR_VAR 0 4
17783: PUSH
17784: LD_VAR 0 2
17788: PUSH
17789: FOR_IN
17790: IFFALSE 17878
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17792: LD_VAR 0 4
17796: PUSH
17797: LD_INT 1
17799: ARRAY
17800: PPUSH
17801: LD_VAR 0 4
17805: PUSH
17806: LD_INT 2
17808: ARRAY
17809: PPUSH
17810: CALL_OW 458
17814: NOT
17815: IFFALSE 17819
// continue ;
17817: GO 17789
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17819: LD_VAR 0 4
17823: PUSH
17824: LD_INT 1
17826: ARRAY
17827: PPUSH
17828: LD_VAR 0 4
17832: PUSH
17833: LD_INT 2
17835: ARRAY
17836: PPUSH
17837: CALL_OW 428
17841: PUSH
17842: LD_VAR 0 5
17846: IN
17847: IFFALSE 17876
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17849: LD_VAR 0 4
17853: PUSH
17854: LD_INT 1
17856: ARRAY
17857: PPUSH
17858: LD_VAR 0 4
17862: PUSH
17863: LD_INT 2
17865: ARRAY
17866: PPUSH
17867: LD_VAR 0 1
17871: PPUSH
17872: CALL_OW 456
// end ;
17876: GO 17789
17878: POP
17879: POP
// end ;
17880: LD_VAR 0 3
17884: RET
// export function Count ( array ) ; var i ; begin
17885: LD_INT 0
17887: PPUSH
17888: PPUSH
// result := 0 ;
17889: LD_ADDR_VAR 0 2
17893: PUSH
17894: LD_INT 0
17896: ST_TO_ADDR
// for i in array do
17897: LD_ADDR_VAR 0 3
17901: PUSH
17902: LD_VAR 0 1
17906: PUSH
17907: FOR_IN
17908: IFFALSE 17932
// if i then
17910: LD_VAR 0 3
17914: IFFALSE 17930
// result := result + 1 ;
17916: LD_ADDR_VAR 0 2
17920: PUSH
17921: LD_VAR 0 2
17925: PUSH
17926: LD_INT 1
17928: PLUS
17929: ST_TO_ADDR
17930: GO 17907
17932: POP
17933: POP
// end ;
17934: LD_VAR 0 2
17938: RET
// export function IsEmpty ( building ) ; begin
17939: LD_INT 0
17941: PPUSH
// if not building then
17942: LD_VAR 0 1
17946: NOT
17947: IFFALSE 17951
// exit ;
17949: GO 17994
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17951: LD_ADDR_VAR 0 2
17955: PUSH
17956: LD_VAR 0 1
17960: PUSH
17961: LD_INT 22
17963: PUSH
17964: LD_VAR 0 1
17968: PPUSH
17969: CALL_OW 255
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: PUSH
17978: LD_INT 58
17980: PUSH
17981: EMPTY
17982: LIST
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: PPUSH
17988: CALL_OW 69
17992: IN
17993: ST_TO_ADDR
// end ;
17994: LD_VAR 0 2
17998: RET
// export function IsNotFull ( building ) ; begin
17999: LD_INT 0
18001: PPUSH
// if not building then
18002: LD_VAR 0 1
18006: NOT
18007: IFFALSE 18011
// exit ;
18009: GO 18030
// result := UnitsInside ( building ) < 6 ;
18011: LD_ADDR_VAR 0 2
18015: PUSH
18016: LD_VAR 0 1
18020: PPUSH
18021: CALL_OW 313
18025: PUSH
18026: LD_INT 6
18028: LESS
18029: ST_TO_ADDR
// end ;
18030: LD_VAR 0 2
18034: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18035: LD_INT 0
18037: PPUSH
18038: PPUSH
18039: PPUSH
18040: PPUSH
// tmp := [ ] ;
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// list := [ ] ;
18048: LD_ADDR_VAR 0 5
18052: PUSH
18053: EMPTY
18054: ST_TO_ADDR
// for i = 16 to 25 do
18055: LD_ADDR_VAR 0 4
18059: PUSH
18060: DOUBLE
18061: LD_INT 16
18063: DEC
18064: ST_TO_ADDR
18065: LD_INT 25
18067: PUSH
18068: FOR_TO
18069: IFFALSE 18142
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18071: LD_ADDR_VAR 0 3
18075: PUSH
18076: LD_VAR 0 3
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_VAR 0 1
18088: PPUSH
18089: CALL_OW 255
18093: PUSH
18094: EMPTY
18095: LIST
18096: LIST
18097: PUSH
18098: LD_INT 91
18100: PUSH
18101: LD_VAR 0 1
18105: PUSH
18106: LD_INT 6
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 30
18116: PUSH
18117: LD_VAR 0 4
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: LIST
18130: PUSH
18131: EMPTY
18132: LIST
18133: PPUSH
18134: CALL_OW 69
18138: ADD
18139: ST_TO_ADDR
18140: GO 18068
18142: POP
18143: POP
// for i = 1 to tmp do
18144: LD_ADDR_VAR 0 4
18148: PUSH
18149: DOUBLE
18150: LD_INT 1
18152: DEC
18153: ST_TO_ADDR
18154: LD_VAR 0 3
18158: PUSH
18159: FOR_TO
18160: IFFALSE 18248
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18162: LD_ADDR_VAR 0 5
18166: PUSH
18167: LD_VAR 0 5
18171: PUSH
18172: LD_VAR 0 3
18176: PUSH
18177: LD_VAR 0 4
18181: ARRAY
18182: PPUSH
18183: CALL_OW 266
18187: PUSH
18188: LD_VAR 0 3
18192: PUSH
18193: LD_VAR 0 4
18197: ARRAY
18198: PPUSH
18199: CALL_OW 250
18203: PUSH
18204: LD_VAR 0 3
18208: PUSH
18209: LD_VAR 0 4
18213: ARRAY
18214: PPUSH
18215: CALL_OW 251
18219: PUSH
18220: LD_VAR 0 3
18224: PUSH
18225: LD_VAR 0 4
18229: ARRAY
18230: PPUSH
18231: CALL_OW 254
18235: PUSH
18236: EMPTY
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: PUSH
18242: EMPTY
18243: LIST
18244: ADD
18245: ST_TO_ADDR
18246: GO 18159
18248: POP
18249: POP
// result := list ;
18250: LD_ADDR_VAR 0 2
18254: PUSH
18255: LD_VAR 0 5
18259: ST_TO_ADDR
// end ;
18260: LD_VAR 0 2
18264: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18265: LD_INT 0
18267: PPUSH
18268: PPUSH
18269: PPUSH
18270: PPUSH
18271: PPUSH
18272: PPUSH
18273: PPUSH
// if not factory then
18274: LD_VAR 0 1
18278: NOT
18279: IFFALSE 18283
// exit ;
18281: GO 18808
// if control = control_apeman then
18283: LD_VAR 0 4
18287: PUSH
18288: LD_INT 5
18290: EQUAL
18291: IFFALSE 18400
// begin tmp := UnitsInside ( factory ) ;
18293: LD_ADDR_VAR 0 8
18297: PUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 313
18307: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18308: LD_VAR 0 8
18312: PPUSH
18313: LD_INT 25
18315: PUSH
18316: LD_INT 12
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PPUSH
18323: CALL_OW 72
18327: NOT
18328: IFFALSE 18338
// control := control_manual ;
18330: LD_ADDR_VAR 0 4
18334: PUSH
18335: LD_INT 1
18337: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18338: LD_ADDR_VAR 0 8
18342: PUSH
18343: LD_VAR 0 1
18347: PPUSH
18348: CALL 18035 0 1
18352: ST_TO_ADDR
// if tmp then
18353: LD_VAR 0 8
18357: IFFALSE 18400
// begin for i in tmp do
18359: LD_ADDR_VAR 0 7
18363: PUSH
18364: LD_VAR 0 8
18368: PUSH
18369: FOR_IN
18370: IFFALSE 18398
// if i [ 1 ] = b_ext_radar then
18372: LD_VAR 0 7
18376: PUSH
18377: LD_INT 1
18379: ARRAY
18380: PUSH
18381: LD_INT 20
18383: EQUAL
18384: IFFALSE 18396
// begin control := control_remote ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_INT 2
18393: ST_TO_ADDR
// break ;
18394: GO 18398
// end ;
18396: GO 18369
18398: POP
18399: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18400: LD_VAR 0 1
18404: PPUSH
18405: LD_VAR 0 2
18409: PPUSH
18410: LD_VAR 0 3
18414: PPUSH
18415: LD_VAR 0 4
18419: PPUSH
18420: LD_VAR 0 5
18424: PPUSH
18425: CALL_OW 448
18429: IFFALSE 18464
// begin result := [ chassis , engine , control , weapon ] ;
18431: LD_ADDR_VAR 0 6
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: LD_VAR 0 3
18445: PUSH
18446: LD_VAR 0 4
18450: PUSH
18451: LD_VAR 0 5
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
// exit ;
18462: GO 18808
// end ; _chassis := AvailableChassisList ( factory ) ;
18464: LD_ADDR_VAR 0 9
18468: PUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: CALL_OW 475
18478: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18479: LD_ADDR_VAR 0 11
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 476
18493: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18494: LD_ADDR_VAR 0 12
18498: PUSH
18499: LD_VAR 0 1
18503: PPUSH
18504: CALL_OW 477
18508: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18509: LD_ADDR_VAR 0 10
18513: PUSH
18514: LD_VAR 0 1
18518: PPUSH
18519: CALL_OW 478
18523: ST_TO_ADDR
// if not chassis in _chassis then
18524: LD_VAR 0 2
18528: PUSH
18529: LD_VAR 0 9
18533: IN
18534: NOT
18535: IFFALSE 18561
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 9
18546: PUSH
18547: LD_INT 1
18549: PPUSH
18550: LD_VAR 0 9
18554: PPUSH
18555: CALL_OW 12
18559: ARRAY
18560: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18561: LD_VAR 0 2
18565: PPUSH
18566: LD_VAR 0 3
18570: PPUSH
18571: CALL 18813 0 2
18575: NOT
18576: IFFALSE 18635
// repeat engine := _engine [ 1 ] ;
18578: LD_ADDR_VAR 0 3
18582: PUSH
18583: LD_VAR 0 11
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18592: LD_ADDR_VAR 0 11
18596: PUSH
18597: LD_VAR 0 11
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: CALL_OW 3
18609: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18610: LD_VAR 0 2
18614: PPUSH
18615: LD_VAR 0 3
18619: PPUSH
18620: CALL 18813 0 2
18624: PUSH
18625: LD_VAR 0 11
18629: PUSH
18630: EMPTY
18631: EQUAL
18632: OR
18633: IFFALSE 18578
// if not control in _control then
18635: LD_VAR 0 4
18639: PUSH
18640: LD_VAR 0 12
18644: IN
18645: NOT
18646: IFFALSE 18672
// control := _control [ rand ( 1 , _control ) ] ;
18648: LD_ADDR_VAR 0 4
18652: PUSH
18653: LD_VAR 0 12
18657: PUSH
18658: LD_INT 1
18660: PPUSH
18661: LD_VAR 0 12
18665: PPUSH
18666: CALL_OW 12
18670: ARRAY
18671: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18672: LD_VAR 0 2
18676: PPUSH
18677: LD_VAR 0 5
18681: PPUSH
18682: CALL 19033 0 2
18686: NOT
18687: IFFALSE 18746
// repeat weapon := _weapon [ 1 ] ;
18689: LD_ADDR_VAR 0 5
18693: PUSH
18694: LD_VAR 0 10
18698: PUSH
18699: LD_INT 1
18701: ARRAY
18702: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18703: LD_ADDR_VAR 0 10
18707: PUSH
18708: LD_VAR 0 10
18712: PPUSH
18713: LD_INT 1
18715: PPUSH
18716: CALL_OW 3
18720: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_VAR 0 5
18730: PPUSH
18731: CALL 19033 0 2
18735: PUSH
18736: LD_VAR 0 10
18740: PUSH
18741: EMPTY
18742: EQUAL
18743: OR
18744: IFFALSE 18689
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18746: LD_VAR 0 1
18750: PPUSH
18751: LD_VAR 0 2
18755: PPUSH
18756: LD_VAR 0 3
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: LD_VAR 0 5
18770: PPUSH
18771: CALL_OW 448
18775: IFFALSE 18808
// result := [ chassis , engine , control , weapon ] ;
18777: LD_ADDR_VAR 0 6
18781: PUSH
18782: LD_VAR 0 2
18786: PUSH
18787: LD_VAR 0 3
18791: PUSH
18792: LD_VAR 0 4
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
// end ;
18808: LD_VAR 0 6
18812: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18813: LD_INT 0
18815: PPUSH
// if not chassis or not engine then
18816: LD_VAR 0 1
18820: NOT
18821: PUSH
18822: LD_VAR 0 2
18826: NOT
18827: OR
18828: IFFALSE 18832
// exit ;
18830: GO 19028
// case engine of engine_solar :
18832: LD_VAR 0 2
18836: PUSH
18837: LD_INT 2
18839: DOUBLE
18840: EQUAL
18841: IFTRUE 18845
18843: GO 18883
18845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18846: LD_ADDR_VAR 0 3
18850: PUSH
18851: LD_INT 11
18853: PUSH
18854: LD_INT 12
18856: PUSH
18857: LD_INT 13
18859: PUSH
18860: LD_INT 14
18862: PUSH
18863: LD_INT 1
18865: PUSH
18866: LD_INT 2
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: ST_TO_ADDR
18881: GO 19012
18883: LD_INT 1
18885: DOUBLE
18886: EQUAL
18887: IFTRUE 18891
18889: GO 18953
18891: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18892: LD_ADDR_VAR 0 3
18896: PUSH
18897: LD_INT 11
18899: PUSH
18900: LD_INT 12
18902: PUSH
18903: LD_INT 13
18905: PUSH
18906: LD_INT 14
18908: PUSH
18909: LD_INT 1
18911: PUSH
18912: LD_INT 2
18914: PUSH
18915: LD_INT 3
18917: PUSH
18918: LD_INT 4
18920: PUSH
18921: LD_INT 5
18923: PUSH
18924: LD_INT 21
18926: PUSH
18927: LD_INT 23
18929: PUSH
18930: LD_INT 22
18932: PUSH
18933: LD_INT 24
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: LIST
18950: ST_TO_ADDR
18951: GO 19012
18953: LD_INT 3
18955: DOUBLE
18956: EQUAL
18957: IFTRUE 18961
18959: GO 19011
18961: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18962: LD_ADDR_VAR 0 3
18966: PUSH
18967: LD_INT 13
18969: PUSH
18970: LD_INT 14
18972: PUSH
18973: LD_INT 2
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: LD_INT 4
18981: PUSH
18982: LD_INT 5
18984: PUSH
18985: LD_INT 21
18987: PUSH
18988: LD_INT 22
18990: PUSH
18991: LD_INT 23
18993: PUSH
18994: LD_INT 24
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: LIST
19008: ST_TO_ADDR
19009: GO 19012
19011: POP
// result := ( chassis in result ) ;
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_VAR 0 1
19021: PUSH
19022: LD_VAR 0 3
19026: IN
19027: ST_TO_ADDR
// end ;
19028: LD_VAR 0 3
19032: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19033: LD_INT 0
19035: PPUSH
// if not chassis or not weapon then
19036: LD_VAR 0 1
19040: NOT
19041: PUSH
19042: LD_VAR 0 2
19046: NOT
19047: OR
19048: IFFALSE 19052
// exit ;
19050: GO 20078
// case weapon of us_machine_gun :
19052: LD_VAR 0 2
19056: PUSH
19057: LD_INT 2
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19095
19065: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 1
19073: PUSH
19074: LD_INT 2
19076: PUSH
19077: LD_INT 3
19079: PUSH
19080: LD_INT 4
19082: PUSH
19083: LD_INT 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: LIST
19092: ST_TO_ADDR
19093: GO 20062
19095: LD_INT 3
19097: DOUBLE
19098: EQUAL
19099: IFTRUE 19103
19101: GO 19133
19103: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19104: LD_ADDR_VAR 0 3
19108: PUSH
19109: LD_INT 1
19111: PUSH
19112: LD_INT 2
19114: PUSH
19115: LD_INT 3
19117: PUSH
19118: LD_INT 4
19120: PUSH
19121: LD_INT 5
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: LIST
19128: LIST
19129: LIST
19130: ST_TO_ADDR
19131: GO 20062
19133: LD_INT 11
19135: DOUBLE
19136: EQUAL
19137: IFTRUE 19141
19139: GO 19171
19141: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19142: LD_ADDR_VAR 0 3
19146: PUSH
19147: LD_INT 1
19149: PUSH
19150: LD_INT 2
19152: PUSH
19153: LD_INT 3
19155: PUSH
19156: LD_INT 4
19158: PUSH
19159: LD_INT 5
19161: PUSH
19162: EMPTY
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: ST_TO_ADDR
19169: GO 20062
19171: LD_INT 4
19173: DOUBLE
19174: EQUAL
19175: IFTRUE 19179
19177: GO 19205
19179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19180: LD_ADDR_VAR 0 3
19184: PUSH
19185: LD_INT 2
19187: PUSH
19188: LD_INT 3
19190: PUSH
19191: LD_INT 4
19193: PUSH
19194: LD_INT 5
19196: PUSH
19197: EMPTY
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: ST_TO_ADDR
19203: GO 20062
19205: LD_INT 5
19207: DOUBLE
19208: EQUAL
19209: IFTRUE 19213
19211: GO 19239
19213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19214: LD_ADDR_VAR 0 3
19218: PUSH
19219: LD_INT 2
19221: PUSH
19222: LD_INT 3
19224: PUSH
19225: LD_INT 4
19227: PUSH
19228: LD_INT 5
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: ST_TO_ADDR
19237: GO 20062
19239: LD_INT 9
19241: DOUBLE
19242: EQUAL
19243: IFTRUE 19247
19245: GO 19273
19247: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19248: LD_ADDR_VAR 0 3
19252: PUSH
19253: LD_INT 2
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: LD_INT 4
19261: PUSH
19262: LD_INT 5
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: ST_TO_ADDR
19271: GO 20062
19273: LD_INT 7
19275: DOUBLE
19276: EQUAL
19277: IFTRUE 19281
19279: GO 19307
19281: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19282: LD_ADDR_VAR 0 3
19286: PUSH
19287: LD_INT 2
19289: PUSH
19290: LD_INT 3
19292: PUSH
19293: LD_INT 4
19295: PUSH
19296: LD_INT 5
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: ST_TO_ADDR
19305: GO 20062
19307: LD_INT 12
19309: DOUBLE
19310: EQUAL
19311: IFTRUE 19315
19313: GO 19341
19315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19316: LD_ADDR_VAR 0 3
19320: PUSH
19321: LD_INT 2
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: LD_INT 4
19329: PUSH
19330: LD_INT 5
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: ST_TO_ADDR
19339: GO 20062
19341: LD_INT 13
19343: DOUBLE
19344: EQUAL
19345: IFTRUE 19349
19347: GO 19375
19349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19350: LD_ADDR_VAR 0 3
19354: PUSH
19355: LD_INT 2
19357: PUSH
19358: LD_INT 3
19360: PUSH
19361: LD_INT 4
19363: PUSH
19364: LD_INT 5
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: ST_TO_ADDR
19373: GO 20062
19375: LD_INT 14
19377: DOUBLE
19378: EQUAL
19379: IFTRUE 19383
19381: GO 19401
19383: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19384: LD_ADDR_VAR 0 3
19388: PUSH
19389: LD_INT 4
19391: PUSH
19392: LD_INT 5
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: ST_TO_ADDR
19399: GO 20062
19401: LD_INT 6
19403: DOUBLE
19404: EQUAL
19405: IFTRUE 19409
19407: GO 19427
19409: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19410: LD_ADDR_VAR 0 3
19414: PUSH
19415: LD_INT 4
19417: PUSH
19418: LD_INT 5
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: ST_TO_ADDR
19425: GO 20062
19427: LD_INT 10
19429: DOUBLE
19430: EQUAL
19431: IFTRUE 19435
19433: GO 19453
19435: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19436: LD_ADDR_VAR 0 3
19440: PUSH
19441: LD_INT 4
19443: PUSH
19444: LD_INT 5
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: ST_TO_ADDR
19451: GO 20062
19453: LD_INT 22
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19487
19461: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19462: LD_ADDR_VAR 0 3
19466: PUSH
19467: LD_INT 11
19469: PUSH
19470: LD_INT 12
19472: PUSH
19473: LD_INT 13
19475: PUSH
19476: LD_INT 14
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: ST_TO_ADDR
19485: GO 20062
19487: LD_INT 23
19489: DOUBLE
19490: EQUAL
19491: IFTRUE 19495
19493: GO 19521
19495: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19496: LD_ADDR_VAR 0 3
19500: PUSH
19501: LD_INT 11
19503: PUSH
19504: LD_INT 12
19506: PUSH
19507: LD_INT 13
19509: PUSH
19510: LD_INT 14
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: ST_TO_ADDR
19519: GO 20062
19521: LD_INT 24
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19555
19529: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_INT 11
19537: PUSH
19538: LD_INT 12
19540: PUSH
19541: LD_INT 13
19543: PUSH
19544: LD_INT 14
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 20062
19555: LD_INT 30
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19589
19563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 11
19571: PUSH
19572: LD_INT 12
19574: PUSH
19575: LD_INT 13
19577: PUSH
19578: LD_INT 14
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: ST_TO_ADDR
19587: GO 20062
19589: LD_INT 25
19591: DOUBLE
19592: EQUAL
19593: IFTRUE 19597
19595: GO 19615
19597: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19598: LD_ADDR_VAR 0 3
19602: PUSH
19603: LD_INT 13
19605: PUSH
19606: LD_INT 14
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: ST_TO_ADDR
19613: GO 20062
19615: LD_INT 27
19617: DOUBLE
19618: EQUAL
19619: IFTRUE 19623
19621: GO 19641
19623: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19624: LD_ADDR_VAR 0 3
19628: PUSH
19629: LD_INT 13
19631: PUSH
19632: LD_INT 14
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: ST_TO_ADDR
19639: GO 20062
19641: LD_INT 28
19643: DOUBLE
19644: EQUAL
19645: IFTRUE 19649
19647: GO 19667
19649: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19650: LD_ADDR_VAR 0 3
19654: PUSH
19655: LD_INT 13
19657: PUSH
19658: LD_INT 14
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: ST_TO_ADDR
19665: GO 20062
19667: LD_INT 29
19669: DOUBLE
19670: EQUAL
19671: IFTRUE 19675
19673: GO 19693
19675: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19676: LD_ADDR_VAR 0 3
19680: PUSH
19681: LD_INT 13
19683: PUSH
19684: LD_INT 14
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: ST_TO_ADDR
19691: GO 20062
19693: LD_INT 31
19695: DOUBLE
19696: EQUAL
19697: IFTRUE 19701
19699: GO 19719
19701: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19702: LD_ADDR_VAR 0 3
19706: PUSH
19707: LD_INT 13
19709: PUSH
19710: LD_INT 14
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: ST_TO_ADDR
19717: GO 20062
19719: LD_INT 26
19721: DOUBLE
19722: EQUAL
19723: IFTRUE 19727
19725: GO 19745
19727: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_INT 13
19735: PUSH
19736: LD_INT 14
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: ST_TO_ADDR
19743: GO 20062
19745: LD_INT 42
19747: DOUBLE
19748: EQUAL
19749: IFTRUE 19753
19751: GO 19779
19753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19754: LD_ADDR_VAR 0 3
19758: PUSH
19759: LD_INT 21
19761: PUSH
19762: LD_INT 22
19764: PUSH
19765: LD_INT 23
19767: PUSH
19768: LD_INT 24
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: ST_TO_ADDR
19777: GO 20062
19779: LD_INT 43
19781: DOUBLE
19782: EQUAL
19783: IFTRUE 19787
19785: GO 19813
19787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19788: LD_ADDR_VAR 0 3
19792: PUSH
19793: LD_INT 21
19795: PUSH
19796: LD_INT 22
19798: PUSH
19799: LD_INT 23
19801: PUSH
19802: LD_INT 24
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: ST_TO_ADDR
19811: GO 20062
19813: LD_INT 44
19815: DOUBLE
19816: EQUAL
19817: IFTRUE 19821
19819: GO 19847
19821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19822: LD_ADDR_VAR 0 3
19826: PUSH
19827: LD_INT 21
19829: PUSH
19830: LD_INT 22
19832: PUSH
19833: LD_INT 23
19835: PUSH
19836: LD_INT 24
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: ST_TO_ADDR
19845: GO 20062
19847: LD_INT 45
19849: DOUBLE
19850: EQUAL
19851: IFTRUE 19855
19853: GO 19881
19855: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19856: LD_ADDR_VAR 0 3
19860: PUSH
19861: LD_INT 21
19863: PUSH
19864: LD_INT 22
19866: PUSH
19867: LD_INT 23
19869: PUSH
19870: LD_INT 24
19872: PUSH
19873: EMPTY
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: ST_TO_ADDR
19879: GO 20062
19881: LD_INT 49
19883: DOUBLE
19884: EQUAL
19885: IFTRUE 19889
19887: GO 19915
19889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19890: LD_ADDR_VAR 0 3
19894: PUSH
19895: LD_INT 21
19897: PUSH
19898: LD_INT 22
19900: PUSH
19901: LD_INT 23
19903: PUSH
19904: LD_INT 24
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: ST_TO_ADDR
19913: GO 20062
19915: LD_INT 51
19917: DOUBLE
19918: EQUAL
19919: IFTRUE 19923
19921: GO 19949
19923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19924: LD_ADDR_VAR 0 3
19928: PUSH
19929: LD_INT 21
19931: PUSH
19932: LD_INT 22
19934: PUSH
19935: LD_INT 23
19937: PUSH
19938: LD_INT 24
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: ST_TO_ADDR
19947: GO 20062
19949: LD_INT 52
19951: DOUBLE
19952: EQUAL
19953: IFTRUE 19957
19955: GO 19983
19957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19958: LD_ADDR_VAR 0 3
19962: PUSH
19963: LD_INT 21
19965: PUSH
19966: LD_INT 22
19968: PUSH
19969: LD_INT 23
19971: PUSH
19972: LD_INT 24
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: ST_TO_ADDR
19981: GO 20062
19983: LD_INT 53
19985: DOUBLE
19986: EQUAL
19987: IFTRUE 19991
19989: GO 20009
19991: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19992: LD_ADDR_VAR 0 3
19996: PUSH
19997: LD_INT 23
19999: PUSH
20000: LD_INT 24
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: ST_TO_ADDR
20007: GO 20062
20009: LD_INT 46
20011: DOUBLE
20012: EQUAL
20013: IFTRUE 20017
20015: GO 20035
20017: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_INT 23
20025: PUSH
20026: LD_INT 24
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20062
20035: LD_INT 47
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20061
20043: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 23
20051: PUSH
20052: LD_INT 24
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20062
20061: POP
// result := ( chassis in result ) ;
20062: LD_ADDR_VAR 0 3
20066: PUSH
20067: LD_VAR 0 1
20071: PUSH
20072: LD_VAR 0 3
20076: IN
20077: ST_TO_ADDR
// end ;
20078: LD_VAR 0 3
20082: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20083: LD_INT 0
20085: PPUSH
20086: PPUSH
20087: PPUSH
20088: PPUSH
20089: PPUSH
20090: PPUSH
20091: PPUSH
// result := array ;
20092: LD_ADDR_VAR 0 5
20096: PUSH
20097: LD_VAR 0 1
20101: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20102: LD_VAR 0 1
20106: NOT
20107: PUSH
20108: LD_VAR 0 2
20112: NOT
20113: OR
20114: PUSH
20115: LD_VAR 0 3
20119: NOT
20120: OR
20121: PUSH
20122: LD_VAR 0 2
20126: PUSH
20127: LD_VAR 0 1
20131: GREATER
20132: OR
20133: PUSH
20134: LD_VAR 0 3
20138: PUSH
20139: LD_VAR 0 1
20143: GREATER
20144: OR
20145: IFFALSE 20149
// exit ;
20147: GO 20445
// if direction then
20149: LD_VAR 0 4
20153: IFFALSE 20217
// begin d := 1 ;
20155: LD_ADDR_VAR 0 9
20159: PUSH
20160: LD_INT 1
20162: ST_TO_ADDR
// if i_from > i_to then
20163: LD_VAR 0 2
20167: PUSH
20168: LD_VAR 0 3
20172: GREATER
20173: IFFALSE 20199
// length := ( array - i_from ) + i_to else
20175: LD_ADDR_VAR 0 11
20179: PUSH
20180: LD_VAR 0 1
20184: PUSH
20185: LD_VAR 0 2
20189: MINUS
20190: PUSH
20191: LD_VAR 0 3
20195: PLUS
20196: ST_TO_ADDR
20197: GO 20215
// length := i_to - i_from ;
20199: LD_ADDR_VAR 0 11
20203: PUSH
20204: LD_VAR 0 3
20208: PUSH
20209: LD_VAR 0 2
20213: MINUS
20214: ST_TO_ADDR
// end else
20215: GO 20278
// begin d := - 1 ;
20217: LD_ADDR_VAR 0 9
20221: PUSH
20222: LD_INT 1
20224: NEG
20225: ST_TO_ADDR
// if i_from > i_to then
20226: LD_VAR 0 2
20230: PUSH
20231: LD_VAR 0 3
20235: GREATER
20236: IFFALSE 20256
// length := i_from - i_to else
20238: LD_ADDR_VAR 0 11
20242: PUSH
20243: LD_VAR 0 2
20247: PUSH
20248: LD_VAR 0 3
20252: MINUS
20253: ST_TO_ADDR
20254: GO 20278
// length := ( array - i_to ) + i_from ;
20256: LD_ADDR_VAR 0 11
20260: PUSH
20261: LD_VAR 0 1
20265: PUSH
20266: LD_VAR 0 3
20270: MINUS
20271: PUSH
20272: LD_VAR 0 2
20276: PLUS
20277: ST_TO_ADDR
// end ; if not length then
20278: LD_VAR 0 11
20282: NOT
20283: IFFALSE 20287
// exit ;
20285: GO 20445
// tmp := array ;
20287: LD_ADDR_VAR 0 10
20291: PUSH
20292: LD_VAR 0 1
20296: ST_TO_ADDR
// for i = 1 to length do
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: DOUBLE
20303: LD_INT 1
20305: DEC
20306: ST_TO_ADDR
20307: LD_VAR 0 11
20311: PUSH
20312: FOR_TO
20313: IFFALSE 20433
// begin for j = 1 to array do
20315: LD_ADDR_VAR 0 7
20319: PUSH
20320: DOUBLE
20321: LD_INT 1
20323: DEC
20324: ST_TO_ADDR
20325: LD_VAR 0 1
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20419
// begin k := j + d ;
20333: LD_ADDR_VAR 0 8
20337: PUSH
20338: LD_VAR 0 7
20342: PUSH
20343: LD_VAR 0 9
20347: PLUS
20348: ST_TO_ADDR
// if k > array then
20349: LD_VAR 0 8
20353: PUSH
20354: LD_VAR 0 1
20358: GREATER
20359: IFFALSE 20369
// k := 1 ;
20361: LD_ADDR_VAR 0 8
20365: PUSH
20366: LD_INT 1
20368: ST_TO_ADDR
// if not k then
20369: LD_VAR 0 8
20373: NOT
20374: IFFALSE 20386
// k := array ;
20376: LD_ADDR_VAR 0 8
20380: PUSH
20381: LD_VAR 0 1
20385: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20386: LD_ADDR_VAR 0 10
20390: PUSH
20391: LD_VAR 0 10
20395: PPUSH
20396: LD_VAR 0 8
20400: PPUSH
20401: LD_VAR 0 1
20405: PUSH
20406: LD_VAR 0 7
20410: ARRAY
20411: PPUSH
20412: CALL_OW 1
20416: ST_TO_ADDR
// end ;
20417: GO 20330
20419: POP
20420: POP
// array := tmp ;
20421: LD_ADDR_VAR 0 1
20425: PUSH
20426: LD_VAR 0 10
20430: ST_TO_ADDR
// end ;
20431: GO 20312
20433: POP
20434: POP
// result := array ;
20435: LD_ADDR_VAR 0 5
20439: PUSH
20440: LD_VAR 0 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 5
20449: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20450: LD_INT 0
20452: PPUSH
20453: PPUSH
// result := 0 ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 0
20461: ST_TO_ADDR
// if not array or not value in array then
20462: LD_VAR 0 1
20466: NOT
20467: PUSH
20468: LD_VAR 0 2
20472: PUSH
20473: LD_VAR 0 1
20477: IN
20478: NOT
20479: OR
20480: IFFALSE 20484
// exit ;
20482: GO 20538
// for i = 1 to array do
20484: LD_ADDR_VAR 0 4
20488: PUSH
20489: DOUBLE
20490: LD_INT 1
20492: DEC
20493: ST_TO_ADDR
20494: LD_VAR 0 1
20498: PUSH
20499: FOR_TO
20500: IFFALSE 20536
// if value = array [ i ] then
20502: LD_VAR 0 2
20506: PUSH
20507: LD_VAR 0 1
20511: PUSH
20512: LD_VAR 0 4
20516: ARRAY
20517: EQUAL
20518: IFFALSE 20534
// begin result := i ;
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_VAR 0 4
20529: ST_TO_ADDR
// exit ;
20530: POP
20531: POP
20532: GO 20538
// end ;
20534: GO 20499
20536: POP
20537: POP
// end ;
20538: LD_VAR 0 3
20542: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20543: LD_INT 0
20545: PPUSH
// vc_chassis := chassis ;
20546: LD_ADDR_OWVAR 37
20550: PUSH
20551: LD_VAR 0 1
20555: ST_TO_ADDR
// vc_engine := engine ;
20556: LD_ADDR_OWVAR 39
20560: PUSH
20561: LD_VAR 0 2
20565: ST_TO_ADDR
// vc_control := control ;
20566: LD_ADDR_OWVAR 38
20570: PUSH
20571: LD_VAR 0 3
20575: ST_TO_ADDR
// vc_weapon := weapon ;
20576: LD_ADDR_OWVAR 40
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20586: LD_ADDR_OWVAR 41
20590: PUSH
20591: LD_VAR 0 5
20595: ST_TO_ADDR
// end ;
20596: LD_VAR 0 6
20600: RET
// export function WantPlant ( unit ) ; var task ; begin
20601: LD_INT 0
20603: PPUSH
20604: PPUSH
// result := false ;
20605: LD_ADDR_VAR 0 2
20609: PUSH
20610: LD_INT 0
20612: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20613: LD_ADDR_VAR 0 3
20617: PUSH
20618: LD_VAR 0 1
20622: PPUSH
20623: CALL_OW 437
20627: ST_TO_ADDR
// if task then
20628: LD_VAR 0 3
20632: IFFALSE 20660
// if task [ 1 ] [ 1 ] = p then
20634: LD_VAR 0 3
20638: PUSH
20639: LD_INT 1
20641: ARRAY
20642: PUSH
20643: LD_INT 1
20645: ARRAY
20646: PUSH
20647: LD_STRING p
20649: EQUAL
20650: IFFALSE 20660
// result := true ;
20652: LD_ADDR_VAR 0 2
20656: PUSH
20657: LD_INT 1
20659: ST_TO_ADDR
// end ;
20660: LD_VAR 0 2
20664: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20665: LD_INT 0
20667: PPUSH
20668: PPUSH
20669: PPUSH
20670: PPUSH
// if pos < 1 then
20671: LD_VAR 0 2
20675: PUSH
20676: LD_INT 1
20678: LESS
20679: IFFALSE 20683
// exit ;
20681: GO 20986
// if pos = 1 then
20683: LD_VAR 0 2
20687: PUSH
20688: LD_INT 1
20690: EQUAL
20691: IFFALSE 20724
// result := Replace ( arr , pos [ 1 ] , value ) else
20693: LD_ADDR_VAR 0 4
20697: PUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: LD_VAR 0 2
20707: PUSH
20708: LD_INT 1
20710: ARRAY
20711: PPUSH
20712: LD_VAR 0 3
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
20722: GO 20986
// begin tmp := arr ;
20724: LD_ADDR_VAR 0 6
20728: PUSH
20729: LD_VAR 0 1
20733: ST_TO_ADDR
// s_arr := [ tmp ] ;
20734: LD_ADDR_VAR 0 7
20738: PUSH
20739: LD_VAR 0 6
20743: PUSH
20744: EMPTY
20745: LIST
20746: ST_TO_ADDR
// for i = 1 to pos - 1 do
20747: LD_ADDR_VAR 0 5
20751: PUSH
20752: DOUBLE
20753: LD_INT 1
20755: DEC
20756: ST_TO_ADDR
20757: LD_VAR 0 2
20761: PUSH
20762: LD_INT 1
20764: MINUS
20765: PUSH
20766: FOR_TO
20767: IFFALSE 20812
// begin tmp := tmp [ pos [ i ] ] ;
20769: LD_ADDR_VAR 0 6
20773: PUSH
20774: LD_VAR 0 6
20778: PUSH
20779: LD_VAR 0 2
20783: PUSH
20784: LD_VAR 0 5
20788: ARRAY
20789: ARRAY
20790: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20791: LD_ADDR_VAR 0 7
20795: PUSH
20796: LD_VAR 0 7
20800: PUSH
20801: LD_VAR 0 6
20805: PUSH
20806: EMPTY
20807: LIST
20808: ADD
20809: ST_TO_ADDR
// end ;
20810: GO 20766
20812: POP
20813: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20814: LD_ADDR_VAR 0 6
20818: PUSH
20819: LD_VAR 0 6
20823: PPUSH
20824: LD_VAR 0 2
20828: PUSH
20829: LD_VAR 0 2
20833: ARRAY
20834: PPUSH
20835: LD_VAR 0 3
20839: PPUSH
20840: CALL_OW 1
20844: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20845: LD_ADDR_VAR 0 7
20849: PUSH
20850: LD_VAR 0 7
20854: PPUSH
20855: LD_VAR 0 7
20859: PPUSH
20860: LD_VAR 0 6
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// for i = s_arr downto 2 do
20870: LD_ADDR_VAR 0 5
20874: PUSH
20875: DOUBLE
20876: LD_VAR 0 7
20880: INC
20881: ST_TO_ADDR
20882: LD_INT 2
20884: PUSH
20885: FOR_DOWNTO
20886: IFFALSE 20970
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20888: LD_ADDR_VAR 0 6
20892: PUSH
20893: LD_VAR 0 7
20897: PUSH
20898: LD_VAR 0 5
20902: PUSH
20903: LD_INT 1
20905: MINUS
20906: ARRAY
20907: PPUSH
20908: LD_VAR 0 2
20912: PUSH
20913: LD_VAR 0 5
20917: PUSH
20918: LD_INT 1
20920: MINUS
20921: ARRAY
20922: PPUSH
20923: LD_VAR 0 7
20927: PUSH
20928: LD_VAR 0 5
20932: ARRAY
20933: PPUSH
20934: CALL_OW 1
20938: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20939: LD_ADDR_VAR 0 7
20943: PUSH
20944: LD_VAR 0 7
20948: PPUSH
20949: LD_VAR 0 5
20953: PUSH
20954: LD_INT 1
20956: MINUS
20957: PPUSH
20958: LD_VAR 0 6
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// end ;
20968: GO 20885
20970: POP
20971: POP
// result := s_arr [ 1 ] ;
20972: LD_ADDR_VAR 0 4
20976: PUSH
20977: LD_VAR 0 7
20981: PUSH
20982: LD_INT 1
20984: ARRAY
20985: ST_TO_ADDR
// end ; end ;
20986: LD_VAR 0 4
20990: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20991: LD_INT 0
20993: PPUSH
20994: PPUSH
// if not list then
20995: LD_VAR 0 1
20999: NOT
21000: IFFALSE 21004
// exit ;
21002: GO 21095
// i := list [ pos1 ] ;
21004: LD_ADDR_VAR 0 5
21008: PUSH
21009: LD_VAR 0 1
21013: PUSH
21014: LD_VAR 0 2
21018: ARRAY
21019: ST_TO_ADDR
// if not i then
21020: LD_VAR 0 5
21024: NOT
21025: IFFALSE 21029
// exit ;
21027: GO 21095
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21029: LD_ADDR_VAR 0 1
21033: PUSH
21034: LD_VAR 0 1
21038: PPUSH
21039: LD_VAR 0 2
21043: PPUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 3
21053: ARRAY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21060: LD_ADDR_VAR 0 1
21064: PUSH
21065: LD_VAR 0 1
21069: PPUSH
21070: LD_VAR 0 3
21074: PPUSH
21075: LD_VAR 0 5
21079: PPUSH
21080: CALL_OW 1
21084: ST_TO_ADDR
// result := list ;
21085: LD_ADDR_VAR 0 4
21089: PUSH
21090: LD_VAR 0 1
21094: ST_TO_ADDR
// end ;
21095: LD_VAR 0 4
21099: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21100: LD_INT 0
21102: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21103: LD_ADDR_VAR 0 5
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 250
21117: PPUSH
21118: LD_VAR 0 1
21122: PPUSH
21123: CALL_OW 251
21127: PPUSH
21128: LD_VAR 0 2
21132: PPUSH
21133: LD_VAR 0 3
21137: PPUSH
21138: LD_VAR 0 4
21142: PPUSH
21143: CALL 21153 0 5
21147: ST_TO_ADDR
// end ;
21148: LD_VAR 0 5
21152: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21153: LD_INT 0
21155: PPUSH
21156: PPUSH
21157: PPUSH
21158: PPUSH
// if not list then
21159: LD_VAR 0 3
21163: NOT
21164: IFFALSE 21168
// exit ;
21166: GO 21556
// result := [ ] ;
21168: LD_ADDR_VAR 0 6
21172: PUSH
21173: EMPTY
21174: ST_TO_ADDR
// for i in list do
21175: LD_ADDR_VAR 0 7
21179: PUSH
21180: LD_VAR 0 3
21184: PUSH
21185: FOR_IN
21186: IFFALSE 21388
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21188: LD_ADDR_VAR 0 9
21192: PUSH
21193: LD_VAR 0 7
21197: PPUSH
21198: LD_VAR 0 1
21202: PPUSH
21203: LD_VAR 0 2
21207: PPUSH
21208: CALL_OW 297
21212: ST_TO_ADDR
// if not result then
21213: LD_VAR 0 6
21217: NOT
21218: IFFALSE 21244
// result := [ [ i , tmp ] ] else
21220: LD_ADDR_VAR 0 6
21224: PUSH
21225: LD_VAR 0 7
21229: PUSH
21230: LD_VAR 0 9
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: ST_TO_ADDR
21242: GO 21386
// begin if result [ result ] [ 2 ] < tmp then
21244: LD_VAR 0 6
21248: PUSH
21249: LD_VAR 0 6
21253: ARRAY
21254: PUSH
21255: LD_INT 2
21257: ARRAY
21258: PUSH
21259: LD_VAR 0 9
21263: LESS
21264: IFFALSE 21306
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21266: LD_ADDR_VAR 0 6
21270: PUSH
21271: LD_VAR 0 6
21275: PPUSH
21276: LD_VAR 0 6
21280: PUSH
21281: LD_INT 1
21283: PLUS
21284: PPUSH
21285: LD_VAR 0 7
21289: PUSH
21290: LD_VAR 0 9
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PPUSH
21299: CALL_OW 2
21303: ST_TO_ADDR
21304: GO 21386
// for j = 1 to result do
21306: LD_ADDR_VAR 0 8
21310: PUSH
21311: DOUBLE
21312: LD_INT 1
21314: DEC
21315: ST_TO_ADDR
21316: LD_VAR 0 6
21320: PUSH
21321: FOR_TO
21322: IFFALSE 21384
// begin if tmp < result [ j ] [ 2 ] then
21324: LD_VAR 0 9
21328: PUSH
21329: LD_VAR 0 6
21333: PUSH
21334: LD_VAR 0 8
21338: ARRAY
21339: PUSH
21340: LD_INT 2
21342: ARRAY
21343: LESS
21344: IFFALSE 21382
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21346: LD_ADDR_VAR 0 6
21350: PUSH
21351: LD_VAR 0 6
21355: PPUSH
21356: LD_VAR 0 8
21360: PPUSH
21361: LD_VAR 0 7
21365: PUSH
21366: LD_VAR 0 9
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 2
21379: ST_TO_ADDR
// break ;
21380: GO 21384
// end ; end ;
21382: GO 21321
21384: POP
21385: POP
// end ; end ;
21386: GO 21185
21388: POP
21389: POP
// if result and not asc then
21390: LD_VAR 0 6
21394: PUSH
21395: LD_VAR 0 4
21399: NOT
21400: AND
21401: IFFALSE 21476
// begin tmp := result ;
21403: LD_ADDR_VAR 0 9
21407: PUSH
21408: LD_VAR 0 6
21412: ST_TO_ADDR
// for i = tmp downto 1 do
21413: LD_ADDR_VAR 0 7
21417: PUSH
21418: DOUBLE
21419: LD_VAR 0 9
21423: INC
21424: ST_TO_ADDR
21425: LD_INT 1
21427: PUSH
21428: FOR_DOWNTO
21429: IFFALSE 21474
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21431: LD_ADDR_VAR 0 6
21435: PUSH
21436: LD_VAR 0 6
21440: PPUSH
21441: LD_VAR 0 9
21445: PUSH
21446: LD_VAR 0 7
21450: MINUS
21451: PUSH
21452: LD_INT 1
21454: PLUS
21455: PPUSH
21456: LD_VAR 0 9
21460: PUSH
21461: LD_VAR 0 7
21465: ARRAY
21466: PPUSH
21467: CALL_OW 1
21471: ST_TO_ADDR
21472: GO 21428
21474: POP
21475: POP
// end ; tmp := [ ] ;
21476: LD_ADDR_VAR 0 9
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// if mode then
21483: LD_VAR 0 5
21487: IFFALSE 21556
// begin for i = 1 to result do
21489: LD_ADDR_VAR 0 7
21493: PUSH
21494: DOUBLE
21495: LD_INT 1
21497: DEC
21498: ST_TO_ADDR
21499: LD_VAR 0 6
21503: PUSH
21504: FOR_TO
21505: IFFALSE 21544
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21507: LD_ADDR_VAR 0 9
21511: PUSH
21512: LD_VAR 0 9
21516: PPUSH
21517: LD_VAR 0 7
21521: PPUSH
21522: LD_VAR 0 6
21526: PUSH
21527: LD_VAR 0 7
21531: ARRAY
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
21542: GO 21504
21544: POP
21545: POP
// result := tmp ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 9
21555: ST_TO_ADDR
// end ; end ;
21556: LD_VAR 0 6
21560: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21561: LD_INT 0
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
21567: PPUSH
21568: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21569: LD_ADDR_VAR 0 5
21573: PUSH
21574: LD_INT 0
21576: PUSH
21577: LD_INT 0
21579: PUSH
21580: LD_INT 0
21582: PUSH
21583: EMPTY
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: ST_TO_ADDR
// if not x or not y then
21591: LD_VAR 0 2
21595: NOT
21596: PUSH
21597: LD_VAR 0 3
21601: NOT
21602: OR
21603: IFFALSE 21607
// exit ;
21605: GO 23253
// if not range then
21607: LD_VAR 0 4
21611: NOT
21612: IFFALSE 21622
// range := 10 ;
21614: LD_ADDR_VAR 0 4
21618: PUSH
21619: LD_INT 10
21621: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21622: LD_ADDR_VAR 0 8
21626: PUSH
21627: LD_INT 81
21629: PUSH
21630: LD_VAR 0 1
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 92
21641: PUSH
21642: LD_VAR 0 2
21646: PUSH
21647: LD_VAR 0 3
21651: PUSH
21652: LD_VAR 0 4
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: PUSH
21663: LD_INT 3
21665: PUSH
21666: LD_INT 21
21668: PUSH
21669: LD_INT 3
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: PPUSH
21685: CALL_OW 69
21689: ST_TO_ADDR
// if not tmp then
21690: LD_VAR 0 8
21694: NOT
21695: IFFALSE 21699
// exit ;
21697: GO 23253
// for i in tmp do
21699: LD_ADDR_VAR 0 6
21703: PUSH
21704: LD_VAR 0 8
21708: PUSH
21709: FOR_IN
21710: IFFALSE 23228
// begin points := [ 0 , 0 , 0 ] ;
21712: LD_ADDR_VAR 0 9
21716: PUSH
21717: LD_INT 0
21719: PUSH
21720: LD_INT 0
21722: PUSH
21723: LD_INT 0
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: LIST
21730: ST_TO_ADDR
// bpoints := 1 ;
21731: LD_ADDR_VAR 0 10
21735: PUSH
21736: LD_INT 1
21738: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21739: LD_VAR 0 6
21743: PPUSH
21744: CALL_OW 247
21748: PUSH
21749: LD_INT 1
21751: DOUBLE
21752: EQUAL
21753: IFTRUE 21757
21755: GO 22335
21757: POP
// begin if GetClass ( i ) = 1 then
21758: LD_VAR 0 6
21762: PPUSH
21763: CALL_OW 257
21767: PUSH
21768: LD_INT 1
21770: EQUAL
21771: IFFALSE 21792
// points := [ 10 , 5 , 3 ] ;
21773: LD_ADDR_VAR 0 9
21777: PUSH
21778: LD_INT 10
21780: PUSH
21781: LD_INT 5
21783: PUSH
21784: LD_INT 3
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: LIST
21791: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21792: LD_VAR 0 6
21796: PPUSH
21797: CALL_OW 257
21801: PUSH
21802: LD_INT 2
21804: PUSH
21805: LD_INT 3
21807: PUSH
21808: LD_INT 4
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: IN
21816: IFFALSE 21837
// points := [ 3 , 2 , 1 ] ;
21818: LD_ADDR_VAR 0 9
21822: PUSH
21823: LD_INT 3
21825: PUSH
21826: LD_INT 2
21828: PUSH
21829: LD_INT 1
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21837: LD_VAR 0 6
21841: PPUSH
21842: CALL_OW 257
21846: PUSH
21847: LD_INT 5
21849: EQUAL
21850: IFFALSE 21871
// points := [ 130 , 5 , 2 ] ;
21852: LD_ADDR_VAR 0 9
21856: PUSH
21857: LD_INT 130
21859: PUSH
21860: LD_INT 5
21862: PUSH
21863: LD_INT 2
21865: PUSH
21866: EMPTY
21867: LIST
21868: LIST
21869: LIST
21870: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21871: LD_VAR 0 6
21875: PPUSH
21876: CALL_OW 257
21880: PUSH
21881: LD_INT 8
21883: EQUAL
21884: IFFALSE 21905
// points := [ 35 , 35 , 30 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 35
21893: PUSH
21894: LD_INT 35
21896: PUSH
21897: LD_INT 30
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21905: LD_VAR 0 6
21909: PPUSH
21910: CALL_OW 257
21914: PUSH
21915: LD_INT 9
21917: EQUAL
21918: IFFALSE 21939
// points := [ 20 , 55 , 40 ] ;
21920: LD_ADDR_VAR 0 9
21924: PUSH
21925: LD_INT 20
21927: PUSH
21928: LD_INT 55
21930: PUSH
21931: LD_INT 40
21933: PUSH
21934: EMPTY
21935: LIST
21936: LIST
21937: LIST
21938: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21939: LD_VAR 0 6
21943: PPUSH
21944: CALL_OW 257
21948: PUSH
21949: LD_INT 12
21951: PUSH
21952: LD_INT 16
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: IN
21959: IFFALSE 21980
// points := [ 5 , 3 , 2 ] ;
21961: LD_ADDR_VAR 0 9
21965: PUSH
21966: LD_INT 5
21968: PUSH
21969: LD_INT 3
21971: PUSH
21972: LD_INT 2
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21980: LD_VAR 0 6
21984: PPUSH
21985: CALL_OW 257
21989: PUSH
21990: LD_INT 17
21992: EQUAL
21993: IFFALSE 22014
// points := [ 100 , 50 , 75 ] ;
21995: LD_ADDR_VAR 0 9
21999: PUSH
22000: LD_INT 100
22002: PUSH
22003: LD_INT 50
22005: PUSH
22006: LD_INT 75
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: LIST
22013: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22014: LD_VAR 0 6
22018: PPUSH
22019: CALL_OW 257
22023: PUSH
22024: LD_INT 15
22026: EQUAL
22027: IFFALSE 22048
// points := [ 10 , 5 , 3 ] ;
22029: LD_ADDR_VAR 0 9
22033: PUSH
22034: LD_INT 10
22036: PUSH
22037: LD_INT 5
22039: PUSH
22040: LD_INT 3
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: LIST
22047: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22048: LD_VAR 0 6
22052: PPUSH
22053: CALL_OW 257
22057: PUSH
22058: LD_INT 14
22060: EQUAL
22061: IFFALSE 22082
// points := [ 10 , 0 , 0 ] ;
22063: LD_ADDR_VAR 0 9
22067: PUSH
22068: LD_INT 10
22070: PUSH
22071: LD_INT 0
22073: PUSH
22074: LD_INT 0
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: LIST
22081: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 257
22091: PUSH
22092: LD_INT 11
22094: EQUAL
22095: IFFALSE 22116
// points := [ 30 , 10 , 5 ] ;
22097: LD_ADDR_VAR 0 9
22101: PUSH
22102: LD_INT 30
22104: PUSH
22105: LD_INT 10
22107: PUSH
22108: LD_INT 5
22110: PUSH
22111: EMPTY
22112: LIST
22113: LIST
22114: LIST
22115: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22116: LD_VAR 0 1
22120: PPUSH
22121: LD_INT 5
22123: PPUSH
22124: CALL_OW 321
22128: PUSH
22129: LD_INT 2
22131: EQUAL
22132: IFFALSE 22149
// bpoints := bpoints * 1.8 ;
22134: LD_ADDR_VAR 0 10
22138: PUSH
22139: LD_VAR 0 10
22143: PUSH
22144: LD_REAL  1.80000000000000E+0000
22147: MUL
22148: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22149: LD_VAR 0 6
22153: PPUSH
22154: CALL_OW 257
22158: PUSH
22159: LD_INT 1
22161: PUSH
22162: LD_INT 2
22164: PUSH
22165: LD_INT 3
22167: PUSH
22168: LD_INT 4
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: IN
22177: PUSH
22178: LD_VAR 0 1
22182: PPUSH
22183: LD_INT 51
22185: PPUSH
22186: CALL_OW 321
22190: PUSH
22191: LD_INT 2
22193: EQUAL
22194: AND
22195: IFFALSE 22212
// bpoints := bpoints * 1.2 ;
22197: LD_ADDR_VAR 0 10
22201: PUSH
22202: LD_VAR 0 10
22206: PUSH
22207: LD_REAL  1.20000000000000E+0000
22210: MUL
22211: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22212: LD_VAR 0 6
22216: PPUSH
22217: CALL_OW 257
22221: PUSH
22222: LD_INT 5
22224: PUSH
22225: LD_INT 7
22227: PUSH
22228: LD_INT 9
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: LIST
22235: IN
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: LD_INT 52
22244: PPUSH
22245: CALL_OW 321
22249: PUSH
22250: LD_INT 2
22252: EQUAL
22253: AND
22254: IFFALSE 22271
// bpoints := bpoints * 1.5 ;
22256: LD_ADDR_VAR 0 10
22260: PUSH
22261: LD_VAR 0 10
22265: PUSH
22266: LD_REAL  1.50000000000000E+0000
22269: MUL
22270: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22271: LD_VAR 0 1
22275: PPUSH
22276: LD_INT 66
22278: PPUSH
22279: CALL_OW 321
22283: PUSH
22284: LD_INT 2
22286: EQUAL
22287: IFFALSE 22304
// bpoints := bpoints * 1.1 ;
22289: LD_ADDR_VAR 0 10
22293: PUSH
22294: LD_VAR 0 10
22298: PUSH
22299: LD_REAL  1.10000000000000E+0000
22302: MUL
22303: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22304: LD_ADDR_VAR 0 10
22308: PUSH
22309: LD_VAR 0 10
22313: PUSH
22314: LD_VAR 0 6
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: CALL_OW 259
22326: PUSH
22327: LD_REAL  1.15000000000000E+0000
22330: MUL
22331: MUL
22332: ST_TO_ADDR
// end ; unit_vehicle :
22333: GO 23157
22335: LD_INT 2
22337: DOUBLE
22338: EQUAL
22339: IFTRUE 22343
22341: GO 23145
22343: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22344: LD_VAR 0 6
22348: PPUSH
22349: CALL_OW 264
22353: PUSH
22354: LD_INT 2
22356: PUSH
22357: LD_INT 42
22359: PUSH
22360: LD_INT 24
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: IN
22368: IFFALSE 22389
// points := [ 25 , 5 , 3 ] ;
22370: LD_ADDR_VAR 0 9
22374: PUSH
22375: LD_INT 25
22377: PUSH
22378: LD_INT 5
22380: PUSH
22381: LD_INT 3
22383: PUSH
22384: EMPTY
22385: LIST
22386: LIST
22387: LIST
22388: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22389: LD_VAR 0 6
22393: PPUSH
22394: CALL_OW 264
22398: PUSH
22399: LD_INT 4
22401: PUSH
22402: LD_INT 43
22404: PUSH
22405: LD_INT 25
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: IN
22413: IFFALSE 22434
// points := [ 40 , 15 , 5 ] ;
22415: LD_ADDR_VAR 0 9
22419: PUSH
22420: LD_INT 40
22422: PUSH
22423: LD_INT 15
22425: PUSH
22426: LD_INT 5
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22434: LD_VAR 0 6
22438: PPUSH
22439: CALL_OW 264
22443: PUSH
22444: LD_INT 3
22446: PUSH
22447: LD_INT 23
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: IN
22454: IFFALSE 22475
// points := [ 7 , 25 , 8 ] ;
22456: LD_ADDR_VAR 0 9
22460: PUSH
22461: LD_INT 7
22463: PUSH
22464: LD_INT 25
22466: PUSH
22467: LD_INT 8
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: LIST
22474: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22475: LD_VAR 0 6
22479: PPUSH
22480: CALL_OW 264
22484: PUSH
22485: LD_INT 5
22487: PUSH
22488: LD_INT 27
22490: PUSH
22491: LD_INT 44
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: LIST
22498: IN
22499: IFFALSE 22520
// points := [ 14 , 50 , 16 ] ;
22501: LD_ADDR_VAR 0 9
22505: PUSH
22506: LD_INT 14
22508: PUSH
22509: LD_INT 50
22511: PUSH
22512: LD_INT 16
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: LIST
22519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22520: LD_VAR 0 6
22524: PPUSH
22525: CALL_OW 264
22529: PUSH
22530: LD_INT 6
22532: PUSH
22533: LD_INT 46
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: IN
22540: IFFALSE 22561
// points := [ 32 , 120 , 70 ] ;
22542: LD_ADDR_VAR 0 9
22546: PUSH
22547: LD_INT 32
22549: PUSH
22550: LD_INT 120
22552: PUSH
22553: LD_INT 70
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: LIST
22560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22561: LD_VAR 0 6
22565: PPUSH
22566: CALL_OW 264
22570: PUSH
22571: LD_INT 7
22573: PUSH
22574: LD_INT 28
22576: PUSH
22577: LD_INT 45
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: IN
22585: IFFALSE 22606
// points := [ 35 , 20 , 45 ] ;
22587: LD_ADDR_VAR 0 9
22591: PUSH
22592: LD_INT 35
22594: PUSH
22595: LD_INT 20
22597: PUSH
22598: LD_INT 45
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: LIST
22605: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22606: LD_VAR 0 6
22610: PPUSH
22611: CALL_OW 264
22615: PUSH
22616: LD_INT 47
22618: PUSH
22619: EMPTY
22620: LIST
22621: IN
22622: IFFALSE 22643
// points := [ 67 , 45 , 75 ] ;
22624: LD_ADDR_VAR 0 9
22628: PUSH
22629: LD_INT 67
22631: PUSH
22632: LD_INT 45
22634: PUSH
22635: LD_INT 75
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: LIST
22642: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22643: LD_VAR 0 6
22647: PPUSH
22648: CALL_OW 264
22652: PUSH
22653: LD_INT 26
22655: PUSH
22656: EMPTY
22657: LIST
22658: IN
22659: IFFALSE 22680
// points := [ 120 , 30 , 80 ] ;
22661: LD_ADDR_VAR 0 9
22665: PUSH
22666: LD_INT 120
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 80
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22680: LD_VAR 0 6
22684: PPUSH
22685: CALL_OW 264
22689: PUSH
22690: LD_INT 22
22692: PUSH
22693: EMPTY
22694: LIST
22695: IN
22696: IFFALSE 22717
// points := [ 40 , 1 , 1 ] ;
22698: LD_ADDR_VAR 0 9
22702: PUSH
22703: LD_INT 40
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: LD_INT 1
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22717: LD_VAR 0 6
22721: PPUSH
22722: CALL_OW 264
22726: PUSH
22727: LD_INT 29
22729: PUSH
22730: EMPTY
22731: LIST
22732: IN
22733: IFFALSE 22754
// points := [ 70 , 200 , 400 ] ;
22735: LD_ADDR_VAR 0 9
22739: PUSH
22740: LD_INT 70
22742: PUSH
22743: LD_INT 200
22745: PUSH
22746: LD_INT 400
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: LIST
22753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22754: LD_VAR 0 6
22758: PPUSH
22759: CALL_OW 264
22763: PUSH
22764: LD_INT 14
22766: PUSH
22767: LD_INT 53
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: IN
22774: IFFALSE 22795
// points := [ 40 , 10 , 20 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 40
22783: PUSH
22784: LD_INT 10
22786: PUSH
22787: LD_INT 20
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 264
22804: PUSH
22805: LD_INT 9
22807: PUSH
22808: EMPTY
22809: LIST
22810: IN
22811: IFFALSE 22832
// points := [ 5 , 70 , 20 ] ;
22813: LD_ADDR_VAR 0 9
22817: PUSH
22818: LD_INT 5
22820: PUSH
22821: LD_INT 70
22823: PUSH
22824: LD_INT 20
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: LIST
22831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22832: LD_VAR 0 6
22836: PPUSH
22837: CALL_OW 264
22841: PUSH
22842: LD_INT 10
22844: PUSH
22845: EMPTY
22846: LIST
22847: IN
22848: IFFALSE 22869
// points := [ 35 , 110 , 70 ] ;
22850: LD_ADDR_VAR 0 9
22854: PUSH
22855: LD_INT 35
22857: PUSH
22858: LD_INT 110
22860: PUSH
22861: LD_INT 70
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: LIST
22868: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22869: LD_VAR 0 6
22873: PPUSH
22874: CALL_OW 265
22878: PUSH
22879: LD_INT 25
22881: EQUAL
22882: IFFALSE 22903
// points := [ 80 , 65 , 100 ] ;
22884: LD_ADDR_VAR 0 9
22888: PUSH
22889: LD_INT 80
22891: PUSH
22892: LD_INT 65
22894: PUSH
22895: LD_INT 100
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: LIST
22902: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 263
22912: PUSH
22913: LD_INT 1
22915: EQUAL
22916: IFFALSE 22951
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22918: LD_ADDR_VAR 0 10
22922: PUSH
22923: LD_VAR 0 10
22927: PUSH
22928: LD_VAR 0 6
22932: PPUSH
22933: CALL_OW 311
22937: PPUSH
22938: LD_INT 3
22940: PPUSH
22941: CALL_OW 259
22945: PUSH
22946: LD_INT 4
22948: MUL
22949: MUL
22950: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22951: LD_VAR 0 6
22955: PPUSH
22956: CALL_OW 263
22960: PUSH
22961: LD_INT 2
22963: EQUAL
22964: IFFALSE 23015
// begin j := IsControledBy ( i ) ;
22966: LD_ADDR_VAR 0 7
22970: PUSH
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 312
22980: ST_TO_ADDR
// if j then
22981: LD_VAR 0 7
22985: IFFALSE 23015
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22987: LD_ADDR_VAR 0 10
22991: PUSH
22992: LD_VAR 0 10
22996: PUSH
22997: LD_VAR 0 7
23001: PPUSH
23002: LD_INT 3
23004: PPUSH
23005: CALL_OW 259
23009: PUSH
23010: LD_INT 3
23012: MUL
23013: MUL
23014: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23015: LD_VAR 0 6
23019: PPUSH
23020: CALL_OW 264
23024: PUSH
23025: LD_INT 5
23027: PUSH
23028: LD_INT 6
23030: PUSH
23031: LD_INT 46
23033: PUSH
23034: LD_INT 44
23036: PUSH
23037: LD_INT 47
23039: PUSH
23040: LD_INT 45
23042: PUSH
23043: LD_INT 28
23045: PUSH
23046: LD_INT 7
23048: PUSH
23049: LD_INT 27
23051: PUSH
23052: LD_INT 29
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: LIST
23065: LIST
23066: IN
23067: PUSH
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_INT 52
23075: PPUSH
23076: CALL_OW 321
23080: PUSH
23081: LD_INT 2
23083: EQUAL
23084: AND
23085: IFFALSE 23102
// bpoints := bpoints * 1.2 ;
23087: LD_ADDR_VAR 0 10
23091: PUSH
23092: LD_VAR 0 10
23096: PUSH
23097: LD_REAL  1.20000000000000E+0000
23100: MUL
23101: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23102: LD_VAR 0 6
23106: PPUSH
23107: CALL_OW 264
23111: PUSH
23112: LD_INT 6
23114: PUSH
23115: LD_INT 46
23117: PUSH
23118: LD_INT 47
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: LIST
23125: IN
23126: IFFALSE 23143
// bpoints := bpoints * 1.2 ;
23128: LD_ADDR_VAR 0 10
23132: PUSH
23133: LD_VAR 0 10
23137: PUSH
23138: LD_REAL  1.20000000000000E+0000
23141: MUL
23142: ST_TO_ADDR
// end ; unit_building :
23143: GO 23157
23145: LD_INT 3
23147: DOUBLE
23148: EQUAL
23149: IFTRUE 23153
23151: GO 23156
23153: POP
// ; end ;
23154: GO 23157
23156: POP
// for j = 1 to 3 do
23157: LD_ADDR_VAR 0 7
23161: PUSH
23162: DOUBLE
23163: LD_INT 1
23165: DEC
23166: ST_TO_ADDR
23167: LD_INT 3
23169: PUSH
23170: FOR_TO
23171: IFFALSE 23224
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23173: LD_ADDR_VAR 0 5
23177: PUSH
23178: LD_VAR 0 5
23182: PPUSH
23183: LD_VAR 0 7
23187: PPUSH
23188: LD_VAR 0 5
23192: PUSH
23193: LD_VAR 0 7
23197: ARRAY
23198: PUSH
23199: LD_VAR 0 9
23203: PUSH
23204: LD_VAR 0 7
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 10
23214: MUL
23215: PLUS
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
23222: GO 23170
23224: POP
23225: POP
// end ;
23226: GO 21709
23228: POP
23229: POP
// result := Replace ( result , 4 , tmp ) ;
23230: LD_ADDR_VAR 0 5
23234: PUSH
23235: LD_VAR 0 5
23239: PPUSH
23240: LD_INT 4
23242: PPUSH
23243: LD_VAR 0 8
23247: PPUSH
23248: CALL_OW 1
23252: ST_TO_ADDR
// end ;
23253: LD_VAR 0 5
23257: RET
// export function DangerAtRange ( unit , range ) ; begin
23258: LD_INT 0
23260: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23261: LD_ADDR_VAR 0 3
23265: PUSH
23266: LD_VAR 0 1
23270: PPUSH
23271: CALL_OW 255
23275: PPUSH
23276: LD_VAR 0 1
23280: PPUSH
23281: CALL_OW 250
23285: PPUSH
23286: LD_VAR 0 1
23290: PPUSH
23291: CALL_OW 251
23295: PPUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: CALL 21561 0 4
23305: ST_TO_ADDR
// end ;
23306: LD_VAR 0 3
23310: RET
// export function DangerInArea ( side , area ) ; begin
23311: LD_INT 0
23313: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_VAR 0 2
23323: PPUSH
23324: LD_INT 81
23326: PUSH
23327: LD_VAR 0 1
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PPUSH
23336: CALL_OW 70
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 3
23345: RET
// export function IsExtension ( b ) ; begin
23346: LD_INT 0
23348: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23349: LD_ADDR_VAR 0 2
23353: PUSH
23354: LD_VAR 0 1
23358: PUSH
23359: LD_INT 23
23361: PUSH
23362: LD_INT 20
23364: PUSH
23365: LD_INT 22
23367: PUSH
23368: LD_INT 17
23370: PUSH
23371: LD_INT 24
23373: PUSH
23374: LD_INT 21
23376: PUSH
23377: LD_INT 19
23379: PUSH
23380: LD_INT 16
23382: PUSH
23383: LD_INT 25
23385: PUSH
23386: LD_INT 18
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: IN
23401: ST_TO_ADDR
// end ;
23402: LD_VAR 0 2
23406: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23407: LD_INT 0
23409: PPUSH
23410: PPUSH
23411: PPUSH
// result := [ ] ;
23412: LD_ADDR_VAR 0 3
23416: PUSH
23417: EMPTY
23418: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23419: LD_ADDR_VAR 0 4
23423: PUSH
23424: LD_VAR 0 2
23428: PPUSH
23429: LD_INT 21
23431: PUSH
23432: LD_INT 3
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PPUSH
23439: CALL_OW 70
23443: ST_TO_ADDR
// if not tmp then
23444: LD_VAR 0 4
23448: NOT
23449: IFFALSE 23453
// exit ;
23451: GO 23511
// for i in tmp do
23453: LD_ADDR_VAR 0 5
23457: PUSH
23458: LD_VAR 0 4
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23499
// if GetBase ( i ) <> base then
23466: LD_VAR 0 5
23470: PPUSH
23471: CALL_OW 274
23475: PUSH
23476: LD_VAR 0 1
23480: NONEQUAL
23481: IFFALSE 23497
// ComLinkToBase ( base , i ) ;
23483: LD_VAR 0 1
23487: PPUSH
23488: LD_VAR 0 5
23492: PPUSH
23493: CALL_OW 169
23497: GO 23463
23499: POP
23500: POP
// result := tmp ;
23501: LD_ADDR_VAR 0 3
23505: PUSH
23506: LD_VAR 0 4
23510: ST_TO_ADDR
// end ;
23511: LD_VAR 0 3
23515: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23516: LD_INT 0
23518: PPUSH
23519: PPUSH
// if BuildingStatus ( b ) = bs_build then
23520: LD_VAR 0 2
23524: PPUSH
23525: CALL_OW 461
23529: PUSH
23530: LD_INT 1
23532: EQUAL
23533: IFFALSE 23593
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23535: LD_VAR 0 1
23539: PPUSH
23540: LD_STRING h
23542: PUSH
23543: LD_VAR 0 2
23547: PPUSH
23548: CALL_OW 250
23552: PUSH
23553: LD_VAR 0 2
23557: PPUSH
23558: CALL_OW 251
23562: PUSH
23563: LD_VAR 0 2
23567: PUSH
23568: LD_INT 0
23570: PUSH
23571: LD_INT 0
23573: PUSH
23574: LD_INT 0
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: PUSH
23586: EMPTY
23587: LIST
23588: PPUSH
23589: CALL_OW 446
// end ;
23593: LD_VAR 0 3
23597: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23606: LD_VAR 0 1
23610: NOT
23611: PUSH
23612: LD_VAR 0 1
23616: PPUSH
23617: CALL_OW 263
23621: PUSH
23622: LD_INT 2
23624: EQUAL
23625: NOT
23626: OR
23627: IFFALSE 23631
// exit ;
23629: GO 23947
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23631: LD_ADDR_VAR 0 6
23635: PUSH
23636: LD_INT 22
23638: PUSH
23639: LD_VAR 0 1
23643: PPUSH
23644: CALL_OW 255
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: LD_INT 2
23655: PUSH
23656: LD_INT 30
23658: PUSH
23659: LD_INT 36
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: LD_INT 34
23668: PUSH
23669: LD_INT 31
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: LIST
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: PPUSH
23685: CALL_OW 69
23689: ST_TO_ADDR
// if not tmp then
23690: LD_VAR 0 6
23694: NOT
23695: IFFALSE 23699
// exit ;
23697: GO 23947
// result := [ ] ;
23699: LD_ADDR_VAR 0 2
23703: PUSH
23704: EMPTY
23705: ST_TO_ADDR
// for i in tmp do
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_VAR 0 6
23715: PUSH
23716: FOR_IN
23717: IFFALSE 23788
// begin t := UnitsInside ( i ) ;
23719: LD_ADDR_VAR 0 4
23723: PUSH
23724: LD_VAR 0 3
23728: PPUSH
23729: CALL_OW 313
23733: ST_TO_ADDR
// if t then
23734: LD_VAR 0 4
23738: IFFALSE 23786
// for j in t do
23740: LD_ADDR_VAR 0 7
23744: PUSH
23745: LD_VAR 0 4
23749: PUSH
23750: FOR_IN
23751: IFFALSE 23784
// result := Insert ( result , result + 1 , j ) ;
23753: LD_ADDR_VAR 0 2
23757: PUSH
23758: LD_VAR 0 2
23762: PPUSH
23763: LD_VAR 0 2
23767: PUSH
23768: LD_INT 1
23770: PLUS
23771: PPUSH
23772: LD_VAR 0 7
23776: PPUSH
23777: CALL_OW 2
23781: ST_TO_ADDR
23782: GO 23750
23784: POP
23785: POP
// end ;
23786: GO 23716
23788: POP
23789: POP
// if not result then
23790: LD_VAR 0 2
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 23947
// mech := result [ 1 ] ;
23799: LD_ADDR_VAR 0 5
23803: PUSH
23804: LD_VAR 0 2
23808: PUSH
23809: LD_INT 1
23811: ARRAY
23812: ST_TO_ADDR
// if result > 1 then
23813: LD_VAR 0 2
23817: PUSH
23818: LD_INT 1
23820: GREATER
23821: IFFALSE 23933
// for i = 2 to result do
23823: LD_ADDR_VAR 0 3
23827: PUSH
23828: DOUBLE
23829: LD_INT 2
23831: DEC
23832: ST_TO_ADDR
23833: LD_VAR 0 2
23837: PUSH
23838: FOR_TO
23839: IFFALSE 23931
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23841: LD_ADDR_VAR 0 4
23845: PUSH
23846: LD_VAR 0 2
23850: PUSH
23851: LD_VAR 0 3
23855: ARRAY
23856: PPUSH
23857: LD_INT 3
23859: PPUSH
23860: CALL_OW 259
23864: PUSH
23865: LD_VAR 0 2
23869: PUSH
23870: LD_VAR 0 3
23874: ARRAY
23875: PPUSH
23876: CALL_OW 432
23880: MINUS
23881: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23882: LD_VAR 0 4
23886: PUSH
23887: LD_VAR 0 5
23891: PPUSH
23892: LD_INT 3
23894: PPUSH
23895: CALL_OW 259
23899: PUSH
23900: LD_VAR 0 5
23904: PPUSH
23905: CALL_OW 432
23909: MINUS
23910: GREATEREQUAL
23911: IFFALSE 23929
// mech := result [ i ] ;
23913: LD_ADDR_VAR 0 5
23917: PUSH
23918: LD_VAR 0 2
23922: PUSH
23923: LD_VAR 0 3
23927: ARRAY
23928: ST_TO_ADDR
// end ;
23929: GO 23838
23931: POP
23932: POP
// ComLinkTo ( vehicle , mech ) ;
23933: LD_VAR 0 1
23937: PPUSH
23938: LD_VAR 0 5
23942: PPUSH
23943: CALL_OW 135
// end ;
23947: LD_VAR 0 2
23951: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23952: LD_INT 0
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
// result := [ ] ;
23967: LD_ADDR_VAR 0 7
23971: PUSH
23972: EMPTY
23973: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23974: LD_VAR 0 1
23978: PPUSH
23979: CALL_OW 266
23983: PUSH
23984: LD_INT 0
23986: PUSH
23987: LD_INT 1
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: IN
23994: NOT
23995: IFFALSE 23999
// exit ;
23997: GO 25630
// if name then
23999: LD_VAR 0 3
24003: IFFALSE 24019
// SetBName ( base_dep , name ) ;
24005: LD_VAR 0 1
24009: PPUSH
24010: LD_VAR 0 3
24014: PPUSH
24015: CALL_OW 500
// base := GetBase ( base_dep ) ;
24019: LD_ADDR_VAR 0 15
24023: PUSH
24024: LD_VAR 0 1
24028: PPUSH
24029: CALL_OW 274
24033: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24034: LD_ADDR_VAR 0 16
24038: PUSH
24039: LD_VAR 0 1
24043: PPUSH
24044: CALL_OW 255
24048: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24049: LD_ADDR_VAR 0 17
24053: PUSH
24054: LD_VAR 0 1
24058: PPUSH
24059: CALL_OW 248
24063: ST_TO_ADDR
// if sources then
24064: LD_VAR 0 5
24068: IFFALSE 24115
// for i = 1 to 3 do
24070: LD_ADDR_VAR 0 8
24074: PUSH
24075: DOUBLE
24076: LD_INT 1
24078: DEC
24079: ST_TO_ADDR
24080: LD_INT 3
24082: PUSH
24083: FOR_TO
24084: IFFALSE 24113
// AddResourceType ( base , i , sources [ i ] ) ;
24086: LD_VAR 0 15
24090: PPUSH
24091: LD_VAR 0 8
24095: PPUSH
24096: LD_VAR 0 5
24100: PUSH
24101: LD_VAR 0 8
24105: ARRAY
24106: PPUSH
24107: CALL_OW 276
24111: GO 24083
24113: POP
24114: POP
// buildings := GetBaseBuildings ( base , area ) ;
24115: LD_ADDR_VAR 0 18
24119: PUSH
24120: LD_VAR 0 15
24124: PPUSH
24125: LD_VAR 0 2
24129: PPUSH
24130: CALL 23407 0 2
24134: ST_TO_ADDR
// InitHc ;
24135: CALL_OW 19
// InitUc ;
24139: CALL_OW 18
// uc_side := side ;
24143: LD_ADDR_OWVAR 20
24147: PUSH
24148: LD_VAR 0 16
24152: ST_TO_ADDR
// uc_nation := nation ;
24153: LD_ADDR_OWVAR 21
24157: PUSH
24158: LD_VAR 0 17
24162: ST_TO_ADDR
// if buildings then
24163: LD_VAR 0 18
24167: IFFALSE 25489
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24169: LD_ADDR_VAR 0 19
24173: PUSH
24174: LD_VAR 0 18
24178: PPUSH
24179: LD_INT 2
24181: PUSH
24182: LD_INT 30
24184: PUSH
24185: LD_INT 29
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: LD_INT 30
24194: PUSH
24195: LD_INT 30
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: LIST
24206: PPUSH
24207: CALL_OW 72
24211: ST_TO_ADDR
// if tmp then
24212: LD_VAR 0 19
24216: IFFALSE 24264
// for i in tmp do
24218: LD_ADDR_VAR 0 8
24222: PUSH
24223: LD_VAR 0 19
24227: PUSH
24228: FOR_IN
24229: IFFALSE 24262
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24231: LD_VAR 0 8
24235: PPUSH
24236: CALL_OW 250
24240: PPUSH
24241: LD_VAR 0 8
24245: PPUSH
24246: CALL_OW 251
24250: PPUSH
24251: LD_VAR 0 16
24255: PPUSH
24256: CALL_OW 441
24260: GO 24228
24262: POP
24263: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24264: LD_VAR 0 18
24268: PPUSH
24269: LD_INT 2
24271: PUSH
24272: LD_INT 30
24274: PUSH
24275: LD_INT 32
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 30
24284: PUSH
24285: LD_INT 33
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL_OW 72
24301: IFFALSE 24389
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24303: LD_ADDR_VAR 0 8
24307: PUSH
24308: LD_VAR 0 18
24312: PPUSH
24313: LD_INT 2
24315: PUSH
24316: LD_INT 30
24318: PUSH
24319: LD_INT 32
24321: PUSH
24322: EMPTY
24323: LIST
24324: LIST
24325: PUSH
24326: LD_INT 30
24328: PUSH
24329: LD_INT 33
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: PPUSH
24341: CALL_OW 72
24345: PUSH
24346: FOR_IN
24347: IFFALSE 24387
// begin if not GetBWeapon ( i ) then
24349: LD_VAR 0 8
24353: PPUSH
24354: CALL_OW 269
24358: NOT
24359: IFFALSE 24385
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24361: LD_VAR 0 8
24365: PPUSH
24366: LD_VAR 0 8
24370: PPUSH
24371: LD_VAR 0 2
24375: PPUSH
24376: CALL 25635 0 2
24380: PPUSH
24381: CALL_OW 431
// end ;
24385: GO 24346
24387: POP
24388: POP
// end ; for i = 1 to personel do
24389: LD_ADDR_VAR 0 8
24393: PUSH
24394: DOUBLE
24395: LD_INT 1
24397: DEC
24398: ST_TO_ADDR
24399: LD_VAR 0 6
24403: PUSH
24404: FOR_TO
24405: IFFALSE 25469
// begin if i > 4 then
24407: LD_VAR 0 8
24411: PUSH
24412: LD_INT 4
24414: GREATER
24415: IFFALSE 24419
// break ;
24417: GO 25469
// case i of 1 :
24419: LD_VAR 0 8
24423: PUSH
24424: LD_INT 1
24426: DOUBLE
24427: EQUAL
24428: IFTRUE 24432
24430: GO 24512
24432: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24433: LD_ADDR_VAR 0 12
24437: PUSH
24438: LD_VAR 0 18
24442: PPUSH
24443: LD_INT 22
24445: PUSH
24446: LD_VAR 0 16
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 58
24457: PUSH
24458: EMPTY
24459: LIST
24460: PUSH
24461: LD_INT 2
24463: PUSH
24464: LD_INT 30
24466: PUSH
24467: LD_INT 32
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 30
24476: PUSH
24477: LD_INT 4
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: LD_INT 30
24486: PUSH
24487: LD_INT 5
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: PPUSH
24505: CALL_OW 72
24509: ST_TO_ADDR
24510: GO 24734
24512: LD_INT 2
24514: DOUBLE
24515: EQUAL
24516: IFTRUE 24520
24518: GO 24582
24520: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24521: LD_ADDR_VAR 0 12
24525: PUSH
24526: LD_VAR 0 18
24530: PPUSH
24531: LD_INT 22
24533: PUSH
24534: LD_VAR 0 16
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: LD_INT 2
24545: PUSH
24546: LD_INT 30
24548: PUSH
24549: LD_INT 0
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PUSH
24556: LD_INT 30
24558: PUSH
24559: LD_INT 1
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 72
24579: ST_TO_ADDR
24580: GO 24734
24582: LD_INT 3
24584: DOUBLE
24585: EQUAL
24586: IFTRUE 24590
24588: GO 24652
24590: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24591: LD_ADDR_VAR 0 12
24595: PUSH
24596: LD_VAR 0 18
24600: PPUSH
24601: LD_INT 22
24603: PUSH
24604: LD_VAR 0 16
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 2
24615: PUSH
24616: LD_INT 30
24618: PUSH
24619: LD_INT 2
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 30
24628: PUSH
24629: LD_INT 3
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: LIST
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: PPUSH
24645: CALL_OW 72
24649: ST_TO_ADDR
24650: GO 24734
24652: LD_INT 4
24654: DOUBLE
24655: EQUAL
24656: IFTRUE 24660
24658: GO 24733
24660: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24661: LD_ADDR_VAR 0 12
24665: PUSH
24666: LD_VAR 0 18
24670: PPUSH
24671: LD_INT 22
24673: PUSH
24674: LD_VAR 0 16
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 2
24685: PUSH
24686: LD_INT 30
24688: PUSH
24689: LD_INT 6
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 30
24698: PUSH
24699: LD_INT 7
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 30
24708: PUSH
24709: LD_INT 8
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PPUSH
24726: CALL_OW 72
24730: ST_TO_ADDR
24731: GO 24734
24733: POP
// if i = 1 then
24734: LD_VAR 0 8
24738: PUSH
24739: LD_INT 1
24741: EQUAL
24742: IFFALSE 24853
// begin tmp := [ ] ;
24744: LD_ADDR_VAR 0 19
24748: PUSH
24749: EMPTY
24750: ST_TO_ADDR
// for j in f do
24751: LD_ADDR_VAR 0 9
24755: PUSH
24756: LD_VAR 0 12
24760: PUSH
24761: FOR_IN
24762: IFFALSE 24835
// if GetBType ( j ) = b_bunker then
24764: LD_VAR 0 9
24768: PPUSH
24769: CALL_OW 266
24773: PUSH
24774: LD_INT 32
24776: EQUAL
24777: IFFALSE 24804
// tmp := Insert ( tmp , 1 , j ) else
24779: LD_ADDR_VAR 0 19
24783: PUSH
24784: LD_VAR 0 19
24788: PPUSH
24789: LD_INT 1
24791: PPUSH
24792: LD_VAR 0 9
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
24802: GO 24833
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24804: LD_ADDR_VAR 0 19
24808: PUSH
24809: LD_VAR 0 19
24813: PPUSH
24814: LD_VAR 0 19
24818: PUSH
24819: LD_INT 1
24821: PLUS
24822: PPUSH
24823: LD_VAR 0 9
24827: PPUSH
24828: CALL_OW 2
24832: ST_TO_ADDR
24833: GO 24761
24835: POP
24836: POP
// if tmp then
24837: LD_VAR 0 19
24841: IFFALSE 24853
// f := tmp ;
24843: LD_ADDR_VAR 0 12
24847: PUSH
24848: LD_VAR 0 19
24852: ST_TO_ADDR
// end ; x := personel [ i ] ;
24853: LD_ADDR_VAR 0 13
24857: PUSH
24858: LD_VAR 0 6
24862: PUSH
24863: LD_VAR 0 8
24867: ARRAY
24868: ST_TO_ADDR
// if x = - 1 then
24869: LD_VAR 0 13
24873: PUSH
24874: LD_INT 1
24876: NEG
24877: EQUAL
24878: IFFALSE 25087
// begin for j in f do
24880: LD_ADDR_VAR 0 9
24884: PUSH
24885: LD_VAR 0 12
24889: PUSH
24890: FOR_IN
24891: IFFALSE 25083
// repeat InitHc ;
24893: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24897: LD_VAR 0 9
24901: PPUSH
24902: CALL_OW 266
24906: PUSH
24907: LD_INT 5
24909: EQUAL
24910: IFFALSE 24980
// begin if UnitsInside ( j ) < 3 then
24912: LD_VAR 0 9
24916: PPUSH
24917: CALL_OW 313
24921: PUSH
24922: LD_INT 3
24924: LESS
24925: IFFALSE 24961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24927: LD_INT 0
24929: PPUSH
24930: LD_INT 5
24932: PUSH
24933: LD_INT 8
24935: PUSH
24936: LD_INT 9
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: LIST
24943: PUSH
24944: LD_VAR 0 17
24948: ARRAY
24949: PPUSH
24950: LD_VAR 0 4
24954: PPUSH
24955: CALL_OW 380
24959: GO 24978
// PrepareHuman ( false , i , skill ) ;
24961: LD_INT 0
24963: PPUSH
24964: LD_VAR 0 8
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 380
// end else
24978: GO 24997
// PrepareHuman ( false , i , skill ) ;
24980: LD_INT 0
24982: PPUSH
24983: LD_VAR 0 8
24987: PPUSH
24988: LD_VAR 0 4
24992: PPUSH
24993: CALL_OW 380
// un := CreateHuman ;
24997: LD_ADDR_VAR 0 14
25001: PUSH
25002: CALL_OW 44
25006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25007: LD_ADDR_VAR 0 7
25011: PUSH
25012: LD_VAR 0 7
25016: PPUSH
25017: LD_INT 1
25019: PPUSH
25020: LD_VAR 0 14
25024: PPUSH
25025: CALL_OW 2
25029: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25030: LD_VAR 0 14
25034: PPUSH
25035: LD_VAR 0 9
25039: PPUSH
25040: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25044: LD_VAR 0 9
25048: PPUSH
25049: CALL_OW 313
25053: PUSH
25054: LD_INT 6
25056: EQUAL
25057: PUSH
25058: LD_VAR 0 9
25062: PPUSH
25063: CALL_OW 266
25067: PUSH
25068: LD_INT 32
25070: PUSH
25071: LD_INT 31
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: IN
25078: OR
25079: IFFALSE 24893
25081: GO 24890
25083: POP
25084: POP
// end else
25085: GO 25467
// for j = 1 to x do
25087: LD_ADDR_VAR 0 9
25091: PUSH
25092: DOUBLE
25093: LD_INT 1
25095: DEC
25096: ST_TO_ADDR
25097: LD_VAR 0 13
25101: PUSH
25102: FOR_TO
25103: IFFALSE 25465
// begin InitHc ;
25105: CALL_OW 19
// if not f then
25109: LD_VAR 0 12
25113: NOT
25114: IFFALSE 25203
// begin PrepareHuman ( false , i , skill ) ;
25116: LD_INT 0
25118: PPUSH
25119: LD_VAR 0 8
25123: PPUSH
25124: LD_VAR 0 4
25128: PPUSH
25129: CALL_OW 380
// un := CreateHuman ;
25133: LD_ADDR_VAR 0 14
25137: PUSH
25138: CALL_OW 44
25142: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25143: LD_ADDR_VAR 0 7
25147: PUSH
25148: LD_VAR 0 7
25152: PPUSH
25153: LD_INT 1
25155: PPUSH
25156: LD_VAR 0 14
25160: PPUSH
25161: CALL_OW 2
25165: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25166: LD_VAR 0 14
25170: PPUSH
25171: LD_VAR 0 1
25175: PPUSH
25176: CALL_OW 250
25180: PPUSH
25181: LD_VAR 0 1
25185: PPUSH
25186: CALL_OW 251
25190: PPUSH
25191: LD_INT 10
25193: PPUSH
25194: LD_INT 0
25196: PPUSH
25197: CALL_OW 50
// continue ;
25201: GO 25102
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25203: LD_VAR 0 12
25207: PUSH
25208: LD_INT 1
25210: ARRAY
25211: PPUSH
25212: CALL_OW 313
25216: PUSH
25217: LD_VAR 0 12
25221: PUSH
25222: LD_INT 1
25224: ARRAY
25225: PPUSH
25226: CALL_OW 266
25230: PUSH
25231: LD_INT 32
25233: PUSH
25234: LD_INT 31
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: IN
25241: AND
25242: PUSH
25243: LD_VAR 0 12
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: PPUSH
25252: CALL_OW 313
25256: PUSH
25257: LD_INT 6
25259: EQUAL
25260: OR
25261: IFFALSE 25281
// f := Delete ( f , 1 ) ;
25263: LD_ADDR_VAR 0 12
25267: PUSH
25268: LD_VAR 0 12
25272: PPUSH
25273: LD_INT 1
25275: PPUSH
25276: CALL_OW 3
25280: ST_TO_ADDR
// if not f then
25281: LD_VAR 0 12
25285: NOT
25286: IFFALSE 25304
// begin x := x + 2 ;
25288: LD_ADDR_VAR 0 13
25292: PUSH
25293: LD_VAR 0 13
25297: PUSH
25298: LD_INT 2
25300: PLUS
25301: ST_TO_ADDR
// continue ;
25302: GO 25102
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25304: LD_VAR 0 12
25308: PUSH
25309: LD_INT 1
25311: ARRAY
25312: PPUSH
25313: CALL_OW 266
25317: PUSH
25318: LD_INT 5
25320: EQUAL
25321: IFFALSE 25395
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25323: LD_VAR 0 12
25327: PUSH
25328: LD_INT 1
25330: ARRAY
25331: PPUSH
25332: CALL_OW 313
25336: PUSH
25337: LD_INT 3
25339: LESS
25340: IFFALSE 25376
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25342: LD_INT 0
25344: PPUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 8
25350: PUSH
25351: LD_INT 9
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: LD_VAR 0 17
25363: ARRAY
25364: PPUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: CALL_OW 380
25374: GO 25393
// PrepareHuman ( false , i , skill ) ;
25376: LD_INT 0
25378: PPUSH
25379: LD_VAR 0 8
25383: PPUSH
25384: LD_VAR 0 4
25388: PPUSH
25389: CALL_OW 380
// end else
25393: GO 25412
// PrepareHuman ( false , i , skill ) ;
25395: LD_INT 0
25397: PPUSH
25398: LD_VAR 0 8
25402: PPUSH
25403: LD_VAR 0 4
25407: PPUSH
25408: CALL_OW 380
// un := CreateHuman ;
25412: LD_ADDR_VAR 0 14
25416: PUSH
25417: CALL_OW 44
25421: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25422: LD_ADDR_VAR 0 7
25426: PUSH
25427: LD_VAR 0 7
25431: PPUSH
25432: LD_INT 1
25434: PPUSH
25435: LD_VAR 0 14
25439: PPUSH
25440: CALL_OW 2
25444: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25445: LD_VAR 0 14
25449: PPUSH
25450: LD_VAR 0 12
25454: PUSH
25455: LD_INT 1
25457: ARRAY
25458: PPUSH
25459: CALL_OW 52
// end ;
25463: GO 25102
25465: POP
25466: POP
// end ;
25467: GO 24404
25469: POP
25470: POP
// result := result ^ buildings ;
25471: LD_ADDR_VAR 0 7
25475: PUSH
25476: LD_VAR 0 7
25480: PUSH
25481: LD_VAR 0 18
25485: ADD
25486: ST_TO_ADDR
// end else
25487: GO 25630
// begin for i = 1 to personel do
25489: LD_ADDR_VAR 0 8
25493: PUSH
25494: DOUBLE
25495: LD_INT 1
25497: DEC
25498: ST_TO_ADDR
25499: LD_VAR 0 6
25503: PUSH
25504: FOR_TO
25505: IFFALSE 25628
// begin if i > 4 then
25507: LD_VAR 0 8
25511: PUSH
25512: LD_INT 4
25514: GREATER
25515: IFFALSE 25519
// break ;
25517: GO 25628
// x := personel [ i ] ;
25519: LD_ADDR_VAR 0 13
25523: PUSH
25524: LD_VAR 0 6
25528: PUSH
25529: LD_VAR 0 8
25533: ARRAY
25534: ST_TO_ADDR
// if x = - 1 then
25535: LD_VAR 0 13
25539: PUSH
25540: LD_INT 1
25542: NEG
25543: EQUAL
25544: IFFALSE 25548
// continue ;
25546: GO 25504
// PrepareHuman ( false , i , skill ) ;
25548: LD_INT 0
25550: PPUSH
25551: LD_VAR 0 8
25555: PPUSH
25556: LD_VAR 0 4
25560: PPUSH
25561: CALL_OW 380
// un := CreateHuman ;
25565: LD_ADDR_VAR 0 14
25569: PUSH
25570: CALL_OW 44
25574: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25575: LD_VAR 0 14
25579: PPUSH
25580: LD_VAR 0 1
25584: PPUSH
25585: CALL_OW 250
25589: PPUSH
25590: LD_VAR 0 1
25594: PPUSH
25595: CALL_OW 251
25599: PPUSH
25600: LD_INT 10
25602: PPUSH
25603: LD_INT 0
25605: PPUSH
25606: CALL_OW 50
// result := result ^ un ;
25610: LD_ADDR_VAR 0 7
25614: PUSH
25615: LD_VAR 0 7
25619: PUSH
25620: LD_VAR 0 14
25624: ADD
25625: ST_TO_ADDR
// end ;
25626: GO 25504
25628: POP
25629: POP
// end ; end ;
25630: LD_VAR 0 7
25634: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25635: LD_INT 0
25637: PPUSH
25638: PPUSH
25639: PPUSH
25640: PPUSH
25641: PPUSH
25642: PPUSH
25643: PPUSH
25644: PPUSH
25645: PPUSH
25646: PPUSH
25647: PPUSH
25648: PPUSH
25649: PPUSH
25650: PPUSH
25651: PPUSH
25652: PPUSH
// result := false ;
25653: LD_ADDR_VAR 0 3
25657: PUSH
25658: LD_INT 0
25660: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25661: LD_VAR 0 1
25665: NOT
25666: PUSH
25667: LD_VAR 0 1
25671: PPUSH
25672: CALL_OW 266
25676: PUSH
25677: LD_INT 32
25679: PUSH
25680: LD_INT 33
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: IN
25687: NOT
25688: OR
25689: IFFALSE 25693
// exit ;
25691: GO 26829
// nat := GetNation ( tower ) ;
25693: LD_ADDR_VAR 0 12
25697: PUSH
25698: LD_VAR 0 1
25702: PPUSH
25703: CALL_OW 248
25707: ST_TO_ADDR
// side := GetSide ( tower ) ;
25708: LD_ADDR_VAR 0 16
25712: PUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: CALL_OW 255
25722: ST_TO_ADDR
// x := GetX ( tower ) ;
25723: LD_ADDR_VAR 0 10
25727: PUSH
25728: LD_VAR 0 1
25732: PPUSH
25733: CALL_OW 250
25737: ST_TO_ADDR
// y := GetY ( tower ) ;
25738: LD_ADDR_VAR 0 11
25742: PUSH
25743: LD_VAR 0 1
25747: PPUSH
25748: CALL_OW 251
25752: ST_TO_ADDR
// if not x or not y then
25753: LD_VAR 0 10
25757: NOT
25758: PUSH
25759: LD_VAR 0 11
25763: NOT
25764: OR
25765: IFFALSE 25769
// exit ;
25767: GO 26829
// weapon := 0 ;
25769: LD_ADDR_VAR 0 18
25773: PUSH
25774: LD_INT 0
25776: ST_TO_ADDR
// fac_list := [ ] ;
25777: LD_ADDR_VAR 0 17
25781: PUSH
25782: EMPTY
25783: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25784: LD_ADDR_VAR 0 6
25788: PUSH
25789: LD_VAR 0 1
25793: PPUSH
25794: CALL_OW 274
25798: PPUSH
25799: LD_VAR 0 2
25803: PPUSH
25804: CALL 23407 0 2
25808: PPUSH
25809: LD_INT 30
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: PPUSH
25819: CALL_OW 72
25823: ST_TO_ADDR
// if not factories then
25824: LD_VAR 0 6
25828: NOT
25829: IFFALSE 25833
// exit ;
25831: GO 26829
// for i in factories do
25833: LD_ADDR_VAR 0 8
25837: PUSH
25838: LD_VAR 0 6
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25869
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25846: LD_ADDR_VAR 0 17
25850: PUSH
25851: LD_VAR 0 17
25855: PUSH
25856: LD_VAR 0 8
25860: PPUSH
25861: CALL_OW 478
25865: UNION
25866: ST_TO_ADDR
25867: GO 25843
25869: POP
25870: POP
// if not fac_list then
25871: LD_VAR 0 17
25875: NOT
25876: IFFALSE 25880
// exit ;
25878: GO 26829
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25880: LD_ADDR_VAR 0 5
25884: PUSH
25885: LD_INT 4
25887: PUSH
25888: LD_INT 5
25890: PUSH
25891: LD_INT 9
25893: PUSH
25894: LD_INT 10
25896: PUSH
25897: LD_INT 6
25899: PUSH
25900: LD_INT 7
25902: PUSH
25903: LD_INT 11
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: LIST
25910: LIST
25911: LIST
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 27
25917: PUSH
25918: LD_INT 28
25920: PUSH
25921: LD_INT 26
25923: PUSH
25924: LD_INT 30
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 43
25935: PUSH
25936: LD_INT 44
25938: PUSH
25939: LD_INT 46
25941: PUSH
25942: LD_INT 45
25944: PUSH
25945: LD_INT 47
25947: PUSH
25948: LD_INT 49
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: LIST
25963: PUSH
25964: LD_VAR 0 12
25968: ARRAY
25969: ST_TO_ADDR
// for i in list do
25970: LD_ADDR_VAR 0 8
25974: PUSH
25975: LD_VAR 0 5
25979: PUSH
25980: FOR_IN
25981: IFFALSE 26014
// if not i in fac_list then
25983: LD_VAR 0 8
25987: PUSH
25988: LD_VAR 0 17
25992: IN
25993: NOT
25994: IFFALSE 26012
// list := list diff i ;
25996: LD_ADDR_VAR 0 5
26000: PUSH
26001: LD_VAR 0 5
26005: PUSH
26006: LD_VAR 0 8
26010: DIFF
26011: ST_TO_ADDR
26012: GO 25980
26014: POP
26015: POP
// if not list then
26016: LD_VAR 0 5
26020: NOT
26021: IFFALSE 26025
// exit ;
26023: GO 26829
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26025: LD_VAR 0 12
26029: PUSH
26030: LD_INT 3
26032: EQUAL
26033: PUSH
26034: LD_INT 49
26036: PUSH
26037: LD_VAR 0 5
26041: IN
26042: AND
26043: PUSH
26044: LD_INT 31
26046: PPUSH
26047: LD_VAR 0 16
26051: PPUSH
26052: CALL_OW 321
26056: PUSH
26057: LD_INT 2
26059: EQUAL
26060: AND
26061: IFFALSE 26121
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26063: LD_INT 22
26065: PUSH
26066: LD_VAR 0 16
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 35
26077: PUSH
26078: LD_INT 49
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 91
26087: PUSH
26088: LD_VAR 0 1
26092: PUSH
26093: LD_INT 10
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: PPUSH
26106: CALL_OW 69
26110: NOT
26111: IFFALSE 26121
// weapon := ru_time_lapser ;
26113: LD_ADDR_VAR 0 18
26117: PUSH
26118: LD_INT 49
26120: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26121: LD_VAR 0 12
26125: PUSH
26126: LD_INT 1
26128: PUSH
26129: LD_INT 2
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: IN
26136: PUSH
26137: LD_INT 11
26139: PUSH
26140: LD_VAR 0 5
26144: IN
26145: PUSH
26146: LD_INT 30
26148: PUSH
26149: LD_VAR 0 5
26153: IN
26154: OR
26155: AND
26156: PUSH
26157: LD_INT 6
26159: PPUSH
26160: LD_VAR 0 16
26164: PPUSH
26165: CALL_OW 321
26169: PUSH
26170: LD_INT 2
26172: EQUAL
26173: AND
26174: IFFALSE 26339
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26176: LD_INT 22
26178: PUSH
26179: LD_VAR 0 16
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: LD_INT 35
26193: PUSH
26194: LD_INT 11
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 35
26203: PUSH
26204: LD_INT 30
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 91
26218: PUSH
26219: LD_VAR 0 1
26223: PUSH
26224: LD_INT 18
26226: PUSH
26227: EMPTY
26228: LIST
26229: LIST
26230: LIST
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: LIST
26236: PPUSH
26237: CALL_OW 69
26241: NOT
26242: PUSH
26243: LD_INT 22
26245: PUSH
26246: LD_VAR 0 16
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 32
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 33
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 91
26285: PUSH
26286: LD_VAR 0 1
26290: PUSH
26291: LD_INT 12
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: LIST
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: LIST
26303: PUSH
26304: EMPTY
26305: LIST
26306: PPUSH
26307: CALL_OW 69
26311: PUSH
26312: LD_INT 2
26314: GREATER
26315: AND
26316: IFFALSE 26339
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26318: LD_ADDR_VAR 0 18
26322: PUSH
26323: LD_INT 11
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_VAR 0 12
26337: ARRAY
26338: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26339: LD_VAR 0 18
26343: NOT
26344: PUSH
26345: LD_INT 40
26347: PPUSH
26348: LD_VAR 0 16
26352: PPUSH
26353: CALL_OW 321
26357: PUSH
26358: LD_INT 2
26360: EQUAL
26361: AND
26362: PUSH
26363: LD_INT 7
26365: PUSH
26366: LD_VAR 0 5
26370: IN
26371: PUSH
26372: LD_INT 28
26374: PUSH
26375: LD_VAR 0 5
26379: IN
26380: OR
26381: PUSH
26382: LD_INT 45
26384: PUSH
26385: LD_VAR 0 5
26389: IN
26390: OR
26391: AND
26392: IFFALSE 26646
// begin hex := GetHexInfo ( x , y ) ;
26394: LD_ADDR_VAR 0 4
26398: PUSH
26399: LD_VAR 0 10
26403: PPUSH
26404: LD_VAR 0 11
26408: PPUSH
26409: CALL_OW 546
26413: ST_TO_ADDR
// if hex [ 1 ] then
26414: LD_VAR 0 4
26418: PUSH
26419: LD_INT 1
26421: ARRAY
26422: IFFALSE 26426
// exit ;
26424: GO 26829
// height := hex [ 2 ] ;
26426: LD_ADDR_VAR 0 15
26430: PUSH
26431: LD_VAR 0 4
26435: PUSH
26436: LD_INT 2
26438: ARRAY
26439: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26440: LD_ADDR_VAR 0 14
26444: PUSH
26445: LD_INT 0
26447: PUSH
26448: LD_INT 2
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 5
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: LIST
26462: ST_TO_ADDR
// for i in tmp do
26463: LD_ADDR_VAR 0 8
26467: PUSH
26468: LD_VAR 0 14
26472: PUSH
26473: FOR_IN
26474: IFFALSE 26644
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26476: LD_ADDR_VAR 0 9
26480: PUSH
26481: LD_VAR 0 10
26485: PPUSH
26486: LD_VAR 0 8
26490: PPUSH
26491: LD_INT 5
26493: PPUSH
26494: CALL_OW 272
26498: PUSH
26499: LD_VAR 0 11
26503: PPUSH
26504: LD_VAR 0 8
26508: PPUSH
26509: LD_INT 5
26511: PPUSH
26512: CALL_OW 273
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26521: LD_VAR 0 9
26525: PUSH
26526: LD_INT 1
26528: ARRAY
26529: PPUSH
26530: LD_VAR 0 9
26534: PUSH
26535: LD_INT 2
26537: ARRAY
26538: PPUSH
26539: CALL_OW 488
26543: IFFALSE 26642
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26545: LD_ADDR_VAR 0 4
26549: PUSH
26550: LD_VAR 0 9
26554: PUSH
26555: LD_INT 1
26557: ARRAY
26558: PPUSH
26559: LD_VAR 0 9
26563: PUSH
26564: LD_INT 2
26566: ARRAY
26567: PPUSH
26568: CALL_OW 546
26572: ST_TO_ADDR
// if hex [ 1 ] then
26573: LD_VAR 0 4
26577: PUSH
26578: LD_INT 1
26580: ARRAY
26581: IFFALSE 26585
// continue ;
26583: GO 26473
// h := hex [ 2 ] ;
26585: LD_ADDR_VAR 0 13
26589: PUSH
26590: LD_VAR 0 4
26594: PUSH
26595: LD_INT 2
26597: ARRAY
26598: ST_TO_ADDR
// if h + 7 < height then
26599: LD_VAR 0 13
26603: PUSH
26604: LD_INT 7
26606: PLUS
26607: PUSH
26608: LD_VAR 0 15
26612: LESS
26613: IFFALSE 26642
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26615: LD_ADDR_VAR 0 18
26619: PUSH
26620: LD_INT 7
26622: PUSH
26623: LD_INT 28
26625: PUSH
26626: LD_INT 45
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: LIST
26633: PUSH
26634: LD_VAR 0 12
26638: ARRAY
26639: ST_TO_ADDR
// break ;
26640: GO 26644
// end ; end ; end ;
26642: GO 26473
26644: POP
26645: POP
// end ; if not weapon then
26646: LD_VAR 0 18
26650: NOT
26651: IFFALSE 26711
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26653: LD_ADDR_VAR 0 5
26657: PUSH
26658: LD_VAR 0 5
26662: PUSH
26663: LD_INT 11
26665: PUSH
26666: LD_INT 30
26668: PUSH
26669: LD_INT 49
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: DIFF
26677: ST_TO_ADDR
// if not list then
26678: LD_VAR 0 5
26682: NOT
26683: IFFALSE 26687
// exit ;
26685: GO 26829
// weapon := list [ rand ( 1 , list ) ] ;
26687: LD_ADDR_VAR 0 18
26691: PUSH
26692: LD_VAR 0 5
26696: PUSH
26697: LD_INT 1
26699: PPUSH
26700: LD_VAR 0 5
26704: PPUSH
26705: CALL_OW 12
26709: ARRAY
26710: ST_TO_ADDR
// end ; if weapon then
26711: LD_VAR 0 18
26715: IFFALSE 26829
// begin tmp := CostOfWeapon ( weapon ) ;
26717: LD_ADDR_VAR 0 14
26721: PUSH
26722: LD_VAR 0 18
26726: PPUSH
26727: CALL_OW 451
26731: ST_TO_ADDR
// j := GetBase ( tower ) ;
26732: LD_ADDR_VAR 0 9
26736: PUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 274
26746: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26747: LD_VAR 0 9
26751: PPUSH
26752: LD_INT 1
26754: PPUSH
26755: CALL_OW 275
26759: PUSH
26760: LD_VAR 0 14
26764: PUSH
26765: LD_INT 1
26767: ARRAY
26768: GREATEREQUAL
26769: PUSH
26770: LD_VAR 0 9
26774: PPUSH
26775: LD_INT 2
26777: PPUSH
26778: CALL_OW 275
26782: PUSH
26783: LD_VAR 0 14
26787: PUSH
26788: LD_INT 2
26790: ARRAY
26791: GREATEREQUAL
26792: AND
26793: PUSH
26794: LD_VAR 0 9
26798: PPUSH
26799: LD_INT 3
26801: PPUSH
26802: CALL_OW 275
26806: PUSH
26807: LD_VAR 0 14
26811: PUSH
26812: LD_INT 3
26814: ARRAY
26815: GREATEREQUAL
26816: AND
26817: IFFALSE 26829
// result := weapon ;
26819: LD_ADDR_VAR 0 3
26823: PUSH
26824: LD_VAR 0 18
26828: ST_TO_ADDR
// end ; end ;
26829: LD_VAR 0 3
26833: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26834: LD_INT 0
26836: PPUSH
26837: PPUSH
// result := true ;
26838: LD_ADDR_VAR 0 3
26842: PUSH
26843: LD_INT 1
26845: ST_TO_ADDR
// if array1 = array2 then
26846: LD_VAR 0 1
26850: PUSH
26851: LD_VAR 0 2
26855: EQUAL
26856: IFFALSE 26916
// begin for i = 1 to array1 do
26858: LD_ADDR_VAR 0 4
26862: PUSH
26863: DOUBLE
26864: LD_INT 1
26866: DEC
26867: ST_TO_ADDR
26868: LD_VAR 0 1
26872: PUSH
26873: FOR_TO
26874: IFFALSE 26912
// if array1 [ i ] <> array2 [ i ] then
26876: LD_VAR 0 1
26880: PUSH
26881: LD_VAR 0 4
26885: ARRAY
26886: PUSH
26887: LD_VAR 0 2
26891: PUSH
26892: LD_VAR 0 4
26896: ARRAY
26897: NONEQUAL
26898: IFFALSE 26910
// begin result := false ;
26900: LD_ADDR_VAR 0 3
26904: PUSH
26905: LD_INT 0
26907: ST_TO_ADDR
// break ;
26908: GO 26912
// end ;
26910: GO 26873
26912: POP
26913: POP
// end else
26914: GO 26924
// result := false ;
26916: LD_ADDR_VAR 0 3
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// end ;
26924: LD_VAR 0 3
26928: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26929: LD_INT 0
26931: PPUSH
26932: PPUSH
26933: PPUSH
// pom := GetBase ( fac ) ;
26934: LD_ADDR_VAR 0 5
26938: PUSH
26939: LD_VAR 0 1
26943: PPUSH
26944: CALL_OW 274
26948: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26949: LD_ADDR_VAR 0 4
26953: PUSH
26954: LD_VAR 0 2
26958: PUSH
26959: LD_INT 1
26961: ARRAY
26962: PPUSH
26963: LD_VAR 0 2
26967: PUSH
26968: LD_INT 2
26970: ARRAY
26971: PPUSH
26972: LD_VAR 0 2
26976: PUSH
26977: LD_INT 3
26979: ARRAY
26980: PPUSH
26981: LD_VAR 0 2
26985: PUSH
26986: LD_INT 4
26988: ARRAY
26989: PPUSH
26990: CALL_OW 449
26994: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26995: LD_ADDR_VAR 0 3
26999: PUSH
27000: LD_VAR 0 5
27004: PPUSH
27005: LD_INT 1
27007: PPUSH
27008: CALL_OW 275
27012: PUSH
27013: LD_VAR 0 4
27017: PUSH
27018: LD_INT 1
27020: ARRAY
27021: GREATEREQUAL
27022: PUSH
27023: LD_VAR 0 5
27027: PPUSH
27028: LD_INT 2
27030: PPUSH
27031: CALL_OW 275
27035: PUSH
27036: LD_VAR 0 4
27040: PUSH
27041: LD_INT 2
27043: ARRAY
27044: GREATEREQUAL
27045: AND
27046: PUSH
27047: LD_VAR 0 5
27051: PPUSH
27052: LD_INT 3
27054: PPUSH
27055: CALL_OW 275
27059: PUSH
27060: LD_VAR 0 4
27064: PUSH
27065: LD_INT 3
27067: ARRAY
27068: GREATEREQUAL
27069: AND
27070: ST_TO_ADDR
// end ;
27071: LD_VAR 0 3
27075: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27076: LD_INT 0
27078: PPUSH
27079: PPUSH
27080: PPUSH
27081: PPUSH
// pom := GetBase ( building ) ;
27082: LD_ADDR_VAR 0 3
27086: PUSH
27087: LD_VAR 0 1
27091: PPUSH
27092: CALL_OW 274
27096: ST_TO_ADDR
// if not pom then
27097: LD_VAR 0 3
27101: NOT
27102: IFFALSE 27106
// exit ;
27104: GO 27276
// btype := GetBType ( building ) ;
27106: LD_ADDR_VAR 0 5
27110: PUSH
27111: LD_VAR 0 1
27115: PPUSH
27116: CALL_OW 266
27120: ST_TO_ADDR
// if btype = b_armoury then
27121: LD_VAR 0 5
27125: PUSH
27126: LD_INT 4
27128: EQUAL
27129: IFFALSE 27139
// btype := b_barracks ;
27131: LD_ADDR_VAR 0 5
27135: PUSH
27136: LD_INT 5
27138: ST_TO_ADDR
// if btype = b_depot then
27139: LD_VAR 0 5
27143: PUSH
27144: LD_INT 0
27146: EQUAL
27147: IFFALSE 27157
// btype := b_warehouse ;
27149: LD_ADDR_VAR 0 5
27153: PUSH
27154: LD_INT 1
27156: ST_TO_ADDR
// if btype = b_workshop then
27157: LD_VAR 0 5
27161: PUSH
27162: LD_INT 2
27164: EQUAL
27165: IFFALSE 27175
// btype := b_factory ;
27167: LD_ADDR_VAR 0 5
27171: PUSH
27172: LD_INT 3
27174: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27175: LD_ADDR_VAR 0 4
27179: PUSH
27180: LD_VAR 0 5
27184: PPUSH
27185: LD_VAR 0 1
27189: PPUSH
27190: CALL_OW 248
27194: PPUSH
27195: CALL_OW 450
27199: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27200: LD_ADDR_VAR 0 2
27204: PUSH
27205: LD_VAR 0 3
27209: PPUSH
27210: LD_INT 1
27212: PPUSH
27213: CALL_OW 275
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_INT 1
27225: ARRAY
27226: GREATEREQUAL
27227: PUSH
27228: LD_VAR 0 3
27232: PPUSH
27233: LD_INT 2
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 4
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: GREATEREQUAL
27250: AND
27251: PUSH
27252: LD_VAR 0 3
27256: PPUSH
27257: LD_INT 3
27259: PPUSH
27260: CALL_OW 275
27264: PUSH
27265: LD_VAR 0 4
27269: PUSH
27270: LD_INT 3
27272: ARRAY
27273: GREATEREQUAL
27274: AND
27275: ST_TO_ADDR
// end ;
27276: LD_VAR 0 2
27280: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27281: LD_INT 0
27283: PPUSH
27284: PPUSH
27285: PPUSH
// pom := GetBase ( building ) ;
27286: LD_ADDR_VAR 0 4
27290: PUSH
27291: LD_VAR 0 1
27295: PPUSH
27296: CALL_OW 274
27300: ST_TO_ADDR
// if not pom then
27301: LD_VAR 0 4
27305: NOT
27306: IFFALSE 27310
// exit ;
27308: GO 27411
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27310: LD_ADDR_VAR 0 5
27314: PUSH
27315: LD_VAR 0 2
27319: PPUSH
27320: LD_VAR 0 1
27324: PPUSH
27325: CALL_OW 248
27329: PPUSH
27330: CALL_OW 450
27334: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27335: LD_ADDR_VAR 0 3
27339: PUSH
27340: LD_VAR 0 4
27344: PPUSH
27345: LD_INT 1
27347: PPUSH
27348: CALL_OW 275
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: LD_INT 1
27360: ARRAY
27361: GREATEREQUAL
27362: PUSH
27363: LD_VAR 0 4
27367: PPUSH
27368: LD_INT 2
27370: PPUSH
27371: CALL_OW 275
27375: PUSH
27376: LD_VAR 0 5
27380: PUSH
27381: LD_INT 2
27383: ARRAY
27384: GREATEREQUAL
27385: AND
27386: PUSH
27387: LD_VAR 0 4
27391: PPUSH
27392: LD_INT 3
27394: PPUSH
27395: CALL_OW 275
27399: PUSH
27400: LD_VAR 0 5
27404: PUSH
27405: LD_INT 3
27407: ARRAY
27408: GREATEREQUAL
27409: AND
27410: ST_TO_ADDR
// end ;
27411: LD_VAR 0 3
27415: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27416: LD_INT 0
27418: PPUSH
27419: PPUSH
27420: PPUSH
27421: PPUSH
27422: PPUSH
27423: PPUSH
27424: PPUSH
27425: PPUSH
27426: PPUSH
27427: PPUSH
// result := false ;
27428: LD_ADDR_VAR 0 6
27432: PUSH
27433: LD_INT 0
27435: ST_TO_ADDR
// if not base or not btype or not x or not y then
27436: LD_VAR 0 1
27440: NOT
27441: PUSH
27442: LD_VAR 0 2
27446: NOT
27447: OR
27448: PUSH
27449: LD_VAR 0 3
27453: NOT
27454: OR
27455: PUSH
27456: LD_VAR 0 4
27460: NOT
27461: OR
27462: IFFALSE 27466
// exit ;
27464: GO 28057
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27466: LD_ADDR_VAR 0 12
27470: PUSH
27471: LD_VAR 0 2
27475: PPUSH
27476: LD_VAR 0 3
27480: PPUSH
27481: LD_VAR 0 4
27485: PPUSH
27486: LD_VAR 0 5
27490: PPUSH
27491: LD_VAR 0 1
27495: PUSH
27496: LD_INT 1
27498: ARRAY
27499: PPUSH
27500: CALL_OW 248
27504: PPUSH
27505: LD_INT 0
27507: PPUSH
27508: CALL 28894 0 6
27512: ST_TO_ADDR
// if not hexes then
27513: LD_VAR 0 12
27517: NOT
27518: IFFALSE 27522
// exit ;
27520: GO 28057
// for i = 1 to hexes do
27522: LD_ADDR_VAR 0 7
27526: PUSH
27527: DOUBLE
27528: LD_INT 1
27530: DEC
27531: ST_TO_ADDR
27532: LD_VAR 0 12
27536: PUSH
27537: FOR_TO
27538: IFFALSE 28055
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 12
27549: PUSH
27550: LD_VAR 0 7
27554: ARRAY
27555: PUSH
27556: LD_INT 1
27558: ARRAY
27559: PPUSH
27560: LD_VAR 0 12
27564: PUSH
27565: LD_VAR 0 7
27569: ARRAY
27570: PUSH
27571: LD_INT 2
27573: ARRAY
27574: PPUSH
27575: CALL_OW 428
27579: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27580: LD_VAR 0 12
27584: PUSH
27585: LD_VAR 0 7
27589: ARRAY
27590: PUSH
27591: LD_INT 1
27593: ARRAY
27594: PPUSH
27595: LD_VAR 0 12
27599: PUSH
27600: LD_VAR 0 7
27604: ARRAY
27605: PUSH
27606: LD_INT 2
27608: ARRAY
27609: PPUSH
27610: CALL_OW 351
27614: PUSH
27615: LD_VAR 0 12
27619: PUSH
27620: LD_VAR 0 7
27624: ARRAY
27625: PUSH
27626: LD_INT 1
27628: ARRAY
27629: PPUSH
27630: LD_VAR 0 12
27634: PUSH
27635: LD_VAR 0 7
27639: ARRAY
27640: PUSH
27641: LD_INT 2
27643: ARRAY
27644: PPUSH
27645: CALL_OW 488
27649: NOT
27650: OR
27651: PUSH
27652: LD_VAR 0 11
27656: PPUSH
27657: CALL_OW 247
27661: PUSH
27662: LD_INT 3
27664: EQUAL
27665: OR
27666: IFFALSE 27672
// exit ;
27668: POP
27669: POP
27670: GO 28057
// if not tmp then
27672: LD_VAR 0 11
27676: NOT
27677: IFFALSE 27681
// continue ;
27679: GO 27537
// result := true ;
27681: LD_ADDR_VAR 0 6
27685: PUSH
27686: LD_INT 1
27688: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27689: LD_ADDR_VAR 0 15
27693: PUSH
27694: LD_INT 22
27696: PUSH
27697: LD_VAR 0 11
27701: PPUSH
27702: CALL_OW 255
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: LD_INT 2
27713: PUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 30
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: LIST
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PPUSH
27743: CALL_OW 69
27747: ST_TO_ADDR
// if dep then
27748: LD_VAR 0 15
27752: IFFALSE 27888
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27754: LD_ADDR_VAR 0 14
27758: PUSH
27759: LD_VAR 0 15
27763: PUSH
27764: LD_INT 1
27766: ARRAY
27767: PPUSH
27768: CALL_OW 250
27772: PPUSH
27773: LD_VAR 0 15
27777: PUSH
27778: LD_INT 1
27780: ARRAY
27781: PPUSH
27782: CALL_OW 254
27786: PPUSH
27787: LD_INT 5
27789: PPUSH
27790: CALL_OW 272
27794: PUSH
27795: LD_VAR 0 15
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: CALL_OW 251
27808: PPUSH
27809: LD_VAR 0 15
27813: PUSH
27814: LD_INT 1
27816: ARRAY
27817: PPUSH
27818: CALL_OW 254
27822: PPUSH
27823: LD_INT 5
27825: PPUSH
27826: CALL_OW 273
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27835: LD_VAR 0 14
27839: PUSH
27840: LD_INT 1
27842: ARRAY
27843: PPUSH
27844: LD_VAR 0 14
27848: PUSH
27849: LD_INT 2
27851: ARRAY
27852: PPUSH
27853: CALL_OW 488
27857: IFFALSE 27888
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27859: LD_VAR 0 11
27863: PPUSH
27864: LD_VAR 0 14
27868: PUSH
27869: LD_INT 1
27871: ARRAY
27872: PPUSH
27873: LD_VAR 0 14
27877: PUSH
27878: LD_INT 2
27880: ARRAY
27881: PPUSH
27882: CALL_OW 111
// continue ;
27886: GO 27537
// end ; end ; r := GetDir ( tmp ) ;
27888: LD_ADDR_VAR 0 13
27892: PUSH
27893: LD_VAR 0 11
27897: PPUSH
27898: CALL_OW 254
27902: ST_TO_ADDR
// if r = 5 then
27903: LD_VAR 0 13
27907: PUSH
27908: LD_INT 5
27910: EQUAL
27911: IFFALSE 27921
// r := 0 ;
27913: LD_ADDR_VAR 0 13
27917: PUSH
27918: LD_INT 0
27920: ST_TO_ADDR
// for j = r to 5 do
27921: LD_ADDR_VAR 0 8
27925: PUSH
27926: DOUBLE
27927: LD_VAR 0 13
27931: DEC
27932: ST_TO_ADDR
27933: LD_INT 5
27935: PUSH
27936: FOR_TO
27937: IFFALSE 28051
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27939: LD_ADDR_VAR 0 9
27943: PUSH
27944: LD_VAR 0 11
27948: PPUSH
27949: CALL_OW 250
27953: PPUSH
27954: LD_VAR 0 8
27958: PPUSH
27959: LD_INT 2
27961: PPUSH
27962: CALL_OW 272
27966: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27967: LD_ADDR_VAR 0 10
27971: PUSH
27972: LD_VAR 0 11
27976: PPUSH
27977: CALL_OW 251
27981: PPUSH
27982: LD_VAR 0 8
27986: PPUSH
27987: LD_INT 2
27989: PPUSH
27990: CALL_OW 273
27994: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27995: LD_VAR 0 9
27999: PPUSH
28000: LD_VAR 0 10
28004: PPUSH
28005: CALL_OW 488
28009: PUSH
28010: LD_VAR 0 9
28014: PPUSH
28015: LD_VAR 0 10
28019: PPUSH
28020: CALL_OW 428
28024: NOT
28025: AND
28026: IFFALSE 28049
// begin ComMoveXY ( tmp , _x , _y ) ;
28028: LD_VAR 0 11
28032: PPUSH
28033: LD_VAR 0 9
28037: PPUSH
28038: LD_VAR 0 10
28042: PPUSH
28043: CALL_OW 111
// break ;
28047: GO 28051
// end ; end ;
28049: GO 27936
28051: POP
28052: POP
// end ;
28053: GO 27537
28055: POP
28056: POP
// end ;
28057: LD_VAR 0 6
28061: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28062: LD_INT 0
28064: PPUSH
28065: PPUSH
28066: PPUSH
28067: PPUSH
28068: PPUSH
28069: PPUSH
28070: PPUSH
28071: PPUSH
28072: PPUSH
28073: PPUSH
// result := false ;
28074: LD_ADDR_VAR 0 6
28078: PUSH
28079: LD_INT 0
28081: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28082: LD_VAR 0 1
28086: NOT
28087: PUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 266
28097: PUSH
28098: LD_INT 0
28100: PUSH
28101: LD_INT 1
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: IN
28108: NOT
28109: OR
28110: PUSH
28111: LD_VAR 0 2
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 5
28122: PUSH
28123: LD_INT 0
28125: PUSH
28126: LD_INT 1
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: LD_INT 3
28134: PUSH
28135: LD_INT 4
28137: PUSH
28138: LD_INT 5
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: IN
28149: NOT
28150: OR
28151: PUSH
28152: LD_VAR 0 3
28156: PPUSH
28157: LD_VAR 0 4
28161: PPUSH
28162: CALL_OW 488
28166: NOT
28167: OR
28168: IFFALSE 28172
// exit ;
28170: GO 28889
// pom := GetBase ( depot ) ;
28172: LD_ADDR_VAR 0 10
28176: PUSH
28177: LD_VAR 0 1
28181: PPUSH
28182: CALL_OW 274
28186: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28187: LD_ADDR_VAR 0 11
28191: PUSH
28192: LD_VAR 0 2
28196: PPUSH
28197: LD_VAR 0 1
28201: PPUSH
28202: CALL_OW 248
28206: PPUSH
28207: CALL_OW 450
28211: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28212: LD_VAR 0 10
28216: PPUSH
28217: LD_INT 1
28219: PPUSH
28220: CALL_OW 275
28224: PUSH
28225: LD_VAR 0 11
28229: PUSH
28230: LD_INT 1
28232: ARRAY
28233: GREATEREQUAL
28234: PUSH
28235: LD_VAR 0 10
28239: PPUSH
28240: LD_INT 2
28242: PPUSH
28243: CALL_OW 275
28247: PUSH
28248: LD_VAR 0 11
28252: PUSH
28253: LD_INT 2
28255: ARRAY
28256: GREATEREQUAL
28257: AND
28258: PUSH
28259: LD_VAR 0 10
28263: PPUSH
28264: LD_INT 3
28266: PPUSH
28267: CALL_OW 275
28271: PUSH
28272: LD_VAR 0 11
28276: PUSH
28277: LD_INT 3
28279: ARRAY
28280: GREATEREQUAL
28281: AND
28282: NOT
28283: IFFALSE 28287
// exit ;
28285: GO 28889
// if GetBType ( depot ) = b_depot then
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 266
28296: PUSH
28297: LD_INT 0
28299: EQUAL
28300: IFFALSE 28312
// dist := 28 else
28302: LD_ADDR_VAR 0 14
28306: PUSH
28307: LD_INT 28
28309: ST_TO_ADDR
28310: GO 28320
// dist := 36 ;
28312: LD_ADDR_VAR 0 14
28316: PUSH
28317: LD_INT 36
28319: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28320: LD_VAR 0 1
28324: PPUSH
28325: LD_VAR 0 3
28329: PPUSH
28330: LD_VAR 0 4
28334: PPUSH
28335: CALL_OW 297
28339: PUSH
28340: LD_VAR 0 14
28344: GREATER
28345: IFFALSE 28349
// exit ;
28347: GO 28889
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28349: LD_ADDR_VAR 0 12
28353: PUSH
28354: LD_VAR 0 2
28358: PPUSH
28359: LD_VAR 0 3
28363: PPUSH
28364: LD_VAR 0 4
28368: PPUSH
28369: LD_VAR 0 5
28373: PPUSH
28374: LD_VAR 0 1
28378: PPUSH
28379: CALL_OW 248
28383: PPUSH
28384: LD_INT 0
28386: PPUSH
28387: CALL 28894 0 6
28391: ST_TO_ADDR
// if not hexes then
28392: LD_VAR 0 12
28396: NOT
28397: IFFALSE 28401
// exit ;
28399: GO 28889
// hex := GetHexInfo ( x , y ) ;
28401: LD_ADDR_VAR 0 15
28405: PUSH
28406: LD_VAR 0 3
28410: PPUSH
28411: LD_VAR 0 4
28415: PPUSH
28416: CALL_OW 546
28420: ST_TO_ADDR
// if hex [ 1 ] then
28421: LD_VAR 0 15
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: IFFALSE 28433
// exit ;
28431: GO 28889
// height := hex [ 2 ] ;
28433: LD_ADDR_VAR 0 13
28437: PUSH
28438: LD_VAR 0 15
28442: PUSH
28443: LD_INT 2
28445: ARRAY
28446: ST_TO_ADDR
// for i = 1 to hexes do
28447: LD_ADDR_VAR 0 7
28451: PUSH
28452: DOUBLE
28453: LD_INT 1
28455: DEC
28456: ST_TO_ADDR
28457: LD_VAR 0 12
28461: PUSH
28462: FOR_TO
28463: IFFALSE 28793
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28465: LD_VAR 0 12
28469: PUSH
28470: LD_VAR 0 7
28474: ARRAY
28475: PUSH
28476: LD_INT 1
28478: ARRAY
28479: PPUSH
28480: LD_VAR 0 12
28484: PUSH
28485: LD_VAR 0 7
28489: ARRAY
28490: PUSH
28491: LD_INT 2
28493: ARRAY
28494: PPUSH
28495: CALL_OW 488
28499: NOT
28500: PUSH
28501: LD_VAR 0 12
28505: PUSH
28506: LD_VAR 0 7
28510: ARRAY
28511: PUSH
28512: LD_INT 1
28514: ARRAY
28515: PPUSH
28516: LD_VAR 0 12
28520: PUSH
28521: LD_VAR 0 7
28525: ARRAY
28526: PUSH
28527: LD_INT 2
28529: ARRAY
28530: PPUSH
28531: CALL_OW 428
28535: PUSH
28536: LD_INT 0
28538: GREATER
28539: OR
28540: PUSH
28541: LD_VAR 0 12
28545: PUSH
28546: LD_VAR 0 7
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: PPUSH
28556: LD_VAR 0 12
28560: PUSH
28561: LD_VAR 0 7
28565: ARRAY
28566: PUSH
28567: LD_INT 2
28569: ARRAY
28570: PPUSH
28571: CALL_OW 351
28575: OR
28576: IFFALSE 28582
// exit ;
28578: POP
28579: POP
28580: GO 28889
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28582: LD_ADDR_VAR 0 8
28586: PUSH
28587: LD_VAR 0 12
28591: PUSH
28592: LD_VAR 0 7
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: ARRAY
28601: PPUSH
28602: LD_VAR 0 12
28606: PUSH
28607: LD_VAR 0 7
28611: ARRAY
28612: PUSH
28613: LD_INT 2
28615: ARRAY
28616: PPUSH
28617: CALL_OW 546
28621: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28622: LD_VAR 0 8
28626: PUSH
28627: LD_INT 1
28629: ARRAY
28630: PUSH
28631: LD_VAR 0 8
28635: PUSH
28636: LD_INT 2
28638: ARRAY
28639: PUSH
28640: LD_VAR 0 13
28644: PUSH
28645: LD_INT 2
28647: PLUS
28648: GREATER
28649: OR
28650: PUSH
28651: LD_VAR 0 8
28655: PUSH
28656: LD_INT 2
28658: ARRAY
28659: PUSH
28660: LD_VAR 0 13
28664: PUSH
28665: LD_INT 2
28667: MINUS
28668: LESS
28669: OR
28670: PUSH
28671: LD_VAR 0 8
28675: PUSH
28676: LD_INT 3
28678: ARRAY
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 8
28685: PUSH
28686: LD_INT 9
28688: PUSH
28689: LD_INT 10
28691: PUSH
28692: LD_INT 11
28694: PUSH
28695: LD_INT 12
28697: PUSH
28698: LD_INT 13
28700: PUSH
28701: LD_INT 16
28703: PUSH
28704: LD_INT 17
28706: PUSH
28707: LD_INT 18
28709: PUSH
28710: LD_INT 19
28712: PUSH
28713: LD_INT 20
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: LIST
28733: IN
28734: NOT
28735: OR
28736: PUSH
28737: LD_VAR 0 8
28741: PUSH
28742: LD_INT 5
28744: ARRAY
28745: NOT
28746: OR
28747: PUSH
28748: LD_VAR 0 8
28752: PUSH
28753: LD_INT 6
28755: ARRAY
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 7
28765: PUSH
28766: LD_INT 9
28768: PUSH
28769: LD_INT 10
28771: PUSH
28772: LD_INT 11
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: IN
28783: NOT
28784: OR
28785: IFFALSE 28791
// exit ;
28787: POP
28788: POP
28789: GO 28889
// end ;
28791: GO 28462
28793: POP
28794: POP
// side := GetSide ( depot ) ;
28795: LD_ADDR_VAR 0 9
28799: PUSH
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 255
28809: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28810: LD_VAR 0 9
28814: PPUSH
28815: LD_VAR 0 3
28819: PPUSH
28820: LD_VAR 0 4
28824: PPUSH
28825: LD_INT 20
28827: PPUSH
28828: CALL 21561 0 4
28832: PUSH
28833: LD_INT 4
28835: ARRAY
28836: IFFALSE 28840
// exit ;
28838: GO 28889
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28840: LD_VAR 0 2
28844: PUSH
28845: LD_INT 29
28847: PUSH
28848: LD_INT 30
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: IN
28855: PUSH
28856: LD_VAR 0 3
28860: PPUSH
28861: LD_VAR 0 4
28865: PPUSH
28866: LD_VAR 0 9
28870: PPUSH
28871: CALL_OW 440
28875: NOT
28876: AND
28877: IFFALSE 28881
// exit ;
28879: GO 28889
// result := true ;
28881: LD_ADDR_VAR 0 6
28885: PUSH
28886: LD_INT 1
28888: ST_TO_ADDR
// end ;
28889: LD_VAR 0 6
28893: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28894: LD_INT 0
28896: PPUSH
28897: PPUSH
28898: PPUSH
28899: PPUSH
28900: PPUSH
28901: PPUSH
28902: PPUSH
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
// result = [ ] ;
28954: LD_ADDR_VAR 0 7
28958: PUSH
28959: EMPTY
28960: ST_TO_ADDR
// temp_list = [ ] ;
28961: LD_ADDR_VAR 0 9
28965: PUSH
28966: EMPTY
28967: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28968: LD_VAR 0 4
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 4
28987: PUSH
28988: LD_INT 5
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: IN
28999: NOT
29000: PUSH
29001: LD_VAR 0 1
29005: PUSH
29006: LD_INT 0
29008: PUSH
29009: LD_INT 1
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: IN
29016: PUSH
29017: LD_VAR 0 5
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: IN
29036: NOT
29037: AND
29038: OR
29039: IFFALSE 29043
// exit ;
29041: GO 47428
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29043: LD_VAR 0 1
29047: PUSH
29048: LD_INT 6
29050: PUSH
29051: LD_INT 7
29053: PUSH
29054: LD_INT 8
29056: PUSH
29057: LD_INT 13
29059: PUSH
29060: LD_INT 12
29062: PUSH
29063: LD_INT 15
29065: PUSH
29066: LD_INT 11
29068: PUSH
29069: LD_INT 14
29071: PUSH
29072: LD_INT 10
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: IN
29086: IFFALSE 29096
// btype = b_lab ;
29088: LD_ADDR_VAR 0 1
29092: PUSH
29093: LD_INT 6
29095: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29096: LD_VAR 0 6
29100: PUSH
29101: LD_INT 0
29103: PUSH
29104: LD_INT 1
29106: PUSH
29107: LD_INT 2
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: IN
29115: NOT
29116: PUSH
29117: LD_VAR 0 1
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: LD_INT 3
29133: PUSH
29134: LD_INT 6
29136: PUSH
29137: LD_INT 36
29139: PUSH
29140: LD_INT 4
29142: PUSH
29143: LD_INT 5
29145: PUSH
29146: LD_INT 31
29148: PUSH
29149: LD_INT 32
29151: PUSH
29152: LD_INT 33
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: IN
29168: NOT
29169: PUSH
29170: LD_VAR 0 6
29174: PUSH
29175: LD_INT 1
29177: EQUAL
29178: AND
29179: OR
29180: PUSH
29181: LD_VAR 0 1
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: IN
29196: NOT
29197: PUSH
29198: LD_VAR 0 6
29202: PUSH
29203: LD_INT 2
29205: EQUAL
29206: AND
29207: OR
29208: IFFALSE 29218
// mode = 0 ;
29210: LD_ADDR_VAR 0 6
29214: PUSH
29215: LD_INT 0
29217: ST_TO_ADDR
// case mode of 0 :
29218: LD_VAR 0 6
29222: PUSH
29223: LD_INT 0
29225: DOUBLE
29226: EQUAL
29227: IFTRUE 29231
29229: GO 40684
29231: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29232: LD_ADDR_VAR 0 11
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: LD_INT 0
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: LD_INT 1
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 0
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: LD_INT 1
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 1
29313: NEG
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 0
29325: PUSH
29326: LD_INT 2
29328: NEG
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: LD_INT 2
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 0
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: NEG
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: LD_INT 3
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: LD_INT 3
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: LD_INT 2
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29425: LD_ADDR_VAR 0 12
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 2
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: NEG
29538: PUSH
29539: LD_INT 1
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 2
29548: NEG
29549: PUSH
29550: LD_INT 0
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 2
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: NEG
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 3
29582: NEG
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 3
29593: NEG
29594: PUSH
29595: LD_INT 1
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29621: LD_ADDR_VAR 0 13
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 2
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 2
29724: PUSH
29725: LD_INT 2
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: LD_INT 2
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 1
29748: NEG
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 2
29756: NEG
29757: PUSH
29758: LD_INT 2
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: LD_INT 3
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 3
29780: NEG
29781: PUSH
29782: LD_INT 2
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 3
29792: NEG
29793: PUSH
29794: LD_INT 3
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29820: LD_ADDR_VAR 0 14
29824: PUSH
29825: LD_INT 0
29827: PUSH
29828: LD_INT 0
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: LD_INT 1
29840: NEG
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 0
29868: PUSH
29869: LD_INT 1
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 1
29878: NEG
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 1
29889: NEG
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 1
29901: NEG
29902: PUSH
29903: LD_INT 2
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: LD_INT 2
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: LD_INT 1
29927: NEG
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: LD_INT 2
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 2
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 1
29955: NEG
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 3
29981: NEG
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 2
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30016: LD_ADDR_VAR 0 15
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: LD_INT 0
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: NEG
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 2
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 2
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 1
30165: NEG
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 3
30173: PUSH
30174: LD_INT 0
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 3
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30209: LD_ADDR_VAR 0 16
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 0
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: NEG
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: LD_INT 2
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: NEG
30345: PUSH
30346: LD_INT 2
30348: NEG
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 3
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 3
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: PUSH
30377: LD_INT 3
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30402: LD_ADDR_VAR 0 17
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: LD_INT 1
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: NEG
30461: PUSH
30462: LD_INT 0
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: LD_INT 2
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: LD_INT 2
30498: NEG
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: NEG
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 2
30527: PUSH
30528: LD_INT 1
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 2
30537: PUSH
30538: LD_INT 2
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 2
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 2
30578: NEG
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 2
30589: NEG
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: NEG
30602: PUSH
30603: LD_INT 2
30605: NEG
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30632: LD_ADDR_VAR 0 18
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: LD_INT 1
30652: NEG
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 1
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: LD_INT 1
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: LD_INT 1
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: NEG
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: LD_INT 2
30728: NEG
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 2
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 2
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 2
30767: PUSH
30768: LD_INT 2
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: PUSH
30778: LD_INT 2
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 2
30808: NEG
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 2
30819: NEG
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: LD_INT 2
30835: NEG
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30862: LD_ADDR_VAR 0 19
30866: PUSH
30867: LD_INT 0
30869: PUSH
30870: LD_INT 0
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: NEG
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 1
30943: NEG
30944: PUSH
30945: LD_INT 2
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 2
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: PUSH
31008: LD_INT 2
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: LD_INT 2
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: NEG
31062: PUSH
31063: LD_INT 2
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31092: LD_ADDR_VAR 0 20
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 0
31185: PUSH
31186: LD_INT 2
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 1
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 2
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 2
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: LD_INT 2
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 2
31268: NEG
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 2
31279: NEG
31280: PUSH
31281: LD_INT 1
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31322: LD_ADDR_VAR 0 21
31326: PUSH
31327: LD_INT 0
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: LD_INT 0
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: LD_INT 0
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: LD_INT 1
31395: NEG
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 1
31403: NEG
31404: PUSH
31405: LD_INT 2
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: LD_INT 2
31418: NEG
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 2
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 2
31457: PUSH
31458: LD_INT 2
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: LD_INT 2
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 2
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 2
31498: NEG
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 2
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: NEG
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 2
31521: NEG
31522: PUSH
31523: LD_INT 2
31525: NEG
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31552: LD_ADDR_VAR 0 22
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 1
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 0
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: NEG
31634: PUSH
31635: LD_INT 2
31637: NEG
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 0
31645: PUSH
31646: LD_INT 2
31648: NEG
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 2
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 2
31687: PUSH
31688: LD_INT 2
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 2
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: LD_INT 2
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: LD_INT 1
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 2
31739: NEG
31740: PUSH
31741: LD_INT 1
31743: NEG
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: NEG
31752: PUSH
31753: LD_INT 2
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31782: LD_ADDR_VAR 0 23
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: LD_INT 1
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 0
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: LD_INT 1
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: NEG
31864: PUSH
31865: LD_INT 2
31867: NEG
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: LD_INT 2
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 2
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 2
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: NEG
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: NEG
31982: PUSH
31983: LD_INT 2
31985: NEG
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 3
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 3
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32062: LD_ADDR_VAR 0 24
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 1
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: LD_INT 1
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 1
32120: NEG
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 0
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: LD_INT 1
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 2
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 2
32187: PUSH
32188: LD_INT 1
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 2
32197: PUSH
32198: LD_INT 2
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: PUSH
32208: LD_INT 2
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 2
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: NEG
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 2
32238: NEG
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 2
32249: NEG
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: NEG
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 2
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 1
32287: NEG
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 3
32295: PUSH
32296: LD_INT 1
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 3
32305: PUSH
32306: LD_INT 2
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32338: LD_ADDR_VAR 0 25
32342: PUSH
32343: LD_INT 0
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: LD_INT 0
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: LD_INT 1
32411: NEG
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: LD_INT 2
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: LD_INT 0
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: LD_INT 1
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 2
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: LD_INT 2
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 2
32514: NEG
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: LD_INT 1
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: LD_INT 2
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 3
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 3
32559: PUSH
32560: LD_INT 2
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 3
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 3
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32612: LD_ADDR_VAR 0 26
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: LD_INT 0
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 1
32632: NEG
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 1
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: LD_INT 1
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: LD_INT 1
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: NEG
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: NEG
32694: PUSH
32695: LD_INT 2
32697: NEG
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: NEG
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: LD_INT 2
32815: NEG
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: LD_INT 3
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: LD_INT 3
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: LD_INT 2
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 2
32854: NEG
32855: PUSH
32856: LD_INT 1
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32888: LD_ADDR_VAR 0 27
32892: PUSH
32893: LD_INT 0
32895: PUSH
32896: LD_INT 0
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: LD_INT 1
32908: NEG
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 1
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: LD_INT 2
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: LD_INT 1
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: LD_INT 2
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 0
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 1
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: NEG
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 2
33110: NEG
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 3
33121: NEG
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 3
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33168: LD_ADDR_VAR 0 28
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 1
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: LD_INT 1
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: NEG
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: NEG
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: LD_INT 2
33253: NEG
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: NEG
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 0
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 2
33355: NEG
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 2
33371: NEG
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 2
33379: NEG
33380: PUSH
33381: LD_INT 3
33383: NEG
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: LD_INT 3
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 3
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33450: LD_ADDR_VAR 0 29
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: PUSH
33566: LD_INT 0
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 2
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: LD_INT 2
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 0
33595: PUSH
33596: LD_INT 2
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 1
33605: NEG
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 2
33628: NEG
33629: PUSH
33630: LD_INT 2
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 2
33640: NEG
33641: PUSH
33642: LD_INT 3
33644: NEG
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 3
33663: PUSH
33664: LD_INT 1
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: LD_INT 3
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 3
33694: NEG
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33729: LD_ADDR_VAR 0 30
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: LD_INT 0
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 1
33810: NEG
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 0
33822: PUSH
33823: LD_INT 2
33825: NEG
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: LD_INT 0
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 2
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: PUSH
33865: LD_INT 2
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: NEG
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 2
33906: NEG
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 3
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 2
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: LD_INT 2
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 3
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 2
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 3
33972: NEG
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34007: LD_ADDR_VAR 0 31
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: LD_INT 2
34092: NEG
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 2
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 2
34131: PUSH
34132: LD_INT 2
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: LD_INT 2
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 0
34151: PUSH
34152: LD_INT 2
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: NEG
34197: PUSH
34198: LD_INT 3
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 2
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 3
34250: NEG
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34285: LD_ADDR_VAR 0 32
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 2
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: NEG
34441: PUSH
34442: LD_INT 1
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: NEG
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 2
34462: NEG
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 3
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 2
34489: NEG
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 3
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 3
34528: NEG
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34563: LD_ADDR_VAR 0 33
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: LD_INT 0
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: LD_INT 1
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 1
34636: NEG
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: LD_INT 2
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: LD_INT 2
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: NEG
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: LD_INT 1
34733: NEG
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: NEG
34742: PUSH
34743: LD_INT 2
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: LD_INT 3
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 2
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 3
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: LD_INT 3
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 3
34807: NEG
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34842: LD_ADDR_VAR 0 34
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 0
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: LD_INT 1
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: LD_INT 1
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: LD_INT 0
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: LD_INT 2
34927: NEG
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: LD_INT 1
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 3
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 2
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 3
35056: PUSH
35057: LD_INT 2
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: LD_INT 3
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 2
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 3
35087: NEG
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35122: LD_ADDR_VAR 0 35
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 0
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: LD_INT 1
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35234: LD_ADDR_VAR 0 36
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: LD_INT 1
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: LD_INT 0
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 2
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 2
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35346: LD_ADDR_VAR 0 37
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 0
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 0
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35458: LD_ADDR_VAR 0 38
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: NEG
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35570: LD_ADDR_VAR 0 39
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35682: LD_ADDR_VAR 0 40
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: LD_INT 1
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35794: LD_ADDR_VAR 0 41
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 1
35863: NEG
35864: PUSH
35865: LD_INT 1
35867: NEG
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 2
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: NEG
35961: PUSH
35962: LD_INT 1
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 2
35972: NEG
35973: PUSH
35974: LD_INT 2
35976: NEG
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 2
35984: NEG
35985: PUSH
35986: LD_INT 3
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 3
36017: PUSH
36018: LD_INT 1
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: LD_INT 2
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 3
36037: PUSH
36038: LD_INT 3
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: LD_INT 3
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: NEG
36058: PUSH
36059: LD_INT 1
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: LD_INT 0
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 3
36079: NEG
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 3
36091: NEG
36092: PUSH
36093: LD_INT 2
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 3
36103: NEG
36104: PUSH
36105: LD_INT 3
36107: NEG
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36144: LD_ADDR_VAR 0 42
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 2
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: LD_INT 2
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: LD_INT 3
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 3
36350: NEG
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 2
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 3
36380: PUSH
36381: LD_INT 2
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: LD_INT 3
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 3
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 3
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 3
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: NEG
36431: PUSH
36432: LD_INT 2
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 3
36441: NEG
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 3
36453: NEG
36454: PUSH
36455: LD_INT 3
36457: NEG
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36494: LD_ADDR_VAR 0 43
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 0
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: LD_INT 1
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: NEG
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 2
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 1
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 2
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 2
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: LD_INT 2
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: LD_INT 1
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 2
36671: NEG
36672: PUSH
36673: LD_INT 1
36675: NEG
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: LD_INT 3
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 0
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 2
36709: NEG
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 2
36717: PUSH
36718: LD_INT 1
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 3
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 3
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: LD_INT 3
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: LD_INT 3
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 3
36790: NEG
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 3
36801: NEG
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: LIST
36815: LIST
36816: LIST
36817: LIST
36818: LIST
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36842: LD_ADDR_VAR 0 44
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 1
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 1
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 1
36900: NEG
36901: PUSH
36902: LD_INT 0
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 1
36923: NEG
36924: PUSH
36925: LD_INT 2
36927: NEG
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 2
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: LD_INT 2
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: LD_INT 2
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 2
36997: NEG
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: NEG
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: NEG
37021: PUSH
37022: LD_INT 2
37024: NEG
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 2
37032: NEG
37033: PUSH
37034: LD_INT 3
37036: NEG
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 2
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: LD_INT 1
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 3
37075: PUSH
37076: LD_INT 2
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 3
37085: PUSH
37086: LD_INT 3
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: LD_INT 3
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 2
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 3
37116: NEG
37117: PUSH
37118: LD_INT 0
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 3
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 3
37139: NEG
37140: PUSH
37141: LD_INT 2
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 3
37151: NEG
37152: PUSH
37153: LD_INT 3
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37192: LD_ADDR_VAR 0 45
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 1
37220: PUSH
37221: LD_INT 0
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: NEG
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: LD_INT 2
37277: NEG
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 2
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: PUSH
37297: LD_INT 1
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: LD_INT 2
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 1
37327: PUSH
37328: LD_INT 2
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 0
37337: PUSH
37338: LD_INT 2
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 1
37347: NEG
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: NEG
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: LD_INT 3
37386: NEG
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: LD_INT 3
37398: NEG
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 0
37406: PUSH
37407: LD_INT 3
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 3
37428: PUSH
37429: LD_INT 2
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 3
37438: PUSH
37439: LD_INT 3
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: PUSH
37449: LD_INT 3
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: PUSH
37459: LD_INT 3
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: LD_INT 3
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: NEG
37479: PUSH
37480: LD_INT 2
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 3
37489: NEG
37490: PUSH
37491: LD_INT 2
37493: NEG
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: LD_INT 3
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37542: LD_ADDR_VAR 0 46
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 0
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 0
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: LD_INT 2
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 1
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 2
37708: NEG
37709: PUSH
37710: LD_INT 0
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: NEG
37720: PUSH
37721: LD_INT 1
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: LD_INT 3
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 0
37743: PUSH
37744: LD_INT 3
37746: NEG
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 2
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 3
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 1
37796: PUSH
37797: LD_INT 3
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 1
37816: NEG
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 2
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 3
37838: NEG
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 3
37849: NEG
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37890: LD_ADDR_VAR 0 47
37894: PUSH
37895: LD_INT 0
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: LD_INT 1
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 1
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 1
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: LD_INT 1
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: LD_INT 0
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 1
37959: NEG
37960: PUSH
37961: LD_INT 1
37963: NEG
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 1
37971: NEG
37972: PUSH
37973: LD_INT 2
37975: NEG
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: LD_INT 2
37986: NEG
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 2
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38041: LD_ADDR_VAR 0 48
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 1
38110: NEG
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: LD_INT 2
38126: NEG
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: LD_INT 2
38137: NEG
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: PUSH
38167: LD_INT 1
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38188: LD_ADDR_VAR 0 49
38192: PUSH
38193: LD_INT 0
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: LD_INT 1
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 0
38236: PUSH
38237: LD_INT 1
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 1
38257: NEG
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 2
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: PUSH
38301: LD_INT 2
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38332: LD_ADDR_VAR 0 50
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 0
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: LD_INT 1
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 0
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: NEG
38391: PUSH
38392: LD_INT 0
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 1
38405: NEG
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: LD_INT 2
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: LD_INT 2
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: LD_INT 2
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38476: LD_ADDR_VAR 0 51
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: LD_INT 1
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 2
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38623: LD_ADDR_VAR 0 52
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: LD_INT 1
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 1
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 1
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 1
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 2
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38774: LD_ADDR_VAR 0 53
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: LD_INT 1
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 1
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 1
38832: NEG
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: NEG
38844: PUSH
38845: LD_INT 1
38847: NEG
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: LD_INT 2
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: LD_INT 1
38881: NEG
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 2
38889: PUSH
38890: LD_INT 0
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: LD_INT 2
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: LD_INT 2
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 2
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: NEG
38974: PUSH
38975: LD_INT 2
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: LIST
38987: LIST
38988: LIST
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39004: LD_ADDR_VAR 0 54
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 1
39042: PUSH
39043: LD_INT 1
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: LD_INT 1
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 1
39085: NEG
39086: PUSH
39087: LD_INT 2
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: LD_INT 2
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 2
39129: PUSH
39130: LD_INT 1
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 2
39139: PUSH
39140: LD_INT 2
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: LD_INT 2
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 2
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: NEG
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39234: LD_ADDR_VAR 0 55
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 0
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 1
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 1
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 0
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 2
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 2
39369: PUSH
39370: LD_INT 2
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: LD_INT 2
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: LD_INT 2
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: NEG
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 2
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39464: LD_ADDR_VAR 0 56
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 0
39557: PUSH
39558: LD_INT 2
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 1
39568: PUSH
39569: LD_INT 1
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 2
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: LD_INT 2
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: LD_INT 2
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: LD_INT 2
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 1
39629: NEG
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 2
39640: NEG
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: NEG
39664: PUSH
39665: LD_INT 2
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39694: LD_ADDR_VAR 0 57
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 1
39722: PUSH
39723: LD_INT 0
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 0
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 1
39752: NEG
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 1
39775: NEG
39776: PUSH
39777: LD_INT 2
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 2
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 2
39809: PUSH
39810: LD_INT 0
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: LD_INT 1
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: PUSH
39830: LD_INT 2
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: LD_INT 2
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 2
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39924: LD_ADDR_VAR 0 58
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: LD_INT 0
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 1
39962: PUSH
39963: LD_INT 1
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 0
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 1
39982: NEG
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: NEG
40006: PUSH
40007: LD_INT 2
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: LD_INT 2
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: LD_INT 1
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 2
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 2
40059: PUSH
40060: LD_INT 2
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: LD_INT 2
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 0
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 2
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 2
40123: NEG
40124: PUSH
40125: LD_INT 2
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40154: LD_ADDR_VAR 0 59
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: LD_INT 1
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: LD_INT 1
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40242: LD_ADDR_VAR 0 60
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: LD_INT 1
40262: NEG
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 1
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 1
40280: PUSH
40281: LD_INT 1
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 1
40300: NEG
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40330: LD_ADDR_VAR 0 61
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: LD_INT 0
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: LD_INT 1
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 0
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: LD_INT 1
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: LD_INT 1
40403: NEG
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40418: LD_ADDR_VAR 0 62
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: LD_INT 0
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: LD_INT 1
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 0
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 1
40476: NEG
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40506: LD_ADDR_VAR 0 63
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 0
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: PUSH
40545: LD_INT 1
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: LD_INT 1
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: LD_INT 1
40579: NEG
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40594: LD_ADDR_VAR 0 64
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: LD_INT 0
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: LD_INT 1
40614: NEG
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 1
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 1
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 0
40642: PUSH
40643: LD_INT 1
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 1
40663: NEG
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: ST_TO_ADDR
// end ; 1 :
40682: GO 46579
40684: LD_INT 1
40686: DOUBLE
40687: EQUAL
40688: IFTRUE 40692
40690: GO 43315
40692: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40693: LD_ADDR_VAR 0 11
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 3
40704: NEG
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: LD_INT 3
40715: NEG
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: LIST
40736: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40737: LD_ADDR_VAR 0 12
40741: PUSH
40742: LD_INT 2
40744: PUSH
40745: LD_INT 1
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 3
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40778: LD_ADDR_VAR 0 13
40782: PUSH
40783: LD_INT 3
40785: PUSH
40786: LD_INT 2
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: LD_INT 3
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 2
40805: PUSH
40806: LD_INT 3
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40818: LD_ADDR_VAR 0 14
40822: PUSH
40823: LD_INT 1
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 1
40845: NEG
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: LIST
40858: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40859: LD_ADDR_VAR 0 15
40863: PUSH
40864: LD_INT 2
40866: NEG
40867: PUSH
40868: LD_INT 1
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40903: LD_ADDR_VAR 0 16
40907: PUSH
40908: LD_INT 2
40910: NEG
40911: PUSH
40912: LD_INT 3
40914: NEG
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: NEG
40923: PUSH
40924: LD_INT 2
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 3
40934: NEG
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: LIST
40948: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40949: LD_ADDR_VAR 0 17
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: LD_INT 3
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 0
40968: PUSH
40969: LD_INT 3
40971: NEG
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: LIST
40992: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40993: LD_ADDR_VAR 0 18
40997: PUSH
40998: LD_INT 2
41000: PUSH
41001: LD_INT 1
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 3
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: LIST
41033: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41034: LD_ADDR_VAR 0 19
41038: PUSH
41039: LD_INT 3
41041: PUSH
41042: LD_INT 2
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 3
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: PUSH
41062: LD_INT 3
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41074: LD_ADDR_VAR 0 20
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 3
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: LD_INT 2
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: LIST
41114: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41115: LD_ADDR_VAR 0 21
41119: PUSH
41120: LD_INT 2
41122: NEG
41123: PUSH
41124: LD_INT 1
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 1
41148: NEG
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41159: LD_ADDR_VAR 0 22
41163: PUSH
41164: LD_INT 2
41166: NEG
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 3
41178: NEG
41179: PUSH
41180: LD_INT 2
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 3
41190: NEG
41191: PUSH
41192: LD_INT 3
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41205: LD_ADDR_VAR 0 23
41209: PUSH
41210: LD_INT 0
41212: PUSH
41213: LD_INT 3
41215: NEG
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 1
41223: NEG
41224: PUSH
41225: LD_INT 4
41227: NEG
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: LD_INT 3
41238: NEG
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: LIST
41248: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41249: LD_ADDR_VAR 0 24
41253: PUSH
41254: LD_INT 3
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 3
41266: PUSH
41267: LD_INT 1
41269: NEG
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: LIST
41289: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41290: LD_ADDR_VAR 0 25
41294: PUSH
41295: LD_INT 3
41297: PUSH
41298: LD_INT 3
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 4
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 3
41317: PUSH
41318: LD_INT 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41330: LD_ADDR_VAR 0 26
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 3
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: NEG
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: LIST
41370: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41371: LD_ADDR_VAR 0 27
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: LD_INT 1
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41415: LD_ADDR_VAR 0 28
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: LD_INT 4
41438: NEG
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 3
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41461: LD_ADDR_VAR 0 29
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 3
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 2
41494: NEG
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PUSH
41504: LD_INT 4
41506: NEG
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 0
41514: PUSH
41515: LD_INT 4
41517: NEG
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: LD_INT 3
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: LD_INT 5
41540: NEG
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 0
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: LD_INT 4
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: LD_INT 6
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 6
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 1
41593: PUSH
41594: LD_INT 5
41596: NEG
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41616: LD_ADDR_VAR 0 30
41620: PUSH
41621: LD_INT 2
41623: PUSH
41624: LD_INT 1
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: PUSH
41635: LD_INT 0
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 3
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 4
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 4
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 4
41685: PUSH
41686: LD_INT 1
41688: NEG
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 5
41696: PUSH
41697: LD_INT 0
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 5
41706: PUSH
41707: LD_INT 1
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 5
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 6
41727: PUSH
41728: LD_INT 0
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 6
41737: PUSH
41738: LD_INT 1
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41759: LD_ADDR_VAR 0 31
41763: PUSH
41764: LD_INT 3
41766: PUSH
41767: LD_INT 2
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 3
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: PUSH
41787: LD_INT 3
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 4
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 4
41806: PUSH
41807: LD_INT 4
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: PUSH
41817: LD_INT 4
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 5
41826: PUSH
41827: LD_INT 4
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 5
41836: PUSH
41837: LD_INT 5
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 4
41846: PUSH
41847: LD_INT 5
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 6
41856: PUSH
41857: LD_INT 5
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 6
41866: PUSH
41867: LD_INT 6
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 5
41876: PUSH
41877: LD_INT 6
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41898: LD_ADDR_VAR 0 32
41902: PUSH
41903: LD_INT 1
41905: PUSH
41906: LD_INT 3
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 0
41915: PUSH
41916: LD_INT 3
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 1
41925: NEG
41926: PUSH
41927: LD_INT 2
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 1
41936: PUSH
41937: LD_INT 4
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: LD_INT 4
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: NEG
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 1
41967: PUSH
41968: LD_INT 5
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 0
41977: PUSH
41978: LD_INT 5
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 4
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 1
41998: PUSH
41999: LD_INT 6
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 0
42008: PUSH
42009: LD_INT 6
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 5
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42041: LD_ADDR_VAR 0 33
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 3
42070: NEG
42071: PUSH
42072: LD_INT 1
42074: NEG
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: NEG
42094: PUSH
42095: LD_INT 0
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: PUSH
42102: LD_INT 4
42104: NEG
42105: PUSH
42106: LD_INT 1
42108: NEG
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 4
42116: NEG
42117: PUSH
42118: LD_INT 1
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 5
42127: NEG
42128: PUSH
42129: LD_INT 0
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 5
42150: NEG
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 6
42161: NEG
42162: PUSH
42163: LD_INT 0
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 6
42172: NEG
42173: PUSH
42174: LD_INT 1
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42196: LD_ADDR_VAR 0 34
42200: PUSH
42201: LD_INT 2
42203: NEG
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 3
42239: NEG
42240: PUSH
42241: LD_INT 4
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 4
42251: NEG
42252: PUSH
42253: LD_INT 3
42255: NEG
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 4
42263: NEG
42264: PUSH
42265: LD_INT 4
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 4
42275: NEG
42276: PUSH
42277: LD_INT 5
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 5
42287: NEG
42288: PUSH
42289: LD_INT 4
42291: NEG
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 5
42299: NEG
42300: PUSH
42301: LD_INT 5
42303: NEG
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: LD_INT 5
42311: NEG
42312: PUSH
42313: LD_INT 6
42315: NEG
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 6
42323: NEG
42324: PUSH
42325: LD_INT 5
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 6
42335: NEG
42336: PUSH
42337: LD_INT 6
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42359: LD_ADDR_VAR 0 41
42363: PUSH
42364: LD_INT 0
42366: PUSH
42367: LD_INT 2
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 1
42377: NEG
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 1
42389: PUSH
42390: LD_INT 2
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: LIST
42402: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42403: LD_ADDR_VAR 0 42
42407: PUSH
42408: LD_INT 2
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 2
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 3
42431: PUSH
42432: LD_INT 1
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: LIST
42443: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42444: LD_ADDR_VAR 0 43
42448: PUSH
42449: LD_INT 2
42451: PUSH
42452: LD_INT 2
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: PUSH
42462: LD_INT 2
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42484: LD_ADDR_VAR 0 44
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 2
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: LD_INT 2
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: LIST
42524: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42525: LD_ADDR_VAR 0 45
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: LD_INT 0
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 3
42554: NEG
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42569: LD_ADDR_VAR 0 46
42573: PUSH
42574: LD_INT 2
42576: NEG
42577: PUSH
42578: LD_INT 2
42580: NEG
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 2
42588: NEG
42589: PUSH
42590: LD_INT 3
42592: NEG
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: LD_INT 2
42604: NEG
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: LIST
42614: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42615: LD_ADDR_VAR 0 47
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: LD_INT 3
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 1
42634: NEG
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42648: LD_ADDR_VAR 0 48
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 2
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 2
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42679: LD_ADDR_VAR 0 49
42683: PUSH
42684: LD_INT 3
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: LD_INT 2
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42708: LD_ADDR_VAR 0 50
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: LD_INT 3
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 1
42725: PUSH
42726: LD_INT 3
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42737: LD_ADDR_VAR 0 51
42741: PUSH
42742: LD_INT 1
42744: NEG
42745: PUSH
42746: LD_INT 2
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 2
42755: NEG
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42768: LD_ADDR_VAR 0 52
42772: PUSH
42773: LD_INT 3
42775: NEG
42776: PUSH
42777: LD_INT 1
42779: NEG
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: LD_INT 2
42791: NEG
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42801: LD_ADDR_VAR 0 53
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 3
42812: NEG
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: LD_INT 3
42823: NEG
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: LIST
42844: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42845: LD_ADDR_VAR 0 54
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: LD_INT 1
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 3
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 3
42873: PUSH
42874: LD_INT 1
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: LIST
42885: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42886: LD_ADDR_VAR 0 55
42890: PUSH
42891: LD_INT 3
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: LD_INT 3
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 2
42913: PUSH
42914: LD_INT 3
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42926: LD_ADDR_VAR 0 56
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 3
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: LD_INT 3
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 1
42953: NEG
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: LIST
42966: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42967: LD_ADDR_VAR 0 57
42971: PUSH
42972: LD_INT 2
42974: NEG
42975: PUSH
42976: LD_INT 1
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 3
42985: NEG
42986: PUSH
42987: LD_INT 0
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: LD_INT 3
42996: NEG
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43011: LD_ADDR_VAR 0 58
43015: PUSH
43016: LD_INT 2
43018: NEG
43019: PUSH
43020: LD_INT 3
43022: NEG
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 3
43030: NEG
43031: PUSH
43032: LD_INT 2
43034: NEG
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 3
43042: NEG
43043: PUSH
43044: LD_INT 3
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: LIST
43056: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43057: LD_ADDR_VAR 0 59
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: LD_INT 2
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: LD_INT 2
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: LD_INT 1
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: LIST
43100: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43101: LD_ADDR_VAR 0 60
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: LD_INT 1
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: LIST
43141: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43142: LD_ADDR_VAR 0 61
43146: PUSH
43147: LD_INT 2
43149: PUSH
43150: LD_INT 1
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: PUSH
43160: LD_INT 2
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: PUSH
43170: LD_INT 2
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43182: LD_ADDR_VAR 0 62
43186: PUSH
43187: LD_INT 1
43189: PUSH
43190: LD_INT 2
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 2
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 1
43209: NEG
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: LIST
43222: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43223: LD_ADDR_VAR 0 63
43227: PUSH
43228: LD_INT 1
43230: NEG
43231: PUSH
43232: LD_INT 1
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: LD_INT 0
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 2
43252: NEG
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43267: LD_ADDR_VAR 0 64
43271: PUSH
43272: LD_INT 1
43274: NEG
43275: PUSH
43276: LD_INT 2
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 2
43286: NEG
43287: PUSH
43288: LD_INT 1
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: NEG
43299: PUSH
43300: LD_INT 2
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: ST_TO_ADDR
// end ; 2 :
43313: GO 46579
43315: LD_INT 2
43317: DOUBLE
43318: EQUAL
43319: IFTRUE 43323
43321: GO 46578
43323: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43324: LD_ADDR_VAR 0 29
43328: PUSH
43329: LD_INT 4
43331: PUSH
43332: LD_INT 0
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 4
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 5
43352: PUSH
43353: LD_INT 0
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 5
43362: PUSH
43363: LD_INT 1
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 4
43372: PUSH
43373: LD_INT 1
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 3
43382: PUSH
43383: LD_INT 0
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 3
43392: PUSH
43393: LD_INT 1
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 2
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 5
43414: PUSH
43415: LD_INT 2
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 3
43424: PUSH
43425: LD_INT 3
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: LD_INT 2
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 4
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 4
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: LD_INT 4
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 3
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 2
43484: PUSH
43485: LD_INT 2
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 4
43494: PUSH
43495: LD_INT 2
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: LD_INT 4
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 0
43514: PUSH
43515: LD_INT 4
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: LD_INT 3
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 1
43534: PUSH
43535: LD_INT 4
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 5
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 0
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 1
43564: NEG
43565: PUSH
43566: LD_INT 4
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 1
43575: NEG
43576: PUSH
43577: LD_INT 3
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 2
43586: PUSH
43587: LD_INT 5
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 3
43607: NEG
43608: PUSH
43609: LD_INT 0
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 3
43618: NEG
43619: PUSH
43620: LD_INT 1
43622: NEG
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: NEG
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 2
43641: NEG
43642: PUSH
43643: LD_INT 1
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 3
43652: NEG
43653: PUSH
43654: LD_INT 1
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 4
43663: NEG
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 4
43674: NEG
43675: PUSH
43676: LD_INT 1
43678: NEG
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 4
43686: NEG
43687: PUSH
43688: LD_INT 2
43690: NEG
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: LD_INT 2
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 4
43709: NEG
43710: PUSH
43711: LD_INT 4
43713: NEG
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 4
43721: NEG
43722: PUSH
43723: LD_INT 5
43725: NEG
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 3
43733: NEG
43734: PUSH
43735: LD_INT 4
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: LD_INT 3
43749: NEG
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 4
43757: NEG
43758: PUSH
43759: LD_INT 3
43761: NEG
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 5
43769: NEG
43770: PUSH
43771: LD_INT 4
43773: NEG
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: LD_INT 5
43785: NEG
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 3
43793: NEG
43794: PUSH
43795: LD_INT 5
43797: NEG
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 5
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: NEG
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43862: LD_ADDR_VAR 0 30
43866: PUSH
43867: LD_INT 4
43869: PUSH
43870: LD_INT 4
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 4
43879: PUSH
43880: LD_INT 3
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 5
43889: PUSH
43890: LD_INT 4
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 5
43899: PUSH
43900: LD_INT 5
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 4
43909: PUSH
43910: LD_INT 5
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: PUSH
43920: LD_INT 4
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 3
43929: PUSH
43930: LD_INT 3
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: LD_INT 3
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: LD_INT 5
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 0
43959: PUSH
43960: LD_INT 3
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 0
43969: PUSH
43970: LD_INT 2
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 1
43979: PUSH
43980: LD_INT 3
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: LD_INT 4
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 0
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: NEG
44010: PUSH
44011: LD_INT 3
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 1
44020: NEG
44021: PUSH
44022: LD_INT 2
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: NEG
44042: PUSH
44043: LD_INT 2
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 4
44052: NEG
44053: PUSH
44054: LD_INT 0
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 4
44063: NEG
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 3
44075: NEG
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: LD_INT 1
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: LD_INT 1
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 5
44108: NEG
44109: PUSH
44110: LD_INT 0
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 5
44119: NEG
44120: PUSH
44121: LD_INT 1
44123: NEG
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 5
44131: NEG
44132: PUSH
44133: LD_INT 2
44135: NEG
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 3
44143: NEG
44144: PUSH
44145: LD_INT 2
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 3
44154: NEG
44155: PUSH
44156: LD_INT 3
44158: NEG
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 3
44166: NEG
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 2
44178: NEG
44179: PUSH
44180: LD_INT 3
44182: NEG
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 2
44190: NEG
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: LD_INT 2
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 4
44214: NEG
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: LD_INT 4
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: LD_INT 4
44242: NEG
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 4
44250: NEG
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: LD_INT 4
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 1
44284: PUSH
44285: LD_INT 4
44287: NEG
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 1
44295: PUSH
44296: LD_INT 3
44298: NEG
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 0
44306: PUSH
44307: LD_INT 3
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 1
44317: NEG
44318: PUSH
44319: LD_INT 4
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 5
44333: NEG
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 2
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: LD_INT 5
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44409: LD_ADDR_VAR 0 31
44413: PUSH
44414: LD_INT 0
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: LD_INT 3
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 1
44436: PUSH
44437: LD_INT 4
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: LD_INT 5
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: LD_INT 5
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 1
44466: NEG
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 1
44477: NEG
44478: PUSH
44479: LD_INT 3
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 2
44488: PUSH
44489: LD_INT 5
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 2
44498: NEG
44499: PUSH
44500: LD_INT 3
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: LD_INT 0
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 3
44520: NEG
44521: PUSH
44522: LD_INT 1
44524: NEG
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 2
44532: NEG
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: LD_INT 1
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: LD_INT 1
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 4
44565: NEG
44566: PUSH
44567: LD_INT 0
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 4
44576: NEG
44577: PUSH
44578: LD_INT 1
44580: NEG
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 4
44588: NEG
44589: PUSH
44590: LD_INT 2
44592: NEG
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 2
44600: NEG
44601: PUSH
44602: LD_INT 2
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: LD_INT 4
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 4
44623: NEG
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 3
44635: NEG
44636: PUSH
44637: LD_INT 4
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 3
44647: NEG
44648: PUSH
44649: LD_INT 3
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 4
44659: NEG
44660: PUSH
44661: LD_INT 3
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 5
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: LD_INT 5
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 3
44695: NEG
44696: PUSH
44697: LD_INT 5
44699: NEG
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 5
44707: NEG
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 3
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: LD_INT 3
44744: NEG
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 1
44752: PUSH
44753: LD_INT 2
44755: NEG
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: LD_INT 2
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 1
44774: NEG
44775: PUSH
44776: LD_INT 3
44778: NEG
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: LD_INT 4
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 2
44798: PUSH
44799: LD_INT 2
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 2
44809: NEG
44810: PUSH
44811: LD_INT 4
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 4
44821: PUSH
44822: LD_INT 0
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 4
44831: PUSH
44832: LD_INT 1
44834: NEG
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 5
44842: PUSH
44843: LD_INT 0
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 5
44852: PUSH
44853: LD_INT 1
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 1
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 3
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 3
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 2
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 5
44904: PUSH
44905: LD_INT 2
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44959: LD_ADDR_VAR 0 32
44963: PUSH
44964: LD_INT 4
44966: NEG
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 4
44977: NEG
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 3
44989: NEG
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 3
45000: NEG
45001: PUSH
45002: LD_INT 1
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_INT 4
45011: NEG
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: LD_INT 5
45022: NEG
45023: PUSH
45024: LD_INT 0
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 5
45033: NEG
45034: PUSH
45035: LD_INT 1
45037: NEG
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 5
45045: NEG
45046: PUSH
45047: LD_INT 2
45049: NEG
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 3
45057: NEG
45058: PUSH
45059: LD_INT 2
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 3
45068: NEG
45069: PUSH
45070: LD_INT 3
45072: NEG
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 3
45080: NEG
45081: PUSH
45082: LD_INT 4
45084: NEG
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 2
45092: NEG
45093: PUSH
45094: LD_INT 3
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 3
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 4
45128: NEG
45129: PUSH
45130: LD_INT 3
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: LD_INT 4
45144: NEG
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 2
45152: NEG
45153: PUSH
45154: LD_INT 4
45156: NEG
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 4
45164: NEG
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 0
45176: PUSH
45177: LD_INT 4
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 1
45198: PUSH
45199: LD_INT 4
45201: NEG
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 1
45209: PUSH
45210: LD_INT 3
45212: NEG
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: LD_INT 3
45223: NEG
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 1
45231: NEG
45232: PUSH
45233: LD_INT 4
45235: NEG
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 1
45243: NEG
45244: PUSH
45245: LD_INT 5
45247: NEG
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 2
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 2
45266: NEG
45267: PUSH
45268: LD_INT 5
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: LD_INT 0
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 3
45288: PUSH
45289: LD_INT 1
45291: NEG
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 4
45299: PUSH
45300: LD_INT 0
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 4
45309: PUSH
45310: LD_INT 1
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 1
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: LD_INT 0
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 2
45339: PUSH
45340: LD_INT 1
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 2
45350: PUSH
45351: LD_INT 2
45353: NEG
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: LD_INT 2
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 4
45371: PUSH
45372: LD_INT 4
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: LD_INT 3
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 5
45391: PUSH
45392: LD_INT 4
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 5
45401: PUSH
45402: LD_INT 5
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 4
45411: PUSH
45412: LD_INT 5
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 4
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 3
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 5
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 3
45451: PUSH
45452: LD_INT 5
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45506: LD_ADDR_VAR 0 33
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: LD_INT 4
45517: NEG
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 4
45525: NEG
45526: PUSH
45527: LD_INT 5
45529: NEG
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: NEG
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 3
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 4
45561: NEG
45562: PUSH
45563: LD_INT 3
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 5
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 5
45585: NEG
45586: PUSH
45587: LD_INT 5
45589: NEG
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 3
45597: NEG
45598: PUSH
45599: LD_INT 5
45601: NEG
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 5
45609: NEG
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 0
45621: PUSH
45622: LD_INT 3
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 0
45632: PUSH
45633: LD_INT 4
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 1
45643: PUSH
45644: LD_INT 3
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 1
45654: PUSH
45655: LD_INT 2
45657: NEG
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PUSH
45663: LD_INT 0
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 1
45676: NEG
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 1
45688: NEG
45689: PUSH
45690: LD_INT 4
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 2
45700: PUSH
45701: LD_INT 2
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 2
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 4
45723: PUSH
45724: LD_INT 0
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 4
45733: PUSH
45734: LD_INT 1
45736: NEG
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 5
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 5
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 4
45764: PUSH
45765: LD_INT 1
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 0
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 3
45784: PUSH
45785: LD_INT 1
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 3
45795: PUSH
45796: LD_INT 2
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 5
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 3
45816: PUSH
45817: LD_INT 3
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 3
45826: PUSH
45827: LD_INT 2
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 4
45836: PUSH
45837: LD_INT 3
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 4
45846: PUSH
45847: LD_INT 4
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: LD_INT 4
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 3
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 2
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 4
45886: PUSH
45887: LD_INT 2
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 2
45896: PUSH
45897: LD_INT 4
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 0
45906: PUSH
45907: LD_INT 4
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 0
45916: PUSH
45917: LD_INT 3
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: PUSH
45927: LD_INT 4
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 1
45936: PUSH
45937: LD_INT 5
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: LD_INT 5
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 1
45956: NEG
45957: PUSH
45958: LD_INT 4
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 1
45967: NEG
45968: PUSH
45969: LD_INT 3
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 2
45978: PUSH
45979: LD_INT 5
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 2
45988: NEG
45989: PUSH
45990: LD_INT 3
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46044: LD_ADDR_VAR 0 34
46048: PUSH
46049: LD_INT 0
46051: PUSH
46052: LD_INT 4
46054: NEG
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 5
46065: NEG
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 1
46073: PUSH
46074: LD_INT 4
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 1
46084: PUSH
46085: LD_INT 3
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 0
46095: PUSH
46096: LD_INT 3
46098: NEG
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 1
46106: NEG
46107: PUSH
46108: LD_INT 4
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 1
46118: NEG
46119: PUSH
46120: LD_INT 5
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 2
46130: PUSH
46131: LD_INT 3
46133: NEG
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 2
46141: NEG
46142: PUSH
46143: LD_INT 5
46145: NEG
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 3
46153: PUSH
46154: LD_INT 0
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 3
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 4
46174: PUSH
46175: LD_INT 0
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 4
46184: PUSH
46185: LD_INT 1
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 3
46194: PUSH
46195: LD_INT 1
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 2
46204: PUSH
46205: LD_INT 0
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 2
46214: PUSH
46215: LD_INT 1
46217: NEG
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 2
46228: NEG
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 4
46236: PUSH
46237: LD_INT 2
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 4
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 5
46266: PUSH
46267: LD_INT 4
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 5
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 4
46286: PUSH
46287: LD_INT 5
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 3
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 3
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 5
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: LD_INT 5
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 0
46336: PUSH
46337: LD_INT 3
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 0
46346: PUSH
46347: LD_INT 2
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: LD_INT 3
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 1
46366: PUSH
46367: LD_INT 4
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 0
46376: PUSH
46377: LD_INT 4
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 1
46386: NEG
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 1
46397: NEG
46398: PUSH
46399: LD_INT 2
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 2
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 2
46418: NEG
46419: PUSH
46420: LD_INT 2
46422: PUSH
46423: EMPTY
46424: LIST
46425: LIST
46426: PUSH
46427: LD_INT 4
46429: NEG
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 4
46440: NEG
46441: PUSH
46442: LD_INT 1
46444: NEG
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 3
46452: NEG
46453: PUSH
46454: LD_INT 0
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 3
46463: NEG
46464: PUSH
46465: LD_INT 1
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: PUSH
46472: LD_INT 4
46474: NEG
46475: PUSH
46476: LD_INT 1
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PUSH
46483: LD_INT 5
46485: NEG
46486: PUSH
46487: LD_INT 0
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 5
46496: NEG
46497: PUSH
46498: LD_INT 1
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 5
46508: NEG
46509: PUSH
46510: LD_INT 2
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: LD_INT 2
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: ST_TO_ADDR
// end ; end ;
46576: GO 46579
46578: POP
// case btype of b_depot , b_warehouse :
46579: LD_VAR 0 1
46583: PUSH
46584: LD_INT 0
46586: DOUBLE
46587: EQUAL
46588: IFTRUE 46598
46590: LD_INT 1
46592: DOUBLE
46593: EQUAL
46594: IFTRUE 46598
46596: GO 46799
46598: POP
// case nation of nation_american :
46599: LD_VAR 0 5
46603: PUSH
46604: LD_INT 1
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46612
46610: GO 46668
46612: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46613: LD_ADDR_VAR 0 9
46617: PUSH
46618: LD_VAR 0 11
46622: PUSH
46623: LD_VAR 0 12
46627: PUSH
46628: LD_VAR 0 13
46632: PUSH
46633: LD_VAR 0 14
46637: PUSH
46638: LD_VAR 0 15
46642: PUSH
46643: LD_VAR 0 16
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 4
46660: PUSH
46661: LD_INT 1
46663: PLUS
46664: ARRAY
46665: ST_TO_ADDR
46666: GO 46797
46668: LD_INT 2
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46676
46674: GO 46732
46676: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 17
46686: PUSH
46687: LD_VAR 0 18
46691: PUSH
46692: LD_VAR 0 19
46696: PUSH
46697: LD_VAR 0 20
46701: PUSH
46702: LD_VAR 0 21
46706: PUSH
46707: LD_VAR 0 22
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: PUSH
46720: LD_VAR 0 4
46724: PUSH
46725: LD_INT 1
46727: PLUS
46728: ARRAY
46729: ST_TO_ADDR
46730: GO 46797
46732: LD_INT 3
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46796
46740: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_VAR 0 23
46750: PUSH
46751: LD_VAR 0 24
46755: PUSH
46756: LD_VAR 0 25
46760: PUSH
46761: LD_VAR 0 26
46765: PUSH
46766: LD_VAR 0 27
46770: PUSH
46771: LD_VAR 0 28
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: PUSH
46784: LD_VAR 0 4
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: ARRAY
46793: ST_TO_ADDR
46794: GO 46797
46796: POP
46797: GO 47346
46799: LD_INT 2
46801: DOUBLE
46802: EQUAL
46803: IFTRUE 46813
46805: LD_INT 3
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 46869
46813: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46814: LD_ADDR_VAR 0 9
46818: PUSH
46819: LD_VAR 0 29
46823: PUSH
46824: LD_VAR 0 30
46828: PUSH
46829: LD_VAR 0 31
46833: PUSH
46834: LD_VAR 0 32
46838: PUSH
46839: LD_VAR 0 33
46843: PUSH
46844: LD_VAR 0 34
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: PUSH
46857: LD_VAR 0 4
46861: PUSH
46862: LD_INT 1
46864: PLUS
46865: ARRAY
46866: ST_TO_ADDR
46867: GO 47346
46869: LD_INT 16
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46925
46875: LD_INT 17
46877: DOUBLE
46878: EQUAL
46879: IFTRUE 46925
46881: LD_INT 18
46883: DOUBLE
46884: EQUAL
46885: IFTRUE 46925
46887: LD_INT 19
46889: DOUBLE
46890: EQUAL
46891: IFTRUE 46925
46893: LD_INT 20
46895: DOUBLE
46896: EQUAL
46897: IFTRUE 46925
46899: LD_INT 21
46901: DOUBLE
46902: EQUAL
46903: IFTRUE 46925
46905: LD_INT 23
46907: DOUBLE
46908: EQUAL
46909: IFTRUE 46925
46911: LD_INT 24
46913: DOUBLE
46914: EQUAL
46915: IFTRUE 46925
46917: LD_INT 25
46919: DOUBLE
46920: EQUAL
46921: IFTRUE 46925
46923: GO 46981
46925: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46926: LD_ADDR_VAR 0 9
46930: PUSH
46931: LD_VAR 0 35
46935: PUSH
46936: LD_VAR 0 36
46940: PUSH
46941: LD_VAR 0 37
46945: PUSH
46946: LD_VAR 0 38
46950: PUSH
46951: LD_VAR 0 39
46955: PUSH
46956: LD_VAR 0 40
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: LD_VAR 0 4
46973: PUSH
46974: LD_INT 1
46976: PLUS
46977: ARRAY
46978: ST_TO_ADDR
46979: GO 47346
46981: LD_INT 6
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 47037
46987: LD_INT 7
46989: DOUBLE
46990: EQUAL
46991: IFTRUE 47037
46993: LD_INT 8
46995: DOUBLE
46996: EQUAL
46997: IFTRUE 47037
46999: LD_INT 13
47001: DOUBLE
47002: EQUAL
47003: IFTRUE 47037
47005: LD_INT 12
47007: DOUBLE
47008: EQUAL
47009: IFTRUE 47037
47011: LD_INT 15
47013: DOUBLE
47014: EQUAL
47015: IFTRUE 47037
47017: LD_INT 11
47019: DOUBLE
47020: EQUAL
47021: IFTRUE 47037
47023: LD_INT 14
47025: DOUBLE
47026: EQUAL
47027: IFTRUE 47037
47029: LD_INT 10
47031: DOUBLE
47032: EQUAL
47033: IFTRUE 47037
47035: GO 47093
47037: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47038: LD_ADDR_VAR 0 9
47042: PUSH
47043: LD_VAR 0 41
47047: PUSH
47048: LD_VAR 0 42
47052: PUSH
47053: LD_VAR 0 43
47057: PUSH
47058: LD_VAR 0 44
47062: PUSH
47063: LD_VAR 0 45
47067: PUSH
47068: LD_VAR 0 46
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: PUSH
47081: LD_VAR 0 4
47085: PUSH
47086: LD_INT 1
47088: PLUS
47089: ARRAY
47090: ST_TO_ADDR
47091: GO 47346
47093: LD_INT 36
47095: DOUBLE
47096: EQUAL
47097: IFTRUE 47101
47099: GO 47157
47101: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47102: LD_ADDR_VAR 0 9
47106: PUSH
47107: LD_VAR 0 47
47111: PUSH
47112: LD_VAR 0 48
47116: PUSH
47117: LD_VAR 0 49
47121: PUSH
47122: LD_VAR 0 50
47126: PUSH
47127: LD_VAR 0 51
47131: PUSH
47132: LD_VAR 0 52
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: PUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_INT 1
47152: PLUS
47153: ARRAY
47154: ST_TO_ADDR
47155: GO 47346
47157: LD_INT 4
47159: DOUBLE
47160: EQUAL
47161: IFTRUE 47183
47163: LD_INT 5
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47183
47169: LD_INT 34
47171: DOUBLE
47172: EQUAL
47173: IFTRUE 47183
47175: LD_INT 37
47177: DOUBLE
47178: EQUAL
47179: IFTRUE 47183
47181: GO 47239
47183: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47184: LD_ADDR_VAR 0 9
47188: PUSH
47189: LD_VAR 0 53
47193: PUSH
47194: LD_VAR 0 54
47198: PUSH
47199: LD_VAR 0 55
47203: PUSH
47204: LD_VAR 0 56
47208: PUSH
47209: LD_VAR 0 57
47213: PUSH
47214: LD_VAR 0 58
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: PUSH
47227: LD_VAR 0 4
47231: PUSH
47232: LD_INT 1
47234: PLUS
47235: ARRAY
47236: ST_TO_ADDR
47237: GO 47346
47239: LD_INT 31
47241: DOUBLE
47242: EQUAL
47243: IFTRUE 47289
47245: LD_INT 32
47247: DOUBLE
47248: EQUAL
47249: IFTRUE 47289
47251: LD_INT 33
47253: DOUBLE
47254: EQUAL
47255: IFTRUE 47289
47257: LD_INT 27
47259: DOUBLE
47260: EQUAL
47261: IFTRUE 47289
47263: LD_INT 26
47265: DOUBLE
47266: EQUAL
47267: IFTRUE 47289
47269: LD_INT 28
47271: DOUBLE
47272: EQUAL
47273: IFTRUE 47289
47275: LD_INT 29
47277: DOUBLE
47278: EQUAL
47279: IFTRUE 47289
47281: LD_INT 30
47283: DOUBLE
47284: EQUAL
47285: IFTRUE 47289
47287: GO 47345
47289: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47290: LD_ADDR_VAR 0 9
47294: PUSH
47295: LD_VAR 0 59
47299: PUSH
47300: LD_VAR 0 60
47304: PUSH
47305: LD_VAR 0 61
47309: PUSH
47310: LD_VAR 0 62
47314: PUSH
47315: LD_VAR 0 63
47319: PUSH
47320: LD_VAR 0 64
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: PUSH
47333: LD_VAR 0 4
47337: PUSH
47338: LD_INT 1
47340: PLUS
47341: ARRAY
47342: ST_TO_ADDR
47343: GO 47346
47345: POP
// temp_list2 = [ ] ;
47346: LD_ADDR_VAR 0 10
47350: PUSH
47351: EMPTY
47352: ST_TO_ADDR
// for i in temp_list do
47353: LD_ADDR_VAR 0 8
47357: PUSH
47358: LD_VAR 0 9
47362: PUSH
47363: FOR_IN
47364: IFFALSE 47416
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47366: LD_ADDR_VAR 0 10
47370: PUSH
47371: LD_VAR 0 10
47375: PUSH
47376: LD_VAR 0 8
47380: PUSH
47381: LD_INT 1
47383: ARRAY
47384: PUSH
47385: LD_VAR 0 2
47389: PLUS
47390: PUSH
47391: LD_VAR 0 8
47395: PUSH
47396: LD_INT 2
47398: ARRAY
47399: PUSH
47400: LD_VAR 0 3
47404: PLUS
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: ADD
47413: ST_TO_ADDR
47414: GO 47363
47416: POP
47417: POP
// result = temp_list2 ;
47418: LD_ADDR_VAR 0 7
47422: PUSH
47423: LD_VAR 0 10
47427: ST_TO_ADDR
// end ;
47428: LD_VAR 0 7
47432: RET
// export function EnemyInRange ( unit , dist ) ; begin
47433: LD_INT 0
47435: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47436: LD_ADDR_VAR 0 3
47440: PUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL_OW 255
47450: PPUSH
47451: LD_VAR 0 1
47455: PPUSH
47456: CALL_OW 250
47460: PPUSH
47461: LD_VAR 0 1
47465: PPUSH
47466: CALL_OW 251
47470: PPUSH
47471: LD_VAR 0 2
47475: PPUSH
47476: CALL 21561 0 4
47480: PUSH
47481: LD_INT 4
47483: ARRAY
47484: ST_TO_ADDR
// end ;
47485: LD_VAR 0 3
47489: RET
// export function PlayerSeeMe ( unit ) ; begin
47490: LD_INT 0
47492: PPUSH
// result := See ( your_side , unit ) ;
47493: LD_ADDR_VAR 0 2
47497: PUSH
47498: LD_OWVAR 2
47502: PPUSH
47503: LD_VAR 0 1
47507: PPUSH
47508: CALL_OW 292
47512: ST_TO_ADDR
// end ;
47513: LD_VAR 0 2
47517: RET
// export function ReverseDir ( unit ) ; begin
47518: LD_INT 0
47520: PPUSH
// if not unit then
47521: LD_VAR 0 1
47525: NOT
47526: IFFALSE 47530
// exit ;
47528: GO 47576
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47530: LD_ADDR_VAR 0 2
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: LD_INT 5
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 1
47549: PUSH
47550: LD_INT 2
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PPUSH
47566: CALL_OW 254
47570: PUSH
47571: LD_INT 1
47573: PLUS
47574: ARRAY
47575: ST_TO_ADDR
// end ;
47576: LD_VAR 0 2
47580: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47581: LD_INT 0
47583: PPUSH
47584: PPUSH
47585: PPUSH
47586: PPUSH
47587: PPUSH
// if not hexes then
47588: LD_VAR 0 2
47592: NOT
47593: IFFALSE 47597
// exit ;
47595: GO 47745
// dist := 9999 ;
47597: LD_ADDR_VAR 0 5
47601: PUSH
47602: LD_INT 9999
47604: ST_TO_ADDR
// for i = 1 to hexes do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: DOUBLE
47611: LD_INT 1
47613: DEC
47614: ST_TO_ADDR
47615: LD_VAR 0 2
47619: PUSH
47620: FOR_TO
47621: IFFALSE 47733
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47623: LD_VAR 0 1
47627: PPUSH
47628: LD_VAR 0 2
47632: PUSH
47633: LD_VAR 0 4
47637: ARRAY
47638: PUSH
47639: LD_INT 1
47641: ARRAY
47642: PPUSH
47643: LD_VAR 0 2
47647: PUSH
47648: LD_VAR 0 4
47652: ARRAY
47653: PUSH
47654: LD_INT 2
47656: ARRAY
47657: PPUSH
47658: CALL_OW 297
47662: PUSH
47663: LD_VAR 0 5
47667: LESS
47668: IFFALSE 47731
// begin hex := hexes [ i ] ;
47670: LD_ADDR_VAR 0 7
47674: PUSH
47675: LD_VAR 0 2
47679: PUSH
47680: LD_VAR 0 4
47684: ARRAY
47685: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47686: LD_ADDR_VAR 0 5
47690: PUSH
47691: LD_VAR 0 1
47695: PPUSH
47696: LD_VAR 0 2
47700: PUSH
47701: LD_VAR 0 4
47705: ARRAY
47706: PUSH
47707: LD_INT 1
47709: ARRAY
47710: PPUSH
47711: LD_VAR 0 2
47715: PUSH
47716: LD_VAR 0 4
47720: ARRAY
47721: PUSH
47722: LD_INT 2
47724: ARRAY
47725: PPUSH
47726: CALL_OW 297
47730: ST_TO_ADDR
// end ; end ;
47731: GO 47620
47733: POP
47734: POP
// result := hex ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_VAR 0 7
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 3
47749: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47754: LD_VAR 0 1
47758: NOT
47759: PUSH
47760: LD_VAR 0 1
47764: PUSH
47765: LD_INT 21
47767: PUSH
47768: LD_INT 2
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PUSH
47775: LD_INT 23
47777: PUSH
47778: LD_INT 2
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PPUSH
47789: CALL_OW 69
47793: IN
47794: NOT
47795: OR
47796: IFFALSE 47800
// exit ;
47798: GO 47847
// for i = 1 to 3 do
47800: LD_ADDR_VAR 0 3
47804: PUSH
47805: DOUBLE
47806: LD_INT 1
47808: DEC
47809: ST_TO_ADDR
47810: LD_INT 3
47812: PUSH
47813: FOR_TO
47814: IFFALSE 47845
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47816: LD_VAR 0 1
47820: PPUSH
47821: CALL_OW 250
47825: PPUSH
47826: LD_VAR 0 1
47830: PPUSH
47831: CALL_OW 251
47835: PPUSH
47836: LD_INT 1
47838: PPUSH
47839: CALL_OW 453
47843: GO 47813
47845: POP
47846: POP
// end ;
47847: LD_VAR 0 2
47851: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47852: LD_INT 0
47854: PPUSH
47855: PPUSH
47856: PPUSH
47857: PPUSH
47858: PPUSH
47859: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47860: LD_VAR 0 1
47864: NOT
47865: PUSH
47866: LD_VAR 0 2
47870: NOT
47871: OR
47872: PUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: CALL_OW 314
47882: OR
47883: IFFALSE 47887
// exit ;
47885: GO 48328
// x := GetX ( enemy_unit ) ;
47887: LD_ADDR_VAR 0 7
47891: PUSH
47892: LD_VAR 0 2
47896: PPUSH
47897: CALL_OW 250
47901: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47902: LD_ADDR_VAR 0 8
47906: PUSH
47907: LD_VAR 0 2
47911: PPUSH
47912: CALL_OW 251
47916: ST_TO_ADDR
// if not x or not y then
47917: LD_VAR 0 7
47921: NOT
47922: PUSH
47923: LD_VAR 0 8
47927: NOT
47928: OR
47929: IFFALSE 47933
// exit ;
47931: GO 48328
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47933: LD_ADDR_VAR 0 6
47937: PUSH
47938: LD_VAR 0 7
47942: PPUSH
47943: LD_INT 0
47945: PPUSH
47946: LD_INT 4
47948: PPUSH
47949: CALL_OW 272
47953: PUSH
47954: LD_VAR 0 8
47958: PPUSH
47959: LD_INT 0
47961: PPUSH
47962: LD_INT 4
47964: PPUSH
47965: CALL_OW 273
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PUSH
47974: LD_VAR 0 7
47978: PPUSH
47979: LD_INT 1
47981: PPUSH
47982: LD_INT 4
47984: PPUSH
47985: CALL_OW 272
47989: PUSH
47990: LD_VAR 0 8
47994: PPUSH
47995: LD_INT 1
47997: PPUSH
47998: LD_INT 4
48000: PPUSH
48001: CALL_OW 273
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_VAR 0 7
48014: PPUSH
48015: LD_INT 2
48017: PPUSH
48018: LD_INT 4
48020: PPUSH
48021: CALL_OW 272
48025: PUSH
48026: LD_VAR 0 8
48030: PPUSH
48031: LD_INT 2
48033: PPUSH
48034: LD_INT 4
48036: PPUSH
48037: CALL_OW 273
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_VAR 0 7
48050: PPUSH
48051: LD_INT 3
48053: PPUSH
48054: LD_INT 4
48056: PPUSH
48057: CALL_OW 272
48061: PUSH
48062: LD_VAR 0 8
48066: PPUSH
48067: LD_INT 3
48069: PPUSH
48070: LD_INT 4
48072: PPUSH
48073: CALL_OW 273
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_VAR 0 7
48086: PPUSH
48087: LD_INT 4
48089: PPUSH
48090: LD_INT 4
48092: PPUSH
48093: CALL_OW 272
48097: PUSH
48098: LD_VAR 0 8
48102: PPUSH
48103: LD_INT 4
48105: PPUSH
48106: LD_INT 4
48108: PPUSH
48109: CALL_OW 273
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: PUSH
48118: LD_VAR 0 7
48122: PPUSH
48123: LD_INT 5
48125: PPUSH
48126: LD_INT 4
48128: PPUSH
48129: CALL_OW 272
48133: PUSH
48134: LD_VAR 0 8
48138: PPUSH
48139: LD_INT 5
48141: PPUSH
48142: LD_INT 4
48144: PPUSH
48145: CALL_OW 273
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: ST_TO_ADDR
// for i = tmp downto 1 do
48162: LD_ADDR_VAR 0 4
48166: PUSH
48167: DOUBLE
48168: LD_VAR 0 6
48172: INC
48173: ST_TO_ADDR
48174: LD_INT 1
48176: PUSH
48177: FOR_DOWNTO
48178: IFFALSE 48279
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48180: LD_VAR 0 6
48184: PUSH
48185: LD_VAR 0 4
48189: ARRAY
48190: PUSH
48191: LD_INT 1
48193: ARRAY
48194: PPUSH
48195: LD_VAR 0 6
48199: PUSH
48200: LD_VAR 0 4
48204: ARRAY
48205: PUSH
48206: LD_INT 2
48208: ARRAY
48209: PPUSH
48210: CALL_OW 488
48214: NOT
48215: PUSH
48216: LD_VAR 0 6
48220: PUSH
48221: LD_VAR 0 4
48225: ARRAY
48226: PUSH
48227: LD_INT 1
48229: ARRAY
48230: PPUSH
48231: LD_VAR 0 6
48235: PUSH
48236: LD_VAR 0 4
48240: ARRAY
48241: PUSH
48242: LD_INT 2
48244: ARRAY
48245: PPUSH
48246: CALL_OW 428
48250: PUSH
48251: LD_INT 0
48253: NONEQUAL
48254: OR
48255: IFFALSE 48277
// tmp := Delete ( tmp , i ) ;
48257: LD_ADDR_VAR 0 6
48261: PUSH
48262: LD_VAR 0 6
48266: PPUSH
48267: LD_VAR 0 4
48271: PPUSH
48272: CALL_OW 3
48276: ST_TO_ADDR
48277: GO 48177
48279: POP
48280: POP
// j := GetClosestHex ( unit , tmp ) ;
48281: LD_ADDR_VAR 0 5
48285: PUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: LD_VAR 0 6
48295: PPUSH
48296: CALL 47581 0 2
48300: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48301: LD_VAR 0 1
48305: PPUSH
48306: LD_VAR 0 5
48310: PUSH
48311: LD_INT 1
48313: ARRAY
48314: PPUSH
48315: LD_VAR 0 5
48319: PUSH
48320: LD_INT 2
48322: ARRAY
48323: PPUSH
48324: CALL_OW 111
// end ;
48328: LD_VAR 0 3
48332: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48333: LD_INT 0
48335: PPUSH
48336: PPUSH
48337: PPUSH
// uc_side = 0 ;
48338: LD_ADDR_OWVAR 20
48342: PUSH
48343: LD_INT 0
48345: ST_TO_ADDR
// uc_nation = 0 ;
48346: LD_ADDR_OWVAR 21
48350: PUSH
48351: LD_INT 0
48353: ST_TO_ADDR
// InitHc ;
48354: CALL_OW 19
// InitVc ;
48358: CALL_OW 20
// if mastodonts then
48362: LD_VAR 0 6
48366: IFFALSE 48433
// for i = 1 to mastodonts do
48368: LD_ADDR_VAR 0 11
48372: PUSH
48373: DOUBLE
48374: LD_INT 1
48376: DEC
48377: ST_TO_ADDR
48378: LD_VAR 0 6
48382: PUSH
48383: FOR_TO
48384: IFFALSE 48431
// begin vc_chassis := 31 ;
48386: LD_ADDR_OWVAR 37
48390: PUSH
48391: LD_INT 31
48393: ST_TO_ADDR
// vc_control := control_rider ;
48394: LD_ADDR_OWVAR 38
48398: PUSH
48399: LD_INT 4
48401: ST_TO_ADDR
// animal := CreateVehicle ;
48402: LD_ADDR_VAR 0 12
48406: PUSH
48407: CALL_OW 45
48411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48412: LD_VAR 0 12
48416: PPUSH
48417: LD_VAR 0 8
48421: PPUSH
48422: LD_INT 0
48424: PPUSH
48425: CALL 55178 0 3
// end ;
48429: GO 48383
48431: POP
48432: POP
// if horses then
48433: LD_VAR 0 5
48437: IFFALSE 48504
// for i = 1 to horses do
48439: LD_ADDR_VAR 0 11
48443: PUSH
48444: DOUBLE
48445: LD_INT 1
48447: DEC
48448: ST_TO_ADDR
48449: LD_VAR 0 5
48453: PUSH
48454: FOR_TO
48455: IFFALSE 48502
// begin hc_class := 21 ;
48457: LD_ADDR_OWVAR 28
48461: PUSH
48462: LD_INT 21
48464: ST_TO_ADDR
// hc_gallery :=  ;
48465: LD_ADDR_OWVAR 33
48469: PUSH
48470: LD_STRING 
48472: ST_TO_ADDR
// animal := CreateHuman ;
48473: LD_ADDR_VAR 0 12
48477: PUSH
48478: CALL_OW 44
48482: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48483: LD_VAR 0 12
48487: PPUSH
48488: LD_VAR 0 8
48492: PPUSH
48493: LD_INT 0
48495: PPUSH
48496: CALL 55178 0 3
// end ;
48500: GO 48454
48502: POP
48503: POP
// if birds then
48504: LD_VAR 0 1
48508: IFFALSE 48575
// for i = 1 to birds do
48510: LD_ADDR_VAR 0 11
48514: PUSH
48515: DOUBLE
48516: LD_INT 1
48518: DEC
48519: ST_TO_ADDR
48520: LD_VAR 0 1
48524: PUSH
48525: FOR_TO
48526: IFFALSE 48573
// begin hc_class = 18 ;
48528: LD_ADDR_OWVAR 28
48532: PUSH
48533: LD_INT 18
48535: ST_TO_ADDR
// hc_gallery =  ;
48536: LD_ADDR_OWVAR 33
48540: PUSH
48541: LD_STRING 
48543: ST_TO_ADDR
// animal := CreateHuman ;
48544: LD_ADDR_VAR 0 12
48548: PUSH
48549: CALL_OW 44
48553: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48554: LD_VAR 0 12
48558: PPUSH
48559: LD_VAR 0 8
48563: PPUSH
48564: LD_INT 0
48566: PPUSH
48567: CALL 55178 0 3
// end ;
48571: GO 48525
48573: POP
48574: POP
// if tigers then
48575: LD_VAR 0 2
48579: IFFALSE 48663
// for i = 1 to tigers do
48581: LD_ADDR_VAR 0 11
48585: PUSH
48586: DOUBLE
48587: LD_INT 1
48589: DEC
48590: ST_TO_ADDR
48591: LD_VAR 0 2
48595: PUSH
48596: FOR_TO
48597: IFFALSE 48661
// begin hc_class = class_tiger ;
48599: LD_ADDR_OWVAR 28
48603: PUSH
48604: LD_INT 14
48606: ST_TO_ADDR
// hc_gallery =  ;
48607: LD_ADDR_OWVAR 33
48611: PUSH
48612: LD_STRING 
48614: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48615: LD_ADDR_OWVAR 35
48619: PUSH
48620: LD_INT 7
48622: NEG
48623: PPUSH
48624: LD_INT 7
48626: PPUSH
48627: CALL_OW 12
48631: ST_TO_ADDR
// animal := CreateHuman ;
48632: LD_ADDR_VAR 0 12
48636: PUSH
48637: CALL_OW 44
48641: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48642: LD_VAR 0 12
48646: PPUSH
48647: LD_VAR 0 8
48651: PPUSH
48652: LD_INT 0
48654: PPUSH
48655: CALL 55178 0 3
// end ;
48659: GO 48596
48661: POP
48662: POP
// if apemans then
48663: LD_VAR 0 3
48667: IFFALSE 48790
// for i = 1 to apemans do
48669: LD_ADDR_VAR 0 11
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_VAR 0 3
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48788
// begin hc_class = class_apeman ;
48687: LD_ADDR_OWVAR 28
48691: PUSH
48692: LD_INT 12
48694: ST_TO_ADDR
// hc_gallery =  ;
48695: LD_ADDR_OWVAR 33
48699: PUSH
48700: LD_STRING 
48702: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48703: LD_ADDR_OWVAR 35
48707: PUSH
48708: LD_INT 5
48710: NEG
48711: PPUSH
48712: LD_INT 5
48714: PPUSH
48715: CALL_OW 12
48719: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48720: LD_ADDR_OWVAR 31
48724: PUSH
48725: LD_INT 1
48727: PPUSH
48728: LD_INT 3
48730: PPUSH
48731: CALL_OW 12
48735: PUSH
48736: LD_INT 1
48738: PPUSH
48739: LD_INT 3
48741: PPUSH
48742: CALL_OW 12
48746: PUSH
48747: LD_INT 0
48749: PUSH
48750: LD_INT 0
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: ST_TO_ADDR
// animal := CreateHuman ;
48759: LD_ADDR_VAR 0 12
48763: PUSH
48764: CALL_OW 44
48768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48769: LD_VAR 0 12
48773: PPUSH
48774: LD_VAR 0 8
48778: PPUSH
48779: LD_INT 0
48781: PPUSH
48782: CALL 55178 0 3
// end ;
48786: GO 48684
48788: POP
48789: POP
// if enchidnas then
48790: LD_VAR 0 4
48794: IFFALSE 48861
// for i = 1 to enchidnas do
48796: LD_ADDR_VAR 0 11
48800: PUSH
48801: DOUBLE
48802: LD_INT 1
48804: DEC
48805: ST_TO_ADDR
48806: LD_VAR 0 4
48810: PUSH
48811: FOR_TO
48812: IFFALSE 48859
// begin hc_class = 13 ;
48814: LD_ADDR_OWVAR 28
48818: PUSH
48819: LD_INT 13
48821: ST_TO_ADDR
// hc_gallery =  ;
48822: LD_ADDR_OWVAR 33
48826: PUSH
48827: LD_STRING 
48829: ST_TO_ADDR
// animal := CreateHuman ;
48830: LD_ADDR_VAR 0 12
48834: PUSH
48835: CALL_OW 44
48839: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48840: LD_VAR 0 12
48844: PPUSH
48845: LD_VAR 0 8
48849: PPUSH
48850: LD_INT 0
48852: PPUSH
48853: CALL 55178 0 3
// end ;
48857: GO 48811
48859: POP
48860: POP
// if fishes then
48861: LD_VAR 0 7
48865: IFFALSE 48932
// for i = 1 to fishes do
48867: LD_ADDR_VAR 0 11
48871: PUSH
48872: DOUBLE
48873: LD_INT 1
48875: DEC
48876: ST_TO_ADDR
48877: LD_VAR 0 7
48881: PUSH
48882: FOR_TO
48883: IFFALSE 48930
// begin hc_class = 20 ;
48885: LD_ADDR_OWVAR 28
48889: PUSH
48890: LD_INT 20
48892: ST_TO_ADDR
// hc_gallery =  ;
48893: LD_ADDR_OWVAR 33
48897: PUSH
48898: LD_STRING 
48900: ST_TO_ADDR
// animal := CreateHuman ;
48901: LD_ADDR_VAR 0 12
48905: PUSH
48906: CALL_OW 44
48910: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48911: LD_VAR 0 12
48915: PPUSH
48916: LD_VAR 0 9
48920: PPUSH
48921: LD_INT 0
48923: PPUSH
48924: CALL 55178 0 3
// end ;
48928: GO 48882
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 10
48936: RET
// export function WantHeal ( sci , unit ) ; begin
48937: LD_INT 0
48939: PPUSH
// if GetTaskList ( sci ) > 0 then
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 437
48949: PUSH
48950: LD_INT 0
48952: GREATER
48953: IFFALSE 49023
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL_OW 437
48964: PUSH
48965: LD_INT 1
48967: ARRAY
48968: PUSH
48969: LD_INT 1
48971: ARRAY
48972: PUSH
48973: LD_STRING l
48975: EQUAL
48976: PUSH
48977: LD_VAR 0 1
48981: PPUSH
48982: CALL_OW 437
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: PUSH
48991: LD_INT 4
48993: ARRAY
48994: PUSH
48995: LD_VAR 0 2
48999: EQUAL
49000: AND
49001: IFFALSE 49013
// result := true else
49003: LD_ADDR_VAR 0 3
49007: PUSH
49008: LD_INT 1
49010: ST_TO_ADDR
49011: GO 49021
// result := false ;
49013: LD_ADDR_VAR 0 3
49017: PUSH
49018: LD_INT 0
49020: ST_TO_ADDR
// end else
49021: GO 49031
// result := false ;
49023: LD_ADDR_VAR 0 3
49027: PUSH
49028: LD_INT 0
49030: ST_TO_ADDR
// end ;
49031: LD_VAR 0 3
49035: RET
// export function HealTarget ( sci ) ; begin
49036: LD_INT 0
49038: PPUSH
// if not sci then
49039: LD_VAR 0 1
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49113
// result := 0 ;
49048: LD_ADDR_VAR 0 2
49052: PUSH
49053: LD_INT 0
49055: ST_TO_ADDR
// if GetTaskList ( sci ) then
49056: LD_VAR 0 1
49060: PPUSH
49061: CALL_OW 437
49065: IFFALSE 49113
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL_OW 437
49076: PUSH
49077: LD_INT 1
49079: ARRAY
49080: PUSH
49081: LD_INT 1
49083: ARRAY
49084: PUSH
49085: LD_STRING l
49087: EQUAL
49088: IFFALSE 49113
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49090: LD_ADDR_VAR 0 2
49094: PUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: CALL_OW 437
49104: PUSH
49105: LD_INT 1
49107: ARRAY
49108: PUSH
49109: LD_INT 4
49111: ARRAY
49112: ST_TO_ADDR
// end ;
49113: LD_VAR 0 2
49117: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49118: LD_INT 0
49120: PPUSH
49121: PPUSH
49122: PPUSH
49123: PPUSH
49124: PPUSH
49125: PPUSH
49126: PPUSH
49127: PPUSH
49128: PPUSH
49129: PPUSH
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
49153: PPUSH
// if not list then
49154: LD_VAR 0 1
49158: NOT
49159: IFFALSE 49163
// exit ;
49161: GO 53789
// base := list [ 1 ] ;
49163: LD_ADDR_VAR 0 3
49167: PUSH
49168: LD_VAR 0 1
49172: PUSH
49173: LD_INT 1
49175: ARRAY
49176: ST_TO_ADDR
// group := list [ 2 ] ;
49177: LD_ADDR_VAR 0 4
49181: PUSH
49182: LD_VAR 0 1
49186: PUSH
49187: LD_INT 2
49189: ARRAY
49190: ST_TO_ADDR
// path := list [ 3 ] ;
49191: LD_ADDR_VAR 0 5
49195: PUSH
49196: LD_VAR 0 1
49200: PUSH
49201: LD_INT 3
49203: ARRAY
49204: ST_TO_ADDR
// flags := list [ 4 ] ;
49205: LD_ADDR_VAR 0 6
49209: PUSH
49210: LD_VAR 0 1
49214: PUSH
49215: LD_INT 4
49217: ARRAY
49218: ST_TO_ADDR
// mined := [ ] ;
49219: LD_ADDR_VAR 0 27
49223: PUSH
49224: EMPTY
49225: ST_TO_ADDR
// bombed := [ ] ;
49226: LD_ADDR_VAR 0 28
49230: PUSH
49231: EMPTY
49232: ST_TO_ADDR
// healers := [ ] ;
49233: LD_ADDR_VAR 0 31
49237: PUSH
49238: EMPTY
49239: ST_TO_ADDR
// to_heal := [ ] ;
49240: LD_ADDR_VAR 0 30
49244: PUSH
49245: EMPTY
49246: ST_TO_ADDR
// repairs := [ ] ;
49247: LD_ADDR_VAR 0 33
49251: PUSH
49252: EMPTY
49253: ST_TO_ADDR
// to_repair := [ ] ;
49254: LD_ADDR_VAR 0 32
49258: PUSH
49259: EMPTY
49260: ST_TO_ADDR
// if not group or not path then
49261: LD_VAR 0 4
49265: NOT
49266: PUSH
49267: LD_VAR 0 5
49271: NOT
49272: OR
49273: IFFALSE 49277
// exit ;
49275: GO 53789
// side := GetSide ( group [ 1 ] ) ;
49277: LD_ADDR_VAR 0 35
49281: PUSH
49282: LD_VAR 0 4
49286: PUSH
49287: LD_INT 1
49289: ARRAY
49290: PPUSH
49291: CALL_OW 255
49295: ST_TO_ADDR
// if flags then
49296: LD_VAR 0 6
49300: IFFALSE 49444
// begin f_ignore_area := flags [ 1 ] ;
49302: LD_ADDR_VAR 0 17
49306: PUSH
49307: LD_VAR 0 6
49311: PUSH
49312: LD_INT 1
49314: ARRAY
49315: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49316: LD_ADDR_VAR 0 18
49320: PUSH
49321: LD_VAR 0 6
49325: PUSH
49326: LD_INT 2
49328: ARRAY
49329: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49330: LD_ADDR_VAR 0 19
49334: PUSH
49335: LD_VAR 0 6
49339: PUSH
49340: LD_INT 3
49342: ARRAY
49343: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49344: LD_ADDR_VAR 0 20
49348: PUSH
49349: LD_VAR 0 6
49353: PUSH
49354: LD_INT 4
49356: ARRAY
49357: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49358: LD_ADDR_VAR 0 21
49362: PUSH
49363: LD_VAR 0 6
49367: PUSH
49368: LD_INT 5
49370: ARRAY
49371: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49372: LD_ADDR_VAR 0 22
49376: PUSH
49377: LD_VAR 0 6
49381: PUSH
49382: LD_INT 6
49384: ARRAY
49385: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49386: LD_ADDR_VAR 0 23
49390: PUSH
49391: LD_VAR 0 6
49395: PUSH
49396: LD_INT 7
49398: ARRAY
49399: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49400: LD_ADDR_VAR 0 24
49404: PUSH
49405: LD_VAR 0 6
49409: PUSH
49410: LD_INT 8
49412: ARRAY
49413: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49414: LD_ADDR_VAR 0 25
49418: PUSH
49419: LD_VAR 0 6
49423: PUSH
49424: LD_INT 9
49426: ARRAY
49427: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49428: LD_ADDR_VAR 0 26
49432: PUSH
49433: LD_VAR 0 6
49437: PUSH
49438: LD_INT 10
49440: ARRAY
49441: ST_TO_ADDR
// end else
49442: GO 49524
// begin f_ignore_area := false ;
49444: LD_ADDR_VAR 0 17
49448: PUSH
49449: LD_INT 0
49451: ST_TO_ADDR
// f_capture := false ;
49452: LD_ADDR_VAR 0 18
49456: PUSH
49457: LD_INT 0
49459: ST_TO_ADDR
// f_ignore_civ := false ;
49460: LD_ADDR_VAR 0 19
49464: PUSH
49465: LD_INT 0
49467: ST_TO_ADDR
// f_murder := false ;
49468: LD_ADDR_VAR 0 20
49472: PUSH
49473: LD_INT 0
49475: ST_TO_ADDR
// f_mines := false ;
49476: LD_ADDR_VAR 0 21
49480: PUSH
49481: LD_INT 0
49483: ST_TO_ADDR
// f_repair := false ;
49484: LD_ADDR_VAR 0 22
49488: PUSH
49489: LD_INT 0
49491: ST_TO_ADDR
// f_heal := false ;
49492: LD_ADDR_VAR 0 23
49496: PUSH
49497: LD_INT 0
49499: ST_TO_ADDR
// f_spacetime := false ;
49500: LD_ADDR_VAR 0 24
49504: PUSH
49505: LD_INT 0
49507: ST_TO_ADDR
// f_attack_depot := false ;
49508: LD_ADDR_VAR 0 25
49512: PUSH
49513: LD_INT 0
49515: ST_TO_ADDR
// f_crawl := false ;
49516: LD_ADDR_VAR 0 26
49520: PUSH
49521: LD_INT 0
49523: ST_TO_ADDR
// end ; if f_heal then
49524: LD_VAR 0 23
49528: IFFALSE 49555
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49530: LD_ADDR_VAR 0 31
49534: PUSH
49535: LD_VAR 0 4
49539: PPUSH
49540: LD_INT 25
49542: PUSH
49543: LD_INT 4
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PPUSH
49550: CALL_OW 72
49554: ST_TO_ADDR
// if f_repair then
49555: LD_VAR 0 22
49559: IFFALSE 49586
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49561: LD_ADDR_VAR 0 33
49565: PUSH
49566: LD_VAR 0 4
49570: PPUSH
49571: LD_INT 25
49573: PUSH
49574: LD_INT 3
49576: PUSH
49577: EMPTY
49578: LIST
49579: LIST
49580: PPUSH
49581: CALL_OW 72
49585: ST_TO_ADDR
// units_path := [ ] ;
49586: LD_ADDR_VAR 0 16
49590: PUSH
49591: EMPTY
49592: ST_TO_ADDR
// for i = 1 to group do
49593: LD_ADDR_VAR 0 7
49597: PUSH
49598: DOUBLE
49599: LD_INT 1
49601: DEC
49602: ST_TO_ADDR
49603: LD_VAR 0 4
49607: PUSH
49608: FOR_TO
49609: IFFALSE 49638
// units_path := Replace ( units_path , i , path ) ;
49611: LD_ADDR_VAR 0 16
49615: PUSH
49616: LD_VAR 0 16
49620: PPUSH
49621: LD_VAR 0 7
49625: PPUSH
49626: LD_VAR 0 5
49630: PPUSH
49631: CALL_OW 1
49635: ST_TO_ADDR
49636: GO 49608
49638: POP
49639: POP
// repeat for i = group downto 1 do
49640: LD_ADDR_VAR 0 7
49644: PUSH
49645: DOUBLE
49646: LD_VAR 0 4
49650: INC
49651: ST_TO_ADDR
49652: LD_INT 1
49654: PUSH
49655: FOR_DOWNTO
49656: IFFALSE 53752
// begin wait ( 5 ) ;
49658: LD_INT 5
49660: PPUSH
49661: CALL_OW 67
// tmp := [ ] ;
49665: LD_ADDR_VAR 0 14
49669: PUSH
49670: EMPTY
49671: ST_TO_ADDR
// attacking := false ;
49672: LD_ADDR_VAR 0 29
49676: PUSH
49677: LD_INT 0
49679: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49680: LD_VAR 0 4
49684: PUSH
49685: LD_VAR 0 7
49689: ARRAY
49690: PPUSH
49691: CALL_OW 301
49695: PUSH
49696: LD_VAR 0 4
49700: PUSH
49701: LD_VAR 0 7
49705: ARRAY
49706: NOT
49707: OR
49708: IFFALSE 49817
// begin if GetType ( group [ i ] ) = unit_human then
49710: LD_VAR 0 4
49714: PUSH
49715: LD_VAR 0 7
49719: ARRAY
49720: PPUSH
49721: CALL_OW 247
49725: PUSH
49726: LD_INT 1
49728: EQUAL
49729: IFFALSE 49775
// begin to_heal := to_heal diff group [ i ] ;
49731: LD_ADDR_VAR 0 30
49735: PUSH
49736: LD_VAR 0 30
49740: PUSH
49741: LD_VAR 0 4
49745: PUSH
49746: LD_VAR 0 7
49750: ARRAY
49751: DIFF
49752: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49753: LD_ADDR_VAR 0 31
49757: PUSH
49758: LD_VAR 0 31
49762: PUSH
49763: LD_VAR 0 4
49767: PUSH
49768: LD_VAR 0 7
49772: ARRAY
49773: DIFF
49774: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49775: LD_ADDR_VAR 0 4
49779: PUSH
49780: LD_VAR 0 4
49784: PPUSH
49785: LD_VAR 0 7
49789: PPUSH
49790: CALL_OW 3
49794: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49795: LD_ADDR_VAR 0 16
49799: PUSH
49800: LD_VAR 0 16
49804: PPUSH
49805: LD_VAR 0 7
49809: PPUSH
49810: CALL_OW 3
49814: ST_TO_ADDR
// continue ;
49815: GO 49655
// end ; if f_repair then
49817: LD_VAR 0 22
49821: IFFALSE 50310
// begin if GetType ( group [ i ] ) = unit_vehicle then
49823: LD_VAR 0 4
49827: PUSH
49828: LD_VAR 0 7
49832: ARRAY
49833: PPUSH
49834: CALL_OW 247
49838: PUSH
49839: LD_INT 2
49841: EQUAL
49842: IFFALSE 50032
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49844: LD_VAR 0 4
49848: PUSH
49849: LD_VAR 0 7
49853: ARRAY
49854: PPUSH
49855: CALL_OW 256
49859: PUSH
49860: LD_INT 700
49862: LESS
49863: PUSH
49864: LD_VAR 0 4
49868: PUSH
49869: LD_VAR 0 7
49873: ARRAY
49874: PUSH
49875: LD_VAR 0 32
49879: IN
49880: NOT
49881: AND
49882: IFFALSE 49906
// to_repair := to_repair union group [ i ] ;
49884: LD_ADDR_VAR 0 32
49888: PUSH
49889: LD_VAR 0 32
49893: PUSH
49894: LD_VAR 0 4
49898: PUSH
49899: LD_VAR 0 7
49903: ARRAY
49904: UNION
49905: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49906: LD_VAR 0 4
49910: PUSH
49911: LD_VAR 0 7
49915: ARRAY
49916: PPUSH
49917: CALL_OW 256
49921: PUSH
49922: LD_INT 1000
49924: EQUAL
49925: PUSH
49926: LD_VAR 0 4
49930: PUSH
49931: LD_VAR 0 7
49935: ARRAY
49936: PUSH
49937: LD_VAR 0 32
49941: IN
49942: AND
49943: IFFALSE 49967
// to_repair := to_repair diff group [ i ] ;
49945: LD_ADDR_VAR 0 32
49949: PUSH
49950: LD_VAR 0 32
49954: PUSH
49955: LD_VAR 0 4
49959: PUSH
49960: LD_VAR 0 7
49964: ARRAY
49965: DIFF
49966: ST_TO_ADDR
// if group [ i ] in to_repair then
49967: LD_VAR 0 4
49971: PUSH
49972: LD_VAR 0 7
49976: ARRAY
49977: PUSH
49978: LD_VAR 0 32
49982: IN
49983: IFFALSE 50030
// begin if not IsInArea ( group [ i ] , f_repair ) then
49985: LD_VAR 0 4
49989: PUSH
49990: LD_VAR 0 7
49994: ARRAY
49995: PPUSH
49996: LD_VAR 0 22
50000: PPUSH
50001: CALL_OW 308
50005: NOT
50006: IFFALSE 50028
// ComMoveToArea ( group [ i ] , f_repair ) ;
50008: LD_VAR 0 4
50012: PUSH
50013: LD_VAR 0 7
50017: ARRAY
50018: PPUSH
50019: LD_VAR 0 22
50023: PPUSH
50024: CALL_OW 113
// continue ;
50028: GO 49655
// end ; end else
50030: GO 50310
// if group [ i ] in repairs then
50032: LD_VAR 0 4
50036: PUSH
50037: LD_VAR 0 7
50041: ARRAY
50042: PUSH
50043: LD_VAR 0 33
50047: IN
50048: IFFALSE 50310
// begin if IsInUnit ( group [ i ] ) then
50050: LD_VAR 0 4
50054: PUSH
50055: LD_VAR 0 7
50059: ARRAY
50060: PPUSH
50061: CALL_OW 310
50065: IFFALSE 50133
// begin z := IsInUnit ( group [ i ] ) ;
50067: LD_ADDR_VAR 0 13
50071: PUSH
50072: LD_VAR 0 4
50076: PUSH
50077: LD_VAR 0 7
50081: ARRAY
50082: PPUSH
50083: CALL_OW 310
50087: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50088: LD_VAR 0 13
50092: PUSH
50093: LD_VAR 0 32
50097: IN
50098: PUSH
50099: LD_VAR 0 13
50103: PPUSH
50104: LD_VAR 0 22
50108: PPUSH
50109: CALL_OW 308
50113: AND
50114: IFFALSE 50131
// ComExitVehicle ( group [ i ] ) ;
50116: LD_VAR 0 4
50120: PUSH
50121: LD_VAR 0 7
50125: ARRAY
50126: PPUSH
50127: CALL_OW 121
// end else
50131: GO 50310
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50133: LD_ADDR_VAR 0 13
50137: PUSH
50138: LD_VAR 0 4
50142: PPUSH
50143: LD_INT 95
50145: PUSH
50146: LD_VAR 0 22
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 58
50157: PUSH
50158: EMPTY
50159: LIST
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PPUSH
50165: CALL_OW 72
50169: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50170: LD_VAR 0 4
50174: PUSH
50175: LD_VAR 0 7
50179: ARRAY
50180: PPUSH
50181: CALL_OW 314
50185: NOT
50186: IFFALSE 50308
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50188: LD_ADDR_VAR 0 10
50192: PUSH
50193: LD_VAR 0 13
50197: PPUSH
50198: LD_VAR 0 4
50202: PUSH
50203: LD_VAR 0 7
50207: ARRAY
50208: PPUSH
50209: CALL_OW 74
50213: ST_TO_ADDR
// if not x then
50214: LD_VAR 0 10
50218: NOT
50219: IFFALSE 50223
// continue ;
50221: GO 49655
// if GetLives ( x ) < 1000 then
50223: LD_VAR 0 10
50227: PPUSH
50228: CALL_OW 256
50232: PUSH
50233: LD_INT 1000
50235: LESS
50236: IFFALSE 50260
// ComRepairVehicle ( group [ i ] , x ) else
50238: LD_VAR 0 4
50242: PUSH
50243: LD_VAR 0 7
50247: ARRAY
50248: PPUSH
50249: LD_VAR 0 10
50253: PPUSH
50254: CALL_OW 129
50258: GO 50308
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50260: LD_VAR 0 23
50264: PUSH
50265: LD_VAR 0 4
50269: PUSH
50270: LD_VAR 0 7
50274: ARRAY
50275: PPUSH
50276: CALL_OW 256
50280: PUSH
50281: LD_INT 1000
50283: LESS
50284: AND
50285: NOT
50286: IFFALSE 50308
// ComEnterUnit ( group [ i ] , x ) ;
50288: LD_VAR 0 4
50292: PUSH
50293: LD_VAR 0 7
50297: ARRAY
50298: PPUSH
50299: LD_VAR 0 10
50303: PPUSH
50304: CALL_OW 120
// end ; continue ;
50308: GO 49655
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50310: LD_VAR 0 23
50314: PUSH
50315: LD_VAR 0 4
50319: PUSH
50320: LD_VAR 0 7
50324: ARRAY
50325: PPUSH
50326: CALL_OW 247
50330: PUSH
50331: LD_INT 1
50333: EQUAL
50334: AND
50335: IFFALSE 50813
// begin if group [ i ] in healers then
50337: LD_VAR 0 4
50341: PUSH
50342: LD_VAR 0 7
50346: ARRAY
50347: PUSH
50348: LD_VAR 0 31
50352: IN
50353: IFFALSE 50626
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50355: LD_VAR 0 4
50359: PUSH
50360: LD_VAR 0 7
50364: ARRAY
50365: PPUSH
50366: LD_VAR 0 23
50370: PPUSH
50371: CALL_OW 308
50375: NOT
50376: PUSH
50377: LD_VAR 0 4
50381: PUSH
50382: LD_VAR 0 7
50386: ARRAY
50387: PPUSH
50388: CALL_OW 314
50392: NOT
50393: AND
50394: IFFALSE 50418
// ComMoveToArea ( group [ i ] , f_heal ) else
50396: LD_VAR 0 4
50400: PUSH
50401: LD_VAR 0 7
50405: ARRAY
50406: PPUSH
50407: LD_VAR 0 23
50411: PPUSH
50412: CALL_OW 113
50416: GO 50624
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50418: LD_VAR 0 4
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PPUSH
50429: CALL 49036 0 1
50433: PPUSH
50434: CALL_OW 256
50438: PUSH
50439: LD_INT 1000
50441: EQUAL
50442: IFFALSE 50461
// ComStop ( group [ i ] ) else
50444: LD_VAR 0 4
50448: PUSH
50449: LD_VAR 0 7
50453: ARRAY
50454: PPUSH
50455: CALL_OW 141
50459: GO 50624
// if not HasTask ( group [ i ] ) and to_heal then
50461: LD_VAR 0 4
50465: PUSH
50466: LD_VAR 0 7
50470: ARRAY
50471: PPUSH
50472: CALL_OW 314
50476: NOT
50477: PUSH
50478: LD_VAR 0 30
50482: AND
50483: IFFALSE 50624
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50485: LD_ADDR_VAR 0 13
50489: PUSH
50490: LD_VAR 0 30
50494: PPUSH
50495: LD_INT 3
50497: PUSH
50498: LD_INT 54
50500: PUSH
50501: EMPTY
50502: LIST
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PPUSH
50508: CALL_OW 72
50512: PPUSH
50513: LD_VAR 0 4
50517: PUSH
50518: LD_VAR 0 7
50522: ARRAY
50523: PPUSH
50524: CALL_OW 74
50528: ST_TO_ADDR
// if z then
50529: LD_VAR 0 13
50533: IFFALSE 50624
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50535: LD_INT 91
50537: PUSH
50538: LD_VAR 0 13
50542: PUSH
50543: LD_INT 10
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: LIST
50550: PUSH
50551: LD_INT 81
50553: PUSH
50554: LD_VAR 0 13
50558: PPUSH
50559: CALL_OW 255
50563: PUSH
50564: EMPTY
50565: LIST
50566: LIST
50567: PUSH
50568: EMPTY
50569: LIST
50570: LIST
50571: PPUSH
50572: CALL_OW 69
50576: PUSH
50577: LD_INT 0
50579: EQUAL
50580: IFFALSE 50604
// ComHeal ( group [ i ] , z ) else
50582: LD_VAR 0 4
50586: PUSH
50587: LD_VAR 0 7
50591: ARRAY
50592: PPUSH
50593: LD_VAR 0 13
50597: PPUSH
50598: CALL_OW 128
50602: GO 50624
// ComMoveToArea ( group [ i ] , f_heal ) ;
50604: LD_VAR 0 4
50608: PUSH
50609: LD_VAR 0 7
50613: ARRAY
50614: PPUSH
50615: LD_VAR 0 23
50619: PPUSH
50620: CALL_OW 113
// end ; continue ;
50624: GO 49655
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50626: LD_VAR 0 4
50630: PUSH
50631: LD_VAR 0 7
50635: ARRAY
50636: PPUSH
50637: CALL_OW 256
50641: PUSH
50642: LD_INT 700
50644: LESS
50645: PUSH
50646: LD_VAR 0 4
50650: PUSH
50651: LD_VAR 0 7
50655: ARRAY
50656: PUSH
50657: LD_VAR 0 30
50661: IN
50662: NOT
50663: AND
50664: IFFALSE 50688
// to_heal := to_heal union group [ i ] ;
50666: LD_ADDR_VAR 0 30
50670: PUSH
50671: LD_VAR 0 30
50675: PUSH
50676: LD_VAR 0 4
50680: PUSH
50681: LD_VAR 0 7
50685: ARRAY
50686: UNION
50687: ST_TO_ADDR
// if group [ i ] in to_heal then
50688: LD_VAR 0 4
50692: PUSH
50693: LD_VAR 0 7
50697: ARRAY
50698: PUSH
50699: LD_VAR 0 30
50703: IN
50704: IFFALSE 50813
// begin if GetLives ( group [ i ] ) = 1000 then
50706: LD_VAR 0 4
50710: PUSH
50711: LD_VAR 0 7
50715: ARRAY
50716: PPUSH
50717: CALL_OW 256
50721: PUSH
50722: LD_INT 1000
50724: EQUAL
50725: IFFALSE 50751
// to_heal := to_heal diff group [ i ] else
50727: LD_ADDR_VAR 0 30
50731: PUSH
50732: LD_VAR 0 30
50736: PUSH
50737: LD_VAR 0 4
50741: PUSH
50742: LD_VAR 0 7
50746: ARRAY
50747: DIFF
50748: ST_TO_ADDR
50749: GO 50813
// begin if not IsInArea ( group [ i ] , to_heal ) then
50751: LD_VAR 0 4
50755: PUSH
50756: LD_VAR 0 7
50760: ARRAY
50761: PPUSH
50762: LD_VAR 0 30
50766: PPUSH
50767: CALL_OW 308
50771: NOT
50772: IFFALSE 50796
// ComMoveToArea ( group [ i ] , f_heal ) else
50774: LD_VAR 0 4
50778: PUSH
50779: LD_VAR 0 7
50783: ARRAY
50784: PPUSH
50785: LD_VAR 0 23
50789: PPUSH
50790: CALL_OW 113
50794: GO 50811
// ComHold ( group [ i ] ) ;
50796: LD_VAR 0 4
50800: PUSH
50801: LD_VAR 0 7
50805: ARRAY
50806: PPUSH
50807: CALL_OW 140
// continue ;
50811: GO 49655
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50813: LD_VAR 0 4
50817: PUSH
50818: LD_VAR 0 7
50822: ARRAY
50823: PPUSH
50824: LD_INT 10
50826: PPUSH
50827: CALL 47433 0 2
50831: NOT
50832: PUSH
50833: LD_VAR 0 16
50837: PUSH
50838: LD_VAR 0 7
50842: ARRAY
50843: PUSH
50844: EMPTY
50845: EQUAL
50846: NOT
50847: AND
50848: IFFALSE 51114
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50850: LD_VAR 0 4
50854: PUSH
50855: LD_VAR 0 7
50859: ARRAY
50860: PPUSH
50861: CALL_OW 262
50865: PUSH
50866: LD_INT 1
50868: PUSH
50869: LD_INT 2
50871: PUSH
50872: EMPTY
50873: LIST
50874: LIST
50875: IN
50876: IFFALSE 50917
// if GetFuel ( group [ i ] ) < 10 then
50878: LD_VAR 0 4
50882: PUSH
50883: LD_VAR 0 7
50887: ARRAY
50888: PPUSH
50889: CALL_OW 261
50893: PUSH
50894: LD_INT 10
50896: LESS
50897: IFFALSE 50917
// SetFuel ( group [ i ] , 12 ) ;
50899: LD_VAR 0 4
50903: PUSH
50904: LD_VAR 0 7
50908: ARRAY
50909: PPUSH
50910: LD_INT 12
50912: PPUSH
50913: CALL_OW 240
// if units_path [ i ] then
50917: LD_VAR 0 16
50921: PUSH
50922: LD_VAR 0 7
50926: ARRAY
50927: IFFALSE 51112
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50929: LD_VAR 0 4
50933: PUSH
50934: LD_VAR 0 7
50938: ARRAY
50939: PPUSH
50940: LD_VAR 0 16
50944: PUSH
50945: LD_VAR 0 7
50949: ARRAY
50950: PUSH
50951: LD_INT 1
50953: ARRAY
50954: PUSH
50955: LD_INT 1
50957: ARRAY
50958: PPUSH
50959: LD_VAR 0 16
50963: PUSH
50964: LD_VAR 0 7
50968: ARRAY
50969: PUSH
50970: LD_INT 1
50972: ARRAY
50973: PUSH
50974: LD_INT 2
50976: ARRAY
50977: PPUSH
50978: CALL_OW 297
50982: PUSH
50983: LD_INT 6
50985: GREATER
50986: IFFALSE 51061
// begin if not HasTask ( group [ i ] ) then
50988: LD_VAR 0 4
50992: PUSH
50993: LD_VAR 0 7
50997: ARRAY
50998: PPUSH
50999: CALL_OW 314
51003: NOT
51004: IFFALSE 51059
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51006: LD_VAR 0 4
51010: PUSH
51011: LD_VAR 0 7
51015: ARRAY
51016: PPUSH
51017: LD_VAR 0 16
51021: PUSH
51022: LD_VAR 0 7
51026: ARRAY
51027: PUSH
51028: LD_INT 1
51030: ARRAY
51031: PUSH
51032: LD_INT 1
51034: ARRAY
51035: PPUSH
51036: LD_VAR 0 16
51040: PUSH
51041: LD_VAR 0 7
51045: ARRAY
51046: PUSH
51047: LD_INT 1
51049: ARRAY
51050: PUSH
51051: LD_INT 2
51053: ARRAY
51054: PPUSH
51055: CALL_OW 114
// end else
51059: GO 51112
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51061: LD_ADDR_VAR 0 15
51065: PUSH
51066: LD_VAR 0 16
51070: PUSH
51071: LD_VAR 0 7
51075: ARRAY
51076: PPUSH
51077: LD_INT 1
51079: PPUSH
51080: CALL_OW 3
51084: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51085: LD_ADDR_VAR 0 16
51089: PUSH
51090: LD_VAR 0 16
51094: PPUSH
51095: LD_VAR 0 7
51099: PPUSH
51100: LD_VAR 0 15
51104: PPUSH
51105: CALL_OW 1
51109: ST_TO_ADDR
// continue ;
51110: GO 49655
// end ; end ; end else
51112: GO 53750
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51114: LD_ADDR_VAR 0 14
51118: PUSH
51119: LD_INT 81
51121: PUSH
51122: LD_VAR 0 4
51126: PUSH
51127: LD_VAR 0 7
51131: ARRAY
51132: PPUSH
51133: CALL_OW 255
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PPUSH
51142: CALL_OW 69
51146: ST_TO_ADDR
// if not tmp then
51147: LD_VAR 0 14
51151: NOT
51152: IFFALSE 51156
// continue ;
51154: GO 49655
// if f_ignore_area then
51156: LD_VAR 0 17
51160: IFFALSE 51248
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51162: LD_ADDR_VAR 0 15
51166: PUSH
51167: LD_VAR 0 14
51171: PPUSH
51172: LD_INT 3
51174: PUSH
51175: LD_INT 92
51177: PUSH
51178: LD_VAR 0 17
51182: PUSH
51183: LD_INT 1
51185: ARRAY
51186: PUSH
51187: LD_VAR 0 17
51191: PUSH
51192: LD_INT 2
51194: ARRAY
51195: PUSH
51196: LD_VAR 0 17
51200: PUSH
51201: LD_INT 3
51203: ARRAY
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: LIST
51209: LIST
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PPUSH
51215: CALL_OW 72
51219: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51220: LD_VAR 0 14
51224: PUSH
51225: LD_VAR 0 15
51229: DIFF
51230: IFFALSE 51248
// tmp := tmp diff tmp2 ;
51232: LD_ADDR_VAR 0 14
51236: PUSH
51237: LD_VAR 0 14
51241: PUSH
51242: LD_VAR 0 15
51246: DIFF
51247: ST_TO_ADDR
// end ; if not f_murder then
51248: LD_VAR 0 20
51252: NOT
51253: IFFALSE 51311
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51255: LD_ADDR_VAR 0 15
51259: PUSH
51260: LD_VAR 0 14
51264: PPUSH
51265: LD_INT 3
51267: PUSH
51268: LD_INT 50
51270: PUSH
51271: EMPTY
51272: LIST
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 72
51282: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51283: LD_VAR 0 14
51287: PUSH
51288: LD_VAR 0 15
51292: DIFF
51293: IFFALSE 51311
// tmp := tmp diff tmp2 ;
51295: LD_ADDR_VAR 0 14
51299: PUSH
51300: LD_VAR 0 14
51304: PUSH
51305: LD_VAR 0 15
51309: DIFF
51310: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51311: LD_ADDR_VAR 0 14
51315: PUSH
51316: LD_VAR 0 4
51320: PUSH
51321: LD_VAR 0 7
51325: ARRAY
51326: PPUSH
51327: LD_VAR 0 14
51331: PPUSH
51332: LD_INT 1
51334: PPUSH
51335: LD_INT 1
51337: PPUSH
51338: CALL 21100 0 4
51342: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51343: LD_VAR 0 4
51347: PUSH
51348: LD_VAR 0 7
51352: ARRAY
51353: PPUSH
51354: CALL_OW 257
51358: PUSH
51359: LD_INT 1
51361: EQUAL
51362: IFFALSE 51810
// begin if WantPlant ( group [ i ] ) then
51364: LD_VAR 0 4
51368: PUSH
51369: LD_VAR 0 7
51373: ARRAY
51374: PPUSH
51375: CALL 20601 0 1
51379: IFFALSE 51383
// continue ;
51381: GO 49655
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51383: LD_VAR 0 18
51387: PUSH
51388: LD_VAR 0 4
51392: PUSH
51393: LD_VAR 0 7
51397: ARRAY
51398: PPUSH
51399: CALL_OW 310
51403: NOT
51404: AND
51405: PUSH
51406: LD_VAR 0 14
51410: PUSH
51411: LD_INT 1
51413: ARRAY
51414: PUSH
51415: LD_VAR 0 14
51419: PPUSH
51420: LD_INT 21
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 58
51432: PUSH
51433: EMPTY
51434: LIST
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PPUSH
51440: CALL_OW 72
51444: IN
51445: AND
51446: IFFALSE 51482
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51448: LD_VAR 0 4
51452: PUSH
51453: LD_VAR 0 7
51457: ARRAY
51458: PPUSH
51459: LD_VAR 0 14
51463: PUSH
51464: LD_INT 1
51466: ARRAY
51467: PPUSH
51468: CALL_OW 120
// attacking := true ;
51472: LD_ADDR_VAR 0 29
51476: PUSH
51477: LD_INT 1
51479: ST_TO_ADDR
// continue ;
51480: GO 49655
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51482: LD_VAR 0 26
51486: PUSH
51487: LD_VAR 0 4
51491: PUSH
51492: LD_VAR 0 7
51496: ARRAY
51497: PPUSH
51498: CALL_OW 257
51502: PUSH
51503: LD_INT 1
51505: EQUAL
51506: AND
51507: PUSH
51508: LD_VAR 0 4
51512: PUSH
51513: LD_VAR 0 7
51517: ARRAY
51518: PPUSH
51519: CALL_OW 256
51523: PUSH
51524: LD_INT 800
51526: LESS
51527: AND
51528: PUSH
51529: LD_VAR 0 4
51533: PUSH
51534: LD_VAR 0 7
51538: ARRAY
51539: PPUSH
51540: CALL_OW 318
51544: NOT
51545: AND
51546: IFFALSE 51563
// ComCrawl ( group [ i ] ) ;
51548: LD_VAR 0 4
51552: PUSH
51553: LD_VAR 0 7
51557: ARRAY
51558: PPUSH
51559: CALL_OW 137
// if f_mines then
51563: LD_VAR 0 21
51567: IFFALSE 51810
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51569: LD_VAR 0 14
51573: PUSH
51574: LD_INT 1
51576: ARRAY
51577: PPUSH
51578: CALL_OW 247
51582: PUSH
51583: LD_INT 3
51585: EQUAL
51586: PUSH
51587: LD_VAR 0 14
51591: PUSH
51592: LD_INT 1
51594: ARRAY
51595: PUSH
51596: LD_VAR 0 27
51600: IN
51601: NOT
51602: AND
51603: IFFALSE 51810
// begin x := GetX ( tmp [ 1 ] ) ;
51605: LD_ADDR_VAR 0 10
51609: PUSH
51610: LD_VAR 0 14
51614: PUSH
51615: LD_INT 1
51617: ARRAY
51618: PPUSH
51619: CALL_OW 250
51623: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51624: LD_ADDR_VAR 0 11
51628: PUSH
51629: LD_VAR 0 14
51633: PUSH
51634: LD_INT 1
51636: ARRAY
51637: PPUSH
51638: CALL_OW 251
51642: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51643: LD_ADDR_VAR 0 12
51647: PUSH
51648: LD_VAR 0 4
51652: PUSH
51653: LD_VAR 0 7
51657: ARRAY
51658: PPUSH
51659: CALL 47518 0 1
51663: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51664: LD_VAR 0 4
51668: PUSH
51669: LD_VAR 0 7
51673: ARRAY
51674: PPUSH
51675: LD_VAR 0 10
51679: PPUSH
51680: LD_VAR 0 11
51684: PPUSH
51685: LD_VAR 0 14
51689: PUSH
51690: LD_INT 1
51692: ARRAY
51693: PPUSH
51694: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51698: LD_VAR 0 4
51702: PUSH
51703: LD_VAR 0 7
51707: ARRAY
51708: PPUSH
51709: LD_VAR 0 10
51713: PPUSH
51714: LD_VAR 0 12
51718: PPUSH
51719: LD_INT 7
51721: PPUSH
51722: CALL_OW 272
51726: PPUSH
51727: LD_VAR 0 11
51731: PPUSH
51732: LD_VAR 0 12
51736: PPUSH
51737: LD_INT 7
51739: PPUSH
51740: CALL_OW 273
51744: PPUSH
51745: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51749: LD_VAR 0 4
51753: PUSH
51754: LD_VAR 0 7
51758: ARRAY
51759: PPUSH
51760: LD_INT 71
51762: PPUSH
51763: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51767: LD_ADDR_VAR 0 27
51771: PUSH
51772: LD_VAR 0 27
51776: PPUSH
51777: LD_VAR 0 27
51781: PUSH
51782: LD_INT 1
51784: PLUS
51785: PPUSH
51786: LD_VAR 0 14
51790: PUSH
51791: LD_INT 1
51793: ARRAY
51794: PPUSH
51795: CALL_OW 1
51799: ST_TO_ADDR
// attacking := true ;
51800: LD_ADDR_VAR 0 29
51804: PUSH
51805: LD_INT 1
51807: ST_TO_ADDR
// continue ;
51808: GO 49655
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51810: LD_VAR 0 4
51814: PUSH
51815: LD_VAR 0 7
51819: ARRAY
51820: PPUSH
51821: CALL_OW 257
51825: PUSH
51826: LD_INT 17
51828: EQUAL
51829: PUSH
51830: LD_VAR 0 4
51834: PUSH
51835: LD_VAR 0 7
51839: ARRAY
51840: PPUSH
51841: CALL_OW 110
51845: PUSH
51846: LD_INT 71
51848: EQUAL
51849: NOT
51850: AND
51851: IFFALSE 51997
// begin attacking := false ;
51853: LD_ADDR_VAR 0 29
51857: PUSH
51858: LD_INT 0
51860: ST_TO_ADDR
// k := 5 ;
51861: LD_ADDR_VAR 0 9
51865: PUSH
51866: LD_INT 5
51868: ST_TO_ADDR
// if tmp < k then
51869: LD_VAR 0 14
51873: PUSH
51874: LD_VAR 0 9
51878: LESS
51879: IFFALSE 51891
// k := tmp ;
51881: LD_ADDR_VAR 0 9
51885: PUSH
51886: LD_VAR 0 14
51890: ST_TO_ADDR
// for j = 1 to k do
51891: LD_ADDR_VAR 0 8
51895: PUSH
51896: DOUBLE
51897: LD_INT 1
51899: DEC
51900: ST_TO_ADDR
51901: LD_VAR 0 9
51905: PUSH
51906: FOR_TO
51907: IFFALSE 51995
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51909: LD_VAR 0 14
51913: PUSH
51914: LD_VAR 0 8
51918: ARRAY
51919: PUSH
51920: LD_VAR 0 14
51924: PPUSH
51925: LD_INT 58
51927: PUSH
51928: EMPTY
51929: LIST
51930: PPUSH
51931: CALL_OW 72
51935: IN
51936: NOT
51937: IFFALSE 51993
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51939: LD_VAR 0 4
51943: PUSH
51944: LD_VAR 0 7
51948: ARRAY
51949: PPUSH
51950: LD_VAR 0 14
51954: PUSH
51955: LD_VAR 0 8
51959: ARRAY
51960: PPUSH
51961: CALL_OW 115
// attacking := true ;
51965: LD_ADDR_VAR 0 29
51969: PUSH
51970: LD_INT 1
51972: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51973: LD_VAR 0 4
51977: PUSH
51978: LD_VAR 0 7
51982: ARRAY
51983: PPUSH
51984: LD_INT 71
51986: PPUSH
51987: CALL_OW 109
// continue ;
51991: GO 51906
// end ; end ;
51993: GO 51906
51995: POP
51996: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51997: LD_VAR 0 4
52001: PUSH
52002: LD_VAR 0 7
52006: ARRAY
52007: PPUSH
52008: CALL_OW 257
52012: PUSH
52013: LD_INT 8
52015: EQUAL
52016: PUSH
52017: LD_VAR 0 4
52021: PUSH
52022: LD_VAR 0 7
52026: ARRAY
52027: PPUSH
52028: CALL_OW 264
52032: PUSH
52033: LD_INT 28
52035: PUSH
52036: LD_INT 45
52038: PUSH
52039: LD_INT 7
52041: PUSH
52042: LD_INT 47
52044: PUSH
52045: EMPTY
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: IN
52051: OR
52052: IFFALSE 52282
// begin attacking := false ;
52054: LD_ADDR_VAR 0 29
52058: PUSH
52059: LD_INT 0
52061: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52062: LD_VAR 0 14
52066: PUSH
52067: LD_INT 1
52069: ARRAY
52070: PPUSH
52071: CALL_OW 266
52075: PUSH
52076: LD_INT 32
52078: PUSH
52079: LD_INT 31
52081: PUSH
52082: LD_INT 33
52084: PUSH
52085: LD_INT 4
52087: PUSH
52088: LD_INT 5
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: IN
52098: IFFALSE 52282
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52100: LD_ADDR_VAR 0 9
52104: PUSH
52105: LD_VAR 0 14
52109: PUSH
52110: LD_INT 1
52112: ARRAY
52113: PPUSH
52114: CALL_OW 266
52118: PPUSH
52119: LD_VAR 0 14
52123: PUSH
52124: LD_INT 1
52126: ARRAY
52127: PPUSH
52128: CALL_OW 250
52132: PPUSH
52133: LD_VAR 0 14
52137: PUSH
52138: LD_INT 1
52140: ARRAY
52141: PPUSH
52142: CALL_OW 251
52146: PPUSH
52147: LD_VAR 0 14
52151: PUSH
52152: LD_INT 1
52154: ARRAY
52155: PPUSH
52156: CALL_OW 254
52160: PPUSH
52161: LD_VAR 0 14
52165: PUSH
52166: LD_INT 1
52168: ARRAY
52169: PPUSH
52170: CALL_OW 248
52174: PPUSH
52175: LD_INT 0
52177: PPUSH
52178: CALL 28894 0 6
52182: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52183: LD_ADDR_VAR 0 8
52187: PUSH
52188: LD_VAR 0 4
52192: PUSH
52193: LD_VAR 0 7
52197: ARRAY
52198: PPUSH
52199: LD_VAR 0 9
52203: PPUSH
52204: CALL 47581 0 2
52208: ST_TO_ADDR
// if j then
52209: LD_VAR 0 8
52213: IFFALSE 52282
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52215: LD_VAR 0 8
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PPUSH
52224: LD_VAR 0 8
52228: PUSH
52229: LD_INT 2
52231: ARRAY
52232: PPUSH
52233: CALL_OW 488
52237: IFFALSE 52282
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52239: LD_VAR 0 4
52243: PUSH
52244: LD_VAR 0 7
52248: ARRAY
52249: PPUSH
52250: LD_VAR 0 8
52254: PUSH
52255: LD_INT 1
52257: ARRAY
52258: PPUSH
52259: LD_VAR 0 8
52263: PUSH
52264: LD_INT 2
52266: ARRAY
52267: PPUSH
52268: CALL_OW 116
// attacking := true ;
52272: LD_ADDR_VAR 0 29
52276: PUSH
52277: LD_INT 1
52279: ST_TO_ADDR
// continue ;
52280: GO 49655
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52282: LD_VAR 0 4
52286: PUSH
52287: LD_VAR 0 7
52291: ARRAY
52292: PPUSH
52293: CALL_OW 265
52297: PUSH
52298: LD_INT 11
52300: EQUAL
52301: IFFALSE 52579
// begin k := 10 ;
52303: LD_ADDR_VAR 0 9
52307: PUSH
52308: LD_INT 10
52310: ST_TO_ADDR
// x := 0 ;
52311: LD_ADDR_VAR 0 10
52315: PUSH
52316: LD_INT 0
52318: ST_TO_ADDR
// if tmp < k then
52319: LD_VAR 0 14
52323: PUSH
52324: LD_VAR 0 9
52328: LESS
52329: IFFALSE 52341
// k := tmp ;
52331: LD_ADDR_VAR 0 9
52335: PUSH
52336: LD_VAR 0 14
52340: ST_TO_ADDR
// for j = k downto 1 do
52341: LD_ADDR_VAR 0 8
52345: PUSH
52346: DOUBLE
52347: LD_VAR 0 9
52351: INC
52352: ST_TO_ADDR
52353: LD_INT 1
52355: PUSH
52356: FOR_DOWNTO
52357: IFFALSE 52432
// begin if GetType ( tmp [ j ] ) = unit_human then
52359: LD_VAR 0 14
52363: PUSH
52364: LD_VAR 0 8
52368: ARRAY
52369: PPUSH
52370: CALL_OW 247
52374: PUSH
52375: LD_INT 1
52377: EQUAL
52378: IFFALSE 52430
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52380: LD_VAR 0 4
52384: PUSH
52385: LD_VAR 0 7
52389: ARRAY
52390: PPUSH
52391: LD_VAR 0 14
52395: PUSH
52396: LD_VAR 0 8
52400: ARRAY
52401: PPUSH
52402: CALL 47852 0 2
// x := tmp [ j ] ;
52406: LD_ADDR_VAR 0 10
52410: PUSH
52411: LD_VAR 0 14
52415: PUSH
52416: LD_VAR 0 8
52420: ARRAY
52421: ST_TO_ADDR
// attacking := true ;
52422: LD_ADDR_VAR 0 29
52426: PUSH
52427: LD_INT 1
52429: ST_TO_ADDR
// end ; end ;
52430: GO 52356
52432: POP
52433: POP
// if not x then
52434: LD_VAR 0 10
52438: NOT
52439: IFFALSE 52579
// begin attacking := true ;
52441: LD_ADDR_VAR 0 29
52445: PUSH
52446: LD_INT 1
52448: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52449: LD_VAR 0 4
52453: PUSH
52454: LD_VAR 0 7
52458: ARRAY
52459: PPUSH
52460: CALL_OW 250
52464: PPUSH
52465: LD_VAR 0 4
52469: PUSH
52470: LD_VAR 0 7
52474: ARRAY
52475: PPUSH
52476: CALL_OW 251
52480: PPUSH
52481: CALL_OW 546
52485: PUSH
52486: LD_INT 2
52488: ARRAY
52489: PUSH
52490: LD_VAR 0 14
52494: PUSH
52495: LD_INT 1
52497: ARRAY
52498: PPUSH
52499: CALL_OW 250
52503: PPUSH
52504: LD_VAR 0 14
52508: PUSH
52509: LD_INT 1
52511: ARRAY
52512: PPUSH
52513: CALL_OW 251
52517: PPUSH
52518: CALL_OW 546
52522: PUSH
52523: LD_INT 2
52525: ARRAY
52526: EQUAL
52527: IFFALSE 52555
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52529: LD_VAR 0 4
52533: PUSH
52534: LD_VAR 0 7
52538: ARRAY
52539: PPUSH
52540: LD_VAR 0 14
52544: PUSH
52545: LD_INT 1
52547: ARRAY
52548: PPUSH
52549: CALL 47852 0 2
52553: GO 52579
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52555: LD_VAR 0 4
52559: PUSH
52560: LD_VAR 0 7
52564: ARRAY
52565: PPUSH
52566: LD_VAR 0 14
52570: PUSH
52571: LD_INT 1
52573: ARRAY
52574: PPUSH
52575: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52579: LD_VAR 0 4
52583: PUSH
52584: LD_VAR 0 7
52588: ARRAY
52589: PPUSH
52590: CALL_OW 264
52594: PUSH
52595: LD_INT 29
52597: EQUAL
52598: IFFALSE 52964
// begin if WantsToAttack ( group [ i ] ) in bombed then
52600: LD_VAR 0 4
52604: PUSH
52605: LD_VAR 0 7
52609: ARRAY
52610: PPUSH
52611: CALL_OW 319
52615: PUSH
52616: LD_VAR 0 28
52620: IN
52621: IFFALSE 52625
// continue ;
52623: GO 49655
// k := 8 ;
52625: LD_ADDR_VAR 0 9
52629: PUSH
52630: LD_INT 8
52632: ST_TO_ADDR
// x := 0 ;
52633: LD_ADDR_VAR 0 10
52637: PUSH
52638: LD_INT 0
52640: ST_TO_ADDR
// if tmp < k then
52641: LD_VAR 0 14
52645: PUSH
52646: LD_VAR 0 9
52650: LESS
52651: IFFALSE 52663
// k := tmp ;
52653: LD_ADDR_VAR 0 9
52657: PUSH
52658: LD_VAR 0 14
52662: ST_TO_ADDR
// for j = 1 to k do
52663: LD_ADDR_VAR 0 8
52667: PUSH
52668: DOUBLE
52669: LD_INT 1
52671: DEC
52672: ST_TO_ADDR
52673: LD_VAR 0 9
52677: PUSH
52678: FOR_TO
52679: IFFALSE 52811
// begin if GetType ( tmp [ j ] ) = unit_building then
52681: LD_VAR 0 14
52685: PUSH
52686: LD_VAR 0 8
52690: ARRAY
52691: PPUSH
52692: CALL_OW 247
52696: PUSH
52697: LD_INT 3
52699: EQUAL
52700: IFFALSE 52809
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52702: LD_VAR 0 14
52706: PUSH
52707: LD_VAR 0 8
52711: ARRAY
52712: PUSH
52713: LD_VAR 0 28
52717: IN
52718: NOT
52719: PUSH
52720: LD_VAR 0 14
52724: PUSH
52725: LD_VAR 0 8
52729: ARRAY
52730: PPUSH
52731: CALL_OW 313
52735: AND
52736: IFFALSE 52809
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52738: LD_VAR 0 4
52742: PUSH
52743: LD_VAR 0 7
52747: ARRAY
52748: PPUSH
52749: LD_VAR 0 14
52753: PUSH
52754: LD_VAR 0 8
52758: ARRAY
52759: PPUSH
52760: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52764: LD_ADDR_VAR 0 28
52768: PUSH
52769: LD_VAR 0 28
52773: PPUSH
52774: LD_VAR 0 28
52778: PUSH
52779: LD_INT 1
52781: PLUS
52782: PPUSH
52783: LD_VAR 0 14
52787: PUSH
52788: LD_VAR 0 8
52792: ARRAY
52793: PPUSH
52794: CALL_OW 1
52798: ST_TO_ADDR
// attacking := true ;
52799: LD_ADDR_VAR 0 29
52803: PUSH
52804: LD_INT 1
52806: ST_TO_ADDR
// break ;
52807: GO 52811
// end ; end ;
52809: GO 52678
52811: POP
52812: POP
// if not attacking and f_attack_depot then
52813: LD_VAR 0 29
52817: NOT
52818: PUSH
52819: LD_VAR 0 25
52823: AND
52824: IFFALSE 52919
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52826: LD_ADDR_VAR 0 13
52830: PUSH
52831: LD_VAR 0 14
52835: PPUSH
52836: LD_INT 2
52838: PUSH
52839: LD_INT 30
52841: PUSH
52842: LD_INT 0
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: PUSH
52849: LD_INT 30
52851: PUSH
52852: LD_INT 1
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: LIST
52863: PPUSH
52864: CALL_OW 72
52868: ST_TO_ADDR
// if z then
52869: LD_VAR 0 13
52873: IFFALSE 52919
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52875: LD_VAR 0 4
52879: PUSH
52880: LD_VAR 0 7
52884: ARRAY
52885: PPUSH
52886: LD_VAR 0 13
52890: PPUSH
52891: LD_VAR 0 4
52895: PUSH
52896: LD_VAR 0 7
52900: ARRAY
52901: PPUSH
52902: CALL_OW 74
52906: PPUSH
52907: CALL_OW 115
// attacking := true ;
52911: LD_ADDR_VAR 0 29
52915: PUSH
52916: LD_INT 1
52918: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52919: LD_VAR 0 4
52923: PUSH
52924: LD_VAR 0 7
52928: ARRAY
52929: PPUSH
52930: CALL_OW 256
52934: PUSH
52935: LD_INT 500
52937: LESS
52938: IFFALSE 52964
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52940: LD_VAR 0 4
52944: PUSH
52945: LD_VAR 0 7
52949: ARRAY
52950: PPUSH
52951: LD_VAR 0 14
52955: PUSH
52956: LD_INT 1
52958: ARRAY
52959: PPUSH
52960: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52964: LD_VAR 0 4
52968: PUSH
52969: LD_VAR 0 7
52973: ARRAY
52974: PPUSH
52975: CALL_OW 264
52979: PUSH
52980: LD_INT 49
52982: EQUAL
52983: IFFALSE 53104
// begin if not HasTask ( group [ i ] ) then
52985: LD_VAR 0 4
52989: PUSH
52990: LD_VAR 0 7
52994: ARRAY
52995: PPUSH
52996: CALL_OW 314
53000: NOT
53001: IFFALSE 53104
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53003: LD_ADDR_VAR 0 9
53007: PUSH
53008: LD_INT 81
53010: PUSH
53011: LD_VAR 0 4
53015: PUSH
53016: LD_VAR 0 7
53020: ARRAY
53021: PPUSH
53022: CALL_OW 255
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: PPUSH
53031: CALL_OW 69
53035: PPUSH
53036: LD_VAR 0 4
53040: PUSH
53041: LD_VAR 0 7
53045: ARRAY
53046: PPUSH
53047: CALL_OW 74
53051: ST_TO_ADDR
// if k then
53052: LD_VAR 0 9
53056: IFFALSE 53104
// if GetDistUnits ( group [ i ] , k ) > 10 then
53058: LD_VAR 0 4
53062: PUSH
53063: LD_VAR 0 7
53067: ARRAY
53068: PPUSH
53069: LD_VAR 0 9
53073: PPUSH
53074: CALL_OW 296
53078: PUSH
53079: LD_INT 10
53081: GREATER
53082: IFFALSE 53104
// ComMoveUnit ( group [ i ] , k ) ;
53084: LD_VAR 0 4
53088: PUSH
53089: LD_VAR 0 7
53093: ARRAY
53094: PPUSH
53095: LD_VAR 0 9
53099: PPUSH
53100: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53104: LD_VAR 0 4
53108: PUSH
53109: LD_VAR 0 7
53113: ARRAY
53114: PPUSH
53115: CALL_OW 256
53119: PUSH
53120: LD_INT 250
53122: LESS
53123: PUSH
53124: LD_VAR 0 4
53128: PUSH
53129: LD_VAR 0 7
53133: ARRAY
53134: PUSH
53135: LD_INT 21
53137: PUSH
53138: LD_INT 2
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: PUSH
53145: LD_INT 23
53147: PUSH
53148: LD_INT 2
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: PPUSH
53159: CALL_OW 69
53163: IN
53164: AND
53165: IFFALSE 53290
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53167: LD_ADDR_VAR 0 9
53171: PUSH
53172: LD_OWVAR 3
53176: PUSH
53177: LD_VAR 0 4
53181: PUSH
53182: LD_VAR 0 7
53186: ARRAY
53187: DIFF
53188: PPUSH
53189: LD_VAR 0 4
53193: PUSH
53194: LD_VAR 0 7
53198: ARRAY
53199: PPUSH
53200: CALL_OW 74
53204: ST_TO_ADDR
// if not k then
53205: LD_VAR 0 9
53209: NOT
53210: IFFALSE 53214
// continue ;
53212: GO 49655
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53214: LD_VAR 0 9
53218: PUSH
53219: LD_INT 81
53221: PUSH
53222: LD_VAR 0 4
53226: PUSH
53227: LD_VAR 0 7
53231: ARRAY
53232: PPUSH
53233: CALL_OW 255
53237: PUSH
53238: EMPTY
53239: LIST
53240: LIST
53241: PPUSH
53242: CALL_OW 69
53246: IN
53247: PUSH
53248: LD_VAR 0 9
53252: PPUSH
53253: LD_VAR 0 4
53257: PUSH
53258: LD_VAR 0 7
53262: ARRAY
53263: PPUSH
53264: CALL_OW 296
53268: PUSH
53269: LD_INT 5
53271: LESS
53272: AND
53273: IFFALSE 53290
// ComAutodestruct ( group [ i ] ) ;
53275: LD_VAR 0 4
53279: PUSH
53280: LD_VAR 0 7
53284: ARRAY
53285: PPUSH
53286: CALL 47750 0 1
// end ; if f_attack_depot then
53290: LD_VAR 0 25
53294: IFFALSE 53406
// begin k := 6 ;
53296: LD_ADDR_VAR 0 9
53300: PUSH
53301: LD_INT 6
53303: ST_TO_ADDR
// if tmp < k then
53304: LD_VAR 0 14
53308: PUSH
53309: LD_VAR 0 9
53313: LESS
53314: IFFALSE 53326
// k := tmp ;
53316: LD_ADDR_VAR 0 9
53320: PUSH
53321: LD_VAR 0 14
53325: ST_TO_ADDR
// for j = 1 to k do
53326: LD_ADDR_VAR 0 8
53330: PUSH
53331: DOUBLE
53332: LD_INT 1
53334: DEC
53335: ST_TO_ADDR
53336: LD_VAR 0 9
53340: PUSH
53341: FOR_TO
53342: IFFALSE 53404
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53344: LD_VAR 0 8
53348: PPUSH
53349: CALL_OW 266
53353: PUSH
53354: LD_INT 0
53356: PUSH
53357: LD_INT 1
53359: PUSH
53360: EMPTY
53361: LIST
53362: LIST
53363: IN
53364: IFFALSE 53402
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53366: LD_VAR 0 4
53370: PUSH
53371: LD_VAR 0 7
53375: ARRAY
53376: PPUSH
53377: LD_VAR 0 14
53381: PUSH
53382: LD_VAR 0 8
53386: ARRAY
53387: PPUSH
53388: CALL_OW 115
// attacking := true ;
53392: LD_ADDR_VAR 0 29
53396: PUSH
53397: LD_INT 1
53399: ST_TO_ADDR
// break ;
53400: GO 53404
// end ;
53402: GO 53341
53404: POP
53405: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53406: LD_VAR 0 4
53410: PUSH
53411: LD_VAR 0 7
53415: ARRAY
53416: PPUSH
53417: CALL_OW 302
53421: PUSH
53422: LD_VAR 0 29
53426: NOT
53427: AND
53428: IFFALSE 53750
// begin if GetTag ( group [ i ] ) = 71 then
53430: LD_VAR 0 4
53434: PUSH
53435: LD_VAR 0 7
53439: ARRAY
53440: PPUSH
53441: CALL_OW 110
53445: PUSH
53446: LD_INT 71
53448: EQUAL
53449: IFFALSE 53490
// begin if HasTask ( group [ i ] ) then
53451: LD_VAR 0 4
53455: PUSH
53456: LD_VAR 0 7
53460: ARRAY
53461: PPUSH
53462: CALL_OW 314
53466: IFFALSE 53472
// continue else
53468: GO 49655
53470: GO 53490
// SetTag ( group [ i ] , 0 ) ;
53472: LD_VAR 0 4
53476: PUSH
53477: LD_VAR 0 7
53481: ARRAY
53482: PPUSH
53483: LD_INT 0
53485: PPUSH
53486: CALL_OW 109
// end ; k := 8 ;
53490: LD_ADDR_VAR 0 9
53494: PUSH
53495: LD_INT 8
53497: ST_TO_ADDR
// x := 0 ;
53498: LD_ADDR_VAR 0 10
53502: PUSH
53503: LD_INT 0
53505: ST_TO_ADDR
// if tmp < k then
53506: LD_VAR 0 14
53510: PUSH
53511: LD_VAR 0 9
53515: LESS
53516: IFFALSE 53528
// k := tmp ;
53518: LD_ADDR_VAR 0 9
53522: PUSH
53523: LD_VAR 0 14
53527: ST_TO_ADDR
// for j = 1 to k do
53528: LD_ADDR_VAR 0 8
53532: PUSH
53533: DOUBLE
53534: LD_INT 1
53536: DEC
53537: ST_TO_ADDR
53538: LD_VAR 0 9
53542: PUSH
53543: FOR_TO
53544: IFFALSE 53642
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53546: LD_VAR 0 14
53550: PUSH
53551: LD_VAR 0 8
53555: ARRAY
53556: PPUSH
53557: CALL_OW 247
53561: PUSH
53562: LD_INT 1
53564: EQUAL
53565: PUSH
53566: LD_VAR 0 14
53570: PUSH
53571: LD_VAR 0 8
53575: ARRAY
53576: PPUSH
53577: CALL_OW 256
53581: PUSH
53582: LD_INT 250
53584: LESS
53585: PUSH
53586: LD_VAR 0 20
53590: AND
53591: PUSH
53592: LD_VAR 0 20
53596: NOT
53597: PUSH
53598: LD_VAR 0 14
53602: PUSH
53603: LD_VAR 0 8
53607: ARRAY
53608: PPUSH
53609: CALL_OW 256
53613: PUSH
53614: LD_INT 250
53616: GREATEREQUAL
53617: AND
53618: OR
53619: AND
53620: IFFALSE 53640
// begin x := tmp [ j ] ;
53622: LD_ADDR_VAR 0 10
53626: PUSH
53627: LD_VAR 0 14
53631: PUSH
53632: LD_VAR 0 8
53636: ARRAY
53637: ST_TO_ADDR
// break ;
53638: GO 53642
// end ;
53640: GO 53543
53642: POP
53643: POP
// if x then
53644: LD_VAR 0 10
53648: IFFALSE 53672
// ComAttackUnit ( group [ i ] , x ) else
53650: LD_VAR 0 4
53654: PUSH
53655: LD_VAR 0 7
53659: ARRAY
53660: PPUSH
53661: LD_VAR 0 10
53665: PPUSH
53666: CALL_OW 115
53670: GO 53696
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53672: LD_VAR 0 4
53676: PUSH
53677: LD_VAR 0 7
53681: ARRAY
53682: PPUSH
53683: LD_VAR 0 14
53687: PUSH
53688: LD_INT 1
53690: ARRAY
53691: PPUSH
53692: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53696: LD_VAR 0 4
53700: PUSH
53701: LD_VAR 0 7
53705: ARRAY
53706: PPUSH
53707: CALL_OW 314
53711: NOT
53712: IFFALSE 53750
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53714: LD_VAR 0 4
53718: PUSH
53719: LD_VAR 0 7
53723: ARRAY
53724: PPUSH
53725: LD_VAR 0 14
53729: PPUSH
53730: LD_VAR 0 4
53734: PUSH
53735: LD_VAR 0 7
53739: ARRAY
53740: PPUSH
53741: CALL_OW 74
53745: PPUSH
53746: CALL_OW 115
// end ; end ; end ;
53750: GO 49655
53752: POP
53753: POP
// wait ( 0 0$1 ) ;
53754: LD_INT 35
53756: PPUSH
53757: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53761: LD_VAR 0 4
53765: PUSH
53766: EMPTY
53767: EQUAL
53768: PUSH
53769: LD_INT 81
53771: PUSH
53772: LD_VAR 0 35
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PPUSH
53781: CALL_OW 69
53785: NOT
53786: OR
53787: IFFALSE 49640
// end ;
53789: LD_VAR 0 2
53793: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53794: LD_INT 0
53796: PPUSH
53797: PPUSH
53798: PPUSH
53799: PPUSH
// if not base_units then
53800: LD_VAR 0 1
53804: NOT
53805: IFFALSE 53809
// exit ;
53807: GO 53896
// result := false ;
53809: LD_ADDR_VAR 0 2
53813: PUSH
53814: LD_INT 0
53816: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53817: LD_ADDR_VAR 0 5
53821: PUSH
53822: LD_VAR 0 1
53826: PPUSH
53827: LD_INT 21
53829: PUSH
53830: LD_INT 3
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: PPUSH
53837: CALL_OW 72
53841: ST_TO_ADDR
// if not tmp then
53842: LD_VAR 0 5
53846: NOT
53847: IFFALSE 53851
// exit ;
53849: GO 53896
// for i in tmp do
53851: LD_ADDR_VAR 0 3
53855: PUSH
53856: LD_VAR 0 5
53860: PUSH
53861: FOR_IN
53862: IFFALSE 53894
// begin result := EnemyInRange ( i , 22 ) ;
53864: LD_ADDR_VAR 0 2
53868: PUSH
53869: LD_VAR 0 3
53873: PPUSH
53874: LD_INT 22
53876: PPUSH
53877: CALL 47433 0 2
53881: ST_TO_ADDR
// if result then
53882: LD_VAR 0 2
53886: IFFALSE 53892
// exit ;
53888: POP
53889: POP
53890: GO 53896
// end ;
53892: GO 53861
53894: POP
53895: POP
// end ;
53896: LD_VAR 0 2
53900: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53901: LD_INT 0
53903: PPUSH
53904: PPUSH
// if not units then
53905: LD_VAR 0 1
53909: NOT
53910: IFFALSE 53914
// exit ;
53912: GO 53984
// result := [ ] ;
53914: LD_ADDR_VAR 0 3
53918: PUSH
53919: EMPTY
53920: ST_TO_ADDR
// for i in units do
53921: LD_ADDR_VAR 0 4
53925: PUSH
53926: LD_VAR 0 1
53930: PUSH
53931: FOR_IN
53932: IFFALSE 53982
// if GetTag ( i ) = tag then
53934: LD_VAR 0 4
53938: PPUSH
53939: CALL_OW 110
53943: PUSH
53944: LD_VAR 0 2
53948: EQUAL
53949: IFFALSE 53980
// result := Insert ( result , result + 1 , i ) ;
53951: LD_ADDR_VAR 0 3
53955: PUSH
53956: LD_VAR 0 3
53960: PPUSH
53961: LD_VAR 0 3
53965: PUSH
53966: LD_INT 1
53968: PLUS
53969: PPUSH
53970: LD_VAR 0 4
53974: PPUSH
53975: CALL_OW 2
53979: ST_TO_ADDR
53980: GO 53931
53982: POP
53983: POP
// end ;
53984: LD_VAR 0 3
53988: RET
// export function IsDriver ( un ) ; begin
53989: LD_INT 0
53991: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53992: LD_ADDR_VAR 0 2
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 55
54004: PUSH
54005: EMPTY
54006: LIST
54007: PPUSH
54008: CALL_OW 69
54012: IN
54013: ST_TO_ADDR
// end ;
54014: LD_VAR 0 2
54018: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54019: LD_INT 0
54021: PPUSH
54022: PPUSH
// list := [ ] ;
54023: LD_ADDR_VAR 0 5
54027: PUSH
54028: EMPTY
54029: ST_TO_ADDR
// case d of 0 :
54030: LD_VAR 0 3
54034: PUSH
54035: LD_INT 0
54037: DOUBLE
54038: EQUAL
54039: IFTRUE 54043
54041: GO 54176
54043: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54044: LD_ADDR_VAR 0 5
54048: PUSH
54049: LD_VAR 0 1
54053: PUSH
54054: LD_INT 4
54056: MINUS
54057: PUSH
54058: LD_VAR 0 2
54062: PUSH
54063: LD_INT 4
54065: MINUS
54066: PUSH
54067: LD_INT 2
54069: PUSH
54070: EMPTY
54071: LIST
54072: LIST
54073: LIST
54074: PUSH
54075: LD_VAR 0 1
54079: PUSH
54080: LD_INT 3
54082: MINUS
54083: PUSH
54084: LD_VAR 0 2
54088: PUSH
54089: LD_INT 1
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: LIST
54096: PUSH
54097: LD_VAR 0 1
54101: PUSH
54102: LD_INT 4
54104: PLUS
54105: PUSH
54106: LD_VAR 0 2
54110: PUSH
54111: LD_INT 4
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: LIST
54118: PUSH
54119: LD_VAR 0 1
54123: PUSH
54124: LD_INT 3
54126: PLUS
54127: PUSH
54128: LD_VAR 0 2
54132: PUSH
54133: LD_INT 3
54135: PLUS
54136: PUSH
54137: LD_INT 5
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: LIST
54144: PUSH
54145: LD_VAR 0 1
54149: PUSH
54150: LD_VAR 0 2
54154: PUSH
54155: LD_INT 4
54157: PLUS
54158: PUSH
54159: LD_INT 0
54161: PUSH
54162: EMPTY
54163: LIST
54164: LIST
54165: LIST
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: LIST
54171: LIST
54172: LIST
54173: ST_TO_ADDR
// end ; 1 :
54174: GO 54874
54176: LD_INT 1
54178: DOUBLE
54179: EQUAL
54180: IFTRUE 54184
54182: GO 54317
54184: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54185: LD_ADDR_VAR 0 5
54189: PUSH
54190: LD_VAR 0 1
54194: PUSH
54195: LD_VAR 0 2
54199: PUSH
54200: LD_INT 4
54202: MINUS
54203: PUSH
54204: LD_INT 3
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: LIST
54211: PUSH
54212: LD_VAR 0 1
54216: PUSH
54217: LD_INT 3
54219: MINUS
54220: PUSH
54221: LD_VAR 0 2
54225: PUSH
54226: LD_INT 3
54228: MINUS
54229: PUSH
54230: LD_INT 2
54232: PUSH
54233: EMPTY
54234: LIST
54235: LIST
54236: LIST
54237: PUSH
54238: LD_VAR 0 1
54242: PUSH
54243: LD_INT 4
54245: MINUS
54246: PUSH
54247: LD_VAR 0 2
54251: PUSH
54252: LD_INT 1
54254: PUSH
54255: EMPTY
54256: LIST
54257: LIST
54258: LIST
54259: PUSH
54260: LD_VAR 0 1
54264: PUSH
54265: LD_VAR 0 2
54269: PUSH
54270: LD_INT 3
54272: PLUS
54273: PUSH
54274: LD_INT 0
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: LIST
54281: PUSH
54282: LD_VAR 0 1
54286: PUSH
54287: LD_INT 4
54289: PLUS
54290: PUSH
54291: LD_VAR 0 2
54295: PUSH
54296: LD_INT 4
54298: PLUS
54299: PUSH
54300: LD_INT 5
54302: PUSH
54303: EMPTY
54304: LIST
54305: LIST
54306: LIST
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: ST_TO_ADDR
// end ; 2 :
54315: GO 54874
54317: LD_INT 2
54319: DOUBLE
54320: EQUAL
54321: IFTRUE 54325
54323: GO 54454
54325: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54326: LD_ADDR_VAR 0 5
54330: PUSH
54331: LD_VAR 0 1
54335: PUSH
54336: LD_VAR 0 2
54340: PUSH
54341: LD_INT 3
54343: MINUS
54344: PUSH
54345: LD_INT 3
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: LIST
54352: PUSH
54353: LD_VAR 0 1
54357: PUSH
54358: LD_INT 4
54360: PLUS
54361: PUSH
54362: LD_VAR 0 2
54366: PUSH
54367: LD_INT 4
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: LIST
54374: PUSH
54375: LD_VAR 0 1
54379: PUSH
54380: LD_VAR 0 2
54384: PUSH
54385: LD_INT 4
54387: PLUS
54388: PUSH
54389: LD_INT 0
54391: PUSH
54392: EMPTY
54393: LIST
54394: LIST
54395: LIST
54396: PUSH
54397: LD_VAR 0 1
54401: PUSH
54402: LD_INT 3
54404: MINUS
54405: PUSH
54406: LD_VAR 0 2
54410: PUSH
54411: LD_INT 1
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: LIST
54418: PUSH
54419: LD_VAR 0 1
54423: PUSH
54424: LD_INT 4
54426: MINUS
54427: PUSH
54428: LD_VAR 0 2
54432: PUSH
54433: LD_INT 4
54435: MINUS
54436: PUSH
54437: LD_INT 2
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: LIST
54444: PUSH
54445: EMPTY
54446: LIST
54447: LIST
54448: LIST
54449: LIST
54450: LIST
54451: ST_TO_ADDR
// end ; 3 :
54452: GO 54874
54454: LD_INT 3
54456: DOUBLE
54457: EQUAL
54458: IFTRUE 54462
54460: GO 54595
54462: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54463: LD_ADDR_VAR 0 5
54467: PUSH
54468: LD_VAR 0 1
54472: PUSH
54473: LD_INT 3
54475: PLUS
54476: PUSH
54477: LD_VAR 0 2
54481: PUSH
54482: LD_INT 4
54484: PUSH
54485: EMPTY
54486: LIST
54487: LIST
54488: LIST
54489: PUSH
54490: LD_VAR 0 1
54494: PUSH
54495: LD_INT 4
54497: PLUS
54498: PUSH
54499: LD_VAR 0 2
54503: PUSH
54504: LD_INT 4
54506: PLUS
54507: PUSH
54508: LD_INT 5
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: LIST
54515: PUSH
54516: LD_VAR 0 1
54520: PUSH
54521: LD_INT 4
54523: MINUS
54524: PUSH
54525: LD_VAR 0 2
54529: PUSH
54530: LD_INT 1
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: PUSH
54538: LD_VAR 0 1
54542: PUSH
54543: LD_VAR 0 2
54547: PUSH
54548: LD_INT 4
54550: MINUS
54551: PUSH
54552: LD_INT 3
54554: PUSH
54555: EMPTY
54556: LIST
54557: LIST
54558: LIST
54559: PUSH
54560: LD_VAR 0 1
54564: PUSH
54565: LD_INT 3
54567: MINUS
54568: PUSH
54569: LD_VAR 0 2
54573: PUSH
54574: LD_INT 3
54576: MINUS
54577: PUSH
54578: LD_INT 2
54580: PUSH
54581: EMPTY
54582: LIST
54583: LIST
54584: LIST
54585: PUSH
54586: EMPTY
54587: LIST
54588: LIST
54589: LIST
54590: LIST
54591: LIST
54592: ST_TO_ADDR
// end ; 4 :
54593: GO 54874
54595: LD_INT 4
54597: DOUBLE
54598: EQUAL
54599: IFTRUE 54603
54601: GO 54736
54603: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54604: LD_ADDR_VAR 0 5
54608: PUSH
54609: LD_VAR 0 1
54613: PUSH
54614: LD_VAR 0 2
54618: PUSH
54619: LD_INT 4
54621: PLUS
54622: PUSH
54623: LD_INT 0
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: LIST
54630: PUSH
54631: LD_VAR 0 1
54635: PUSH
54636: LD_INT 3
54638: PLUS
54639: PUSH
54640: LD_VAR 0 2
54644: PUSH
54645: LD_INT 3
54647: PLUS
54648: PUSH
54649: LD_INT 5
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: LIST
54656: PUSH
54657: LD_VAR 0 1
54661: PUSH
54662: LD_INT 4
54664: PLUS
54665: PUSH
54666: LD_VAR 0 2
54670: PUSH
54671: LD_INT 4
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: LIST
54678: PUSH
54679: LD_VAR 0 1
54683: PUSH
54684: LD_VAR 0 2
54688: PUSH
54689: LD_INT 3
54691: MINUS
54692: PUSH
54693: LD_INT 3
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: LIST
54700: PUSH
54701: LD_VAR 0 1
54705: PUSH
54706: LD_INT 4
54708: MINUS
54709: PUSH
54710: LD_VAR 0 2
54714: PUSH
54715: LD_INT 4
54717: MINUS
54718: PUSH
54719: LD_INT 2
54721: PUSH
54722: EMPTY
54723: LIST
54724: LIST
54725: LIST
54726: PUSH
54727: EMPTY
54728: LIST
54729: LIST
54730: LIST
54731: LIST
54732: LIST
54733: ST_TO_ADDR
// end ; 5 :
54734: GO 54874
54736: LD_INT 5
54738: DOUBLE
54739: EQUAL
54740: IFTRUE 54744
54742: GO 54873
54744: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54745: LD_ADDR_VAR 0 5
54749: PUSH
54750: LD_VAR 0 1
54754: PUSH
54755: LD_INT 4
54757: MINUS
54758: PUSH
54759: LD_VAR 0 2
54763: PUSH
54764: LD_INT 1
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: LIST
54771: PUSH
54772: LD_VAR 0 1
54776: PUSH
54777: LD_VAR 0 2
54781: PUSH
54782: LD_INT 4
54784: MINUS
54785: PUSH
54786: LD_INT 3
54788: PUSH
54789: EMPTY
54790: LIST
54791: LIST
54792: LIST
54793: PUSH
54794: LD_VAR 0 1
54798: PUSH
54799: LD_INT 4
54801: PLUS
54802: PUSH
54803: LD_VAR 0 2
54807: PUSH
54808: LD_INT 4
54810: PLUS
54811: PUSH
54812: LD_INT 5
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: LIST
54819: PUSH
54820: LD_VAR 0 1
54824: PUSH
54825: LD_INT 3
54827: PLUS
54828: PUSH
54829: LD_VAR 0 2
54833: PUSH
54834: LD_INT 4
54836: PUSH
54837: EMPTY
54838: LIST
54839: LIST
54840: LIST
54841: PUSH
54842: LD_VAR 0 1
54846: PUSH
54847: LD_VAR 0 2
54851: PUSH
54852: LD_INT 3
54854: PLUS
54855: PUSH
54856: LD_INT 0
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: PUSH
54864: EMPTY
54865: LIST
54866: LIST
54867: LIST
54868: LIST
54869: LIST
54870: ST_TO_ADDR
// end ; end ;
54871: GO 54874
54873: POP
// result := list ;
54874: LD_ADDR_VAR 0 4
54878: PUSH
54879: LD_VAR 0 5
54883: ST_TO_ADDR
// end ;
54884: LD_VAR 0 4
54888: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54889: LD_INT 0
54891: PPUSH
54892: PPUSH
54893: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54894: LD_VAR 0 1
54898: NOT
54899: PUSH
54900: LD_VAR 0 2
54904: PUSH
54905: LD_INT 1
54907: PUSH
54908: LD_INT 2
54910: PUSH
54911: LD_INT 3
54913: PUSH
54914: LD_INT 4
54916: PUSH
54917: EMPTY
54918: LIST
54919: LIST
54920: LIST
54921: LIST
54922: IN
54923: NOT
54924: OR
54925: IFFALSE 54929
// exit ;
54927: GO 55021
// tmp := [ ] ;
54929: LD_ADDR_VAR 0 5
54933: PUSH
54934: EMPTY
54935: ST_TO_ADDR
// for i in units do
54936: LD_ADDR_VAR 0 4
54940: PUSH
54941: LD_VAR 0 1
54945: PUSH
54946: FOR_IN
54947: IFFALSE 54990
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54949: LD_ADDR_VAR 0 5
54953: PUSH
54954: LD_VAR 0 5
54958: PPUSH
54959: LD_VAR 0 5
54963: PUSH
54964: LD_INT 1
54966: PLUS
54967: PPUSH
54968: LD_VAR 0 4
54972: PPUSH
54973: LD_VAR 0 2
54977: PPUSH
54978: CALL_OW 259
54982: PPUSH
54983: CALL_OW 2
54987: ST_TO_ADDR
54988: GO 54946
54990: POP
54991: POP
// if not tmp then
54992: LD_VAR 0 5
54996: NOT
54997: IFFALSE 55001
// exit ;
54999: GO 55021
// result := SortListByListDesc ( units , tmp ) ;
55001: LD_ADDR_VAR 0 3
55005: PUSH
55006: LD_VAR 0 1
55010: PPUSH
55011: LD_VAR 0 5
55015: PPUSH
55016: CALL_OW 77
55020: ST_TO_ADDR
// end ;
55021: LD_VAR 0 3
55025: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55026: LD_INT 0
55028: PPUSH
55029: PPUSH
55030: PPUSH
// x := GetX ( building ) ;
55031: LD_ADDR_VAR 0 4
55035: PUSH
55036: LD_VAR 0 2
55040: PPUSH
55041: CALL_OW 250
55045: ST_TO_ADDR
// y := GetY ( building ) ;
55046: LD_ADDR_VAR 0 5
55050: PUSH
55051: LD_VAR 0 2
55055: PPUSH
55056: CALL_OW 251
55060: ST_TO_ADDR
// if GetTaskList ( unit ) then
55061: LD_VAR 0 1
55065: PPUSH
55066: CALL_OW 437
55070: IFFALSE 55165
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55072: LD_STRING e
55074: PUSH
55075: LD_VAR 0 1
55079: PPUSH
55080: CALL_OW 437
55084: PUSH
55085: LD_INT 1
55087: ARRAY
55088: PUSH
55089: LD_INT 1
55091: ARRAY
55092: EQUAL
55093: PUSH
55094: LD_VAR 0 4
55098: PUSH
55099: LD_VAR 0 1
55103: PPUSH
55104: CALL_OW 437
55108: PUSH
55109: LD_INT 1
55111: ARRAY
55112: PUSH
55113: LD_INT 2
55115: ARRAY
55116: EQUAL
55117: AND
55118: PUSH
55119: LD_VAR 0 5
55123: PUSH
55124: LD_VAR 0 1
55128: PPUSH
55129: CALL_OW 437
55133: PUSH
55134: LD_INT 1
55136: ARRAY
55137: PUSH
55138: LD_INT 3
55140: ARRAY
55141: EQUAL
55142: AND
55143: IFFALSE 55155
// result := true else
55145: LD_ADDR_VAR 0 3
55149: PUSH
55150: LD_INT 1
55152: ST_TO_ADDR
55153: GO 55163
// result := false ;
55155: LD_ADDR_VAR 0 3
55159: PUSH
55160: LD_INT 0
55162: ST_TO_ADDR
// end else
55163: GO 55173
// result := false ;
55165: LD_ADDR_VAR 0 3
55169: PUSH
55170: LD_INT 0
55172: ST_TO_ADDR
// end ;
55173: LD_VAR 0 3
55177: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55178: LD_INT 0
55180: PPUSH
55181: PPUSH
55182: PPUSH
55183: PPUSH
// if not unit or not area then
55184: LD_VAR 0 1
55188: NOT
55189: PUSH
55190: LD_VAR 0 2
55194: NOT
55195: OR
55196: IFFALSE 55200
// exit ;
55198: GO 55364
// tmp := AreaToList ( area , i ) ;
55200: LD_ADDR_VAR 0 6
55204: PUSH
55205: LD_VAR 0 2
55209: PPUSH
55210: LD_VAR 0 5
55214: PPUSH
55215: CALL_OW 517
55219: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55220: LD_ADDR_VAR 0 5
55224: PUSH
55225: DOUBLE
55226: LD_INT 1
55228: DEC
55229: ST_TO_ADDR
55230: LD_VAR 0 6
55234: PUSH
55235: LD_INT 1
55237: ARRAY
55238: PUSH
55239: FOR_TO
55240: IFFALSE 55362
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55242: LD_ADDR_VAR 0 7
55246: PUSH
55247: LD_VAR 0 6
55251: PUSH
55252: LD_INT 1
55254: ARRAY
55255: PUSH
55256: LD_VAR 0 5
55260: ARRAY
55261: PUSH
55262: LD_VAR 0 6
55266: PUSH
55267: LD_INT 2
55269: ARRAY
55270: PUSH
55271: LD_VAR 0 5
55275: ARRAY
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55281: LD_VAR 0 7
55285: PUSH
55286: LD_INT 1
55288: ARRAY
55289: PPUSH
55290: LD_VAR 0 7
55294: PUSH
55295: LD_INT 2
55297: ARRAY
55298: PPUSH
55299: CALL_OW 428
55303: PUSH
55304: LD_INT 0
55306: EQUAL
55307: IFFALSE 55360
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55309: LD_VAR 0 1
55313: PPUSH
55314: LD_VAR 0 7
55318: PUSH
55319: LD_INT 1
55321: ARRAY
55322: PPUSH
55323: LD_VAR 0 7
55327: PUSH
55328: LD_INT 2
55330: ARRAY
55331: PPUSH
55332: LD_VAR 0 3
55336: PPUSH
55337: CALL_OW 48
// result := IsPlaced ( unit ) ;
55341: LD_ADDR_VAR 0 4
55345: PUSH
55346: LD_VAR 0 1
55350: PPUSH
55351: CALL_OW 305
55355: ST_TO_ADDR
// exit ;
55356: POP
55357: POP
55358: GO 55364
// end ; end ;
55360: GO 55239
55362: POP
55363: POP
// end ;
55364: LD_VAR 0 4
55368: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55369: LD_INT 0
55371: PPUSH
55372: PPUSH
55373: PPUSH
// if not side or side > 8 then
55374: LD_VAR 0 1
55378: NOT
55379: PUSH
55380: LD_VAR 0 1
55384: PUSH
55385: LD_INT 8
55387: GREATER
55388: OR
55389: IFFALSE 55393
// exit ;
55391: GO 55580
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55393: LD_ADDR_VAR 0 4
55397: PUSH
55398: LD_INT 22
55400: PUSH
55401: LD_VAR 0 1
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PUSH
55410: LD_INT 21
55412: PUSH
55413: LD_INT 3
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: EMPTY
55421: LIST
55422: LIST
55423: PPUSH
55424: CALL_OW 69
55428: ST_TO_ADDR
// if not tmp then
55429: LD_VAR 0 4
55433: NOT
55434: IFFALSE 55438
// exit ;
55436: GO 55580
// enable_addtolog := true ;
55438: LD_ADDR_OWVAR 81
55442: PUSH
55443: LD_INT 1
55445: ST_TO_ADDR
// AddToLog ( [ ) ;
55446: LD_STRING [
55448: PPUSH
55449: CALL_OW 561
// for i in tmp do
55453: LD_ADDR_VAR 0 3
55457: PUSH
55458: LD_VAR 0 4
55462: PUSH
55463: FOR_IN
55464: IFFALSE 55571
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55466: LD_STRING [
55468: PUSH
55469: LD_VAR 0 3
55473: PPUSH
55474: CALL_OW 266
55478: STR
55479: PUSH
55480: LD_STRING , 
55482: STR
55483: PUSH
55484: LD_VAR 0 3
55488: PPUSH
55489: CALL_OW 250
55493: STR
55494: PUSH
55495: LD_STRING , 
55497: STR
55498: PUSH
55499: LD_VAR 0 3
55503: PPUSH
55504: CALL_OW 251
55508: STR
55509: PUSH
55510: LD_STRING , 
55512: STR
55513: PUSH
55514: LD_VAR 0 3
55518: PPUSH
55519: CALL_OW 254
55523: STR
55524: PUSH
55525: LD_STRING , 
55527: STR
55528: PUSH
55529: LD_VAR 0 3
55533: PPUSH
55534: LD_INT 1
55536: PPUSH
55537: CALL_OW 268
55541: STR
55542: PUSH
55543: LD_STRING , 
55545: STR
55546: PUSH
55547: LD_VAR 0 3
55551: PPUSH
55552: LD_INT 2
55554: PPUSH
55555: CALL_OW 268
55559: STR
55560: PUSH
55561: LD_STRING ],
55563: STR
55564: PPUSH
55565: CALL_OW 561
// end ;
55569: GO 55463
55571: POP
55572: POP
// AddToLog ( ]; ) ;
55573: LD_STRING ];
55575: PPUSH
55576: CALL_OW 561
// end ;
55580: LD_VAR 0 2
55584: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55585: LD_INT 0
55587: PPUSH
55588: PPUSH
55589: PPUSH
55590: PPUSH
55591: PPUSH
// if not area or not rate or not max then
55592: LD_VAR 0 1
55596: NOT
55597: PUSH
55598: LD_VAR 0 2
55602: NOT
55603: OR
55604: PUSH
55605: LD_VAR 0 4
55609: NOT
55610: OR
55611: IFFALSE 55615
// exit ;
55613: GO 55807
// while 1 do
55615: LD_INT 1
55617: IFFALSE 55807
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55619: LD_ADDR_VAR 0 9
55623: PUSH
55624: LD_VAR 0 1
55628: PPUSH
55629: LD_INT 1
55631: PPUSH
55632: CALL_OW 287
55636: PUSH
55637: LD_INT 10
55639: MUL
55640: ST_TO_ADDR
// r := rate / 10 ;
55641: LD_ADDR_VAR 0 7
55645: PUSH
55646: LD_VAR 0 2
55650: PUSH
55651: LD_INT 10
55653: DIVREAL
55654: ST_TO_ADDR
// time := 1 1$00 ;
55655: LD_ADDR_VAR 0 8
55659: PUSH
55660: LD_INT 2100
55662: ST_TO_ADDR
// if amount < min then
55663: LD_VAR 0 9
55667: PUSH
55668: LD_VAR 0 3
55672: LESS
55673: IFFALSE 55691
// r := r * 2 else
55675: LD_ADDR_VAR 0 7
55679: PUSH
55680: LD_VAR 0 7
55684: PUSH
55685: LD_INT 2
55687: MUL
55688: ST_TO_ADDR
55689: GO 55717
// if amount > max then
55691: LD_VAR 0 9
55695: PUSH
55696: LD_VAR 0 4
55700: GREATER
55701: IFFALSE 55717
// r := r / 2 ;
55703: LD_ADDR_VAR 0 7
55707: PUSH
55708: LD_VAR 0 7
55712: PUSH
55713: LD_INT 2
55715: DIVREAL
55716: ST_TO_ADDR
// time := time / r ;
55717: LD_ADDR_VAR 0 8
55721: PUSH
55722: LD_VAR 0 8
55726: PUSH
55727: LD_VAR 0 7
55731: DIVREAL
55732: ST_TO_ADDR
// if time < 0 then
55733: LD_VAR 0 8
55737: PUSH
55738: LD_INT 0
55740: LESS
55741: IFFALSE 55758
// time := time * - 1 ;
55743: LD_ADDR_VAR 0 8
55747: PUSH
55748: LD_VAR 0 8
55752: PUSH
55753: LD_INT 1
55755: NEG
55756: MUL
55757: ST_TO_ADDR
// wait ( time ) ;
55758: LD_VAR 0 8
55762: PPUSH
55763: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55767: LD_INT 35
55769: PPUSH
55770: LD_INT 875
55772: PPUSH
55773: CALL_OW 12
55777: PPUSH
55778: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55782: LD_INT 1
55784: PPUSH
55785: LD_INT 5
55787: PPUSH
55788: CALL_OW 12
55792: PPUSH
55793: LD_VAR 0 1
55797: PPUSH
55798: LD_INT 1
55800: PPUSH
55801: CALL_OW 55
// end ;
55805: GO 55615
// end ;
55807: LD_VAR 0 5
55811: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55812: LD_INT 0
55814: PPUSH
55815: PPUSH
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
55820: PPUSH
55821: PPUSH
// if not turrets or not factories then
55822: LD_VAR 0 1
55826: NOT
55827: PUSH
55828: LD_VAR 0 2
55832: NOT
55833: OR
55834: IFFALSE 55838
// exit ;
55836: GO 56145
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55838: LD_ADDR_VAR 0 10
55842: PUSH
55843: LD_INT 5
55845: PUSH
55846: LD_INT 6
55848: PUSH
55849: EMPTY
55850: LIST
55851: LIST
55852: PUSH
55853: LD_INT 2
55855: PUSH
55856: LD_INT 4
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: PUSH
55863: LD_INT 3
55865: PUSH
55866: LD_INT 5
55868: PUSH
55869: EMPTY
55870: LIST
55871: LIST
55872: PUSH
55873: EMPTY
55874: LIST
55875: LIST
55876: LIST
55877: PUSH
55878: LD_INT 24
55880: PUSH
55881: LD_INT 25
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PUSH
55888: LD_INT 23
55890: PUSH
55891: LD_INT 27
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PUSH
55902: LD_INT 42
55904: PUSH
55905: LD_INT 43
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: PUSH
55912: LD_INT 44
55914: PUSH
55915: LD_INT 46
55917: PUSH
55918: EMPTY
55919: LIST
55920: LIST
55921: PUSH
55922: LD_INT 45
55924: PUSH
55925: LD_INT 47
55927: PUSH
55928: EMPTY
55929: LIST
55930: LIST
55931: PUSH
55932: EMPTY
55933: LIST
55934: LIST
55935: LIST
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: LIST
55941: ST_TO_ADDR
// result := [ ] ;
55942: LD_ADDR_VAR 0 3
55946: PUSH
55947: EMPTY
55948: ST_TO_ADDR
// for i in turrets do
55949: LD_ADDR_VAR 0 4
55953: PUSH
55954: LD_VAR 0 1
55958: PUSH
55959: FOR_IN
55960: IFFALSE 56143
// begin nat := GetNation ( i ) ;
55962: LD_ADDR_VAR 0 7
55966: PUSH
55967: LD_VAR 0 4
55971: PPUSH
55972: CALL_OW 248
55976: ST_TO_ADDR
// weapon := 0 ;
55977: LD_ADDR_VAR 0 8
55981: PUSH
55982: LD_INT 0
55984: ST_TO_ADDR
// if not nat then
55985: LD_VAR 0 7
55989: NOT
55990: IFFALSE 55994
// continue ;
55992: GO 55959
// for j in list [ nat ] do
55994: LD_ADDR_VAR 0 5
55998: PUSH
55999: LD_VAR 0 10
56003: PUSH
56004: LD_VAR 0 7
56008: ARRAY
56009: PUSH
56010: FOR_IN
56011: IFFALSE 56052
// if GetBWeapon ( i ) = j [ 1 ] then
56013: LD_VAR 0 4
56017: PPUSH
56018: CALL_OW 269
56022: PUSH
56023: LD_VAR 0 5
56027: PUSH
56028: LD_INT 1
56030: ARRAY
56031: EQUAL
56032: IFFALSE 56050
// begin weapon := j [ 2 ] ;
56034: LD_ADDR_VAR 0 8
56038: PUSH
56039: LD_VAR 0 5
56043: PUSH
56044: LD_INT 2
56046: ARRAY
56047: ST_TO_ADDR
// break ;
56048: GO 56052
// end ;
56050: GO 56010
56052: POP
56053: POP
// if not weapon then
56054: LD_VAR 0 8
56058: NOT
56059: IFFALSE 56063
// continue ;
56061: GO 55959
// for k in factories do
56063: LD_ADDR_VAR 0 6
56067: PUSH
56068: LD_VAR 0 2
56072: PUSH
56073: FOR_IN
56074: IFFALSE 56139
// begin weapons := AvailableWeaponList ( k ) ;
56076: LD_ADDR_VAR 0 9
56080: PUSH
56081: LD_VAR 0 6
56085: PPUSH
56086: CALL_OW 478
56090: ST_TO_ADDR
// if not weapons then
56091: LD_VAR 0 9
56095: NOT
56096: IFFALSE 56100
// continue ;
56098: GO 56073
// if weapon in weapons then
56100: LD_VAR 0 8
56104: PUSH
56105: LD_VAR 0 9
56109: IN
56110: IFFALSE 56137
// begin result := [ i , weapon ] ;
56112: LD_ADDR_VAR 0 3
56116: PUSH
56117: LD_VAR 0 4
56121: PUSH
56122: LD_VAR 0 8
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: ST_TO_ADDR
// exit ;
56131: POP
56132: POP
56133: POP
56134: POP
56135: GO 56145
// end ; end ;
56137: GO 56073
56139: POP
56140: POP
// end ;
56141: GO 55959
56143: POP
56144: POP
// end ;
56145: LD_VAR 0 3
56149: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56150: LD_INT 0
56152: PPUSH
// if not side or side > 8 then
56153: LD_VAR 0 3
56157: NOT
56158: PUSH
56159: LD_VAR 0 3
56163: PUSH
56164: LD_INT 8
56166: GREATER
56167: OR
56168: IFFALSE 56172
// exit ;
56170: GO 56231
// if not range then
56172: LD_VAR 0 4
56176: NOT
56177: IFFALSE 56188
// range := - 12 ;
56179: LD_ADDR_VAR 0 4
56183: PUSH
56184: LD_INT 12
56186: NEG
56187: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56188: LD_VAR 0 1
56192: PPUSH
56193: LD_VAR 0 2
56197: PPUSH
56198: LD_VAR 0 3
56202: PPUSH
56203: LD_VAR 0 4
56207: PPUSH
56208: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56212: LD_VAR 0 1
56216: PPUSH
56217: LD_VAR 0 2
56221: PPUSH
56222: LD_VAR 0 3
56226: PPUSH
56227: CALL_OW 331
// end ;
56231: LD_VAR 0 5
56235: RET
// export function Video ( mode ) ; begin
56236: LD_INT 0
56238: PPUSH
// ingame_video = mode ;
56239: LD_ADDR_OWVAR 52
56243: PUSH
56244: LD_VAR 0 1
56248: ST_TO_ADDR
// interface_hidden = mode ;
56249: LD_ADDR_OWVAR 54
56253: PUSH
56254: LD_VAR 0 1
56258: ST_TO_ADDR
// end ;
56259: LD_VAR 0 2
56263: RET
// export function Join ( array , element ) ; begin
56264: LD_INT 0
56266: PPUSH
// result := array ^ element ;
56267: LD_ADDR_VAR 0 3
56271: PUSH
56272: LD_VAR 0 1
56276: PUSH
56277: LD_VAR 0 2
56281: ADD
56282: ST_TO_ADDR
// end ;
56283: LD_VAR 0 3
56287: RET
// export function JoinUnion ( array , element ) ; begin
56288: LD_INT 0
56290: PPUSH
// result := array union element ;
56291: LD_ADDR_VAR 0 3
56295: PUSH
56296: LD_VAR 0 1
56300: PUSH
56301: LD_VAR 0 2
56305: UNION
56306: ST_TO_ADDR
// end ;
56307: LD_VAR 0 3
56311: RET
// export function GetBehemoths ( side ) ; begin
56312: LD_INT 0
56314: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56315: LD_ADDR_VAR 0 2
56319: PUSH
56320: LD_INT 22
56322: PUSH
56323: LD_VAR 0 1
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: PUSH
56332: LD_INT 31
56334: PUSH
56335: LD_INT 25
56337: PUSH
56338: EMPTY
56339: LIST
56340: LIST
56341: PUSH
56342: EMPTY
56343: LIST
56344: LIST
56345: PPUSH
56346: CALL_OW 69
56350: ST_TO_ADDR
// end ;
56351: LD_VAR 0 2
56355: RET
// export function Shuffle ( array ) ; var i , index ; begin
56356: LD_INT 0
56358: PPUSH
56359: PPUSH
56360: PPUSH
// result := [ ] ;
56361: LD_ADDR_VAR 0 2
56365: PUSH
56366: EMPTY
56367: ST_TO_ADDR
// if not array then
56368: LD_VAR 0 1
56372: NOT
56373: IFFALSE 56377
// exit ;
56375: GO 56476
// Randomize ;
56377: CALL_OW 10
// for i = array downto 1 do
56381: LD_ADDR_VAR 0 3
56385: PUSH
56386: DOUBLE
56387: LD_VAR 0 1
56391: INC
56392: ST_TO_ADDR
56393: LD_INT 1
56395: PUSH
56396: FOR_DOWNTO
56397: IFFALSE 56474
// begin index := rand ( 1 , array ) ;
56399: LD_ADDR_VAR 0 4
56403: PUSH
56404: LD_INT 1
56406: PPUSH
56407: LD_VAR 0 1
56411: PPUSH
56412: CALL_OW 12
56416: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56417: LD_ADDR_VAR 0 2
56421: PUSH
56422: LD_VAR 0 2
56426: PPUSH
56427: LD_VAR 0 2
56431: PUSH
56432: LD_INT 1
56434: PLUS
56435: PPUSH
56436: LD_VAR 0 1
56440: PUSH
56441: LD_VAR 0 4
56445: ARRAY
56446: PPUSH
56447: CALL_OW 2
56451: ST_TO_ADDR
// array := Delete ( array , index ) ;
56452: LD_ADDR_VAR 0 1
56456: PUSH
56457: LD_VAR 0 1
56461: PPUSH
56462: LD_VAR 0 4
56466: PPUSH
56467: CALL_OW 3
56471: ST_TO_ADDR
// end ;
56472: GO 56396
56474: POP
56475: POP
// end ; end_of_file
56476: LD_VAR 0 2
56480: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56481: LD_INT 0
56483: PPUSH
56484: PPUSH
// skirmish := false ;
56485: LD_ADDR_EXP 56
56489: PUSH
56490: LD_INT 0
56492: ST_TO_ADDR
// debug_mc := false ;
56493: LD_ADDR_EXP 57
56497: PUSH
56498: LD_INT 0
56500: ST_TO_ADDR
// mc_bases := [ ] ;
56501: LD_ADDR_EXP 58
56505: PUSH
56506: EMPTY
56507: ST_TO_ADDR
// mc_sides := [ ] ;
56508: LD_ADDR_EXP 84
56512: PUSH
56513: EMPTY
56514: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56515: LD_ADDR_EXP 59
56519: PUSH
56520: EMPTY
56521: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56522: LD_ADDR_EXP 60
56526: PUSH
56527: EMPTY
56528: ST_TO_ADDR
// mc_need_heal := [ ] ;
56529: LD_ADDR_EXP 61
56533: PUSH
56534: EMPTY
56535: ST_TO_ADDR
// mc_healers := [ ] ;
56536: LD_ADDR_EXP 62
56540: PUSH
56541: EMPTY
56542: ST_TO_ADDR
// mc_build_list := [ ] ;
56543: LD_ADDR_EXP 63
56547: PUSH
56548: EMPTY
56549: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56550: LD_ADDR_EXP 90
56554: PUSH
56555: EMPTY
56556: ST_TO_ADDR
// mc_builders := [ ] ;
56557: LD_ADDR_EXP 64
56561: PUSH
56562: EMPTY
56563: ST_TO_ADDR
// mc_construct_list := [ ] ;
56564: LD_ADDR_EXP 65
56568: PUSH
56569: EMPTY
56570: ST_TO_ADDR
// mc_turret_list := [ ] ;
56571: LD_ADDR_EXP 66
56575: PUSH
56576: EMPTY
56577: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56578: LD_ADDR_EXP 67
56582: PUSH
56583: EMPTY
56584: ST_TO_ADDR
// mc_miners := [ ] ;
56585: LD_ADDR_EXP 72
56589: PUSH
56590: EMPTY
56591: ST_TO_ADDR
// mc_mines := [ ] ;
56592: LD_ADDR_EXP 71
56596: PUSH
56597: EMPTY
56598: ST_TO_ADDR
// mc_minefields := [ ] ;
56599: LD_ADDR_EXP 73
56603: PUSH
56604: EMPTY
56605: ST_TO_ADDR
// mc_crates := [ ] ;
56606: LD_ADDR_EXP 74
56610: PUSH
56611: EMPTY
56612: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56613: LD_ADDR_EXP 75
56617: PUSH
56618: EMPTY
56619: ST_TO_ADDR
// mc_crates_area := [ ] ;
56620: LD_ADDR_EXP 76
56624: PUSH
56625: EMPTY
56626: ST_TO_ADDR
// mc_vehicles := [ ] ;
56627: LD_ADDR_EXP 77
56631: PUSH
56632: EMPTY
56633: ST_TO_ADDR
// mc_attack := [ ] ;
56634: LD_ADDR_EXP 78
56638: PUSH
56639: EMPTY
56640: ST_TO_ADDR
// mc_produce := [ ] ;
56641: LD_ADDR_EXP 79
56645: PUSH
56646: EMPTY
56647: ST_TO_ADDR
// mc_defender := [ ] ;
56648: LD_ADDR_EXP 80
56652: PUSH
56653: EMPTY
56654: ST_TO_ADDR
// mc_parking := [ ] ;
56655: LD_ADDR_EXP 82
56659: PUSH
56660: EMPTY
56661: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56662: LD_ADDR_EXP 68
56666: PUSH
56667: EMPTY
56668: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56669: LD_ADDR_EXP 70
56673: PUSH
56674: EMPTY
56675: ST_TO_ADDR
// mc_scan := [ ] ;
56676: LD_ADDR_EXP 81
56680: PUSH
56681: EMPTY
56682: ST_TO_ADDR
// mc_scan_area := [ ] ;
56683: LD_ADDR_EXP 83
56687: PUSH
56688: EMPTY
56689: ST_TO_ADDR
// mc_tech := [ ] ;
56690: LD_ADDR_EXP 85
56694: PUSH
56695: EMPTY
56696: ST_TO_ADDR
// mc_class := [ ] ;
56697: LD_ADDR_EXP 99
56701: PUSH
56702: EMPTY
56703: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56704: LD_ADDR_EXP 100
56708: PUSH
56709: EMPTY
56710: ST_TO_ADDR
// end ;
56711: LD_VAR 0 1
56715: RET
// export function MC_Kill ( base ) ; begin
56716: LD_INT 0
56718: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56719: LD_ADDR_EXP 58
56723: PUSH
56724: LD_EXP 58
56728: PPUSH
56729: LD_VAR 0 1
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56741: LD_ADDR_EXP 59
56745: PUSH
56746: LD_EXP 59
56750: PPUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56763: LD_ADDR_EXP 60
56767: PUSH
56768: LD_EXP 60
56772: PPUSH
56773: LD_VAR 0 1
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56785: LD_ADDR_EXP 61
56789: PUSH
56790: LD_EXP 61
56794: PPUSH
56795: LD_VAR 0 1
56799: PPUSH
56800: EMPTY
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56807: LD_ADDR_EXP 62
56811: PUSH
56812: LD_EXP 62
56816: PPUSH
56817: LD_VAR 0 1
56821: PPUSH
56822: EMPTY
56823: PPUSH
56824: CALL_OW 1
56828: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56829: LD_ADDR_EXP 63
56833: PUSH
56834: LD_EXP 63
56838: PPUSH
56839: LD_VAR 0 1
56843: PPUSH
56844: EMPTY
56845: PPUSH
56846: CALL_OW 1
56850: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56851: LD_ADDR_EXP 64
56855: PUSH
56856: LD_EXP 64
56860: PPUSH
56861: LD_VAR 0 1
56865: PPUSH
56866: EMPTY
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56873: LD_ADDR_EXP 65
56877: PUSH
56878: LD_EXP 65
56882: PPUSH
56883: LD_VAR 0 1
56887: PPUSH
56888: EMPTY
56889: PPUSH
56890: CALL_OW 1
56894: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56895: LD_ADDR_EXP 66
56899: PUSH
56900: LD_EXP 66
56904: PPUSH
56905: LD_VAR 0 1
56909: PPUSH
56910: EMPTY
56911: PPUSH
56912: CALL_OW 1
56916: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56917: LD_ADDR_EXP 67
56921: PUSH
56922: LD_EXP 67
56926: PPUSH
56927: LD_VAR 0 1
56931: PPUSH
56932: EMPTY
56933: PPUSH
56934: CALL_OW 1
56938: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56939: LD_ADDR_EXP 68
56943: PUSH
56944: LD_EXP 68
56948: PPUSH
56949: LD_VAR 0 1
56953: PPUSH
56954: EMPTY
56955: PPUSH
56956: CALL_OW 1
56960: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56961: LD_ADDR_EXP 69
56965: PUSH
56966: LD_EXP 69
56970: PPUSH
56971: LD_VAR 0 1
56975: PPUSH
56976: LD_INT 0
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56984: LD_ADDR_EXP 70
56988: PUSH
56989: LD_EXP 70
56993: PPUSH
56994: LD_VAR 0 1
56998: PPUSH
56999: EMPTY
57000: PPUSH
57001: CALL_OW 1
57005: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57006: LD_ADDR_EXP 71
57010: PUSH
57011: LD_EXP 71
57015: PPUSH
57016: LD_VAR 0 1
57020: PPUSH
57021: EMPTY
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57028: LD_ADDR_EXP 72
57032: PUSH
57033: LD_EXP 72
57037: PPUSH
57038: LD_VAR 0 1
57042: PPUSH
57043: EMPTY
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57050: LD_ADDR_EXP 73
57054: PUSH
57055: LD_EXP 73
57059: PPUSH
57060: LD_VAR 0 1
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57072: LD_ADDR_EXP 74
57076: PUSH
57077: LD_EXP 74
57081: PPUSH
57082: LD_VAR 0 1
57086: PPUSH
57087: EMPTY
57088: PPUSH
57089: CALL_OW 1
57093: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57094: LD_ADDR_EXP 75
57098: PUSH
57099: LD_EXP 75
57103: PPUSH
57104: LD_VAR 0 1
57108: PPUSH
57109: EMPTY
57110: PPUSH
57111: CALL_OW 1
57115: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57116: LD_ADDR_EXP 76
57120: PUSH
57121: LD_EXP 76
57125: PPUSH
57126: LD_VAR 0 1
57130: PPUSH
57131: EMPTY
57132: PPUSH
57133: CALL_OW 1
57137: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57138: LD_ADDR_EXP 77
57142: PUSH
57143: LD_EXP 77
57147: PPUSH
57148: LD_VAR 0 1
57152: PPUSH
57153: EMPTY
57154: PPUSH
57155: CALL_OW 1
57159: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57160: LD_ADDR_EXP 78
57164: PUSH
57165: LD_EXP 78
57169: PPUSH
57170: LD_VAR 0 1
57174: PPUSH
57175: EMPTY
57176: PPUSH
57177: CALL_OW 1
57181: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57182: LD_ADDR_EXP 79
57186: PUSH
57187: LD_EXP 79
57191: PPUSH
57192: LD_VAR 0 1
57196: PPUSH
57197: EMPTY
57198: PPUSH
57199: CALL_OW 1
57203: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57204: LD_ADDR_EXP 80
57208: PUSH
57209: LD_EXP 80
57213: PPUSH
57214: LD_VAR 0 1
57218: PPUSH
57219: EMPTY
57220: PPUSH
57221: CALL_OW 1
57225: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57226: LD_ADDR_EXP 81
57230: PUSH
57231: LD_EXP 81
57235: PPUSH
57236: LD_VAR 0 1
57240: PPUSH
57241: EMPTY
57242: PPUSH
57243: CALL_OW 1
57247: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57248: LD_ADDR_EXP 82
57252: PUSH
57253: LD_EXP 82
57257: PPUSH
57258: LD_VAR 0 1
57262: PPUSH
57263: EMPTY
57264: PPUSH
57265: CALL_OW 1
57269: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57270: LD_ADDR_EXP 83
57274: PUSH
57275: LD_EXP 83
57279: PPUSH
57280: LD_VAR 0 1
57284: PPUSH
57285: EMPTY
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57292: LD_ADDR_EXP 85
57296: PUSH
57297: LD_EXP 85
57301: PPUSH
57302: LD_VAR 0 1
57306: PPUSH
57307: EMPTY
57308: PPUSH
57309: CALL_OW 1
57313: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57314: LD_ADDR_EXP 87
57318: PUSH
57319: LD_EXP 87
57323: PPUSH
57324: LD_VAR 0 1
57328: PPUSH
57329: EMPTY
57330: PPUSH
57331: CALL_OW 1
57335: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57336: LD_ADDR_EXP 88
57340: PUSH
57341: LD_EXP 88
57345: PPUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: EMPTY
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57358: LD_ADDR_EXP 89
57362: PUSH
57363: LD_EXP 89
57367: PPUSH
57368: LD_VAR 0 1
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57380: LD_ADDR_EXP 90
57384: PUSH
57385: LD_EXP 90
57389: PPUSH
57390: LD_VAR 0 1
57394: PPUSH
57395: EMPTY
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57402: LD_ADDR_EXP 91
57406: PUSH
57407: LD_EXP 91
57411: PPUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: EMPTY
57418: PPUSH
57419: CALL_OW 1
57423: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57424: LD_ADDR_EXP 92
57428: PUSH
57429: LD_EXP 92
57433: PPUSH
57434: LD_VAR 0 1
57438: PPUSH
57439: EMPTY
57440: PPUSH
57441: CALL_OW 1
57445: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57446: LD_ADDR_EXP 93
57450: PUSH
57451: LD_EXP 93
57455: PPUSH
57456: LD_VAR 0 1
57460: PPUSH
57461: EMPTY
57462: PPUSH
57463: CALL_OW 1
57467: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57468: LD_ADDR_EXP 94
57472: PUSH
57473: LD_EXP 94
57477: PPUSH
57478: LD_VAR 0 1
57482: PPUSH
57483: EMPTY
57484: PPUSH
57485: CALL_OW 1
57489: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57490: LD_ADDR_EXP 95
57494: PUSH
57495: LD_EXP 95
57499: PPUSH
57500: LD_VAR 0 1
57504: PPUSH
57505: EMPTY
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57512: LD_ADDR_EXP 96
57516: PUSH
57517: LD_EXP 96
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: EMPTY
57528: PPUSH
57529: CALL_OW 1
57533: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57534: LD_ADDR_EXP 97
57538: PUSH
57539: LD_EXP 97
57543: PPUSH
57544: LD_VAR 0 1
57548: PPUSH
57549: EMPTY
57550: PPUSH
57551: CALL_OW 1
57555: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57556: LD_ADDR_EXP 98
57560: PUSH
57561: LD_EXP 98
57565: PPUSH
57566: LD_VAR 0 1
57570: PPUSH
57571: EMPTY
57572: PPUSH
57573: CALL_OW 1
57577: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57578: LD_ADDR_EXP 99
57582: PUSH
57583: LD_EXP 99
57587: PPUSH
57588: LD_VAR 0 1
57592: PPUSH
57593: EMPTY
57594: PPUSH
57595: CALL_OW 1
57599: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57600: LD_ADDR_EXP 100
57604: PUSH
57605: LD_EXP 100
57609: PPUSH
57610: LD_VAR 0 1
57614: PPUSH
57615: LD_INT 0
57617: PPUSH
57618: CALL_OW 1
57622: ST_TO_ADDR
// end ;
57623: LD_VAR 0 2
57627: RET
// export function MC_Add ( side , units ) ; var base ; begin
57628: LD_INT 0
57630: PPUSH
57631: PPUSH
// base := mc_bases + 1 ;
57632: LD_ADDR_VAR 0 4
57636: PUSH
57637: LD_EXP 58
57641: PUSH
57642: LD_INT 1
57644: PLUS
57645: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57646: LD_ADDR_EXP 84
57650: PUSH
57651: LD_EXP 84
57655: PPUSH
57656: LD_VAR 0 4
57660: PPUSH
57661: LD_VAR 0 1
57665: PPUSH
57666: CALL_OW 1
57670: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57671: LD_ADDR_EXP 58
57675: PUSH
57676: LD_EXP 58
57680: PPUSH
57681: LD_VAR 0 4
57685: PPUSH
57686: LD_VAR 0 2
57690: PPUSH
57691: CALL_OW 1
57695: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57696: LD_ADDR_EXP 59
57700: PUSH
57701: LD_EXP 59
57705: PPUSH
57706: LD_VAR 0 4
57710: PPUSH
57711: EMPTY
57712: PPUSH
57713: CALL_OW 1
57717: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57718: LD_ADDR_EXP 60
57722: PUSH
57723: LD_EXP 60
57727: PPUSH
57728: LD_VAR 0 4
57732: PPUSH
57733: EMPTY
57734: PPUSH
57735: CALL_OW 1
57739: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57740: LD_ADDR_EXP 61
57744: PUSH
57745: LD_EXP 61
57749: PPUSH
57750: LD_VAR 0 4
57754: PPUSH
57755: EMPTY
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57762: LD_ADDR_EXP 62
57766: PUSH
57767: LD_EXP 62
57771: PPUSH
57772: LD_VAR 0 4
57776: PPUSH
57777: EMPTY
57778: PPUSH
57779: CALL_OW 1
57783: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57784: LD_ADDR_EXP 63
57788: PUSH
57789: LD_EXP 63
57793: PPUSH
57794: LD_VAR 0 4
57798: PPUSH
57799: EMPTY
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57806: LD_ADDR_EXP 64
57810: PUSH
57811: LD_EXP 64
57815: PPUSH
57816: LD_VAR 0 4
57820: PPUSH
57821: EMPTY
57822: PPUSH
57823: CALL_OW 1
57827: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57828: LD_ADDR_EXP 65
57832: PUSH
57833: LD_EXP 65
57837: PPUSH
57838: LD_VAR 0 4
57842: PPUSH
57843: EMPTY
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57850: LD_ADDR_EXP 66
57854: PUSH
57855: LD_EXP 66
57859: PPUSH
57860: LD_VAR 0 4
57864: PPUSH
57865: EMPTY
57866: PPUSH
57867: CALL_OW 1
57871: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57872: LD_ADDR_EXP 67
57876: PUSH
57877: LD_EXP 67
57881: PPUSH
57882: LD_VAR 0 4
57886: PPUSH
57887: EMPTY
57888: PPUSH
57889: CALL_OW 1
57893: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57894: LD_ADDR_EXP 68
57898: PUSH
57899: LD_EXP 68
57903: PPUSH
57904: LD_VAR 0 4
57908: PPUSH
57909: EMPTY
57910: PPUSH
57911: CALL_OW 1
57915: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57916: LD_ADDR_EXP 69
57920: PUSH
57921: LD_EXP 69
57925: PPUSH
57926: LD_VAR 0 4
57930: PPUSH
57931: LD_INT 0
57933: PPUSH
57934: CALL_OW 1
57938: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57939: LD_ADDR_EXP 70
57943: PUSH
57944: LD_EXP 70
57948: PPUSH
57949: LD_VAR 0 4
57953: PPUSH
57954: EMPTY
57955: PPUSH
57956: CALL_OW 1
57960: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57961: LD_ADDR_EXP 71
57965: PUSH
57966: LD_EXP 71
57970: PPUSH
57971: LD_VAR 0 4
57975: PPUSH
57976: EMPTY
57977: PPUSH
57978: CALL_OW 1
57982: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57983: LD_ADDR_EXP 72
57987: PUSH
57988: LD_EXP 72
57992: PPUSH
57993: LD_VAR 0 4
57997: PPUSH
57998: EMPTY
57999: PPUSH
58000: CALL_OW 1
58004: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58005: LD_ADDR_EXP 73
58009: PUSH
58010: LD_EXP 73
58014: PPUSH
58015: LD_VAR 0 4
58019: PPUSH
58020: EMPTY
58021: PPUSH
58022: CALL_OW 1
58026: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58027: LD_ADDR_EXP 74
58031: PUSH
58032: LD_EXP 74
58036: PPUSH
58037: LD_VAR 0 4
58041: PPUSH
58042: EMPTY
58043: PPUSH
58044: CALL_OW 1
58048: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58049: LD_ADDR_EXP 75
58053: PUSH
58054: LD_EXP 75
58058: PPUSH
58059: LD_VAR 0 4
58063: PPUSH
58064: EMPTY
58065: PPUSH
58066: CALL_OW 1
58070: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58071: LD_ADDR_EXP 76
58075: PUSH
58076: LD_EXP 76
58080: PPUSH
58081: LD_VAR 0 4
58085: PPUSH
58086: EMPTY
58087: PPUSH
58088: CALL_OW 1
58092: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58093: LD_ADDR_EXP 77
58097: PUSH
58098: LD_EXP 77
58102: PPUSH
58103: LD_VAR 0 4
58107: PPUSH
58108: EMPTY
58109: PPUSH
58110: CALL_OW 1
58114: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58115: LD_ADDR_EXP 78
58119: PUSH
58120: LD_EXP 78
58124: PPUSH
58125: LD_VAR 0 4
58129: PPUSH
58130: EMPTY
58131: PPUSH
58132: CALL_OW 1
58136: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58137: LD_ADDR_EXP 79
58141: PUSH
58142: LD_EXP 79
58146: PPUSH
58147: LD_VAR 0 4
58151: PPUSH
58152: EMPTY
58153: PPUSH
58154: CALL_OW 1
58158: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58159: LD_ADDR_EXP 80
58163: PUSH
58164: LD_EXP 80
58168: PPUSH
58169: LD_VAR 0 4
58173: PPUSH
58174: EMPTY
58175: PPUSH
58176: CALL_OW 1
58180: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58181: LD_ADDR_EXP 81
58185: PUSH
58186: LD_EXP 81
58190: PPUSH
58191: LD_VAR 0 4
58195: PPUSH
58196: EMPTY
58197: PPUSH
58198: CALL_OW 1
58202: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58203: LD_ADDR_EXP 82
58207: PUSH
58208: LD_EXP 82
58212: PPUSH
58213: LD_VAR 0 4
58217: PPUSH
58218: EMPTY
58219: PPUSH
58220: CALL_OW 1
58224: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58225: LD_ADDR_EXP 83
58229: PUSH
58230: LD_EXP 83
58234: PPUSH
58235: LD_VAR 0 4
58239: PPUSH
58240: EMPTY
58241: PPUSH
58242: CALL_OW 1
58246: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58247: LD_ADDR_EXP 85
58251: PUSH
58252: LD_EXP 85
58256: PPUSH
58257: LD_VAR 0 4
58261: PPUSH
58262: EMPTY
58263: PPUSH
58264: CALL_OW 1
58268: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58269: LD_ADDR_EXP 87
58273: PUSH
58274: LD_EXP 87
58278: PPUSH
58279: LD_VAR 0 4
58283: PPUSH
58284: EMPTY
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58291: LD_ADDR_EXP 88
58295: PUSH
58296: LD_EXP 88
58300: PPUSH
58301: LD_VAR 0 4
58305: PPUSH
58306: EMPTY
58307: PPUSH
58308: CALL_OW 1
58312: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58313: LD_ADDR_EXP 89
58317: PUSH
58318: LD_EXP 89
58322: PPUSH
58323: LD_VAR 0 4
58327: PPUSH
58328: EMPTY
58329: PPUSH
58330: CALL_OW 1
58334: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58335: LD_ADDR_EXP 90
58339: PUSH
58340: LD_EXP 90
58344: PPUSH
58345: LD_VAR 0 4
58349: PPUSH
58350: EMPTY
58351: PPUSH
58352: CALL_OW 1
58356: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58357: LD_ADDR_EXP 91
58361: PUSH
58362: LD_EXP 91
58366: PPUSH
58367: LD_VAR 0 4
58371: PPUSH
58372: EMPTY
58373: PPUSH
58374: CALL_OW 1
58378: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58379: LD_ADDR_EXP 92
58383: PUSH
58384: LD_EXP 92
58388: PPUSH
58389: LD_VAR 0 4
58393: PPUSH
58394: EMPTY
58395: PPUSH
58396: CALL_OW 1
58400: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58401: LD_ADDR_EXP 93
58405: PUSH
58406: LD_EXP 93
58410: PPUSH
58411: LD_VAR 0 4
58415: PPUSH
58416: EMPTY
58417: PPUSH
58418: CALL_OW 1
58422: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58423: LD_ADDR_EXP 94
58427: PUSH
58428: LD_EXP 94
58432: PPUSH
58433: LD_VAR 0 4
58437: PPUSH
58438: EMPTY
58439: PPUSH
58440: CALL_OW 1
58444: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58445: LD_ADDR_EXP 95
58449: PUSH
58450: LD_EXP 95
58454: PPUSH
58455: LD_VAR 0 4
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58467: LD_ADDR_EXP 96
58471: PUSH
58472: LD_EXP 96
58476: PPUSH
58477: LD_VAR 0 4
58481: PPUSH
58482: EMPTY
58483: PPUSH
58484: CALL_OW 1
58488: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58489: LD_ADDR_EXP 97
58493: PUSH
58494: LD_EXP 97
58498: PPUSH
58499: LD_VAR 0 4
58503: PPUSH
58504: EMPTY
58505: PPUSH
58506: CALL_OW 1
58510: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58511: LD_ADDR_EXP 98
58515: PUSH
58516: LD_EXP 98
58520: PPUSH
58521: LD_VAR 0 4
58525: PPUSH
58526: EMPTY
58527: PPUSH
58528: CALL_OW 1
58532: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58533: LD_ADDR_EXP 99
58537: PUSH
58538: LD_EXP 99
58542: PPUSH
58543: LD_VAR 0 4
58547: PPUSH
58548: EMPTY
58549: PPUSH
58550: CALL_OW 1
58554: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58555: LD_ADDR_EXP 100
58559: PUSH
58560: LD_EXP 100
58564: PPUSH
58565: LD_VAR 0 4
58569: PPUSH
58570: LD_INT 0
58572: PPUSH
58573: CALL_OW 1
58577: ST_TO_ADDR
// result := base ;
58578: LD_ADDR_VAR 0 3
58582: PUSH
58583: LD_VAR 0 4
58587: ST_TO_ADDR
// end ;
58588: LD_VAR 0 3
58592: RET
// export function MC_Start ( ) ; var i ; begin
58593: LD_INT 0
58595: PPUSH
58596: PPUSH
// for i = 1 to mc_bases do
58597: LD_ADDR_VAR 0 2
58601: PUSH
58602: DOUBLE
58603: LD_INT 1
58605: DEC
58606: ST_TO_ADDR
58607: LD_EXP 58
58611: PUSH
58612: FOR_TO
58613: IFFALSE 59690
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58615: LD_ADDR_EXP 58
58619: PUSH
58620: LD_EXP 58
58624: PPUSH
58625: LD_VAR 0 2
58629: PPUSH
58630: LD_EXP 58
58634: PUSH
58635: LD_VAR 0 2
58639: ARRAY
58640: PUSH
58641: LD_INT 0
58643: DIFF
58644: PPUSH
58645: CALL_OW 1
58649: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58650: LD_ADDR_EXP 59
58654: PUSH
58655: LD_EXP 59
58659: PPUSH
58660: LD_VAR 0 2
58664: PPUSH
58665: EMPTY
58666: PPUSH
58667: CALL_OW 1
58671: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58672: LD_ADDR_EXP 60
58676: PUSH
58677: LD_EXP 60
58681: PPUSH
58682: LD_VAR 0 2
58686: PPUSH
58687: EMPTY
58688: PPUSH
58689: CALL_OW 1
58693: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58694: LD_ADDR_EXP 61
58698: PUSH
58699: LD_EXP 61
58703: PPUSH
58704: LD_VAR 0 2
58708: PPUSH
58709: EMPTY
58710: PPUSH
58711: CALL_OW 1
58715: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58716: LD_ADDR_EXP 62
58720: PUSH
58721: LD_EXP 62
58725: PPUSH
58726: LD_VAR 0 2
58730: PPUSH
58731: EMPTY
58732: PUSH
58733: EMPTY
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: PPUSH
58739: CALL_OW 1
58743: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58744: LD_ADDR_EXP 63
58748: PUSH
58749: LD_EXP 63
58753: PPUSH
58754: LD_VAR 0 2
58758: PPUSH
58759: EMPTY
58760: PPUSH
58761: CALL_OW 1
58765: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58766: LD_ADDR_EXP 90
58770: PUSH
58771: LD_EXP 90
58775: PPUSH
58776: LD_VAR 0 2
58780: PPUSH
58781: EMPTY
58782: PPUSH
58783: CALL_OW 1
58787: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58788: LD_ADDR_EXP 64
58792: PUSH
58793: LD_EXP 64
58797: PPUSH
58798: LD_VAR 0 2
58802: PPUSH
58803: EMPTY
58804: PPUSH
58805: CALL_OW 1
58809: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58810: LD_ADDR_EXP 65
58814: PUSH
58815: LD_EXP 65
58819: PPUSH
58820: LD_VAR 0 2
58824: PPUSH
58825: EMPTY
58826: PPUSH
58827: CALL_OW 1
58831: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58832: LD_ADDR_EXP 66
58836: PUSH
58837: LD_EXP 66
58841: PPUSH
58842: LD_VAR 0 2
58846: PPUSH
58847: LD_EXP 58
58851: PUSH
58852: LD_VAR 0 2
58856: ARRAY
58857: PPUSH
58858: LD_INT 2
58860: PUSH
58861: LD_INT 30
58863: PUSH
58864: LD_INT 32
58866: PUSH
58867: EMPTY
58868: LIST
58869: LIST
58870: PUSH
58871: LD_INT 30
58873: PUSH
58874: LD_INT 33
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PUSH
58881: EMPTY
58882: LIST
58883: LIST
58884: LIST
58885: PPUSH
58886: CALL_OW 72
58890: PPUSH
58891: CALL_OW 1
58895: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58896: LD_ADDR_EXP 67
58900: PUSH
58901: LD_EXP 67
58905: PPUSH
58906: LD_VAR 0 2
58910: PPUSH
58911: LD_EXP 58
58915: PUSH
58916: LD_VAR 0 2
58920: ARRAY
58921: PPUSH
58922: LD_INT 2
58924: PUSH
58925: LD_INT 30
58927: PUSH
58928: LD_INT 32
58930: PUSH
58931: EMPTY
58932: LIST
58933: LIST
58934: PUSH
58935: LD_INT 30
58937: PUSH
58938: LD_INT 31
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: PUSH
58945: EMPTY
58946: LIST
58947: LIST
58948: LIST
58949: PUSH
58950: LD_INT 58
58952: PUSH
58953: EMPTY
58954: LIST
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: PPUSH
58960: CALL_OW 72
58964: PPUSH
58965: CALL_OW 1
58969: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58970: LD_ADDR_EXP 68
58974: PUSH
58975: LD_EXP 68
58979: PPUSH
58980: LD_VAR 0 2
58984: PPUSH
58985: EMPTY
58986: PPUSH
58987: CALL_OW 1
58991: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58992: LD_ADDR_EXP 72
58996: PUSH
58997: LD_EXP 72
59001: PPUSH
59002: LD_VAR 0 2
59006: PPUSH
59007: EMPTY
59008: PPUSH
59009: CALL_OW 1
59013: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59014: LD_ADDR_EXP 71
59018: PUSH
59019: LD_EXP 71
59023: PPUSH
59024: LD_VAR 0 2
59028: PPUSH
59029: EMPTY
59030: PPUSH
59031: CALL_OW 1
59035: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59036: LD_ADDR_EXP 73
59040: PUSH
59041: LD_EXP 73
59045: PPUSH
59046: LD_VAR 0 2
59050: PPUSH
59051: EMPTY
59052: PPUSH
59053: CALL_OW 1
59057: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59058: LD_ADDR_EXP 74
59062: PUSH
59063: LD_EXP 74
59067: PPUSH
59068: LD_VAR 0 2
59072: PPUSH
59073: EMPTY
59074: PPUSH
59075: CALL_OW 1
59079: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59080: LD_ADDR_EXP 75
59084: PUSH
59085: LD_EXP 75
59089: PPUSH
59090: LD_VAR 0 2
59094: PPUSH
59095: EMPTY
59096: PPUSH
59097: CALL_OW 1
59101: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59102: LD_ADDR_EXP 76
59106: PUSH
59107: LD_EXP 76
59111: PPUSH
59112: LD_VAR 0 2
59116: PPUSH
59117: EMPTY
59118: PPUSH
59119: CALL_OW 1
59123: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59124: LD_ADDR_EXP 77
59128: PUSH
59129: LD_EXP 77
59133: PPUSH
59134: LD_VAR 0 2
59138: PPUSH
59139: EMPTY
59140: PPUSH
59141: CALL_OW 1
59145: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59146: LD_ADDR_EXP 78
59150: PUSH
59151: LD_EXP 78
59155: PPUSH
59156: LD_VAR 0 2
59160: PPUSH
59161: EMPTY
59162: PPUSH
59163: CALL_OW 1
59167: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59168: LD_ADDR_EXP 79
59172: PUSH
59173: LD_EXP 79
59177: PPUSH
59178: LD_VAR 0 2
59182: PPUSH
59183: EMPTY
59184: PPUSH
59185: CALL_OW 1
59189: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59190: LD_ADDR_EXP 80
59194: PUSH
59195: LD_EXP 80
59199: PPUSH
59200: LD_VAR 0 2
59204: PPUSH
59205: EMPTY
59206: PPUSH
59207: CALL_OW 1
59211: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59212: LD_ADDR_EXP 69
59216: PUSH
59217: LD_EXP 69
59221: PPUSH
59222: LD_VAR 0 2
59226: PPUSH
59227: LD_INT 0
59229: PPUSH
59230: CALL_OW 1
59234: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59235: LD_ADDR_EXP 82
59239: PUSH
59240: LD_EXP 82
59244: PPUSH
59245: LD_VAR 0 2
59249: PPUSH
59250: LD_INT 0
59252: PPUSH
59253: CALL_OW 1
59257: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59258: LD_ADDR_EXP 70
59262: PUSH
59263: LD_EXP 70
59267: PPUSH
59268: LD_VAR 0 2
59272: PPUSH
59273: EMPTY
59274: PPUSH
59275: CALL_OW 1
59279: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59280: LD_ADDR_EXP 81
59284: PUSH
59285: LD_EXP 81
59289: PPUSH
59290: LD_VAR 0 2
59294: PPUSH
59295: LD_INT 0
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59303: LD_ADDR_EXP 83
59307: PUSH
59308: LD_EXP 83
59312: PPUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: EMPTY
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59325: LD_ADDR_EXP 86
59329: PUSH
59330: LD_EXP 86
59334: PPUSH
59335: LD_VAR 0 2
59339: PPUSH
59340: LD_INT 0
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59348: LD_ADDR_EXP 87
59352: PUSH
59353: LD_EXP 87
59357: PPUSH
59358: LD_VAR 0 2
59362: PPUSH
59363: EMPTY
59364: PPUSH
59365: CALL_OW 1
59369: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59370: LD_ADDR_EXP 88
59374: PUSH
59375: LD_EXP 88
59379: PPUSH
59380: LD_VAR 0 2
59384: PPUSH
59385: EMPTY
59386: PPUSH
59387: CALL_OW 1
59391: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59392: LD_ADDR_EXP 89
59396: PUSH
59397: LD_EXP 89
59401: PPUSH
59402: LD_VAR 0 2
59406: PPUSH
59407: EMPTY
59408: PPUSH
59409: CALL_OW 1
59413: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59414: LD_ADDR_EXP 91
59418: PUSH
59419: LD_EXP 91
59423: PPUSH
59424: LD_VAR 0 2
59428: PPUSH
59429: LD_EXP 58
59433: PUSH
59434: LD_VAR 0 2
59438: ARRAY
59439: PPUSH
59440: LD_INT 2
59442: PUSH
59443: LD_INT 30
59445: PUSH
59446: LD_INT 6
59448: PUSH
59449: EMPTY
59450: LIST
59451: LIST
59452: PUSH
59453: LD_INT 30
59455: PUSH
59456: LD_INT 7
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PUSH
59463: LD_INT 30
59465: PUSH
59466: LD_INT 8
59468: PUSH
59469: EMPTY
59470: LIST
59471: LIST
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: LIST
59477: LIST
59478: PPUSH
59479: CALL_OW 72
59483: PPUSH
59484: CALL_OW 1
59488: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59489: LD_ADDR_EXP 92
59493: PUSH
59494: LD_EXP 92
59498: PPUSH
59499: LD_VAR 0 2
59503: PPUSH
59504: EMPTY
59505: PPUSH
59506: CALL_OW 1
59510: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59511: LD_ADDR_EXP 93
59515: PUSH
59516: LD_EXP 93
59520: PPUSH
59521: LD_VAR 0 2
59525: PPUSH
59526: EMPTY
59527: PPUSH
59528: CALL_OW 1
59532: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59533: LD_ADDR_EXP 94
59537: PUSH
59538: LD_EXP 94
59542: PPUSH
59543: LD_VAR 0 2
59547: PPUSH
59548: EMPTY
59549: PPUSH
59550: CALL_OW 1
59554: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59555: LD_ADDR_EXP 95
59559: PUSH
59560: LD_EXP 95
59564: PPUSH
59565: LD_VAR 0 2
59569: PPUSH
59570: EMPTY
59571: PPUSH
59572: CALL_OW 1
59576: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59577: LD_ADDR_EXP 96
59581: PUSH
59582: LD_EXP 96
59586: PPUSH
59587: LD_VAR 0 2
59591: PPUSH
59592: EMPTY
59593: PPUSH
59594: CALL_OW 1
59598: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59599: LD_ADDR_EXP 97
59603: PUSH
59604: LD_EXP 97
59608: PPUSH
59609: LD_VAR 0 2
59613: PPUSH
59614: EMPTY
59615: PPUSH
59616: CALL_OW 1
59620: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59621: LD_ADDR_EXP 98
59625: PUSH
59626: LD_EXP 98
59630: PPUSH
59631: LD_VAR 0 2
59635: PPUSH
59636: EMPTY
59637: PPUSH
59638: CALL_OW 1
59642: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59643: LD_ADDR_EXP 99
59647: PUSH
59648: LD_EXP 99
59652: PPUSH
59653: LD_VAR 0 2
59657: PPUSH
59658: EMPTY
59659: PPUSH
59660: CALL_OW 1
59664: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59665: LD_ADDR_EXP 100
59669: PUSH
59670: LD_EXP 100
59674: PPUSH
59675: LD_VAR 0 2
59679: PPUSH
59680: LD_INT 0
59682: PPUSH
59683: CALL_OW 1
59687: ST_TO_ADDR
// end ;
59688: GO 58612
59690: POP
59691: POP
// MC_InitSides ( ) ;
59692: CALL 59978 0 0
// MC_InitResearch ( ) ;
59696: CALL 59717 0 0
// CustomInitMacro ( ) ;
59700: CALL 174 0 0
// skirmish := true ;
59704: LD_ADDR_EXP 56
59708: PUSH
59709: LD_INT 1
59711: ST_TO_ADDR
// end ;
59712: LD_VAR 0 1
59716: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59717: LD_INT 0
59719: PPUSH
59720: PPUSH
59721: PPUSH
59722: PPUSH
59723: PPUSH
59724: PPUSH
// if not mc_bases then
59725: LD_EXP 58
59729: NOT
59730: IFFALSE 59734
// exit ;
59732: GO 59973
// for i = 1 to 8 do
59734: LD_ADDR_VAR 0 2
59738: PUSH
59739: DOUBLE
59740: LD_INT 1
59742: DEC
59743: ST_TO_ADDR
59744: LD_INT 8
59746: PUSH
59747: FOR_TO
59748: IFFALSE 59774
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59750: LD_ADDR_EXP 85
59754: PUSH
59755: LD_EXP 85
59759: PPUSH
59760: LD_VAR 0 2
59764: PPUSH
59765: EMPTY
59766: PPUSH
59767: CALL_OW 1
59771: ST_TO_ADDR
59772: GO 59747
59774: POP
59775: POP
// tmp := [ ] ;
59776: LD_ADDR_VAR 0 5
59780: PUSH
59781: EMPTY
59782: ST_TO_ADDR
// for i = 1 to mc_sides do
59783: LD_ADDR_VAR 0 2
59787: PUSH
59788: DOUBLE
59789: LD_INT 1
59791: DEC
59792: ST_TO_ADDR
59793: LD_EXP 84
59797: PUSH
59798: FOR_TO
59799: IFFALSE 59857
// if not mc_sides [ i ] in tmp then
59801: LD_EXP 84
59805: PUSH
59806: LD_VAR 0 2
59810: ARRAY
59811: PUSH
59812: LD_VAR 0 5
59816: IN
59817: NOT
59818: IFFALSE 59855
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59820: LD_ADDR_VAR 0 5
59824: PUSH
59825: LD_VAR 0 5
59829: PPUSH
59830: LD_VAR 0 5
59834: PUSH
59835: LD_INT 1
59837: PLUS
59838: PPUSH
59839: LD_EXP 84
59843: PUSH
59844: LD_VAR 0 2
59848: ARRAY
59849: PPUSH
59850: CALL_OW 2
59854: ST_TO_ADDR
59855: GO 59798
59857: POP
59858: POP
// if not tmp then
59859: LD_VAR 0 5
59863: NOT
59864: IFFALSE 59868
// exit ;
59866: GO 59973
// for j in tmp do
59868: LD_ADDR_VAR 0 3
59872: PUSH
59873: LD_VAR 0 5
59877: PUSH
59878: FOR_IN
59879: IFFALSE 59971
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59881: LD_ADDR_VAR 0 6
59885: PUSH
59886: LD_INT 22
59888: PUSH
59889: LD_VAR 0 3
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 69
59902: ST_TO_ADDR
// if not un then
59903: LD_VAR 0 6
59907: NOT
59908: IFFALSE 59912
// continue ;
59910: GO 59878
// nation := GetNation ( un [ 1 ] ) ;
59912: LD_ADDR_VAR 0 4
59916: PUSH
59917: LD_VAR 0 6
59921: PUSH
59922: LD_INT 1
59924: ARRAY
59925: PPUSH
59926: CALL_OW 248
59930: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59931: LD_ADDR_EXP 85
59935: PUSH
59936: LD_EXP 85
59940: PPUSH
59941: LD_VAR 0 3
59945: PPUSH
59946: LD_VAR 0 3
59950: PPUSH
59951: LD_VAR 0 4
59955: PPUSH
59956: LD_INT 1
59958: PPUSH
59959: CALL 13973 0 3
59963: PPUSH
59964: CALL_OW 1
59968: ST_TO_ADDR
// end ;
59969: GO 59878
59971: POP
59972: POP
// end ;
59973: LD_VAR 0 1
59977: RET
// export function MC_InitSides ( ) ; var i ; begin
59978: LD_INT 0
59980: PPUSH
59981: PPUSH
// if not mc_bases then
59982: LD_EXP 58
59986: NOT
59987: IFFALSE 59991
// exit ;
59989: GO 60065
// for i = 1 to mc_bases do
59991: LD_ADDR_VAR 0 2
59995: PUSH
59996: DOUBLE
59997: LD_INT 1
59999: DEC
60000: ST_TO_ADDR
60001: LD_EXP 58
60005: PUSH
60006: FOR_TO
60007: IFFALSE 60063
// if mc_bases [ i ] then
60009: LD_EXP 58
60013: PUSH
60014: LD_VAR 0 2
60018: ARRAY
60019: IFFALSE 60061
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60021: LD_ADDR_EXP 84
60025: PUSH
60026: LD_EXP 84
60030: PPUSH
60031: LD_VAR 0 2
60035: PPUSH
60036: LD_EXP 58
60040: PUSH
60041: LD_VAR 0 2
60045: ARRAY
60046: PUSH
60047: LD_INT 1
60049: ARRAY
60050: PPUSH
60051: CALL_OW 255
60055: PPUSH
60056: CALL_OW 1
60060: ST_TO_ADDR
60061: GO 60006
60063: POP
60064: POP
// end ;
60065: LD_VAR 0 1
60069: RET
// every 0 0$01 trigger skirmish do
60070: LD_EXP 56
60074: IFFALSE 60228
60076: GO 60078
60078: DISABLE
// begin enable ;
60079: ENABLE
// MC_CheckBuildings ( ) ;
60080: CALL 64717 0 0
// MC_CheckPeopleLife ( ) ;
60084: CALL 64842 0 0
// RaiseSailEvent ( 100 ) ;
60088: LD_INT 100
60090: PPUSH
60091: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60095: LD_INT 103
60097: PPUSH
60098: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60102: LD_INT 104
60104: PPUSH
60105: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60109: LD_INT 105
60111: PPUSH
60112: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60116: LD_INT 106
60118: PPUSH
60119: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60123: LD_INT 107
60125: PPUSH
60126: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60130: LD_INT 108
60132: PPUSH
60133: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60137: LD_INT 109
60139: PPUSH
60140: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60144: LD_INT 110
60146: PPUSH
60147: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60151: LD_INT 111
60153: PPUSH
60154: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60158: LD_INT 112
60160: PPUSH
60161: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60165: LD_INT 113
60167: PPUSH
60168: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60172: LD_INT 120
60174: PPUSH
60175: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60179: LD_INT 121
60181: PPUSH
60182: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60186: LD_INT 122
60188: PPUSH
60189: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60193: LD_INT 123
60195: PPUSH
60196: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60200: LD_INT 124
60202: PPUSH
60203: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60207: LD_INT 125
60209: PPUSH
60210: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60214: LD_INT 126
60216: PPUSH
60217: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60221: LD_INT 200
60223: PPUSH
60224: CALL_OW 427
// end ;
60228: END
// on SailEvent ( event ) do begin if event < 100 then
60229: LD_VAR 0 1
60233: PUSH
60234: LD_INT 100
60236: LESS
60237: IFFALSE 60248
// CustomEvent ( event ) ;
60239: LD_VAR 0 1
60243: PPUSH
60244: CALL 12687 0 1
// if event = 100 then
60248: LD_VAR 0 1
60252: PUSH
60253: LD_INT 100
60255: EQUAL
60256: IFFALSE 60262
// MC_ClassManager ( ) ;
60258: CALL 60654 0 0
// if event = 101 then
60262: LD_VAR 0 1
60266: PUSH
60267: LD_INT 101
60269: EQUAL
60270: IFFALSE 60276
// MC_RepairBuildings ( ) ;
60272: CALL 65438 0 0
// if event = 102 then
60276: LD_VAR 0 1
60280: PUSH
60281: LD_INT 102
60283: EQUAL
60284: IFFALSE 60290
// MC_Heal ( ) ;
60286: CALL 65844 0 0
// if event = 103 then
60290: LD_VAR 0 1
60294: PUSH
60295: LD_INT 103
60297: EQUAL
60298: IFFALSE 60304
// MC_Build ( ) ;
60300: CALL 66266 0 0
// if event = 104 then
60304: LD_VAR 0 1
60308: PUSH
60309: LD_INT 104
60311: EQUAL
60312: IFFALSE 60318
// MC_TurretWeapon ( ) ;
60314: CALL 67879 0 0
// if event = 105 then
60318: LD_VAR 0 1
60322: PUSH
60323: LD_INT 105
60325: EQUAL
60326: IFFALSE 60332
// MC_BuildUpgrade ( ) ;
60328: CALL 67430 0 0
// if event = 106 then
60332: LD_VAR 0 1
60336: PUSH
60337: LD_INT 106
60339: EQUAL
60340: IFFALSE 60346
// MC_PlantMines ( ) ;
60342: CALL 68309 0 0
// if event = 107 then
60346: LD_VAR 0 1
60350: PUSH
60351: LD_INT 107
60353: EQUAL
60354: IFFALSE 60360
// MC_CollectCrates ( ) ;
60356: CALL 69343 0 0
// if event = 108 then
60360: LD_VAR 0 1
60364: PUSH
60365: LD_INT 108
60367: EQUAL
60368: IFFALSE 60374
// MC_LinkRemoteControl ( ) ;
60370: CALL 71100 0 0
// if event = 109 then
60374: LD_VAR 0 1
60378: PUSH
60379: LD_INT 109
60381: EQUAL
60382: IFFALSE 60388
// MC_ProduceVehicle ( ) ;
60384: CALL 71281 0 0
// if event = 110 then
60388: LD_VAR 0 1
60392: PUSH
60393: LD_INT 110
60395: EQUAL
60396: IFFALSE 60402
// MC_SendAttack ( ) ;
60398: CALL 71762 0 0
// if event = 111 then
60402: LD_VAR 0 1
60406: PUSH
60407: LD_INT 111
60409: EQUAL
60410: IFFALSE 60416
// MC_Defend ( ) ;
60412: CALL 71870 0 0
// if event = 112 then
60416: LD_VAR 0 1
60420: PUSH
60421: LD_INT 112
60423: EQUAL
60424: IFFALSE 60430
// MC_Research ( ) ;
60426: CALL 72497 0 0
// if event = 113 then
60430: LD_VAR 0 1
60434: PUSH
60435: LD_INT 113
60437: EQUAL
60438: IFFALSE 60444
// MC_MinesTrigger ( ) ;
60440: CALL 73611 0 0
// if event = 120 then
60444: LD_VAR 0 1
60448: PUSH
60449: LD_INT 120
60451: EQUAL
60452: IFFALSE 60458
// MC_RepairVehicle ( ) ;
60454: CALL 73710 0 0
// if event = 121 then
60458: LD_VAR 0 1
60462: PUSH
60463: LD_INT 121
60465: EQUAL
60466: IFFALSE 60472
// MC_TameApe ( ) ;
60468: CALL 74453 0 0
// if event = 122 then
60472: LD_VAR 0 1
60476: PUSH
60477: LD_INT 122
60479: EQUAL
60480: IFFALSE 60486
// MC_ChangeApeClass ( ) ;
60482: CALL 75282 0 0
// if event = 123 then
60486: LD_VAR 0 1
60490: PUSH
60491: LD_INT 123
60493: EQUAL
60494: IFFALSE 60500
// MC_Bazooka ( ) ;
60496: CALL 75932 0 0
// if event = 124 then
60500: LD_VAR 0 1
60504: PUSH
60505: LD_INT 124
60507: EQUAL
60508: IFFALSE 60514
// MC_TeleportExit ( ) ;
60510: CALL 76130 0 0
// if event = 125 then
60514: LD_VAR 0 1
60518: PUSH
60519: LD_INT 125
60521: EQUAL
60522: IFFALSE 60528
// MC_Deposits ( ) ;
60524: CALL 76777 0 0
// if event = 126 then
60528: LD_VAR 0 1
60532: PUSH
60533: LD_INT 126
60535: EQUAL
60536: IFFALSE 60542
// MC_RemoteDriver ( ) ;
60538: CALL 77402 0 0
// if event = 200 then
60542: LD_VAR 0 1
60546: PUSH
60547: LD_INT 200
60549: EQUAL
60550: IFFALSE 60556
// MC_Idle ( ) ;
60552: CALL 79135 0 0
// end ;
60556: PPOPN 1
60558: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60559: LD_INT 0
60561: PPUSH
60562: PPUSH
// if not mc_bases [ base ] or not tag then
60563: LD_EXP 58
60567: PUSH
60568: LD_VAR 0 1
60572: ARRAY
60573: NOT
60574: PUSH
60575: LD_VAR 0 2
60579: NOT
60580: OR
60581: IFFALSE 60585
// exit ;
60583: GO 60649
// for i in mc_bases [ base ] union mc_ape [ base ] do
60585: LD_ADDR_VAR 0 4
60589: PUSH
60590: LD_EXP 58
60594: PUSH
60595: LD_VAR 0 1
60599: ARRAY
60600: PUSH
60601: LD_EXP 87
60605: PUSH
60606: LD_VAR 0 1
60610: ARRAY
60611: UNION
60612: PUSH
60613: FOR_IN
60614: IFFALSE 60647
// if GetTag ( i ) = tag then
60616: LD_VAR 0 4
60620: PPUSH
60621: CALL_OW 110
60625: PUSH
60626: LD_VAR 0 2
60630: EQUAL
60631: IFFALSE 60645
// SetTag ( i , 0 ) ;
60633: LD_VAR 0 4
60637: PPUSH
60638: LD_INT 0
60640: PPUSH
60641: CALL_OW 109
60645: GO 60613
60647: POP
60648: POP
// end ;
60649: LD_VAR 0 3
60653: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60654: LD_INT 0
60656: PPUSH
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
60661: PPUSH
60662: PPUSH
60663: PPUSH
// if not mc_bases then
60664: LD_EXP 58
60668: NOT
60669: IFFALSE 60673
// exit ;
60671: GO 61131
// for i = 1 to mc_bases do
60673: LD_ADDR_VAR 0 2
60677: PUSH
60678: DOUBLE
60679: LD_INT 1
60681: DEC
60682: ST_TO_ADDR
60683: LD_EXP 58
60687: PUSH
60688: FOR_TO
60689: IFFALSE 61129
// begin tmp := MC_ClassCheckReq ( i ) ;
60691: LD_ADDR_VAR 0 4
60695: PUSH
60696: LD_VAR 0 2
60700: PPUSH
60701: CALL 61136 0 1
60705: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60706: LD_ADDR_EXP 99
60710: PUSH
60711: LD_EXP 99
60715: PPUSH
60716: LD_VAR 0 2
60720: PPUSH
60721: LD_VAR 0 4
60725: PPUSH
60726: CALL_OW 1
60730: ST_TO_ADDR
// if not tmp then
60731: LD_VAR 0 4
60735: NOT
60736: IFFALSE 60740
// continue ;
60738: GO 60688
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60740: LD_ADDR_VAR 0 6
60744: PUSH
60745: LD_EXP 58
60749: PUSH
60750: LD_VAR 0 2
60754: ARRAY
60755: PPUSH
60756: LD_INT 2
60758: PUSH
60759: LD_INT 30
60761: PUSH
60762: LD_INT 4
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 30
60771: PUSH
60772: LD_INT 5
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: LIST
60783: PPUSH
60784: CALL_OW 72
60788: PUSH
60789: LD_EXP 58
60793: PUSH
60794: LD_VAR 0 2
60798: ARRAY
60799: PPUSH
60800: LD_INT 2
60802: PUSH
60803: LD_INT 30
60805: PUSH
60806: LD_INT 0
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: PUSH
60813: LD_INT 30
60815: PUSH
60816: LD_INT 1
60818: PUSH
60819: EMPTY
60820: LIST
60821: LIST
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: LIST
60827: PPUSH
60828: CALL_OW 72
60832: PUSH
60833: LD_EXP 58
60837: PUSH
60838: LD_VAR 0 2
60842: ARRAY
60843: PPUSH
60844: LD_INT 30
60846: PUSH
60847: LD_INT 3
60849: PUSH
60850: EMPTY
60851: LIST
60852: LIST
60853: PPUSH
60854: CALL_OW 72
60858: PUSH
60859: LD_EXP 58
60863: PUSH
60864: LD_VAR 0 2
60868: ARRAY
60869: PPUSH
60870: LD_INT 2
60872: PUSH
60873: LD_INT 30
60875: PUSH
60876: LD_INT 6
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PUSH
60883: LD_INT 30
60885: PUSH
60886: LD_INT 7
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: PUSH
60893: LD_INT 30
60895: PUSH
60896: LD_INT 8
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: PPUSH
60909: CALL_OW 72
60913: PUSH
60914: EMPTY
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: ST_TO_ADDR
// for j = 1 to 4 do
60920: LD_ADDR_VAR 0 3
60924: PUSH
60925: DOUBLE
60926: LD_INT 1
60928: DEC
60929: ST_TO_ADDR
60930: LD_INT 4
60932: PUSH
60933: FOR_TO
60934: IFFALSE 61125
// begin if not tmp [ j ] then
60936: LD_VAR 0 4
60940: PUSH
60941: LD_VAR 0 3
60945: ARRAY
60946: NOT
60947: IFFALSE 60951
// continue ;
60949: GO 60933
// for p in tmp [ j ] do
60951: LD_ADDR_VAR 0 5
60955: PUSH
60956: LD_VAR 0 4
60960: PUSH
60961: LD_VAR 0 3
60965: ARRAY
60966: PUSH
60967: FOR_IN
60968: IFFALSE 61121
// begin if not b [ j ] then
60970: LD_VAR 0 6
60974: PUSH
60975: LD_VAR 0 3
60979: ARRAY
60980: NOT
60981: IFFALSE 60985
// break ;
60983: GO 61121
// e := 0 ;
60985: LD_ADDR_VAR 0 7
60989: PUSH
60990: LD_INT 0
60992: ST_TO_ADDR
// for k in b [ j ] do
60993: LD_ADDR_VAR 0 8
60997: PUSH
60998: LD_VAR 0 6
61002: PUSH
61003: LD_VAR 0 3
61007: ARRAY
61008: PUSH
61009: FOR_IN
61010: IFFALSE 61037
// if IsNotFull ( k ) then
61012: LD_VAR 0 8
61016: PPUSH
61017: CALL 17999 0 1
61021: IFFALSE 61035
// begin e := k ;
61023: LD_ADDR_VAR 0 7
61027: PUSH
61028: LD_VAR 0 8
61032: ST_TO_ADDR
// break ;
61033: GO 61037
// end ;
61035: GO 61009
61037: POP
61038: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61039: LD_VAR 0 7
61043: PUSH
61044: LD_VAR 0 5
61048: PPUSH
61049: LD_VAR 0 7
61053: PPUSH
61054: CALL 55026 0 2
61058: NOT
61059: AND
61060: IFFALSE 61119
// begin if IsInUnit ( p ) then
61062: LD_VAR 0 5
61066: PPUSH
61067: CALL_OW 310
61071: IFFALSE 61082
// ComExitBuilding ( p ) ;
61073: LD_VAR 0 5
61077: PPUSH
61078: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61082: LD_VAR 0 5
61086: PPUSH
61087: LD_VAR 0 7
61091: PPUSH
61092: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61096: LD_VAR 0 5
61100: PPUSH
61101: LD_VAR 0 3
61105: PPUSH
61106: CALL_OW 183
// AddComExitBuilding ( p ) ;
61110: LD_VAR 0 5
61114: PPUSH
61115: CALL_OW 182
// end ; end ;
61119: GO 60967
61121: POP
61122: POP
// end ;
61123: GO 60933
61125: POP
61126: POP
// end ;
61127: GO 60688
61129: POP
61130: POP
// end ;
61131: LD_VAR 0 1
61135: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61136: LD_INT 0
61138: PPUSH
61139: PPUSH
61140: PPUSH
61141: PPUSH
61142: PPUSH
61143: PPUSH
61144: PPUSH
61145: PPUSH
61146: PPUSH
61147: PPUSH
61148: PPUSH
61149: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61150: LD_VAR 0 1
61154: NOT
61155: PUSH
61156: LD_EXP 58
61160: PUSH
61161: LD_VAR 0 1
61165: ARRAY
61166: NOT
61167: OR
61168: PUSH
61169: LD_EXP 58
61173: PUSH
61174: LD_VAR 0 1
61178: ARRAY
61179: PPUSH
61180: LD_INT 2
61182: PUSH
61183: LD_INT 30
61185: PUSH
61186: LD_INT 0
61188: PUSH
61189: EMPTY
61190: LIST
61191: LIST
61192: PUSH
61193: LD_INT 30
61195: PUSH
61196: LD_INT 1
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: LIST
61207: PPUSH
61208: CALL_OW 72
61212: NOT
61213: OR
61214: IFFALSE 61218
// exit ;
61216: GO 64712
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61218: LD_ADDR_VAR 0 4
61222: PUSH
61223: LD_EXP 58
61227: PUSH
61228: LD_VAR 0 1
61232: ARRAY
61233: PPUSH
61234: LD_INT 2
61236: PUSH
61237: LD_INT 25
61239: PUSH
61240: LD_INT 1
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PUSH
61247: LD_INT 25
61249: PUSH
61250: LD_INT 2
61252: PUSH
61253: EMPTY
61254: LIST
61255: LIST
61256: PUSH
61257: LD_INT 25
61259: PUSH
61260: LD_INT 3
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: PUSH
61267: LD_INT 25
61269: PUSH
61270: LD_INT 4
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_INT 25
61279: PUSH
61280: LD_INT 5
61282: PUSH
61283: EMPTY
61284: LIST
61285: LIST
61286: PUSH
61287: LD_INT 25
61289: PUSH
61290: LD_INT 8
61292: PUSH
61293: EMPTY
61294: LIST
61295: LIST
61296: PUSH
61297: LD_INT 25
61299: PUSH
61300: LD_INT 9
61302: PUSH
61303: EMPTY
61304: LIST
61305: LIST
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: PPUSH
61317: CALL_OW 72
61321: ST_TO_ADDR
// for i in tmp do
61322: LD_ADDR_VAR 0 3
61326: PUSH
61327: LD_VAR 0 4
61331: PUSH
61332: FOR_IN
61333: IFFALSE 61364
// if GetTag ( i ) then
61335: LD_VAR 0 3
61339: PPUSH
61340: CALL_OW 110
61344: IFFALSE 61362
// tmp := tmp diff i ;
61346: LD_ADDR_VAR 0 4
61350: PUSH
61351: LD_VAR 0 4
61355: PUSH
61356: LD_VAR 0 3
61360: DIFF
61361: ST_TO_ADDR
61362: GO 61332
61364: POP
61365: POP
// if not tmp then
61366: LD_VAR 0 4
61370: NOT
61371: IFFALSE 61375
// exit ;
61373: GO 64712
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61375: LD_ADDR_VAR 0 5
61379: PUSH
61380: LD_EXP 58
61384: PUSH
61385: LD_VAR 0 1
61389: ARRAY
61390: PPUSH
61391: LD_INT 2
61393: PUSH
61394: LD_INT 25
61396: PUSH
61397: LD_INT 1
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 25
61406: PUSH
61407: LD_INT 5
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 25
61416: PUSH
61417: LD_INT 8
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 25
61426: PUSH
61427: LD_INT 9
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: PPUSH
61441: CALL_OW 72
61445: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61446: LD_ADDR_VAR 0 6
61450: PUSH
61451: LD_EXP 58
61455: PUSH
61456: LD_VAR 0 1
61460: ARRAY
61461: PPUSH
61462: LD_INT 25
61464: PUSH
61465: LD_INT 2
61467: PUSH
61468: EMPTY
61469: LIST
61470: LIST
61471: PPUSH
61472: CALL_OW 72
61476: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61477: LD_ADDR_VAR 0 7
61481: PUSH
61482: LD_EXP 58
61486: PUSH
61487: LD_VAR 0 1
61491: ARRAY
61492: PPUSH
61493: LD_INT 25
61495: PUSH
61496: LD_INT 3
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: PPUSH
61503: CALL_OW 72
61507: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61508: LD_ADDR_VAR 0 8
61512: PUSH
61513: LD_EXP 58
61517: PUSH
61518: LD_VAR 0 1
61522: ARRAY
61523: PPUSH
61524: LD_INT 25
61526: PUSH
61527: LD_INT 4
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: PUSH
61534: LD_INT 24
61536: PUSH
61537: LD_INT 251
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PPUSH
61548: CALL_OW 72
61552: ST_TO_ADDR
// if mc_scan [ base ] then
61553: LD_EXP 81
61557: PUSH
61558: LD_VAR 0 1
61562: ARRAY
61563: IFFALSE 62024
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61565: LD_ADDR_EXP 100
61569: PUSH
61570: LD_EXP 100
61574: PPUSH
61575: LD_VAR 0 1
61579: PPUSH
61580: LD_INT 4
61582: PPUSH
61583: CALL_OW 1
61587: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61588: LD_ADDR_VAR 0 12
61592: PUSH
61593: LD_EXP 58
61597: PUSH
61598: LD_VAR 0 1
61602: ARRAY
61603: PPUSH
61604: LD_INT 2
61606: PUSH
61607: LD_INT 30
61609: PUSH
61610: LD_INT 4
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: PUSH
61617: LD_INT 30
61619: PUSH
61620: LD_INT 5
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: LIST
61631: PPUSH
61632: CALL_OW 72
61636: ST_TO_ADDR
// if not b then
61637: LD_VAR 0 12
61641: NOT
61642: IFFALSE 61646
// exit ;
61644: GO 64712
// p := [ ] ;
61646: LD_ADDR_VAR 0 11
61650: PUSH
61651: EMPTY
61652: ST_TO_ADDR
// if sci >= 2 then
61653: LD_VAR 0 8
61657: PUSH
61658: LD_INT 2
61660: GREATEREQUAL
61661: IFFALSE 61692
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61663: LD_ADDR_VAR 0 8
61667: PUSH
61668: LD_VAR 0 8
61672: PUSH
61673: LD_INT 1
61675: ARRAY
61676: PUSH
61677: LD_VAR 0 8
61681: PUSH
61682: LD_INT 2
61684: ARRAY
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: ST_TO_ADDR
61690: GO 61753
// if sci = 1 then
61692: LD_VAR 0 8
61696: PUSH
61697: LD_INT 1
61699: EQUAL
61700: IFFALSE 61721
// sci := [ sci [ 1 ] ] else
61702: LD_ADDR_VAR 0 8
61706: PUSH
61707: LD_VAR 0 8
61711: PUSH
61712: LD_INT 1
61714: ARRAY
61715: PUSH
61716: EMPTY
61717: LIST
61718: ST_TO_ADDR
61719: GO 61753
// if sci = 0 then
61721: LD_VAR 0 8
61725: PUSH
61726: LD_INT 0
61728: EQUAL
61729: IFFALSE 61753
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61731: LD_ADDR_VAR 0 11
61735: PUSH
61736: LD_VAR 0 4
61740: PPUSH
61741: LD_INT 4
61743: PPUSH
61744: CALL 54889 0 2
61748: PUSH
61749: LD_INT 1
61751: ARRAY
61752: ST_TO_ADDR
// if eng > 4 then
61753: LD_VAR 0 6
61757: PUSH
61758: LD_INT 4
61760: GREATER
61761: IFFALSE 61807
// for i = eng downto 4 do
61763: LD_ADDR_VAR 0 3
61767: PUSH
61768: DOUBLE
61769: LD_VAR 0 6
61773: INC
61774: ST_TO_ADDR
61775: LD_INT 4
61777: PUSH
61778: FOR_DOWNTO
61779: IFFALSE 61805
// eng := eng diff eng [ i ] ;
61781: LD_ADDR_VAR 0 6
61785: PUSH
61786: LD_VAR 0 6
61790: PUSH
61791: LD_VAR 0 6
61795: PUSH
61796: LD_VAR 0 3
61800: ARRAY
61801: DIFF
61802: ST_TO_ADDR
61803: GO 61778
61805: POP
61806: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61807: LD_ADDR_VAR 0 4
61811: PUSH
61812: LD_VAR 0 4
61816: PUSH
61817: LD_VAR 0 5
61821: PUSH
61822: LD_VAR 0 6
61826: UNION
61827: PUSH
61828: LD_VAR 0 7
61832: UNION
61833: PUSH
61834: LD_VAR 0 8
61838: UNION
61839: DIFF
61840: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61841: LD_ADDR_VAR 0 13
61845: PUSH
61846: LD_EXP 58
61850: PUSH
61851: LD_VAR 0 1
61855: ARRAY
61856: PPUSH
61857: LD_INT 2
61859: PUSH
61860: LD_INT 30
61862: PUSH
61863: LD_INT 32
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: LD_INT 30
61872: PUSH
61873: LD_INT 31
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: LIST
61884: PPUSH
61885: CALL_OW 72
61889: PUSH
61890: LD_EXP 58
61894: PUSH
61895: LD_VAR 0 1
61899: ARRAY
61900: PPUSH
61901: LD_INT 2
61903: PUSH
61904: LD_INT 30
61906: PUSH
61907: LD_INT 4
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: PUSH
61914: LD_INT 30
61916: PUSH
61917: LD_INT 5
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: LIST
61928: PPUSH
61929: CALL_OW 72
61933: PUSH
61934: LD_INT 6
61936: MUL
61937: PLUS
61938: ST_TO_ADDR
// if bcount < tmp then
61939: LD_VAR 0 13
61943: PUSH
61944: LD_VAR 0 4
61948: LESS
61949: IFFALSE 61995
// for i = tmp downto bcount do
61951: LD_ADDR_VAR 0 3
61955: PUSH
61956: DOUBLE
61957: LD_VAR 0 4
61961: INC
61962: ST_TO_ADDR
61963: LD_VAR 0 13
61967: PUSH
61968: FOR_DOWNTO
61969: IFFALSE 61993
// tmp := Delete ( tmp , tmp ) ;
61971: LD_ADDR_VAR 0 4
61975: PUSH
61976: LD_VAR 0 4
61980: PPUSH
61981: LD_VAR 0 4
61985: PPUSH
61986: CALL_OW 3
61990: ST_TO_ADDR
61991: GO 61968
61993: POP
61994: POP
// result := [ tmp , 0 , 0 , p ] ;
61995: LD_ADDR_VAR 0 2
61999: PUSH
62000: LD_VAR 0 4
62004: PUSH
62005: LD_INT 0
62007: PUSH
62008: LD_INT 0
62010: PUSH
62011: LD_VAR 0 11
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: LIST
62020: LIST
62021: ST_TO_ADDR
// exit ;
62022: GO 64712
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62024: LD_EXP 58
62028: PUSH
62029: LD_VAR 0 1
62033: ARRAY
62034: PPUSH
62035: LD_INT 2
62037: PUSH
62038: LD_INT 30
62040: PUSH
62041: LD_INT 6
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 30
62050: PUSH
62051: LD_INT 7
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 30
62060: PUSH
62061: LD_INT 8
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: EMPTY
62069: LIST
62070: LIST
62071: LIST
62072: LIST
62073: PPUSH
62074: CALL_OW 72
62078: NOT
62079: PUSH
62080: LD_EXP 58
62084: PUSH
62085: LD_VAR 0 1
62089: ARRAY
62090: PPUSH
62091: LD_INT 30
62093: PUSH
62094: LD_INT 3
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PPUSH
62101: CALL_OW 72
62105: NOT
62106: AND
62107: IFFALSE 62179
// begin if eng = tmp then
62109: LD_VAR 0 6
62113: PUSH
62114: LD_VAR 0 4
62118: EQUAL
62119: IFFALSE 62123
// exit ;
62121: GO 64712
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62123: LD_ADDR_EXP 100
62127: PUSH
62128: LD_EXP 100
62132: PPUSH
62133: LD_VAR 0 1
62137: PPUSH
62138: LD_INT 1
62140: PPUSH
62141: CALL_OW 1
62145: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62146: LD_ADDR_VAR 0 2
62150: PUSH
62151: LD_INT 0
62153: PUSH
62154: LD_VAR 0 4
62158: PUSH
62159: LD_VAR 0 6
62163: DIFF
62164: PUSH
62165: LD_INT 0
62167: PUSH
62168: LD_INT 0
62170: PUSH
62171: EMPTY
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: ST_TO_ADDR
// exit ;
62177: GO 64712
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62179: LD_EXP 85
62183: PUSH
62184: LD_EXP 84
62188: PUSH
62189: LD_VAR 0 1
62193: ARRAY
62194: ARRAY
62195: PUSH
62196: LD_EXP 58
62200: PUSH
62201: LD_VAR 0 1
62205: ARRAY
62206: PPUSH
62207: LD_INT 2
62209: PUSH
62210: LD_INT 30
62212: PUSH
62213: LD_INT 6
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: PUSH
62220: LD_INT 30
62222: PUSH
62223: LD_INT 7
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PUSH
62230: LD_INT 30
62232: PUSH
62233: LD_INT 8
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: EMPTY
62241: LIST
62242: LIST
62243: LIST
62244: LIST
62245: PPUSH
62246: CALL_OW 72
62250: AND
62251: PUSH
62252: LD_EXP 58
62256: PUSH
62257: LD_VAR 0 1
62261: ARRAY
62262: PPUSH
62263: LD_INT 30
62265: PUSH
62266: LD_INT 3
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: PPUSH
62273: CALL_OW 72
62277: NOT
62278: AND
62279: IFFALSE 62493
// begin if sci >= 6 then
62281: LD_VAR 0 8
62285: PUSH
62286: LD_INT 6
62288: GREATEREQUAL
62289: IFFALSE 62293
// exit ;
62291: GO 64712
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62293: LD_ADDR_EXP 100
62297: PUSH
62298: LD_EXP 100
62302: PPUSH
62303: LD_VAR 0 1
62307: PPUSH
62308: LD_INT 2
62310: PPUSH
62311: CALL_OW 1
62315: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62316: LD_ADDR_VAR 0 9
62320: PUSH
62321: LD_VAR 0 4
62325: PUSH
62326: LD_VAR 0 8
62330: DIFF
62331: PPUSH
62332: LD_INT 4
62334: PPUSH
62335: CALL 54889 0 2
62339: ST_TO_ADDR
// p := [ ] ;
62340: LD_ADDR_VAR 0 11
62344: PUSH
62345: EMPTY
62346: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62347: LD_VAR 0 8
62351: PUSH
62352: LD_INT 6
62354: LESS
62355: PUSH
62356: LD_VAR 0 9
62360: PUSH
62361: LD_INT 6
62363: GREATER
62364: AND
62365: IFFALSE 62446
// begin for i = 1 to 6 - sci do
62367: LD_ADDR_VAR 0 3
62371: PUSH
62372: DOUBLE
62373: LD_INT 1
62375: DEC
62376: ST_TO_ADDR
62377: LD_INT 6
62379: PUSH
62380: LD_VAR 0 8
62384: MINUS
62385: PUSH
62386: FOR_TO
62387: IFFALSE 62442
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62389: LD_ADDR_VAR 0 11
62393: PUSH
62394: LD_VAR 0 11
62398: PPUSH
62399: LD_VAR 0 11
62403: PUSH
62404: LD_INT 1
62406: PLUS
62407: PPUSH
62408: LD_VAR 0 9
62412: PUSH
62413: LD_INT 1
62415: ARRAY
62416: PPUSH
62417: CALL_OW 2
62421: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62422: LD_ADDR_VAR 0 9
62426: PUSH
62427: LD_VAR 0 9
62431: PPUSH
62432: LD_INT 1
62434: PPUSH
62435: CALL_OW 3
62439: ST_TO_ADDR
// end ;
62440: GO 62386
62442: POP
62443: POP
// end else
62444: GO 62466
// if sort then
62446: LD_VAR 0 9
62450: IFFALSE 62466
// p := sort [ 1 ] ;
62452: LD_ADDR_VAR 0 11
62456: PUSH
62457: LD_VAR 0 9
62461: PUSH
62462: LD_INT 1
62464: ARRAY
62465: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62466: LD_ADDR_VAR 0 2
62470: PUSH
62471: LD_INT 0
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: LD_INT 0
62479: PUSH
62480: LD_VAR 0 11
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: LIST
62489: LIST
62490: ST_TO_ADDR
// exit ;
62491: GO 64712
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62493: LD_EXP 85
62497: PUSH
62498: LD_EXP 84
62502: PUSH
62503: LD_VAR 0 1
62507: ARRAY
62508: ARRAY
62509: PUSH
62510: LD_EXP 58
62514: PUSH
62515: LD_VAR 0 1
62519: ARRAY
62520: PPUSH
62521: LD_INT 2
62523: PUSH
62524: LD_INT 30
62526: PUSH
62527: LD_INT 6
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PUSH
62534: LD_INT 30
62536: PUSH
62537: LD_INT 7
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 30
62546: PUSH
62547: LD_INT 8
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: LIST
62558: LIST
62559: PPUSH
62560: CALL_OW 72
62564: AND
62565: PUSH
62566: LD_EXP 58
62570: PUSH
62571: LD_VAR 0 1
62575: ARRAY
62576: PPUSH
62577: LD_INT 30
62579: PUSH
62580: LD_INT 3
62582: PUSH
62583: EMPTY
62584: LIST
62585: LIST
62586: PPUSH
62587: CALL_OW 72
62591: AND
62592: IFFALSE 63326
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62594: LD_ADDR_EXP 100
62598: PUSH
62599: LD_EXP 100
62603: PPUSH
62604: LD_VAR 0 1
62608: PPUSH
62609: LD_INT 3
62611: PPUSH
62612: CALL_OW 1
62616: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62617: LD_ADDR_VAR 0 2
62621: PUSH
62622: LD_INT 0
62624: PUSH
62625: LD_INT 0
62627: PUSH
62628: LD_INT 0
62630: PUSH
62631: LD_INT 0
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: ST_TO_ADDR
// if not eng then
62640: LD_VAR 0 6
62644: NOT
62645: IFFALSE 62708
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62647: LD_ADDR_VAR 0 11
62651: PUSH
62652: LD_VAR 0 4
62656: PPUSH
62657: LD_INT 2
62659: PPUSH
62660: CALL 54889 0 2
62664: PUSH
62665: LD_INT 1
62667: ARRAY
62668: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62669: LD_ADDR_VAR 0 2
62673: PUSH
62674: LD_VAR 0 2
62678: PPUSH
62679: LD_INT 2
62681: PPUSH
62682: LD_VAR 0 11
62686: PPUSH
62687: CALL_OW 1
62691: ST_TO_ADDR
// tmp := tmp diff p ;
62692: LD_ADDR_VAR 0 4
62696: PUSH
62697: LD_VAR 0 4
62701: PUSH
62702: LD_VAR 0 11
62706: DIFF
62707: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62708: LD_VAR 0 4
62712: PUSH
62713: LD_VAR 0 8
62717: PUSH
62718: LD_INT 6
62720: LESS
62721: AND
62722: IFFALSE 62910
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62724: LD_ADDR_VAR 0 9
62728: PUSH
62729: LD_VAR 0 4
62733: PUSH
62734: LD_VAR 0 8
62738: PUSH
62739: LD_VAR 0 7
62743: UNION
62744: DIFF
62745: PPUSH
62746: LD_INT 4
62748: PPUSH
62749: CALL 54889 0 2
62753: ST_TO_ADDR
// p := [ ] ;
62754: LD_ADDR_VAR 0 11
62758: PUSH
62759: EMPTY
62760: ST_TO_ADDR
// if sort then
62761: LD_VAR 0 9
62765: IFFALSE 62881
// for i = 1 to 6 - sci do
62767: LD_ADDR_VAR 0 3
62771: PUSH
62772: DOUBLE
62773: LD_INT 1
62775: DEC
62776: ST_TO_ADDR
62777: LD_INT 6
62779: PUSH
62780: LD_VAR 0 8
62784: MINUS
62785: PUSH
62786: FOR_TO
62787: IFFALSE 62879
// begin if i = sort then
62789: LD_VAR 0 3
62793: PUSH
62794: LD_VAR 0 9
62798: EQUAL
62799: IFFALSE 62803
// break ;
62801: GO 62879
// if GetClass ( i ) = 4 then
62803: LD_VAR 0 3
62807: PPUSH
62808: CALL_OW 257
62812: PUSH
62813: LD_INT 4
62815: EQUAL
62816: IFFALSE 62820
// continue ;
62818: GO 62786
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62820: LD_ADDR_VAR 0 11
62824: PUSH
62825: LD_VAR 0 11
62829: PPUSH
62830: LD_VAR 0 11
62834: PUSH
62835: LD_INT 1
62837: PLUS
62838: PPUSH
62839: LD_VAR 0 9
62843: PUSH
62844: LD_VAR 0 3
62848: ARRAY
62849: PPUSH
62850: CALL_OW 2
62854: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62855: LD_ADDR_VAR 0 4
62859: PUSH
62860: LD_VAR 0 4
62864: PUSH
62865: LD_VAR 0 9
62869: PUSH
62870: LD_VAR 0 3
62874: ARRAY
62875: DIFF
62876: ST_TO_ADDR
// end ;
62877: GO 62786
62879: POP
62880: POP
// if p then
62881: LD_VAR 0 11
62885: IFFALSE 62910
// result := Replace ( result , 4 , p ) ;
62887: LD_ADDR_VAR 0 2
62891: PUSH
62892: LD_VAR 0 2
62896: PPUSH
62897: LD_INT 4
62899: PPUSH
62900: LD_VAR 0 11
62904: PPUSH
62905: CALL_OW 1
62909: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62910: LD_VAR 0 4
62914: PUSH
62915: LD_VAR 0 7
62919: PUSH
62920: LD_INT 6
62922: LESS
62923: AND
62924: IFFALSE 63112
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62926: LD_ADDR_VAR 0 9
62930: PUSH
62931: LD_VAR 0 4
62935: PUSH
62936: LD_VAR 0 8
62940: PUSH
62941: LD_VAR 0 7
62945: UNION
62946: DIFF
62947: PPUSH
62948: LD_INT 3
62950: PPUSH
62951: CALL 54889 0 2
62955: ST_TO_ADDR
// p := [ ] ;
62956: LD_ADDR_VAR 0 11
62960: PUSH
62961: EMPTY
62962: ST_TO_ADDR
// if sort then
62963: LD_VAR 0 9
62967: IFFALSE 63083
// for i = 1 to 6 - mech do
62969: LD_ADDR_VAR 0 3
62973: PUSH
62974: DOUBLE
62975: LD_INT 1
62977: DEC
62978: ST_TO_ADDR
62979: LD_INT 6
62981: PUSH
62982: LD_VAR 0 7
62986: MINUS
62987: PUSH
62988: FOR_TO
62989: IFFALSE 63081
// begin if i = sort then
62991: LD_VAR 0 3
62995: PUSH
62996: LD_VAR 0 9
63000: EQUAL
63001: IFFALSE 63005
// break ;
63003: GO 63081
// if GetClass ( i ) = 3 then
63005: LD_VAR 0 3
63009: PPUSH
63010: CALL_OW 257
63014: PUSH
63015: LD_INT 3
63017: EQUAL
63018: IFFALSE 63022
// continue ;
63020: GO 62988
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63022: LD_ADDR_VAR 0 11
63026: PUSH
63027: LD_VAR 0 11
63031: PPUSH
63032: LD_VAR 0 11
63036: PUSH
63037: LD_INT 1
63039: PLUS
63040: PPUSH
63041: LD_VAR 0 9
63045: PUSH
63046: LD_VAR 0 3
63050: ARRAY
63051: PPUSH
63052: CALL_OW 2
63056: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63057: LD_ADDR_VAR 0 4
63061: PUSH
63062: LD_VAR 0 4
63066: PUSH
63067: LD_VAR 0 9
63071: PUSH
63072: LD_VAR 0 3
63076: ARRAY
63077: DIFF
63078: ST_TO_ADDR
// end ;
63079: GO 62988
63081: POP
63082: POP
// if p then
63083: LD_VAR 0 11
63087: IFFALSE 63112
// result := Replace ( result , 3 , p ) ;
63089: LD_ADDR_VAR 0 2
63093: PUSH
63094: LD_VAR 0 2
63098: PPUSH
63099: LD_INT 3
63101: PPUSH
63102: LD_VAR 0 11
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63112: LD_VAR 0 4
63116: PUSH
63117: LD_INT 6
63119: GREATER
63120: PUSH
63121: LD_VAR 0 6
63125: PUSH
63126: LD_INT 6
63128: LESS
63129: AND
63130: IFFALSE 63324
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63132: LD_ADDR_VAR 0 9
63136: PUSH
63137: LD_VAR 0 4
63141: PUSH
63142: LD_VAR 0 8
63146: PUSH
63147: LD_VAR 0 7
63151: UNION
63152: PUSH
63153: LD_VAR 0 6
63157: UNION
63158: DIFF
63159: PPUSH
63160: LD_INT 2
63162: PPUSH
63163: CALL 54889 0 2
63167: ST_TO_ADDR
// p := [ ] ;
63168: LD_ADDR_VAR 0 11
63172: PUSH
63173: EMPTY
63174: ST_TO_ADDR
// if sort then
63175: LD_VAR 0 9
63179: IFFALSE 63295
// for i = 1 to 6 - eng do
63181: LD_ADDR_VAR 0 3
63185: PUSH
63186: DOUBLE
63187: LD_INT 1
63189: DEC
63190: ST_TO_ADDR
63191: LD_INT 6
63193: PUSH
63194: LD_VAR 0 6
63198: MINUS
63199: PUSH
63200: FOR_TO
63201: IFFALSE 63293
// begin if i = sort then
63203: LD_VAR 0 3
63207: PUSH
63208: LD_VAR 0 9
63212: EQUAL
63213: IFFALSE 63217
// break ;
63215: GO 63293
// if GetClass ( i ) = 2 then
63217: LD_VAR 0 3
63221: PPUSH
63222: CALL_OW 257
63226: PUSH
63227: LD_INT 2
63229: EQUAL
63230: IFFALSE 63234
// continue ;
63232: GO 63200
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63234: LD_ADDR_VAR 0 11
63238: PUSH
63239: LD_VAR 0 11
63243: PPUSH
63244: LD_VAR 0 11
63248: PUSH
63249: LD_INT 1
63251: PLUS
63252: PPUSH
63253: LD_VAR 0 9
63257: PUSH
63258: LD_VAR 0 3
63262: ARRAY
63263: PPUSH
63264: CALL_OW 2
63268: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63269: LD_ADDR_VAR 0 4
63273: PUSH
63274: LD_VAR 0 4
63278: PUSH
63279: LD_VAR 0 9
63283: PUSH
63284: LD_VAR 0 3
63288: ARRAY
63289: DIFF
63290: ST_TO_ADDR
// end ;
63291: GO 63200
63293: POP
63294: POP
// if p then
63295: LD_VAR 0 11
63299: IFFALSE 63324
// result := Replace ( result , 2 , p ) ;
63301: LD_ADDR_VAR 0 2
63305: PUSH
63306: LD_VAR 0 2
63310: PPUSH
63311: LD_INT 2
63313: PPUSH
63314: LD_VAR 0 11
63318: PPUSH
63319: CALL_OW 1
63323: ST_TO_ADDR
// end ; exit ;
63324: GO 64712
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63326: LD_EXP 85
63330: PUSH
63331: LD_EXP 84
63335: PUSH
63336: LD_VAR 0 1
63340: ARRAY
63341: ARRAY
63342: NOT
63343: PUSH
63344: LD_EXP 58
63348: PUSH
63349: LD_VAR 0 1
63353: ARRAY
63354: PPUSH
63355: LD_INT 30
63357: PUSH
63358: LD_INT 3
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PPUSH
63365: CALL_OW 72
63369: AND
63370: PUSH
63371: LD_EXP 63
63375: PUSH
63376: LD_VAR 0 1
63380: ARRAY
63381: AND
63382: IFFALSE 63990
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63384: LD_ADDR_EXP 100
63388: PUSH
63389: LD_EXP 100
63393: PPUSH
63394: LD_VAR 0 1
63398: PPUSH
63399: LD_INT 5
63401: PPUSH
63402: CALL_OW 1
63406: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63407: LD_ADDR_VAR 0 2
63411: PUSH
63412: LD_INT 0
63414: PUSH
63415: LD_INT 0
63417: PUSH
63418: LD_INT 0
63420: PUSH
63421: LD_INT 0
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: LIST
63428: LIST
63429: ST_TO_ADDR
// if sci > 1 then
63430: LD_VAR 0 8
63434: PUSH
63435: LD_INT 1
63437: GREATER
63438: IFFALSE 63466
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63440: LD_ADDR_VAR 0 4
63444: PUSH
63445: LD_VAR 0 4
63449: PUSH
63450: LD_VAR 0 8
63454: PUSH
63455: LD_VAR 0 8
63459: PUSH
63460: LD_INT 1
63462: ARRAY
63463: DIFF
63464: DIFF
63465: ST_TO_ADDR
// if tmp and not sci then
63466: LD_VAR 0 4
63470: PUSH
63471: LD_VAR 0 8
63475: NOT
63476: AND
63477: IFFALSE 63546
// begin sort := SortBySkill ( tmp , 4 ) ;
63479: LD_ADDR_VAR 0 9
63483: PUSH
63484: LD_VAR 0 4
63488: PPUSH
63489: LD_INT 4
63491: PPUSH
63492: CALL 54889 0 2
63496: ST_TO_ADDR
// if sort then
63497: LD_VAR 0 9
63501: IFFALSE 63517
// p := sort [ 1 ] ;
63503: LD_ADDR_VAR 0 11
63507: PUSH
63508: LD_VAR 0 9
63512: PUSH
63513: LD_INT 1
63515: ARRAY
63516: ST_TO_ADDR
// if p then
63517: LD_VAR 0 11
63521: IFFALSE 63546
// result := Replace ( result , 4 , p ) ;
63523: LD_ADDR_VAR 0 2
63527: PUSH
63528: LD_VAR 0 2
63532: PPUSH
63533: LD_INT 4
63535: PPUSH
63536: LD_VAR 0 11
63540: PPUSH
63541: CALL_OW 1
63545: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63546: LD_ADDR_VAR 0 4
63550: PUSH
63551: LD_VAR 0 4
63555: PUSH
63556: LD_VAR 0 7
63560: DIFF
63561: ST_TO_ADDR
// if tmp and mech < 6 then
63562: LD_VAR 0 4
63566: PUSH
63567: LD_VAR 0 7
63571: PUSH
63572: LD_INT 6
63574: LESS
63575: AND
63576: IFFALSE 63764
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63578: LD_ADDR_VAR 0 9
63582: PUSH
63583: LD_VAR 0 4
63587: PUSH
63588: LD_VAR 0 8
63592: PUSH
63593: LD_VAR 0 7
63597: UNION
63598: DIFF
63599: PPUSH
63600: LD_INT 3
63602: PPUSH
63603: CALL 54889 0 2
63607: ST_TO_ADDR
// p := [ ] ;
63608: LD_ADDR_VAR 0 11
63612: PUSH
63613: EMPTY
63614: ST_TO_ADDR
// if sort then
63615: LD_VAR 0 9
63619: IFFALSE 63735
// for i = 1 to 6 - mech do
63621: LD_ADDR_VAR 0 3
63625: PUSH
63626: DOUBLE
63627: LD_INT 1
63629: DEC
63630: ST_TO_ADDR
63631: LD_INT 6
63633: PUSH
63634: LD_VAR 0 7
63638: MINUS
63639: PUSH
63640: FOR_TO
63641: IFFALSE 63733
// begin if i = sort then
63643: LD_VAR 0 3
63647: PUSH
63648: LD_VAR 0 9
63652: EQUAL
63653: IFFALSE 63657
// break ;
63655: GO 63733
// if GetClass ( i ) = 3 then
63657: LD_VAR 0 3
63661: PPUSH
63662: CALL_OW 257
63666: PUSH
63667: LD_INT 3
63669: EQUAL
63670: IFFALSE 63674
// continue ;
63672: GO 63640
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63674: LD_ADDR_VAR 0 11
63678: PUSH
63679: LD_VAR 0 11
63683: PPUSH
63684: LD_VAR 0 11
63688: PUSH
63689: LD_INT 1
63691: PLUS
63692: PPUSH
63693: LD_VAR 0 9
63697: PUSH
63698: LD_VAR 0 3
63702: ARRAY
63703: PPUSH
63704: CALL_OW 2
63708: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63709: LD_ADDR_VAR 0 4
63713: PUSH
63714: LD_VAR 0 4
63718: PUSH
63719: LD_VAR 0 9
63723: PUSH
63724: LD_VAR 0 3
63728: ARRAY
63729: DIFF
63730: ST_TO_ADDR
// end ;
63731: GO 63640
63733: POP
63734: POP
// if p then
63735: LD_VAR 0 11
63739: IFFALSE 63764
// result := Replace ( result , 3 , p ) ;
63741: LD_ADDR_VAR 0 2
63745: PUSH
63746: LD_VAR 0 2
63750: PPUSH
63751: LD_INT 3
63753: PPUSH
63754: LD_VAR 0 11
63758: PPUSH
63759: CALL_OW 1
63763: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63764: LD_ADDR_VAR 0 4
63768: PUSH
63769: LD_VAR 0 4
63773: PUSH
63774: LD_VAR 0 6
63778: DIFF
63779: ST_TO_ADDR
// if tmp and eng < 6 then
63780: LD_VAR 0 4
63784: PUSH
63785: LD_VAR 0 6
63789: PUSH
63790: LD_INT 6
63792: LESS
63793: AND
63794: IFFALSE 63988
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63796: LD_ADDR_VAR 0 9
63800: PUSH
63801: LD_VAR 0 4
63805: PUSH
63806: LD_VAR 0 8
63810: PUSH
63811: LD_VAR 0 7
63815: UNION
63816: PUSH
63817: LD_VAR 0 6
63821: UNION
63822: DIFF
63823: PPUSH
63824: LD_INT 2
63826: PPUSH
63827: CALL 54889 0 2
63831: ST_TO_ADDR
// p := [ ] ;
63832: LD_ADDR_VAR 0 11
63836: PUSH
63837: EMPTY
63838: ST_TO_ADDR
// if sort then
63839: LD_VAR 0 9
63843: IFFALSE 63959
// for i = 1 to 6 - eng do
63845: LD_ADDR_VAR 0 3
63849: PUSH
63850: DOUBLE
63851: LD_INT 1
63853: DEC
63854: ST_TO_ADDR
63855: LD_INT 6
63857: PUSH
63858: LD_VAR 0 6
63862: MINUS
63863: PUSH
63864: FOR_TO
63865: IFFALSE 63957
// begin if i = sort then
63867: LD_VAR 0 3
63871: PUSH
63872: LD_VAR 0 9
63876: EQUAL
63877: IFFALSE 63881
// break ;
63879: GO 63957
// if GetClass ( i ) = 2 then
63881: LD_VAR 0 3
63885: PPUSH
63886: CALL_OW 257
63890: PUSH
63891: LD_INT 2
63893: EQUAL
63894: IFFALSE 63898
// continue ;
63896: GO 63864
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63898: LD_ADDR_VAR 0 11
63902: PUSH
63903: LD_VAR 0 11
63907: PPUSH
63908: LD_VAR 0 11
63912: PUSH
63913: LD_INT 1
63915: PLUS
63916: PPUSH
63917: LD_VAR 0 9
63921: PUSH
63922: LD_VAR 0 3
63926: ARRAY
63927: PPUSH
63928: CALL_OW 2
63932: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63933: LD_ADDR_VAR 0 4
63937: PUSH
63938: LD_VAR 0 4
63942: PUSH
63943: LD_VAR 0 9
63947: PUSH
63948: LD_VAR 0 3
63952: ARRAY
63953: DIFF
63954: ST_TO_ADDR
// end ;
63955: GO 63864
63957: POP
63958: POP
// if p then
63959: LD_VAR 0 11
63963: IFFALSE 63988
// result := Replace ( result , 2 , p ) ;
63965: LD_ADDR_VAR 0 2
63969: PUSH
63970: LD_VAR 0 2
63974: PPUSH
63975: LD_INT 2
63977: PPUSH
63978: LD_VAR 0 11
63982: PPUSH
63983: CALL_OW 1
63987: ST_TO_ADDR
// end ; exit ;
63988: GO 64712
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63990: LD_EXP 85
63994: PUSH
63995: LD_EXP 84
63999: PUSH
64000: LD_VAR 0 1
64004: ARRAY
64005: ARRAY
64006: NOT
64007: PUSH
64008: LD_EXP 58
64012: PUSH
64013: LD_VAR 0 1
64017: ARRAY
64018: PPUSH
64019: LD_INT 30
64021: PUSH
64022: LD_INT 3
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PPUSH
64029: CALL_OW 72
64033: AND
64034: PUSH
64035: LD_EXP 63
64039: PUSH
64040: LD_VAR 0 1
64044: ARRAY
64045: NOT
64046: AND
64047: IFFALSE 64712
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64049: LD_ADDR_EXP 100
64053: PUSH
64054: LD_EXP 100
64058: PPUSH
64059: LD_VAR 0 1
64063: PPUSH
64064: LD_INT 6
64066: PPUSH
64067: CALL_OW 1
64071: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64072: LD_ADDR_VAR 0 2
64076: PUSH
64077: LD_INT 0
64079: PUSH
64080: LD_INT 0
64082: PUSH
64083: LD_INT 0
64085: PUSH
64086: LD_INT 0
64088: PUSH
64089: EMPTY
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: ST_TO_ADDR
// if sci >= 1 then
64095: LD_VAR 0 8
64099: PUSH
64100: LD_INT 1
64102: GREATEREQUAL
64103: IFFALSE 64125
// tmp := tmp diff sci [ 1 ] ;
64105: LD_ADDR_VAR 0 4
64109: PUSH
64110: LD_VAR 0 4
64114: PUSH
64115: LD_VAR 0 8
64119: PUSH
64120: LD_INT 1
64122: ARRAY
64123: DIFF
64124: ST_TO_ADDR
// if tmp and not sci then
64125: LD_VAR 0 4
64129: PUSH
64130: LD_VAR 0 8
64134: NOT
64135: AND
64136: IFFALSE 64205
// begin sort := SortBySkill ( tmp , 4 ) ;
64138: LD_ADDR_VAR 0 9
64142: PUSH
64143: LD_VAR 0 4
64147: PPUSH
64148: LD_INT 4
64150: PPUSH
64151: CALL 54889 0 2
64155: ST_TO_ADDR
// if sort then
64156: LD_VAR 0 9
64160: IFFALSE 64176
// p := sort [ 1 ] ;
64162: LD_ADDR_VAR 0 11
64166: PUSH
64167: LD_VAR 0 9
64171: PUSH
64172: LD_INT 1
64174: ARRAY
64175: ST_TO_ADDR
// if p then
64176: LD_VAR 0 11
64180: IFFALSE 64205
// result := Replace ( result , 4 , p ) ;
64182: LD_ADDR_VAR 0 2
64186: PUSH
64187: LD_VAR 0 2
64191: PPUSH
64192: LD_INT 4
64194: PPUSH
64195: LD_VAR 0 11
64199: PPUSH
64200: CALL_OW 1
64204: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64205: LD_ADDR_VAR 0 4
64209: PUSH
64210: LD_VAR 0 4
64214: PUSH
64215: LD_VAR 0 7
64219: DIFF
64220: ST_TO_ADDR
// if tmp and mech < 6 then
64221: LD_VAR 0 4
64225: PUSH
64226: LD_VAR 0 7
64230: PUSH
64231: LD_INT 6
64233: LESS
64234: AND
64235: IFFALSE 64417
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64237: LD_ADDR_VAR 0 9
64241: PUSH
64242: LD_VAR 0 4
64246: PUSH
64247: LD_VAR 0 7
64251: DIFF
64252: PPUSH
64253: LD_INT 3
64255: PPUSH
64256: CALL 54889 0 2
64260: ST_TO_ADDR
// p := [ ] ;
64261: LD_ADDR_VAR 0 11
64265: PUSH
64266: EMPTY
64267: ST_TO_ADDR
// if sort then
64268: LD_VAR 0 9
64272: IFFALSE 64388
// for i = 1 to 6 - mech do
64274: LD_ADDR_VAR 0 3
64278: PUSH
64279: DOUBLE
64280: LD_INT 1
64282: DEC
64283: ST_TO_ADDR
64284: LD_INT 6
64286: PUSH
64287: LD_VAR 0 7
64291: MINUS
64292: PUSH
64293: FOR_TO
64294: IFFALSE 64386
// begin if i = sort then
64296: LD_VAR 0 3
64300: PUSH
64301: LD_VAR 0 9
64305: EQUAL
64306: IFFALSE 64310
// break ;
64308: GO 64386
// if GetClass ( i ) = 3 then
64310: LD_VAR 0 3
64314: PPUSH
64315: CALL_OW 257
64319: PUSH
64320: LD_INT 3
64322: EQUAL
64323: IFFALSE 64327
// continue ;
64325: GO 64293
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64327: LD_ADDR_VAR 0 11
64331: PUSH
64332: LD_VAR 0 11
64336: PPUSH
64337: LD_VAR 0 11
64341: PUSH
64342: LD_INT 1
64344: PLUS
64345: PPUSH
64346: LD_VAR 0 9
64350: PUSH
64351: LD_VAR 0 3
64355: ARRAY
64356: PPUSH
64357: CALL_OW 2
64361: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64362: LD_ADDR_VAR 0 4
64366: PUSH
64367: LD_VAR 0 4
64371: PUSH
64372: LD_VAR 0 9
64376: PUSH
64377: LD_VAR 0 3
64381: ARRAY
64382: DIFF
64383: ST_TO_ADDR
// end ;
64384: GO 64293
64386: POP
64387: POP
// if p then
64388: LD_VAR 0 11
64392: IFFALSE 64417
// result := Replace ( result , 3 , p ) ;
64394: LD_ADDR_VAR 0 2
64398: PUSH
64399: LD_VAR 0 2
64403: PPUSH
64404: LD_INT 3
64406: PPUSH
64407: LD_VAR 0 11
64411: PPUSH
64412: CALL_OW 1
64416: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64417: LD_ADDR_VAR 0 4
64421: PUSH
64422: LD_VAR 0 4
64426: PUSH
64427: LD_VAR 0 6
64431: DIFF
64432: ST_TO_ADDR
// if tmp and eng < 4 then
64433: LD_VAR 0 4
64437: PUSH
64438: LD_VAR 0 6
64442: PUSH
64443: LD_INT 4
64445: LESS
64446: AND
64447: IFFALSE 64637
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64449: LD_ADDR_VAR 0 9
64453: PUSH
64454: LD_VAR 0 4
64458: PUSH
64459: LD_VAR 0 7
64463: PUSH
64464: LD_VAR 0 6
64468: UNION
64469: DIFF
64470: PPUSH
64471: LD_INT 2
64473: PPUSH
64474: CALL 54889 0 2
64478: ST_TO_ADDR
// p := [ ] ;
64479: LD_ADDR_VAR 0 11
64483: PUSH
64484: EMPTY
64485: ST_TO_ADDR
// if sort then
64486: LD_VAR 0 9
64490: IFFALSE 64606
// for i = 1 to 4 - eng do
64492: LD_ADDR_VAR 0 3
64496: PUSH
64497: DOUBLE
64498: LD_INT 1
64500: DEC
64501: ST_TO_ADDR
64502: LD_INT 4
64504: PUSH
64505: LD_VAR 0 6
64509: MINUS
64510: PUSH
64511: FOR_TO
64512: IFFALSE 64604
// begin if i = sort then
64514: LD_VAR 0 3
64518: PUSH
64519: LD_VAR 0 9
64523: EQUAL
64524: IFFALSE 64528
// break ;
64526: GO 64604
// if GetClass ( i ) = 2 then
64528: LD_VAR 0 3
64532: PPUSH
64533: CALL_OW 257
64537: PUSH
64538: LD_INT 2
64540: EQUAL
64541: IFFALSE 64545
// continue ;
64543: GO 64511
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64545: LD_ADDR_VAR 0 11
64549: PUSH
64550: LD_VAR 0 11
64554: PPUSH
64555: LD_VAR 0 11
64559: PUSH
64560: LD_INT 1
64562: PLUS
64563: PPUSH
64564: LD_VAR 0 9
64568: PUSH
64569: LD_VAR 0 3
64573: ARRAY
64574: PPUSH
64575: CALL_OW 2
64579: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64580: LD_ADDR_VAR 0 4
64584: PUSH
64585: LD_VAR 0 4
64589: PUSH
64590: LD_VAR 0 9
64594: PUSH
64595: LD_VAR 0 3
64599: ARRAY
64600: DIFF
64601: ST_TO_ADDR
// end ;
64602: GO 64511
64604: POP
64605: POP
// if p then
64606: LD_VAR 0 11
64610: IFFALSE 64635
// result := Replace ( result , 2 , p ) ;
64612: LD_ADDR_VAR 0 2
64616: PUSH
64617: LD_VAR 0 2
64621: PPUSH
64622: LD_INT 2
64624: PPUSH
64625: LD_VAR 0 11
64629: PPUSH
64630: CALL_OW 1
64634: ST_TO_ADDR
// end else
64635: GO 64681
// for i = eng downto 5 do
64637: LD_ADDR_VAR 0 3
64641: PUSH
64642: DOUBLE
64643: LD_VAR 0 6
64647: INC
64648: ST_TO_ADDR
64649: LD_INT 5
64651: PUSH
64652: FOR_DOWNTO
64653: IFFALSE 64679
// tmp := tmp union eng [ i ] ;
64655: LD_ADDR_VAR 0 4
64659: PUSH
64660: LD_VAR 0 4
64664: PUSH
64665: LD_VAR 0 6
64669: PUSH
64670: LD_VAR 0 3
64674: ARRAY
64675: UNION
64676: ST_TO_ADDR
64677: GO 64652
64679: POP
64680: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64681: LD_ADDR_VAR 0 2
64685: PUSH
64686: LD_VAR 0 2
64690: PPUSH
64691: LD_INT 1
64693: PPUSH
64694: LD_VAR 0 4
64698: PUSH
64699: LD_VAR 0 5
64703: DIFF
64704: PPUSH
64705: CALL_OW 1
64709: ST_TO_ADDR
// exit ;
64710: GO 64712
// end ; end ;
64712: LD_VAR 0 2
64716: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64717: LD_INT 0
64719: PPUSH
64720: PPUSH
64721: PPUSH
// if not mc_bases then
64722: LD_EXP 58
64726: NOT
64727: IFFALSE 64731
// exit ;
64729: GO 64837
// for i = 1 to mc_bases do
64731: LD_ADDR_VAR 0 2
64735: PUSH
64736: DOUBLE
64737: LD_INT 1
64739: DEC
64740: ST_TO_ADDR
64741: LD_EXP 58
64745: PUSH
64746: FOR_TO
64747: IFFALSE 64828
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64749: LD_ADDR_VAR 0 3
64753: PUSH
64754: LD_EXP 58
64758: PUSH
64759: LD_VAR 0 2
64763: ARRAY
64764: PPUSH
64765: LD_INT 21
64767: PUSH
64768: LD_INT 3
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: LD_INT 3
64777: PUSH
64778: LD_INT 24
64780: PUSH
64781: LD_INT 1000
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PPUSH
64796: CALL_OW 72
64800: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64801: LD_ADDR_EXP 59
64805: PUSH
64806: LD_EXP 59
64810: PPUSH
64811: LD_VAR 0 2
64815: PPUSH
64816: LD_VAR 0 3
64820: PPUSH
64821: CALL_OW 1
64825: ST_TO_ADDR
// end ;
64826: GO 64746
64828: POP
64829: POP
// RaiseSailEvent ( 101 ) ;
64830: LD_INT 101
64832: PPUSH
64833: CALL_OW 427
// end ;
64837: LD_VAR 0 1
64841: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64842: LD_INT 0
64844: PPUSH
64845: PPUSH
64846: PPUSH
64847: PPUSH
64848: PPUSH
64849: PPUSH
64850: PPUSH
// if not mc_bases then
64851: LD_EXP 58
64855: NOT
64856: IFFALSE 64860
// exit ;
64858: GO 65433
// for i = 1 to mc_bases do
64860: LD_ADDR_VAR 0 2
64864: PUSH
64865: DOUBLE
64866: LD_INT 1
64868: DEC
64869: ST_TO_ADDR
64870: LD_EXP 58
64874: PUSH
64875: FOR_TO
64876: IFFALSE 65424
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
64878: LD_ADDR_VAR 0 5
64882: PUSH
64883: LD_EXP 58
64887: PUSH
64888: LD_VAR 0 2
64892: ARRAY
64893: PUSH
64894: LD_EXP 87
64898: PUSH
64899: LD_VAR 0 2
64903: ARRAY
64904: UNION
64905: PPUSH
64906: LD_INT 21
64908: PUSH
64909: LD_INT 1
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: LD_INT 3
64921: PUSH
64922: LD_INT 54
64924: PUSH
64925: EMPTY
64926: LIST
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 3
64934: PUSH
64935: LD_INT 24
64937: PUSH
64938: LD_INT 750
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: EMPTY
64946: LIST
64947: LIST
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: LIST
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PPUSH
64958: CALL_OW 72
64962: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64963: LD_ADDR_VAR 0 6
64967: PUSH
64968: LD_EXP 58
64972: PUSH
64973: LD_VAR 0 2
64977: ARRAY
64978: PPUSH
64979: LD_INT 21
64981: PUSH
64982: LD_INT 1
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: LD_INT 1
64991: PUSH
64992: LD_INT 3
64994: PUSH
64995: LD_INT 54
64997: PUSH
64998: EMPTY
64999: LIST
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: PUSH
65005: LD_INT 3
65007: PUSH
65008: LD_INT 24
65010: PUSH
65011: LD_INT 250
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: LIST
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PPUSH
65031: CALL_OW 72
65035: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65036: LD_ADDR_VAR 0 7
65040: PUSH
65041: LD_VAR 0 5
65045: PUSH
65046: LD_VAR 0 6
65050: DIFF
65051: ST_TO_ADDR
// if not need_heal_1 then
65052: LD_VAR 0 6
65056: NOT
65057: IFFALSE 65090
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65059: LD_ADDR_EXP 61
65063: PUSH
65064: LD_EXP 61
65068: PPUSH
65069: LD_VAR 0 2
65073: PUSH
65074: LD_INT 1
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PPUSH
65081: EMPTY
65082: PPUSH
65083: CALL 20665 0 3
65087: ST_TO_ADDR
65088: GO 65160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65090: LD_ADDR_EXP 61
65094: PUSH
65095: LD_EXP 61
65099: PPUSH
65100: LD_VAR 0 2
65104: PUSH
65105: LD_INT 1
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PPUSH
65112: LD_EXP 61
65116: PUSH
65117: LD_VAR 0 2
65121: ARRAY
65122: PUSH
65123: LD_INT 1
65125: ARRAY
65126: PPUSH
65127: LD_INT 3
65129: PUSH
65130: LD_INT 24
65132: PUSH
65133: LD_INT 1000
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PPUSH
65144: CALL_OW 72
65148: PUSH
65149: LD_VAR 0 6
65153: UNION
65154: PPUSH
65155: CALL 20665 0 3
65159: ST_TO_ADDR
// if not need_heal_2 then
65160: LD_VAR 0 7
65164: NOT
65165: IFFALSE 65198
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65167: LD_ADDR_EXP 61
65171: PUSH
65172: LD_EXP 61
65176: PPUSH
65177: LD_VAR 0 2
65181: PUSH
65182: LD_INT 2
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PPUSH
65189: EMPTY
65190: PPUSH
65191: CALL 20665 0 3
65195: ST_TO_ADDR
65196: GO 65230
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65198: LD_ADDR_EXP 61
65202: PUSH
65203: LD_EXP 61
65207: PPUSH
65208: LD_VAR 0 2
65212: PUSH
65213: LD_INT 2
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PPUSH
65220: LD_VAR 0 7
65224: PPUSH
65225: CALL 20665 0 3
65229: ST_TO_ADDR
// if need_heal_2 then
65230: LD_VAR 0 7
65234: IFFALSE 65406
// for j in need_heal_2 do
65236: LD_ADDR_VAR 0 3
65240: PUSH
65241: LD_VAR 0 7
65245: PUSH
65246: FOR_IN
65247: IFFALSE 65404
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65249: LD_ADDR_VAR 0 5
65253: PUSH
65254: LD_EXP 58
65258: PUSH
65259: LD_VAR 0 2
65263: ARRAY
65264: PPUSH
65265: LD_INT 2
65267: PUSH
65268: LD_INT 30
65270: PUSH
65271: LD_INT 6
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 30
65280: PUSH
65281: LD_INT 7
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: LD_INT 30
65290: PUSH
65291: LD_INT 8
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 30
65300: PUSH
65301: LD_INT 0
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: PUSH
65308: LD_INT 30
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: PUSH
65318: LD_INT 25
65320: PUSH
65321: LD_INT 4
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: PPUSH
65337: CALL_OW 72
65341: ST_TO_ADDR
// if tmp then
65342: LD_VAR 0 5
65346: IFFALSE 65402
// begin k := NearestUnitToUnit ( tmp , j ) ;
65348: LD_ADDR_VAR 0 4
65352: PUSH
65353: LD_VAR 0 5
65357: PPUSH
65358: LD_VAR 0 3
65362: PPUSH
65363: CALL_OW 74
65367: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65368: LD_VAR 0 3
65372: PPUSH
65373: LD_VAR 0 4
65377: PPUSH
65378: CALL_OW 296
65382: PUSH
65383: LD_INT 7
65385: GREATER
65386: IFFALSE 65402
// ComMoveUnit ( j , k ) ;
65388: LD_VAR 0 3
65392: PPUSH
65393: LD_VAR 0 4
65397: PPUSH
65398: CALL_OW 112
// end ; end ;
65402: GO 65246
65404: POP
65405: POP
// if not need_heal_1 and not need_heal_2 then
65406: LD_VAR 0 6
65410: NOT
65411: PUSH
65412: LD_VAR 0 7
65416: NOT
65417: AND
65418: IFFALSE 65422
// continue ;
65420: GO 64875
// end ;
65422: GO 64875
65424: POP
65425: POP
// RaiseSailEvent ( 102 ) ;
65426: LD_INT 102
65428: PPUSH
65429: CALL_OW 427
// end ;
65433: LD_VAR 0 1
65437: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
65438: LD_INT 0
65440: PPUSH
65441: PPUSH
65442: PPUSH
65443: PPUSH
65444: PPUSH
// if not mc_bases then
65445: LD_EXP 58
65449: NOT
65450: IFFALSE 65454
// exit ;
65452: GO 65839
// for i = 1 to mc_bases do
65454: LD_ADDR_VAR 0 2
65458: PUSH
65459: DOUBLE
65460: LD_INT 1
65462: DEC
65463: ST_TO_ADDR
65464: LD_EXP 58
65468: PUSH
65469: FOR_TO
65470: IFFALSE 65837
// begin if not mc_building_need_repair [ i ] then
65472: LD_EXP 59
65476: PUSH
65477: LD_VAR 0 2
65481: ARRAY
65482: NOT
65483: IFFALSE 65521
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65485: LD_ADDR_EXP 60
65489: PUSH
65490: LD_EXP 60
65494: PPUSH
65495: LD_VAR 0 2
65499: PPUSH
65500: EMPTY
65501: PPUSH
65502: CALL_OW 1
65506: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65507: LD_VAR 0 2
65511: PPUSH
65512: LD_INT 101
65514: PPUSH
65515: CALL 60559 0 2
// continue ;
65519: GO 65469
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65521: LD_ADDR_EXP 64
65525: PUSH
65526: LD_EXP 64
65530: PPUSH
65531: LD_VAR 0 2
65535: PPUSH
65536: EMPTY
65537: PPUSH
65538: CALL_OW 1
65542: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65543: LD_VAR 0 2
65547: PPUSH
65548: LD_INT 103
65550: PPUSH
65551: CALL 60559 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65555: LD_ADDR_VAR 0 5
65559: PUSH
65560: LD_EXP 58
65564: PUSH
65565: LD_VAR 0 2
65569: ARRAY
65570: PUSH
65571: LD_EXP 87
65575: PUSH
65576: LD_VAR 0 2
65580: ARRAY
65581: UNION
65582: PPUSH
65583: LD_INT 2
65585: PUSH
65586: LD_INT 25
65588: PUSH
65589: LD_INT 2
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 25
65598: PUSH
65599: LD_INT 16
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: LIST
65610: PUSH
65611: EMPTY
65612: LIST
65613: PPUSH
65614: CALL_OW 72
65618: ST_TO_ADDR
// if not tmp then
65619: LD_VAR 0 5
65623: NOT
65624: IFFALSE 65628
// continue ;
65626: GO 65469
// for j in tmp do
65628: LD_ADDR_VAR 0 3
65632: PUSH
65633: LD_VAR 0 5
65637: PUSH
65638: FOR_IN
65639: IFFALSE 65833
// begin if mc_need_heal [ i ] then
65641: LD_EXP 61
65645: PUSH
65646: LD_VAR 0 2
65650: ARRAY
65651: IFFALSE 65699
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
65653: LD_VAR 0 3
65657: PUSH
65658: LD_EXP 61
65662: PUSH
65663: LD_VAR 0 2
65667: ARRAY
65668: PUSH
65669: LD_INT 1
65671: ARRAY
65672: IN
65673: PUSH
65674: LD_VAR 0 3
65678: PUSH
65679: LD_EXP 61
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: PUSH
65690: LD_INT 2
65692: ARRAY
65693: IN
65694: OR
65695: IFFALSE 65699
// continue ;
65697: GO 65638
// if IsInUnit ( j ) then
65699: LD_VAR 0 3
65703: PPUSH
65704: CALL_OW 310
65708: IFFALSE 65719
// ComExitBuilding ( j ) ;
65710: LD_VAR 0 3
65714: PPUSH
65715: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65719: LD_VAR 0 3
65723: PUSH
65724: LD_EXP 60
65728: PUSH
65729: LD_VAR 0 2
65733: ARRAY
65734: IN
65735: NOT
65736: IFFALSE 65794
// begin SetTag ( j , 101 ) ;
65738: LD_VAR 0 3
65742: PPUSH
65743: LD_INT 101
65745: PPUSH
65746: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65750: LD_ADDR_EXP 60
65754: PUSH
65755: LD_EXP 60
65759: PPUSH
65760: LD_VAR 0 2
65764: PUSH
65765: LD_EXP 60
65769: PUSH
65770: LD_VAR 0 2
65774: ARRAY
65775: PUSH
65776: LD_INT 1
65778: PLUS
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PPUSH
65784: LD_VAR 0 3
65788: PPUSH
65789: CALL 20665 0 3
65793: ST_TO_ADDR
// end ; wait ( 1 ) ;
65794: LD_INT 1
65796: PPUSH
65797: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
65801: LD_VAR 0 3
65805: PPUSH
65806: LD_EXP 59
65810: PUSH
65811: LD_VAR 0 2
65815: ARRAY
65816: PPUSH
65817: LD_VAR 0 3
65821: PPUSH
65822: CALL_OW 74
65826: PPUSH
65827: CALL_OW 130
// end ;
65831: GO 65638
65833: POP
65834: POP
// end ;
65835: GO 65469
65837: POP
65838: POP
// end ;
65839: LD_VAR 0 1
65843: RET
// export function MC_Heal ; var i , j , tmp ; begin
65844: LD_INT 0
65846: PPUSH
65847: PPUSH
65848: PPUSH
65849: PPUSH
// if not mc_bases then
65850: LD_EXP 58
65854: NOT
65855: IFFALSE 65859
// exit ;
65857: GO 66261
// for i = 1 to mc_bases do
65859: LD_ADDR_VAR 0 2
65863: PUSH
65864: DOUBLE
65865: LD_INT 1
65867: DEC
65868: ST_TO_ADDR
65869: LD_EXP 58
65873: PUSH
65874: FOR_TO
65875: IFFALSE 66259
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65877: LD_EXP 61
65881: PUSH
65882: LD_VAR 0 2
65886: ARRAY
65887: PUSH
65888: LD_INT 1
65890: ARRAY
65891: NOT
65892: PUSH
65893: LD_EXP 61
65897: PUSH
65898: LD_VAR 0 2
65902: ARRAY
65903: PUSH
65904: LD_INT 2
65906: ARRAY
65907: NOT
65908: AND
65909: IFFALSE 65947
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65911: LD_ADDR_EXP 62
65915: PUSH
65916: LD_EXP 62
65920: PPUSH
65921: LD_VAR 0 2
65925: PPUSH
65926: EMPTY
65927: PPUSH
65928: CALL_OW 1
65932: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65933: LD_VAR 0 2
65937: PPUSH
65938: LD_INT 102
65940: PPUSH
65941: CALL 60559 0 2
// continue ;
65945: GO 65874
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65947: LD_ADDR_VAR 0 4
65951: PUSH
65952: LD_EXP 58
65956: PUSH
65957: LD_VAR 0 2
65961: ARRAY
65962: PPUSH
65963: LD_INT 25
65965: PUSH
65966: LD_INT 4
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PPUSH
65973: CALL_OW 72
65977: ST_TO_ADDR
// if not tmp then
65978: LD_VAR 0 4
65982: NOT
65983: IFFALSE 65987
// continue ;
65985: GO 65874
// if mc_taming [ i ] then
65987: LD_EXP 89
65991: PUSH
65992: LD_VAR 0 2
65996: ARRAY
65997: IFFALSE 66021
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65999: LD_ADDR_EXP 89
66003: PUSH
66004: LD_EXP 89
66008: PPUSH
66009: LD_VAR 0 2
66013: PPUSH
66014: EMPTY
66015: PPUSH
66016: CALL_OW 1
66020: ST_TO_ADDR
// for j in tmp do
66021: LD_ADDR_VAR 0 3
66025: PUSH
66026: LD_VAR 0 4
66030: PUSH
66031: FOR_IN
66032: IFFALSE 66255
// begin if IsInUnit ( j ) then
66034: LD_VAR 0 3
66038: PPUSH
66039: CALL_OW 310
66043: IFFALSE 66054
// ComExitBuilding ( j ) ;
66045: LD_VAR 0 3
66049: PPUSH
66050: CALL_OW 122
// if not j in mc_healers [ i ] then
66054: LD_VAR 0 3
66058: PUSH
66059: LD_EXP 62
66063: PUSH
66064: LD_VAR 0 2
66068: ARRAY
66069: IN
66070: NOT
66071: IFFALSE 66117
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66073: LD_ADDR_EXP 62
66077: PUSH
66078: LD_EXP 62
66082: PPUSH
66083: LD_VAR 0 2
66087: PUSH
66088: LD_EXP 62
66092: PUSH
66093: LD_VAR 0 2
66097: ARRAY
66098: PUSH
66099: LD_INT 1
66101: PLUS
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PPUSH
66107: LD_VAR 0 3
66111: PPUSH
66112: CALL 20665 0 3
66116: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66117: LD_VAR 0 3
66121: PPUSH
66122: CALL_OW 110
66126: PUSH
66127: LD_INT 102
66129: NONEQUAL
66130: IFFALSE 66144
// SetTag ( j , 102 ) ;
66132: LD_VAR 0 3
66136: PPUSH
66137: LD_INT 102
66139: PPUSH
66140: CALL_OW 109
// Wait ( 3 ) ;
66144: LD_INT 3
66146: PPUSH
66147: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66151: LD_EXP 61
66155: PUSH
66156: LD_VAR 0 2
66160: ARRAY
66161: PUSH
66162: LD_INT 1
66164: ARRAY
66165: IFFALSE 66197
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66167: LD_VAR 0 3
66171: PPUSH
66172: LD_EXP 61
66176: PUSH
66177: LD_VAR 0 2
66181: ARRAY
66182: PUSH
66183: LD_INT 1
66185: ARRAY
66186: PUSH
66187: LD_INT 1
66189: ARRAY
66190: PPUSH
66191: CALL_OW 128
66195: GO 66253
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66197: LD_VAR 0 3
66201: PPUSH
66202: CALL_OW 314
66206: NOT
66207: PUSH
66208: LD_EXP 61
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: PUSH
66219: LD_INT 2
66221: ARRAY
66222: AND
66223: IFFALSE 66253
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66225: LD_VAR 0 3
66229: PPUSH
66230: LD_EXP 61
66234: PUSH
66235: LD_VAR 0 2
66239: ARRAY
66240: PUSH
66241: LD_INT 2
66243: ARRAY
66244: PUSH
66245: LD_INT 1
66247: ARRAY
66248: PPUSH
66249: CALL_OW 128
// end ;
66253: GO 66031
66255: POP
66256: POP
// end ;
66257: GO 65874
66259: POP
66260: POP
// end ;
66261: LD_VAR 0 1
66265: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66266: LD_INT 0
66268: PPUSH
66269: PPUSH
66270: PPUSH
66271: PPUSH
66272: PPUSH
// if not mc_bases then
66273: LD_EXP 58
66277: NOT
66278: IFFALSE 66282
// exit ;
66280: GO 67425
// for i = 1 to mc_bases do
66282: LD_ADDR_VAR 0 2
66286: PUSH
66287: DOUBLE
66288: LD_INT 1
66290: DEC
66291: ST_TO_ADDR
66292: LD_EXP 58
66296: PUSH
66297: FOR_TO
66298: IFFALSE 67423
// begin if mc_scan [ i ] then
66300: LD_EXP 81
66304: PUSH
66305: LD_VAR 0 2
66309: ARRAY
66310: IFFALSE 66314
// continue ;
66312: GO 66297
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66314: LD_EXP 63
66318: PUSH
66319: LD_VAR 0 2
66323: ARRAY
66324: NOT
66325: PUSH
66326: LD_EXP 65
66330: PUSH
66331: LD_VAR 0 2
66335: ARRAY
66336: NOT
66337: AND
66338: PUSH
66339: LD_EXP 64
66343: PUSH
66344: LD_VAR 0 2
66348: ARRAY
66349: AND
66350: IFFALSE 66388
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66352: LD_ADDR_EXP 64
66356: PUSH
66357: LD_EXP 64
66361: PPUSH
66362: LD_VAR 0 2
66366: PPUSH
66367: EMPTY
66368: PPUSH
66369: CALL_OW 1
66373: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66374: LD_VAR 0 2
66378: PPUSH
66379: LD_INT 103
66381: PPUSH
66382: CALL 60559 0 2
// continue ;
66386: GO 66297
// end ; if mc_construct_list [ i ] then
66388: LD_EXP 65
66392: PUSH
66393: LD_VAR 0 2
66397: ARRAY
66398: IFFALSE 66618
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66400: LD_ADDR_VAR 0 4
66404: PUSH
66405: LD_EXP 58
66409: PUSH
66410: LD_VAR 0 2
66414: ARRAY
66415: PPUSH
66416: LD_INT 25
66418: PUSH
66419: LD_INT 2
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PPUSH
66426: CALL_OW 72
66430: PUSH
66431: LD_EXP 60
66435: PUSH
66436: LD_VAR 0 2
66440: ARRAY
66441: DIFF
66442: ST_TO_ADDR
// if not tmp then
66443: LD_VAR 0 4
66447: NOT
66448: IFFALSE 66452
// continue ;
66450: GO 66297
// for j in tmp do
66452: LD_ADDR_VAR 0 3
66456: PUSH
66457: LD_VAR 0 4
66461: PUSH
66462: FOR_IN
66463: IFFALSE 66614
// begin if not mc_builders [ i ] then
66465: LD_EXP 64
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: NOT
66476: IFFALSE 66534
// begin SetTag ( j , 103 ) ;
66478: LD_VAR 0 3
66482: PPUSH
66483: LD_INT 103
66485: PPUSH
66486: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66490: LD_ADDR_EXP 64
66494: PUSH
66495: LD_EXP 64
66499: PPUSH
66500: LD_VAR 0 2
66504: PUSH
66505: LD_EXP 64
66509: PUSH
66510: LD_VAR 0 2
66514: ARRAY
66515: PUSH
66516: LD_INT 1
66518: PLUS
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PPUSH
66524: LD_VAR 0 3
66528: PPUSH
66529: CALL 20665 0 3
66533: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66534: LD_VAR 0 3
66538: PPUSH
66539: CALL_OW 310
66543: IFFALSE 66554
// ComExitBuilding ( j ) ;
66545: LD_VAR 0 3
66549: PPUSH
66550: CALL_OW 122
// wait ( 3 ) ;
66554: LD_INT 3
66556: PPUSH
66557: CALL_OW 67
// if not mc_construct_list [ i ] then
66561: LD_EXP 65
66565: PUSH
66566: LD_VAR 0 2
66570: ARRAY
66571: NOT
66572: IFFALSE 66576
// break ;
66574: GO 66614
// if not HasTask ( j ) then
66576: LD_VAR 0 3
66580: PPUSH
66581: CALL_OW 314
66585: NOT
66586: IFFALSE 66612
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66588: LD_VAR 0 3
66592: PPUSH
66593: LD_EXP 65
66597: PUSH
66598: LD_VAR 0 2
66602: ARRAY
66603: PUSH
66604: LD_INT 1
66606: ARRAY
66607: PPUSH
66608: CALL 23516 0 2
// end ;
66612: GO 66462
66614: POP
66615: POP
// end else
66616: GO 67421
// if mc_build_list [ i ] then
66618: LD_EXP 63
66622: PUSH
66623: LD_VAR 0 2
66627: ARRAY
66628: IFFALSE 67421
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66630: LD_ADDR_VAR 0 5
66634: PUSH
66635: LD_EXP 58
66639: PUSH
66640: LD_VAR 0 2
66644: ARRAY
66645: PPUSH
66646: LD_INT 2
66648: PUSH
66649: LD_INT 30
66651: PUSH
66652: LD_INT 0
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 30
66661: PUSH
66662: LD_INT 1
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: LIST
66673: PPUSH
66674: CALL_OW 72
66678: ST_TO_ADDR
// if depot then
66679: LD_VAR 0 5
66683: IFFALSE 66701
// depot := depot [ 1 ] else
66685: LD_ADDR_VAR 0 5
66689: PUSH
66690: LD_VAR 0 5
66694: PUSH
66695: LD_INT 1
66697: ARRAY
66698: ST_TO_ADDR
66699: GO 66709
// depot := 0 ;
66701: LD_ADDR_VAR 0 5
66705: PUSH
66706: LD_INT 0
66708: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66709: LD_EXP 63
66713: PUSH
66714: LD_VAR 0 2
66718: ARRAY
66719: PUSH
66720: LD_INT 1
66722: ARRAY
66723: PUSH
66724: LD_INT 1
66726: ARRAY
66727: PPUSH
66728: CALL 23346 0 1
66732: PUSH
66733: LD_EXP 58
66737: PUSH
66738: LD_VAR 0 2
66742: ARRAY
66743: PPUSH
66744: LD_INT 2
66746: PUSH
66747: LD_INT 30
66749: PUSH
66750: LD_INT 2
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 30
66759: PUSH
66760: LD_INT 3
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: LIST
66771: PPUSH
66772: CALL_OW 72
66776: NOT
66777: AND
66778: IFFALSE 66883
// begin for j = 1 to mc_build_list [ i ] do
66780: LD_ADDR_VAR 0 3
66784: PUSH
66785: DOUBLE
66786: LD_INT 1
66788: DEC
66789: ST_TO_ADDR
66790: LD_EXP 63
66794: PUSH
66795: LD_VAR 0 2
66799: ARRAY
66800: PUSH
66801: FOR_TO
66802: IFFALSE 66881
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66804: LD_EXP 63
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PUSH
66815: LD_VAR 0 3
66819: ARRAY
66820: PUSH
66821: LD_INT 1
66823: ARRAY
66824: PUSH
66825: LD_INT 2
66827: EQUAL
66828: IFFALSE 66879
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66830: LD_ADDR_EXP 63
66834: PUSH
66835: LD_EXP 63
66839: PPUSH
66840: LD_VAR 0 2
66844: PPUSH
66845: LD_EXP 63
66849: PUSH
66850: LD_VAR 0 2
66854: ARRAY
66855: PPUSH
66856: LD_VAR 0 3
66860: PPUSH
66861: LD_INT 1
66863: PPUSH
66864: LD_INT 0
66866: PPUSH
66867: CALL 20083 0 4
66871: PPUSH
66872: CALL_OW 1
66876: ST_TO_ADDR
// break ;
66877: GO 66881
// end ;
66879: GO 66801
66881: POP
66882: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66883: LD_EXP 63
66887: PUSH
66888: LD_VAR 0 2
66892: ARRAY
66893: PUSH
66894: LD_INT 1
66896: ARRAY
66897: PUSH
66898: LD_INT 1
66900: ARRAY
66901: PUSH
66902: LD_INT 0
66904: EQUAL
66905: PUSH
66906: LD_VAR 0 5
66910: PUSH
66911: LD_VAR 0 5
66915: PPUSH
66916: LD_EXP 63
66920: PUSH
66921: LD_VAR 0 2
66925: ARRAY
66926: PUSH
66927: LD_INT 1
66929: ARRAY
66930: PUSH
66931: LD_INT 1
66933: ARRAY
66934: PPUSH
66935: LD_EXP 63
66939: PUSH
66940: LD_VAR 0 2
66944: ARRAY
66945: PUSH
66946: LD_INT 1
66948: ARRAY
66949: PUSH
66950: LD_INT 2
66952: ARRAY
66953: PPUSH
66954: LD_EXP 63
66958: PUSH
66959: LD_VAR 0 2
66963: ARRAY
66964: PUSH
66965: LD_INT 1
66967: ARRAY
66968: PUSH
66969: LD_INT 3
66971: ARRAY
66972: PPUSH
66973: LD_EXP 63
66977: PUSH
66978: LD_VAR 0 2
66982: ARRAY
66983: PUSH
66984: LD_INT 1
66986: ARRAY
66987: PUSH
66988: LD_INT 4
66990: ARRAY
66991: PPUSH
66992: CALL 28062 0 5
66996: AND
66997: OR
66998: IFFALSE 67279
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67000: LD_ADDR_VAR 0 4
67004: PUSH
67005: LD_EXP 58
67009: PUSH
67010: LD_VAR 0 2
67014: ARRAY
67015: PPUSH
67016: LD_INT 25
67018: PUSH
67019: LD_INT 2
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PPUSH
67026: CALL_OW 72
67030: PUSH
67031: LD_EXP 60
67035: PUSH
67036: LD_VAR 0 2
67040: ARRAY
67041: DIFF
67042: ST_TO_ADDR
// if not tmp then
67043: LD_VAR 0 4
67047: NOT
67048: IFFALSE 67052
// continue ;
67050: GO 66297
// for j in tmp do
67052: LD_ADDR_VAR 0 3
67056: PUSH
67057: LD_VAR 0 4
67061: PUSH
67062: FOR_IN
67063: IFFALSE 67275
// begin if not mc_builders [ i ] then
67065: LD_EXP 64
67069: PUSH
67070: LD_VAR 0 2
67074: ARRAY
67075: NOT
67076: IFFALSE 67134
// begin SetTag ( j , 103 ) ;
67078: LD_VAR 0 3
67082: PPUSH
67083: LD_INT 103
67085: PPUSH
67086: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67090: LD_ADDR_EXP 64
67094: PUSH
67095: LD_EXP 64
67099: PPUSH
67100: LD_VAR 0 2
67104: PUSH
67105: LD_EXP 64
67109: PUSH
67110: LD_VAR 0 2
67114: ARRAY
67115: PUSH
67116: LD_INT 1
67118: PLUS
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PPUSH
67124: LD_VAR 0 3
67128: PPUSH
67129: CALL 20665 0 3
67133: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67134: LD_VAR 0 3
67138: PPUSH
67139: CALL_OW 310
67143: IFFALSE 67154
// ComExitBuilding ( j ) ;
67145: LD_VAR 0 3
67149: PPUSH
67150: CALL_OW 122
// wait ( 3 ) ;
67154: LD_INT 3
67156: PPUSH
67157: CALL_OW 67
// if not mc_build_list [ i ] then
67161: LD_EXP 63
67165: PUSH
67166: LD_VAR 0 2
67170: ARRAY
67171: NOT
67172: IFFALSE 67176
// break ;
67174: GO 67275
// if not HasTask ( j ) then
67176: LD_VAR 0 3
67180: PPUSH
67181: CALL_OW 314
67185: NOT
67186: IFFALSE 67273
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67188: LD_VAR 0 3
67192: PPUSH
67193: LD_EXP 63
67197: PUSH
67198: LD_VAR 0 2
67202: ARRAY
67203: PUSH
67204: LD_INT 1
67206: ARRAY
67207: PUSH
67208: LD_INT 1
67210: ARRAY
67211: PPUSH
67212: LD_EXP 63
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: PUSH
67223: LD_INT 1
67225: ARRAY
67226: PUSH
67227: LD_INT 2
67229: ARRAY
67230: PPUSH
67231: LD_EXP 63
67235: PUSH
67236: LD_VAR 0 2
67240: ARRAY
67241: PUSH
67242: LD_INT 1
67244: ARRAY
67245: PUSH
67246: LD_INT 3
67248: ARRAY
67249: PPUSH
67250: LD_EXP 63
67254: PUSH
67255: LD_VAR 0 2
67259: ARRAY
67260: PUSH
67261: LD_INT 1
67263: ARRAY
67264: PUSH
67265: LD_INT 4
67267: ARRAY
67268: PPUSH
67269: CALL_OW 145
// end ;
67273: GO 67062
67275: POP
67276: POP
// end else
67277: GO 67421
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67279: LD_EXP 58
67283: PUSH
67284: LD_VAR 0 2
67288: ARRAY
67289: PPUSH
67290: LD_EXP 63
67294: PUSH
67295: LD_VAR 0 2
67299: ARRAY
67300: PUSH
67301: LD_INT 1
67303: ARRAY
67304: PUSH
67305: LD_INT 1
67307: ARRAY
67308: PPUSH
67309: LD_EXP 63
67313: PUSH
67314: LD_VAR 0 2
67318: ARRAY
67319: PUSH
67320: LD_INT 1
67322: ARRAY
67323: PUSH
67324: LD_INT 2
67326: ARRAY
67327: PPUSH
67328: LD_EXP 63
67332: PUSH
67333: LD_VAR 0 2
67337: ARRAY
67338: PUSH
67339: LD_INT 1
67341: ARRAY
67342: PUSH
67343: LD_INT 3
67345: ARRAY
67346: PPUSH
67347: LD_EXP 63
67351: PUSH
67352: LD_VAR 0 2
67356: ARRAY
67357: PUSH
67358: LD_INT 1
67360: ARRAY
67361: PUSH
67362: LD_INT 4
67364: ARRAY
67365: PPUSH
67366: CALL 27416 0 5
67370: NOT
67371: IFFALSE 67421
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67373: LD_ADDR_EXP 63
67377: PUSH
67378: LD_EXP 63
67382: PPUSH
67383: LD_VAR 0 2
67387: PPUSH
67388: LD_EXP 63
67392: PUSH
67393: LD_VAR 0 2
67397: ARRAY
67398: PPUSH
67399: LD_INT 1
67401: PPUSH
67402: LD_INT 1
67404: NEG
67405: PPUSH
67406: LD_INT 0
67408: PPUSH
67409: CALL 20083 0 4
67413: PPUSH
67414: CALL_OW 1
67418: ST_TO_ADDR
// continue ;
67419: GO 66297
// end ; end ; end ;
67421: GO 66297
67423: POP
67424: POP
// end ;
67425: LD_VAR 0 1
67429: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67430: LD_INT 0
67432: PPUSH
67433: PPUSH
67434: PPUSH
67435: PPUSH
67436: PPUSH
67437: PPUSH
// if not mc_bases then
67438: LD_EXP 58
67442: NOT
67443: IFFALSE 67447
// exit ;
67445: GO 67874
// for i = 1 to mc_bases do
67447: LD_ADDR_VAR 0 2
67451: PUSH
67452: DOUBLE
67453: LD_INT 1
67455: DEC
67456: ST_TO_ADDR
67457: LD_EXP 58
67461: PUSH
67462: FOR_TO
67463: IFFALSE 67872
// begin tmp := mc_build_upgrade [ i ] ;
67465: LD_ADDR_VAR 0 4
67469: PUSH
67470: LD_EXP 90
67474: PUSH
67475: LD_VAR 0 2
67479: ARRAY
67480: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67481: LD_ADDR_VAR 0 6
67485: PUSH
67486: LD_EXP 91
67490: PUSH
67491: LD_VAR 0 2
67495: ARRAY
67496: PPUSH
67497: LD_INT 2
67499: PUSH
67500: LD_INT 30
67502: PUSH
67503: LD_INT 6
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 30
67512: PUSH
67513: LD_INT 7
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: LIST
67524: PPUSH
67525: CALL_OW 72
67529: ST_TO_ADDR
// if not tmp and not lab then
67530: LD_VAR 0 4
67534: NOT
67535: PUSH
67536: LD_VAR 0 6
67540: NOT
67541: AND
67542: IFFALSE 67546
// continue ;
67544: GO 67462
// if tmp then
67546: LD_VAR 0 4
67550: IFFALSE 67670
// for j in tmp do
67552: LD_ADDR_VAR 0 3
67556: PUSH
67557: LD_VAR 0 4
67561: PUSH
67562: FOR_IN
67563: IFFALSE 67668
// begin if UpgradeCost ( j ) then
67565: LD_VAR 0 3
67569: PPUSH
67570: CALL 27076 0 1
67574: IFFALSE 67666
// begin ComUpgrade ( j ) ;
67576: LD_VAR 0 3
67580: PPUSH
67581: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67585: LD_ADDR_EXP 90
67589: PUSH
67590: LD_EXP 90
67594: PPUSH
67595: LD_VAR 0 2
67599: PPUSH
67600: LD_EXP 90
67604: PUSH
67605: LD_VAR 0 2
67609: ARRAY
67610: PUSH
67611: LD_VAR 0 3
67615: DIFF
67616: PPUSH
67617: CALL_OW 1
67621: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67622: LD_ADDR_EXP 65
67626: PUSH
67627: LD_EXP 65
67631: PPUSH
67632: LD_VAR 0 2
67636: PUSH
67637: LD_EXP 65
67641: PUSH
67642: LD_VAR 0 2
67646: ARRAY
67647: PUSH
67648: LD_INT 1
67650: PLUS
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PPUSH
67656: LD_VAR 0 3
67660: PPUSH
67661: CALL 20665 0 3
67665: ST_TO_ADDR
// end ; end ;
67666: GO 67562
67668: POP
67669: POP
// if not lab or not mc_lab_upgrade [ i ] then
67670: LD_VAR 0 6
67674: NOT
67675: PUSH
67676: LD_EXP 92
67680: PUSH
67681: LD_VAR 0 2
67685: ARRAY
67686: NOT
67687: OR
67688: IFFALSE 67692
// continue ;
67690: GO 67462
// for j in lab do
67692: LD_ADDR_VAR 0 3
67696: PUSH
67697: LD_VAR 0 6
67701: PUSH
67702: FOR_IN
67703: IFFALSE 67868
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67705: LD_VAR 0 3
67709: PPUSH
67710: CALL_OW 266
67714: PUSH
67715: LD_INT 6
67717: PUSH
67718: LD_INT 7
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: IN
67725: PUSH
67726: LD_VAR 0 3
67730: PPUSH
67731: CALL_OW 461
67735: PUSH
67736: LD_INT 1
67738: NONEQUAL
67739: AND
67740: IFFALSE 67866
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67742: LD_VAR 0 3
67746: PPUSH
67747: LD_EXP 92
67751: PUSH
67752: LD_VAR 0 2
67756: ARRAY
67757: PUSH
67758: LD_INT 1
67760: ARRAY
67761: PPUSH
67762: CALL 27281 0 2
67766: IFFALSE 67866
// begin ComCancel ( j ) ;
67768: LD_VAR 0 3
67772: PPUSH
67773: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67777: LD_VAR 0 3
67781: PPUSH
67782: LD_EXP 92
67786: PUSH
67787: LD_VAR 0 2
67791: ARRAY
67792: PUSH
67793: LD_INT 1
67795: ARRAY
67796: PPUSH
67797: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67801: LD_VAR 0 3
67805: PUSH
67806: LD_EXP 65
67810: PUSH
67811: LD_VAR 0 2
67815: ARRAY
67816: IN
67817: NOT
67818: IFFALSE 67864
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67820: LD_ADDR_EXP 65
67824: PUSH
67825: LD_EXP 65
67829: PPUSH
67830: LD_VAR 0 2
67834: PUSH
67835: LD_EXP 65
67839: PUSH
67840: LD_VAR 0 2
67844: ARRAY
67845: PUSH
67846: LD_INT 1
67848: PLUS
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PPUSH
67854: LD_VAR 0 3
67858: PPUSH
67859: CALL 20665 0 3
67863: ST_TO_ADDR
// break ;
67864: GO 67868
// end ; end ; end ;
67866: GO 67702
67868: POP
67869: POP
// end ;
67870: GO 67462
67872: POP
67873: POP
// end ;
67874: LD_VAR 0 1
67878: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67879: LD_INT 0
67881: PPUSH
67882: PPUSH
67883: PPUSH
67884: PPUSH
67885: PPUSH
67886: PPUSH
67887: PPUSH
67888: PPUSH
67889: PPUSH
// if not mc_bases then
67890: LD_EXP 58
67894: NOT
67895: IFFALSE 67899
// exit ;
67897: GO 68304
// for i = 1 to mc_bases do
67899: LD_ADDR_VAR 0 2
67903: PUSH
67904: DOUBLE
67905: LD_INT 1
67907: DEC
67908: ST_TO_ADDR
67909: LD_EXP 58
67913: PUSH
67914: FOR_TO
67915: IFFALSE 68302
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67917: LD_EXP 66
67921: PUSH
67922: LD_VAR 0 2
67926: ARRAY
67927: NOT
67928: PUSH
67929: LD_EXP 58
67933: PUSH
67934: LD_VAR 0 2
67938: ARRAY
67939: PPUSH
67940: LD_INT 30
67942: PUSH
67943: LD_INT 3
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PPUSH
67950: CALL_OW 72
67954: NOT
67955: OR
67956: IFFALSE 67960
// continue ;
67958: GO 67914
// busy := false ;
67960: LD_ADDR_VAR 0 8
67964: PUSH
67965: LD_INT 0
67967: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67968: LD_ADDR_VAR 0 4
67972: PUSH
67973: LD_EXP 58
67977: PUSH
67978: LD_VAR 0 2
67982: ARRAY
67983: PPUSH
67984: LD_INT 30
67986: PUSH
67987: LD_INT 3
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PPUSH
67994: CALL_OW 72
67998: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67999: LD_ADDR_VAR 0 6
68003: PUSH
68004: LD_EXP 66
68008: PUSH
68009: LD_VAR 0 2
68013: ARRAY
68014: PPUSH
68015: LD_INT 2
68017: PUSH
68018: LD_INT 30
68020: PUSH
68021: LD_INT 32
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 30
68030: PUSH
68031: LD_INT 33
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: LIST
68042: PPUSH
68043: CALL_OW 72
68047: ST_TO_ADDR
// if not t then
68048: LD_VAR 0 6
68052: NOT
68053: IFFALSE 68057
// continue ;
68055: GO 67914
// for j in tmp do
68057: LD_ADDR_VAR 0 3
68061: PUSH
68062: LD_VAR 0 4
68066: PUSH
68067: FOR_IN
68068: IFFALSE 68098
// if not BuildingStatus ( j ) = bs_idle then
68070: LD_VAR 0 3
68074: PPUSH
68075: CALL_OW 461
68079: PUSH
68080: LD_INT 2
68082: EQUAL
68083: NOT
68084: IFFALSE 68096
// begin busy := true ;
68086: LD_ADDR_VAR 0 8
68090: PUSH
68091: LD_INT 1
68093: ST_TO_ADDR
// break ;
68094: GO 68098
// end ;
68096: GO 68067
68098: POP
68099: POP
// if busy then
68100: LD_VAR 0 8
68104: IFFALSE 68108
// continue ;
68106: GO 67914
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68108: LD_ADDR_VAR 0 7
68112: PUSH
68113: LD_VAR 0 6
68117: PPUSH
68118: LD_INT 35
68120: PUSH
68121: LD_INT 0
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PPUSH
68128: CALL_OW 72
68132: ST_TO_ADDR
// if tw then
68133: LD_VAR 0 7
68137: IFFALSE 68214
// begin tw := tw [ 1 ] ;
68139: LD_ADDR_VAR 0 7
68143: PUSH
68144: LD_VAR 0 7
68148: PUSH
68149: LD_INT 1
68151: ARRAY
68152: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68153: LD_ADDR_VAR 0 9
68157: PUSH
68158: LD_VAR 0 7
68162: PPUSH
68163: LD_EXP 83
68167: PUSH
68168: LD_VAR 0 2
68172: ARRAY
68173: PPUSH
68174: CALL 25635 0 2
68178: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68179: LD_EXP 97
68183: PUSH
68184: LD_VAR 0 2
68188: ARRAY
68189: IFFALSE 68212
// if not weapon in mc_allowed_tower_weapons [ i ] then
68191: LD_VAR 0 9
68195: PUSH
68196: LD_EXP 97
68200: PUSH
68201: LD_VAR 0 2
68205: ARRAY
68206: IN
68207: NOT
68208: IFFALSE 68212
// continue ;
68210: GO 67914
// end else
68212: GO 68277
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68214: LD_ADDR_VAR 0 5
68218: PUSH
68219: LD_EXP 66
68223: PUSH
68224: LD_VAR 0 2
68228: ARRAY
68229: PPUSH
68230: LD_VAR 0 4
68234: PPUSH
68235: CALL 55812 0 2
68239: ST_TO_ADDR
// if not tmp2 then
68240: LD_VAR 0 5
68244: NOT
68245: IFFALSE 68249
// continue ;
68247: GO 67914
// tw := tmp2 [ 1 ] ;
68249: LD_ADDR_VAR 0 7
68253: PUSH
68254: LD_VAR 0 5
68258: PUSH
68259: LD_INT 1
68261: ARRAY
68262: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68263: LD_ADDR_VAR 0 9
68267: PUSH
68268: LD_VAR 0 5
68272: PUSH
68273: LD_INT 2
68275: ARRAY
68276: ST_TO_ADDR
// end ; if not weapon then
68277: LD_VAR 0 9
68281: NOT
68282: IFFALSE 68286
// continue ;
68284: GO 67914
// ComPlaceWeapon ( tw , weapon ) ;
68286: LD_VAR 0 7
68290: PPUSH
68291: LD_VAR 0 9
68295: PPUSH
68296: CALL_OW 148
// end ;
68300: GO 67914
68302: POP
68303: POP
// end ;
68304: LD_VAR 0 1
68308: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68309: LD_INT 0
68311: PPUSH
68312: PPUSH
68313: PPUSH
68314: PPUSH
68315: PPUSH
68316: PPUSH
// if not mc_bases then
68317: LD_EXP 58
68321: NOT
68322: IFFALSE 68326
// exit ;
68324: GO 69338
// for i = 1 to mc_bases do
68326: LD_ADDR_VAR 0 2
68330: PUSH
68331: DOUBLE
68332: LD_INT 1
68334: DEC
68335: ST_TO_ADDR
68336: LD_EXP 58
68340: PUSH
68341: FOR_TO
68342: IFFALSE 69336
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68344: LD_EXP 71
68348: PUSH
68349: LD_VAR 0 2
68353: ARRAY
68354: NOT
68355: PUSH
68356: LD_EXP 71
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: PUSH
68367: LD_EXP 72
68371: PUSH
68372: LD_VAR 0 2
68376: ARRAY
68377: EQUAL
68378: OR
68379: IFFALSE 68383
// continue ;
68381: GO 68341
// if mc_miners [ i ] then
68383: LD_EXP 72
68387: PUSH
68388: LD_VAR 0 2
68392: ARRAY
68393: IFFALSE 69023
// begin k := 1 ;
68395: LD_ADDR_VAR 0 4
68399: PUSH
68400: LD_INT 1
68402: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
68403: LD_ADDR_VAR 0 3
68407: PUSH
68408: DOUBLE
68409: LD_EXP 72
68413: PUSH
68414: LD_VAR 0 2
68418: ARRAY
68419: INC
68420: ST_TO_ADDR
68421: LD_INT 1
68423: PUSH
68424: FOR_DOWNTO
68425: IFFALSE 69021
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68427: LD_EXP 72
68431: PUSH
68432: LD_VAR 0 2
68436: ARRAY
68437: PUSH
68438: LD_VAR 0 3
68442: ARRAY
68443: PPUSH
68444: CALL_OW 301
68448: PUSH
68449: LD_EXP 72
68453: PUSH
68454: LD_VAR 0 2
68458: ARRAY
68459: PUSH
68460: LD_VAR 0 3
68464: ARRAY
68465: PPUSH
68466: CALL_OW 257
68470: PUSH
68471: LD_INT 1
68473: NONEQUAL
68474: OR
68475: IFFALSE 68538
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68477: LD_ADDR_VAR 0 5
68481: PUSH
68482: LD_EXP 72
68486: PUSH
68487: LD_VAR 0 2
68491: ARRAY
68492: PUSH
68493: LD_EXP 72
68497: PUSH
68498: LD_VAR 0 2
68502: ARRAY
68503: PUSH
68504: LD_VAR 0 3
68508: ARRAY
68509: DIFF
68510: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68511: LD_ADDR_EXP 72
68515: PUSH
68516: LD_EXP 72
68520: PPUSH
68521: LD_VAR 0 2
68525: PPUSH
68526: LD_VAR 0 5
68530: PPUSH
68531: CALL_OW 1
68535: ST_TO_ADDR
// continue ;
68536: GO 68424
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
68538: LD_EXP 72
68542: PUSH
68543: LD_VAR 0 2
68547: ARRAY
68548: PUSH
68549: LD_VAR 0 3
68553: ARRAY
68554: PPUSH
68555: CALL 20601 0 1
68559: PUSH
68560: LD_EXP 72
68564: PUSH
68565: LD_VAR 0 2
68569: ARRAY
68570: PUSH
68571: LD_VAR 0 3
68575: ARRAY
68576: PPUSH
68577: CALL_OW 255
68581: PPUSH
68582: LD_EXP 71
68586: PUSH
68587: LD_VAR 0 2
68591: ARRAY
68592: PUSH
68593: LD_VAR 0 4
68597: ARRAY
68598: PUSH
68599: LD_INT 1
68601: ARRAY
68602: PPUSH
68603: LD_EXP 71
68607: PUSH
68608: LD_VAR 0 2
68612: ARRAY
68613: PUSH
68614: LD_VAR 0 4
68618: ARRAY
68619: PUSH
68620: LD_INT 2
68622: ARRAY
68623: PPUSH
68624: LD_INT 15
68626: PPUSH
68627: CALL 21561 0 4
68631: PUSH
68632: LD_INT 4
68634: ARRAY
68635: PUSH
68636: LD_EXP 72
68640: PUSH
68641: LD_VAR 0 2
68645: ARRAY
68646: PUSH
68647: LD_VAR 0 3
68651: ARRAY
68652: PPUSH
68653: LD_INT 10
68655: PPUSH
68656: CALL 23258 0 2
68660: PUSH
68661: LD_INT 4
68663: ARRAY
68664: OR
68665: AND
68666: IFFALSE 68689
// ComStop ( mc_miners [ i ] [ j ] ) ;
68668: LD_EXP 72
68672: PUSH
68673: LD_VAR 0 2
68677: ARRAY
68678: PUSH
68679: LD_VAR 0 3
68683: ARRAY
68684: PPUSH
68685: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
68689: LD_EXP 72
68693: PUSH
68694: LD_VAR 0 2
68698: ARRAY
68699: PUSH
68700: LD_VAR 0 3
68704: ARRAY
68705: PPUSH
68706: CALL_OW 257
68710: PUSH
68711: LD_INT 1
68713: EQUAL
68714: PUSH
68715: LD_EXP 72
68719: PUSH
68720: LD_VAR 0 2
68724: ARRAY
68725: PUSH
68726: LD_VAR 0 3
68730: ARRAY
68731: PPUSH
68732: CALL_OW 459
68736: NOT
68737: AND
68738: PUSH
68739: LD_EXP 72
68743: PUSH
68744: LD_VAR 0 2
68748: ARRAY
68749: PUSH
68750: LD_VAR 0 3
68754: ARRAY
68755: PPUSH
68756: CALL_OW 255
68760: PPUSH
68761: LD_EXP 71
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: PUSH
68772: LD_VAR 0 4
68776: ARRAY
68777: PUSH
68778: LD_INT 1
68780: ARRAY
68781: PPUSH
68782: LD_EXP 71
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_VAR 0 4
68797: ARRAY
68798: PUSH
68799: LD_INT 2
68801: ARRAY
68802: PPUSH
68803: LD_INT 15
68805: PPUSH
68806: CALL 21561 0 4
68810: PUSH
68811: LD_INT 4
68813: ARRAY
68814: PUSH
68815: LD_INT 0
68817: EQUAL
68818: AND
68819: PUSH
68820: LD_EXP 72
68824: PUSH
68825: LD_VAR 0 2
68829: ARRAY
68830: PUSH
68831: LD_VAR 0 3
68835: ARRAY
68836: PPUSH
68837: CALL_OW 314
68841: NOT
68842: AND
68843: IFFALSE 69019
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68845: LD_EXP 72
68849: PUSH
68850: LD_VAR 0 2
68854: ARRAY
68855: PUSH
68856: LD_VAR 0 3
68860: ARRAY
68861: PPUSH
68862: CALL_OW 310
68866: IFFALSE 68889
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68868: LD_EXP 72
68872: PUSH
68873: LD_VAR 0 2
68877: ARRAY
68878: PUSH
68879: LD_VAR 0 3
68883: ARRAY
68884: PPUSH
68885: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68889: LD_EXP 72
68893: PUSH
68894: LD_VAR 0 2
68898: ARRAY
68899: PUSH
68900: LD_VAR 0 3
68904: ARRAY
68905: PPUSH
68906: CALL_OW 314
68910: NOT
68911: IFFALSE 68979
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
68913: LD_EXP 72
68917: PUSH
68918: LD_VAR 0 2
68922: ARRAY
68923: PUSH
68924: LD_VAR 0 3
68928: ARRAY
68929: PPUSH
68930: LD_EXP 71
68934: PUSH
68935: LD_VAR 0 2
68939: ARRAY
68940: PUSH
68941: LD_VAR 0 4
68945: ARRAY
68946: PUSH
68947: LD_INT 1
68949: ARRAY
68950: PPUSH
68951: LD_EXP 71
68955: PUSH
68956: LD_VAR 0 2
68960: ARRAY
68961: PUSH
68962: LD_VAR 0 4
68966: ARRAY
68967: PUSH
68968: LD_INT 2
68970: ARRAY
68971: PPUSH
68972: LD_INT 0
68974: PPUSH
68975: CALL_OW 193
// k := k + 1 ;
68979: LD_ADDR_VAR 0 4
68983: PUSH
68984: LD_VAR 0 4
68988: PUSH
68989: LD_INT 1
68991: PLUS
68992: ST_TO_ADDR
// if k > mc_mines [ i ] then
68993: LD_VAR 0 4
68997: PUSH
68998: LD_EXP 71
69002: PUSH
69003: LD_VAR 0 2
69007: ARRAY
69008: GREATER
69009: IFFALSE 69019
// k := 1 ;
69011: LD_ADDR_VAR 0 4
69015: PUSH
69016: LD_INT 1
69018: ST_TO_ADDR
// end ; end ;
69019: GO 68424
69021: POP
69022: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69023: LD_ADDR_VAR 0 5
69027: PUSH
69028: LD_EXP 58
69032: PUSH
69033: LD_VAR 0 2
69037: ARRAY
69038: PPUSH
69039: LD_INT 2
69041: PUSH
69042: LD_INT 30
69044: PUSH
69045: LD_INT 4
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 30
69054: PUSH
69055: LD_INT 5
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 30
69064: PUSH
69065: LD_INT 32
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: PPUSH
69078: CALL_OW 72
69082: ST_TO_ADDR
// if not tmp then
69083: LD_VAR 0 5
69087: NOT
69088: IFFALSE 69092
// continue ;
69090: GO 68341
// list := [ ] ;
69092: LD_ADDR_VAR 0 6
69096: PUSH
69097: EMPTY
69098: ST_TO_ADDR
// for j in tmp do
69099: LD_ADDR_VAR 0 3
69103: PUSH
69104: LD_VAR 0 5
69108: PUSH
69109: FOR_IN
69110: IFFALSE 69179
// begin for k in UnitsInside ( j ) do
69112: LD_ADDR_VAR 0 4
69116: PUSH
69117: LD_VAR 0 3
69121: PPUSH
69122: CALL_OW 313
69126: PUSH
69127: FOR_IN
69128: IFFALSE 69175
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69130: LD_VAR 0 4
69134: PPUSH
69135: CALL_OW 257
69139: PUSH
69140: LD_INT 1
69142: EQUAL
69143: PUSH
69144: LD_VAR 0 4
69148: PPUSH
69149: CALL_OW 459
69153: NOT
69154: AND
69155: IFFALSE 69173
// list := list ^ k ;
69157: LD_ADDR_VAR 0 6
69161: PUSH
69162: LD_VAR 0 6
69166: PUSH
69167: LD_VAR 0 4
69171: ADD
69172: ST_TO_ADDR
69173: GO 69127
69175: POP
69176: POP
// end ;
69177: GO 69109
69179: POP
69180: POP
// list := list diff mc_miners [ i ] ;
69181: LD_ADDR_VAR 0 6
69185: PUSH
69186: LD_VAR 0 6
69190: PUSH
69191: LD_EXP 72
69195: PUSH
69196: LD_VAR 0 2
69200: ARRAY
69201: DIFF
69202: ST_TO_ADDR
// if not list then
69203: LD_VAR 0 6
69207: NOT
69208: IFFALSE 69212
// continue ;
69210: GO 68341
// k := mc_mines [ i ] - mc_miners [ i ] ;
69212: LD_ADDR_VAR 0 4
69216: PUSH
69217: LD_EXP 71
69221: PUSH
69222: LD_VAR 0 2
69226: ARRAY
69227: PUSH
69228: LD_EXP 72
69232: PUSH
69233: LD_VAR 0 2
69237: ARRAY
69238: MINUS
69239: ST_TO_ADDR
// if k > list then
69240: LD_VAR 0 4
69244: PUSH
69245: LD_VAR 0 6
69249: GREATER
69250: IFFALSE 69262
// k := list ;
69252: LD_ADDR_VAR 0 4
69256: PUSH
69257: LD_VAR 0 6
69261: ST_TO_ADDR
// for j = 1 to k do
69262: LD_ADDR_VAR 0 3
69266: PUSH
69267: DOUBLE
69268: LD_INT 1
69270: DEC
69271: ST_TO_ADDR
69272: LD_VAR 0 4
69276: PUSH
69277: FOR_TO
69278: IFFALSE 69332
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69280: LD_ADDR_EXP 72
69284: PUSH
69285: LD_EXP 72
69289: PPUSH
69290: LD_VAR 0 2
69294: PUSH
69295: LD_EXP 72
69299: PUSH
69300: LD_VAR 0 2
69304: ARRAY
69305: PUSH
69306: LD_INT 1
69308: PLUS
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PPUSH
69314: LD_VAR 0 6
69318: PUSH
69319: LD_VAR 0 3
69323: ARRAY
69324: PPUSH
69325: CALL 20665 0 3
69329: ST_TO_ADDR
69330: GO 69277
69332: POP
69333: POP
// end ;
69334: GO 68341
69336: POP
69337: POP
// end ;
69338: LD_VAR 0 1
69342: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69343: LD_INT 0
69345: PPUSH
69346: PPUSH
69347: PPUSH
69348: PPUSH
69349: PPUSH
69350: PPUSH
69351: PPUSH
69352: PPUSH
69353: PPUSH
69354: PPUSH
// if not mc_bases then
69355: LD_EXP 58
69359: NOT
69360: IFFALSE 69364
// exit ;
69362: GO 71095
// for i = 1 to mc_bases do
69364: LD_ADDR_VAR 0 2
69368: PUSH
69369: DOUBLE
69370: LD_INT 1
69372: DEC
69373: ST_TO_ADDR
69374: LD_EXP 58
69378: PUSH
69379: FOR_TO
69380: IFFALSE 71093
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69382: LD_EXP 58
69386: PUSH
69387: LD_VAR 0 2
69391: ARRAY
69392: NOT
69393: PUSH
69394: LD_EXP 65
69398: PUSH
69399: LD_VAR 0 2
69403: ARRAY
69404: OR
69405: IFFALSE 69409
// continue ;
69407: GO 69379
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69409: LD_EXP 74
69413: PUSH
69414: LD_VAR 0 2
69418: ARRAY
69419: NOT
69420: PUSH
69421: LD_EXP 75
69425: PUSH
69426: LD_VAR 0 2
69430: ARRAY
69431: AND
69432: IFFALSE 69470
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69434: LD_ADDR_EXP 75
69438: PUSH
69439: LD_EXP 75
69443: PPUSH
69444: LD_VAR 0 2
69448: PPUSH
69449: EMPTY
69450: PPUSH
69451: CALL_OW 1
69455: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69456: LD_VAR 0 2
69460: PPUSH
69461: LD_INT 107
69463: PPUSH
69464: CALL 60559 0 2
// continue ;
69468: GO 69379
// end ; target := [ ] ;
69470: LD_ADDR_VAR 0 6
69474: PUSH
69475: EMPTY
69476: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69477: LD_ADDR_VAR 0 3
69481: PUSH
69482: DOUBLE
69483: LD_EXP 74
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: INC
69494: ST_TO_ADDR
69495: LD_INT 1
69497: PUSH
69498: FOR_DOWNTO
69499: IFFALSE 69759
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69501: LD_EXP 74
69505: PUSH
69506: LD_VAR 0 2
69510: ARRAY
69511: PUSH
69512: LD_VAR 0 3
69516: ARRAY
69517: PUSH
69518: LD_INT 2
69520: ARRAY
69521: PPUSH
69522: LD_EXP 74
69526: PUSH
69527: LD_VAR 0 2
69531: ARRAY
69532: PUSH
69533: LD_VAR 0 3
69537: ARRAY
69538: PUSH
69539: LD_INT 3
69541: ARRAY
69542: PPUSH
69543: CALL_OW 488
69547: PUSH
69548: LD_EXP 74
69552: PUSH
69553: LD_VAR 0 2
69557: ARRAY
69558: PUSH
69559: LD_VAR 0 3
69563: ARRAY
69564: PUSH
69565: LD_INT 2
69567: ARRAY
69568: PPUSH
69569: LD_EXP 74
69573: PUSH
69574: LD_VAR 0 2
69578: ARRAY
69579: PUSH
69580: LD_VAR 0 3
69584: ARRAY
69585: PUSH
69586: LD_INT 3
69588: ARRAY
69589: PPUSH
69590: CALL_OW 284
69594: PUSH
69595: LD_INT 0
69597: EQUAL
69598: AND
69599: IFFALSE 69654
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69601: LD_ADDR_VAR 0 5
69605: PUSH
69606: LD_EXP 74
69610: PUSH
69611: LD_VAR 0 2
69615: ARRAY
69616: PPUSH
69617: LD_VAR 0 3
69621: PPUSH
69622: CALL_OW 3
69626: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69627: LD_ADDR_EXP 74
69631: PUSH
69632: LD_EXP 74
69636: PPUSH
69637: LD_VAR 0 2
69641: PPUSH
69642: LD_VAR 0 5
69646: PPUSH
69647: CALL_OW 1
69651: ST_TO_ADDR
// continue ;
69652: GO 69498
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69654: LD_EXP 58
69658: PUSH
69659: LD_VAR 0 2
69663: ARRAY
69664: PUSH
69665: LD_INT 1
69667: ARRAY
69668: PPUSH
69669: CALL_OW 255
69673: PPUSH
69674: LD_EXP 74
69678: PUSH
69679: LD_VAR 0 2
69683: ARRAY
69684: PUSH
69685: LD_VAR 0 3
69689: ARRAY
69690: PUSH
69691: LD_INT 2
69693: ARRAY
69694: PPUSH
69695: LD_EXP 74
69699: PUSH
69700: LD_VAR 0 2
69704: ARRAY
69705: PUSH
69706: LD_VAR 0 3
69710: ARRAY
69711: PUSH
69712: LD_INT 3
69714: ARRAY
69715: PPUSH
69716: LD_INT 30
69718: PPUSH
69719: CALL 21561 0 4
69723: PUSH
69724: LD_INT 4
69726: ARRAY
69727: PUSH
69728: LD_INT 0
69730: EQUAL
69731: IFFALSE 69757
// begin target := mc_crates [ i ] [ j ] ;
69733: LD_ADDR_VAR 0 6
69737: PUSH
69738: LD_EXP 74
69742: PUSH
69743: LD_VAR 0 2
69747: ARRAY
69748: PUSH
69749: LD_VAR 0 3
69753: ARRAY
69754: ST_TO_ADDR
// break ;
69755: GO 69759
// end ; end ;
69757: GO 69498
69759: POP
69760: POP
// if not target then
69761: LD_VAR 0 6
69765: NOT
69766: IFFALSE 69770
// continue ;
69768: GO 69379
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69770: LD_ADDR_VAR 0 7
69774: PUSH
69775: LD_EXP 77
69779: PUSH
69780: LD_VAR 0 2
69784: ARRAY
69785: PPUSH
69786: LD_INT 2
69788: PUSH
69789: LD_INT 3
69791: PUSH
69792: LD_INT 58
69794: PUSH
69795: EMPTY
69796: LIST
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 61
69804: PUSH
69805: EMPTY
69806: LIST
69807: PUSH
69808: LD_INT 33
69810: PUSH
69811: LD_INT 5
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 33
69820: PUSH
69821: LD_INT 3
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 2
69837: PUSH
69838: LD_INT 34
69840: PUSH
69841: LD_INT 32
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 34
69850: PUSH
69851: LD_INT 51
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 34
69860: PUSH
69861: LD_INT 12
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PPUSH
69878: CALL_OW 72
69882: ST_TO_ADDR
// if not cargo then
69883: LD_VAR 0 7
69887: NOT
69888: IFFALSE 70531
// begin if mc_crates_collector [ i ] < 5 then
69890: LD_EXP 75
69894: PUSH
69895: LD_VAR 0 2
69899: ARRAY
69900: PUSH
69901: LD_INT 5
69903: LESS
69904: IFFALSE 70270
// begin if mc_ape [ i ] then
69906: LD_EXP 87
69910: PUSH
69911: LD_VAR 0 2
69915: ARRAY
69916: IFFALSE 69963
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69918: LD_ADDR_VAR 0 5
69922: PUSH
69923: LD_EXP 87
69927: PUSH
69928: LD_VAR 0 2
69932: ARRAY
69933: PPUSH
69934: LD_INT 25
69936: PUSH
69937: LD_INT 16
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 24
69946: PUSH
69947: LD_INT 750
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PPUSH
69958: CALL_OW 72
69962: ST_TO_ADDR
// if not tmp then
69963: LD_VAR 0 5
69967: NOT
69968: IFFALSE 70015
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69970: LD_ADDR_VAR 0 5
69974: PUSH
69975: LD_EXP 58
69979: PUSH
69980: LD_VAR 0 2
69984: ARRAY
69985: PPUSH
69986: LD_INT 25
69988: PUSH
69989: LD_INT 2
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 24
69998: PUSH
69999: LD_INT 750
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PPUSH
70010: CALL_OW 72
70014: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70015: LD_EXP 87
70019: PUSH
70020: LD_VAR 0 2
70024: ARRAY
70025: PUSH
70026: LD_EXP 58
70030: PUSH
70031: LD_VAR 0 2
70035: ARRAY
70036: PPUSH
70037: LD_INT 25
70039: PUSH
70040: LD_INT 2
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 24
70049: PUSH
70050: LD_INT 750
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PPUSH
70061: CALL_OW 72
70065: AND
70066: PUSH
70067: LD_VAR 0 5
70071: PUSH
70072: LD_INT 5
70074: LESS
70075: AND
70076: IFFALSE 70158
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70078: LD_ADDR_VAR 0 3
70082: PUSH
70083: LD_EXP 58
70087: PUSH
70088: LD_VAR 0 2
70092: ARRAY
70093: PPUSH
70094: LD_INT 25
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 24
70106: PUSH
70107: LD_INT 750
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PPUSH
70118: CALL_OW 72
70122: PUSH
70123: FOR_IN
70124: IFFALSE 70156
// begin tmp := tmp union j ;
70126: LD_ADDR_VAR 0 5
70130: PUSH
70131: LD_VAR 0 5
70135: PUSH
70136: LD_VAR 0 3
70140: UNION
70141: ST_TO_ADDR
// if tmp >= 5 then
70142: LD_VAR 0 5
70146: PUSH
70147: LD_INT 5
70149: GREATEREQUAL
70150: IFFALSE 70154
// break ;
70152: GO 70156
// end ;
70154: GO 70123
70156: POP
70157: POP
// end ; if not tmp then
70158: LD_VAR 0 5
70162: NOT
70163: IFFALSE 70167
// continue ;
70165: GO 69379
// for j in tmp do
70167: LD_ADDR_VAR 0 3
70171: PUSH
70172: LD_VAR 0 5
70176: PUSH
70177: FOR_IN
70178: IFFALSE 70268
// if not GetTag ( j ) then
70180: LD_VAR 0 3
70184: PPUSH
70185: CALL_OW 110
70189: NOT
70190: IFFALSE 70266
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70192: LD_ADDR_EXP 75
70196: PUSH
70197: LD_EXP 75
70201: PPUSH
70202: LD_VAR 0 2
70206: PUSH
70207: LD_EXP 75
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: PUSH
70218: LD_INT 1
70220: PLUS
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PPUSH
70226: LD_VAR 0 3
70230: PPUSH
70231: CALL 20665 0 3
70235: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70236: LD_VAR 0 3
70240: PPUSH
70241: LD_INT 107
70243: PPUSH
70244: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70248: LD_EXP 75
70252: PUSH
70253: LD_VAR 0 2
70257: ARRAY
70258: PUSH
70259: LD_INT 5
70261: GREATEREQUAL
70262: IFFALSE 70266
// break ;
70264: GO 70268
// end ;
70266: GO 70177
70268: POP
70269: POP
// end ; if mc_crates_collector [ i ] and target then
70270: LD_EXP 75
70274: PUSH
70275: LD_VAR 0 2
70279: ARRAY
70280: PUSH
70281: LD_VAR 0 6
70285: AND
70286: IFFALSE 70529
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70288: LD_EXP 75
70292: PUSH
70293: LD_VAR 0 2
70297: ARRAY
70298: PUSH
70299: LD_VAR 0 6
70303: PUSH
70304: LD_INT 1
70306: ARRAY
70307: LESS
70308: IFFALSE 70328
// tmp := mc_crates_collector [ i ] else
70310: LD_ADDR_VAR 0 5
70314: PUSH
70315: LD_EXP 75
70319: PUSH
70320: LD_VAR 0 2
70324: ARRAY
70325: ST_TO_ADDR
70326: GO 70342
// tmp := target [ 1 ] ;
70328: LD_ADDR_VAR 0 5
70332: PUSH
70333: LD_VAR 0 6
70337: PUSH
70338: LD_INT 1
70340: ARRAY
70341: ST_TO_ADDR
// k := 0 ;
70342: LD_ADDR_VAR 0 4
70346: PUSH
70347: LD_INT 0
70349: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70350: LD_ADDR_VAR 0 3
70354: PUSH
70355: LD_EXP 75
70359: PUSH
70360: LD_VAR 0 2
70364: ARRAY
70365: PUSH
70366: FOR_IN
70367: IFFALSE 70527
// begin k := k + 1 ;
70369: LD_ADDR_VAR 0 4
70373: PUSH
70374: LD_VAR 0 4
70378: PUSH
70379: LD_INT 1
70381: PLUS
70382: ST_TO_ADDR
// if k > tmp then
70383: LD_VAR 0 4
70387: PUSH
70388: LD_VAR 0 5
70392: GREATER
70393: IFFALSE 70397
// break ;
70395: GO 70527
// if not GetClass ( j ) in [ 2 , 16 ] then
70397: LD_VAR 0 3
70401: PPUSH
70402: CALL_OW 257
70406: PUSH
70407: LD_INT 2
70409: PUSH
70410: LD_INT 16
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: IN
70417: NOT
70418: IFFALSE 70471
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70420: LD_ADDR_EXP 75
70424: PUSH
70425: LD_EXP 75
70429: PPUSH
70430: LD_VAR 0 2
70434: PPUSH
70435: LD_EXP 75
70439: PUSH
70440: LD_VAR 0 2
70444: ARRAY
70445: PUSH
70446: LD_VAR 0 3
70450: DIFF
70451: PPUSH
70452: CALL_OW 1
70456: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70457: LD_VAR 0 3
70461: PPUSH
70462: LD_INT 0
70464: PPUSH
70465: CALL_OW 109
// continue ;
70469: GO 70366
// end ; if IsInUnit ( j ) then
70471: LD_VAR 0 3
70475: PPUSH
70476: CALL_OW 310
70480: IFFALSE 70491
// ComExitBuilding ( j ) ;
70482: LD_VAR 0 3
70486: PPUSH
70487: CALL_OW 122
// wait ( 3 ) ;
70491: LD_INT 3
70493: PPUSH
70494: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70498: LD_VAR 0 3
70502: PPUSH
70503: LD_VAR 0 6
70507: PUSH
70508: LD_INT 2
70510: ARRAY
70511: PPUSH
70512: LD_VAR 0 6
70516: PUSH
70517: LD_INT 3
70519: ARRAY
70520: PPUSH
70521: CALL_OW 117
// end ;
70525: GO 70366
70527: POP
70528: POP
// end ; end else
70529: GO 71091
// begin for j in cargo do
70531: LD_ADDR_VAR 0 3
70535: PUSH
70536: LD_VAR 0 7
70540: PUSH
70541: FOR_IN
70542: IFFALSE 71089
// begin if GetTag ( j ) <> 0 then
70544: LD_VAR 0 3
70548: PPUSH
70549: CALL_OW 110
70553: PUSH
70554: LD_INT 0
70556: NONEQUAL
70557: IFFALSE 70561
// continue ;
70559: GO 70541
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70561: LD_VAR 0 3
70565: PPUSH
70566: CALL_OW 256
70570: PUSH
70571: LD_INT 1000
70573: LESS
70574: PUSH
70575: LD_VAR 0 3
70579: PPUSH
70580: LD_EXP 82
70584: PUSH
70585: LD_VAR 0 2
70589: ARRAY
70590: PPUSH
70591: CALL_OW 308
70595: NOT
70596: AND
70597: IFFALSE 70619
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70599: LD_VAR 0 3
70603: PPUSH
70604: LD_EXP 82
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: PPUSH
70615: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70619: LD_VAR 0 3
70623: PPUSH
70624: CALL_OW 256
70628: PUSH
70629: LD_INT 1000
70631: LESS
70632: PUSH
70633: LD_VAR 0 3
70637: PPUSH
70638: LD_EXP 82
70642: PUSH
70643: LD_VAR 0 2
70647: ARRAY
70648: PPUSH
70649: CALL_OW 308
70653: AND
70654: IFFALSE 70658
// continue ;
70656: GO 70541
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70658: LD_VAR 0 3
70662: PPUSH
70663: CALL_OW 262
70667: PUSH
70668: LD_INT 2
70670: EQUAL
70671: PUSH
70672: LD_VAR 0 3
70676: PPUSH
70677: CALL_OW 261
70681: PUSH
70682: LD_INT 15
70684: LESS
70685: AND
70686: IFFALSE 70690
// continue ;
70688: GO 70541
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70690: LD_VAR 0 3
70694: PPUSH
70695: CALL_OW 262
70699: PUSH
70700: LD_INT 1
70702: EQUAL
70703: PUSH
70704: LD_VAR 0 3
70708: PPUSH
70709: CALL_OW 261
70713: PUSH
70714: LD_INT 10
70716: LESS
70717: AND
70718: IFFALSE 71028
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70720: LD_ADDR_VAR 0 8
70724: PUSH
70725: LD_EXP 58
70729: PUSH
70730: LD_VAR 0 2
70734: ARRAY
70735: PPUSH
70736: LD_INT 2
70738: PUSH
70739: LD_INT 30
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 30
70751: PUSH
70752: LD_INT 1
70754: PUSH
70755: EMPTY
70756: LIST
70757: LIST
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: LIST
70763: PPUSH
70764: CALL_OW 72
70768: ST_TO_ADDR
// if not depot then
70769: LD_VAR 0 8
70773: NOT
70774: IFFALSE 70778
// continue ;
70776: GO 70541
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70778: LD_VAR 0 3
70782: PPUSH
70783: LD_VAR 0 8
70787: PPUSH
70788: LD_VAR 0 3
70792: PPUSH
70793: CALL_OW 74
70797: PPUSH
70798: CALL_OW 296
70802: PUSH
70803: LD_INT 6
70805: LESS
70806: IFFALSE 70822
// SetFuel ( j , 100 ) else
70808: LD_VAR 0 3
70812: PPUSH
70813: LD_INT 100
70815: PPUSH
70816: CALL_OW 240
70820: GO 71028
// if GetFuel ( j ) = 0 then
70822: LD_VAR 0 3
70826: PPUSH
70827: CALL_OW 261
70831: PUSH
70832: LD_INT 0
70834: EQUAL
70835: IFFALSE 71028
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70837: LD_ADDR_EXP 77
70841: PUSH
70842: LD_EXP 77
70846: PPUSH
70847: LD_VAR 0 2
70851: PPUSH
70852: LD_EXP 77
70856: PUSH
70857: LD_VAR 0 2
70861: ARRAY
70862: PUSH
70863: LD_VAR 0 3
70867: DIFF
70868: PPUSH
70869: CALL_OW 1
70873: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70874: LD_VAR 0 3
70878: PPUSH
70879: CALL_OW 263
70883: PUSH
70884: LD_INT 1
70886: EQUAL
70887: IFFALSE 70903
// ComExitVehicle ( IsInUnit ( j ) ) ;
70889: LD_VAR 0 3
70893: PPUSH
70894: CALL_OW 310
70898: PPUSH
70899: CALL_OW 121
// if GetControl ( j ) = control_remote then
70903: LD_VAR 0 3
70907: PPUSH
70908: CALL_OW 263
70912: PUSH
70913: LD_INT 2
70915: EQUAL
70916: IFFALSE 70927
// ComUnlink ( j ) ;
70918: LD_VAR 0 3
70922: PPUSH
70923: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
70927: LD_ADDR_VAR 0 9
70931: PUSH
70932: LD_VAR 0 2
70936: PPUSH
70937: LD_INT 3
70939: PPUSH
70940: CALL 80132 0 2
70944: ST_TO_ADDR
// if fac then
70945: LD_VAR 0 9
70949: IFFALSE 71026
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70951: LD_ADDR_VAR 0 10
70955: PUSH
70956: LD_VAR 0 9
70960: PPUSH
70961: LD_VAR 0 3
70965: PPUSH
70966: CALL_OW 265
70970: PPUSH
70971: LD_VAR 0 3
70975: PPUSH
70976: CALL_OW 262
70980: PPUSH
70981: LD_VAR 0 3
70985: PPUSH
70986: CALL_OW 263
70990: PPUSH
70991: LD_VAR 0 3
70995: PPUSH
70996: CALL_OW 264
71000: PPUSH
71001: CALL 18265 0 5
71005: ST_TO_ADDR
// if components then
71006: LD_VAR 0 10
71010: IFFALSE 71026
// MC_InsertProduceList ( i , components ) ;
71012: LD_VAR 0 2
71016: PPUSH
71017: LD_VAR 0 10
71021: PPUSH
71022: CALL 79760 0 2
// end ; continue ;
71026: GO 70541
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71028: LD_VAR 0 3
71032: PPUSH
71033: LD_INT 1
71035: PPUSH
71036: CALL_OW 289
71040: PUSH
71041: LD_INT 100
71043: LESS
71044: PUSH
71045: LD_VAR 0 3
71049: PPUSH
71050: CALL_OW 314
71054: NOT
71055: AND
71056: IFFALSE 71085
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71058: LD_VAR 0 3
71062: PPUSH
71063: LD_VAR 0 6
71067: PUSH
71068: LD_INT 2
71070: ARRAY
71071: PPUSH
71072: LD_VAR 0 6
71076: PUSH
71077: LD_INT 3
71079: ARRAY
71080: PPUSH
71081: CALL_OW 117
// break ;
71085: GO 71089
// end ;
71087: GO 70541
71089: POP
71090: POP
// end ; end ;
71091: GO 69379
71093: POP
71094: POP
// end ;
71095: LD_VAR 0 1
71099: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71100: LD_INT 0
71102: PPUSH
71103: PPUSH
71104: PPUSH
71105: PPUSH
// if not mc_bases then
71106: LD_EXP 58
71110: NOT
71111: IFFALSE 71115
// exit ;
71113: GO 71276
// for i = 1 to mc_bases do
71115: LD_ADDR_VAR 0 2
71119: PUSH
71120: DOUBLE
71121: LD_INT 1
71123: DEC
71124: ST_TO_ADDR
71125: LD_EXP 58
71129: PUSH
71130: FOR_TO
71131: IFFALSE 71274
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71133: LD_ADDR_VAR 0 4
71137: PUSH
71138: LD_EXP 77
71142: PUSH
71143: LD_VAR 0 2
71147: ARRAY
71148: PUSH
71149: LD_EXP 80
71153: PUSH
71154: LD_VAR 0 2
71158: ARRAY
71159: UNION
71160: PPUSH
71161: LD_INT 33
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PPUSH
71171: CALL_OW 72
71175: ST_TO_ADDR
// if tmp then
71176: LD_VAR 0 4
71180: IFFALSE 71272
// for j in tmp do
71182: LD_ADDR_VAR 0 3
71186: PUSH
71187: LD_VAR 0 4
71191: PUSH
71192: FOR_IN
71193: IFFALSE 71270
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71195: LD_VAR 0 3
71199: PPUSH
71200: CALL_OW 312
71204: NOT
71205: PUSH
71206: LD_VAR 0 3
71210: PPUSH
71211: CALL_OW 256
71215: PUSH
71216: LD_INT 250
71218: GREATEREQUAL
71219: AND
71220: IFFALSE 71233
// Connect ( j ) else
71222: LD_VAR 0 3
71226: PPUSH
71227: CALL 23598 0 1
71231: GO 71268
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71233: LD_VAR 0 3
71237: PPUSH
71238: CALL_OW 256
71242: PUSH
71243: LD_INT 250
71245: LESS
71246: PUSH
71247: LD_VAR 0 3
71251: PPUSH
71252: CALL_OW 312
71256: AND
71257: IFFALSE 71268
// ComUnlink ( j ) ;
71259: LD_VAR 0 3
71263: PPUSH
71264: CALL_OW 136
71268: GO 71192
71270: POP
71271: POP
// end ;
71272: GO 71130
71274: POP
71275: POP
// end ;
71276: LD_VAR 0 1
71280: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71281: LD_INT 0
71283: PPUSH
71284: PPUSH
71285: PPUSH
71286: PPUSH
71287: PPUSH
// if not mc_bases then
71288: LD_EXP 58
71292: NOT
71293: IFFALSE 71297
// exit ;
71295: GO 71757
// for i = 1 to mc_bases do
71297: LD_ADDR_VAR 0 2
71301: PUSH
71302: DOUBLE
71303: LD_INT 1
71305: DEC
71306: ST_TO_ADDR
71307: LD_EXP 58
71311: PUSH
71312: FOR_TO
71313: IFFALSE 71755
// begin if not mc_produce [ i ] then
71315: LD_EXP 79
71319: PUSH
71320: LD_VAR 0 2
71324: ARRAY
71325: NOT
71326: IFFALSE 71330
// continue ;
71328: GO 71312
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71330: LD_ADDR_VAR 0 5
71334: PUSH
71335: LD_EXP 58
71339: PUSH
71340: LD_VAR 0 2
71344: ARRAY
71345: PPUSH
71346: LD_INT 30
71348: PUSH
71349: LD_INT 3
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PPUSH
71356: CALL_OW 72
71360: ST_TO_ADDR
// if not fac then
71361: LD_VAR 0 5
71365: NOT
71366: IFFALSE 71370
// continue ;
71368: GO 71312
// for j in fac do
71370: LD_ADDR_VAR 0 3
71374: PUSH
71375: LD_VAR 0 5
71379: PUSH
71380: FOR_IN
71381: IFFALSE 71751
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
71383: LD_VAR 0 3
71387: PPUSH
71388: CALL_OW 461
71392: PUSH
71393: LD_INT 2
71395: NONEQUAL
71396: PUSH
71397: LD_VAR 0 3
71401: PPUSH
71402: LD_INT 15
71404: PPUSH
71405: CALL 23258 0 2
71409: PUSH
71410: LD_INT 4
71412: ARRAY
71413: OR
71414: PUSH
71415: LD_VAR 0 3
71419: PPUSH
71420: CALL_OW 313
71424: PUSH
71425: LD_INT 0
71427: EQUAL
71428: OR
71429: IFFALSE 71433
// continue ;
71431: GO 71380
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71433: LD_VAR 0 3
71437: PPUSH
71438: LD_EXP 79
71442: PUSH
71443: LD_VAR 0 2
71447: ARRAY
71448: PUSH
71449: LD_INT 1
71451: ARRAY
71452: PUSH
71453: LD_INT 1
71455: ARRAY
71456: PPUSH
71457: LD_EXP 79
71461: PUSH
71462: LD_VAR 0 2
71466: ARRAY
71467: PUSH
71468: LD_INT 1
71470: ARRAY
71471: PUSH
71472: LD_INT 2
71474: ARRAY
71475: PPUSH
71476: LD_EXP 79
71480: PUSH
71481: LD_VAR 0 2
71485: ARRAY
71486: PUSH
71487: LD_INT 1
71489: ARRAY
71490: PUSH
71491: LD_INT 3
71493: ARRAY
71494: PPUSH
71495: LD_EXP 79
71499: PUSH
71500: LD_VAR 0 2
71504: ARRAY
71505: PUSH
71506: LD_INT 1
71508: ARRAY
71509: PUSH
71510: LD_INT 4
71512: ARRAY
71513: PPUSH
71514: CALL_OW 448
71518: PUSH
71519: LD_VAR 0 3
71523: PPUSH
71524: LD_EXP 79
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: PUSH
71535: LD_INT 1
71537: ARRAY
71538: PUSH
71539: LD_INT 1
71541: ARRAY
71542: PUSH
71543: LD_EXP 79
71547: PUSH
71548: LD_VAR 0 2
71552: ARRAY
71553: PUSH
71554: LD_INT 1
71556: ARRAY
71557: PUSH
71558: LD_INT 2
71560: ARRAY
71561: PUSH
71562: LD_EXP 79
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PUSH
71573: LD_INT 1
71575: ARRAY
71576: PUSH
71577: LD_INT 3
71579: ARRAY
71580: PUSH
71581: LD_EXP 79
71585: PUSH
71586: LD_VAR 0 2
71590: ARRAY
71591: PUSH
71592: LD_INT 1
71594: ARRAY
71595: PUSH
71596: LD_INT 4
71598: ARRAY
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: PPUSH
71606: CALL 26929 0 2
71610: AND
71611: IFFALSE 71749
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71613: LD_VAR 0 3
71617: PPUSH
71618: LD_EXP 79
71622: PUSH
71623: LD_VAR 0 2
71627: ARRAY
71628: PUSH
71629: LD_INT 1
71631: ARRAY
71632: PUSH
71633: LD_INT 1
71635: ARRAY
71636: PPUSH
71637: LD_EXP 79
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: PUSH
71648: LD_INT 1
71650: ARRAY
71651: PUSH
71652: LD_INT 2
71654: ARRAY
71655: PPUSH
71656: LD_EXP 79
71660: PUSH
71661: LD_VAR 0 2
71665: ARRAY
71666: PUSH
71667: LD_INT 1
71669: ARRAY
71670: PUSH
71671: LD_INT 3
71673: ARRAY
71674: PPUSH
71675: LD_EXP 79
71679: PUSH
71680: LD_VAR 0 2
71684: ARRAY
71685: PUSH
71686: LD_INT 1
71688: ARRAY
71689: PUSH
71690: LD_INT 4
71692: ARRAY
71693: PPUSH
71694: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71698: LD_ADDR_VAR 0 4
71702: PUSH
71703: LD_EXP 79
71707: PUSH
71708: LD_VAR 0 2
71712: ARRAY
71713: PPUSH
71714: LD_INT 1
71716: PPUSH
71717: CALL_OW 3
71721: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71722: LD_ADDR_EXP 79
71726: PUSH
71727: LD_EXP 79
71731: PPUSH
71732: LD_VAR 0 2
71736: PPUSH
71737: LD_VAR 0 4
71741: PPUSH
71742: CALL_OW 1
71746: ST_TO_ADDR
// break ;
71747: GO 71751
// end ; end ;
71749: GO 71380
71751: POP
71752: POP
// end ;
71753: GO 71312
71755: POP
71756: POP
// end ;
71757: LD_VAR 0 1
71761: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71762: LD_INT 0
71764: PPUSH
71765: PPUSH
71766: PPUSH
// if not mc_bases then
71767: LD_EXP 58
71771: NOT
71772: IFFALSE 71776
// exit ;
71774: GO 71865
// for i = 1 to mc_bases do
71776: LD_ADDR_VAR 0 2
71780: PUSH
71781: DOUBLE
71782: LD_INT 1
71784: DEC
71785: ST_TO_ADDR
71786: LD_EXP 58
71790: PUSH
71791: FOR_TO
71792: IFFALSE 71863
// begin if mc_attack [ i ] then
71794: LD_EXP 78
71798: PUSH
71799: LD_VAR 0 2
71803: ARRAY
71804: IFFALSE 71861
// begin tmp := mc_attack [ i ] [ 1 ] ;
71806: LD_ADDR_VAR 0 3
71810: PUSH
71811: LD_EXP 78
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PUSH
71822: LD_INT 1
71824: ARRAY
71825: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71826: LD_ADDR_EXP 78
71830: PUSH
71831: LD_EXP 78
71835: PPUSH
71836: LD_VAR 0 2
71840: PPUSH
71841: EMPTY
71842: PPUSH
71843: CALL_OW 1
71847: ST_TO_ADDR
// Attack ( tmp ) ;
71848: LD_VAR 0 3
71852: PPUSH
71853: CALL 49118 0 1
// exit ;
71857: POP
71858: POP
71859: GO 71865
// end ; end ;
71861: GO 71791
71863: POP
71864: POP
// end ;
71865: LD_VAR 0 1
71869: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71870: LD_INT 0
71872: PPUSH
71873: PPUSH
71874: PPUSH
71875: PPUSH
71876: PPUSH
71877: PPUSH
71878: PPUSH
// if not mc_bases then
71879: LD_EXP 58
71883: NOT
71884: IFFALSE 71888
// exit ;
71886: GO 72492
// for i = 1 to mc_bases do
71888: LD_ADDR_VAR 0 2
71892: PUSH
71893: DOUBLE
71894: LD_INT 1
71896: DEC
71897: ST_TO_ADDR
71898: LD_EXP 58
71902: PUSH
71903: FOR_TO
71904: IFFALSE 72490
// begin if not mc_bases [ i ] then
71906: LD_EXP 58
71910: PUSH
71911: LD_VAR 0 2
71915: ARRAY
71916: NOT
71917: IFFALSE 71921
// continue ;
71919: GO 71903
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71921: LD_ADDR_VAR 0 7
71925: PUSH
71926: LD_EXP 58
71930: PUSH
71931: LD_VAR 0 2
71935: ARRAY
71936: PUSH
71937: LD_INT 1
71939: ARRAY
71940: PPUSH
71941: CALL 17569 0 1
71945: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71946: LD_ADDR_EXP 81
71950: PUSH
71951: LD_EXP 81
71955: PPUSH
71956: LD_VAR 0 2
71960: PPUSH
71961: LD_EXP 58
71965: PUSH
71966: LD_VAR 0 2
71970: ARRAY
71971: PUSH
71972: LD_INT 1
71974: ARRAY
71975: PPUSH
71976: CALL_OW 255
71980: PPUSH
71981: LD_EXP 83
71985: PUSH
71986: LD_VAR 0 2
71990: ARRAY
71991: PPUSH
71992: CALL 15529 0 2
71996: PPUSH
71997: CALL_OW 1
72001: ST_TO_ADDR
// if not mc_scan [ i ] then
72002: LD_EXP 81
72006: PUSH
72007: LD_VAR 0 2
72011: ARRAY
72012: NOT
72013: IFFALSE 72168
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72015: LD_ADDR_VAR 0 4
72019: PUSH
72020: LD_EXP 58
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: PPUSH
72031: LD_INT 2
72033: PUSH
72034: LD_INT 25
72036: PUSH
72037: LD_INT 5
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 25
72046: PUSH
72047: LD_INT 8
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 25
72056: PUSH
72057: LD_INT 9
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: PPUSH
72070: CALL_OW 72
72074: ST_TO_ADDR
// if not tmp then
72075: LD_VAR 0 4
72079: NOT
72080: IFFALSE 72084
// continue ;
72082: GO 71903
// for j in tmp do
72084: LD_ADDR_VAR 0 3
72088: PUSH
72089: LD_VAR 0 4
72093: PUSH
72094: FOR_IN
72095: IFFALSE 72166
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72097: LD_VAR 0 3
72101: PPUSH
72102: CALL_OW 310
72106: PPUSH
72107: CALL_OW 266
72111: PUSH
72112: LD_INT 5
72114: EQUAL
72115: PUSH
72116: LD_VAR 0 3
72120: PPUSH
72121: CALL_OW 257
72125: PUSH
72126: LD_INT 1
72128: EQUAL
72129: AND
72130: PUSH
72131: LD_VAR 0 3
72135: PPUSH
72136: CALL_OW 459
72140: NOT
72141: AND
72142: PUSH
72143: LD_VAR 0 7
72147: AND
72148: IFFALSE 72164
// ComChangeProfession ( j , class ) ;
72150: LD_VAR 0 3
72154: PPUSH
72155: LD_VAR 0 7
72159: PPUSH
72160: CALL_OW 123
72164: GO 72094
72166: POP
72167: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72168: LD_EXP 81
72172: PUSH
72173: LD_VAR 0 2
72177: ARRAY
72178: PUSH
72179: LD_EXP 80
72183: PUSH
72184: LD_VAR 0 2
72188: ARRAY
72189: NOT
72190: AND
72191: PUSH
72192: LD_EXP 58
72196: PUSH
72197: LD_VAR 0 2
72201: ARRAY
72202: PPUSH
72203: LD_INT 30
72205: PUSH
72206: LD_INT 32
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PPUSH
72213: CALL_OW 72
72217: NOT
72218: AND
72219: PUSH
72220: LD_EXP 58
72224: PUSH
72225: LD_VAR 0 2
72229: ARRAY
72230: PPUSH
72231: LD_INT 2
72233: PUSH
72234: LD_INT 30
72236: PUSH
72237: LD_INT 4
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 30
72246: PUSH
72247: LD_INT 5
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: LIST
72258: PPUSH
72259: CALL_OW 72
72263: NOT
72264: AND
72265: IFFALSE 72397
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72267: LD_ADDR_VAR 0 4
72271: PUSH
72272: LD_EXP 58
72276: PUSH
72277: LD_VAR 0 2
72281: ARRAY
72282: PPUSH
72283: LD_INT 2
72285: PUSH
72286: LD_INT 25
72288: PUSH
72289: LD_INT 1
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 25
72298: PUSH
72299: LD_INT 5
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 25
72308: PUSH
72309: LD_INT 8
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 25
72318: PUSH
72319: LD_INT 9
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: PPUSH
72333: CALL_OW 72
72337: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72338: LD_ADDR_VAR 0 4
72342: PUSH
72343: LD_VAR 0 4
72347: PUSH
72348: LD_VAR 0 4
72352: PPUSH
72353: LD_INT 18
72355: PPUSH
72356: CALL 53901 0 2
72360: DIFF
72361: ST_TO_ADDR
// if tmp then
72362: LD_VAR 0 4
72366: IFFALSE 72397
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72368: LD_VAR 0 2
72372: PPUSH
72373: LD_VAR 0 4
72377: PPUSH
72378: LD_EXP 83
72382: PUSH
72383: LD_VAR 0 2
72387: ARRAY
72388: PPUSH
72389: CALL 15564 0 3
// exit ;
72393: POP
72394: POP
72395: GO 72492
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
72397: LD_EXP 81
72401: PUSH
72402: LD_VAR 0 2
72406: ARRAY
72407: PUSH
72408: LD_EXP 80
72412: PUSH
72413: LD_VAR 0 2
72417: ARRAY
72418: AND
72419: IFFALSE 72488
// begin tmp := mc_defender [ i ] ;
72421: LD_ADDR_VAR 0 4
72425: PUSH
72426: LD_EXP 80
72430: PUSH
72431: LD_VAR 0 2
72435: ARRAY
72436: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
72437: LD_ADDR_EXP 80
72441: PUSH
72442: LD_EXP 80
72446: PPUSH
72447: LD_VAR 0 2
72451: PPUSH
72452: EMPTY
72453: PPUSH
72454: CALL_OW 1
72458: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
72459: LD_VAR 0 2
72463: PPUSH
72464: LD_VAR 0 4
72468: PPUSH
72469: LD_EXP 81
72473: PUSH
72474: LD_VAR 0 2
72478: ARRAY
72479: PPUSH
72480: CALL 16062 0 3
// exit ;
72484: POP
72485: POP
72486: GO 72492
// end ; end ;
72488: GO 71903
72490: POP
72491: POP
// end ;
72492: LD_VAR 0 1
72496: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72497: LD_INT 0
72499: PPUSH
72500: PPUSH
72501: PPUSH
72502: PPUSH
72503: PPUSH
72504: PPUSH
72505: PPUSH
72506: PPUSH
72507: PPUSH
72508: PPUSH
72509: PPUSH
// if not mc_bases then
72510: LD_EXP 58
72514: NOT
72515: IFFALSE 72519
// exit ;
72517: GO 73606
// for i = 1 to mc_bases do
72519: LD_ADDR_VAR 0 2
72523: PUSH
72524: DOUBLE
72525: LD_INT 1
72527: DEC
72528: ST_TO_ADDR
72529: LD_EXP 58
72533: PUSH
72534: FOR_TO
72535: IFFALSE 73604
// begin tmp := mc_lab [ i ] ;
72537: LD_ADDR_VAR 0 6
72541: PUSH
72542: LD_EXP 91
72546: PUSH
72547: LD_VAR 0 2
72551: ARRAY
72552: ST_TO_ADDR
// if not tmp then
72553: LD_VAR 0 6
72557: NOT
72558: IFFALSE 72562
// continue ;
72560: GO 72534
// idle_lab := 0 ;
72562: LD_ADDR_VAR 0 11
72566: PUSH
72567: LD_INT 0
72569: ST_TO_ADDR
// for j in tmp do
72570: LD_ADDR_VAR 0 3
72574: PUSH
72575: LD_VAR 0 6
72579: PUSH
72580: FOR_IN
72581: IFFALSE 73600
// begin researching := false ;
72583: LD_ADDR_VAR 0 10
72587: PUSH
72588: LD_INT 0
72590: ST_TO_ADDR
// side := GetSide ( j ) ;
72591: LD_ADDR_VAR 0 4
72595: PUSH
72596: LD_VAR 0 3
72600: PPUSH
72601: CALL_OW 255
72605: ST_TO_ADDR
// if not mc_tech [ side ] then
72606: LD_EXP 85
72610: PUSH
72611: LD_VAR 0 4
72615: ARRAY
72616: NOT
72617: IFFALSE 72621
// continue ;
72619: GO 72580
// if BuildingStatus ( j ) = bs_idle then
72621: LD_VAR 0 3
72625: PPUSH
72626: CALL_OW 461
72630: PUSH
72631: LD_INT 2
72633: EQUAL
72634: IFFALSE 72822
// begin if idle_lab and UnitsInside ( j ) < 6 then
72636: LD_VAR 0 11
72640: PUSH
72641: LD_VAR 0 3
72645: PPUSH
72646: CALL_OW 313
72650: PUSH
72651: LD_INT 6
72653: LESS
72654: AND
72655: IFFALSE 72726
// begin tmp2 := UnitsInside ( idle_lab ) ;
72657: LD_ADDR_VAR 0 9
72661: PUSH
72662: LD_VAR 0 11
72666: PPUSH
72667: CALL_OW 313
72671: ST_TO_ADDR
// if tmp2 then
72672: LD_VAR 0 9
72676: IFFALSE 72718
// for x in tmp2 do
72678: LD_ADDR_VAR 0 7
72682: PUSH
72683: LD_VAR 0 9
72687: PUSH
72688: FOR_IN
72689: IFFALSE 72716
// begin ComExitBuilding ( x ) ;
72691: LD_VAR 0 7
72695: PPUSH
72696: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72700: LD_VAR 0 7
72704: PPUSH
72705: LD_VAR 0 3
72709: PPUSH
72710: CALL_OW 180
// end ;
72714: GO 72688
72716: POP
72717: POP
// idle_lab := 0 ;
72718: LD_ADDR_VAR 0 11
72722: PUSH
72723: LD_INT 0
72725: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72726: LD_ADDR_VAR 0 5
72730: PUSH
72731: LD_EXP 85
72735: PUSH
72736: LD_VAR 0 4
72740: ARRAY
72741: PUSH
72742: FOR_IN
72743: IFFALSE 72803
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72745: LD_VAR 0 3
72749: PPUSH
72750: LD_VAR 0 5
72754: PPUSH
72755: CALL_OW 430
72759: PUSH
72760: LD_VAR 0 4
72764: PPUSH
72765: LD_VAR 0 5
72769: PPUSH
72770: CALL 14634 0 2
72774: AND
72775: IFFALSE 72801
// begin researching := true ;
72777: LD_ADDR_VAR 0 10
72781: PUSH
72782: LD_INT 1
72784: ST_TO_ADDR
// ComResearch ( j , t ) ;
72785: LD_VAR 0 3
72789: PPUSH
72790: LD_VAR 0 5
72794: PPUSH
72795: CALL_OW 124
// break ;
72799: GO 72803
// end ;
72801: GO 72742
72803: POP
72804: POP
// if not researching then
72805: LD_VAR 0 10
72809: NOT
72810: IFFALSE 72822
// idle_lab := j ;
72812: LD_ADDR_VAR 0 11
72816: PUSH
72817: LD_VAR 0 3
72821: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72822: LD_VAR 0 3
72826: PPUSH
72827: CALL_OW 461
72831: PUSH
72832: LD_INT 10
72834: EQUAL
72835: IFFALSE 73423
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72837: LD_EXP 87
72841: PUSH
72842: LD_VAR 0 2
72846: ARRAY
72847: NOT
72848: PUSH
72849: LD_EXP 88
72853: PUSH
72854: LD_VAR 0 2
72858: ARRAY
72859: NOT
72860: AND
72861: PUSH
72862: LD_EXP 85
72866: PUSH
72867: LD_VAR 0 4
72871: ARRAY
72872: PUSH
72873: LD_INT 1
72875: GREATER
72876: AND
72877: IFFALSE 73008
// begin ComCancel ( j ) ;
72879: LD_VAR 0 3
72883: PPUSH
72884: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72888: LD_ADDR_EXP 85
72892: PUSH
72893: LD_EXP 85
72897: PPUSH
72898: LD_VAR 0 4
72902: PPUSH
72903: LD_EXP 85
72907: PUSH
72908: LD_VAR 0 4
72912: ARRAY
72913: PPUSH
72914: LD_EXP 85
72918: PUSH
72919: LD_VAR 0 4
72923: ARRAY
72924: PUSH
72925: LD_INT 1
72927: MINUS
72928: PPUSH
72929: LD_EXP 85
72933: PUSH
72934: LD_VAR 0 4
72938: ARRAY
72939: PPUSH
72940: LD_INT 0
72942: PPUSH
72943: CALL 20083 0 4
72947: PPUSH
72948: CALL_OW 1
72952: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72953: LD_ADDR_EXP 85
72957: PUSH
72958: LD_EXP 85
72962: PPUSH
72963: LD_VAR 0 4
72967: PPUSH
72968: LD_EXP 85
72972: PUSH
72973: LD_VAR 0 4
72977: ARRAY
72978: PPUSH
72979: LD_EXP 85
72983: PUSH
72984: LD_VAR 0 4
72988: ARRAY
72989: PPUSH
72990: LD_INT 1
72992: PPUSH
72993: LD_INT 0
72995: PPUSH
72996: CALL 20083 0 4
73000: PPUSH
73001: CALL_OW 1
73005: ST_TO_ADDR
// continue ;
73006: GO 72580
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73008: LD_EXP 87
73012: PUSH
73013: LD_VAR 0 2
73017: ARRAY
73018: PUSH
73019: LD_EXP 88
73023: PUSH
73024: LD_VAR 0 2
73028: ARRAY
73029: NOT
73030: AND
73031: IFFALSE 73158
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73033: LD_ADDR_EXP 88
73037: PUSH
73038: LD_EXP 88
73042: PPUSH
73043: LD_VAR 0 2
73047: PUSH
73048: LD_EXP 88
73052: PUSH
73053: LD_VAR 0 2
73057: ARRAY
73058: PUSH
73059: LD_INT 1
73061: PLUS
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PPUSH
73067: LD_EXP 87
73071: PUSH
73072: LD_VAR 0 2
73076: ARRAY
73077: PUSH
73078: LD_INT 1
73080: ARRAY
73081: PPUSH
73082: CALL 20665 0 3
73086: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73087: LD_EXP 87
73091: PUSH
73092: LD_VAR 0 2
73096: ARRAY
73097: PUSH
73098: LD_INT 1
73100: ARRAY
73101: PPUSH
73102: LD_INT 112
73104: PPUSH
73105: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73109: LD_ADDR_VAR 0 9
73113: PUSH
73114: LD_EXP 87
73118: PUSH
73119: LD_VAR 0 2
73123: ARRAY
73124: PPUSH
73125: LD_INT 1
73127: PPUSH
73128: CALL_OW 3
73132: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73133: LD_ADDR_EXP 87
73137: PUSH
73138: LD_EXP 87
73142: PPUSH
73143: LD_VAR 0 2
73147: PPUSH
73148: LD_VAR 0 9
73152: PPUSH
73153: CALL_OW 1
73157: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73158: LD_EXP 87
73162: PUSH
73163: LD_VAR 0 2
73167: ARRAY
73168: PUSH
73169: LD_EXP 88
73173: PUSH
73174: LD_VAR 0 2
73178: ARRAY
73179: AND
73180: PUSH
73181: LD_EXP 88
73185: PUSH
73186: LD_VAR 0 2
73190: ARRAY
73191: PUSH
73192: LD_INT 1
73194: ARRAY
73195: PPUSH
73196: CALL_OW 310
73200: NOT
73201: AND
73202: PUSH
73203: LD_VAR 0 3
73207: PPUSH
73208: CALL_OW 313
73212: PUSH
73213: LD_INT 6
73215: EQUAL
73216: AND
73217: IFFALSE 73273
// begin tmp2 := UnitsInside ( j ) ;
73219: LD_ADDR_VAR 0 9
73223: PUSH
73224: LD_VAR 0 3
73228: PPUSH
73229: CALL_OW 313
73233: ST_TO_ADDR
// if tmp2 = 6 then
73234: LD_VAR 0 9
73238: PUSH
73239: LD_INT 6
73241: EQUAL
73242: IFFALSE 73273
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73244: LD_VAR 0 9
73248: PUSH
73249: LD_INT 1
73251: ARRAY
73252: PPUSH
73253: LD_INT 112
73255: PPUSH
73256: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73260: LD_VAR 0 9
73264: PUSH
73265: LD_INT 1
73267: ARRAY
73268: PPUSH
73269: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73273: LD_EXP 88
73277: PUSH
73278: LD_VAR 0 2
73282: ARRAY
73283: PUSH
73284: LD_EXP 88
73288: PUSH
73289: LD_VAR 0 2
73293: ARRAY
73294: PUSH
73295: LD_INT 1
73297: ARRAY
73298: PPUSH
73299: CALL_OW 314
73303: NOT
73304: AND
73305: PUSH
73306: LD_EXP 88
73310: PUSH
73311: LD_VAR 0 2
73315: ARRAY
73316: PUSH
73317: LD_INT 1
73319: ARRAY
73320: PPUSH
73321: CALL_OW 310
73325: NOT
73326: AND
73327: IFFALSE 73353
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73329: LD_EXP 88
73333: PUSH
73334: LD_VAR 0 2
73338: ARRAY
73339: PUSH
73340: LD_INT 1
73342: ARRAY
73343: PPUSH
73344: LD_VAR 0 3
73348: PPUSH
73349: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73353: LD_EXP 88
73357: PUSH
73358: LD_VAR 0 2
73362: ARRAY
73363: PUSH
73364: LD_INT 1
73366: ARRAY
73367: PPUSH
73368: CALL_OW 310
73372: PUSH
73373: LD_EXP 88
73377: PUSH
73378: LD_VAR 0 2
73382: ARRAY
73383: PUSH
73384: LD_INT 1
73386: ARRAY
73387: PPUSH
73388: CALL_OW 310
73392: PPUSH
73393: CALL_OW 461
73397: PUSH
73398: LD_INT 3
73400: NONEQUAL
73401: AND
73402: IFFALSE 73423
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73404: LD_EXP 88
73408: PUSH
73409: LD_VAR 0 2
73413: ARRAY
73414: PUSH
73415: LD_INT 1
73417: ARRAY
73418: PPUSH
73419: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73423: LD_VAR 0 3
73427: PPUSH
73428: CALL_OW 461
73432: PUSH
73433: LD_INT 6
73435: EQUAL
73436: PUSH
73437: LD_VAR 0 6
73441: PUSH
73442: LD_INT 1
73444: GREATER
73445: AND
73446: IFFALSE 73598
// begin sci := [ ] ;
73448: LD_ADDR_VAR 0 8
73452: PUSH
73453: EMPTY
73454: ST_TO_ADDR
// for x in ( tmp diff j ) do
73455: LD_ADDR_VAR 0 7
73459: PUSH
73460: LD_VAR 0 6
73464: PUSH
73465: LD_VAR 0 3
73469: DIFF
73470: PUSH
73471: FOR_IN
73472: IFFALSE 73524
// begin if sci = 6 then
73474: LD_VAR 0 8
73478: PUSH
73479: LD_INT 6
73481: EQUAL
73482: IFFALSE 73486
// break ;
73484: GO 73524
// if BuildingStatus ( x ) = bs_idle then
73486: LD_VAR 0 7
73490: PPUSH
73491: CALL_OW 461
73495: PUSH
73496: LD_INT 2
73498: EQUAL
73499: IFFALSE 73522
// sci := sci ^ UnitsInside ( x ) ;
73501: LD_ADDR_VAR 0 8
73505: PUSH
73506: LD_VAR 0 8
73510: PUSH
73511: LD_VAR 0 7
73515: PPUSH
73516: CALL_OW 313
73520: ADD
73521: ST_TO_ADDR
// end ;
73522: GO 73471
73524: POP
73525: POP
// if not sci then
73526: LD_VAR 0 8
73530: NOT
73531: IFFALSE 73535
// continue ;
73533: GO 72580
// for x in sci do
73535: LD_ADDR_VAR 0 7
73539: PUSH
73540: LD_VAR 0 8
73544: PUSH
73545: FOR_IN
73546: IFFALSE 73596
// if IsInUnit ( x ) and not HasTask ( x ) then
73548: LD_VAR 0 7
73552: PPUSH
73553: CALL_OW 310
73557: PUSH
73558: LD_VAR 0 7
73562: PPUSH
73563: CALL_OW 314
73567: NOT
73568: AND
73569: IFFALSE 73594
// begin ComExitBuilding ( x ) ;
73571: LD_VAR 0 7
73575: PPUSH
73576: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73580: LD_VAR 0 7
73584: PPUSH
73585: LD_VAR 0 3
73589: PPUSH
73590: CALL_OW 180
// end ;
73594: GO 73545
73596: POP
73597: POP
// end ; end ;
73598: GO 72580
73600: POP
73601: POP
// end ;
73602: GO 72534
73604: POP
73605: POP
// end ;
73606: LD_VAR 0 1
73610: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73611: LD_INT 0
73613: PPUSH
73614: PPUSH
// if not mc_bases then
73615: LD_EXP 58
73619: NOT
73620: IFFALSE 73624
// exit ;
73622: GO 73705
// for i = 1 to mc_bases do
73624: LD_ADDR_VAR 0 2
73628: PUSH
73629: DOUBLE
73630: LD_INT 1
73632: DEC
73633: ST_TO_ADDR
73634: LD_EXP 58
73638: PUSH
73639: FOR_TO
73640: IFFALSE 73703
// if mc_mines [ i ] and mc_miners [ i ] then
73642: LD_EXP 71
73646: PUSH
73647: LD_VAR 0 2
73651: ARRAY
73652: PUSH
73653: LD_EXP 72
73657: PUSH
73658: LD_VAR 0 2
73662: ARRAY
73663: AND
73664: IFFALSE 73701
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73666: LD_EXP 72
73670: PUSH
73671: LD_VAR 0 2
73675: ARRAY
73676: PUSH
73677: LD_INT 1
73679: ARRAY
73680: PPUSH
73681: CALL_OW 255
73685: PPUSH
73686: LD_EXP 71
73690: PUSH
73691: LD_VAR 0 2
73695: ARRAY
73696: PPUSH
73697: CALL 17722 0 2
73701: GO 73639
73703: POP
73704: POP
// end ;
73705: LD_VAR 0 1
73709: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73710: LD_INT 0
73712: PPUSH
73713: PPUSH
73714: PPUSH
73715: PPUSH
73716: PPUSH
73717: PPUSH
73718: PPUSH
73719: PPUSH
// if not mc_bases or not mc_parking then
73720: LD_EXP 58
73724: NOT
73725: PUSH
73726: LD_EXP 82
73730: NOT
73731: OR
73732: IFFALSE 73736
// exit ;
73734: GO 74448
// for i = 1 to mc_bases do
73736: LD_ADDR_VAR 0 2
73740: PUSH
73741: DOUBLE
73742: LD_INT 1
73744: DEC
73745: ST_TO_ADDR
73746: LD_EXP 58
73750: PUSH
73751: FOR_TO
73752: IFFALSE 74446
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73754: LD_EXP 58
73758: PUSH
73759: LD_VAR 0 2
73763: ARRAY
73764: NOT
73765: PUSH
73766: LD_EXP 82
73770: PUSH
73771: LD_VAR 0 2
73775: ARRAY
73776: NOT
73777: OR
73778: IFFALSE 73782
// continue ;
73780: GO 73751
// if mc_scan [ i ] then
73782: LD_EXP 81
73786: PUSH
73787: LD_VAR 0 2
73791: ARRAY
73792: IFFALSE 73818
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73794: LD_ADDR_EXP 70
73798: PUSH
73799: LD_EXP 70
73803: PPUSH
73804: LD_VAR 0 2
73808: PPUSH
73809: EMPTY
73810: PPUSH
73811: CALL_OW 1
73815: ST_TO_ADDR
// continue ;
73816: GO 73751
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73818: LD_ADDR_VAR 0 5
73822: PUSH
73823: LD_EXP 58
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: PUSH
73834: LD_INT 1
73836: ARRAY
73837: PPUSH
73838: CALL_OW 255
73842: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73843: LD_ADDR_VAR 0 6
73847: PUSH
73848: LD_EXP 58
73852: PUSH
73853: LD_VAR 0 2
73857: ARRAY
73858: PPUSH
73859: LD_INT 30
73861: PUSH
73862: LD_INT 3
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PPUSH
73869: CALL_OW 72
73873: ST_TO_ADDR
// if not fac then
73874: LD_VAR 0 6
73878: NOT
73879: IFFALSE 73930
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73881: LD_ADDR_VAR 0 6
73885: PUSH
73886: LD_EXP 58
73890: PUSH
73891: LD_VAR 0 2
73895: ARRAY
73896: PPUSH
73897: LD_INT 2
73899: PUSH
73900: LD_INT 30
73902: PUSH
73903: LD_INT 0
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 30
73912: PUSH
73913: LD_INT 1
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: LIST
73924: PPUSH
73925: CALL_OW 72
73929: ST_TO_ADDR
// if not fac then
73930: LD_VAR 0 6
73934: NOT
73935: IFFALSE 73939
// continue ;
73937: GO 73751
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73939: LD_ADDR_VAR 0 7
73943: PUSH
73944: LD_EXP 82
73948: PUSH
73949: LD_VAR 0 2
73953: ARRAY
73954: PPUSH
73955: LD_INT 22
73957: PUSH
73958: LD_VAR 0 5
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 21
73969: PUSH
73970: LD_INT 2
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 3
73979: PUSH
73980: LD_INT 24
73982: PUSH
73983: LD_INT 1000
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: LIST
73998: PPUSH
73999: CALL_OW 70
74003: PUSH
74004: LD_INT 22
74006: PUSH
74007: LD_VAR 0 5
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 91
74018: PUSH
74019: LD_VAR 0 6
74023: PUSH
74024: LD_INT 1
74026: ARRAY
74027: PUSH
74028: LD_INT 25
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 21
74038: PUSH
74039: LD_INT 2
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 3
74048: PUSH
74049: LD_INT 24
74051: PUSH
74052: LD_INT 1000
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: PPUSH
74069: CALL_OW 69
74073: UNION
74074: ST_TO_ADDR
// if not vehs then
74075: LD_VAR 0 7
74079: NOT
74080: IFFALSE 74106
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74082: LD_ADDR_EXP 70
74086: PUSH
74087: LD_EXP 70
74091: PPUSH
74092: LD_VAR 0 2
74096: PPUSH
74097: EMPTY
74098: PPUSH
74099: CALL_OW 1
74103: ST_TO_ADDR
// continue ;
74104: GO 73751
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74106: LD_ADDR_VAR 0 8
74110: PUSH
74111: LD_EXP 58
74115: PUSH
74116: LD_VAR 0 2
74120: ARRAY
74121: PPUSH
74122: LD_INT 30
74124: PUSH
74125: LD_INT 3
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PPUSH
74132: CALL_OW 72
74136: ST_TO_ADDR
// if tmp then
74137: LD_VAR 0 8
74141: IFFALSE 74244
// begin for j in tmp do
74143: LD_ADDR_VAR 0 3
74147: PUSH
74148: LD_VAR 0 8
74152: PUSH
74153: FOR_IN
74154: IFFALSE 74242
// for k in UnitsInside ( j ) do
74156: LD_ADDR_VAR 0 4
74160: PUSH
74161: LD_VAR 0 3
74165: PPUSH
74166: CALL_OW 313
74170: PUSH
74171: FOR_IN
74172: IFFALSE 74238
// if k then
74174: LD_VAR 0 4
74178: IFFALSE 74236
// if not k in mc_repair_vehicle [ i ] then
74180: LD_VAR 0 4
74184: PUSH
74185: LD_EXP 70
74189: PUSH
74190: LD_VAR 0 2
74194: ARRAY
74195: IN
74196: NOT
74197: IFFALSE 74236
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74199: LD_ADDR_EXP 70
74203: PUSH
74204: LD_EXP 70
74208: PPUSH
74209: LD_VAR 0 2
74213: PPUSH
74214: LD_EXP 70
74218: PUSH
74219: LD_VAR 0 2
74223: ARRAY
74224: PUSH
74225: LD_VAR 0 4
74229: UNION
74230: PPUSH
74231: CALL_OW 1
74235: ST_TO_ADDR
74236: GO 74171
74238: POP
74239: POP
74240: GO 74153
74242: POP
74243: POP
// end ; if not mc_repair_vehicle [ i ] then
74244: LD_EXP 70
74248: PUSH
74249: LD_VAR 0 2
74253: ARRAY
74254: NOT
74255: IFFALSE 74259
// continue ;
74257: GO 73751
// for j in mc_repair_vehicle [ i ] do
74259: LD_ADDR_VAR 0 3
74263: PUSH
74264: LD_EXP 70
74268: PUSH
74269: LD_VAR 0 2
74273: ARRAY
74274: PUSH
74275: FOR_IN
74276: IFFALSE 74442
// begin if GetClass ( j ) <> 3 then
74278: LD_VAR 0 3
74282: PPUSH
74283: CALL_OW 257
74287: PUSH
74288: LD_INT 3
74290: NONEQUAL
74291: IFFALSE 74332
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74293: LD_ADDR_EXP 70
74297: PUSH
74298: LD_EXP 70
74302: PPUSH
74303: LD_VAR 0 2
74307: PPUSH
74308: LD_EXP 70
74312: PUSH
74313: LD_VAR 0 2
74317: ARRAY
74318: PUSH
74319: LD_VAR 0 3
74323: DIFF
74324: PPUSH
74325: CALL_OW 1
74329: ST_TO_ADDR
// continue ;
74330: GO 74275
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74332: LD_VAR 0 3
74336: PPUSH
74337: CALL_OW 311
74341: NOT
74342: PUSH
74343: LD_VAR 0 3
74347: PUSH
74348: LD_EXP 61
74352: PUSH
74353: LD_VAR 0 2
74357: ARRAY
74358: PUSH
74359: LD_INT 1
74361: ARRAY
74362: IN
74363: NOT
74364: AND
74365: PUSH
74366: LD_VAR 0 3
74370: PUSH
74371: LD_EXP 61
74375: PUSH
74376: LD_VAR 0 2
74380: ARRAY
74381: PUSH
74382: LD_INT 2
74384: ARRAY
74385: IN
74386: NOT
74387: AND
74388: IFFALSE 74440
// begin if IsInUnit ( j ) then
74390: LD_VAR 0 3
74394: PPUSH
74395: CALL_OW 310
74399: IFFALSE 74410
// ComExitBuilding ( j ) ;
74401: LD_VAR 0 3
74405: PPUSH
74406: CALL_OW 122
// if not HasTask ( j ) then
74410: LD_VAR 0 3
74414: PPUSH
74415: CALL_OW 314
74419: NOT
74420: IFFALSE 74440
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
74422: LD_VAR 0 3
74426: PPUSH
74427: LD_VAR 0 7
74431: PUSH
74432: LD_INT 1
74434: ARRAY
74435: PPUSH
74436: CALL_OW 189
// end ; end ;
74440: GO 74275
74442: POP
74443: POP
// end ;
74444: GO 73751
74446: POP
74447: POP
// end ;
74448: LD_VAR 0 1
74452: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74453: LD_INT 0
74455: PPUSH
74456: PPUSH
74457: PPUSH
74458: PPUSH
74459: PPUSH
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
74464: PPUSH
74465: PPUSH
// if not mc_bases then
74466: LD_EXP 58
74470: NOT
74471: IFFALSE 74475
// exit ;
74473: GO 75277
// for i = 1 to mc_bases do
74475: LD_ADDR_VAR 0 2
74479: PUSH
74480: DOUBLE
74481: LD_INT 1
74483: DEC
74484: ST_TO_ADDR
74485: LD_EXP 58
74489: PUSH
74490: FOR_TO
74491: IFFALSE 75275
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74493: LD_EXP 86
74497: PUSH
74498: LD_VAR 0 2
74502: ARRAY
74503: NOT
74504: PUSH
74505: LD_EXP 61
74509: PUSH
74510: LD_VAR 0 2
74514: ARRAY
74515: PUSH
74516: LD_INT 1
74518: ARRAY
74519: OR
74520: PUSH
74521: LD_EXP 61
74525: PUSH
74526: LD_VAR 0 2
74530: ARRAY
74531: PUSH
74532: LD_INT 2
74534: ARRAY
74535: OR
74536: PUSH
74537: LD_EXP 84
74541: PUSH
74542: LD_VAR 0 2
74546: ARRAY
74547: PPUSH
74548: LD_INT 1
74550: PPUSH
74551: CALL_OW 325
74555: NOT
74556: OR
74557: PUSH
74558: LD_EXP 81
74562: PUSH
74563: LD_VAR 0 2
74567: ARRAY
74568: OR
74569: IFFALSE 74573
// continue ;
74571: GO 74490
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74573: LD_ADDR_VAR 0 8
74577: PUSH
74578: LD_EXP 58
74582: PUSH
74583: LD_VAR 0 2
74587: ARRAY
74588: PPUSH
74589: LD_INT 25
74591: PUSH
74592: LD_INT 4
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 50
74601: PUSH
74602: EMPTY
74603: LIST
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: LD_INT 60
74610: PUSH
74611: EMPTY
74612: LIST
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: LIST
74622: PPUSH
74623: CALL_OW 72
74627: PUSH
74628: LD_EXP 62
74632: PUSH
74633: LD_VAR 0 2
74637: ARRAY
74638: DIFF
74639: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74640: LD_ADDR_VAR 0 9
74644: PUSH
74645: LD_EXP 58
74649: PUSH
74650: LD_VAR 0 2
74654: ARRAY
74655: PPUSH
74656: LD_INT 2
74658: PUSH
74659: LD_INT 30
74661: PUSH
74662: LD_INT 0
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 30
74671: PUSH
74672: LD_INT 1
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: LIST
74683: PPUSH
74684: CALL_OW 72
74688: ST_TO_ADDR
// if not tmp or not dep then
74689: LD_VAR 0 8
74693: NOT
74694: PUSH
74695: LD_VAR 0 9
74699: NOT
74700: OR
74701: IFFALSE 74705
// continue ;
74703: GO 74490
// side := GetSide ( tmp [ 1 ] ) ;
74705: LD_ADDR_VAR 0 11
74709: PUSH
74710: LD_VAR 0 8
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: PPUSH
74719: CALL_OW 255
74723: ST_TO_ADDR
// dep := dep [ 1 ] ;
74724: LD_ADDR_VAR 0 9
74728: PUSH
74729: LD_VAR 0 9
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74738: LD_ADDR_VAR 0 7
74742: PUSH
74743: LD_EXP 86
74747: PUSH
74748: LD_VAR 0 2
74752: ARRAY
74753: PPUSH
74754: LD_INT 22
74756: PUSH
74757: LD_INT 0
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 25
74766: PUSH
74767: LD_INT 12
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PPUSH
74778: CALL_OW 70
74782: PUSH
74783: LD_INT 22
74785: PUSH
74786: LD_INT 0
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 25
74795: PUSH
74796: LD_INT 12
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 91
74805: PUSH
74806: LD_VAR 0 9
74810: PUSH
74811: LD_INT 20
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: LIST
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: LIST
74823: PPUSH
74824: CALL_OW 69
74828: UNION
74829: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74830: LD_ADDR_VAR 0 10
74834: PUSH
74835: LD_EXP 86
74839: PUSH
74840: LD_VAR 0 2
74844: ARRAY
74845: PPUSH
74846: LD_INT 81
74848: PUSH
74849: LD_VAR 0 11
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PPUSH
74858: CALL_OW 70
74862: ST_TO_ADDR
// if not apes or danger_at_area then
74863: LD_VAR 0 7
74867: NOT
74868: PUSH
74869: LD_VAR 0 10
74873: OR
74874: IFFALSE 74924
// begin if mc_taming [ i ] then
74876: LD_EXP 89
74880: PUSH
74881: LD_VAR 0 2
74885: ARRAY
74886: IFFALSE 74922
// begin MC_Reset ( i , 121 ) ;
74888: LD_VAR 0 2
74892: PPUSH
74893: LD_INT 121
74895: PPUSH
74896: CALL 60559 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74900: LD_ADDR_EXP 89
74904: PUSH
74905: LD_EXP 89
74909: PPUSH
74910: LD_VAR 0 2
74914: PPUSH
74915: EMPTY
74916: PPUSH
74917: CALL_OW 1
74921: ST_TO_ADDR
// end ; continue ;
74922: GO 74490
// end ; for j in tmp do
74924: LD_ADDR_VAR 0 3
74928: PUSH
74929: LD_VAR 0 8
74933: PUSH
74934: FOR_IN
74935: IFFALSE 75271
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74937: LD_VAR 0 3
74941: PUSH
74942: LD_EXP 89
74946: PUSH
74947: LD_VAR 0 2
74951: ARRAY
74952: IN
74953: NOT
74954: PUSH
74955: LD_EXP 89
74959: PUSH
74960: LD_VAR 0 2
74964: ARRAY
74965: PUSH
74966: LD_INT 3
74968: LESS
74969: AND
74970: IFFALSE 75028
// begin SetTag ( j , 121 ) ;
74972: LD_VAR 0 3
74976: PPUSH
74977: LD_INT 121
74979: PPUSH
74980: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74984: LD_ADDR_EXP 89
74988: PUSH
74989: LD_EXP 89
74993: PPUSH
74994: LD_VAR 0 2
74998: PUSH
74999: LD_EXP 89
75003: PUSH
75004: LD_VAR 0 2
75008: ARRAY
75009: PUSH
75010: LD_INT 1
75012: PLUS
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PPUSH
75018: LD_VAR 0 3
75022: PPUSH
75023: CALL 20665 0 3
75027: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75028: LD_VAR 0 3
75032: PUSH
75033: LD_EXP 89
75037: PUSH
75038: LD_VAR 0 2
75042: ARRAY
75043: IN
75044: IFFALSE 75269
// begin if GetClass ( j ) <> 4 then
75046: LD_VAR 0 3
75050: PPUSH
75051: CALL_OW 257
75055: PUSH
75056: LD_INT 4
75058: NONEQUAL
75059: IFFALSE 75112
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75061: LD_ADDR_EXP 89
75065: PUSH
75066: LD_EXP 89
75070: PPUSH
75071: LD_VAR 0 2
75075: PPUSH
75076: LD_EXP 89
75080: PUSH
75081: LD_VAR 0 2
75085: ARRAY
75086: PUSH
75087: LD_VAR 0 3
75091: DIFF
75092: PPUSH
75093: CALL_OW 1
75097: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75098: LD_VAR 0 3
75102: PPUSH
75103: LD_INT 0
75105: PPUSH
75106: CALL_OW 109
// continue ;
75110: GO 74934
// end ; if IsInUnit ( j ) then
75112: LD_VAR 0 3
75116: PPUSH
75117: CALL_OW 310
75121: IFFALSE 75132
// ComExitBuilding ( j ) ;
75123: LD_VAR 0 3
75127: PPUSH
75128: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75132: LD_ADDR_VAR 0 6
75136: PUSH
75137: LD_VAR 0 7
75141: PPUSH
75142: LD_VAR 0 3
75146: PPUSH
75147: CALL_OW 74
75151: ST_TO_ADDR
// if not ape then
75152: LD_VAR 0 6
75156: NOT
75157: IFFALSE 75161
// break ;
75159: GO 75271
// x := GetX ( ape ) ;
75161: LD_ADDR_VAR 0 4
75165: PUSH
75166: LD_VAR 0 6
75170: PPUSH
75171: CALL_OW 250
75175: ST_TO_ADDR
// y := GetY ( ape ) ;
75176: LD_ADDR_VAR 0 5
75180: PUSH
75181: LD_VAR 0 6
75185: PPUSH
75186: CALL_OW 251
75190: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75191: LD_VAR 0 4
75195: PPUSH
75196: LD_VAR 0 5
75200: PPUSH
75201: CALL_OW 488
75205: NOT
75206: PUSH
75207: LD_VAR 0 11
75211: PPUSH
75212: LD_VAR 0 4
75216: PPUSH
75217: LD_VAR 0 5
75221: PPUSH
75222: LD_INT 20
75224: PPUSH
75225: CALL 21561 0 4
75229: PUSH
75230: LD_INT 4
75232: ARRAY
75233: OR
75234: IFFALSE 75238
// break ;
75236: GO 75271
// if not HasTask ( j ) then
75238: LD_VAR 0 3
75242: PPUSH
75243: CALL_OW 314
75247: NOT
75248: IFFALSE 75269
// ComTameXY ( j , x , y ) ;
75250: LD_VAR 0 3
75254: PPUSH
75255: LD_VAR 0 4
75259: PPUSH
75260: LD_VAR 0 5
75264: PPUSH
75265: CALL_OW 131
// end ; end ;
75269: GO 74934
75271: POP
75272: POP
// end ;
75273: GO 74490
75275: POP
75276: POP
// end ;
75277: LD_VAR 0 1
75281: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75282: LD_INT 0
75284: PPUSH
75285: PPUSH
75286: PPUSH
75287: PPUSH
75288: PPUSH
75289: PPUSH
75290: PPUSH
75291: PPUSH
// if not mc_bases then
75292: LD_EXP 58
75296: NOT
75297: IFFALSE 75301
// exit ;
75299: GO 75927
// for i = 1 to mc_bases do
75301: LD_ADDR_VAR 0 2
75305: PUSH
75306: DOUBLE
75307: LD_INT 1
75309: DEC
75310: ST_TO_ADDR
75311: LD_EXP 58
75315: PUSH
75316: FOR_TO
75317: IFFALSE 75925
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75319: LD_EXP 87
75323: PUSH
75324: LD_VAR 0 2
75328: ARRAY
75329: NOT
75330: PUSH
75331: LD_EXP 87
75335: PUSH
75336: LD_VAR 0 2
75340: ARRAY
75341: PPUSH
75342: LD_INT 25
75344: PUSH
75345: LD_INT 12
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PPUSH
75352: CALL_OW 72
75356: NOT
75357: OR
75358: IFFALSE 75362
// continue ;
75360: GO 75316
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75362: LD_ADDR_VAR 0 5
75366: PUSH
75367: LD_EXP 87
75371: PUSH
75372: LD_VAR 0 2
75376: ARRAY
75377: PUSH
75378: LD_INT 1
75380: ARRAY
75381: PPUSH
75382: CALL_OW 255
75386: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75387: LD_VAR 0 5
75391: PPUSH
75392: LD_INT 2
75394: PPUSH
75395: CALL_OW 325
75399: IFFALSE 75652
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75401: LD_ADDR_VAR 0 4
75405: PUSH
75406: LD_EXP 87
75410: PUSH
75411: LD_VAR 0 2
75415: ARRAY
75416: PPUSH
75417: LD_INT 25
75419: PUSH
75420: LD_INT 16
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PPUSH
75427: CALL_OW 72
75431: ST_TO_ADDR
// if tmp < 6 then
75432: LD_VAR 0 4
75436: PUSH
75437: LD_INT 6
75439: LESS
75440: IFFALSE 75652
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75442: LD_ADDR_VAR 0 6
75446: PUSH
75447: LD_EXP 58
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PPUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 30
75463: PUSH
75464: LD_INT 0
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 30
75473: PUSH
75474: LD_INT 1
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: LIST
75485: PPUSH
75486: CALL_OW 72
75490: ST_TO_ADDR
// if depot then
75491: LD_VAR 0 6
75495: IFFALSE 75652
// begin selected := 0 ;
75497: LD_ADDR_VAR 0 7
75501: PUSH
75502: LD_INT 0
75504: ST_TO_ADDR
// for j in depot do
75505: LD_ADDR_VAR 0 3
75509: PUSH
75510: LD_VAR 0 6
75514: PUSH
75515: FOR_IN
75516: IFFALSE 75547
// begin if UnitsInside ( j ) < 6 then
75518: LD_VAR 0 3
75522: PPUSH
75523: CALL_OW 313
75527: PUSH
75528: LD_INT 6
75530: LESS
75531: IFFALSE 75545
// begin selected := j ;
75533: LD_ADDR_VAR 0 7
75537: PUSH
75538: LD_VAR 0 3
75542: ST_TO_ADDR
// break ;
75543: GO 75547
// end ; end ;
75545: GO 75515
75547: POP
75548: POP
// if selected then
75549: LD_VAR 0 7
75553: IFFALSE 75652
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75555: LD_ADDR_VAR 0 3
75559: PUSH
75560: LD_EXP 87
75564: PUSH
75565: LD_VAR 0 2
75569: ARRAY
75570: PPUSH
75571: LD_INT 25
75573: PUSH
75574: LD_INT 12
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PPUSH
75581: CALL_OW 72
75585: PUSH
75586: FOR_IN
75587: IFFALSE 75650
// if not HasTask ( j ) then
75589: LD_VAR 0 3
75593: PPUSH
75594: CALL_OW 314
75598: NOT
75599: IFFALSE 75648
// begin if not IsInUnit ( j ) then
75601: LD_VAR 0 3
75605: PPUSH
75606: CALL_OW 310
75610: NOT
75611: IFFALSE 75627
// ComEnterUnit ( j , selected ) ;
75613: LD_VAR 0 3
75617: PPUSH
75618: LD_VAR 0 7
75622: PPUSH
75623: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75627: LD_VAR 0 3
75631: PPUSH
75632: LD_INT 16
75634: PPUSH
75635: CALL_OW 183
// AddComExitBuilding ( j ) ;
75639: LD_VAR 0 3
75643: PPUSH
75644: CALL_OW 182
// end ;
75648: GO 75586
75650: POP
75651: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75652: LD_VAR 0 5
75656: PPUSH
75657: LD_INT 11
75659: PPUSH
75660: CALL_OW 325
75664: IFFALSE 75923
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75666: LD_ADDR_VAR 0 4
75670: PUSH
75671: LD_EXP 87
75675: PUSH
75676: LD_VAR 0 2
75680: ARRAY
75681: PPUSH
75682: LD_INT 25
75684: PUSH
75685: LD_INT 16
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PPUSH
75692: CALL_OW 72
75696: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75697: LD_VAR 0 4
75701: PUSH
75702: LD_INT 6
75704: GREATEREQUAL
75705: PUSH
75706: LD_VAR 0 5
75710: PPUSH
75711: LD_INT 2
75713: PPUSH
75714: CALL_OW 325
75718: NOT
75719: OR
75720: IFFALSE 75923
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75722: LD_ADDR_VAR 0 8
75726: PUSH
75727: LD_EXP 58
75731: PUSH
75732: LD_VAR 0 2
75736: ARRAY
75737: PPUSH
75738: LD_INT 2
75740: PUSH
75741: LD_INT 30
75743: PUSH
75744: LD_INT 4
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 30
75753: PUSH
75754: LD_INT 5
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: LIST
75765: PPUSH
75766: CALL_OW 72
75770: ST_TO_ADDR
// if barracks then
75771: LD_VAR 0 8
75775: IFFALSE 75923
// begin selected := 0 ;
75777: LD_ADDR_VAR 0 7
75781: PUSH
75782: LD_INT 0
75784: ST_TO_ADDR
// for j in barracks do
75785: LD_ADDR_VAR 0 3
75789: PUSH
75790: LD_VAR 0 8
75794: PUSH
75795: FOR_IN
75796: IFFALSE 75827
// begin if UnitsInside ( j ) < 6 then
75798: LD_VAR 0 3
75802: PPUSH
75803: CALL_OW 313
75807: PUSH
75808: LD_INT 6
75810: LESS
75811: IFFALSE 75825
// begin selected := j ;
75813: LD_ADDR_VAR 0 7
75817: PUSH
75818: LD_VAR 0 3
75822: ST_TO_ADDR
// break ;
75823: GO 75827
// end ; end ;
75825: GO 75795
75827: POP
75828: POP
// if selected then
75829: LD_VAR 0 7
75833: IFFALSE 75923
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75835: LD_ADDR_VAR 0 3
75839: PUSH
75840: LD_EXP 87
75844: PUSH
75845: LD_VAR 0 2
75849: ARRAY
75850: PPUSH
75851: LD_INT 25
75853: PUSH
75854: LD_INT 12
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PPUSH
75861: CALL_OW 72
75865: PUSH
75866: FOR_IN
75867: IFFALSE 75921
// if not IsInUnit ( j ) and not HasTask ( j ) then
75869: LD_VAR 0 3
75873: PPUSH
75874: CALL_OW 310
75878: NOT
75879: PUSH
75880: LD_VAR 0 3
75884: PPUSH
75885: CALL_OW 314
75889: NOT
75890: AND
75891: IFFALSE 75919
// begin ComEnterUnit ( j , selected ) ;
75893: LD_VAR 0 3
75897: PPUSH
75898: LD_VAR 0 7
75902: PPUSH
75903: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75907: LD_VAR 0 3
75911: PPUSH
75912: LD_INT 15
75914: PPUSH
75915: CALL_OW 183
// end ;
75919: GO 75866
75921: POP
75922: POP
// end ; end ; end ; end ; end ;
75923: GO 75316
75925: POP
75926: POP
// end ;
75927: LD_VAR 0 1
75931: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75932: LD_INT 0
75934: PPUSH
75935: PPUSH
75936: PPUSH
75937: PPUSH
// if not mc_bases then
75938: LD_EXP 58
75942: NOT
75943: IFFALSE 75947
// exit ;
75945: GO 76125
// for i = 1 to mc_bases do
75947: LD_ADDR_VAR 0 2
75951: PUSH
75952: DOUBLE
75953: LD_INT 1
75955: DEC
75956: ST_TO_ADDR
75957: LD_EXP 58
75961: PUSH
75962: FOR_TO
75963: IFFALSE 76123
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75965: LD_ADDR_VAR 0 4
75969: PUSH
75970: LD_EXP 58
75974: PUSH
75975: LD_VAR 0 2
75979: ARRAY
75980: PPUSH
75981: LD_INT 25
75983: PUSH
75984: LD_INT 9
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PPUSH
75991: CALL_OW 72
75995: ST_TO_ADDR
// if not tmp then
75996: LD_VAR 0 4
76000: NOT
76001: IFFALSE 76005
// continue ;
76003: GO 75962
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76005: LD_EXP 84
76009: PUSH
76010: LD_VAR 0 2
76014: ARRAY
76015: PPUSH
76016: LD_INT 29
76018: PPUSH
76019: CALL_OW 325
76023: NOT
76024: PUSH
76025: LD_EXP 84
76029: PUSH
76030: LD_VAR 0 2
76034: ARRAY
76035: PPUSH
76036: LD_INT 28
76038: PPUSH
76039: CALL_OW 325
76043: NOT
76044: AND
76045: IFFALSE 76049
// continue ;
76047: GO 75962
// for j in tmp do
76049: LD_ADDR_VAR 0 3
76053: PUSH
76054: LD_VAR 0 4
76058: PUSH
76059: FOR_IN
76060: IFFALSE 76119
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76062: LD_VAR 0 3
76066: PUSH
76067: LD_EXP 61
76071: PUSH
76072: LD_VAR 0 2
76076: ARRAY
76077: PUSH
76078: LD_INT 1
76080: ARRAY
76081: IN
76082: NOT
76083: PUSH
76084: LD_VAR 0 3
76088: PUSH
76089: LD_EXP 61
76093: PUSH
76094: LD_VAR 0 2
76098: ARRAY
76099: PUSH
76100: LD_INT 2
76102: ARRAY
76103: IN
76104: NOT
76105: AND
76106: IFFALSE 76117
// ComSpaceTimeShoot ( j ) ;
76108: LD_VAR 0 3
76112: PPUSH
76113: CALL 14725 0 1
76117: GO 76059
76119: POP
76120: POP
// end ;
76121: GO 75962
76123: POP
76124: POP
// end ;
76125: LD_VAR 0 1
76129: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76130: LD_INT 0
76132: PPUSH
76133: PPUSH
76134: PPUSH
76135: PPUSH
76136: PPUSH
76137: PPUSH
76138: PPUSH
76139: PPUSH
76140: PPUSH
// if not mc_bases then
76141: LD_EXP 58
76145: NOT
76146: IFFALSE 76150
// exit ;
76148: GO 76772
// for i = 1 to mc_bases do
76150: LD_ADDR_VAR 0 2
76154: PUSH
76155: DOUBLE
76156: LD_INT 1
76158: DEC
76159: ST_TO_ADDR
76160: LD_EXP 58
76164: PUSH
76165: FOR_TO
76166: IFFALSE 76770
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76168: LD_EXP 93
76172: PUSH
76173: LD_VAR 0 2
76177: ARRAY
76178: NOT
76179: PUSH
76180: LD_INT 38
76182: PPUSH
76183: LD_EXP 84
76187: PUSH
76188: LD_VAR 0 2
76192: ARRAY
76193: PPUSH
76194: CALL_OW 321
76198: PUSH
76199: LD_INT 2
76201: NONEQUAL
76202: OR
76203: IFFALSE 76207
// continue ;
76205: GO 76165
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76207: LD_ADDR_VAR 0 8
76211: PUSH
76212: LD_EXP 58
76216: PUSH
76217: LD_VAR 0 2
76221: ARRAY
76222: PPUSH
76223: LD_INT 30
76225: PUSH
76226: LD_INT 34
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PPUSH
76233: CALL_OW 72
76237: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76238: LD_ADDR_VAR 0 9
76242: PUSH
76243: LD_EXP 58
76247: PUSH
76248: LD_VAR 0 2
76252: ARRAY
76253: PPUSH
76254: LD_INT 25
76256: PUSH
76257: LD_INT 4
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PPUSH
76264: CALL_OW 72
76268: PPUSH
76269: LD_INT 0
76271: PPUSH
76272: CALL 53901 0 2
76276: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76277: LD_VAR 0 9
76281: NOT
76282: PUSH
76283: LD_VAR 0 8
76287: NOT
76288: OR
76289: PUSH
76290: LD_EXP 58
76294: PUSH
76295: LD_VAR 0 2
76299: ARRAY
76300: PPUSH
76301: LD_INT 124
76303: PPUSH
76304: CALL 53901 0 2
76308: OR
76309: IFFALSE 76313
// continue ;
76311: GO 76165
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76313: LD_EXP 94
76317: PUSH
76318: LD_VAR 0 2
76322: ARRAY
76323: PUSH
76324: LD_EXP 93
76328: PUSH
76329: LD_VAR 0 2
76333: ARRAY
76334: LESS
76335: PUSH
76336: LD_EXP 94
76340: PUSH
76341: LD_VAR 0 2
76345: ARRAY
76346: PUSH
76347: LD_VAR 0 8
76351: LESS
76352: AND
76353: IFFALSE 76768
// begin tmp := sci [ 1 ] ;
76355: LD_ADDR_VAR 0 7
76359: PUSH
76360: LD_VAR 0 9
76364: PUSH
76365: LD_INT 1
76367: ARRAY
76368: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76369: LD_VAR 0 7
76373: PPUSH
76374: LD_INT 124
76376: PPUSH
76377: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76381: LD_ADDR_VAR 0 3
76385: PUSH
76386: DOUBLE
76387: LD_EXP 93
76391: PUSH
76392: LD_VAR 0 2
76396: ARRAY
76397: INC
76398: ST_TO_ADDR
76399: LD_EXP 93
76403: PUSH
76404: LD_VAR 0 2
76408: ARRAY
76409: PUSH
76410: FOR_DOWNTO
76411: IFFALSE 76754
// begin if IsInUnit ( tmp ) then
76413: LD_VAR 0 7
76417: PPUSH
76418: CALL_OW 310
76422: IFFALSE 76433
// ComExitBuilding ( tmp ) ;
76424: LD_VAR 0 7
76428: PPUSH
76429: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76433: LD_INT 35
76435: PPUSH
76436: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76440: LD_VAR 0 7
76444: PPUSH
76445: CALL_OW 310
76449: NOT
76450: PUSH
76451: LD_VAR 0 7
76455: PPUSH
76456: CALL_OW 314
76460: NOT
76461: AND
76462: IFFALSE 76433
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76464: LD_ADDR_VAR 0 6
76468: PUSH
76469: LD_VAR 0 7
76473: PPUSH
76474: CALL_OW 250
76478: PUSH
76479: LD_VAR 0 7
76483: PPUSH
76484: CALL_OW 251
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76493: LD_INT 35
76495: PPUSH
76496: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76500: LD_ADDR_VAR 0 4
76504: PUSH
76505: LD_EXP 93
76509: PUSH
76510: LD_VAR 0 2
76514: ARRAY
76515: PUSH
76516: LD_VAR 0 3
76520: ARRAY
76521: PUSH
76522: LD_INT 1
76524: ARRAY
76525: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76526: LD_ADDR_VAR 0 5
76530: PUSH
76531: LD_EXP 93
76535: PUSH
76536: LD_VAR 0 2
76540: ARRAY
76541: PUSH
76542: LD_VAR 0 3
76546: ARRAY
76547: PUSH
76548: LD_INT 2
76550: ARRAY
76551: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76552: LD_VAR 0 7
76556: PPUSH
76557: LD_INT 10
76559: PPUSH
76560: CALL 23258 0 2
76564: PUSH
76565: LD_INT 4
76567: ARRAY
76568: IFFALSE 76606
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76570: LD_VAR 0 7
76574: PPUSH
76575: LD_VAR 0 6
76579: PUSH
76580: LD_INT 1
76582: ARRAY
76583: PPUSH
76584: LD_VAR 0 6
76588: PUSH
76589: LD_INT 2
76591: ARRAY
76592: PPUSH
76593: CALL_OW 111
// wait ( 0 0$10 ) ;
76597: LD_INT 350
76599: PPUSH
76600: CALL_OW 67
// end else
76604: GO 76632
// begin ComMoveXY ( tmp , x , y ) ;
76606: LD_VAR 0 7
76610: PPUSH
76611: LD_VAR 0 4
76615: PPUSH
76616: LD_VAR 0 5
76620: PPUSH
76621: CALL_OW 111
// wait ( 0 0$3 ) ;
76625: LD_INT 105
76627: PPUSH
76628: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76632: LD_VAR 0 7
76636: PPUSH
76637: LD_VAR 0 4
76641: PPUSH
76642: LD_VAR 0 5
76646: PPUSH
76647: CALL_OW 307
76651: IFFALSE 76493
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76653: LD_VAR 0 7
76657: PPUSH
76658: LD_VAR 0 4
76662: PPUSH
76663: LD_VAR 0 5
76667: PPUSH
76668: LD_VAR 0 8
76672: PUSH
76673: LD_VAR 0 3
76677: ARRAY
76678: PPUSH
76679: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76683: LD_INT 35
76685: PPUSH
76686: CALL_OW 67
// until not HasTask ( tmp ) ;
76690: LD_VAR 0 7
76694: PPUSH
76695: CALL_OW 314
76699: NOT
76700: IFFALSE 76683
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76702: LD_ADDR_EXP 94
76706: PUSH
76707: LD_EXP 94
76711: PPUSH
76712: LD_VAR 0 2
76716: PUSH
76717: LD_EXP 94
76721: PUSH
76722: LD_VAR 0 2
76726: ARRAY
76727: PUSH
76728: LD_INT 1
76730: PLUS
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PPUSH
76736: LD_VAR 0 8
76740: PUSH
76741: LD_VAR 0 3
76745: ARRAY
76746: PPUSH
76747: CALL 20665 0 3
76751: ST_TO_ADDR
// end ;
76752: GO 76410
76754: POP
76755: POP
// MC_Reset ( i , 124 ) ;
76756: LD_VAR 0 2
76760: PPUSH
76761: LD_INT 124
76763: PPUSH
76764: CALL 60559 0 2
// end ; end ;
76768: GO 76165
76770: POP
76771: POP
// end ;
76772: LD_VAR 0 1
76776: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76777: LD_INT 0
76779: PPUSH
76780: PPUSH
76781: PPUSH
// if not mc_bases then
76782: LD_EXP 58
76786: NOT
76787: IFFALSE 76791
// exit ;
76789: GO 77397
// for i = 1 to mc_bases do
76791: LD_ADDR_VAR 0 2
76795: PUSH
76796: DOUBLE
76797: LD_INT 1
76799: DEC
76800: ST_TO_ADDR
76801: LD_EXP 58
76805: PUSH
76806: FOR_TO
76807: IFFALSE 77395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76809: LD_ADDR_VAR 0 3
76813: PUSH
76814: LD_EXP 58
76818: PUSH
76819: LD_VAR 0 2
76823: ARRAY
76824: PPUSH
76825: LD_INT 25
76827: PUSH
76828: LD_INT 4
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PPUSH
76835: CALL_OW 72
76839: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76840: LD_VAR 0 3
76844: NOT
76845: PUSH
76846: LD_EXP 95
76850: PUSH
76851: LD_VAR 0 2
76855: ARRAY
76856: NOT
76857: OR
76858: PUSH
76859: LD_EXP 58
76863: PUSH
76864: LD_VAR 0 2
76868: ARRAY
76869: PPUSH
76870: LD_INT 2
76872: PUSH
76873: LD_INT 30
76875: PUSH
76876: LD_INT 0
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 30
76885: PUSH
76886: LD_INT 1
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: LIST
76897: PPUSH
76898: CALL_OW 72
76902: NOT
76903: OR
76904: IFFALSE 76954
// begin if mc_deposits_finder [ i ] then
76906: LD_EXP 96
76910: PUSH
76911: LD_VAR 0 2
76915: ARRAY
76916: IFFALSE 76952
// begin MC_Reset ( i , 125 ) ;
76918: LD_VAR 0 2
76922: PPUSH
76923: LD_INT 125
76925: PPUSH
76926: CALL 60559 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76930: LD_ADDR_EXP 96
76934: PUSH
76935: LD_EXP 96
76939: PPUSH
76940: LD_VAR 0 2
76944: PPUSH
76945: EMPTY
76946: PPUSH
76947: CALL_OW 1
76951: ST_TO_ADDR
// end ; continue ;
76952: GO 76806
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76954: LD_EXP 95
76958: PUSH
76959: LD_VAR 0 2
76963: ARRAY
76964: PUSH
76965: LD_INT 1
76967: ARRAY
76968: PUSH
76969: LD_INT 3
76971: ARRAY
76972: PUSH
76973: LD_INT 1
76975: EQUAL
76976: PUSH
76977: LD_INT 20
76979: PPUSH
76980: LD_EXP 84
76984: PUSH
76985: LD_VAR 0 2
76989: ARRAY
76990: PPUSH
76991: CALL_OW 321
76995: PUSH
76996: LD_INT 2
76998: NONEQUAL
76999: AND
77000: IFFALSE 77050
// begin if mc_deposits_finder [ i ] then
77002: LD_EXP 96
77006: PUSH
77007: LD_VAR 0 2
77011: ARRAY
77012: IFFALSE 77048
// begin MC_Reset ( i , 125 ) ;
77014: LD_VAR 0 2
77018: PPUSH
77019: LD_INT 125
77021: PPUSH
77022: CALL 60559 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77026: LD_ADDR_EXP 96
77030: PUSH
77031: LD_EXP 96
77035: PPUSH
77036: LD_VAR 0 2
77040: PPUSH
77041: EMPTY
77042: PPUSH
77043: CALL_OW 1
77047: ST_TO_ADDR
// end ; continue ;
77048: GO 76806
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77050: LD_EXP 95
77054: PUSH
77055: LD_VAR 0 2
77059: ARRAY
77060: PUSH
77061: LD_INT 1
77063: ARRAY
77064: PUSH
77065: LD_INT 1
77067: ARRAY
77068: PPUSH
77069: LD_EXP 95
77073: PUSH
77074: LD_VAR 0 2
77078: ARRAY
77079: PUSH
77080: LD_INT 1
77082: ARRAY
77083: PUSH
77084: LD_INT 2
77086: ARRAY
77087: PPUSH
77088: LD_EXP 84
77092: PUSH
77093: LD_VAR 0 2
77097: ARRAY
77098: PPUSH
77099: CALL_OW 440
77103: IFFALSE 77146
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77105: LD_ADDR_EXP 95
77109: PUSH
77110: LD_EXP 95
77114: PPUSH
77115: LD_VAR 0 2
77119: PPUSH
77120: LD_EXP 95
77124: PUSH
77125: LD_VAR 0 2
77129: ARRAY
77130: PPUSH
77131: LD_INT 1
77133: PPUSH
77134: CALL_OW 3
77138: PPUSH
77139: CALL_OW 1
77143: ST_TO_ADDR
77144: GO 77393
// begin if not mc_deposits_finder [ i ] then
77146: LD_EXP 96
77150: PUSH
77151: LD_VAR 0 2
77155: ARRAY
77156: NOT
77157: IFFALSE 77209
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77159: LD_ADDR_EXP 96
77163: PUSH
77164: LD_EXP 96
77168: PPUSH
77169: LD_VAR 0 2
77173: PPUSH
77174: LD_VAR 0 3
77178: PUSH
77179: LD_INT 1
77181: ARRAY
77182: PUSH
77183: EMPTY
77184: LIST
77185: PPUSH
77186: CALL_OW 1
77190: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77191: LD_VAR 0 3
77195: PUSH
77196: LD_INT 1
77198: ARRAY
77199: PPUSH
77200: LD_INT 125
77202: PPUSH
77203: CALL_OW 109
// end else
77207: GO 77393
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77209: LD_EXP 96
77213: PUSH
77214: LD_VAR 0 2
77218: ARRAY
77219: PUSH
77220: LD_INT 1
77222: ARRAY
77223: PPUSH
77224: CALL_OW 310
77228: IFFALSE 77251
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77230: LD_EXP 96
77234: PUSH
77235: LD_VAR 0 2
77239: ARRAY
77240: PUSH
77241: LD_INT 1
77243: ARRAY
77244: PPUSH
77245: CALL_OW 122
77249: GO 77393
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77251: LD_EXP 96
77255: PUSH
77256: LD_VAR 0 2
77260: ARRAY
77261: PUSH
77262: LD_INT 1
77264: ARRAY
77265: PPUSH
77266: CALL_OW 314
77270: NOT
77271: PUSH
77272: LD_EXP 96
77276: PUSH
77277: LD_VAR 0 2
77281: ARRAY
77282: PUSH
77283: LD_INT 1
77285: ARRAY
77286: PPUSH
77287: LD_EXP 95
77291: PUSH
77292: LD_VAR 0 2
77296: ARRAY
77297: PUSH
77298: LD_INT 1
77300: ARRAY
77301: PUSH
77302: LD_INT 1
77304: ARRAY
77305: PPUSH
77306: LD_EXP 95
77310: PUSH
77311: LD_VAR 0 2
77315: ARRAY
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PUSH
77321: LD_INT 2
77323: ARRAY
77324: PPUSH
77325: CALL_OW 297
77329: PUSH
77330: LD_INT 6
77332: GREATER
77333: AND
77334: IFFALSE 77393
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77336: LD_EXP 96
77340: PUSH
77341: LD_VAR 0 2
77345: ARRAY
77346: PUSH
77347: LD_INT 1
77349: ARRAY
77350: PPUSH
77351: LD_EXP 95
77355: PUSH
77356: LD_VAR 0 2
77360: ARRAY
77361: PUSH
77362: LD_INT 1
77364: ARRAY
77365: PUSH
77366: LD_INT 1
77368: ARRAY
77369: PPUSH
77370: LD_EXP 95
77374: PUSH
77375: LD_VAR 0 2
77379: ARRAY
77380: PUSH
77381: LD_INT 1
77383: ARRAY
77384: PUSH
77385: LD_INT 2
77387: ARRAY
77388: PPUSH
77389: CALL_OW 111
// end ; end ; end ;
77393: GO 76806
77395: POP
77396: POP
// end ;
77397: LD_VAR 0 1
77401: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77402: LD_INT 0
77404: PPUSH
77405: PPUSH
77406: PPUSH
77407: PPUSH
77408: PPUSH
77409: PPUSH
77410: PPUSH
77411: PPUSH
77412: PPUSH
77413: PPUSH
77414: PPUSH
// if not mc_bases then
77415: LD_EXP 58
77419: NOT
77420: IFFALSE 77424
// exit ;
77422: GO 78148
// for i = 1 to mc_bases do
77424: LD_ADDR_VAR 0 2
77428: PUSH
77429: DOUBLE
77430: LD_INT 1
77432: DEC
77433: ST_TO_ADDR
77434: LD_EXP 58
77438: PUSH
77439: FOR_TO
77440: IFFALSE 78146
// begin if not mc_bases [ i ] then
77442: LD_EXP 58
77446: PUSH
77447: LD_VAR 0 2
77451: ARRAY
77452: NOT
77453: IFFALSE 77457
// continue ;
77455: GO 77439
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77457: LD_ADDR_VAR 0 7
77461: PUSH
77462: LD_EXP 58
77466: PUSH
77467: LD_VAR 0 2
77471: ARRAY
77472: PUSH
77473: LD_INT 1
77475: ARRAY
77476: PPUSH
77477: CALL_OW 248
77481: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77482: LD_VAR 0 7
77486: PUSH
77487: LD_INT 3
77489: EQUAL
77490: PUSH
77491: LD_EXP 77
77495: PUSH
77496: LD_VAR 0 2
77500: ARRAY
77501: PUSH
77502: LD_EXP 80
77506: PUSH
77507: LD_VAR 0 2
77511: ARRAY
77512: UNION
77513: PPUSH
77514: LD_INT 33
77516: PUSH
77517: LD_INT 2
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PPUSH
77524: CALL_OW 72
77528: NOT
77529: OR
77530: IFFALSE 77534
// continue ;
77532: GO 77439
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77534: LD_ADDR_VAR 0 9
77538: PUSH
77539: LD_EXP 58
77543: PUSH
77544: LD_VAR 0 2
77548: ARRAY
77549: PPUSH
77550: LD_INT 30
77552: PUSH
77553: LD_INT 36
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PPUSH
77560: CALL_OW 72
77564: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77565: LD_ADDR_VAR 0 10
77569: PUSH
77570: LD_EXP 77
77574: PUSH
77575: LD_VAR 0 2
77579: ARRAY
77580: PPUSH
77581: LD_INT 34
77583: PUSH
77584: LD_INT 31
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PPUSH
77591: CALL_OW 72
77595: ST_TO_ADDR
// if not cts and not mcts then
77596: LD_VAR 0 9
77600: NOT
77601: PUSH
77602: LD_VAR 0 10
77606: NOT
77607: AND
77608: IFFALSE 77612
// continue ;
77610: GO 77439
// x := cts ;
77612: LD_ADDR_VAR 0 11
77616: PUSH
77617: LD_VAR 0 9
77621: ST_TO_ADDR
// if not x then
77622: LD_VAR 0 11
77626: NOT
77627: IFFALSE 77639
// x := mcts ;
77629: LD_ADDR_VAR 0 11
77633: PUSH
77634: LD_VAR 0 10
77638: ST_TO_ADDR
// if mc_remote_driver [ i ] then
77639: LD_EXP 98
77643: PUSH
77644: LD_VAR 0 2
77648: ARRAY
77649: IFFALSE 77918
// for j in mc_remote_driver [ i ] do
77651: LD_ADDR_VAR 0 3
77655: PUSH
77656: LD_EXP 98
77660: PUSH
77661: LD_VAR 0 2
77665: ARRAY
77666: PUSH
77667: FOR_IN
77668: IFFALSE 77916
// begin if GetClass ( j ) <> 3 then
77670: LD_VAR 0 3
77674: PPUSH
77675: CALL_OW 257
77679: PUSH
77680: LD_INT 3
77682: NONEQUAL
77683: IFFALSE 77736
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77685: LD_ADDR_EXP 98
77689: PUSH
77690: LD_EXP 98
77694: PPUSH
77695: LD_VAR 0 2
77699: PPUSH
77700: LD_EXP 98
77704: PUSH
77705: LD_VAR 0 2
77709: ARRAY
77710: PUSH
77711: LD_VAR 0 3
77715: DIFF
77716: PPUSH
77717: CALL_OW 1
77721: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77722: LD_VAR 0 3
77726: PPUSH
77727: LD_INT 0
77729: PPUSH
77730: CALL_OW 109
// continue ;
77734: GO 77667
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77736: LD_VAR 0 3
77740: PPUSH
77741: CALL_OW 310
77745: NOT
77746: PUSH
77747: LD_VAR 0 3
77751: PPUSH
77752: CALL_OW 310
77756: PPUSH
77757: CALL_OW 266
77761: PUSH
77762: LD_INT 36
77764: NONEQUAL
77765: PUSH
77766: LD_VAR 0 3
77770: PPUSH
77771: CALL 53989 0 1
77775: NOT
77776: AND
77777: OR
77778: IFFALSE 77914
// begin if IsInUnit ( j ) then
77780: LD_VAR 0 3
77784: PPUSH
77785: CALL_OW 310
77789: IFFALSE 77800
// ComExitBuilding ( j ) ;
77791: LD_VAR 0 3
77795: PPUSH
77796: CALL_OW 122
// ct := 0 ;
77800: LD_ADDR_VAR 0 8
77804: PUSH
77805: LD_INT 0
77807: ST_TO_ADDR
// for k in x do
77808: LD_ADDR_VAR 0 4
77812: PUSH
77813: LD_VAR 0 11
77817: PUSH
77818: FOR_IN
77819: IFFALSE 77892
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77821: LD_VAR 0 4
77825: PPUSH
77826: CALL_OW 264
77830: PUSH
77831: LD_INT 31
77833: EQUAL
77834: PUSH
77835: LD_VAR 0 4
77839: PPUSH
77840: CALL_OW 311
77844: NOT
77845: AND
77846: PUSH
77847: LD_VAR 0 4
77851: PPUSH
77852: CALL_OW 266
77856: PUSH
77857: LD_INT 36
77859: EQUAL
77860: PUSH
77861: LD_VAR 0 4
77865: PPUSH
77866: CALL_OW 313
77870: PUSH
77871: LD_INT 3
77873: LESS
77874: AND
77875: OR
77876: IFFALSE 77890
// begin ct := k ;
77878: LD_ADDR_VAR 0 8
77882: PUSH
77883: LD_VAR 0 4
77887: ST_TO_ADDR
// break ;
77888: GO 77892
// end ;
77890: GO 77818
77892: POP
77893: POP
// if ct then
77894: LD_VAR 0 8
77898: IFFALSE 77914
// ComEnterUnit ( j , ct ) ;
77900: LD_VAR 0 3
77904: PPUSH
77905: LD_VAR 0 8
77909: PPUSH
77910: CALL_OW 120
// end ; end ;
77914: GO 77667
77916: POP
77917: POP
// places := 0 ;
77918: LD_ADDR_VAR 0 5
77922: PUSH
77923: LD_INT 0
77925: ST_TO_ADDR
// for j = 1 to x do
77926: LD_ADDR_VAR 0 3
77930: PUSH
77931: DOUBLE
77932: LD_INT 1
77934: DEC
77935: ST_TO_ADDR
77936: LD_VAR 0 11
77940: PUSH
77941: FOR_TO
77942: IFFALSE 77997
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77944: LD_VAR 0 11
77948: PUSH
77949: LD_VAR 0 3
77953: ARRAY
77954: PPUSH
77955: CALL_OW 264
77959: PUSH
77960: LD_INT 31
77962: EQUAL
77963: IFFALSE 77981
// places := places + 1 else
77965: LD_ADDR_VAR 0 5
77969: PUSH
77970: LD_VAR 0 5
77974: PUSH
77975: LD_INT 1
77977: PLUS
77978: ST_TO_ADDR
77979: GO 77995
// places := places + 3 ;
77981: LD_ADDR_VAR 0 5
77985: PUSH
77986: LD_VAR 0 5
77990: PUSH
77991: LD_INT 3
77993: PLUS
77994: ST_TO_ADDR
77995: GO 77941
77997: POP
77998: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77999: LD_ADDR_VAR 0 6
78003: PUSH
78004: LD_EXP 58
78008: PUSH
78009: LD_VAR 0 2
78013: ARRAY
78014: PPUSH
78015: LD_INT 25
78017: PUSH
78018: LD_INT 3
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PPUSH
78025: CALL_OW 72
78029: PUSH
78030: LD_EXP 98
78034: PUSH
78035: LD_VAR 0 2
78039: ARRAY
78040: DIFF
78041: PPUSH
78042: LD_INT 3
78044: PPUSH
78045: CALL 54889 0 2
78049: ST_TO_ADDR
// if not tmp then
78050: LD_VAR 0 6
78054: NOT
78055: IFFALSE 78059
// continue ;
78057: GO 77439
// places := places - mc_remote_driver [ i ] ;
78059: LD_ADDR_VAR 0 5
78063: PUSH
78064: LD_VAR 0 5
78068: PUSH
78069: LD_EXP 98
78073: PUSH
78074: LD_VAR 0 2
78078: ARRAY
78079: MINUS
78080: ST_TO_ADDR
// if places then
78081: LD_VAR 0 5
78085: IFFALSE 78144
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78087: LD_ADDR_EXP 98
78091: PUSH
78092: LD_EXP 98
78096: PPUSH
78097: LD_VAR 0 2
78101: PPUSH
78102: LD_EXP 98
78106: PUSH
78107: LD_VAR 0 2
78111: ARRAY
78112: PUSH
78113: LD_VAR 0 6
78117: PUSH
78118: LD_INT 1
78120: ARRAY
78121: UNION
78122: PPUSH
78123: CALL_OW 1
78127: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78128: LD_VAR 0 6
78132: PUSH
78133: LD_INT 1
78135: ARRAY
78136: PPUSH
78137: LD_INT 126
78139: PPUSH
78140: CALL_OW 109
// end ; end ;
78144: GO 77439
78146: POP
78147: POP
// end ;
78148: LD_VAR 0 1
78152: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78153: LD_INT 0
78155: PPUSH
78156: PPUSH
78157: PPUSH
78158: PPUSH
78159: PPUSH
78160: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78161: LD_VAR 0 1
78165: NOT
78166: PUSH
78167: LD_VAR 0 2
78171: NOT
78172: OR
78173: PUSH
78174: LD_VAR 0 3
78178: NOT
78179: OR
78180: PUSH
78181: LD_VAR 0 4
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: LD_INT 3
78194: PUSH
78195: LD_INT 4
78197: PUSH
78198: LD_INT 5
78200: PUSH
78201: LD_INT 8
78203: PUSH
78204: LD_INT 9
78206: PUSH
78207: LD_INT 15
78209: PUSH
78210: LD_INT 16
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: IN
78224: NOT
78225: OR
78226: IFFALSE 78230
// exit ;
78228: GO 79130
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78230: LD_ADDR_VAR 0 2
78234: PUSH
78235: LD_VAR 0 2
78239: PPUSH
78240: LD_INT 21
78242: PUSH
78243: LD_INT 3
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 24
78252: PUSH
78253: LD_INT 250
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PPUSH
78264: CALL_OW 72
78268: ST_TO_ADDR
// case class of 1 , 15 :
78269: LD_VAR 0 4
78273: PUSH
78274: LD_INT 1
78276: DOUBLE
78277: EQUAL
78278: IFTRUE 78288
78280: LD_INT 15
78282: DOUBLE
78283: EQUAL
78284: IFTRUE 78288
78286: GO 78373
78288: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78289: LD_ADDR_VAR 0 8
78293: PUSH
78294: LD_VAR 0 2
78298: PPUSH
78299: LD_INT 2
78301: PUSH
78302: LD_INT 30
78304: PUSH
78305: LD_INT 32
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 30
78314: PUSH
78315: LD_INT 31
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: LIST
78326: PPUSH
78327: CALL_OW 72
78331: PUSH
78332: LD_VAR 0 2
78336: PPUSH
78337: LD_INT 2
78339: PUSH
78340: LD_INT 30
78342: PUSH
78343: LD_INT 4
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 30
78352: PUSH
78353: LD_INT 5
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: LIST
78364: PPUSH
78365: CALL_OW 72
78369: ADD
78370: ST_TO_ADDR
78371: GO 78619
78373: LD_INT 2
78375: DOUBLE
78376: EQUAL
78377: IFTRUE 78387
78379: LD_INT 16
78381: DOUBLE
78382: EQUAL
78383: IFTRUE 78387
78385: GO 78433
78387: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78388: LD_ADDR_VAR 0 8
78392: PUSH
78393: LD_VAR 0 2
78397: PPUSH
78398: LD_INT 2
78400: PUSH
78401: LD_INT 30
78403: PUSH
78404: LD_INT 0
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 30
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: LIST
78425: PPUSH
78426: CALL_OW 72
78430: ST_TO_ADDR
78431: GO 78619
78433: LD_INT 3
78435: DOUBLE
78436: EQUAL
78437: IFTRUE 78441
78439: GO 78487
78441: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78442: LD_ADDR_VAR 0 8
78446: PUSH
78447: LD_VAR 0 2
78451: PPUSH
78452: LD_INT 2
78454: PUSH
78455: LD_INT 30
78457: PUSH
78458: LD_INT 2
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 30
78467: PUSH
78468: LD_INT 3
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: LIST
78479: PPUSH
78480: CALL_OW 72
78484: ST_TO_ADDR
78485: GO 78619
78487: LD_INT 4
78489: DOUBLE
78490: EQUAL
78491: IFTRUE 78495
78493: GO 78552
78495: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78496: LD_ADDR_VAR 0 8
78500: PUSH
78501: LD_VAR 0 2
78505: PPUSH
78506: LD_INT 2
78508: PUSH
78509: LD_INT 30
78511: PUSH
78512: LD_INT 6
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 30
78521: PUSH
78522: LD_INT 7
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 30
78531: PUSH
78532: LD_INT 8
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: PPUSH
78545: CALL_OW 72
78549: ST_TO_ADDR
78550: GO 78619
78552: LD_INT 5
78554: DOUBLE
78555: EQUAL
78556: IFTRUE 78572
78558: LD_INT 8
78560: DOUBLE
78561: EQUAL
78562: IFTRUE 78572
78564: LD_INT 9
78566: DOUBLE
78567: EQUAL
78568: IFTRUE 78572
78570: GO 78618
78572: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78573: LD_ADDR_VAR 0 8
78577: PUSH
78578: LD_VAR 0 2
78582: PPUSH
78583: LD_INT 2
78585: PUSH
78586: LD_INT 30
78588: PUSH
78589: LD_INT 4
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 30
78598: PUSH
78599: LD_INT 5
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: LIST
78610: PPUSH
78611: CALL_OW 72
78615: ST_TO_ADDR
78616: GO 78619
78618: POP
// if not tmp then
78619: LD_VAR 0 8
78623: NOT
78624: IFFALSE 78628
// exit ;
78626: GO 79130
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78628: LD_VAR 0 4
78632: PUSH
78633: LD_INT 1
78635: PUSH
78636: LD_INT 15
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: IN
78643: PUSH
78644: LD_EXP 67
78648: PUSH
78649: LD_VAR 0 1
78653: ARRAY
78654: AND
78655: IFFALSE 78811
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78657: LD_ADDR_VAR 0 9
78661: PUSH
78662: LD_EXP 67
78666: PUSH
78667: LD_VAR 0 1
78671: ARRAY
78672: PUSH
78673: LD_INT 1
78675: ARRAY
78676: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78677: LD_VAR 0 9
78681: PUSH
78682: LD_EXP 68
78686: PUSH
78687: LD_VAR 0 1
78691: ARRAY
78692: IN
78693: NOT
78694: IFFALSE 78809
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78696: LD_ADDR_EXP 68
78700: PUSH
78701: LD_EXP 68
78705: PPUSH
78706: LD_VAR 0 1
78710: PUSH
78711: LD_EXP 68
78715: PUSH
78716: LD_VAR 0 1
78720: ARRAY
78721: PUSH
78722: LD_INT 1
78724: PLUS
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PPUSH
78730: LD_VAR 0 9
78734: PPUSH
78735: CALL 20665 0 3
78739: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78740: LD_ADDR_EXP 67
78744: PUSH
78745: LD_EXP 67
78749: PPUSH
78750: LD_VAR 0 1
78754: PPUSH
78755: LD_EXP 67
78759: PUSH
78760: LD_VAR 0 1
78764: ARRAY
78765: PUSH
78766: LD_VAR 0 9
78770: DIFF
78771: PPUSH
78772: CALL_OW 1
78776: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78777: LD_VAR 0 3
78781: PPUSH
78782: LD_EXP 68
78786: PUSH
78787: LD_VAR 0 1
78791: ARRAY
78792: PUSH
78793: LD_EXP 68
78797: PUSH
78798: LD_VAR 0 1
78802: ARRAY
78803: ARRAY
78804: PPUSH
78805: CALL_OW 120
// end ; exit ;
78809: GO 79130
// end ; if tmp > 1 then
78811: LD_VAR 0 8
78815: PUSH
78816: LD_INT 1
78818: GREATER
78819: IFFALSE 78923
// for i = 2 to tmp do
78821: LD_ADDR_VAR 0 6
78825: PUSH
78826: DOUBLE
78827: LD_INT 2
78829: DEC
78830: ST_TO_ADDR
78831: LD_VAR 0 8
78835: PUSH
78836: FOR_TO
78837: IFFALSE 78921
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78839: LD_VAR 0 8
78843: PUSH
78844: LD_VAR 0 6
78848: ARRAY
78849: PPUSH
78850: CALL_OW 461
78854: PUSH
78855: LD_INT 6
78857: EQUAL
78858: IFFALSE 78919
// begin x := tmp [ i ] ;
78860: LD_ADDR_VAR 0 9
78864: PUSH
78865: LD_VAR 0 8
78869: PUSH
78870: LD_VAR 0 6
78874: ARRAY
78875: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78876: LD_ADDR_VAR 0 8
78880: PUSH
78881: LD_VAR 0 8
78885: PPUSH
78886: LD_VAR 0 6
78890: PPUSH
78891: CALL_OW 3
78895: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78896: LD_ADDR_VAR 0 8
78900: PUSH
78901: LD_VAR 0 8
78905: PPUSH
78906: LD_INT 1
78908: PPUSH
78909: LD_VAR 0 9
78913: PPUSH
78914: CALL_OW 2
78918: ST_TO_ADDR
// end ;
78919: GO 78836
78921: POP
78922: POP
// for i in tmp do
78923: LD_ADDR_VAR 0 6
78927: PUSH
78928: LD_VAR 0 8
78932: PUSH
78933: FOR_IN
78934: IFFALSE 79003
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78936: LD_VAR 0 6
78940: PPUSH
78941: CALL_OW 313
78945: PUSH
78946: LD_INT 6
78948: LESS
78949: PUSH
78950: LD_VAR 0 6
78954: PPUSH
78955: CALL_OW 266
78959: PUSH
78960: LD_INT 31
78962: PUSH
78963: LD_INT 32
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: IN
78970: NOT
78971: AND
78972: PUSH
78973: LD_VAR 0 6
78977: PPUSH
78978: CALL_OW 313
78982: PUSH
78983: LD_INT 0
78985: EQUAL
78986: OR
78987: IFFALSE 79001
// begin j := i ;
78989: LD_ADDR_VAR 0 7
78993: PUSH
78994: LD_VAR 0 6
78998: ST_TO_ADDR
// break ;
78999: GO 79003
// end ; end ;
79001: GO 78933
79003: POP
79004: POP
// if j then
79005: LD_VAR 0 7
79009: IFFALSE 79027
// ComEnterUnit ( unit , j ) else
79011: LD_VAR 0 3
79015: PPUSH
79016: LD_VAR 0 7
79020: PPUSH
79021: CALL_OW 120
79025: GO 79130
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79027: LD_ADDR_VAR 0 10
79031: PUSH
79032: LD_VAR 0 2
79036: PPUSH
79037: LD_INT 2
79039: PUSH
79040: LD_INT 30
79042: PUSH
79043: LD_INT 0
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 30
79052: PUSH
79053: LD_INT 1
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: LIST
79064: PPUSH
79065: CALL_OW 72
79069: ST_TO_ADDR
// if depot then
79070: LD_VAR 0 10
79074: IFFALSE 79130
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79076: LD_ADDR_VAR 0 10
79080: PUSH
79081: LD_VAR 0 10
79085: PPUSH
79086: LD_VAR 0 3
79090: PPUSH
79091: CALL_OW 74
79095: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79096: LD_VAR 0 3
79100: PPUSH
79101: LD_VAR 0 10
79105: PPUSH
79106: CALL_OW 296
79110: PUSH
79111: LD_INT 10
79113: GREATER
79114: IFFALSE 79130
// ComStandNearbyBuilding ( unit , depot ) ;
79116: LD_VAR 0 3
79120: PPUSH
79121: LD_VAR 0 10
79125: PPUSH
79126: CALL 15342 0 2
// end ; end ; end ;
79130: LD_VAR 0 5
79134: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79135: LD_INT 0
79137: PPUSH
79138: PPUSH
79139: PPUSH
79140: PPUSH
// if not mc_bases then
79141: LD_EXP 58
79145: NOT
79146: IFFALSE 79150
// exit ;
79148: GO 79389
// for i = 1 to mc_bases do
79150: LD_ADDR_VAR 0 2
79154: PUSH
79155: DOUBLE
79156: LD_INT 1
79158: DEC
79159: ST_TO_ADDR
79160: LD_EXP 58
79164: PUSH
79165: FOR_TO
79166: IFFALSE 79387
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79168: LD_ADDR_VAR 0 4
79172: PUSH
79173: LD_EXP 58
79177: PUSH
79178: LD_VAR 0 2
79182: ARRAY
79183: PPUSH
79184: LD_INT 21
79186: PUSH
79187: LD_INT 1
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PPUSH
79194: CALL_OW 72
79198: PUSH
79199: LD_EXP 87
79203: PUSH
79204: LD_VAR 0 2
79208: ARRAY
79209: UNION
79210: ST_TO_ADDR
// if not tmp then
79211: LD_VAR 0 4
79215: NOT
79216: IFFALSE 79220
// continue ;
79218: GO 79165
// for j in tmp do
79220: LD_ADDR_VAR 0 3
79224: PUSH
79225: LD_VAR 0 4
79229: PUSH
79230: FOR_IN
79231: IFFALSE 79383
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79233: LD_VAR 0 3
79237: PPUSH
79238: CALL_OW 110
79242: NOT
79243: PUSH
79244: LD_VAR 0 3
79248: PPUSH
79249: CALL_OW 314
79253: NOT
79254: AND
79255: PUSH
79256: LD_VAR 0 3
79260: PPUSH
79261: CALL_OW 311
79265: NOT
79266: AND
79267: PUSH
79268: LD_VAR 0 3
79272: PPUSH
79273: CALL_OW 310
79277: NOT
79278: AND
79279: PUSH
79280: LD_VAR 0 3
79284: PUSH
79285: LD_EXP 61
79289: PUSH
79290: LD_VAR 0 2
79294: ARRAY
79295: PUSH
79296: LD_INT 1
79298: ARRAY
79299: IN
79300: NOT
79301: AND
79302: PUSH
79303: LD_VAR 0 3
79307: PUSH
79308: LD_EXP 61
79312: PUSH
79313: LD_VAR 0 2
79317: ARRAY
79318: PUSH
79319: LD_INT 2
79321: ARRAY
79322: IN
79323: NOT
79324: AND
79325: PUSH
79326: LD_VAR 0 3
79330: PUSH
79331: LD_EXP 70
79335: PUSH
79336: LD_VAR 0 2
79340: ARRAY
79341: IN
79342: NOT
79343: AND
79344: IFFALSE 79381
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79346: LD_VAR 0 2
79350: PPUSH
79351: LD_EXP 58
79355: PUSH
79356: LD_VAR 0 2
79360: ARRAY
79361: PPUSH
79362: LD_VAR 0 3
79366: PPUSH
79367: LD_VAR 0 3
79371: PPUSH
79372: CALL_OW 257
79376: PPUSH
79377: CALL 78153 0 4
// end ;
79381: GO 79230
79383: POP
79384: POP
// end ;
79385: GO 79165
79387: POP
79388: POP
// end ;
79389: LD_VAR 0 1
79393: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79394: LD_INT 0
79396: PPUSH
79397: PPUSH
79398: PPUSH
79399: PPUSH
79400: PPUSH
79401: PPUSH
// if not mc_bases [ base ] then
79402: LD_EXP 58
79406: PUSH
79407: LD_VAR 0 1
79411: ARRAY
79412: NOT
79413: IFFALSE 79417
// exit ;
79415: GO 79599
// tmp := [ ] ;
79417: LD_ADDR_VAR 0 6
79421: PUSH
79422: EMPTY
79423: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79424: LD_ADDR_VAR 0 7
79428: PUSH
79429: LD_VAR 0 3
79433: PPUSH
79434: LD_INT 0
79436: PPUSH
79437: CALL_OW 517
79441: ST_TO_ADDR
// if not list then
79442: LD_VAR 0 7
79446: NOT
79447: IFFALSE 79451
// exit ;
79449: GO 79599
// for i = 1 to amount do
79451: LD_ADDR_VAR 0 5
79455: PUSH
79456: DOUBLE
79457: LD_INT 1
79459: DEC
79460: ST_TO_ADDR
79461: LD_VAR 0 2
79465: PUSH
79466: FOR_TO
79467: IFFALSE 79547
// begin x := rand ( 1 , list [ 1 ] ) ;
79469: LD_ADDR_VAR 0 8
79473: PUSH
79474: LD_INT 1
79476: PPUSH
79477: LD_VAR 0 7
79481: PUSH
79482: LD_INT 1
79484: ARRAY
79485: PPUSH
79486: CALL_OW 12
79490: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79491: LD_ADDR_VAR 0 6
79495: PUSH
79496: LD_VAR 0 6
79500: PPUSH
79501: LD_VAR 0 5
79505: PPUSH
79506: LD_VAR 0 7
79510: PUSH
79511: LD_INT 1
79513: ARRAY
79514: PUSH
79515: LD_VAR 0 8
79519: ARRAY
79520: PUSH
79521: LD_VAR 0 7
79525: PUSH
79526: LD_INT 2
79528: ARRAY
79529: PUSH
79530: LD_VAR 0 8
79534: ARRAY
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PPUSH
79540: CALL_OW 1
79544: ST_TO_ADDR
// end ;
79545: GO 79466
79547: POP
79548: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79549: LD_ADDR_EXP 71
79553: PUSH
79554: LD_EXP 71
79558: PPUSH
79559: LD_VAR 0 1
79563: PPUSH
79564: LD_VAR 0 6
79568: PPUSH
79569: CALL_OW 1
79573: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79574: LD_ADDR_EXP 73
79578: PUSH
79579: LD_EXP 73
79583: PPUSH
79584: LD_VAR 0 1
79588: PPUSH
79589: LD_VAR 0 3
79593: PPUSH
79594: CALL_OW 1
79598: ST_TO_ADDR
// end ;
79599: LD_VAR 0 4
79603: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79604: LD_INT 0
79606: PPUSH
// if not mc_bases [ base ] then
79607: LD_EXP 58
79611: PUSH
79612: LD_VAR 0 1
79616: ARRAY
79617: NOT
79618: IFFALSE 79622
// exit ;
79620: GO 79647
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79622: LD_ADDR_EXP 63
79626: PUSH
79627: LD_EXP 63
79631: PPUSH
79632: LD_VAR 0 1
79636: PPUSH
79637: LD_VAR 0 2
79641: PPUSH
79642: CALL_OW 1
79646: ST_TO_ADDR
// end ;
79647: LD_VAR 0 3
79651: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79652: LD_INT 0
79654: PPUSH
// if not mc_bases [ base ] then
79655: LD_EXP 58
79659: PUSH
79660: LD_VAR 0 1
79664: ARRAY
79665: NOT
79666: IFFALSE 79670
// exit ;
79668: GO 79707
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79670: LD_ADDR_EXP 63
79674: PUSH
79675: LD_EXP 63
79679: PPUSH
79680: LD_VAR 0 1
79684: PPUSH
79685: LD_EXP 63
79689: PUSH
79690: LD_VAR 0 1
79694: ARRAY
79695: PUSH
79696: LD_VAR 0 2
79700: UNION
79701: PPUSH
79702: CALL_OW 1
79706: ST_TO_ADDR
// end ;
79707: LD_VAR 0 3
79711: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79712: LD_INT 0
79714: PPUSH
// if not mc_bases [ base ] then
79715: LD_EXP 58
79719: PUSH
79720: LD_VAR 0 1
79724: ARRAY
79725: NOT
79726: IFFALSE 79730
// exit ;
79728: GO 79755
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79730: LD_ADDR_EXP 79
79734: PUSH
79735: LD_EXP 79
79739: PPUSH
79740: LD_VAR 0 1
79744: PPUSH
79745: LD_VAR 0 2
79749: PPUSH
79750: CALL_OW 1
79754: ST_TO_ADDR
// end ;
79755: LD_VAR 0 3
79759: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79760: LD_INT 0
79762: PPUSH
// if not mc_bases [ base ] then
79763: LD_EXP 58
79767: PUSH
79768: LD_VAR 0 1
79772: ARRAY
79773: NOT
79774: IFFALSE 79778
// exit ;
79776: GO 79815
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79778: LD_ADDR_EXP 79
79782: PUSH
79783: LD_EXP 79
79787: PPUSH
79788: LD_VAR 0 1
79792: PPUSH
79793: LD_EXP 79
79797: PUSH
79798: LD_VAR 0 1
79802: ARRAY
79803: PUSH
79804: LD_VAR 0 2
79808: ADD
79809: PPUSH
79810: CALL_OW 1
79814: ST_TO_ADDR
// end ;
79815: LD_VAR 0 3
79819: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79820: LD_INT 0
79822: PPUSH
// if not mc_bases [ base ] then
79823: LD_EXP 58
79827: PUSH
79828: LD_VAR 0 1
79832: ARRAY
79833: NOT
79834: IFFALSE 79838
// exit ;
79836: GO 79892
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79838: LD_ADDR_EXP 80
79842: PUSH
79843: LD_EXP 80
79847: PPUSH
79848: LD_VAR 0 1
79852: PPUSH
79853: LD_VAR 0 2
79857: PPUSH
79858: CALL_OW 1
79862: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79863: LD_ADDR_EXP 69
79867: PUSH
79868: LD_EXP 69
79872: PPUSH
79873: LD_VAR 0 1
79877: PPUSH
79878: LD_VAR 0 2
79882: PUSH
79883: LD_INT 0
79885: PLUS
79886: PPUSH
79887: CALL_OW 1
79891: ST_TO_ADDR
// end ;
79892: LD_VAR 0 3
79896: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79897: LD_INT 0
79899: PPUSH
// if not mc_bases [ base ] then
79900: LD_EXP 58
79904: PUSH
79905: LD_VAR 0 1
79909: ARRAY
79910: NOT
79911: IFFALSE 79915
// exit ;
79913: GO 79940
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79915: LD_ADDR_EXP 69
79919: PUSH
79920: LD_EXP 69
79924: PPUSH
79925: LD_VAR 0 1
79929: PPUSH
79930: LD_VAR 0 2
79934: PPUSH
79935: CALL_OW 1
79939: ST_TO_ADDR
// end ;
79940: LD_VAR 0 3
79944: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79945: LD_INT 0
79947: PPUSH
79948: PPUSH
79949: PPUSH
79950: PPUSH
// if not mc_bases [ base ] then
79951: LD_EXP 58
79955: PUSH
79956: LD_VAR 0 1
79960: ARRAY
79961: NOT
79962: IFFALSE 79966
// exit ;
79964: GO 80031
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79966: LD_ADDR_EXP 78
79970: PUSH
79971: LD_EXP 78
79975: PPUSH
79976: LD_VAR 0 1
79980: PUSH
79981: LD_EXP 78
79985: PUSH
79986: LD_VAR 0 1
79990: ARRAY
79991: PUSH
79992: LD_INT 1
79994: PLUS
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PPUSH
80000: LD_VAR 0 1
80004: PUSH
80005: LD_VAR 0 2
80009: PUSH
80010: LD_VAR 0 3
80014: PUSH
80015: LD_VAR 0 4
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: PPUSH
80026: CALL 20665 0 3
80030: ST_TO_ADDR
// end ;
80031: LD_VAR 0 5
80035: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80036: LD_INT 0
80038: PPUSH
// if not mc_bases [ base ] then
80039: LD_EXP 58
80043: PUSH
80044: LD_VAR 0 1
80048: ARRAY
80049: NOT
80050: IFFALSE 80054
// exit ;
80052: GO 80079
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80054: LD_ADDR_EXP 95
80058: PUSH
80059: LD_EXP 95
80063: PPUSH
80064: LD_VAR 0 1
80068: PPUSH
80069: LD_VAR 0 2
80073: PPUSH
80074: CALL_OW 1
80078: ST_TO_ADDR
// end ;
80079: LD_VAR 0 3
80083: RET
// export function MC_GetMinesField ( base ) ; begin
80084: LD_INT 0
80086: PPUSH
// result := mc_mines [ base ] ;
80087: LD_ADDR_VAR 0 2
80091: PUSH
80092: LD_EXP 71
80096: PUSH
80097: LD_VAR 0 1
80101: ARRAY
80102: ST_TO_ADDR
// end ;
80103: LD_VAR 0 2
80107: RET
// export function MC_GetProduceList ( base ) ; begin
80108: LD_INT 0
80110: PPUSH
// result := mc_produce [ base ] ;
80111: LD_ADDR_VAR 0 2
80115: PUSH
80116: LD_EXP 79
80120: PUSH
80121: LD_VAR 0 1
80125: ARRAY
80126: ST_TO_ADDR
// end ;
80127: LD_VAR 0 2
80131: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80132: LD_INT 0
80134: PPUSH
80135: PPUSH
// if not mc_bases then
80136: LD_EXP 58
80140: NOT
80141: IFFALSE 80145
// exit ;
80143: GO 80210
// if mc_bases [ base ] then
80145: LD_EXP 58
80149: PUSH
80150: LD_VAR 0 1
80154: ARRAY
80155: IFFALSE 80210
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80157: LD_ADDR_VAR 0 3
80161: PUSH
80162: LD_EXP 58
80166: PUSH
80167: LD_VAR 0 1
80171: ARRAY
80172: PPUSH
80173: LD_INT 30
80175: PUSH
80176: LD_VAR 0 2
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PPUSH
80185: CALL_OW 72
80189: ST_TO_ADDR
// if result then
80190: LD_VAR 0 3
80194: IFFALSE 80210
// result := result [ 1 ] ;
80196: LD_ADDR_VAR 0 3
80200: PUSH
80201: LD_VAR 0 3
80205: PUSH
80206: LD_INT 1
80208: ARRAY
80209: ST_TO_ADDR
// end ; end ;
80210: LD_VAR 0 3
80214: RET
// export function MC_SetTame ( base , area ) ; begin
80215: LD_INT 0
80217: PPUSH
// if not mc_bases or not base then
80218: LD_EXP 58
80222: NOT
80223: PUSH
80224: LD_VAR 0 1
80228: NOT
80229: OR
80230: IFFALSE 80234
// exit ;
80232: GO 80259
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80234: LD_ADDR_EXP 86
80238: PUSH
80239: LD_EXP 86
80243: PPUSH
80244: LD_VAR 0 1
80248: PPUSH
80249: LD_VAR 0 2
80253: PPUSH
80254: CALL_OW 1
80258: ST_TO_ADDR
// end ;
80259: LD_VAR 0 3
80263: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80264: LD_INT 0
80266: PPUSH
80267: PPUSH
// if not mc_bases or not base then
80268: LD_EXP 58
80272: NOT
80273: PUSH
80274: LD_VAR 0 1
80278: NOT
80279: OR
80280: IFFALSE 80284
// exit ;
80282: GO 80386
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80284: LD_ADDR_VAR 0 4
80288: PUSH
80289: LD_EXP 58
80293: PUSH
80294: LD_VAR 0 1
80298: ARRAY
80299: PPUSH
80300: LD_INT 30
80302: PUSH
80303: LD_VAR 0 2
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PPUSH
80312: CALL_OW 72
80316: ST_TO_ADDR
// if not tmp then
80317: LD_VAR 0 4
80321: NOT
80322: IFFALSE 80326
// exit ;
80324: GO 80386
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80326: LD_ADDR_EXP 90
80330: PUSH
80331: LD_EXP 90
80335: PPUSH
80336: LD_VAR 0 1
80340: PPUSH
80341: LD_EXP 90
80345: PUSH
80346: LD_VAR 0 1
80350: ARRAY
80351: PPUSH
80352: LD_EXP 90
80356: PUSH
80357: LD_VAR 0 1
80361: ARRAY
80362: PUSH
80363: LD_INT 1
80365: PLUS
80366: PPUSH
80367: LD_VAR 0 4
80371: PUSH
80372: LD_INT 1
80374: ARRAY
80375: PPUSH
80376: CALL_OW 2
80380: PPUSH
80381: CALL_OW 1
80385: ST_TO_ADDR
// end ;
80386: LD_VAR 0 3
80390: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80391: LD_INT 0
80393: PPUSH
80394: PPUSH
// if not mc_bases or not base or not kinds then
80395: LD_EXP 58
80399: NOT
80400: PUSH
80401: LD_VAR 0 1
80405: NOT
80406: OR
80407: PUSH
80408: LD_VAR 0 2
80412: NOT
80413: OR
80414: IFFALSE 80418
// exit ;
80416: GO 80479
// for i in kinds do
80418: LD_ADDR_VAR 0 4
80422: PUSH
80423: LD_VAR 0 2
80427: PUSH
80428: FOR_IN
80429: IFFALSE 80477
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80431: LD_ADDR_EXP 92
80435: PUSH
80436: LD_EXP 92
80440: PPUSH
80441: LD_VAR 0 1
80445: PUSH
80446: LD_EXP 92
80450: PUSH
80451: LD_VAR 0 1
80455: ARRAY
80456: PUSH
80457: LD_INT 1
80459: PLUS
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PPUSH
80465: LD_VAR 0 4
80469: PPUSH
80470: CALL 20665 0 3
80474: ST_TO_ADDR
80475: GO 80428
80477: POP
80478: POP
// end ;
80479: LD_VAR 0 3
80483: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80484: LD_INT 0
80486: PPUSH
// if not mc_bases or not base or not areas then
80487: LD_EXP 58
80491: NOT
80492: PUSH
80493: LD_VAR 0 1
80497: NOT
80498: OR
80499: PUSH
80500: LD_VAR 0 2
80504: NOT
80505: OR
80506: IFFALSE 80510
// exit ;
80508: GO 80535
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80510: LD_ADDR_EXP 76
80514: PUSH
80515: LD_EXP 76
80519: PPUSH
80520: LD_VAR 0 1
80524: PPUSH
80525: LD_VAR 0 2
80529: PPUSH
80530: CALL_OW 1
80534: ST_TO_ADDR
// end ;
80535: LD_VAR 0 3
80539: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80540: LD_INT 0
80542: PPUSH
// if not mc_bases or not base or not teleports_exit then
80543: LD_EXP 58
80547: NOT
80548: PUSH
80549: LD_VAR 0 1
80553: NOT
80554: OR
80555: PUSH
80556: LD_VAR 0 2
80560: NOT
80561: OR
80562: IFFALSE 80566
// exit ;
80564: GO 80591
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80566: LD_ADDR_EXP 93
80570: PUSH
80571: LD_EXP 93
80575: PPUSH
80576: LD_VAR 0 1
80580: PPUSH
80581: LD_VAR 0 2
80585: PPUSH
80586: CALL_OW 1
80590: ST_TO_ADDR
// end ;
80591: LD_VAR 0 3
80595: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80596: LD_INT 0
80598: PPUSH
80599: PPUSH
80600: PPUSH
// if not mc_bases or not base or not ext_list then
80601: LD_EXP 58
80605: NOT
80606: PUSH
80607: LD_VAR 0 1
80611: NOT
80612: OR
80613: PUSH
80614: LD_VAR 0 5
80618: NOT
80619: OR
80620: IFFALSE 80624
// exit ;
80622: GO 80797
// tmp := GetFacExtXYD ( x , y , d ) ;
80624: LD_ADDR_VAR 0 8
80628: PUSH
80629: LD_VAR 0 2
80633: PPUSH
80634: LD_VAR 0 3
80638: PPUSH
80639: LD_VAR 0 4
80643: PPUSH
80644: CALL 54019 0 3
80648: ST_TO_ADDR
// if not tmp then
80649: LD_VAR 0 8
80653: NOT
80654: IFFALSE 80658
// exit ;
80656: GO 80797
// for i in tmp do
80658: LD_ADDR_VAR 0 7
80662: PUSH
80663: LD_VAR 0 8
80667: PUSH
80668: FOR_IN
80669: IFFALSE 80795
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80671: LD_ADDR_EXP 63
80675: PUSH
80676: LD_EXP 63
80680: PPUSH
80681: LD_VAR 0 1
80685: PPUSH
80686: LD_EXP 63
80690: PUSH
80691: LD_VAR 0 1
80695: ARRAY
80696: PPUSH
80697: LD_EXP 63
80701: PUSH
80702: LD_VAR 0 1
80706: ARRAY
80707: PUSH
80708: LD_INT 1
80710: PLUS
80711: PPUSH
80712: LD_VAR 0 5
80716: PUSH
80717: LD_INT 1
80719: ARRAY
80720: PUSH
80721: LD_VAR 0 7
80725: PUSH
80726: LD_INT 1
80728: ARRAY
80729: PUSH
80730: LD_VAR 0 7
80734: PUSH
80735: LD_INT 2
80737: ARRAY
80738: PUSH
80739: LD_VAR 0 7
80743: PUSH
80744: LD_INT 3
80746: ARRAY
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: PPUSH
80754: CALL_OW 2
80758: PPUSH
80759: CALL_OW 1
80763: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80764: LD_ADDR_VAR 0 5
80768: PUSH
80769: LD_VAR 0 5
80773: PPUSH
80774: LD_INT 1
80776: PPUSH
80777: CALL_OW 3
80781: ST_TO_ADDR
// if not ext_list then
80782: LD_VAR 0 5
80786: NOT
80787: IFFALSE 80793
// exit ;
80789: POP
80790: POP
80791: GO 80797
// end ;
80793: GO 80668
80795: POP
80796: POP
// end ;
80797: LD_VAR 0 6
80801: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80802: LD_INT 0
80804: PPUSH
// if not mc_bases or not base or not weapon_list then
80805: LD_EXP 58
80809: NOT
80810: PUSH
80811: LD_VAR 0 1
80815: NOT
80816: OR
80817: PUSH
80818: LD_VAR 0 2
80822: NOT
80823: OR
80824: IFFALSE 80828
// exit ;
80826: GO 80853
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80828: LD_ADDR_EXP 97
80832: PUSH
80833: LD_EXP 97
80837: PPUSH
80838: LD_VAR 0 1
80842: PPUSH
80843: LD_VAR 0 2
80847: PPUSH
80848: CALL_OW 1
80852: ST_TO_ADDR
// end ;
80853: LD_VAR 0 3
80857: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80858: LD_INT 0
80860: PPUSH
// if not mc_bases or not base or not tech_list then
80861: LD_EXP 58
80865: NOT
80866: PUSH
80867: LD_VAR 0 1
80871: NOT
80872: OR
80873: PUSH
80874: LD_VAR 0 2
80878: NOT
80879: OR
80880: IFFALSE 80884
// exit ;
80882: GO 80909
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80884: LD_ADDR_EXP 85
80888: PUSH
80889: LD_EXP 85
80893: PPUSH
80894: LD_VAR 0 1
80898: PPUSH
80899: LD_VAR 0 2
80903: PPUSH
80904: CALL_OW 1
80908: ST_TO_ADDR
// end ;
80909: LD_VAR 0 3
80913: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80914: LD_INT 0
80916: PPUSH
// if not mc_bases or not parking_area or not base then
80917: LD_EXP 58
80921: NOT
80922: PUSH
80923: LD_VAR 0 2
80927: NOT
80928: OR
80929: PUSH
80930: LD_VAR 0 1
80934: NOT
80935: OR
80936: IFFALSE 80940
// exit ;
80938: GO 80965
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80940: LD_ADDR_EXP 82
80944: PUSH
80945: LD_EXP 82
80949: PPUSH
80950: LD_VAR 0 1
80954: PPUSH
80955: LD_VAR 0 2
80959: PPUSH
80960: CALL_OW 1
80964: ST_TO_ADDR
// end ;
80965: LD_VAR 0 3
80969: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80970: LD_INT 0
80972: PPUSH
// if not mc_bases or not base or not scan_area then
80973: LD_EXP 58
80977: NOT
80978: PUSH
80979: LD_VAR 0 1
80983: NOT
80984: OR
80985: PUSH
80986: LD_VAR 0 2
80990: NOT
80991: OR
80992: IFFALSE 80996
// exit ;
80994: GO 81021
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80996: LD_ADDR_EXP 83
81000: PUSH
81001: LD_EXP 83
81005: PPUSH
81006: LD_VAR 0 1
81010: PPUSH
81011: LD_VAR 0 2
81015: PPUSH
81016: CALL_OW 1
81020: ST_TO_ADDR
// end ;
81021: LD_VAR 0 3
81025: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81026: LD_INT 0
81028: PPUSH
81029: PPUSH
// if not mc_bases or not base then
81030: LD_EXP 58
81034: NOT
81035: PUSH
81036: LD_VAR 0 1
81040: NOT
81041: OR
81042: IFFALSE 81046
// exit ;
81044: GO 81110
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81046: LD_ADDR_VAR 0 3
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: LD_INT 2
81056: PUSH
81057: LD_INT 3
81059: PUSH
81060: LD_INT 4
81062: PUSH
81063: LD_INT 11
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81073: LD_ADDR_EXP 85
81077: PUSH
81078: LD_EXP 85
81082: PPUSH
81083: LD_VAR 0 1
81087: PPUSH
81088: LD_EXP 85
81092: PUSH
81093: LD_VAR 0 1
81097: ARRAY
81098: PUSH
81099: LD_VAR 0 3
81103: DIFF
81104: PPUSH
81105: CALL_OW 1
81109: ST_TO_ADDR
// end ;
81110: LD_VAR 0 2
81114: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81115: LD_INT 0
81117: PPUSH
// result := mc_vehicles [ base ] ;
81118: LD_ADDR_VAR 0 3
81122: PUSH
81123: LD_EXP 77
81127: PUSH
81128: LD_VAR 0 1
81132: ARRAY
81133: ST_TO_ADDR
// if onlyCombat then
81134: LD_VAR 0 2
81138: IFFALSE 81303
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81140: LD_ADDR_VAR 0 3
81144: PUSH
81145: LD_VAR 0 3
81149: PUSH
81150: LD_VAR 0 3
81154: PPUSH
81155: LD_INT 2
81157: PUSH
81158: LD_INT 34
81160: PUSH
81161: LD_INT 12
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 34
81170: PUSH
81171: LD_INT 51
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 34
81180: PUSH
81181: LD_EXP 102
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 34
81192: PUSH
81193: LD_INT 32
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 34
81202: PUSH
81203: LD_INT 13
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 34
81212: PUSH
81213: LD_INT 52
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 34
81222: PUSH
81223: LD_INT 14
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 34
81232: PUSH
81233: LD_INT 53
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 34
81242: PUSH
81243: LD_EXP 101
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 34
81254: PUSH
81255: LD_INT 31
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 34
81264: PUSH
81265: LD_INT 48
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 34
81274: PUSH
81275: LD_INT 8
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: PPUSH
81297: CALL_OW 72
81301: DIFF
81302: ST_TO_ADDR
// end ; end_of_file
81303: LD_VAR 0 3
81307: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81308: LD_INT 0
81310: PPUSH
81311: PPUSH
81312: PPUSH
// if not mc_bases or not skirmish then
81313: LD_EXP 58
81317: NOT
81318: PUSH
81319: LD_EXP 56
81323: NOT
81324: OR
81325: IFFALSE 81329
// exit ;
81327: GO 81494
// for i = 1 to mc_bases do
81329: LD_ADDR_VAR 0 4
81333: PUSH
81334: DOUBLE
81335: LD_INT 1
81337: DEC
81338: ST_TO_ADDR
81339: LD_EXP 58
81343: PUSH
81344: FOR_TO
81345: IFFALSE 81492
// begin if sci in mc_bases [ i ] then
81347: LD_VAR 0 2
81351: PUSH
81352: LD_EXP 58
81356: PUSH
81357: LD_VAR 0 4
81361: ARRAY
81362: IN
81363: IFFALSE 81490
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81365: LD_ADDR_EXP 87
81369: PUSH
81370: LD_EXP 87
81374: PPUSH
81375: LD_VAR 0 4
81379: PUSH
81380: LD_EXP 87
81384: PUSH
81385: LD_VAR 0 4
81389: ARRAY
81390: PUSH
81391: LD_INT 1
81393: PLUS
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PPUSH
81399: LD_VAR 0 1
81403: PPUSH
81404: CALL 20665 0 3
81408: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81409: LD_ADDR_VAR 0 5
81413: PUSH
81414: LD_EXP 58
81418: PUSH
81419: LD_VAR 0 4
81423: ARRAY
81424: PPUSH
81425: LD_INT 2
81427: PUSH
81428: LD_INT 30
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 30
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: LIST
81452: PPUSH
81453: CALL_OW 72
81457: PPUSH
81458: LD_VAR 0 1
81462: PPUSH
81463: CALL_OW 74
81467: ST_TO_ADDR
// if tmp then
81468: LD_VAR 0 5
81472: IFFALSE 81488
// ComStandNearbyBuilding ( ape , tmp ) ;
81474: LD_VAR 0 1
81478: PPUSH
81479: LD_VAR 0 5
81483: PPUSH
81484: CALL 15342 0 2
// break ;
81488: GO 81492
// end ; end ;
81490: GO 81344
81492: POP
81493: POP
// end ;
81494: LD_VAR 0 3
81498: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81499: LD_INT 0
81501: PPUSH
81502: PPUSH
81503: PPUSH
// if not mc_bases or not skirmish then
81504: LD_EXP 58
81508: NOT
81509: PUSH
81510: LD_EXP 56
81514: NOT
81515: OR
81516: IFFALSE 81520
// exit ;
81518: GO 81609
// for i = 1 to mc_bases do
81520: LD_ADDR_VAR 0 4
81524: PUSH
81525: DOUBLE
81526: LD_INT 1
81528: DEC
81529: ST_TO_ADDR
81530: LD_EXP 58
81534: PUSH
81535: FOR_TO
81536: IFFALSE 81607
// begin if building in mc_busy_turret_list [ i ] then
81538: LD_VAR 0 1
81542: PUSH
81543: LD_EXP 68
81547: PUSH
81548: LD_VAR 0 4
81552: ARRAY
81553: IN
81554: IFFALSE 81605
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81556: LD_ADDR_VAR 0 5
81560: PUSH
81561: LD_EXP 68
81565: PUSH
81566: LD_VAR 0 4
81570: ARRAY
81571: PUSH
81572: LD_VAR 0 1
81576: DIFF
81577: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81578: LD_ADDR_EXP 68
81582: PUSH
81583: LD_EXP 68
81587: PPUSH
81588: LD_VAR 0 4
81592: PPUSH
81593: LD_VAR 0 5
81597: PPUSH
81598: CALL_OW 1
81602: ST_TO_ADDR
// break ;
81603: GO 81607
// end ; end ;
81605: GO 81535
81607: POP
81608: POP
// end ;
81609: LD_VAR 0 3
81613: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81614: LD_INT 0
81616: PPUSH
81617: PPUSH
81618: PPUSH
// if not mc_bases or not skirmish then
81619: LD_EXP 58
81623: NOT
81624: PUSH
81625: LD_EXP 56
81629: NOT
81630: OR
81631: IFFALSE 81635
// exit ;
81633: GO 81834
// for i = 1 to mc_bases do
81635: LD_ADDR_VAR 0 5
81639: PUSH
81640: DOUBLE
81641: LD_INT 1
81643: DEC
81644: ST_TO_ADDR
81645: LD_EXP 58
81649: PUSH
81650: FOR_TO
81651: IFFALSE 81832
// if building in mc_bases [ i ] then
81653: LD_VAR 0 1
81657: PUSH
81658: LD_EXP 58
81662: PUSH
81663: LD_VAR 0 5
81667: ARRAY
81668: IN
81669: IFFALSE 81830
// begin tmp := mc_bases [ i ] diff building ;
81671: LD_ADDR_VAR 0 6
81675: PUSH
81676: LD_EXP 58
81680: PUSH
81681: LD_VAR 0 5
81685: ARRAY
81686: PUSH
81687: LD_VAR 0 1
81691: DIFF
81692: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81693: LD_ADDR_EXP 58
81697: PUSH
81698: LD_EXP 58
81702: PPUSH
81703: LD_VAR 0 5
81707: PPUSH
81708: LD_VAR 0 6
81712: PPUSH
81713: CALL_OW 1
81717: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81718: LD_VAR 0 1
81722: PUSH
81723: LD_EXP 66
81727: PUSH
81728: LD_VAR 0 5
81732: ARRAY
81733: IN
81734: IFFALSE 81773
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81736: LD_ADDR_EXP 66
81740: PUSH
81741: LD_EXP 66
81745: PPUSH
81746: LD_VAR 0 5
81750: PPUSH
81751: LD_EXP 66
81755: PUSH
81756: LD_VAR 0 5
81760: ARRAY
81761: PUSH
81762: LD_VAR 0 1
81766: DIFF
81767: PPUSH
81768: CALL_OW 1
81772: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81773: LD_VAR 0 1
81777: PUSH
81778: LD_EXP 67
81782: PUSH
81783: LD_VAR 0 5
81787: ARRAY
81788: IN
81789: IFFALSE 81828
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81791: LD_ADDR_EXP 67
81795: PUSH
81796: LD_EXP 67
81800: PPUSH
81801: LD_VAR 0 5
81805: PPUSH
81806: LD_EXP 67
81810: PUSH
81811: LD_VAR 0 5
81815: ARRAY
81816: PUSH
81817: LD_VAR 0 1
81821: DIFF
81822: PPUSH
81823: CALL_OW 1
81827: ST_TO_ADDR
// break ;
81828: GO 81832
// end ;
81830: GO 81650
81832: POP
81833: POP
// end ;
81834: LD_VAR 0 4
81838: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81839: LD_INT 0
81841: PPUSH
81842: PPUSH
81843: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81844: LD_EXP 58
81848: NOT
81849: PUSH
81850: LD_EXP 56
81854: NOT
81855: OR
81856: PUSH
81857: LD_VAR 0 3
81861: PUSH
81862: LD_EXP 84
81866: IN
81867: NOT
81868: OR
81869: IFFALSE 81873
// exit ;
81871: GO 81996
// for i = 1 to mc_vehicles do
81873: LD_ADDR_VAR 0 6
81877: PUSH
81878: DOUBLE
81879: LD_INT 1
81881: DEC
81882: ST_TO_ADDR
81883: LD_EXP 77
81887: PUSH
81888: FOR_TO
81889: IFFALSE 81994
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81891: LD_VAR 0 2
81895: PUSH
81896: LD_EXP 77
81900: PUSH
81901: LD_VAR 0 6
81905: ARRAY
81906: IN
81907: PUSH
81908: LD_VAR 0 1
81912: PUSH
81913: LD_EXP 77
81917: PUSH
81918: LD_VAR 0 6
81922: ARRAY
81923: IN
81924: OR
81925: IFFALSE 81992
// begin tmp := mc_vehicles [ i ] diff old ;
81927: LD_ADDR_VAR 0 7
81931: PUSH
81932: LD_EXP 77
81936: PUSH
81937: LD_VAR 0 6
81941: ARRAY
81942: PUSH
81943: LD_VAR 0 2
81947: DIFF
81948: ST_TO_ADDR
// tmp := tmp diff new ;
81949: LD_ADDR_VAR 0 7
81953: PUSH
81954: LD_VAR 0 7
81958: PUSH
81959: LD_VAR 0 1
81963: DIFF
81964: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81965: LD_ADDR_EXP 77
81969: PUSH
81970: LD_EXP 77
81974: PPUSH
81975: LD_VAR 0 6
81979: PPUSH
81980: LD_VAR 0 7
81984: PPUSH
81985: CALL_OW 1
81989: ST_TO_ADDR
// break ;
81990: GO 81994
// end ;
81992: GO 81888
81994: POP
81995: POP
// end ;
81996: LD_VAR 0 5
82000: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82001: LD_INT 0
82003: PPUSH
82004: PPUSH
82005: PPUSH
82006: PPUSH
// if not mc_bases or not skirmish then
82007: LD_EXP 58
82011: NOT
82012: PUSH
82013: LD_EXP 56
82017: NOT
82018: OR
82019: IFFALSE 82023
// exit ;
82021: GO 82406
// side := GetSide ( vehicle ) ;
82023: LD_ADDR_VAR 0 5
82027: PUSH
82028: LD_VAR 0 1
82032: PPUSH
82033: CALL_OW 255
82037: ST_TO_ADDR
// for i = 1 to mc_bases do
82038: LD_ADDR_VAR 0 4
82042: PUSH
82043: DOUBLE
82044: LD_INT 1
82046: DEC
82047: ST_TO_ADDR
82048: LD_EXP 58
82052: PUSH
82053: FOR_TO
82054: IFFALSE 82404
// begin if factory in mc_bases [ i ] then
82056: LD_VAR 0 2
82060: PUSH
82061: LD_EXP 58
82065: PUSH
82066: LD_VAR 0 4
82070: ARRAY
82071: IN
82072: IFFALSE 82402
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82074: LD_EXP 80
82078: PUSH
82079: LD_VAR 0 4
82083: ARRAY
82084: PUSH
82085: LD_EXP 69
82089: PUSH
82090: LD_VAR 0 4
82094: ARRAY
82095: LESS
82096: PUSH
82097: LD_VAR 0 1
82101: PPUSH
82102: CALL_OW 264
82106: PUSH
82107: LD_INT 31
82109: PUSH
82110: LD_INT 32
82112: PUSH
82113: LD_INT 51
82115: PUSH
82116: LD_EXP 102
82120: PUSH
82121: LD_INT 12
82123: PUSH
82124: LD_INT 30
82126: PUSH
82127: LD_EXP 101
82131: PUSH
82132: LD_INT 11
82134: PUSH
82135: LD_INT 53
82137: PUSH
82138: LD_INT 14
82140: PUSH
82141: LD_EXP 105
82145: PUSH
82146: LD_INT 29
82148: PUSH
82149: LD_EXP 103
82153: PUSH
82154: LD_INT 13
82156: PUSH
82157: LD_INT 52
82159: PUSH
82160: LD_INT 48
82162: PUSH
82163: LD_INT 8
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: IN
82185: NOT
82186: AND
82187: IFFALSE 82228
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
82189: LD_ADDR_EXP 80
82193: PUSH
82194: LD_EXP 80
82198: PPUSH
82199: LD_VAR 0 4
82203: PPUSH
82204: LD_EXP 80
82208: PUSH
82209: LD_VAR 0 4
82213: ARRAY
82214: PUSH
82215: LD_VAR 0 1
82219: ADD
82220: PPUSH
82221: CALL_OW 1
82225: ST_TO_ADDR
82226: GO 82272
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82228: LD_ADDR_EXP 77
82232: PUSH
82233: LD_EXP 77
82237: PPUSH
82238: LD_VAR 0 4
82242: PUSH
82243: LD_EXP 77
82247: PUSH
82248: LD_VAR 0 4
82252: ARRAY
82253: PUSH
82254: LD_INT 1
82256: PLUS
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PPUSH
82262: LD_VAR 0 1
82266: PPUSH
82267: CALL 20665 0 3
82271: ST_TO_ADDR
// if not mc_scan [ i ] then
82272: LD_EXP 81
82276: PUSH
82277: LD_VAR 0 4
82281: ARRAY
82282: NOT
82283: IFFALSE 82402
// begin if GetControl ( vehicle ) = control_remote then
82285: LD_VAR 0 1
82289: PPUSH
82290: CALL_OW 263
82294: PUSH
82295: LD_INT 2
82297: EQUAL
82298: IFFALSE 82318
// repeat wait ( 0 0$1 ) ;
82300: LD_INT 35
82302: PPUSH
82303: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82307: LD_VAR 0 1
82311: PPUSH
82312: CALL_OW 312
82316: IFFALSE 82300
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82318: LD_VAR 0 1
82322: PPUSH
82323: LD_EXP 82
82327: PUSH
82328: LD_VAR 0 4
82332: ARRAY
82333: PPUSH
82334: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82338: LD_VAR 0 1
82342: PPUSH
82343: CALL_OW 263
82347: PUSH
82348: LD_INT 1
82350: NONEQUAL
82351: IFFALSE 82355
// break ;
82353: GO 82404
// repeat wait ( 0 0$1 ) ;
82355: LD_INT 35
82357: PPUSH
82358: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82362: LD_VAR 0 1
82366: PPUSH
82367: LD_EXP 82
82371: PUSH
82372: LD_VAR 0 4
82376: ARRAY
82377: PPUSH
82378: CALL_OW 308
82382: IFFALSE 82355
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82384: LD_VAR 0 1
82388: PPUSH
82389: CALL_OW 311
82393: PPUSH
82394: CALL_OW 121
// exit ;
82398: POP
82399: POP
82400: GO 82406
// end ; end ; end ;
82402: GO 82053
82404: POP
82405: POP
// end ;
82406: LD_VAR 0 3
82410: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82411: LD_INT 0
82413: PPUSH
82414: PPUSH
82415: PPUSH
82416: PPUSH
// if not mc_bases or not skirmish then
82417: LD_EXP 58
82421: NOT
82422: PUSH
82423: LD_EXP 56
82427: NOT
82428: OR
82429: IFFALSE 82433
// exit ;
82431: GO 82786
// repeat wait ( 0 0$1 ) ;
82433: LD_INT 35
82435: PPUSH
82436: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82440: LD_VAR 0 2
82444: PPUSH
82445: LD_VAR 0 3
82449: PPUSH
82450: CALL_OW 284
82454: IFFALSE 82433
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82456: LD_VAR 0 2
82460: PPUSH
82461: LD_VAR 0 3
82465: PPUSH
82466: CALL_OW 283
82470: PUSH
82471: LD_INT 4
82473: EQUAL
82474: IFFALSE 82478
// exit ;
82476: GO 82786
// for i = 1 to mc_bases do
82478: LD_ADDR_VAR 0 7
82482: PUSH
82483: DOUBLE
82484: LD_INT 1
82486: DEC
82487: ST_TO_ADDR
82488: LD_EXP 58
82492: PUSH
82493: FOR_TO
82494: IFFALSE 82784
// begin if mc_crates_area [ i ] then
82496: LD_EXP 76
82500: PUSH
82501: LD_VAR 0 7
82505: ARRAY
82506: IFFALSE 82617
// for j in mc_crates_area [ i ] do
82508: LD_ADDR_VAR 0 8
82512: PUSH
82513: LD_EXP 76
82517: PUSH
82518: LD_VAR 0 7
82522: ARRAY
82523: PUSH
82524: FOR_IN
82525: IFFALSE 82615
// if InArea ( x , y , j ) then
82527: LD_VAR 0 2
82531: PPUSH
82532: LD_VAR 0 3
82536: PPUSH
82537: LD_VAR 0 8
82541: PPUSH
82542: CALL_OW 309
82546: IFFALSE 82613
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82548: LD_ADDR_EXP 74
82552: PUSH
82553: LD_EXP 74
82557: PPUSH
82558: LD_VAR 0 7
82562: PUSH
82563: LD_EXP 74
82567: PUSH
82568: LD_VAR 0 7
82572: ARRAY
82573: PUSH
82574: LD_INT 1
82576: PLUS
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PPUSH
82582: LD_VAR 0 4
82586: PUSH
82587: LD_VAR 0 2
82591: PUSH
82592: LD_VAR 0 3
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: LIST
82601: PPUSH
82602: CALL 20665 0 3
82606: ST_TO_ADDR
// exit ;
82607: POP
82608: POP
82609: POP
82610: POP
82611: GO 82786
// end ;
82613: GO 82524
82615: POP
82616: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82617: LD_ADDR_VAR 0 9
82621: PUSH
82622: LD_EXP 58
82626: PUSH
82627: LD_VAR 0 7
82631: ARRAY
82632: PPUSH
82633: LD_INT 2
82635: PUSH
82636: LD_INT 30
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: LD_INT 30
82648: PUSH
82649: LD_INT 1
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: LIST
82660: PPUSH
82661: CALL_OW 72
82665: ST_TO_ADDR
// if not depot then
82666: LD_VAR 0 9
82670: NOT
82671: IFFALSE 82675
// continue ;
82673: GO 82493
// for j in depot do
82675: LD_ADDR_VAR 0 8
82679: PUSH
82680: LD_VAR 0 9
82684: PUSH
82685: FOR_IN
82686: IFFALSE 82780
// if GetDistUnitXY ( j , x , y ) < 30 then
82688: LD_VAR 0 8
82692: PPUSH
82693: LD_VAR 0 2
82697: PPUSH
82698: LD_VAR 0 3
82702: PPUSH
82703: CALL_OW 297
82707: PUSH
82708: LD_INT 30
82710: LESS
82711: IFFALSE 82778
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82713: LD_ADDR_EXP 74
82717: PUSH
82718: LD_EXP 74
82722: PPUSH
82723: LD_VAR 0 7
82727: PUSH
82728: LD_EXP 74
82732: PUSH
82733: LD_VAR 0 7
82737: ARRAY
82738: PUSH
82739: LD_INT 1
82741: PLUS
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PPUSH
82747: LD_VAR 0 4
82751: PUSH
82752: LD_VAR 0 2
82756: PUSH
82757: LD_VAR 0 3
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: LIST
82766: PPUSH
82767: CALL 20665 0 3
82771: ST_TO_ADDR
// exit ;
82772: POP
82773: POP
82774: POP
82775: POP
82776: GO 82786
// end ;
82778: GO 82685
82780: POP
82781: POP
// end ;
82782: GO 82493
82784: POP
82785: POP
// end ;
82786: LD_VAR 0 6
82790: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82791: LD_INT 0
82793: PPUSH
82794: PPUSH
82795: PPUSH
82796: PPUSH
// if not mc_bases or not skirmish then
82797: LD_EXP 58
82801: NOT
82802: PUSH
82803: LD_EXP 56
82807: NOT
82808: OR
82809: IFFALSE 82813
// exit ;
82811: GO 83090
// side := GetSide ( lab ) ;
82813: LD_ADDR_VAR 0 4
82817: PUSH
82818: LD_VAR 0 2
82822: PPUSH
82823: CALL_OW 255
82827: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82828: LD_VAR 0 4
82832: PUSH
82833: LD_EXP 84
82837: IN
82838: NOT
82839: PUSH
82840: LD_EXP 85
82844: NOT
82845: OR
82846: PUSH
82847: LD_EXP 58
82851: NOT
82852: OR
82853: IFFALSE 82857
// exit ;
82855: GO 83090
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82857: LD_ADDR_EXP 85
82861: PUSH
82862: LD_EXP 85
82866: PPUSH
82867: LD_VAR 0 4
82871: PPUSH
82872: LD_EXP 85
82876: PUSH
82877: LD_VAR 0 4
82881: ARRAY
82882: PUSH
82883: LD_VAR 0 1
82887: DIFF
82888: PPUSH
82889: CALL_OW 1
82893: ST_TO_ADDR
// for i = 1 to mc_bases do
82894: LD_ADDR_VAR 0 5
82898: PUSH
82899: DOUBLE
82900: LD_INT 1
82902: DEC
82903: ST_TO_ADDR
82904: LD_EXP 58
82908: PUSH
82909: FOR_TO
82910: IFFALSE 83088
// begin if lab in mc_bases [ i ] then
82912: LD_VAR 0 2
82916: PUSH
82917: LD_EXP 58
82921: PUSH
82922: LD_VAR 0 5
82926: ARRAY
82927: IN
82928: IFFALSE 83086
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82930: LD_VAR 0 1
82934: PUSH
82935: LD_INT 11
82937: PUSH
82938: LD_INT 4
82940: PUSH
82941: LD_INT 3
82943: PUSH
82944: LD_INT 2
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: IN
82953: PUSH
82954: LD_EXP 88
82958: PUSH
82959: LD_VAR 0 5
82963: ARRAY
82964: AND
82965: IFFALSE 83086
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82967: LD_ADDR_VAR 0 6
82971: PUSH
82972: LD_EXP 88
82976: PUSH
82977: LD_VAR 0 5
82981: ARRAY
82982: PUSH
82983: LD_INT 1
82985: ARRAY
82986: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82987: LD_ADDR_EXP 88
82991: PUSH
82992: LD_EXP 88
82996: PPUSH
82997: LD_VAR 0 5
83001: PPUSH
83002: EMPTY
83003: PPUSH
83004: CALL_OW 1
83008: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83009: LD_VAR 0 6
83013: PPUSH
83014: LD_INT 0
83016: PPUSH
83017: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83021: LD_VAR 0 6
83025: PPUSH
83026: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83030: LD_ADDR_EXP 87
83034: PUSH
83035: LD_EXP 87
83039: PPUSH
83040: LD_VAR 0 5
83044: PPUSH
83045: LD_EXP 87
83049: PUSH
83050: LD_VAR 0 5
83054: ARRAY
83055: PPUSH
83056: LD_INT 1
83058: PPUSH
83059: LD_VAR 0 6
83063: PPUSH
83064: CALL_OW 2
83068: PPUSH
83069: CALL_OW 1
83073: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83074: LD_VAR 0 5
83078: PPUSH
83079: LD_INT 112
83081: PPUSH
83082: CALL 60559 0 2
// end ; end ; end ;
83086: GO 82909
83088: POP
83089: POP
// end ;
83090: LD_VAR 0 3
83094: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83095: LD_INT 0
83097: PPUSH
83098: PPUSH
83099: PPUSH
83100: PPUSH
83101: PPUSH
83102: PPUSH
83103: PPUSH
83104: PPUSH
// if not mc_bases or not skirmish then
83105: LD_EXP 58
83109: NOT
83110: PUSH
83111: LD_EXP 56
83115: NOT
83116: OR
83117: IFFALSE 83121
// exit ;
83119: GO 84137
// for i = 1 to mc_bases do
83121: LD_ADDR_VAR 0 3
83125: PUSH
83126: DOUBLE
83127: LD_INT 1
83129: DEC
83130: ST_TO_ADDR
83131: LD_EXP 58
83135: PUSH
83136: FOR_TO
83137: IFFALSE 84135
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83139: LD_VAR 0 1
83143: PUSH
83144: LD_EXP 58
83148: PUSH
83149: LD_VAR 0 3
83153: ARRAY
83154: IN
83155: PUSH
83156: LD_VAR 0 1
83160: PUSH
83161: LD_EXP 65
83165: PUSH
83166: LD_VAR 0 3
83170: ARRAY
83171: IN
83172: OR
83173: PUSH
83174: LD_VAR 0 1
83178: PUSH
83179: LD_EXP 77
83183: PUSH
83184: LD_VAR 0 3
83188: ARRAY
83189: IN
83190: OR
83191: PUSH
83192: LD_VAR 0 1
83196: PUSH
83197: LD_EXP 87
83201: PUSH
83202: LD_VAR 0 3
83206: ARRAY
83207: IN
83208: OR
83209: PUSH
83210: LD_VAR 0 1
83214: PUSH
83215: LD_EXP 88
83219: PUSH
83220: LD_VAR 0 3
83224: ARRAY
83225: IN
83226: OR
83227: IFFALSE 84133
// begin if un in mc_ape [ i ] then
83229: LD_VAR 0 1
83233: PUSH
83234: LD_EXP 87
83238: PUSH
83239: LD_VAR 0 3
83243: ARRAY
83244: IN
83245: IFFALSE 83284
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83247: LD_ADDR_EXP 87
83251: PUSH
83252: LD_EXP 87
83256: PPUSH
83257: LD_VAR 0 3
83261: PPUSH
83262: LD_EXP 87
83266: PUSH
83267: LD_VAR 0 3
83271: ARRAY
83272: PUSH
83273: LD_VAR 0 1
83277: DIFF
83278: PPUSH
83279: CALL_OW 1
83283: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83284: LD_VAR 0 1
83288: PUSH
83289: LD_EXP 88
83293: PUSH
83294: LD_VAR 0 3
83298: ARRAY
83299: IN
83300: IFFALSE 83324
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83302: LD_ADDR_EXP 88
83306: PUSH
83307: LD_EXP 88
83311: PPUSH
83312: LD_VAR 0 3
83316: PPUSH
83317: EMPTY
83318: PPUSH
83319: CALL_OW 1
83323: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
83324: LD_VAR 0 1
83328: PPUSH
83329: CALL_OW 247
83333: PUSH
83334: LD_INT 2
83336: EQUAL
83337: PUSH
83338: LD_VAR 0 1
83342: PPUSH
83343: CALL_OW 110
83347: PUSH
83348: LD_INT 20
83350: EQUAL
83351: PUSH
83352: LD_VAR 0 1
83356: PUSH
83357: LD_EXP 80
83361: PUSH
83362: LD_VAR 0 3
83366: ARRAY
83367: IN
83368: OR
83369: AND
83370: IFFALSE 83473
// begin fac := MC_GetBuilding ( i , b_factory ) ;
83372: LD_ADDR_VAR 0 8
83376: PUSH
83377: LD_VAR 0 3
83381: PPUSH
83382: LD_INT 3
83384: PPUSH
83385: CALL 80132 0 2
83389: ST_TO_ADDR
// if fac then
83390: LD_VAR 0 8
83394: IFFALSE 83473
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83396: LD_ADDR_VAR 0 9
83400: PUSH
83401: LD_VAR 0 8
83405: PPUSH
83406: LD_VAR 0 1
83410: PPUSH
83411: CALL_OW 265
83415: PPUSH
83416: LD_VAR 0 1
83420: PPUSH
83421: CALL_OW 262
83425: PPUSH
83426: LD_VAR 0 1
83430: PPUSH
83431: CALL_OW 263
83435: PPUSH
83436: LD_VAR 0 1
83440: PPUSH
83441: CALL_OW 264
83445: PPUSH
83446: CALL 18265 0 5
83450: ST_TO_ADDR
// if components then
83451: LD_VAR 0 9
83455: IFFALSE 83471
// MC_InsertProduceList ( i , components ) ;
83457: LD_VAR 0 3
83461: PPUSH
83462: LD_VAR 0 9
83466: PPUSH
83467: CALL 79760 0 2
// break ;
83471: GO 84135
// end ; end ; if GetType ( un ) = unit_building then
83473: LD_VAR 0 1
83477: PPUSH
83478: CALL_OW 247
83482: PUSH
83483: LD_INT 3
83485: EQUAL
83486: IFFALSE 83801
// begin btype := GetBType ( un ) ;
83488: LD_ADDR_VAR 0 5
83492: PUSH
83493: LD_VAR 0 1
83497: PPUSH
83498: CALL_OW 266
83502: ST_TO_ADDR
// if btype = b_warehouse then
83503: LD_VAR 0 5
83507: PUSH
83508: LD_INT 1
83510: EQUAL
83511: IFFALSE 83529
// begin btype := b_depot ;
83513: LD_ADDR_VAR 0 5
83517: PUSH
83518: LD_INT 0
83520: ST_TO_ADDR
// pos := 1 ;
83521: LD_ADDR_VAR 0 6
83525: PUSH
83526: LD_INT 1
83528: ST_TO_ADDR
// end ; if btype = b_factory then
83529: LD_VAR 0 5
83533: PUSH
83534: LD_INT 3
83536: EQUAL
83537: IFFALSE 83555
// begin btype := b_workshop ;
83539: LD_ADDR_VAR 0 5
83543: PUSH
83544: LD_INT 2
83546: ST_TO_ADDR
// pos := 1 ;
83547: LD_ADDR_VAR 0 6
83551: PUSH
83552: LD_INT 1
83554: ST_TO_ADDR
// end ; if btype = b_barracks then
83555: LD_VAR 0 5
83559: PUSH
83560: LD_INT 5
83562: EQUAL
83563: IFFALSE 83573
// btype := b_armoury ;
83565: LD_ADDR_VAR 0 5
83569: PUSH
83570: LD_INT 4
83572: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83573: LD_VAR 0 5
83577: PUSH
83578: LD_INT 7
83580: PUSH
83581: LD_INT 8
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: IN
83588: IFFALSE 83598
// btype := b_lab ;
83590: LD_ADDR_VAR 0 5
83594: PUSH
83595: LD_INT 6
83597: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83598: LD_ADDR_EXP 63
83602: PUSH
83603: LD_EXP 63
83607: PPUSH
83608: LD_VAR 0 3
83612: PUSH
83613: LD_EXP 63
83617: PUSH
83618: LD_VAR 0 3
83622: ARRAY
83623: PUSH
83624: LD_INT 1
83626: PLUS
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PPUSH
83632: LD_VAR 0 5
83636: PUSH
83637: LD_VAR 0 1
83641: PPUSH
83642: CALL_OW 250
83646: PUSH
83647: LD_VAR 0 1
83651: PPUSH
83652: CALL_OW 251
83656: PUSH
83657: LD_VAR 0 1
83661: PPUSH
83662: CALL_OW 254
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: PPUSH
83673: CALL 20665 0 3
83677: ST_TO_ADDR
// if pos = 1 then
83678: LD_VAR 0 6
83682: PUSH
83683: LD_INT 1
83685: EQUAL
83686: IFFALSE 83801
// begin tmp := mc_build_list [ i ] ;
83688: LD_ADDR_VAR 0 7
83692: PUSH
83693: LD_EXP 63
83697: PUSH
83698: LD_VAR 0 3
83702: ARRAY
83703: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83704: LD_VAR 0 7
83708: PPUSH
83709: LD_INT 2
83711: PUSH
83712: LD_INT 30
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 30
83724: PUSH
83725: LD_INT 1
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: LIST
83736: PPUSH
83737: CALL_OW 72
83741: IFFALSE 83751
// pos := 2 ;
83743: LD_ADDR_VAR 0 6
83747: PUSH
83748: LD_INT 2
83750: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83751: LD_ADDR_VAR 0 7
83755: PUSH
83756: LD_VAR 0 7
83760: PPUSH
83761: LD_VAR 0 6
83765: PPUSH
83766: LD_VAR 0 7
83770: PPUSH
83771: CALL 20991 0 3
83775: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83776: LD_ADDR_EXP 63
83780: PUSH
83781: LD_EXP 63
83785: PPUSH
83786: LD_VAR 0 3
83790: PPUSH
83791: LD_VAR 0 7
83795: PPUSH
83796: CALL_OW 1
83800: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83801: LD_VAR 0 1
83805: PUSH
83806: LD_EXP 58
83810: PUSH
83811: LD_VAR 0 3
83815: ARRAY
83816: IN
83817: IFFALSE 83856
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83819: LD_ADDR_EXP 58
83823: PUSH
83824: LD_EXP 58
83828: PPUSH
83829: LD_VAR 0 3
83833: PPUSH
83834: LD_EXP 58
83838: PUSH
83839: LD_VAR 0 3
83843: ARRAY
83844: PUSH
83845: LD_VAR 0 1
83849: DIFF
83850: PPUSH
83851: CALL_OW 1
83855: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83856: LD_VAR 0 1
83860: PUSH
83861: LD_EXP 65
83865: PUSH
83866: LD_VAR 0 3
83870: ARRAY
83871: IN
83872: IFFALSE 83911
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83874: LD_ADDR_EXP 65
83878: PUSH
83879: LD_EXP 65
83883: PPUSH
83884: LD_VAR 0 3
83888: PPUSH
83889: LD_EXP 65
83893: PUSH
83894: LD_VAR 0 3
83898: ARRAY
83899: PUSH
83900: LD_VAR 0 1
83904: DIFF
83905: PPUSH
83906: CALL_OW 1
83910: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83911: LD_VAR 0 1
83915: PUSH
83916: LD_EXP 77
83920: PUSH
83921: LD_VAR 0 3
83925: ARRAY
83926: IN
83927: IFFALSE 83966
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83929: LD_ADDR_EXP 77
83933: PUSH
83934: LD_EXP 77
83938: PPUSH
83939: LD_VAR 0 3
83943: PPUSH
83944: LD_EXP 77
83948: PUSH
83949: LD_VAR 0 3
83953: ARRAY
83954: PUSH
83955: LD_VAR 0 1
83959: DIFF
83960: PPUSH
83961: CALL_OW 1
83965: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83966: LD_VAR 0 1
83970: PUSH
83971: LD_EXP 80
83975: PUSH
83976: LD_VAR 0 3
83980: ARRAY
83981: IN
83982: IFFALSE 84021
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83984: LD_ADDR_EXP 80
83988: PUSH
83989: LD_EXP 80
83993: PPUSH
83994: LD_VAR 0 3
83998: PPUSH
83999: LD_EXP 80
84003: PUSH
84004: LD_VAR 0 3
84008: ARRAY
84009: PUSH
84010: LD_VAR 0 1
84014: DIFF
84015: PPUSH
84016: CALL_OW 1
84020: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84021: LD_VAR 0 1
84025: PUSH
84026: LD_EXP 67
84030: PUSH
84031: LD_VAR 0 3
84035: ARRAY
84036: IN
84037: IFFALSE 84076
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84039: LD_ADDR_EXP 67
84043: PUSH
84044: LD_EXP 67
84048: PPUSH
84049: LD_VAR 0 3
84053: PPUSH
84054: LD_EXP 67
84058: PUSH
84059: LD_VAR 0 3
84063: ARRAY
84064: PUSH
84065: LD_VAR 0 1
84069: DIFF
84070: PPUSH
84071: CALL_OW 1
84075: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84076: LD_VAR 0 1
84080: PUSH
84081: LD_EXP 66
84085: PUSH
84086: LD_VAR 0 3
84090: ARRAY
84091: IN
84092: IFFALSE 84131
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84094: LD_ADDR_EXP 66
84098: PUSH
84099: LD_EXP 66
84103: PPUSH
84104: LD_VAR 0 3
84108: PPUSH
84109: LD_EXP 66
84113: PUSH
84114: LD_VAR 0 3
84118: ARRAY
84119: PUSH
84120: LD_VAR 0 1
84124: DIFF
84125: PPUSH
84126: CALL_OW 1
84130: ST_TO_ADDR
// end ; break ;
84131: GO 84135
// end ;
84133: GO 83136
84135: POP
84136: POP
// end ;
84137: LD_VAR 0 2
84141: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84142: LD_INT 0
84144: PPUSH
84145: PPUSH
84146: PPUSH
// if not mc_bases or not skirmish then
84147: LD_EXP 58
84151: NOT
84152: PUSH
84153: LD_EXP 56
84157: NOT
84158: OR
84159: IFFALSE 84163
// exit ;
84161: GO 84378
// for i = 1 to mc_bases do
84163: LD_ADDR_VAR 0 3
84167: PUSH
84168: DOUBLE
84169: LD_INT 1
84171: DEC
84172: ST_TO_ADDR
84173: LD_EXP 58
84177: PUSH
84178: FOR_TO
84179: IFFALSE 84376
// begin if building in mc_construct_list [ i ] then
84181: LD_VAR 0 1
84185: PUSH
84186: LD_EXP 65
84190: PUSH
84191: LD_VAR 0 3
84195: ARRAY
84196: IN
84197: IFFALSE 84374
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84199: LD_ADDR_EXP 65
84203: PUSH
84204: LD_EXP 65
84208: PPUSH
84209: LD_VAR 0 3
84213: PPUSH
84214: LD_EXP 65
84218: PUSH
84219: LD_VAR 0 3
84223: ARRAY
84224: PUSH
84225: LD_VAR 0 1
84229: DIFF
84230: PPUSH
84231: CALL_OW 1
84235: ST_TO_ADDR
// if building in mc_lab [ i ] then
84236: LD_VAR 0 1
84240: PUSH
84241: LD_EXP 91
84245: PUSH
84246: LD_VAR 0 3
84250: ARRAY
84251: IN
84252: IFFALSE 84307
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84254: LD_ADDR_EXP 92
84258: PUSH
84259: LD_EXP 92
84263: PPUSH
84264: LD_VAR 0 3
84268: PPUSH
84269: LD_EXP 92
84273: PUSH
84274: LD_VAR 0 3
84278: ARRAY
84279: PPUSH
84280: LD_INT 1
84282: PPUSH
84283: LD_EXP 92
84287: PUSH
84288: LD_VAR 0 3
84292: ARRAY
84293: PPUSH
84294: LD_INT 0
84296: PPUSH
84297: CALL 20083 0 4
84301: PPUSH
84302: CALL_OW 1
84306: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84307: LD_VAR 0 1
84311: PUSH
84312: LD_EXP 58
84316: PUSH
84317: LD_VAR 0 3
84321: ARRAY
84322: IN
84323: NOT
84324: IFFALSE 84370
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84326: LD_ADDR_EXP 58
84330: PUSH
84331: LD_EXP 58
84335: PPUSH
84336: LD_VAR 0 3
84340: PUSH
84341: LD_EXP 58
84345: PUSH
84346: LD_VAR 0 3
84350: ARRAY
84351: PUSH
84352: LD_INT 1
84354: PLUS
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PPUSH
84360: LD_VAR 0 1
84364: PPUSH
84365: CALL 20665 0 3
84369: ST_TO_ADDR
// exit ;
84370: POP
84371: POP
84372: GO 84378
// end ; end ;
84374: GO 84178
84376: POP
84377: POP
// end ;
84378: LD_VAR 0 2
84382: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84383: LD_INT 0
84385: PPUSH
84386: PPUSH
84387: PPUSH
84388: PPUSH
84389: PPUSH
84390: PPUSH
84391: PPUSH
// if not mc_bases or not skirmish then
84392: LD_EXP 58
84396: NOT
84397: PUSH
84398: LD_EXP 56
84402: NOT
84403: OR
84404: IFFALSE 84408
// exit ;
84406: GO 85069
// for i = 1 to mc_bases do
84408: LD_ADDR_VAR 0 3
84412: PUSH
84413: DOUBLE
84414: LD_INT 1
84416: DEC
84417: ST_TO_ADDR
84418: LD_EXP 58
84422: PUSH
84423: FOR_TO
84424: IFFALSE 85067
// begin if building in mc_construct_list [ i ] then
84426: LD_VAR 0 1
84430: PUSH
84431: LD_EXP 65
84435: PUSH
84436: LD_VAR 0 3
84440: ARRAY
84441: IN
84442: IFFALSE 85065
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84444: LD_ADDR_EXP 65
84448: PUSH
84449: LD_EXP 65
84453: PPUSH
84454: LD_VAR 0 3
84458: PPUSH
84459: LD_EXP 65
84463: PUSH
84464: LD_VAR 0 3
84468: ARRAY
84469: PUSH
84470: LD_VAR 0 1
84474: DIFF
84475: PPUSH
84476: CALL_OW 1
84480: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84481: LD_ADDR_EXP 58
84485: PUSH
84486: LD_EXP 58
84490: PPUSH
84491: LD_VAR 0 3
84495: PUSH
84496: LD_EXP 58
84500: PUSH
84501: LD_VAR 0 3
84505: ARRAY
84506: PUSH
84507: LD_INT 1
84509: PLUS
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PPUSH
84515: LD_VAR 0 1
84519: PPUSH
84520: CALL 20665 0 3
84524: ST_TO_ADDR
// btype := GetBType ( building ) ;
84525: LD_ADDR_VAR 0 5
84529: PUSH
84530: LD_VAR 0 1
84534: PPUSH
84535: CALL_OW 266
84539: ST_TO_ADDR
// side := GetSide ( building ) ;
84540: LD_ADDR_VAR 0 8
84544: PUSH
84545: LD_VAR 0 1
84549: PPUSH
84550: CALL_OW 255
84554: ST_TO_ADDR
// if btype = b_lab then
84555: LD_VAR 0 5
84559: PUSH
84560: LD_INT 6
84562: EQUAL
84563: IFFALSE 84613
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84565: LD_ADDR_EXP 91
84569: PUSH
84570: LD_EXP 91
84574: PPUSH
84575: LD_VAR 0 3
84579: PUSH
84580: LD_EXP 91
84584: PUSH
84585: LD_VAR 0 3
84589: ARRAY
84590: PUSH
84591: LD_INT 1
84593: PLUS
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PPUSH
84599: LD_VAR 0 1
84603: PPUSH
84604: CALL 20665 0 3
84608: ST_TO_ADDR
// exit ;
84609: POP
84610: POP
84611: GO 85069
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84613: LD_VAR 0 5
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: LD_INT 2
84623: PUSH
84624: LD_INT 4
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: LIST
84631: IN
84632: IFFALSE 84756
// begin if btype = b_armoury then
84634: LD_VAR 0 5
84638: PUSH
84639: LD_INT 4
84641: EQUAL
84642: IFFALSE 84652
// btype := b_barracks ;
84644: LD_ADDR_VAR 0 5
84648: PUSH
84649: LD_INT 5
84651: ST_TO_ADDR
// if btype = b_depot then
84652: LD_VAR 0 5
84656: PUSH
84657: LD_INT 0
84659: EQUAL
84660: IFFALSE 84670
// btype := b_warehouse ;
84662: LD_ADDR_VAR 0 5
84666: PUSH
84667: LD_INT 1
84669: ST_TO_ADDR
// if btype = b_workshop then
84670: LD_VAR 0 5
84674: PUSH
84675: LD_INT 2
84677: EQUAL
84678: IFFALSE 84688
// btype := b_factory ;
84680: LD_ADDR_VAR 0 5
84684: PUSH
84685: LD_INT 3
84687: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84688: LD_VAR 0 5
84692: PPUSH
84693: LD_VAR 0 8
84697: PPUSH
84698: CALL_OW 323
84702: PUSH
84703: LD_INT 1
84705: EQUAL
84706: IFFALSE 84752
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84708: LD_ADDR_EXP 90
84712: PUSH
84713: LD_EXP 90
84717: PPUSH
84718: LD_VAR 0 3
84722: PUSH
84723: LD_EXP 90
84727: PUSH
84728: LD_VAR 0 3
84732: ARRAY
84733: PUSH
84734: LD_INT 1
84736: PLUS
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: PPUSH
84742: LD_VAR 0 1
84746: PPUSH
84747: CALL 20665 0 3
84751: ST_TO_ADDR
// exit ;
84752: POP
84753: POP
84754: GO 85069
// end ; if btype in [ b_bunker , b_turret ] then
84756: LD_VAR 0 5
84760: PUSH
84761: LD_INT 32
84763: PUSH
84764: LD_INT 33
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: IN
84771: IFFALSE 85061
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84773: LD_ADDR_EXP 66
84777: PUSH
84778: LD_EXP 66
84782: PPUSH
84783: LD_VAR 0 3
84787: PUSH
84788: LD_EXP 66
84792: PUSH
84793: LD_VAR 0 3
84797: ARRAY
84798: PUSH
84799: LD_INT 1
84801: PLUS
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PPUSH
84807: LD_VAR 0 1
84811: PPUSH
84812: CALL 20665 0 3
84816: ST_TO_ADDR
// if btype = b_bunker then
84817: LD_VAR 0 5
84821: PUSH
84822: LD_INT 32
84824: EQUAL
84825: IFFALSE 85061
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84827: LD_ADDR_EXP 67
84831: PUSH
84832: LD_EXP 67
84836: PPUSH
84837: LD_VAR 0 3
84841: PUSH
84842: LD_EXP 67
84846: PUSH
84847: LD_VAR 0 3
84851: ARRAY
84852: PUSH
84853: LD_INT 1
84855: PLUS
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PPUSH
84861: LD_VAR 0 1
84865: PPUSH
84866: CALL 20665 0 3
84870: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84871: LD_ADDR_VAR 0 6
84875: PUSH
84876: LD_EXP 58
84880: PUSH
84881: LD_VAR 0 3
84885: ARRAY
84886: PPUSH
84887: LD_INT 25
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 3
84899: PUSH
84900: LD_INT 54
84902: PUSH
84903: EMPTY
84904: LIST
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PPUSH
84914: CALL_OW 72
84918: ST_TO_ADDR
// if tmp then
84919: LD_VAR 0 6
84923: IFFALSE 84929
// exit ;
84925: POP
84926: POP
84927: GO 85069
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84929: LD_ADDR_VAR 0 6
84933: PUSH
84934: LD_EXP 58
84938: PUSH
84939: LD_VAR 0 3
84943: ARRAY
84944: PPUSH
84945: LD_INT 2
84947: PUSH
84948: LD_INT 30
84950: PUSH
84951: LD_INT 4
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 30
84960: PUSH
84961: LD_INT 5
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: LIST
84972: PPUSH
84973: CALL_OW 72
84977: ST_TO_ADDR
// if not tmp then
84978: LD_VAR 0 6
84982: NOT
84983: IFFALSE 84989
// exit ;
84985: POP
84986: POP
84987: GO 85069
// for j in tmp do
84989: LD_ADDR_VAR 0 4
84993: PUSH
84994: LD_VAR 0 6
84998: PUSH
84999: FOR_IN
85000: IFFALSE 85059
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85002: LD_ADDR_VAR 0 7
85006: PUSH
85007: LD_VAR 0 4
85011: PPUSH
85012: CALL_OW 313
85016: PPUSH
85017: LD_INT 25
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PPUSH
85027: CALL_OW 72
85031: ST_TO_ADDR
// if units then
85032: LD_VAR 0 7
85036: IFFALSE 85057
// begin ComExitBuilding ( units [ 1 ] ) ;
85038: LD_VAR 0 7
85042: PUSH
85043: LD_INT 1
85045: ARRAY
85046: PPUSH
85047: CALL_OW 122
// exit ;
85051: POP
85052: POP
85053: POP
85054: POP
85055: GO 85069
// end ; end ;
85057: GO 84999
85059: POP
85060: POP
// end ; end ; exit ;
85061: POP
85062: POP
85063: GO 85069
// end ; end ;
85065: GO 84423
85067: POP
85068: POP
// end ;
85069: LD_VAR 0 2
85073: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85074: LD_INT 0
85076: PPUSH
85077: PPUSH
85078: PPUSH
85079: PPUSH
85080: PPUSH
85081: PPUSH
85082: PPUSH
// if not mc_bases or not skirmish then
85083: LD_EXP 58
85087: NOT
85088: PUSH
85089: LD_EXP 56
85093: NOT
85094: OR
85095: IFFALSE 85099
// exit ;
85097: GO 85330
// btype := GetBType ( building ) ;
85099: LD_ADDR_VAR 0 6
85103: PUSH
85104: LD_VAR 0 1
85108: PPUSH
85109: CALL_OW 266
85113: ST_TO_ADDR
// x := GetX ( building ) ;
85114: LD_ADDR_VAR 0 7
85118: PUSH
85119: LD_VAR 0 1
85123: PPUSH
85124: CALL_OW 250
85128: ST_TO_ADDR
// y := GetY ( building ) ;
85129: LD_ADDR_VAR 0 8
85133: PUSH
85134: LD_VAR 0 1
85138: PPUSH
85139: CALL_OW 251
85143: ST_TO_ADDR
// d := GetDir ( building ) ;
85144: LD_ADDR_VAR 0 9
85148: PUSH
85149: LD_VAR 0 1
85153: PPUSH
85154: CALL_OW 254
85158: ST_TO_ADDR
// for i = 1 to mc_bases do
85159: LD_ADDR_VAR 0 4
85163: PUSH
85164: DOUBLE
85165: LD_INT 1
85167: DEC
85168: ST_TO_ADDR
85169: LD_EXP 58
85173: PUSH
85174: FOR_TO
85175: IFFALSE 85328
// begin if not mc_build_list [ i ] then
85177: LD_EXP 63
85181: PUSH
85182: LD_VAR 0 4
85186: ARRAY
85187: NOT
85188: IFFALSE 85192
// continue ;
85190: GO 85174
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
85192: LD_VAR 0 6
85196: PUSH
85197: LD_VAR 0 7
85201: PUSH
85202: LD_VAR 0 8
85206: PUSH
85207: LD_VAR 0 9
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: PPUSH
85218: LD_EXP 63
85222: PUSH
85223: LD_VAR 0 4
85227: ARRAY
85228: PUSH
85229: LD_INT 1
85231: ARRAY
85232: PPUSH
85233: CALL 26834 0 2
85237: IFFALSE 85326
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
85239: LD_ADDR_EXP 63
85243: PUSH
85244: LD_EXP 63
85248: PPUSH
85249: LD_VAR 0 4
85253: PPUSH
85254: LD_EXP 63
85258: PUSH
85259: LD_VAR 0 4
85263: ARRAY
85264: PPUSH
85265: LD_INT 1
85267: PPUSH
85268: CALL_OW 3
85272: PPUSH
85273: CALL_OW 1
85277: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85278: LD_ADDR_EXP 65
85282: PUSH
85283: LD_EXP 65
85287: PPUSH
85288: LD_VAR 0 4
85292: PUSH
85293: LD_EXP 65
85297: PUSH
85298: LD_VAR 0 4
85302: ARRAY
85303: PUSH
85304: LD_INT 1
85306: PLUS
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PPUSH
85312: LD_VAR 0 1
85316: PPUSH
85317: CALL 20665 0 3
85321: ST_TO_ADDR
// exit ;
85322: POP
85323: POP
85324: GO 85330
// end ; end ;
85326: GO 85174
85328: POP
85329: POP
// end ;
85330: LD_VAR 0 3
85334: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85335: LD_INT 0
85337: PPUSH
85338: PPUSH
85339: PPUSH
// if not mc_bases or not skirmish then
85340: LD_EXP 58
85344: NOT
85345: PUSH
85346: LD_EXP 56
85350: NOT
85351: OR
85352: IFFALSE 85356
// exit ;
85354: GO 85546
// for i = 1 to mc_bases do
85356: LD_ADDR_VAR 0 4
85360: PUSH
85361: DOUBLE
85362: LD_INT 1
85364: DEC
85365: ST_TO_ADDR
85366: LD_EXP 58
85370: PUSH
85371: FOR_TO
85372: IFFALSE 85459
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85374: LD_VAR 0 1
85378: PUSH
85379: LD_EXP 66
85383: PUSH
85384: LD_VAR 0 4
85388: ARRAY
85389: IN
85390: PUSH
85391: LD_VAR 0 1
85395: PUSH
85396: LD_EXP 67
85400: PUSH
85401: LD_VAR 0 4
85405: ARRAY
85406: IN
85407: NOT
85408: AND
85409: IFFALSE 85457
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85411: LD_ADDR_EXP 67
85415: PUSH
85416: LD_EXP 67
85420: PPUSH
85421: LD_VAR 0 4
85425: PUSH
85426: LD_EXP 67
85430: PUSH
85431: LD_VAR 0 4
85435: ARRAY
85436: PUSH
85437: LD_INT 1
85439: PLUS
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PPUSH
85445: LD_VAR 0 1
85449: PPUSH
85450: CALL 20665 0 3
85454: ST_TO_ADDR
// break ;
85455: GO 85459
// end ; end ;
85457: GO 85371
85459: POP
85460: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85461: LD_VAR 0 1
85465: PPUSH
85466: CALL_OW 257
85470: PUSH
85471: LD_EXP 84
85475: IN
85476: PUSH
85477: LD_VAR 0 1
85481: PPUSH
85482: CALL_OW 266
85486: PUSH
85487: LD_INT 5
85489: EQUAL
85490: AND
85491: PUSH
85492: LD_VAR 0 2
85496: PPUSH
85497: CALL_OW 110
85501: PUSH
85502: LD_INT 18
85504: NONEQUAL
85505: AND
85506: IFFALSE 85546
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85508: LD_VAR 0 2
85512: PPUSH
85513: CALL_OW 257
85517: PUSH
85518: LD_INT 5
85520: PUSH
85521: LD_INT 8
85523: PUSH
85524: LD_INT 9
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: LIST
85531: IN
85532: IFFALSE 85546
// SetClass ( unit , 1 ) ;
85534: LD_VAR 0 2
85538: PPUSH
85539: LD_INT 1
85541: PPUSH
85542: CALL_OW 336
// end ;
85546: LD_VAR 0 3
85550: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85551: LD_INT 0
85553: PPUSH
85554: PPUSH
// if not mc_bases or not skirmish then
85555: LD_EXP 58
85559: NOT
85560: PUSH
85561: LD_EXP 56
85565: NOT
85566: OR
85567: IFFALSE 85571
// exit ;
85569: GO 85687
// if GetLives ( abandoned_vehicle ) > 250 then
85571: LD_VAR 0 2
85575: PPUSH
85576: CALL_OW 256
85580: PUSH
85581: LD_INT 250
85583: GREATER
85584: IFFALSE 85588
// exit ;
85586: GO 85687
// for i = 1 to mc_bases do
85588: LD_ADDR_VAR 0 6
85592: PUSH
85593: DOUBLE
85594: LD_INT 1
85596: DEC
85597: ST_TO_ADDR
85598: LD_EXP 58
85602: PUSH
85603: FOR_TO
85604: IFFALSE 85685
// begin if driver in mc_bases [ i ] then
85606: LD_VAR 0 1
85610: PUSH
85611: LD_EXP 58
85615: PUSH
85616: LD_VAR 0 6
85620: ARRAY
85621: IN
85622: IFFALSE 85683
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85624: LD_VAR 0 1
85628: PPUSH
85629: LD_EXP 58
85633: PUSH
85634: LD_VAR 0 6
85638: ARRAY
85639: PPUSH
85640: LD_INT 2
85642: PUSH
85643: LD_INT 30
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 30
85655: PUSH
85656: LD_INT 1
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: LIST
85667: PPUSH
85668: CALL_OW 72
85672: PUSH
85673: LD_INT 1
85675: ARRAY
85676: PPUSH
85677: CALL_OW 112
// break ;
85681: GO 85685
// end ; end ;
85683: GO 85603
85685: POP
85686: POP
// end ; end_of_file
85687: LD_VAR 0 5
85691: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
85692: GO 85694
85694: DISABLE
// begin ru_radar := 98 ;
85695: LD_ADDR_EXP 101
85699: PUSH
85700: LD_INT 98
85702: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85703: LD_ADDR_EXP 102
85707: PUSH
85708: LD_INT 89
85710: ST_TO_ADDR
// us_hack := 99 ;
85711: LD_ADDR_EXP 103
85715: PUSH
85716: LD_INT 99
85718: ST_TO_ADDR
// us_artillery := 97 ;
85719: LD_ADDR_EXP 104
85723: PUSH
85724: LD_INT 97
85726: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85727: LD_ADDR_EXP 105
85731: PUSH
85732: LD_INT 91
85734: ST_TO_ADDR
// end ;
85735: END
