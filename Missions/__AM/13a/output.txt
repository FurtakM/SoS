// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 56314 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48932 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48932 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48932 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 48932 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4018 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 58494 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7376 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 80197 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 80642 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 81100 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 81369 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 80582 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 81276 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 80642 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 81100 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 81369 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 80426 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 81687 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 80582 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 14950 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 14950 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 14950 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 14950 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 14950 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 14950 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 14950 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 14950 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 14950 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 14950 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 14950 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 14950 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 14950 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 14950 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 14950 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 14950 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 14950 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 14950 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 19790 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 19790 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 19790 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 23234 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 19790 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4015
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 2
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 0
3356: PUSH
3357: LD_INT 0
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: LD_INT 0
3365: PUSH
3366: LD_INT 0
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: LD_INT 0
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 0
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3396: LD_ADDR_VAR 0 3
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 45
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: LD_INT 21
3421: PUSH
3422: LD_INT 1
3424: PUSH
3425: LD_INT 3
3427: PUSH
3428: LD_INT 45
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 22
3439: PUSH
3440: LD_INT 1
3442: PUSH
3443: LD_INT 3
3445: PUSH
3446: LD_INT 45
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: LIST
3453: LIST
3454: PUSH
3455: LD_INT 23
3457: PUSH
3458: LD_INT 1
3460: PUSH
3461: LD_INT 3
3463: PUSH
3464: LD_INT 46
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: ST_TO_ADDR
// amount := Difficulty ;
3479: LD_ADDR_VAR 0 7
3483: PUSH
3484: LD_OWVAR 67
3488: ST_TO_ADDR
// if tick > 30 30$00 then
3489: LD_OWVAR 1
3493: PUSH
3494: LD_INT 63000
3496: GREATER
3497: IFFALSE 3534
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3499: LD_ADDR_VAR 0 7
3503: PUSH
3504: LD_VAR 0 7
3508: PUSH
3509: LD_INT 2
3511: PUSH
3512: LD_INT 3
3514: PUSH
3515: LD_INT 4
3517: PUSH
3518: LD_INT 4
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: PLUS
3533: ST_TO_ADDR
// for i = 1 to amount do
3534: LD_ADDR_VAR 0 1
3538: PUSH
3539: DOUBLE
3540: LD_INT 1
3542: DEC
3543: ST_TO_ADDR
3544: LD_VAR 0 7
3548: PUSH
3549: FOR_TO
3550: IFFALSE 3638
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: LD_VAR 0 3
3561: PPUSH
3562: LD_VAR 0 3
3566: PUSH
3567: LD_INT 1
3569: PLUS
3570: PPUSH
3571: LD_INT 23
3573: PUSH
3574: LD_INT 24
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: LD_INT 1
3583: PPUSH
3584: LD_INT 2
3586: PPUSH
3587: CALL_OW 12
3591: ARRAY
3592: PUSH
3593: LD_INT 1
3595: PUSH
3596: LD_INT 3
3598: PUSH
3599: LD_INT 46
3601: PUSH
3602: LD_INT 47
3604: PUSH
3605: LD_INT 45
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PUSH
3613: LD_INT 1
3615: PPUSH
3616: LD_INT 3
3618: PPUSH
3619: CALL_OW 12
3623: ARRAY
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: PPUSH
3631: CALL_OW 2
3635: ST_TO_ADDR
3636: GO 3549
3638: POP
3639: POP
// MC_InsertProduceList ( base , tmp ) ;
3640: LD_VAR 0 2
3644: PPUSH
3645: LD_VAR 0 3
3649: PPUSH
3650: CALL 80582 0 2
// repeat wait ( 0 0$1 ) ;
3654: LD_INT 35
3656: PPUSH
3657: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3661: LD_VAR 0 2
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: CALL 82000 0 2
3673: PUSH
3674: LD_VAR 0 7
3678: GREATEREQUAL
3679: IFFALSE 3654
// wait ( 0 0$30 ) ;
3681: LD_INT 1050
3683: PPUSH
3684: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3688: LD_ADDR_VAR 0 5
3692: PUSH
3693: LD_INT 71
3695: PUSH
3696: LD_INT 19
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: LD_INT 91
3705: PUSH
3706: LD_INT 67
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PUSH
3713: LD_INT 52
3715: PUSH
3716: LD_INT 44
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 68
3725: PUSH
3726: LD_INT 48
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: LIST
3737: LIST
3738: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3739: LD_ADDR_VAR 0 6
3743: PUSH
3744: LD_EXP 80
3748: PUSH
3749: LD_VAR 0 2
3753: ARRAY
3754: PUSH
3755: LD_EXP 80
3759: PUSH
3760: LD_VAR 0 2
3764: ARRAY
3765: PPUSH
3766: LD_INT 2
3768: PUSH
3769: LD_INT 34
3771: PUSH
3772: LD_INT 51
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PUSH
3779: LD_INT 34
3781: PUSH
3782: LD_INT 52
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 72
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4015
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 2
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 2
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// repeat wait ( 0 0$1 ) ;
3951: LD_INT 35
3953: PPUSH
3954: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3958: LD_VAR 0 6
3962: PPUSH
3963: LD_INT 60
3965: PUSH
3966: EMPTY
3967: LIST
3968: PPUSH
3969: CALL_OW 72
3973: NOT
3974: IFFALSE 3951
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3976: LD_VAR 0 2
3980: PPUSH
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_VAR 0 5
3990: PPUSH
3991: LD_VAR 0 4
3995: PPUSH
3996: CALL 80767 0 4
// if not first_attack then
4000: LD_EXP 7
4004: NOT
4005: IFFALSE 4015
// first_attack := true ;
4007: LD_ADDR_EXP 7
4011: PUSH
4012: LD_INT 1
4014: ST_TO_ADDR
// end ; end_of_file
4015: PPOPN 7
4017: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4018: LD_INT 0
4020: PPUSH
4021: PPUSH
4022: PPUSH
4023: PPUSH
4024: PPUSH
4025: PPUSH
4026: PPUSH
// uc_side := 2 ;
4027: LD_ADDR_OWVAR 20
4031: PUSH
4032: LD_INT 2
4034: ST_TO_ADDR
// uc_nation := 2 ;
4035: LD_ADDR_OWVAR 21
4039: PUSH
4040: LD_INT 2
4042: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4043: LD_ADDR_EXP 57
4047: PUSH
4048: LD_STRING Abdul
4050: PPUSH
4051: CALL_OW 25
4055: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4056: LD_EXP 57
4060: PPUSH
4061: LD_INT 11
4063: PPUSH
4064: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4068: LD_EXP 57
4072: PPUSH
4073: LD_INT 1
4075: PPUSH
4076: CALL_OW 52
// vc_chassis := 31 ;
4080: LD_ADDR_OWVAR 37
4084: PUSH
4085: LD_INT 31
4087: ST_TO_ADDR
// vc_control := control_rider ;
4088: LD_ADDR_OWVAR 38
4092: PUSH
4093: LD_INT 4
4095: ST_TO_ADDR
// mastodont := CreateVehicle ;
4096: LD_ADDR_EXP 58
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4106: LD_EXP 58
4110: PPUSH
4111: LD_INT 153
4113: PPUSH
4114: LD_INT 71
4116: PPUSH
4117: LD_INT 0
4119: PPUSH
4120: CALL_OW 48
// InitVc ;
4124: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4128: LD_ADDR_EXP 55
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: LD_STRING 
4141: PPUSH
4142: LD_INT 7
4144: PUSH
4145: LD_INT 8
4147: PUSH
4148: LD_INT 9
4150: PUSH
4151: LD_INT 10
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_OWVAR 67
4164: ARRAY
4165: PPUSH
4166: LD_INT 5000
4168: PUSH
4169: LD_INT 1000
4171: PUSH
4172: LD_INT 300
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PPUSH
4180: LD_INT 18
4182: PUSH
4183: LD_INT 5
4185: PUSH
4186: LD_INT 6
4188: PUSH
4189: LD_INT 9
4191: PUSH
4192: EMPTY
4193: LIST
4194: LIST
4195: LIST
4196: LIST
4197: PPUSH
4198: CALL 23234 0 6
4202: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4203: LD_ADDR_EXP 61
4207: PUSH
4208: LD_EXP 61
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_EXP 55
4220: PPUSH
4221: CALL_OW 1
4225: ST_TO_ADDR
// tmp := [ ] ;
4226: LD_ADDR_VAR 0 4
4230: PUSH
4231: EMPTY
4232: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4233: LD_ADDR_OWVAR 37
4237: PUSH
4238: LD_INT 14
4240: ST_TO_ADDR
// vc_engine := engine_siberite ;
4241: LD_ADDR_OWVAR 39
4245: PUSH
4246: LD_INT 3
4248: ST_TO_ADDR
// vc_control := control_manual ;
4249: LD_ADDR_OWVAR 38
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4257: LD_ADDR_OWVAR 40
4261: PUSH
4262: LD_INT 31
4264: ST_TO_ADDR
// for i = 1 to 3 do
4265: LD_ADDR_VAR 0 2
4269: PUSH
4270: DOUBLE
4271: LD_INT 1
4273: DEC
4274: ST_TO_ADDR
4275: LD_INT 3
4277: PUSH
4278: FOR_TO
4279: IFFALSE 4527
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4281: LD_ADDR_VAR 0 5
4285: PUSH
4286: LD_INT 153
4288: PUSH
4289: LD_INT 71
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 155
4298: PUSH
4299: LD_INT 81
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PUSH
4310: LD_VAR 0 2
4314: PUSH
4315: LD_INT 2
4317: MOD
4318: PUSH
4319: LD_INT 1
4321: PLUS
4322: ARRAY
4323: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4324: LD_INT 0
4326: PPUSH
4327: LD_INT 3
4329: PPUSH
4330: LD_INT 7
4332: PUSH
4333: LD_INT 8
4335: PUSH
4336: LD_INT 10
4338: PUSH
4339: LD_INT 10
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: LD_OWVAR 67
4352: ARRAY
4353: PPUSH
4354: CALL_OW 380
// un := CreateVehicle ;
4358: LD_ADDR_VAR 0 6
4362: PUSH
4363: CALL_OW 45
4367: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4368: LD_VAR 0 6
4372: PPUSH
4373: LD_INT 0
4375: PPUSH
4376: LD_INT 5
4378: PPUSH
4379: CALL_OW 12
4383: PPUSH
4384: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4388: LD_VAR 0 6
4392: PPUSH
4393: LD_VAR 0 5
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PPUSH
4402: LD_VAR 0 5
4406: PUSH
4407: LD_INT 2
4409: ARRAY
4410: PPUSH
4411: LD_INT 6
4413: PPUSH
4414: LD_INT 0
4416: PPUSH
4417: CALL_OW 50
// un2 := CreateHuman ;
4421: LD_ADDR_VAR 0 7
4425: PUSH
4426: CALL_OW 44
4430: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4431: LD_VAR 0 7
4435: PPUSH
4436: LD_VAR 0 6
4440: PPUSH
4441: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4445: LD_ADDR_EXP 61
4449: PUSH
4450: LD_EXP 61
4454: PPUSH
4455: LD_INT 1
4457: PUSH
4458: LD_EXP 61
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PUSH
4467: LD_INT 1
4469: PLUS
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PPUSH
4475: LD_VAR 0 6
4479: PPUSH
4480: CALL 19912 0 3
4484: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4485: LD_ADDR_EXP 61
4489: PUSH
4490: LD_EXP 61
4494: PPUSH
4495: LD_INT 1
4497: PUSH
4498: LD_EXP 61
4502: PUSH
4503: LD_INT 1
4505: ARRAY
4506: PUSH
4507: LD_INT 1
4509: PLUS
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PPUSH
4515: LD_VAR 0 7
4519: PPUSH
4520: CALL 19912 0 3
4524: ST_TO_ADDR
// end ;
4525: GO 4278
4527: POP
4528: POP
// for i = 1 to 5 do
4529: LD_ADDR_VAR 0 2
4533: PUSH
4534: DOUBLE
4535: LD_INT 1
4537: DEC
4538: ST_TO_ADDR
4539: LD_INT 5
4541: PUSH
4542: FOR_TO
4543: IFFALSE 4636
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4545: LD_INT 14
4547: PPUSH
4548: LD_INT 3
4550: PPUSH
4551: LD_INT 1
4553: PPUSH
4554: LD_INT 25
4556: PUSH
4557: LD_INT 28
4559: PUSH
4560: LD_INT 28
4562: PUSH
4563: LD_INT 26
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: PUSH
4577: LD_INT 4
4579: MOD
4580: PUSH
4581: LD_INT 1
4583: PLUS
4584: ARRAY
4585: PPUSH
4586: LD_INT 100
4588: PPUSH
4589: CALL 19790 0 5
// veh := CreateVehicle ;
4593: LD_ADDR_VAR 0 3
4597: PUSH
4598: CALL_OW 45
4602: ST_TO_ADDR
// tmp := tmp ^ veh ;
4603: LD_ADDR_VAR 0 4
4607: PUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_VAR 0 3
4617: ADD
4618: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4619: LD_VAR 0 3
4623: PPUSH
4624: LD_INT 1
4626: PPUSH
4627: LD_INT 0
4629: PPUSH
4630: CALL_OW 49
// end ;
4634: GO 4542
4636: POP
4637: POP
// arabian_guard := tmp ;
4638: LD_ADDR_EXP 56
4642: PUSH
4643: LD_VAR 0 4
4647: ST_TO_ADDR
// end ;
4648: LD_VAR 0 1
4652: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4653: LD_INT 22
4655: PUSH
4656: LD_INT 7
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 91
4665: PUSH
4666: LD_INT 1
4668: PUSH
4669: LD_INT 12
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: LIST
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PPUSH
4681: CALL_OW 69
4685: PUSH
4686: LD_EXP 58
4690: PPUSH
4691: CALL_OW 256
4695: PUSH
4696: LD_INT 990
4698: LESS
4699: OR
4700: PUSH
4701: LD_EXP 57
4705: PPUSH
4706: CALL_OW 256
4710: PUSH
4711: LD_INT 990
4713: LESS
4714: OR
4715: IFFALSE 4858
4717: GO 4719
4719: DISABLE
// begin if IsInUnit ( Abdul ) then
4720: LD_EXP 57
4724: PPUSH
4725: CALL_OW 310
4729: IFFALSE 4740
// ComExitBuilding ( Abdul ) ;
4731: LD_EXP 57
4735: PPUSH
4736: CALL_OW 122
// if Mastodont then
4740: LD_EXP 58
4744: IFFALSE 4761
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4746: LD_EXP 58
4750: PPUSH
4751: LD_INT 205
4753: PPUSH
4754: LD_INT 132
4756: PPUSH
4757: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4761: LD_EXP 57
4765: PPUSH
4766: LD_INT 205
4768: PPUSH
4769: LD_INT 132
4771: PPUSH
4772: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4776: LD_INT 35
4778: PPUSH
4779: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4783: LD_EXP 57
4787: PPUSH
4788: LD_INT 21
4790: PPUSH
4791: CALL_OW 308
4795: IFFALSE 4776
// RemoveUnit ( Abdul ) ;
4797: LD_EXP 57
4801: PPUSH
4802: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 21
4820: PPUSH
4821: CALL_OW 308
4825: PUSH
4826: LD_EXP 58
4830: PPUSH
4831: CALL_OW 301
4835: OR
4836: IFFALSE 4806
// if IsOk ( Mastodont ) then
4838: LD_EXP 58
4842: PPUSH
4843: CALL_OW 302
4847: IFFALSE 4858
// RemoveUnit ( Mastodont ) ;
4849: LD_EXP 58
4853: PPUSH
4854: CALL_OW 64
// end ;
4858: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4859: LD_EXP 57
4863: PPUSH
4864: CALL_OW 301
4868: PUSH
4869: LD_INT 22
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PUSH
4879: LD_INT 2
4881: PUSH
4882: LD_INT 25
4884: PUSH
4885: LD_INT 1
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 25
4894: PUSH
4895: LD_INT 2
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 25
4904: PUSH
4905: LD_INT 3
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: LD_INT 25
4914: PUSH
4915: LD_INT 4
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 25
4924: PUSH
4925: LD_INT 8
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PPUSH
4944: CALL_OW 69
4948: PUSH
4949: LD_INT 16
4951: PUSH
4952: LD_INT 19
4954: PUSH
4955: LD_INT 22
4957: PUSH
4958: LD_INT 22
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: PUSH
4967: LD_OWVAR 67
4971: ARRAY
4972: LESS
4973: OR
4974: IFFALSE 5647
4976: GO 4978
4978: DISABLE
4979: LD_INT 0
4981: PPUSH
4982: PPUSH
4983: PPUSH
4984: PPUSH
4985: PPUSH
4986: PPUSH
// begin MC_Kill ( 1 ) ;
4987: LD_INT 1
4989: PPUSH
4990: CALL 56571 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4994: LD_ADDR_VAR 0 2
4998: PUSH
4999: LD_INT 22
5001: PUSH
5002: LD_INT 2
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: PUSH
5009: LD_INT 2
5011: PUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 1
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PUSH
5022: LD_INT 25
5024: PUSH
5025: LD_INT 2
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: PUSH
5032: LD_INT 25
5034: PUSH
5035: LD_INT 3
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PUSH
5042: LD_INT 25
5044: PUSH
5045: LD_INT 4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 25
5054: PUSH
5055: LD_INT 8
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: LIST
5066: LIST
5067: LIST
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PPUSH
5074: CALL_OW 69
5078: ST_TO_ADDR
// for i in tmp do
5079: LD_ADDR_VAR 0 5
5083: PUSH
5084: LD_VAR 0 2
5088: PUSH
5089: FOR_IN
5090: IFFALSE 5106
// SetTag ( i , 10 ) ;
5092: LD_VAR 0 5
5096: PPUSH
5097: LD_INT 10
5099: PPUSH
5100: CALL_OW 109
5104: GO 5089
5106: POP
5107: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5108: LD_ADDR_VAR 0 3
5112: PUSH
5113: LD_INT 22
5115: PUSH
5116: LD_INT 2
5118: PUSH
5119: EMPTY
5120: LIST
5121: LIST
5122: PUSH
5123: LD_INT 21
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PPUSH
5137: CALL_OW 69
5141: PUSH
5142: LD_VAR 0 2
5146: DIFF
5147: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5148: LD_ADDR_VAR 0 1
5152: PUSH
5153: LD_INT 22
5155: PUSH
5156: LD_INT 2
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 21
5165: PUSH
5166: LD_INT 2
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 24
5175: PUSH
5176: LD_INT 300
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 69
5192: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5193: LD_ADDR_VAR 0 4
5197: PUSH
5198: LD_VAR 0 1
5202: PPUSH
5203: LD_INT 33
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 58
5215: PUSH
5216: EMPTY
5217: LIST
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PPUSH
5223: CALL_OW 72
5227: ST_TO_ADDR
// for i in tmp do
5228: LD_ADDR_VAR 0 5
5232: PUSH
5233: LD_VAR 0 2
5237: PUSH
5238: FOR_IN
5239: IFFALSE 5423
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5241: LD_VAR 0 5
5245: PUSH
5246: LD_INT 55
5248: PUSH
5249: EMPTY
5250: LIST
5251: PPUSH
5252: CALL_OW 69
5256: IN
5257: IFFALSE 5276
// begin AddComMoveXY ( i , 209 , 132 ) ;
5259: LD_VAR 0 5
5263: PPUSH
5264: LD_INT 209
5266: PPUSH
5267: LD_INT 132
5269: PPUSH
5270: CALL_OW 171
// continue ;
5274: GO 5238
// end ; if IsInUnit ( i ) then
5276: LD_VAR 0 5
5280: PPUSH
5281: CALL_OW 310
5285: IFFALSE 5303
// begin ComExitBuilding ( i ) ;
5287: LD_VAR 0 5
5291: PPUSH
5292: CALL_OW 122
// wait ( 3 ) ;
5296: LD_INT 3
5298: PPUSH
5299: CALL_OW 67
// end ; if tmp_empty then
5303: LD_VAR 0 4
5307: IFFALSE 5406
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5309: LD_VAR 0 5
5313: PPUSH
5314: LD_VAR 0 4
5318: PPUSH
5319: LD_VAR 0 5
5323: PPUSH
5324: CALL_OW 74
5328: PPUSH
5329: CALL_OW 296
5333: PUSH
5334: LD_INT 25
5336: LESS
5337: IFFALSE 5406
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5339: LD_ADDR_VAR 0 6
5343: PUSH
5344: LD_VAR 0 4
5348: PPUSH
5349: LD_VAR 0 5
5353: PPUSH
5354: CALL_OW 74
5358: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5359: LD_VAR 0 5
5363: PPUSH
5364: LD_VAR 0 6
5368: PPUSH
5369: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5373: LD_VAR 0 5
5377: PPUSH
5378: LD_INT 209
5380: PPUSH
5381: LD_INT 132
5383: PPUSH
5384: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5388: LD_ADDR_VAR 0 4
5392: PUSH
5393: LD_VAR 0 4
5397: PUSH
5398: LD_VAR 0 6
5402: DIFF
5403: ST_TO_ADDR
// continue ;
5404: GO 5238
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_INT 201
5413: PPUSH
5414: LD_INT 132
5416: PPUSH
5417: CALL_OW 171
// end ;
5421: GO 5238
5423: POP
5424: POP
// for i in tmp_ape do
5425: LD_ADDR_VAR 0 5
5429: PUSH
5430: LD_VAR 0 3
5434: PUSH
5435: FOR_IN
5436: IFFALSE 5475
// begin if IsInUnit ( i ) then
5438: LD_VAR 0 5
5442: PPUSH
5443: CALL_OW 310
5447: IFFALSE 5458
// ComExitBuilding ( i ) ;
5449: LD_VAR 0 5
5453: PPUSH
5454: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5458: LD_VAR 0 5
5462: PPUSH
5463: LD_INT 201
5465: PPUSH
5466: LD_INT 132
5468: PPUSH
5469: CALL_OW 171
// end ;
5473: GO 5435
5475: POP
5476: POP
// repeat wait ( 0 0$1 ) ;
5477: LD_INT 35
5479: PPUSH
5480: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5484: LD_ADDR_VAR 0 5
5488: PUSH
5489: LD_VAR 0 2
5493: PUSH
5494: LD_VAR 0 3
5498: UNION
5499: PUSH
5500: LD_VAR 0 1
5504: UNION
5505: PUSH
5506: FOR_IN
5507: IFFALSE 5538
// if not HasTask ( i ) then
5509: LD_VAR 0 5
5513: PPUSH
5514: CALL_OW 314
5518: NOT
5519: IFFALSE 5536
// ComMoveXY ( i , 201 , 132 ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_INT 201
5528: PPUSH
5529: LD_INT 132
5531: PPUSH
5532: CALL_OW 111
5536: GO 5506
5538: POP
5539: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5540: LD_INT 21
5542: PPUSH
5543: LD_INT 22
5545: PUSH
5546: LD_INT 2
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 70
5557: IFFALSE 5598
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5559: LD_ADDR_VAR 0 5
5563: PUSH
5564: LD_INT 21
5566: PPUSH
5567: LD_INT 22
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PPUSH
5577: CALL_OW 70
5581: PUSH
5582: FOR_IN
5583: IFFALSE 5596
// RemoveUnit ( i ) ;
5585: LD_VAR 0 5
5589: PPUSH
5590: CALL_OW 64
5594: GO 5582
5596: POP
5597: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5598: LD_INT 22
5600: PUSH
5601: LD_INT 2
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 2
5610: PUSH
5611: LD_INT 21
5613: PUSH
5614: LD_INT 1
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PUSH
5621: LD_INT 21
5623: PUSH
5624: LD_INT 2
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: LIST
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PPUSH
5640: CALL_OW 69
5644: NOT
5645: IFFALSE 5477
// end ;
5647: PPOPN 6
5649: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5650: LD_EXP 9
5654: PUSH
5655: LD_INT 92
5657: PPUSH
5658: LD_INT 40
5660: PPUSH
5661: CALL_OW 428
5665: PPUSH
5666: CALL_OW 266
5670: PUSH
5671: LD_INT 30
5673: EQUAL
5674: AND
5675: IFFALSE 5871
5677: GO 5679
5679: DISABLE
5680: LD_INT 0
5682: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5683: LD_ADDR_VAR 0 1
5687: PUSH
5688: LD_EXP 61
5692: PUSH
5693: LD_INT 1
5695: ARRAY
5696: PPUSH
5697: LD_INT 25
5699: PUSH
5700: LD_INT 4
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 72
5711: ST_TO_ADDR
// if not sci then
5712: LD_VAR 0 1
5716: NOT
5717: IFFALSE 5721
// exit ;
5719: GO 5871
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5721: LD_ADDR_EXP 61
5725: PUSH
5726: LD_EXP 61
5730: PPUSH
5731: LD_INT 1
5733: PPUSH
5734: LD_EXP 61
5738: PUSH
5739: LD_INT 1
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 1
5747: PUSH
5748: LD_INT 1
5750: ARRAY
5751: DIFF
5752: PPUSH
5753: CALL_OW 1
5757: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: CALL_OW 310
5771: IFFALSE 5786
// ComExitBuilding ( sci [ 1 ] ) ;
5773: LD_VAR 0 1
5777: PUSH
5778: LD_INT 1
5780: ARRAY
5781: PPUSH
5782: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5786: LD_INT 2
5788: PPUSH
5789: LD_INT 105
5791: PPUSH
5792: LD_INT 14
5794: PPUSH
5795: LD_INT 20
5797: PPUSH
5798: CALL 20808 0 4
5802: PUSH
5803: LD_INT 4
5805: ARRAY
5806: PUSH
5807: LD_INT 10
5809: LESS
5810: IFFALSE 5833
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5812: LD_VAR 0 1
5816: PUSH
5817: LD_INT 1
5819: ARRAY
5820: PPUSH
5821: LD_INT 105
5823: PPUSH
5824: LD_INT 14
5826: PPUSH
5827: CALL_OW 171
5831: GO 5852
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5833: LD_VAR 0 1
5837: PUSH
5838: LD_INT 1
5840: ARRAY
5841: PPUSH
5842: LD_INT 118
5844: PPUSH
5845: LD_INT 77
5847: PPUSH
5848: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5852: LD_VAR 0 1
5856: PUSH
5857: LD_INT 1
5859: ARRAY
5860: PPUSH
5861: LD_INT 92
5863: PPUSH
5864: LD_INT 40
5866: PPUSH
5867: CALL_OW 218
// end ;
5871: PPOPN 1
5873: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5874: LD_INT 1
5876: PPUSH
5877: CALL_OW 302
5881: PUSH
5882: LD_EXP 9
5886: AND
5887: IFFALSE 6364
5889: GO 5891
5891: DISABLE
5892: LD_INT 0
5894: PPUSH
5895: PPUSH
5896: PPUSH
5897: PPUSH
5898: PPUSH
5899: PPUSH
// begin enable ;
5900: ENABLE
// base := 1 ;
5901: LD_ADDR_VAR 0 2
5905: PUSH
5906: LD_INT 1
5908: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5909: LD_ADDR_VAR 0 4
5913: PUSH
5914: LD_INT 0
5916: PUSH
5917: LD_INT 0
5919: PUSH
5920: LD_INT 0
5922: PUSH
5923: LD_INT 0
5925: PUSH
5926: LD_INT 0
5928: PUSH
5929: LD_INT 0
5931: PUSH
5932: LD_INT 0
5934: PUSH
5935: LD_INT 0
5937: PUSH
5938: LD_INT 1
5940: PUSH
5941: LD_INT 0
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5956: LD_ADDR_VAR 0 3
5960: PUSH
5961: LD_INT 14
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 26
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 14
5981: PUSH
5982: LD_INT 1
5984: PUSH
5985: LD_INT 2
5987: PUSH
5988: LD_INT 28
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 13
5999: PUSH
6000: LD_INT 1
6002: PUSH
6003: LD_INT 2
6005: PUSH
6006: LD_INT 29
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: LIST
6019: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6020: LD_ADDR_VAR 0 1
6024: PUSH
6025: DOUBLE
6026: LD_INT 1
6028: DEC
6029: ST_TO_ADDR
6030: LD_OWVAR 67
6034: PUSH
6035: LD_OWVAR 1
6039: PUSH
6040: LD_INT 21000
6042: DIV
6043: PLUS
6044: PUSH
6045: FOR_TO
6046: IFFALSE 6138
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6048: LD_ADDR_VAR 0 3
6052: PUSH
6053: LD_VAR 0 3
6057: PPUSH
6058: LD_VAR 0 3
6062: PUSH
6063: LD_INT 1
6065: PLUS
6066: PPUSH
6067: LD_INT 13
6069: PUSH
6070: LD_INT 14
6072: PUSH
6073: EMPTY
6074: LIST
6075: LIST
6076: PUSH
6077: LD_INT 1
6079: PPUSH
6080: LD_INT 2
6082: PPUSH
6083: CALL_OW 12
6087: ARRAY
6088: PUSH
6089: LD_INT 1
6091: PUSH
6092: LD_INT 2
6094: PUSH
6095: LD_INT 28
6097: PUSH
6098: LD_INT 29
6100: PUSH
6101: LD_INT 25
6103: PUSH
6104: LD_INT 26
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: PUSH
6113: LD_INT 1
6115: PPUSH
6116: LD_INT 4
6118: PPUSH
6119: CALL_OW 12
6123: ARRAY
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: PPUSH
6131: CALL_OW 2
6135: ST_TO_ADDR
6136: GO 6045
6138: POP
6139: POP
// MC_InsertProduceList ( base , tmp ) ;
6140: LD_VAR 0 2
6144: PPUSH
6145: LD_VAR 0 3
6149: PPUSH
6150: CALL 80582 0 2
// repeat wait ( 0 0$1 ) ;
6154: LD_INT 35
6156: PPUSH
6157: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6161: LD_EXP 80
6165: PUSH
6166: LD_VAR 0 2
6170: ARRAY
6171: PUSH
6172: LD_INT 6
6174: GREATER
6175: IFFALSE 6154
// wait ( 0 0$20 ) ;
6177: LD_INT 700
6179: PPUSH
6180: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6184: LD_ADDR_VAR 0 5
6188: PUSH
6189: LD_INT 124
6191: PUSH
6192: LD_INT 85
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 90
6201: PUSH
6202: LD_INT 61
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 69
6211: PUSH
6212: LD_INT 48
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PUSH
6219: LD_INT 68
6221: PUSH
6222: LD_INT 48
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6235: LD_ADDR_VAR 0 6
6239: PUSH
6240: LD_EXP 80
6244: PUSH
6245: LD_VAR 0 2
6249: ARRAY
6250: PUSH
6251: LD_EXP 80
6255: PUSH
6256: LD_VAR 0 2
6260: ARRAY
6261: PPUSH
6262: LD_INT 2
6264: PUSH
6265: LD_INT 34
6267: PUSH
6268: LD_INT 32
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 34
6277: PUSH
6278: LD_INT 88
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: LIST
6289: PPUSH
6290: CALL_OW 72
6294: DIFF
6295: ST_TO_ADDR
// if not attackers then
6296: LD_VAR 0 6
6300: NOT
6301: IFFALSE 6305
// exit ;
6303: GO 6364
// ar_attackers := attackers ;
6305: LD_ADDR_EXP 11
6309: PUSH
6310: LD_VAR 0 6
6314: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6315: LD_INT 35
6317: PPUSH
6318: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6322: LD_VAR 0 6
6326: PPUSH
6327: LD_INT 60
6329: PUSH
6330: EMPTY
6331: LIST
6332: PPUSH
6333: CALL_OW 72
6337: NOT
6338: IFFALSE 6315
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_VAR 0 6
6349: PPUSH
6350: LD_VAR 0 5
6354: PPUSH
6355: LD_VAR 0 4
6359: PPUSH
6360: CALL 80767 0 4
// end ;
6364: PPOPN 6
6366: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6367: LD_INT 1
6369: PPUSH
6370: CALL_OW 302
6374: PUSH
6375: LD_EXP 9
6379: AND
6380: PUSH
6381: LD_EXP 51
6385: PPUSH
6386: LD_INT 22
6388: PPUSH
6389: CALL_OW 308
6393: AND
6394: PUSH
6395: LD_INT 1
6397: PPUSH
6398: CALL 80930 0 1
6402: PUSH
6403: LD_INT 0
6405: EQUAL
6406: AND
6407: PUSH
6408: LD_EXP 11
6412: NOT
6413: AND
6414: IFFALSE 6900
6416: GO 6418
6418: DISABLE
6419: LD_INT 0
6421: PPUSH
6422: PPUSH
6423: PPUSH
6424: PPUSH
6425: PPUSH
6426: PPUSH
6427: PPUSH
// begin base := 1 ;
6428: LD_ADDR_VAR 0 2
6432: PUSH
6433: LD_INT 1
6435: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6436: LD_ADDR_VAR 0 4
6440: PUSH
6441: LD_INT 0
6443: PUSH
6444: LD_INT 0
6446: PUSH
6447: LD_INT 0
6449: PUSH
6450: LD_INT 0
6452: PUSH
6453: LD_INT 0
6455: PUSH
6456: LD_INT 0
6458: PUSH
6459: LD_INT 0
6461: PUSH
6462: LD_INT 0
6464: PUSH
6465: LD_INT 1
6467: PUSH
6468: LD_INT 0
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: LIST
6482: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6483: LD_ADDR_VAR 0 3
6487: PUSH
6488: LD_INT 13
6490: PUSH
6491: LD_INT 1
6493: PUSH
6494: LD_INT 2
6496: PUSH
6497: LD_INT 28
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: PUSH
6506: LD_INT 13
6508: PUSH
6509: LD_INT 1
6511: PUSH
6512: LD_INT 2
6514: PUSH
6515: LD_INT 27
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 13
6526: PUSH
6527: LD_INT 1
6529: PUSH
6530: LD_INT 2
6532: PUSH
6533: LD_INT 25
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: PUSH
6542: LD_INT 11
6544: PUSH
6545: LD_INT 2
6547: PUSH
6548: LD_INT 2
6550: PUSH
6551: LD_INT 24
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: PUSH
6560: LD_INT 11
6562: PUSH
6563: LD_INT 2
6565: PUSH
6566: LD_INT 2
6568: PUSH
6569: LD_INT 24
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: LIST
6584: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6585: LD_VAR 0 2
6589: PPUSH
6590: LD_VAR 0 3
6594: PPUSH
6595: CALL 80582 0 2
// repeat wait ( 0 0$1 ) ;
6599: LD_INT 35
6601: PPUSH
6602: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6606: LD_EXP 80
6610: PUSH
6611: LD_VAR 0 2
6615: ARRAY
6616: PUSH
6617: LD_INT 6
6619: GREATEREQUAL
6620: IFFALSE 6599
// wait ( 0 0$20 ) ;
6622: LD_INT 700
6624: PPUSH
6625: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6629: LD_ADDR_VAR 0 5
6633: PUSH
6634: LD_INT 119
6636: PUSH
6637: LD_INT 9
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6647: LD_ADDR_VAR 0 6
6651: PUSH
6652: LD_EXP 80
6656: PUSH
6657: LD_VAR 0 2
6661: ARRAY
6662: PUSH
6663: LD_EXP 80
6667: PUSH
6668: LD_VAR 0 2
6672: ARRAY
6673: PPUSH
6674: LD_INT 2
6676: PUSH
6677: LD_INT 34
6679: PUSH
6680: LD_INT 32
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 34
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 72
6706: DIFF
6707: ST_TO_ADDR
// if not attackers then
6708: LD_VAR 0 6
6712: NOT
6713: IFFALSE 6717
// exit ;
6715: GO 6900
// uc_side := 2 ;
6717: LD_ADDR_OWVAR 20
6721: PUSH
6722: LD_INT 2
6724: ST_TO_ADDR
// uc_nation := 2 ;
6725: LD_ADDR_OWVAR 21
6729: PUSH
6730: LD_INT 2
6732: ST_TO_ADDR
// InitHc ;
6733: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6737: LD_ADDR_VAR 0 1
6741: PUSH
6742: DOUBLE
6743: LD_INT 1
6745: DEC
6746: ST_TO_ADDR
6747: LD_INT 4
6749: PUSH
6750: LD_INT 5
6752: PUSH
6753: LD_INT 6
6755: PUSH
6756: LD_INT 6
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: PUSH
6765: LD_OWVAR 67
6769: ARRAY
6770: PUSH
6771: FOR_TO
6772: IFFALSE 6849
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6774: LD_INT 0
6776: PPUSH
6777: LD_INT 15
6779: PUSH
6780: LD_INT 17
6782: PUSH
6783: EMPTY
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_INT 2
6792: PPUSH
6793: CALL_OW 12
6797: ARRAY
6798: PPUSH
6799: LD_INT 8
6801: PPUSH
6802: CALL_OW 380
// un := CreateHuman ;
6806: LD_ADDR_VAR 0 7
6810: PUSH
6811: CALL_OW 44
6815: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6816: LD_VAR 0 7
6820: PPUSH
6821: LD_INT 23
6823: PPUSH
6824: LD_INT 0
6826: PPUSH
6827: CALL_OW 49
// attackers := attackers union un ;
6831: LD_ADDR_VAR 0 6
6835: PUSH
6836: LD_VAR 0 6
6840: PUSH
6841: LD_VAR 0 7
6845: UNION
6846: ST_TO_ADDR
// end ;
6847: GO 6771
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6858: LD_VAR 0 6
6862: PPUSH
6863: LD_INT 60
6865: PUSH
6866: EMPTY
6867: LIST
6868: PPUSH
6869: CALL_OW 72
6873: NOT
6874: IFFALSE 6851
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6876: LD_VAR 0 2
6880: PPUSH
6881: LD_VAR 0 6
6885: PPUSH
6886: LD_VAR 0 5
6890: PPUSH
6891: LD_VAR 0 4
6895: PPUSH
6896: CALL 80767 0 4
// end ; end_of_file
6900: PPOPN 7
6902: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6903: LD_INT 0
6905: PPUSH
6906: PPUSH
6907: PPUSH
6908: PPUSH
6909: PPUSH
6910: PPUSH
// uc_side := 1 ;
6911: LD_ADDR_OWVAR 20
6915: PUSH
6916: LD_INT 1
6918: ST_TO_ADDR
// uc_nation := 1 ;
6919: LD_ADDR_OWVAR 21
6923: PUSH
6924: LD_INT 1
6926: ST_TO_ADDR
// InitHc ;
6927: CALL_OW 19
// InitVc ;
6931: CALL_OW 20
// tmp := [ ] ;
6935: LD_ADDR_VAR 0 3
6939: PUSH
6940: EMPTY
6941: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6942: LD_ADDR_VAR 0 2
6946: PUSH
6947: DOUBLE
6948: LD_INT 1
6950: DEC
6951: ST_TO_ADDR
6952: LD_INT 6
6954: PUSH
6955: LD_INT 8
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: LD_INT 10
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: PUSH
6970: LD_OWVAR 67
6974: ARRAY
6975: PUSH
6976: FOR_TO
6977: IFFALSE 7251
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6979: LD_ADDR_VAR 0 5
6983: PUSH
6984: LD_INT 2
6986: PUSH
6987: LD_INT 4
6989: PUSH
6990: LD_INT 5
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: LIST
6997: PUSH
6998: LD_INT 1
7000: PPUSH
7001: LD_INT 3
7003: PPUSH
7004: CALL_OW 12
7008: ARRAY
7009: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7010: LD_VAR 0 5
7014: PUSH
7015: LD_INT 2
7017: DOUBLE
7018: EQUAL
7019: IFTRUE 7023
7021: GO 7057
7023: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7024: LD_ADDR_VAR 0 6
7028: PUSH
7029: LD_INT 9
7031: PUSH
7032: LD_INT 5
7034: PUSH
7035: LD_INT 7
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 1
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 12
7053: ARRAY
7054: ST_TO_ADDR
7055: GO 7146
7057: LD_INT 4
7059: DOUBLE
7060: EQUAL
7061: IFTRUE 7065
7063: GO 7103
7065: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7066: LD_ADDR_VAR 0 6
7070: PUSH
7071: LD_INT 9
7073: PUSH
7074: LD_INT 6
7076: PUSH
7077: LD_INT 6
7079: PUSH
7080: LD_INT 7
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: PUSH
7089: LD_INT 1
7091: PPUSH
7092: LD_INT 4
7094: PPUSH
7095: CALL_OW 12
7099: ARRAY
7100: ST_TO_ADDR
7101: GO 7146
7103: LD_INT 5
7105: DOUBLE
7106: EQUAL
7107: IFTRUE 7111
7109: GO 7145
7111: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7112: LD_ADDR_VAR 0 6
7116: PUSH
7117: LD_INT 9
7119: PUSH
7120: LD_INT 6
7122: PUSH
7123: LD_INT 7
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: PUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 3
7136: PPUSH
7137: CALL_OW 12
7141: ARRAY
7142: ST_TO_ADDR
7143: GO 7146
7145: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7146: LD_VAR 0 5
7150: PPUSH
7151: LD_INT 1
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 1
7163: PPUSH
7164: LD_INT 2
7166: PPUSH
7167: CALL_OW 12
7171: ARRAY
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_VAR 0 6
7180: PPUSH
7181: LD_INT 70
7183: PPUSH
7184: LD_INT 90
7186: PPUSH
7187: CALL_OW 12
7191: PPUSH
7192: CALL 19790 0 5
// veh := CreateVehicle ;
7196: LD_ADDR_VAR 0 4
7200: PUSH
7201: CALL_OW 45
7205: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7206: LD_VAR 0 4
7210: PPUSH
7211: LD_INT 2
7213: PPUSH
7214: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7218: LD_VAR 0 4
7222: PPUSH
7223: LD_INT 17
7225: PPUSH
7226: LD_INT 0
7228: PPUSH
7229: CALL_OW 49
// tmp := tmp ^ veh ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_VAR 0 3
7242: PUSH
7243: LD_VAR 0 4
7247: ADD
7248: ST_TO_ADDR
// end ;
7249: GO 6976
7251: POP
7252: POP
// if not tmp then
7253: LD_VAR 0 3
7257: NOT
7258: IFFALSE 7262
// exit ;
7260: GO 7371
// if not first_powell_attack then
7262: LD_EXP 12
7266: NOT
7267: IFFALSE 7277
// first_powell_attack := true ;
7269: LD_ADDR_EXP 12
7273: PUSH
7274: LD_INT 1
7276: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7277: LD_INT 70
7279: PPUSH
7280: CALL_OW 67
// for i in tmp do
7284: LD_ADDR_VAR 0 2
7288: PUSH
7289: LD_VAR 0 3
7293: PUSH
7294: FOR_IN
7295: IFFALSE 7362
// if IsOk ( i ) then
7297: LD_VAR 0 2
7301: PPUSH
7302: CALL_OW 302
7306: IFFALSE 7344
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7308: LD_VAR 0 2
7312: PPUSH
7313: LD_INT 81
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PPUSH
7323: CALL_OW 69
7327: PPUSH
7328: LD_VAR 0 2
7332: PPUSH
7333: CALL_OW 74
7337: PPUSH
7338: CALL_OW 115
7342: GO 7360
// tmp := tmp diff i ;
7344: LD_ADDR_VAR 0 3
7348: PUSH
7349: LD_VAR 0 3
7353: PUSH
7354: LD_VAR 0 2
7358: DIFF
7359: ST_TO_ADDR
7360: GO 7294
7362: POP
7363: POP
// until not tmp ;
7364: LD_VAR 0 3
7368: NOT
7369: IFFALSE 7277
// end ; end_of_file
7371: LD_VAR 0 1
7375: RET
// export function Action ; var tmp , i , un ; begin
7376: LD_INT 0
7378: PPUSH
7379: PPUSH
7380: PPUSH
7381: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7382: LD_INT 68
7384: PPUSH
7385: LD_INT 39
7387: PPUSH
7388: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7392: LD_ADDR_VAR 0 2
7396: PUSH
7397: LD_INT 22
7399: PUSH
7400: LD_INT 7
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PPUSH
7407: CALL_OW 69
7411: ST_TO_ADDR
// InGameOn ;
7412: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7416: LD_VAR 0 2
7420: PPUSH
7421: LD_INT 71
7423: PPUSH
7424: LD_INT 49
7426: PPUSH
7427: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7431: LD_INT 35
7433: PPUSH
7434: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7438: LD_INT 7
7440: PPUSH
7441: LD_INT 71
7443: PPUSH
7444: LD_INT 51
7446: PPUSH
7447: CALL_OW 293
7451: IFFALSE 7431
// DialogueOn ;
7453: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7457: LD_EXP 16
7461: PPUSH
7462: LD_STRING D1-JMM-1
7464: PPUSH
7465: CALL_OW 88
// if Joan then
7469: LD_EXP 31
7473: IFFALSE 7487
// Say ( Joan , D1-Joan-1 ) ;
7475: LD_EXP 31
7479: PPUSH
7480: LD_STRING D1-Joan-1
7482: PPUSH
7483: CALL_OW 88
// if Lisa then
7487: LD_EXP 18
7491: IFFALSE 7505
// Say ( Lisa , D1-Lisa-1 ) ;
7493: LD_EXP 18
7497: PPUSH
7498: LD_STRING D1-Lisa-1
7500: PPUSH
7501: CALL_OW 88
// if Joan or Lisa then
7505: LD_EXP 31
7509: PUSH
7510: LD_EXP 18
7514: OR
7515: IFFALSE 7529
// Say ( JMM , D1-JMM-2 ) ;
7517: LD_EXP 16
7521: PPUSH
7522: LD_STRING D1-JMM-2
7524: PPUSH
7525: CALL_OW 88
// DialogueOff ;
7529: CALL_OW 7
// InGameOff ;
7533: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7537: LD_INT 71
7539: PPUSH
7540: LD_INT 50
7542: PPUSH
7543: LD_INT 7
7545: PPUSH
7546: LD_INT 30
7548: NEG
7549: PPUSH
7550: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7554: LD_INT 71
7556: PPUSH
7557: LD_INT 50
7559: PPUSH
7560: LD_INT 7
7562: PPUSH
7563: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7567: LD_STRING M1
7569: PPUSH
7570: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7574: LD_INT 35
7576: PPUSH
7577: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7581: LD_EXP 3
7585: PUSH
7586: LD_OWVAR 1
7590: PUSH
7591: LD_INT 2100
7593: GREATER
7594: OR
7595: IFFALSE 7574
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7597: LD_INT 350
7599: PPUSH
7600: LD_INT 700
7602: PPUSH
7603: CALL_OW 12
7607: PPUSH
7608: CALL_OW 67
// PrepareGossudarov ;
7612: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7616: LD_INT 35
7618: PPUSH
7619: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7623: LD_INT 22
7625: PUSH
7626: LD_INT 6
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: LD_INT 3
7635: PUSH
7636: LD_INT 24
7638: PUSH
7639: LD_INT 1000
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: CALL_OW 69
7658: PUSH
7659: LD_INT 7
7661: PPUSH
7662: LD_EXP 34
7666: PPUSH
7667: CALL_OW 292
7671: OR
7672: IFFALSE 7616
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 22
7681: PUSH
7682: LD_INT 6
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: PPUSH
7689: CALL_OW 69
7693: ST_TO_ADDR
// for i in tmp do
7694: LD_ADDR_VAR 0 3
7698: PUSH
7699: LD_VAR 0 2
7703: PUSH
7704: FOR_IN
7705: IFFALSE 7721
// SetSide ( i , 7 ) ;
7707: LD_VAR 0 3
7711: PPUSH
7712: LD_INT 7
7714: PPUSH
7715: CALL_OW 235
7719: GO 7704
7721: POP
7722: POP
// DialogueOn ;
7723: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7727: LD_EXP 16
7731: PUSH
7732: LD_EXP 17
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: LD_EXP 34
7745: PPUSH
7746: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7750: LD_EXP 34
7754: PPUSH
7755: CALL_OW 87
// if not Roth then
7759: LD_EXP 17
7763: NOT
7764: IFFALSE 7856
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7766: LD_VAR 0 2
7770: PPUSH
7771: LD_INT 3
7773: PUSH
7774: LD_INT 24
7776: PUSH
7777: LD_INT 1000
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PPUSH
7788: CALL_OW 72
7792: IFFALSE 7806
// Say ( JMM , D2-JMM-1 ) ;
7794: LD_EXP 16
7798: PPUSH
7799: LD_STRING D2-JMM-1
7801: PPUSH
7802: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-JMM-1b
7813: PPUSH
7814: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7818: LD_EXP 34
7822: PPUSH
7823: LD_STRING D2-Gos-1
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7830: LD_EXP 16
7834: PPUSH
7835: LD_STRING D2-JMM-2
7837: PPUSH
7838: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7842: LD_EXP 34
7846: PPUSH
7847: LD_STRING D2-Gos-2
7849: PPUSH
7850: CALL_OW 88
// end else
7854: GO 8008
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7856: LD_VAR 0 2
7860: PPUSH
7861: LD_INT 3
7863: PUSH
7864: LD_INT 24
7866: PUSH
7867: LD_INT 1000
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: IFFALSE 7908
// begin Say ( Roth , D2-Roth-2 ) ;
7884: LD_EXP 17
7888: PPUSH
7889: LD_STRING D2-Roth-2
7891: PPUSH
7892: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7896: LD_EXP 16
7900: PPUSH
7901: LD_STRING D2-JMM-1a
7903: PPUSH
7904: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7908: LD_EXP 17
7912: PPUSH
7913: LD_STRING D2-Roth-2a
7915: PPUSH
7916: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7920: LD_EXP 17
7924: PPUSH
7925: LD_STRING D2-Roth-2b
7927: PPUSH
7928: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7932: LD_EXP 16
7936: PPUSH
7937: LD_STRING D2-JMM-3
7939: PPUSH
7940: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7944: LD_VAR 0 2
7948: PPUSH
7949: LD_INT 3
7951: PUSH
7952: LD_INT 24
7954: PUSH
7955: LD_INT 1000
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PPUSH
7966: CALL_OW 72
7970: IFFALSE 8008
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7972: LD_EXP 34
7976: PPUSH
7977: LD_STRING D2-Gos-3
7979: PPUSH
7980: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7984: LD_EXP 16
7988: PPUSH
7989: LD_STRING D2-JMM-4
7991: PPUSH
7992: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7996: LD_EXP 34
8000: PPUSH
8001: LD_STRING D2-Gos-4
8003: PPUSH
8004: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8008: LD_EXP 16
8012: PPUSH
8013: LD_STRING D2-JMM-5
8015: PPUSH
8016: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8020: LD_EXP 34
8024: PPUSH
8025: LD_STRING D2-Gos-5
8027: PPUSH
8028: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8032: LD_EXP 16
8036: PPUSH
8037: LD_STRING D2-JMM-6
8039: PPUSH
8040: CALL_OW 88
// DialogueOff ;
8044: CALL_OW 7
// wait ( 0 0$2 ) ;
8048: LD_INT 70
8050: PPUSH
8051: CALL_OW 67
// if Kirilenkova then
8055: LD_EXP 35
8059: IFFALSE 8073
// Say ( Kirilenkova , D3-Kir-1 ) ;
8061: LD_EXP 35
8065: PPUSH
8066: LD_STRING D3-Kir-1
8068: PPUSH
8069: CALL_OW 88
// gossudarov_arrive := true ;
8073: LD_ADDR_EXP 4
8077: PUSH
8078: LD_INT 1
8080: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8081: LD_INT 35
8083: PPUSH
8084: CALL_OW 67
// until ru_lab_builded ;
8088: LD_EXP 5
8092: IFFALSE 8081
// DialogueOn ;
8094: CALL_OW 6
// if Kirilenkova then
8098: LD_EXP 35
8102: IFFALSE 8118
// Say ( Kirilenkova , D3a-Kir-1 ) else
8104: LD_EXP 35
8108: PPUSH
8109: LD_STRING D3a-Kir-1
8111: PPUSH
8112: CALL_OW 88
8116: GO 8140
// begin un := SciRu ;
8118: LD_ADDR_VAR 0 4
8122: PUSH
8123: CALL 13334 0 0
8127: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8128: LD_VAR 0 4
8132: PPUSH
8133: LD_STRING D3a-Sci1-1
8135: PPUSH
8136: CALL_OW 88
// end ; if Kirilenkova or un then
8140: LD_EXP 35
8144: PUSH
8145: LD_VAR 0 4
8149: OR
8150: IFFALSE 8164
// Say ( JMM , D3a-JMM-1 ) ;
8152: LD_EXP 16
8156: PPUSH
8157: LD_STRING D3a-JMM-1
8159: PPUSH
8160: CALL_OW 88
// DialogueOff ;
8164: CALL_OW 7
// end ;
8168: LD_VAR 0 1
8172: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8173: LD_EXP 4
8177: PUSH
8178: LD_INT 22
8180: PUSH
8181: LD_INT 7
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 2
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 1
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 25
8213: PUSH
8214: LD_INT 3
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: LD_INT 25
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PUSH
8231: LD_INT 25
8233: PUSH
8234: LD_INT 5
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 25
8243: PUSH
8244: LD_INT 8
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 25
8253: PUSH
8254: LD_INT 9
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PPUSH
8275: CALL_OW 69
8279: PUSH
8280: LD_INT 7
8282: LESS
8283: AND
8284: IFFALSE 8296
8286: GO 8288
8288: DISABLE
// YouLost ( TooMany ) ;
8289: LD_STRING TooMany
8291: PPUSH
8292: CALL_OW 104
8296: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8297: LD_EXP 34
8301: PPUSH
8302: CALL_OW 255
8306: PUSH
8307: LD_INT 7
8309: EQUAL
8310: IFFALSE 8527
8312: GO 8314
8314: DISABLE
8315: LD_INT 0
8317: PPUSH
8318: PPUSH
8319: PPUSH
// begin uc_side := 3 ;
8320: LD_ADDR_OWVAR 20
8324: PUSH
8325: LD_INT 3
8327: ST_TO_ADDR
// uc_nation := 3 ;
8328: LD_ADDR_OWVAR 21
8332: PUSH
8333: LD_INT 3
8335: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8336: LD_INT 21
8338: PPUSH
8339: LD_INT 3
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: LD_INT 42
8347: PPUSH
8348: LD_INT 100
8350: PPUSH
8351: CALL 19790 0 5
// un := CreateVehicle ;
8355: LD_ADDR_VAR 0 3
8359: PUSH
8360: CALL_OW 45
8364: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8380: LD_VAR 0 3
8384: PPUSH
8385: LD_INT 67
8387: PPUSH
8388: LD_INT 45
8390: PPUSH
8391: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8395: LD_VAR 0 3
8399: PPUSH
8400: LD_INT 70
8402: PPUSH
8403: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8407: LD_VAR 0 3
8411: PPUSH
8412: LD_INT 69
8414: PPUSH
8415: LD_INT 18
8417: PPUSH
8418: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8422: LD_VAR 0 3
8426: PPUSH
8427: LD_INT 60
8429: PPUSH
8430: LD_INT 3
8432: PPUSH
8433: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8437: LD_INT 35
8439: PPUSH
8440: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8444: LD_VAR 0 3
8448: PPUSH
8449: CALL_OW 302
8453: NOT
8454: PUSH
8455: LD_VAR 0 3
8459: PPUSH
8460: LD_INT 17
8462: PPUSH
8463: CALL_OW 308
8467: OR
8468: PUSH
8469: LD_VAR 0 3
8473: PPUSH
8474: LD_INT 60
8476: PPUSH
8477: LD_INT 3
8479: PPUSH
8480: CALL_OW 307
8484: OR
8485: IFFALSE 8437
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8487: LD_VAR 0 3
8491: PPUSH
8492: LD_INT 17
8494: PPUSH
8495: CALL_OW 308
8499: PUSH
8500: LD_VAR 0 3
8504: PPUSH
8505: LD_INT 60
8507: PPUSH
8508: LD_INT 3
8510: PPUSH
8511: CALL_OW 307
8515: OR
8516: IFFALSE 8527
// RemoveUnit ( un ) ;
8518: LD_VAR 0 3
8522: PPUSH
8523: CALL_OW 64
// end ;
8527: PPOPN 3
8529: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8530: LD_EXP 4
8534: IFFALSE 8776
8536: GO 8538
8538: DISABLE
8539: LD_INT 0
8541: PPUSH
8542: PPUSH
8543: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8544: LD_INT 70
8546: PPUSH
8547: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8551: LD_ADDR_VAR 0 3
8555: PUSH
8556: LD_INT 22
8558: PUSH
8559: LD_INT 7
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PUSH
8566: LD_INT 101
8568: PUSH
8569: LD_INT 3
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PPUSH
8580: CALL_OW 69
8584: ST_TO_ADDR
// until tmp ;
8585: LD_VAR 0 3
8589: IFFALSE 8544
// un := NearestUnitToUnit ( tmp , JMM ) ;
8591: LD_ADDR_VAR 0 2
8595: PUSH
8596: LD_VAR 0 3
8600: PPUSH
8601: LD_EXP 16
8605: PPUSH
8606: CALL_OW 74
8610: ST_TO_ADDR
// player_spotted := true ;
8611: LD_ADDR_EXP 6
8615: PUSH
8616: LD_INT 1
8618: ST_TO_ADDR
// tmp := SciRu ;
8619: LD_ADDR_VAR 0 3
8623: PUSH
8624: CALL 13334 0 0
8628: ST_TO_ADDR
// if not tmp then
8629: LD_VAR 0 3
8633: NOT
8634: IFFALSE 8646
// tmp := SolRu ;
8636: LD_ADDR_VAR 0 3
8640: PUSH
8641: CALL 13481 0 0
8645: ST_TO_ADDR
// DialogueOn ;
8646: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8650: LD_VAR 0 2
8654: PPUSH
8655: CALL_OW 250
8659: PPUSH
8660: LD_VAR 0 2
8664: PPUSH
8665: CALL_OW 251
8669: PPUSH
8670: LD_INT 7
8672: PPUSH
8673: LD_INT 8
8675: NEG
8676: PPUSH
8677: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 87
// if tmp then
8690: LD_VAR 0 3
8694: IFFALSE 8708
// Say ( tmp , D4-RSci1-1 ) ;
8696: LD_VAR 0 3
8700: PPUSH
8701: LD_STRING D4-RSci1-1
8703: PPUSH
8704: CALL_OW 88
// if Gossudarov then
8708: LD_EXP 34
8712: IFFALSE 8738
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8714: LD_EXP 34
8718: PPUSH
8719: LD_STRING D4-Gos-1
8721: PPUSH
8722: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8726: LD_EXP 16
8730: PPUSH
8731: LD_STRING D4-JMM-1
8733: PPUSH
8734: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8738: LD_VAR 0 2
8742: PPUSH
8743: CALL_OW 250
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 251
8757: PPUSH
8758: LD_INT 7
8760: PPUSH
8761: CALL_OW 331
// DialogueOff ;
8765: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8769: LD_STRING M5
8771: PPUSH
8772: CALL_OW 337
// end ;
8776: PPOPN 3
8778: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8779: LD_EXP 6
8783: IFFALSE 9376
8785: GO 8787
8787: DISABLE
8788: LD_INT 0
8790: PPUSH
8791: PPUSH
8792: PPUSH
// begin PrepareBelkov ;
8793: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8797: LD_EXP 49
8801: PPUSH
8802: LD_INT 118
8804: PPUSH
8805: LD_INT 106
8807: PPUSH
8808: CALL_OW 111
// AddComHold ( Belkov ) ;
8812: LD_EXP 49
8816: PPUSH
8817: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8821: LD_INT 35
8823: PPUSH
8824: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8828: LD_EXP 49
8832: PPUSH
8833: LD_INT 118
8835: PPUSH
8836: LD_INT 106
8838: PPUSH
8839: CALL_OW 307
8843: IFFALSE 8821
// ChangeSideFog ( 4 , 7 ) ;
8845: LD_INT 4
8847: PPUSH
8848: LD_INT 7
8850: PPUSH
8851: CALL_OW 343
// if IsOk ( Belkov ) then
8855: LD_EXP 49
8859: PPUSH
8860: CALL_OW 302
8864: IFFALSE 8948
// begin InGameOn ;
8866: CALL_OW 8
// DialogueOn ;
8870: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8874: LD_EXP 49
8878: PPUSH
8879: LD_STRING D5-Bel-1
8881: PPUSH
8882: CALL_OW 94
// if Gossudarov then
8886: LD_EXP 34
8890: IFFALSE 8940
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8892: LD_EXP 34
8896: PPUSH
8897: LD_STRING D5-Gos-1
8899: PPUSH
8900: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8904: LD_EXP 16
8908: PPUSH
8909: LD_STRING D5-JMM-1
8911: PPUSH
8912: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8916: LD_EXP 34
8920: PPUSH
8921: LD_STRING D5-Gos-2
8923: PPUSH
8924: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8928: LD_EXP 16
8932: PPUSH
8933: LD_STRING D5-JMM-2
8935: PPUSH
8936: CALL_OW 88
// end ; DialogueOff ;
8940: CALL_OW 7
// InGameOff ;
8944: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8948: LD_STRING QSaveBelkov
8950: PPUSH
8951: CALL_OW 97
8955: PUSH
8956: LD_INT 1
8958: DOUBLE
8959: EQUAL
8960: IFTRUE 8964
8962: GO 9014
8964: POP
// begin DialogueOn ;
8965: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8969: LD_EXP 16
8973: PPUSH
8974: LD_STRING D5a-JMM-1
8976: PPUSH
8977: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8981: LD_EXP 49
8985: PPUSH
8986: LD_STRING D5a-Bel-1
8988: PPUSH
8989: CALL_OW 94
// DialogueOff ;
8993: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8997: LD_EXP 49
9001: PPUSH
9002: LD_INT 83
9004: PPUSH
9005: LD_INT 49
9007: PPUSH
9008: CALL_OW 111
// end ; 2 :
9012: GO 9047
9014: LD_INT 2
9016: DOUBLE
9017: EQUAL
9018: IFTRUE 9022
9020: GO 9046
9022: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9023: LD_EXP 16
9027: PPUSH
9028: LD_STRING D5a-JMM-2
9030: PPUSH
9031: CALL_OW 88
// ComHold ( Belkov ) ;
9035: LD_EXP 49
9039: PPUSH
9040: CALL_OW 140
// end ; end ;
9044: GO 9047
9046: POP
// time := 0 0$00 ;
9047: LD_ADDR_VAR 0 1
9051: PUSH
9052: LD_INT 0
9054: ST_TO_ADDR
// vehSpawned := false ;
9055: LD_ADDR_VAR 0 3
9059: PUSH
9060: LD_INT 0
9062: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9063: LD_INT 35
9065: PPUSH
9066: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9070: LD_VAR 0 1
9074: PUSH
9075: LD_INT 350
9077: PUSH
9078: LD_INT 175
9080: PUSH
9081: LD_INT 105
9083: PUSH
9084: LD_INT 70
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: LIST
9092: PUSH
9093: LD_OWVAR 67
9097: ARRAY
9098: GREATEREQUAL
9099: PUSH
9100: LD_VAR 0 3
9104: NOT
9105: AND
9106: IFFALSE 9196
// begin vehSpawned := true ;
9108: LD_ADDR_VAR 0 3
9112: PUSH
9113: LD_INT 1
9115: ST_TO_ADDR
// uc_side := 3 ;
9116: LD_ADDR_OWVAR 20
9120: PUSH
9121: LD_INT 3
9123: ST_TO_ADDR
// uc_nation := 3 ;
9124: LD_ADDR_OWVAR 21
9128: PUSH
9129: LD_INT 3
9131: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9132: LD_INT 22
9134: PPUSH
9135: LD_INT 3
9137: PPUSH
9138: LD_INT 3
9140: PPUSH
9141: LD_INT 43
9143: PPUSH
9144: LD_INT 100
9146: PPUSH
9147: CALL 19790 0 5
// veh := CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: CALL_OW 45
9160: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9161: LD_VAR 0 2
9165: PPUSH
9166: LD_INT 130
9168: PPUSH
9169: LD_INT 131
9171: PPUSH
9172: LD_INT 0
9174: PPUSH
9175: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9179: LD_VAR 0 2
9183: PPUSH
9184: LD_INT 100
9186: PPUSH
9187: LD_INT 82
9189: PPUSH
9190: CALL_OW 114
// end else
9194: GO 9210
// time := time + 0 0$1 ;
9196: LD_ADDR_VAR 0 1
9200: PUSH
9201: LD_VAR 0 1
9205: PUSH
9206: LD_INT 35
9208: PLUS
9209: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9210: LD_EXP 49
9214: PPUSH
9215: CALL_OW 301
9219: PUSH
9220: LD_EXP 49
9224: PPUSH
9225: CALL_OW 255
9229: PUSH
9230: LD_INT 4
9232: EQUAL
9233: AND
9234: PUSH
9235: LD_INT 22
9237: PUSH
9238: LD_INT 7
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 69
9249: PPUSH
9250: LD_EXP 49
9254: PPUSH
9255: CALL_OW 74
9259: PPUSH
9260: LD_EXP 49
9264: PPUSH
9265: CALL_OW 296
9269: PUSH
9270: LD_INT 10
9272: LESS
9273: OR
9274: IFFALSE 9063
// if IsDead ( Belkov ) then
9276: LD_EXP 49
9280: PPUSH
9281: CALL_OW 301
9285: IFFALSE 9310
// begin CenterNowOnUnits ( Belkov ) ;
9287: LD_EXP 49
9291: PPUSH
9292: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9296: LD_EXP 16
9300: PPUSH
9301: LD_STRING D5a-JMM-2a
9303: PPUSH
9304: CALL_OW 88
// exit ;
9308: GO 9376
// end ; if See ( 7 , Belkov ) then
9310: LD_INT 7
9312: PPUSH
9313: LD_EXP 49
9317: PPUSH
9318: CALL_OW 292
9322: IFFALSE 9336
// SetSide ( Belkov , 7 ) ;
9324: LD_EXP 49
9328: PPUSH
9329: LD_INT 7
9331: PPUSH
9332: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9336: LD_INT 35
9338: PPUSH
9339: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9343: LD_EXP 49
9347: PPUSH
9348: LD_INT 66
9350: PPUSH
9351: LD_INT 45
9353: PPUSH
9354: CALL_OW 297
9358: PUSH
9359: LD_INT 30
9361: LESS
9362: IFFALSE 9336
// Say ( Belkov , D6-Bel-1 ) ;
9364: LD_EXP 49
9368: PPUSH
9369: LD_STRING D6-Bel-1
9371: PPUSH
9372: CALL_OW 88
// end ;
9376: PPOPN 3
9378: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9379: LD_EXP 49
9383: PPUSH
9384: CALL_OW 302
9388: PUSH
9389: LD_EXP 49
9393: PPUSH
9394: CALL_OW 504
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: LD_INT 34
9404: PUSH
9405: LD_INT 47
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 34
9414: PUSH
9415: LD_INT 45
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: IN
9432: AND
9433: IFFALSE 9450
9435: GO 9437
9437: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9438: LD_EXP 49
9442: PPUSH
9443: LD_STRING D7-Bel-1
9445: PPUSH
9446: CALL_OW 88
9450: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9451: LD_INT 22
9453: PUSH
9454: LD_INT 7
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 101
9463: PUSH
9464: LD_INT 2
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PPUSH
9475: CALL_OW 69
9479: PUSH
9480: LD_EXP 8
9484: NOT
9485: AND
9486: PUSH
9487: LD_EXP 48
9491: PPUSH
9492: CALL_OW 305
9496: NOT
9497: AND
9498: IFFALSE 9968
9500: GO 9502
9502: DISABLE
9503: LD_INT 0
9505: PPUSH
// begin ar_base_spotted := true ;
9506: LD_ADDR_EXP 8
9510: PUSH
9511: LD_INT 1
9513: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9514: LD_ADDR_VAR 0 1
9518: PUSH
9519: LD_INT 22
9521: PUSH
9522: LD_INT 2
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: PUSH
9529: LD_INT 21
9531: PUSH
9532: LD_INT 3
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PPUSH
9543: CALL_OW 69
9547: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9548: LD_ADDR_VAR 0 1
9552: PUSH
9553: LD_VAR 0 1
9557: PPUSH
9558: LD_EXP 16
9562: PPUSH
9563: CALL_OW 74
9567: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9568: LD_INT 7
9570: PPUSH
9571: LD_INT 3
9573: PPUSH
9574: CALL_OW 332
// DialogueOn ;
9578: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9582: LD_VAR 0 1
9586: PPUSH
9587: CALL_OW 250
9591: PPUSH
9592: LD_VAR 0 1
9596: PPUSH
9597: CALL_OW 251
9601: PPUSH
9602: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9606: LD_ADDR_VAR 0 1
9610: PUSH
9611: LD_INT 22
9613: PUSH
9614: LD_INT 7
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: LD_INT 23
9623: PUSH
9624: LD_INT 1
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: PUSH
9631: LD_INT 26
9633: PUSH
9634: LD_INT 1
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: PPUSH
9646: CALL_OW 69
9650: PUSH
9651: LD_EXP 16
9655: PUSH
9656: LD_EXP 20
9660: PUSH
9661: LD_EXP 21
9665: PUSH
9666: LD_EXP 28
9670: PUSH
9671: LD_EXP 17
9675: PUSH
9676: LD_EXP 26
9680: PUSH
9681: LD_EXP 22
9685: PUSH
9686: LD_EXP 24
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: DIFF
9701: ST_TO_ADDR
// if not tmp then
9702: LD_VAR 0 1
9706: NOT
9707: IFFALSE 9781
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9709: LD_ADDR_VAR 0 1
9713: PUSH
9714: LD_INT 22
9716: PUSH
9717: LD_INT 7
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 23
9726: PUSH
9727: LD_INT 1
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: LD_INT 26
9736: PUSH
9737: LD_INT 2
9739: PUSH
9740: EMPTY
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: LIST
9748: PPUSH
9749: CALL_OW 69
9753: PUSH
9754: LD_EXP 31
9758: PUSH
9759: LD_EXP 18
9763: PUSH
9764: LD_EXP 29
9768: PUSH
9769: LD_EXP 30
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: LIST
9778: LIST
9779: DIFF
9780: ST_TO_ADDR
// if tmp then
9781: LD_VAR 0 1
9785: IFFALSE 9856
// case GetSex ( tmp [ 1 ] ) of sex_male :
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: CALL_OW 258
9800: PUSH
9801: LD_INT 1
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9828
9809: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9810: LD_VAR 0 1
9814: PUSH
9815: LD_INT 1
9817: ARRAY
9818: PPUSH
9819: LD_STRING D9-Sol1-1
9821: PPUSH
9822: CALL_OW 88
9826: GO 9856
9828: LD_INT 2
9830: DOUBLE
9831: EQUAL
9832: IFTRUE 9836
9834: GO 9855
9836: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 1
9844: ARRAY
9845: PPUSH
9846: LD_STRING D9-FSol1-1
9848: PPUSH
9849: CALL_OW 88
9853: GO 9856
9855: POP
// if Frank then
9856: LD_EXP 28
9860: IFFALSE 9964
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9862: LD_EXP 58
9866: PPUSH
9867: CALL_OW 250
9871: PPUSH
9872: LD_EXP 58
9876: PPUSH
9877: CALL_OW 251
9881: PPUSH
9882: LD_INT 7
9884: PPUSH
9885: LD_INT 8
9887: PPUSH
9888: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9892: LD_EXP 58
9896: PPUSH
9897: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9901: LD_EXP 28
9905: PPUSH
9906: LD_STRING D9-Frank-1
9908: PPUSH
9909: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9913: LD_EXP 16
9917: PPUSH
9918: LD_STRING D9-JMM-1
9920: PPUSH
9921: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9925: LD_EXP 28
9929: PPUSH
9930: LD_STRING D9-Frank-2
9932: PPUSH
9933: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9937: LD_EXP 58
9941: PPUSH
9942: CALL_OW 250
9946: PPUSH
9947: LD_EXP 58
9951: PPUSH
9952: CALL_OW 251
9956: PPUSH
9957: LD_INT 7
9959: PPUSH
9960: CALL_OW 331
// end ; DialogueOff ;
9964: CALL_OW 7
// end ;
9968: PPOPN 1
9970: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9971: LD_EXP 7
9975: PUSH
9976: LD_OWVAR 1
9980: PUSH
9981: LD_INT 42000
9983: GREATEREQUAL
9984: OR
9985: IFFALSE 11012
9987: GO 9989
9989: DISABLE
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
// begin selected_option := 1 ;
9994: LD_ADDR_VAR 0 2
9998: PUSH
9999: LD_INT 1
10001: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10002: LD_INT 10500
10004: PPUSH
10005: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10009: LD_INT 35
10011: PPUSH
10012: CALL_OW 67
// until not ru_attackers ;
10016: LD_EXP 54
10020: NOT
10021: IFFALSE 10009
// PrepareBurlak ;
10023: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10027: LD_INT 70
10029: PPUSH
10030: CALL_OW 67
// until not HasTask ( Burlak ) ;
10034: LD_EXP 48
10038: PPUSH
10039: CALL_OW 314
10043: NOT
10044: IFFALSE 10027
// InGameOn ;
10046: CALL_OW 8
// DialogueOn ;
10050: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10054: LD_EXP 51
10058: PPUSH
10059: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10063: LD_EXP 48
10067: PPUSH
10068: LD_STRING D10-Bur-1
10070: PPUSH
10071: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10075: LD_EXP 49
10079: PUSH
10080: LD_EXP 49
10084: PPUSH
10085: CALL_OW 255
10089: PUSH
10090: LD_INT 7
10092: EQUAL
10093: AND
10094: IFFALSE 10108
// Say ( Belkov , D10-Bel-1 ) ;
10096: LD_EXP 49
10100: PPUSH
10101: LD_STRING D10-Bel-1
10103: PPUSH
10104: CALL_OW 88
// if Gossudarov then
10108: LD_EXP 34
10112: IFFALSE 10126
// Say ( Gossudarov , D10-Gos-1 ) ;
10114: LD_EXP 34
10118: PPUSH
10119: LD_STRING D10-Gos-1
10121: PPUSH
10122: CALL_OW 88
// if Kirilenkova then
10126: LD_EXP 35
10130: IFFALSE 10144
// Say ( Kirilenkova , D10-Kir-1 ) ;
10132: LD_EXP 35
10136: PPUSH
10137: LD_STRING D10-Kir-1
10139: PPUSH
10140: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10144: CALL 13481 0 0
10148: PPUSH
10149: LD_STRING D10-RSol1-1
10151: PPUSH
10152: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10156: LD_EXP 48
10160: PPUSH
10161: LD_STRING D10-Bur-2
10163: PPUSH
10164: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10168: LD_EXP 16
10172: PPUSH
10173: LD_STRING D10-JMM-2
10175: PPUSH
10176: CALL_OW 88
// if Kirilenkova then
10180: LD_EXP 35
10184: IFFALSE 10200
// Say ( Kirilenkova , D10-Kir-2 ) else
10186: LD_EXP 35
10190: PPUSH
10191: LD_STRING D10-Kir-2
10193: PPUSH
10194: CALL_OW 88
10198: GO 10212
// Say ( SolRu , D10-RSol1-2 ) ;
10200: CALL 13481 0 0
10204: PPUSH
10205: LD_STRING D10-RSol1-2
10207: PPUSH
10208: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10212: LD_EXP 16
10216: PPUSH
10217: LD_STRING D10-JMM-3
10219: PPUSH
10220: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10224: LD_EXP 48
10228: PPUSH
10229: LD_STRING D10-Bur-3
10231: PPUSH
10232: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10236: LD_EXP 16
10240: PPUSH
10241: LD_STRING D10-JMM-4
10243: PPUSH
10244: CALL_OW 88
// DialogueOff ;
10248: CALL_OW 7
// InGameOff ;
10252: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10256: LD_STRING M2
10258: PPUSH
10259: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10263: LD_INT 35
10265: PPUSH
10266: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10270: LD_INT 22
10272: PUSH
10273: LD_INT 7
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 91
10282: PUSH
10283: LD_EXP 48
10287: PUSH
10288: LD_INT 8
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: IFFALSE 10263
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10306: LD_ADDR_VAR 0 1
10310: PUSH
10311: LD_INT 22
10313: PUSH
10314: LD_INT 4
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 69
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 7 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 7
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// ChangeMissionObjectives ( M3 ) ;
10345: LD_STRING M3
10347: PPUSH
10348: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10352: LD_INT 35
10354: PPUSH
10355: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10359: LD_EXP 16
10363: PPUSH
10364: LD_EXP 48
10368: PPUSH
10369: CALL_OW 296
10373: PUSH
10374: LD_INT 8
10376: LESS
10377: IFFALSE 10352
// ComTurnUnit ( JMM , Burlak ) ;
10379: LD_EXP 16
10383: PPUSH
10384: LD_EXP 48
10388: PPUSH
10389: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10393: LD_EXP 48
10397: PPUSH
10398: LD_EXP 16
10402: PPUSH
10403: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10407: LD_INT 10
10409: PPUSH
10410: CALL_OW 67
// DialogueOn ;
10414: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10418: LD_EXP 16
10422: PPUSH
10423: LD_STRING D11-JMM-1
10425: PPUSH
10426: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10430: LD_EXP 48
10434: PPUSH
10435: LD_STRING D11-Bur-1
10437: PPUSH
10438: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10442: LD_EXP 16
10446: PPUSH
10447: LD_STRING D11-JMM-2
10449: PPUSH
10450: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10454: LD_EXP 48
10458: PPUSH
10459: LD_STRING D11-Bur-2
10461: PPUSH
10462: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10466: LD_EXP 16
10470: PPUSH
10471: LD_STRING D11-JMM-3
10473: PPUSH
10474: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10478: LD_EXP 48
10482: PPUSH
10483: LD_STRING D11-Bur-3
10485: PPUSH
10486: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10490: LD_EXP 16
10494: PPUSH
10495: LD_STRING D11-JMM-4
10497: PPUSH
10498: CALL_OW 88
// if ar_base_spotted then
10502: LD_EXP 8
10506: IFFALSE 10522
// Say ( Burlak , D12-Bur-1 ) else
10508: LD_EXP 48
10512: PPUSH
10513: LD_STRING D12-Bur-1
10515: PPUSH
10516: CALL_OW 88
10520: GO 10561
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10522: LD_INT 7
10524: PPUSH
10525: LD_INT 3
10527: PPUSH
10528: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10532: LD_INT 127
10534: PPUSH
10535: LD_INT 45
10537: PPUSH
10538: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10542: LD_EXP 48
10546: PPUSH
10547: LD_STRING D12-Bur-1a
10549: PPUSH
10550: CALL_OW 88
// dwait ( 0 0$2 ) ;
10554: LD_INT 70
10556: PPUSH
10557: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10561: LD_EXP 48
10565: PPUSH
10566: LD_STRING D12-Bur-1b
10568: PPUSH
10569: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10573: LD_EXP 16
10577: PPUSH
10578: LD_STRING D12-JMM-1
10580: PPUSH
10581: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10585: LD_EXP 48
10589: PPUSH
10590: LD_STRING D12-Bur-2
10592: PPUSH
10593: CALL_OW 88
// if Roth then
10597: LD_EXP 17
10601: IFFALSE 10617
// Say ( Roth , D12-Roth-2 ) else
10603: LD_EXP 17
10607: PPUSH
10608: LD_STRING D12-Roth-2
10610: PPUSH
10611: CALL_OW 88
10615: GO 10629
// Say ( SciRu , D12-RSci1-2 ) ;
10617: CALL 13334 0 0
10621: PPUSH
10622: LD_STRING D12-RSci1-2
10624: PPUSH
10625: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10629: LD_EXP 16
10633: PPUSH
10634: LD_STRING D12-JMM-2
10636: PPUSH
10637: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10641: LD_EXP 48
10645: PPUSH
10646: LD_STRING D12-Bur-3
10648: PPUSH
10649: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10653: LD_EXP 16
10657: PPUSH
10658: LD_STRING D12-JMM-3
10660: PPUSH
10661: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10665: LD_EXP 48
10669: PPUSH
10670: LD_STRING D12-Bur-4
10672: PPUSH
10673: CALL_OW 88
// case Query ( QBase ) of 1 :
10677: LD_STRING QBase
10679: PPUSH
10680: CALL_OW 97
10684: PUSH
10685: LD_INT 1
10687: DOUBLE
10688: EQUAL
10689: IFTRUE 10693
10691: GO 10811
10693: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10694: LD_EXP 16
10698: PPUSH
10699: LD_STRING D13a-JMM-1
10701: PPUSH
10702: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10706: LD_EXP 48
10710: PPUSH
10711: LD_STRING D13a-Bur-1
10713: PPUSH
10714: CALL_OW 88
// if Roth then
10718: LD_EXP 17
10722: IFFALSE 10738
// Say ( Roth , D13a-Roth-1 ) else
10724: LD_EXP 17
10728: PPUSH
10729: LD_STRING D13a-Roth-1
10731: PPUSH
10732: CALL_OW 88
10736: GO 10750
// Say ( SciRu , D13a-RSci1-1 ) ;
10738: CALL 13334 0 0
10742: PPUSH
10743: LD_STRING D13a-RSci1-1
10745: PPUSH
10746: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10750: LD_EXP 16
10754: PPUSH
10755: LD_STRING D13a-JMM-2
10757: PPUSH
10758: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10762: LD_STRING QBaseAgain
10764: PPUSH
10765: CALL_OW 97
10769: PUSH
10770: LD_INT 1
10772: DOUBLE
10773: EQUAL
10774: IFTRUE 10778
10776: GO 10789
10778: POP
// selected_option := 2 ; 2 :
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_INT 2
10786: ST_TO_ADDR
10787: GO 10809
10789: LD_INT 2
10791: DOUBLE
10792: EQUAL
10793: IFTRUE 10797
10795: GO 10808
10797: POP
// selected_option := 3 ; end ;
10798: LD_ADDR_VAR 0 2
10802: PUSH
10803: LD_INT 3
10805: ST_TO_ADDR
10806: GO 10809
10808: POP
// end ; 2 :
10809: GO 10850
10811: LD_INT 2
10813: DOUBLE
10814: EQUAL
10815: IFTRUE 10819
10817: GO 10830
10819: POP
// selected_option := 2 ; 3 :
10820: LD_ADDR_VAR 0 2
10824: PUSH
10825: LD_INT 2
10827: ST_TO_ADDR
10828: GO 10850
10830: LD_INT 3
10832: DOUBLE
10833: EQUAL
10834: IFTRUE 10838
10836: GO 10849
10838: POP
// selected_option := 3 ; end ;
10839: LD_ADDR_VAR 0 2
10843: PUSH
10844: LD_INT 3
10846: ST_TO_ADDR
10847: GO 10850
10849: POP
// if selected_option = 2 then
10850: LD_VAR 0 2
10854: PUSH
10855: LD_INT 2
10857: EQUAL
10858: IFFALSE 10952
// begin Say ( JMM , D13b-JMM-1 ) ;
10860: LD_EXP 16
10864: PPUSH
10865: LD_STRING D13b-JMM-1
10867: PPUSH
10868: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10872: LD_EXP 48
10876: PPUSH
10877: LD_STRING D13b-Bur-1
10879: PPUSH
10880: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10884: LD_EXP 16
10888: PPUSH
10889: LD_STRING D13b-JMM-2
10891: PPUSH
10892: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10896: LD_EXP 57
10900: PPUSH
10901: LD_STRING D13b-Abd-2
10903: PPUSH
10904: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10908: LD_EXP 16
10912: PPUSH
10913: LD_STRING D13b-JMM-3
10915: PPUSH
10916: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10920: LD_EXP 57
10924: PPUSH
10925: LD_STRING D13b-Abd-3
10927: PPUSH
10928: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10932: LD_EXP 16
10936: PPUSH
10937: LD_STRING D13b-JMM-4
10939: PPUSH
10940: CALL_OW 88
// ar_active_attack := true ;
10944: LD_ADDR_EXP 9
10948: PUSH
10949: LD_INT 1
10951: ST_TO_ADDR
// end ; if selected_option = 3 then
10952: LD_VAR 0 2
10956: PUSH
10957: LD_INT 3
10959: EQUAL
10960: IFFALSE 10986
// begin Say ( JMM , D13c-JMM-1 ) ;
10962: LD_EXP 16
10966: PPUSH
10967: LD_STRING D13c-JMM-1
10969: PPUSH
10970: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10974: LD_EXP 48
10978: PPUSH
10979: LD_STRING D13c-Bur-1
10981: PPUSH
10982: CALL_OW 88
// end ; DialogueOff ;
10986: CALL_OW 7
// if not ar_active_attack then
10990: LD_EXP 9
10994: NOT
10995: IFFALSE 11012
// begin wait ( 6 6$00 ) ;
10997: LD_INT 12600
10999: PPUSH
11000: CALL_OW 67
// ar_active_attack := true ;
11004: LD_ADDR_EXP 9
11008: PUSH
11009: LD_INT 1
11011: ST_TO_ADDR
// end ; end ;
11012: PPOPN 2
11014: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11015: LD_EXP 48
11019: PPUSH
11020: CALL_OW 305
11024: PUSH
11025: LD_EXP 48
11029: PPUSH
11030: CALL_OW 255
11034: PUSH
11035: LD_INT 7
11037: EQUAL
11038: AND
11039: IFFALSE 11235
11041: GO 11043
11043: DISABLE
11044: LD_INT 0
11046: PPUSH
// begin wait ( 4 4$40 ) ;
11047: LD_INT 9800
11049: PPUSH
11050: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// until not ru_attackers ;
11061: LD_EXP 54
11065: NOT
11066: IFFALSE 11054
// PrepareGnyevko ;
11068: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11072: LD_EXP 50
11076: PPUSH
11077: LD_INT 124
11079: PPUSH
11080: LD_INT 118
11082: PPUSH
11083: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11087: LD_EXP 50
11091: PPUSH
11092: CALL_OW 200
// time := 0 0$00 ;
11096: LD_ADDR_VAR 0 1
11100: PUSH
11101: LD_INT 0
11103: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11104: LD_INT 35
11106: PPUSH
11107: CALL_OW 67
// time := time + 0 0$1 ;
11111: LD_ADDR_VAR 0 1
11115: PUSH
11116: LD_VAR 0 1
11120: PUSH
11121: LD_INT 35
11123: PLUS
11124: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11125: LD_EXP 50
11129: PPUSH
11130: LD_INT 124
11132: PPUSH
11133: LD_INT 118
11135: PPUSH
11136: CALL_OW 307
11140: PUSH
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 1050
11148: GREATEREQUAL
11149: OR
11150: IFFALSE 11104
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11152: LD_EXP 50
11156: PPUSH
11157: LD_STRING DBelkov-Gny-1
11159: PPUSH
11160: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11164: LD_EXP 48
11168: PPUSH
11169: LD_STRING DBelkov-Bur-1a
11171: PPUSH
11172: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11176: LD_INT 35
11178: PPUSH
11179: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11183: LD_EXP 50
11187: PPUSH
11188: LD_INT 22
11190: PUSH
11191: LD_INT 7
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PPUSH
11198: CALL_OW 69
11202: PPUSH
11203: LD_EXP 50
11207: PPUSH
11208: CALL_OW 74
11212: PPUSH
11213: CALL_OW 296
11217: PUSH
11218: LD_INT 8
11220: LESS
11221: IFFALSE 11176
// SetSide ( Gnyevko , 7 ) ;
11223: LD_EXP 50
11227: PPUSH
11228: LD_INT 7
11230: PPUSH
11231: CALL_OW 235
// end ;
11235: PPOPN 1
11237: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11238: LD_EXP 48
11242: PPUSH
11243: CALL_OW 255
11247: PUSH
11248: LD_INT 7
11250: EQUAL
11251: IFFALSE 11261
11253: GO 11255
11255: DISABLE
// begin enable ;
11256: ENABLE
// PrepareAmericanAttack ;
11257: CALL 6903 0 0
// end ;
11261: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11262: LD_INT 22
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PPUSH
11272: CALL_OW 69
11276: IFFALSE 11460
11278: GO 11280
11280: DISABLE
11281: LD_INT 0
11283: PPUSH
11284: PPUSH
// begin while true do
11285: LD_INT 1
11287: IFFALSE 11344
// begin wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11296: LD_ADDR_VAR 0 2
11300: PUSH
11301: LD_INT 22
11303: PUSH
11304: LD_INT 1
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: PPUSH
11311: CALL_OW 69
11315: PPUSH
11316: LD_EXP 16
11320: PPUSH
11321: CALL_OW 74
11325: ST_TO_ADDR
// if See ( 7 , tmp ) then
11326: LD_INT 7
11328: PPUSH
11329: LD_VAR 0 2
11333: PPUSH
11334: CALL_OW 292
11338: IFFALSE 11342
// break ;
11340: GO 11344
// end ;
11342: GO 11285
// DialogueOn ;
11344: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11348: LD_VAR 0 2
11352: PPUSH
11353: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11357: LD_VAR 0 2
11361: PPUSH
11362: CALL_OW 250
11366: PPUSH
11367: LD_VAR 0 2
11371: PPUSH
11372: CALL_OW 251
11376: PPUSH
11377: LD_INT 7
11379: PPUSH
11380: LD_INT 8
11382: PPUSH
11383: CALL_OW 330
// if Denis then
11387: LD_EXP 22
11391: IFFALSE 11405
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11393: LD_EXP 22
11397: PPUSH
11398: LD_STRING DAmerAttack-Pet-1
11400: PPUSH
11401: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11405: LD_EXP 16
11409: PPUSH
11410: LD_STRING DAmerAttack-JMM-1
11412: PPUSH
11413: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11417: LD_EXP 48
11421: PPUSH
11422: LD_STRING DStop-Bur-1
11424: PPUSH
11425: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11429: LD_VAR 0 2
11433: PPUSH
11434: CALL_OW 250
11438: PPUSH
11439: LD_VAR 0 2
11443: PPUSH
11444: CALL_OW 251
11448: PPUSH
11449: LD_INT 7
11451: PPUSH
11452: CALL_OW 331
// DialogueOff ;
11456: CALL_OW 7
// end ;
11460: PPOPN 2
11462: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11463: LD_INT 22
11465: PUSH
11466: LD_INT 3
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 21
11475: PUSH
11476: LD_INT 1
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: PPUSH
11487: CALL_OW 69
11491: PUSH
11492: LD_INT 0
11494: EQUAL
11495: IFFALSE 11537
11497: GO 11499
11499: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11500: LD_STRING M5a
11502: PPUSH
11503: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11507: LD_EXP 16
11511: PPUSH
11512: LD_STRING D8-JMM-1
11514: PPUSH
11515: CALL_OW 88
// if Gossudarov then
11519: LD_EXP 34
11523: IFFALSE 11537
// Say ( Gossudarov , D8-Gos-1 ) ;
11525: LD_EXP 34
11529: PPUSH
11530: LD_STRING D8-Gos-1
11532: PPUSH
11533: CALL_OW 88
// end ;
11537: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11538: LD_INT 22
11540: PUSH
11541: LD_INT 2
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 21
11550: PUSH
11551: LD_INT 1
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PPUSH
11562: CALL_OW 69
11566: PUSH
11567: LD_INT 0
11569: EQUAL
11570: IFFALSE 11620
11572: GO 11574
11574: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11575: LD_STRING M4c
11577: PPUSH
11578: CALL_OW 337
// if Roth then
11582: LD_EXP 17
11586: IFFALSE 11602
// Say ( Roth , DStop-Roth-1 ) else
11588: LD_EXP 17
11592: PPUSH
11593: LD_STRING DStop-Roth-1
11595: PPUSH
11596: CALL_OW 88
11600: GO 11620
// if Gossudarov then
11602: LD_EXP 34
11606: IFFALSE 11620
// Say ( Gossudarov , D8-Gos-1a ) ;
11608: LD_EXP 34
11612: PPUSH
11613: LD_STRING D8-Gos-1a
11615: PPUSH
11616: CALL_OW 88
// end ;
11620: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11621: LD_INT 7
11623: PPUSH
11624: LD_INT 1
11626: PPUSH
11627: LD_INT 1
11629: PPUSH
11630: CALL 15013 0 3
11634: PUSH
11635: LD_INT 0
11637: EQUAL
11638: PUSH
11639: LD_INT 7
11641: PPUSH
11642: LD_INT 3
11644: PPUSH
11645: LD_INT 1
11647: PPUSH
11648: CALL 15013 0 3
11652: PUSH
11653: LD_INT 0
11655: EQUAL
11656: AND
11657: IFFALSE 11669
11659: GO 11661
11661: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11662: LD_STRING M1a
11664: PPUSH
11665: CALL_OW 337
// end ;
11669: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11670: LD_INT 22
11672: PUSH
11673: LD_INT 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: LD_INT 21
11682: PUSH
11683: LD_INT 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PPUSH
11694: CALL_OW 69
11698: PUSH
11699: LD_INT 0
11701: EQUAL
11702: PUSH
11703: LD_INT 22
11705: PUSH
11706: LD_INT 3
11708: PUSH
11709: EMPTY
11710: LIST
11711: LIST
11712: PUSH
11713: LD_INT 21
11715: PUSH
11716: LD_INT 1
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 69
11731: PUSH
11732: LD_INT 0
11734: EQUAL
11735: AND
11736: PUSH
11737: LD_INT 22
11739: PUSH
11740: LD_INT 1
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 69
11751: PUSH
11752: LD_INT 0
11754: EQUAL
11755: AND
11756: PUSH
11757: LD_INT 7
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 1
11765: PPUSH
11766: CALL 15013 0 3
11770: PUSH
11771: LD_INT 0
11773: EQUAL
11774: AND
11775: PUSH
11776: LD_INT 7
11778: PPUSH
11779: LD_INT 3
11781: PPUSH
11782: LD_INT 1
11784: PPUSH
11785: CALL 15013 0 3
11789: PUSH
11790: LD_INT 0
11792: EQUAL
11793: AND
11794: PUSH
11795: LD_EXP 48
11799: PPUSH
11800: CALL_OW 255
11804: PUSH
11805: LD_INT 7
11807: EQUAL
11808: AND
11809: PUSH
11810: LD_EXP 48
11814: PPUSH
11815: CALL_OW 302
11819: AND
11820: IFFALSE 13331
11822: GO 11824
11824: DISABLE
11825: LD_INT 0
11827: PPUSH
11828: PPUSH
11829: PPUSH
11830: PPUSH
11831: PPUSH
11832: PPUSH
// begin m1 := false ;
11833: LD_ADDR_VAR 0 4
11837: PUSH
11838: LD_INT 0
11840: ST_TO_ADDR
// m2 := false ;
11841: LD_ADDR_VAR 0 5
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// m3 := false ;
11849: LD_ADDR_VAR 0 6
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// if tick < 40 40$00 then
11857: LD_OWVAR 1
11861: PUSH
11862: LD_INT 84000
11864: LESS
11865: IFFALSE 11874
// SetAchievement ( ACH_ASPEED_17 ) ;
11867: LD_STRING ACH_ASPEED_17
11869: PPUSH
11870: CALL_OW 543
// wait ( 0 0$5 ) ;
11874: LD_INT 175
11876: PPUSH
11877: CALL_OW 67
// if not masha_killed then
11881: LD_EXP 10
11885: NOT
11886: IFFALSE 11908
// begin m1 := true ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11896: LD_STRING Masha
11898: PPUSH
11899: LD_INT 1
11901: PPUSH
11902: CALL_OW 101
// end else
11906: GO 11919
// AddMedal ( Masha , - 1 ) ;
11908: LD_STRING Masha
11910: PPUSH
11911: LD_INT 1
11913: NEG
11914: PPUSH
11915: CALL_OW 101
// if abdul_escaped then
11919: LD_EXP 13
11923: IFFALSE 11938
// AddMedal ( Abdul , - 1 ) else
11925: LD_STRING Abdul
11927: PPUSH
11928: LD_INT 1
11930: NEG
11931: PPUSH
11932: CALL_OW 101
11936: GO 11956
// begin m2 := true ;
11938: LD_ADDR_VAR 0 5
11942: PUSH
11943: LD_INT 1
11945: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11946: LD_STRING Abdul
11948: PPUSH
11949: LD_INT 1
11951: PPUSH
11952: CALL_OW 101
// end ; if loss_counter = 0 then
11956: LD_EXP 14
11960: PUSH
11961: LD_INT 0
11963: EQUAL
11964: IFFALSE 11986
// begin m3 := true ;
11966: LD_ADDR_VAR 0 6
11970: PUSH
11971: LD_INT 1
11973: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11974: LD_STRING People
11976: PPUSH
11977: LD_INT 2
11979: PPUSH
11980: CALL_OW 101
// end else
11984: GO 12048
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11986: LD_EXP 14
11990: PUSH
11991: LD_INT 3
11993: PUSH
11994: LD_INT 2
11996: PUSH
11997: LD_INT 2
11999: PUSH
12000: LD_INT 1
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PUSH
12009: LD_OWVAR 67
12013: ARRAY
12014: LESSEQUAL
12015: IFFALSE 12037
// begin AddMedal ( People , 1 ) ;
12017: LD_STRING People
12019: PPUSH
12020: LD_INT 1
12022: PPUSH
12023: CALL_OW 101
// m3 := true ;
12027: LD_ADDR_VAR 0 6
12031: PUSH
12032: LD_INT 1
12034: ST_TO_ADDR
// end else
12035: GO 12048
// AddMedal ( People , - 1 ) ;
12037: LD_STRING People
12039: PPUSH
12040: LD_INT 1
12042: NEG
12043: PPUSH
12044: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12048: LD_OWVAR 67
12052: PUSH
12053: LD_INT 3
12055: GREATEREQUAL
12056: PUSH
12057: LD_VAR 0 4
12061: AND
12062: PUSH
12063: LD_VAR 0 5
12067: AND
12068: PUSH
12069: LD_VAR 0 6
12073: AND
12074: IFFALSE 12086
// SetAchievementEX ( ACH_AMER , 17 ) ;
12076: LD_STRING ACH_AMER
12078: PPUSH
12079: LD_INT 17
12081: PPUSH
12082: CALL_OW 564
// GiveMedals ( MAIN ) ;
12086: LD_STRING MAIN
12088: PPUSH
12089: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12093: LD_ADDR_VAR 0 2
12097: PUSH
12098: LD_INT 22
12100: PUSH
12101: LD_INT 7
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: PUSH
12108: LD_INT 50
12110: PUSH
12111: EMPTY
12112: LIST
12113: PUSH
12114: LD_INT 2
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 1
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: LD_INT 25
12129: PUSH
12130: LD_INT 2
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 25
12139: PUSH
12140: LD_INT 3
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 25
12149: PUSH
12150: LD_INT 4
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: LD_INT 25
12159: PUSH
12160: LD_INT 5
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: PUSH
12167: LD_INT 25
12169: PUSH
12170: LD_INT 8
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 25
12179: PUSH
12180: LD_INT 9
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: LIST
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12207: LD_VAR 0 2
12211: PPUSH
12212: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12216: LD_ADDR_VAR 0 3
12220: PUSH
12221: LD_EXP 16
12225: PUSH
12226: LD_EXP 17
12230: PUSH
12231: LD_EXP 18
12235: PUSH
12236: LD_EXP 19
12240: PUSH
12241: LD_EXP 20
12245: PUSH
12246: LD_EXP 21
12250: PUSH
12251: LD_EXP 22
12255: PUSH
12256: LD_EXP 23
12260: PUSH
12261: LD_EXP 24
12265: PUSH
12266: LD_EXP 25
12270: PUSH
12271: LD_EXP 26
12275: PUSH
12276: LD_EXP 27
12280: PUSH
12281: LD_EXP 28
12285: PUSH
12286: LD_EXP 29
12290: PUSH
12291: LD_EXP 30
12295: PUSH
12296: LD_EXP 31
12300: PUSH
12301: LD_EXP 32
12305: PUSH
12306: LD_EXP 34
12310: PUSH
12311: LD_EXP 35
12315: PUSH
12316: LD_EXP 36
12320: PUSH
12321: LD_EXP 38
12325: PUSH
12326: LD_EXP 39
12330: PUSH
12331: LD_EXP 40
12335: PUSH
12336: LD_EXP 41
12340: PUSH
12341: LD_EXP 42
12345: PUSH
12346: LD_EXP 43
12350: PUSH
12351: LD_EXP 44
12355: PUSH
12356: LD_EXP 45
12360: PUSH
12361: LD_EXP 46
12365: PUSH
12366: LD_EXP 47
12370: PUSH
12371: LD_EXP 48
12375: PUSH
12376: LD_EXP 49
12380: PUSH
12381: LD_EXP 50
12385: PUSH
12386: LD_EXP 33
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: LIST
12426: ST_TO_ADDR
// if tmp diff tmp2 then
12427: LD_VAR 0 2
12431: PUSH
12432: LD_VAR 0 3
12436: DIFF
12437: IFFALSE 12457
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12439: LD_VAR 0 2
12443: PUSH
12444: LD_VAR 0 3
12448: DIFF
12449: PPUSH
12450: LD_STRING 13a_others
12452: PPUSH
12453: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12457: LD_EXP 16
12461: PPUSH
12462: LD_STRING 13a_JMM
12464: PPUSH
12465: CALL_OW 38
// if IsOk ( Mike ) then
12469: LD_EXP 33
12473: PPUSH
12474: CALL_OW 302
12478: IFFALSE 12492
// SaveCharacters ( Mike , 13a_Mike ) ;
12480: LD_EXP 33
12484: PPUSH
12485: LD_STRING 13a_Mike
12487: PPUSH
12488: CALL_OW 38
// if Titov then
12492: LD_EXP 36
12496: IFFALSE 12510
// SaveCharacters ( Titov , 13a_Titov ) ;
12498: LD_EXP 36
12502: PPUSH
12503: LD_STRING 13a_Titov
12505: PPUSH
12506: CALL_OW 38
// if Dolgov then
12510: LD_EXP 38
12514: IFFALSE 12528
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12516: LD_EXP 38
12520: PPUSH
12521: LD_STRING 13a_Dolgov
12523: PPUSH
12524: CALL_OW 38
// if Petrosyan then
12528: LD_EXP 39
12532: IFFALSE 12546
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12534: LD_EXP 39
12538: PPUSH
12539: LD_STRING 13a_Petrosyan
12541: PPUSH
12542: CALL_OW 38
// if Scholtze then
12546: LD_EXP 40
12550: IFFALSE 12564
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12552: LD_EXP 40
12556: PPUSH
12557: LD_STRING 13a_Scholtze
12559: PPUSH
12560: CALL_OW 38
// if Oblukov then
12564: LD_EXP 41
12568: IFFALSE 12582
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12570: LD_EXP 41
12574: PPUSH
12575: LD_STRING 13a_Oblukov
12577: PPUSH
12578: CALL_OW 38
// if Kapitsova then
12582: LD_EXP 42
12586: IFFALSE 12600
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12588: LD_EXP 42
12592: PPUSH
12593: LD_STRING 13a_Kapitsova
12595: PPUSH
12596: CALL_OW 38
// if Lipshchin then
12600: LD_EXP 43
12604: IFFALSE 12618
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12606: LD_EXP 43
12610: PPUSH
12611: LD_STRING 13a_Lipshchin
12613: PPUSH
12614: CALL_OW 38
// if Petrovova then
12618: LD_EXP 44
12622: IFFALSE 12636
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12624: LD_EXP 44
12628: PPUSH
12629: LD_STRING 13a_Petrovova
12631: PPUSH
12632: CALL_OW 38
// if Kovalyuk then
12636: LD_EXP 45
12640: IFFALSE 12654
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12642: LD_EXP 45
12646: PPUSH
12647: LD_STRING 13a_Kovalyuk
12649: PPUSH
12650: CALL_OW 38
// if Kuzmov then
12654: LD_EXP 46
12658: IFFALSE 12672
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12660: LD_EXP 46
12664: PPUSH
12665: LD_STRING 13a_Kuzmov
12667: PPUSH
12668: CALL_OW 38
// if Karamazov then
12672: LD_EXP 47
12676: IFFALSE 12690
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12678: LD_EXP 47
12682: PPUSH
12683: LD_STRING 13a_Karamazov
12685: PPUSH
12686: CALL_OW 38
// if Burlak then
12690: LD_EXP 48
12694: IFFALSE 12708
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12696: LD_EXP 48
12700: PPUSH
12701: LD_STRING 13a_Burlak
12703: PPUSH
12704: CALL_OW 38
// if Belkov then
12708: LD_EXP 49
12712: IFFALSE 12726
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12714: LD_EXP 49
12718: PPUSH
12719: LD_STRING 13a_Belkov
12721: PPUSH
12722: CALL_OW 38
// if Gnyevko then
12726: LD_EXP 50
12730: IFFALSE 12744
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12732: LD_EXP 50
12736: PPUSH
12737: LD_STRING 13a_Gnyevko
12739: PPUSH
12740: CALL_OW 38
// if Lisa then
12744: LD_EXP 18
12748: IFFALSE 12762
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12750: LD_EXP 18
12754: PPUSH
12755: LD_STRING 13a_Lisa
12757: PPUSH
12758: CALL_OW 38
// if Donaldson then
12762: LD_EXP 19
12766: IFFALSE 12780
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12768: LD_EXP 19
12772: PPUSH
12773: LD_STRING 13a_Donaldson
12775: PPUSH
12776: CALL_OW 38
// if Bobby then
12780: LD_EXP 20
12784: IFFALSE 12798
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12786: LD_EXP 20
12790: PPUSH
12791: LD_STRING 13a_Bobby
12793: PPUSH
12794: CALL_OW 38
// if Cyrus then
12798: LD_EXP 21
12802: IFFALSE 12816
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12804: LD_EXP 21
12808: PPUSH
12809: LD_STRING 13a_Cyrus
12811: PPUSH
12812: CALL_OW 38
// if Denis then
12816: LD_EXP 22
12820: IFFALSE 12834
// SaveCharacters ( Denis , 13a_Denis ) ;
12822: LD_EXP 22
12826: PPUSH
12827: LD_STRING 13a_Denis
12829: PPUSH
12830: CALL_OW 38
// if Brown then
12834: LD_EXP 23
12838: IFFALSE 12852
// SaveCharacters ( Brown , 13a_Brown ) ;
12840: LD_EXP 23
12844: PPUSH
12845: LD_STRING 13a_Brown
12847: PPUSH
12848: CALL_OW 38
// if Gladstone then
12852: LD_EXP 24
12856: IFFALSE 12870
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12858: LD_EXP 24
12862: PPUSH
12863: LD_STRING 13a_Gladstone
12865: PPUSH
12866: CALL_OW 38
// if Houten then
12870: LD_EXP 25
12874: IFFALSE 12888
// SaveCharacters ( Houten , 13a_Houten ) ;
12876: LD_EXP 25
12880: PPUSH
12881: LD_STRING 13a_Houten
12883: PPUSH
12884: CALL_OW 38
// if Cornel then
12888: LD_EXP 26
12892: IFFALSE 12906
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12894: LD_EXP 26
12898: PPUSH
12899: LD_STRING 13a_Cornel
12901: PPUSH
12902: CALL_OW 38
// if Gary then
12906: LD_EXP 27
12910: IFFALSE 12924
// SaveCharacters ( Gary , 13a_Gary ) ;
12912: LD_EXP 27
12916: PPUSH
12917: LD_STRING 13a_Gary
12919: PPUSH
12920: CALL_OW 38
// if Frank then
12924: LD_EXP 28
12928: IFFALSE 12942
// SaveCharacters ( Frank , 13a_Frank ) ;
12930: LD_EXP 28
12934: PPUSH
12935: LD_STRING 13a_Frank
12937: PPUSH
12938: CALL_OW 38
// if Kikuchi then
12942: LD_EXP 29
12946: IFFALSE 12960
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12948: LD_EXP 29
12952: PPUSH
12953: LD_STRING 13a_Kikuchi
12955: PPUSH
12956: CALL_OW 38
// if Simms then
12960: LD_EXP 30
12964: IFFALSE 12978
// SaveCharacters ( Simms , 13a_Simms ) ;
12966: LD_EXP 30
12970: PPUSH
12971: LD_STRING 13a_Simms
12973: PPUSH
12974: CALL_OW 38
// if Joan then
12978: LD_EXP 31
12982: IFFALSE 12996
// SaveCharacters ( Joan , 13a_Joan ) ;
12984: LD_EXP 31
12988: PPUSH
12989: LD_STRING 13a_Joan
12991: PPUSH
12992: CALL_OW 38
// if DeltaDoctor then
12996: LD_EXP 32
13000: IFFALSE 13014
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13002: LD_EXP 32
13006: PPUSH
13007: LD_STRING 13a_DeltaDoctor
13009: PPUSH
13010: CALL_OW 38
// if Gossudarov then
13014: LD_EXP 34
13018: IFFALSE 13032
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13020: LD_EXP 34
13024: PPUSH
13025: LD_STRING 13a_Gossudarov
13027: PPUSH
13028: CALL_OW 38
// if Kirilenkova then
13032: LD_EXP 35
13036: IFFALSE 13050
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13038: LD_EXP 35
13042: PPUSH
13043: LD_STRING 13a_Kirilenkova
13045: PPUSH
13046: CALL_OW 38
// if Roth then
13050: LD_EXP 17
13054: IFFALSE 13068
// SaveCharacters ( Roth , 13a_Roth ) ;
13056: LD_EXP 17
13060: PPUSH
13061: LD_STRING 13a_Roth
13063: PPUSH
13064: CALL_OW 38
// if Masha then
13068: LD_EXP 51
13072: IFFALSE 13127
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13074: LD_EXP 51
13078: PPUSH
13079: CALL_OW 265
13083: PUSH
13084: LD_EXP 51
13088: PPUSH
13089: CALL_OW 262
13093: PUSH
13094: LD_EXP 51
13098: PPUSH
13099: CALL_OW 263
13103: PUSH
13104: LD_EXP 51
13108: PPUSH
13109: CALL_OW 264
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: PPUSH
13120: LD_STRING 13a_Masha
13122: PPUSH
13123: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13127: LD_ADDR_VAR 0 2
13131: PUSH
13132: LD_INT 21
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PPUSH
13142: CALL_OW 69
13146: ST_TO_ADDR
// tmp2 := [ ] ;
13147: LD_ADDR_VAR 0 3
13151: PUSH
13152: EMPTY
13153: ST_TO_ADDR
// if tmp then
13154: LD_VAR 0 2
13158: IFFALSE 13309
// for i in tmp do
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_VAR 0 2
13169: PUSH
13170: FOR_IN
13171: IFFALSE 13307
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13173: LD_ADDR_VAR 0 3
13177: PUSH
13178: LD_VAR 0 3
13182: PUSH
13183: LD_VAR 0 1
13187: PPUSH
13188: CALL_OW 255
13192: PUSH
13193: LD_VAR 0 1
13197: PPUSH
13198: CALL_OW 248
13202: PUSH
13203: LD_VAR 0 1
13207: PPUSH
13208: CALL_OW 266
13212: PUSH
13213: LD_VAR 0 1
13217: PPUSH
13218: CALL_OW 250
13222: PUSH
13223: LD_VAR 0 1
13227: PPUSH
13228: CALL_OW 251
13232: PUSH
13233: LD_VAR 0 1
13237: PPUSH
13238: CALL_OW 254
13242: PUSH
13243: LD_VAR 0 1
13247: PPUSH
13248: CALL_OW 267
13252: PUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: CALL_OW 268
13265: PUSH
13266: LD_VAR 0 1
13270: PPUSH
13271: LD_INT 2
13273: PPUSH
13274: CALL_OW 268
13278: PUSH
13279: LD_VAR 0 1
13283: PPUSH
13284: CALL_OW 269
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: PUSH
13301: EMPTY
13302: LIST
13303: ADD
13304: ST_TO_ADDR
13305: GO 13170
13307: POP
13308: POP
// if tmp2 then
13309: LD_VAR 0 3
13313: IFFALSE 13327
// SaveVariable ( tmp2 , 13a_buildings ) ;
13315: LD_VAR 0 3
13319: PPUSH
13320: LD_STRING 13a_buildings
13322: PPUSH
13323: CALL_OW 39
// YouWin ;
13327: CALL_OW 103
// end ;
13331: PPOPN 6
13333: END
// export function SciRu ; var tmp , t ; begin
13334: LD_INT 0
13336: PPUSH
13337: PPUSH
13338: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13339: LD_ADDR_VAR 0 3
13343: PUSH
13344: LD_EXP 34
13348: PUSH
13349: LD_EXP 48
13353: PUSH
13354: LD_EXP 36
13358: PUSH
13359: LD_EXP 49
13363: PUSH
13364: LD_EXP 50
13368: PUSH
13369: LD_EXP 39
13373: PUSH
13374: LD_EXP 40
13378: PUSH
13379: LD_EXP 38
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13394: LD_ADDR_VAR 0 2
13398: PUSH
13399: LD_INT 22
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 23
13411: PUSH
13412: LD_INT 3
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 25
13421: PUSH
13422: LD_INT 4
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: LD_INT 26
13431: PUSH
13432: LD_INT 1
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: PPUSH
13445: CALL_OW 69
13449: PUSH
13450: LD_VAR 0 3
13454: DIFF
13455: ST_TO_ADDR
// if tmp then
13456: LD_VAR 0 2
13460: IFFALSE 13476
// result := tmp [ 1 ] ;
13462: LD_ADDR_VAR 0 1
13466: PUSH
13467: LD_VAR 0 2
13471: PUSH
13472: LD_INT 1
13474: ARRAY
13475: ST_TO_ADDR
// end ;
13476: LD_VAR 0 1
13480: RET
// export function SolRu ; var tmp , t ; begin
13481: LD_INT 0
13483: PPUSH
13484: PPUSH
13485: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13486: LD_ADDR_VAR 0 3
13490: PUSH
13491: LD_EXP 34
13495: PUSH
13496: LD_EXP 48
13500: PUSH
13501: LD_EXP 36
13505: PUSH
13506: LD_EXP 49
13510: PUSH
13511: LD_EXP 50
13515: PUSH
13516: LD_EXP 39
13520: PUSH
13521: LD_EXP 40
13525: PUSH
13526: LD_EXP 38
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: LIST
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: LIST
13540: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13541: LD_ADDR_VAR 0 2
13545: PUSH
13546: LD_INT 22
13548: PUSH
13549: LD_INT 7
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 23
13558: PUSH
13559: LD_INT 3
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 1
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 26
13578: PUSH
13579: LD_INT 1
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: PPUSH
13592: CALL_OW 69
13596: PUSH
13597: LD_VAR 0 3
13601: DIFF
13602: ST_TO_ADDR
// if tmp then
13603: LD_VAR 0 2
13607: IFFALSE 13623
// result := tmp [ 1 ] ;
13609: LD_ADDR_VAR 0 1
13613: PUSH
13614: LD_VAR 0 2
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: ST_TO_ADDR
// end ; end_of_file
13623: LD_VAR 0 1
13627: RET
// export function CustomEvent ( event ) ; begin
13628: LD_INT 0
13630: PPUSH
// end ;
13631: LD_VAR 0 2
13635: RET
// on UnitDestroyed ( un ) do var i , side ;
13636: LD_INT 0
13638: PPUSH
13639: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL 102802 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13649: LD_VAR 0 1
13653: PUSH
13654: LD_INT 22
13656: PUSH
13657: LD_INT 7
13659: PUSH
13660: EMPTY
13661: LIST
13662: LIST
13663: PUSH
13664: LD_INT 2
13666: PUSH
13667: LD_INT 25
13669: PUSH
13670: LD_INT 1
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: PUSH
13677: LD_INT 25
13679: PUSH
13680: LD_INT 2
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: PUSH
13687: LD_INT 25
13689: PUSH
13690: LD_INT 3
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PUSH
13697: LD_INT 25
13699: PUSH
13700: LD_INT 4
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PUSH
13707: LD_INT 25
13709: PUSH
13710: LD_INT 5
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: PUSH
13717: LD_INT 25
13719: PUSH
13720: LD_INT 8
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PUSH
13727: LD_INT 25
13729: PUSH
13730: LD_INT 9
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PPUSH
13751: CALL_OW 69
13755: IN
13756: IFFALSE 13772
// loss_counter := loss_counter + 1 ;
13758: LD_ADDR_EXP 14
13762: PUSH
13763: LD_EXP 14
13767: PUSH
13768: LD_INT 1
13770: PLUS
13771: ST_TO_ADDR
// if un = Abdul then
13772: LD_VAR 0 1
13776: PUSH
13777: LD_EXP 57
13781: EQUAL
13782: IFFALSE 13792
// abdul_escaped := false ;
13784: LD_ADDR_EXP 13
13788: PUSH
13789: LD_INT 0
13791: ST_TO_ADDR
// if un in ru_attackers then
13792: LD_VAR 0 1
13796: PUSH
13797: LD_EXP 54
13801: IN
13802: IFFALSE 13820
// ru_attackers := ru_attackers diff un ;
13804: LD_ADDR_EXP 54
13808: PUSH
13809: LD_EXP 54
13813: PUSH
13814: LD_VAR 0 1
13818: DIFF
13819: ST_TO_ADDR
// if un in ar_attackers then
13820: LD_VAR 0 1
13824: PUSH
13825: LD_EXP 11
13829: IN
13830: IFFALSE 13848
// ar_attackers := ar_attackers diff un ;
13832: LD_ADDR_EXP 11
13836: PUSH
13837: LD_EXP 11
13841: PUSH
13842: LD_VAR 0 1
13846: DIFF
13847: ST_TO_ADDR
// if un = JMM then
13848: LD_VAR 0 1
13852: PUSH
13853: LD_EXP 16
13857: EQUAL
13858: IFFALSE 13869
// begin YouLost ( JMM ) ;
13860: LD_STRING JMM
13862: PPUSH
13863: CALL_OW 104
// exit ;
13867: GO 13966
// end ; if un = Burlak then
13869: LD_VAR 0 1
13873: PUSH
13874: LD_EXP 48
13878: EQUAL
13879: IFFALSE 13890
// begin YouLost ( Burlak ) ;
13881: LD_STRING Burlak
13883: PPUSH
13884: CALL_OW 104
// exit ;
13888: GO 13966
// end ; if un = freedom then
13890: LD_VAR 0 1
13894: PUSH
13895: LD_EXP 3
13899: EQUAL
13900: IFFALSE 13911
// begin YouLost ( Destroyed ) ;
13902: LD_STRING Destroyed
13904: PPUSH
13905: CALL_OW 104
// exit ;
13909: GO 13966
// end ; if un = Masha then
13911: LD_VAR 0 1
13915: PUSH
13916: LD_EXP 51
13920: EQUAL
13921: IFFALSE 13938
// begin ChangeMissionObjectives ( M4b ) ;
13923: LD_STRING M4b
13925: PPUSH
13926: CALL_OW 337
// masha_killed := true ;
13930: LD_ADDR_EXP 10
13934: PUSH
13935: LD_INT 1
13937: ST_TO_ADDR
// end ; if un = Mastodont then
13938: LD_VAR 0 1
13942: PUSH
13943: LD_EXP 58
13947: EQUAL
13948: IFFALSE 13957
// ChangeMissionObjectives ( M4a ) ;
13950: LD_STRING M4a
13952: PPUSH
13953: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13957: LD_VAR 0 1
13961: PPUSH
13962: CALL 84024 0 1
// end ;
13966: PPOPN 3
13968: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13969: LD_VAR 0 1
13973: PPUSH
13974: LD_VAR 0 2
13978: PPUSH
13979: CALL 86356 0 2
// end ;
13983: PPOPN 2
13985: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13986: LD_VAR 0 1
13990: PPUSH
13991: CALL 85424 0 1
// end ;
13995: PPOPN 1
13997: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13998: LD_VAR 0 1
14002: PUSH
14003: LD_INT 22
14005: PUSH
14006: LD_INT 7
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: PUSH
14013: LD_INT 30
14015: PUSH
14016: LD_INT 0
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PPUSH
14027: CALL_OW 69
14031: IN
14032: IFFALSE 14071
// begin SetBName ( building , freedom ) ;
14034: LD_VAR 0 1
14038: PPUSH
14039: LD_STRING freedom
14041: PPUSH
14042: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14046: LD_INT 0
14048: PPUSH
14049: LD_INT 7
14051: PPUSH
14052: LD_INT 0
14054: PPUSH
14055: CALL_OW 324
// freedom := building ;
14059: LD_ADDR_EXP 3
14063: PUSH
14064: LD_VAR 0 1
14068: ST_TO_ADDR
// exit ;
14069: GO 14137
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14071: LD_VAR 0 1
14075: PUSH
14076: LD_INT 22
14078: PUSH
14079: LD_INT 7
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: PUSH
14086: LD_INT 23
14088: PUSH
14089: LD_INT 3
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: PUSH
14096: LD_INT 30
14098: PUSH
14099: LD_INT 6
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: PPUSH
14111: CALL_OW 69
14115: IN
14116: IFFALSE 14128
// begin ru_lab_builded := true ;
14118: LD_ADDR_EXP 5
14122: PUSH
14123: LD_INT 1
14125: ST_TO_ADDR
// exit ;
14126: GO 14137
// end ; MCE_BuildingComplete ( building ) ;
14128: LD_VAR 0 1
14132: PPUSH
14133: CALL 85665 0 1
// end ;
14137: PPOPN 1
14139: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_VAR 0 2
14149: PPUSH
14150: CALL 83720 0 2
// end ;
14154: PPOPN 2
14156: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14157: LD_VAR 0 1
14161: PPUSH
14162: LD_VAR 0 2
14166: PPUSH
14167: LD_VAR 0 3
14171: PPUSH
14172: LD_VAR 0 4
14176: PPUSH
14177: LD_VAR 0 5
14181: PPUSH
14182: CALL 83340 0 5
// end ;
14186: PPOPN 5
14188: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14189: LD_VAR 0 1
14193: PPUSH
14194: LD_VAR 0 2
14198: PPUSH
14199: CALL 102922 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14203: LD_VAR 0 1
14207: PPUSH
14208: LD_VAR 0 2
14212: PPUSH
14213: CALL 82893 0 2
// end ;
14217: PPOPN 2
14219: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14220: LD_VAR 0 1
14224: PPUSH
14225: CALL_OW 263
14229: PUSH
14230: LD_INT 3
14232: EQUAL
14233: PUSH
14234: LD_VAR 0 2
14238: PPUSH
14239: CALL_OW 263
14243: PUSH
14244: LD_INT 3
14246: EQUAL
14247: OR
14248: IFFALSE 14264
// hack_counter := hack_counter + 1 ;
14250: LD_ADDR_EXP 15
14254: PUSH
14255: LD_EXP 15
14259: PUSH
14260: LD_INT 1
14262: PLUS
14263: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14264: LD_VAR 0 1
14268: PPUSH
14269: LD_VAR 0 2
14273: PPUSH
14274: LD_VAR 0 3
14278: PPUSH
14279: LD_VAR 0 4
14283: PPUSH
14284: CALL 82731 0 4
// end ;
14288: PPOPN 4
14290: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14291: LD_VAR 0 1
14295: PPUSH
14296: LD_VAR 0 2
14300: PPUSH
14301: LD_VAR 0 3
14305: PPUSH
14306: CALL 82506 0 3
// end ;
14310: PPOPN 3
14312: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14313: LD_VAR 0 1
14317: PPUSH
14318: LD_VAR 0 2
14322: PPUSH
14323: CALL 82391 0 2
// end ;
14327: PPOPN 2
14329: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14330: LD_VAR 0 1
14334: PPUSH
14335: LD_VAR 0 2
14339: PPUSH
14340: CALL 86651 0 2
// end ;
14344: PPOPN 2
14346: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14347: LD_VAR 0 1
14351: PPUSH
14352: LD_VAR 0 2
14356: PPUSH
14357: LD_VAR 0 3
14361: PPUSH
14362: LD_VAR 0 4
14366: PPUSH
14367: CALL 86867 0 4
// end ;
14371: PPOPN 4
14373: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14374: LD_VAR 0 1
14378: PPUSH
14379: LD_VAR 0 2
14383: PPUSH
14384: CALL 82200 0 2
// end ;
14388: PPOPN 2
14390: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: CALL 102906 0 1
// end ; end_of_file
14400: PPOPN 1
14402: END
// every 0 0$30 do var cr , time ;
14403: GO 14405
14405: DISABLE
14406: LD_INT 0
14408: PPUSH
14409: PPUSH
// begin time := 0 0$20 ;
14410: LD_ADDR_VAR 0 2
14414: PUSH
14415: LD_INT 700
14417: ST_TO_ADDR
// while game do
14418: LD_EXP 2
14422: IFFALSE 14525
// begin wait ( time ) ;
14424: LD_VAR 0 2
14428: PPUSH
14429: CALL_OW 67
// if tick > 2 2$00 then
14433: LD_OWVAR 1
14437: PUSH
14438: LD_INT 4200
14440: GREATER
14441: IFFALSE 14478
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14443: LD_ADDR_VAR 0 2
14447: PUSH
14448: LD_VAR 0 2
14452: PUSH
14453: LD_INT 140
14455: PUSH
14456: LD_INT 140
14458: PUSH
14459: LD_INT 210
14461: PUSH
14462: LD_INT 280
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: LD_OWVAR 67
14475: ARRAY
14476: PLUS
14477: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14478: LD_INT 1
14480: PPUSH
14481: LD_INT 5
14483: PPUSH
14484: CALL_OW 12
14488: PPUSH
14489: LD_INT 70
14491: PPUSH
14492: LD_INT 49
14494: PPUSH
14495: LD_INT 25
14497: PPUSH
14498: LD_INT 1
14500: PPUSH
14501: CALL_OW 56
// if time > 3 3$00 then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 6300
14512: GREATER
14513: IFFALSE 14523
// time := 0 0$30 ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_INT 1050
14522: ST_TO_ADDR
// end ;
14523: GO 14418
// end ;
14525: PPOPN 2
14527: END
// every 0 0$30 do var cr , time ;
14528: GO 14530
14530: DISABLE
14531: LD_INT 0
14533: PPUSH
14534: PPUSH
// begin time := 0 0$20 ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 700
14542: ST_TO_ADDR
// while game do
14543: LD_EXP 2
14547: IFFALSE 14640
// begin wait ( time ) ;
14549: LD_VAR 0 2
14553: PPUSH
14554: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14558: LD_ADDR_VAR 0 2
14562: PUSH
14563: LD_VAR 0 2
14567: PUSH
14568: LD_INT 140
14570: PUSH
14571: LD_INT 175
14573: PUSH
14574: LD_INT 210
14576: PUSH
14577: LD_INT 280
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: PUSH
14586: LD_OWVAR 67
14590: ARRAY
14591: PLUS
14592: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14593: LD_INT 3
14595: PPUSH
14596: LD_INT 5
14598: PPUSH
14599: CALL_OW 12
14603: PPUSH
14604: LD_INT 26
14606: PPUSH
14607: LD_INT 9
14609: PPUSH
14610: LD_INT 30
14612: PPUSH
14613: LD_INT 1
14615: PPUSH
14616: CALL_OW 56
// if time > 3 3$00 then
14620: LD_VAR 0 2
14624: PUSH
14625: LD_INT 6300
14627: GREATER
14628: IFFALSE 14638
// time := 0 0$20 ;
14630: LD_ADDR_VAR 0 2
14634: PUSH
14635: LD_INT 700
14637: ST_TO_ADDR
// end ;
14638: GO 14543
// end ;
14640: PPOPN 2
14642: END
// every 0 0$30 do var cr , time ;
14643: GO 14645
14645: DISABLE
14646: LD_INT 0
14648: PPUSH
14649: PPUSH
// begin time := 0 0$20 ;
14650: LD_ADDR_VAR 0 2
14654: PUSH
14655: LD_INT 700
14657: ST_TO_ADDR
// while game do
14658: LD_EXP 2
14662: IFFALSE 14791
// begin wait ( time ) ;
14664: LD_VAR 0 2
14668: PPUSH
14669: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: LD_VAR 0 2
14682: PUSH
14683: LD_INT 175
14685: PUSH
14686: LD_INT 210
14688: PUSH
14689: LD_INT 280
14691: PUSH
14692: LD_INT 350
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: PUSH
14701: LD_OWVAR 67
14705: ARRAY
14706: PLUS
14707: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14708: LD_INT 1
14710: PPUSH
14711: LD_INT 5
14713: PPUSH
14714: CALL_OW 12
14718: PPUSH
14719: LD_INT 179
14721: PPUSH
14722: LD_INT 101
14724: PPUSH
14725: LD_INT 20
14727: PPUSH
14728: LD_INT 1
14730: PPUSH
14731: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14735: LD_INT 350
14737: PPUSH
14738: LD_INT 525
14740: PPUSH
14741: CALL_OW 12
14745: PPUSH
14746: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14750: LD_INT 1
14752: PPUSH
14753: LD_INT 5
14755: PPUSH
14756: CALL_OW 12
14760: PPUSH
14761: LD_INT 9
14763: PPUSH
14764: LD_INT 1
14766: PPUSH
14767: CALL_OW 55
// if time > 4 4$00 then
14771: LD_VAR 0 2
14775: PUSH
14776: LD_INT 8400
14778: GREATER
14779: IFFALSE 14789
// time := 0 0$30 ;
14781: LD_ADDR_VAR 0 2
14785: PUSH
14786: LD_INT 1050
14788: ST_TO_ADDR
// end ;
14789: GO 14658
// end ;
14791: PPOPN 2
14793: END
// every 0 0$30 do var cr , time ;
14794: GO 14796
14796: DISABLE
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
// begin time := 0 0$10 ;
14801: LD_ADDR_VAR 0 2
14805: PUSH
14806: LD_INT 350
14808: ST_TO_ADDR
// while game do
14809: LD_EXP 2
14813: IFFALSE 14947
// begin wait ( time ) ;
14815: LD_VAR 0 2
14819: PPUSH
14820: CALL_OW 67
// time := time + 0 0$10 ;
14824: LD_ADDR_VAR 0 2
14828: PUSH
14829: LD_VAR 0 2
14833: PUSH
14834: LD_INT 350
14836: PLUS
14837: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14838: LD_INT 1
14840: PPUSH
14841: LD_INT 5
14843: PPUSH
14844: CALL_OW 12
14848: PPUSH
14849: LD_INT 11
14851: PPUSH
14852: LD_INT 1
14854: PPUSH
14855: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14859: LD_ADDR_VAR 0 1
14863: PUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 3
14869: PPUSH
14870: CALL_OW 12
14874: ST_TO_ADDR
// if cr = 1 then
14875: LD_VAR 0 1
14879: PUSH
14880: LD_INT 1
14882: EQUAL
14883: IFFALSE 14927
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14885: LD_INT 700
14887: PPUSH
14888: LD_INT 1575
14890: PPUSH
14891: CALL_OW 12
14895: PPUSH
14896: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14900: LD_INT 1
14902: PPUSH
14903: LD_INT 5
14905: PPUSH
14906: CALL_OW 12
14910: PPUSH
14911: LD_INT 34
14913: PPUSH
14914: LD_INT 50
14916: PPUSH
14917: LD_INT 7
14919: PPUSH
14920: LD_INT 1
14922: PPUSH
14923: CALL_OW 56
// end ; if time > 4 4$00 then
14927: LD_VAR 0 2
14931: PUSH
14932: LD_INT 8400
14934: GREATER
14935: IFFALSE 14945
// time := 0 0$40 ;
14937: LD_ADDR_VAR 0 2
14941: PUSH
14942: LD_INT 1400
14944: ST_TO_ADDR
// end ;
14945: GO 14809
// end ; end_of_file
14947: PPOPN 2
14949: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14950: LD_INT 0
14952: PPUSH
14953: PPUSH
// if exist_mode then
14954: LD_VAR 0 2
14958: IFFALSE 14983
// unit := CreateCharacter ( prefix & ident ) else
14960: LD_ADDR_VAR 0 5
14964: PUSH
14965: LD_VAR 0 3
14969: PUSH
14970: LD_VAR 0 1
14974: STR
14975: PPUSH
14976: CALL_OW 34
14980: ST_TO_ADDR
14981: GO 14998
// unit := NewCharacter ( ident ) ;
14983: LD_ADDR_VAR 0 5
14987: PUSH
14988: LD_VAR 0 1
14992: PPUSH
14993: CALL_OW 25
14997: ST_TO_ADDR
// result := unit ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_VAR 0 5
15007: ST_TO_ADDR
// end ;
15008: LD_VAR 0 4
15012: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15013: LD_INT 0
15015: PPUSH
15016: PPUSH
// if not side or not nation then
15017: LD_VAR 0 1
15021: NOT
15022: PUSH
15023: LD_VAR 0 2
15027: NOT
15028: OR
15029: IFFALSE 15033
// exit ;
15031: GO 15801
// case nation of nation_american :
15033: LD_VAR 0 2
15037: PUSH
15038: LD_INT 1
15040: DOUBLE
15041: EQUAL
15042: IFTRUE 15046
15044: GO 15260
15046: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15047: LD_ADDR_VAR 0 4
15051: PUSH
15052: LD_INT 35
15054: PUSH
15055: LD_INT 45
15057: PUSH
15058: LD_INT 46
15060: PUSH
15061: LD_INT 47
15063: PUSH
15064: LD_INT 82
15066: PUSH
15067: LD_INT 83
15069: PUSH
15070: LD_INT 84
15072: PUSH
15073: LD_INT 85
15075: PUSH
15076: LD_INT 86
15078: PUSH
15079: LD_INT 1
15081: PUSH
15082: LD_INT 2
15084: PUSH
15085: LD_INT 6
15087: PUSH
15088: LD_INT 15
15090: PUSH
15091: LD_INT 16
15093: PUSH
15094: LD_INT 7
15096: PUSH
15097: LD_INT 12
15099: PUSH
15100: LD_INT 13
15102: PUSH
15103: LD_INT 10
15105: PUSH
15106: LD_INT 14
15108: PUSH
15109: LD_INT 20
15111: PUSH
15112: LD_INT 21
15114: PUSH
15115: LD_INT 22
15117: PUSH
15118: LD_INT 25
15120: PUSH
15121: LD_INT 32
15123: PUSH
15124: LD_INT 27
15126: PUSH
15127: LD_INT 36
15129: PUSH
15130: LD_INT 69
15132: PUSH
15133: LD_INT 39
15135: PUSH
15136: LD_INT 34
15138: PUSH
15139: LD_INT 40
15141: PUSH
15142: LD_INT 48
15144: PUSH
15145: LD_INT 49
15147: PUSH
15148: LD_INT 50
15150: PUSH
15151: LD_INT 51
15153: PUSH
15154: LD_INT 52
15156: PUSH
15157: LD_INT 53
15159: PUSH
15160: LD_INT 54
15162: PUSH
15163: LD_INT 55
15165: PUSH
15166: LD_INT 56
15168: PUSH
15169: LD_INT 57
15171: PUSH
15172: LD_INT 58
15174: PUSH
15175: LD_INT 59
15177: PUSH
15178: LD_INT 60
15180: PUSH
15181: LD_INT 61
15183: PUSH
15184: LD_INT 62
15186: PUSH
15187: LD_INT 80
15189: PUSH
15190: LD_INT 82
15192: PUSH
15193: LD_INT 83
15195: PUSH
15196: LD_INT 84
15198: PUSH
15199: LD_INT 85
15201: PUSH
15202: LD_INT 86
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: ST_TO_ADDR
15258: GO 15725
15260: LD_INT 2
15262: DOUBLE
15263: EQUAL
15264: IFTRUE 15268
15266: GO 15494
15268: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15269: LD_ADDR_VAR 0 4
15273: PUSH
15274: LD_INT 35
15276: PUSH
15277: LD_INT 45
15279: PUSH
15280: LD_INT 46
15282: PUSH
15283: LD_INT 47
15285: PUSH
15286: LD_INT 82
15288: PUSH
15289: LD_INT 83
15291: PUSH
15292: LD_INT 84
15294: PUSH
15295: LD_INT 85
15297: PUSH
15298: LD_INT 87
15300: PUSH
15301: LD_INT 70
15303: PUSH
15304: LD_INT 1
15306: PUSH
15307: LD_INT 11
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: LD_INT 4
15315: PUSH
15316: LD_INT 5
15318: PUSH
15319: LD_INT 6
15321: PUSH
15322: LD_INT 15
15324: PUSH
15325: LD_INT 18
15327: PUSH
15328: LD_INT 7
15330: PUSH
15331: LD_INT 17
15333: PUSH
15334: LD_INT 8
15336: PUSH
15337: LD_INT 20
15339: PUSH
15340: LD_INT 21
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 72
15348: PUSH
15349: LD_INT 26
15351: PUSH
15352: LD_INT 69
15354: PUSH
15355: LD_INT 39
15357: PUSH
15358: LD_INT 40
15360: PUSH
15361: LD_INT 41
15363: PUSH
15364: LD_INT 42
15366: PUSH
15367: LD_INT 43
15369: PUSH
15370: LD_INT 48
15372: PUSH
15373: LD_INT 49
15375: PUSH
15376: LD_INT 50
15378: PUSH
15379: LD_INT 51
15381: PUSH
15382: LD_INT 52
15384: PUSH
15385: LD_INT 53
15387: PUSH
15388: LD_INT 54
15390: PUSH
15391: LD_INT 55
15393: PUSH
15394: LD_INT 56
15396: PUSH
15397: LD_INT 60
15399: PUSH
15400: LD_INT 61
15402: PUSH
15403: LD_INT 62
15405: PUSH
15406: LD_INT 66
15408: PUSH
15409: LD_INT 67
15411: PUSH
15412: LD_INT 68
15414: PUSH
15415: LD_INT 81
15417: PUSH
15418: LD_INT 82
15420: PUSH
15421: LD_INT 83
15423: PUSH
15424: LD_INT 84
15426: PUSH
15427: LD_INT 85
15429: PUSH
15430: LD_INT 87
15432: PUSH
15433: LD_INT 88
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: ST_TO_ADDR
15492: GO 15725
15494: LD_INT 3
15496: DOUBLE
15497: EQUAL
15498: IFTRUE 15502
15500: GO 15724
15502: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15503: LD_ADDR_VAR 0 4
15507: PUSH
15508: LD_INT 46
15510: PUSH
15511: LD_INT 47
15513: PUSH
15514: LD_INT 1
15516: PUSH
15517: LD_INT 2
15519: PUSH
15520: LD_INT 82
15522: PUSH
15523: LD_INT 83
15525: PUSH
15526: LD_INT 84
15528: PUSH
15529: LD_INT 85
15531: PUSH
15532: LD_INT 86
15534: PUSH
15535: LD_INT 11
15537: PUSH
15538: LD_INT 9
15540: PUSH
15541: LD_INT 20
15543: PUSH
15544: LD_INT 19
15546: PUSH
15547: LD_INT 21
15549: PUSH
15550: LD_INT 24
15552: PUSH
15553: LD_INT 22
15555: PUSH
15556: LD_INT 25
15558: PUSH
15559: LD_INT 28
15561: PUSH
15562: LD_INT 29
15564: PUSH
15565: LD_INT 30
15567: PUSH
15568: LD_INT 31
15570: PUSH
15571: LD_INT 37
15573: PUSH
15574: LD_INT 38
15576: PUSH
15577: LD_INT 32
15579: PUSH
15580: LD_INT 27
15582: PUSH
15583: LD_INT 33
15585: PUSH
15586: LD_INT 69
15588: PUSH
15589: LD_INT 39
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 40
15597: PUSH
15598: LD_INT 71
15600: PUSH
15601: LD_INT 23
15603: PUSH
15604: LD_INT 44
15606: PUSH
15607: LD_INT 48
15609: PUSH
15610: LD_INT 49
15612: PUSH
15613: LD_INT 50
15615: PUSH
15616: LD_INT 51
15618: PUSH
15619: LD_INT 52
15621: PUSH
15622: LD_INT 53
15624: PUSH
15625: LD_INT 54
15627: PUSH
15628: LD_INT 55
15630: PUSH
15631: LD_INT 56
15633: PUSH
15634: LD_INT 57
15636: PUSH
15637: LD_INT 58
15639: PUSH
15640: LD_INT 59
15642: PUSH
15643: LD_INT 63
15645: PUSH
15646: LD_INT 64
15648: PUSH
15649: LD_INT 65
15651: PUSH
15652: LD_INT 82
15654: PUSH
15655: LD_INT 83
15657: PUSH
15658: LD_INT 84
15660: PUSH
15661: LD_INT 85
15663: PUSH
15664: LD_INT 86
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: LIST
15700: LIST
15701: LIST
15702: LIST
15703: LIST
15704: LIST
15705: LIST
15706: LIST
15707: LIST
15708: LIST
15709: LIST
15710: LIST
15711: LIST
15712: LIST
15713: LIST
15714: LIST
15715: LIST
15716: LIST
15717: LIST
15718: LIST
15719: LIST
15720: LIST
15721: ST_TO_ADDR
15722: GO 15725
15724: POP
// if state > - 1 and state < 3 then
15725: LD_VAR 0 3
15729: PUSH
15730: LD_INT 1
15732: NEG
15733: GREATER
15734: PUSH
15735: LD_VAR 0 3
15739: PUSH
15740: LD_INT 3
15742: LESS
15743: AND
15744: IFFALSE 15801
// for i in result do
15746: LD_ADDR_VAR 0 5
15750: PUSH
15751: LD_VAR 0 4
15755: PUSH
15756: FOR_IN
15757: IFFALSE 15799
// if GetTech ( i , side ) <> state then
15759: LD_VAR 0 5
15763: PPUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 321
15773: PUSH
15774: LD_VAR 0 3
15778: NONEQUAL
15779: IFFALSE 15797
// result := result diff i ;
15781: LD_ADDR_VAR 0 4
15785: PUSH
15786: LD_VAR 0 4
15790: PUSH
15791: LD_VAR 0 5
15795: DIFF
15796: ST_TO_ADDR
15797: GO 15756
15799: POP
15800: POP
// end ;
15801: LD_VAR 0 4
15805: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15806: LD_INT 0
15808: PPUSH
15809: PPUSH
15810: PPUSH
// result := true ;
15811: LD_ADDR_VAR 0 3
15815: PUSH
15816: LD_INT 1
15818: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15819: LD_ADDR_VAR 0 5
15823: PUSH
15824: LD_VAR 0 2
15828: PPUSH
15829: CALL_OW 480
15833: ST_TO_ADDR
// if not tmp then
15834: LD_VAR 0 5
15838: NOT
15839: IFFALSE 15843
// exit ;
15841: GO 15892
// for i in tmp do
15843: LD_ADDR_VAR 0 4
15847: PUSH
15848: LD_VAR 0 5
15852: PUSH
15853: FOR_IN
15854: IFFALSE 15890
// if GetTech ( i , side ) <> state_researched then
15856: LD_VAR 0 4
15860: PPUSH
15861: LD_VAR 0 1
15865: PPUSH
15866: CALL_OW 321
15870: PUSH
15871: LD_INT 2
15873: NONEQUAL
15874: IFFALSE 15888
// begin result := false ;
15876: LD_ADDR_VAR 0 3
15880: PUSH
15881: LD_INT 0
15883: ST_TO_ADDR
// exit ;
15884: POP
15885: POP
15886: GO 15892
// end ;
15888: GO 15853
15890: POP
15891: POP
// end ;
15892: LD_VAR 0 3
15896: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15897: LD_INT 0
15899: PPUSH
15900: PPUSH
15901: PPUSH
15902: PPUSH
15903: PPUSH
15904: PPUSH
15905: PPUSH
15906: PPUSH
15907: PPUSH
15908: PPUSH
15909: PPUSH
15910: PPUSH
15911: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15912: LD_VAR 0 1
15916: NOT
15917: PUSH
15918: LD_VAR 0 1
15922: PPUSH
15923: CALL_OW 257
15927: PUSH
15928: LD_INT 9
15930: NONEQUAL
15931: OR
15932: IFFALSE 15936
// exit ;
15934: GO 16509
// side := GetSide ( unit ) ;
15936: LD_ADDR_VAR 0 9
15940: PUSH
15941: LD_VAR 0 1
15945: PPUSH
15946: CALL_OW 255
15950: ST_TO_ADDR
// tech_space := tech_spacanom ;
15951: LD_ADDR_VAR 0 12
15955: PUSH
15956: LD_INT 29
15958: ST_TO_ADDR
// tech_time := tech_taurad ;
15959: LD_ADDR_VAR 0 13
15963: PUSH
15964: LD_INT 28
15966: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15967: LD_ADDR_VAR 0 11
15971: PUSH
15972: LD_VAR 0 1
15976: PPUSH
15977: CALL_OW 310
15981: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15982: LD_VAR 0 11
15986: PPUSH
15987: CALL_OW 247
15991: PUSH
15992: LD_INT 2
15994: EQUAL
15995: IFFALSE 15999
// exit ;
15997: GO 16509
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15999: LD_ADDR_VAR 0 8
16003: PUSH
16004: LD_INT 81
16006: PUSH
16007: LD_VAR 0 9
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: LD_INT 21
16021: PUSH
16022: LD_INT 3
16024: PUSH
16025: EMPTY
16026: LIST
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: PPUSH
16037: CALL_OW 69
16041: ST_TO_ADDR
// if not tmp then
16042: LD_VAR 0 8
16046: NOT
16047: IFFALSE 16051
// exit ;
16049: GO 16509
// if in_unit then
16051: LD_VAR 0 11
16055: IFFALSE 16079
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16057: LD_ADDR_VAR 0 10
16061: PUSH
16062: LD_VAR 0 8
16066: PPUSH
16067: LD_VAR 0 11
16071: PPUSH
16072: CALL_OW 74
16076: ST_TO_ADDR
16077: GO 16099
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16079: LD_ADDR_VAR 0 10
16083: PUSH
16084: LD_VAR 0 8
16088: PPUSH
16089: LD_VAR 0 1
16093: PPUSH
16094: CALL_OW 74
16098: ST_TO_ADDR
// if not enemy then
16099: LD_VAR 0 10
16103: NOT
16104: IFFALSE 16108
// exit ;
16106: GO 16509
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16108: LD_VAR 0 11
16112: PUSH
16113: LD_VAR 0 11
16117: PPUSH
16118: LD_VAR 0 10
16122: PPUSH
16123: CALL_OW 296
16127: PUSH
16128: LD_INT 13
16130: GREATER
16131: AND
16132: PUSH
16133: LD_VAR 0 1
16137: PPUSH
16138: LD_VAR 0 10
16142: PPUSH
16143: CALL_OW 296
16147: PUSH
16148: LD_INT 12
16150: GREATER
16151: OR
16152: IFFALSE 16156
// exit ;
16154: GO 16509
// missile := [ 1 ] ;
16156: LD_ADDR_VAR 0 14
16160: PUSH
16161: LD_INT 1
16163: PUSH
16164: EMPTY
16165: LIST
16166: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16167: LD_VAR 0 9
16171: PPUSH
16172: LD_VAR 0 12
16176: PPUSH
16177: CALL_OW 325
16181: IFFALSE 16210
// missile := Replace ( missile , missile + 1 , 2 ) ;
16183: LD_ADDR_VAR 0 14
16187: PUSH
16188: LD_VAR 0 14
16192: PPUSH
16193: LD_VAR 0 14
16197: PUSH
16198: LD_INT 1
16200: PLUS
16201: PPUSH
16202: LD_INT 2
16204: PPUSH
16205: CALL_OW 1
16209: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16210: LD_VAR 0 9
16214: PPUSH
16215: LD_VAR 0 13
16219: PPUSH
16220: CALL_OW 325
16224: PUSH
16225: LD_VAR 0 10
16229: PPUSH
16230: CALL_OW 255
16234: PPUSH
16235: LD_VAR 0 13
16239: PPUSH
16240: CALL_OW 325
16244: NOT
16245: AND
16246: IFFALSE 16275
// missile := Replace ( missile , missile + 1 , 3 ) ;
16248: LD_ADDR_VAR 0 14
16252: PUSH
16253: LD_VAR 0 14
16257: PPUSH
16258: LD_VAR 0 14
16262: PUSH
16263: LD_INT 1
16265: PLUS
16266: PPUSH
16267: LD_INT 3
16269: PPUSH
16270: CALL_OW 1
16274: ST_TO_ADDR
// if missile < 2 then
16275: LD_VAR 0 14
16279: PUSH
16280: LD_INT 2
16282: LESS
16283: IFFALSE 16287
// exit ;
16285: GO 16509
// x := GetX ( enemy ) ;
16287: LD_ADDR_VAR 0 4
16291: PUSH
16292: LD_VAR 0 10
16296: PPUSH
16297: CALL_OW 250
16301: ST_TO_ADDR
// y := GetY ( enemy ) ;
16302: LD_ADDR_VAR 0 5
16306: PUSH
16307: LD_VAR 0 10
16311: PPUSH
16312: CALL_OW 251
16316: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16317: LD_ADDR_VAR 0 6
16321: PUSH
16322: LD_VAR 0 4
16326: PUSH
16327: LD_INT 1
16329: NEG
16330: PPUSH
16331: LD_INT 1
16333: PPUSH
16334: CALL_OW 12
16338: PLUS
16339: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16340: LD_ADDR_VAR 0 7
16344: PUSH
16345: LD_VAR 0 5
16349: PUSH
16350: LD_INT 1
16352: NEG
16353: PPUSH
16354: LD_INT 1
16356: PPUSH
16357: CALL_OW 12
16361: PLUS
16362: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16363: LD_VAR 0 6
16367: PPUSH
16368: LD_VAR 0 7
16372: PPUSH
16373: CALL_OW 488
16377: NOT
16378: IFFALSE 16400
// begin _x := x ;
16380: LD_ADDR_VAR 0 6
16384: PUSH
16385: LD_VAR 0 4
16389: ST_TO_ADDR
// _y := y ;
16390: LD_ADDR_VAR 0 7
16394: PUSH
16395: LD_VAR 0 5
16399: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16400: LD_ADDR_VAR 0 3
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_VAR 0 14
16412: PPUSH
16413: CALL_OW 12
16417: ST_TO_ADDR
// case i of 1 :
16418: LD_VAR 0 3
16422: PUSH
16423: LD_INT 1
16425: DOUBLE
16426: EQUAL
16427: IFTRUE 16431
16429: GO 16448
16431: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16432: LD_VAR 0 1
16436: PPUSH
16437: LD_VAR 0 10
16441: PPUSH
16442: CALL_OW 115
16446: GO 16509
16448: LD_INT 2
16450: DOUBLE
16451: EQUAL
16452: IFTRUE 16456
16454: GO 16478
16456: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16457: LD_VAR 0 1
16461: PPUSH
16462: LD_VAR 0 6
16466: PPUSH
16467: LD_VAR 0 7
16471: PPUSH
16472: CALL_OW 153
16476: GO 16509
16478: LD_INT 3
16480: DOUBLE
16481: EQUAL
16482: IFTRUE 16486
16484: GO 16508
16486: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16487: LD_VAR 0 1
16491: PPUSH
16492: LD_VAR 0 6
16496: PPUSH
16497: LD_VAR 0 7
16501: PPUSH
16502: CALL_OW 154
16506: GO 16509
16508: POP
// end ;
16509: LD_VAR 0 2
16513: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16514: LD_INT 0
16516: PPUSH
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
// if not unit or not building then
16522: LD_VAR 0 1
16526: NOT
16527: PUSH
16528: LD_VAR 0 2
16532: NOT
16533: OR
16534: IFFALSE 16538
// exit ;
16536: GO 16696
// x := GetX ( building ) ;
16538: LD_ADDR_VAR 0 5
16542: PUSH
16543: LD_VAR 0 2
16547: PPUSH
16548: CALL_OW 250
16552: ST_TO_ADDR
// y := GetY ( building ) ;
16553: LD_ADDR_VAR 0 6
16557: PUSH
16558: LD_VAR 0 2
16562: PPUSH
16563: CALL_OW 251
16567: ST_TO_ADDR
// for i = 0 to 5 do
16568: LD_ADDR_VAR 0 4
16572: PUSH
16573: DOUBLE
16574: LD_INT 0
16576: DEC
16577: ST_TO_ADDR
16578: LD_INT 5
16580: PUSH
16581: FOR_TO
16582: IFFALSE 16694
// begin _x := ShiftX ( x , i , 3 ) ;
16584: LD_ADDR_VAR 0 7
16588: PUSH
16589: LD_VAR 0 5
16593: PPUSH
16594: LD_VAR 0 4
16598: PPUSH
16599: LD_INT 3
16601: PPUSH
16602: CALL_OW 272
16606: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16607: LD_ADDR_VAR 0 8
16611: PUSH
16612: LD_VAR 0 6
16616: PPUSH
16617: LD_VAR 0 4
16621: PPUSH
16622: LD_INT 3
16624: PPUSH
16625: CALL_OW 273
16629: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16630: LD_VAR 0 7
16634: PPUSH
16635: LD_VAR 0 8
16639: PPUSH
16640: CALL_OW 488
16644: NOT
16645: IFFALSE 16649
// continue ;
16647: GO 16581
// if HexInfo ( _x , _y ) = 0 then
16649: LD_VAR 0 7
16653: PPUSH
16654: LD_VAR 0 8
16658: PPUSH
16659: CALL_OW 428
16663: PUSH
16664: LD_INT 0
16666: EQUAL
16667: IFFALSE 16692
// begin ComMoveXY ( unit , _x , _y ) ;
16669: LD_VAR 0 1
16673: PPUSH
16674: LD_VAR 0 7
16678: PPUSH
16679: LD_VAR 0 8
16683: PPUSH
16684: CALL_OW 111
// exit ;
16688: POP
16689: POP
16690: GO 16696
// end ; end ;
16692: GO 16581
16694: POP
16695: POP
// end ;
16696: LD_VAR 0 3
16700: RET
// export function ScanBase ( side , base_area ) ; begin
16701: LD_INT 0
16703: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16704: LD_ADDR_VAR 0 3
16708: PUSH
16709: LD_VAR 0 2
16713: PPUSH
16714: LD_INT 81
16716: PUSH
16717: LD_VAR 0 1
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PPUSH
16726: CALL_OW 70
16730: ST_TO_ADDR
// end ;
16731: LD_VAR 0 3
16735: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16736: LD_INT 0
16738: PPUSH
16739: PPUSH
16740: PPUSH
16741: PPUSH
// result := false ;
16742: LD_ADDR_VAR 0 2
16746: PUSH
16747: LD_INT 0
16749: ST_TO_ADDR
// side := GetSide ( unit ) ;
16750: LD_ADDR_VAR 0 3
16754: PUSH
16755: LD_VAR 0 1
16759: PPUSH
16760: CALL_OW 255
16764: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16765: LD_ADDR_VAR 0 4
16769: PUSH
16770: LD_VAR 0 1
16774: PPUSH
16775: CALL_OW 248
16779: ST_TO_ADDR
// case nat of 1 :
16780: LD_VAR 0 4
16784: PUSH
16785: LD_INT 1
16787: DOUBLE
16788: EQUAL
16789: IFTRUE 16793
16791: GO 16804
16793: POP
// tech := tech_lassight ; 2 :
16794: LD_ADDR_VAR 0 5
16798: PUSH
16799: LD_INT 12
16801: ST_TO_ADDR
16802: GO 16843
16804: LD_INT 2
16806: DOUBLE
16807: EQUAL
16808: IFTRUE 16812
16810: GO 16823
16812: POP
// tech := tech_mortar ; 3 :
16813: LD_ADDR_VAR 0 5
16817: PUSH
16818: LD_INT 41
16820: ST_TO_ADDR
16821: GO 16843
16823: LD_INT 3
16825: DOUBLE
16826: EQUAL
16827: IFTRUE 16831
16829: GO 16842
16831: POP
// tech := tech_bazooka ; end ;
16832: LD_ADDR_VAR 0 5
16836: PUSH
16837: LD_INT 44
16839: ST_TO_ADDR
16840: GO 16843
16842: POP
// if Researched ( side , tech ) then
16843: LD_VAR 0 3
16847: PPUSH
16848: LD_VAR 0 5
16852: PPUSH
16853: CALL_OW 325
16857: IFFALSE 16884
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16859: LD_ADDR_VAR 0 2
16863: PUSH
16864: LD_INT 5
16866: PUSH
16867: LD_INT 8
16869: PUSH
16870: LD_INT 9
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: LD_VAR 0 4
16882: ARRAY
16883: ST_TO_ADDR
// end ;
16884: LD_VAR 0 2
16888: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16889: LD_INT 0
16891: PPUSH
16892: PPUSH
16893: PPUSH
// if not mines then
16894: LD_VAR 0 2
16898: NOT
16899: IFFALSE 16903
// exit ;
16901: GO 17047
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16903: LD_ADDR_VAR 0 5
16907: PUSH
16908: LD_INT 81
16910: PUSH
16911: LD_VAR 0 1
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: LD_INT 3
16922: PUSH
16923: LD_INT 21
16925: PUSH
16926: LD_INT 3
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PPUSH
16941: CALL_OW 69
16945: ST_TO_ADDR
// for i in mines do
16946: LD_ADDR_VAR 0 4
16950: PUSH
16951: LD_VAR 0 2
16955: PUSH
16956: FOR_IN
16957: IFFALSE 17045
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16959: LD_VAR 0 4
16963: PUSH
16964: LD_INT 1
16966: ARRAY
16967: PPUSH
16968: LD_VAR 0 4
16972: PUSH
16973: LD_INT 2
16975: ARRAY
16976: PPUSH
16977: CALL_OW 458
16981: NOT
16982: IFFALSE 16986
// continue ;
16984: GO 16956
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16986: LD_VAR 0 4
16990: PUSH
16991: LD_INT 1
16993: ARRAY
16994: PPUSH
16995: LD_VAR 0 4
16999: PUSH
17000: LD_INT 2
17002: ARRAY
17003: PPUSH
17004: CALL_OW 428
17008: PUSH
17009: LD_VAR 0 5
17013: IN
17014: IFFALSE 17043
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17016: LD_VAR 0 4
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: LD_VAR 0 4
17029: PUSH
17030: LD_INT 2
17032: ARRAY
17033: PPUSH
17034: LD_VAR 0 1
17038: PPUSH
17039: CALL_OW 456
// end ;
17043: GO 16956
17045: POP
17046: POP
// end ;
17047: LD_VAR 0 3
17051: RET
// export function Count ( array ) ; begin
17052: LD_INT 0
17054: PPUSH
// result := array + 0 ;
17055: LD_ADDR_VAR 0 2
17059: PUSH
17060: LD_VAR 0 1
17064: PUSH
17065: LD_INT 0
17067: PLUS
17068: ST_TO_ADDR
// end ;
17069: LD_VAR 0 2
17073: RET
// export function IsEmpty ( building ) ; begin
17074: LD_INT 0
17076: PPUSH
// if not building then
17077: LD_VAR 0 1
17081: NOT
17082: IFFALSE 17086
// exit ;
17084: GO 17129
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17086: LD_ADDR_VAR 0 2
17090: PUSH
17091: LD_VAR 0 1
17095: PUSH
17096: LD_INT 22
17098: PUSH
17099: LD_VAR 0 1
17103: PPUSH
17104: CALL_OW 255
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: PUSH
17113: LD_INT 58
17115: PUSH
17116: EMPTY
17117: LIST
17118: PUSH
17119: EMPTY
17120: LIST
17121: LIST
17122: PPUSH
17123: CALL_OW 69
17127: IN
17128: ST_TO_ADDR
// end ;
17129: LD_VAR 0 2
17133: RET
// export function IsNotFull ( building ) ; var places ; begin
17134: LD_INT 0
17136: PPUSH
17137: PPUSH
// if not building then
17138: LD_VAR 0 1
17142: NOT
17143: IFFALSE 17147
// exit ;
17145: GO 17175
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
17147: LD_ADDR_VAR 0 2
17151: PUSH
17152: LD_VAR 0 1
17156: PPUSH
17157: LD_INT 3
17159: PUSH
17160: LD_INT 62
17162: PUSH
17163: EMPTY
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PPUSH
17170: CALL_OW 72
17174: ST_TO_ADDR
// end ;
17175: LD_VAR 0 2
17179: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17180: LD_INT 0
17182: PPUSH
17183: PPUSH
17184: PPUSH
17185: PPUSH
// tmp := [ ] ;
17186: LD_ADDR_VAR 0 3
17190: PUSH
17191: EMPTY
17192: ST_TO_ADDR
// list := [ ] ;
17193: LD_ADDR_VAR 0 5
17197: PUSH
17198: EMPTY
17199: ST_TO_ADDR
// for i = 16 to 25 do
17200: LD_ADDR_VAR 0 4
17204: PUSH
17205: DOUBLE
17206: LD_INT 16
17208: DEC
17209: ST_TO_ADDR
17210: LD_INT 25
17212: PUSH
17213: FOR_TO
17214: IFFALSE 17287
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17216: LD_ADDR_VAR 0 3
17220: PUSH
17221: LD_VAR 0 3
17225: PUSH
17226: LD_INT 22
17228: PUSH
17229: LD_VAR 0 1
17233: PPUSH
17234: CALL_OW 255
17238: PUSH
17239: EMPTY
17240: LIST
17241: LIST
17242: PUSH
17243: LD_INT 91
17245: PUSH
17246: LD_VAR 0 1
17250: PUSH
17251: LD_INT 6
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: PUSH
17259: LD_INT 30
17261: PUSH
17262: LD_VAR 0 4
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: LIST
17275: PUSH
17276: EMPTY
17277: LIST
17278: PPUSH
17279: CALL_OW 69
17283: ADD
17284: ST_TO_ADDR
17285: GO 17213
17287: POP
17288: POP
// for i = 1 to tmp do
17289: LD_ADDR_VAR 0 4
17293: PUSH
17294: DOUBLE
17295: LD_INT 1
17297: DEC
17298: ST_TO_ADDR
17299: LD_VAR 0 3
17303: PUSH
17304: FOR_TO
17305: IFFALSE 17393
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17307: LD_ADDR_VAR 0 5
17311: PUSH
17312: LD_VAR 0 5
17316: PUSH
17317: LD_VAR 0 3
17321: PUSH
17322: LD_VAR 0 4
17326: ARRAY
17327: PPUSH
17328: CALL_OW 266
17332: PUSH
17333: LD_VAR 0 3
17337: PUSH
17338: LD_VAR 0 4
17342: ARRAY
17343: PPUSH
17344: CALL_OW 250
17348: PUSH
17349: LD_VAR 0 3
17353: PUSH
17354: LD_VAR 0 4
17358: ARRAY
17359: PPUSH
17360: CALL_OW 251
17364: PUSH
17365: LD_VAR 0 3
17369: PUSH
17370: LD_VAR 0 4
17374: ARRAY
17375: PPUSH
17376: CALL_OW 254
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: PUSH
17387: EMPTY
17388: LIST
17389: ADD
17390: ST_TO_ADDR
17391: GO 17304
17393: POP
17394: POP
// result := list ;
17395: LD_ADDR_VAR 0 2
17399: PUSH
17400: LD_VAR 0 5
17404: ST_TO_ADDR
// end ;
17405: LD_VAR 0 2
17409: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17410: LD_INT 0
17412: PPUSH
17413: PPUSH
17414: PPUSH
17415: PPUSH
17416: PPUSH
17417: PPUSH
17418: PPUSH
// if not factory then
17419: LD_VAR 0 1
17423: NOT
17424: IFFALSE 17428
// exit ;
17426: GO 18021
// if control = control_apeman then
17428: LD_VAR 0 4
17432: PUSH
17433: LD_INT 5
17435: EQUAL
17436: IFFALSE 17545
// begin tmp := UnitsInside ( factory ) ;
17438: LD_ADDR_VAR 0 8
17442: PUSH
17443: LD_VAR 0 1
17447: PPUSH
17448: CALL_OW 313
17452: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17453: LD_VAR 0 8
17457: PPUSH
17458: LD_INT 25
17460: PUSH
17461: LD_INT 12
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PPUSH
17468: CALL_OW 72
17472: NOT
17473: IFFALSE 17483
// control := control_manual ;
17475: LD_ADDR_VAR 0 4
17479: PUSH
17480: LD_INT 1
17482: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17483: LD_ADDR_VAR 0 8
17487: PUSH
17488: LD_VAR 0 1
17492: PPUSH
17493: CALL 17180 0 1
17497: ST_TO_ADDR
// if tmp then
17498: LD_VAR 0 8
17502: IFFALSE 17545
// begin for i in tmp do
17504: LD_ADDR_VAR 0 7
17508: PUSH
17509: LD_VAR 0 8
17513: PUSH
17514: FOR_IN
17515: IFFALSE 17543
// if i [ 1 ] = b_ext_radio then
17517: LD_VAR 0 7
17521: PUSH
17522: LD_INT 1
17524: ARRAY
17525: PUSH
17526: LD_INT 22
17528: EQUAL
17529: IFFALSE 17541
// begin control := control_remote ;
17531: LD_ADDR_VAR 0 4
17535: PUSH
17536: LD_INT 2
17538: ST_TO_ADDR
// break ;
17539: GO 17543
// end ;
17541: GO 17514
17543: POP
17544: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17545: LD_VAR 0 1
17549: PPUSH
17550: LD_VAR 0 2
17554: PPUSH
17555: LD_VAR 0 3
17559: PPUSH
17560: LD_VAR 0 4
17564: PPUSH
17565: LD_VAR 0 5
17569: PPUSH
17570: CALL_OW 448
17574: IFFALSE 17609
// begin result := [ chassis , engine , control , weapon ] ;
17576: LD_ADDR_VAR 0 6
17580: PUSH
17581: LD_VAR 0 2
17585: PUSH
17586: LD_VAR 0 3
17590: PUSH
17591: LD_VAR 0 4
17595: PUSH
17596: LD_VAR 0 5
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
// exit ;
17607: GO 18021
// end ; _chassis := AvailableChassisList ( factory ) ;
17609: LD_ADDR_VAR 0 9
17613: PUSH
17614: LD_VAR 0 1
17618: PPUSH
17619: CALL_OW 475
17623: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17624: LD_ADDR_VAR 0 11
17628: PUSH
17629: LD_VAR 0 1
17633: PPUSH
17634: CALL_OW 476
17638: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17639: LD_ADDR_VAR 0 12
17643: PUSH
17644: LD_VAR 0 1
17648: PPUSH
17649: CALL_OW 477
17653: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17654: LD_ADDR_VAR 0 10
17658: PUSH
17659: LD_VAR 0 1
17663: PPUSH
17664: CALL_OW 478
17668: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17669: LD_VAR 0 9
17673: NOT
17674: PUSH
17675: LD_VAR 0 11
17679: NOT
17680: OR
17681: PUSH
17682: LD_VAR 0 12
17686: NOT
17687: OR
17688: PUSH
17689: LD_VAR 0 10
17693: NOT
17694: OR
17695: IFFALSE 17730
// begin result := [ chassis , engine , control , weapon ] ;
17697: LD_ADDR_VAR 0 6
17701: PUSH
17702: LD_VAR 0 2
17706: PUSH
17707: LD_VAR 0 3
17711: PUSH
17712: LD_VAR 0 4
17716: PUSH
17717: LD_VAR 0 5
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: ST_TO_ADDR
// exit ;
17728: GO 18021
// end ; if not chassis in _chassis then
17730: LD_VAR 0 2
17734: PUSH
17735: LD_VAR 0 9
17739: IN
17740: NOT
17741: IFFALSE 17767
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17743: LD_ADDR_VAR 0 2
17747: PUSH
17748: LD_VAR 0 9
17752: PUSH
17753: LD_INT 1
17755: PPUSH
17756: LD_VAR 0 9
17760: PPUSH
17761: CALL_OW 12
17765: ARRAY
17766: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17767: LD_VAR 0 2
17771: PPUSH
17772: LD_VAR 0 3
17776: PPUSH
17777: CALL 18026 0 2
17781: NOT
17782: IFFALSE 17841
// repeat engine := _engine [ 1 ] ;
17784: LD_ADDR_VAR 0 3
17788: PUSH
17789: LD_VAR 0 11
17793: PUSH
17794: LD_INT 1
17796: ARRAY
17797: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17798: LD_ADDR_VAR 0 11
17802: PUSH
17803: LD_VAR 0 11
17807: PPUSH
17808: LD_INT 1
17810: PPUSH
17811: CALL_OW 3
17815: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17816: LD_VAR 0 2
17820: PPUSH
17821: LD_VAR 0 3
17825: PPUSH
17826: CALL 18026 0 2
17830: PUSH
17831: LD_VAR 0 11
17835: PUSH
17836: EMPTY
17837: EQUAL
17838: OR
17839: IFFALSE 17784
// if not control in _control then
17841: LD_VAR 0 4
17845: PUSH
17846: LD_VAR 0 12
17850: IN
17851: NOT
17852: IFFALSE 17878
// control := _control [ rand ( 1 , _control ) ] ;
17854: LD_ADDR_VAR 0 4
17858: PUSH
17859: LD_VAR 0 12
17863: PUSH
17864: LD_INT 1
17866: PPUSH
17867: LD_VAR 0 12
17871: PPUSH
17872: CALL_OW 12
17876: ARRAY
17877: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17878: LD_VAR 0 2
17882: PPUSH
17883: LD_VAR 0 5
17887: PPUSH
17888: CALL 18246 0 2
17892: NOT
17893: IFFALSE 17952
// repeat weapon := _weapon [ 1 ] ;
17895: LD_ADDR_VAR 0 5
17899: PUSH
17900: LD_VAR 0 10
17904: PUSH
17905: LD_INT 1
17907: ARRAY
17908: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17909: LD_ADDR_VAR 0 10
17913: PUSH
17914: LD_VAR 0 10
17918: PPUSH
17919: LD_INT 1
17921: PPUSH
17922: CALL_OW 3
17926: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17927: LD_VAR 0 2
17931: PPUSH
17932: LD_VAR 0 5
17936: PPUSH
17937: CALL 18246 0 2
17941: PUSH
17942: LD_VAR 0 10
17946: PUSH
17947: EMPTY
17948: EQUAL
17949: OR
17950: IFFALSE 17895
// result := [ ] ;
17952: LD_ADDR_VAR 0 6
17956: PUSH
17957: EMPTY
17958: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17959: LD_VAR 0 1
17963: PPUSH
17964: LD_VAR 0 2
17968: PPUSH
17969: LD_VAR 0 3
17973: PPUSH
17974: LD_VAR 0 4
17978: PPUSH
17979: LD_VAR 0 5
17983: PPUSH
17984: CALL_OW 448
17988: IFFALSE 18021
// result := [ chassis , engine , control , weapon ] ;
17990: LD_ADDR_VAR 0 6
17994: PUSH
17995: LD_VAR 0 2
17999: PUSH
18000: LD_VAR 0 3
18004: PUSH
18005: LD_VAR 0 4
18009: PUSH
18010: LD_VAR 0 5
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: ST_TO_ADDR
// end ;
18021: LD_VAR 0 6
18025: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18026: LD_INT 0
18028: PPUSH
// if not chassis or not engine then
18029: LD_VAR 0 1
18033: NOT
18034: PUSH
18035: LD_VAR 0 2
18039: NOT
18040: OR
18041: IFFALSE 18045
// exit ;
18043: GO 18241
// case engine of engine_solar :
18045: LD_VAR 0 2
18049: PUSH
18050: LD_INT 2
18052: DOUBLE
18053: EQUAL
18054: IFTRUE 18058
18056: GO 18096
18058: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18059: LD_ADDR_VAR 0 3
18063: PUSH
18064: LD_INT 11
18066: PUSH
18067: LD_INT 12
18069: PUSH
18070: LD_INT 13
18072: PUSH
18073: LD_INT 14
18075: PUSH
18076: LD_INT 1
18078: PUSH
18079: LD_INT 2
18081: PUSH
18082: LD_INT 3
18084: PUSH
18085: EMPTY
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: LIST
18093: ST_TO_ADDR
18094: GO 18225
18096: LD_INT 1
18098: DOUBLE
18099: EQUAL
18100: IFTRUE 18104
18102: GO 18166
18104: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18105: LD_ADDR_VAR 0 3
18109: PUSH
18110: LD_INT 11
18112: PUSH
18113: LD_INT 12
18115: PUSH
18116: LD_INT 13
18118: PUSH
18119: LD_INT 14
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: LD_INT 2
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 4
18133: PUSH
18134: LD_INT 5
18136: PUSH
18137: LD_INT 21
18139: PUSH
18140: LD_INT 23
18142: PUSH
18143: LD_INT 22
18145: PUSH
18146: LD_INT 24
18148: PUSH
18149: EMPTY
18150: LIST
18151: LIST
18152: LIST
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: LIST
18160: LIST
18161: LIST
18162: LIST
18163: ST_TO_ADDR
18164: GO 18225
18166: LD_INT 3
18168: DOUBLE
18169: EQUAL
18170: IFTRUE 18174
18172: GO 18224
18174: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18175: LD_ADDR_VAR 0 3
18179: PUSH
18180: LD_INT 13
18182: PUSH
18183: LD_INT 14
18185: PUSH
18186: LD_INT 2
18188: PUSH
18189: LD_INT 3
18191: PUSH
18192: LD_INT 4
18194: PUSH
18195: LD_INT 5
18197: PUSH
18198: LD_INT 21
18200: PUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 23
18206: PUSH
18207: LD_INT 24
18209: PUSH
18210: EMPTY
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: ST_TO_ADDR
18222: GO 18225
18224: POP
// result := ( chassis in result ) ;
18225: LD_ADDR_VAR 0 3
18229: PUSH
18230: LD_VAR 0 1
18234: PUSH
18235: LD_VAR 0 3
18239: IN
18240: ST_TO_ADDR
// end ;
18241: LD_VAR 0 3
18245: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18246: LD_INT 0
18248: PPUSH
// if not chassis or not weapon then
18249: LD_VAR 0 1
18253: NOT
18254: PUSH
18255: LD_VAR 0 2
18259: NOT
18260: OR
18261: IFFALSE 18265
// exit ;
18263: GO 19325
// case weapon of us_machine_gun :
18265: LD_VAR 0 2
18269: PUSH
18270: LD_INT 2
18272: DOUBLE
18273: EQUAL
18274: IFTRUE 18278
18276: GO 18308
18278: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18279: LD_ADDR_VAR 0 3
18283: PUSH
18284: LD_INT 1
18286: PUSH
18287: LD_INT 2
18289: PUSH
18290: LD_INT 3
18292: PUSH
18293: LD_INT 4
18295: PUSH
18296: LD_INT 5
18298: PUSH
18299: EMPTY
18300: LIST
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: ST_TO_ADDR
18306: GO 19309
18308: LD_INT 3
18310: DOUBLE
18311: EQUAL
18312: IFTRUE 18316
18314: GO 18346
18316: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18317: LD_ADDR_VAR 0 3
18321: PUSH
18322: LD_INT 1
18324: PUSH
18325: LD_INT 2
18327: PUSH
18328: LD_INT 3
18330: PUSH
18331: LD_INT 4
18333: PUSH
18334: LD_INT 5
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: LIST
18343: ST_TO_ADDR
18344: GO 19309
18346: LD_INT 11
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18384
18354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18355: LD_ADDR_VAR 0 3
18359: PUSH
18360: LD_INT 1
18362: PUSH
18363: LD_INT 2
18365: PUSH
18366: LD_INT 3
18368: PUSH
18369: LD_INT 4
18371: PUSH
18372: LD_INT 5
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: LIST
18381: ST_TO_ADDR
18382: GO 19309
18384: LD_INT 4
18386: DOUBLE
18387: EQUAL
18388: IFTRUE 18392
18390: GO 18418
18392: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18393: LD_ADDR_VAR 0 3
18397: PUSH
18398: LD_INT 2
18400: PUSH
18401: LD_INT 3
18403: PUSH
18404: LD_INT 4
18406: PUSH
18407: LD_INT 5
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: ST_TO_ADDR
18416: GO 19309
18418: LD_INT 5
18420: DOUBLE
18421: EQUAL
18422: IFTRUE 18426
18424: GO 18452
18426: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18427: LD_ADDR_VAR 0 3
18431: PUSH
18432: LD_INT 2
18434: PUSH
18435: LD_INT 3
18437: PUSH
18438: LD_INT 4
18440: PUSH
18441: LD_INT 5
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 19309
18452: LD_INT 9
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18486
18460: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18461: LD_ADDR_VAR 0 3
18465: PUSH
18466: LD_INT 2
18468: PUSH
18469: LD_INT 3
18471: PUSH
18472: LD_INT 4
18474: PUSH
18475: LD_INT 5
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: ST_TO_ADDR
18484: GO 19309
18486: LD_INT 7
18488: DOUBLE
18489: EQUAL
18490: IFTRUE 18494
18492: GO 18520
18494: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18495: LD_ADDR_VAR 0 3
18499: PUSH
18500: LD_INT 2
18502: PUSH
18503: LD_INT 3
18505: PUSH
18506: LD_INT 4
18508: PUSH
18509: LD_INT 5
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: LIST
18516: LIST
18517: ST_TO_ADDR
18518: GO 19309
18520: LD_INT 12
18522: DOUBLE
18523: EQUAL
18524: IFTRUE 18528
18526: GO 18554
18528: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18529: LD_ADDR_VAR 0 3
18533: PUSH
18534: LD_INT 2
18536: PUSH
18537: LD_INT 3
18539: PUSH
18540: LD_INT 4
18542: PUSH
18543: LD_INT 5
18545: PUSH
18546: EMPTY
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: ST_TO_ADDR
18552: GO 19309
18554: LD_INT 13
18556: DOUBLE
18557: EQUAL
18558: IFTRUE 18562
18560: GO 18588
18562: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18563: LD_ADDR_VAR 0 3
18567: PUSH
18568: LD_INT 2
18570: PUSH
18571: LD_INT 3
18573: PUSH
18574: LD_INT 4
18576: PUSH
18577: LD_INT 5
18579: PUSH
18580: EMPTY
18581: LIST
18582: LIST
18583: LIST
18584: LIST
18585: ST_TO_ADDR
18586: GO 19309
18588: LD_INT 14
18590: DOUBLE
18591: EQUAL
18592: IFTRUE 18596
18594: GO 18614
18596: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18597: LD_ADDR_VAR 0 3
18601: PUSH
18602: LD_INT 4
18604: PUSH
18605: LD_INT 5
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: ST_TO_ADDR
18612: GO 19309
18614: LD_INT 6
18616: DOUBLE
18617: EQUAL
18618: IFTRUE 18622
18620: GO 18640
18622: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18623: LD_ADDR_VAR 0 3
18627: PUSH
18628: LD_INT 4
18630: PUSH
18631: LD_INT 5
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: ST_TO_ADDR
18638: GO 19309
18640: LD_INT 10
18642: DOUBLE
18643: EQUAL
18644: IFTRUE 18648
18646: GO 18666
18648: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18649: LD_ADDR_VAR 0 3
18653: PUSH
18654: LD_INT 4
18656: PUSH
18657: LD_INT 5
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: ST_TO_ADDR
18664: GO 19309
18666: LD_INT 22
18668: DOUBLE
18669: EQUAL
18670: IFTRUE 18674
18672: GO 18700
18674: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18675: LD_ADDR_VAR 0 3
18679: PUSH
18680: LD_INT 11
18682: PUSH
18683: LD_INT 12
18685: PUSH
18686: LD_INT 13
18688: PUSH
18689: LD_INT 14
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: ST_TO_ADDR
18698: GO 19309
18700: LD_INT 23
18702: DOUBLE
18703: EQUAL
18704: IFTRUE 18708
18706: GO 18734
18708: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18709: LD_ADDR_VAR 0 3
18713: PUSH
18714: LD_INT 11
18716: PUSH
18717: LD_INT 12
18719: PUSH
18720: LD_INT 13
18722: PUSH
18723: LD_INT 14
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: ST_TO_ADDR
18732: GO 19309
18734: LD_INT 24
18736: DOUBLE
18737: EQUAL
18738: IFTRUE 18742
18740: GO 18768
18742: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18743: LD_ADDR_VAR 0 3
18747: PUSH
18748: LD_INT 11
18750: PUSH
18751: LD_INT 12
18753: PUSH
18754: LD_INT 13
18756: PUSH
18757: LD_INT 14
18759: PUSH
18760: EMPTY
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: ST_TO_ADDR
18766: GO 19309
18768: LD_INT 30
18770: DOUBLE
18771: EQUAL
18772: IFTRUE 18776
18774: GO 18802
18776: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18777: LD_ADDR_VAR 0 3
18781: PUSH
18782: LD_INT 11
18784: PUSH
18785: LD_INT 12
18787: PUSH
18788: LD_INT 13
18790: PUSH
18791: LD_INT 14
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: ST_TO_ADDR
18800: GO 19309
18802: LD_INT 25
18804: DOUBLE
18805: EQUAL
18806: IFTRUE 18810
18808: GO 18828
18810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18811: LD_ADDR_VAR 0 3
18815: PUSH
18816: LD_INT 13
18818: PUSH
18819: LD_INT 14
18821: PUSH
18822: EMPTY
18823: LIST
18824: LIST
18825: ST_TO_ADDR
18826: GO 19309
18828: LD_INT 27
18830: DOUBLE
18831: EQUAL
18832: IFTRUE 18836
18834: GO 18854
18836: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18837: LD_ADDR_VAR 0 3
18841: PUSH
18842: LD_INT 13
18844: PUSH
18845: LD_INT 14
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: ST_TO_ADDR
18852: GO 19309
18854: LD_INT 92
18856: DOUBLE
18857: EQUAL
18858: IFTRUE 18862
18860: GO 18888
18862: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18863: LD_ADDR_VAR 0 3
18867: PUSH
18868: LD_INT 11
18870: PUSH
18871: LD_INT 12
18873: PUSH
18874: LD_INT 13
18876: PUSH
18877: LD_INT 14
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: LIST
18884: LIST
18885: ST_TO_ADDR
18886: GO 19309
18888: LD_INT 28
18890: DOUBLE
18891: EQUAL
18892: IFTRUE 18896
18894: GO 18914
18896: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18897: LD_ADDR_VAR 0 3
18901: PUSH
18902: LD_INT 13
18904: PUSH
18905: LD_INT 14
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: ST_TO_ADDR
18912: GO 19309
18914: LD_INT 29
18916: DOUBLE
18917: EQUAL
18918: IFTRUE 18922
18920: GO 18940
18922: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18923: LD_ADDR_VAR 0 3
18927: PUSH
18928: LD_INT 13
18930: PUSH
18931: LD_INT 14
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: ST_TO_ADDR
18938: GO 19309
18940: LD_INT 31
18942: DOUBLE
18943: EQUAL
18944: IFTRUE 18948
18946: GO 18966
18948: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18949: LD_ADDR_VAR 0 3
18953: PUSH
18954: LD_INT 13
18956: PUSH
18957: LD_INT 14
18959: PUSH
18960: EMPTY
18961: LIST
18962: LIST
18963: ST_TO_ADDR
18964: GO 19309
18966: LD_INT 26
18968: DOUBLE
18969: EQUAL
18970: IFTRUE 18974
18972: GO 18992
18974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18975: LD_ADDR_VAR 0 3
18979: PUSH
18980: LD_INT 13
18982: PUSH
18983: LD_INT 14
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: ST_TO_ADDR
18990: GO 19309
18992: LD_INT 42
18994: DOUBLE
18995: EQUAL
18996: IFTRUE 19000
18998: GO 19026
19000: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19001: LD_ADDR_VAR 0 3
19005: PUSH
19006: LD_INT 21
19008: PUSH
19009: LD_INT 22
19011: PUSH
19012: LD_INT 23
19014: PUSH
19015: LD_INT 24
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: LIST
19023: ST_TO_ADDR
19024: GO 19309
19026: LD_INT 43
19028: DOUBLE
19029: EQUAL
19030: IFTRUE 19034
19032: GO 19060
19034: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19035: LD_ADDR_VAR 0 3
19039: PUSH
19040: LD_INT 21
19042: PUSH
19043: LD_INT 22
19045: PUSH
19046: LD_INT 23
19048: PUSH
19049: LD_INT 24
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: LIST
19056: LIST
19057: ST_TO_ADDR
19058: GO 19309
19060: LD_INT 44
19062: DOUBLE
19063: EQUAL
19064: IFTRUE 19068
19066: GO 19094
19068: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19069: LD_ADDR_VAR 0 3
19073: PUSH
19074: LD_INT 21
19076: PUSH
19077: LD_INT 22
19079: PUSH
19080: LD_INT 23
19082: PUSH
19083: LD_INT 24
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: ST_TO_ADDR
19092: GO 19309
19094: LD_INT 45
19096: DOUBLE
19097: EQUAL
19098: IFTRUE 19102
19100: GO 19128
19102: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19103: LD_ADDR_VAR 0 3
19107: PUSH
19108: LD_INT 21
19110: PUSH
19111: LD_INT 22
19113: PUSH
19114: LD_INT 23
19116: PUSH
19117: LD_INT 24
19119: PUSH
19120: EMPTY
19121: LIST
19122: LIST
19123: LIST
19124: LIST
19125: ST_TO_ADDR
19126: GO 19309
19128: LD_INT 49
19130: DOUBLE
19131: EQUAL
19132: IFTRUE 19136
19134: GO 19162
19136: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19137: LD_ADDR_VAR 0 3
19141: PUSH
19142: LD_INT 21
19144: PUSH
19145: LD_INT 22
19147: PUSH
19148: LD_INT 23
19150: PUSH
19151: LD_INT 24
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: ST_TO_ADDR
19160: GO 19309
19162: LD_INT 51
19164: DOUBLE
19165: EQUAL
19166: IFTRUE 19170
19168: GO 19196
19170: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19171: LD_ADDR_VAR 0 3
19175: PUSH
19176: LD_INT 21
19178: PUSH
19179: LD_INT 22
19181: PUSH
19182: LD_INT 23
19184: PUSH
19185: LD_INT 24
19187: PUSH
19188: EMPTY
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: ST_TO_ADDR
19194: GO 19309
19196: LD_INT 52
19198: DOUBLE
19199: EQUAL
19200: IFTRUE 19204
19202: GO 19230
19204: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19205: LD_ADDR_VAR 0 3
19209: PUSH
19210: LD_INT 21
19212: PUSH
19213: LD_INT 22
19215: PUSH
19216: LD_INT 23
19218: PUSH
19219: LD_INT 24
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: LIST
19226: LIST
19227: ST_TO_ADDR
19228: GO 19309
19230: LD_INT 53
19232: DOUBLE
19233: EQUAL
19234: IFTRUE 19238
19236: GO 19256
19238: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19239: LD_ADDR_VAR 0 3
19243: PUSH
19244: LD_INT 23
19246: PUSH
19247: LD_INT 24
19249: PUSH
19250: EMPTY
19251: LIST
19252: LIST
19253: ST_TO_ADDR
19254: GO 19309
19256: LD_INT 46
19258: DOUBLE
19259: EQUAL
19260: IFTRUE 19264
19262: GO 19282
19264: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19265: LD_ADDR_VAR 0 3
19269: PUSH
19270: LD_INT 23
19272: PUSH
19273: LD_INT 24
19275: PUSH
19276: EMPTY
19277: LIST
19278: LIST
19279: ST_TO_ADDR
19280: GO 19309
19282: LD_INT 47
19284: DOUBLE
19285: EQUAL
19286: IFTRUE 19290
19288: GO 19308
19290: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19291: LD_ADDR_VAR 0 3
19295: PUSH
19296: LD_INT 23
19298: PUSH
19299: LD_INT 24
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: ST_TO_ADDR
19306: GO 19309
19308: POP
// result := ( chassis in result ) ;
19309: LD_ADDR_VAR 0 3
19313: PUSH
19314: LD_VAR 0 1
19318: PUSH
19319: LD_VAR 0 3
19323: IN
19324: ST_TO_ADDR
// end ;
19325: LD_VAR 0 3
19329: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19330: LD_INT 0
19332: PPUSH
19333: PPUSH
19334: PPUSH
19335: PPUSH
19336: PPUSH
19337: PPUSH
19338: PPUSH
// result := array ;
19339: LD_ADDR_VAR 0 5
19343: PUSH
19344: LD_VAR 0 1
19348: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19349: LD_VAR 0 1
19353: NOT
19354: PUSH
19355: LD_VAR 0 2
19359: NOT
19360: OR
19361: PUSH
19362: LD_VAR 0 3
19366: NOT
19367: OR
19368: PUSH
19369: LD_VAR 0 2
19373: PUSH
19374: LD_VAR 0 1
19378: GREATER
19379: OR
19380: PUSH
19381: LD_VAR 0 3
19385: PUSH
19386: LD_VAR 0 1
19390: GREATER
19391: OR
19392: IFFALSE 19396
// exit ;
19394: GO 19692
// if direction then
19396: LD_VAR 0 4
19400: IFFALSE 19464
// begin d := 1 ;
19402: LD_ADDR_VAR 0 9
19406: PUSH
19407: LD_INT 1
19409: ST_TO_ADDR
// if i_from > i_to then
19410: LD_VAR 0 2
19414: PUSH
19415: LD_VAR 0 3
19419: GREATER
19420: IFFALSE 19446
// length := ( array - i_from ) + i_to else
19422: LD_ADDR_VAR 0 11
19426: PUSH
19427: LD_VAR 0 1
19431: PUSH
19432: LD_VAR 0 2
19436: MINUS
19437: PUSH
19438: LD_VAR 0 3
19442: PLUS
19443: ST_TO_ADDR
19444: GO 19462
// length := i_to - i_from ;
19446: LD_ADDR_VAR 0 11
19450: PUSH
19451: LD_VAR 0 3
19455: PUSH
19456: LD_VAR 0 2
19460: MINUS
19461: ST_TO_ADDR
// end else
19462: GO 19525
// begin d := - 1 ;
19464: LD_ADDR_VAR 0 9
19468: PUSH
19469: LD_INT 1
19471: NEG
19472: ST_TO_ADDR
// if i_from > i_to then
19473: LD_VAR 0 2
19477: PUSH
19478: LD_VAR 0 3
19482: GREATER
19483: IFFALSE 19503
// length := i_from - i_to else
19485: LD_ADDR_VAR 0 11
19489: PUSH
19490: LD_VAR 0 2
19494: PUSH
19495: LD_VAR 0 3
19499: MINUS
19500: ST_TO_ADDR
19501: GO 19525
// length := ( array - i_to ) + i_from ;
19503: LD_ADDR_VAR 0 11
19507: PUSH
19508: LD_VAR 0 1
19512: PUSH
19513: LD_VAR 0 3
19517: MINUS
19518: PUSH
19519: LD_VAR 0 2
19523: PLUS
19524: ST_TO_ADDR
// end ; if not length then
19525: LD_VAR 0 11
19529: NOT
19530: IFFALSE 19534
// exit ;
19532: GO 19692
// tmp := array ;
19534: LD_ADDR_VAR 0 10
19538: PUSH
19539: LD_VAR 0 1
19543: ST_TO_ADDR
// for i = 1 to length do
19544: LD_ADDR_VAR 0 6
19548: PUSH
19549: DOUBLE
19550: LD_INT 1
19552: DEC
19553: ST_TO_ADDR
19554: LD_VAR 0 11
19558: PUSH
19559: FOR_TO
19560: IFFALSE 19680
// begin for j = 1 to array do
19562: LD_ADDR_VAR 0 7
19566: PUSH
19567: DOUBLE
19568: LD_INT 1
19570: DEC
19571: ST_TO_ADDR
19572: LD_VAR 0 1
19576: PUSH
19577: FOR_TO
19578: IFFALSE 19666
// begin k := j + d ;
19580: LD_ADDR_VAR 0 8
19584: PUSH
19585: LD_VAR 0 7
19589: PUSH
19590: LD_VAR 0 9
19594: PLUS
19595: ST_TO_ADDR
// if k > array then
19596: LD_VAR 0 8
19600: PUSH
19601: LD_VAR 0 1
19605: GREATER
19606: IFFALSE 19616
// k := 1 ;
19608: LD_ADDR_VAR 0 8
19612: PUSH
19613: LD_INT 1
19615: ST_TO_ADDR
// if not k then
19616: LD_VAR 0 8
19620: NOT
19621: IFFALSE 19633
// k := array ;
19623: LD_ADDR_VAR 0 8
19627: PUSH
19628: LD_VAR 0 1
19632: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19633: LD_ADDR_VAR 0 10
19637: PUSH
19638: LD_VAR 0 10
19642: PPUSH
19643: LD_VAR 0 8
19647: PPUSH
19648: LD_VAR 0 1
19652: PUSH
19653: LD_VAR 0 7
19657: ARRAY
19658: PPUSH
19659: CALL_OW 1
19663: ST_TO_ADDR
// end ;
19664: GO 19577
19666: POP
19667: POP
// array := tmp ;
19668: LD_ADDR_VAR 0 1
19672: PUSH
19673: LD_VAR 0 10
19677: ST_TO_ADDR
// end ;
19678: GO 19559
19680: POP
19681: POP
// result := array ;
19682: LD_ADDR_VAR 0 5
19686: PUSH
19687: LD_VAR 0 1
19691: ST_TO_ADDR
// end ;
19692: LD_VAR 0 5
19696: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19697: LD_INT 0
19699: PPUSH
19700: PPUSH
// result := 0 ;
19701: LD_ADDR_VAR 0 3
19705: PUSH
19706: LD_INT 0
19708: ST_TO_ADDR
// if not array or not value in array then
19709: LD_VAR 0 1
19713: NOT
19714: PUSH
19715: LD_VAR 0 2
19719: PUSH
19720: LD_VAR 0 1
19724: IN
19725: NOT
19726: OR
19727: IFFALSE 19731
// exit ;
19729: GO 19785
// for i = 1 to array do
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: DOUBLE
19737: LD_INT 1
19739: DEC
19740: ST_TO_ADDR
19741: LD_VAR 0 1
19745: PUSH
19746: FOR_TO
19747: IFFALSE 19783
// if value = array [ i ] then
19749: LD_VAR 0 2
19753: PUSH
19754: LD_VAR 0 1
19758: PUSH
19759: LD_VAR 0 4
19763: ARRAY
19764: EQUAL
19765: IFFALSE 19781
// begin result := i ;
19767: LD_ADDR_VAR 0 3
19771: PUSH
19772: LD_VAR 0 4
19776: ST_TO_ADDR
// exit ;
19777: POP
19778: POP
19779: GO 19785
// end ;
19781: GO 19746
19783: POP
19784: POP
// end ;
19785: LD_VAR 0 3
19789: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19790: LD_INT 0
19792: PPUSH
// vc_chassis := chassis ;
19793: LD_ADDR_OWVAR 37
19797: PUSH
19798: LD_VAR 0 1
19802: ST_TO_ADDR
// vc_engine := engine ;
19803: LD_ADDR_OWVAR 39
19807: PUSH
19808: LD_VAR 0 2
19812: ST_TO_ADDR
// vc_control := control ;
19813: LD_ADDR_OWVAR 38
19817: PUSH
19818: LD_VAR 0 3
19822: ST_TO_ADDR
// vc_weapon := weapon ;
19823: LD_ADDR_OWVAR 40
19827: PUSH
19828: LD_VAR 0 4
19832: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19833: LD_ADDR_OWVAR 41
19837: PUSH
19838: LD_VAR 0 5
19842: ST_TO_ADDR
// end ;
19843: LD_VAR 0 6
19847: RET
// export function WantPlant ( unit ) ; var task ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
// result := false ;
19852: LD_ADDR_VAR 0 2
19856: PUSH
19857: LD_INT 0
19859: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19860: LD_ADDR_VAR 0 3
19864: PUSH
19865: LD_VAR 0 1
19869: PPUSH
19870: CALL_OW 437
19874: ST_TO_ADDR
// if task then
19875: LD_VAR 0 3
19879: IFFALSE 19907
// if task [ 1 ] [ 1 ] = p then
19881: LD_VAR 0 3
19885: PUSH
19886: LD_INT 1
19888: ARRAY
19889: PUSH
19890: LD_INT 1
19892: ARRAY
19893: PUSH
19894: LD_STRING p
19896: EQUAL
19897: IFFALSE 19907
// result := true ;
19899: LD_ADDR_VAR 0 2
19903: PUSH
19904: LD_INT 1
19906: ST_TO_ADDR
// end ;
19907: LD_VAR 0 2
19911: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19912: LD_INT 0
19914: PPUSH
19915: PPUSH
19916: PPUSH
19917: PPUSH
// if pos < 1 then
19918: LD_VAR 0 2
19922: PUSH
19923: LD_INT 1
19925: LESS
19926: IFFALSE 19930
// exit ;
19928: GO 20233
// if pos = 1 then
19930: LD_VAR 0 2
19934: PUSH
19935: LD_INT 1
19937: EQUAL
19938: IFFALSE 19971
// result := Replace ( arr , pos [ 1 ] , value ) else
19940: LD_ADDR_VAR 0 4
19944: PUSH
19945: LD_VAR 0 1
19949: PPUSH
19950: LD_VAR 0 2
19954: PUSH
19955: LD_INT 1
19957: ARRAY
19958: PPUSH
19959: LD_VAR 0 3
19963: PPUSH
19964: CALL_OW 1
19968: ST_TO_ADDR
19969: GO 20233
// begin tmp := arr ;
19971: LD_ADDR_VAR 0 6
19975: PUSH
19976: LD_VAR 0 1
19980: ST_TO_ADDR
// s_arr := [ tmp ] ;
19981: LD_ADDR_VAR 0 7
19985: PUSH
19986: LD_VAR 0 6
19990: PUSH
19991: EMPTY
19992: LIST
19993: ST_TO_ADDR
// for i = 1 to pos - 1 do
19994: LD_ADDR_VAR 0 5
19998: PUSH
19999: DOUBLE
20000: LD_INT 1
20002: DEC
20003: ST_TO_ADDR
20004: LD_VAR 0 2
20008: PUSH
20009: LD_INT 1
20011: MINUS
20012: PUSH
20013: FOR_TO
20014: IFFALSE 20059
// begin tmp := tmp [ pos [ i ] ] ;
20016: LD_ADDR_VAR 0 6
20020: PUSH
20021: LD_VAR 0 6
20025: PUSH
20026: LD_VAR 0 2
20030: PUSH
20031: LD_VAR 0 5
20035: ARRAY
20036: ARRAY
20037: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20038: LD_ADDR_VAR 0 7
20042: PUSH
20043: LD_VAR 0 7
20047: PUSH
20048: LD_VAR 0 6
20052: PUSH
20053: EMPTY
20054: LIST
20055: ADD
20056: ST_TO_ADDR
// end ;
20057: GO 20013
20059: POP
20060: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20061: LD_ADDR_VAR 0 6
20065: PUSH
20066: LD_VAR 0 6
20070: PPUSH
20071: LD_VAR 0 2
20075: PUSH
20076: LD_VAR 0 2
20080: ARRAY
20081: PPUSH
20082: LD_VAR 0 3
20086: PPUSH
20087: CALL_OW 1
20091: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20092: LD_ADDR_VAR 0 7
20096: PUSH
20097: LD_VAR 0 7
20101: PPUSH
20102: LD_VAR 0 7
20106: PPUSH
20107: LD_VAR 0 6
20111: PPUSH
20112: CALL_OW 1
20116: ST_TO_ADDR
// for i = s_arr downto 2 do
20117: LD_ADDR_VAR 0 5
20121: PUSH
20122: DOUBLE
20123: LD_VAR 0 7
20127: INC
20128: ST_TO_ADDR
20129: LD_INT 2
20131: PUSH
20132: FOR_DOWNTO
20133: IFFALSE 20217
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20135: LD_ADDR_VAR 0 6
20139: PUSH
20140: LD_VAR 0 7
20144: PUSH
20145: LD_VAR 0 5
20149: PUSH
20150: LD_INT 1
20152: MINUS
20153: ARRAY
20154: PPUSH
20155: LD_VAR 0 2
20159: PUSH
20160: LD_VAR 0 5
20164: PUSH
20165: LD_INT 1
20167: MINUS
20168: ARRAY
20169: PPUSH
20170: LD_VAR 0 7
20174: PUSH
20175: LD_VAR 0 5
20179: ARRAY
20180: PPUSH
20181: CALL_OW 1
20185: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20186: LD_ADDR_VAR 0 7
20190: PUSH
20191: LD_VAR 0 7
20195: PPUSH
20196: LD_VAR 0 5
20200: PUSH
20201: LD_INT 1
20203: MINUS
20204: PPUSH
20205: LD_VAR 0 6
20209: PPUSH
20210: CALL_OW 1
20214: ST_TO_ADDR
// end ;
20215: GO 20132
20217: POP
20218: POP
// result := s_arr [ 1 ] ;
20219: LD_ADDR_VAR 0 4
20223: PUSH
20224: LD_VAR 0 7
20228: PUSH
20229: LD_INT 1
20231: ARRAY
20232: ST_TO_ADDR
// end ; end ;
20233: LD_VAR 0 4
20237: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20238: LD_INT 0
20240: PPUSH
20241: PPUSH
// if not list then
20242: LD_VAR 0 1
20246: NOT
20247: IFFALSE 20251
// exit ;
20249: GO 20342
// i := list [ pos1 ] ;
20251: LD_ADDR_VAR 0 5
20255: PUSH
20256: LD_VAR 0 1
20260: PUSH
20261: LD_VAR 0 2
20265: ARRAY
20266: ST_TO_ADDR
// if not i then
20267: LD_VAR 0 5
20271: NOT
20272: IFFALSE 20276
// exit ;
20274: GO 20342
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20276: LD_ADDR_VAR 0 1
20280: PUSH
20281: LD_VAR 0 1
20285: PPUSH
20286: LD_VAR 0 2
20290: PPUSH
20291: LD_VAR 0 1
20295: PUSH
20296: LD_VAR 0 3
20300: ARRAY
20301: PPUSH
20302: CALL_OW 1
20306: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20307: LD_ADDR_VAR 0 1
20311: PUSH
20312: LD_VAR 0 1
20316: PPUSH
20317: LD_VAR 0 3
20321: PPUSH
20322: LD_VAR 0 5
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// result := list ;
20332: LD_ADDR_VAR 0 4
20336: PUSH
20337: LD_VAR 0 1
20341: ST_TO_ADDR
// end ;
20342: LD_VAR 0 4
20346: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20347: LD_INT 0
20349: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20350: LD_ADDR_VAR 0 5
20354: PUSH
20355: LD_VAR 0 1
20359: PPUSH
20360: CALL_OW 250
20364: PPUSH
20365: LD_VAR 0 1
20369: PPUSH
20370: CALL_OW 251
20374: PPUSH
20375: LD_VAR 0 2
20379: PPUSH
20380: LD_VAR 0 3
20384: PPUSH
20385: LD_VAR 0 4
20389: PPUSH
20390: CALL 20400 0 5
20394: ST_TO_ADDR
// end ;
20395: LD_VAR 0 5
20399: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20400: LD_INT 0
20402: PPUSH
20403: PPUSH
20404: PPUSH
20405: PPUSH
// if not list then
20406: LD_VAR 0 3
20410: NOT
20411: IFFALSE 20415
// exit ;
20413: GO 20803
// result := [ ] ;
20415: LD_ADDR_VAR 0 6
20419: PUSH
20420: EMPTY
20421: ST_TO_ADDR
// for i in list do
20422: LD_ADDR_VAR 0 7
20426: PUSH
20427: LD_VAR 0 3
20431: PUSH
20432: FOR_IN
20433: IFFALSE 20635
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20435: LD_ADDR_VAR 0 9
20439: PUSH
20440: LD_VAR 0 7
20444: PPUSH
20445: LD_VAR 0 1
20449: PPUSH
20450: LD_VAR 0 2
20454: PPUSH
20455: CALL_OW 297
20459: ST_TO_ADDR
// if not result then
20460: LD_VAR 0 6
20464: NOT
20465: IFFALSE 20491
// result := [ [ i , tmp ] ] else
20467: LD_ADDR_VAR 0 6
20471: PUSH
20472: LD_VAR 0 7
20476: PUSH
20477: LD_VAR 0 9
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: PUSH
20486: EMPTY
20487: LIST
20488: ST_TO_ADDR
20489: GO 20633
// begin if result [ result ] [ 2 ] < tmp then
20491: LD_VAR 0 6
20495: PUSH
20496: LD_VAR 0 6
20500: ARRAY
20501: PUSH
20502: LD_INT 2
20504: ARRAY
20505: PUSH
20506: LD_VAR 0 9
20510: LESS
20511: IFFALSE 20553
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20513: LD_ADDR_VAR 0 6
20517: PUSH
20518: LD_VAR 0 6
20522: PPUSH
20523: LD_VAR 0 6
20527: PUSH
20528: LD_INT 1
20530: PLUS
20531: PPUSH
20532: LD_VAR 0 7
20536: PUSH
20537: LD_VAR 0 9
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: PPUSH
20546: CALL_OW 2
20550: ST_TO_ADDR
20551: GO 20633
// for j = 1 to result do
20553: LD_ADDR_VAR 0 8
20557: PUSH
20558: DOUBLE
20559: LD_INT 1
20561: DEC
20562: ST_TO_ADDR
20563: LD_VAR 0 6
20567: PUSH
20568: FOR_TO
20569: IFFALSE 20631
// begin if tmp < result [ j ] [ 2 ] then
20571: LD_VAR 0 9
20575: PUSH
20576: LD_VAR 0 6
20580: PUSH
20581: LD_VAR 0 8
20585: ARRAY
20586: PUSH
20587: LD_INT 2
20589: ARRAY
20590: LESS
20591: IFFALSE 20629
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20593: LD_ADDR_VAR 0 6
20597: PUSH
20598: LD_VAR 0 6
20602: PPUSH
20603: LD_VAR 0 8
20607: PPUSH
20608: LD_VAR 0 7
20612: PUSH
20613: LD_VAR 0 9
20617: PUSH
20618: EMPTY
20619: LIST
20620: LIST
20621: PPUSH
20622: CALL_OW 2
20626: ST_TO_ADDR
// break ;
20627: GO 20631
// end ; end ;
20629: GO 20568
20631: POP
20632: POP
// end ; end ;
20633: GO 20432
20635: POP
20636: POP
// if result and not asc then
20637: LD_VAR 0 6
20641: PUSH
20642: LD_VAR 0 4
20646: NOT
20647: AND
20648: IFFALSE 20723
// begin tmp := result ;
20650: LD_ADDR_VAR 0 9
20654: PUSH
20655: LD_VAR 0 6
20659: ST_TO_ADDR
// for i = tmp downto 1 do
20660: LD_ADDR_VAR 0 7
20664: PUSH
20665: DOUBLE
20666: LD_VAR 0 9
20670: INC
20671: ST_TO_ADDR
20672: LD_INT 1
20674: PUSH
20675: FOR_DOWNTO
20676: IFFALSE 20721
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20678: LD_ADDR_VAR 0 6
20682: PUSH
20683: LD_VAR 0 6
20687: PPUSH
20688: LD_VAR 0 9
20692: PUSH
20693: LD_VAR 0 7
20697: MINUS
20698: PUSH
20699: LD_INT 1
20701: PLUS
20702: PPUSH
20703: LD_VAR 0 9
20707: PUSH
20708: LD_VAR 0 7
20712: ARRAY
20713: PPUSH
20714: CALL_OW 1
20718: ST_TO_ADDR
20719: GO 20675
20721: POP
20722: POP
// end ; tmp := [ ] ;
20723: LD_ADDR_VAR 0 9
20727: PUSH
20728: EMPTY
20729: ST_TO_ADDR
// if mode then
20730: LD_VAR 0 5
20734: IFFALSE 20803
// begin for i = 1 to result do
20736: LD_ADDR_VAR 0 7
20740: PUSH
20741: DOUBLE
20742: LD_INT 1
20744: DEC
20745: ST_TO_ADDR
20746: LD_VAR 0 6
20750: PUSH
20751: FOR_TO
20752: IFFALSE 20791
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20754: LD_ADDR_VAR 0 9
20758: PUSH
20759: LD_VAR 0 9
20763: PPUSH
20764: LD_VAR 0 7
20768: PPUSH
20769: LD_VAR 0 6
20773: PUSH
20774: LD_VAR 0 7
20778: ARRAY
20779: PUSH
20780: LD_INT 1
20782: ARRAY
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
20789: GO 20751
20791: POP
20792: POP
// result := tmp ;
20793: LD_ADDR_VAR 0 6
20797: PUSH
20798: LD_VAR 0 9
20802: ST_TO_ADDR
// end ; end ;
20803: LD_VAR 0 6
20807: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20808: LD_INT 0
20810: PPUSH
20811: PPUSH
20812: PPUSH
20813: PPUSH
20814: PPUSH
20815: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20816: LD_ADDR_VAR 0 5
20820: PUSH
20821: LD_INT 0
20823: PUSH
20824: LD_INT 0
20826: PUSH
20827: LD_INT 0
20829: PUSH
20830: EMPTY
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: LIST
20836: LIST
20837: ST_TO_ADDR
// if not x or not y then
20838: LD_VAR 0 2
20842: NOT
20843: PUSH
20844: LD_VAR 0 3
20848: NOT
20849: OR
20850: IFFALSE 20854
// exit ;
20852: GO 22504
// if not range then
20854: LD_VAR 0 4
20858: NOT
20859: IFFALSE 20869
// range := 10 ;
20861: LD_ADDR_VAR 0 4
20865: PUSH
20866: LD_INT 10
20868: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20869: LD_ADDR_VAR 0 8
20873: PUSH
20874: LD_INT 81
20876: PUSH
20877: LD_VAR 0 1
20881: PUSH
20882: EMPTY
20883: LIST
20884: LIST
20885: PUSH
20886: LD_INT 92
20888: PUSH
20889: LD_VAR 0 2
20893: PUSH
20894: LD_VAR 0 3
20898: PUSH
20899: LD_VAR 0 4
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: LIST
20908: LIST
20909: PUSH
20910: LD_INT 3
20912: PUSH
20913: LD_INT 21
20915: PUSH
20916: LD_INT 3
20918: PUSH
20919: EMPTY
20920: LIST
20921: LIST
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: LIST
20931: PPUSH
20932: CALL_OW 69
20936: ST_TO_ADDR
// if not tmp then
20937: LD_VAR 0 8
20941: NOT
20942: IFFALSE 20946
// exit ;
20944: GO 22504
// for i in tmp do
20946: LD_ADDR_VAR 0 6
20950: PUSH
20951: LD_VAR 0 8
20955: PUSH
20956: FOR_IN
20957: IFFALSE 22479
// begin points := [ 0 , 0 , 0 ] ;
20959: LD_ADDR_VAR 0 9
20963: PUSH
20964: LD_INT 0
20966: PUSH
20967: LD_INT 0
20969: PUSH
20970: LD_INT 0
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: LIST
20977: ST_TO_ADDR
// bpoints := 1 ;
20978: LD_ADDR_VAR 0 10
20982: PUSH
20983: LD_INT 1
20985: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20986: LD_VAR 0 6
20990: PPUSH
20991: CALL_OW 247
20995: PUSH
20996: LD_INT 1
20998: DOUBLE
20999: EQUAL
21000: IFTRUE 21004
21002: GO 21582
21004: POP
// begin if GetClass ( i ) = 1 then
21005: LD_VAR 0 6
21009: PPUSH
21010: CALL_OW 257
21014: PUSH
21015: LD_INT 1
21017: EQUAL
21018: IFFALSE 21039
// points := [ 10 , 5 , 3 ] ;
21020: LD_ADDR_VAR 0 9
21024: PUSH
21025: LD_INT 10
21027: PUSH
21028: LD_INT 5
21030: PUSH
21031: LD_INT 3
21033: PUSH
21034: EMPTY
21035: LIST
21036: LIST
21037: LIST
21038: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21039: LD_VAR 0 6
21043: PPUSH
21044: CALL_OW 257
21048: PUSH
21049: LD_INT 2
21051: PUSH
21052: LD_INT 3
21054: PUSH
21055: LD_INT 4
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: LIST
21062: IN
21063: IFFALSE 21084
// points := [ 3 , 2 , 1 ] ;
21065: LD_ADDR_VAR 0 9
21069: PUSH
21070: LD_INT 3
21072: PUSH
21073: LD_INT 2
21075: PUSH
21076: LD_INT 1
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: LIST
21083: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21084: LD_VAR 0 6
21088: PPUSH
21089: CALL_OW 257
21093: PUSH
21094: LD_INT 5
21096: EQUAL
21097: IFFALSE 21118
// points := [ 130 , 5 , 2 ] ;
21099: LD_ADDR_VAR 0 9
21103: PUSH
21104: LD_INT 130
21106: PUSH
21107: LD_INT 5
21109: PUSH
21110: LD_INT 2
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21118: LD_VAR 0 6
21122: PPUSH
21123: CALL_OW 257
21127: PUSH
21128: LD_INT 8
21130: EQUAL
21131: IFFALSE 21152
// points := [ 35 , 35 , 30 ] ;
21133: LD_ADDR_VAR 0 9
21137: PUSH
21138: LD_INT 35
21140: PUSH
21141: LD_INT 35
21143: PUSH
21144: LD_INT 30
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21152: LD_VAR 0 6
21156: PPUSH
21157: CALL_OW 257
21161: PUSH
21162: LD_INT 9
21164: EQUAL
21165: IFFALSE 21186
// points := [ 20 , 55 , 40 ] ;
21167: LD_ADDR_VAR 0 9
21171: PUSH
21172: LD_INT 20
21174: PUSH
21175: LD_INT 55
21177: PUSH
21178: LD_INT 40
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: LIST
21185: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21186: LD_VAR 0 6
21190: PPUSH
21191: CALL_OW 257
21195: PUSH
21196: LD_INT 12
21198: PUSH
21199: LD_INT 16
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: IN
21206: IFFALSE 21227
// points := [ 5 , 3 , 2 ] ;
21208: LD_ADDR_VAR 0 9
21212: PUSH
21213: LD_INT 5
21215: PUSH
21216: LD_INT 3
21218: PUSH
21219: LD_INT 2
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: LIST
21226: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21227: LD_VAR 0 6
21231: PPUSH
21232: CALL_OW 257
21236: PUSH
21237: LD_INT 17
21239: EQUAL
21240: IFFALSE 21261
// points := [ 100 , 50 , 75 ] ;
21242: LD_ADDR_VAR 0 9
21246: PUSH
21247: LD_INT 100
21249: PUSH
21250: LD_INT 50
21252: PUSH
21253: LD_INT 75
21255: PUSH
21256: EMPTY
21257: LIST
21258: LIST
21259: LIST
21260: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21261: LD_VAR 0 6
21265: PPUSH
21266: CALL_OW 257
21270: PUSH
21271: LD_INT 15
21273: EQUAL
21274: IFFALSE 21295
// points := [ 10 , 5 , 3 ] ;
21276: LD_ADDR_VAR 0 9
21280: PUSH
21281: LD_INT 10
21283: PUSH
21284: LD_INT 5
21286: PUSH
21287: LD_INT 3
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: LIST
21294: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21295: LD_VAR 0 6
21299: PPUSH
21300: CALL_OW 257
21304: PUSH
21305: LD_INT 14
21307: EQUAL
21308: IFFALSE 21329
// points := [ 10 , 0 , 0 ] ;
21310: LD_ADDR_VAR 0 9
21314: PUSH
21315: LD_INT 10
21317: PUSH
21318: LD_INT 0
21320: PUSH
21321: LD_INT 0
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21329: LD_VAR 0 6
21333: PPUSH
21334: CALL_OW 257
21338: PUSH
21339: LD_INT 11
21341: EQUAL
21342: IFFALSE 21363
// points := [ 30 , 10 , 5 ] ;
21344: LD_ADDR_VAR 0 9
21348: PUSH
21349: LD_INT 30
21351: PUSH
21352: LD_INT 10
21354: PUSH
21355: LD_INT 5
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: LIST
21362: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21363: LD_VAR 0 1
21367: PPUSH
21368: LD_INT 5
21370: PPUSH
21371: CALL_OW 321
21375: PUSH
21376: LD_INT 2
21378: EQUAL
21379: IFFALSE 21396
// bpoints := bpoints * 1.8 ;
21381: LD_ADDR_VAR 0 10
21385: PUSH
21386: LD_VAR 0 10
21390: PUSH
21391: LD_REAL  1.80000000000000E+0000
21394: MUL
21395: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21396: LD_VAR 0 6
21400: PPUSH
21401: CALL_OW 257
21405: PUSH
21406: LD_INT 1
21408: PUSH
21409: LD_INT 2
21411: PUSH
21412: LD_INT 3
21414: PUSH
21415: LD_INT 4
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: LIST
21422: LIST
21423: IN
21424: PUSH
21425: LD_VAR 0 1
21429: PPUSH
21430: LD_INT 51
21432: PPUSH
21433: CALL_OW 321
21437: PUSH
21438: LD_INT 2
21440: EQUAL
21441: AND
21442: IFFALSE 21459
// bpoints := bpoints * 1.2 ;
21444: LD_ADDR_VAR 0 10
21448: PUSH
21449: LD_VAR 0 10
21453: PUSH
21454: LD_REAL  1.20000000000000E+0000
21457: MUL
21458: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21459: LD_VAR 0 6
21463: PPUSH
21464: CALL_OW 257
21468: PUSH
21469: LD_INT 5
21471: PUSH
21472: LD_INT 7
21474: PUSH
21475: LD_INT 9
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: LIST
21482: IN
21483: PUSH
21484: LD_VAR 0 1
21488: PPUSH
21489: LD_INT 52
21491: PPUSH
21492: CALL_OW 321
21496: PUSH
21497: LD_INT 2
21499: EQUAL
21500: AND
21501: IFFALSE 21518
// bpoints := bpoints * 1.5 ;
21503: LD_ADDR_VAR 0 10
21507: PUSH
21508: LD_VAR 0 10
21512: PUSH
21513: LD_REAL  1.50000000000000E+0000
21516: MUL
21517: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21518: LD_VAR 0 1
21522: PPUSH
21523: LD_INT 66
21525: PPUSH
21526: CALL_OW 321
21530: PUSH
21531: LD_INT 2
21533: EQUAL
21534: IFFALSE 21551
// bpoints := bpoints * 1.1 ;
21536: LD_ADDR_VAR 0 10
21540: PUSH
21541: LD_VAR 0 10
21545: PUSH
21546: LD_REAL  1.10000000000000E+0000
21549: MUL
21550: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21551: LD_ADDR_VAR 0 10
21555: PUSH
21556: LD_VAR 0 10
21560: PUSH
21561: LD_VAR 0 6
21565: PPUSH
21566: LD_INT 1
21568: PPUSH
21569: CALL_OW 259
21573: PUSH
21574: LD_REAL  1.15000000000000E+0000
21577: MUL
21578: MUL
21579: ST_TO_ADDR
// end ; unit_vehicle :
21580: GO 22408
21582: LD_INT 2
21584: DOUBLE
21585: EQUAL
21586: IFTRUE 21590
21588: GO 22396
21590: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21591: LD_VAR 0 6
21595: PPUSH
21596: CALL_OW 264
21600: PUSH
21601: LD_INT 2
21603: PUSH
21604: LD_INT 42
21606: PUSH
21607: LD_INT 24
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: LIST
21614: IN
21615: IFFALSE 21636
// points := [ 25 , 5 , 3 ] ;
21617: LD_ADDR_VAR 0 9
21621: PUSH
21622: LD_INT 25
21624: PUSH
21625: LD_INT 5
21627: PUSH
21628: LD_INT 3
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: LIST
21635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21636: LD_VAR 0 6
21640: PPUSH
21641: CALL_OW 264
21645: PUSH
21646: LD_INT 4
21648: PUSH
21649: LD_INT 43
21651: PUSH
21652: LD_INT 25
21654: PUSH
21655: EMPTY
21656: LIST
21657: LIST
21658: LIST
21659: IN
21660: IFFALSE 21681
// points := [ 40 , 15 , 5 ] ;
21662: LD_ADDR_VAR 0 9
21666: PUSH
21667: LD_INT 40
21669: PUSH
21670: LD_INT 15
21672: PUSH
21673: LD_INT 5
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: LIST
21680: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21681: LD_VAR 0 6
21685: PPUSH
21686: CALL_OW 264
21690: PUSH
21691: LD_INT 3
21693: PUSH
21694: LD_INT 23
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: IN
21701: IFFALSE 21722
// points := [ 7 , 25 , 8 ] ;
21703: LD_ADDR_VAR 0 9
21707: PUSH
21708: LD_INT 7
21710: PUSH
21711: LD_INT 25
21713: PUSH
21714: LD_INT 8
21716: PUSH
21717: EMPTY
21718: LIST
21719: LIST
21720: LIST
21721: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21722: LD_VAR 0 6
21726: PPUSH
21727: CALL_OW 264
21731: PUSH
21732: LD_INT 5
21734: PUSH
21735: LD_INT 27
21737: PUSH
21738: LD_INT 44
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: LIST
21745: IN
21746: IFFALSE 21767
// points := [ 14 , 50 , 16 ] ;
21748: LD_ADDR_VAR 0 9
21752: PUSH
21753: LD_INT 14
21755: PUSH
21756: LD_INT 50
21758: PUSH
21759: LD_INT 16
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: LIST
21766: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21767: LD_VAR 0 6
21771: PPUSH
21772: CALL_OW 264
21776: PUSH
21777: LD_INT 6
21779: PUSH
21780: LD_INT 46
21782: PUSH
21783: EMPTY
21784: LIST
21785: LIST
21786: IN
21787: IFFALSE 21808
// points := [ 32 , 120 , 70 ] ;
21789: LD_ADDR_VAR 0 9
21793: PUSH
21794: LD_INT 32
21796: PUSH
21797: LD_INT 120
21799: PUSH
21800: LD_INT 70
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: LIST
21807: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21808: LD_VAR 0 6
21812: PPUSH
21813: CALL_OW 264
21817: PUSH
21818: LD_INT 7
21820: PUSH
21821: LD_INT 28
21823: PUSH
21824: LD_INT 45
21826: PUSH
21827: LD_INT 92
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: IN
21836: IFFALSE 21857
// points := [ 35 , 20 , 45 ] ;
21838: LD_ADDR_VAR 0 9
21842: PUSH
21843: LD_INT 35
21845: PUSH
21846: LD_INT 20
21848: PUSH
21849: LD_INT 45
21851: PUSH
21852: EMPTY
21853: LIST
21854: LIST
21855: LIST
21856: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21857: LD_VAR 0 6
21861: PPUSH
21862: CALL_OW 264
21866: PUSH
21867: LD_INT 47
21869: PUSH
21870: EMPTY
21871: LIST
21872: IN
21873: IFFALSE 21894
// points := [ 67 , 45 , 75 ] ;
21875: LD_ADDR_VAR 0 9
21879: PUSH
21880: LD_INT 67
21882: PUSH
21883: LD_INT 45
21885: PUSH
21886: LD_INT 75
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: LIST
21893: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21894: LD_VAR 0 6
21898: PPUSH
21899: CALL_OW 264
21903: PUSH
21904: LD_INT 26
21906: PUSH
21907: EMPTY
21908: LIST
21909: IN
21910: IFFALSE 21931
// points := [ 120 , 30 , 80 ] ;
21912: LD_ADDR_VAR 0 9
21916: PUSH
21917: LD_INT 120
21919: PUSH
21920: LD_INT 30
21922: PUSH
21923: LD_INT 80
21925: PUSH
21926: EMPTY
21927: LIST
21928: LIST
21929: LIST
21930: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21931: LD_VAR 0 6
21935: PPUSH
21936: CALL_OW 264
21940: PUSH
21941: LD_INT 22
21943: PUSH
21944: EMPTY
21945: LIST
21946: IN
21947: IFFALSE 21968
// points := [ 40 , 1 , 1 ] ;
21949: LD_ADDR_VAR 0 9
21953: PUSH
21954: LD_INT 40
21956: PUSH
21957: LD_INT 1
21959: PUSH
21960: LD_INT 1
21962: PUSH
21963: EMPTY
21964: LIST
21965: LIST
21966: LIST
21967: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21968: LD_VAR 0 6
21972: PPUSH
21973: CALL_OW 264
21977: PUSH
21978: LD_INT 29
21980: PUSH
21981: EMPTY
21982: LIST
21983: IN
21984: IFFALSE 22005
// points := [ 70 , 200 , 400 ] ;
21986: LD_ADDR_VAR 0 9
21990: PUSH
21991: LD_INT 70
21993: PUSH
21994: LD_INT 200
21996: PUSH
21997: LD_INT 400
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22005: LD_VAR 0 6
22009: PPUSH
22010: CALL_OW 264
22014: PUSH
22015: LD_INT 14
22017: PUSH
22018: LD_INT 53
22020: PUSH
22021: EMPTY
22022: LIST
22023: LIST
22024: IN
22025: IFFALSE 22046
// points := [ 40 , 10 , 20 ] ;
22027: LD_ADDR_VAR 0 9
22031: PUSH
22032: LD_INT 40
22034: PUSH
22035: LD_INT 10
22037: PUSH
22038: LD_INT 20
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: LIST
22045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22046: LD_VAR 0 6
22050: PPUSH
22051: CALL_OW 264
22055: PUSH
22056: LD_INT 9
22058: PUSH
22059: EMPTY
22060: LIST
22061: IN
22062: IFFALSE 22083
// points := [ 5 , 70 , 20 ] ;
22064: LD_ADDR_VAR 0 9
22068: PUSH
22069: LD_INT 5
22071: PUSH
22072: LD_INT 70
22074: PUSH
22075: LD_INT 20
22077: PUSH
22078: EMPTY
22079: LIST
22080: LIST
22081: LIST
22082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22083: LD_VAR 0 6
22087: PPUSH
22088: CALL_OW 264
22092: PUSH
22093: LD_INT 10
22095: PUSH
22096: EMPTY
22097: LIST
22098: IN
22099: IFFALSE 22120
// points := [ 35 , 110 , 70 ] ;
22101: LD_ADDR_VAR 0 9
22105: PUSH
22106: LD_INT 35
22108: PUSH
22109: LD_INT 110
22111: PUSH
22112: LD_INT 70
22114: PUSH
22115: EMPTY
22116: LIST
22117: LIST
22118: LIST
22119: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22120: LD_VAR 0 6
22124: PPUSH
22125: CALL_OW 265
22129: PUSH
22130: LD_INT 25
22132: EQUAL
22133: IFFALSE 22154
// points := [ 80 , 65 , 100 ] ;
22135: LD_ADDR_VAR 0 9
22139: PUSH
22140: LD_INT 80
22142: PUSH
22143: LD_INT 65
22145: PUSH
22146: LD_INT 100
22148: PUSH
22149: EMPTY
22150: LIST
22151: LIST
22152: LIST
22153: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22154: LD_VAR 0 6
22158: PPUSH
22159: CALL_OW 263
22163: PUSH
22164: LD_INT 1
22166: EQUAL
22167: IFFALSE 22202
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22169: LD_ADDR_VAR 0 10
22173: PUSH
22174: LD_VAR 0 10
22178: PUSH
22179: LD_VAR 0 6
22183: PPUSH
22184: CALL_OW 311
22188: PPUSH
22189: LD_INT 3
22191: PPUSH
22192: CALL_OW 259
22196: PUSH
22197: LD_INT 4
22199: MUL
22200: MUL
22201: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22202: LD_VAR 0 6
22206: PPUSH
22207: CALL_OW 263
22211: PUSH
22212: LD_INT 2
22214: EQUAL
22215: IFFALSE 22266
// begin j := IsControledBy ( i ) ;
22217: LD_ADDR_VAR 0 7
22221: PUSH
22222: LD_VAR 0 6
22226: PPUSH
22227: CALL_OW 312
22231: ST_TO_ADDR
// if j then
22232: LD_VAR 0 7
22236: IFFALSE 22266
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22238: LD_ADDR_VAR 0 10
22242: PUSH
22243: LD_VAR 0 10
22247: PUSH
22248: LD_VAR 0 7
22252: PPUSH
22253: LD_INT 3
22255: PPUSH
22256: CALL_OW 259
22260: PUSH
22261: LD_INT 3
22263: MUL
22264: MUL
22265: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22266: LD_VAR 0 6
22270: PPUSH
22271: CALL_OW 264
22275: PUSH
22276: LD_INT 5
22278: PUSH
22279: LD_INT 6
22281: PUSH
22282: LD_INT 46
22284: PUSH
22285: LD_INT 44
22287: PUSH
22288: LD_INT 47
22290: PUSH
22291: LD_INT 45
22293: PUSH
22294: LD_INT 28
22296: PUSH
22297: LD_INT 7
22299: PUSH
22300: LD_INT 27
22302: PUSH
22303: LD_INT 29
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: LIST
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: LIST
22317: IN
22318: PUSH
22319: LD_VAR 0 1
22323: PPUSH
22324: LD_INT 52
22326: PPUSH
22327: CALL_OW 321
22331: PUSH
22332: LD_INT 2
22334: EQUAL
22335: AND
22336: IFFALSE 22353
// bpoints := bpoints * 1.2 ;
22338: LD_ADDR_VAR 0 10
22342: PUSH
22343: LD_VAR 0 10
22347: PUSH
22348: LD_REAL  1.20000000000000E+0000
22351: MUL
22352: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22353: LD_VAR 0 6
22357: PPUSH
22358: CALL_OW 264
22362: PUSH
22363: LD_INT 6
22365: PUSH
22366: LD_INT 46
22368: PUSH
22369: LD_INT 47
22371: PUSH
22372: EMPTY
22373: LIST
22374: LIST
22375: LIST
22376: IN
22377: IFFALSE 22394
// bpoints := bpoints * 1.2 ;
22379: LD_ADDR_VAR 0 10
22383: PUSH
22384: LD_VAR 0 10
22388: PUSH
22389: LD_REAL  1.20000000000000E+0000
22392: MUL
22393: ST_TO_ADDR
// end ; unit_building :
22394: GO 22408
22396: LD_INT 3
22398: DOUBLE
22399: EQUAL
22400: IFTRUE 22404
22402: GO 22407
22404: POP
// ; end ;
22405: GO 22408
22407: POP
// for j = 1 to 3 do
22408: LD_ADDR_VAR 0 7
22412: PUSH
22413: DOUBLE
22414: LD_INT 1
22416: DEC
22417: ST_TO_ADDR
22418: LD_INT 3
22420: PUSH
22421: FOR_TO
22422: IFFALSE 22475
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22424: LD_ADDR_VAR 0 5
22428: PUSH
22429: LD_VAR 0 5
22433: PPUSH
22434: LD_VAR 0 7
22438: PPUSH
22439: LD_VAR 0 5
22443: PUSH
22444: LD_VAR 0 7
22448: ARRAY
22449: PUSH
22450: LD_VAR 0 9
22454: PUSH
22455: LD_VAR 0 7
22459: ARRAY
22460: PUSH
22461: LD_VAR 0 10
22465: MUL
22466: PLUS
22467: PPUSH
22468: CALL_OW 1
22472: ST_TO_ADDR
22473: GO 22421
22475: POP
22476: POP
// end ;
22477: GO 20956
22479: POP
22480: POP
// result := Replace ( result , 4 , tmp ) ;
22481: LD_ADDR_VAR 0 5
22485: PUSH
22486: LD_VAR 0 5
22490: PPUSH
22491: LD_INT 4
22493: PPUSH
22494: LD_VAR 0 8
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// end ;
22504: LD_VAR 0 5
22508: RET
// export function DangerAtRange ( unit , range ) ; begin
22509: LD_INT 0
22511: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22512: LD_ADDR_VAR 0 3
22516: PUSH
22517: LD_VAR 0 1
22521: PPUSH
22522: CALL_OW 255
22526: PPUSH
22527: LD_VAR 0 1
22531: PPUSH
22532: CALL_OW 250
22536: PPUSH
22537: LD_VAR 0 1
22541: PPUSH
22542: CALL_OW 251
22546: PPUSH
22547: LD_VAR 0 2
22551: PPUSH
22552: CALL 20808 0 4
22556: ST_TO_ADDR
// end ;
22557: LD_VAR 0 3
22561: RET
// export function DangerInArea ( side , area ) ; begin
22562: LD_INT 0
22564: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22565: LD_ADDR_VAR 0 3
22569: PUSH
22570: LD_VAR 0 2
22574: PPUSH
22575: LD_INT 81
22577: PUSH
22578: LD_VAR 0 1
22582: PUSH
22583: EMPTY
22584: LIST
22585: LIST
22586: PPUSH
22587: CALL_OW 70
22591: ST_TO_ADDR
// end ;
22592: LD_VAR 0 3
22596: RET
// export function IsExtension ( b ) ; begin
22597: LD_INT 0
22599: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22600: LD_ADDR_VAR 0 2
22604: PUSH
22605: LD_VAR 0 1
22609: PUSH
22610: LD_INT 23
22612: PUSH
22613: LD_INT 20
22615: PUSH
22616: LD_INT 22
22618: PUSH
22619: LD_INT 17
22621: PUSH
22622: LD_INT 24
22624: PUSH
22625: LD_INT 21
22627: PUSH
22628: LD_INT 19
22630: PUSH
22631: LD_INT 16
22633: PUSH
22634: LD_INT 25
22636: PUSH
22637: LD_INT 18
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: LIST
22644: LIST
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: LIST
22650: LIST
22651: IN
22652: ST_TO_ADDR
// end ;
22653: LD_VAR 0 2
22657: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22658: LD_INT 0
22660: PPUSH
22661: PPUSH
22662: PPUSH
// result := [ ] ;
22663: LD_ADDR_VAR 0 4
22667: PUSH
22668: EMPTY
22669: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22670: LD_ADDR_VAR 0 5
22674: PUSH
22675: LD_VAR 0 2
22679: PPUSH
22680: LD_INT 21
22682: PUSH
22683: LD_INT 3
22685: PUSH
22686: EMPTY
22687: LIST
22688: LIST
22689: PPUSH
22690: CALL_OW 70
22694: ST_TO_ADDR
// if not tmp then
22695: LD_VAR 0 5
22699: NOT
22700: IFFALSE 22704
// exit ;
22702: GO 22768
// if checkLink then
22704: LD_VAR 0 3
22708: IFFALSE 22758
// begin for i in tmp do
22710: LD_ADDR_VAR 0 6
22714: PUSH
22715: LD_VAR 0 5
22719: PUSH
22720: FOR_IN
22721: IFFALSE 22756
// if GetBase ( i ) <> base then
22723: LD_VAR 0 6
22727: PPUSH
22728: CALL_OW 274
22732: PUSH
22733: LD_VAR 0 1
22737: NONEQUAL
22738: IFFALSE 22754
// ComLinkToBase ( base , i ) ;
22740: LD_VAR 0 1
22744: PPUSH
22745: LD_VAR 0 6
22749: PPUSH
22750: CALL_OW 169
22754: GO 22720
22756: POP
22757: POP
// end ; result := tmp ;
22758: LD_ADDR_VAR 0 4
22762: PUSH
22763: LD_VAR 0 5
22767: ST_TO_ADDR
// end ;
22768: LD_VAR 0 4
22772: RET
// export function ComComplete ( units , b ) ; var i ; begin
22773: LD_INT 0
22775: PPUSH
22776: PPUSH
// if not units then
22777: LD_VAR 0 1
22781: NOT
22782: IFFALSE 22786
// exit ;
22784: GO 22876
// for i in units do
22786: LD_ADDR_VAR 0 4
22790: PUSH
22791: LD_VAR 0 1
22795: PUSH
22796: FOR_IN
22797: IFFALSE 22874
// if BuildingStatus ( b ) = bs_build then
22799: LD_VAR 0 2
22803: PPUSH
22804: CALL_OW 461
22808: PUSH
22809: LD_INT 1
22811: EQUAL
22812: IFFALSE 22872
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22814: LD_VAR 0 4
22818: PPUSH
22819: LD_STRING h
22821: PUSH
22822: LD_VAR 0 2
22826: PPUSH
22827: CALL_OW 250
22831: PUSH
22832: LD_VAR 0 2
22836: PPUSH
22837: CALL_OW 251
22841: PUSH
22842: LD_VAR 0 2
22846: PUSH
22847: LD_INT 0
22849: PUSH
22850: LD_INT 0
22852: PUSH
22853: LD_INT 0
22855: PUSH
22856: EMPTY
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: PPUSH
22868: CALL_OW 446
22872: GO 22796
22874: POP
22875: POP
// end ;
22876: LD_VAR 0 3
22880: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22881: LD_INT 0
22883: PPUSH
22884: PPUSH
22885: PPUSH
22886: PPUSH
22887: PPUSH
22888: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22889: LD_VAR 0 1
22893: NOT
22894: PUSH
22895: LD_VAR 0 1
22899: PPUSH
22900: CALL_OW 263
22904: PUSH
22905: LD_INT 2
22907: NONEQUAL
22908: OR
22909: IFFALSE 22913
// exit ;
22911: GO 23229
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22913: LD_ADDR_VAR 0 6
22917: PUSH
22918: LD_INT 22
22920: PUSH
22921: LD_VAR 0 1
22925: PPUSH
22926: CALL_OW 255
22930: PUSH
22931: EMPTY
22932: LIST
22933: LIST
22934: PUSH
22935: LD_INT 2
22937: PUSH
22938: LD_INT 30
22940: PUSH
22941: LD_INT 36
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: PUSH
22948: LD_INT 34
22950: PUSH
22951: LD_INT 31
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: LIST
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PPUSH
22967: CALL_OW 69
22971: ST_TO_ADDR
// if not tmp then
22972: LD_VAR 0 6
22976: NOT
22977: IFFALSE 22981
// exit ;
22979: GO 23229
// result := [ ] ;
22981: LD_ADDR_VAR 0 2
22985: PUSH
22986: EMPTY
22987: ST_TO_ADDR
// for i in tmp do
22988: LD_ADDR_VAR 0 3
22992: PUSH
22993: LD_VAR 0 6
22997: PUSH
22998: FOR_IN
22999: IFFALSE 23070
// begin t := UnitsInside ( i ) ;
23001: LD_ADDR_VAR 0 4
23005: PUSH
23006: LD_VAR 0 3
23010: PPUSH
23011: CALL_OW 313
23015: ST_TO_ADDR
// if t then
23016: LD_VAR 0 4
23020: IFFALSE 23068
// for j in t do
23022: LD_ADDR_VAR 0 7
23026: PUSH
23027: LD_VAR 0 4
23031: PUSH
23032: FOR_IN
23033: IFFALSE 23066
// result := Replace ( result , result + 1 , j ) ;
23035: LD_ADDR_VAR 0 2
23039: PUSH
23040: LD_VAR 0 2
23044: PPUSH
23045: LD_VAR 0 2
23049: PUSH
23050: LD_INT 1
23052: PLUS
23053: PPUSH
23054: LD_VAR 0 7
23058: PPUSH
23059: CALL_OW 1
23063: ST_TO_ADDR
23064: GO 23032
23066: POP
23067: POP
// end ;
23068: GO 22998
23070: POP
23071: POP
// if not result then
23072: LD_VAR 0 2
23076: NOT
23077: IFFALSE 23081
// exit ;
23079: GO 23229
// mech := result [ 1 ] ;
23081: LD_ADDR_VAR 0 5
23085: PUSH
23086: LD_VAR 0 2
23090: PUSH
23091: LD_INT 1
23093: ARRAY
23094: ST_TO_ADDR
// if result > 1 then
23095: LD_VAR 0 2
23099: PUSH
23100: LD_INT 1
23102: GREATER
23103: IFFALSE 23215
// begin for i = 2 to result do
23105: LD_ADDR_VAR 0 3
23109: PUSH
23110: DOUBLE
23111: LD_INT 2
23113: DEC
23114: ST_TO_ADDR
23115: LD_VAR 0 2
23119: PUSH
23120: FOR_TO
23121: IFFALSE 23213
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23123: LD_ADDR_VAR 0 4
23127: PUSH
23128: LD_VAR 0 2
23132: PUSH
23133: LD_VAR 0 3
23137: ARRAY
23138: PPUSH
23139: LD_INT 3
23141: PPUSH
23142: CALL_OW 259
23146: PUSH
23147: LD_VAR 0 2
23151: PUSH
23152: LD_VAR 0 3
23156: ARRAY
23157: PPUSH
23158: CALL_OW 432
23162: MINUS
23163: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23164: LD_VAR 0 4
23168: PUSH
23169: LD_VAR 0 5
23173: PPUSH
23174: LD_INT 3
23176: PPUSH
23177: CALL_OW 259
23181: PUSH
23182: LD_VAR 0 5
23186: PPUSH
23187: CALL_OW 432
23191: MINUS
23192: GREATEREQUAL
23193: IFFALSE 23211
// mech := result [ i ] ;
23195: LD_ADDR_VAR 0 5
23199: PUSH
23200: LD_VAR 0 2
23204: PUSH
23205: LD_VAR 0 3
23209: ARRAY
23210: ST_TO_ADDR
// end ;
23211: GO 23120
23213: POP
23214: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23215: LD_VAR 0 1
23219: PPUSH
23220: LD_VAR 0 5
23224: PPUSH
23225: CALL_OW 135
// end ;
23229: LD_VAR 0 2
23233: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23234: LD_INT 0
23236: PPUSH
23237: PPUSH
23238: PPUSH
23239: PPUSH
23240: PPUSH
23241: PPUSH
23242: PPUSH
23243: PPUSH
23244: PPUSH
23245: PPUSH
23246: PPUSH
23247: PPUSH
23248: PPUSH
// result := [ ] ;
23249: LD_ADDR_VAR 0 7
23253: PUSH
23254: EMPTY
23255: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23256: LD_VAR 0 1
23260: PPUSH
23261: CALL_OW 266
23265: PUSH
23266: LD_INT 0
23268: PUSH
23269: LD_INT 1
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: IN
23276: NOT
23277: IFFALSE 23281
// exit ;
23279: GO 24915
// if name then
23281: LD_VAR 0 3
23285: IFFALSE 23301
// SetBName ( base_dep , name ) ;
23287: LD_VAR 0 1
23291: PPUSH
23292: LD_VAR 0 3
23296: PPUSH
23297: CALL_OW 500
// base := GetBase ( base_dep ) ;
23301: LD_ADDR_VAR 0 15
23305: PUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 274
23315: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23316: LD_ADDR_VAR 0 16
23320: PUSH
23321: LD_VAR 0 1
23325: PPUSH
23326: CALL_OW 255
23330: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23331: LD_ADDR_VAR 0 17
23335: PUSH
23336: LD_VAR 0 1
23340: PPUSH
23341: CALL_OW 248
23345: ST_TO_ADDR
// if sources then
23346: LD_VAR 0 5
23350: IFFALSE 23397
// for i = 1 to 3 do
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: DOUBLE
23358: LD_INT 1
23360: DEC
23361: ST_TO_ADDR
23362: LD_INT 3
23364: PUSH
23365: FOR_TO
23366: IFFALSE 23395
// AddResourceType ( base , i , sources [ i ] ) ;
23368: LD_VAR 0 15
23372: PPUSH
23373: LD_VAR 0 8
23377: PPUSH
23378: LD_VAR 0 5
23382: PUSH
23383: LD_VAR 0 8
23387: ARRAY
23388: PPUSH
23389: CALL_OW 276
23393: GO 23365
23395: POP
23396: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23397: LD_ADDR_VAR 0 18
23401: PUSH
23402: LD_VAR 0 15
23406: PPUSH
23407: LD_VAR 0 2
23411: PPUSH
23412: LD_INT 1
23414: PPUSH
23415: CALL 22658 0 3
23419: ST_TO_ADDR
// InitHc ;
23420: CALL_OW 19
// InitUc ;
23424: CALL_OW 18
// uc_side := side ;
23428: LD_ADDR_OWVAR 20
23432: PUSH
23433: LD_VAR 0 16
23437: ST_TO_ADDR
// uc_nation := nation ;
23438: LD_ADDR_OWVAR 21
23442: PUSH
23443: LD_VAR 0 17
23447: ST_TO_ADDR
// if buildings then
23448: LD_VAR 0 18
23452: IFFALSE 24774
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23454: LD_ADDR_VAR 0 19
23458: PUSH
23459: LD_VAR 0 18
23463: PPUSH
23464: LD_INT 2
23466: PUSH
23467: LD_INT 30
23469: PUSH
23470: LD_INT 29
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 30
23479: PUSH
23480: LD_INT 30
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: LIST
23491: PPUSH
23492: CALL_OW 72
23496: ST_TO_ADDR
// if tmp then
23497: LD_VAR 0 19
23501: IFFALSE 23549
// for i in tmp do
23503: LD_ADDR_VAR 0 8
23507: PUSH
23508: LD_VAR 0 19
23512: PUSH
23513: FOR_IN
23514: IFFALSE 23547
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23516: LD_VAR 0 8
23520: PPUSH
23521: CALL_OW 250
23525: PPUSH
23526: LD_VAR 0 8
23530: PPUSH
23531: CALL_OW 251
23535: PPUSH
23536: LD_VAR 0 16
23540: PPUSH
23541: CALL_OW 441
23545: GO 23513
23547: POP
23548: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23549: LD_VAR 0 18
23553: PPUSH
23554: LD_INT 2
23556: PUSH
23557: LD_INT 30
23559: PUSH
23560: LD_INT 32
23562: PUSH
23563: EMPTY
23564: LIST
23565: LIST
23566: PUSH
23567: LD_INT 30
23569: PUSH
23570: LD_INT 33
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: LIST
23581: PPUSH
23582: CALL_OW 72
23586: IFFALSE 23674
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23588: LD_ADDR_VAR 0 8
23592: PUSH
23593: LD_VAR 0 18
23597: PPUSH
23598: LD_INT 2
23600: PUSH
23601: LD_INT 30
23603: PUSH
23604: LD_INT 32
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: PUSH
23611: LD_INT 30
23613: PUSH
23614: LD_INT 33
23616: PUSH
23617: EMPTY
23618: LIST
23619: LIST
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: PPUSH
23626: CALL_OW 72
23630: PUSH
23631: FOR_IN
23632: IFFALSE 23672
// begin if not GetBWeapon ( i ) then
23634: LD_VAR 0 8
23638: PPUSH
23639: CALL_OW 269
23643: NOT
23644: IFFALSE 23670
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23646: LD_VAR 0 8
23650: PPUSH
23651: LD_VAR 0 8
23655: PPUSH
23656: LD_VAR 0 2
23660: PPUSH
23661: CALL 24920 0 2
23665: PPUSH
23666: CALL_OW 431
// end ;
23670: GO 23631
23672: POP
23673: POP
// end ; for i = 1 to personel do
23674: LD_ADDR_VAR 0 8
23678: PUSH
23679: DOUBLE
23680: LD_INT 1
23682: DEC
23683: ST_TO_ADDR
23684: LD_VAR 0 6
23688: PUSH
23689: FOR_TO
23690: IFFALSE 24754
// begin if i > 4 then
23692: LD_VAR 0 8
23696: PUSH
23697: LD_INT 4
23699: GREATER
23700: IFFALSE 23704
// break ;
23702: GO 24754
// case i of 1 :
23704: LD_VAR 0 8
23708: PUSH
23709: LD_INT 1
23711: DOUBLE
23712: EQUAL
23713: IFTRUE 23717
23715: GO 23797
23717: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23718: LD_ADDR_VAR 0 12
23722: PUSH
23723: LD_VAR 0 18
23727: PPUSH
23728: LD_INT 22
23730: PUSH
23731: LD_VAR 0 16
23735: PUSH
23736: EMPTY
23737: LIST
23738: LIST
23739: PUSH
23740: LD_INT 58
23742: PUSH
23743: EMPTY
23744: LIST
23745: PUSH
23746: LD_INT 2
23748: PUSH
23749: LD_INT 30
23751: PUSH
23752: LD_INT 32
23754: PUSH
23755: EMPTY
23756: LIST
23757: LIST
23758: PUSH
23759: LD_INT 30
23761: PUSH
23762: LD_INT 4
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 30
23771: PUSH
23772: LD_INT 5
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: LIST
23789: PPUSH
23790: CALL_OW 72
23794: ST_TO_ADDR
23795: GO 24019
23797: LD_INT 2
23799: DOUBLE
23800: EQUAL
23801: IFTRUE 23805
23803: GO 23867
23805: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23806: LD_ADDR_VAR 0 12
23810: PUSH
23811: LD_VAR 0 18
23815: PPUSH
23816: LD_INT 22
23818: PUSH
23819: LD_VAR 0 16
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PUSH
23828: LD_INT 2
23830: PUSH
23831: LD_INT 30
23833: PUSH
23834: LD_INT 0
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: LD_INT 30
23843: PUSH
23844: LD_INT 1
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: EMPTY
23852: LIST
23853: LIST
23854: LIST
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 72
23864: ST_TO_ADDR
23865: GO 24019
23867: LD_INT 3
23869: DOUBLE
23870: EQUAL
23871: IFTRUE 23875
23873: GO 23937
23875: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23876: LD_ADDR_VAR 0 12
23880: PUSH
23881: LD_VAR 0 18
23885: PPUSH
23886: LD_INT 22
23888: PUSH
23889: LD_VAR 0 16
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: LD_INT 2
23900: PUSH
23901: LD_INT 30
23903: PUSH
23904: LD_INT 2
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 30
23913: PUSH
23914: LD_INT 3
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: LIST
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PPUSH
23930: CALL_OW 72
23934: ST_TO_ADDR
23935: GO 24019
23937: LD_INT 4
23939: DOUBLE
23940: EQUAL
23941: IFTRUE 23945
23943: GO 24018
23945: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23946: LD_ADDR_VAR 0 12
23950: PUSH
23951: LD_VAR 0 18
23955: PPUSH
23956: LD_INT 22
23958: PUSH
23959: LD_VAR 0 16
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: LD_INT 2
23970: PUSH
23971: LD_INT 30
23973: PUSH
23974: LD_INT 6
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 30
23983: PUSH
23984: LD_INT 7
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 30
23993: PUSH
23994: LD_INT 8
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: LIST
24005: LIST
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PPUSH
24011: CALL_OW 72
24015: ST_TO_ADDR
24016: GO 24019
24018: POP
// if i = 1 then
24019: LD_VAR 0 8
24023: PUSH
24024: LD_INT 1
24026: EQUAL
24027: IFFALSE 24138
// begin tmp := [ ] ;
24029: LD_ADDR_VAR 0 19
24033: PUSH
24034: EMPTY
24035: ST_TO_ADDR
// for j in f do
24036: LD_ADDR_VAR 0 9
24040: PUSH
24041: LD_VAR 0 12
24045: PUSH
24046: FOR_IN
24047: IFFALSE 24120
// if GetBType ( j ) = b_bunker then
24049: LD_VAR 0 9
24053: PPUSH
24054: CALL_OW 266
24058: PUSH
24059: LD_INT 32
24061: EQUAL
24062: IFFALSE 24089
// tmp := Insert ( tmp , 1 , j ) else
24064: LD_ADDR_VAR 0 19
24068: PUSH
24069: LD_VAR 0 19
24073: PPUSH
24074: LD_INT 1
24076: PPUSH
24077: LD_VAR 0 9
24081: PPUSH
24082: CALL_OW 2
24086: ST_TO_ADDR
24087: GO 24118
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24089: LD_ADDR_VAR 0 19
24093: PUSH
24094: LD_VAR 0 19
24098: PPUSH
24099: LD_VAR 0 19
24103: PUSH
24104: LD_INT 1
24106: PLUS
24107: PPUSH
24108: LD_VAR 0 9
24112: PPUSH
24113: CALL_OW 2
24117: ST_TO_ADDR
24118: GO 24046
24120: POP
24121: POP
// if tmp then
24122: LD_VAR 0 19
24126: IFFALSE 24138
// f := tmp ;
24128: LD_ADDR_VAR 0 12
24132: PUSH
24133: LD_VAR 0 19
24137: ST_TO_ADDR
// end ; x := personel [ i ] ;
24138: LD_ADDR_VAR 0 13
24142: PUSH
24143: LD_VAR 0 6
24147: PUSH
24148: LD_VAR 0 8
24152: ARRAY
24153: ST_TO_ADDR
// if x = - 1 then
24154: LD_VAR 0 13
24158: PUSH
24159: LD_INT 1
24161: NEG
24162: EQUAL
24163: IFFALSE 24372
// begin for j in f do
24165: LD_ADDR_VAR 0 9
24169: PUSH
24170: LD_VAR 0 12
24174: PUSH
24175: FOR_IN
24176: IFFALSE 24368
// repeat InitHc ;
24178: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24182: LD_VAR 0 9
24186: PPUSH
24187: CALL_OW 266
24191: PUSH
24192: LD_INT 5
24194: EQUAL
24195: IFFALSE 24265
// begin if UnitsInside ( j ) < 3 then
24197: LD_VAR 0 9
24201: PPUSH
24202: CALL_OW 313
24206: PUSH
24207: LD_INT 3
24209: LESS
24210: IFFALSE 24246
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24212: LD_INT 0
24214: PPUSH
24215: LD_INT 5
24217: PUSH
24218: LD_INT 8
24220: PUSH
24221: LD_INT 9
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: PUSH
24229: LD_VAR 0 17
24233: ARRAY
24234: PPUSH
24235: LD_VAR 0 4
24239: PPUSH
24240: CALL_OW 380
24244: GO 24263
// PrepareHuman ( false , i , skill ) ;
24246: LD_INT 0
24248: PPUSH
24249: LD_VAR 0 8
24253: PPUSH
24254: LD_VAR 0 4
24258: PPUSH
24259: CALL_OW 380
// end else
24263: GO 24282
// PrepareHuman ( false , i , skill ) ;
24265: LD_INT 0
24267: PPUSH
24268: LD_VAR 0 8
24272: PPUSH
24273: LD_VAR 0 4
24277: PPUSH
24278: CALL_OW 380
// un := CreateHuman ;
24282: LD_ADDR_VAR 0 14
24286: PUSH
24287: CALL_OW 44
24291: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24292: LD_ADDR_VAR 0 7
24296: PUSH
24297: LD_VAR 0 7
24301: PPUSH
24302: LD_INT 1
24304: PPUSH
24305: LD_VAR 0 14
24309: PPUSH
24310: CALL_OW 2
24314: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24315: LD_VAR 0 14
24319: PPUSH
24320: LD_VAR 0 9
24324: PPUSH
24325: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24329: LD_VAR 0 9
24333: PPUSH
24334: CALL_OW 313
24338: PUSH
24339: LD_INT 6
24341: EQUAL
24342: PUSH
24343: LD_VAR 0 9
24347: PPUSH
24348: CALL_OW 266
24352: PUSH
24353: LD_INT 32
24355: PUSH
24356: LD_INT 31
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: IN
24363: OR
24364: IFFALSE 24178
24366: GO 24175
24368: POP
24369: POP
// end else
24370: GO 24752
// for j = 1 to x do
24372: LD_ADDR_VAR 0 9
24376: PUSH
24377: DOUBLE
24378: LD_INT 1
24380: DEC
24381: ST_TO_ADDR
24382: LD_VAR 0 13
24386: PUSH
24387: FOR_TO
24388: IFFALSE 24750
// begin InitHc ;
24390: CALL_OW 19
// if not f then
24394: LD_VAR 0 12
24398: NOT
24399: IFFALSE 24488
// begin PrepareHuman ( false , i , skill ) ;
24401: LD_INT 0
24403: PPUSH
24404: LD_VAR 0 8
24408: PPUSH
24409: LD_VAR 0 4
24413: PPUSH
24414: CALL_OW 380
// un := CreateHuman ;
24418: LD_ADDR_VAR 0 14
24422: PUSH
24423: CALL_OW 44
24427: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24428: LD_ADDR_VAR 0 7
24432: PUSH
24433: LD_VAR 0 7
24437: PPUSH
24438: LD_INT 1
24440: PPUSH
24441: LD_VAR 0 14
24445: PPUSH
24446: CALL_OW 2
24450: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24451: LD_VAR 0 14
24455: PPUSH
24456: LD_VAR 0 1
24460: PPUSH
24461: CALL_OW 250
24465: PPUSH
24466: LD_VAR 0 1
24470: PPUSH
24471: CALL_OW 251
24475: PPUSH
24476: LD_INT 10
24478: PPUSH
24479: LD_INT 0
24481: PPUSH
24482: CALL_OW 50
// continue ;
24486: GO 24387
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24488: LD_VAR 0 12
24492: PUSH
24493: LD_INT 1
24495: ARRAY
24496: PPUSH
24497: CALL_OW 313
24501: PUSH
24502: LD_VAR 0 12
24506: PUSH
24507: LD_INT 1
24509: ARRAY
24510: PPUSH
24511: CALL_OW 266
24515: PUSH
24516: LD_INT 32
24518: PUSH
24519: LD_INT 31
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: IN
24526: AND
24527: PUSH
24528: LD_VAR 0 12
24532: PUSH
24533: LD_INT 1
24535: ARRAY
24536: PPUSH
24537: CALL_OW 313
24541: PUSH
24542: LD_INT 6
24544: EQUAL
24545: OR
24546: IFFALSE 24566
// f := Delete ( f , 1 ) ;
24548: LD_ADDR_VAR 0 12
24552: PUSH
24553: LD_VAR 0 12
24557: PPUSH
24558: LD_INT 1
24560: PPUSH
24561: CALL_OW 3
24565: ST_TO_ADDR
// if not f then
24566: LD_VAR 0 12
24570: NOT
24571: IFFALSE 24589
// begin x := x + 2 ;
24573: LD_ADDR_VAR 0 13
24577: PUSH
24578: LD_VAR 0 13
24582: PUSH
24583: LD_INT 2
24585: PLUS
24586: ST_TO_ADDR
// continue ;
24587: GO 24387
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24589: LD_VAR 0 12
24593: PUSH
24594: LD_INT 1
24596: ARRAY
24597: PPUSH
24598: CALL_OW 266
24602: PUSH
24603: LD_INT 5
24605: EQUAL
24606: IFFALSE 24680
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24608: LD_VAR 0 12
24612: PUSH
24613: LD_INT 1
24615: ARRAY
24616: PPUSH
24617: CALL_OW 313
24621: PUSH
24622: LD_INT 3
24624: LESS
24625: IFFALSE 24661
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24627: LD_INT 0
24629: PPUSH
24630: LD_INT 5
24632: PUSH
24633: LD_INT 8
24635: PUSH
24636: LD_INT 9
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: LIST
24643: PUSH
24644: LD_VAR 0 17
24648: ARRAY
24649: PPUSH
24650: LD_VAR 0 4
24654: PPUSH
24655: CALL_OW 380
24659: GO 24678
// PrepareHuman ( false , i , skill ) ;
24661: LD_INT 0
24663: PPUSH
24664: LD_VAR 0 8
24668: PPUSH
24669: LD_VAR 0 4
24673: PPUSH
24674: CALL_OW 380
// end else
24678: GO 24697
// PrepareHuman ( false , i , skill ) ;
24680: LD_INT 0
24682: PPUSH
24683: LD_VAR 0 8
24687: PPUSH
24688: LD_VAR 0 4
24692: PPUSH
24693: CALL_OW 380
// un := CreateHuman ;
24697: LD_ADDR_VAR 0 14
24701: PUSH
24702: CALL_OW 44
24706: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24707: LD_ADDR_VAR 0 7
24711: PUSH
24712: LD_VAR 0 7
24716: PPUSH
24717: LD_INT 1
24719: PPUSH
24720: LD_VAR 0 14
24724: PPUSH
24725: CALL_OW 2
24729: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24730: LD_VAR 0 14
24734: PPUSH
24735: LD_VAR 0 12
24739: PUSH
24740: LD_INT 1
24742: ARRAY
24743: PPUSH
24744: CALL_OW 52
// end ;
24748: GO 24387
24750: POP
24751: POP
// end ;
24752: GO 23689
24754: POP
24755: POP
// result := result ^ buildings ;
24756: LD_ADDR_VAR 0 7
24760: PUSH
24761: LD_VAR 0 7
24765: PUSH
24766: LD_VAR 0 18
24770: ADD
24771: ST_TO_ADDR
// end else
24772: GO 24915
// begin for i = 1 to personel do
24774: LD_ADDR_VAR 0 8
24778: PUSH
24779: DOUBLE
24780: LD_INT 1
24782: DEC
24783: ST_TO_ADDR
24784: LD_VAR 0 6
24788: PUSH
24789: FOR_TO
24790: IFFALSE 24913
// begin if i > 4 then
24792: LD_VAR 0 8
24796: PUSH
24797: LD_INT 4
24799: GREATER
24800: IFFALSE 24804
// break ;
24802: GO 24913
// x := personel [ i ] ;
24804: LD_ADDR_VAR 0 13
24808: PUSH
24809: LD_VAR 0 6
24813: PUSH
24814: LD_VAR 0 8
24818: ARRAY
24819: ST_TO_ADDR
// if x = - 1 then
24820: LD_VAR 0 13
24824: PUSH
24825: LD_INT 1
24827: NEG
24828: EQUAL
24829: IFFALSE 24833
// continue ;
24831: GO 24789
// PrepareHuman ( false , i , skill ) ;
24833: LD_INT 0
24835: PPUSH
24836: LD_VAR 0 8
24840: PPUSH
24841: LD_VAR 0 4
24845: PPUSH
24846: CALL_OW 380
// un := CreateHuman ;
24850: LD_ADDR_VAR 0 14
24854: PUSH
24855: CALL_OW 44
24859: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24860: LD_VAR 0 14
24864: PPUSH
24865: LD_VAR 0 1
24869: PPUSH
24870: CALL_OW 250
24874: PPUSH
24875: LD_VAR 0 1
24879: PPUSH
24880: CALL_OW 251
24884: PPUSH
24885: LD_INT 10
24887: PPUSH
24888: LD_INT 0
24890: PPUSH
24891: CALL_OW 50
// result := result ^ un ;
24895: LD_ADDR_VAR 0 7
24899: PUSH
24900: LD_VAR 0 7
24904: PUSH
24905: LD_VAR 0 14
24909: ADD
24910: ST_TO_ADDR
// end ;
24911: GO 24789
24913: POP
24914: POP
// end ; end ;
24915: LD_VAR 0 7
24919: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24920: LD_INT 0
24922: PPUSH
24923: PPUSH
24924: PPUSH
24925: PPUSH
24926: PPUSH
24927: PPUSH
24928: PPUSH
24929: PPUSH
24930: PPUSH
24931: PPUSH
24932: PPUSH
24933: PPUSH
24934: PPUSH
24935: PPUSH
24936: PPUSH
24937: PPUSH
// result := false ;
24938: LD_ADDR_VAR 0 3
24942: PUSH
24943: LD_INT 0
24945: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24946: LD_VAR 0 1
24950: NOT
24951: PUSH
24952: LD_VAR 0 1
24956: PPUSH
24957: CALL_OW 266
24961: PUSH
24962: LD_INT 32
24964: PUSH
24965: LD_INT 33
24967: PUSH
24968: EMPTY
24969: LIST
24970: LIST
24971: IN
24972: NOT
24973: OR
24974: IFFALSE 24978
// exit ;
24976: GO 26087
// nat := GetNation ( tower ) ;
24978: LD_ADDR_VAR 0 12
24982: PUSH
24983: LD_VAR 0 1
24987: PPUSH
24988: CALL_OW 248
24992: ST_TO_ADDR
// side := GetSide ( tower ) ;
24993: LD_ADDR_VAR 0 16
24997: PUSH
24998: LD_VAR 0 1
25002: PPUSH
25003: CALL_OW 255
25007: ST_TO_ADDR
// x := GetX ( tower ) ;
25008: LD_ADDR_VAR 0 10
25012: PUSH
25013: LD_VAR 0 1
25017: PPUSH
25018: CALL_OW 250
25022: ST_TO_ADDR
// y := GetY ( tower ) ;
25023: LD_ADDR_VAR 0 11
25027: PUSH
25028: LD_VAR 0 1
25032: PPUSH
25033: CALL_OW 251
25037: ST_TO_ADDR
// if not x or not y then
25038: LD_VAR 0 10
25042: NOT
25043: PUSH
25044: LD_VAR 0 11
25048: NOT
25049: OR
25050: IFFALSE 25054
// exit ;
25052: GO 26087
// weapon := 0 ;
25054: LD_ADDR_VAR 0 18
25058: PUSH
25059: LD_INT 0
25061: ST_TO_ADDR
// fac_list := [ ] ;
25062: LD_ADDR_VAR 0 17
25066: PUSH
25067: EMPTY
25068: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25069: LD_ADDR_VAR 0 6
25073: PUSH
25074: LD_VAR 0 1
25078: PPUSH
25079: CALL_OW 274
25083: PPUSH
25084: LD_VAR 0 2
25088: PPUSH
25089: LD_INT 0
25091: PPUSH
25092: CALL 22658 0 3
25096: PPUSH
25097: LD_INT 30
25099: PUSH
25100: LD_INT 3
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PPUSH
25107: CALL_OW 72
25111: ST_TO_ADDR
// if not factories then
25112: LD_VAR 0 6
25116: NOT
25117: IFFALSE 25121
// exit ;
25119: GO 26087
// for i in factories do
25121: LD_ADDR_VAR 0 8
25125: PUSH
25126: LD_VAR 0 6
25130: PUSH
25131: FOR_IN
25132: IFFALSE 25157
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25134: LD_ADDR_VAR 0 17
25138: PUSH
25139: LD_VAR 0 17
25143: PUSH
25144: LD_VAR 0 8
25148: PPUSH
25149: CALL_OW 478
25153: UNION
25154: ST_TO_ADDR
25155: GO 25131
25157: POP
25158: POP
// if not fac_list then
25159: LD_VAR 0 17
25163: NOT
25164: IFFALSE 25168
// exit ;
25166: GO 26087
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25168: LD_ADDR_VAR 0 5
25172: PUSH
25173: LD_INT 4
25175: PUSH
25176: LD_INT 5
25178: PUSH
25179: LD_INT 9
25181: PUSH
25182: LD_INT 10
25184: PUSH
25185: LD_INT 6
25187: PUSH
25188: LD_INT 7
25190: PUSH
25191: LD_INT 11
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: LIST
25198: LIST
25199: LIST
25200: LIST
25201: LIST
25202: PUSH
25203: LD_INT 27
25205: PUSH
25206: LD_INT 28
25208: PUSH
25209: LD_INT 26
25211: PUSH
25212: LD_INT 30
25214: PUSH
25215: EMPTY
25216: LIST
25217: LIST
25218: LIST
25219: LIST
25220: PUSH
25221: LD_INT 43
25223: PUSH
25224: LD_INT 44
25226: PUSH
25227: LD_INT 46
25229: PUSH
25230: LD_INT 45
25232: PUSH
25233: LD_INT 47
25235: PUSH
25236: LD_INT 49
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: LIST
25251: PUSH
25252: LD_VAR 0 12
25256: ARRAY
25257: ST_TO_ADDR
// list := list isect fac_list ;
25258: LD_ADDR_VAR 0 5
25262: PUSH
25263: LD_VAR 0 5
25267: PUSH
25268: LD_VAR 0 17
25272: ISECT
25273: ST_TO_ADDR
// if not list then
25274: LD_VAR 0 5
25278: NOT
25279: IFFALSE 25283
// exit ;
25281: GO 26087
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25283: LD_VAR 0 12
25287: PUSH
25288: LD_INT 3
25290: EQUAL
25291: PUSH
25292: LD_INT 49
25294: PUSH
25295: LD_VAR 0 5
25299: IN
25300: AND
25301: PUSH
25302: LD_INT 31
25304: PPUSH
25305: LD_VAR 0 16
25309: PPUSH
25310: CALL_OW 321
25314: PUSH
25315: LD_INT 2
25317: EQUAL
25318: AND
25319: IFFALSE 25379
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25321: LD_INT 22
25323: PUSH
25324: LD_VAR 0 16
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: LD_INT 35
25335: PUSH
25336: LD_INT 49
25338: PUSH
25339: EMPTY
25340: LIST
25341: LIST
25342: PUSH
25343: LD_INT 91
25345: PUSH
25346: LD_VAR 0 1
25350: PUSH
25351: LD_INT 10
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: LIST
25363: PPUSH
25364: CALL_OW 69
25368: NOT
25369: IFFALSE 25379
// weapon := ru_time_lapser ;
25371: LD_ADDR_VAR 0 18
25375: PUSH
25376: LD_INT 49
25378: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25379: LD_VAR 0 12
25383: PUSH
25384: LD_INT 1
25386: PUSH
25387: LD_INT 2
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: IN
25394: PUSH
25395: LD_INT 11
25397: PUSH
25398: LD_VAR 0 5
25402: IN
25403: PUSH
25404: LD_INT 30
25406: PUSH
25407: LD_VAR 0 5
25411: IN
25412: OR
25413: AND
25414: PUSH
25415: LD_INT 6
25417: PPUSH
25418: LD_VAR 0 16
25422: PPUSH
25423: CALL_OW 321
25427: PUSH
25428: LD_INT 2
25430: EQUAL
25431: AND
25432: IFFALSE 25597
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25434: LD_INT 22
25436: PUSH
25437: LD_VAR 0 16
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: LD_INT 2
25448: PUSH
25449: LD_INT 35
25451: PUSH
25452: LD_INT 11
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: PUSH
25459: LD_INT 35
25461: PUSH
25462: LD_INT 30
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: LIST
25473: PUSH
25474: LD_INT 91
25476: PUSH
25477: LD_VAR 0 1
25481: PUSH
25482: LD_INT 18
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: PUSH
25490: EMPTY
25491: LIST
25492: LIST
25493: LIST
25494: PPUSH
25495: CALL_OW 69
25499: NOT
25500: PUSH
25501: LD_INT 22
25503: PUSH
25504: LD_VAR 0 16
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 2
25515: PUSH
25516: LD_INT 30
25518: PUSH
25519: LD_INT 32
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 30
25528: PUSH
25529: LD_INT 33
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 91
25543: PUSH
25544: LD_VAR 0 1
25548: PUSH
25549: LD_INT 12
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: LIST
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: LIST
25561: PUSH
25562: EMPTY
25563: LIST
25564: PPUSH
25565: CALL_OW 69
25569: PUSH
25570: LD_INT 2
25572: GREATER
25573: AND
25574: IFFALSE 25597
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25576: LD_ADDR_VAR 0 18
25580: PUSH
25581: LD_INT 11
25583: PUSH
25584: LD_INT 30
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: LD_VAR 0 12
25595: ARRAY
25596: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25597: LD_VAR 0 18
25601: NOT
25602: PUSH
25603: LD_INT 40
25605: PPUSH
25606: LD_VAR 0 16
25610: PPUSH
25611: CALL_OW 321
25615: PUSH
25616: LD_INT 2
25618: EQUAL
25619: AND
25620: PUSH
25621: LD_INT 7
25623: PUSH
25624: LD_VAR 0 5
25628: IN
25629: PUSH
25630: LD_INT 28
25632: PUSH
25633: LD_VAR 0 5
25637: IN
25638: OR
25639: PUSH
25640: LD_INT 45
25642: PUSH
25643: LD_VAR 0 5
25647: IN
25648: OR
25649: AND
25650: IFFALSE 25904
// begin hex := GetHexInfo ( x , y ) ;
25652: LD_ADDR_VAR 0 4
25656: PUSH
25657: LD_VAR 0 10
25661: PPUSH
25662: LD_VAR 0 11
25666: PPUSH
25667: CALL_OW 546
25671: ST_TO_ADDR
// if hex [ 1 ] then
25672: LD_VAR 0 4
25676: PUSH
25677: LD_INT 1
25679: ARRAY
25680: IFFALSE 25684
// exit ;
25682: GO 26087
// height := hex [ 2 ] ;
25684: LD_ADDR_VAR 0 15
25688: PUSH
25689: LD_VAR 0 4
25693: PUSH
25694: LD_INT 2
25696: ARRAY
25697: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25698: LD_ADDR_VAR 0 14
25702: PUSH
25703: LD_INT 0
25705: PUSH
25706: LD_INT 2
25708: PUSH
25709: LD_INT 3
25711: PUSH
25712: LD_INT 5
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: LIST
25720: ST_TO_ADDR
// for i in tmp do
25721: LD_ADDR_VAR 0 8
25725: PUSH
25726: LD_VAR 0 14
25730: PUSH
25731: FOR_IN
25732: IFFALSE 25902
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25734: LD_ADDR_VAR 0 9
25738: PUSH
25739: LD_VAR 0 10
25743: PPUSH
25744: LD_VAR 0 8
25748: PPUSH
25749: LD_INT 5
25751: PPUSH
25752: CALL_OW 272
25756: PUSH
25757: LD_VAR 0 11
25761: PPUSH
25762: LD_VAR 0 8
25766: PPUSH
25767: LD_INT 5
25769: PPUSH
25770: CALL_OW 273
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25779: LD_VAR 0 9
25783: PUSH
25784: LD_INT 1
25786: ARRAY
25787: PPUSH
25788: LD_VAR 0 9
25792: PUSH
25793: LD_INT 2
25795: ARRAY
25796: PPUSH
25797: CALL_OW 488
25801: IFFALSE 25900
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25803: LD_ADDR_VAR 0 4
25807: PUSH
25808: LD_VAR 0 9
25812: PUSH
25813: LD_INT 1
25815: ARRAY
25816: PPUSH
25817: LD_VAR 0 9
25821: PUSH
25822: LD_INT 2
25824: ARRAY
25825: PPUSH
25826: CALL_OW 546
25830: ST_TO_ADDR
// if hex [ 1 ] then
25831: LD_VAR 0 4
25835: PUSH
25836: LD_INT 1
25838: ARRAY
25839: IFFALSE 25843
// continue ;
25841: GO 25731
// h := hex [ 2 ] ;
25843: LD_ADDR_VAR 0 13
25847: PUSH
25848: LD_VAR 0 4
25852: PUSH
25853: LD_INT 2
25855: ARRAY
25856: ST_TO_ADDR
// if h + 7 < height then
25857: LD_VAR 0 13
25861: PUSH
25862: LD_INT 7
25864: PLUS
25865: PUSH
25866: LD_VAR 0 15
25870: LESS
25871: IFFALSE 25900
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25873: LD_ADDR_VAR 0 18
25877: PUSH
25878: LD_INT 7
25880: PUSH
25881: LD_INT 28
25883: PUSH
25884: LD_INT 45
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: LIST
25891: PUSH
25892: LD_VAR 0 12
25896: ARRAY
25897: ST_TO_ADDR
// break ;
25898: GO 25902
// end ; end ; end ;
25900: GO 25731
25902: POP
25903: POP
// end ; if not weapon then
25904: LD_VAR 0 18
25908: NOT
25909: IFFALSE 25969
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25911: LD_ADDR_VAR 0 5
25915: PUSH
25916: LD_VAR 0 5
25920: PUSH
25921: LD_INT 11
25923: PUSH
25924: LD_INT 30
25926: PUSH
25927: LD_INT 49
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: LIST
25934: DIFF
25935: ST_TO_ADDR
// if not list then
25936: LD_VAR 0 5
25940: NOT
25941: IFFALSE 25945
// exit ;
25943: GO 26087
// weapon := list [ rand ( 1 , list ) ] ;
25945: LD_ADDR_VAR 0 18
25949: PUSH
25950: LD_VAR 0 5
25954: PUSH
25955: LD_INT 1
25957: PPUSH
25958: LD_VAR 0 5
25962: PPUSH
25963: CALL_OW 12
25967: ARRAY
25968: ST_TO_ADDR
// end ; if weapon then
25969: LD_VAR 0 18
25973: IFFALSE 26087
// begin tmp := CostOfWeapon ( weapon ) ;
25975: LD_ADDR_VAR 0 14
25979: PUSH
25980: LD_VAR 0 18
25984: PPUSH
25985: CALL_OW 451
25989: ST_TO_ADDR
// j := GetBase ( tower ) ;
25990: LD_ADDR_VAR 0 9
25994: PUSH
25995: LD_VAR 0 1
25999: PPUSH
26000: CALL_OW 274
26004: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26005: LD_VAR 0 9
26009: PPUSH
26010: LD_INT 1
26012: PPUSH
26013: CALL_OW 275
26017: PUSH
26018: LD_VAR 0 14
26022: PUSH
26023: LD_INT 1
26025: ARRAY
26026: GREATEREQUAL
26027: PUSH
26028: LD_VAR 0 9
26032: PPUSH
26033: LD_INT 2
26035: PPUSH
26036: CALL_OW 275
26040: PUSH
26041: LD_VAR 0 14
26045: PUSH
26046: LD_INT 2
26048: ARRAY
26049: GREATEREQUAL
26050: AND
26051: PUSH
26052: LD_VAR 0 9
26056: PPUSH
26057: LD_INT 3
26059: PPUSH
26060: CALL_OW 275
26064: PUSH
26065: LD_VAR 0 14
26069: PUSH
26070: LD_INT 3
26072: ARRAY
26073: GREATEREQUAL
26074: AND
26075: IFFALSE 26087
// result := weapon ;
26077: LD_ADDR_VAR 0 3
26081: PUSH
26082: LD_VAR 0 18
26086: ST_TO_ADDR
// end ; end ;
26087: LD_VAR 0 3
26091: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26092: LD_INT 0
26094: PPUSH
26095: PPUSH
// result := true ;
26096: LD_ADDR_VAR 0 3
26100: PUSH
26101: LD_INT 1
26103: ST_TO_ADDR
// if array1 = array2 then
26104: LD_VAR 0 1
26108: PUSH
26109: LD_VAR 0 2
26113: EQUAL
26114: IFFALSE 26174
// begin for i = 1 to array1 do
26116: LD_ADDR_VAR 0 4
26120: PUSH
26121: DOUBLE
26122: LD_INT 1
26124: DEC
26125: ST_TO_ADDR
26126: LD_VAR 0 1
26130: PUSH
26131: FOR_TO
26132: IFFALSE 26170
// if array1 [ i ] <> array2 [ i ] then
26134: LD_VAR 0 1
26138: PUSH
26139: LD_VAR 0 4
26143: ARRAY
26144: PUSH
26145: LD_VAR 0 2
26149: PUSH
26150: LD_VAR 0 4
26154: ARRAY
26155: NONEQUAL
26156: IFFALSE 26168
// begin result := false ;
26158: LD_ADDR_VAR 0 3
26162: PUSH
26163: LD_INT 0
26165: ST_TO_ADDR
// break ;
26166: GO 26170
// end ;
26168: GO 26131
26170: POP
26171: POP
// end else
26172: GO 26182
// result := false ;
26174: LD_ADDR_VAR 0 3
26178: PUSH
26179: LD_INT 0
26181: ST_TO_ADDR
// end ;
26182: LD_VAR 0 3
26186: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26187: LD_INT 0
26189: PPUSH
26190: PPUSH
// if not array1 or not array2 then
26191: LD_VAR 0 1
26195: NOT
26196: PUSH
26197: LD_VAR 0 2
26201: NOT
26202: OR
26203: IFFALSE 26207
// exit ;
26205: GO 26271
// result := true ;
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: LD_INT 1
26214: ST_TO_ADDR
// for i = 1 to array1 do
26215: LD_ADDR_VAR 0 4
26219: PUSH
26220: DOUBLE
26221: LD_INT 1
26223: DEC
26224: ST_TO_ADDR
26225: LD_VAR 0 1
26229: PUSH
26230: FOR_TO
26231: IFFALSE 26269
// if array1 [ i ] <> array2 [ i ] then
26233: LD_VAR 0 1
26237: PUSH
26238: LD_VAR 0 4
26242: ARRAY
26243: PUSH
26244: LD_VAR 0 2
26248: PUSH
26249: LD_VAR 0 4
26253: ARRAY
26254: NONEQUAL
26255: IFFALSE 26267
// begin result := false ;
26257: LD_ADDR_VAR 0 3
26261: PUSH
26262: LD_INT 0
26264: ST_TO_ADDR
// break ;
26265: GO 26269
// end ;
26267: GO 26230
26269: POP
26270: POP
// end ;
26271: LD_VAR 0 3
26275: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26276: LD_INT 0
26278: PPUSH
26279: PPUSH
26280: PPUSH
// pom := GetBase ( fac ) ;
26281: LD_ADDR_VAR 0 5
26285: PUSH
26286: LD_VAR 0 1
26290: PPUSH
26291: CALL_OW 274
26295: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26296: LD_ADDR_VAR 0 4
26300: PUSH
26301: LD_VAR 0 2
26305: PUSH
26306: LD_INT 1
26308: ARRAY
26309: PPUSH
26310: LD_VAR 0 2
26314: PUSH
26315: LD_INT 2
26317: ARRAY
26318: PPUSH
26319: LD_VAR 0 2
26323: PUSH
26324: LD_INT 3
26326: ARRAY
26327: PPUSH
26328: LD_VAR 0 2
26332: PUSH
26333: LD_INT 4
26335: ARRAY
26336: PPUSH
26337: CALL_OW 449
26341: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26342: LD_ADDR_VAR 0 3
26346: PUSH
26347: LD_VAR 0 5
26351: PPUSH
26352: LD_INT 1
26354: PPUSH
26355: CALL_OW 275
26359: PUSH
26360: LD_VAR 0 4
26364: PUSH
26365: LD_INT 1
26367: ARRAY
26368: GREATEREQUAL
26369: PUSH
26370: LD_VAR 0 5
26374: PPUSH
26375: LD_INT 2
26377: PPUSH
26378: CALL_OW 275
26382: PUSH
26383: LD_VAR 0 4
26387: PUSH
26388: LD_INT 2
26390: ARRAY
26391: GREATEREQUAL
26392: AND
26393: PUSH
26394: LD_VAR 0 5
26398: PPUSH
26399: LD_INT 3
26401: PPUSH
26402: CALL_OW 275
26406: PUSH
26407: LD_VAR 0 4
26411: PUSH
26412: LD_INT 3
26414: ARRAY
26415: GREATEREQUAL
26416: AND
26417: ST_TO_ADDR
// end ;
26418: LD_VAR 0 3
26422: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26423: LD_INT 0
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
// pom := GetBase ( building ) ;
26429: LD_ADDR_VAR 0 3
26433: PUSH
26434: LD_VAR 0 1
26438: PPUSH
26439: CALL_OW 274
26443: ST_TO_ADDR
// if not pom then
26444: LD_VAR 0 3
26448: NOT
26449: IFFALSE 26453
// exit ;
26451: GO 26623
// btype := GetBType ( building ) ;
26453: LD_ADDR_VAR 0 5
26457: PUSH
26458: LD_VAR 0 1
26462: PPUSH
26463: CALL_OW 266
26467: ST_TO_ADDR
// if btype = b_armoury then
26468: LD_VAR 0 5
26472: PUSH
26473: LD_INT 4
26475: EQUAL
26476: IFFALSE 26486
// btype := b_barracks ;
26478: LD_ADDR_VAR 0 5
26482: PUSH
26483: LD_INT 5
26485: ST_TO_ADDR
// if btype = b_depot then
26486: LD_VAR 0 5
26490: PUSH
26491: LD_INT 0
26493: EQUAL
26494: IFFALSE 26504
// btype := b_warehouse ;
26496: LD_ADDR_VAR 0 5
26500: PUSH
26501: LD_INT 1
26503: ST_TO_ADDR
// if btype = b_workshop then
26504: LD_VAR 0 5
26508: PUSH
26509: LD_INT 2
26511: EQUAL
26512: IFFALSE 26522
// btype := b_factory ;
26514: LD_ADDR_VAR 0 5
26518: PUSH
26519: LD_INT 3
26521: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26522: LD_ADDR_VAR 0 4
26526: PUSH
26527: LD_VAR 0 5
26531: PPUSH
26532: LD_VAR 0 1
26536: PPUSH
26537: CALL_OW 248
26541: PPUSH
26542: CALL_OW 450
26546: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26547: LD_ADDR_VAR 0 2
26551: PUSH
26552: LD_VAR 0 3
26556: PPUSH
26557: LD_INT 1
26559: PPUSH
26560: CALL_OW 275
26564: PUSH
26565: LD_VAR 0 4
26569: PUSH
26570: LD_INT 1
26572: ARRAY
26573: GREATEREQUAL
26574: PUSH
26575: LD_VAR 0 3
26579: PPUSH
26580: LD_INT 2
26582: PPUSH
26583: CALL_OW 275
26587: PUSH
26588: LD_VAR 0 4
26592: PUSH
26593: LD_INT 2
26595: ARRAY
26596: GREATEREQUAL
26597: AND
26598: PUSH
26599: LD_VAR 0 3
26603: PPUSH
26604: LD_INT 3
26606: PPUSH
26607: CALL_OW 275
26611: PUSH
26612: LD_VAR 0 4
26616: PUSH
26617: LD_INT 3
26619: ARRAY
26620: GREATEREQUAL
26621: AND
26622: ST_TO_ADDR
// end ;
26623: LD_VAR 0 2
26627: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26628: LD_INT 0
26630: PPUSH
26631: PPUSH
26632: PPUSH
// pom := GetBase ( building ) ;
26633: LD_ADDR_VAR 0 4
26637: PUSH
26638: LD_VAR 0 1
26642: PPUSH
26643: CALL_OW 274
26647: ST_TO_ADDR
// if not pom then
26648: LD_VAR 0 4
26652: NOT
26653: IFFALSE 26657
// exit ;
26655: GO 26758
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26657: LD_ADDR_VAR 0 5
26661: PUSH
26662: LD_VAR 0 2
26666: PPUSH
26667: LD_VAR 0 1
26671: PPUSH
26672: CALL_OW 248
26676: PPUSH
26677: CALL_OW 450
26681: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26682: LD_ADDR_VAR 0 3
26686: PUSH
26687: LD_VAR 0 4
26691: PPUSH
26692: LD_INT 1
26694: PPUSH
26695: CALL_OW 275
26699: PUSH
26700: LD_VAR 0 5
26704: PUSH
26705: LD_INT 1
26707: ARRAY
26708: GREATEREQUAL
26709: PUSH
26710: LD_VAR 0 4
26714: PPUSH
26715: LD_INT 2
26717: PPUSH
26718: CALL_OW 275
26722: PUSH
26723: LD_VAR 0 5
26727: PUSH
26728: LD_INT 2
26730: ARRAY
26731: GREATEREQUAL
26732: AND
26733: PUSH
26734: LD_VAR 0 4
26738: PPUSH
26739: LD_INT 3
26741: PPUSH
26742: CALL_OW 275
26746: PUSH
26747: LD_VAR 0 5
26751: PUSH
26752: LD_INT 3
26754: ARRAY
26755: GREATEREQUAL
26756: AND
26757: ST_TO_ADDR
// end ;
26758: LD_VAR 0 3
26762: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26763: LD_INT 0
26765: PPUSH
26766: PPUSH
26767: PPUSH
26768: PPUSH
26769: PPUSH
26770: PPUSH
26771: PPUSH
26772: PPUSH
26773: PPUSH
26774: PPUSH
26775: PPUSH
// result := false ;
26776: LD_ADDR_VAR 0 8
26780: PUSH
26781: LD_INT 0
26783: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26784: LD_VAR 0 5
26788: NOT
26789: PUSH
26790: LD_VAR 0 1
26794: NOT
26795: OR
26796: PUSH
26797: LD_VAR 0 2
26801: NOT
26802: OR
26803: PUSH
26804: LD_VAR 0 3
26808: NOT
26809: OR
26810: IFFALSE 26814
// exit ;
26812: GO 27628
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26814: LD_ADDR_VAR 0 14
26818: PUSH
26819: LD_VAR 0 1
26823: PPUSH
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_VAR 0 3
26833: PPUSH
26834: LD_VAR 0 4
26838: PPUSH
26839: LD_VAR 0 5
26843: PUSH
26844: LD_INT 1
26846: ARRAY
26847: PPUSH
26848: CALL_OW 248
26852: PPUSH
26853: LD_INT 0
26855: PPUSH
26856: CALL 28861 0 6
26860: ST_TO_ADDR
// if not hexes then
26861: LD_VAR 0 14
26865: NOT
26866: IFFALSE 26870
// exit ;
26868: GO 27628
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26870: LD_ADDR_VAR 0 17
26874: PUSH
26875: LD_VAR 0 5
26879: PPUSH
26880: LD_INT 22
26882: PUSH
26883: LD_VAR 0 13
26887: PPUSH
26888: CALL_OW 255
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 2
26899: PUSH
26900: LD_INT 30
26902: PUSH
26903: LD_INT 0
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 30
26912: PUSH
26913: LD_INT 1
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: LIST
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PPUSH
26929: CALL_OW 72
26933: ST_TO_ADDR
// for i = 1 to hexes do
26934: LD_ADDR_VAR 0 9
26938: PUSH
26939: DOUBLE
26940: LD_INT 1
26942: DEC
26943: ST_TO_ADDR
26944: LD_VAR 0 14
26948: PUSH
26949: FOR_TO
26950: IFFALSE 27626
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26952: LD_ADDR_VAR 0 13
26956: PUSH
26957: LD_VAR 0 14
26961: PUSH
26962: LD_VAR 0 9
26966: ARRAY
26967: PUSH
26968: LD_INT 1
26970: ARRAY
26971: PPUSH
26972: LD_VAR 0 14
26976: PUSH
26977: LD_VAR 0 9
26981: ARRAY
26982: PUSH
26983: LD_INT 2
26985: ARRAY
26986: PPUSH
26987: CALL_OW 428
26991: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26992: LD_VAR 0 14
26996: PUSH
26997: LD_VAR 0 9
27001: ARRAY
27002: PUSH
27003: LD_INT 1
27005: ARRAY
27006: PPUSH
27007: LD_VAR 0 14
27011: PUSH
27012: LD_VAR 0 9
27016: ARRAY
27017: PUSH
27018: LD_INT 2
27020: ARRAY
27021: PPUSH
27022: CALL_OW 351
27026: PUSH
27027: LD_VAR 0 14
27031: PUSH
27032: LD_VAR 0 9
27036: ARRAY
27037: PUSH
27038: LD_INT 1
27040: ARRAY
27041: PPUSH
27042: LD_VAR 0 14
27046: PUSH
27047: LD_VAR 0 9
27051: ARRAY
27052: PUSH
27053: LD_INT 2
27055: ARRAY
27056: PPUSH
27057: CALL_OW 488
27061: NOT
27062: OR
27063: PUSH
27064: LD_VAR 0 13
27068: PPUSH
27069: CALL_OW 247
27073: PUSH
27074: LD_INT 3
27076: EQUAL
27077: OR
27078: IFFALSE 27084
// exit ;
27080: POP
27081: POP
27082: GO 27628
// if not tmp then
27084: LD_VAR 0 13
27088: NOT
27089: IFFALSE 27093
// continue ;
27091: GO 26949
// result := true ;
27093: LD_ADDR_VAR 0 8
27097: PUSH
27098: LD_INT 1
27100: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27101: LD_VAR 0 6
27105: PUSH
27106: LD_VAR 0 13
27110: PPUSH
27111: CALL_OW 247
27115: PUSH
27116: LD_INT 2
27118: EQUAL
27119: AND
27120: PUSH
27121: LD_VAR 0 13
27125: PPUSH
27126: CALL_OW 263
27130: PUSH
27131: LD_INT 1
27133: EQUAL
27134: AND
27135: IFFALSE 27299
// begin if IsDrivenBy ( tmp ) then
27137: LD_VAR 0 13
27141: PPUSH
27142: CALL_OW 311
27146: IFFALSE 27150
// continue ;
27148: GO 26949
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27150: LD_VAR 0 6
27154: PPUSH
27155: LD_INT 3
27157: PUSH
27158: LD_INT 60
27160: PUSH
27161: EMPTY
27162: LIST
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 3
27170: PUSH
27171: LD_INT 55
27173: PUSH
27174: EMPTY
27175: LIST
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PPUSH
27185: CALL_OW 72
27189: IFFALSE 27297
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27191: LD_ADDR_VAR 0 18
27195: PUSH
27196: LD_VAR 0 6
27200: PPUSH
27201: LD_INT 3
27203: PUSH
27204: LD_INT 60
27206: PUSH
27207: EMPTY
27208: LIST
27209: PUSH
27210: EMPTY
27211: LIST
27212: LIST
27213: PUSH
27214: LD_INT 3
27216: PUSH
27217: LD_INT 55
27219: PUSH
27220: EMPTY
27221: LIST
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PPUSH
27231: CALL_OW 72
27235: PUSH
27236: LD_INT 1
27238: ARRAY
27239: ST_TO_ADDR
// if IsInUnit ( driver ) then
27240: LD_VAR 0 18
27244: PPUSH
27245: CALL_OW 310
27249: IFFALSE 27260
// ComExit ( driver ) ;
27251: LD_VAR 0 18
27255: PPUSH
27256: CALL 52640 0 1
// AddComEnterUnit ( driver , tmp ) ;
27260: LD_VAR 0 18
27264: PPUSH
27265: LD_VAR 0 13
27269: PPUSH
27270: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27274: LD_VAR 0 18
27278: PPUSH
27279: LD_VAR 0 7
27283: PPUSH
27284: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27288: LD_VAR 0 18
27292: PPUSH
27293: CALL_OW 181
// end ; continue ;
27297: GO 26949
// end ; if not cleaners or not tmp in cleaners then
27299: LD_VAR 0 6
27303: NOT
27304: PUSH
27305: LD_VAR 0 13
27309: PUSH
27310: LD_VAR 0 6
27314: IN
27315: NOT
27316: OR
27317: IFFALSE 27624
// begin if dep then
27319: LD_VAR 0 17
27323: IFFALSE 27459
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27325: LD_ADDR_VAR 0 16
27329: PUSH
27330: LD_VAR 0 17
27334: PUSH
27335: LD_INT 1
27337: ARRAY
27338: PPUSH
27339: CALL_OW 250
27343: PPUSH
27344: LD_VAR 0 17
27348: PUSH
27349: LD_INT 1
27351: ARRAY
27352: PPUSH
27353: CALL_OW 254
27357: PPUSH
27358: LD_INT 5
27360: PPUSH
27361: CALL_OW 272
27365: PUSH
27366: LD_VAR 0 17
27370: PUSH
27371: LD_INT 1
27373: ARRAY
27374: PPUSH
27375: CALL_OW 251
27379: PPUSH
27380: LD_VAR 0 17
27384: PUSH
27385: LD_INT 1
27387: ARRAY
27388: PPUSH
27389: CALL_OW 254
27393: PPUSH
27394: LD_INT 5
27396: PPUSH
27397: CALL_OW 273
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27406: LD_VAR 0 16
27410: PUSH
27411: LD_INT 1
27413: ARRAY
27414: PPUSH
27415: LD_VAR 0 16
27419: PUSH
27420: LD_INT 2
27422: ARRAY
27423: PPUSH
27424: CALL_OW 488
27428: IFFALSE 27459
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27430: LD_VAR 0 13
27434: PPUSH
27435: LD_VAR 0 16
27439: PUSH
27440: LD_INT 1
27442: ARRAY
27443: PPUSH
27444: LD_VAR 0 16
27448: PUSH
27449: LD_INT 2
27451: ARRAY
27452: PPUSH
27453: CALL_OW 111
// continue ;
27457: GO 26949
// end ; end ; r := GetDir ( tmp ) ;
27459: LD_ADDR_VAR 0 15
27463: PUSH
27464: LD_VAR 0 13
27468: PPUSH
27469: CALL_OW 254
27473: ST_TO_ADDR
// if r = 5 then
27474: LD_VAR 0 15
27478: PUSH
27479: LD_INT 5
27481: EQUAL
27482: IFFALSE 27492
// r := 0 ;
27484: LD_ADDR_VAR 0 15
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// for j = r to 5 do
27492: LD_ADDR_VAR 0 10
27496: PUSH
27497: DOUBLE
27498: LD_VAR 0 15
27502: DEC
27503: ST_TO_ADDR
27504: LD_INT 5
27506: PUSH
27507: FOR_TO
27508: IFFALSE 27622
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27510: LD_ADDR_VAR 0 11
27514: PUSH
27515: LD_VAR 0 13
27519: PPUSH
27520: CALL_OW 250
27524: PPUSH
27525: LD_VAR 0 10
27529: PPUSH
27530: LD_INT 2
27532: PPUSH
27533: CALL_OW 272
27537: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27538: LD_ADDR_VAR 0 12
27542: PUSH
27543: LD_VAR 0 13
27547: PPUSH
27548: CALL_OW 251
27552: PPUSH
27553: LD_VAR 0 10
27557: PPUSH
27558: LD_INT 2
27560: PPUSH
27561: CALL_OW 273
27565: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27566: LD_VAR 0 11
27570: PPUSH
27571: LD_VAR 0 12
27575: PPUSH
27576: CALL_OW 488
27580: PUSH
27581: LD_VAR 0 11
27585: PPUSH
27586: LD_VAR 0 12
27590: PPUSH
27591: CALL_OW 428
27595: NOT
27596: AND
27597: IFFALSE 27620
// begin ComMoveXY ( tmp , _x , _y ) ;
27599: LD_VAR 0 13
27603: PPUSH
27604: LD_VAR 0 11
27608: PPUSH
27609: LD_VAR 0 12
27613: PPUSH
27614: CALL_OW 111
// break ;
27618: GO 27622
// end ; end ;
27620: GO 27507
27622: POP
27623: POP
// end ; end ;
27624: GO 26949
27626: POP
27627: POP
// end ;
27628: LD_VAR 0 8
27632: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27633: LD_INT 0
27635: PPUSH
// result := true ;
27636: LD_ADDR_VAR 0 3
27640: PUSH
27641: LD_INT 1
27643: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27644: LD_VAR 0 2
27648: PUSH
27649: LD_INT 24
27651: DOUBLE
27652: EQUAL
27653: IFTRUE 27663
27655: LD_INT 33
27657: DOUBLE
27658: EQUAL
27659: IFTRUE 27663
27661: GO 27688
27663: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27664: LD_ADDR_VAR 0 3
27668: PUSH
27669: LD_INT 32
27671: PPUSH
27672: LD_VAR 0 1
27676: PPUSH
27677: CALL_OW 321
27681: PUSH
27682: LD_INT 2
27684: EQUAL
27685: ST_TO_ADDR
27686: GO 28004
27688: LD_INT 20
27690: DOUBLE
27691: EQUAL
27692: IFTRUE 27696
27694: GO 27721
27696: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27697: LD_ADDR_VAR 0 3
27701: PUSH
27702: LD_INT 6
27704: PPUSH
27705: LD_VAR 0 1
27709: PPUSH
27710: CALL_OW 321
27714: PUSH
27715: LD_INT 2
27717: EQUAL
27718: ST_TO_ADDR
27719: GO 28004
27721: LD_INT 22
27723: DOUBLE
27724: EQUAL
27725: IFTRUE 27735
27727: LD_INT 36
27729: DOUBLE
27730: EQUAL
27731: IFTRUE 27735
27733: GO 27760
27735: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27736: LD_ADDR_VAR 0 3
27740: PUSH
27741: LD_INT 15
27743: PPUSH
27744: LD_VAR 0 1
27748: PPUSH
27749: CALL_OW 321
27753: PUSH
27754: LD_INT 2
27756: EQUAL
27757: ST_TO_ADDR
27758: GO 28004
27760: LD_INT 30
27762: DOUBLE
27763: EQUAL
27764: IFTRUE 27768
27766: GO 27793
27768: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27769: LD_ADDR_VAR 0 3
27773: PUSH
27774: LD_INT 20
27776: PPUSH
27777: LD_VAR 0 1
27781: PPUSH
27782: CALL_OW 321
27786: PUSH
27787: LD_INT 2
27789: EQUAL
27790: ST_TO_ADDR
27791: GO 28004
27793: LD_INT 28
27795: DOUBLE
27796: EQUAL
27797: IFTRUE 27807
27799: LD_INT 21
27801: DOUBLE
27802: EQUAL
27803: IFTRUE 27807
27805: GO 27832
27807: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27808: LD_ADDR_VAR 0 3
27812: PUSH
27813: LD_INT 21
27815: PPUSH
27816: LD_VAR 0 1
27820: PPUSH
27821: CALL_OW 321
27825: PUSH
27826: LD_INT 2
27828: EQUAL
27829: ST_TO_ADDR
27830: GO 28004
27832: LD_INT 16
27834: DOUBLE
27835: EQUAL
27836: IFTRUE 27840
27838: GO 27865
27840: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27841: LD_ADDR_VAR 0 3
27845: PUSH
27846: LD_INT 84
27848: PPUSH
27849: LD_VAR 0 1
27853: PPUSH
27854: CALL_OW 321
27858: PUSH
27859: LD_INT 2
27861: EQUAL
27862: ST_TO_ADDR
27863: GO 28004
27865: LD_INT 19
27867: DOUBLE
27868: EQUAL
27869: IFTRUE 27879
27871: LD_INT 23
27873: DOUBLE
27874: EQUAL
27875: IFTRUE 27879
27877: GO 27904
27879: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27880: LD_ADDR_VAR 0 3
27884: PUSH
27885: LD_INT 83
27887: PPUSH
27888: LD_VAR 0 1
27892: PPUSH
27893: CALL_OW 321
27897: PUSH
27898: LD_INT 2
27900: EQUAL
27901: ST_TO_ADDR
27902: GO 28004
27904: LD_INT 17
27906: DOUBLE
27907: EQUAL
27908: IFTRUE 27912
27910: GO 27937
27912: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27913: LD_ADDR_VAR 0 3
27917: PUSH
27918: LD_INT 39
27920: PPUSH
27921: LD_VAR 0 1
27925: PPUSH
27926: CALL_OW 321
27930: PUSH
27931: LD_INT 2
27933: EQUAL
27934: ST_TO_ADDR
27935: GO 28004
27937: LD_INT 18
27939: DOUBLE
27940: EQUAL
27941: IFTRUE 27945
27943: GO 27970
27945: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27946: LD_ADDR_VAR 0 3
27950: PUSH
27951: LD_INT 40
27953: PPUSH
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 321
27963: PUSH
27964: LD_INT 2
27966: EQUAL
27967: ST_TO_ADDR
27968: GO 28004
27970: LD_INT 27
27972: DOUBLE
27973: EQUAL
27974: IFTRUE 27978
27976: GO 28003
27978: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27979: LD_ADDR_VAR 0 3
27983: PUSH
27984: LD_INT 35
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 321
27996: PUSH
27997: LD_INT 2
27999: EQUAL
28000: ST_TO_ADDR
28001: GO 28004
28003: POP
// end ;
28004: LD_VAR 0 3
28008: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28009: LD_INT 0
28011: PPUSH
28012: PPUSH
28013: PPUSH
28014: PPUSH
28015: PPUSH
28016: PPUSH
28017: PPUSH
28018: PPUSH
28019: PPUSH
28020: PPUSH
28021: PPUSH
// result := false ;
28022: LD_ADDR_VAR 0 6
28026: PUSH
28027: LD_INT 0
28029: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28030: LD_VAR 0 1
28034: NOT
28035: PUSH
28036: LD_VAR 0 1
28040: PPUSH
28041: CALL_OW 266
28045: PUSH
28046: LD_INT 0
28048: PUSH
28049: LD_INT 1
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: IN
28056: NOT
28057: OR
28058: PUSH
28059: LD_VAR 0 2
28063: NOT
28064: OR
28065: PUSH
28066: LD_VAR 0 5
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: LD_INT 1
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: LD_INT 3
28082: PUSH
28083: LD_INT 4
28085: PUSH
28086: LD_INT 5
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: IN
28097: NOT
28098: OR
28099: PUSH
28100: LD_VAR 0 3
28104: PPUSH
28105: LD_VAR 0 4
28109: PPUSH
28110: CALL_OW 488
28114: NOT
28115: OR
28116: IFFALSE 28120
// exit ;
28118: GO 28856
// side := GetSide ( depot ) ;
28120: LD_ADDR_VAR 0 9
28124: PUSH
28125: LD_VAR 0 1
28129: PPUSH
28130: CALL_OW 255
28134: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28135: LD_VAR 0 9
28139: PPUSH
28140: LD_VAR 0 2
28144: PPUSH
28145: CALL 27633 0 2
28149: NOT
28150: IFFALSE 28154
// exit ;
28152: GO 28856
// pom := GetBase ( depot ) ;
28154: LD_ADDR_VAR 0 10
28158: PUSH
28159: LD_VAR 0 1
28163: PPUSH
28164: CALL_OW 274
28168: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28169: LD_ADDR_VAR 0 11
28173: PUSH
28174: LD_VAR 0 2
28178: PPUSH
28179: LD_VAR 0 1
28183: PPUSH
28184: CALL_OW 248
28188: PPUSH
28189: CALL_OW 450
28193: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28194: LD_VAR 0 10
28198: PPUSH
28199: LD_INT 1
28201: PPUSH
28202: CALL_OW 275
28206: PUSH
28207: LD_VAR 0 11
28211: PUSH
28212: LD_INT 1
28214: ARRAY
28215: GREATEREQUAL
28216: PUSH
28217: LD_VAR 0 10
28221: PPUSH
28222: LD_INT 2
28224: PPUSH
28225: CALL_OW 275
28229: PUSH
28230: LD_VAR 0 11
28234: PUSH
28235: LD_INT 2
28237: ARRAY
28238: GREATEREQUAL
28239: AND
28240: PUSH
28241: LD_VAR 0 10
28245: PPUSH
28246: LD_INT 3
28248: PPUSH
28249: CALL_OW 275
28253: PUSH
28254: LD_VAR 0 11
28258: PUSH
28259: LD_INT 3
28261: ARRAY
28262: GREATEREQUAL
28263: AND
28264: NOT
28265: IFFALSE 28269
// exit ;
28267: GO 28856
// if GetBType ( depot ) = b_depot then
28269: LD_VAR 0 1
28273: PPUSH
28274: CALL_OW 266
28278: PUSH
28279: LD_INT 0
28281: EQUAL
28282: IFFALSE 28294
// dist := 28 else
28284: LD_ADDR_VAR 0 14
28288: PUSH
28289: LD_INT 28
28291: ST_TO_ADDR
28292: GO 28302
// dist := 36 ;
28294: LD_ADDR_VAR 0 14
28298: PUSH
28299: LD_INT 36
28301: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28302: LD_VAR 0 1
28306: PPUSH
28307: LD_VAR 0 3
28311: PPUSH
28312: LD_VAR 0 4
28316: PPUSH
28317: CALL_OW 297
28321: PUSH
28322: LD_VAR 0 14
28326: GREATER
28327: IFFALSE 28331
// exit ;
28329: GO 28856
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28331: LD_ADDR_VAR 0 12
28335: PUSH
28336: LD_VAR 0 2
28340: PPUSH
28341: LD_VAR 0 3
28345: PPUSH
28346: LD_VAR 0 4
28350: PPUSH
28351: LD_VAR 0 5
28355: PPUSH
28356: LD_VAR 0 1
28360: PPUSH
28361: CALL_OW 248
28365: PPUSH
28366: LD_INT 0
28368: PPUSH
28369: CALL 28861 0 6
28373: ST_TO_ADDR
// if not hexes then
28374: LD_VAR 0 12
28378: NOT
28379: IFFALSE 28383
// exit ;
28381: GO 28856
// hex := GetHexInfo ( x , y ) ;
28383: LD_ADDR_VAR 0 15
28387: PUSH
28388: LD_VAR 0 3
28392: PPUSH
28393: LD_VAR 0 4
28397: PPUSH
28398: CALL_OW 546
28402: ST_TO_ADDR
// if hex [ 1 ] then
28403: LD_VAR 0 15
28407: PUSH
28408: LD_INT 1
28410: ARRAY
28411: IFFALSE 28415
// exit ;
28413: GO 28856
// height := hex [ 2 ] ;
28415: LD_ADDR_VAR 0 13
28419: PUSH
28420: LD_VAR 0 15
28424: PUSH
28425: LD_INT 2
28427: ARRAY
28428: ST_TO_ADDR
// for i = 1 to hexes do
28429: LD_ADDR_VAR 0 7
28433: PUSH
28434: DOUBLE
28435: LD_INT 1
28437: DEC
28438: ST_TO_ADDR
28439: LD_VAR 0 12
28443: PUSH
28444: FOR_TO
28445: IFFALSE 28775
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28447: LD_VAR 0 12
28451: PUSH
28452: LD_VAR 0 7
28456: ARRAY
28457: PUSH
28458: LD_INT 1
28460: ARRAY
28461: PPUSH
28462: LD_VAR 0 12
28466: PUSH
28467: LD_VAR 0 7
28471: ARRAY
28472: PUSH
28473: LD_INT 2
28475: ARRAY
28476: PPUSH
28477: CALL_OW 488
28481: NOT
28482: PUSH
28483: LD_VAR 0 12
28487: PUSH
28488: LD_VAR 0 7
28492: ARRAY
28493: PUSH
28494: LD_INT 1
28496: ARRAY
28497: PPUSH
28498: LD_VAR 0 12
28502: PUSH
28503: LD_VAR 0 7
28507: ARRAY
28508: PUSH
28509: LD_INT 2
28511: ARRAY
28512: PPUSH
28513: CALL_OW 428
28517: PUSH
28518: LD_INT 0
28520: GREATER
28521: OR
28522: PUSH
28523: LD_VAR 0 12
28527: PUSH
28528: LD_VAR 0 7
28532: ARRAY
28533: PUSH
28534: LD_INT 1
28536: ARRAY
28537: PPUSH
28538: LD_VAR 0 12
28542: PUSH
28543: LD_VAR 0 7
28547: ARRAY
28548: PUSH
28549: LD_INT 2
28551: ARRAY
28552: PPUSH
28553: CALL_OW 351
28557: OR
28558: IFFALSE 28564
// exit ;
28560: POP
28561: POP
28562: GO 28856
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28564: LD_ADDR_VAR 0 8
28568: PUSH
28569: LD_VAR 0 12
28573: PUSH
28574: LD_VAR 0 7
28578: ARRAY
28579: PUSH
28580: LD_INT 1
28582: ARRAY
28583: PPUSH
28584: LD_VAR 0 12
28588: PUSH
28589: LD_VAR 0 7
28593: ARRAY
28594: PUSH
28595: LD_INT 2
28597: ARRAY
28598: PPUSH
28599: CALL_OW 546
28603: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28604: LD_VAR 0 8
28608: PUSH
28609: LD_INT 1
28611: ARRAY
28612: PUSH
28613: LD_VAR 0 8
28617: PUSH
28618: LD_INT 2
28620: ARRAY
28621: PUSH
28622: LD_VAR 0 13
28626: PUSH
28627: LD_INT 2
28629: PLUS
28630: GREATER
28631: OR
28632: PUSH
28633: LD_VAR 0 8
28637: PUSH
28638: LD_INT 2
28640: ARRAY
28641: PUSH
28642: LD_VAR 0 13
28646: PUSH
28647: LD_INT 2
28649: MINUS
28650: LESS
28651: OR
28652: PUSH
28653: LD_VAR 0 8
28657: PUSH
28658: LD_INT 3
28660: ARRAY
28661: PUSH
28662: LD_INT 0
28664: PUSH
28665: LD_INT 8
28667: PUSH
28668: LD_INT 9
28670: PUSH
28671: LD_INT 10
28673: PUSH
28674: LD_INT 11
28676: PUSH
28677: LD_INT 12
28679: PUSH
28680: LD_INT 13
28682: PUSH
28683: LD_INT 16
28685: PUSH
28686: LD_INT 17
28688: PUSH
28689: LD_INT 18
28691: PUSH
28692: LD_INT 19
28694: PUSH
28695: LD_INT 20
28697: PUSH
28698: LD_INT 21
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: IN
28716: NOT
28717: OR
28718: PUSH
28719: LD_VAR 0 8
28723: PUSH
28724: LD_INT 5
28726: ARRAY
28727: NOT
28728: OR
28729: PUSH
28730: LD_VAR 0 8
28734: PUSH
28735: LD_INT 6
28737: ARRAY
28738: PUSH
28739: LD_INT 1
28741: PUSH
28742: LD_INT 2
28744: PUSH
28745: LD_INT 7
28747: PUSH
28748: LD_INT 9
28750: PUSH
28751: LD_INT 10
28753: PUSH
28754: LD_INT 11
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: IN
28765: NOT
28766: OR
28767: IFFALSE 28773
// exit ;
28769: POP
28770: POP
28771: GO 28856
// end ;
28773: GO 28444
28775: POP
28776: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28777: LD_VAR 0 9
28781: PPUSH
28782: LD_VAR 0 3
28786: PPUSH
28787: LD_VAR 0 4
28791: PPUSH
28792: LD_INT 20
28794: PPUSH
28795: CALL 20808 0 4
28799: PUSH
28800: LD_INT 4
28802: ARRAY
28803: IFFALSE 28807
// exit ;
28805: GO 28856
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28807: LD_VAR 0 2
28811: PUSH
28812: LD_INT 29
28814: PUSH
28815: LD_INT 30
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: IN
28822: PUSH
28823: LD_VAR 0 3
28827: PPUSH
28828: LD_VAR 0 4
28832: PPUSH
28833: LD_VAR 0 9
28837: PPUSH
28838: CALL_OW 440
28842: NOT
28843: AND
28844: IFFALSE 28848
// exit ;
28846: GO 28856
// result := true ;
28848: LD_ADDR_VAR 0 6
28852: PUSH
28853: LD_INT 1
28855: ST_TO_ADDR
// end ;
28856: LD_VAR 0 6
28860: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28861: LD_INT 0
28863: PPUSH
28864: PPUSH
28865: PPUSH
28866: PPUSH
28867: PPUSH
28868: PPUSH
28869: PPUSH
28870: PPUSH
28871: PPUSH
28872: PPUSH
28873: PPUSH
28874: PPUSH
28875: PPUSH
28876: PPUSH
28877: PPUSH
28878: PPUSH
28879: PPUSH
28880: PPUSH
28881: PPUSH
28882: PPUSH
28883: PPUSH
28884: PPUSH
28885: PPUSH
28886: PPUSH
28887: PPUSH
28888: PPUSH
28889: PPUSH
28890: PPUSH
28891: PPUSH
28892: PPUSH
28893: PPUSH
28894: PPUSH
28895: PPUSH
28896: PPUSH
28897: PPUSH
28898: PPUSH
28899: PPUSH
28900: PPUSH
28901: PPUSH
28902: PPUSH
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
// result = [ ] ;
28921: LD_ADDR_VAR 0 7
28925: PUSH
28926: EMPTY
28927: ST_TO_ADDR
// temp_list = [ ] ;
28928: LD_ADDR_VAR 0 9
28932: PUSH
28933: EMPTY
28934: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28935: LD_VAR 0 4
28939: PUSH
28940: LD_INT 0
28942: PUSH
28943: LD_INT 1
28945: PUSH
28946: LD_INT 2
28948: PUSH
28949: LD_INT 3
28951: PUSH
28952: LD_INT 4
28954: PUSH
28955: LD_INT 5
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: LIST
28962: LIST
28963: LIST
28964: LIST
28965: IN
28966: NOT
28967: PUSH
28968: LD_VAR 0 1
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: IN
28983: PUSH
28984: LD_VAR 0 5
28988: PUSH
28989: LD_INT 1
28991: PUSH
28992: LD_INT 2
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: LIST
29002: IN
29003: NOT
29004: AND
29005: OR
29006: IFFALSE 29010
// exit ;
29008: GO 47401
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29010: LD_VAR 0 1
29014: PUSH
29015: LD_INT 6
29017: PUSH
29018: LD_INT 7
29020: PUSH
29021: LD_INT 8
29023: PUSH
29024: LD_INT 13
29026: PUSH
29027: LD_INT 12
29029: PUSH
29030: LD_INT 15
29032: PUSH
29033: LD_INT 11
29035: PUSH
29036: LD_INT 14
29038: PUSH
29039: LD_INT 10
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: IN
29053: IFFALSE 29063
// btype = b_lab ;
29055: LD_ADDR_VAR 0 1
29059: PUSH
29060: LD_INT 6
29062: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29063: LD_VAR 0 6
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: LD_INT 2
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: LIST
29081: IN
29082: NOT
29083: PUSH
29084: LD_VAR 0 1
29088: PUSH
29089: LD_INT 0
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: LD_INT 3
29100: PUSH
29101: LD_INT 6
29103: PUSH
29104: LD_INT 36
29106: PUSH
29107: LD_INT 4
29109: PUSH
29110: LD_INT 5
29112: PUSH
29113: LD_INT 31
29115: PUSH
29116: LD_INT 32
29118: PUSH
29119: LD_INT 33
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: IN
29135: NOT
29136: PUSH
29137: LD_VAR 0 6
29141: PUSH
29142: LD_INT 1
29144: EQUAL
29145: AND
29146: OR
29147: PUSH
29148: LD_VAR 0 1
29152: PUSH
29153: LD_INT 2
29155: PUSH
29156: LD_INT 3
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: IN
29163: NOT
29164: PUSH
29165: LD_VAR 0 6
29169: PUSH
29170: LD_INT 2
29172: EQUAL
29173: AND
29174: OR
29175: IFFALSE 29185
// mode = 0 ;
29177: LD_ADDR_VAR 0 6
29181: PUSH
29182: LD_INT 0
29184: ST_TO_ADDR
// case mode of 0 :
29185: LD_VAR 0 6
29189: PUSH
29190: LD_INT 0
29192: DOUBLE
29193: EQUAL
29194: IFTRUE 29198
29196: GO 40651
29198: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29199: LD_ADDR_VAR 0 11
29203: PUSH
29204: LD_INT 0
29206: PUSH
29207: LD_INT 0
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 0
29216: PUSH
29217: LD_INT 1
29219: NEG
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 1
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: EMPTY
29232: LIST
29233: LIST
29234: PUSH
29235: LD_INT 1
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 0
29247: PUSH
29248: LD_INT 1
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 1
29257: NEG
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PUSH
29266: LD_INT 1
29268: NEG
29269: PUSH
29270: LD_INT 1
29272: NEG
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: NEG
29281: PUSH
29282: LD_INT 2
29284: NEG
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 0
29292: PUSH
29293: LD_INT 2
29295: NEG
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: LD_INT 1
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: LD_INT 2
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 0
29324: PUSH
29325: LD_INT 2
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 1
29334: NEG
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 1
29345: PUSH
29346: LD_INT 3
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 0
29355: PUSH
29356: LD_INT 3
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 1
29365: NEG
29366: PUSH
29367: LD_INT 2
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: LIST
29378: LIST
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: LIST
29391: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29392: LD_ADDR_VAR 0 12
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 0
29409: PUSH
29410: LD_INT 1
29412: NEG
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 0
29440: PUSH
29441: LD_INT 1
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 1
29450: NEG
29451: PUSH
29452: LD_INT 0
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 1
29461: NEG
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 1
29473: PUSH
29474: LD_INT 1
29476: NEG
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 2
29494: PUSH
29495: LD_INT 1
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 1
29504: NEG
29505: PUSH
29506: LD_INT 1
29508: PUSH
29509: EMPTY
29510: LIST
29511: LIST
29512: PUSH
29513: LD_INT 2
29515: NEG
29516: PUSH
29517: LD_INT 0
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 2
29526: NEG
29527: PUSH
29528: LD_INT 1
29530: NEG
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 3
29549: NEG
29550: PUSH
29551: LD_INT 0
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 3
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: NEG
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: LIST
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29588: LD_ADDR_VAR 0 13
29592: PUSH
29593: LD_INT 0
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 0
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 1
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 1
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 0
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 1
29646: NEG
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 1
29657: NEG
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 1
29669: NEG
29670: PUSH
29671: LD_INT 2
29673: NEG
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: PUSH
29692: LD_INT 2
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 2
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 2
29711: NEG
29712: PUSH
29713: LD_INT 1
29715: NEG
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 2
29723: NEG
29724: PUSH
29725: LD_INT 2
29727: NEG
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 2
29735: NEG
29736: PUSH
29737: LD_INT 3
29739: NEG
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: LD_INT 3
29747: NEG
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 3
29759: NEG
29760: PUSH
29761: LD_INT 3
29763: NEG
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: LIST
29786: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29787: LD_ADDR_VAR 0 14
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 0
29804: PUSH
29805: LD_INT 1
29807: NEG
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 1
29815: PUSH
29816: LD_INT 0
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 1
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 0
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 1
29845: NEG
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 1
29856: NEG
29857: PUSH
29858: LD_INT 1
29860: NEG
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 1
29868: NEG
29869: PUSH
29870: LD_INT 2
29872: NEG
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: PUSH
29878: LD_INT 0
29880: PUSH
29881: LD_INT 2
29883: NEG
29884: PUSH
29885: EMPTY
29886: LIST
29887: LIST
29888: PUSH
29889: LD_INT 1
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 1
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 0
29912: PUSH
29913: LD_INT 2
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 1
29922: NEG
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: LD_INT 3
29937: NEG
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 3
29948: NEG
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: LD_INT 1
29956: PUSH
29957: LD_INT 2
29959: NEG
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: LIST
29980: LIST
29981: LIST
29982: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29983: LD_ADDR_VAR 0 15
29987: PUSH
29988: LD_INT 0
29990: PUSH
29991: LD_INT 0
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 0
30000: PUSH
30001: LD_INT 1
30003: NEG
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: LD_INT 1
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 1
30041: NEG
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 1
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 2
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 0
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 2
30117: NEG
30118: PUSH
30119: LD_INT 1
30121: NEG
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 2
30129: PUSH
30130: LD_INT 1
30132: NEG
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 3
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 3
30150: PUSH
30151: LD_INT 1
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30176: LD_ADDR_VAR 0 16
30180: PUSH
30181: LD_INT 0
30183: PUSH
30184: LD_INT 0
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 0
30193: PUSH
30194: LD_INT 1
30196: NEG
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 1
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: PUSH
30215: LD_INT 1
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 0
30224: PUSH
30225: LD_INT 1
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: LD_INT 0
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: LD_INT 2
30261: NEG
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: PUSH
30267: LD_INT 2
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 2
30279: PUSH
30280: LD_INT 2
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 2
30299: NEG
30300: PUSH
30301: LD_INT 1
30303: NEG
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 2
30311: NEG
30312: PUSH
30313: LD_INT 2
30315: NEG
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 3
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 3
30333: PUSH
30334: LD_INT 3
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 2
30343: PUSH
30344: LD_INT 3
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30369: LD_ADDR_VAR 0 17
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: LD_INT 0
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 0
30386: PUSH
30387: LD_INT 1
30389: NEG
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 1
30397: PUSH
30398: LD_INT 0
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: LD_INT 1
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: LD_INT 1
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 1
30427: NEG
30428: PUSH
30429: LD_INT 0
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 1
30438: NEG
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 1
30450: NEG
30451: PUSH
30452: LD_INT 2
30454: NEG
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: LD_INT 2
30465: NEG
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: PUSH
30471: LD_INT 1
30473: PUSH
30474: LD_INT 1
30476: NEG
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: LD_INT 0
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 2
30494: PUSH
30495: LD_INT 1
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 2
30504: PUSH
30505: LD_INT 2
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 1
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: LD_INT 2
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 1
30534: NEG
30535: PUSH
30536: LD_INT 1
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 2
30545: NEG
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 2
30556: NEG
30557: PUSH
30558: LD_INT 1
30560: NEG
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: LD_INT 2
30572: NEG
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30599: LD_ADDR_VAR 0 18
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: LD_INT 0
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 0
30616: PUSH
30617: LD_INT 1
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 1
30627: PUSH
30628: LD_INT 0
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 1
30637: PUSH
30638: LD_INT 1
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: LD_INT 1
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: LD_INT 1
30657: NEG
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 1
30668: NEG
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: LD_INT 2
30684: NEG
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 0
30692: PUSH
30693: LD_INT 2
30695: NEG
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 1
30703: PUSH
30704: LD_INT 1
30706: NEG
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: PUSH
30715: LD_INT 0
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 2
30734: PUSH
30735: LD_INT 2
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 1
30744: PUSH
30745: LD_INT 2
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 0
30754: PUSH
30755: LD_INT 2
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 1
30764: NEG
30765: PUSH
30766: LD_INT 1
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 2
30775: NEG
30776: PUSH
30777: LD_INT 0
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 2
30786: NEG
30787: PUSH
30788: LD_INT 1
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 2
30798: NEG
30799: PUSH
30800: LD_INT 2
30802: NEG
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: LIST
30821: LIST
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30829: LD_ADDR_VAR 0 19
30833: PUSH
30834: LD_INT 0
30836: PUSH
30837: LD_INT 0
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 0
30846: PUSH
30847: LD_INT 1
30849: NEG
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PUSH
30855: LD_INT 1
30857: PUSH
30858: LD_INT 0
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: LD_INT 1
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: LD_INT 0
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 1
30898: NEG
30899: PUSH
30900: LD_INT 1
30902: NEG
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: LD_INT 2
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 0
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 1
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: PUSH
30945: LD_INT 0
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 2
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 2
30964: PUSH
30965: LD_INT 2
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: PUSH
30975: LD_INT 2
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 1
30994: NEG
30995: PUSH
30996: LD_INT 1
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 2
31005: NEG
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 2
31016: NEG
31017: PUSH
31018: LD_INT 1
31020: NEG
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 2
31028: NEG
31029: PUSH
31030: LD_INT 2
31032: NEG
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: LIST
31054: LIST
31055: LIST
31056: LIST
31057: LIST
31058: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31059: LD_ADDR_VAR 0 20
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: LD_INT 0
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: LD_INT 1
31079: NEG
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 1
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: LD_INT 1
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 1
31117: NEG
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 1
31128: NEG
31129: PUSH
31130: LD_INT 1
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 1
31140: NEG
31141: PUSH
31142: LD_INT 2
31144: NEG
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 0
31152: PUSH
31153: LD_INT 2
31155: NEG
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 1
31163: PUSH
31164: LD_INT 1
31166: NEG
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: LD_INT 0
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 1
31224: NEG
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 2
31235: NEG
31236: PUSH
31237: LD_INT 0
31239: PUSH
31240: EMPTY
31241: LIST
31242: LIST
31243: PUSH
31244: LD_INT 2
31246: NEG
31247: PUSH
31248: LD_INT 1
31250: NEG
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: NEG
31259: PUSH
31260: LD_INT 2
31262: NEG
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: LIST
31286: LIST
31287: LIST
31288: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31289: LD_ADDR_VAR 0 21
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 0
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: LD_INT 0
31306: PUSH
31307: LD_INT 1
31309: NEG
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: LD_INT 1
31317: PUSH
31318: LD_INT 0
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 0
31337: PUSH
31338: LD_INT 1
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: LD_INT 0
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: LD_INT 1
31362: NEG
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 1
31370: NEG
31371: PUSH
31372: LD_INT 2
31374: NEG
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 0
31382: PUSH
31383: LD_INT 2
31385: NEG
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 1
31393: PUSH
31394: LD_INT 1
31396: NEG
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 1
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 2
31424: PUSH
31425: LD_INT 2
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: PUSH
31435: LD_INT 2
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: LD_INT 2
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 1
31454: NEG
31455: PUSH
31456: LD_INT 1
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 2
31465: NEG
31466: PUSH
31467: LD_INT 0
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 2
31476: NEG
31477: PUSH
31478: LD_INT 1
31480: NEG
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: LD_INT 2
31492: NEG
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31519: LD_ADDR_VAR 0 22
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 0
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: LD_INT 0
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 0
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 1
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: LD_INT 1
31570: PUSH
31571: EMPTY
31572: LIST
31573: LIST
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: LD_INT 0
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 1
31588: NEG
31589: PUSH
31590: LD_INT 1
31592: NEG
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 1
31600: NEG
31601: PUSH
31602: LD_INT 2
31604: NEG
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: LD_INT 0
31612: PUSH
31613: LD_INT 2
31615: NEG
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 1
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: PUSH
31635: LD_INT 0
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: LD_INT 1
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: LD_INT 2
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 1
31664: PUSH
31665: LD_INT 2
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 2
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 1
31684: NEG
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 2
31695: NEG
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: EMPTY
31701: LIST
31702: LIST
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: LD_INT 1
31710: NEG
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 2
31718: NEG
31719: PUSH
31720: LD_INT 2
31722: NEG
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31749: LD_ADDR_VAR 0 23
31753: PUSH
31754: LD_INT 0
31756: PUSH
31757: LD_INT 0
31759: PUSH
31760: EMPTY
31761: LIST
31762: LIST
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: LD_INT 1
31769: NEG
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 1
31777: PUSH
31778: LD_INT 0
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 1
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 0
31797: PUSH
31798: LD_INT 1
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 1
31818: NEG
31819: PUSH
31820: LD_INT 1
31822: NEG
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 1
31830: NEG
31831: PUSH
31832: LD_INT 2
31834: NEG
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 0
31842: PUSH
31843: LD_INT 2
31845: NEG
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: LD_INT 1
31856: NEG
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: LD_INT 0
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: LD_INT 2
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 1
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 0
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: LD_INT 1
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 2
31925: NEG
31926: PUSH
31927: LD_INT 0
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 2
31936: NEG
31937: PUSH
31938: LD_INT 1
31940: NEG
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 2
31948: NEG
31949: PUSH
31950: LD_INT 2
31952: NEG
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: LD_INT 3
31964: NEG
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 1
31972: NEG
31973: PUSH
31974: LD_INT 3
31976: NEG
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: LD_INT 2
31987: NEG
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 2
31995: PUSH
31996: LD_INT 1
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32029: LD_ADDR_VAR 0 24
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 0
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: LD_INT 0
32046: PUSH
32047: LD_INT 1
32049: NEG
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 1
32057: PUSH
32058: LD_INT 0
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 1
32067: PUSH
32068: LD_INT 1
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 0
32077: PUSH
32078: LD_INT 1
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 1
32087: NEG
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: LD_INT 1
32102: NEG
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 2
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 0
32122: PUSH
32123: LD_INT 2
32125: NEG
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 1
32133: PUSH
32134: LD_INT 1
32136: NEG
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 2
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 2
32154: PUSH
32155: LD_INT 1
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 2
32164: PUSH
32165: LD_INT 2
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 1
32174: PUSH
32175: LD_INT 2
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: LD_INT 2
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: NEG
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 2
32205: NEG
32206: PUSH
32207: LD_INT 0
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: LD_INT 2
32216: NEG
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 2
32228: NEG
32229: PUSH
32230: LD_INT 2
32232: NEG
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: LD_INT 2
32243: NEG
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 3
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 3
32272: PUSH
32273: LD_INT 2
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32305: LD_ADDR_VAR 0 25
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 0
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: LD_INT 1
32325: NEG
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 1
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 1
32343: PUSH
32344: LD_INT 1
32346: PUSH
32347: EMPTY
32348: LIST
32349: LIST
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 1
32363: NEG
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 1
32374: NEG
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 1
32386: NEG
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 0
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: LD_INT 0
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: LD_INT 1
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 2
32440: PUSH
32441: LD_INT 2
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 0
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 1
32470: NEG
32471: PUSH
32472: LD_INT 1
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 2
32481: NEG
32482: PUSH
32483: LD_INT 0
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 2
32492: NEG
32493: PUSH
32494: LD_INT 1
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 2
32504: NEG
32505: PUSH
32506: LD_INT 2
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 3
32526: PUSH
32527: LD_INT 2
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 2
32536: PUSH
32537: LD_INT 3
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: LD_INT 3
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32579: LD_ADDR_VAR 0 26
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 0
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 0
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: LD_INT 1
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 1
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 1
32648: NEG
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 1
32660: NEG
32661: PUSH
32662: LD_INT 2
32664: NEG
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: LD_INT 0
32672: PUSH
32673: LD_INT 2
32675: NEG
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PUSH
32681: LD_INT 1
32683: PUSH
32684: LD_INT 1
32686: NEG
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 2
32694: PUSH
32695: LD_INT 0
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 2
32714: PUSH
32715: LD_INT 2
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 0
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 1
32744: NEG
32745: PUSH
32746: LD_INT 1
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: LD_INT 2
32755: NEG
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 2
32766: NEG
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 2
32778: NEG
32779: PUSH
32780: LD_INT 2
32782: NEG
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 2
32790: PUSH
32791: LD_INT 3
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 1
32800: PUSH
32801: LD_INT 3
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: LIST
32834: LIST
32835: LIST
32836: LIST
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: LIST
32851: LIST
32852: LIST
32853: LIST
32854: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32855: LD_ADDR_VAR 0 27
32859: PUSH
32860: LD_INT 0
32862: PUSH
32863: LD_INT 0
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: LD_INT 1
32875: NEG
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: LD_INT 1
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 1
32893: PUSH
32894: LD_INT 1
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 1
32924: NEG
32925: PUSH
32926: LD_INT 1
32928: NEG
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: LD_INT 2
32940: NEG
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 2
32951: NEG
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 2
32970: PUSH
32971: LD_INT 0
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 2
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 2
32990: PUSH
32991: LD_INT 2
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: LD_INT 1
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 2
33031: NEG
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 2
33054: NEG
33055: PUSH
33056: LD_INT 2
33058: NEG
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 1
33066: NEG
33067: PUSH
33068: LD_INT 2
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 2
33077: NEG
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 3
33088: NEG
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 3
33100: NEG
33101: PUSH
33102: LD_INT 2
33104: NEG
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: LIST
33117: LIST
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33135: LD_ADDR_VAR 0 28
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: LD_INT 0
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: LD_INT 0
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 1
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: LD_INT 1
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 1
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: NEG
33217: PUSH
33218: LD_INT 2
33220: NEG
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 0
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 1
33239: PUSH
33240: LD_INT 1
33242: NEG
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 2
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 2
33270: PUSH
33271: LD_INT 2
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 0
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 1
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: NEG
33312: PUSH
33313: LD_INT 0
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: LD_INT 2
33322: NEG
33323: PUSH
33324: LD_INT 1
33326: NEG
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 2
33334: NEG
33335: PUSH
33336: LD_INT 2
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 2
33346: NEG
33347: PUSH
33348: LD_INT 3
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 1
33358: NEG
33359: PUSH
33360: LD_INT 3
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 3
33370: NEG
33371: PUSH
33372: LD_INT 1
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 3
33382: NEG
33383: PUSH
33384: LD_INT 2
33386: NEG
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33417: LD_ADDR_VAR 0 29
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 0
33434: PUSH
33435: LD_INT 1
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: PUSH
33446: LD_INT 0
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 1
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 0
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: NEG
33487: PUSH
33488: LD_INT 1
33490: NEG
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 1
33498: NEG
33499: PUSH
33500: LD_INT 2
33502: NEG
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 2
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: LD_INT 1
33524: NEG
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 2
33532: PUSH
33533: LD_INT 0
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 2
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: PUSH
33553: LD_INT 2
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: LD_INT 2
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 1
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 2
33595: NEG
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 2
33607: NEG
33608: PUSH
33609: LD_INT 3
33611: NEG
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: LD_INT 1
33622: NEG
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 3
33630: PUSH
33631: LD_INT 1
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 3
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: NEG
33651: PUSH
33652: LD_INT 2
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 3
33661: NEG
33662: PUSH
33663: LD_INT 2
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 30
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: NEG
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 0
33789: PUSH
33790: LD_INT 2
33792: NEG
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: LD_INT 1
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 2
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 2
33821: PUSH
33822: LD_INT 1
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 2
33831: PUSH
33832: LD_INT 2
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 2
33862: NEG
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: NEG
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 2
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 3
33908: PUSH
33909: LD_INT 2
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 3
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: NEG
33929: PUSH
33930: LD_INT 1
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 3
33939: NEG
33940: PUSH
33941: LD_INT 1
33943: NEG
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: LIST
33969: LIST
33970: LIST
33971: LIST
33972: LIST
33973: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33974: LD_ADDR_VAR 0 31
33978: PUSH
33979: LD_INT 0
33981: PUSH
33982: LD_INT 0
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 0
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 1
34032: NEG
34033: PUSH
34034: LD_INT 0
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: NEG
34044: PUSH
34045: LD_INT 1
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: NEG
34056: PUSH
34057: LD_INT 2
34059: NEG
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 1
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 2
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 2
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: PUSH
34099: LD_INT 2
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 1
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 0
34118: PUSH
34119: LD_INT 2
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 2
34139: NEG
34140: PUSH
34141: LD_INT 1
34143: NEG
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: LD_INT 2
34155: NEG
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 2
34163: NEG
34164: PUSH
34165: LD_INT 3
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: LD_INT 1
34178: NEG
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 3
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 3
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: LD_INT 2
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 3
34217: NEG
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34252: LD_ADDR_VAR 0 32
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: NEG
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 2
34337: NEG
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 0
34345: PUSH
34346: LD_INT 2
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 2
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 2
34377: PUSH
34378: LD_INT 2
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 2
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: NEG
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 2
34429: NEG
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 3
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 2
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 3
34464: PUSH
34465: LD_INT 2
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 3
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 2
34484: NEG
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 3
34495: NEG
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: LIST
34527: LIST
34528: LIST
34529: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34530: LD_ADDR_VAR 0 33
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: LD_INT 0
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: LD_INT 1
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: LD_INT 1
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: NEG
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 1
34623: PUSH
34624: LD_INT 1
34626: NEG
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 2
34644: PUSH
34645: LD_INT 1
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 1
34654: PUSH
34655: LD_INT 2
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 0
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 2
34685: NEG
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 2
34708: NEG
34709: PUSH
34710: LD_INT 2
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 2
34720: NEG
34721: PUSH
34722: LD_INT 3
34724: NEG
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 2
34732: PUSH
34733: LD_INT 1
34735: NEG
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 3
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: LD_INT 3
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: LD_INT 2
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 3
34774: NEG
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34809: LD_ADDR_VAR 0 34
34813: PUSH
34814: LD_INT 0
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 0
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 1
34837: PUSH
34838: LD_INT 0
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 1
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 0
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: NEG
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 1
34878: NEG
34879: PUSH
34880: LD_INT 1
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 2
34894: NEG
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: LD_INT 2
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 1
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 2
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 1
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 2
34965: NEG
34966: PUSH
34967: LD_INT 0
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 2
34976: NEG
34977: PUSH
34978: LD_INT 1
34980: NEG
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: NEG
35001: PUSH
35002: LD_INT 3
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 1
35012: PUSH
35013: LD_INT 2
35015: NEG
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 3
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 2
35033: PUSH
35034: LD_INT 3
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 2
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 3
35054: NEG
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35089: LD_ADDR_VAR 0 35
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 0
35106: PUSH
35107: LD_INT 1
35109: NEG
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 1
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: PUSH
35135: LD_INT 0
35137: PUSH
35138: LD_INT 1
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 1
35147: NEG
35148: PUSH
35149: LD_INT 0
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: NEG
35181: PUSH
35182: LD_INT 1
35184: NEG
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35201: LD_ADDR_VAR 0 36
35205: PUSH
35206: LD_INT 0
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: LD_INT 0
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 1
35239: PUSH
35240: LD_INT 1
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 0
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: NEG
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 1
35282: NEG
35283: PUSH
35284: LD_INT 2
35286: NEG
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 1
35294: PUSH
35295: LD_INT 2
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35313: LD_ADDR_VAR 0 37
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 0
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 0
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: LD_INT 0
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 1
35382: NEG
35383: PUSH
35384: LD_INT 1
35386: NEG
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 1
35394: PUSH
35395: LD_INT 1
35397: NEG
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 1
35405: NEG
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35425: LD_ADDR_VAR 0 38
35429: PUSH
35430: LD_INT 0
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 1
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 1
35463: PUSH
35464: LD_INT 1
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 0
35473: PUSH
35474: LD_INT 1
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: LD_INT 0
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 2
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 2
35516: NEG
35517: PUSH
35518: LD_INT 1
35520: NEG
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35537: LD_ADDR_VAR 0 39
35541: PUSH
35542: LD_INT 0
35544: PUSH
35545: LD_INT 0
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 1
35565: PUSH
35566: LD_INT 0
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 1
35575: PUSH
35576: LD_INT 1
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: LD_INT 1
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: LD_INT 0
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: LD_INT 1
35610: NEG
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: LD_INT 2
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 1
35630: PUSH
35631: LD_INT 2
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35649: LD_ADDR_VAR 0 40
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: LD_INT 0
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 0
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: LD_INT 1
35733: NEG
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 1
35741: NEG
35742: PUSH
35743: LD_INT 1
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35761: LD_ADDR_VAR 0 41
35765: PUSH
35766: LD_INT 0
35768: PUSH
35769: LD_INT 0
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: LD_INT 0
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: LD_INT 1
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: LD_INT 1
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 1
35842: NEG
35843: PUSH
35844: LD_INT 2
35846: NEG
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 1
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 2
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 2
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 2
35885: PUSH
35886: LD_INT 2
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 1
35905: NEG
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 2
35916: NEG
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 2
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 2
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 2
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 3
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 3
35984: PUSH
35985: LD_INT 1
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 3
35994: PUSH
35995: LD_INT 2
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 3
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 2
36014: PUSH
36015: LD_INT 3
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 2
36024: NEG
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 3
36035: NEG
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 3
36046: NEG
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: LD_INT 2
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 3
36070: NEG
36071: PUSH
36072: LD_INT 3
36074: NEG
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36111: LD_ADDR_VAR 0 42
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: LD_INT 0
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 0
36128: PUSH
36129: LD_INT 1
36131: NEG
36132: PUSH
36133: EMPTY
36134: LIST
36135: LIST
36136: PUSH
36137: LD_INT 1
36139: PUSH
36140: LD_INT 0
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 1
36149: PUSH
36150: LD_INT 1
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 0
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 1
36169: NEG
36170: PUSH
36171: LD_INT 0
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 0
36204: PUSH
36205: LD_INT 2
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 2
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 2
36236: PUSH
36237: LD_INT 2
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: LD_INT 2
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 0
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 1
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 2
36277: NEG
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 2
36289: NEG
36290: PUSH
36291: LD_INT 2
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 2
36301: NEG
36302: PUSH
36303: LD_INT 3
36305: NEG
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: LD_INT 3
36317: NEG
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: PUSH
36323: LD_INT 0
36325: PUSH
36326: LD_INT 3
36328: NEG
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 1
36336: PUSH
36337: LD_INT 2
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 3
36347: PUSH
36348: LD_INT 2
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 3
36357: PUSH
36358: LD_INT 3
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: PUSH
36368: LD_INT 3
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 1
36377: PUSH
36378: LD_INT 3
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 1
36397: NEG
36398: PUSH
36399: LD_INT 2
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 3
36408: NEG
36409: PUSH
36410: LD_INT 2
36412: NEG
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 3
36420: NEG
36421: PUSH
36422: LD_INT 3
36424: NEG
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36461: LD_ADDR_VAR 0 43
36465: PUSH
36466: LD_INT 0
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 1
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 1
36530: NEG
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: LD_INT 2
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 2
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 2
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 2
36586: PUSH
36587: LD_INT 1
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: LD_INT 2
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: LD_INT 2
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: NEG
36617: PUSH
36618: LD_INT 1
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 2
36627: NEG
36628: PUSH
36629: LD_INT 0
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 2
36638: NEG
36639: PUSH
36640: LD_INT 1
36642: NEG
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 1
36650: NEG
36651: PUSH
36652: LD_INT 3
36654: NEG
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 3
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 2
36676: NEG
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 2
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 3
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 3
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 1
36715: PUSH
36716: LD_INT 3
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 3
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: LD_INT 2
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 2
36746: NEG
36747: PUSH
36748: LD_INT 1
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 3
36757: NEG
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 3
36768: NEG
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: LIST
36805: LIST
36806: LIST
36807: LIST
36808: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36809: LD_ADDR_VAR 0 44
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: LD_INT 0
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 0
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: PUSH
36838: LD_INT 0
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 0
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 1
36867: NEG
36868: PUSH
36869: LD_INT 0
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: NEG
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 1
36902: PUSH
36903: LD_INT 1
36905: NEG
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PUSH
36911: LD_INT 2
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 2
36923: PUSH
36924: LD_INT 1
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 2
36933: PUSH
36934: LD_INT 2
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 1
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 1
36953: NEG
36954: PUSH
36955: LD_INT 1
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 2
36964: NEG
36965: PUSH
36966: LD_INT 0
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 1
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 2
36987: NEG
36988: PUSH
36989: LD_INT 2
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 2
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 2
37011: PUSH
37012: LD_INT 1
37014: NEG
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 3
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 3
37032: PUSH
37033: LD_INT 1
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 3
37042: PUSH
37043: LD_INT 2
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 3
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: NEG
37073: PUSH
37074: LD_INT 1
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: LD_INT 0
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 3
37094: NEG
37095: PUSH
37096: LD_INT 1
37098: NEG
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 3
37106: NEG
37107: PUSH
37108: LD_INT 2
37110: NEG
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 3
37118: NEG
37119: PUSH
37120: LD_INT 3
37122: NEG
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37159: LD_ADDR_VAR 0 45
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: LD_INT 2
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: LD_INT 2
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 0
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 1
37314: NEG
37315: PUSH
37316: LD_INT 1
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 2
37349: NEG
37350: PUSH
37351: LD_INT 3
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: NEG
37362: PUSH
37363: LD_INT 3
37365: NEG
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 0
37373: PUSH
37374: LD_INT 3
37376: NEG
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: LD_INT 2
37387: NEG
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: PUSH
37393: LD_INT 3
37395: PUSH
37396: LD_INT 2
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 3
37405: PUSH
37406: LD_INT 3
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: LD_INT 2
37415: PUSH
37416: LD_INT 3
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PUSH
37423: LD_INT 1
37425: PUSH
37426: LD_INT 3
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 0
37435: PUSH
37436: LD_INT 3
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 1
37445: NEG
37446: PUSH
37447: LD_INT 2
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 3
37456: NEG
37457: PUSH
37458: LD_INT 2
37460: NEG
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 3
37468: NEG
37469: PUSH
37470: LD_INT 3
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: LIST
37495: LIST
37496: LIST
37497: LIST
37498: LIST
37499: LIST
37500: LIST
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37509: LD_ADDR_VAR 0 46
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 0
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 0
37526: PUSH
37527: LD_INT 1
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: LD_INT 0
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 1
37547: PUSH
37548: LD_INT 1
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: LD_INT 1
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: LD_INT 1
37567: NEG
37568: PUSH
37569: LD_INT 0
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 1
37578: NEG
37579: PUSH
37580: LD_INT 1
37582: NEG
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 1
37590: NEG
37591: PUSH
37592: LD_INT 2
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 2
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: LD_INT 1
37616: NEG
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 2
37624: PUSH
37625: LD_INT 0
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 2
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 2
37675: NEG
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 2
37686: NEG
37687: PUSH
37688: LD_INT 1
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 1
37698: NEG
37699: PUSH
37700: LD_INT 3
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 0
37710: PUSH
37711: LD_INT 3
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 1
37721: PUSH
37722: LD_INT 2
37724: NEG
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 2
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 3
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 3
37753: PUSH
37754: LD_INT 1
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: LD_INT 3
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: LD_INT 2
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 3
37805: NEG
37806: PUSH
37807: LD_INT 0
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 3
37816: NEG
37817: PUSH
37818: LD_INT 1
37820: NEG
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: LIST
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: LIST
37835: LIST
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37857: LD_ADDR_VAR 0 47
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: LD_INT 0
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 0
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 1
37895: PUSH
37896: LD_INT 1
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 0
37905: PUSH
37906: LD_INT 1
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 1
37915: NEG
37916: PUSH
37917: LD_INT 0
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: LD_INT 1
37930: NEG
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 1
37938: NEG
37939: PUSH
37940: LD_INT 2
37942: NEG
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 0
37950: PUSH
37951: LD_INT 2
37953: NEG
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 1
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 2
37972: NEG
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 2
37984: NEG
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38008: LD_ADDR_VAR 0 48
38012: PUSH
38013: LD_INT 0
38015: PUSH
38016: LD_INT 0
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 0
38025: PUSH
38026: LD_INT 1
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 1
38036: PUSH
38037: LD_INT 0
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 1
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: LD_INT 1
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: LD_INT 0
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 1
38077: NEG
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: LD_INT 2
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 0
38101: PUSH
38102: LD_INT 2
38104: NEG
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 2
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 2
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: LIST
38153: LIST
38154: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38155: LD_ADDR_VAR 0 49
38159: PUSH
38160: LD_INT 0
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: LD_INT 0
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: LD_INT 1
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 1
38213: NEG
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: NEG
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 2
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 2
38257: PUSH
38258: LD_INT 1
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 2
38267: PUSH
38268: LD_INT 2
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 1
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: LIST
38290: LIST
38291: LIST
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: LIST
38297: LIST
38298: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38299: LD_ADDR_VAR 0 50
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: LD_INT 1
38319: NEG
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: LD_INT 0
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 1
38337: PUSH
38338: LD_INT 1
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: LD_INT 1
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 1
38357: NEG
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: LD_INT 1
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 2
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 2
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 1
38400: PUSH
38401: LD_INT 2
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 1
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38443: LD_ADDR_VAR 0 51
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: LD_INT 0
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 0
38460: PUSH
38461: LD_INT 1
38463: NEG
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 1
38481: PUSH
38482: LD_INT 1
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 1
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 1
38501: NEG
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: NEG
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: NEG
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: LIST
38588: LIST
38589: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38590: LD_ADDR_VAR 0 52
38594: PUSH
38595: LD_INT 0
38597: PUSH
38598: LD_INT 0
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 1
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 1
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: PUSH
38629: LD_INT 1
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 1
38648: NEG
38649: PUSH
38650: LD_INT 0
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 1
38659: NEG
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 1
38671: NEG
38672: PUSH
38673: LD_INT 2
38675: NEG
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: NEG
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38741: LD_ADDR_VAR 0 53
38745: PUSH
38746: LD_INT 0
38748: PUSH
38749: LD_INT 0
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 0
38758: PUSH
38759: LD_INT 1
38761: NEG
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 1
38769: PUSH
38770: LD_INT 0
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 1
38779: PUSH
38780: LD_INT 1
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 1
38799: NEG
38800: PUSH
38801: LD_INT 0
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 1
38810: NEG
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 1
38822: NEG
38823: PUSH
38824: LD_INT 2
38826: NEG
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: LD_INT 2
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 1
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 2
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 2
38866: PUSH
38867: LD_INT 1
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 2
38876: PUSH
38877: LD_INT 2
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: PUSH
38887: LD_INT 2
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: LD_INT 2
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 2
38917: NEG
38918: PUSH
38919: LD_INT 0
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: LD_INT 2
38928: NEG
38929: PUSH
38930: LD_INT 1
38932: NEG
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: NEG
38941: PUSH
38942: LD_INT 2
38944: NEG
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38971: LD_ADDR_VAR 0 54
38975: PUSH
38976: LD_INT 0
38978: PUSH
38979: LD_INT 0
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 0
38988: PUSH
38989: LD_INT 1
38991: NEG
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: LD_INT 0
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 1
39009: PUSH
39010: LD_INT 1
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: NEG
39041: PUSH
39042: LD_INT 1
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: LD_INT 2
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 0
39064: PUSH
39065: LD_INT 2
39067: NEG
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: LD_INT 1
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 2
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 2
39096: PUSH
39097: LD_INT 1
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 2
39106: PUSH
39107: LD_INT 2
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 1
39116: PUSH
39117: LD_INT 2
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 0
39126: PUSH
39127: LD_INT 2
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: NEG
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 2
39147: NEG
39148: PUSH
39149: LD_INT 0
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 2
39158: NEG
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 2
39170: NEG
39171: PUSH
39172: LD_INT 2
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39201: LD_ADDR_VAR 0 55
39205: PUSH
39206: LD_INT 0
39208: PUSH
39209: LD_INT 0
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: LD_INT 1
39221: NEG
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 1
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 1
39239: PUSH
39240: LD_INT 1
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 0
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: LD_INT 0
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 1
39270: NEG
39271: PUSH
39272: LD_INT 1
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 1
39282: NEG
39283: PUSH
39284: LD_INT 2
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 0
39294: PUSH
39295: LD_INT 2
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 2
39316: PUSH
39317: LD_INT 0
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 2
39326: PUSH
39327: LD_INT 1
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 2
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 0
39356: PUSH
39357: LD_INT 2
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 1
39366: NEG
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 2
39377: NEG
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 2
39388: NEG
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 2
39400: NEG
39401: PUSH
39402: LD_INT 2
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39431: LD_ADDR_VAR 0 56
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 0
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: LD_INT 0
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 1
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 0
39479: PUSH
39480: LD_INT 1
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: LD_INT 1
39489: NEG
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 1
39500: NEG
39501: PUSH
39502: LD_INT 1
39504: NEG
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 1
39512: NEG
39513: PUSH
39514: LD_INT 2
39516: NEG
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 0
39524: PUSH
39525: LD_INT 2
39527: NEG
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 1
39535: PUSH
39536: LD_INT 1
39538: NEG
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 2
39546: PUSH
39547: LD_INT 0
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 2
39556: PUSH
39557: LD_INT 1
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 2
39566: PUSH
39567: LD_INT 2
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: LD_INT 2
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: LD_INT 1
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 2
39607: NEG
39608: PUSH
39609: LD_INT 0
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 2
39618: NEG
39619: PUSH
39620: LD_INT 1
39622: NEG
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 2
39630: NEG
39631: PUSH
39632: LD_INT 2
39634: NEG
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: LIST
39660: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39661: LD_ADDR_VAR 0 57
39665: PUSH
39666: LD_INT 0
39668: PUSH
39669: LD_INT 0
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 0
39678: PUSH
39679: LD_INT 1
39681: NEG
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 1
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 0
39709: PUSH
39710: LD_INT 1
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 1
39730: NEG
39731: PUSH
39732: LD_INT 1
39734: NEG
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 1
39742: NEG
39743: PUSH
39744: LD_INT 2
39746: NEG
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 0
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 1
39765: PUSH
39766: LD_INT 1
39768: NEG
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: LD_INT 1
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 2
39796: PUSH
39797: LD_INT 2
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: LD_INT 2
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: NEG
39827: PUSH
39828: LD_INT 1
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 2
39848: NEG
39849: PUSH
39850: LD_INT 1
39852: NEG
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 2
39860: NEG
39861: PUSH
39862: LD_INT 2
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39891: LD_ADDR_VAR 0 58
39895: PUSH
39896: LD_INT 0
39898: PUSH
39899: LD_INT 0
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: LD_INT 1
39911: NEG
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: PUSH
39920: LD_INT 0
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: LD_INT 1
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: LD_INT 1
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 1
39960: NEG
39961: PUSH
39962: LD_INT 1
39964: NEG
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 1
39972: NEG
39973: PUSH
39974: LD_INT 2
39976: NEG
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: LD_INT 2
39987: NEG
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 1
39995: PUSH
39996: LD_INT 1
39998: NEG
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: PUSH
40007: LD_INT 0
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: LD_INT 1
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: LD_INT 2
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 0
40046: PUSH
40047: LD_INT 2
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: NEG
40057: PUSH
40058: LD_INT 1
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 2
40067: NEG
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 2
40078: NEG
40079: PUSH
40080: LD_INT 1
40082: NEG
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 2
40090: NEG
40091: PUSH
40092: LD_INT 2
40094: NEG
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: LIST
40116: LIST
40117: LIST
40118: LIST
40119: LIST
40120: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40121: LD_ADDR_VAR 0 59
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: LD_INT 0
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 0
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: LD_INT 0
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: LD_INT 1
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 0
40169: PUSH
40170: LD_INT 1
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: LD_INT 0
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: LD_INT 1
40194: NEG
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40209: LD_ADDR_VAR 0 60
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: LD_INT 1
40229: NEG
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 1
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 1
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 0
40257: PUSH
40258: LD_INT 1
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: LD_INT 1
40282: NEG
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: LIST
40296: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40297: LD_ADDR_VAR 0 61
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: LD_INT 0
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 0
40314: PUSH
40315: LD_INT 1
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 1
40325: PUSH
40326: LD_INT 0
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: NEG
40367: PUSH
40368: LD_INT 1
40370: NEG
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40385: LD_ADDR_VAR 0 62
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: LD_INT 0
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: LD_INT 1
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 1
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 1
40423: PUSH
40424: LD_INT 1
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 0
40433: PUSH
40434: LD_INT 1
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: NEG
40444: PUSH
40445: LD_INT 0
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 1
40454: NEG
40455: PUSH
40456: LD_INT 1
40458: NEG
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40473: LD_ADDR_VAR 0 63
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: LD_INT 0
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: PUSH
40488: LD_INT 0
40490: PUSH
40491: LD_INT 1
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 1
40501: PUSH
40502: LD_INT 0
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: PUSH
40512: LD_INT 1
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 0
40521: PUSH
40522: LD_INT 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 1
40531: NEG
40532: PUSH
40533: LD_INT 0
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PUSH
40540: LD_INT 1
40542: NEG
40543: PUSH
40544: LD_INT 1
40546: NEG
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40561: LD_ADDR_VAR 0 64
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 0
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: LD_INT 1
40581: NEG
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 1
40599: PUSH
40600: LD_INT 1
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: LD_INT 1
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 1
40619: NEG
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 1
40630: NEG
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: ST_TO_ADDR
// end ; 1 :
40649: GO 46546
40651: LD_INT 1
40653: DOUBLE
40654: EQUAL
40655: IFTRUE 40659
40657: GO 43282
40659: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40660: LD_ADDR_VAR 0 11
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 3
40671: NEG
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: LD_INT 3
40682: NEG
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PUSH
40688: LD_INT 1
40690: PUSH
40691: LD_INT 2
40693: NEG
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: LIST
40703: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40704: LD_ADDR_VAR 0 12
40708: PUSH
40709: LD_INT 2
40711: PUSH
40712: LD_INT 1
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 3
40722: PUSH
40723: LD_INT 0
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: LD_INT 3
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: LIST
40744: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40745: LD_ADDR_VAR 0 13
40749: PUSH
40750: LD_INT 3
40752: PUSH
40753: LD_INT 2
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 3
40762: PUSH
40763: LD_INT 3
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 2
40772: PUSH
40773: LD_INT 3
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40785: LD_ADDR_VAR 0 14
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: LD_INT 3
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 1
40812: NEG
40813: PUSH
40814: LD_INT 2
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: LIST
40825: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40826: LD_ADDR_VAR 0 15
40830: PUSH
40831: LD_INT 2
40833: NEG
40834: PUSH
40835: LD_INT 1
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 3
40844: NEG
40845: PUSH
40846: LD_INT 0
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 3
40855: NEG
40856: PUSH
40857: LD_INT 1
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40870: LD_ADDR_VAR 0 16
40874: PUSH
40875: LD_INT 2
40877: NEG
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 3
40889: NEG
40890: PUSH
40891: LD_INT 2
40893: NEG
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 3
40901: NEG
40902: PUSH
40903: LD_INT 3
40905: NEG
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: LIST
40915: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40916: LD_ADDR_VAR 0 17
40920: PUSH
40921: LD_INT 1
40923: NEG
40924: PUSH
40925: LD_INT 3
40927: NEG
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 1
40946: PUSH
40947: LD_INT 2
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: LIST
40959: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40960: LD_ADDR_VAR 0 18
40964: PUSH
40965: LD_INT 2
40967: PUSH
40968: LD_INT 1
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 3
40978: PUSH
40979: LD_INT 0
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 3
40988: PUSH
40989: LD_INT 1
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: LIST
41000: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41001: LD_ADDR_VAR 0 19
41005: PUSH
41006: LD_INT 3
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 3
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 2
41028: PUSH
41029: LD_INT 3
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: LIST
41040: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41041: LD_ADDR_VAR 0 20
41045: PUSH
41046: LD_INT 1
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 0
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 1
41068: NEG
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: LIST
41081: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41082: LD_ADDR_VAR 0 21
41086: PUSH
41087: LD_INT 2
41089: NEG
41090: PUSH
41091: LD_INT 1
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 3
41100: NEG
41101: PUSH
41102: LD_INT 0
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 3
41111: NEG
41112: PUSH
41113: LD_INT 1
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: LIST
41125: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41126: LD_ADDR_VAR 0 22
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 3
41137: NEG
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: LD_INT 2
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 3
41157: NEG
41158: PUSH
41159: LD_INT 3
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: LIST
41171: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41172: LD_ADDR_VAR 0 23
41176: PUSH
41177: LD_INT 0
41179: PUSH
41180: LD_INT 3
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: LD_INT 4
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 1
41202: PUSH
41203: LD_INT 3
41205: NEG
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: LIST
41215: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41216: LD_ADDR_VAR 0 24
41220: PUSH
41221: LD_INT 3
41223: PUSH
41224: LD_INT 0
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 3
41233: PUSH
41234: LD_INT 1
41236: NEG
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 4
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: LIST
41256: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41257: LD_ADDR_VAR 0 25
41261: PUSH
41262: LD_INT 3
41264: PUSH
41265: LD_INT 3
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 4
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 3
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41297: LD_ADDR_VAR 0 26
41301: PUSH
41302: LD_INT 0
41304: PUSH
41305: LD_INT 3
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 1
41314: PUSH
41315: LD_INT 4
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: LD_INT 3
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: LIST
41337: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41338: LD_ADDR_VAR 0 27
41342: PUSH
41343: LD_INT 3
41345: NEG
41346: PUSH
41347: LD_INT 0
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: NEG
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 4
41367: NEG
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41382: LD_ADDR_VAR 0 28
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: LD_INT 3
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 3
41401: NEG
41402: PUSH
41403: LD_INT 4
41405: NEG
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 4
41413: NEG
41414: PUSH
41415: LD_INT 3
41417: NEG
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: LIST
41427: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41428: LD_ADDR_VAR 0 29
41432: PUSH
41433: LD_INT 1
41435: NEG
41436: PUSH
41437: LD_INT 3
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 0
41447: PUSH
41448: LD_INT 3
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 1
41469: NEG
41470: PUSH
41471: LD_INT 4
41473: NEG
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 0
41481: PUSH
41482: LD_INT 4
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: LD_INT 3
41495: NEG
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 1
41503: NEG
41504: PUSH
41505: LD_INT 5
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: LD_INT 5
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 1
41526: PUSH
41527: LD_INT 4
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 1
41537: NEG
41538: PUSH
41539: LD_INT 6
41541: NEG
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 0
41549: PUSH
41550: LD_INT 6
41552: NEG
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 1
41560: PUSH
41561: LD_INT 5
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41583: LD_ADDR_VAR 0 30
41587: PUSH
41588: LD_INT 2
41590: PUSH
41591: LD_INT 1
41593: NEG
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 3
41601: PUSH
41602: LD_INT 0
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 3
41611: PUSH
41612: LD_INT 1
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: PUSH
41622: LD_INT 1
41624: NEG
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: LD_INT 4
41632: PUSH
41633: LD_INT 0
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 4
41642: PUSH
41643: LD_INT 1
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: LD_INT 4
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 5
41663: PUSH
41664: LD_INT 0
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 5
41673: PUSH
41674: LD_INT 1
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 5
41683: PUSH
41684: LD_INT 1
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 6
41694: PUSH
41695: LD_INT 0
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: PUSH
41702: LD_INT 6
41704: PUSH
41705: LD_INT 1
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: LIST
41716: LIST
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41726: LD_ADDR_VAR 0 31
41730: PUSH
41731: LD_INT 3
41733: PUSH
41734: LD_INT 2
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 3
41743: PUSH
41744: LD_INT 3
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: LD_INT 3
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 4
41763: PUSH
41764: LD_INT 3
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 4
41773: PUSH
41774: LD_INT 4
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: LD_INT 4
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 5
41793: PUSH
41794: LD_INT 4
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 5
41803: PUSH
41804: LD_INT 5
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 4
41813: PUSH
41814: LD_INT 5
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: LD_INT 6
41823: PUSH
41824: LD_INT 5
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 6
41833: PUSH
41834: LD_INT 6
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 5
41843: PUSH
41844: LD_INT 6
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: LIST
41855: LIST
41856: LIST
41857: LIST
41858: LIST
41859: LIST
41860: LIST
41861: LIST
41862: LIST
41863: LIST
41864: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41865: LD_ADDR_VAR 0 32
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: LD_INT 3
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 0
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 1
41892: NEG
41893: PUSH
41894: LD_INT 2
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 1
41903: PUSH
41904: LD_INT 4
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 0
41913: PUSH
41914: LD_INT 4
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: PUSH
41921: LD_INT 1
41923: NEG
41924: PUSH
41925: LD_INT 3
41927: PUSH
41928: EMPTY
41929: LIST
41930: LIST
41931: PUSH
41932: LD_INT 1
41934: PUSH
41935: LD_INT 5
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 0
41944: PUSH
41945: LD_INT 5
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 1
41954: NEG
41955: PUSH
41956: LD_INT 4
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 1
41965: PUSH
41966: LD_INT 6
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 0
41975: PUSH
41976: LD_INT 6
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 1
41985: NEG
41986: PUSH
41987: LD_INT 5
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42008: LD_ADDR_VAR 0 33
42012: PUSH
42013: LD_INT 2
42015: NEG
42016: PUSH
42017: LD_INT 1
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 3
42026: NEG
42027: PUSH
42028: LD_INT 0
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 3
42037: NEG
42038: PUSH
42039: LD_INT 1
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 3
42049: NEG
42050: PUSH
42051: LD_INT 1
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 4
42060: NEG
42061: PUSH
42062: LD_INT 0
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 4
42071: NEG
42072: PUSH
42073: LD_INT 1
42075: NEG
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 4
42083: NEG
42084: PUSH
42085: LD_INT 1
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: LD_INT 5
42094: NEG
42095: PUSH
42096: LD_INT 0
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 5
42105: NEG
42106: PUSH
42107: LD_INT 1
42109: NEG
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 5
42117: NEG
42118: PUSH
42119: LD_INT 1
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 6
42128: NEG
42129: PUSH
42130: LD_INT 0
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 6
42139: NEG
42140: PUSH
42141: LD_INT 1
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42163: LD_ADDR_VAR 0 34
42167: PUSH
42168: LD_INT 2
42170: NEG
42171: PUSH
42172: LD_INT 3
42174: NEG
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 3
42182: NEG
42183: PUSH
42184: LD_INT 2
42186: NEG
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 3
42194: NEG
42195: PUSH
42196: LD_INT 3
42198: NEG
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_INT 3
42206: NEG
42207: PUSH
42208: LD_INT 4
42210: NEG
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 4
42218: NEG
42219: PUSH
42220: LD_INT 3
42222: NEG
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 4
42230: NEG
42231: PUSH
42232: LD_INT 4
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 4
42242: NEG
42243: PUSH
42244: LD_INT 5
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 5
42254: NEG
42255: PUSH
42256: LD_INT 4
42258: NEG
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 5
42266: NEG
42267: PUSH
42268: LD_INT 5
42270: NEG
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 5
42278: NEG
42279: PUSH
42280: LD_INT 6
42282: NEG
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 6
42290: NEG
42291: PUSH
42292: LD_INT 5
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 6
42302: NEG
42303: PUSH
42304: LD_INT 6
42306: NEG
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: LIST
42325: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42326: LD_ADDR_VAR 0 41
42330: PUSH
42331: LD_INT 0
42333: PUSH
42334: LD_INT 2
42336: NEG
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 1
42344: NEG
42345: PUSH
42346: LD_INT 3
42348: NEG
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 1
42356: PUSH
42357: LD_INT 2
42359: NEG
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: LIST
42369: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42370: LD_ADDR_VAR 0 42
42374: PUSH
42375: LD_INT 2
42377: PUSH
42378: LD_INT 0
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 2
42387: PUSH
42388: LD_INT 1
42390: NEG
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 3
42398: PUSH
42399: LD_INT 1
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42411: LD_ADDR_VAR 0 43
42415: PUSH
42416: LD_INT 2
42418: PUSH
42419: LD_INT 2
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: LD_INT 3
42428: PUSH
42429: LD_INT 2
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 2
42438: PUSH
42439: LD_INT 3
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: LIST
42450: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42451: LD_ADDR_VAR 0 44
42455: PUSH
42456: LD_INT 0
42458: PUSH
42459: LD_INT 2
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 1
42468: PUSH
42469: LD_INT 3
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: LD_INT 2
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: LIST
42491: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42492: LD_ADDR_VAR 0 45
42496: PUSH
42497: LD_INT 2
42499: NEG
42500: PUSH
42501: LD_INT 0
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 2
42510: NEG
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 3
42521: NEG
42522: PUSH
42523: LD_INT 1
42525: NEG
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: LIST
42535: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42536: LD_ADDR_VAR 0 46
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: LD_INT 2
42547: NEG
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 2
42555: NEG
42556: PUSH
42557: LD_INT 3
42559: NEG
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 3
42567: NEG
42568: PUSH
42569: LD_INT 2
42571: NEG
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: LIST
42581: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42582: LD_ADDR_VAR 0 47
42586: PUSH
42587: LD_INT 2
42589: NEG
42590: PUSH
42591: LD_INT 3
42593: NEG
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 1
42601: NEG
42602: PUSH
42603: LD_INT 3
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42615: LD_ADDR_VAR 0 48
42619: PUSH
42620: LD_INT 1
42622: PUSH
42623: LD_INT 2
42625: NEG
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: PUSH
42631: LD_INT 2
42633: PUSH
42634: LD_INT 1
42636: NEG
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42646: LD_ADDR_VAR 0 49
42650: PUSH
42651: LD_INT 3
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: LD_INT 2
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42675: LD_ADDR_VAR 0 50
42679: PUSH
42680: LD_INT 2
42682: PUSH
42683: LD_INT 3
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: LD_INT 3
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42704: LD_ADDR_VAR 0 51
42708: PUSH
42709: LD_INT 1
42711: NEG
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 2
42722: NEG
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42735: LD_ADDR_VAR 0 52
42739: PUSH
42740: LD_INT 3
42742: NEG
42743: PUSH
42744: LD_INT 1
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: LD_INT 2
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42768: LD_ADDR_VAR 0 53
42772: PUSH
42773: LD_INT 1
42775: NEG
42776: PUSH
42777: LD_INT 3
42779: NEG
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 0
42787: PUSH
42788: LD_INT 3
42790: NEG
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 1
42798: PUSH
42799: LD_INT 2
42801: NEG
42802: PUSH
42803: EMPTY
42804: LIST
42805: LIST
42806: PUSH
42807: EMPTY
42808: LIST
42809: LIST
42810: LIST
42811: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42812: LD_ADDR_VAR 0 54
42816: PUSH
42817: LD_INT 2
42819: PUSH
42820: LD_INT 1
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 3
42830: PUSH
42831: LD_INT 0
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: LD_INT 3
42840: PUSH
42841: LD_INT 1
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: PUSH
42848: EMPTY
42849: LIST
42850: LIST
42851: LIST
42852: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42853: LD_ADDR_VAR 0 55
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: LD_INT 2
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 3
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 2
42880: PUSH
42881: LD_INT 3
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42893: LD_ADDR_VAR 0 56
42897: PUSH
42898: LD_INT 1
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 0
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: LD_INT 2
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: LIST
42933: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42934: LD_ADDR_VAR 0 57
42938: PUSH
42939: LD_INT 2
42941: NEG
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 3
42952: NEG
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 3
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: LIST
42977: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42978: LD_ADDR_VAR 0 58
42982: PUSH
42983: LD_INT 2
42985: NEG
42986: PUSH
42987: LD_INT 3
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 3
42997: NEG
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 3
43009: NEG
43010: PUSH
43011: LD_INT 3
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: LIST
43023: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43024: LD_ADDR_VAR 0 59
43028: PUSH
43029: LD_INT 1
43031: NEG
43032: PUSH
43033: LD_INT 2
43035: NEG
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 0
43043: PUSH
43044: LD_INT 2
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: LIST
43067: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43068: LD_ADDR_VAR 0 60
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: LD_INT 2
43086: PUSH
43087: LD_INT 0
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 2
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: LIST
43108: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43109: LD_ADDR_VAR 0 61
43113: PUSH
43114: LD_INT 2
43116: PUSH
43117: LD_INT 1
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 2
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 1
43136: PUSH
43137: LD_INT 2
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43149: LD_ADDR_VAR 0 62
43153: PUSH
43154: LD_INT 1
43156: PUSH
43157: LD_INT 2
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: LD_INT 2
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 1
43176: NEG
43177: PUSH
43178: LD_INT 1
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: LIST
43189: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43190: LD_ADDR_VAR 0 63
43194: PUSH
43195: LD_INT 1
43197: NEG
43198: PUSH
43199: LD_INT 1
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: LD_INT 2
43208: NEG
43209: PUSH
43210: LD_INT 0
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 2
43219: NEG
43220: PUSH
43221: LD_INT 1
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: LIST
43233: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43234: LD_ADDR_VAR 0 64
43238: PUSH
43239: LD_INT 1
43241: NEG
43242: PUSH
43243: LD_INT 2
43245: NEG
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 2
43253: NEG
43254: PUSH
43255: LD_INT 1
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 2
43265: NEG
43266: PUSH
43267: LD_INT 2
43269: NEG
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: LIST
43279: ST_TO_ADDR
// end ; 2 :
43280: GO 46546
43282: LD_INT 2
43284: DOUBLE
43285: EQUAL
43286: IFTRUE 43290
43288: GO 46545
43290: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43291: LD_ADDR_VAR 0 29
43295: PUSH
43296: LD_INT 4
43298: PUSH
43299: LD_INT 0
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 4
43308: PUSH
43309: LD_INT 1
43311: NEG
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 5
43319: PUSH
43320: LD_INT 0
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 5
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 4
43339: PUSH
43340: LD_INT 1
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: LD_INT 3
43349: PUSH
43350: LD_INT 0
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 3
43359: PUSH
43360: LD_INT 1
43362: NEG
43363: PUSH
43364: EMPTY
43365: LIST
43366: LIST
43367: PUSH
43368: LD_INT 3
43370: PUSH
43371: LD_INT 2
43373: NEG
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PUSH
43379: LD_INT 5
43381: PUSH
43382: LD_INT 2
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 3
43391: PUSH
43392: LD_INT 3
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 3
43401: PUSH
43402: LD_INT 2
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 4
43411: PUSH
43412: LD_INT 3
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 4
43421: PUSH
43422: LD_INT 4
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 3
43431: PUSH
43432: LD_INT 4
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 2
43441: PUSH
43442: LD_INT 3
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 2
43451: PUSH
43452: LD_INT 2
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 4
43461: PUSH
43462: LD_INT 2
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: LD_INT 2
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 0
43481: PUSH
43482: LD_INT 4
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 0
43491: PUSH
43492: LD_INT 3
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 1
43501: PUSH
43502: LD_INT 4
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 1
43511: PUSH
43512: LD_INT 5
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 5
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 1
43531: NEG
43532: PUSH
43533: LD_INT 4
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 1
43542: NEG
43543: PUSH
43544: LD_INT 3
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 2
43553: PUSH
43554: LD_INT 5
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: NEG
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 3
43574: NEG
43575: PUSH
43576: LD_INT 0
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 3
43585: NEG
43586: PUSH
43587: LD_INT 1
43589: NEG
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 2
43597: NEG
43598: PUSH
43599: LD_INT 0
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 2
43608: NEG
43609: PUSH
43610: LD_INT 1
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 3
43619: NEG
43620: PUSH
43621: LD_INT 1
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 4
43630: NEG
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 4
43641: NEG
43642: PUSH
43643: LD_INT 1
43645: NEG
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 4
43653: NEG
43654: PUSH
43655: LD_INT 2
43657: NEG
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 2
43665: NEG
43666: PUSH
43667: LD_INT 2
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 4
43676: NEG
43677: PUSH
43678: LD_INT 4
43680: NEG
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 4
43688: NEG
43689: PUSH
43690: LD_INT 5
43692: NEG
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: LD_INT 3
43700: NEG
43701: PUSH
43702: LD_INT 4
43704: NEG
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: LD_INT 3
43712: NEG
43713: PUSH
43714: LD_INT 3
43716: NEG
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: LD_INT 4
43724: NEG
43725: PUSH
43726: LD_INT 3
43728: NEG
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: LD_INT 4
43740: NEG
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 5
43748: NEG
43749: PUSH
43750: LD_INT 5
43752: NEG
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 3
43760: NEG
43761: PUSH
43762: LD_INT 5
43764: NEG
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: LD_INT 5
43772: NEG
43773: PUSH
43774: LD_INT 3
43776: NEG
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: LIST
43786: LIST
43787: LIST
43788: LIST
43789: LIST
43790: LIST
43791: LIST
43792: LIST
43793: LIST
43794: LIST
43795: LIST
43796: LIST
43797: LIST
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: LIST
43810: LIST
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: LIST
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43829: LD_ADDR_VAR 0 30
43833: PUSH
43834: LD_INT 4
43836: PUSH
43837: LD_INT 4
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 4
43846: PUSH
43847: LD_INT 3
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 5
43856: PUSH
43857: LD_INT 4
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 5
43866: PUSH
43867: LD_INT 5
43869: PUSH
43870: EMPTY
43871: LIST
43872: LIST
43873: PUSH
43874: LD_INT 4
43876: PUSH
43877: LD_INT 5
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 3
43886: PUSH
43887: LD_INT 4
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 3
43896: PUSH
43897: LD_INT 3
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: PUSH
43907: LD_INT 3
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 3
43916: PUSH
43917: LD_INT 5
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 0
43926: PUSH
43927: LD_INT 3
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 0
43936: PUSH
43937: LD_INT 2
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 1
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 1
43956: PUSH
43957: LD_INT 4
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 0
43966: PUSH
43967: LD_INT 4
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 1
43976: NEG
43977: PUSH
43978: LD_INT 3
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 1
43987: NEG
43988: PUSH
43989: LD_INT 2
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: LD_INT 4
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 2
44008: NEG
44009: PUSH
44010: LD_INT 2
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 4
44019: NEG
44020: PUSH
44021: LD_INT 0
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 4
44030: NEG
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: NEG
44043: PUSH
44044: LD_INT 0
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 3
44053: NEG
44054: PUSH
44055: LD_INT 1
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 4
44064: NEG
44065: PUSH
44066: LD_INT 1
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 5
44075: NEG
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 5
44086: NEG
44087: PUSH
44088: LD_INT 1
44090: NEG
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 5
44098: NEG
44099: PUSH
44100: LD_INT 2
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 3
44110: NEG
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 3
44121: NEG
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 3
44133: NEG
44134: PUSH
44135: LD_INT 4
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 2
44145: NEG
44146: PUSH
44147: LD_INT 3
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 2
44157: NEG
44158: PUSH
44159: LD_INT 2
44161: NEG
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: LD_INT 3
44169: NEG
44170: PUSH
44171: LD_INT 2
44173: NEG
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 4
44181: NEG
44182: PUSH
44183: LD_INT 3
44185: NEG
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: LD_INT 4
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: LD_INT 4
44209: NEG
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 4
44217: NEG
44218: PUSH
44219: LD_INT 2
44221: NEG
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 0
44229: PUSH
44230: LD_INT 4
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 0
44240: PUSH
44241: LD_INT 5
44243: NEG
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: LD_INT 1
44251: PUSH
44252: LD_INT 4
44254: NEG
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 1
44262: PUSH
44263: LD_INT 3
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 3
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 1
44284: NEG
44285: PUSH
44286: LD_INT 4
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 1
44296: NEG
44297: PUSH
44298: LD_INT 5
44300: NEG
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 2
44308: PUSH
44309: LD_INT 3
44311: NEG
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: LD_INT 5
44323: NEG
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44376: LD_ADDR_VAR 0 31
44380: PUSH
44381: LD_INT 0
44383: PUSH
44384: LD_INT 4
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: LD_INT 3
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 1
44403: PUSH
44404: LD_INT 4
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 1
44413: PUSH
44414: LD_INT 5
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 0
44423: PUSH
44424: LD_INT 5
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 1
44433: NEG
44434: PUSH
44435: LD_INT 4
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 1
44444: NEG
44445: PUSH
44446: LD_INT 3
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 2
44455: PUSH
44456: LD_INT 5
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 2
44465: NEG
44466: PUSH
44467: LD_INT 3
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 3
44476: NEG
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 3
44487: NEG
44488: PUSH
44489: LD_INT 1
44491: NEG
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PUSH
44497: LD_INT 2
44499: NEG
44500: PUSH
44501: LD_INT 0
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 2
44510: NEG
44511: PUSH
44512: LD_INT 1
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 3
44521: NEG
44522: PUSH
44523: LD_INT 1
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 4
44532: NEG
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 4
44543: NEG
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 4
44555: NEG
44556: PUSH
44557: LD_INT 2
44559: NEG
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 2
44567: NEG
44568: PUSH
44569: LD_INT 2
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 4
44578: NEG
44579: PUSH
44580: LD_INT 4
44582: NEG
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 4
44590: NEG
44591: PUSH
44592: LD_INT 5
44594: NEG
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 3
44602: NEG
44603: PUSH
44604: LD_INT 4
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 3
44614: NEG
44615: PUSH
44616: LD_INT 3
44618: NEG
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 4
44626: NEG
44627: PUSH
44628: LD_INT 3
44630: NEG
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 5
44638: NEG
44639: PUSH
44640: LD_INT 4
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 5
44650: NEG
44651: PUSH
44652: LD_INT 5
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 5
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 5
44674: NEG
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: LD_INT 4
44700: NEG
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 1
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 1
44719: PUSH
44720: LD_INT 2
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: LD_INT 2
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: NEG
44742: PUSH
44743: LD_INT 3
44745: NEG
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 1
44753: NEG
44754: PUSH
44755: LD_INT 4
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 2
44765: PUSH
44766: LD_INT 2
44768: NEG
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 2
44776: NEG
44777: PUSH
44778: LD_INT 4
44780: NEG
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 4
44788: PUSH
44789: LD_INT 0
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 4
44798: PUSH
44799: LD_INT 1
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 5
44809: PUSH
44810: LD_INT 0
44812: PUSH
44813: EMPTY
44814: LIST
44815: LIST
44816: PUSH
44817: LD_INT 5
44819: PUSH
44820: LD_INT 1
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: PUSH
44827: LD_INT 4
44829: PUSH
44830: LD_INT 1
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 3
44839: PUSH
44840: LD_INT 0
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 3
44849: PUSH
44850: LD_INT 1
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 3
44860: PUSH
44861: LD_INT 2
44863: NEG
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 5
44871: PUSH
44872: LD_INT 2
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44926: LD_ADDR_VAR 0 32
44930: PUSH
44931: LD_INT 4
44933: NEG
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 4
44944: NEG
44945: PUSH
44946: LD_INT 1
44948: NEG
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 3
44956: NEG
44957: PUSH
44958: LD_INT 0
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 3
44967: NEG
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 4
44978: NEG
44979: PUSH
44980: LD_INT 1
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 5
44989: NEG
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 5
45000: NEG
45001: PUSH
45002: LD_INT 1
45004: NEG
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: LD_INT 5
45012: NEG
45013: PUSH
45014: LD_INT 2
45016: NEG
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 3
45024: NEG
45025: PUSH
45026: LD_INT 2
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 3
45035: NEG
45036: PUSH
45037: LD_INT 3
45039: NEG
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 3
45047: NEG
45048: PUSH
45049: LD_INT 4
45051: NEG
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 2
45059: NEG
45060: PUSH
45061: LD_INT 3
45063: NEG
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 2
45071: NEG
45072: PUSH
45073: LD_INT 2
45075: NEG
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: LD_INT 3
45083: NEG
45084: PUSH
45085: LD_INT 2
45087: NEG
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: PUSH
45093: LD_INT 4
45095: NEG
45096: PUSH
45097: LD_INT 3
45099: NEG
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 4
45107: NEG
45108: PUSH
45109: LD_INT 4
45111: NEG
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 2
45119: NEG
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 4
45131: NEG
45132: PUSH
45133: LD_INT 2
45135: NEG
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: LD_INT 4
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 0
45154: PUSH
45155: LD_INT 5
45157: NEG
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: PUSH
45166: LD_INT 4
45168: NEG
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 1
45176: PUSH
45177: LD_INT 3
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 3
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 1
45198: NEG
45199: PUSH
45200: LD_INT 4
45202: NEG
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 1
45210: NEG
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 2
45222: PUSH
45223: LD_INT 3
45225: NEG
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 2
45233: NEG
45234: PUSH
45235: LD_INT 5
45237: NEG
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 3
45245: PUSH
45246: LD_INT 0
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 3
45255: PUSH
45256: LD_INT 1
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 4
45266: PUSH
45267: LD_INT 0
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: LD_INT 4
45276: PUSH
45277: LD_INT 1
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: LD_INT 3
45286: PUSH
45287: LD_INT 1
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 2
45296: PUSH
45297: LD_INT 0
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 2
45306: PUSH
45307: LD_INT 1
45309: NEG
45310: PUSH
45311: EMPTY
45312: LIST
45313: LIST
45314: PUSH
45315: LD_INT 2
45317: PUSH
45318: LD_INT 2
45320: NEG
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 4
45328: PUSH
45329: LD_INT 2
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 4
45338: PUSH
45339: LD_INT 4
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 4
45348: PUSH
45349: LD_INT 3
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 5
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 5
45368: PUSH
45369: LD_INT 5
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 4
45378: PUSH
45379: LD_INT 5
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 3
45388: PUSH
45389: LD_INT 4
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 3
45398: PUSH
45399: LD_INT 3
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 5
45408: PUSH
45409: LD_INT 3
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: LD_INT 3
45418: PUSH
45419: LD_INT 5
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45473: LD_ADDR_VAR 0 33
45477: PUSH
45478: LD_INT 4
45480: NEG
45481: PUSH
45482: LD_INT 4
45484: NEG
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: PUSH
45490: LD_INT 4
45492: NEG
45493: PUSH
45494: LD_INT 5
45496: NEG
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: PUSH
45502: LD_INT 3
45504: NEG
45505: PUSH
45506: LD_INT 4
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 3
45516: NEG
45517: PUSH
45518: LD_INT 3
45520: NEG
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 4
45528: NEG
45529: PUSH
45530: LD_INT 3
45532: NEG
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: PUSH
45538: LD_INT 5
45540: NEG
45541: PUSH
45542: LD_INT 4
45544: NEG
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 5
45552: NEG
45553: PUSH
45554: LD_INT 5
45556: NEG
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 3
45564: NEG
45565: PUSH
45566: LD_INT 5
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 5
45576: NEG
45577: PUSH
45578: LD_INT 3
45580: NEG
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 0
45588: PUSH
45589: LD_INT 3
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 4
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 1
45621: PUSH
45622: LD_INT 2
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 0
45632: PUSH
45633: LD_INT 2
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 1
45643: NEG
45644: PUSH
45645: LD_INT 3
45647: NEG
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: PUSH
45653: LD_INT 1
45655: NEG
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 2
45667: PUSH
45668: LD_INT 2
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 2
45678: NEG
45679: PUSH
45680: LD_INT 4
45682: NEG
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PUSH
45688: LD_INT 4
45690: PUSH
45691: LD_INT 0
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 4
45700: PUSH
45701: LD_INT 1
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 5
45711: PUSH
45712: LD_INT 0
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: PUSH
45719: LD_INT 5
45721: PUSH
45722: LD_INT 1
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: LD_INT 1
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: PUSH
45742: LD_INT 0
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 3
45751: PUSH
45752: LD_INT 1
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 3
45762: PUSH
45763: LD_INT 2
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 5
45773: PUSH
45774: LD_INT 2
45776: PUSH
45777: EMPTY
45778: LIST
45779: LIST
45780: PUSH
45781: LD_INT 3
45783: PUSH
45784: LD_INT 3
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 3
45793: PUSH
45794: LD_INT 2
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: LD_INT 4
45803: PUSH
45804: LD_INT 3
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 4
45813: PUSH
45814: LD_INT 4
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 3
45823: PUSH
45824: LD_INT 4
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 2
45833: PUSH
45834: LD_INT 3
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 2
45843: PUSH
45844: LD_INT 2
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 4
45853: PUSH
45854: LD_INT 2
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 4
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 0
45873: PUSH
45874: LD_INT 4
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 0
45883: PUSH
45884: LD_INT 3
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 1
45893: PUSH
45894: LD_INT 4
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 1
45903: PUSH
45904: LD_INT 5
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 5
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 1
45923: NEG
45924: PUSH
45925: LD_INT 4
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PUSH
45932: LD_INT 1
45934: NEG
45935: PUSH
45936: LD_INT 3
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 2
45945: PUSH
45946: LD_INT 5
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 2
45955: NEG
45956: PUSH
45957: LD_INT 3
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46011: LD_ADDR_VAR 0 34
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: LD_INT 4
46021: NEG
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: PUSH
46027: LD_INT 0
46029: PUSH
46030: LD_INT 5
46032: NEG
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: LD_INT 1
46040: PUSH
46041: LD_INT 4
46043: NEG
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 1
46051: PUSH
46052: LD_INT 3
46054: NEG
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 3
46065: NEG
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 1
46073: NEG
46074: PUSH
46075: LD_INT 4
46077: NEG
46078: PUSH
46079: EMPTY
46080: LIST
46081: LIST
46082: PUSH
46083: LD_INT 1
46085: NEG
46086: PUSH
46087: LD_INT 5
46089: NEG
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 2
46097: PUSH
46098: LD_INT 3
46100: NEG
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 2
46108: NEG
46109: PUSH
46110: LD_INT 5
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 3
46120: PUSH
46121: LD_INT 0
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 3
46130: PUSH
46131: LD_INT 1
46133: NEG
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 4
46141: PUSH
46142: LD_INT 0
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 4
46151: PUSH
46152: LD_INT 1
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 3
46161: PUSH
46162: LD_INT 1
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 2
46171: PUSH
46172: LD_INT 0
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: LD_INT 1
46184: NEG
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 2
46192: PUSH
46193: LD_INT 2
46195: NEG
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 4
46203: PUSH
46204: LD_INT 2
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 4
46213: PUSH
46214: LD_INT 4
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 4
46223: PUSH
46224: LD_INT 3
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: PUSH
46231: LD_INT 5
46233: PUSH
46234: LD_INT 4
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 5
46243: PUSH
46244: LD_INT 5
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 5
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 3
46263: PUSH
46264: LD_INT 4
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 3
46273: PUSH
46274: LD_INT 3
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: LD_INT 3
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 3
46293: PUSH
46294: LD_INT 5
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 0
46303: PUSH
46304: LD_INT 3
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 0
46313: PUSH
46314: LD_INT 2
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 1
46333: PUSH
46334: LD_INT 4
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 0
46343: PUSH
46344: LD_INT 4
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 1
46353: NEG
46354: PUSH
46355: LD_INT 3
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 1
46364: NEG
46365: PUSH
46366: LD_INT 2
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 2
46375: PUSH
46376: LD_INT 4
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 2
46385: NEG
46386: PUSH
46387: LD_INT 2
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: PUSH
46394: LD_INT 4
46396: NEG
46397: PUSH
46398: LD_INT 0
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PUSH
46405: LD_INT 4
46407: NEG
46408: PUSH
46409: LD_INT 1
46411: NEG
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: LD_INT 3
46419: NEG
46420: PUSH
46421: LD_INT 0
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 3
46430: NEG
46431: PUSH
46432: LD_INT 1
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: PUSH
46439: LD_INT 4
46441: NEG
46442: PUSH
46443: LD_INT 1
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 5
46452: NEG
46453: PUSH
46454: LD_INT 0
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 5
46463: NEG
46464: PUSH
46465: LD_INT 1
46467: NEG
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 5
46475: NEG
46476: PUSH
46477: LD_INT 2
46479: NEG
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PUSH
46485: LD_INT 3
46487: NEG
46488: PUSH
46489: LD_INT 2
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: ST_TO_ADDR
// end ; end ;
46543: GO 46546
46545: POP
// case btype of b_depot , b_warehouse :
46546: LD_VAR 0 1
46550: PUSH
46551: LD_INT 0
46553: DOUBLE
46554: EQUAL
46555: IFTRUE 46565
46557: LD_INT 1
46559: DOUBLE
46560: EQUAL
46561: IFTRUE 46565
46563: GO 46766
46565: POP
// case nation of nation_american :
46566: LD_VAR 0 5
46570: PUSH
46571: LD_INT 1
46573: DOUBLE
46574: EQUAL
46575: IFTRUE 46579
46577: GO 46635
46579: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46580: LD_ADDR_VAR 0 9
46584: PUSH
46585: LD_VAR 0 11
46589: PUSH
46590: LD_VAR 0 12
46594: PUSH
46595: LD_VAR 0 13
46599: PUSH
46600: LD_VAR 0 14
46604: PUSH
46605: LD_VAR 0 15
46609: PUSH
46610: LD_VAR 0 16
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: PUSH
46623: LD_VAR 0 4
46627: PUSH
46628: LD_INT 1
46630: PLUS
46631: ARRAY
46632: ST_TO_ADDR
46633: GO 46764
46635: LD_INT 2
46637: DOUBLE
46638: EQUAL
46639: IFTRUE 46643
46641: GO 46699
46643: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46644: LD_ADDR_VAR 0 9
46648: PUSH
46649: LD_VAR 0 17
46653: PUSH
46654: LD_VAR 0 18
46658: PUSH
46659: LD_VAR 0 19
46663: PUSH
46664: LD_VAR 0 20
46668: PUSH
46669: LD_VAR 0 21
46673: PUSH
46674: LD_VAR 0 22
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: PUSH
46687: LD_VAR 0 4
46691: PUSH
46692: LD_INT 1
46694: PLUS
46695: ARRAY
46696: ST_TO_ADDR
46697: GO 46764
46699: LD_INT 3
46701: DOUBLE
46702: EQUAL
46703: IFTRUE 46707
46705: GO 46763
46707: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46708: LD_ADDR_VAR 0 9
46712: PUSH
46713: LD_VAR 0 23
46717: PUSH
46718: LD_VAR 0 24
46722: PUSH
46723: LD_VAR 0 25
46727: PUSH
46728: LD_VAR 0 26
46732: PUSH
46733: LD_VAR 0 27
46737: PUSH
46738: LD_VAR 0 28
46742: PUSH
46743: EMPTY
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: PUSH
46751: LD_VAR 0 4
46755: PUSH
46756: LD_INT 1
46758: PLUS
46759: ARRAY
46760: ST_TO_ADDR
46761: GO 46764
46763: POP
46764: GO 47319
46766: LD_INT 2
46768: DOUBLE
46769: EQUAL
46770: IFTRUE 46780
46772: LD_INT 3
46774: DOUBLE
46775: EQUAL
46776: IFTRUE 46780
46778: GO 46836
46780: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46781: LD_ADDR_VAR 0 9
46785: PUSH
46786: LD_VAR 0 29
46790: PUSH
46791: LD_VAR 0 30
46795: PUSH
46796: LD_VAR 0 31
46800: PUSH
46801: LD_VAR 0 32
46805: PUSH
46806: LD_VAR 0 33
46810: PUSH
46811: LD_VAR 0 34
46815: PUSH
46816: EMPTY
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: PUSH
46824: LD_VAR 0 4
46828: PUSH
46829: LD_INT 1
46831: PLUS
46832: ARRAY
46833: ST_TO_ADDR
46834: GO 47319
46836: LD_INT 16
46838: DOUBLE
46839: EQUAL
46840: IFTRUE 46898
46842: LD_INT 17
46844: DOUBLE
46845: EQUAL
46846: IFTRUE 46898
46848: LD_INT 18
46850: DOUBLE
46851: EQUAL
46852: IFTRUE 46898
46854: LD_INT 19
46856: DOUBLE
46857: EQUAL
46858: IFTRUE 46898
46860: LD_INT 22
46862: DOUBLE
46863: EQUAL
46864: IFTRUE 46898
46866: LD_INT 20
46868: DOUBLE
46869: EQUAL
46870: IFTRUE 46898
46872: LD_INT 21
46874: DOUBLE
46875: EQUAL
46876: IFTRUE 46898
46878: LD_INT 23
46880: DOUBLE
46881: EQUAL
46882: IFTRUE 46898
46884: LD_INT 24
46886: DOUBLE
46887: EQUAL
46888: IFTRUE 46898
46890: LD_INT 25
46892: DOUBLE
46893: EQUAL
46894: IFTRUE 46898
46896: GO 46954
46898: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46899: LD_ADDR_VAR 0 9
46903: PUSH
46904: LD_VAR 0 35
46908: PUSH
46909: LD_VAR 0 36
46913: PUSH
46914: LD_VAR 0 37
46918: PUSH
46919: LD_VAR 0 38
46923: PUSH
46924: LD_VAR 0 39
46928: PUSH
46929: LD_VAR 0 40
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: PUSH
46942: LD_VAR 0 4
46946: PUSH
46947: LD_INT 1
46949: PLUS
46950: ARRAY
46951: ST_TO_ADDR
46952: GO 47319
46954: LD_INT 6
46956: DOUBLE
46957: EQUAL
46958: IFTRUE 47010
46960: LD_INT 7
46962: DOUBLE
46963: EQUAL
46964: IFTRUE 47010
46966: LD_INT 8
46968: DOUBLE
46969: EQUAL
46970: IFTRUE 47010
46972: LD_INT 13
46974: DOUBLE
46975: EQUAL
46976: IFTRUE 47010
46978: LD_INT 12
46980: DOUBLE
46981: EQUAL
46982: IFTRUE 47010
46984: LD_INT 15
46986: DOUBLE
46987: EQUAL
46988: IFTRUE 47010
46990: LD_INT 11
46992: DOUBLE
46993: EQUAL
46994: IFTRUE 47010
46996: LD_INT 14
46998: DOUBLE
46999: EQUAL
47000: IFTRUE 47010
47002: LD_INT 10
47004: DOUBLE
47005: EQUAL
47006: IFTRUE 47010
47008: GO 47066
47010: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47011: LD_ADDR_VAR 0 9
47015: PUSH
47016: LD_VAR 0 41
47020: PUSH
47021: LD_VAR 0 42
47025: PUSH
47026: LD_VAR 0 43
47030: PUSH
47031: LD_VAR 0 44
47035: PUSH
47036: LD_VAR 0 45
47040: PUSH
47041: LD_VAR 0 46
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: PUSH
47054: LD_VAR 0 4
47058: PUSH
47059: LD_INT 1
47061: PLUS
47062: ARRAY
47063: ST_TO_ADDR
47064: GO 47319
47066: LD_INT 36
47068: DOUBLE
47069: EQUAL
47070: IFTRUE 47074
47072: GO 47130
47074: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47075: LD_ADDR_VAR 0 9
47079: PUSH
47080: LD_VAR 0 47
47084: PUSH
47085: LD_VAR 0 48
47089: PUSH
47090: LD_VAR 0 49
47094: PUSH
47095: LD_VAR 0 50
47099: PUSH
47100: LD_VAR 0 51
47104: PUSH
47105: LD_VAR 0 52
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: PUSH
47118: LD_VAR 0 4
47122: PUSH
47123: LD_INT 1
47125: PLUS
47126: ARRAY
47127: ST_TO_ADDR
47128: GO 47319
47130: LD_INT 4
47132: DOUBLE
47133: EQUAL
47134: IFTRUE 47156
47136: LD_INT 5
47138: DOUBLE
47139: EQUAL
47140: IFTRUE 47156
47142: LD_INT 34
47144: DOUBLE
47145: EQUAL
47146: IFTRUE 47156
47148: LD_INT 37
47150: DOUBLE
47151: EQUAL
47152: IFTRUE 47156
47154: GO 47212
47156: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47157: LD_ADDR_VAR 0 9
47161: PUSH
47162: LD_VAR 0 53
47166: PUSH
47167: LD_VAR 0 54
47171: PUSH
47172: LD_VAR 0 55
47176: PUSH
47177: LD_VAR 0 56
47181: PUSH
47182: LD_VAR 0 57
47186: PUSH
47187: LD_VAR 0 58
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: PUSH
47200: LD_VAR 0 4
47204: PUSH
47205: LD_INT 1
47207: PLUS
47208: ARRAY
47209: ST_TO_ADDR
47210: GO 47319
47212: LD_INT 31
47214: DOUBLE
47215: EQUAL
47216: IFTRUE 47262
47218: LD_INT 32
47220: DOUBLE
47221: EQUAL
47222: IFTRUE 47262
47224: LD_INT 33
47226: DOUBLE
47227: EQUAL
47228: IFTRUE 47262
47230: LD_INT 27
47232: DOUBLE
47233: EQUAL
47234: IFTRUE 47262
47236: LD_INT 26
47238: DOUBLE
47239: EQUAL
47240: IFTRUE 47262
47242: LD_INT 28
47244: DOUBLE
47245: EQUAL
47246: IFTRUE 47262
47248: LD_INT 29
47250: DOUBLE
47251: EQUAL
47252: IFTRUE 47262
47254: LD_INT 30
47256: DOUBLE
47257: EQUAL
47258: IFTRUE 47262
47260: GO 47318
47262: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47263: LD_ADDR_VAR 0 9
47267: PUSH
47268: LD_VAR 0 59
47272: PUSH
47273: LD_VAR 0 60
47277: PUSH
47278: LD_VAR 0 61
47282: PUSH
47283: LD_VAR 0 62
47287: PUSH
47288: LD_VAR 0 63
47292: PUSH
47293: LD_VAR 0 64
47297: PUSH
47298: EMPTY
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: PUSH
47306: LD_VAR 0 4
47310: PUSH
47311: LD_INT 1
47313: PLUS
47314: ARRAY
47315: ST_TO_ADDR
47316: GO 47319
47318: POP
// temp_list2 = [ ] ;
47319: LD_ADDR_VAR 0 10
47323: PUSH
47324: EMPTY
47325: ST_TO_ADDR
// for i in temp_list do
47326: LD_ADDR_VAR 0 8
47330: PUSH
47331: LD_VAR 0 9
47335: PUSH
47336: FOR_IN
47337: IFFALSE 47389
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47339: LD_ADDR_VAR 0 10
47343: PUSH
47344: LD_VAR 0 10
47348: PUSH
47349: LD_VAR 0 8
47353: PUSH
47354: LD_INT 1
47356: ARRAY
47357: PUSH
47358: LD_VAR 0 2
47362: PLUS
47363: PUSH
47364: LD_VAR 0 8
47368: PUSH
47369: LD_INT 2
47371: ARRAY
47372: PUSH
47373: LD_VAR 0 3
47377: PLUS
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: EMPTY
47384: LIST
47385: ADD
47386: ST_TO_ADDR
47387: GO 47336
47389: POP
47390: POP
// result = temp_list2 ;
47391: LD_ADDR_VAR 0 7
47395: PUSH
47396: LD_VAR 0 10
47400: ST_TO_ADDR
// end ;
47401: LD_VAR 0 7
47405: RET
// export function EnemyInRange ( unit , dist ) ; begin
47406: LD_INT 0
47408: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47409: LD_ADDR_VAR 0 3
47413: PUSH
47414: LD_VAR 0 1
47418: PPUSH
47419: CALL_OW 255
47423: PPUSH
47424: LD_VAR 0 1
47428: PPUSH
47429: CALL_OW 250
47433: PPUSH
47434: LD_VAR 0 1
47438: PPUSH
47439: CALL_OW 251
47443: PPUSH
47444: LD_VAR 0 2
47448: PPUSH
47449: CALL 20808 0 4
47453: PUSH
47454: LD_INT 4
47456: ARRAY
47457: ST_TO_ADDR
// end ;
47458: LD_VAR 0 3
47462: RET
// export function PlayerSeeMe ( unit ) ; begin
47463: LD_INT 0
47465: PPUSH
// result := See ( your_side , unit ) ;
47466: LD_ADDR_VAR 0 2
47470: PUSH
47471: LD_OWVAR 2
47475: PPUSH
47476: LD_VAR 0 1
47480: PPUSH
47481: CALL_OW 292
47485: ST_TO_ADDR
// end ;
47486: LD_VAR 0 2
47490: RET
// export function ReverseDir ( unit ) ; begin
47491: LD_INT 0
47493: PPUSH
// if not unit then
47494: LD_VAR 0 1
47498: NOT
47499: IFFALSE 47503
// exit ;
47501: GO 47526
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47503: LD_ADDR_VAR 0 2
47507: PUSH
47508: LD_VAR 0 1
47512: PPUSH
47513: CALL_OW 254
47517: PUSH
47518: LD_INT 3
47520: PLUS
47521: PUSH
47522: LD_INT 6
47524: MOD
47525: ST_TO_ADDR
// end ;
47526: LD_VAR 0 2
47530: RET
// export function ReverseArray ( array ) ; var i ; begin
47531: LD_INT 0
47533: PPUSH
47534: PPUSH
// if not array then
47535: LD_VAR 0 1
47539: NOT
47540: IFFALSE 47544
// exit ;
47542: GO 47599
// result := [ ] ;
47544: LD_ADDR_VAR 0 2
47548: PUSH
47549: EMPTY
47550: ST_TO_ADDR
// for i := array downto 1 do
47551: LD_ADDR_VAR 0 3
47555: PUSH
47556: DOUBLE
47557: LD_VAR 0 1
47561: INC
47562: ST_TO_ADDR
47563: LD_INT 1
47565: PUSH
47566: FOR_DOWNTO
47567: IFFALSE 47597
// result := Join ( result , array [ i ] ) ;
47569: LD_ADDR_VAR 0 2
47573: PUSH
47574: LD_VAR 0 2
47578: PPUSH
47579: LD_VAR 0 1
47583: PUSH
47584: LD_VAR 0 3
47588: ARRAY
47589: PPUSH
47590: CALL 52242 0 2
47594: ST_TO_ADDR
47595: GO 47566
47597: POP
47598: POP
// end ;
47599: LD_VAR 0 2
47603: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
47604: LD_INT 0
47606: PPUSH
47607: PPUSH
47608: PPUSH
47609: PPUSH
47610: PPUSH
47611: PPUSH
// if not unit or not hexes then
47612: LD_VAR 0 1
47616: NOT
47617: PUSH
47618: LD_VAR 0 2
47622: NOT
47623: OR
47624: IFFALSE 47628
// exit ;
47626: GO 47751
// dist := 9999 ;
47628: LD_ADDR_VAR 0 5
47632: PUSH
47633: LD_INT 9999
47635: ST_TO_ADDR
// for i = 1 to hexes do
47636: LD_ADDR_VAR 0 4
47640: PUSH
47641: DOUBLE
47642: LD_INT 1
47644: DEC
47645: ST_TO_ADDR
47646: LD_VAR 0 2
47650: PUSH
47651: FOR_TO
47652: IFFALSE 47739
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47654: LD_ADDR_VAR 0 6
47658: PUSH
47659: LD_VAR 0 1
47663: PPUSH
47664: LD_VAR 0 2
47668: PUSH
47669: LD_VAR 0 4
47673: ARRAY
47674: PUSH
47675: LD_INT 1
47677: ARRAY
47678: PPUSH
47679: LD_VAR 0 2
47683: PUSH
47684: LD_VAR 0 4
47688: ARRAY
47689: PUSH
47690: LD_INT 2
47692: ARRAY
47693: PPUSH
47694: CALL_OW 297
47698: ST_TO_ADDR
// if tdist < dist then
47699: LD_VAR 0 6
47703: PUSH
47704: LD_VAR 0 5
47708: LESS
47709: IFFALSE 47737
// begin hex := hexes [ i ] ;
47711: LD_ADDR_VAR 0 8
47715: PUSH
47716: LD_VAR 0 2
47720: PUSH
47721: LD_VAR 0 4
47725: ARRAY
47726: ST_TO_ADDR
// dist := tdist ;
47727: LD_ADDR_VAR 0 5
47731: PUSH
47732: LD_VAR 0 6
47736: ST_TO_ADDR
// end ; end ;
47737: GO 47651
47739: POP
47740: POP
// result := hex ;
47741: LD_ADDR_VAR 0 3
47745: PUSH
47746: LD_VAR 0 8
47750: ST_TO_ADDR
// end ;
47751: LD_VAR 0 3
47755: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47756: LD_INT 0
47758: PPUSH
47759: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47760: LD_VAR 0 1
47764: NOT
47765: PUSH
47766: LD_VAR 0 1
47770: PUSH
47771: LD_INT 21
47773: PUSH
47774: LD_INT 2
47776: PUSH
47777: EMPTY
47778: LIST
47779: LIST
47780: PUSH
47781: LD_INT 23
47783: PUSH
47784: LD_INT 2
47786: PUSH
47787: EMPTY
47788: LIST
47789: LIST
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: PPUSH
47795: CALL_OW 69
47799: IN
47800: NOT
47801: OR
47802: IFFALSE 47806
// exit ;
47804: GO 47853
// for i = 1 to 3 do
47806: LD_ADDR_VAR 0 3
47810: PUSH
47811: DOUBLE
47812: LD_INT 1
47814: DEC
47815: ST_TO_ADDR
47816: LD_INT 3
47818: PUSH
47819: FOR_TO
47820: IFFALSE 47851
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47822: LD_VAR 0 1
47826: PPUSH
47827: CALL_OW 250
47831: PPUSH
47832: LD_VAR 0 1
47836: PPUSH
47837: CALL_OW 251
47841: PPUSH
47842: LD_INT 1
47844: PPUSH
47845: CALL_OW 453
47849: GO 47819
47851: POP
47852: POP
// end ;
47853: LD_VAR 0 2
47857: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47858: LD_INT 0
47860: PPUSH
47861: PPUSH
47862: PPUSH
47863: PPUSH
47864: PPUSH
47865: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47866: LD_VAR 0 1
47870: NOT
47871: PUSH
47872: LD_VAR 0 2
47876: NOT
47877: OR
47878: PUSH
47879: LD_VAR 0 1
47883: PPUSH
47884: CALL_OW 314
47888: OR
47889: IFFALSE 47893
// exit ;
47891: GO 48360
// if GetLives ( i ) < 250 then
47893: LD_VAR 0 4
47897: PPUSH
47898: CALL_OW 256
47902: PUSH
47903: LD_INT 250
47905: LESS
47906: IFFALSE 47919
// begin ComAutodestruct ( i ) ;
47908: LD_VAR 0 4
47912: PPUSH
47913: CALL 47756 0 1
// exit ;
47917: GO 48360
// end ; x := GetX ( enemy_unit ) ;
47919: LD_ADDR_VAR 0 7
47923: PUSH
47924: LD_VAR 0 2
47928: PPUSH
47929: CALL_OW 250
47933: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47934: LD_ADDR_VAR 0 8
47938: PUSH
47939: LD_VAR 0 2
47943: PPUSH
47944: CALL_OW 251
47948: ST_TO_ADDR
// if not x or not y then
47949: LD_VAR 0 7
47953: NOT
47954: PUSH
47955: LD_VAR 0 8
47959: NOT
47960: OR
47961: IFFALSE 47965
// exit ;
47963: GO 48360
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47965: LD_ADDR_VAR 0 6
47969: PUSH
47970: LD_VAR 0 7
47974: PPUSH
47975: LD_INT 0
47977: PPUSH
47978: LD_INT 4
47980: PPUSH
47981: CALL_OW 272
47985: PUSH
47986: LD_VAR 0 8
47990: PPUSH
47991: LD_INT 0
47993: PPUSH
47994: LD_INT 4
47996: PPUSH
47997: CALL_OW 273
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: PUSH
48006: LD_VAR 0 7
48010: PPUSH
48011: LD_INT 1
48013: PPUSH
48014: LD_INT 4
48016: PPUSH
48017: CALL_OW 272
48021: PUSH
48022: LD_VAR 0 8
48026: PPUSH
48027: LD_INT 1
48029: PPUSH
48030: LD_INT 4
48032: PPUSH
48033: CALL_OW 273
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: PUSH
48042: LD_VAR 0 7
48046: PPUSH
48047: LD_INT 2
48049: PPUSH
48050: LD_INT 4
48052: PPUSH
48053: CALL_OW 272
48057: PUSH
48058: LD_VAR 0 8
48062: PPUSH
48063: LD_INT 2
48065: PPUSH
48066: LD_INT 4
48068: PPUSH
48069: CALL_OW 273
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: PUSH
48078: LD_VAR 0 7
48082: PPUSH
48083: LD_INT 3
48085: PPUSH
48086: LD_INT 4
48088: PPUSH
48089: CALL_OW 272
48093: PUSH
48094: LD_VAR 0 8
48098: PPUSH
48099: LD_INT 3
48101: PPUSH
48102: LD_INT 4
48104: PPUSH
48105: CALL_OW 273
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: PUSH
48114: LD_VAR 0 7
48118: PPUSH
48119: LD_INT 4
48121: PPUSH
48122: LD_INT 4
48124: PPUSH
48125: CALL_OW 272
48129: PUSH
48130: LD_VAR 0 8
48134: PPUSH
48135: LD_INT 4
48137: PPUSH
48138: LD_INT 4
48140: PPUSH
48141: CALL_OW 273
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_VAR 0 7
48154: PPUSH
48155: LD_INT 5
48157: PPUSH
48158: LD_INT 4
48160: PPUSH
48161: CALL_OW 272
48165: PUSH
48166: LD_VAR 0 8
48170: PPUSH
48171: LD_INT 5
48173: PPUSH
48174: LD_INT 4
48176: PPUSH
48177: CALL_OW 273
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: ST_TO_ADDR
// for i = tmp downto 1 do
48194: LD_ADDR_VAR 0 4
48198: PUSH
48199: DOUBLE
48200: LD_VAR 0 6
48204: INC
48205: ST_TO_ADDR
48206: LD_INT 1
48208: PUSH
48209: FOR_DOWNTO
48210: IFFALSE 48311
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48212: LD_VAR 0 6
48216: PUSH
48217: LD_VAR 0 4
48221: ARRAY
48222: PUSH
48223: LD_INT 1
48225: ARRAY
48226: PPUSH
48227: LD_VAR 0 6
48231: PUSH
48232: LD_VAR 0 4
48236: ARRAY
48237: PUSH
48238: LD_INT 2
48240: ARRAY
48241: PPUSH
48242: CALL_OW 488
48246: NOT
48247: PUSH
48248: LD_VAR 0 6
48252: PUSH
48253: LD_VAR 0 4
48257: ARRAY
48258: PUSH
48259: LD_INT 1
48261: ARRAY
48262: PPUSH
48263: LD_VAR 0 6
48267: PUSH
48268: LD_VAR 0 4
48272: ARRAY
48273: PUSH
48274: LD_INT 2
48276: ARRAY
48277: PPUSH
48278: CALL_OW 428
48282: PUSH
48283: LD_INT 0
48285: NONEQUAL
48286: OR
48287: IFFALSE 48309
// tmp := Delete ( tmp , i ) ;
48289: LD_ADDR_VAR 0 6
48293: PUSH
48294: LD_VAR 0 6
48298: PPUSH
48299: LD_VAR 0 4
48303: PPUSH
48304: CALL_OW 3
48308: ST_TO_ADDR
48309: GO 48209
48311: POP
48312: POP
// j := GetClosestHex ( unit , tmp ) ;
48313: LD_ADDR_VAR 0 5
48317: PUSH
48318: LD_VAR 0 1
48322: PPUSH
48323: LD_VAR 0 6
48327: PPUSH
48328: CALL 47604 0 2
48332: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48333: LD_VAR 0 1
48337: PPUSH
48338: LD_VAR 0 5
48342: PUSH
48343: LD_INT 1
48345: ARRAY
48346: PPUSH
48347: LD_VAR 0 5
48351: PUSH
48352: LD_INT 2
48354: ARRAY
48355: PPUSH
48356: CALL_OW 111
// end ;
48360: LD_VAR 0 3
48364: RET
// export function PrepareApemanSoldier ( ) ; begin
48365: LD_INT 0
48367: PPUSH
// uc_nation := 0 ;
48368: LD_ADDR_OWVAR 21
48372: PUSH
48373: LD_INT 0
48375: ST_TO_ADDR
// hc_sex := sex_male ;
48376: LD_ADDR_OWVAR 27
48380: PUSH
48381: LD_INT 1
48383: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48384: LD_ADDR_OWVAR 28
48388: PUSH
48389: LD_INT 15
48391: ST_TO_ADDR
// hc_gallery :=  ;
48392: LD_ADDR_OWVAR 33
48396: PUSH
48397: LD_STRING 
48399: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48400: LD_ADDR_OWVAR 31
48404: PUSH
48405: LD_INT 0
48407: PPUSH
48408: LD_INT 3
48410: PPUSH
48411: CALL_OW 12
48415: PUSH
48416: LD_INT 0
48418: PPUSH
48419: LD_INT 3
48421: PPUSH
48422: CALL_OW 12
48426: PUSH
48427: LD_INT 0
48429: PUSH
48430: LD_INT 0
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: ST_TO_ADDR
// end ;
48439: LD_VAR 0 1
48443: RET
// export function PrepareApemanEngineer ( ) ; begin
48444: LD_INT 0
48446: PPUSH
// uc_nation := 0 ;
48447: LD_ADDR_OWVAR 21
48451: PUSH
48452: LD_INT 0
48454: ST_TO_ADDR
// hc_sex := sex_male ;
48455: LD_ADDR_OWVAR 27
48459: PUSH
48460: LD_INT 1
48462: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48463: LD_ADDR_OWVAR 28
48467: PUSH
48468: LD_INT 16
48470: ST_TO_ADDR
// hc_gallery :=  ;
48471: LD_ADDR_OWVAR 33
48475: PUSH
48476: LD_STRING 
48478: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48479: LD_ADDR_OWVAR 31
48483: PUSH
48484: LD_INT 0
48486: PPUSH
48487: LD_INT 3
48489: PPUSH
48490: CALL_OW 12
48494: PUSH
48495: LD_INT 0
48497: PPUSH
48498: LD_INT 3
48500: PPUSH
48501: CALL_OW 12
48505: PUSH
48506: LD_INT 0
48508: PUSH
48509: LD_INT 0
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: LIST
48516: LIST
48517: ST_TO_ADDR
// end ;
48518: LD_VAR 0 1
48522: RET
// export function PrepareApeman ( agressivity ) ; begin
48523: LD_INT 0
48525: PPUSH
// uc_side := 0 ;
48526: LD_ADDR_OWVAR 20
48530: PUSH
48531: LD_INT 0
48533: ST_TO_ADDR
// uc_nation := 0 ;
48534: LD_ADDR_OWVAR 21
48538: PUSH
48539: LD_INT 0
48541: ST_TO_ADDR
// hc_sex := sex_male ;
48542: LD_ADDR_OWVAR 27
48546: PUSH
48547: LD_INT 1
48549: ST_TO_ADDR
// hc_class := class_apeman ;
48550: LD_ADDR_OWVAR 28
48554: PUSH
48555: LD_INT 12
48557: ST_TO_ADDR
// hc_gallery :=  ;
48558: LD_ADDR_OWVAR 33
48562: PUSH
48563: LD_STRING 
48565: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48566: LD_ADDR_OWVAR 35
48570: PUSH
48571: LD_VAR 0 1
48575: NEG
48576: PPUSH
48577: LD_VAR 0 1
48581: PPUSH
48582: CALL_OW 12
48586: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48587: LD_ADDR_OWVAR 31
48591: PUSH
48592: LD_INT 0
48594: PPUSH
48595: LD_INT 3
48597: PPUSH
48598: CALL_OW 12
48602: PUSH
48603: LD_INT 0
48605: PPUSH
48606: LD_INT 3
48608: PPUSH
48609: CALL_OW 12
48613: PUSH
48614: LD_INT 0
48616: PUSH
48617: LD_INT 0
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: LIST
48624: LIST
48625: ST_TO_ADDR
// end ;
48626: LD_VAR 0 2
48630: RET
// export function PrepareTiger ( agressivity ) ; begin
48631: LD_INT 0
48633: PPUSH
// uc_side := 0 ;
48634: LD_ADDR_OWVAR 20
48638: PUSH
48639: LD_INT 0
48641: ST_TO_ADDR
// uc_nation := 0 ;
48642: LD_ADDR_OWVAR 21
48646: PUSH
48647: LD_INT 0
48649: ST_TO_ADDR
// hc_class := class_tiger ;
48650: LD_ADDR_OWVAR 28
48654: PUSH
48655: LD_INT 14
48657: ST_TO_ADDR
// hc_gallery :=  ;
48658: LD_ADDR_OWVAR 33
48662: PUSH
48663: LD_STRING 
48665: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48666: LD_ADDR_OWVAR 35
48670: PUSH
48671: LD_VAR 0 1
48675: NEG
48676: PPUSH
48677: LD_VAR 0 1
48681: PPUSH
48682: CALL_OW 12
48686: ST_TO_ADDR
// end ;
48687: LD_VAR 0 2
48691: RET
// export function PrepareEnchidna ( ) ; begin
48692: LD_INT 0
48694: PPUSH
// uc_side := 0 ;
48695: LD_ADDR_OWVAR 20
48699: PUSH
48700: LD_INT 0
48702: ST_TO_ADDR
// uc_nation := 0 ;
48703: LD_ADDR_OWVAR 21
48707: PUSH
48708: LD_INT 0
48710: ST_TO_ADDR
// hc_class := class_baggie ;
48711: LD_ADDR_OWVAR 28
48715: PUSH
48716: LD_INT 13
48718: ST_TO_ADDR
// hc_gallery :=  ;
48719: LD_ADDR_OWVAR 33
48723: PUSH
48724: LD_STRING 
48726: ST_TO_ADDR
// end ;
48727: LD_VAR 0 1
48731: RET
// export function PrepareFrog ( ) ; begin
48732: LD_INT 0
48734: PPUSH
// uc_side := 0 ;
48735: LD_ADDR_OWVAR 20
48739: PUSH
48740: LD_INT 0
48742: ST_TO_ADDR
// uc_nation := 0 ;
48743: LD_ADDR_OWVAR 21
48747: PUSH
48748: LD_INT 0
48750: ST_TO_ADDR
// hc_class := class_frog ;
48751: LD_ADDR_OWVAR 28
48755: PUSH
48756: LD_INT 19
48758: ST_TO_ADDR
// hc_gallery :=  ;
48759: LD_ADDR_OWVAR 33
48763: PUSH
48764: LD_STRING 
48766: ST_TO_ADDR
// end ;
48767: LD_VAR 0 1
48771: RET
// export function PrepareFish ( ) ; begin
48772: LD_INT 0
48774: PPUSH
// uc_side := 0 ;
48775: LD_ADDR_OWVAR 20
48779: PUSH
48780: LD_INT 0
48782: ST_TO_ADDR
// uc_nation := 0 ;
48783: LD_ADDR_OWVAR 21
48787: PUSH
48788: LD_INT 0
48790: ST_TO_ADDR
// hc_class := class_fish ;
48791: LD_ADDR_OWVAR 28
48795: PUSH
48796: LD_INT 20
48798: ST_TO_ADDR
// hc_gallery :=  ;
48799: LD_ADDR_OWVAR 33
48803: PUSH
48804: LD_STRING 
48806: ST_TO_ADDR
// end ;
48807: LD_VAR 0 1
48811: RET
// export function PrepareBird ( ) ; begin
48812: LD_INT 0
48814: PPUSH
// uc_side := 0 ;
48815: LD_ADDR_OWVAR 20
48819: PUSH
48820: LD_INT 0
48822: ST_TO_ADDR
// uc_nation := 0 ;
48823: LD_ADDR_OWVAR 21
48827: PUSH
48828: LD_INT 0
48830: ST_TO_ADDR
// hc_class := class_phororhacos ;
48831: LD_ADDR_OWVAR 28
48835: PUSH
48836: LD_INT 18
48838: ST_TO_ADDR
// hc_gallery :=  ;
48839: LD_ADDR_OWVAR 33
48843: PUSH
48844: LD_STRING 
48846: ST_TO_ADDR
// end ;
48847: LD_VAR 0 1
48851: RET
// export function PrepareHorse ( ) ; begin
48852: LD_INT 0
48854: PPUSH
// uc_side := 0 ;
48855: LD_ADDR_OWVAR 20
48859: PUSH
48860: LD_INT 0
48862: ST_TO_ADDR
// uc_nation := 0 ;
48863: LD_ADDR_OWVAR 21
48867: PUSH
48868: LD_INT 0
48870: ST_TO_ADDR
// hc_class := class_horse ;
48871: LD_ADDR_OWVAR 28
48875: PUSH
48876: LD_INT 21
48878: ST_TO_ADDR
// hc_gallery :=  ;
48879: LD_ADDR_OWVAR 33
48883: PUSH
48884: LD_STRING 
48886: ST_TO_ADDR
// end ;
48887: LD_VAR 0 1
48891: RET
// export function PrepareMastodont ( ) ; begin
48892: LD_INT 0
48894: PPUSH
// uc_side := 0 ;
48895: LD_ADDR_OWVAR 20
48899: PUSH
48900: LD_INT 0
48902: ST_TO_ADDR
// uc_nation := 0 ;
48903: LD_ADDR_OWVAR 21
48907: PUSH
48908: LD_INT 0
48910: ST_TO_ADDR
// vc_chassis := class_mastodont ;
48911: LD_ADDR_OWVAR 37
48915: PUSH
48916: LD_INT 31
48918: ST_TO_ADDR
// vc_control := control_rider ;
48919: LD_ADDR_OWVAR 38
48923: PUSH
48924: LD_INT 4
48926: ST_TO_ADDR
// end ;
48927: LD_VAR 0 1
48931: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48932: LD_INT 0
48934: PPUSH
48935: PPUSH
48936: PPUSH
// uc_side = 0 ;
48937: LD_ADDR_OWVAR 20
48941: PUSH
48942: LD_INT 0
48944: ST_TO_ADDR
// uc_nation = 0 ;
48945: LD_ADDR_OWVAR 21
48949: PUSH
48950: LD_INT 0
48952: ST_TO_ADDR
// InitHc_All ( ) ;
48953: CALL_OW 584
// InitVc ;
48957: CALL_OW 20
// if mastodonts then
48961: LD_VAR 0 6
48965: IFFALSE 49032
// for i = 1 to mastodonts do
48967: LD_ADDR_VAR 0 11
48971: PUSH
48972: DOUBLE
48973: LD_INT 1
48975: DEC
48976: ST_TO_ADDR
48977: LD_VAR 0 6
48981: PUSH
48982: FOR_TO
48983: IFFALSE 49030
// begin vc_chassis := 31 ;
48985: LD_ADDR_OWVAR 37
48989: PUSH
48990: LD_INT 31
48992: ST_TO_ADDR
// vc_control := control_rider ;
48993: LD_ADDR_OWVAR 38
48997: PUSH
48998: LD_INT 4
49000: ST_TO_ADDR
// animal := CreateVehicle ;
49001: LD_ADDR_VAR 0 12
49005: PUSH
49006: CALL_OW 45
49010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49011: LD_VAR 0 12
49015: PPUSH
49016: LD_VAR 0 8
49020: PPUSH
49021: LD_INT 0
49023: PPUSH
49024: CALL 51160 0 3
// end ;
49028: GO 48982
49030: POP
49031: POP
// if horses then
49032: LD_VAR 0 5
49036: IFFALSE 49103
// for i = 1 to horses do
49038: LD_ADDR_VAR 0 11
49042: PUSH
49043: DOUBLE
49044: LD_INT 1
49046: DEC
49047: ST_TO_ADDR
49048: LD_VAR 0 5
49052: PUSH
49053: FOR_TO
49054: IFFALSE 49101
// begin hc_class := 21 ;
49056: LD_ADDR_OWVAR 28
49060: PUSH
49061: LD_INT 21
49063: ST_TO_ADDR
// hc_gallery :=  ;
49064: LD_ADDR_OWVAR 33
49068: PUSH
49069: LD_STRING 
49071: ST_TO_ADDR
// animal := CreateHuman ;
49072: LD_ADDR_VAR 0 12
49076: PUSH
49077: CALL_OW 44
49081: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49082: LD_VAR 0 12
49086: PPUSH
49087: LD_VAR 0 8
49091: PPUSH
49092: LD_INT 0
49094: PPUSH
49095: CALL 51160 0 3
// end ;
49099: GO 49053
49101: POP
49102: POP
// if birds then
49103: LD_VAR 0 1
49107: IFFALSE 49174
// for i = 1 to birds do
49109: LD_ADDR_VAR 0 11
49113: PUSH
49114: DOUBLE
49115: LD_INT 1
49117: DEC
49118: ST_TO_ADDR
49119: LD_VAR 0 1
49123: PUSH
49124: FOR_TO
49125: IFFALSE 49172
// begin hc_class = 18 ;
49127: LD_ADDR_OWVAR 28
49131: PUSH
49132: LD_INT 18
49134: ST_TO_ADDR
// hc_gallery =  ;
49135: LD_ADDR_OWVAR 33
49139: PUSH
49140: LD_STRING 
49142: ST_TO_ADDR
// animal := CreateHuman ;
49143: LD_ADDR_VAR 0 12
49147: PUSH
49148: CALL_OW 44
49152: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49153: LD_VAR 0 12
49157: PPUSH
49158: LD_VAR 0 8
49162: PPUSH
49163: LD_INT 0
49165: PPUSH
49166: CALL 51160 0 3
// end ;
49170: GO 49124
49172: POP
49173: POP
// if tigers then
49174: LD_VAR 0 2
49178: IFFALSE 49262
// for i = 1 to tigers do
49180: LD_ADDR_VAR 0 11
49184: PUSH
49185: DOUBLE
49186: LD_INT 1
49188: DEC
49189: ST_TO_ADDR
49190: LD_VAR 0 2
49194: PUSH
49195: FOR_TO
49196: IFFALSE 49260
// begin hc_class = class_tiger ;
49198: LD_ADDR_OWVAR 28
49202: PUSH
49203: LD_INT 14
49205: ST_TO_ADDR
// hc_gallery =  ;
49206: LD_ADDR_OWVAR 33
49210: PUSH
49211: LD_STRING 
49213: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49214: LD_ADDR_OWVAR 35
49218: PUSH
49219: LD_INT 7
49221: NEG
49222: PPUSH
49223: LD_INT 7
49225: PPUSH
49226: CALL_OW 12
49230: ST_TO_ADDR
// animal := CreateHuman ;
49231: LD_ADDR_VAR 0 12
49235: PUSH
49236: CALL_OW 44
49240: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49241: LD_VAR 0 12
49245: PPUSH
49246: LD_VAR 0 8
49250: PPUSH
49251: LD_INT 0
49253: PPUSH
49254: CALL 51160 0 3
// end ;
49258: GO 49195
49260: POP
49261: POP
// if apemans then
49262: LD_VAR 0 3
49266: IFFALSE 49389
// for i = 1 to apemans do
49268: LD_ADDR_VAR 0 11
49272: PUSH
49273: DOUBLE
49274: LD_INT 1
49276: DEC
49277: ST_TO_ADDR
49278: LD_VAR 0 3
49282: PUSH
49283: FOR_TO
49284: IFFALSE 49387
// begin hc_class = class_apeman ;
49286: LD_ADDR_OWVAR 28
49290: PUSH
49291: LD_INT 12
49293: ST_TO_ADDR
// hc_gallery =  ;
49294: LD_ADDR_OWVAR 33
49298: PUSH
49299: LD_STRING 
49301: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49302: LD_ADDR_OWVAR 35
49306: PUSH
49307: LD_INT 2
49309: NEG
49310: PPUSH
49311: LD_INT 2
49313: PPUSH
49314: CALL_OW 12
49318: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49319: LD_ADDR_OWVAR 31
49323: PUSH
49324: LD_INT 1
49326: PPUSH
49327: LD_INT 3
49329: PPUSH
49330: CALL_OW 12
49334: PUSH
49335: LD_INT 1
49337: PPUSH
49338: LD_INT 3
49340: PPUSH
49341: CALL_OW 12
49345: PUSH
49346: LD_INT 0
49348: PUSH
49349: LD_INT 0
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: ST_TO_ADDR
// animal := CreateHuman ;
49358: LD_ADDR_VAR 0 12
49362: PUSH
49363: CALL_OW 44
49367: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49368: LD_VAR 0 12
49372: PPUSH
49373: LD_VAR 0 8
49377: PPUSH
49378: LD_INT 0
49380: PPUSH
49381: CALL 51160 0 3
// end ;
49385: GO 49283
49387: POP
49388: POP
// if enchidnas then
49389: LD_VAR 0 4
49393: IFFALSE 49460
// for i = 1 to enchidnas do
49395: LD_ADDR_VAR 0 11
49399: PUSH
49400: DOUBLE
49401: LD_INT 1
49403: DEC
49404: ST_TO_ADDR
49405: LD_VAR 0 4
49409: PUSH
49410: FOR_TO
49411: IFFALSE 49458
// begin hc_class = 13 ;
49413: LD_ADDR_OWVAR 28
49417: PUSH
49418: LD_INT 13
49420: ST_TO_ADDR
// hc_gallery =  ;
49421: LD_ADDR_OWVAR 33
49425: PUSH
49426: LD_STRING 
49428: ST_TO_ADDR
// animal := CreateHuman ;
49429: LD_ADDR_VAR 0 12
49433: PUSH
49434: CALL_OW 44
49438: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49439: LD_VAR 0 12
49443: PPUSH
49444: LD_VAR 0 8
49448: PPUSH
49449: LD_INT 0
49451: PPUSH
49452: CALL 51160 0 3
// end ;
49456: GO 49410
49458: POP
49459: POP
// if fishes then
49460: LD_VAR 0 7
49464: IFFALSE 49531
// for i = 1 to fishes do
49466: LD_ADDR_VAR 0 11
49470: PUSH
49471: DOUBLE
49472: LD_INT 1
49474: DEC
49475: ST_TO_ADDR
49476: LD_VAR 0 7
49480: PUSH
49481: FOR_TO
49482: IFFALSE 49529
// begin hc_class = 20 ;
49484: LD_ADDR_OWVAR 28
49488: PUSH
49489: LD_INT 20
49491: ST_TO_ADDR
// hc_gallery =  ;
49492: LD_ADDR_OWVAR 33
49496: PUSH
49497: LD_STRING 
49499: ST_TO_ADDR
// animal := CreateHuman ;
49500: LD_ADDR_VAR 0 12
49504: PUSH
49505: CALL_OW 44
49509: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49510: LD_VAR 0 12
49514: PPUSH
49515: LD_VAR 0 9
49519: PPUSH
49520: LD_INT 0
49522: PPUSH
49523: CALL 51160 0 3
// end ;
49527: GO 49481
49529: POP
49530: POP
// end ;
49531: LD_VAR 0 10
49535: RET
// export function WantHeal ( sci , unit ) ; begin
49536: LD_INT 0
49538: PPUSH
// if GetTaskList ( sci ) > 0 then
49539: LD_VAR 0 1
49543: PPUSH
49544: CALL_OW 437
49548: PUSH
49549: LD_INT 0
49551: GREATER
49552: IFFALSE 49622
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49554: LD_VAR 0 1
49558: PPUSH
49559: CALL_OW 437
49563: PUSH
49564: LD_INT 1
49566: ARRAY
49567: PUSH
49568: LD_INT 1
49570: ARRAY
49571: PUSH
49572: LD_STRING l
49574: EQUAL
49575: PUSH
49576: LD_VAR 0 1
49580: PPUSH
49581: CALL_OW 437
49585: PUSH
49586: LD_INT 1
49588: ARRAY
49589: PUSH
49590: LD_INT 4
49592: ARRAY
49593: PUSH
49594: LD_VAR 0 2
49598: EQUAL
49599: AND
49600: IFFALSE 49612
// result := true else
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: LD_INT 1
49609: ST_TO_ADDR
49610: GO 49620
// result := false ;
49612: LD_ADDR_VAR 0 3
49616: PUSH
49617: LD_INT 0
49619: ST_TO_ADDR
// end else
49620: GO 49630
// result := false ;
49622: LD_ADDR_VAR 0 3
49626: PUSH
49627: LD_INT 0
49629: ST_TO_ADDR
// end ;
49630: LD_VAR 0 3
49634: RET
// export function HealTarget ( sci ) ; begin
49635: LD_INT 0
49637: PPUSH
// if not sci then
49638: LD_VAR 0 1
49642: NOT
49643: IFFALSE 49647
// exit ;
49645: GO 49712
// result := 0 ;
49647: LD_ADDR_VAR 0 2
49651: PUSH
49652: LD_INT 0
49654: ST_TO_ADDR
// if GetTaskList ( sci ) then
49655: LD_VAR 0 1
49659: PPUSH
49660: CALL_OW 437
49664: IFFALSE 49712
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49666: LD_VAR 0 1
49670: PPUSH
49671: CALL_OW 437
49675: PUSH
49676: LD_INT 1
49678: ARRAY
49679: PUSH
49680: LD_INT 1
49682: ARRAY
49683: PUSH
49684: LD_STRING l
49686: EQUAL
49687: IFFALSE 49712
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49689: LD_ADDR_VAR 0 2
49693: PUSH
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 437
49703: PUSH
49704: LD_INT 1
49706: ARRAY
49707: PUSH
49708: LD_INT 4
49710: ARRAY
49711: ST_TO_ADDR
// end ;
49712: LD_VAR 0 2
49716: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49717: LD_INT 0
49719: PPUSH
49720: PPUSH
49721: PPUSH
49722: PPUSH
// if not base_units then
49723: LD_VAR 0 1
49727: NOT
49728: IFFALSE 49732
// exit ;
49730: GO 49819
// result := false ;
49732: LD_ADDR_VAR 0 2
49736: PUSH
49737: LD_INT 0
49739: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49740: LD_ADDR_VAR 0 5
49744: PUSH
49745: LD_VAR 0 1
49749: PPUSH
49750: LD_INT 21
49752: PUSH
49753: LD_INT 3
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PPUSH
49760: CALL_OW 72
49764: ST_TO_ADDR
// if not tmp then
49765: LD_VAR 0 5
49769: NOT
49770: IFFALSE 49774
// exit ;
49772: GO 49819
// for i in tmp do
49774: LD_ADDR_VAR 0 3
49778: PUSH
49779: LD_VAR 0 5
49783: PUSH
49784: FOR_IN
49785: IFFALSE 49817
// begin result := EnemyInRange ( i , 22 ) ;
49787: LD_ADDR_VAR 0 2
49791: PUSH
49792: LD_VAR 0 3
49796: PPUSH
49797: LD_INT 22
49799: PPUSH
49800: CALL 47406 0 2
49804: ST_TO_ADDR
// if result then
49805: LD_VAR 0 2
49809: IFFALSE 49815
// exit ;
49811: POP
49812: POP
49813: GO 49819
// end ;
49815: GO 49784
49817: POP
49818: POP
// end ;
49819: LD_VAR 0 2
49823: RET
// export function FilterByTag ( units , tag ) ; begin
49824: LD_INT 0
49826: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49827: LD_ADDR_VAR 0 3
49831: PUSH
49832: LD_VAR 0 1
49836: PPUSH
49837: LD_INT 120
49839: PUSH
49840: LD_VAR 0 2
49844: PUSH
49845: EMPTY
49846: LIST
49847: LIST
49848: PPUSH
49849: CALL_OW 72
49853: ST_TO_ADDR
// end ;
49854: LD_VAR 0 3
49858: RET
// export function IsDriver ( un ) ; begin
49859: LD_INT 0
49861: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49862: LD_ADDR_VAR 0 2
49866: PUSH
49867: LD_VAR 0 1
49871: PUSH
49872: LD_INT 55
49874: PUSH
49875: EMPTY
49876: LIST
49877: PPUSH
49878: CALL_OW 69
49882: IN
49883: ST_TO_ADDR
// end ;
49884: LD_VAR 0 2
49888: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49889: LD_INT 0
49891: PPUSH
49892: PPUSH
// list := [ ] ;
49893: LD_ADDR_VAR 0 5
49897: PUSH
49898: EMPTY
49899: ST_TO_ADDR
// case d of 0 :
49900: LD_VAR 0 3
49904: PUSH
49905: LD_INT 0
49907: DOUBLE
49908: EQUAL
49909: IFTRUE 49913
49911: GO 50046
49913: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49914: LD_ADDR_VAR 0 5
49918: PUSH
49919: LD_VAR 0 1
49923: PUSH
49924: LD_INT 4
49926: MINUS
49927: PUSH
49928: LD_VAR 0 2
49932: PUSH
49933: LD_INT 4
49935: MINUS
49936: PUSH
49937: LD_INT 2
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: LIST
49944: PUSH
49945: LD_VAR 0 1
49949: PUSH
49950: LD_INT 3
49952: MINUS
49953: PUSH
49954: LD_VAR 0 2
49958: PUSH
49959: LD_INT 1
49961: PUSH
49962: EMPTY
49963: LIST
49964: LIST
49965: LIST
49966: PUSH
49967: LD_VAR 0 1
49971: PUSH
49972: LD_INT 4
49974: PLUS
49975: PUSH
49976: LD_VAR 0 2
49980: PUSH
49981: LD_INT 4
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: LIST
49988: PUSH
49989: LD_VAR 0 1
49993: PUSH
49994: LD_INT 3
49996: PLUS
49997: PUSH
49998: LD_VAR 0 2
50002: PUSH
50003: LD_INT 3
50005: PLUS
50006: PUSH
50007: LD_INT 5
50009: PUSH
50010: EMPTY
50011: LIST
50012: LIST
50013: LIST
50014: PUSH
50015: LD_VAR 0 1
50019: PUSH
50020: LD_VAR 0 2
50024: PUSH
50025: LD_INT 4
50027: PLUS
50028: PUSH
50029: LD_INT 0
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: LIST
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: LIST
50041: LIST
50042: LIST
50043: ST_TO_ADDR
// end ; 1 :
50044: GO 50744
50046: LD_INT 1
50048: DOUBLE
50049: EQUAL
50050: IFTRUE 50054
50052: GO 50187
50054: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50055: LD_ADDR_VAR 0 5
50059: PUSH
50060: LD_VAR 0 1
50064: PUSH
50065: LD_VAR 0 2
50069: PUSH
50070: LD_INT 4
50072: MINUS
50073: PUSH
50074: LD_INT 3
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: LIST
50081: PUSH
50082: LD_VAR 0 1
50086: PUSH
50087: LD_INT 3
50089: MINUS
50090: PUSH
50091: LD_VAR 0 2
50095: PUSH
50096: LD_INT 3
50098: MINUS
50099: PUSH
50100: LD_INT 2
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: LIST
50107: PUSH
50108: LD_VAR 0 1
50112: PUSH
50113: LD_INT 4
50115: MINUS
50116: PUSH
50117: LD_VAR 0 2
50121: PUSH
50122: LD_INT 1
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: LIST
50129: PUSH
50130: LD_VAR 0 1
50134: PUSH
50135: LD_VAR 0 2
50139: PUSH
50140: LD_INT 3
50142: PLUS
50143: PUSH
50144: LD_INT 0
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: LIST
50151: PUSH
50152: LD_VAR 0 1
50156: PUSH
50157: LD_INT 4
50159: PLUS
50160: PUSH
50161: LD_VAR 0 2
50165: PUSH
50166: LD_INT 4
50168: PLUS
50169: PUSH
50170: LD_INT 5
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: LIST
50177: PUSH
50178: EMPTY
50179: LIST
50180: LIST
50181: LIST
50182: LIST
50183: LIST
50184: ST_TO_ADDR
// end ; 2 :
50185: GO 50744
50187: LD_INT 2
50189: DOUBLE
50190: EQUAL
50191: IFTRUE 50195
50193: GO 50324
50195: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50196: LD_ADDR_VAR 0 5
50200: PUSH
50201: LD_VAR 0 1
50205: PUSH
50206: LD_VAR 0 2
50210: PUSH
50211: LD_INT 3
50213: MINUS
50214: PUSH
50215: LD_INT 3
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: LIST
50222: PUSH
50223: LD_VAR 0 1
50227: PUSH
50228: LD_INT 4
50230: PLUS
50231: PUSH
50232: LD_VAR 0 2
50236: PUSH
50237: LD_INT 4
50239: PUSH
50240: EMPTY
50241: LIST
50242: LIST
50243: LIST
50244: PUSH
50245: LD_VAR 0 1
50249: PUSH
50250: LD_VAR 0 2
50254: PUSH
50255: LD_INT 4
50257: PLUS
50258: PUSH
50259: LD_INT 0
50261: PUSH
50262: EMPTY
50263: LIST
50264: LIST
50265: LIST
50266: PUSH
50267: LD_VAR 0 1
50271: PUSH
50272: LD_INT 3
50274: MINUS
50275: PUSH
50276: LD_VAR 0 2
50280: PUSH
50281: LD_INT 1
50283: PUSH
50284: EMPTY
50285: LIST
50286: LIST
50287: LIST
50288: PUSH
50289: LD_VAR 0 1
50293: PUSH
50294: LD_INT 4
50296: MINUS
50297: PUSH
50298: LD_VAR 0 2
50302: PUSH
50303: LD_INT 4
50305: MINUS
50306: PUSH
50307: LD_INT 2
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: LIST
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: ST_TO_ADDR
// end ; 3 :
50322: GO 50744
50324: LD_INT 3
50326: DOUBLE
50327: EQUAL
50328: IFTRUE 50332
50330: GO 50465
50332: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50333: LD_ADDR_VAR 0 5
50337: PUSH
50338: LD_VAR 0 1
50342: PUSH
50343: LD_INT 3
50345: PLUS
50346: PUSH
50347: LD_VAR 0 2
50351: PUSH
50352: LD_INT 4
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: LIST
50359: PUSH
50360: LD_VAR 0 1
50364: PUSH
50365: LD_INT 4
50367: PLUS
50368: PUSH
50369: LD_VAR 0 2
50373: PUSH
50374: LD_INT 4
50376: PLUS
50377: PUSH
50378: LD_INT 5
50380: PUSH
50381: EMPTY
50382: LIST
50383: LIST
50384: LIST
50385: PUSH
50386: LD_VAR 0 1
50390: PUSH
50391: LD_INT 4
50393: MINUS
50394: PUSH
50395: LD_VAR 0 2
50399: PUSH
50400: LD_INT 1
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: LIST
50407: PUSH
50408: LD_VAR 0 1
50412: PUSH
50413: LD_VAR 0 2
50417: PUSH
50418: LD_INT 4
50420: MINUS
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: EMPTY
50426: LIST
50427: LIST
50428: LIST
50429: PUSH
50430: LD_VAR 0 1
50434: PUSH
50435: LD_INT 3
50437: MINUS
50438: PUSH
50439: LD_VAR 0 2
50443: PUSH
50444: LD_INT 3
50446: MINUS
50447: PUSH
50448: LD_INT 2
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: LIST
50455: PUSH
50456: EMPTY
50457: LIST
50458: LIST
50459: LIST
50460: LIST
50461: LIST
50462: ST_TO_ADDR
// end ; 4 :
50463: GO 50744
50465: LD_INT 4
50467: DOUBLE
50468: EQUAL
50469: IFTRUE 50473
50471: GO 50606
50473: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50474: LD_ADDR_VAR 0 5
50478: PUSH
50479: LD_VAR 0 1
50483: PUSH
50484: LD_VAR 0 2
50488: PUSH
50489: LD_INT 4
50491: PLUS
50492: PUSH
50493: LD_INT 0
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: LIST
50500: PUSH
50501: LD_VAR 0 1
50505: PUSH
50506: LD_INT 3
50508: PLUS
50509: PUSH
50510: LD_VAR 0 2
50514: PUSH
50515: LD_INT 3
50517: PLUS
50518: PUSH
50519: LD_INT 5
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: LIST
50526: PUSH
50527: LD_VAR 0 1
50531: PUSH
50532: LD_INT 4
50534: PLUS
50535: PUSH
50536: LD_VAR 0 2
50540: PUSH
50541: LD_INT 4
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: LIST
50548: PUSH
50549: LD_VAR 0 1
50553: PUSH
50554: LD_VAR 0 2
50558: PUSH
50559: LD_INT 3
50561: MINUS
50562: PUSH
50563: LD_INT 3
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: LIST
50570: PUSH
50571: LD_VAR 0 1
50575: PUSH
50576: LD_INT 4
50578: MINUS
50579: PUSH
50580: LD_VAR 0 2
50584: PUSH
50585: LD_INT 4
50587: MINUS
50588: PUSH
50589: LD_INT 2
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: LIST
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: LIST
50601: LIST
50602: LIST
50603: ST_TO_ADDR
// end ; 5 :
50604: GO 50744
50606: LD_INT 5
50608: DOUBLE
50609: EQUAL
50610: IFTRUE 50614
50612: GO 50743
50614: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50615: LD_ADDR_VAR 0 5
50619: PUSH
50620: LD_VAR 0 1
50624: PUSH
50625: LD_INT 4
50627: MINUS
50628: PUSH
50629: LD_VAR 0 2
50633: PUSH
50634: LD_INT 1
50636: PUSH
50637: EMPTY
50638: LIST
50639: LIST
50640: LIST
50641: PUSH
50642: LD_VAR 0 1
50646: PUSH
50647: LD_VAR 0 2
50651: PUSH
50652: LD_INT 4
50654: MINUS
50655: PUSH
50656: LD_INT 3
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: LIST
50663: PUSH
50664: LD_VAR 0 1
50668: PUSH
50669: LD_INT 4
50671: PLUS
50672: PUSH
50673: LD_VAR 0 2
50677: PUSH
50678: LD_INT 4
50680: PLUS
50681: PUSH
50682: LD_INT 5
50684: PUSH
50685: EMPTY
50686: LIST
50687: LIST
50688: LIST
50689: PUSH
50690: LD_VAR 0 1
50694: PUSH
50695: LD_INT 3
50697: PLUS
50698: PUSH
50699: LD_VAR 0 2
50703: PUSH
50704: LD_INT 4
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: LIST
50711: PUSH
50712: LD_VAR 0 1
50716: PUSH
50717: LD_VAR 0 2
50721: PUSH
50722: LD_INT 3
50724: PLUS
50725: PUSH
50726: LD_INT 0
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: LIST
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: ST_TO_ADDR
// end ; end ;
50741: GO 50744
50743: POP
// result := list ;
50744: LD_ADDR_VAR 0 4
50748: PUSH
50749: LD_VAR 0 5
50753: ST_TO_ADDR
// end ;
50754: LD_VAR 0 4
50758: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50759: LD_INT 0
50761: PPUSH
50762: PPUSH
50763: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50764: LD_VAR 0 1
50768: NOT
50769: PUSH
50770: LD_VAR 0 2
50774: PUSH
50775: LD_INT 1
50777: PUSH
50778: LD_INT 2
50780: PUSH
50781: LD_INT 3
50783: PUSH
50784: LD_INT 4
50786: PUSH
50787: EMPTY
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: IN
50793: NOT
50794: OR
50795: IFFALSE 50799
// exit ;
50797: GO 50882
// tmp := [ ] ;
50799: LD_ADDR_VAR 0 5
50803: PUSH
50804: EMPTY
50805: ST_TO_ADDR
// for i in units do
50806: LD_ADDR_VAR 0 4
50810: PUSH
50811: LD_VAR 0 1
50815: PUSH
50816: FOR_IN
50817: IFFALSE 50851
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
50819: LD_ADDR_VAR 0 5
50823: PUSH
50824: LD_VAR 0 5
50828: PPUSH
50829: LD_VAR 0 4
50833: PPUSH
50834: LD_VAR 0 2
50838: PPUSH
50839: CALL_OW 259
50843: PPUSH
50844: CALL 52242 0 2
50848: ST_TO_ADDR
50849: GO 50816
50851: POP
50852: POP
// if not tmp then
50853: LD_VAR 0 5
50857: NOT
50858: IFFALSE 50862
// exit ;
50860: GO 50882
// result := SortListByListDesc ( units , tmp ) ;
50862: LD_ADDR_VAR 0 3
50866: PUSH
50867: LD_VAR 0 1
50871: PPUSH
50872: LD_VAR 0 5
50876: PPUSH
50877: CALL_OW 77
50881: ST_TO_ADDR
// end ;
50882: LD_VAR 0 3
50886: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50887: LD_INT 0
50889: PPUSH
50890: PPUSH
50891: PPUSH
// result := false ;
50892: LD_ADDR_VAR 0 3
50896: PUSH
50897: LD_INT 0
50899: ST_TO_ADDR
// if not building then
50900: LD_VAR 0 2
50904: NOT
50905: IFFALSE 50909
// exit ;
50907: GO 51047
// x := GetX ( building ) ;
50909: LD_ADDR_VAR 0 4
50913: PUSH
50914: LD_VAR 0 2
50918: PPUSH
50919: CALL_OW 250
50923: ST_TO_ADDR
// y := GetY ( building ) ;
50924: LD_ADDR_VAR 0 5
50928: PUSH
50929: LD_VAR 0 2
50933: PPUSH
50934: CALL_OW 251
50938: ST_TO_ADDR
// if not x or not y then
50939: LD_VAR 0 4
50943: NOT
50944: PUSH
50945: LD_VAR 0 5
50949: NOT
50950: OR
50951: IFFALSE 50955
// exit ;
50953: GO 51047
// if GetTaskList ( unit ) then
50955: LD_VAR 0 1
50959: PPUSH
50960: CALL_OW 437
50964: IFFALSE 51047
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50966: LD_STRING e
50968: PUSH
50969: LD_VAR 0 1
50973: PPUSH
50974: CALL_OW 437
50978: PUSH
50979: LD_INT 1
50981: ARRAY
50982: PUSH
50983: LD_INT 1
50985: ARRAY
50986: EQUAL
50987: PUSH
50988: LD_VAR 0 4
50992: PUSH
50993: LD_VAR 0 1
50997: PPUSH
50998: CALL_OW 437
51002: PUSH
51003: LD_INT 1
51005: ARRAY
51006: PUSH
51007: LD_INT 2
51009: ARRAY
51010: EQUAL
51011: AND
51012: PUSH
51013: LD_VAR 0 5
51017: PUSH
51018: LD_VAR 0 1
51022: PPUSH
51023: CALL_OW 437
51027: PUSH
51028: LD_INT 1
51030: ARRAY
51031: PUSH
51032: LD_INT 3
51034: ARRAY
51035: EQUAL
51036: AND
51037: IFFALSE 51047
// result := true end ;
51039: LD_ADDR_VAR 0 3
51043: PUSH
51044: LD_INT 1
51046: ST_TO_ADDR
// end ;
51047: LD_VAR 0 3
51051: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51052: LD_INT 0
51054: PPUSH
// result := false ;
51055: LD_ADDR_VAR 0 4
51059: PUSH
51060: LD_INT 0
51062: ST_TO_ADDR
// if GetTaskList ( unit ) then
51063: LD_VAR 0 1
51067: PPUSH
51068: CALL_OW 437
51072: IFFALSE 51155
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51074: LD_STRING M
51076: PUSH
51077: LD_VAR 0 1
51081: PPUSH
51082: CALL_OW 437
51086: PUSH
51087: LD_INT 1
51089: ARRAY
51090: PUSH
51091: LD_INT 1
51093: ARRAY
51094: EQUAL
51095: PUSH
51096: LD_VAR 0 2
51100: PUSH
51101: LD_VAR 0 1
51105: PPUSH
51106: CALL_OW 437
51110: PUSH
51111: LD_INT 1
51113: ARRAY
51114: PUSH
51115: LD_INT 2
51117: ARRAY
51118: EQUAL
51119: AND
51120: PUSH
51121: LD_VAR 0 3
51125: PUSH
51126: LD_VAR 0 1
51130: PPUSH
51131: CALL_OW 437
51135: PUSH
51136: LD_INT 1
51138: ARRAY
51139: PUSH
51140: LD_INT 3
51142: ARRAY
51143: EQUAL
51144: AND
51145: IFFALSE 51155
// result := true ;
51147: LD_ADDR_VAR 0 4
51151: PUSH
51152: LD_INT 1
51154: ST_TO_ADDR
// end ; end ;
51155: LD_VAR 0 4
51159: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51160: LD_INT 0
51162: PPUSH
51163: PPUSH
51164: PPUSH
51165: PPUSH
// if not unit or not area then
51166: LD_VAR 0 1
51170: NOT
51171: PUSH
51172: LD_VAR 0 2
51176: NOT
51177: OR
51178: IFFALSE 51182
// exit ;
51180: GO 51345
// tmp := AreaToList ( area , i ) ;
51182: LD_ADDR_VAR 0 6
51186: PUSH
51187: LD_VAR 0 2
51191: PPUSH
51192: LD_VAR 0 5
51196: PPUSH
51197: CALL_OW 517
51201: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51202: LD_ADDR_VAR 0 5
51206: PUSH
51207: DOUBLE
51208: LD_INT 1
51210: DEC
51211: ST_TO_ADDR
51212: LD_VAR 0 6
51216: PUSH
51217: LD_INT 1
51219: ARRAY
51220: PUSH
51221: FOR_TO
51222: IFFALSE 51343
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51224: LD_ADDR_VAR 0 7
51228: PUSH
51229: LD_VAR 0 6
51233: PUSH
51234: LD_INT 1
51236: ARRAY
51237: PUSH
51238: LD_VAR 0 5
51242: ARRAY
51243: PUSH
51244: LD_VAR 0 6
51248: PUSH
51249: LD_INT 2
51251: ARRAY
51252: PUSH
51253: LD_VAR 0 5
51257: ARRAY
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
51263: LD_INT 92
51265: PUSH
51266: LD_VAR 0 7
51270: PUSH
51271: LD_INT 1
51273: ARRAY
51274: PUSH
51275: LD_VAR 0 7
51279: PUSH
51280: LD_INT 2
51282: ARRAY
51283: PUSH
51284: LD_INT 3
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: LIST
51291: LIST
51292: PPUSH
51293: CALL_OW 69
51297: PUSH
51298: LD_INT 0
51300: EQUAL
51301: IFFALSE 51341
// begin PlaceUnitArea ( unit , area , mode ) ;
51303: LD_VAR 0 1
51307: PPUSH
51308: LD_VAR 0 2
51312: PPUSH
51313: LD_VAR 0 3
51317: PPUSH
51318: CALL_OW 49
// result := IsPlaced ( unit ) ;
51322: LD_ADDR_VAR 0 4
51326: PUSH
51327: LD_VAR 0 1
51331: PPUSH
51332: CALL_OW 305
51336: ST_TO_ADDR
// exit ;
51337: POP
51338: POP
51339: GO 51345
// end ; end ;
51341: GO 51221
51343: POP
51344: POP
// end ;
51345: LD_VAR 0 4
51349: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51350: LD_INT 0
51352: PPUSH
51353: PPUSH
51354: PPUSH
// if not side or side > 8 then
51355: LD_VAR 0 1
51359: NOT
51360: PUSH
51361: LD_VAR 0 1
51365: PUSH
51366: LD_INT 8
51368: GREATER
51369: OR
51370: IFFALSE 51374
// exit ;
51372: GO 51561
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51374: LD_ADDR_VAR 0 4
51378: PUSH
51379: LD_INT 22
51381: PUSH
51382: LD_VAR 0 1
51386: PUSH
51387: EMPTY
51388: LIST
51389: LIST
51390: PUSH
51391: LD_INT 21
51393: PUSH
51394: LD_INT 3
51396: PUSH
51397: EMPTY
51398: LIST
51399: LIST
51400: PUSH
51401: EMPTY
51402: LIST
51403: LIST
51404: PPUSH
51405: CALL_OW 69
51409: ST_TO_ADDR
// if not tmp then
51410: LD_VAR 0 4
51414: NOT
51415: IFFALSE 51419
// exit ;
51417: GO 51561
// enable_addtolog := true ;
51419: LD_ADDR_OWVAR 81
51423: PUSH
51424: LD_INT 1
51426: ST_TO_ADDR
// AddToLog ( [ ) ;
51427: LD_STRING [
51429: PPUSH
51430: CALL_OW 561
// for i in tmp do
51434: LD_ADDR_VAR 0 3
51438: PUSH
51439: LD_VAR 0 4
51443: PUSH
51444: FOR_IN
51445: IFFALSE 51552
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51447: LD_STRING [
51449: PUSH
51450: LD_VAR 0 3
51454: PPUSH
51455: CALL_OW 266
51459: STR
51460: PUSH
51461: LD_STRING , 
51463: STR
51464: PUSH
51465: LD_VAR 0 3
51469: PPUSH
51470: CALL_OW 250
51474: STR
51475: PUSH
51476: LD_STRING , 
51478: STR
51479: PUSH
51480: LD_VAR 0 3
51484: PPUSH
51485: CALL_OW 251
51489: STR
51490: PUSH
51491: LD_STRING , 
51493: STR
51494: PUSH
51495: LD_VAR 0 3
51499: PPUSH
51500: CALL_OW 254
51504: STR
51505: PUSH
51506: LD_STRING , 
51508: STR
51509: PUSH
51510: LD_VAR 0 3
51514: PPUSH
51515: LD_INT 1
51517: PPUSH
51518: CALL_OW 268
51522: STR
51523: PUSH
51524: LD_STRING , 
51526: STR
51527: PUSH
51528: LD_VAR 0 3
51532: PPUSH
51533: LD_INT 2
51535: PPUSH
51536: CALL_OW 268
51540: STR
51541: PUSH
51542: LD_STRING ],
51544: STR
51545: PPUSH
51546: CALL_OW 561
// end ;
51550: GO 51444
51552: POP
51553: POP
// AddToLog ( ]; ) ;
51554: LD_STRING ];
51556: PPUSH
51557: CALL_OW 561
// end ;
51561: LD_VAR 0 2
51565: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51566: LD_INT 0
51568: PPUSH
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
// if not area or not rate or not max then
51573: LD_VAR 0 1
51577: NOT
51578: PUSH
51579: LD_VAR 0 2
51583: NOT
51584: OR
51585: PUSH
51586: LD_VAR 0 4
51590: NOT
51591: OR
51592: IFFALSE 51596
// exit ;
51594: GO 51785
// while 1 do
51596: LD_INT 1
51598: IFFALSE 51785
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51600: LD_ADDR_VAR 0 9
51604: PUSH
51605: LD_VAR 0 1
51609: PPUSH
51610: LD_INT 1
51612: PPUSH
51613: CALL_OW 287
51617: PUSH
51618: LD_INT 10
51620: MUL
51621: ST_TO_ADDR
// r := rate / 10 ;
51622: LD_ADDR_VAR 0 7
51626: PUSH
51627: LD_VAR 0 2
51631: PUSH
51632: LD_INT 10
51634: DIVREAL
51635: ST_TO_ADDR
// time := 1 1$00 ;
51636: LD_ADDR_VAR 0 8
51640: PUSH
51641: LD_INT 2100
51643: ST_TO_ADDR
// if amount < min then
51644: LD_VAR 0 9
51648: PUSH
51649: LD_VAR 0 3
51653: LESS
51654: IFFALSE 51672
// r := r * 2 else
51656: LD_ADDR_VAR 0 7
51660: PUSH
51661: LD_VAR 0 7
51665: PUSH
51666: LD_INT 2
51668: MUL
51669: ST_TO_ADDR
51670: GO 51698
// if amount > max then
51672: LD_VAR 0 9
51676: PUSH
51677: LD_VAR 0 4
51681: GREATER
51682: IFFALSE 51698
// r := r / 2 ;
51684: LD_ADDR_VAR 0 7
51688: PUSH
51689: LD_VAR 0 7
51693: PUSH
51694: LD_INT 2
51696: DIVREAL
51697: ST_TO_ADDR
// time := time / r ;
51698: LD_ADDR_VAR 0 8
51702: PUSH
51703: LD_VAR 0 8
51707: PUSH
51708: LD_VAR 0 7
51712: DIVREAL
51713: ST_TO_ADDR
// if time < 0 then
51714: LD_VAR 0 8
51718: PUSH
51719: LD_INT 0
51721: LESS
51722: IFFALSE 51739
// time := time * - 1 ;
51724: LD_ADDR_VAR 0 8
51728: PUSH
51729: LD_VAR 0 8
51733: PUSH
51734: LD_INT 1
51736: NEG
51737: MUL
51738: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51739: LD_VAR 0 8
51743: PUSH
51744: LD_INT 35
51746: PPUSH
51747: LD_INT 875
51749: PPUSH
51750: CALL_OW 12
51754: PLUS
51755: PPUSH
51756: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51760: LD_INT 1
51762: PPUSH
51763: LD_INT 5
51765: PPUSH
51766: CALL_OW 12
51770: PPUSH
51771: LD_VAR 0 1
51775: PPUSH
51776: LD_INT 1
51778: PPUSH
51779: CALL_OW 55
// end ;
51783: GO 51596
// end ;
51785: LD_VAR 0 5
51789: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51790: LD_INT 0
51792: PPUSH
51793: PPUSH
51794: PPUSH
51795: PPUSH
51796: PPUSH
51797: PPUSH
51798: PPUSH
51799: PPUSH
// if not turrets or not factories then
51800: LD_VAR 0 1
51804: NOT
51805: PUSH
51806: LD_VAR 0 2
51810: NOT
51811: OR
51812: IFFALSE 51816
// exit ;
51814: GO 52123
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51816: LD_ADDR_VAR 0 10
51820: PUSH
51821: LD_INT 5
51823: PUSH
51824: LD_INT 6
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: PUSH
51831: LD_INT 2
51833: PUSH
51834: LD_INT 4
51836: PUSH
51837: EMPTY
51838: LIST
51839: LIST
51840: PUSH
51841: LD_INT 3
51843: PUSH
51844: LD_INT 5
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: PUSH
51851: EMPTY
51852: LIST
51853: LIST
51854: LIST
51855: PUSH
51856: LD_INT 24
51858: PUSH
51859: LD_INT 25
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: PUSH
51866: LD_INT 23
51868: PUSH
51869: LD_INT 27
51871: PUSH
51872: EMPTY
51873: LIST
51874: LIST
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: PUSH
51880: LD_INT 42
51882: PUSH
51883: LD_INT 43
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: PUSH
51890: LD_INT 44
51892: PUSH
51893: LD_INT 46
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: PUSH
51900: LD_INT 45
51902: PUSH
51903: LD_INT 47
51905: PUSH
51906: EMPTY
51907: LIST
51908: LIST
51909: PUSH
51910: EMPTY
51911: LIST
51912: LIST
51913: LIST
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: LIST
51919: ST_TO_ADDR
// result := [ ] ;
51920: LD_ADDR_VAR 0 3
51924: PUSH
51925: EMPTY
51926: ST_TO_ADDR
// for i in turrets do
51927: LD_ADDR_VAR 0 4
51931: PUSH
51932: LD_VAR 0 1
51936: PUSH
51937: FOR_IN
51938: IFFALSE 52121
// begin nat := GetNation ( i ) ;
51940: LD_ADDR_VAR 0 7
51944: PUSH
51945: LD_VAR 0 4
51949: PPUSH
51950: CALL_OW 248
51954: ST_TO_ADDR
// weapon := 0 ;
51955: LD_ADDR_VAR 0 8
51959: PUSH
51960: LD_INT 0
51962: ST_TO_ADDR
// if not nat then
51963: LD_VAR 0 7
51967: NOT
51968: IFFALSE 51972
// continue ;
51970: GO 51937
// for j in list [ nat ] do
51972: LD_ADDR_VAR 0 5
51976: PUSH
51977: LD_VAR 0 10
51981: PUSH
51982: LD_VAR 0 7
51986: ARRAY
51987: PUSH
51988: FOR_IN
51989: IFFALSE 52030
// if GetBWeapon ( i ) = j [ 1 ] then
51991: LD_VAR 0 4
51995: PPUSH
51996: CALL_OW 269
52000: PUSH
52001: LD_VAR 0 5
52005: PUSH
52006: LD_INT 1
52008: ARRAY
52009: EQUAL
52010: IFFALSE 52028
// begin weapon := j [ 2 ] ;
52012: LD_ADDR_VAR 0 8
52016: PUSH
52017: LD_VAR 0 5
52021: PUSH
52022: LD_INT 2
52024: ARRAY
52025: ST_TO_ADDR
// break ;
52026: GO 52030
// end ;
52028: GO 51988
52030: POP
52031: POP
// if not weapon then
52032: LD_VAR 0 8
52036: NOT
52037: IFFALSE 52041
// continue ;
52039: GO 51937
// for k in factories do
52041: LD_ADDR_VAR 0 6
52045: PUSH
52046: LD_VAR 0 2
52050: PUSH
52051: FOR_IN
52052: IFFALSE 52117
// begin weapons := AvailableWeaponList ( k ) ;
52054: LD_ADDR_VAR 0 9
52058: PUSH
52059: LD_VAR 0 6
52063: PPUSH
52064: CALL_OW 478
52068: ST_TO_ADDR
// if not weapons then
52069: LD_VAR 0 9
52073: NOT
52074: IFFALSE 52078
// continue ;
52076: GO 52051
// if weapon in weapons then
52078: LD_VAR 0 8
52082: PUSH
52083: LD_VAR 0 9
52087: IN
52088: IFFALSE 52115
// begin result := [ i , weapon ] ;
52090: LD_ADDR_VAR 0 3
52094: PUSH
52095: LD_VAR 0 4
52099: PUSH
52100: LD_VAR 0 8
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: ST_TO_ADDR
// exit ;
52109: POP
52110: POP
52111: POP
52112: POP
52113: GO 52123
// end ; end ;
52115: GO 52051
52117: POP
52118: POP
// end ;
52119: GO 51937
52121: POP
52122: POP
// end ;
52123: LD_VAR 0 3
52127: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52128: LD_INT 0
52130: PPUSH
// if not side or side > 8 then
52131: LD_VAR 0 3
52135: NOT
52136: PUSH
52137: LD_VAR 0 3
52141: PUSH
52142: LD_INT 8
52144: GREATER
52145: OR
52146: IFFALSE 52150
// exit ;
52148: GO 52209
// if not range then
52150: LD_VAR 0 4
52154: NOT
52155: IFFALSE 52166
// range := - 12 ;
52157: LD_ADDR_VAR 0 4
52161: PUSH
52162: LD_INT 12
52164: NEG
52165: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52166: LD_VAR 0 1
52170: PPUSH
52171: LD_VAR 0 2
52175: PPUSH
52176: LD_VAR 0 3
52180: PPUSH
52181: LD_VAR 0 4
52185: PPUSH
52186: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52190: LD_VAR 0 1
52194: PPUSH
52195: LD_VAR 0 2
52199: PPUSH
52200: LD_VAR 0 3
52204: PPUSH
52205: CALL_OW 331
// end ;
52209: LD_VAR 0 5
52213: RET
// export function Video ( mode ) ; begin
52214: LD_INT 0
52216: PPUSH
// ingame_video = mode ;
52217: LD_ADDR_OWVAR 52
52221: PUSH
52222: LD_VAR 0 1
52226: ST_TO_ADDR
// interface_hidden = mode ;
52227: LD_ADDR_OWVAR 54
52231: PUSH
52232: LD_VAR 0 1
52236: ST_TO_ADDR
// end ;
52237: LD_VAR 0 2
52241: RET
// export function Join ( array , element ) ; begin
52242: LD_INT 0
52244: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52245: LD_ADDR_VAR 0 3
52249: PUSH
52250: LD_VAR 0 1
52254: PPUSH
52255: LD_VAR 0 1
52259: PUSH
52260: LD_INT 1
52262: PLUS
52263: PPUSH
52264: LD_VAR 0 2
52268: PPUSH
52269: CALL_OW 1
52273: ST_TO_ADDR
// end ;
52274: LD_VAR 0 3
52278: RET
// export function JoinUnion ( array , element ) ; begin
52279: LD_INT 0
52281: PPUSH
// result := array union element ;
52282: LD_ADDR_VAR 0 3
52286: PUSH
52287: LD_VAR 0 1
52291: PUSH
52292: LD_VAR 0 2
52296: UNION
52297: ST_TO_ADDR
// end ;
52298: LD_VAR 0 3
52302: RET
// export function GetBehemoths ( side ) ; begin
52303: LD_INT 0
52305: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52306: LD_ADDR_VAR 0 2
52310: PUSH
52311: LD_INT 22
52313: PUSH
52314: LD_VAR 0 1
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: PUSH
52323: LD_INT 31
52325: PUSH
52326: LD_INT 25
52328: PUSH
52329: EMPTY
52330: LIST
52331: LIST
52332: PUSH
52333: EMPTY
52334: LIST
52335: LIST
52336: PPUSH
52337: CALL_OW 69
52341: ST_TO_ADDR
// end ;
52342: LD_VAR 0 2
52346: RET
// export function Shuffle ( array ) ; var i , index ; begin
52347: LD_INT 0
52349: PPUSH
52350: PPUSH
52351: PPUSH
// result := [ ] ;
52352: LD_ADDR_VAR 0 2
52356: PUSH
52357: EMPTY
52358: ST_TO_ADDR
// if not array then
52359: LD_VAR 0 1
52363: NOT
52364: IFFALSE 52368
// exit ;
52366: GO 52467
// Randomize ;
52368: CALL_OW 10
// for i = array downto 1 do
52372: LD_ADDR_VAR 0 3
52376: PUSH
52377: DOUBLE
52378: LD_VAR 0 1
52382: INC
52383: ST_TO_ADDR
52384: LD_INT 1
52386: PUSH
52387: FOR_DOWNTO
52388: IFFALSE 52465
// begin index := rand ( 1 , array ) ;
52390: LD_ADDR_VAR 0 4
52394: PUSH
52395: LD_INT 1
52397: PPUSH
52398: LD_VAR 0 1
52402: PPUSH
52403: CALL_OW 12
52407: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52408: LD_ADDR_VAR 0 2
52412: PUSH
52413: LD_VAR 0 2
52417: PPUSH
52418: LD_VAR 0 2
52422: PUSH
52423: LD_INT 1
52425: PLUS
52426: PPUSH
52427: LD_VAR 0 1
52431: PUSH
52432: LD_VAR 0 4
52436: ARRAY
52437: PPUSH
52438: CALL_OW 2
52442: ST_TO_ADDR
// array := Delete ( array , index ) ;
52443: LD_ADDR_VAR 0 1
52447: PUSH
52448: LD_VAR 0 1
52452: PPUSH
52453: LD_VAR 0 4
52457: PPUSH
52458: CALL_OW 3
52462: ST_TO_ADDR
// end ;
52463: GO 52387
52465: POP
52466: POP
// end ;
52467: LD_VAR 0 2
52471: RET
// export function GetBaseMaterials ( base ) ; begin
52472: LD_INT 0
52474: PPUSH
// result := [ 0 , 0 , 0 ] ;
52475: LD_ADDR_VAR 0 2
52479: PUSH
52480: LD_INT 0
52482: PUSH
52483: LD_INT 0
52485: PUSH
52486: LD_INT 0
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: LIST
52493: ST_TO_ADDR
// if not base then
52494: LD_VAR 0 1
52498: NOT
52499: IFFALSE 52503
// exit ;
52501: GO 52552
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52503: LD_ADDR_VAR 0 2
52507: PUSH
52508: LD_VAR 0 1
52512: PPUSH
52513: LD_INT 1
52515: PPUSH
52516: CALL_OW 275
52520: PUSH
52521: LD_VAR 0 1
52525: PPUSH
52526: LD_INT 2
52528: PPUSH
52529: CALL_OW 275
52533: PUSH
52534: LD_VAR 0 1
52538: PPUSH
52539: LD_INT 3
52541: PPUSH
52542: CALL_OW 275
52546: PUSH
52547: EMPTY
52548: LIST
52549: LIST
52550: LIST
52551: ST_TO_ADDR
// end ;
52552: LD_VAR 0 2
52556: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52557: LD_INT 0
52559: PPUSH
52560: PPUSH
// result := array ;
52561: LD_ADDR_VAR 0 3
52565: PUSH
52566: LD_VAR 0 1
52570: ST_TO_ADDR
// if size >= result then
52571: LD_VAR 0 2
52575: PUSH
52576: LD_VAR 0 3
52580: GREATEREQUAL
52581: IFFALSE 52585
// exit ;
52583: GO 52635
// if size then
52585: LD_VAR 0 2
52589: IFFALSE 52635
// for i := array downto size do
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: DOUBLE
52597: LD_VAR 0 1
52601: INC
52602: ST_TO_ADDR
52603: LD_VAR 0 2
52607: PUSH
52608: FOR_DOWNTO
52609: IFFALSE 52633
// result := Delete ( result , result ) ;
52611: LD_ADDR_VAR 0 3
52615: PUSH
52616: LD_VAR 0 3
52620: PPUSH
52621: LD_VAR 0 3
52625: PPUSH
52626: CALL_OW 3
52630: ST_TO_ADDR
52631: GO 52608
52633: POP
52634: POP
// end ;
52635: LD_VAR 0 3
52639: RET
// export function ComExit ( unit ) ; var tmp ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
// if not IsInUnit ( unit ) then
52644: LD_VAR 0 1
52648: PPUSH
52649: CALL_OW 310
52653: NOT
52654: IFFALSE 52658
// exit ;
52656: GO 52718
// tmp := IsInUnit ( unit ) ;
52658: LD_ADDR_VAR 0 3
52662: PUSH
52663: LD_VAR 0 1
52667: PPUSH
52668: CALL_OW 310
52672: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52673: LD_VAR 0 3
52677: PPUSH
52678: CALL_OW 247
52682: PUSH
52683: LD_INT 2
52685: EQUAL
52686: IFFALSE 52699
// ComExitVehicle ( unit ) else
52688: LD_VAR 0 1
52692: PPUSH
52693: CALL_OW 121
52697: GO 52708
// ComExitBuilding ( unit ) ;
52699: LD_VAR 0 1
52703: PPUSH
52704: CALL_OW 122
// result := tmp ;
52708: LD_ADDR_VAR 0 2
52712: PUSH
52713: LD_VAR 0 3
52717: ST_TO_ADDR
// end ;
52718: LD_VAR 0 2
52722: RET
// export function ComExitAll ( units ) ; var i ; begin
52723: LD_INT 0
52725: PPUSH
52726: PPUSH
// if not units then
52727: LD_VAR 0 1
52731: NOT
52732: IFFALSE 52736
// exit ;
52734: GO 52762
// for i in units do
52736: LD_ADDR_VAR 0 3
52740: PUSH
52741: LD_VAR 0 1
52745: PUSH
52746: FOR_IN
52747: IFFALSE 52760
// ComExit ( i ) ;
52749: LD_VAR 0 3
52753: PPUSH
52754: CALL 52640 0 1
52758: GO 52746
52760: POP
52761: POP
// end ;
52762: LD_VAR 0 2
52766: RET
// export function ResetHc ; begin
52767: LD_INT 0
52769: PPUSH
// InitHc ;
52770: CALL_OW 19
// hc_importance := 0 ;
52774: LD_ADDR_OWVAR 32
52778: PUSH
52779: LD_INT 0
52781: ST_TO_ADDR
// end ;
52782: LD_VAR 0 1
52786: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52787: LD_INT 0
52789: PPUSH
52790: PPUSH
52791: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52792: LD_ADDR_VAR 0 6
52796: PUSH
52797: LD_VAR 0 1
52801: PUSH
52802: LD_VAR 0 3
52806: PLUS
52807: PUSH
52808: LD_INT 2
52810: DIV
52811: ST_TO_ADDR
// if _x < 0 then
52812: LD_VAR 0 6
52816: PUSH
52817: LD_INT 0
52819: LESS
52820: IFFALSE 52837
// _x := _x * - 1 ;
52822: LD_ADDR_VAR 0 6
52826: PUSH
52827: LD_VAR 0 6
52831: PUSH
52832: LD_INT 1
52834: NEG
52835: MUL
52836: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52837: LD_ADDR_VAR 0 7
52841: PUSH
52842: LD_VAR 0 2
52846: PUSH
52847: LD_VAR 0 4
52851: PLUS
52852: PUSH
52853: LD_INT 2
52855: DIV
52856: ST_TO_ADDR
// if _y < 0 then
52857: LD_VAR 0 7
52861: PUSH
52862: LD_INT 0
52864: LESS
52865: IFFALSE 52882
// _y := _y * - 1 ;
52867: LD_ADDR_VAR 0 7
52871: PUSH
52872: LD_VAR 0 7
52876: PUSH
52877: LD_INT 1
52879: NEG
52880: MUL
52881: ST_TO_ADDR
// result := [ _x , _y ] ;
52882: LD_ADDR_VAR 0 5
52886: PUSH
52887: LD_VAR 0 6
52891: PUSH
52892: LD_VAR 0 7
52896: PUSH
52897: EMPTY
52898: LIST
52899: LIST
52900: ST_TO_ADDR
// end ;
52901: LD_VAR 0 5
52905: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52906: LD_INT 0
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
// task := GetTaskList ( unit ) ;
52912: LD_ADDR_VAR 0 7
52916: PUSH
52917: LD_VAR 0 1
52921: PPUSH
52922: CALL_OW 437
52926: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52927: LD_VAR 0 7
52931: NOT
52932: PUSH
52933: LD_VAR 0 1
52937: PPUSH
52938: LD_VAR 0 2
52942: PPUSH
52943: CALL_OW 308
52947: NOT
52948: AND
52949: IFFALSE 52953
// exit ;
52951: GO 53071
// if IsInArea ( unit , area ) then
52953: LD_VAR 0 1
52957: PPUSH
52958: LD_VAR 0 2
52962: PPUSH
52963: CALL_OW 308
52967: IFFALSE 52985
// begin ComMoveToArea ( unit , goAway ) ;
52969: LD_VAR 0 1
52973: PPUSH
52974: LD_VAR 0 3
52978: PPUSH
52979: CALL_OW 113
// exit ;
52983: GO 53071
// end ; if task [ 1 ] [ 1 ] <> M then
52985: LD_VAR 0 7
52989: PUSH
52990: LD_INT 1
52992: ARRAY
52993: PUSH
52994: LD_INT 1
52996: ARRAY
52997: PUSH
52998: LD_STRING M
53000: NONEQUAL
53001: IFFALSE 53005
// exit ;
53003: GO 53071
// x := task [ 1 ] [ 2 ] ;
53005: LD_ADDR_VAR 0 5
53009: PUSH
53010: LD_VAR 0 7
53014: PUSH
53015: LD_INT 1
53017: ARRAY
53018: PUSH
53019: LD_INT 2
53021: ARRAY
53022: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53023: LD_ADDR_VAR 0 6
53027: PUSH
53028: LD_VAR 0 7
53032: PUSH
53033: LD_INT 1
53035: ARRAY
53036: PUSH
53037: LD_INT 3
53039: ARRAY
53040: ST_TO_ADDR
// if InArea ( x , y , area ) then
53041: LD_VAR 0 5
53045: PPUSH
53046: LD_VAR 0 6
53050: PPUSH
53051: LD_VAR 0 2
53055: PPUSH
53056: CALL_OW 309
53060: IFFALSE 53071
// ComStop ( unit ) ;
53062: LD_VAR 0 1
53066: PPUSH
53067: CALL_OW 141
// end ;
53071: LD_VAR 0 4
53075: RET
// export function Abs ( value ) ; begin
53076: LD_INT 0
53078: PPUSH
// result := value ;
53079: LD_ADDR_VAR 0 2
53083: PUSH
53084: LD_VAR 0 1
53088: ST_TO_ADDR
// if value < 0 then
53089: LD_VAR 0 1
53093: PUSH
53094: LD_INT 0
53096: LESS
53097: IFFALSE 53114
// result := value * - 1 ;
53099: LD_ADDR_VAR 0 2
53103: PUSH
53104: LD_VAR 0 1
53108: PUSH
53109: LD_INT 1
53111: NEG
53112: MUL
53113: ST_TO_ADDR
// end ;
53114: LD_VAR 0 2
53118: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53119: LD_INT 0
53121: PPUSH
53122: PPUSH
53123: PPUSH
53124: PPUSH
53125: PPUSH
53126: PPUSH
53127: PPUSH
53128: PPUSH
// if not unit or not building then
53129: LD_VAR 0 1
53133: NOT
53134: PUSH
53135: LD_VAR 0 2
53139: NOT
53140: OR
53141: IFFALSE 53145
// exit ;
53143: GO 53371
// x := GetX ( building ) ;
53145: LD_ADDR_VAR 0 4
53149: PUSH
53150: LD_VAR 0 2
53154: PPUSH
53155: CALL_OW 250
53159: ST_TO_ADDR
// y := GetY ( building ) ;
53160: LD_ADDR_VAR 0 6
53164: PUSH
53165: LD_VAR 0 2
53169: PPUSH
53170: CALL_OW 251
53174: ST_TO_ADDR
// d := GetDir ( building ) ;
53175: LD_ADDR_VAR 0 8
53179: PUSH
53180: LD_VAR 0 2
53184: PPUSH
53185: CALL_OW 254
53189: ST_TO_ADDR
// r := 4 ;
53190: LD_ADDR_VAR 0 9
53194: PUSH
53195: LD_INT 4
53197: ST_TO_ADDR
// for i := 1 to 5 do
53198: LD_ADDR_VAR 0 10
53202: PUSH
53203: DOUBLE
53204: LD_INT 1
53206: DEC
53207: ST_TO_ADDR
53208: LD_INT 5
53210: PUSH
53211: FOR_TO
53212: IFFALSE 53369
// begin _x := ShiftX ( x , d , r + i ) ;
53214: LD_ADDR_VAR 0 5
53218: PUSH
53219: LD_VAR 0 4
53223: PPUSH
53224: LD_VAR 0 8
53228: PPUSH
53229: LD_VAR 0 9
53233: PUSH
53234: LD_VAR 0 10
53238: PLUS
53239: PPUSH
53240: CALL_OW 272
53244: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53245: LD_ADDR_VAR 0 7
53249: PUSH
53250: LD_VAR 0 6
53254: PPUSH
53255: LD_VAR 0 8
53259: PPUSH
53260: LD_VAR 0 9
53264: PUSH
53265: LD_VAR 0 10
53269: PLUS
53270: PPUSH
53271: CALL_OW 273
53275: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53276: LD_VAR 0 5
53280: PPUSH
53281: LD_VAR 0 7
53285: PPUSH
53286: CALL_OW 488
53290: PUSH
53291: LD_VAR 0 5
53295: PPUSH
53296: LD_VAR 0 7
53300: PPUSH
53301: CALL_OW 428
53305: PPUSH
53306: CALL_OW 247
53310: PUSH
53311: LD_INT 3
53313: PUSH
53314: LD_INT 2
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: IN
53321: NOT
53322: AND
53323: IFFALSE 53367
// begin ComMoveXY ( unit , _x , _y ) ;
53325: LD_VAR 0 1
53329: PPUSH
53330: LD_VAR 0 5
53334: PPUSH
53335: LD_VAR 0 7
53339: PPUSH
53340: CALL_OW 111
// result := [ _x , _y ] ;
53344: LD_ADDR_VAR 0 3
53348: PUSH
53349: LD_VAR 0 5
53353: PUSH
53354: LD_VAR 0 7
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: ST_TO_ADDR
// exit ;
53363: POP
53364: POP
53365: GO 53371
// end ; end ;
53367: GO 53211
53369: POP
53370: POP
// end ;
53371: LD_VAR 0 3
53375: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53376: LD_INT 0
53378: PPUSH
53379: PPUSH
53380: PPUSH
// result := 0 ;
53381: LD_ADDR_VAR 0 3
53385: PUSH
53386: LD_INT 0
53388: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53389: LD_VAR 0 1
53393: PUSH
53394: LD_INT 0
53396: LESS
53397: PUSH
53398: LD_VAR 0 1
53402: PUSH
53403: LD_INT 8
53405: GREATER
53406: OR
53407: PUSH
53408: LD_VAR 0 2
53412: PUSH
53413: LD_INT 0
53415: LESS
53416: OR
53417: PUSH
53418: LD_VAR 0 2
53422: PUSH
53423: LD_INT 8
53425: GREATER
53426: OR
53427: IFFALSE 53431
// exit ;
53429: GO 53506
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53431: LD_ADDR_VAR 0 4
53435: PUSH
53436: LD_INT 22
53438: PUSH
53439: LD_VAR 0 2
53443: PUSH
53444: EMPTY
53445: LIST
53446: LIST
53447: PPUSH
53448: CALL_OW 69
53452: PUSH
53453: FOR_IN
53454: IFFALSE 53504
// begin un := UnitShoot ( i ) ;
53456: LD_ADDR_VAR 0 5
53460: PUSH
53461: LD_VAR 0 4
53465: PPUSH
53466: CALL_OW 504
53470: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53471: LD_VAR 0 5
53475: PPUSH
53476: CALL_OW 255
53480: PUSH
53481: LD_VAR 0 1
53485: EQUAL
53486: IFFALSE 53502
// begin result := un ;
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_VAR 0 5
53497: ST_TO_ADDR
// exit ;
53498: POP
53499: POP
53500: GO 53506
// end ; end ;
53502: GO 53453
53504: POP
53505: POP
// end ;
53506: LD_VAR 0 3
53510: RET
// export function GetCargoBay ( units ) ; begin
53511: LD_INT 0
53513: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53514: LD_ADDR_VAR 0 2
53518: PUSH
53519: LD_VAR 0 1
53523: PPUSH
53524: LD_INT 2
53526: PUSH
53527: LD_INT 34
53529: PUSH
53530: LD_INT 12
53532: PUSH
53533: EMPTY
53534: LIST
53535: LIST
53536: PUSH
53537: LD_INT 34
53539: PUSH
53540: LD_INT 51
53542: PUSH
53543: EMPTY
53544: LIST
53545: LIST
53546: PUSH
53547: LD_INT 34
53549: PUSH
53550: LD_INT 32
53552: PUSH
53553: EMPTY
53554: LIST
53555: LIST
53556: PUSH
53557: LD_INT 34
53559: PUSH
53560: LD_INT 89
53562: PUSH
53563: EMPTY
53564: LIST
53565: LIST
53566: PUSH
53567: EMPTY
53568: LIST
53569: LIST
53570: LIST
53571: LIST
53572: LIST
53573: PPUSH
53574: CALL_OW 72
53578: ST_TO_ADDR
// end ;
53579: LD_VAR 0 2
53583: RET
// export function Negate ( value ) ; begin
53584: LD_INT 0
53586: PPUSH
// result := not value ;
53587: LD_ADDR_VAR 0 2
53591: PUSH
53592: LD_VAR 0 1
53596: NOT
53597: ST_TO_ADDR
// end ;
53598: LD_VAR 0 2
53602: RET
// export function Inc ( value ) ; begin
53603: LD_INT 0
53605: PPUSH
// result := value + 1 ;
53606: LD_ADDR_VAR 0 2
53610: PUSH
53611: LD_VAR 0 1
53615: PUSH
53616: LD_INT 1
53618: PLUS
53619: ST_TO_ADDR
// end ;
53620: LD_VAR 0 2
53624: RET
// export function Dec ( value ) ; begin
53625: LD_INT 0
53627: PPUSH
// result := value - 1 ;
53628: LD_ADDR_VAR 0 2
53632: PUSH
53633: LD_VAR 0 1
53637: PUSH
53638: LD_INT 1
53640: MINUS
53641: ST_TO_ADDR
// end ;
53642: LD_VAR 0 2
53646: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53647: LD_INT 0
53649: PPUSH
53650: PPUSH
53651: PPUSH
53652: PPUSH
53653: PPUSH
53654: PPUSH
53655: PPUSH
53656: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53657: LD_VAR 0 1
53661: PPUSH
53662: LD_VAR 0 2
53666: PPUSH
53667: CALL_OW 488
53671: NOT
53672: PUSH
53673: LD_VAR 0 3
53677: PPUSH
53678: LD_VAR 0 4
53682: PPUSH
53683: CALL_OW 488
53687: NOT
53688: OR
53689: IFFALSE 53702
// begin result := - 1 ;
53691: LD_ADDR_VAR 0 5
53695: PUSH
53696: LD_INT 1
53698: NEG
53699: ST_TO_ADDR
// exit ;
53700: GO 53937
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53702: LD_ADDR_VAR 0 12
53706: PUSH
53707: LD_VAR 0 1
53711: PPUSH
53712: LD_VAR 0 2
53716: PPUSH
53717: LD_VAR 0 3
53721: PPUSH
53722: LD_VAR 0 4
53726: PPUSH
53727: CALL 52787 0 4
53731: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53732: LD_ADDR_VAR 0 11
53736: PUSH
53737: LD_VAR 0 1
53741: PPUSH
53742: LD_VAR 0 2
53746: PPUSH
53747: LD_VAR 0 12
53751: PUSH
53752: LD_INT 1
53754: ARRAY
53755: PPUSH
53756: LD_VAR 0 12
53760: PUSH
53761: LD_INT 2
53763: ARRAY
53764: PPUSH
53765: CALL_OW 298
53769: ST_TO_ADDR
// distance := 9999 ;
53770: LD_ADDR_VAR 0 10
53774: PUSH
53775: LD_INT 9999
53777: ST_TO_ADDR
// for i := 0 to 5 do
53778: LD_ADDR_VAR 0 6
53782: PUSH
53783: DOUBLE
53784: LD_INT 0
53786: DEC
53787: ST_TO_ADDR
53788: LD_INT 5
53790: PUSH
53791: FOR_TO
53792: IFFALSE 53935
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53794: LD_ADDR_VAR 0 7
53798: PUSH
53799: LD_VAR 0 1
53803: PPUSH
53804: LD_VAR 0 6
53808: PPUSH
53809: LD_VAR 0 11
53813: PPUSH
53814: CALL_OW 272
53818: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53819: LD_ADDR_VAR 0 8
53823: PUSH
53824: LD_VAR 0 2
53828: PPUSH
53829: LD_VAR 0 6
53833: PPUSH
53834: LD_VAR 0 11
53838: PPUSH
53839: CALL_OW 273
53843: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53844: LD_VAR 0 7
53848: PPUSH
53849: LD_VAR 0 8
53853: PPUSH
53854: CALL_OW 488
53858: NOT
53859: IFFALSE 53863
// continue ;
53861: GO 53791
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53863: LD_ADDR_VAR 0 9
53867: PUSH
53868: LD_VAR 0 12
53872: PUSH
53873: LD_INT 1
53875: ARRAY
53876: PPUSH
53877: LD_VAR 0 12
53881: PUSH
53882: LD_INT 2
53884: ARRAY
53885: PPUSH
53886: LD_VAR 0 7
53890: PPUSH
53891: LD_VAR 0 8
53895: PPUSH
53896: CALL_OW 298
53900: ST_TO_ADDR
// if tmp < distance then
53901: LD_VAR 0 9
53905: PUSH
53906: LD_VAR 0 10
53910: LESS
53911: IFFALSE 53933
// begin result := i ;
53913: LD_ADDR_VAR 0 5
53917: PUSH
53918: LD_VAR 0 6
53922: ST_TO_ADDR
// distance := tmp ;
53923: LD_ADDR_VAR 0 10
53927: PUSH
53928: LD_VAR 0 9
53932: ST_TO_ADDR
// end ; end ;
53933: GO 53791
53935: POP
53936: POP
// end ;
53937: LD_VAR 0 5
53941: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53942: LD_INT 0
53944: PPUSH
53945: PPUSH
// if not driver or not IsInUnit ( driver ) then
53946: LD_VAR 0 1
53950: NOT
53951: PUSH
53952: LD_VAR 0 1
53956: PPUSH
53957: CALL_OW 310
53961: NOT
53962: OR
53963: IFFALSE 53967
// exit ;
53965: GO 54057
// vehicle := IsInUnit ( driver ) ;
53967: LD_ADDR_VAR 0 3
53971: PUSH
53972: LD_VAR 0 1
53976: PPUSH
53977: CALL_OW 310
53981: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53982: LD_VAR 0 1
53986: PPUSH
53987: LD_STRING \
53989: PUSH
53990: LD_INT 0
53992: PUSH
53993: LD_INT 0
53995: PUSH
53996: LD_INT 0
53998: PUSH
53999: LD_INT 0
54001: PUSH
54002: LD_INT 0
54004: PUSH
54005: LD_INT 0
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: PUSH
54017: LD_STRING E
54019: PUSH
54020: LD_INT 0
54022: PUSH
54023: LD_INT 0
54025: PUSH
54026: LD_VAR 0 3
54030: PUSH
54031: LD_INT 0
54033: PUSH
54034: LD_INT 0
54036: PUSH
54037: LD_INT 0
54039: PUSH
54040: EMPTY
54041: LIST
54042: LIST
54043: LIST
54044: LIST
54045: LIST
54046: LIST
54047: LIST
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: PPUSH
54053: CALL_OW 446
// end ;
54057: LD_VAR 0 2
54061: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54062: LD_INT 0
54064: PPUSH
54065: PPUSH
// if not driver or not IsInUnit ( driver ) then
54066: LD_VAR 0 1
54070: NOT
54071: PUSH
54072: LD_VAR 0 1
54076: PPUSH
54077: CALL_OW 310
54081: NOT
54082: OR
54083: IFFALSE 54087
// exit ;
54085: GO 54177
// vehicle := IsInUnit ( driver ) ;
54087: LD_ADDR_VAR 0 3
54091: PUSH
54092: LD_VAR 0 1
54096: PPUSH
54097: CALL_OW 310
54101: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54102: LD_VAR 0 1
54106: PPUSH
54107: LD_STRING \
54109: PUSH
54110: LD_INT 0
54112: PUSH
54113: LD_INT 0
54115: PUSH
54116: LD_INT 0
54118: PUSH
54119: LD_INT 0
54121: PUSH
54122: LD_INT 0
54124: PUSH
54125: LD_INT 0
54127: PUSH
54128: EMPTY
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: LIST
54135: LIST
54136: PUSH
54137: LD_STRING E
54139: PUSH
54140: LD_INT 0
54142: PUSH
54143: LD_INT 0
54145: PUSH
54146: LD_VAR 0 3
54150: PUSH
54151: LD_INT 0
54153: PUSH
54154: LD_INT 0
54156: PUSH
54157: LD_INT 0
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: LIST
54164: LIST
54165: LIST
54166: LIST
54167: LIST
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: PPUSH
54173: CALL_OW 447
// end ;
54177: LD_VAR 0 2
54181: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54182: LD_INT 0
54184: PPUSH
54185: PPUSH
54186: PPUSH
// tmp := [ ] ;
54187: LD_ADDR_VAR 0 5
54191: PUSH
54192: EMPTY
54193: ST_TO_ADDR
// for i in units do
54194: LD_ADDR_VAR 0 4
54198: PUSH
54199: LD_VAR 0 1
54203: PUSH
54204: FOR_IN
54205: IFFALSE 54243
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54207: LD_ADDR_VAR 0 5
54211: PUSH
54212: LD_VAR 0 5
54216: PPUSH
54217: LD_VAR 0 5
54221: PUSH
54222: LD_INT 1
54224: PLUS
54225: PPUSH
54226: LD_VAR 0 4
54230: PPUSH
54231: CALL_OW 256
54235: PPUSH
54236: CALL_OW 2
54240: ST_TO_ADDR
54241: GO 54204
54243: POP
54244: POP
// if not tmp then
54245: LD_VAR 0 5
54249: NOT
54250: IFFALSE 54254
// exit ;
54252: GO 54302
// if asc then
54254: LD_VAR 0 2
54258: IFFALSE 54282
// result := SortListByListAsc ( units , tmp ) else
54260: LD_ADDR_VAR 0 3
54264: PUSH
54265: LD_VAR 0 1
54269: PPUSH
54270: LD_VAR 0 5
54274: PPUSH
54275: CALL_OW 76
54279: ST_TO_ADDR
54280: GO 54302
// result := SortListByListDesc ( units , tmp ) ;
54282: LD_ADDR_VAR 0 3
54286: PUSH
54287: LD_VAR 0 1
54291: PPUSH
54292: LD_VAR 0 5
54296: PPUSH
54297: CALL_OW 77
54301: ST_TO_ADDR
// end ;
54302: LD_VAR 0 3
54306: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54307: LD_INT 0
54309: PPUSH
54310: PPUSH
// task := GetTaskList ( mech ) ;
54311: LD_ADDR_VAR 0 4
54315: PUSH
54316: LD_VAR 0 1
54320: PPUSH
54321: CALL_OW 437
54325: ST_TO_ADDR
// if not task then
54326: LD_VAR 0 4
54330: NOT
54331: IFFALSE 54335
// exit ;
54333: GO 54377
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54335: LD_ADDR_VAR 0 3
54339: PUSH
54340: LD_VAR 0 4
54344: PUSH
54345: LD_INT 1
54347: ARRAY
54348: PUSH
54349: LD_INT 1
54351: ARRAY
54352: PUSH
54353: LD_STRING r
54355: EQUAL
54356: PUSH
54357: LD_VAR 0 4
54361: PUSH
54362: LD_INT 1
54364: ARRAY
54365: PUSH
54366: LD_INT 4
54368: ARRAY
54369: PUSH
54370: LD_VAR 0 2
54374: EQUAL
54375: AND
54376: ST_TO_ADDR
// end ;
54377: LD_VAR 0 3
54381: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54382: LD_INT 0
54384: PPUSH
// SetDir ( unit , d ) ;
54385: LD_VAR 0 1
54389: PPUSH
54390: LD_VAR 0 4
54394: PPUSH
54395: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54399: LD_VAR 0 1
54403: PPUSH
54404: LD_VAR 0 2
54408: PPUSH
54409: LD_VAR 0 3
54413: PPUSH
54414: LD_VAR 0 5
54418: PPUSH
54419: CALL_OW 48
// end ;
54423: LD_VAR 0 6
54427: RET
// export function ToNaturalNumber ( number ) ; begin
54428: LD_INT 0
54430: PPUSH
// result := number div 1 ;
54431: LD_ADDR_VAR 0 2
54435: PUSH
54436: LD_VAR 0 1
54440: PUSH
54441: LD_INT 1
54443: DIV
54444: ST_TO_ADDR
// if number < 0 then
54445: LD_VAR 0 1
54449: PUSH
54450: LD_INT 0
54452: LESS
54453: IFFALSE 54463
// result := 0 ;
54455: LD_ADDR_VAR 0 2
54459: PUSH
54460: LD_INT 0
54462: ST_TO_ADDR
// end ;
54463: LD_VAR 0 2
54467: RET
// export function SortByClass ( units , class ) ; var un ; begin
54468: LD_INT 0
54470: PPUSH
54471: PPUSH
// if not units or not class then
54472: LD_VAR 0 1
54476: NOT
54477: PUSH
54478: LD_VAR 0 2
54482: NOT
54483: OR
54484: IFFALSE 54488
// exit ;
54486: GO 54583
// result := [ ] ;
54488: LD_ADDR_VAR 0 3
54492: PUSH
54493: EMPTY
54494: ST_TO_ADDR
// for un in units do
54495: LD_ADDR_VAR 0 4
54499: PUSH
54500: LD_VAR 0 1
54504: PUSH
54505: FOR_IN
54506: IFFALSE 54581
// if GetClass ( un ) = class then
54508: LD_VAR 0 4
54512: PPUSH
54513: CALL_OW 257
54517: PUSH
54518: LD_VAR 0 2
54522: EQUAL
54523: IFFALSE 54550
// result := Insert ( result , 1 , un ) else
54525: LD_ADDR_VAR 0 3
54529: PUSH
54530: LD_VAR 0 3
54534: PPUSH
54535: LD_INT 1
54537: PPUSH
54538: LD_VAR 0 4
54542: PPUSH
54543: CALL_OW 2
54547: ST_TO_ADDR
54548: GO 54579
// result := Replace ( result , result + 1 , un ) ;
54550: LD_ADDR_VAR 0 3
54554: PUSH
54555: LD_VAR 0 3
54559: PPUSH
54560: LD_VAR 0 3
54564: PUSH
54565: LD_INT 1
54567: PLUS
54568: PPUSH
54569: LD_VAR 0 4
54573: PPUSH
54574: CALL_OW 1
54578: ST_TO_ADDR
54579: GO 54505
54581: POP
54582: POP
// end ;
54583: LD_VAR 0 3
54587: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54588: LD_INT 0
54590: PPUSH
54591: PPUSH
54592: PPUSH
54593: PPUSH
54594: PPUSH
54595: PPUSH
54596: PPUSH
// result := [ ] ;
54597: LD_ADDR_VAR 0 4
54601: PUSH
54602: EMPTY
54603: ST_TO_ADDR
// if x - r < 0 then
54604: LD_VAR 0 1
54608: PUSH
54609: LD_VAR 0 3
54613: MINUS
54614: PUSH
54615: LD_INT 0
54617: LESS
54618: IFFALSE 54630
// min_x := 0 else
54620: LD_ADDR_VAR 0 8
54624: PUSH
54625: LD_INT 0
54627: ST_TO_ADDR
54628: GO 54646
// min_x := x - r ;
54630: LD_ADDR_VAR 0 8
54634: PUSH
54635: LD_VAR 0 1
54639: PUSH
54640: LD_VAR 0 3
54644: MINUS
54645: ST_TO_ADDR
// if y - r < 0 then
54646: LD_VAR 0 2
54650: PUSH
54651: LD_VAR 0 3
54655: MINUS
54656: PUSH
54657: LD_INT 0
54659: LESS
54660: IFFALSE 54672
// min_y := 0 else
54662: LD_ADDR_VAR 0 7
54666: PUSH
54667: LD_INT 0
54669: ST_TO_ADDR
54670: GO 54688
// min_y := y - r ;
54672: LD_ADDR_VAR 0 7
54676: PUSH
54677: LD_VAR 0 2
54681: PUSH
54682: LD_VAR 0 3
54686: MINUS
54687: ST_TO_ADDR
// max_x := x + r ;
54688: LD_ADDR_VAR 0 9
54692: PUSH
54693: LD_VAR 0 1
54697: PUSH
54698: LD_VAR 0 3
54702: PLUS
54703: ST_TO_ADDR
// max_y := y + r ;
54704: LD_ADDR_VAR 0 10
54708: PUSH
54709: LD_VAR 0 2
54713: PUSH
54714: LD_VAR 0 3
54718: PLUS
54719: ST_TO_ADDR
// for _x = min_x to max_x do
54720: LD_ADDR_VAR 0 5
54724: PUSH
54725: DOUBLE
54726: LD_VAR 0 8
54730: DEC
54731: ST_TO_ADDR
54732: LD_VAR 0 9
54736: PUSH
54737: FOR_TO
54738: IFFALSE 54839
// for _y = min_y to max_y do
54740: LD_ADDR_VAR 0 6
54744: PUSH
54745: DOUBLE
54746: LD_VAR 0 7
54750: DEC
54751: ST_TO_ADDR
54752: LD_VAR 0 10
54756: PUSH
54757: FOR_TO
54758: IFFALSE 54835
// begin if not ValidHex ( _x , _y ) then
54760: LD_VAR 0 5
54764: PPUSH
54765: LD_VAR 0 6
54769: PPUSH
54770: CALL_OW 488
54774: NOT
54775: IFFALSE 54779
// continue ;
54777: GO 54757
// if GetResourceTypeXY ( _x , _y ) then
54779: LD_VAR 0 5
54783: PPUSH
54784: LD_VAR 0 6
54788: PPUSH
54789: CALL_OW 283
54793: IFFALSE 54833
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54795: LD_ADDR_VAR 0 4
54799: PUSH
54800: LD_VAR 0 4
54804: PPUSH
54805: LD_VAR 0 4
54809: PUSH
54810: LD_INT 1
54812: PLUS
54813: PPUSH
54814: LD_VAR 0 5
54818: PUSH
54819: LD_VAR 0 6
54823: PUSH
54824: EMPTY
54825: LIST
54826: LIST
54827: PPUSH
54828: CALL_OW 1
54832: ST_TO_ADDR
// end ;
54833: GO 54757
54835: POP
54836: POP
54837: GO 54737
54839: POP
54840: POP
// end ;
54841: LD_VAR 0 4
54845: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54846: LD_INT 0
54848: PPUSH
54849: PPUSH
54850: PPUSH
54851: PPUSH
54852: PPUSH
54853: PPUSH
54854: PPUSH
54855: PPUSH
// if not units then
54856: LD_VAR 0 1
54860: NOT
54861: IFFALSE 54865
// exit ;
54863: GO 55389
// result := UnitFilter ( units , [ f_ok ] ) ;
54865: LD_ADDR_VAR 0 3
54869: PUSH
54870: LD_VAR 0 1
54874: PPUSH
54875: LD_INT 50
54877: PUSH
54878: EMPTY
54879: LIST
54880: PPUSH
54881: CALL_OW 72
54885: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54886: LD_ADDR_VAR 0 8
54890: PUSH
54891: LD_VAR 0 1
54895: PUSH
54896: LD_INT 1
54898: ARRAY
54899: PPUSH
54900: CALL_OW 255
54904: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
54905: LD_ADDR_VAR 0 10
54909: PUSH
54910: LD_INT 29
54912: PUSH
54913: LD_INT 91
54915: PUSH
54916: LD_INT 49
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: ST_TO_ADDR
// if not result then
54924: LD_VAR 0 3
54928: NOT
54929: IFFALSE 54933
// exit ;
54931: GO 55389
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54933: LD_ADDR_VAR 0 5
54937: PUSH
54938: LD_INT 81
54940: PUSH
54941: LD_VAR 0 8
54945: PUSH
54946: EMPTY
54947: LIST
54948: LIST
54949: PPUSH
54950: CALL_OW 69
54954: ST_TO_ADDR
// for i in result do
54955: LD_ADDR_VAR 0 4
54959: PUSH
54960: LD_VAR 0 3
54964: PUSH
54965: FOR_IN
54966: IFFALSE 55387
// begin tag := GetTag ( i ) + 1 ;
54968: LD_ADDR_VAR 0 9
54972: PUSH
54973: LD_VAR 0 4
54977: PPUSH
54978: CALL_OW 110
54982: PUSH
54983: LD_INT 1
54985: PLUS
54986: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54987: LD_ADDR_VAR 0 7
54991: PUSH
54992: LD_VAR 0 4
54996: PPUSH
54997: CALL_OW 250
55001: PPUSH
55002: LD_VAR 0 4
55006: PPUSH
55007: CALL_OW 251
55011: PPUSH
55012: LD_INT 6
55014: PPUSH
55015: CALL 54588 0 3
55019: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55020: LD_VAR 0 4
55024: PPUSH
55025: CALL_OW 247
55029: PUSH
55030: LD_INT 2
55032: EQUAL
55033: PUSH
55034: LD_VAR 0 7
55038: AND
55039: PUSH
55040: LD_VAR 0 4
55044: PPUSH
55045: CALL_OW 264
55049: PUSH
55050: LD_VAR 0 10
55054: IN
55055: NOT
55056: AND
55057: IFFALSE 55096
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55059: LD_VAR 0 4
55063: PPUSH
55064: LD_VAR 0 7
55068: PUSH
55069: LD_INT 1
55071: ARRAY
55072: PUSH
55073: LD_INT 1
55075: ARRAY
55076: PPUSH
55077: LD_VAR 0 7
55081: PUSH
55082: LD_INT 1
55084: ARRAY
55085: PUSH
55086: LD_INT 2
55088: ARRAY
55089: PPUSH
55090: CALL_OW 116
55094: GO 55385
// if path > tag then
55096: LD_VAR 0 2
55100: PUSH
55101: LD_VAR 0 9
55105: GREATER
55106: IFFALSE 55314
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55108: LD_ADDR_VAR 0 6
55112: PUSH
55113: LD_VAR 0 5
55117: PPUSH
55118: LD_INT 91
55120: PUSH
55121: LD_VAR 0 4
55125: PUSH
55126: LD_INT 8
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: LIST
55133: PPUSH
55134: CALL_OW 72
55138: ST_TO_ADDR
// if nearEnemy then
55139: LD_VAR 0 6
55143: IFFALSE 55212
// begin if GetWeapon ( i ) = ru_time_lapser then
55145: LD_VAR 0 4
55149: PPUSH
55150: CALL_OW 264
55154: PUSH
55155: LD_INT 49
55157: EQUAL
55158: IFFALSE 55186
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55160: LD_VAR 0 4
55164: PPUSH
55165: LD_VAR 0 6
55169: PPUSH
55170: LD_VAR 0 4
55174: PPUSH
55175: CALL_OW 74
55179: PPUSH
55180: CALL_OW 112
55184: GO 55210
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55186: LD_VAR 0 4
55190: PPUSH
55191: LD_VAR 0 6
55195: PPUSH
55196: LD_VAR 0 4
55200: PPUSH
55201: CALL_OW 74
55205: PPUSH
55206: CALL_OW 115
// end else
55210: GO 55312
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55212: LD_VAR 0 4
55216: PPUSH
55217: LD_VAR 0 2
55221: PUSH
55222: LD_VAR 0 9
55226: ARRAY
55227: PUSH
55228: LD_INT 1
55230: ARRAY
55231: PPUSH
55232: LD_VAR 0 2
55236: PUSH
55237: LD_VAR 0 9
55241: ARRAY
55242: PUSH
55243: LD_INT 2
55245: ARRAY
55246: PPUSH
55247: CALL_OW 297
55251: PUSH
55252: LD_INT 6
55254: GREATER
55255: IFFALSE 55298
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55257: LD_VAR 0 4
55261: PPUSH
55262: LD_VAR 0 2
55266: PUSH
55267: LD_VAR 0 9
55271: ARRAY
55272: PUSH
55273: LD_INT 1
55275: ARRAY
55276: PPUSH
55277: LD_VAR 0 2
55281: PUSH
55282: LD_VAR 0 9
55286: ARRAY
55287: PUSH
55288: LD_INT 2
55290: ARRAY
55291: PPUSH
55292: CALL_OW 114
55296: GO 55312
// SetTag ( i , tag ) ;
55298: LD_VAR 0 4
55302: PPUSH
55303: LD_VAR 0 9
55307: PPUSH
55308: CALL_OW 109
// end else
55312: GO 55385
// if enemy then
55314: LD_VAR 0 5
55318: IFFALSE 55385
// begin if GetWeapon ( i ) = ru_time_lapser then
55320: LD_VAR 0 4
55324: PPUSH
55325: CALL_OW 264
55329: PUSH
55330: LD_INT 49
55332: EQUAL
55333: IFFALSE 55361
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55335: LD_VAR 0 4
55339: PPUSH
55340: LD_VAR 0 5
55344: PPUSH
55345: LD_VAR 0 4
55349: PPUSH
55350: CALL_OW 74
55354: PPUSH
55355: CALL_OW 112
55359: GO 55385
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55361: LD_VAR 0 4
55365: PPUSH
55366: LD_VAR 0 5
55370: PPUSH
55371: LD_VAR 0 4
55375: PPUSH
55376: CALL_OW 74
55380: PPUSH
55381: CALL_OW 115
// end ; end ;
55385: GO 54965
55387: POP
55388: POP
// end ;
55389: LD_VAR 0 3
55393: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55394: LD_INT 0
55396: PPUSH
55397: PPUSH
55398: PPUSH
// if not unit or IsInUnit ( unit ) then
55399: LD_VAR 0 1
55403: NOT
55404: PUSH
55405: LD_VAR 0 1
55409: PPUSH
55410: CALL_OW 310
55414: OR
55415: IFFALSE 55419
// exit ;
55417: GO 55510
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55419: LD_ADDR_VAR 0 4
55423: PUSH
55424: LD_VAR 0 1
55428: PPUSH
55429: CALL_OW 250
55433: PPUSH
55434: LD_VAR 0 2
55438: PPUSH
55439: LD_INT 1
55441: PPUSH
55442: CALL_OW 272
55446: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55447: LD_ADDR_VAR 0 5
55451: PUSH
55452: LD_VAR 0 1
55456: PPUSH
55457: CALL_OW 251
55461: PPUSH
55462: LD_VAR 0 2
55466: PPUSH
55467: LD_INT 1
55469: PPUSH
55470: CALL_OW 273
55474: ST_TO_ADDR
// if ValidHex ( x , y ) then
55475: LD_VAR 0 4
55479: PPUSH
55480: LD_VAR 0 5
55484: PPUSH
55485: CALL_OW 488
55489: IFFALSE 55510
// ComTurnXY ( unit , x , y ) ;
55491: LD_VAR 0 1
55495: PPUSH
55496: LD_VAR 0 4
55500: PPUSH
55501: LD_VAR 0 5
55505: PPUSH
55506: CALL_OW 118
// end ;
55510: LD_VAR 0 3
55514: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55515: LD_INT 0
55517: PPUSH
55518: PPUSH
// result := false ;
55519: LD_ADDR_VAR 0 3
55523: PUSH
55524: LD_INT 0
55526: ST_TO_ADDR
// if not units then
55527: LD_VAR 0 2
55531: NOT
55532: IFFALSE 55536
// exit ;
55534: GO 55581
// for i in units do
55536: LD_ADDR_VAR 0 4
55540: PUSH
55541: LD_VAR 0 2
55545: PUSH
55546: FOR_IN
55547: IFFALSE 55579
// if See ( side , i ) then
55549: LD_VAR 0 1
55553: PPUSH
55554: LD_VAR 0 4
55558: PPUSH
55559: CALL_OW 292
55563: IFFALSE 55577
// begin result := true ;
55565: LD_ADDR_VAR 0 3
55569: PUSH
55570: LD_INT 1
55572: ST_TO_ADDR
// exit ;
55573: POP
55574: POP
55575: GO 55581
// end ;
55577: GO 55546
55579: POP
55580: POP
// end ;
55581: LD_VAR 0 3
55585: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55586: LD_INT 0
55588: PPUSH
55589: PPUSH
55590: PPUSH
55591: PPUSH
// if not unit or not points then
55592: LD_VAR 0 1
55596: NOT
55597: PUSH
55598: LD_VAR 0 2
55602: NOT
55603: OR
55604: IFFALSE 55608
// exit ;
55606: GO 55698
// dist := 99999 ;
55608: LD_ADDR_VAR 0 5
55612: PUSH
55613: LD_INT 99999
55615: ST_TO_ADDR
// for i in points do
55616: LD_ADDR_VAR 0 4
55620: PUSH
55621: LD_VAR 0 2
55625: PUSH
55626: FOR_IN
55627: IFFALSE 55696
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55629: LD_ADDR_VAR 0 6
55633: PUSH
55634: LD_VAR 0 1
55638: PPUSH
55639: LD_VAR 0 4
55643: PUSH
55644: LD_INT 1
55646: ARRAY
55647: PPUSH
55648: LD_VAR 0 4
55652: PUSH
55653: LD_INT 2
55655: ARRAY
55656: PPUSH
55657: CALL_OW 297
55661: ST_TO_ADDR
// if tmpDist < dist then
55662: LD_VAR 0 6
55666: PUSH
55667: LD_VAR 0 5
55671: LESS
55672: IFFALSE 55694
// begin result := i ;
55674: LD_ADDR_VAR 0 3
55678: PUSH
55679: LD_VAR 0 4
55683: ST_TO_ADDR
// dist := tmpDist ;
55684: LD_ADDR_VAR 0 5
55688: PUSH
55689: LD_VAR 0 6
55693: ST_TO_ADDR
// end ; end ;
55694: GO 55626
55696: POP
55697: POP
// end ;
55698: LD_VAR 0 3
55702: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55703: LD_INT 0
55705: PPUSH
// uc_side := side ;
55706: LD_ADDR_OWVAR 20
55710: PUSH
55711: LD_VAR 0 1
55715: ST_TO_ADDR
// uc_nation := 3 ;
55716: LD_ADDR_OWVAR 21
55720: PUSH
55721: LD_INT 3
55723: ST_TO_ADDR
// vc_chassis := 25 ;
55724: LD_ADDR_OWVAR 37
55728: PUSH
55729: LD_INT 25
55731: ST_TO_ADDR
// vc_engine := engine_siberite ;
55732: LD_ADDR_OWVAR 39
55736: PUSH
55737: LD_INT 3
55739: ST_TO_ADDR
// vc_control := control_computer ;
55740: LD_ADDR_OWVAR 38
55744: PUSH
55745: LD_INT 3
55747: ST_TO_ADDR
// vc_weapon := 59 ;
55748: LD_ADDR_OWVAR 40
55752: PUSH
55753: LD_INT 59
55755: ST_TO_ADDR
// result := CreateVehicle ;
55756: LD_ADDR_VAR 0 5
55760: PUSH
55761: CALL_OW 45
55765: ST_TO_ADDR
// SetDir ( result , d ) ;
55766: LD_VAR 0 5
55770: PPUSH
55771: LD_VAR 0 4
55775: PPUSH
55776: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55780: LD_VAR 0 5
55784: PPUSH
55785: LD_VAR 0 2
55789: PPUSH
55790: LD_VAR 0 3
55794: PPUSH
55795: LD_INT 0
55797: PPUSH
55798: CALL_OW 48
// end ;
55802: LD_VAR 0 5
55806: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55807: LD_INT 0
55809: PPUSH
55810: PPUSH
55811: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55812: LD_ADDR_VAR 0 2
55816: PUSH
55817: LD_INT 0
55819: PUSH
55820: LD_INT 0
55822: PUSH
55823: LD_INT 0
55825: PUSH
55826: LD_INT 0
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: LIST
55833: LIST
55834: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55835: LD_VAR 0 1
55839: NOT
55840: PUSH
55841: LD_VAR 0 1
55845: PPUSH
55846: CALL_OW 264
55850: PUSH
55851: LD_INT 12
55853: PUSH
55854: LD_INT 51
55856: PUSH
55857: LD_INT 32
55859: PUSH
55860: LD_INT 89
55862: PUSH
55863: EMPTY
55864: LIST
55865: LIST
55866: LIST
55867: LIST
55868: IN
55869: NOT
55870: OR
55871: IFFALSE 55875
// exit ;
55873: GO 55973
// for i := 1 to 3 do
55875: LD_ADDR_VAR 0 3
55879: PUSH
55880: DOUBLE
55881: LD_INT 1
55883: DEC
55884: ST_TO_ADDR
55885: LD_INT 3
55887: PUSH
55888: FOR_TO
55889: IFFALSE 55971
// begin tmp := GetCargo ( cargo , i ) ;
55891: LD_ADDR_VAR 0 4
55895: PUSH
55896: LD_VAR 0 1
55900: PPUSH
55901: LD_VAR 0 3
55905: PPUSH
55906: CALL_OW 289
55910: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
55911: LD_ADDR_VAR 0 2
55915: PUSH
55916: LD_VAR 0 2
55920: PPUSH
55921: LD_VAR 0 3
55925: PPUSH
55926: LD_VAR 0 4
55930: PPUSH
55931: CALL_OW 1
55935: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
55936: LD_ADDR_VAR 0 2
55940: PUSH
55941: LD_VAR 0 2
55945: PPUSH
55946: LD_INT 4
55948: PPUSH
55949: LD_VAR 0 2
55953: PUSH
55954: LD_INT 4
55956: ARRAY
55957: PUSH
55958: LD_VAR 0 4
55962: PLUS
55963: PPUSH
55964: CALL_OW 1
55968: ST_TO_ADDR
// end ;
55969: GO 55888
55971: POP
55972: POP
// end ;
55973: LD_VAR 0 2
55977: RET
// export function Length ( array ) ; begin
55978: LD_INT 0
55980: PPUSH
// result := array + 0 ;
55981: LD_ADDR_VAR 0 2
55985: PUSH
55986: LD_VAR 0 1
55990: PUSH
55991: LD_INT 0
55993: PLUS
55994: ST_TO_ADDR
// end ;
55995: LD_VAR 0 2
55999: RET
// export function PrepareArray ( array ) ; begin
56000: LD_INT 0
56002: PPUSH
// result := array diff 0 ;
56003: LD_ADDR_VAR 0 2
56007: PUSH
56008: LD_VAR 0 1
56012: PUSH
56013: LD_INT 0
56015: DIFF
56016: ST_TO_ADDR
// if not result [ 1 ] then
56017: LD_VAR 0 2
56021: PUSH
56022: LD_INT 1
56024: ARRAY
56025: NOT
56026: IFFALSE 56046
// result := Delete ( result , 1 ) ;
56028: LD_ADDR_VAR 0 2
56032: PUSH
56033: LD_VAR 0 2
56037: PPUSH
56038: LD_INT 1
56040: PPUSH
56041: CALL_OW 3
56045: ST_TO_ADDR
// end ;
56046: LD_VAR 0 2
56050: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56051: LD_INT 0
56053: PPUSH
56054: PPUSH
56055: PPUSH
56056: PPUSH
// sibRocketRange := 25 ;
56057: LD_ADDR_VAR 0 6
56061: PUSH
56062: LD_INT 25
56064: ST_TO_ADDR
// result := false ;
56065: LD_ADDR_VAR 0 4
56069: PUSH
56070: LD_INT 0
56072: ST_TO_ADDR
// for i := 0 to 5 do
56073: LD_ADDR_VAR 0 5
56077: PUSH
56078: DOUBLE
56079: LD_INT 0
56081: DEC
56082: ST_TO_ADDR
56083: LD_INT 5
56085: PUSH
56086: FOR_TO
56087: IFFALSE 56154
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56089: LD_VAR 0 1
56093: PPUSH
56094: LD_VAR 0 5
56098: PPUSH
56099: LD_VAR 0 6
56103: PPUSH
56104: CALL_OW 272
56108: PPUSH
56109: LD_VAR 0 2
56113: PPUSH
56114: LD_VAR 0 5
56118: PPUSH
56119: LD_VAR 0 6
56123: PPUSH
56124: CALL_OW 273
56128: PPUSH
56129: LD_VAR 0 3
56133: PPUSH
56134: CALL_OW 309
56138: IFFALSE 56152
// begin result := true ;
56140: LD_ADDR_VAR 0 4
56144: PUSH
56145: LD_INT 1
56147: ST_TO_ADDR
// exit ;
56148: POP
56149: POP
56150: GO 56156
// end ;
56152: GO 56086
56154: POP
56155: POP
// end ;
56156: LD_VAR 0 4
56160: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56161: LD_INT 0
56163: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56164: LD_VAR 0 1
56168: PPUSH
56169: LD_VAR 0 2
56173: PPUSH
56174: LD_INT 0
56176: PPUSH
56177: LD_INT 0
56179: PPUSH
56180: LD_INT 1
56182: PPUSH
56183: LD_INT 0
56185: PPUSH
56186: CALL_OW 587
// end ;
56190: LD_VAR 0 3
56194: RET
// export function CenterOnNow ( unit ) ; begin
56195: LD_INT 0
56197: PPUSH
// result := IsInUnit ( unit ) ;
56198: LD_ADDR_VAR 0 2
56202: PUSH
56203: LD_VAR 0 1
56207: PPUSH
56208: CALL_OW 310
56212: ST_TO_ADDR
// if not result then
56213: LD_VAR 0 2
56217: NOT
56218: IFFALSE 56230
// result := unit ;
56220: LD_ADDR_VAR 0 2
56224: PUSH
56225: LD_VAR 0 1
56229: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
56230: LD_VAR 0 1
56234: PPUSH
56235: CALL_OW 87
// end ;
56239: LD_VAR 0 2
56243: RET
// export function ComMoveHex ( unit , hex ) ; begin
56244: LD_INT 0
56246: PPUSH
// if not hex then
56247: LD_VAR 0 2
56251: NOT
56252: IFFALSE 56256
// exit ;
56254: GO 56309
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
56256: LD_VAR 0 2
56260: PUSH
56261: LD_INT 1
56263: ARRAY
56264: PPUSH
56265: LD_VAR 0 2
56269: PUSH
56270: LD_INT 2
56272: ARRAY
56273: PPUSH
56274: CALL_OW 428
56278: IFFALSE 56282
// exit ;
56280: GO 56309
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
56282: LD_VAR 0 1
56286: PPUSH
56287: LD_VAR 0 2
56291: PUSH
56292: LD_INT 1
56294: ARRAY
56295: PPUSH
56296: LD_VAR 0 2
56300: PUSH
56301: LD_INT 2
56303: ARRAY
56304: PPUSH
56305: CALL_OW 111
// end ; end_of_file
56309: LD_VAR 0 3
56313: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
56314: LD_INT 0
56316: PPUSH
56317: PPUSH
// skirmish := false ;
56318: LD_ADDR_EXP 59
56322: PUSH
56323: LD_INT 0
56325: ST_TO_ADDR
// debug_mc := false ;
56326: LD_ADDR_EXP 60
56330: PUSH
56331: LD_INT 0
56333: ST_TO_ADDR
// mc_bases := [ ] ;
56334: LD_ADDR_EXP 61
56338: PUSH
56339: EMPTY
56340: ST_TO_ADDR
// mc_sides := [ ] ;
56341: LD_ADDR_EXP 87
56345: PUSH
56346: EMPTY
56347: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56348: LD_ADDR_EXP 62
56352: PUSH
56353: EMPTY
56354: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56355: LD_ADDR_EXP 63
56359: PUSH
56360: EMPTY
56361: ST_TO_ADDR
// mc_need_heal := [ ] ;
56362: LD_ADDR_EXP 64
56366: PUSH
56367: EMPTY
56368: ST_TO_ADDR
// mc_healers := [ ] ;
56369: LD_ADDR_EXP 65
56373: PUSH
56374: EMPTY
56375: ST_TO_ADDR
// mc_build_list := [ ] ;
56376: LD_ADDR_EXP 66
56380: PUSH
56381: EMPTY
56382: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56383: LD_ADDR_EXP 93
56387: PUSH
56388: EMPTY
56389: ST_TO_ADDR
// mc_builders := [ ] ;
56390: LD_ADDR_EXP 67
56394: PUSH
56395: EMPTY
56396: ST_TO_ADDR
// mc_construct_list := [ ] ;
56397: LD_ADDR_EXP 68
56401: PUSH
56402: EMPTY
56403: ST_TO_ADDR
// mc_turret_list := [ ] ;
56404: LD_ADDR_EXP 69
56408: PUSH
56409: EMPTY
56410: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56411: LD_ADDR_EXP 70
56415: PUSH
56416: EMPTY
56417: ST_TO_ADDR
// mc_miners := [ ] ;
56418: LD_ADDR_EXP 75
56422: PUSH
56423: EMPTY
56424: ST_TO_ADDR
// mc_mines := [ ] ;
56425: LD_ADDR_EXP 74
56429: PUSH
56430: EMPTY
56431: ST_TO_ADDR
// mc_minefields := [ ] ;
56432: LD_ADDR_EXP 76
56436: PUSH
56437: EMPTY
56438: ST_TO_ADDR
// mc_crates := [ ] ;
56439: LD_ADDR_EXP 77
56443: PUSH
56444: EMPTY
56445: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56446: LD_ADDR_EXP 78
56450: PUSH
56451: EMPTY
56452: ST_TO_ADDR
// mc_crates_area := [ ] ;
56453: LD_ADDR_EXP 79
56457: PUSH
56458: EMPTY
56459: ST_TO_ADDR
// mc_vehicles := [ ] ;
56460: LD_ADDR_EXP 80
56464: PUSH
56465: EMPTY
56466: ST_TO_ADDR
// mc_attack := [ ] ;
56467: LD_ADDR_EXP 81
56471: PUSH
56472: EMPTY
56473: ST_TO_ADDR
// mc_produce := [ ] ;
56474: LD_ADDR_EXP 82
56478: PUSH
56479: EMPTY
56480: ST_TO_ADDR
// mc_defender := [ ] ;
56481: LD_ADDR_EXP 83
56485: PUSH
56486: EMPTY
56487: ST_TO_ADDR
// mc_parking := [ ] ;
56488: LD_ADDR_EXP 85
56492: PUSH
56493: EMPTY
56494: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56495: LD_ADDR_EXP 71
56499: PUSH
56500: EMPTY
56501: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56502: LD_ADDR_EXP 73
56506: PUSH
56507: EMPTY
56508: ST_TO_ADDR
// mc_scan := [ ] ;
56509: LD_ADDR_EXP 84
56513: PUSH
56514: EMPTY
56515: ST_TO_ADDR
// mc_scan_area := [ ] ;
56516: LD_ADDR_EXP 86
56520: PUSH
56521: EMPTY
56522: ST_TO_ADDR
// mc_tech := [ ] ;
56523: LD_ADDR_EXP 88
56527: PUSH
56528: EMPTY
56529: ST_TO_ADDR
// mc_class := [ ] ;
56530: LD_ADDR_EXP 102
56534: PUSH
56535: EMPTY
56536: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56537: LD_ADDR_EXP 103
56541: PUSH
56542: EMPTY
56543: ST_TO_ADDR
// mc_is_defending := [ ] ;
56544: LD_ADDR_EXP 104
56548: PUSH
56549: EMPTY
56550: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
56551: LD_ADDR_EXP 95
56555: PUSH
56556: EMPTY
56557: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
56558: LD_ADDR_EXP 105
56562: PUSH
56563: LD_INT 0
56565: ST_TO_ADDR
// end ;
56566: LD_VAR 0 1
56570: RET
// export function MC_Kill ( base ) ; begin
56571: LD_INT 0
56573: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56574: LD_ADDR_EXP 61
56578: PUSH
56579: LD_EXP 61
56583: PPUSH
56584: LD_VAR 0 1
56588: PPUSH
56589: EMPTY
56590: PPUSH
56591: CALL_OW 1
56595: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56596: LD_ADDR_EXP 62
56600: PUSH
56601: LD_EXP 62
56605: PPUSH
56606: LD_VAR 0 1
56610: PPUSH
56611: EMPTY
56612: PPUSH
56613: CALL_OW 1
56617: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56618: LD_ADDR_EXP 63
56622: PUSH
56623: LD_EXP 63
56627: PPUSH
56628: LD_VAR 0 1
56632: PPUSH
56633: EMPTY
56634: PPUSH
56635: CALL_OW 1
56639: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56640: LD_ADDR_EXP 64
56644: PUSH
56645: LD_EXP 64
56649: PPUSH
56650: LD_VAR 0 1
56654: PPUSH
56655: EMPTY
56656: PPUSH
56657: CALL_OW 1
56661: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56662: LD_ADDR_EXP 65
56666: PUSH
56667: LD_EXP 65
56671: PPUSH
56672: LD_VAR 0 1
56676: PPUSH
56677: EMPTY
56678: PPUSH
56679: CALL_OW 1
56683: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56684: LD_ADDR_EXP 66
56688: PUSH
56689: LD_EXP 66
56693: PPUSH
56694: LD_VAR 0 1
56698: PPUSH
56699: EMPTY
56700: PPUSH
56701: CALL_OW 1
56705: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56706: LD_ADDR_EXP 67
56710: PUSH
56711: LD_EXP 67
56715: PPUSH
56716: LD_VAR 0 1
56720: PPUSH
56721: EMPTY
56722: PPUSH
56723: CALL_OW 1
56727: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56728: LD_ADDR_EXP 68
56732: PUSH
56733: LD_EXP 68
56737: PPUSH
56738: LD_VAR 0 1
56742: PPUSH
56743: EMPTY
56744: PPUSH
56745: CALL_OW 1
56749: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56750: LD_ADDR_EXP 69
56754: PUSH
56755: LD_EXP 69
56759: PPUSH
56760: LD_VAR 0 1
56764: PPUSH
56765: EMPTY
56766: PPUSH
56767: CALL_OW 1
56771: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56772: LD_ADDR_EXP 70
56776: PUSH
56777: LD_EXP 70
56781: PPUSH
56782: LD_VAR 0 1
56786: PPUSH
56787: EMPTY
56788: PPUSH
56789: CALL_OW 1
56793: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56794: LD_ADDR_EXP 71
56798: PUSH
56799: LD_EXP 71
56803: PPUSH
56804: LD_VAR 0 1
56808: PPUSH
56809: EMPTY
56810: PPUSH
56811: CALL_OW 1
56815: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56816: LD_ADDR_EXP 72
56820: PUSH
56821: LD_EXP 72
56825: PPUSH
56826: LD_VAR 0 1
56830: PPUSH
56831: LD_INT 0
56833: PPUSH
56834: CALL_OW 1
56838: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56839: LD_ADDR_EXP 73
56843: PUSH
56844: LD_EXP 73
56848: PPUSH
56849: LD_VAR 0 1
56853: PPUSH
56854: EMPTY
56855: PPUSH
56856: CALL_OW 1
56860: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56861: LD_ADDR_EXP 74
56865: PUSH
56866: LD_EXP 74
56870: PPUSH
56871: LD_VAR 0 1
56875: PPUSH
56876: EMPTY
56877: PPUSH
56878: CALL_OW 1
56882: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56883: LD_ADDR_EXP 75
56887: PUSH
56888: LD_EXP 75
56892: PPUSH
56893: LD_VAR 0 1
56897: PPUSH
56898: EMPTY
56899: PPUSH
56900: CALL_OW 1
56904: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56905: LD_ADDR_EXP 76
56909: PUSH
56910: LD_EXP 76
56914: PPUSH
56915: LD_VAR 0 1
56919: PPUSH
56920: EMPTY
56921: PPUSH
56922: CALL_OW 1
56926: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56927: LD_ADDR_EXP 77
56931: PUSH
56932: LD_EXP 77
56936: PPUSH
56937: LD_VAR 0 1
56941: PPUSH
56942: EMPTY
56943: PPUSH
56944: CALL_OW 1
56948: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56949: LD_ADDR_EXP 78
56953: PUSH
56954: LD_EXP 78
56958: PPUSH
56959: LD_VAR 0 1
56963: PPUSH
56964: EMPTY
56965: PPUSH
56966: CALL_OW 1
56970: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56971: LD_ADDR_EXP 79
56975: PUSH
56976: LD_EXP 79
56980: PPUSH
56981: LD_VAR 0 1
56985: PPUSH
56986: EMPTY
56987: PPUSH
56988: CALL_OW 1
56992: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56993: LD_ADDR_EXP 80
56997: PUSH
56998: LD_EXP 80
57002: PPUSH
57003: LD_VAR 0 1
57007: PPUSH
57008: EMPTY
57009: PPUSH
57010: CALL_OW 1
57014: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57015: LD_ADDR_EXP 81
57019: PUSH
57020: LD_EXP 81
57024: PPUSH
57025: LD_VAR 0 1
57029: PPUSH
57030: EMPTY
57031: PPUSH
57032: CALL_OW 1
57036: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57037: LD_ADDR_EXP 82
57041: PUSH
57042: LD_EXP 82
57046: PPUSH
57047: LD_VAR 0 1
57051: PPUSH
57052: EMPTY
57053: PPUSH
57054: CALL_OW 1
57058: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57059: LD_ADDR_EXP 83
57063: PUSH
57064: LD_EXP 83
57068: PPUSH
57069: LD_VAR 0 1
57073: PPUSH
57074: EMPTY
57075: PPUSH
57076: CALL_OW 1
57080: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57081: LD_ADDR_EXP 84
57085: PUSH
57086: LD_EXP 84
57090: PPUSH
57091: LD_VAR 0 1
57095: PPUSH
57096: EMPTY
57097: PPUSH
57098: CALL_OW 1
57102: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57103: LD_ADDR_EXP 85
57107: PUSH
57108: LD_EXP 85
57112: PPUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: EMPTY
57119: PPUSH
57120: CALL_OW 1
57124: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57125: LD_ADDR_EXP 86
57129: PUSH
57130: LD_EXP 86
57134: PPUSH
57135: LD_VAR 0 1
57139: PPUSH
57140: EMPTY
57141: PPUSH
57142: CALL_OW 1
57146: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57147: LD_ADDR_EXP 88
57151: PUSH
57152: LD_EXP 88
57156: PPUSH
57157: LD_VAR 0 1
57161: PPUSH
57162: EMPTY
57163: PPUSH
57164: CALL_OW 1
57168: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57169: LD_ADDR_EXP 90
57173: PUSH
57174: LD_EXP 90
57178: PPUSH
57179: LD_VAR 0 1
57183: PPUSH
57184: EMPTY
57185: PPUSH
57186: CALL_OW 1
57190: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57191: LD_ADDR_EXP 91
57195: PUSH
57196: LD_EXP 91
57200: PPUSH
57201: LD_VAR 0 1
57205: PPUSH
57206: EMPTY
57207: PPUSH
57208: CALL_OW 1
57212: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57213: LD_ADDR_EXP 92
57217: PUSH
57218: LD_EXP 92
57222: PPUSH
57223: LD_VAR 0 1
57227: PPUSH
57228: EMPTY
57229: PPUSH
57230: CALL_OW 1
57234: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57235: LD_ADDR_EXP 93
57239: PUSH
57240: LD_EXP 93
57244: PPUSH
57245: LD_VAR 0 1
57249: PPUSH
57250: EMPTY
57251: PPUSH
57252: CALL_OW 1
57256: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57257: LD_ADDR_EXP 94
57261: PUSH
57262: LD_EXP 94
57266: PPUSH
57267: LD_VAR 0 1
57271: PPUSH
57272: EMPTY
57273: PPUSH
57274: CALL_OW 1
57278: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57279: LD_ADDR_EXP 95
57283: PUSH
57284: LD_EXP 95
57288: PPUSH
57289: LD_VAR 0 1
57293: PPUSH
57294: EMPTY
57295: PPUSH
57296: CALL_OW 1
57300: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57301: LD_ADDR_EXP 96
57305: PUSH
57306: LD_EXP 96
57310: PPUSH
57311: LD_VAR 0 1
57315: PPUSH
57316: EMPTY
57317: PPUSH
57318: CALL_OW 1
57322: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57323: LD_ADDR_EXP 97
57327: PUSH
57328: LD_EXP 97
57332: PPUSH
57333: LD_VAR 0 1
57337: PPUSH
57338: EMPTY
57339: PPUSH
57340: CALL_OW 1
57344: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57345: LD_ADDR_EXP 98
57349: PUSH
57350: LD_EXP 98
57354: PPUSH
57355: LD_VAR 0 1
57359: PPUSH
57360: EMPTY
57361: PPUSH
57362: CALL_OW 1
57366: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57367: LD_ADDR_EXP 99
57371: PUSH
57372: LD_EXP 99
57376: PPUSH
57377: LD_VAR 0 1
57381: PPUSH
57382: EMPTY
57383: PPUSH
57384: CALL_OW 1
57388: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57389: LD_ADDR_EXP 100
57393: PUSH
57394: LD_EXP 100
57398: PPUSH
57399: LD_VAR 0 1
57403: PPUSH
57404: EMPTY
57405: PPUSH
57406: CALL_OW 1
57410: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57411: LD_ADDR_EXP 101
57415: PUSH
57416: LD_EXP 101
57420: PPUSH
57421: LD_VAR 0 1
57425: PPUSH
57426: EMPTY
57427: PPUSH
57428: CALL_OW 1
57432: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57433: LD_ADDR_EXP 102
57437: PUSH
57438: LD_EXP 102
57442: PPUSH
57443: LD_VAR 0 1
57447: PPUSH
57448: EMPTY
57449: PPUSH
57450: CALL_OW 1
57454: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57455: LD_ADDR_EXP 103
57459: PUSH
57460: LD_EXP 103
57464: PPUSH
57465: LD_VAR 0 1
57469: PPUSH
57470: LD_INT 0
57472: PPUSH
57473: CALL_OW 1
57477: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57478: LD_ADDR_EXP 104
57482: PUSH
57483: LD_EXP 104
57487: PPUSH
57488: LD_VAR 0 1
57492: PPUSH
57493: LD_INT 0
57495: PPUSH
57496: CALL_OW 1
57500: ST_TO_ADDR
// end ;
57501: LD_VAR 0 2
57505: RET
// export function MC_Add ( side , units ) ; var base ; begin
57506: LD_INT 0
57508: PPUSH
57509: PPUSH
// base := mc_bases + 1 ;
57510: LD_ADDR_VAR 0 4
57514: PUSH
57515: LD_EXP 61
57519: PUSH
57520: LD_INT 1
57522: PLUS
57523: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57524: LD_ADDR_EXP 87
57528: PUSH
57529: LD_EXP 87
57533: PPUSH
57534: LD_VAR 0 4
57538: PPUSH
57539: LD_VAR 0 1
57543: PPUSH
57544: CALL_OW 1
57548: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57549: LD_ADDR_EXP 61
57553: PUSH
57554: LD_EXP 61
57558: PPUSH
57559: LD_VAR 0 4
57563: PPUSH
57564: LD_VAR 0 2
57568: PPUSH
57569: CALL_OW 1
57573: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57574: LD_ADDR_EXP 62
57578: PUSH
57579: LD_EXP 62
57583: PPUSH
57584: LD_VAR 0 4
57588: PPUSH
57589: EMPTY
57590: PPUSH
57591: CALL_OW 1
57595: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57596: LD_ADDR_EXP 63
57600: PUSH
57601: LD_EXP 63
57605: PPUSH
57606: LD_VAR 0 4
57610: PPUSH
57611: EMPTY
57612: PPUSH
57613: CALL_OW 1
57617: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57618: LD_ADDR_EXP 64
57622: PUSH
57623: LD_EXP 64
57627: PPUSH
57628: LD_VAR 0 4
57632: PPUSH
57633: EMPTY
57634: PPUSH
57635: CALL_OW 1
57639: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57640: LD_ADDR_EXP 65
57644: PUSH
57645: LD_EXP 65
57649: PPUSH
57650: LD_VAR 0 4
57654: PPUSH
57655: EMPTY
57656: PPUSH
57657: CALL_OW 1
57661: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57662: LD_ADDR_EXP 66
57666: PUSH
57667: LD_EXP 66
57671: PPUSH
57672: LD_VAR 0 4
57676: PPUSH
57677: EMPTY
57678: PPUSH
57679: CALL_OW 1
57683: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57684: LD_ADDR_EXP 67
57688: PUSH
57689: LD_EXP 67
57693: PPUSH
57694: LD_VAR 0 4
57698: PPUSH
57699: EMPTY
57700: PPUSH
57701: CALL_OW 1
57705: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57706: LD_ADDR_EXP 68
57710: PUSH
57711: LD_EXP 68
57715: PPUSH
57716: LD_VAR 0 4
57720: PPUSH
57721: EMPTY
57722: PPUSH
57723: CALL_OW 1
57727: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57728: LD_ADDR_EXP 69
57732: PUSH
57733: LD_EXP 69
57737: PPUSH
57738: LD_VAR 0 4
57742: PPUSH
57743: EMPTY
57744: PPUSH
57745: CALL_OW 1
57749: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57750: LD_ADDR_EXP 70
57754: PUSH
57755: LD_EXP 70
57759: PPUSH
57760: LD_VAR 0 4
57764: PPUSH
57765: EMPTY
57766: PPUSH
57767: CALL_OW 1
57771: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57772: LD_ADDR_EXP 71
57776: PUSH
57777: LD_EXP 71
57781: PPUSH
57782: LD_VAR 0 4
57786: PPUSH
57787: EMPTY
57788: PPUSH
57789: CALL_OW 1
57793: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57794: LD_ADDR_EXP 72
57798: PUSH
57799: LD_EXP 72
57803: PPUSH
57804: LD_VAR 0 4
57808: PPUSH
57809: LD_INT 0
57811: PPUSH
57812: CALL_OW 1
57816: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57817: LD_ADDR_EXP 73
57821: PUSH
57822: LD_EXP 73
57826: PPUSH
57827: LD_VAR 0 4
57831: PPUSH
57832: EMPTY
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57839: LD_ADDR_EXP 74
57843: PUSH
57844: LD_EXP 74
57848: PPUSH
57849: LD_VAR 0 4
57853: PPUSH
57854: EMPTY
57855: PPUSH
57856: CALL_OW 1
57860: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57861: LD_ADDR_EXP 75
57865: PUSH
57866: LD_EXP 75
57870: PPUSH
57871: LD_VAR 0 4
57875: PPUSH
57876: EMPTY
57877: PPUSH
57878: CALL_OW 1
57882: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57883: LD_ADDR_EXP 76
57887: PUSH
57888: LD_EXP 76
57892: PPUSH
57893: LD_VAR 0 4
57897: PPUSH
57898: EMPTY
57899: PPUSH
57900: CALL_OW 1
57904: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57905: LD_ADDR_EXP 77
57909: PUSH
57910: LD_EXP 77
57914: PPUSH
57915: LD_VAR 0 4
57919: PPUSH
57920: EMPTY
57921: PPUSH
57922: CALL_OW 1
57926: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57927: LD_ADDR_EXP 78
57931: PUSH
57932: LD_EXP 78
57936: PPUSH
57937: LD_VAR 0 4
57941: PPUSH
57942: EMPTY
57943: PPUSH
57944: CALL_OW 1
57948: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57949: LD_ADDR_EXP 79
57953: PUSH
57954: LD_EXP 79
57958: PPUSH
57959: LD_VAR 0 4
57963: PPUSH
57964: EMPTY
57965: PPUSH
57966: CALL_OW 1
57970: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57971: LD_ADDR_EXP 80
57975: PUSH
57976: LD_EXP 80
57980: PPUSH
57981: LD_VAR 0 4
57985: PPUSH
57986: EMPTY
57987: PPUSH
57988: CALL_OW 1
57992: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57993: LD_ADDR_EXP 81
57997: PUSH
57998: LD_EXP 81
58002: PPUSH
58003: LD_VAR 0 4
58007: PPUSH
58008: EMPTY
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58015: LD_ADDR_EXP 82
58019: PUSH
58020: LD_EXP 82
58024: PPUSH
58025: LD_VAR 0 4
58029: PPUSH
58030: EMPTY
58031: PPUSH
58032: CALL_OW 1
58036: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58037: LD_ADDR_EXP 83
58041: PUSH
58042: LD_EXP 83
58046: PPUSH
58047: LD_VAR 0 4
58051: PPUSH
58052: EMPTY
58053: PPUSH
58054: CALL_OW 1
58058: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58059: LD_ADDR_EXP 84
58063: PUSH
58064: LD_EXP 84
58068: PPUSH
58069: LD_VAR 0 4
58073: PPUSH
58074: EMPTY
58075: PPUSH
58076: CALL_OW 1
58080: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58081: LD_ADDR_EXP 85
58085: PUSH
58086: LD_EXP 85
58090: PPUSH
58091: LD_VAR 0 4
58095: PPUSH
58096: EMPTY
58097: PPUSH
58098: CALL_OW 1
58102: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58103: LD_ADDR_EXP 86
58107: PUSH
58108: LD_EXP 86
58112: PPUSH
58113: LD_VAR 0 4
58117: PPUSH
58118: EMPTY
58119: PPUSH
58120: CALL_OW 1
58124: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58125: LD_ADDR_EXP 88
58129: PUSH
58130: LD_EXP 88
58134: PPUSH
58135: LD_VAR 0 4
58139: PPUSH
58140: EMPTY
58141: PPUSH
58142: CALL_OW 1
58146: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58147: LD_ADDR_EXP 90
58151: PUSH
58152: LD_EXP 90
58156: PPUSH
58157: LD_VAR 0 4
58161: PPUSH
58162: EMPTY
58163: PPUSH
58164: CALL_OW 1
58168: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58169: LD_ADDR_EXP 91
58173: PUSH
58174: LD_EXP 91
58178: PPUSH
58179: LD_VAR 0 4
58183: PPUSH
58184: EMPTY
58185: PPUSH
58186: CALL_OW 1
58190: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58191: LD_ADDR_EXP 92
58195: PUSH
58196: LD_EXP 92
58200: PPUSH
58201: LD_VAR 0 4
58205: PPUSH
58206: EMPTY
58207: PPUSH
58208: CALL_OW 1
58212: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58213: LD_ADDR_EXP 93
58217: PUSH
58218: LD_EXP 93
58222: PPUSH
58223: LD_VAR 0 4
58227: PPUSH
58228: EMPTY
58229: PPUSH
58230: CALL_OW 1
58234: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58235: LD_ADDR_EXP 94
58239: PUSH
58240: LD_EXP 94
58244: PPUSH
58245: LD_VAR 0 4
58249: PPUSH
58250: EMPTY
58251: PPUSH
58252: CALL_OW 1
58256: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58257: LD_ADDR_EXP 95
58261: PUSH
58262: LD_EXP 95
58266: PPUSH
58267: LD_VAR 0 4
58271: PPUSH
58272: EMPTY
58273: PPUSH
58274: CALL_OW 1
58278: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58279: LD_ADDR_EXP 96
58283: PUSH
58284: LD_EXP 96
58288: PPUSH
58289: LD_VAR 0 4
58293: PPUSH
58294: EMPTY
58295: PPUSH
58296: CALL_OW 1
58300: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58301: LD_ADDR_EXP 97
58305: PUSH
58306: LD_EXP 97
58310: PPUSH
58311: LD_VAR 0 4
58315: PPUSH
58316: EMPTY
58317: PPUSH
58318: CALL_OW 1
58322: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58323: LD_ADDR_EXP 98
58327: PUSH
58328: LD_EXP 98
58332: PPUSH
58333: LD_VAR 0 4
58337: PPUSH
58338: EMPTY
58339: PPUSH
58340: CALL_OW 1
58344: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58345: LD_ADDR_EXP 99
58349: PUSH
58350: LD_EXP 99
58354: PPUSH
58355: LD_VAR 0 4
58359: PPUSH
58360: EMPTY
58361: PPUSH
58362: CALL_OW 1
58366: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58367: LD_ADDR_EXP 100
58371: PUSH
58372: LD_EXP 100
58376: PPUSH
58377: LD_VAR 0 4
58381: PPUSH
58382: EMPTY
58383: PPUSH
58384: CALL_OW 1
58388: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58389: LD_ADDR_EXP 101
58393: PUSH
58394: LD_EXP 101
58398: PPUSH
58399: LD_VAR 0 4
58403: PPUSH
58404: EMPTY
58405: PPUSH
58406: CALL_OW 1
58410: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58411: LD_ADDR_EXP 102
58415: PUSH
58416: LD_EXP 102
58420: PPUSH
58421: LD_VAR 0 4
58425: PPUSH
58426: EMPTY
58427: PPUSH
58428: CALL_OW 1
58432: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58433: LD_ADDR_EXP 103
58437: PUSH
58438: LD_EXP 103
58442: PPUSH
58443: LD_VAR 0 4
58447: PPUSH
58448: LD_INT 0
58450: PPUSH
58451: CALL_OW 1
58455: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58456: LD_ADDR_EXP 104
58460: PUSH
58461: LD_EXP 104
58465: PPUSH
58466: LD_VAR 0 4
58470: PPUSH
58471: LD_INT 0
58473: PPUSH
58474: CALL_OW 1
58478: ST_TO_ADDR
// result := base ;
58479: LD_ADDR_VAR 0 3
58483: PUSH
58484: LD_VAR 0 4
58488: ST_TO_ADDR
// end ;
58489: LD_VAR 0 3
58493: RET
// export function MC_Start ( ) ; var i ; begin
58494: LD_INT 0
58496: PPUSH
58497: PPUSH
// for i = 1 to mc_bases do
58498: LD_ADDR_VAR 0 2
58502: PUSH
58503: DOUBLE
58504: LD_INT 1
58506: DEC
58507: ST_TO_ADDR
58508: LD_EXP 61
58512: PUSH
58513: FOR_TO
58514: IFFALSE 59614
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58516: LD_ADDR_EXP 61
58520: PUSH
58521: LD_EXP 61
58525: PPUSH
58526: LD_VAR 0 2
58530: PPUSH
58531: LD_EXP 61
58535: PUSH
58536: LD_VAR 0 2
58540: ARRAY
58541: PUSH
58542: LD_INT 0
58544: DIFF
58545: PPUSH
58546: CALL_OW 1
58550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58551: LD_ADDR_EXP 62
58555: PUSH
58556: LD_EXP 62
58560: PPUSH
58561: LD_VAR 0 2
58565: PPUSH
58566: EMPTY
58567: PPUSH
58568: CALL_OW 1
58572: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58573: LD_ADDR_EXP 63
58577: PUSH
58578: LD_EXP 63
58582: PPUSH
58583: LD_VAR 0 2
58587: PPUSH
58588: EMPTY
58589: PPUSH
58590: CALL_OW 1
58594: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58595: LD_ADDR_EXP 64
58599: PUSH
58600: LD_EXP 64
58604: PPUSH
58605: LD_VAR 0 2
58609: PPUSH
58610: EMPTY
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58617: LD_ADDR_EXP 65
58621: PUSH
58622: LD_EXP 65
58626: PPUSH
58627: LD_VAR 0 2
58631: PPUSH
58632: EMPTY
58633: PUSH
58634: EMPTY
58635: PUSH
58636: EMPTY
58637: LIST
58638: LIST
58639: PPUSH
58640: CALL_OW 1
58644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58645: LD_ADDR_EXP 66
58649: PUSH
58650: LD_EXP 66
58654: PPUSH
58655: LD_VAR 0 2
58659: PPUSH
58660: EMPTY
58661: PPUSH
58662: CALL_OW 1
58666: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58667: LD_ADDR_EXP 93
58671: PUSH
58672: LD_EXP 93
58676: PPUSH
58677: LD_VAR 0 2
58681: PPUSH
58682: EMPTY
58683: PPUSH
58684: CALL_OW 1
58688: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58689: LD_ADDR_EXP 67
58693: PUSH
58694: LD_EXP 67
58698: PPUSH
58699: LD_VAR 0 2
58703: PPUSH
58704: EMPTY
58705: PPUSH
58706: CALL_OW 1
58710: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58711: LD_ADDR_EXP 68
58715: PUSH
58716: LD_EXP 68
58720: PPUSH
58721: LD_VAR 0 2
58725: PPUSH
58726: EMPTY
58727: PPUSH
58728: CALL_OW 1
58732: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58733: LD_ADDR_EXP 69
58737: PUSH
58738: LD_EXP 69
58742: PPUSH
58743: LD_VAR 0 2
58747: PPUSH
58748: LD_EXP 61
58752: PUSH
58753: LD_VAR 0 2
58757: ARRAY
58758: PPUSH
58759: LD_INT 2
58761: PUSH
58762: LD_INT 30
58764: PUSH
58765: LD_INT 32
58767: PUSH
58768: EMPTY
58769: LIST
58770: LIST
58771: PUSH
58772: LD_INT 30
58774: PUSH
58775: LD_INT 33
58777: PUSH
58778: EMPTY
58779: LIST
58780: LIST
58781: PUSH
58782: EMPTY
58783: LIST
58784: LIST
58785: LIST
58786: PPUSH
58787: CALL_OW 72
58791: PPUSH
58792: CALL_OW 1
58796: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58797: LD_ADDR_EXP 70
58801: PUSH
58802: LD_EXP 70
58806: PPUSH
58807: LD_VAR 0 2
58811: PPUSH
58812: LD_EXP 61
58816: PUSH
58817: LD_VAR 0 2
58821: ARRAY
58822: PPUSH
58823: LD_INT 2
58825: PUSH
58826: LD_INT 30
58828: PUSH
58829: LD_INT 32
58831: PUSH
58832: EMPTY
58833: LIST
58834: LIST
58835: PUSH
58836: LD_INT 30
58838: PUSH
58839: LD_INT 31
58841: PUSH
58842: EMPTY
58843: LIST
58844: LIST
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: LIST
58850: PUSH
58851: LD_INT 58
58853: PUSH
58854: EMPTY
58855: LIST
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: PPUSH
58861: CALL_OW 72
58865: PPUSH
58866: CALL_OW 1
58870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58871: LD_ADDR_EXP 71
58875: PUSH
58876: LD_EXP 71
58880: PPUSH
58881: LD_VAR 0 2
58885: PPUSH
58886: EMPTY
58887: PPUSH
58888: CALL_OW 1
58892: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58893: LD_ADDR_EXP 75
58897: PUSH
58898: LD_EXP 75
58902: PPUSH
58903: LD_VAR 0 2
58907: PPUSH
58908: EMPTY
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58915: LD_ADDR_EXP 74
58919: PUSH
58920: LD_EXP 74
58924: PPUSH
58925: LD_VAR 0 2
58929: PPUSH
58930: EMPTY
58931: PPUSH
58932: CALL_OW 1
58936: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58937: LD_ADDR_EXP 76
58941: PUSH
58942: LD_EXP 76
58946: PPUSH
58947: LD_VAR 0 2
58951: PPUSH
58952: EMPTY
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58959: LD_ADDR_EXP 77
58963: PUSH
58964: LD_EXP 77
58968: PPUSH
58969: LD_VAR 0 2
58973: PPUSH
58974: EMPTY
58975: PPUSH
58976: CALL_OW 1
58980: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58981: LD_ADDR_EXP 78
58985: PUSH
58986: LD_EXP 78
58990: PPUSH
58991: LD_VAR 0 2
58995: PPUSH
58996: EMPTY
58997: PPUSH
58998: CALL_OW 1
59002: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59003: LD_ADDR_EXP 79
59007: PUSH
59008: LD_EXP 79
59012: PPUSH
59013: LD_VAR 0 2
59017: PPUSH
59018: EMPTY
59019: PPUSH
59020: CALL_OW 1
59024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59025: LD_ADDR_EXP 80
59029: PUSH
59030: LD_EXP 80
59034: PPUSH
59035: LD_VAR 0 2
59039: PPUSH
59040: EMPTY
59041: PPUSH
59042: CALL_OW 1
59046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59047: LD_ADDR_EXP 81
59051: PUSH
59052: LD_EXP 81
59056: PPUSH
59057: LD_VAR 0 2
59061: PPUSH
59062: EMPTY
59063: PPUSH
59064: CALL_OW 1
59068: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59069: LD_ADDR_EXP 82
59073: PUSH
59074: LD_EXP 82
59078: PPUSH
59079: LD_VAR 0 2
59083: PPUSH
59084: EMPTY
59085: PPUSH
59086: CALL_OW 1
59090: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59091: LD_ADDR_EXP 83
59095: PUSH
59096: LD_EXP 83
59100: PPUSH
59101: LD_VAR 0 2
59105: PPUSH
59106: EMPTY
59107: PPUSH
59108: CALL_OW 1
59112: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59113: LD_ADDR_EXP 72
59117: PUSH
59118: LD_EXP 72
59122: PPUSH
59123: LD_VAR 0 2
59127: PPUSH
59128: LD_INT 0
59130: PPUSH
59131: CALL_OW 1
59135: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59136: LD_ADDR_EXP 85
59140: PUSH
59141: LD_EXP 85
59145: PPUSH
59146: LD_VAR 0 2
59150: PPUSH
59151: LD_INT 0
59153: PPUSH
59154: CALL_OW 1
59158: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59159: LD_ADDR_EXP 73
59163: PUSH
59164: LD_EXP 73
59168: PPUSH
59169: LD_VAR 0 2
59173: PPUSH
59174: EMPTY
59175: PPUSH
59176: CALL_OW 1
59180: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59181: LD_ADDR_EXP 84
59185: PUSH
59186: LD_EXP 84
59190: PPUSH
59191: LD_VAR 0 2
59195: PPUSH
59196: LD_INT 0
59198: PPUSH
59199: CALL_OW 1
59203: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59204: LD_ADDR_EXP 86
59208: PUSH
59209: LD_EXP 86
59213: PPUSH
59214: LD_VAR 0 2
59218: PPUSH
59219: EMPTY
59220: PPUSH
59221: CALL_OW 1
59225: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59226: LD_ADDR_EXP 89
59230: PUSH
59231: LD_EXP 89
59235: PPUSH
59236: LD_VAR 0 2
59240: PPUSH
59241: LD_INT 0
59243: PPUSH
59244: CALL_OW 1
59248: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59249: LD_ADDR_EXP 90
59253: PUSH
59254: LD_EXP 90
59258: PPUSH
59259: LD_VAR 0 2
59263: PPUSH
59264: EMPTY
59265: PPUSH
59266: CALL_OW 1
59270: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59271: LD_ADDR_EXP 91
59275: PUSH
59276: LD_EXP 91
59280: PPUSH
59281: LD_VAR 0 2
59285: PPUSH
59286: EMPTY
59287: PPUSH
59288: CALL_OW 1
59292: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59293: LD_ADDR_EXP 92
59297: PUSH
59298: LD_EXP 92
59302: PPUSH
59303: LD_VAR 0 2
59307: PPUSH
59308: EMPTY
59309: PPUSH
59310: CALL_OW 1
59314: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59315: LD_ADDR_EXP 94
59319: PUSH
59320: LD_EXP 94
59324: PPUSH
59325: LD_VAR 0 2
59329: PPUSH
59330: LD_EXP 61
59334: PUSH
59335: LD_VAR 0 2
59339: ARRAY
59340: PPUSH
59341: LD_INT 2
59343: PUSH
59344: LD_INT 30
59346: PUSH
59347: LD_INT 6
59349: PUSH
59350: EMPTY
59351: LIST
59352: LIST
59353: PUSH
59354: LD_INT 30
59356: PUSH
59357: LD_INT 7
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PUSH
59364: LD_INT 30
59366: PUSH
59367: LD_INT 8
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: LIST
59378: LIST
59379: PPUSH
59380: CALL_OW 72
59384: PPUSH
59385: CALL_OW 1
59389: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59390: LD_ADDR_EXP 95
59394: PUSH
59395: LD_EXP 95
59399: PPUSH
59400: LD_VAR 0 2
59404: PPUSH
59405: EMPTY
59406: PPUSH
59407: CALL_OW 1
59411: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59412: LD_ADDR_EXP 96
59416: PUSH
59417: LD_EXP 96
59421: PPUSH
59422: LD_VAR 0 2
59426: PPUSH
59427: EMPTY
59428: PPUSH
59429: CALL_OW 1
59433: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59434: LD_ADDR_EXP 97
59438: PUSH
59439: LD_EXP 97
59443: PPUSH
59444: LD_VAR 0 2
59448: PPUSH
59449: EMPTY
59450: PPUSH
59451: CALL_OW 1
59455: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59456: LD_ADDR_EXP 98
59460: PUSH
59461: LD_EXP 98
59465: PPUSH
59466: LD_VAR 0 2
59470: PPUSH
59471: EMPTY
59472: PPUSH
59473: CALL_OW 1
59477: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59478: LD_ADDR_EXP 99
59482: PUSH
59483: LD_EXP 99
59487: PPUSH
59488: LD_VAR 0 2
59492: PPUSH
59493: EMPTY
59494: PPUSH
59495: CALL_OW 1
59499: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59500: LD_ADDR_EXP 100
59504: PUSH
59505: LD_EXP 100
59509: PPUSH
59510: LD_VAR 0 2
59514: PPUSH
59515: EMPTY
59516: PPUSH
59517: CALL_OW 1
59521: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59522: LD_ADDR_EXP 101
59526: PUSH
59527: LD_EXP 101
59531: PPUSH
59532: LD_VAR 0 2
59536: PPUSH
59537: EMPTY
59538: PPUSH
59539: CALL_OW 1
59543: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59544: LD_ADDR_EXP 102
59548: PUSH
59549: LD_EXP 102
59553: PPUSH
59554: LD_VAR 0 2
59558: PPUSH
59559: EMPTY
59560: PPUSH
59561: CALL_OW 1
59565: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59566: LD_ADDR_EXP 103
59570: PUSH
59571: LD_EXP 103
59575: PPUSH
59576: LD_VAR 0 2
59580: PPUSH
59581: LD_INT 0
59583: PPUSH
59584: CALL_OW 1
59588: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59589: LD_ADDR_EXP 104
59593: PUSH
59594: LD_EXP 104
59598: PPUSH
59599: LD_VAR 0 2
59603: PPUSH
59604: LD_INT 0
59606: PPUSH
59607: CALL_OW 1
59611: ST_TO_ADDR
// end ;
59612: GO 58513
59614: POP
59615: POP
// MC_InitSides ( ) ;
59616: CALL 59902 0 0
// MC_InitResearch ( ) ;
59620: CALL 59641 0 0
// CustomInitMacro ( ) ;
59624: CALL 219 0 0
// skirmish := true ;
59628: LD_ADDR_EXP 59
59632: PUSH
59633: LD_INT 1
59635: ST_TO_ADDR
// end ;
59636: LD_VAR 0 1
59640: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59641: LD_INT 0
59643: PPUSH
59644: PPUSH
59645: PPUSH
59646: PPUSH
59647: PPUSH
59648: PPUSH
// if not mc_bases then
59649: LD_EXP 61
59653: NOT
59654: IFFALSE 59658
// exit ;
59656: GO 59897
// for i = 1 to 8 do
59658: LD_ADDR_VAR 0 2
59662: PUSH
59663: DOUBLE
59664: LD_INT 1
59666: DEC
59667: ST_TO_ADDR
59668: LD_INT 8
59670: PUSH
59671: FOR_TO
59672: IFFALSE 59698
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59674: LD_ADDR_EXP 88
59678: PUSH
59679: LD_EXP 88
59683: PPUSH
59684: LD_VAR 0 2
59688: PPUSH
59689: EMPTY
59690: PPUSH
59691: CALL_OW 1
59695: ST_TO_ADDR
59696: GO 59671
59698: POP
59699: POP
// tmp := [ ] ;
59700: LD_ADDR_VAR 0 5
59704: PUSH
59705: EMPTY
59706: ST_TO_ADDR
// for i = 1 to mc_sides do
59707: LD_ADDR_VAR 0 2
59711: PUSH
59712: DOUBLE
59713: LD_INT 1
59715: DEC
59716: ST_TO_ADDR
59717: LD_EXP 87
59721: PUSH
59722: FOR_TO
59723: IFFALSE 59781
// if not mc_sides [ i ] in tmp then
59725: LD_EXP 87
59729: PUSH
59730: LD_VAR 0 2
59734: ARRAY
59735: PUSH
59736: LD_VAR 0 5
59740: IN
59741: NOT
59742: IFFALSE 59779
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59744: LD_ADDR_VAR 0 5
59748: PUSH
59749: LD_VAR 0 5
59753: PPUSH
59754: LD_VAR 0 5
59758: PUSH
59759: LD_INT 1
59761: PLUS
59762: PPUSH
59763: LD_EXP 87
59767: PUSH
59768: LD_VAR 0 2
59772: ARRAY
59773: PPUSH
59774: CALL_OW 2
59778: ST_TO_ADDR
59779: GO 59722
59781: POP
59782: POP
// if not tmp then
59783: LD_VAR 0 5
59787: NOT
59788: IFFALSE 59792
// exit ;
59790: GO 59897
// for j in tmp do
59792: LD_ADDR_VAR 0 3
59796: PUSH
59797: LD_VAR 0 5
59801: PUSH
59802: FOR_IN
59803: IFFALSE 59895
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59805: LD_ADDR_VAR 0 6
59809: PUSH
59810: LD_INT 22
59812: PUSH
59813: LD_VAR 0 3
59817: PUSH
59818: EMPTY
59819: LIST
59820: LIST
59821: PPUSH
59822: CALL_OW 69
59826: ST_TO_ADDR
// if not un then
59827: LD_VAR 0 6
59831: NOT
59832: IFFALSE 59836
// continue ;
59834: GO 59802
// nation := GetNation ( un [ 1 ] ) ;
59836: LD_ADDR_VAR 0 4
59840: PUSH
59841: LD_VAR 0 6
59845: PUSH
59846: LD_INT 1
59848: ARRAY
59849: PPUSH
59850: CALL_OW 248
59854: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59855: LD_ADDR_EXP 88
59859: PUSH
59860: LD_EXP 88
59864: PPUSH
59865: LD_VAR 0 3
59869: PPUSH
59870: LD_VAR 0 3
59874: PPUSH
59875: LD_VAR 0 4
59879: PPUSH
59880: LD_INT 1
59882: PPUSH
59883: CALL 15013 0 3
59887: PPUSH
59888: CALL_OW 1
59892: ST_TO_ADDR
// end ;
59893: GO 59802
59895: POP
59896: POP
// end ;
59897: LD_VAR 0 1
59901: RET
// export function MC_InitSides ( ) ; var i ; begin
59902: LD_INT 0
59904: PPUSH
59905: PPUSH
// if not mc_bases then
59906: LD_EXP 61
59910: NOT
59911: IFFALSE 59915
// exit ;
59913: GO 59989
// for i = 1 to mc_bases do
59915: LD_ADDR_VAR 0 2
59919: PUSH
59920: DOUBLE
59921: LD_INT 1
59923: DEC
59924: ST_TO_ADDR
59925: LD_EXP 61
59929: PUSH
59930: FOR_TO
59931: IFFALSE 59987
// if mc_bases [ i ] then
59933: LD_EXP 61
59937: PUSH
59938: LD_VAR 0 2
59942: ARRAY
59943: IFFALSE 59985
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59945: LD_ADDR_EXP 87
59949: PUSH
59950: LD_EXP 87
59954: PPUSH
59955: LD_VAR 0 2
59959: PPUSH
59960: LD_EXP 61
59964: PUSH
59965: LD_VAR 0 2
59969: ARRAY
59970: PUSH
59971: LD_INT 1
59973: ARRAY
59974: PPUSH
59975: CALL_OW 255
59979: PPUSH
59980: CALL_OW 1
59984: ST_TO_ADDR
59985: GO 59930
59987: POP
59988: POP
// end ;
59989: LD_VAR 0 1
59993: RET
// every 0 0$03 trigger skirmish do
59994: LD_EXP 59
59998: IFFALSE 60152
60000: GO 60002
60002: DISABLE
// begin enable ;
60003: ENABLE
// MC_CheckBuildings ( ) ;
60004: CALL 64650 0 0
// MC_CheckPeopleLife ( ) ;
60008: CALL 64811 0 0
// RaiseSailEvent ( 100 ) ;
60012: LD_INT 100
60014: PPUSH
60015: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60019: LD_INT 103
60021: PPUSH
60022: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60026: LD_INT 104
60028: PPUSH
60029: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60033: LD_INT 105
60035: PPUSH
60036: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60040: LD_INT 106
60042: PPUSH
60043: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60047: LD_INT 107
60049: PPUSH
60050: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60054: LD_INT 108
60056: PPUSH
60057: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60061: LD_INT 109
60063: PPUSH
60064: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60068: LD_INT 110
60070: PPUSH
60071: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60075: LD_INT 111
60077: PPUSH
60078: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60082: LD_INT 112
60084: PPUSH
60085: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60089: LD_INT 113
60091: PPUSH
60092: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60096: LD_INT 120
60098: PPUSH
60099: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60103: LD_INT 121
60105: PPUSH
60106: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60110: LD_INT 122
60112: PPUSH
60113: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60117: LD_INT 123
60119: PPUSH
60120: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60124: LD_INT 124
60126: PPUSH
60127: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60131: LD_INT 125
60133: PPUSH
60134: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60138: LD_INT 126
60140: PPUSH
60141: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60145: LD_INT 200
60147: PPUSH
60148: CALL_OW 427
// end ;
60152: END
// on SailEvent ( event ) do begin if event < 100 then
60153: LD_VAR 0 1
60157: PUSH
60158: LD_INT 100
60160: LESS
60161: IFFALSE 60172
// CustomEvent ( event ) ;
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL 13628 0 1
// if event = 100 then
60172: LD_VAR 0 1
60176: PUSH
60177: LD_INT 100
60179: EQUAL
60180: IFFALSE 60186
// MC_ClassManager ( ) ;
60182: CALL 60578 0 0
// if event = 101 then
60186: LD_VAR 0 1
60190: PUSH
60191: LD_INT 101
60193: EQUAL
60194: IFFALSE 60200
// MC_RepairBuildings ( ) ;
60196: CALL 65396 0 0
// if event = 102 then
60200: LD_VAR 0 1
60204: PUSH
60205: LD_INT 102
60207: EQUAL
60208: IFFALSE 60214
// MC_Heal ( ) ;
60210: CALL 66331 0 0
// if event = 103 then
60214: LD_VAR 0 1
60218: PUSH
60219: LD_INT 103
60221: EQUAL
60222: IFFALSE 60228
// MC_Build ( ) ;
60224: CALL 66753 0 0
// if event = 104 then
60228: LD_VAR 0 1
60232: PUSH
60233: LD_INT 104
60235: EQUAL
60236: IFFALSE 60242
// MC_TurretWeapon ( ) ;
60238: CALL 68387 0 0
// if event = 105 then
60242: LD_VAR 0 1
60246: PUSH
60247: LD_INT 105
60249: EQUAL
60250: IFFALSE 60256
// MC_BuildUpgrade ( ) ;
60252: CALL 67938 0 0
// if event = 106 then
60256: LD_VAR 0 1
60260: PUSH
60261: LD_INT 106
60263: EQUAL
60264: IFFALSE 60270
// MC_PlantMines ( ) ;
60266: CALL 68817 0 0
// if event = 107 then
60270: LD_VAR 0 1
60274: PUSH
60275: LD_INT 107
60277: EQUAL
60278: IFFALSE 60284
// MC_CollectCrates ( ) ;
60280: CALL 69615 0 0
// if event = 108 then
60284: LD_VAR 0 1
60288: PUSH
60289: LD_INT 108
60291: EQUAL
60292: IFFALSE 60298
// MC_LinkRemoteControl ( ) ;
60294: CALL 71465 0 0
// if event = 109 then
60298: LD_VAR 0 1
60302: PUSH
60303: LD_INT 109
60305: EQUAL
60306: IFFALSE 60312
// MC_ProduceVehicle ( ) ;
60308: CALL 71646 0 0
// if event = 110 then
60312: LD_VAR 0 1
60316: PUSH
60317: LD_INT 110
60319: EQUAL
60320: IFFALSE 60326
// MC_SendAttack ( ) ;
60322: CALL 72112 0 0
// if event = 111 then
60326: LD_VAR 0 1
60330: PUSH
60331: LD_INT 111
60333: EQUAL
60334: IFFALSE 60340
// MC_Defend ( ) ;
60336: CALL 72220 0 0
// if event = 112 then
60340: LD_VAR 0 1
60344: PUSH
60345: LD_INT 112
60347: EQUAL
60348: IFFALSE 60354
// MC_Research ( ) ;
60350: CALL 73100 0 0
// if event = 113 then
60354: LD_VAR 0 1
60358: PUSH
60359: LD_INT 113
60361: EQUAL
60362: IFFALSE 60368
// MC_MinesTrigger ( ) ;
60364: CALL 74214 0 0
// if event = 120 then
60368: LD_VAR 0 1
60372: PUSH
60373: LD_INT 120
60375: EQUAL
60376: IFFALSE 60382
// MC_RepairVehicle ( ) ;
60378: CALL 74313 0 0
// if event = 121 then
60382: LD_VAR 0 1
60386: PUSH
60387: LD_INT 121
60389: EQUAL
60390: IFFALSE 60396
// MC_TameApe ( ) ;
60392: CALL 75082 0 0
// if event = 122 then
60396: LD_VAR 0 1
60400: PUSH
60401: LD_INT 122
60403: EQUAL
60404: IFFALSE 60410
// MC_ChangeApeClass ( ) ;
60406: CALL 75911 0 0
// if event = 123 then
60410: LD_VAR 0 1
60414: PUSH
60415: LD_INT 123
60417: EQUAL
60418: IFFALSE 60424
// MC_Bazooka ( ) ;
60420: CALL 76561 0 0
// if event = 124 then
60424: LD_VAR 0 1
60428: PUSH
60429: LD_INT 124
60431: EQUAL
60432: IFFALSE 60438
// MC_TeleportExit ( ) ;
60434: CALL 76759 0 0
// if event = 125 then
60438: LD_VAR 0 1
60442: PUSH
60443: LD_INT 125
60445: EQUAL
60446: IFFALSE 60452
// MC_Deposits ( ) ;
60448: CALL 77406 0 0
// if event = 126 then
60452: LD_VAR 0 1
60456: PUSH
60457: LD_INT 126
60459: EQUAL
60460: IFFALSE 60466
// MC_RemoteDriver ( ) ;
60462: CALL 78031 0 0
// if event = 200 then
60466: LD_VAR 0 1
60470: PUSH
60471: LD_INT 200
60473: EQUAL
60474: IFFALSE 60480
// MC_Idle ( ) ;
60476: CALL 79938 0 0
// end ;
60480: PPOPN 1
60482: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60483: LD_INT 0
60485: PPUSH
60486: PPUSH
// if not mc_bases [ base ] or not tag then
60487: LD_EXP 61
60491: PUSH
60492: LD_VAR 0 1
60496: ARRAY
60497: NOT
60498: PUSH
60499: LD_VAR 0 2
60503: NOT
60504: OR
60505: IFFALSE 60509
// exit ;
60507: GO 60573
// for i in mc_bases [ base ] union mc_ape [ base ] do
60509: LD_ADDR_VAR 0 4
60513: PUSH
60514: LD_EXP 61
60518: PUSH
60519: LD_VAR 0 1
60523: ARRAY
60524: PUSH
60525: LD_EXP 90
60529: PUSH
60530: LD_VAR 0 1
60534: ARRAY
60535: UNION
60536: PUSH
60537: FOR_IN
60538: IFFALSE 60571
// if GetTag ( i ) = tag then
60540: LD_VAR 0 4
60544: PPUSH
60545: CALL_OW 110
60549: PUSH
60550: LD_VAR 0 2
60554: EQUAL
60555: IFFALSE 60569
// SetTag ( i , 0 ) ;
60557: LD_VAR 0 4
60561: PPUSH
60562: LD_INT 0
60564: PPUSH
60565: CALL_OW 109
60569: GO 60537
60571: POP
60572: POP
// end ;
60573: LD_VAR 0 3
60577: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60578: LD_INT 0
60580: PPUSH
60581: PPUSH
60582: PPUSH
60583: PPUSH
60584: PPUSH
60585: PPUSH
60586: PPUSH
60587: PPUSH
// if not mc_bases then
60588: LD_EXP 61
60592: NOT
60593: IFFALSE 60597
// exit ;
60595: GO 61055
// for i = 1 to mc_bases do
60597: LD_ADDR_VAR 0 2
60601: PUSH
60602: DOUBLE
60603: LD_INT 1
60605: DEC
60606: ST_TO_ADDR
60607: LD_EXP 61
60611: PUSH
60612: FOR_TO
60613: IFFALSE 61053
// begin tmp := MC_ClassCheckReq ( i ) ;
60615: LD_ADDR_VAR 0 4
60619: PUSH
60620: LD_VAR 0 2
60624: PPUSH
60625: CALL 61060 0 1
60629: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60630: LD_ADDR_EXP 102
60634: PUSH
60635: LD_EXP 102
60639: PPUSH
60640: LD_VAR 0 2
60644: PPUSH
60645: LD_VAR 0 4
60649: PPUSH
60650: CALL_OW 1
60654: ST_TO_ADDR
// if not tmp then
60655: LD_VAR 0 4
60659: NOT
60660: IFFALSE 60664
// continue ;
60662: GO 60612
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60664: LD_ADDR_VAR 0 6
60668: PUSH
60669: LD_EXP 61
60673: PUSH
60674: LD_VAR 0 2
60678: ARRAY
60679: PPUSH
60680: LD_INT 2
60682: PUSH
60683: LD_INT 30
60685: PUSH
60686: LD_INT 4
60688: PUSH
60689: EMPTY
60690: LIST
60691: LIST
60692: PUSH
60693: LD_INT 30
60695: PUSH
60696: LD_INT 5
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: EMPTY
60704: LIST
60705: LIST
60706: LIST
60707: PPUSH
60708: CALL_OW 72
60712: PUSH
60713: LD_EXP 61
60717: PUSH
60718: LD_VAR 0 2
60722: ARRAY
60723: PPUSH
60724: LD_INT 2
60726: PUSH
60727: LD_INT 30
60729: PUSH
60730: LD_INT 0
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: PUSH
60737: LD_INT 30
60739: PUSH
60740: LD_INT 1
60742: PUSH
60743: EMPTY
60744: LIST
60745: LIST
60746: PUSH
60747: EMPTY
60748: LIST
60749: LIST
60750: LIST
60751: PPUSH
60752: CALL_OW 72
60756: PUSH
60757: LD_EXP 61
60761: PUSH
60762: LD_VAR 0 2
60766: ARRAY
60767: PPUSH
60768: LD_INT 30
60770: PUSH
60771: LD_INT 3
60773: PUSH
60774: EMPTY
60775: LIST
60776: LIST
60777: PPUSH
60778: CALL_OW 72
60782: PUSH
60783: LD_EXP 61
60787: PUSH
60788: LD_VAR 0 2
60792: ARRAY
60793: PPUSH
60794: LD_INT 2
60796: PUSH
60797: LD_INT 30
60799: PUSH
60800: LD_INT 6
60802: PUSH
60803: EMPTY
60804: LIST
60805: LIST
60806: PUSH
60807: LD_INT 30
60809: PUSH
60810: LD_INT 7
60812: PUSH
60813: EMPTY
60814: LIST
60815: LIST
60816: PUSH
60817: LD_INT 30
60819: PUSH
60820: LD_INT 8
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: PUSH
60827: EMPTY
60828: LIST
60829: LIST
60830: LIST
60831: LIST
60832: PPUSH
60833: CALL_OW 72
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: LIST
60842: LIST
60843: ST_TO_ADDR
// for j = 1 to 4 do
60844: LD_ADDR_VAR 0 3
60848: PUSH
60849: DOUBLE
60850: LD_INT 1
60852: DEC
60853: ST_TO_ADDR
60854: LD_INT 4
60856: PUSH
60857: FOR_TO
60858: IFFALSE 61049
// begin if not tmp [ j ] then
60860: LD_VAR 0 4
60864: PUSH
60865: LD_VAR 0 3
60869: ARRAY
60870: NOT
60871: IFFALSE 60875
// continue ;
60873: GO 60857
// for p in tmp [ j ] do
60875: LD_ADDR_VAR 0 5
60879: PUSH
60880: LD_VAR 0 4
60884: PUSH
60885: LD_VAR 0 3
60889: ARRAY
60890: PUSH
60891: FOR_IN
60892: IFFALSE 61045
// begin if not b [ j ] then
60894: LD_VAR 0 6
60898: PUSH
60899: LD_VAR 0 3
60903: ARRAY
60904: NOT
60905: IFFALSE 60909
// break ;
60907: GO 61045
// e := 0 ;
60909: LD_ADDR_VAR 0 7
60913: PUSH
60914: LD_INT 0
60916: ST_TO_ADDR
// for k in b [ j ] do
60917: LD_ADDR_VAR 0 8
60921: PUSH
60922: LD_VAR 0 6
60926: PUSH
60927: LD_VAR 0 3
60931: ARRAY
60932: PUSH
60933: FOR_IN
60934: IFFALSE 60961
// if IsNotFull ( k ) then
60936: LD_VAR 0 8
60940: PPUSH
60941: CALL 17134 0 1
60945: IFFALSE 60959
// begin e := k ;
60947: LD_ADDR_VAR 0 7
60951: PUSH
60952: LD_VAR 0 8
60956: ST_TO_ADDR
// break ;
60957: GO 60961
// end ;
60959: GO 60933
60961: POP
60962: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60963: LD_VAR 0 7
60967: PUSH
60968: LD_VAR 0 5
60972: PPUSH
60973: LD_VAR 0 7
60977: PPUSH
60978: CALL 50887 0 2
60982: NOT
60983: AND
60984: IFFALSE 61043
// begin if IsInUnit ( p ) then
60986: LD_VAR 0 5
60990: PPUSH
60991: CALL_OW 310
60995: IFFALSE 61006
// ComExitBuilding ( p ) ;
60997: LD_VAR 0 5
61001: PPUSH
61002: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61006: LD_VAR 0 5
61010: PPUSH
61011: LD_VAR 0 7
61015: PPUSH
61016: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61020: LD_VAR 0 5
61024: PPUSH
61025: LD_VAR 0 3
61029: PPUSH
61030: CALL_OW 183
// AddComExitBuilding ( p ) ;
61034: LD_VAR 0 5
61038: PPUSH
61039: CALL_OW 182
// end ; end ;
61043: GO 60891
61045: POP
61046: POP
// end ;
61047: GO 60857
61049: POP
61050: POP
// end ;
61051: GO 60612
61053: POP
61054: POP
// end ;
61055: LD_VAR 0 1
61059: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61060: LD_INT 0
61062: PPUSH
61063: PPUSH
61064: PPUSH
61065: PPUSH
61066: PPUSH
61067: PPUSH
61068: PPUSH
61069: PPUSH
61070: PPUSH
61071: PPUSH
61072: PPUSH
61073: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61074: LD_VAR 0 1
61078: NOT
61079: PUSH
61080: LD_EXP 61
61084: PUSH
61085: LD_VAR 0 1
61089: ARRAY
61090: NOT
61091: OR
61092: PUSH
61093: LD_EXP 61
61097: PUSH
61098: LD_VAR 0 1
61102: ARRAY
61103: PPUSH
61104: LD_INT 2
61106: PUSH
61107: LD_INT 30
61109: PUSH
61110: LD_INT 0
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: PUSH
61117: LD_INT 30
61119: PUSH
61120: LD_INT 1
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PUSH
61127: EMPTY
61128: LIST
61129: LIST
61130: LIST
61131: PPUSH
61132: CALL_OW 72
61136: NOT
61137: OR
61138: IFFALSE 61142
// exit ;
61140: GO 64645
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61142: LD_ADDR_VAR 0 4
61146: PUSH
61147: LD_EXP 61
61151: PUSH
61152: LD_VAR 0 1
61156: ARRAY
61157: PPUSH
61158: LD_INT 2
61160: PUSH
61161: LD_INT 25
61163: PUSH
61164: LD_INT 1
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: LD_INT 25
61173: PUSH
61174: LD_INT 2
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: LD_INT 25
61183: PUSH
61184: LD_INT 3
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PUSH
61191: LD_INT 25
61193: PUSH
61194: LD_INT 4
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: PUSH
61201: LD_INT 25
61203: PUSH
61204: LD_INT 5
61206: PUSH
61207: EMPTY
61208: LIST
61209: LIST
61210: PUSH
61211: LD_INT 25
61213: PUSH
61214: LD_INT 8
61216: PUSH
61217: EMPTY
61218: LIST
61219: LIST
61220: PUSH
61221: LD_INT 25
61223: PUSH
61224: LD_INT 9
61226: PUSH
61227: EMPTY
61228: LIST
61229: LIST
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: PPUSH
61241: CALL_OW 72
61245: ST_TO_ADDR
// if not tmp then
61246: LD_VAR 0 4
61250: NOT
61251: IFFALSE 61255
// exit ;
61253: GO 64645
// for i in tmp do
61255: LD_ADDR_VAR 0 3
61259: PUSH
61260: LD_VAR 0 4
61264: PUSH
61265: FOR_IN
61266: IFFALSE 61297
// if GetTag ( i ) then
61268: LD_VAR 0 3
61272: PPUSH
61273: CALL_OW 110
61277: IFFALSE 61295
// tmp := tmp diff i ;
61279: LD_ADDR_VAR 0 4
61283: PUSH
61284: LD_VAR 0 4
61288: PUSH
61289: LD_VAR 0 3
61293: DIFF
61294: ST_TO_ADDR
61295: GO 61265
61297: POP
61298: POP
// if not tmp then
61299: LD_VAR 0 4
61303: NOT
61304: IFFALSE 61308
// exit ;
61306: GO 64645
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61308: LD_ADDR_VAR 0 5
61312: PUSH
61313: LD_EXP 61
61317: PUSH
61318: LD_VAR 0 1
61322: ARRAY
61323: PPUSH
61324: LD_INT 2
61326: PUSH
61327: LD_INT 25
61329: PUSH
61330: LD_INT 1
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: PUSH
61337: LD_INT 25
61339: PUSH
61340: LD_INT 5
61342: PUSH
61343: EMPTY
61344: LIST
61345: LIST
61346: PUSH
61347: LD_INT 25
61349: PUSH
61350: LD_INT 8
61352: PUSH
61353: EMPTY
61354: LIST
61355: LIST
61356: PUSH
61357: LD_INT 25
61359: PUSH
61360: LD_INT 9
61362: PUSH
61363: EMPTY
61364: LIST
61365: LIST
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: LIST
61373: PPUSH
61374: CALL_OW 72
61378: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61379: LD_ADDR_VAR 0 6
61383: PUSH
61384: LD_EXP 61
61388: PUSH
61389: LD_VAR 0 1
61393: ARRAY
61394: PPUSH
61395: LD_INT 25
61397: PUSH
61398: LD_INT 2
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PPUSH
61405: CALL_OW 72
61409: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61410: LD_ADDR_VAR 0 7
61414: PUSH
61415: LD_EXP 61
61419: PUSH
61420: LD_VAR 0 1
61424: ARRAY
61425: PPUSH
61426: LD_INT 25
61428: PUSH
61429: LD_INT 3
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PPUSH
61436: CALL_OW 72
61440: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61441: LD_ADDR_VAR 0 8
61445: PUSH
61446: LD_EXP 61
61450: PUSH
61451: LD_VAR 0 1
61455: ARRAY
61456: PPUSH
61457: LD_INT 25
61459: PUSH
61460: LD_INT 4
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PUSH
61467: LD_INT 24
61469: PUSH
61470: LD_INT 251
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: EMPTY
61478: LIST
61479: LIST
61480: PPUSH
61481: CALL_OW 72
61485: ST_TO_ADDR
// if mc_is_defending [ base ] then
61486: LD_EXP 104
61490: PUSH
61491: LD_VAR 0 1
61495: ARRAY
61496: IFFALSE 61957
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61498: LD_ADDR_EXP 103
61502: PUSH
61503: LD_EXP 103
61507: PPUSH
61508: LD_VAR 0 1
61512: PPUSH
61513: LD_INT 4
61515: PPUSH
61516: CALL_OW 1
61520: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61521: LD_ADDR_VAR 0 12
61525: PUSH
61526: LD_EXP 61
61530: PUSH
61531: LD_VAR 0 1
61535: ARRAY
61536: PPUSH
61537: LD_INT 2
61539: PUSH
61540: LD_INT 30
61542: PUSH
61543: LD_INT 4
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 30
61552: PUSH
61553: LD_INT 5
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: EMPTY
61561: LIST
61562: LIST
61563: LIST
61564: PPUSH
61565: CALL_OW 72
61569: ST_TO_ADDR
// if not b then
61570: LD_VAR 0 12
61574: NOT
61575: IFFALSE 61579
// exit ;
61577: GO 64645
// p := [ ] ;
61579: LD_ADDR_VAR 0 11
61583: PUSH
61584: EMPTY
61585: ST_TO_ADDR
// if sci >= 2 then
61586: LD_VAR 0 8
61590: PUSH
61591: LD_INT 2
61593: GREATEREQUAL
61594: IFFALSE 61625
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61596: LD_ADDR_VAR 0 8
61600: PUSH
61601: LD_VAR 0 8
61605: PUSH
61606: LD_INT 1
61608: ARRAY
61609: PUSH
61610: LD_VAR 0 8
61614: PUSH
61615: LD_INT 2
61617: ARRAY
61618: PUSH
61619: EMPTY
61620: LIST
61621: LIST
61622: ST_TO_ADDR
61623: GO 61686
// if sci = 1 then
61625: LD_VAR 0 8
61629: PUSH
61630: LD_INT 1
61632: EQUAL
61633: IFFALSE 61654
// sci := [ sci [ 1 ] ] else
61635: LD_ADDR_VAR 0 8
61639: PUSH
61640: LD_VAR 0 8
61644: PUSH
61645: LD_INT 1
61647: ARRAY
61648: PUSH
61649: EMPTY
61650: LIST
61651: ST_TO_ADDR
61652: GO 61686
// if sci = 0 then
61654: LD_VAR 0 8
61658: PUSH
61659: LD_INT 0
61661: EQUAL
61662: IFFALSE 61686
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61664: LD_ADDR_VAR 0 11
61668: PUSH
61669: LD_VAR 0 4
61673: PPUSH
61674: LD_INT 4
61676: PPUSH
61677: CALL 50759 0 2
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: ST_TO_ADDR
// if eng > 4 then
61686: LD_VAR 0 6
61690: PUSH
61691: LD_INT 4
61693: GREATER
61694: IFFALSE 61740
// for i = eng downto 4 do
61696: LD_ADDR_VAR 0 3
61700: PUSH
61701: DOUBLE
61702: LD_VAR 0 6
61706: INC
61707: ST_TO_ADDR
61708: LD_INT 4
61710: PUSH
61711: FOR_DOWNTO
61712: IFFALSE 61738
// eng := eng diff eng [ i ] ;
61714: LD_ADDR_VAR 0 6
61718: PUSH
61719: LD_VAR 0 6
61723: PUSH
61724: LD_VAR 0 6
61728: PUSH
61729: LD_VAR 0 3
61733: ARRAY
61734: DIFF
61735: ST_TO_ADDR
61736: GO 61711
61738: POP
61739: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61740: LD_ADDR_VAR 0 4
61744: PUSH
61745: LD_VAR 0 4
61749: PUSH
61750: LD_VAR 0 5
61754: PUSH
61755: LD_VAR 0 6
61759: UNION
61760: PUSH
61761: LD_VAR 0 7
61765: UNION
61766: PUSH
61767: LD_VAR 0 8
61771: UNION
61772: DIFF
61773: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61774: LD_ADDR_VAR 0 13
61778: PUSH
61779: LD_EXP 61
61783: PUSH
61784: LD_VAR 0 1
61788: ARRAY
61789: PPUSH
61790: LD_INT 2
61792: PUSH
61793: LD_INT 30
61795: PUSH
61796: LD_INT 32
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 30
61805: PUSH
61806: LD_INT 31
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PUSH
61813: EMPTY
61814: LIST
61815: LIST
61816: LIST
61817: PPUSH
61818: CALL_OW 72
61822: PUSH
61823: LD_EXP 61
61827: PUSH
61828: LD_VAR 0 1
61832: ARRAY
61833: PPUSH
61834: LD_INT 2
61836: PUSH
61837: LD_INT 30
61839: PUSH
61840: LD_INT 4
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PUSH
61847: LD_INT 30
61849: PUSH
61850: LD_INT 5
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: LIST
61861: PPUSH
61862: CALL_OW 72
61866: PUSH
61867: LD_INT 6
61869: MUL
61870: PLUS
61871: ST_TO_ADDR
// if bcount < tmp then
61872: LD_VAR 0 13
61876: PUSH
61877: LD_VAR 0 4
61881: LESS
61882: IFFALSE 61928
// for i = tmp downto bcount do
61884: LD_ADDR_VAR 0 3
61888: PUSH
61889: DOUBLE
61890: LD_VAR 0 4
61894: INC
61895: ST_TO_ADDR
61896: LD_VAR 0 13
61900: PUSH
61901: FOR_DOWNTO
61902: IFFALSE 61926
// tmp := Delete ( tmp , tmp ) ;
61904: LD_ADDR_VAR 0 4
61908: PUSH
61909: LD_VAR 0 4
61913: PPUSH
61914: LD_VAR 0 4
61918: PPUSH
61919: CALL_OW 3
61923: ST_TO_ADDR
61924: GO 61901
61926: POP
61927: POP
// result := [ tmp , 0 , 0 , p ] ;
61928: LD_ADDR_VAR 0 2
61932: PUSH
61933: LD_VAR 0 4
61937: PUSH
61938: LD_INT 0
61940: PUSH
61941: LD_INT 0
61943: PUSH
61944: LD_VAR 0 11
61948: PUSH
61949: EMPTY
61950: LIST
61951: LIST
61952: LIST
61953: LIST
61954: ST_TO_ADDR
// exit ;
61955: GO 64645
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61957: LD_EXP 61
61961: PUSH
61962: LD_VAR 0 1
61966: ARRAY
61967: PPUSH
61968: LD_INT 2
61970: PUSH
61971: LD_INT 30
61973: PUSH
61974: LD_INT 6
61976: PUSH
61977: EMPTY
61978: LIST
61979: LIST
61980: PUSH
61981: LD_INT 30
61983: PUSH
61984: LD_INT 7
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: PUSH
61991: LD_INT 30
61993: PUSH
61994: LD_INT 8
61996: PUSH
61997: EMPTY
61998: LIST
61999: LIST
62000: PUSH
62001: EMPTY
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: PPUSH
62007: CALL_OW 72
62011: NOT
62012: PUSH
62013: LD_EXP 61
62017: PUSH
62018: LD_VAR 0 1
62022: ARRAY
62023: PPUSH
62024: LD_INT 30
62026: PUSH
62027: LD_INT 3
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: PPUSH
62034: CALL_OW 72
62038: NOT
62039: AND
62040: IFFALSE 62112
// begin if eng = tmp then
62042: LD_VAR 0 6
62046: PUSH
62047: LD_VAR 0 4
62051: EQUAL
62052: IFFALSE 62056
// exit ;
62054: GO 64645
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62056: LD_ADDR_EXP 103
62060: PUSH
62061: LD_EXP 103
62065: PPUSH
62066: LD_VAR 0 1
62070: PPUSH
62071: LD_INT 1
62073: PPUSH
62074: CALL_OW 1
62078: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62079: LD_ADDR_VAR 0 2
62083: PUSH
62084: LD_INT 0
62086: PUSH
62087: LD_VAR 0 4
62091: PUSH
62092: LD_VAR 0 6
62096: DIFF
62097: PUSH
62098: LD_INT 0
62100: PUSH
62101: LD_INT 0
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: ST_TO_ADDR
// exit ;
62110: GO 64645
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62112: LD_EXP 88
62116: PUSH
62117: LD_EXP 87
62121: PUSH
62122: LD_VAR 0 1
62126: ARRAY
62127: ARRAY
62128: PUSH
62129: LD_EXP 61
62133: PUSH
62134: LD_VAR 0 1
62138: ARRAY
62139: PPUSH
62140: LD_INT 2
62142: PUSH
62143: LD_INT 30
62145: PUSH
62146: LD_INT 6
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PUSH
62153: LD_INT 30
62155: PUSH
62156: LD_INT 7
62158: PUSH
62159: EMPTY
62160: LIST
62161: LIST
62162: PUSH
62163: LD_INT 30
62165: PUSH
62166: LD_INT 8
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: PPUSH
62179: CALL_OW 72
62183: AND
62184: PUSH
62185: LD_EXP 61
62189: PUSH
62190: LD_VAR 0 1
62194: ARRAY
62195: PPUSH
62196: LD_INT 30
62198: PUSH
62199: LD_INT 3
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PPUSH
62206: CALL_OW 72
62210: NOT
62211: AND
62212: IFFALSE 62426
// begin if sci >= 6 then
62214: LD_VAR 0 8
62218: PUSH
62219: LD_INT 6
62221: GREATEREQUAL
62222: IFFALSE 62226
// exit ;
62224: GO 64645
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62226: LD_ADDR_EXP 103
62230: PUSH
62231: LD_EXP 103
62235: PPUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: LD_INT 2
62243: PPUSH
62244: CALL_OW 1
62248: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62249: LD_ADDR_VAR 0 9
62253: PUSH
62254: LD_VAR 0 4
62258: PUSH
62259: LD_VAR 0 8
62263: DIFF
62264: PPUSH
62265: LD_INT 4
62267: PPUSH
62268: CALL 50759 0 2
62272: ST_TO_ADDR
// p := [ ] ;
62273: LD_ADDR_VAR 0 11
62277: PUSH
62278: EMPTY
62279: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62280: LD_VAR 0 8
62284: PUSH
62285: LD_INT 6
62287: LESS
62288: PUSH
62289: LD_VAR 0 9
62293: PUSH
62294: LD_INT 6
62296: GREATER
62297: AND
62298: IFFALSE 62379
// begin for i = 1 to 6 - sci do
62300: LD_ADDR_VAR 0 3
62304: PUSH
62305: DOUBLE
62306: LD_INT 1
62308: DEC
62309: ST_TO_ADDR
62310: LD_INT 6
62312: PUSH
62313: LD_VAR 0 8
62317: MINUS
62318: PUSH
62319: FOR_TO
62320: IFFALSE 62375
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62322: LD_ADDR_VAR 0 11
62326: PUSH
62327: LD_VAR 0 11
62331: PPUSH
62332: LD_VAR 0 11
62336: PUSH
62337: LD_INT 1
62339: PLUS
62340: PPUSH
62341: LD_VAR 0 9
62345: PUSH
62346: LD_INT 1
62348: ARRAY
62349: PPUSH
62350: CALL_OW 2
62354: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62355: LD_ADDR_VAR 0 9
62359: PUSH
62360: LD_VAR 0 9
62364: PPUSH
62365: LD_INT 1
62367: PPUSH
62368: CALL_OW 3
62372: ST_TO_ADDR
// end ;
62373: GO 62319
62375: POP
62376: POP
// end else
62377: GO 62399
// if sort then
62379: LD_VAR 0 9
62383: IFFALSE 62399
// p := sort [ 1 ] ;
62385: LD_ADDR_VAR 0 11
62389: PUSH
62390: LD_VAR 0 9
62394: PUSH
62395: LD_INT 1
62397: ARRAY
62398: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62399: LD_ADDR_VAR 0 2
62403: PUSH
62404: LD_INT 0
62406: PUSH
62407: LD_INT 0
62409: PUSH
62410: LD_INT 0
62412: PUSH
62413: LD_VAR 0 11
62417: PUSH
62418: EMPTY
62419: LIST
62420: LIST
62421: LIST
62422: LIST
62423: ST_TO_ADDR
// exit ;
62424: GO 64645
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62426: LD_EXP 88
62430: PUSH
62431: LD_EXP 87
62435: PUSH
62436: LD_VAR 0 1
62440: ARRAY
62441: ARRAY
62442: PUSH
62443: LD_EXP 61
62447: PUSH
62448: LD_VAR 0 1
62452: ARRAY
62453: PPUSH
62454: LD_INT 2
62456: PUSH
62457: LD_INT 30
62459: PUSH
62460: LD_INT 6
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: PUSH
62467: LD_INT 30
62469: PUSH
62470: LD_INT 7
62472: PUSH
62473: EMPTY
62474: LIST
62475: LIST
62476: PUSH
62477: LD_INT 30
62479: PUSH
62480: LD_INT 8
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: LIST
62491: LIST
62492: PPUSH
62493: CALL_OW 72
62497: AND
62498: PUSH
62499: LD_EXP 61
62503: PUSH
62504: LD_VAR 0 1
62508: ARRAY
62509: PPUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 3
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PPUSH
62520: CALL_OW 72
62524: AND
62525: IFFALSE 63259
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62527: LD_ADDR_EXP 103
62531: PUSH
62532: LD_EXP 103
62536: PPUSH
62537: LD_VAR 0 1
62541: PPUSH
62542: LD_INT 3
62544: PPUSH
62545: CALL_OW 1
62549: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62550: LD_ADDR_VAR 0 2
62554: PUSH
62555: LD_INT 0
62557: PUSH
62558: LD_INT 0
62560: PUSH
62561: LD_INT 0
62563: PUSH
62564: LD_INT 0
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: LIST
62571: LIST
62572: ST_TO_ADDR
// if not eng then
62573: LD_VAR 0 6
62577: NOT
62578: IFFALSE 62641
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62580: LD_ADDR_VAR 0 11
62584: PUSH
62585: LD_VAR 0 4
62589: PPUSH
62590: LD_INT 2
62592: PPUSH
62593: CALL 50759 0 2
62597: PUSH
62598: LD_INT 1
62600: ARRAY
62601: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62602: LD_ADDR_VAR 0 2
62606: PUSH
62607: LD_VAR 0 2
62611: PPUSH
62612: LD_INT 2
62614: PPUSH
62615: LD_VAR 0 11
62619: PPUSH
62620: CALL_OW 1
62624: ST_TO_ADDR
// tmp := tmp diff p ;
62625: LD_ADDR_VAR 0 4
62629: PUSH
62630: LD_VAR 0 4
62634: PUSH
62635: LD_VAR 0 11
62639: DIFF
62640: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62641: LD_VAR 0 4
62645: PUSH
62646: LD_VAR 0 8
62650: PUSH
62651: LD_INT 6
62653: LESS
62654: AND
62655: IFFALSE 62843
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62657: LD_ADDR_VAR 0 9
62661: PUSH
62662: LD_VAR 0 4
62666: PUSH
62667: LD_VAR 0 8
62671: PUSH
62672: LD_VAR 0 7
62676: UNION
62677: DIFF
62678: PPUSH
62679: LD_INT 4
62681: PPUSH
62682: CALL 50759 0 2
62686: ST_TO_ADDR
// p := [ ] ;
62687: LD_ADDR_VAR 0 11
62691: PUSH
62692: EMPTY
62693: ST_TO_ADDR
// if sort then
62694: LD_VAR 0 9
62698: IFFALSE 62814
// for i = 1 to 6 - sci do
62700: LD_ADDR_VAR 0 3
62704: PUSH
62705: DOUBLE
62706: LD_INT 1
62708: DEC
62709: ST_TO_ADDR
62710: LD_INT 6
62712: PUSH
62713: LD_VAR 0 8
62717: MINUS
62718: PUSH
62719: FOR_TO
62720: IFFALSE 62812
// begin if i = sort then
62722: LD_VAR 0 3
62726: PUSH
62727: LD_VAR 0 9
62731: EQUAL
62732: IFFALSE 62736
// break ;
62734: GO 62812
// if GetClass ( i ) = 4 then
62736: LD_VAR 0 3
62740: PPUSH
62741: CALL_OW 257
62745: PUSH
62746: LD_INT 4
62748: EQUAL
62749: IFFALSE 62753
// continue ;
62751: GO 62719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62753: LD_ADDR_VAR 0 11
62757: PUSH
62758: LD_VAR 0 11
62762: PPUSH
62763: LD_VAR 0 11
62767: PUSH
62768: LD_INT 1
62770: PLUS
62771: PPUSH
62772: LD_VAR 0 9
62776: PUSH
62777: LD_VAR 0 3
62781: ARRAY
62782: PPUSH
62783: CALL_OW 2
62787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62788: LD_ADDR_VAR 0 4
62792: PUSH
62793: LD_VAR 0 4
62797: PUSH
62798: LD_VAR 0 9
62802: PUSH
62803: LD_VAR 0 3
62807: ARRAY
62808: DIFF
62809: ST_TO_ADDR
// end ;
62810: GO 62719
62812: POP
62813: POP
// if p then
62814: LD_VAR 0 11
62818: IFFALSE 62843
// result := Replace ( result , 4 , p ) ;
62820: LD_ADDR_VAR 0 2
62824: PUSH
62825: LD_VAR 0 2
62829: PPUSH
62830: LD_INT 4
62832: PPUSH
62833: LD_VAR 0 11
62837: PPUSH
62838: CALL_OW 1
62842: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62843: LD_VAR 0 4
62847: PUSH
62848: LD_VAR 0 7
62852: PUSH
62853: LD_INT 6
62855: LESS
62856: AND
62857: IFFALSE 63045
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62859: LD_ADDR_VAR 0 9
62863: PUSH
62864: LD_VAR 0 4
62868: PUSH
62869: LD_VAR 0 8
62873: PUSH
62874: LD_VAR 0 7
62878: UNION
62879: DIFF
62880: PPUSH
62881: LD_INT 3
62883: PPUSH
62884: CALL 50759 0 2
62888: ST_TO_ADDR
// p := [ ] ;
62889: LD_ADDR_VAR 0 11
62893: PUSH
62894: EMPTY
62895: ST_TO_ADDR
// if sort then
62896: LD_VAR 0 9
62900: IFFALSE 63016
// for i = 1 to 6 - mech do
62902: LD_ADDR_VAR 0 3
62906: PUSH
62907: DOUBLE
62908: LD_INT 1
62910: DEC
62911: ST_TO_ADDR
62912: LD_INT 6
62914: PUSH
62915: LD_VAR 0 7
62919: MINUS
62920: PUSH
62921: FOR_TO
62922: IFFALSE 63014
// begin if i = sort then
62924: LD_VAR 0 3
62928: PUSH
62929: LD_VAR 0 9
62933: EQUAL
62934: IFFALSE 62938
// break ;
62936: GO 63014
// if GetClass ( i ) = 3 then
62938: LD_VAR 0 3
62942: PPUSH
62943: CALL_OW 257
62947: PUSH
62948: LD_INT 3
62950: EQUAL
62951: IFFALSE 62955
// continue ;
62953: GO 62921
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62955: LD_ADDR_VAR 0 11
62959: PUSH
62960: LD_VAR 0 11
62964: PPUSH
62965: LD_VAR 0 11
62969: PUSH
62970: LD_INT 1
62972: PLUS
62973: PPUSH
62974: LD_VAR 0 9
62978: PUSH
62979: LD_VAR 0 3
62983: ARRAY
62984: PPUSH
62985: CALL_OW 2
62989: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62990: LD_ADDR_VAR 0 4
62994: PUSH
62995: LD_VAR 0 4
62999: PUSH
63000: LD_VAR 0 9
63004: PUSH
63005: LD_VAR 0 3
63009: ARRAY
63010: DIFF
63011: ST_TO_ADDR
// end ;
63012: GO 62921
63014: POP
63015: POP
// if p then
63016: LD_VAR 0 11
63020: IFFALSE 63045
// result := Replace ( result , 3 , p ) ;
63022: LD_ADDR_VAR 0 2
63026: PUSH
63027: LD_VAR 0 2
63031: PPUSH
63032: LD_INT 3
63034: PPUSH
63035: LD_VAR 0 11
63039: PPUSH
63040: CALL_OW 1
63044: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63045: LD_VAR 0 4
63049: PUSH
63050: LD_INT 6
63052: GREATER
63053: PUSH
63054: LD_VAR 0 6
63058: PUSH
63059: LD_INT 6
63061: LESS
63062: AND
63063: IFFALSE 63257
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63065: LD_ADDR_VAR 0 9
63069: PUSH
63070: LD_VAR 0 4
63074: PUSH
63075: LD_VAR 0 8
63079: PUSH
63080: LD_VAR 0 7
63084: UNION
63085: PUSH
63086: LD_VAR 0 6
63090: UNION
63091: DIFF
63092: PPUSH
63093: LD_INT 2
63095: PPUSH
63096: CALL 50759 0 2
63100: ST_TO_ADDR
// p := [ ] ;
63101: LD_ADDR_VAR 0 11
63105: PUSH
63106: EMPTY
63107: ST_TO_ADDR
// if sort then
63108: LD_VAR 0 9
63112: IFFALSE 63228
// for i = 1 to 6 - eng do
63114: LD_ADDR_VAR 0 3
63118: PUSH
63119: DOUBLE
63120: LD_INT 1
63122: DEC
63123: ST_TO_ADDR
63124: LD_INT 6
63126: PUSH
63127: LD_VAR 0 6
63131: MINUS
63132: PUSH
63133: FOR_TO
63134: IFFALSE 63226
// begin if i = sort then
63136: LD_VAR 0 3
63140: PUSH
63141: LD_VAR 0 9
63145: EQUAL
63146: IFFALSE 63150
// break ;
63148: GO 63226
// if GetClass ( i ) = 2 then
63150: LD_VAR 0 3
63154: PPUSH
63155: CALL_OW 257
63159: PUSH
63160: LD_INT 2
63162: EQUAL
63163: IFFALSE 63167
// continue ;
63165: GO 63133
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63167: LD_ADDR_VAR 0 11
63171: PUSH
63172: LD_VAR 0 11
63176: PPUSH
63177: LD_VAR 0 11
63181: PUSH
63182: LD_INT 1
63184: PLUS
63185: PPUSH
63186: LD_VAR 0 9
63190: PUSH
63191: LD_VAR 0 3
63195: ARRAY
63196: PPUSH
63197: CALL_OW 2
63201: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63202: LD_ADDR_VAR 0 4
63206: PUSH
63207: LD_VAR 0 4
63211: PUSH
63212: LD_VAR 0 9
63216: PUSH
63217: LD_VAR 0 3
63221: ARRAY
63222: DIFF
63223: ST_TO_ADDR
// end ;
63224: GO 63133
63226: POP
63227: POP
// if p then
63228: LD_VAR 0 11
63232: IFFALSE 63257
// result := Replace ( result , 2 , p ) ;
63234: LD_ADDR_VAR 0 2
63238: PUSH
63239: LD_VAR 0 2
63243: PPUSH
63244: LD_INT 2
63246: PPUSH
63247: LD_VAR 0 11
63251: PPUSH
63252: CALL_OW 1
63256: ST_TO_ADDR
// end ; exit ;
63257: GO 64645
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63259: LD_EXP 88
63263: PUSH
63264: LD_EXP 87
63268: PUSH
63269: LD_VAR 0 1
63273: ARRAY
63274: ARRAY
63275: NOT
63276: PUSH
63277: LD_EXP 61
63281: PUSH
63282: LD_VAR 0 1
63286: ARRAY
63287: PPUSH
63288: LD_INT 30
63290: PUSH
63291: LD_INT 3
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PPUSH
63298: CALL_OW 72
63302: AND
63303: PUSH
63304: LD_EXP 66
63308: PUSH
63309: LD_VAR 0 1
63313: ARRAY
63314: AND
63315: IFFALSE 63923
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63317: LD_ADDR_EXP 103
63321: PUSH
63322: LD_EXP 103
63326: PPUSH
63327: LD_VAR 0 1
63331: PPUSH
63332: LD_INT 5
63334: PPUSH
63335: CALL_OW 1
63339: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63340: LD_ADDR_VAR 0 2
63344: PUSH
63345: LD_INT 0
63347: PUSH
63348: LD_INT 0
63350: PUSH
63351: LD_INT 0
63353: PUSH
63354: LD_INT 0
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: ST_TO_ADDR
// if sci > 1 then
63363: LD_VAR 0 8
63367: PUSH
63368: LD_INT 1
63370: GREATER
63371: IFFALSE 63399
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63373: LD_ADDR_VAR 0 4
63377: PUSH
63378: LD_VAR 0 4
63382: PUSH
63383: LD_VAR 0 8
63387: PUSH
63388: LD_VAR 0 8
63392: PUSH
63393: LD_INT 1
63395: ARRAY
63396: DIFF
63397: DIFF
63398: ST_TO_ADDR
// if tmp and not sci then
63399: LD_VAR 0 4
63403: PUSH
63404: LD_VAR 0 8
63408: NOT
63409: AND
63410: IFFALSE 63479
// begin sort := SortBySkill ( tmp , 4 ) ;
63412: LD_ADDR_VAR 0 9
63416: PUSH
63417: LD_VAR 0 4
63421: PPUSH
63422: LD_INT 4
63424: PPUSH
63425: CALL 50759 0 2
63429: ST_TO_ADDR
// if sort then
63430: LD_VAR 0 9
63434: IFFALSE 63450
// p := sort [ 1 ] ;
63436: LD_ADDR_VAR 0 11
63440: PUSH
63441: LD_VAR 0 9
63445: PUSH
63446: LD_INT 1
63448: ARRAY
63449: ST_TO_ADDR
// if p then
63450: LD_VAR 0 11
63454: IFFALSE 63479
// result := Replace ( result , 4 , p ) ;
63456: LD_ADDR_VAR 0 2
63460: PUSH
63461: LD_VAR 0 2
63465: PPUSH
63466: LD_INT 4
63468: PPUSH
63469: LD_VAR 0 11
63473: PPUSH
63474: CALL_OW 1
63478: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63479: LD_ADDR_VAR 0 4
63483: PUSH
63484: LD_VAR 0 4
63488: PUSH
63489: LD_VAR 0 7
63493: DIFF
63494: ST_TO_ADDR
// if tmp and mech < 6 then
63495: LD_VAR 0 4
63499: PUSH
63500: LD_VAR 0 7
63504: PUSH
63505: LD_INT 6
63507: LESS
63508: AND
63509: IFFALSE 63697
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63511: LD_ADDR_VAR 0 9
63515: PUSH
63516: LD_VAR 0 4
63520: PUSH
63521: LD_VAR 0 8
63525: PUSH
63526: LD_VAR 0 7
63530: UNION
63531: DIFF
63532: PPUSH
63533: LD_INT 3
63535: PPUSH
63536: CALL 50759 0 2
63540: ST_TO_ADDR
// p := [ ] ;
63541: LD_ADDR_VAR 0 11
63545: PUSH
63546: EMPTY
63547: ST_TO_ADDR
// if sort then
63548: LD_VAR 0 9
63552: IFFALSE 63668
// for i = 1 to 6 - mech do
63554: LD_ADDR_VAR 0 3
63558: PUSH
63559: DOUBLE
63560: LD_INT 1
63562: DEC
63563: ST_TO_ADDR
63564: LD_INT 6
63566: PUSH
63567: LD_VAR 0 7
63571: MINUS
63572: PUSH
63573: FOR_TO
63574: IFFALSE 63666
// begin if i = sort then
63576: LD_VAR 0 3
63580: PUSH
63581: LD_VAR 0 9
63585: EQUAL
63586: IFFALSE 63590
// break ;
63588: GO 63666
// if GetClass ( i ) = 3 then
63590: LD_VAR 0 3
63594: PPUSH
63595: CALL_OW 257
63599: PUSH
63600: LD_INT 3
63602: EQUAL
63603: IFFALSE 63607
// continue ;
63605: GO 63573
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63607: LD_ADDR_VAR 0 11
63611: PUSH
63612: LD_VAR 0 11
63616: PPUSH
63617: LD_VAR 0 11
63621: PUSH
63622: LD_INT 1
63624: PLUS
63625: PPUSH
63626: LD_VAR 0 9
63630: PUSH
63631: LD_VAR 0 3
63635: ARRAY
63636: PPUSH
63637: CALL_OW 2
63641: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63642: LD_ADDR_VAR 0 4
63646: PUSH
63647: LD_VAR 0 4
63651: PUSH
63652: LD_VAR 0 9
63656: PUSH
63657: LD_VAR 0 3
63661: ARRAY
63662: DIFF
63663: ST_TO_ADDR
// end ;
63664: GO 63573
63666: POP
63667: POP
// if p then
63668: LD_VAR 0 11
63672: IFFALSE 63697
// result := Replace ( result , 3 , p ) ;
63674: LD_ADDR_VAR 0 2
63678: PUSH
63679: LD_VAR 0 2
63683: PPUSH
63684: LD_INT 3
63686: PPUSH
63687: LD_VAR 0 11
63691: PPUSH
63692: CALL_OW 1
63696: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63697: LD_ADDR_VAR 0 4
63701: PUSH
63702: LD_VAR 0 4
63706: PUSH
63707: LD_VAR 0 6
63711: DIFF
63712: ST_TO_ADDR
// if tmp and eng < 6 then
63713: LD_VAR 0 4
63717: PUSH
63718: LD_VAR 0 6
63722: PUSH
63723: LD_INT 6
63725: LESS
63726: AND
63727: IFFALSE 63921
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63729: LD_ADDR_VAR 0 9
63733: PUSH
63734: LD_VAR 0 4
63738: PUSH
63739: LD_VAR 0 8
63743: PUSH
63744: LD_VAR 0 7
63748: UNION
63749: PUSH
63750: LD_VAR 0 6
63754: UNION
63755: DIFF
63756: PPUSH
63757: LD_INT 2
63759: PPUSH
63760: CALL 50759 0 2
63764: ST_TO_ADDR
// p := [ ] ;
63765: LD_ADDR_VAR 0 11
63769: PUSH
63770: EMPTY
63771: ST_TO_ADDR
// if sort then
63772: LD_VAR 0 9
63776: IFFALSE 63892
// for i = 1 to 6 - eng do
63778: LD_ADDR_VAR 0 3
63782: PUSH
63783: DOUBLE
63784: LD_INT 1
63786: DEC
63787: ST_TO_ADDR
63788: LD_INT 6
63790: PUSH
63791: LD_VAR 0 6
63795: MINUS
63796: PUSH
63797: FOR_TO
63798: IFFALSE 63890
// begin if i = sort then
63800: LD_VAR 0 3
63804: PUSH
63805: LD_VAR 0 9
63809: EQUAL
63810: IFFALSE 63814
// break ;
63812: GO 63890
// if GetClass ( i ) = 2 then
63814: LD_VAR 0 3
63818: PPUSH
63819: CALL_OW 257
63823: PUSH
63824: LD_INT 2
63826: EQUAL
63827: IFFALSE 63831
// continue ;
63829: GO 63797
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63831: LD_ADDR_VAR 0 11
63835: PUSH
63836: LD_VAR 0 11
63840: PPUSH
63841: LD_VAR 0 11
63845: PUSH
63846: LD_INT 1
63848: PLUS
63849: PPUSH
63850: LD_VAR 0 9
63854: PUSH
63855: LD_VAR 0 3
63859: ARRAY
63860: PPUSH
63861: CALL_OW 2
63865: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63866: LD_ADDR_VAR 0 4
63870: PUSH
63871: LD_VAR 0 4
63875: PUSH
63876: LD_VAR 0 9
63880: PUSH
63881: LD_VAR 0 3
63885: ARRAY
63886: DIFF
63887: ST_TO_ADDR
// end ;
63888: GO 63797
63890: POP
63891: POP
// if p then
63892: LD_VAR 0 11
63896: IFFALSE 63921
// result := Replace ( result , 2 , p ) ;
63898: LD_ADDR_VAR 0 2
63902: PUSH
63903: LD_VAR 0 2
63907: PPUSH
63908: LD_INT 2
63910: PPUSH
63911: LD_VAR 0 11
63915: PPUSH
63916: CALL_OW 1
63920: ST_TO_ADDR
// end ; exit ;
63921: GO 64645
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63923: LD_EXP 88
63927: PUSH
63928: LD_EXP 87
63932: PUSH
63933: LD_VAR 0 1
63937: ARRAY
63938: ARRAY
63939: NOT
63940: PUSH
63941: LD_EXP 61
63945: PUSH
63946: LD_VAR 0 1
63950: ARRAY
63951: PPUSH
63952: LD_INT 30
63954: PUSH
63955: LD_INT 3
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PPUSH
63962: CALL_OW 72
63966: AND
63967: PUSH
63968: LD_EXP 66
63972: PUSH
63973: LD_VAR 0 1
63977: ARRAY
63978: NOT
63979: AND
63980: IFFALSE 64645
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63982: LD_ADDR_EXP 103
63986: PUSH
63987: LD_EXP 103
63991: PPUSH
63992: LD_VAR 0 1
63996: PPUSH
63997: LD_INT 6
63999: PPUSH
64000: CALL_OW 1
64004: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64005: LD_ADDR_VAR 0 2
64009: PUSH
64010: LD_INT 0
64012: PUSH
64013: LD_INT 0
64015: PUSH
64016: LD_INT 0
64018: PUSH
64019: LD_INT 0
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: LIST
64026: LIST
64027: ST_TO_ADDR
// if sci >= 1 then
64028: LD_VAR 0 8
64032: PUSH
64033: LD_INT 1
64035: GREATEREQUAL
64036: IFFALSE 64058
// tmp := tmp diff sci [ 1 ] ;
64038: LD_ADDR_VAR 0 4
64042: PUSH
64043: LD_VAR 0 4
64047: PUSH
64048: LD_VAR 0 8
64052: PUSH
64053: LD_INT 1
64055: ARRAY
64056: DIFF
64057: ST_TO_ADDR
// if tmp and not sci then
64058: LD_VAR 0 4
64062: PUSH
64063: LD_VAR 0 8
64067: NOT
64068: AND
64069: IFFALSE 64138
// begin sort := SortBySkill ( tmp , 4 ) ;
64071: LD_ADDR_VAR 0 9
64075: PUSH
64076: LD_VAR 0 4
64080: PPUSH
64081: LD_INT 4
64083: PPUSH
64084: CALL 50759 0 2
64088: ST_TO_ADDR
// if sort then
64089: LD_VAR 0 9
64093: IFFALSE 64109
// p := sort [ 1 ] ;
64095: LD_ADDR_VAR 0 11
64099: PUSH
64100: LD_VAR 0 9
64104: PUSH
64105: LD_INT 1
64107: ARRAY
64108: ST_TO_ADDR
// if p then
64109: LD_VAR 0 11
64113: IFFALSE 64138
// result := Replace ( result , 4 , p ) ;
64115: LD_ADDR_VAR 0 2
64119: PUSH
64120: LD_VAR 0 2
64124: PPUSH
64125: LD_INT 4
64127: PPUSH
64128: LD_VAR 0 11
64132: PPUSH
64133: CALL_OW 1
64137: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64138: LD_ADDR_VAR 0 4
64142: PUSH
64143: LD_VAR 0 4
64147: PUSH
64148: LD_VAR 0 7
64152: DIFF
64153: ST_TO_ADDR
// if tmp and mech < 6 then
64154: LD_VAR 0 4
64158: PUSH
64159: LD_VAR 0 7
64163: PUSH
64164: LD_INT 6
64166: LESS
64167: AND
64168: IFFALSE 64350
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64170: LD_ADDR_VAR 0 9
64174: PUSH
64175: LD_VAR 0 4
64179: PUSH
64180: LD_VAR 0 7
64184: DIFF
64185: PPUSH
64186: LD_INT 3
64188: PPUSH
64189: CALL 50759 0 2
64193: ST_TO_ADDR
// p := [ ] ;
64194: LD_ADDR_VAR 0 11
64198: PUSH
64199: EMPTY
64200: ST_TO_ADDR
// if sort then
64201: LD_VAR 0 9
64205: IFFALSE 64321
// for i = 1 to 6 - mech do
64207: LD_ADDR_VAR 0 3
64211: PUSH
64212: DOUBLE
64213: LD_INT 1
64215: DEC
64216: ST_TO_ADDR
64217: LD_INT 6
64219: PUSH
64220: LD_VAR 0 7
64224: MINUS
64225: PUSH
64226: FOR_TO
64227: IFFALSE 64319
// begin if i = sort then
64229: LD_VAR 0 3
64233: PUSH
64234: LD_VAR 0 9
64238: EQUAL
64239: IFFALSE 64243
// break ;
64241: GO 64319
// if GetClass ( i ) = 3 then
64243: LD_VAR 0 3
64247: PPUSH
64248: CALL_OW 257
64252: PUSH
64253: LD_INT 3
64255: EQUAL
64256: IFFALSE 64260
// continue ;
64258: GO 64226
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64260: LD_ADDR_VAR 0 11
64264: PUSH
64265: LD_VAR 0 11
64269: PPUSH
64270: LD_VAR 0 11
64274: PUSH
64275: LD_INT 1
64277: PLUS
64278: PPUSH
64279: LD_VAR 0 9
64283: PUSH
64284: LD_VAR 0 3
64288: ARRAY
64289: PPUSH
64290: CALL_OW 2
64294: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64295: LD_ADDR_VAR 0 4
64299: PUSH
64300: LD_VAR 0 4
64304: PUSH
64305: LD_VAR 0 9
64309: PUSH
64310: LD_VAR 0 3
64314: ARRAY
64315: DIFF
64316: ST_TO_ADDR
// end ;
64317: GO 64226
64319: POP
64320: POP
// if p then
64321: LD_VAR 0 11
64325: IFFALSE 64350
// result := Replace ( result , 3 , p ) ;
64327: LD_ADDR_VAR 0 2
64331: PUSH
64332: LD_VAR 0 2
64336: PPUSH
64337: LD_INT 3
64339: PPUSH
64340: LD_VAR 0 11
64344: PPUSH
64345: CALL_OW 1
64349: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64350: LD_ADDR_VAR 0 4
64354: PUSH
64355: LD_VAR 0 4
64359: PUSH
64360: LD_VAR 0 6
64364: DIFF
64365: ST_TO_ADDR
// if tmp and eng < 4 then
64366: LD_VAR 0 4
64370: PUSH
64371: LD_VAR 0 6
64375: PUSH
64376: LD_INT 4
64378: LESS
64379: AND
64380: IFFALSE 64570
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64382: LD_ADDR_VAR 0 9
64386: PUSH
64387: LD_VAR 0 4
64391: PUSH
64392: LD_VAR 0 7
64396: PUSH
64397: LD_VAR 0 6
64401: UNION
64402: DIFF
64403: PPUSH
64404: LD_INT 2
64406: PPUSH
64407: CALL 50759 0 2
64411: ST_TO_ADDR
// p := [ ] ;
64412: LD_ADDR_VAR 0 11
64416: PUSH
64417: EMPTY
64418: ST_TO_ADDR
// if sort then
64419: LD_VAR 0 9
64423: IFFALSE 64539
// for i = 1 to 4 - eng do
64425: LD_ADDR_VAR 0 3
64429: PUSH
64430: DOUBLE
64431: LD_INT 1
64433: DEC
64434: ST_TO_ADDR
64435: LD_INT 4
64437: PUSH
64438: LD_VAR 0 6
64442: MINUS
64443: PUSH
64444: FOR_TO
64445: IFFALSE 64537
// begin if i = sort then
64447: LD_VAR 0 3
64451: PUSH
64452: LD_VAR 0 9
64456: EQUAL
64457: IFFALSE 64461
// break ;
64459: GO 64537
// if GetClass ( i ) = 2 then
64461: LD_VAR 0 3
64465: PPUSH
64466: CALL_OW 257
64470: PUSH
64471: LD_INT 2
64473: EQUAL
64474: IFFALSE 64478
// continue ;
64476: GO 64444
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64478: LD_ADDR_VAR 0 11
64482: PUSH
64483: LD_VAR 0 11
64487: PPUSH
64488: LD_VAR 0 11
64492: PUSH
64493: LD_INT 1
64495: PLUS
64496: PPUSH
64497: LD_VAR 0 9
64501: PUSH
64502: LD_VAR 0 3
64506: ARRAY
64507: PPUSH
64508: CALL_OW 2
64512: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64513: LD_ADDR_VAR 0 4
64517: PUSH
64518: LD_VAR 0 4
64522: PUSH
64523: LD_VAR 0 9
64527: PUSH
64528: LD_VAR 0 3
64532: ARRAY
64533: DIFF
64534: ST_TO_ADDR
// end ;
64535: GO 64444
64537: POP
64538: POP
// if p then
64539: LD_VAR 0 11
64543: IFFALSE 64568
// result := Replace ( result , 2 , p ) ;
64545: LD_ADDR_VAR 0 2
64549: PUSH
64550: LD_VAR 0 2
64554: PPUSH
64555: LD_INT 2
64557: PPUSH
64558: LD_VAR 0 11
64562: PPUSH
64563: CALL_OW 1
64567: ST_TO_ADDR
// end else
64568: GO 64614
// for i = eng downto 5 do
64570: LD_ADDR_VAR 0 3
64574: PUSH
64575: DOUBLE
64576: LD_VAR 0 6
64580: INC
64581: ST_TO_ADDR
64582: LD_INT 5
64584: PUSH
64585: FOR_DOWNTO
64586: IFFALSE 64612
// tmp := tmp union eng [ i ] ;
64588: LD_ADDR_VAR 0 4
64592: PUSH
64593: LD_VAR 0 4
64597: PUSH
64598: LD_VAR 0 6
64602: PUSH
64603: LD_VAR 0 3
64607: ARRAY
64608: UNION
64609: ST_TO_ADDR
64610: GO 64585
64612: POP
64613: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64614: LD_ADDR_VAR 0 2
64618: PUSH
64619: LD_VAR 0 2
64623: PPUSH
64624: LD_INT 1
64626: PPUSH
64627: LD_VAR 0 4
64631: PUSH
64632: LD_VAR 0 5
64636: DIFF
64637: PPUSH
64638: CALL_OW 1
64642: ST_TO_ADDR
// exit ;
64643: GO 64645
// end ; end ;
64645: LD_VAR 0 2
64649: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64650: LD_INT 0
64652: PPUSH
64653: PPUSH
64654: PPUSH
// if not mc_bases then
64655: LD_EXP 61
64659: NOT
64660: IFFALSE 64664
// exit ;
64662: GO 64806
// for i = 1 to mc_bases do
64664: LD_ADDR_VAR 0 2
64668: PUSH
64669: DOUBLE
64670: LD_INT 1
64672: DEC
64673: ST_TO_ADDR
64674: LD_EXP 61
64678: PUSH
64679: FOR_TO
64680: IFFALSE 64797
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64682: LD_ADDR_VAR 0 3
64686: PUSH
64687: LD_EXP 61
64691: PUSH
64692: LD_VAR 0 2
64696: ARRAY
64697: PPUSH
64698: LD_INT 21
64700: PUSH
64701: LD_INT 3
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 3
64710: PUSH
64711: LD_INT 2
64713: PUSH
64714: LD_INT 30
64716: PUSH
64717: LD_INT 29
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: LD_INT 30
64726: PUSH
64727: LD_INT 30
64729: PUSH
64730: EMPTY
64731: LIST
64732: LIST
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: LIST
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 3
64745: PUSH
64746: LD_INT 24
64748: PUSH
64749: LD_INT 1000
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: LIST
64764: PPUSH
64765: CALL_OW 72
64769: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64770: LD_ADDR_EXP 62
64774: PUSH
64775: LD_EXP 62
64779: PPUSH
64780: LD_VAR 0 2
64784: PPUSH
64785: LD_VAR 0 3
64789: PPUSH
64790: CALL_OW 1
64794: ST_TO_ADDR
// end ;
64795: GO 64679
64797: POP
64798: POP
// RaiseSailEvent ( 101 ) ;
64799: LD_INT 101
64801: PPUSH
64802: CALL_OW 427
// end ;
64806: LD_VAR 0 1
64810: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64811: LD_INT 0
64813: PPUSH
64814: PPUSH
64815: PPUSH
64816: PPUSH
64817: PPUSH
64818: PPUSH
64819: PPUSH
// if not mc_bases then
64820: LD_EXP 61
64824: NOT
64825: IFFALSE 64829
// exit ;
64827: GO 65391
// for i = 1 to mc_bases do
64829: LD_ADDR_VAR 0 2
64833: PUSH
64834: DOUBLE
64835: LD_INT 1
64837: DEC
64838: ST_TO_ADDR
64839: LD_EXP 61
64843: PUSH
64844: FOR_TO
64845: IFFALSE 65382
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64847: LD_ADDR_VAR 0 5
64851: PUSH
64852: LD_EXP 61
64856: PUSH
64857: LD_VAR 0 2
64861: ARRAY
64862: PUSH
64863: LD_EXP 90
64867: PUSH
64868: LD_VAR 0 2
64872: ARRAY
64873: UNION
64874: PPUSH
64875: LD_INT 21
64877: PUSH
64878: LD_INT 1
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: LD_INT 3
64890: PUSH
64891: LD_INT 54
64893: PUSH
64894: EMPTY
64895: LIST
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PUSH
64901: LD_INT 3
64903: PUSH
64904: LD_INT 24
64906: PUSH
64907: LD_INT 1000
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: LIST
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PPUSH
64927: CALL_OW 72
64931: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64932: LD_ADDR_VAR 0 6
64936: PUSH
64937: LD_EXP 61
64941: PUSH
64942: LD_VAR 0 2
64946: ARRAY
64947: PPUSH
64948: LD_INT 21
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 1
64960: PUSH
64961: LD_INT 3
64963: PUSH
64964: LD_INT 54
64966: PUSH
64967: EMPTY
64968: LIST
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 3
64976: PUSH
64977: LD_INT 24
64979: PUSH
64980: LD_INT 250
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: LIST
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PPUSH
65000: CALL_OW 72
65004: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65005: LD_ADDR_VAR 0 7
65009: PUSH
65010: LD_VAR 0 5
65014: PUSH
65015: LD_VAR 0 6
65019: DIFF
65020: ST_TO_ADDR
// if not need_heal_1 then
65021: LD_VAR 0 6
65025: NOT
65026: IFFALSE 65059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65028: LD_ADDR_EXP 64
65032: PUSH
65033: LD_EXP 64
65037: PPUSH
65038: LD_VAR 0 2
65042: PUSH
65043: LD_INT 1
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PPUSH
65050: EMPTY
65051: PPUSH
65052: CALL 19912 0 3
65056: ST_TO_ADDR
65057: GO 65129
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65059: LD_ADDR_EXP 64
65063: PUSH
65064: LD_EXP 64
65068: PPUSH
65069: LD_VAR 0 2
65073: PUSH
65074: LD_INT 1
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PPUSH
65081: LD_EXP 64
65085: PUSH
65086: LD_VAR 0 2
65090: ARRAY
65091: PUSH
65092: LD_INT 1
65094: ARRAY
65095: PPUSH
65096: LD_INT 3
65098: PUSH
65099: LD_INT 24
65101: PUSH
65102: LD_INT 1000
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PPUSH
65113: CALL_OW 72
65117: PUSH
65118: LD_VAR 0 6
65122: UNION
65123: PPUSH
65124: CALL 19912 0 3
65128: ST_TO_ADDR
// if not need_heal_2 then
65129: LD_VAR 0 7
65133: NOT
65134: IFFALSE 65167
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65136: LD_ADDR_EXP 64
65140: PUSH
65141: LD_EXP 64
65145: PPUSH
65146: LD_VAR 0 2
65150: PUSH
65151: LD_INT 2
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PPUSH
65158: EMPTY
65159: PPUSH
65160: CALL 19912 0 3
65164: ST_TO_ADDR
65165: GO 65199
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65167: LD_ADDR_EXP 64
65171: PUSH
65172: LD_EXP 64
65176: PPUSH
65177: LD_VAR 0 2
65181: PUSH
65182: LD_INT 2
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PPUSH
65189: LD_VAR 0 7
65193: PPUSH
65194: CALL 19912 0 3
65198: ST_TO_ADDR
// if need_heal_2 then
65199: LD_VAR 0 7
65203: IFFALSE 65364
// for j in need_heal_2 do
65205: LD_ADDR_VAR 0 3
65209: PUSH
65210: LD_VAR 0 7
65214: PUSH
65215: FOR_IN
65216: IFFALSE 65362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65218: LD_ADDR_VAR 0 5
65222: PUSH
65223: LD_EXP 61
65227: PUSH
65228: LD_VAR 0 2
65232: ARRAY
65233: PPUSH
65234: LD_INT 2
65236: PUSH
65237: LD_INT 30
65239: PUSH
65240: LD_INT 6
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 30
65249: PUSH
65250: LD_INT 7
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 30
65259: PUSH
65260: LD_INT 8
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 30
65269: PUSH
65270: LD_INT 0
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 30
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: PPUSH
65295: CALL_OW 72
65299: ST_TO_ADDR
// if tmp then
65300: LD_VAR 0 5
65304: IFFALSE 65360
// begin k := NearestUnitToUnit ( tmp , j ) ;
65306: LD_ADDR_VAR 0 4
65310: PUSH
65311: LD_VAR 0 5
65315: PPUSH
65316: LD_VAR 0 3
65320: PPUSH
65321: CALL_OW 74
65325: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65326: LD_VAR 0 3
65330: PPUSH
65331: LD_VAR 0 4
65335: PPUSH
65336: CALL_OW 296
65340: PUSH
65341: LD_INT 5
65343: GREATER
65344: IFFALSE 65360
// ComMoveToNearbyEntrance ( j , k ) ;
65346: LD_VAR 0 3
65350: PPUSH
65351: LD_VAR 0 4
65355: PPUSH
65356: CALL 53119 0 2
// end ; end ;
65360: GO 65215
65362: POP
65363: POP
// if not need_heal_1 and not need_heal_2 then
65364: LD_VAR 0 6
65368: NOT
65369: PUSH
65370: LD_VAR 0 7
65374: NOT
65375: AND
65376: IFFALSE 65380
// continue ;
65378: GO 64844
// end ;
65380: GO 64844
65382: POP
65383: POP
// RaiseSailEvent ( 102 ) ;
65384: LD_INT 102
65386: PPUSH
65387: CALL_OW 427
// end ;
65391: LD_VAR 0 1
65395: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65396: LD_INT 0
65398: PPUSH
65399: PPUSH
65400: PPUSH
65401: PPUSH
65402: PPUSH
65403: PPUSH
65404: PPUSH
65405: PPUSH
// if not mc_bases then
65406: LD_EXP 61
65410: NOT
65411: IFFALSE 65415
// exit ;
65413: GO 66326
// for i = 1 to mc_bases do
65415: LD_ADDR_VAR 0 2
65419: PUSH
65420: DOUBLE
65421: LD_INT 1
65423: DEC
65424: ST_TO_ADDR
65425: LD_EXP 61
65429: PUSH
65430: FOR_TO
65431: IFFALSE 66324
// begin if not mc_building_need_repair [ i ] then
65433: LD_EXP 62
65437: PUSH
65438: LD_VAR 0 2
65442: ARRAY
65443: NOT
65444: IFFALSE 65629
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65446: LD_ADDR_VAR 0 6
65450: PUSH
65451: LD_EXP 80
65455: PUSH
65456: LD_VAR 0 2
65460: ARRAY
65461: PPUSH
65462: LD_INT 3
65464: PUSH
65465: LD_INT 24
65467: PUSH
65468: LD_INT 1000
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: PUSH
65479: LD_INT 2
65481: PUSH
65482: LD_INT 34
65484: PUSH
65485: LD_INT 13
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 34
65494: PUSH
65495: LD_INT 52
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 34
65504: PUSH
65505: LD_INT 88
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PPUSH
65522: CALL_OW 72
65526: ST_TO_ADDR
// if cranes then
65527: LD_VAR 0 6
65531: IFFALSE 65593
// for j in cranes do
65533: LD_ADDR_VAR 0 3
65537: PUSH
65538: LD_VAR 0 6
65542: PUSH
65543: FOR_IN
65544: IFFALSE 65591
// if not IsInArea ( j , mc_parking [ i ] ) then
65546: LD_VAR 0 3
65550: PPUSH
65551: LD_EXP 85
65555: PUSH
65556: LD_VAR 0 2
65560: ARRAY
65561: PPUSH
65562: CALL_OW 308
65566: NOT
65567: IFFALSE 65589
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65569: LD_VAR 0 3
65573: PPUSH
65574: LD_EXP 85
65578: PUSH
65579: LD_VAR 0 2
65583: ARRAY
65584: PPUSH
65585: CALL_OW 113
65589: GO 65543
65591: POP
65592: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65593: LD_ADDR_EXP 63
65597: PUSH
65598: LD_EXP 63
65602: PPUSH
65603: LD_VAR 0 2
65607: PPUSH
65608: EMPTY
65609: PPUSH
65610: CALL_OW 1
65614: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65615: LD_VAR 0 2
65619: PPUSH
65620: LD_INT 101
65622: PPUSH
65623: CALL 60483 0 2
// continue ;
65627: GO 65430
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65629: LD_ADDR_EXP 67
65633: PUSH
65634: LD_EXP 67
65638: PPUSH
65639: LD_VAR 0 2
65643: PPUSH
65644: EMPTY
65645: PPUSH
65646: CALL_OW 1
65650: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65651: LD_VAR 0 2
65655: PPUSH
65656: LD_INT 103
65658: PPUSH
65659: CALL 60483 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65663: LD_ADDR_VAR 0 5
65667: PUSH
65668: LD_EXP 61
65672: PUSH
65673: LD_VAR 0 2
65677: ARRAY
65678: PUSH
65679: LD_EXP 90
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: UNION
65690: PPUSH
65691: LD_INT 2
65693: PUSH
65694: LD_INT 25
65696: PUSH
65697: LD_INT 2
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 25
65706: PUSH
65707: LD_INT 16
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: LIST
65718: PUSH
65719: EMPTY
65720: LIST
65721: PPUSH
65722: CALL_OW 72
65726: ST_TO_ADDR
// if mc_need_heal [ i ] then
65727: LD_EXP 64
65731: PUSH
65732: LD_VAR 0 2
65736: ARRAY
65737: IFFALSE 65781
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65739: LD_ADDR_VAR 0 5
65743: PUSH
65744: LD_VAR 0 5
65748: PUSH
65749: LD_EXP 64
65753: PUSH
65754: LD_VAR 0 2
65758: ARRAY
65759: PUSH
65760: LD_INT 1
65762: ARRAY
65763: PUSH
65764: LD_EXP 64
65768: PUSH
65769: LD_VAR 0 2
65773: ARRAY
65774: PUSH
65775: LD_INT 2
65777: ARRAY
65778: UNION
65779: DIFF
65780: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65781: LD_ADDR_VAR 0 6
65785: PUSH
65786: LD_EXP 80
65790: PUSH
65791: LD_VAR 0 2
65795: ARRAY
65796: PPUSH
65797: LD_INT 2
65799: PUSH
65800: LD_INT 34
65802: PUSH
65803: LD_INT 13
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 34
65812: PUSH
65813: LD_INT 52
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: LD_INT 34
65822: PUSH
65823: LD_INT 88
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: PPUSH
65836: CALL_OW 72
65840: ST_TO_ADDR
// if cranes then
65841: LD_VAR 0 6
65845: IFFALSE 66013
// begin for j in cranes do
65847: LD_ADDR_VAR 0 3
65851: PUSH
65852: LD_VAR 0 6
65856: PUSH
65857: FOR_IN
65858: IFFALSE 66011
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65860: LD_VAR 0 3
65864: PPUSH
65865: CALL_OW 256
65869: PUSH
65870: LD_INT 1000
65872: EQUAL
65873: PUSH
65874: LD_VAR 0 3
65878: PPUSH
65879: CALL_OW 314
65883: NOT
65884: AND
65885: IFFALSE 65951
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
65887: LD_ADDR_VAR 0 8
65891: PUSH
65892: LD_EXP 62
65896: PUSH
65897: LD_VAR 0 2
65901: ARRAY
65902: PPUSH
65903: LD_VAR 0 3
65907: PPUSH
65908: CALL_OW 74
65912: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65913: LD_VAR 0 8
65917: PPUSH
65918: LD_INT 16
65920: PPUSH
65921: CALL 22509 0 2
65925: PUSH
65926: LD_INT 4
65928: ARRAY
65929: PUSH
65930: LD_INT 10
65932: LESS
65933: IFFALSE 65949
// ComRepairBuilding ( j , to_repair ) ;
65935: LD_VAR 0 3
65939: PPUSH
65940: LD_VAR 0 8
65944: PPUSH
65945: CALL_OW 130
// end else
65949: GO 66009
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65951: LD_VAR 0 3
65955: PPUSH
65956: CALL_OW 256
65960: PUSH
65961: LD_INT 500
65963: LESS
65964: PUSH
65965: LD_VAR 0 3
65969: PPUSH
65970: LD_EXP 85
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: PPUSH
65981: CALL_OW 308
65985: NOT
65986: AND
65987: IFFALSE 66009
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65989: LD_VAR 0 3
65993: PPUSH
65994: LD_EXP 85
65998: PUSH
65999: LD_VAR 0 2
66003: ARRAY
66004: PPUSH
66005: CALL_OW 113
// end ;
66009: GO 65857
66011: POP
66012: POP
// end ; if tmp > 3 then
66013: LD_VAR 0 5
66017: PUSH
66018: LD_INT 3
66020: GREATER
66021: IFFALSE 66041
// tmp := ShrinkArray ( tmp , 4 ) ;
66023: LD_ADDR_VAR 0 5
66027: PUSH
66028: LD_VAR 0 5
66032: PPUSH
66033: LD_INT 4
66035: PPUSH
66036: CALL 52557 0 2
66040: ST_TO_ADDR
// if not tmp then
66041: LD_VAR 0 5
66045: NOT
66046: IFFALSE 66050
// continue ;
66048: GO 65430
// for j in tmp do
66050: LD_ADDR_VAR 0 3
66054: PUSH
66055: LD_VAR 0 5
66059: PUSH
66060: FOR_IN
66061: IFFALSE 66320
// begin if IsInUnit ( j ) then
66063: LD_VAR 0 3
66067: PPUSH
66068: CALL_OW 310
66072: IFFALSE 66083
// ComExitBuilding ( j ) ;
66074: LD_VAR 0 3
66078: PPUSH
66079: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66083: LD_VAR 0 3
66087: PUSH
66088: LD_EXP 63
66092: PUSH
66093: LD_VAR 0 2
66097: ARRAY
66098: IN
66099: NOT
66100: IFFALSE 66158
// begin SetTag ( j , 101 ) ;
66102: LD_VAR 0 3
66106: PPUSH
66107: LD_INT 101
66109: PPUSH
66110: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66114: LD_ADDR_EXP 63
66118: PUSH
66119: LD_EXP 63
66123: PPUSH
66124: LD_VAR 0 2
66128: PUSH
66129: LD_EXP 63
66133: PUSH
66134: LD_VAR 0 2
66138: ARRAY
66139: PUSH
66140: LD_INT 1
66142: PLUS
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PPUSH
66148: LD_VAR 0 3
66152: PPUSH
66153: CALL 19912 0 3
66157: ST_TO_ADDR
// end ; wait ( 1 ) ;
66158: LD_INT 1
66160: PPUSH
66161: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66165: LD_ADDR_VAR 0 7
66169: PUSH
66170: LD_EXP 62
66174: PUSH
66175: LD_VAR 0 2
66179: ARRAY
66180: ST_TO_ADDR
// if mc_scan [ i ] then
66181: LD_EXP 84
66185: PUSH
66186: LD_VAR 0 2
66190: ARRAY
66191: IFFALSE 66253
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66193: LD_ADDR_VAR 0 7
66197: PUSH
66198: LD_EXP 62
66202: PUSH
66203: LD_VAR 0 2
66207: ARRAY
66208: PPUSH
66209: LD_INT 3
66211: PUSH
66212: LD_INT 30
66214: PUSH
66215: LD_INT 32
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 30
66224: PUSH
66225: LD_INT 33
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 30
66234: PUSH
66235: LD_INT 31
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: PPUSH
66248: CALL_OW 72
66252: ST_TO_ADDR
// if not to_repair_tmp then
66253: LD_VAR 0 7
66257: NOT
66258: IFFALSE 66262
// continue ;
66260: GO 66060
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66262: LD_ADDR_VAR 0 8
66266: PUSH
66267: LD_VAR 0 7
66271: PPUSH
66272: LD_VAR 0 3
66276: PPUSH
66277: CALL_OW 74
66281: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66282: LD_VAR 0 8
66286: PPUSH
66287: LD_INT 16
66289: PPUSH
66290: CALL 22509 0 2
66294: PUSH
66295: LD_INT 4
66297: ARRAY
66298: PUSH
66299: LD_INT 14
66301: LESS
66302: IFFALSE 66318
// ComRepairBuilding ( j , to_repair ) ;
66304: LD_VAR 0 3
66308: PPUSH
66309: LD_VAR 0 8
66313: PPUSH
66314: CALL_OW 130
// end ;
66318: GO 66060
66320: POP
66321: POP
// end ;
66322: GO 65430
66324: POP
66325: POP
// end ;
66326: LD_VAR 0 1
66330: RET
// export function MC_Heal ; var i , j , tmp ; begin
66331: LD_INT 0
66333: PPUSH
66334: PPUSH
66335: PPUSH
66336: PPUSH
// if not mc_bases then
66337: LD_EXP 61
66341: NOT
66342: IFFALSE 66346
// exit ;
66344: GO 66748
// for i = 1 to mc_bases do
66346: LD_ADDR_VAR 0 2
66350: PUSH
66351: DOUBLE
66352: LD_INT 1
66354: DEC
66355: ST_TO_ADDR
66356: LD_EXP 61
66360: PUSH
66361: FOR_TO
66362: IFFALSE 66746
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66364: LD_EXP 64
66368: PUSH
66369: LD_VAR 0 2
66373: ARRAY
66374: PUSH
66375: LD_INT 1
66377: ARRAY
66378: NOT
66379: PUSH
66380: LD_EXP 64
66384: PUSH
66385: LD_VAR 0 2
66389: ARRAY
66390: PUSH
66391: LD_INT 2
66393: ARRAY
66394: NOT
66395: AND
66396: IFFALSE 66434
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66398: LD_ADDR_EXP 65
66402: PUSH
66403: LD_EXP 65
66407: PPUSH
66408: LD_VAR 0 2
66412: PPUSH
66413: EMPTY
66414: PPUSH
66415: CALL_OW 1
66419: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66420: LD_VAR 0 2
66424: PPUSH
66425: LD_INT 102
66427: PPUSH
66428: CALL 60483 0 2
// continue ;
66432: GO 66361
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66434: LD_ADDR_VAR 0 4
66438: PUSH
66439: LD_EXP 61
66443: PUSH
66444: LD_VAR 0 2
66448: ARRAY
66449: PPUSH
66450: LD_INT 25
66452: PUSH
66453: LD_INT 4
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PPUSH
66460: CALL_OW 72
66464: ST_TO_ADDR
// if not tmp then
66465: LD_VAR 0 4
66469: NOT
66470: IFFALSE 66474
// continue ;
66472: GO 66361
// if mc_taming [ i ] then
66474: LD_EXP 92
66478: PUSH
66479: LD_VAR 0 2
66483: ARRAY
66484: IFFALSE 66508
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66486: LD_ADDR_EXP 92
66490: PUSH
66491: LD_EXP 92
66495: PPUSH
66496: LD_VAR 0 2
66500: PPUSH
66501: EMPTY
66502: PPUSH
66503: CALL_OW 1
66507: ST_TO_ADDR
// for j in tmp do
66508: LD_ADDR_VAR 0 3
66512: PUSH
66513: LD_VAR 0 4
66517: PUSH
66518: FOR_IN
66519: IFFALSE 66742
// begin if IsInUnit ( j ) then
66521: LD_VAR 0 3
66525: PPUSH
66526: CALL_OW 310
66530: IFFALSE 66541
// ComExitBuilding ( j ) ;
66532: LD_VAR 0 3
66536: PPUSH
66537: CALL_OW 122
// if not j in mc_healers [ i ] then
66541: LD_VAR 0 3
66545: PUSH
66546: LD_EXP 65
66550: PUSH
66551: LD_VAR 0 2
66555: ARRAY
66556: IN
66557: NOT
66558: IFFALSE 66604
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66560: LD_ADDR_EXP 65
66564: PUSH
66565: LD_EXP 65
66569: PPUSH
66570: LD_VAR 0 2
66574: PUSH
66575: LD_EXP 65
66579: PUSH
66580: LD_VAR 0 2
66584: ARRAY
66585: PUSH
66586: LD_INT 1
66588: PLUS
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PPUSH
66594: LD_VAR 0 3
66598: PPUSH
66599: CALL 19912 0 3
66603: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66604: LD_VAR 0 3
66608: PPUSH
66609: CALL_OW 110
66613: PUSH
66614: LD_INT 102
66616: NONEQUAL
66617: IFFALSE 66631
// SetTag ( j , 102 ) ;
66619: LD_VAR 0 3
66623: PPUSH
66624: LD_INT 102
66626: PPUSH
66627: CALL_OW 109
// Wait ( 3 ) ;
66631: LD_INT 3
66633: PPUSH
66634: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66638: LD_EXP 64
66642: PUSH
66643: LD_VAR 0 2
66647: ARRAY
66648: PUSH
66649: LD_INT 1
66651: ARRAY
66652: IFFALSE 66684
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66654: LD_VAR 0 3
66658: PPUSH
66659: LD_EXP 64
66663: PUSH
66664: LD_VAR 0 2
66668: ARRAY
66669: PUSH
66670: LD_INT 1
66672: ARRAY
66673: PUSH
66674: LD_INT 1
66676: ARRAY
66677: PPUSH
66678: CALL_OW 128
66682: GO 66740
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66684: LD_VAR 0 3
66688: PPUSH
66689: CALL_OW 314
66693: NOT
66694: PUSH
66695: LD_EXP 64
66699: PUSH
66700: LD_VAR 0 2
66704: ARRAY
66705: PUSH
66706: LD_INT 2
66708: ARRAY
66709: AND
66710: IFFALSE 66740
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66712: LD_VAR 0 3
66716: PPUSH
66717: LD_EXP 64
66721: PUSH
66722: LD_VAR 0 2
66726: ARRAY
66727: PUSH
66728: LD_INT 2
66730: ARRAY
66731: PUSH
66732: LD_INT 1
66734: ARRAY
66735: PPUSH
66736: CALL_OW 128
// end ;
66740: GO 66518
66742: POP
66743: POP
// end ;
66744: GO 66361
66746: POP
66747: POP
// end ;
66748: LD_VAR 0 1
66752: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
66753: LD_INT 0
66755: PPUSH
66756: PPUSH
66757: PPUSH
66758: PPUSH
66759: PPUSH
66760: PPUSH
// if not mc_bases then
66761: LD_EXP 61
66765: NOT
66766: IFFALSE 66770
// exit ;
66768: GO 67933
// for i = 1 to mc_bases do
66770: LD_ADDR_VAR 0 2
66774: PUSH
66775: DOUBLE
66776: LD_INT 1
66778: DEC
66779: ST_TO_ADDR
66780: LD_EXP 61
66784: PUSH
66785: FOR_TO
66786: IFFALSE 67931
// begin if mc_scan [ i ] then
66788: LD_EXP 84
66792: PUSH
66793: LD_VAR 0 2
66797: ARRAY
66798: IFFALSE 66802
// continue ;
66800: GO 66785
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66802: LD_EXP 66
66806: PUSH
66807: LD_VAR 0 2
66811: ARRAY
66812: NOT
66813: PUSH
66814: LD_EXP 68
66818: PUSH
66819: LD_VAR 0 2
66823: ARRAY
66824: NOT
66825: AND
66826: PUSH
66827: LD_EXP 67
66831: PUSH
66832: LD_VAR 0 2
66836: ARRAY
66837: AND
66838: IFFALSE 66876
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66840: LD_ADDR_EXP 67
66844: PUSH
66845: LD_EXP 67
66849: PPUSH
66850: LD_VAR 0 2
66854: PPUSH
66855: EMPTY
66856: PPUSH
66857: CALL_OW 1
66861: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66862: LD_VAR 0 2
66866: PPUSH
66867: LD_INT 103
66869: PPUSH
66870: CALL 60483 0 2
// continue ;
66874: GO 66785
// end ; if mc_construct_list [ i ] then
66876: LD_EXP 68
66880: PUSH
66881: LD_VAR 0 2
66885: ARRAY
66886: IFFALSE 67106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66888: LD_ADDR_VAR 0 5
66892: PUSH
66893: LD_EXP 61
66897: PUSH
66898: LD_VAR 0 2
66902: ARRAY
66903: PPUSH
66904: LD_INT 25
66906: PUSH
66907: LD_INT 2
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PPUSH
66914: CALL_OW 72
66918: PUSH
66919: LD_EXP 63
66923: PUSH
66924: LD_VAR 0 2
66928: ARRAY
66929: DIFF
66930: ST_TO_ADDR
// if not tmp then
66931: LD_VAR 0 5
66935: NOT
66936: IFFALSE 66940
// continue ;
66938: GO 66785
// for j in tmp do
66940: LD_ADDR_VAR 0 3
66944: PUSH
66945: LD_VAR 0 5
66949: PUSH
66950: FOR_IN
66951: IFFALSE 67102
// begin if not mc_builders [ i ] then
66953: LD_EXP 67
66957: PUSH
66958: LD_VAR 0 2
66962: ARRAY
66963: NOT
66964: IFFALSE 67022
// begin SetTag ( j , 103 ) ;
66966: LD_VAR 0 3
66970: PPUSH
66971: LD_INT 103
66973: PPUSH
66974: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66978: LD_ADDR_EXP 67
66982: PUSH
66983: LD_EXP 67
66987: PPUSH
66988: LD_VAR 0 2
66992: PUSH
66993: LD_EXP 67
66997: PUSH
66998: LD_VAR 0 2
67002: ARRAY
67003: PUSH
67004: LD_INT 1
67006: PLUS
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PPUSH
67012: LD_VAR 0 3
67016: PPUSH
67017: CALL 19912 0 3
67021: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67022: LD_VAR 0 3
67026: PPUSH
67027: CALL_OW 310
67031: IFFALSE 67042
// ComExitBuilding ( j ) ;
67033: LD_VAR 0 3
67037: PPUSH
67038: CALL_OW 122
// wait ( 3 ) ;
67042: LD_INT 3
67044: PPUSH
67045: CALL_OW 67
// if not mc_construct_list [ i ] then
67049: LD_EXP 68
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: NOT
67060: IFFALSE 67064
// break ;
67062: GO 67102
// if not HasTask ( j ) then
67064: LD_VAR 0 3
67068: PPUSH
67069: CALL_OW 314
67073: NOT
67074: IFFALSE 67100
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67076: LD_VAR 0 3
67080: PPUSH
67081: LD_EXP 68
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: PUSH
67092: LD_INT 1
67094: ARRAY
67095: PPUSH
67096: CALL 22773 0 2
// end ;
67100: GO 66950
67102: POP
67103: POP
// end else
67104: GO 67929
// if mc_build_list [ i ] then
67106: LD_EXP 66
67110: PUSH
67111: LD_VAR 0 2
67115: ARRAY
67116: IFFALSE 67929
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67118: LD_EXP 66
67122: PUSH
67123: LD_VAR 0 2
67127: ARRAY
67128: PUSH
67129: LD_INT 1
67131: ARRAY
67132: PUSH
67133: LD_INT 1
67135: ARRAY
67136: PPUSH
67137: CALL 22597 0 1
67141: PUSH
67142: LD_EXP 61
67146: PUSH
67147: LD_VAR 0 2
67151: ARRAY
67152: PPUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 30
67158: PUSH
67159: LD_INT 2
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 30
67168: PUSH
67169: LD_INT 3
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: LIST
67180: PPUSH
67181: CALL_OW 72
67185: NOT
67186: AND
67187: IFFALSE 67292
// begin for j = 1 to mc_build_list [ i ] do
67189: LD_ADDR_VAR 0 3
67193: PUSH
67194: DOUBLE
67195: LD_INT 1
67197: DEC
67198: ST_TO_ADDR
67199: LD_EXP 66
67203: PUSH
67204: LD_VAR 0 2
67208: ARRAY
67209: PUSH
67210: FOR_TO
67211: IFFALSE 67290
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67213: LD_EXP 66
67217: PUSH
67218: LD_VAR 0 2
67222: ARRAY
67223: PUSH
67224: LD_VAR 0 3
67228: ARRAY
67229: PUSH
67230: LD_INT 1
67232: ARRAY
67233: PUSH
67234: LD_INT 2
67236: EQUAL
67237: IFFALSE 67288
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67239: LD_ADDR_EXP 66
67243: PUSH
67244: LD_EXP 66
67248: PPUSH
67249: LD_VAR 0 2
67253: PPUSH
67254: LD_EXP 66
67258: PUSH
67259: LD_VAR 0 2
67263: ARRAY
67264: PPUSH
67265: LD_VAR 0 3
67269: PPUSH
67270: LD_INT 1
67272: PPUSH
67273: LD_INT 0
67275: PPUSH
67276: CALL 19330 0 4
67280: PPUSH
67281: CALL_OW 1
67285: ST_TO_ADDR
// break ;
67286: GO 67290
// end ;
67288: GO 67210
67290: POP
67291: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67292: LD_ADDR_VAR 0 6
67296: PUSH
67297: LD_EXP 61
67301: PUSH
67302: LD_VAR 0 2
67306: ARRAY
67307: PPUSH
67308: LD_INT 2
67310: PUSH
67311: LD_INT 30
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 30
67323: PUSH
67324: LD_INT 1
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: LIST
67335: PPUSH
67336: CALL_OW 72
67340: ST_TO_ADDR
// for k := 1 to depot do
67341: LD_ADDR_VAR 0 4
67345: PUSH
67346: DOUBLE
67347: LD_INT 1
67349: DEC
67350: ST_TO_ADDR
67351: LD_VAR 0 6
67355: PUSH
67356: FOR_TO
67357: IFFALSE 67927
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67359: LD_EXP 66
67363: PUSH
67364: LD_VAR 0 2
67368: ARRAY
67369: PUSH
67370: LD_INT 1
67372: ARRAY
67373: PUSH
67374: LD_INT 1
67376: ARRAY
67377: PUSH
67378: LD_INT 0
67380: EQUAL
67381: PUSH
67382: LD_VAR 0 6
67386: PUSH
67387: LD_VAR 0 4
67391: ARRAY
67392: PPUSH
67393: LD_EXP 66
67397: PUSH
67398: LD_VAR 0 2
67402: ARRAY
67403: PUSH
67404: LD_INT 1
67406: ARRAY
67407: PUSH
67408: LD_INT 1
67410: ARRAY
67411: PPUSH
67412: LD_EXP 66
67416: PUSH
67417: LD_VAR 0 2
67421: ARRAY
67422: PUSH
67423: LD_INT 1
67425: ARRAY
67426: PUSH
67427: LD_INT 2
67429: ARRAY
67430: PPUSH
67431: LD_EXP 66
67435: PUSH
67436: LD_VAR 0 2
67440: ARRAY
67441: PUSH
67442: LD_INT 1
67444: ARRAY
67445: PUSH
67446: LD_INT 3
67448: ARRAY
67449: PPUSH
67450: LD_EXP 66
67454: PUSH
67455: LD_VAR 0 2
67459: ARRAY
67460: PUSH
67461: LD_INT 1
67463: ARRAY
67464: PUSH
67465: LD_INT 4
67467: ARRAY
67468: PPUSH
67469: CALL 28009 0 5
67473: OR
67474: IFFALSE 67755
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67476: LD_ADDR_VAR 0 5
67480: PUSH
67481: LD_EXP 61
67485: PUSH
67486: LD_VAR 0 2
67490: ARRAY
67491: PPUSH
67492: LD_INT 25
67494: PUSH
67495: LD_INT 2
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PPUSH
67502: CALL_OW 72
67506: PUSH
67507: LD_EXP 63
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: DIFF
67518: ST_TO_ADDR
// if not tmp then
67519: LD_VAR 0 5
67523: NOT
67524: IFFALSE 67528
// continue ;
67526: GO 67356
// for j in tmp do
67528: LD_ADDR_VAR 0 3
67532: PUSH
67533: LD_VAR 0 5
67537: PUSH
67538: FOR_IN
67539: IFFALSE 67751
// begin if not mc_builders [ i ] then
67541: LD_EXP 67
67545: PUSH
67546: LD_VAR 0 2
67550: ARRAY
67551: NOT
67552: IFFALSE 67610
// begin SetTag ( j , 103 ) ;
67554: LD_VAR 0 3
67558: PPUSH
67559: LD_INT 103
67561: PPUSH
67562: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67566: LD_ADDR_EXP 67
67570: PUSH
67571: LD_EXP 67
67575: PPUSH
67576: LD_VAR 0 2
67580: PUSH
67581: LD_EXP 67
67585: PUSH
67586: LD_VAR 0 2
67590: ARRAY
67591: PUSH
67592: LD_INT 1
67594: PLUS
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PPUSH
67600: LD_VAR 0 3
67604: PPUSH
67605: CALL 19912 0 3
67609: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67610: LD_VAR 0 3
67614: PPUSH
67615: CALL_OW 310
67619: IFFALSE 67630
// ComExitBuilding ( j ) ;
67621: LD_VAR 0 3
67625: PPUSH
67626: CALL_OW 122
// wait ( 3 ) ;
67630: LD_INT 3
67632: PPUSH
67633: CALL_OW 67
// if not mc_build_list [ i ] then
67637: LD_EXP 66
67641: PUSH
67642: LD_VAR 0 2
67646: ARRAY
67647: NOT
67648: IFFALSE 67652
// break ;
67650: GO 67751
// if not HasTask ( j ) then
67652: LD_VAR 0 3
67656: PPUSH
67657: CALL_OW 314
67661: NOT
67662: IFFALSE 67749
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67664: LD_VAR 0 3
67668: PPUSH
67669: LD_EXP 66
67673: PUSH
67674: LD_VAR 0 2
67678: ARRAY
67679: PUSH
67680: LD_INT 1
67682: ARRAY
67683: PUSH
67684: LD_INT 1
67686: ARRAY
67687: PPUSH
67688: LD_EXP 66
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: PUSH
67699: LD_INT 1
67701: ARRAY
67702: PUSH
67703: LD_INT 2
67705: ARRAY
67706: PPUSH
67707: LD_EXP 66
67711: PUSH
67712: LD_VAR 0 2
67716: ARRAY
67717: PUSH
67718: LD_INT 1
67720: ARRAY
67721: PUSH
67722: LD_INT 3
67724: ARRAY
67725: PPUSH
67726: LD_EXP 66
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_INT 1
67739: ARRAY
67740: PUSH
67741: LD_INT 4
67743: ARRAY
67744: PPUSH
67745: CALL_OW 145
// end ;
67749: GO 67538
67751: POP
67752: POP
// end else
67753: GO 67925
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67755: LD_EXP 61
67759: PUSH
67760: LD_VAR 0 2
67764: ARRAY
67765: PPUSH
67766: LD_EXP 66
67770: PUSH
67771: LD_VAR 0 2
67775: ARRAY
67776: PUSH
67777: LD_INT 1
67779: ARRAY
67780: PUSH
67781: LD_INT 1
67783: ARRAY
67784: PPUSH
67785: LD_EXP 66
67789: PUSH
67790: LD_VAR 0 2
67794: ARRAY
67795: PUSH
67796: LD_INT 1
67798: ARRAY
67799: PUSH
67800: LD_INT 2
67802: ARRAY
67803: PPUSH
67804: LD_EXP 66
67808: PUSH
67809: LD_VAR 0 2
67813: ARRAY
67814: PUSH
67815: LD_INT 1
67817: ARRAY
67818: PUSH
67819: LD_INT 3
67821: ARRAY
67822: PPUSH
67823: LD_EXP 66
67827: PUSH
67828: LD_VAR 0 2
67832: ARRAY
67833: PUSH
67834: LD_INT 1
67836: ARRAY
67837: PUSH
67838: LD_INT 4
67840: ARRAY
67841: PPUSH
67842: LD_EXP 61
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PPUSH
67853: LD_INT 21
67855: PUSH
67856: LD_INT 3
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PPUSH
67863: CALL_OW 72
67867: PPUSH
67868: EMPTY
67869: PPUSH
67870: CALL 26763 0 7
67874: NOT
67875: IFFALSE 67925
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67877: LD_ADDR_EXP 66
67881: PUSH
67882: LD_EXP 66
67886: PPUSH
67887: LD_VAR 0 2
67891: PPUSH
67892: LD_EXP 66
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PPUSH
67903: LD_INT 1
67905: PPUSH
67906: LD_INT 1
67908: NEG
67909: PPUSH
67910: LD_INT 0
67912: PPUSH
67913: CALL 19330 0 4
67917: PPUSH
67918: CALL_OW 1
67922: ST_TO_ADDR
// continue ;
67923: GO 67356
// end ; end ;
67925: GO 67356
67927: POP
67928: POP
// end ; end ;
67929: GO 66785
67931: POP
67932: POP
// end ;
67933: LD_VAR 0 1
67937: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67938: LD_INT 0
67940: PPUSH
67941: PPUSH
67942: PPUSH
67943: PPUSH
67944: PPUSH
67945: PPUSH
// if not mc_bases then
67946: LD_EXP 61
67950: NOT
67951: IFFALSE 67955
// exit ;
67953: GO 68382
// for i = 1 to mc_bases do
67955: LD_ADDR_VAR 0 2
67959: PUSH
67960: DOUBLE
67961: LD_INT 1
67963: DEC
67964: ST_TO_ADDR
67965: LD_EXP 61
67969: PUSH
67970: FOR_TO
67971: IFFALSE 68380
// begin tmp := mc_build_upgrade [ i ] ;
67973: LD_ADDR_VAR 0 4
67977: PUSH
67978: LD_EXP 93
67982: PUSH
67983: LD_VAR 0 2
67987: ARRAY
67988: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67989: LD_ADDR_VAR 0 6
67993: PUSH
67994: LD_EXP 94
67998: PUSH
67999: LD_VAR 0 2
68003: ARRAY
68004: PPUSH
68005: LD_INT 2
68007: PUSH
68008: LD_INT 30
68010: PUSH
68011: LD_INT 6
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 30
68020: PUSH
68021: LD_INT 7
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: LIST
68032: PPUSH
68033: CALL_OW 72
68037: ST_TO_ADDR
// if not tmp and not lab then
68038: LD_VAR 0 4
68042: NOT
68043: PUSH
68044: LD_VAR 0 6
68048: NOT
68049: AND
68050: IFFALSE 68054
// continue ;
68052: GO 67970
// if tmp then
68054: LD_VAR 0 4
68058: IFFALSE 68178
// for j in tmp do
68060: LD_ADDR_VAR 0 3
68064: PUSH
68065: LD_VAR 0 4
68069: PUSH
68070: FOR_IN
68071: IFFALSE 68176
// begin if UpgradeCost ( j ) then
68073: LD_VAR 0 3
68077: PPUSH
68078: CALL 26423 0 1
68082: IFFALSE 68174
// begin ComUpgrade ( j ) ;
68084: LD_VAR 0 3
68088: PPUSH
68089: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68093: LD_ADDR_EXP 93
68097: PUSH
68098: LD_EXP 93
68102: PPUSH
68103: LD_VAR 0 2
68107: PPUSH
68108: LD_EXP 93
68112: PUSH
68113: LD_VAR 0 2
68117: ARRAY
68118: PUSH
68119: LD_VAR 0 3
68123: DIFF
68124: PPUSH
68125: CALL_OW 1
68129: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68130: LD_ADDR_EXP 68
68134: PUSH
68135: LD_EXP 68
68139: PPUSH
68140: LD_VAR 0 2
68144: PUSH
68145: LD_EXP 68
68149: PUSH
68150: LD_VAR 0 2
68154: ARRAY
68155: PUSH
68156: LD_INT 1
68158: PLUS
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PPUSH
68164: LD_VAR 0 3
68168: PPUSH
68169: CALL 19912 0 3
68173: ST_TO_ADDR
// end ; end ;
68174: GO 68070
68176: POP
68177: POP
// if not lab or not mc_lab_upgrade [ i ] then
68178: LD_VAR 0 6
68182: NOT
68183: PUSH
68184: LD_EXP 95
68188: PUSH
68189: LD_VAR 0 2
68193: ARRAY
68194: NOT
68195: OR
68196: IFFALSE 68200
// continue ;
68198: GO 67970
// for j in lab do
68200: LD_ADDR_VAR 0 3
68204: PUSH
68205: LD_VAR 0 6
68209: PUSH
68210: FOR_IN
68211: IFFALSE 68376
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68213: LD_VAR 0 3
68217: PPUSH
68218: CALL_OW 266
68222: PUSH
68223: LD_INT 6
68225: PUSH
68226: LD_INT 7
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: IN
68233: PUSH
68234: LD_VAR 0 3
68238: PPUSH
68239: CALL_OW 461
68243: PUSH
68244: LD_INT 1
68246: NONEQUAL
68247: AND
68248: IFFALSE 68374
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68250: LD_VAR 0 3
68254: PPUSH
68255: LD_EXP 95
68259: PUSH
68260: LD_VAR 0 2
68264: ARRAY
68265: PUSH
68266: LD_INT 1
68268: ARRAY
68269: PPUSH
68270: CALL 26628 0 2
68274: IFFALSE 68374
// begin ComCancel ( j ) ;
68276: LD_VAR 0 3
68280: PPUSH
68281: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68285: LD_VAR 0 3
68289: PPUSH
68290: LD_EXP 95
68294: PUSH
68295: LD_VAR 0 2
68299: ARRAY
68300: PUSH
68301: LD_INT 1
68303: ARRAY
68304: PPUSH
68305: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68309: LD_VAR 0 3
68313: PUSH
68314: LD_EXP 68
68318: PUSH
68319: LD_VAR 0 2
68323: ARRAY
68324: IN
68325: NOT
68326: IFFALSE 68372
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68328: LD_ADDR_EXP 68
68332: PUSH
68333: LD_EXP 68
68337: PPUSH
68338: LD_VAR 0 2
68342: PUSH
68343: LD_EXP 68
68347: PUSH
68348: LD_VAR 0 2
68352: ARRAY
68353: PUSH
68354: LD_INT 1
68356: PLUS
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PPUSH
68362: LD_VAR 0 3
68366: PPUSH
68367: CALL 19912 0 3
68371: ST_TO_ADDR
// break ;
68372: GO 68376
// end ; end ; end ;
68374: GO 68210
68376: POP
68377: POP
// end ;
68378: GO 67970
68380: POP
68381: POP
// end ;
68382: LD_VAR 0 1
68386: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68387: LD_INT 0
68389: PPUSH
68390: PPUSH
68391: PPUSH
68392: PPUSH
68393: PPUSH
68394: PPUSH
68395: PPUSH
68396: PPUSH
68397: PPUSH
// if not mc_bases then
68398: LD_EXP 61
68402: NOT
68403: IFFALSE 68407
// exit ;
68405: GO 68812
// for i = 1 to mc_bases do
68407: LD_ADDR_VAR 0 2
68411: PUSH
68412: DOUBLE
68413: LD_INT 1
68415: DEC
68416: ST_TO_ADDR
68417: LD_EXP 61
68421: PUSH
68422: FOR_TO
68423: IFFALSE 68810
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68425: LD_EXP 69
68429: PUSH
68430: LD_VAR 0 2
68434: ARRAY
68435: NOT
68436: PUSH
68437: LD_EXP 61
68441: PUSH
68442: LD_VAR 0 2
68446: ARRAY
68447: PPUSH
68448: LD_INT 30
68450: PUSH
68451: LD_INT 3
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PPUSH
68458: CALL_OW 72
68462: NOT
68463: OR
68464: IFFALSE 68468
// continue ;
68466: GO 68422
// busy := false ;
68468: LD_ADDR_VAR 0 8
68472: PUSH
68473: LD_INT 0
68475: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68476: LD_ADDR_VAR 0 4
68480: PUSH
68481: LD_EXP 61
68485: PUSH
68486: LD_VAR 0 2
68490: ARRAY
68491: PPUSH
68492: LD_INT 30
68494: PUSH
68495: LD_INT 3
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PPUSH
68502: CALL_OW 72
68506: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68507: LD_ADDR_VAR 0 6
68511: PUSH
68512: LD_EXP 69
68516: PUSH
68517: LD_VAR 0 2
68521: ARRAY
68522: PPUSH
68523: LD_INT 2
68525: PUSH
68526: LD_INT 30
68528: PUSH
68529: LD_INT 32
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: LD_INT 30
68538: PUSH
68539: LD_INT 33
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: LIST
68550: PPUSH
68551: CALL_OW 72
68555: ST_TO_ADDR
// if not t then
68556: LD_VAR 0 6
68560: NOT
68561: IFFALSE 68565
// continue ;
68563: GO 68422
// for j in tmp do
68565: LD_ADDR_VAR 0 3
68569: PUSH
68570: LD_VAR 0 4
68574: PUSH
68575: FOR_IN
68576: IFFALSE 68606
// if not BuildingStatus ( j ) = bs_idle then
68578: LD_VAR 0 3
68582: PPUSH
68583: CALL_OW 461
68587: PUSH
68588: LD_INT 2
68590: EQUAL
68591: NOT
68592: IFFALSE 68604
// begin busy := true ;
68594: LD_ADDR_VAR 0 8
68598: PUSH
68599: LD_INT 1
68601: ST_TO_ADDR
// break ;
68602: GO 68606
// end ;
68604: GO 68575
68606: POP
68607: POP
// if busy then
68608: LD_VAR 0 8
68612: IFFALSE 68616
// continue ;
68614: GO 68422
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68616: LD_ADDR_VAR 0 7
68620: PUSH
68621: LD_VAR 0 6
68625: PPUSH
68626: LD_INT 35
68628: PUSH
68629: LD_INT 0
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PPUSH
68636: CALL_OW 72
68640: ST_TO_ADDR
// if tw then
68641: LD_VAR 0 7
68645: IFFALSE 68722
// begin tw := tw [ 1 ] ;
68647: LD_ADDR_VAR 0 7
68651: PUSH
68652: LD_VAR 0 7
68656: PUSH
68657: LD_INT 1
68659: ARRAY
68660: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68661: LD_ADDR_VAR 0 9
68665: PUSH
68666: LD_VAR 0 7
68670: PPUSH
68671: LD_EXP 86
68675: PUSH
68676: LD_VAR 0 2
68680: ARRAY
68681: PPUSH
68682: CALL 24920 0 2
68686: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68687: LD_EXP 100
68691: PUSH
68692: LD_VAR 0 2
68696: ARRAY
68697: IFFALSE 68720
// if not weapon in mc_allowed_tower_weapons [ i ] then
68699: LD_VAR 0 9
68703: PUSH
68704: LD_EXP 100
68708: PUSH
68709: LD_VAR 0 2
68713: ARRAY
68714: IN
68715: NOT
68716: IFFALSE 68720
// continue ;
68718: GO 68422
// end else
68720: GO 68785
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68722: LD_ADDR_VAR 0 5
68726: PUSH
68727: LD_EXP 69
68731: PUSH
68732: LD_VAR 0 2
68736: ARRAY
68737: PPUSH
68738: LD_VAR 0 4
68742: PPUSH
68743: CALL 51790 0 2
68747: ST_TO_ADDR
// if not tmp2 then
68748: LD_VAR 0 5
68752: NOT
68753: IFFALSE 68757
// continue ;
68755: GO 68422
// tw := tmp2 [ 1 ] ;
68757: LD_ADDR_VAR 0 7
68761: PUSH
68762: LD_VAR 0 5
68766: PUSH
68767: LD_INT 1
68769: ARRAY
68770: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68771: LD_ADDR_VAR 0 9
68775: PUSH
68776: LD_VAR 0 5
68780: PUSH
68781: LD_INT 2
68783: ARRAY
68784: ST_TO_ADDR
// end ; if not weapon then
68785: LD_VAR 0 9
68789: NOT
68790: IFFALSE 68794
// continue ;
68792: GO 68422
// ComPlaceWeapon ( tw , weapon ) ;
68794: LD_VAR 0 7
68798: PPUSH
68799: LD_VAR 0 9
68803: PPUSH
68804: CALL_OW 148
// end ;
68808: GO 68422
68810: POP
68811: POP
// end ;
68812: LD_VAR 0 1
68816: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68817: LD_INT 0
68819: PPUSH
68820: PPUSH
68821: PPUSH
68822: PPUSH
68823: PPUSH
68824: PPUSH
68825: PPUSH
// if not mc_bases then
68826: LD_EXP 61
68830: NOT
68831: IFFALSE 68835
// exit ;
68833: GO 69610
// for i = 1 to mc_bases do
68835: LD_ADDR_VAR 0 2
68839: PUSH
68840: DOUBLE
68841: LD_INT 1
68843: DEC
68844: ST_TO_ADDR
68845: LD_EXP 61
68849: PUSH
68850: FOR_TO
68851: IFFALSE 69608
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68853: LD_EXP 74
68857: PUSH
68858: LD_VAR 0 2
68862: ARRAY
68863: NOT
68864: PUSH
68865: LD_EXP 74
68869: PUSH
68870: LD_VAR 0 2
68874: ARRAY
68875: PUSH
68876: LD_EXP 75
68880: PUSH
68881: LD_VAR 0 2
68885: ARRAY
68886: EQUAL
68887: OR
68888: PUSH
68889: LD_EXP 84
68893: PUSH
68894: LD_VAR 0 2
68898: ARRAY
68899: OR
68900: IFFALSE 68904
// continue ;
68902: GO 68850
// if mc_miners [ i ] then
68904: LD_EXP 75
68908: PUSH
68909: LD_VAR 0 2
68913: ARRAY
68914: IFFALSE 69295
// begin for j = mc_miners [ i ] downto 1 do
68916: LD_ADDR_VAR 0 3
68920: PUSH
68921: DOUBLE
68922: LD_EXP 75
68926: PUSH
68927: LD_VAR 0 2
68931: ARRAY
68932: INC
68933: ST_TO_ADDR
68934: LD_INT 1
68936: PUSH
68937: FOR_DOWNTO
68938: IFFALSE 69293
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68940: LD_EXP 75
68944: PUSH
68945: LD_VAR 0 2
68949: ARRAY
68950: PUSH
68951: LD_VAR 0 3
68955: ARRAY
68956: PPUSH
68957: CALL_OW 301
68961: PUSH
68962: LD_EXP 75
68966: PUSH
68967: LD_VAR 0 2
68971: ARRAY
68972: PUSH
68973: LD_VAR 0 3
68977: ARRAY
68978: PPUSH
68979: CALL_OW 257
68983: PUSH
68984: LD_INT 1
68986: NONEQUAL
68987: OR
68988: IFFALSE 69051
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68990: LD_ADDR_VAR 0 5
68994: PUSH
68995: LD_EXP 75
68999: PUSH
69000: LD_VAR 0 2
69004: ARRAY
69005: PUSH
69006: LD_EXP 75
69010: PUSH
69011: LD_VAR 0 2
69015: ARRAY
69016: PUSH
69017: LD_VAR 0 3
69021: ARRAY
69022: DIFF
69023: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69024: LD_ADDR_EXP 75
69028: PUSH
69029: LD_EXP 75
69033: PPUSH
69034: LD_VAR 0 2
69038: PPUSH
69039: LD_VAR 0 5
69043: PPUSH
69044: CALL_OW 1
69048: ST_TO_ADDR
// continue ;
69049: GO 68937
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69051: LD_EXP 75
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: PUSH
69062: LD_VAR 0 3
69066: ARRAY
69067: PPUSH
69068: CALL_OW 257
69072: PUSH
69073: LD_INT 1
69075: EQUAL
69076: PUSH
69077: LD_EXP 75
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: PUSH
69088: LD_VAR 0 3
69092: ARRAY
69093: PPUSH
69094: CALL_OW 459
69098: NOT
69099: AND
69100: PUSH
69101: LD_EXP 75
69105: PUSH
69106: LD_VAR 0 2
69110: ARRAY
69111: PUSH
69112: LD_VAR 0 3
69116: ARRAY
69117: PPUSH
69118: CALL_OW 314
69122: NOT
69123: AND
69124: IFFALSE 69291
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69126: LD_EXP 75
69130: PUSH
69131: LD_VAR 0 2
69135: ARRAY
69136: PUSH
69137: LD_VAR 0 3
69141: ARRAY
69142: PPUSH
69143: CALL_OW 310
69147: IFFALSE 69170
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69149: LD_EXP 75
69153: PUSH
69154: LD_VAR 0 2
69158: ARRAY
69159: PUSH
69160: LD_VAR 0 3
69164: ARRAY
69165: PPUSH
69166: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69170: LD_EXP 75
69174: PUSH
69175: LD_VAR 0 2
69179: ARRAY
69180: PUSH
69181: LD_VAR 0 3
69185: ARRAY
69186: PPUSH
69187: CALL_OW 314
69191: NOT
69192: IFFALSE 69291
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
69194: LD_ADDR_VAR 0 7
69198: PUSH
69199: LD_VAR 0 3
69203: PUSH
69204: LD_EXP 74
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PPUSH
69215: CALL 17052 0 1
69219: MOD
69220: PUSH
69221: LD_INT 1
69223: PLUS
69224: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69225: LD_EXP 75
69229: PUSH
69230: LD_VAR 0 2
69234: ARRAY
69235: PUSH
69236: LD_VAR 0 3
69240: ARRAY
69241: PPUSH
69242: LD_EXP 74
69246: PUSH
69247: LD_VAR 0 2
69251: ARRAY
69252: PUSH
69253: LD_VAR 0 7
69257: ARRAY
69258: PUSH
69259: LD_INT 1
69261: ARRAY
69262: PPUSH
69263: LD_EXP 74
69267: PUSH
69268: LD_VAR 0 2
69272: ARRAY
69273: PUSH
69274: LD_VAR 0 7
69278: ARRAY
69279: PUSH
69280: LD_INT 2
69282: ARRAY
69283: PPUSH
69284: LD_INT 0
69286: PPUSH
69287: CALL_OW 193
// end ; end ; end ;
69291: GO 68937
69293: POP
69294: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69295: LD_ADDR_VAR 0 5
69299: PUSH
69300: LD_EXP 61
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: PPUSH
69311: LD_INT 2
69313: PUSH
69314: LD_INT 30
69316: PUSH
69317: LD_INT 4
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 30
69326: PUSH
69327: LD_INT 5
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 30
69336: PUSH
69337: LD_INT 32
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: PPUSH
69350: CALL_OW 72
69354: ST_TO_ADDR
// if not tmp then
69355: LD_VAR 0 5
69359: NOT
69360: IFFALSE 69364
// continue ;
69362: GO 68850
// list := [ ] ;
69364: LD_ADDR_VAR 0 6
69368: PUSH
69369: EMPTY
69370: ST_TO_ADDR
// for j in tmp do
69371: LD_ADDR_VAR 0 3
69375: PUSH
69376: LD_VAR 0 5
69380: PUSH
69381: FOR_IN
69382: IFFALSE 69451
// begin for k in UnitsInside ( j ) do
69384: LD_ADDR_VAR 0 4
69388: PUSH
69389: LD_VAR 0 3
69393: PPUSH
69394: CALL_OW 313
69398: PUSH
69399: FOR_IN
69400: IFFALSE 69447
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69402: LD_VAR 0 4
69406: PPUSH
69407: CALL_OW 257
69411: PUSH
69412: LD_INT 1
69414: EQUAL
69415: PUSH
69416: LD_VAR 0 4
69420: PPUSH
69421: CALL_OW 459
69425: NOT
69426: AND
69427: IFFALSE 69445
// list := list ^ k ;
69429: LD_ADDR_VAR 0 6
69433: PUSH
69434: LD_VAR 0 6
69438: PUSH
69439: LD_VAR 0 4
69443: ADD
69444: ST_TO_ADDR
69445: GO 69399
69447: POP
69448: POP
// end ;
69449: GO 69381
69451: POP
69452: POP
// list := list diff mc_miners [ i ] ;
69453: LD_ADDR_VAR 0 6
69457: PUSH
69458: LD_VAR 0 6
69462: PUSH
69463: LD_EXP 75
69467: PUSH
69468: LD_VAR 0 2
69472: ARRAY
69473: DIFF
69474: ST_TO_ADDR
// if not list then
69475: LD_VAR 0 6
69479: NOT
69480: IFFALSE 69484
// continue ;
69482: GO 68850
// k := mc_mines [ i ] - mc_miners [ i ] ;
69484: LD_ADDR_VAR 0 4
69488: PUSH
69489: LD_EXP 74
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: PUSH
69500: LD_EXP 75
69504: PUSH
69505: LD_VAR 0 2
69509: ARRAY
69510: MINUS
69511: ST_TO_ADDR
// if k > list then
69512: LD_VAR 0 4
69516: PUSH
69517: LD_VAR 0 6
69521: GREATER
69522: IFFALSE 69534
// k := list ;
69524: LD_ADDR_VAR 0 4
69528: PUSH
69529: LD_VAR 0 6
69533: ST_TO_ADDR
// for j = 1 to k do
69534: LD_ADDR_VAR 0 3
69538: PUSH
69539: DOUBLE
69540: LD_INT 1
69542: DEC
69543: ST_TO_ADDR
69544: LD_VAR 0 4
69548: PUSH
69549: FOR_TO
69550: IFFALSE 69604
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69552: LD_ADDR_EXP 75
69556: PUSH
69557: LD_EXP 75
69561: PPUSH
69562: LD_VAR 0 2
69566: PUSH
69567: LD_EXP 75
69571: PUSH
69572: LD_VAR 0 2
69576: ARRAY
69577: PUSH
69578: LD_INT 1
69580: PLUS
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PPUSH
69586: LD_VAR 0 6
69590: PUSH
69591: LD_VAR 0 3
69595: ARRAY
69596: PPUSH
69597: CALL 19912 0 3
69601: ST_TO_ADDR
69602: GO 69549
69604: POP
69605: POP
// end ;
69606: GO 68850
69608: POP
69609: POP
// end ;
69610: LD_VAR 0 1
69614: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69615: LD_INT 0
69617: PPUSH
69618: PPUSH
69619: PPUSH
69620: PPUSH
69621: PPUSH
69622: PPUSH
69623: PPUSH
69624: PPUSH
69625: PPUSH
69626: PPUSH
69627: PPUSH
// if not mc_bases then
69628: LD_EXP 61
69632: NOT
69633: IFFALSE 69637
// exit ;
69635: GO 71460
// for i = 1 to mc_bases do
69637: LD_ADDR_VAR 0 2
69641: PUSH
69642: DOUBLE
69643: LD_INT 1
69645: DEC
69646: ST_TO_ADDR
69647: LD_EXP 61
69651: PUSH
69652: FOR_TO
69653: IFFALSE 71458
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69655: LD_EXP 61
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: NOT
69666: PUSH
69667: LD_EXP 68
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: OR
69678: IFFALSE 69682
// continue ;
69680: GO 69652
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69682: LD_EXP 77
69686: PUSH
69687: LD_VAR 0 2
69691: ARRAY
69692: NOT
69693: PUSH
69694: LD_EXP 78
69698: PUSH
69699: LD_VAR 0 2
69703: ARRAY
69704: AND
69705: IFFALSE 69743
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69707: LD_ADDR_EXP 78
69711: PUSH
69712: LD_EXP 78
69716: PPUSH
69717: LD_VAR 0 2
69721: PPUSH
69722: EMPTY
69723: PPUSH
69724: CALL_OW 1
69728: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69729: LD_VAR 0 2
69733: PPUSH
69734: LD_INT 107
69736: PPUSH
69737: CALL 60483 0 2
// continue ;
69741: GO 69652
// end ; target := [ ] ;
69743: LD_ADDR_VAR 0 7
69747: PUSH
69748: EMPTY
69749: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69750: LD_ADDR_VAR 0 6
69754: PUSH
69755: LD_EXP 61
69759: PUSH
69760: LD_VAR 0 2
69764: ARRAY
69765: PUSH
69766: LD_INT 1
69768: ARRAY
69769: PPUSH
69770: CALL_OW 255
69774: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69775: LD_ADDR_VAR 0 9
69779: PUSH
69780: LD_EXP 61
69784: PUSH
69785: LD_VAR 0 2
69789: ARRAY
69790: PPUSH
69791: LD_INT 2
69793: PUSH
69794: LD_INT 30
69796: PUSH
69797: LD_INT 0
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 30
69806: PUSH
69807: LD_INT 1
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: LIST
69818: PPUSH
69819: CALL_OW 72
69823: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69824: LD_ADDR_VAR 0 3
69828: PUSH
69829: DOUBLE
69830: LD_EXP 77
69834: PUSH
69835: LD_VAR 0 2
69839: ARRAY
69840: INC
69841: ST_TO_ADDR
69842: LD_INT 1
69844: PUSH
69845: FOR_DOWNTO
69846: IFFALSE 70091
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69848: LD_EXP 77
69852: PUSH
69853: LD_VAR 0 2
69857: ARRAY
69858: PUSH
69859: LD_VAR 0 3
69863: ARRAY
69864: PUSH
69865: LD_INT 2
69867: ARRAY
69868: PPUSH
69869: LD_EXP 77
69873: PUSH
69874: LD_VAR 0 2
69878: ARRAY
69879: PUSH
69880: LD_VAR 0 3
69884: ARRAY
69885: PUSH
69886: LD_INT 3
69888: ARRAY
69889: PPUSH
69890: CALL_OW 488
69894: PUSH
69895: LD_EXP 77
69899: PUSH
69900: LD_VAR 0 2
69904: ARRAY
69905: PUSH
69906: LD_VAR 0 3
69910: ARRAY
69911: PUSH
69912: LD_INT 2
69914: ARRAY
69915: PPUSH
69916: LD_EXP 77
69920: PUSH
69921: LD_VAR 0 2
69925: ARRAY
69926: PUSH
69927: LD_VAR 0 3
69931: ARRAY
69932: PUSH
69933: LD_INT 3
69935: ARRAY
69936: PPUSH
69937: CALL_OW 284
69941: PUSH
69942: LD_INT 0
69944: EQUAL
69945: AND
69946: IFFALSE 70001
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69948: LD_ADDR_VAR 0 5
69952: PUSH
69953: LD_EXP 77
69957: PUSH
69958: LD_VAR 0 2
69962: ARRAY
69963: PPUSH
69964: LD_VAR 0 3
69968: PPUSH
69969: CALL_OW 3
69973: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69974: LD_ADDR_EXP 77
69978: PUSH
69979: LD_EXP 77
69983: PPUSH
69984: LD_VAR 0 2
69988: PPUSH
69989: LD_VAR 0 5
69993: PPUSH
69994: CALL_OW 1
69998: ST_TO_ADDR
// continue ;
69999: GO 69845
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70001: LD_VAR 0 6
70005: PPUSH
70006: LD_EXP 77
70010: PUSH
70011: LD_VAR 0 2
70015: ARRAY
70016: PUSH
70017: LD_VAR 0 3
70021: ARRAY
70022: PUSH
70023: LD_INT 2
70025: ARRAY
70026: PPUSH
70027: LD_EXP 77
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: PUSH
70038: LD_VAR 0 3
70042: ARRAY
70043: PUSH
70044: LD_INT 3
70046: ARRAY
70047: PPUSH
70048: LD_INT 30
70050: PPUSH
70051: CALL 20808 0 4
70055: PUSH
70056: LD_INT 4
70058: ARRAY
70059: PUSH
70060: LD_INT 0
70062: EQUAL
70063: IFFALSE 70089
// begin target := mc_crates [ i ] [ j ] ;
70065: LD_ADDR_VAR 0 7
70069: PUSH
70070: LD_EXP 77
70074: PUSH
70075: LD_VAR 0 2
70079: ARRAY
70080: PUSH
70081: LD_VAR 0 3
70085: ARRAY
70086: ST_TO_ADDR
// break ;
70087: GO 70091
// end ; end ;
70089: GO 69845
70091: POP
70092: POP
// if not target then
70093: LD_VAR 0 7
70097: NOT
70098: IFFALSE 70102
// continue ;
70100: GO 69652
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70102: LD_ADDR_VAR 0 8
70106: PUSH
70107: LD_EXP 80
70111: PUSH
70112: LD_VAR 0 2
70116: ARRAY
70117: PPUSH
70118: LD_INT 2
70120: PUSH
70121: LD_INT 3
70123: PUSH
70124: LD_INT 58
70126: PUSH
70127: EMPTY
70128: LIST
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 61
70136: PUSH
70137: EMPTY
70138: LIST
70139: PUSH
70140: LD_INT 33
70142: PUSH
70143: LD_INT 5
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: PUSH
70150: LD_INT 33
70152: PUSH
70153: LD_INT 3
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: PUSH
70170: LD_INT 34
70172: PUSH
70173: LD_INT 32
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 34
70182: PUSH
70183: LD_INT 51
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 34
70192: PUSH
70193: LD_INT 12
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PPUSH
70210: CALL_OW 72
70214: ST_TO_ADDR
// if not cargo then
70215: LD_VAR 0 8
70219: NOT
70220: IFFALSE 70926
// begin if mc_crates_collector [ i ] < 5 then
70222: LD_EXP 78
70226: PUSH
70227: LD_VAR 0 2
70231: ARRAY
70232: PUSH
70233: LD_INT 5
70235: LESS
70236: IFFALSE 70602
// begin if mc_ape [ i ] then
70238: LD_EXP 90
70242: PUSH
70243: LD_VAR 0 2
70247: ARRAY
70248: IFFALSE 70295
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70250: LD_ADDR_VAR 0 5
70254: PUSH
70255: LD_EXP 90
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: PPUSH
70266: LD_INT 25
70268: PUSH
70269: LD_INT 16
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 24
70278: PUSH
70279: LD_INT 750
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PPUSH
70290: CALL_OW 72
70294: ST_TO_ADDR
// if not tmp then
70295: LD_VAR 0 5
70299: NOT
70300: IFFALSE 70347
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70302: LD_ADDR_VAR 0 5
70306: PUSH
70307: LD_EXP 61
70311: PUSH
70312: LD_VAR 0 2
70316: ARRAY
70317: PPUSH
70318: LD_INT 25
70320: PUSH
70321: LD_INT 2
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 24
70330: PUSH
70331: LD_INT 750
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PPUSH
70342: CALL_OW 72
70346: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70347: LD_EXP 90
70351: PUSH
70352: LD_VAR 0 2
70356: ARRAY
70357: PUSH
70358: LD_EXP 61
70362: PUSH
70363: LD_VAR 0 2
70367: ARRAY
70368: PPUSH
70369: LD_INT 25
70371: PUSH
70372: LD_INT 2
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 24
70381: PUSH
70382: LD_INT 750
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PPUSH
70393: CALL_OW 72
70397: AND
70398: PUSH
70399: LD_VAR 0 5
70403: PUSH
70404: LD_INT 5
70406: LESS
70407: AND
70408: IFFALSE 70490
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70410: LD_ADDR_VAR 0 3
70414: PUSH
70415: LD_EXP 61
70419: PUSH
70420: LD_VAR 0 2
70424: ARRAY
70425: PPUSH
70426: LD_INT 25
70428: PUSH
70429: LD_INT 2
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 24
70438: PUSH
70439: LD_INT 750
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PPUSH
70450: CALL_OW 72
70454: PUSH
70455: FOR_IN
70456: IFFALSE 70488
// begin tmp := tmp union j ;
70458: LD_ADDR_VAR 0 5
70462: PUSH
70463: LD_VAR 0 5
70467: PUSH
70468: LD_VAR 0 3
70472: UNION
70473: ST_TO_ADDR
// if tmp >= 5 then
70474: LD_VAR 0 5
70478: PUSH
70479: LD_INT 5
70481: GREATEREQUAL
70482: IFFALSE 70486
// break ;
70484: GO 70488
// end ;
70486: GO 70455
70488: POP
70489: POP
// end ; if not tmp then
70490: LD_VAR 0 5
70494: NOT
70495: IFFALSE 70499
// continue ;
70497: GO 69652
// for j in tmp do
70499: LD_ADDR_VAR 0 3
70503: PUSH
70504: LD_VAR 0 5
70508: PUSH
70509: FOR_IN
70510: IFFALSE 70600
// if not GetTag ( j ) then
70512: LD_VAR 0 3
70516: PPUSH
70517: CALL_OW 110
70521: NOT
70522: IFFALSE 70598
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70524: LD_ADDR_EXP 78
70528: PUSH
70529: LD_EXP 78
70533: PPUSH
70534: LD_VAR 0 2
70538: PUSH
70539: LD_EXP 78
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: PUSH
70550: LD_INT 1
70552: PLUS
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PPUSH
70558: LD_VAR 0 3
70562: PPUSH
70563: CALL 19912 0 3
70567: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70568: LD_VAR 0 3
70572: PPUSH
70573: LD_INT 107
70575: PPUSH
70576: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70580: LD_EXP 78
70584: PUSH
70585: LD_VAR 0 2
70589: ARRAY
70590: PUSH
70591: LD_INT 5
70593: GREATEREQUAL
70594: IFFALSE 70598
// break ;
70596: GO 70600
// end ;
70598: GO 70509
70600: POP
70601: POP
// end ; if mc_crates_collector [ i ] and target then
70602: LD_EXP 78
70606: PUSH
70607: LD_VAR 0 2
70611: ARRAY
70612: PUSH
70613: LD_VAR 0 7
70617: AND
70618: IFFALSE 70924
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70620: LD_EXP 78
70624: PUSH
70625: LD_VAR 0 2
70629: ARRAY
70630: PUSH
70631: LD_VAR 0 7
70635: PUSH
70636: LD_INT 1
70638: ARRAY
70639: LESS
70640: IFFALSE 70660
// tmp := mc_crates_collector [ i ] else
70642: LD_ADDR_VAR 0 5
70646: PUSH
70647: LD_EXP 78
70651: PUSH
70652: LD_VAR 0 2
70656: ARRAY
70657: ST_TO_ADDR
70658: GO 70674
// tmp := target [ 1 ] ;
70660: LD_ADDR_VAR 0 5
70664: PUSH
70665: LD_VAR 0 7
70669: PUSH
70670: LD_INT 1
70672: ARRAY
70673: ST_TO_ADDR
// k := 0 ;
70674: LD_ADDR_VAR 0 4
70678: PUSH
70679: LD_INT 0
70681: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70682: LD_ADDR_VAR 0 3
70686: PUSH
70687: LD_EXP 78
70691: PUSH
70692: LD_VAR 0 2
70696: ARRAY
70697: PUSH
70698: FOR_IN
70699: IFFALSE 70922
// begin k := k + 1 ;
70701: LD_ADDR_VAR 0 4
70705: PUSH
70706: LD_VAR 0 4
70710: PUSH
70711: LD_INT 1
70713: PLUS
70714: ST_TO_ADDR
// if k > tmp then
70715: LD_VAR 0 4
70719: PUSH
70720: LD_VAR 0 5
70724: GREATER
70725: IFFALSE 70729
// break ;
70727: GO 70922
// if not GetClass ( j ) in [ 2 , 16 ] then
70729: LD_VAR 0 3
70733: PPUSH
70734: CALL_OW 257
70738: PUSH
70739: LD_INT 2
70741: PUSH
70742: LD_INT 16
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: IN
70749: NOT
70750: IFFALSE 70803
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70752: LD_ADDR_EXP 78
70756: PUSH
70757: LD_EXP 78
70761: PPUSH
70762: LD_VAR 0 2
70766: PPUSH
70767: LD_EXP 78
70771: PUSH
70772: LD_VAR 0 2
70776: ARRAY
70777: PUSH
70778: LD_VAR 0 3
70782: DIFF
70783: PPUSH
70784: CALL_OW 1
70788: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70789: LD_VAR 0 3
70793: PPUSH
70794: LD_INT 0
70796: PPUSH
70797: CALL_OW 109
// continue ;
70801: GO 70698
// end ; if IsInUnit ( j ) then
70803: LD_VAR 0 3
70807: PPUSH
70808: CALL_OW 310
70812: IFFALSE 70823
// ComExitBuilding ( j ) ;
70814: LD_VAR 0 3
70818: PPUSH
70819: CALL_OW 122
// wait ( 3 ) ;
70823: LD_INT 3
70825: PPUSH
70826: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70830: LD_VAR 0 3
70834: PPUSH
70835: CALL_OW 314
70839: PUSH
70840: LD_VAR 0 6
70844: PPUSH
70845: LD_VAR 0 7
70849: PUSH
70850: LD_INT 2
70852: ARRAY
70853: PPUSH
70854: LD_VAR 0 7
70858: PUSH
70859: LD_INT 3
70861: ARRAY
70862: PPUSH
70863: LD_INT 30
70865: PPUSH
70866: CALL 20808 0 4
70870: PUSH
70871: LD_INT 4
70873: ARRAY
70874: AND
70875: IFFALSE 70893
// ComStandNearbyBuilding ( j , depot ) else
70877: LD_VAR 0 3
70881: PPUSH
70882: LD_VAR 0 9
70886: PPUSH
70887: CALL 16514 0 2
70891: GO 70920
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70893: LD_VAR 0 3
70897: PPUSH
70898: LD_VAR 0 7
70902: PUSH
70903: LD_INT 2
70905: ARRAY
70906: PPUSH
70907: LD_VAR 0 7
70911: PUSH
70912: LD_INT 3
70914: ARRAY
70915: PPUSH
70916: CALL_OW 117
// end ;
70920: GO 70698
70922: POP
70923: POP
// end ; end else
70924: GO 71456
// begin for j in cargo do
70926: LD_ADDR_VAR 0 3
70930: PUSH
70931: LD_VAR 0 8
70935: PUSH
70936: FOR_IN
70937: IFFALSE 71454
// begin if GetTag ( j ) <> 0 then
70939: LD_VAR 0 3
70943: PPUSH
70944: CALL_OW 110
70948: PUSH
70949: LD_INT 0
70951: NONEQUAL
70952: IFFALSE 70956
// continue ;
70954: GO 70936
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70956: LD_VAR 0 3
70960: PPUSH
70961: CALL_OW 256
70965: PUSH
70966: LD_INT 1000
70968: LESS
70969: PUSH
70970: LD_VAR 0 3
70974: PPUSH
70975: LD_EXP 85
70979: PUSH
70980: LD_VAR 0 2
70984: ARRAY
70985: PPUSH
70986: CALL_OW 308
70990: NOT
70991: AND
70992: IFFALSE 71014
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70994: LD_VAR 0 3
70998: PPUSH
70999: LD_EXP 85
71003: PUSH
71004: LD_VAR 0 2
71008: ARRAY
71009: PPUSH
71010: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71014: LD_VAR 0 3
71018: PPUSH
71019: CALL_OW 256
71023: PUSH
71024: LD_INT 1000
71026: LESS
71027: PUSH
71028: LD_VAR 0 3
71032: PPUSH
71033: LD_EXP 85
71037: PUSH
71038: LD_VAR 0 2
71042: ARRAY
71043: PPUSH
71044: CALL_OW 308
71048: AND
71049: IFFALSE 71053
// continue ;
71051: GO 70936
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71053: LD_VAR 0 3
71057: PPUSH
71058: CALL_OW 262
71062: PUSH
71063: LD_INT 2
71065: EQUAL
71066: PUSH
71067: LD_VAR 0 3
71071: PPUSH
71072: CALL_OW 261
71076: PUSH
71077: LD_INT 15
71079: LESS
71080: AND
71081: IFFALSE 71085
// continue ;
71083: GO 70936
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71085: LD_VAR 0 3
71089: PPUSH
71090: CALL_OW 262
71094: PUSH
71095: LD_INT 1
71097: EQUAL
71098: PUSH
71099: LD_VAR 0 3
71103: PPUSH
71104: CALL_OW 261
71108: PUSH
71109: LD_INT 10
71111: LESS
71112: AND
71113: IFFALSE 71393
// begin if not depot then
71115: LD_VAR 0 9
71119: NOT
71120: IFFALSE 71124
// continue ;
71122: GO 70936
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71124: LD_VAR 0 3
71128: PPUSH
71129: LD_VAR 0 9
71133: PPUSH
71134: LD_VAR 0 3
71138: PPUSH
71139: CALL_OW 74
71143: PPUSH
71144: CALL_OW 296
71148: PUSH
71149: LD_INT 6
71151: LESS
71152: IFFALSE 71168
// SetFuel ( j , 100 ) else
71154: LD_VAR 0 3
71158: PPUSH
71159: LD_INT 100
71161: PPUSH
71162: CALL_OW 240
71166: GO 71393
// if GetFuel ( j ) = 0 then
71168: LD_VAR 0 3
71172: PPUSH
71173: CALL_OW 261
71177: PUSH
71178: LD_INT 0
71180: EQUAL
71181: IFFALSE 71393
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71183: LD_ADDR_EXP 80
71187: PUSH
71188: LD_EXP 80
71192: PPUSH
71193: LD_VAR 0 2
71197: PPUSH
71198: LD_EXP 80
71202: PUSH
71203: LD_VAR 0 2
71207: ARRAY
71208: PUSH
71209: LD_VAR 0 3
71213: DIFF
71214: PPUSH
71215: CALL_OW 1
71219: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71220: LD_VAR 0 3
71224: PPUSH
71225: CALL_OW 263
71229: PUSH
71230: LD_INT 1
71232: EQUAL
71233: IFFALSE 71249
// ComExitVehicle ( IsInUnit ( j ) ) ;
71235: LD_VAR 0 3
71239: PPUSH
71240: CALL_OW 310
71244: PPUSH
71245: CALL_OW 121
// if GetControl ( j ) = control_remote then
71249: LD_VAR 0 3
71253: PPUSH
71254: CALL_OW 263
71258: PUSH
71259: LD_INT 2
71261: EQUAL
71262: IFFALSE 71273
// ComUnlink ( j ) ;
71264: LD_VAR 0 3
71268: PPUSH
71269: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71273: LD_ADDR_VAR 0 10
71277: PUSH
71278: LD_VAR 0 2
71282: PPUSH
71283: LD_INT 3
71285: PPUSH
71286: CALL 81037 0 2
71290: ST_TO_ADDR
// if fac then
71291: LD_VAR 0 10
71295: IFFALSE 71391
// begin for k in fac do
71297: LD_ADDR_VAR 0 4
71301: PUSH
71302: LD_VAR 0 10
71306: PUSH
71307: FOR_IN
71308: IFFALSE 71389
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71310: LD_ADDR_VAR 0 11
71314: PUSH
71315: LD_VAR 0 10
71319: PPUSH
71320: LD_VAR 0 3
71324: PPUSH
71325: CALL_OW 265
71329: PPUSH
71330: LD_VAR 0 3
71334: PPUSH
71335: CALL_OW 262
71339: PPUSH
71340: LD_VAR 0 3
71344: PPUSH
71345: CALL_OW 263
71349: PPUSH
71350: LD_VAR 0 3
71354: PPUSH
71355: CALL_OW 264
71359: PPUSH
71360: CALL 17410 0 5
71364: ST_TO_ADDR
// if components then
71365: LD_VAR 0 11
71369: IFFALSE 71387
// begin MC_InsertProduceList ( i , components ) ;
71371: LD_VAR 0 2
71375: PPUSH
71376: LD_VAR 0 11
71380: PPUSH
71381: CALL 80582 0 2
// break ;
71385: GO 71389
// end ; end ;
71387: GO 71307
71389: POP
71390: POP
// end ; continue ;
71391: GO 70936
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71393: LD_VAR 0 3
71397: PPUSH
71398: LD_INT 1
71400: PPUSH
71401: CALL_OW 289
71405: PUSH
71406: LD_INT 100
71408: LESS
71409: PUSH
71410: LD_VAR 0 3
71414: PPUSH
71415: CALL_OW 314
71419: NOT
71420: AND
71421: IFFALSE 71450
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71423: LD_VAR 0 3
71427: PPUSH
71428: LD_VAR 0 7
71432: PUSH
71433: LD_INT 2
71435: ARRAY
71436: PPUSH
71437: LD_VAR 0 7
71441: PUSH
71442: LD_INT 3
71444: ARRAY
71445: PPUSH
71446: CALL_OW 117
// break ;
71450: GO 71454
// end ;
71452: GO 70936
71454: POP
71455: POP
// end ; end ;
71456: GO 69652
71458: POP
71459: POP
// end ;
71460: LD_VAR 0 1
71464: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71465: LD_INT 0
71467: PPUSH
71468: PPUSH
71469: PPUSH
71470: PPUSH
// if not mc_bases then
71471: LD_EXP 61
71475: NOT
71476: IFFALSE 71480
// exit ;
71478: GO 71641
// for i = 1 to mc_bases do
71480: LD_ADDR_VAR 0 2
71484: PUSH
71485: DOUBLE
71486: LD_INT 1
71488: DEC
71489: ST_TO_ADDR
71490: LD_EXP 61
71494: PUSH
71495: FOR_TO
71496: IFFALSE 71639
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71498: LD_ADDR_VAR 0 4
71502: PUSH
71503: LD_EXP 80
71507: PUSH
71508: LD_VAR 0 2
71512: ARRAY
71513: PUSH
71514: LD_EXP 83
71518: PUSH
71519: LD_VAR 0 2
71523: ARRAY
71524: UNION
71525: PPUSH
71526: LD_INT 33
71528: PUSH
71529: LD_INT 2
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PPUSH
71536: CALL_OW 72
71540: ST_TO_ADDR
// if tmp then
71541: LD_VAR 0 4
71545: IFFALSE 71637
// for j in tmp do
71547: LD_ADDR_VAR 0 3
71551: PUSH
71552: LD_VAR 0 4
71556: PUSH
71557: FOR_IN
71558: IFFALSE 71635
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71560: LD_VAR 0 3
71564: PPUSH
71565: CALL_OW 312
71569: NOT
71570: PUSH
71571: LD_VAR 0 3
71575: PPUSH
71576: CALL_OW 256
71580: PUSH
71581: LD_INT 250
71583: GREATEREQUAL
71584: AND
71585: IFFALSE 71598
// Connect ( j ) else
71587: LD_VAR 0 3
71591: PPUSH
71592: CALL 22881 0 1
71596: GO 71633
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71598: LD_VAR 0 3
71602: PPUSH
71603: CALL_OW 256
71607: PUSH
71608: LD_INT 250
71610: LESS
71611: PUSH
71612: LD_VAR 0 3
71616: PPUSH
71617: CALL_OW 312
71621: AND
71622: IFFALSE 71633
// ComUnlink ( j ) ;
71624: LD_VAR 0 3
71628: PPUSH
71629: CALL_OW 136
71633: GO 71557
71635: POP
71636: POP
// end ;
71637: GO 71495
71639: POP
71640: POP
// end ;
71641: LD_VAR 0 1
71645: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71646: LD_INT 0
71648: PPUSH
71649: PPUSH
71650: PPUSH
71651: PPUSH
71652: PPUSH
// if not mc_bases then
71653: LD_EXP 61
71657: NOT
71658: IFFALSE 71662
// exit ;
71660: GO 72107
// for i = 1 to mc_bases do
71662: LD_ADDR_VAR 0 2
71666: PUSH
71667: DOUBLE
71668: LD_INT 1
71670: DEC
71671: ST_TO_ADDR
71672: LD_EXP 61
71676: PUSH
71677: FOR_TO
71678: IFFALSE 72105
// begin if not mc_produce [ i ] then
71680: LD_EXP 82
71684: PUSH
71685: LD_VAR 0 2
71689: ARRAY
71690: NOT
71691: IFFALSE 71695
// continue ;
71693: GO 71677
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71695: LD_ADDR_VAR 0 5
71699: PUSH
71700: LD_EXP 61
71704: PUSH
71705: LD_VAR 0 2
71709: ARRAY
71710: PPUSH
71711: LD_INT 30
71713: PUSH
71714: LD_INT 3
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PPUSH
71721: CALL_OW 72
71725: ST_TO_ADDR
// if not fac then
71726: LD_VAR 0 5
71730: NOT
71731: IFFALSE 71735
// continue ;
71733: GO 71677
// for j in fac do
71735: LD_ADDR_VAR 0 3
71739: PUSH
71740: LD_VAR 0 5
71744: PUSH
71745: FOR_IN
71746: IFFALSE 72101
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71748: LD_VAR 0 3
71752: PPUSH
71753: CALL_OW 461
71757: PUSH
71758: LD_INT 2
71760: NONEQUAL
71761: PUSH
71762: LD_VAR 0 3
71766: PPUSH
71767: LD_INT 15
71769: PPUSH
71770: CALL 22509 0 2
71774: PUSH
71775: LD_INT 4
71777: ARRAY
71778: OR
71779: IFFALSE 71783
// continue ;
71781: GO 71745
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71783: LD_VAR 0 3
71787: PPUSH
71788: LD_EXP 82
71792: PUSH
71793: LD_VAR 0 2
71797: ARRAY
71798: PUSH
71799: LD_INT 1
71801: ARRAY
71802: PUSH
71803: LD_INT 1
71805: ARRAY
71806: PPUSH
71807: LD_EXP 82
71811: PUSH
71812: LD_VAR 0 2
71816: ARRAY
71817: PUSH
71818: LD_INT 1
71820: ARRAY
71821: PUSH
71822: LD_INT 2
71824: ARRAY
71825: PPUSH
71826: LD_EXP 82
71830: PUSH
71831: LD_VAR 0 2
71835: ARRAY
71836: PUSH
71837: LD_INT 1
71839: ARRAY
71840: PUSH
71841: LD_INT 3
71843: ARRAY
71844: PPUSH
71845: LD_EXP 82
71849: PUSH
71850: LD_VAR 0 2
71854: ARRAY
71855: PUSH
71856: LD_INT 1
71858: ARRAY
71859: PUSH
71860: LD_INT 4
71862: ARRAY
71863: PPUSH
71864: CALL_OW 448
71868: PUSH
71869: LD_VAR 0 3
71873: PPUSH
71874: LD_EXP 82
71878: PUSH
71879: LD_VAR 0 2
71883: ARRAY
71884: PUSH
71885: LD_INT 1
71887: ARRAY
71888: PUSH
71889: LD_INT 1
71891: ARRAY
71892: PUSH
71893: LD_EXP 82
71897: PUSH
71898: LD_VAR 0 2
71902: ARRAY
71903: PUSH
71904: LD_INT 1
71906: ARRAY
71907: PUSH
71908: LD_INT 2
71910: ARRAY
71911: PUSH
71912: LD_EXP 82
71916: PUSH
71917: LD_VAR 0 2
71921: ARRAY
71922: PUSH
71923: LD_INT 1
71925: ARRAY
71926: PUSH
71927: LD_INT 3
71929: ARRAY
71930: PUSH
71931: LD_EXP 82
71935: PUSH
71936: LD_VAR 0 2
71940: ARRAY
71941: PUSH
71942: LD_INT 1
71944: ARRAY
71945: PUSH
71946: LD_INT 4
71948: ARRAY
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: PPUSH
71956: CALL 26276 0 2
71960: AND
71961: IFFALSE 72099
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71963: LD_VAR 0 3
71967: PPUSH
71968: LD_EXP 82
71972: PUSH
71973: LD_VAR 0 2
71977: ARRAY
71978: PUSH
71979: LD_INT 1
71981: ARRAY
71982: PUSH
71983: LD_INT 1
71985: ARRAY
71986: PPUSH
71987: LD_EXP 82
71991: PUSH
71992: LD_VAR 0 2
71996: ARRAY
71997: PUSH
71998: LD_INT 1
72000: ARRAY
72001: PUSH
72002: LD_INT 2
72004: ARRAY
72005: PPUSH
72006: LD_EXP 82
72010: PUSH
72011: LD_VAR 0 2
72015: ARRAY
72016: PUSH
72017: LD_INT 1
72019: ARRAY
72020: PUSH
72021: LD_INT 3
72023: ARRAY
72024: PPUSH
72025: LD_EXP 82
72029: PUSH
72030: LD_VAR 0 2
72034: ARRAY
72035: PUSH
72036: LD_INT 1
72038: ARRAY
72039: PUSH
72040: LD_INT 4
72042: ARRAY
72043: PPUSH
72044: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72048: LD_ADDR_VAR 0 4
72052: PUSH
72053: LD_EXP 82
72057: PUSH
72058: LD_VAR 0 2
72062: ARRAY
72063: PPUSH
72064: LD_INT 1
72066: PPUSH
72067: CALL_OW 3
72071: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72072: LD_ADDR_EXP 82
72076: PUSH
72077: LD_EXP 82
72081: PPUSH
72082: LD_VAR 0 2
72086: PPUSH
72087: LD_VAR 0 4
72091: PPUSH
72092: CALL_OW 1
72096: ST_TO_ADDR
// break ;
72097: GO 72101
// end ; end ;
72099: GO 71745
72101: POP
72102: POP
// end ;
72103: GO 71677
72105: POP
72106: POP
// end ;
72107: LD_VAR 0 1
72111: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72112: LD_INT 0
72114: PPUSH
72115: PPUSH
72116: PPUSH
// if not mc_bases then
72117: LD_EXP 61
72121: NOT
72122: IFFALSE 72126
// exit ;
72124: GO 72215
// for i = 1 to mc_bases do
72126: LD_ADDR_VAR 0 2
72130: PUSH
72131: DOUBLE
72132: LD_INT 1
72134: DEC
72135: ST_TO_ADDR
72136: LD_EXP 61
72140: PUSH
72141: FOR_TO
72142: IFFALSE 72213
// begin if mc_attack [ i ] then
72144: LD_EXP 81
72148: PUSH
72149: LD_VAR 0 2
72153: ARRAY
72154: IFFALSE 72211
// begin tmp := mc_attack [ i ] [ 1 ] ;
72156: LD_ADDR_VAR 0 3
72160: PUSH
72161: LD_EXP 81
72165: PUSH
72166: LD_VAR 0 2
72170: ARRAY
72171: PUSH
72172: LD_INT 1
72174: ARRAY
72175: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72176: LD_ADDR_EXP 81
72180: PUSH
72181: LD_EXP 81
72185: PPUSH
72186: LD_VAR 0 2
72190: PPUSH
72191: EMPTY
72192: PPUSH
72193: CALL_OW 1
72197: ST_TO_ADDR
// Attack ( tmp ) ;
72198: LD_VAR 0 3
72202: PPUSH
72203: CALL 107091 0 1
// exit ;
72207: POP
72208: POP
72209: GO 72215
// end ; end ;
72211: GO 72141
72213: POP
72214: POP
// end ;
72215: LD_VAR 0 1
72219: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72220: LD_INT 0
72222: PPUSH
72223: PPUSH
72224: PPUSH
72225: PPUSH
72226: PPUSH
72227: PPUSH
72228: PPUSH
// if not mc_bases then
72229: LD_EXP 61
72233: NOT
72234: IFFALSE 72238
// exit ;
72236: GO 73095
// for i = 1 to mc_bases do
72238: LD_ADDR_VAR 0 2
72242: PUSH
72243: DOUBLE
72244: LD_INT 1
72246: DEC
72247: ST_TO_ADDR
72248: LD_EXP 61
72252: PUSH
72253: FOR_TO
72254: IFFALSE 73093
// begin if not mc_bases [ i ] then
72256: LD_EXP 61
72260: PUSH
72261: LD_VAR 0 2
72265: ARRAY
72266: NOT
72267: IFFALSE 72271
// continue ;
72269: GO 72253
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72271: LD_ADDR_VAR 0 7
72275: PUSH
72276: LD_EXP 61
72280: PUSH
72281: LD_VAR 0 2
72285: ARRAY
72286: PUSH
72287: LD_INT 1
72289: ARRAY
72290: PPUSH
72291: CALL 16736 0 1
72295: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72296: LD_ADDR_EXP 84
72300: PUSH
72301: LD_EXP 84
72305: PPUSH
72306: LD_VAR 0 2
72310: PPUSH
72311: LD_EXP 61
72315: PUSH
72316: LD_VAR 0 2
72320: ARRAY
72321: PUSH
72322: LD_INT 1
72324: ARRAY
72325: PPUSH
72326: CALL_OW 255
72330: PPUSH
72331: LD_EXP 86
72335: PUSH
72336: LD_VAR 0 2
72340: ARRAY
72341: PPUSH
72342: CALL 16701 0 2
72346: PPUSH
72347: CALL_OW 1
72351: ST_TO_ADDR
// if not mc_scan [ i ] then
72352: LD_EXP 84
72356: PUSH
72357: LD_VAR 0 2
72361: ARRAY
72362: NOT
72363: IFFALSE 72541
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72365: LD_ADDR_EXP 104
72369: PUSH
72370: LD_EXP 104
72374: PPUSH
72375: LD_VAR 0 2
72379: PPUSH
72380: LD_INT 0
72382: PPUSH
72383: CALL_OW 1
72387: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72388: LD_ADDR_VAR 0 4
72392: PUSH
72393: LD_EXP 61
72397: PUSH
72398: LD_VAR 0 2
72402: ARRAY
72403: PPUSH
72404: LD_INT 2
72406: PUSH
72407: LD_INT 25
72409: PUSH
72410: LD_INT 5
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 25
72419: PUSH
72420: LD_INT 8
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 25
72429: PUSH
72430: LD_INT 9
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: PPUSH
72443: CALL_OW 72
72447: ST_TO_ADDR
// if not tmp then
72448: LD_VAR 0 4
72452: NOT
72453: IFFALSE 72457
// continue ;
72455: GO 72253
// for j in tmp do
72457: LD_ADDR_VAR 0 3
72461: PUSH
72462: LD_VAR 0 4
72466: PUSH
72467: FOR_IN
72468: IFFALSE 72539
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72470: LD_VAR 0 3
72474: PPUSH
72475: CALL_OW 310
72479: PPUSH
72480: CALL_OW 266
72484: PUSH
72485: LD_INT 5
72487: EQUAL
72488: PUSH
72489: LD_VAR 0 3
72493: PPUSH
72494: CALL_OW 257
72498: PUSH
72499: LD_INT 1
72501: EQUAL
72502: AND
72503: PUSH
72504: LD_VAR 0 3
72508: PPUSH
72509: CALL_OW 459
72513: NOT
72514: AND
72515: PUSH
72516: LD_VAR 0 7
72520: AND
72521: IFFALSE 72537
// ComChangeProfession ( j , class ) ;
72523: LD_VAR 0 3
72527: PPUSH
72528: LD_VAR 0 7
72532: PPUSH
72533: CALL_OW 123
72537: GO 72467
72539: POP
72540: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72541: LD_EXP 84
72545: PUSH
72546: LD_VAR 0 2
72550: ARRAY
72551: PUSH
72552: LD_EXP 104
72556: PUSH
72557: LD_VAR 0 2
72561: ARRAY
72562: NOT
72563: AND
72564: PUSH
72565: LD_EXP 83
72569: PUSH
72570: LD_VAR 0 2
72574: ARRAY
72575: NOT
72576: AND
72577: PUSH
72578: LD_EXP 61
72582: PUSH
72583: LD_VAR 0 2
72587: ARRAY
72588: PPUSH
72589: LD_INT 50
72591: PUSH
72592: EMPTY
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: LD_INT 30
72600: PUSH
72601: LD_INT 32
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 30
72610: PUSH
72611: LD_INT 33
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 30
72620: PUSH
72621: LD_INT 4
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 30
72630: PUSH
72631: LD_INT 5
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PPUSH
72649: CALL_OW 72
72653: PUSH
72654: LD_INT 4
72656: LESS
72657: PUSH
72658: LD_EXP 61
72662: PUSH
72663: LD_VAR 0 2
72667: ARRAY
72668: PPUSH
72669: LD_INT 3
72671: PUSH
72672: LD_INT 24
72674: PUSH
72675: LD_INT 1000
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 2
72688: PUSH
72689: LD_INT 30
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 30
72701: PUSH
72702: LD_INT 1
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: LIST
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PPUSH
72718: CALL_OW 72
72722: OR
72723: AND
72724: IFFALSE 72975
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72726: LD_ADDR_EXP 104
72730: PUSH
72731: LD_EXP 104
72735: PPUSH
72736: LD_VAR 0 2
72740: PPUSH
72741: LD_INT 1
72743: PPUSH
72744: CALL_OW 1
72748: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72749: LD_ADDR_VAR 0 4
72753: PUSH
72754: LD_EXP 61
72758: PUSH
72759: LD_VAR 0 2
72763: ARRAY
72764: PPUSH
72765: LD_INT 2
72767: PUSH
72768: LD_INT 25
72770: PUSH
72771: LD_INT 1
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 25
72780: PUSH
72781: LD_INT 5
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 25
72790: PUSH
72791: LD_INT 8
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 25
72800: PUSH
72801: LD_INT 9
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: PPUSH
72815: CALL_OW 72
72819: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72820: LD_ADDR_VAR 0 4
72824: PUSH
72825: LD_VAR 0 4
72829: PUSH
72830: LD_VAR 0 4
72834: PPUSH
72835: LD_INT 18
72837: PPUSH
72838: CALL 49824 0 2
72842: DIFF
72843: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72844: LD_VAR 0 4
72848: NOT
72849: PUSH
72850: LD_EXP 61
72854: PUSH
72855: LD_VAR 0 2
72859: ARRAY
72860: PPUSH
72861: LD_INT 2
72863: PUSH
72864: LD_INT 30
72866: PUSH
72867: LD_INT 4
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 30
72876: PUSH
72877: LD_INT 5
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: LIST
72888: PPUSH
72889: CALL_OW 72
72893: NOT
72894: AND
72895: IFFALSE 72957
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72897: LD_ADDR_VAR 0 4
72901: PUSH
72902: LD_EXP 61
72906: PUSH
72907: LD_VAR 0 2
72911: ARRAY
72912: PPUSH
72913: LD_INT 2
72915: PUSH
72916: LD_INT 25
72918: PUSH
72919: LD_INT 2
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 25
72928: PUSH
72929: LD_INT 3
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 25
72938: PUSH
72939: LD_INT 4
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: PPUSH
72952: CALL_OW 72
72956: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72957: LD_VAR 0 2
72961: PPUSH
72962: LD_VAR 0 4
72966: PPUSH
72967: CALL 111800 0 2
// exit ;
72971: POP
72972: POP
72973: GO 73095
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
72975: LD_EXP 84
72979: PUSH
72980: LD_VAR 0 2
72984: ARRAY
72985: PUSH
72986: LD_EXP 104
72990: PUSH
72991: LD_VAR 0 2
72995: ARRAY
72996: NOT
72997: AND
72998: PUSH
72999: LD_EXP 83
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: AND
73010: IFFALSE 73091
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73012: LD_ADDR_EXP 104
73016: PUSH
73017: LD_EXP 104
73021: PPUSH
73022: LD_VAR 0 2
73026: PPUSH
73027: LD_INT 1
73029: PPUSH
73030: CALL_OW 1
73034: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73035: LD_ADDR_VAR 0 4
73039: PUSH
73040: LD_EXP 83
73044: PUSH
73045: LD_VAR 0 2
73049: ARRAY
73050: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73051: LD_ADDR_EXP 83
73055: PUSH
73056: LD_EXP 83
73060: PPUSH
73061: LD_VAR 0 2
73065: PPUSH
73066: EMPTY
73067: PPUSH
73068: CALL_OW 1
73072: ST_TO_ADDR
// Defend ( i , tmp ) ;
73073: LD_VAR 0 2
73077: PPUSH
73078: LD_VAR 0 4
73082: PPUSH
73083: CALL 112396 0 2
// exit ;
73087: POP
73088: POP
73089: GO 73095
// end ; end ;
73091: GO 72253
73093: POP
73094: POP
// end ;
73095: LD_VAR 0 1
73099: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73100: LD_INT 0
73102: PPUSH
73103: PPUSH
73104: PPUSH
73105: PPUSH
73106: PPUSH
73107: PPUSH
73108: PPUSH
73109: PPUSH
73110: PPUSH
73111: PPUSH
73112: PPUSH
// if not mc_bases then
73113: LD_EXP 61
73117: NOT
73118: IFFALSE 73122
// exit ;
73120: GO 74209
// for i = 1 to mc_bases do
73122: LD_ADDR_VAR 0 2
73126: PUSH
73127: DOUBLE
73128: LD_INT 1
73130: DEC
73131: ST_TO_ADDR
73132: LD_EXP 61
73136: PUSH
73137: FOR_TO
73138: IFFALSE 74207
// begin tmp := mc_lab [ i ] ;
73140: LD_ADDR_VAR 0 6
73144: PUSH
73145: LD_EXP 94
73149: PUSH
73150: LD_VAR 0 2
73154: ARRAY
73155: ST_TO_ADDR
// if not tmp then
73156: LD_VAR 0 6
73160: NOT
73161: IFFALSE 73165
// continue ;
73163: GO 73137
// idle_lab := 0 ;
73165: LD_ADDR_VAR 0 11
73169: PUSH
73170: LD_INT 0
73172: ST_TO_ADDR
// for j in tmp do
73173: LD_ADDR_VAR 0 3
73177: PUSH
73178: LD_VAR 0 6
73182: PUSH
73183: FOR_IN
73184: IFFALSE 74203
// begin researching := false ;
73186: LD_ADDR_VAR 0 10
73190: PUSH
73191: LD_INT 0
73193: ST_TO_ADDR
// side := GetSide ( j ) ;
73194: LD_ADDR_VAR 0 4
73198: PUSH
73199: LD_VAR 0 3
73203: PPUSH
73204: CALL_OW 255
73208: ST_TO_ADDR
// if not mc_tech [ side ] then
73209: LD_EXP 88
73213: PUSH
73214: LD_VAR 0 4
73218: ARRAY
73219: NOT
73220: IFFALSE 73224
// continue ;
73222: GO 73183
// if BuildingStatus ( j ) = bs_idle then
73224: LD_VAR 0 3
73228: PPUSH
73229: CALL_OW 461
73233: PUSH
73234: LD_INT 2
73236: EQUAL
73237: IFFALSE 73425
// begin if idle_lab and UnitsInside ( j ) < 6 then
73239: LD_VAR 0 11
73243: PUSH
73244: LD_VAR 0 3
73248: PPUSH
73249: CALL_OW 313
73253: PUSH
73254: LD_INT 6
73256: LESS
73257: AND
73258: IFFALSE 73329
// begin tmp2 := UnitsInside ( idle_lab ) ;
73260: LD_ADDR_VAR 0 9
73264: PUSH
73265: LD_VAR 0 11
73269: PPUSH
73270: CALL_OW 313
73274: ST_TO_ADDR
// if tmp2 then
73275: LD_VAR 0 9
73279: IFFALSE 73321
// for x in tmp2 do
73281: LD_ADDR_VAR 0 7
73285: PUSH
73286: LD_VAR 0 9
73290: PUSH
73291: FOR_IN
73292: IFFALSE 73319
// begin ComExitBuilding ( x ) ;
73294: LD_VAR 0 7
73298: PPUSH
73299: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73303: LD_VAR 0 7
73307: PPUSH
73308: LD_VAR 0 3
73312: PPUSH
73313: CALL_OW 180
// end ;
73317: GO 73291
73319: POP
73320: POP
// idle_lab := 0 ;
73321: LD_ADDR_VAR 0 11
73325: PUSH
73326: LD_INT 0
73328: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73329: LD_ADDR_VAR 0 5
73333: PUSH
73334: LD_EXP 88
73338: PUSH
73339: LD_VAR 0 4
73343: ARRAY
73344: PUSH
73345: FOR_IN
73346: IFFALSE 73406
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73348: LD_VAR 0 3
73352: PPUSH
73353: LD_VAR 0 5
73357: PPUSH
73358: CALL_OW 430
73362: PUSH
73363: LD_VAR 0 4
73367: PPUSH
73368: LD_VAR 0 5
73372: PPUSH
73373: CALL 15806 0 2
73377: AND
73378: IFFALSE 73404
// begin researching := true ;
73380: LD_ADDR_VAR 0 10
73384: PUSH
73385: LD_INT 1
73387: ST_TO_ADDR
// ComResearch ( j , t ) ;
73388: LD_VAR 0 3
73392: PPUSH
73393: LD_VAR 0 5
73397: PPUSH
73398: CALL_OW 124
// break ;
73402: GO 73406
// end ;
73404: GO 73345
73406: POP
73407: POP
// if not researching then
73408: LD_VAR 0 10
73412: NOT
73413: IFFALSE 73425
// idle_lab := j ;
73415: LD_ADDR_VAR 0 11
73419: PUSH
73420: LD_VAR 0 3
73424: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73425: LD_VAR 0 3
73429: PPUSH
73430: CALL_OW 461
73434: PUSH
73435: LD_INT 10
73437: EQUAL
73438: IFFALSE 74026
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73440: LD_EXP 90
73444: PUSH
73445: LD_VAR 0 2
73449: ARRAY
73450: NOT
73451: PUSH
73452: LD_EXP 91
73456: PUSH
73457: LD_VAR 0 2
73461: ARRAY
73462: NOT
73463: AND
73464: PUSH
73465: LD_EXP 88
73469: PUSH
73470: LD_VAR 0 4
73474: ARRAY
73475: PUSH
73476: LD_INT 1
73478: GREATER
73479: AND
73480: IFFALSE 73611
// begin ComCancel ( j ) ;
73482: LD_VAR 0 3
73486: PPUSH
73487: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73491: LD_ADDR_EXP 88
73495: PUSH
73496: LD_EXP 88
73500: PPUSH
73501: LD_VAR 0 4
73505: PPUSH
73506: LD_EXP 88
73510: PUSH
73511: LD_VAR 0 4
73515: ARRAY
73516: PPUSH
73517: LD_EXP 88
73521: PUSH
73522: LD_VAR 0 4
73526: ARRAY
73527: PUSH
73528: LD_INT 1
73530: MINUS
73531: PPUSH
73532: LD_EXP 88
73536: PUSH
73537: LD_VAR 0 4
73541: ARRAY
73542: PPUSH
73543: LD_INT 0
73545: PPUSH
73546: CALL 19330 0 4
73550: PPUSH
73551: CALL_OW 1
73555: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73556: LD_ADDR_EXP 88
73560: PUSH
73561: LD_EXP 88
73565: PPUSH
73566: LD_VAR 0 4
73570: PPUSH
73571: LD_EXP 88
73575: PUSH
73576: LD_VAR 0 4
73580: ARRAY
73581: PPUSH
73582: LD_EXP 88
73586: PUSH
73587: LD_VAR 0 4
73591: ARRAY
73592: PPUSH
73593: LD_INT 1
73595: PPUSH
73596: LD_INT 0
73598: PPUSH
73599: CALL 19330 0 4
73603: PPUSH
73604: CALL_OW 1
73608: ST_TO_ADDR
// continue ;
73609: GO 73183
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73611: LD_EXP 90
73615: PUSH
73616: LD_VAR 0 2
73620: ARRAY
73621: PUSH
73622: LD_EXP 91
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: NOT
73633: AND
73634: IFFALSE 73761
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73636: LD_ADDR_EXP 91
73640: PUSH
73641: LD_EXP 91
73645: PPUSH
73646: LD_VAR 0 2
73650: PUSH
73651: LD_EXP 91
73655: PUSH
73656: LD_VAR 0 2
73660: ARRAY
73661: PUSH
73662: LD_INT 1
73664: PLUS
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PPUSH
73670: LD_EXP 90
73674: PUSH
73675: LD_VAR 0 2
73679: ARRAY
73680: PUSH
73681: LD_INT 1
73683: ARRAY
73684: PPUSH
73685: CALL 19912 0 3
73689: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73690: LD_EXP 90
73694: PUSH
73695: LD_VAR 0 2
73699: ARRAY
73700: PUSH
73701: LD_INT 1
73703: ARRAY
73704: PPUSH
73705: LD_INT 112
73707: PPUSH
73708: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73712: LD_ADDR_VAR 0 9
73716: PUSH
73717: LD_EXP 90
73721: PUSH
73722: LD_VAR 0 2
73726: ARRAY
73727: PPUSH
73728: LD_INT 1
73730: PPUSH
73731: CALL_OW 3
73735: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73736: LD_ADDR_EXP 90
73740: PUSH
73741: LD_EXP 90
73745: PPUSH
73746: LD_VAR 0 2
73750: PPUSH
73751: LD_VAR 0 9
73755: PPUSH
73756: CALL_OW 1
73760: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73761: LD_EXP 90
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: PUSH
73772: LD_EXP 91
73776: PUSH
73777: LD_VAR 0 2
73781: ARRAY
73782: AND
73783: PUSH
73784: LD_EXP 91
73788: PUSH
73789: LD_VAR 0 2
73793: ARRAY
73794: PUSH
73795: LD_INT 1
73797: ARRAY
73798: PPUSH
73799: CALL_OW 310
73803: NOT
73804: AND
73805: PUSH
73806: LD_VAR 0 3
73810: PPUSH
73811: CALL_OW 313
73815: PUSH
73816: LD_INT 6
73818: EQUAL
73819: AND
73820: IFFALSE 73876
// begin tmp2 := UnitsInside ( j ) ;
73822: LD_ADDR_VAR 0 9
73826: PUSH
73827: LD_VAR 0 3
73831: PPUSH
73832: CALL_OW 313
73836: ST_TO_ADDR
// if tmp2 = 6 then
73837: LD_VAR 0 9
73841: PUSH
73842: LD_INT 6
73844: EQUAL
73845: IFFALSE 73876
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73847: LD_VAR 0 9
73851: PUSH
73852: LD_INT 1
73854: ARRAY
73855: PPUSH
73856: LD_INT 112
73858: PPUSH
73859: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73863: LD_VAR 0 9
73867: PUSH
73868: LD_INT 1
73870: ARRAY
73871: PPUSH
73872: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73876: LD_EXP 91
73880: PUSH
73881: LD_VAR 0 2
73885: ARRAY
73886: PUSH
73887: LD_EXP 91
73891: PUSH
73892: LD_VAR 0 2
73896: ARRAY
73897: PUSH
73898: LD_INT 1
73900: ARRAY
73901: PPUSH
73902: CALL_OW 314
73906: NOT
73907: AND
73908: PUSH
73909: LD_EXP 91
73913: PUSH
73914: LD_VAR 0 2
73918: ARRAY
73919: PUSH
73920: LD_INT 1
73922: ARRAY
73923: PPUSH
73924: CALL_OW 310
73928: NOT
73929: AND
73930: IFFALSE 73956
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73932: LD_EXP 91
73936: PUSH
73937: LD_VAR 0 2
73941: ARRAY
73942: PUSH
73943: LD_INT 1
73945: ARRAY
73946: PPUSH
73947: LD_VAR 0 3
73951: PPUSH
73952: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73956: LD_EXP 91
73960: PUSH
73961: LD_VAR 0 2
73965: ARRAY
73966: PUSH
73967: LD_INT 1
73969: ARRAY
73970: PPUSH
73971: CALL_OW 310
73975: PUSH
73976: LD_EXP 91
73980: PUSH
73981: LD_VAR 0 2
73985: ARRAY
73986: PUSH
73987: LD_INT 1
73989: ARRAY
73990: PPUSH
73991: CALL_OW 310
73995: PPUSH
73996: CALL_OW 461
74000: PUSH
74001: LD_INT 3
74003: NONEQUAL
74004: AND
74005: IFFALSE 74026
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74007: LD_EXP 91
74011: PUSH
74012: LD_VAR 0 2
74016: ARRAY
74017: PUSH
74018: LD_INT 1
74020: ARRAY
74021: PPUSH
74022: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74026: LD_VAR 0 3
74030: PPUSH
74031: CALL_OW 461
74035: PUSH
74036: LD_INT 6
74038: EQUAL
74039: PUSH
74040: LD_VAR 0 6
74044: PUSH
74045: LD_INT 1
74047: GREATER
74048: AND
74049: IFFALSE 74201
// begin sci := [ ] ;
74051: LD_ADDR_VAR 0 8
74055: PUSH
74056: EMPTY
74057: ST_TO_ADDR
// for x in ( tmp diff j ) do
74058: LD_ADDR_VAR 0 7
74062: PUSH
74063: LD_VAR 0 6
74067: PUSH
74068: LD_VAR 0 3
74072: DIFF
74073: PUSH
74074: FOR_IN
74075: IFFALSE 74127
// begin if sci = 6 then
74077: LD_VAR 0 8
74081: PUSH
74082: LD_INT 6
74084: EQUAL
74085: IFFALSE 74089
// break ;
74087: GO 74127
// if BuildingStatus ( x ) = bs_idle then
74089: LD_VAR 0 7
74093: PPUSH
74094: CALL_OW 461
74098: PUSH
74099: LD_INT 2
74101: EQUAL
74102: IFFALSE 74125
// sci := sci ^ UnitsInside ( x ) ;
74104: LD_ADDR_VAR 0 8
74108: PUSH
74109: LD_VAR 0 8
74113: PUSH
74114: LD_VAR 0 7
74118: PPUSH
74119: CALL_OW 313
74123: ADD
74124: ST_TO_ADDR
// end ;
74125: GO 74074
74127: POP
74128: POP
// if not sci then
74129: LD_VAR 0 8
74133: NOT
74134: IFFALSE 74138
// continue ;
74136: GO 73183
// for x in sci do
74138: LD_ADDR_VAR 0 7
74142: PUSH
74143: LD_VAR 0 8
74147: PUSH
74148: FOR_IN
74149: IFFALSE 74199
// if IsInUnit ( x ) and not HasTask ( x ) then
74151: LD_VAR 0 7
74155: PPUSH
74156: CALL_OW 310
74160: PUSH
74161: LD_VAR 0 7
74165: PPUSH
74166: CALL_OW 314
74170: NOT
74171: AND
74172: IFFALSE 74197
// begin ComExitBuilding ( x ) ;
74174: LD_VAR 0 7
74178: PPUSH
74179: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74183: LD_VAR 0 7
74187: PPUSH
74188: LD_VAR 0 3
74192: PPUSH
74193: CALL_OW 180
// end ;
74197: GO 74148
74199: POP
74200: POP
// end ; end ;
74201: GO 73183
74203: POP
74204: POP
// end ;
74205: GO 73137
74207: POP
74208: POP
// end ;
74209: LD_VAR 0 1
74213: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74214: LD_INT 0
74216: PPUSH
74217: PPUSH
// if not mc_bases then
74218: LD_EXP 61
74222: NOT
74223: IFFALSE 74227
// exit ;
74225: GO 74308
// for i = 1 to mc_bases do
74227: LD_ADDR_VAR 0 2
74231: PUSH
74232: DOUBLE
74233: LD_INT 1
74235: DEC
74236: ST_TO_ADDR
74237: LD_EXP 61
74241: PUSH
74242: FOR_TO
74243: IFFALSE 74306
// if mc_mines [ i ] and mc_miners [ i ] then
74245: LD_EXP 74
74249: PUSH
74250: LD_VAR 0 2
74254: ARRAY
74255: PUSH
74256: LD_EXP 75
74260: PUSH
74261: LD_VAR 0 2
74265: ARRAY
74266: AND
74267: IFFALSE 74304
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74269: LD_EXP 75
74273: PUSH
74274: LD_VAR 0 2
74278: ARRAY
74279: PUSH
74280: LD_INT 1
74282: ARRAY
74283: PPUSH
74284: CALL_OW 255
74288: PPUSH
74289: LD_EXP 74
74293: PUSH
74294: LD_VAR 0 2
74298: ARRAY
74299: PPUSH
74300: CALL 16889 0 2
74304: GO 74242
74306: POP
74307: POP
// end ;
74308: LD_VAR 0 1
74312: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74313: LD_INT 0
74315: PPUSH
74316: PPUSH
74317: PPUSH
74318: PPUSH
74319: PPUSH
74320: PPUSH
74321: PPUSH
74322: PPUSH
// if not mc_bases or not mc_parking then
74323: LD_EXP 61
74327: NOT
74328: PUSH
74329: LD_EXP 85
74333: NOT
74334: OR
74335: IFFALSE 74339
// exit ;
74337: GO 75077
// for i = 1 to mc_bases do
74339: LD_ADDR_VAR 0 2
74343: PUSH
74344: DOUBLE
74345: LD_INT 1
74347: DEC
74348: ST_TO_ADDR
74349: LD_EXP 61
74353: PUSH
74354: FOR_TO
74355: IFFALSE 75075
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74357: LD_EXP 61
74361: PUSH
74362: LD_VAR 0 2
74366: ARRAY
74367: NOT
74368: PUSH
74369: LD_EXP 85
74373: PUSH
74374: LD_VAR 0 2
74378: ARRAY
74379: NOT
74380: OR
74381: IFFALSE 74385
// continue ;
74383: GO 74354
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74385: LD_ADDR_VAR 0 5
74389: PUSH
74390: LD_EXP 61
74394: PUSH
74395: LD_VAR 0 2
74399: ARRAY
74400: PUSH
74401: LD_INT 1
74403: ARRAY
74404: PPUSH
74405: CALL_OW 255
74409: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74410: LD_ADDR_VAR 0 6
74414: PUSH
74415: LD_EXP 61
74419: PUSH
74420: LD_VAR 0 2
74424: ARRAY
74425: PPUSH
74426: LD_INT 30
74428: PUSH
74429: LD_INT 3
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PPUSH
74436: CALL_OW 72
74440: ST_TO_ADDR
// if not fac then
74441: LD_VAR 0 6
74445: NOT
74446: IFFALSE 74497
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74448: LD_ADDR_VAR 0 6
74452: PUSH
74453: LD_EXP 61
74457: PUSH
74458: LD_VAR 0 2
74462: ARRAY
74463: PPUSH
74464: LD_INT 2
74466: PUSH
74467: LD_INT 30
74469: PUSH
74470: LD_INT 0
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 30
74479: PUSH
74480: LD_INT 1
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: LIST
74491: PPUSH
74492: CALL_OW 72
74496: ST_TO_ADDR
// if not fac then
74497: LD_VAR 0 6
74501: NOT
74502: IFFALSE 74506
// continue ;
74504: GO 74354
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74506: LD_ADDR_VAR 0 7
74510: PUSH
74511: LD_EXP 85
74515: PUSH
74516: LD_VAR 0 2
74520: ARRAY
74521: PPUSH
74522: LD_INT 22
74524: PUSH
74525: LD_VAR 0 5
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 21
74536: PUSH
74537: LD_INT 2
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 3
74546: PUSH
74547: LD_INT 60
74549: PUSH
74550: EMPTY
74551: LIST
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 3
74559: PUSH
74560: LD_INT 24
74562: PUSH
74563: LD_INT 1000
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: PPUSH
74580: CALL_OW 70
74584: ST_TO_ADDR
// for j in fac do
74585: LD_ADDR_VAR 0 3
74589: PUSH
74590: LD_VAR 0 6
74594: PUSH
74595: FOR_IN
74596: IFFALSE 74691
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74598: LD_ADDR_VAR 0 7
74602: PUSH
74603: LD_VAR 0 7
74607: PUSH
74608: LD_INT 22
74610: PUSH
74611: LD_VAR 0 5
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 91
74622: PUSH
74623: LD_VAR 0 3
74627: PUSH
74628: LD_INT 15
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 21
74638: PUSH
74639: LD_INT 2
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 3
74648: PUSH
74649: LD_INT 60
74651: PUSH
74652: EMPTY
74653: LIST
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 3
74661: PUSH
74662: LD_INT 24
74664: PUSH
74665: LD_INT 1000
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: PPUSH
74683: CALL_OW 69
74687: UNION
74688: ST_TO_ADDR
74689: GO 74595
74691: POP
74692: POP
// if not vehs then
74693: LD_VAR 0 7
74697: NOT
74698: IFFALSE 74724
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74700: LD_ADDR_EXP 73
74704: PUSH
74705: LD_EXP 73
74709: PPUSH
74710: LD_VAR 0 2
74714: PPUSH
74715: EMPTY
74716: PPUSH
74717: CALL_OW 1
74721: ST_TO_ADDR
// continue ;
74722: GO 74354
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74724: LD_ADDR_VAR 0 8
74728: PUSH
74729: LD_EXP 61
74733: PUSH
74734: LD_VAR 0 2
74738: ARRAY
74739: PPUSH
74740: LD_INT 30
74742: PUSH
74743: LD_INT 3
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PPUSH
74750: CALL_OW 72
74754: ST_TO_ADDR
// if tmp then
74755: LD_VAR 0 8
74759: IFFALSE 74862
// begin for j in tmp do
74761: LD_ADDR_VAR 0 3
74765: PUSH
74766: LD_VAR 0 8
74770: PUSH
74771: FOR_IN
74772: IFFALSE 74860
// for k in UnitsInside ( j ) do
74774: LD_ADDR_VAR 0 4
74778: PUSH
74779: LD_VAR 0 3
74783: PPUSH
74784: CALL_OW 313
74788: PUSH
74789: FOR_IN
74790: IFFALSE 74856
// if k then
74792: LD_VAR 0 4
74796: IFFALSE 74854
// if not k in mc_repair_vehicle [ i ] then
74798: LD_VAR 0 4
74802: PUSH
74803: LD_EXP 73
74807: PUSH
74808: LD_VAR 0 2
74812: ARRAY
74813: IN
74814: NOT
74815: IFFALSE 74854
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74817: LD_ADDR_EXP 73
74821: PUSH
74822: LD_EXP 73
74826: PPUSH
74827: LD_VAR 0 2
74831: PPUSH
74832: LD_EXP 73
74836: PUSH
74837: LD_VAR 0 2
74841: ARRAY
74842: PUSH
74843: LD_VAR 0 4
74847: UNION
74848: PPUSH
74849: CALL_OW 1
74853: ST_TO_ADDR
74854: GO 74789
74856: POP
74857: POP
74858: GO 74771
74860: POP
74861: POP
// end ; if not mc_repair_vehicle [ i ] then
74862: LD_EXP 73
74866: PUSH
74867: LD_VAR 0 2
74871: ARRAY
74872: NOT
74873: IFFALSE 74877
// continue ;
74875: GO 74354
// for j in mc_repair_vehicle [ i ] do
74877: LD_ADDR_VAR 0 3
74881: PUSH
74882: LD_EXP 73
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: PUSH
74893: FOR_IN
74894: IFFALSE 75071
// begin if GetClass ( j ) <> 3 then
74896: LD_VAR 0 3
74900: PPUSH
74901: CALL_OW 257
74905: PUSH
74906: LD_INT 3
74908: NONEQUAL
74909: IFFALSE 74950
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74911: LD_ADDR_EXP 73
74915: PUSH
74916: LD_EXP 73
74920: PPUSH
74921: LD_VAR 0 2
74925: PPUSH
74926: LD_EXP 73
74930: PUSH
74931: LD_VAR 0 2
74935: ARRAY
74936: PUSH
74937: LD_VAR 0 3
74941: DIFF
74942: PPUSH
74943: CALL_OW 1
74947: ST_TO_ADDR
// continue ;
74948: GO 74893
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74950: LD_VAR 0 3
74954: PPUSH
74955: CALL_OW 311
74959: NOT
74960: PUSH
74961: LD_VAR 0 3
74965: PUSH
74966: LD_EXP 64
74970: PUSH
74971: LD_VAR 0 2
74975: ARRAY
74976: PUSH
74977: LD_INT 1
74979: ARRAY
74980: IN
74981: NOT
74982: AND
74983: PUSH
74984: LD_VAR 0 3
74988: PUSH
74989: LD_EXP 64
74993: PUSH
74994: LD_VAR 0 2
74998: ARRAY
74999: PUSH
75000: LD_INT 2
75002: ARRAY
75003: IN
75004: NOT
75005: AND
75006: IFFALSE 75069
// begin if IsInUnit ( j ) then
75008: LD_VAR 0 3
75012: PPUSH
75013: CALL_OW 310
75017: IFFALSE 75030
// ComExitBuilding ( j ) else
75019: LD_VAR 0 3
75023: PPUSH
75024: CALL_OW 122
75028: GO 75069
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75030: LD_VAR 0 3
75034: PPUSH
75035: LD_VAR 0 7
75039: PUSH
75040: LD_INT 1
75042: ARRAY
75043: PPUSH
75044: CALL 54307 0 2
75048: NOT
75049: IFFALSE 75069
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75051: LD_VAR 0 3
75055: PPUSH
75056: LD_VAR 0 7
75060: PUSH
75061: LD_INT 1
75063: ARRAY
75064: PPUSH
75065: CALL_OW 129
// end ; end ;
75069: GO 74893
75071: POP
75072: POP
// end ;
75073: GO 74354
75075: POP
75076: POP
// end ;
75077: LD_VAR 0 1
75081: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75082: LD_INT 0
75084: PPUSH
75085: PPUSH
75086: PPUSH
75087: PPUSH
75088: PPUSH
75089: PPUSH
75090: PPUSH
75091: PPUSH
75092: PPUSH
75093: PPUSH
75094: PPUSH
// if not mc_bases then
75095: LD_EXP 61
75099: NOT
75100: IFFALSE 75104
// exit ;
75102: GO 75906
// for i = 1 to mc_bases do
75104: LD_ADDR_VAR 0 2
75108: PUSH
75109: DOUBLE
75110: LD_INT 1
75112: DEC
75113: ST_TO_ADDR
75114: LD_EXP 61
75118: PUSH
75119: FOR_TO
75120: IFFALSE 75904
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75122: LD_EXP 89
75126: PUSH
75127: LD_VAR 0 2
75131: ARRAY
75132: NOT
75133: PUSH
75134: LD_EXP 64
75138: PUSH
75139: LD_VAR 0 2
75143: ARRAY
75144: PUSH
75145: LD_INT 1
75147: ARRAY
75148: OR
75149: PUSH
75150: LD_EXP 64
75154: PUSH
75155: LD_VAR 0 2
75159: ARRAY
75160: PUSH
75161: LD_INT 2
75163: ARRAY
75164: OR
75165: PUSH
75166: LD_EXP 87
75170: PUSH
75171: LD_VAR 0 2
75175: ARRAY
75176: PPUSH
75177: LD_INT 1
75179: PPUSH
75180: CALL_OW 325
75184: NOT
75185: OR
75186: PUSH
75187: LD_EXP 84
75191: PUSH
75192: LD_VAR 0 2
75196: ARRAY
75197: OR
75198: IFFALSE 75202
// continue ;
75200: GO 75119
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75202: LD_ADDR_VAR 0 8
75206: PUSH
75207: LD_EXP 61
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: PPUSH
75218: LD_INT 25
75220: PUSH
75221: LD_INT 4
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: LD_INT 50
75230: PUSH
75231: EMPTY
75232: LIST
75233: PUSH
75234: LD_INT 3
75236: PUSH
75237: LD_INT 60
75239: PUSH
75240: EMPTY
75241: LIST
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: LIST
75251: PPUSH
75252: CALL_OW 72
75256: PUSH
75257: LD_EXP 65
75261: PUSH
75262: LD_VAR 0 2
75266: ARRAY
75267: DIFF
75268: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75269: LD_ADDR_VAR 0 9
75273: PUSH
75274: LD_EXP 61
75278: PUSH
75279: LD_VAR 0 2
75283: ARRAY
75284: PPUSH
75285: LD_INT 2
75287: PUSH
75288: LD_INT 30
75290: PUSH
75291: LD_INT 0
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 30
75300: PUSH
75301: LD_INT 1
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: LIST
75312: PPUSH
75313: CALL_OW 72
75317: ST_TO_ADDR
// if not tmp or not dep then
75318: LD_VAR 0 8
75322: NOT
75323: PUSH
75324: LD_VAR 0 9
75328: NOT
75329: OR
75330: IFFALSE 75334
// continue ;
75332: GO 75119
// side := GetSide ( tmp [ 1 ] ) ;
75334: LD_ADDR_VAR 0 11
75338: PUSH
75339: LD_VAR 0 8
75343: PUSH
75344: LD_INT 1
75346: ARRAY
75347: PPUSH
75348: CALL_OW 255
75352: ST_TO_ADDR
// dep := dep [ 1 ] ;
75353: LD_ADDR_VAR 0 9
75357: PUSH
75358: LD_VAR 0 9
75362: PUSH
75363: LD_INT 1
75365: ARRAY
75366: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75367: LD_ADDR_VAR 0 7
75371: PUSH
75372: LD_EXP 89
75376: PUSH
75377: LD_VAR 0 2
75381: ARRAY
75382: PPUSH
75383: LD_INT 22
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: LD_INT 25
75395: PUSH
75396: LD_INT 12
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PPUSH
75407: CALL_OW 70
75411: PUSH
75412: LD_INT 22
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 25
75424: PUSH
75425: LD_INT 12
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 91
75434: PUSH
75435: LD_VAR 0 9
75439: PUSH
75440: LD_INT 20
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: LIST
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: LIST
75452: PPUSH
75453: CALL_OW 69
75457: UNION
75458: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75459: LD_ADDR_VAR 0 10
75463: PUSH
75464: LD_EXP 89
75468: PUSH
75469: LD_VAR 0 2
75473: ARRAY
75474: PPUSH
75475: LD_INT 81
75477: PUSH
75478: LD_VAR 0 11
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PPUSH
75487: CALL_OW 70
75491: ST_TO_ADDR
// if not apes or danger_at_area then
75492: LD_VAR 0 7
75496: NOT
75497: PUSH
75498: LD_VAR 0 10
75502: OR
75503: IFFALSE 75553
// begin if mc_taming [ i ] then
75505: LD_EXP 92
75509: PUSH
75510: LD_VAR 0 2
75514: ARRAY
75515: IFFALSE 75551
// begin MC_Reset ( i , 121 ) ;
75517: LD_VAR 0 2
75521: PPUSH
75522: LD_INT 121
75524: PPUSH
75525: CALL 60483 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75529: LD_ADDR_EXP 92
75533: PUSH
75534: LD_EXP 92
75538: PPUSH
75539: LD_VAR 0 2
75543: PPUSH
75544: EMPTY
75545: PPUSH
75546: CALL_OW 1
75550: ST_TO_ADDR
// end ; continue ;
75551: GO 75119
// end ; for j in tmp do
75553: LD_ADDR_VAR 0 3
75557: PUSH
75558: LD_VAR 0 8
75562: PUSH
75563: FOR_IN
75564: IFFALSE 75900
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75566: LD_VAR 0 3
75570: PUSH
75571: LD_EXP 92
75575: PUSH
75576: LD_VAR 0 2
75580: ARRAY
75581: IN
75582: NOT
75583: PUSH
75584: LD_EXP 92
75588: PUSH
75589: LD_VAR 0 2
75593: ARRAY
75594: PUSH
75595: LD_INT 3
75597: LESS
75598: AND
75599: IFFALSE 75657
// begin SetTag ( j , 121 ) ;
75601: LD_VAR 0 3
75605: PPUSH
75606: LD_INT 121
75608: PPUSH
75609: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75613: LD_ADDR_EXP 92
75617: PUSH
75618: LD_EXP 92
75622: PPUSH
75623: LD_VAR 0 2
75627: PUSH
75628: LD_EXP 92
75632: PUSH
75633: LD_VAR 0 2
75637: ARRAY
75638: PUSH
75639: LD_INT 1
75641: PLUS
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PPUSH
75647: LD_VAR 0 3
75651: PPUSH
75652: CALL 19912 0 3
75656: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75657: LD_VAR 0 3
75661: PUSH
75662: LD_EXP 92
75666: PUSH
75667: LD_VAR 0 2
75671: ARRAY
75672: IN
75673: IFFALSE 75898
// begin if GetClass ( j ) <> 4 then
75675: LD_VAR 0 3
75679: PPUSH
75680: CALL_OW 257
75684: PUSH
75685: LD_INT 4
75687: NONEQUAL
75688: IFFALSE 75741
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75690: LD_ADDR_EXP 92
75694: PUSH
75695: LD_EXP 92
75699: PPUSH
75700: LD_VAR 0 2
75704: PPUSH
75705: LD_EXP 92
75709: PUSH
75710: LD_VAR 0 2
75714: ARRAY
75715: PUSH
75716: LD_VAR 0 3
75720: DIFF
75721: PPUSH
75722: CALL_OW 1
75726: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75727: LD_VAR 0 3
75731: PPUSH
75732: LD_INT 0
75734: PPUSH
75735: CALL_OW 109
// continue ;
75739: GO 75563
// end ; if IsInUnit ( j ) then
75741: LD_VAR 0 3
75745: PPUSH
75746: CALL_OW 310
75750: IFFALSE 75761
// ComExitBuilding ( j ) ;
75752: LD_VAR 0 3
75756: PPUSH
75757: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75761: LD_ADDR_VAR 0 6
75765: PUSH
75766: LD_VAR 0 7
75770: PPUSH
75771: LD_VAR 0 3
75775: PPUSH
75776: CALL_OW 74
75780: ST_TO_ADDR
// if not ape then
75781: LD_VAR 0 6
75785: NOT
75786: IFFALSE 75790
// break ;
75788: GO 75900
// x := GetX ( ape ) ;
75790: LD_ADDR_VAR 0 4
75794: PUSH
75795: LD_VAR 0 6
75799: PPUSH
75800: CALL_OW 250
75804: ST_TO_ADDR
// y := GetY ( ape ) ;
75805: LD_ADDR_VAR 0 5
75809: PUSH
75810: LD_VAR 0 6
75814: PPUSH
75815: CALL_OW 251
75819: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75820: LD_VAR 0 4
75824: PPUSH
75825: LD_VAR 0 5
75829: PPUSH
75830: CALL_OW 488
75834: NOT
75835: PUSH
75836: LD_VAR 0 11
75840: PPUSH
75841: LD_VAR 0 4
75845: PPUSH
75846: LD_VAR 0 5
75850: PPUSH
75851: LD_INT 20
75853: PPUSH
75854: CALL 20808 0 4
75858: PUSH
75859: LD_INT 4
75861: ARRAY
75862: OR
75863: IFFALSE 75867
// break ;
75865: GO 75900
// if not HasTask ( j ) then
75867: LD_VAR 0 3
75871: PPUSH
75872: CALL_OW 314
75876: NOT
75877: IFFALSE 75898
// ComTameXY ( j , x , y ) ;
75879: LD_VAR 0 3
75883: PPUSH
75884: LD_VAR 0 4
75888: PPUSH
75889: LD_VAR 0 5
75893: PPUSH
75894: CALL_OW 131
// end ; end ;
75898: GO 75563
75900: POP
75901: POP
// end ;
75902: GO 75119
75904: POP
75905: POP
// end ;
75906: LD_VAR 0 1
75910: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75911: LD_INT 0
75913: PPUSH
75914: PPUSH
75915: PPUSH
75916: PPUSH
75917: PPUSH
75918: PPUSH
75919: PPUSH
75920: PPUSH
// if not mc_bases then
75921: LD_EXP 61
75925: NOT
75926: IFFALSE 75930
// exit ;
75928: GO 76556
// for i = 1 to mc_bases do
75930: LD_ADDR_VAR 0 2
75934: PUSH
75935: DOUBLE
75936: LD_INT 1
75938: DEC
75939: ST_TO_ADDR
75940: LD_EXP 61
75944: PUSH
75945: FOR_TO
75946: IFFALSE 76554
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75948: LD_EXP 90
75952: PUSH
75953: LD_VAR 0 2
75957: ARRAY
75958: NOT
75959: PUSH
75960: LD_EXP 90
75964: PUSH
75965: LD_VAR 0 2
75969: ARRAY
75970: PPUSH
75971: LD_INT 25
75973: PUSH
75974: LD_INT 12
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PPUSH
75981: CALL_OW 72
75985: NOT
75986: OR
75987: IFFALSE 75991
// continue ;
75989: GO 75945
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75991: LD_ADDR_VAR 0 5
75995: PUSH
75996: LD_EXP 90
76000: PUSH
76001: LD_VAR 0 2
76005: ARRAY
76006: PUSH
76007: LD_INT 1
76009: ARRAY
76010: PPUSH
76011: CALL_OW 255
76015: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76016: LD_VAR 0 5
76020: PPUSH
76021: LD_INT 2
76023: PPUSH
76024: CALL_OW 325
76028: IFFALSE 76281
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76030: LD_ADDR_VAR 0 4
76034: PUSH
76035: LD_EXP 90
76039: PUSH
76040: LD_VAR 0 2
76044: ARRAY
76045: PPUSH
76046: LD_INT 25
76048: PUSH
76049: LD_INT 16
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PPUSH
76056: CALL_OW 72
76060: ST_TO_ADDR
// if tmp < 6 then
76061: LD_VAR 0 4
76065: PUSH
76066: LD_INT 6
76068: LESS
76069: IFFALSE 76281
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76071: LD_ADDR_VAR 0 6
76075: PUSH
76076: LD_EXP 61
76080: PUSH
76081: LD_VAR 0 2
76085: ARRAY
76086: PPUSH
76087: LD_INT 2
76089: PUSH
76090: LD_INT 30
76092: PUSH
76093: LD_INT 0
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: LD_INT 30
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: LIST
76114: PPUSH
76115: CALL_OW 72
76119: ST_TO_ADDR
// if depot then
76120: LD_VAR 0 6
76124: IFFALSE 76281
// begin selected := 0 ;
76126: LD_ADDR_VAR 0 7
76130: PUSH
76131: LD_INT 0
76133: ST_TO_ADDR
// for j in depot do
76134: LD_ADDR_VAR 0 3
76138: PUSH
76139: LD_VAR 0 6
76143: PUSH
76144: FOR_IN
76145: IFFALSE 76176
// begin if UnitsInside ( j ) < 6 then
76147: LD_VAR 0 3
76151: PPUSH
76152: CALL_OW 313
76156: PUSH
76157: LD_INT 6
76159: LESS
76160: IFFALSE 76174
// begin selected := j ;
76162: LD_ADDR_VAR 0 7
76166: PUSH
76167: LD_VAR 0 3
76171: ST_TO_ADDR
// break ;
76172: GO 76176
// end ; end ;
76174: GO 76144
76176: POP
76177: POP
// if selected then
76178: LD_VAR 0 7
76182: IFFALSE 76281
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76184: LD_ADDR_VAR 0 3
76188: PUSH
76189: LD_EXP 90
76193: PUSH
76194: LD_VAR 0 2
76198: ARRAY
76199: PPUSH
76200: LD_INT 25
76202: PUSH
76203: LD_INT 12
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PPUSH
76210: CALL_OW 72
76214: PUSH
76215: FOR_IN
76216: IFFALSE 76279
// if not HasTask ( j ) then
76218: LD_VAR 0 3
76222: PPUSH
76223: CALL_OW 314
76227: NOT
76228: IFFALSE 76277
// begin if not IsInUnit ( j ) then
76230: LD_VAR 0 3
76234: PPUSH
76235: CALL_OW 310
76239: NOT
76240: IFFALSE 76256
// ComEnterUnit ( j , selected ) ;
76242: LD_VAR 0 3
76246: PPUSH
76247: LD_VAR 0 7
76251: PPUSH
76252: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76256: LD_VAR 0 3
76260: PPUSH
76261: LD_INT 16
76263: PPUSH
76264: CALL_OW 183
// AddComExitBuilding ( j ) ;
76268: LD_VAR 0 3
76272: PPUSH
76273: CALL_OW 182
// end ;
76277: GO 76215
76279: POP
76280: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76281: LD_VAR 0 5
76285: PPUSH
76286: LD_INT 11
76288: PPUSH
76289: CALL_OW 325
76293: IFFALSE 76552
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76295: LD_ADDR_VAR 0 4
76299: PUSH
76300: LD_EXP 90
76304: PUSH
76305: LD_VAR 0 2
76309: ARRAY
76310: PPUSH
76311: LD_INT 25
76313: PUSH
76314: LD_INT 16
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PPUSH
76321: CALL_OW 72
76325: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76326: LD_VAR 0 4
76330: PUSH
76331: LD_INT 6
76333: GREATEREQUAL
76334: PUSH
76335: LD_VAR 0 5
76339: PPUSH
76340: LD_INT 2
76342: PPUSH
76343: CALL_OW 325
76347: NOT
76348: OR
76349: IFFALSE 76552
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76351: LD_ADDR_VAR 0 8
76355: PUSH
76356: LD_EXP 61
76360: PUSH
76361: LD_VAR 0 2
76365: ARRAY
76366: PPUSH
76367: LD_INT 2
76369: PUSH
76370: LD_INT 30
76372: PUSH
76373: LD_INT 4
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 30
76382: PUSH
76383: LD_INT 5
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: LIST
76394: PPUSH
76395: CALL_OW 72
76399: ST_TO_ADDR
// if barracks then
76400: LD_VAR 0 8
76404: IFFALSE 76552
// begin selected := 0 ;
76406: LD_ADDR_VAR 0 7
76410: PUSH
76411: LD_INT 0
76413: ST_TO_ADDR
// for j in barracks do
76414: LD_ADDR_VAR 0 3
76418: PUSH
76419: LD_VAR 0 8
76423: PUSH
76424: FOR_IN
76425: IFFALSE 76456
// begin if UnitsInside ( j ) < 6 then
76427: LD_VAR 0 3
76431: PPUSH
76432: CALL_OW 313
76436: PUSH
76437: LD_INT 6
76439: LESS
76440: IFFALSE 76454
// begin selected := j ;
76442: LD_ADDR_VAR 0 7
76446: PUSH
76447: LD_VAR 0 3
76451: ST_TO_ADDR
// break ;
76452: GO 76456
// end ; end ;
76454: GO 76424
76456: POP
76457: POP
// if selected then
76458: LD_VAR 0 7
76462: IFFALSE 76552
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76464: LD_ADDR_VAR 0 3
76468: PUSH
76469: LD_EXP 90
76473: PUSH
76474: LD_VAR 0 2
76478: ARRAY
76479: PPUSH
76480: LD_INT 25
76482: PUSH
76483: LD_INT 12
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PPUSH
76490: CALL_OW 72
76494: PUSH
76495: FOR_IN
76496: IFFALSE 76550
// if not IsInUnit ( j ) and not HasTask ( j ) then
76498: LD_VAR 0 3
76502: PPUSH
76503: CALL_OW 310
76507: NOT
76508: PUSH
76509: LD_VAR 0 3
76513: PPUSH
76514: CALL_OW 314
76518: NOT
76519: AND
76520: IFFALSE 76548
// begin ComEnterUnit ( j , selected ) ;
76522: LD_VAR 0 3
76526: PPUSH
76527: LD_VAR 0 7
76531: PPUSH
76532: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76536: LD_VAR 0 3
76540: PPUSH
76541: LD_INT 15
76543: PPUSH
76544: CALL_OW 183
// end ;
76548: GO 76495
76550: POP
76551: POP
// end ; end ; end ; end ; end ;
76552: GO 75945
76554: POP
76555: POP
// end ;
76556: LD_VAR 0 1
76560: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76561: LD_INT 0
76563: PPUSH
76564: PPUSH
76565: PPUSH
76566: PPUSH
// if not mc_bases then
76567: LD_EXP 61
76571: NOT
76572: IFFALSE 76576
// exit ;
76574: GO 76754
// for i = 1 to mc_bases do
76576: LD_ADDR_VAR 0 2
76580: PUSH
76581: DOUBLE
76582: LD_INT 1
76584: DEC
76585: ST_TO_ADDR
76586: LD_EXP 61
76590: PUSH
76591: FOR_TO
76592: IFFALSE 76752
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76594: LD_ADDR_VAR 0 4
76598: PUSH
76599: LD_EXP 61
76603: PUSH
76604: LD_VAR 0 2
76608: ARRAY
76609: PPUSH
76610: LD_INT 25
76612: PUSH
76613: LD_INT 9
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PPUSH
76620: CALL_OW 72
76624: ST_TO_ADDR
// if not tmp then
76625: LD_VAR 0 4
76629: NOT
76630: IFFALSE 76634
// continue ;
76632: GO 76591
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76634: LD_EXP 87
76638: PUSH
76639: LD_VAR 0 2
76643: ARRAY
76644: PPUSH
76645: LD_INT 29
76647: PPUSH
76648: CALL_OW 325
76652: NOT
76653: PUSH
76654: LD_EXP 87
76658: PUSH
76659: LD_VAR 0 2
76663: ARRAY
76664: PPUSH
76665: LD_INT 28
76667: PPUSH
76668: CALL_OW 325
76672: NOT
76673: AND
76674: IFFALSE 76678
// continue ;
76676: GO 76591
// for j in tmp do
76678: LD_ADDR_VAR 0 3
76682: PUSH
76683: LD_VAR 0 4
76687: PUSH
76688: FOR_IN
76689: IFFALSE 76748
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76691: LD_VAR 0 3
76695: PUSH
76696: LD_EXP 64
76700: PUSH
76701: LD_VAR 0 2
76705: ARRAY
76706: PUSH
76707: LD_INT 1
76709: ARRAY
76710: IN
76711: NOT
76712: PUSH
76713: LD_VAR 0 3
76717: PUSH
76718: LD_EXP 64
76722: PUSH
76723: LD_VAR 0 2
76727: ARRAY
76728: PUSH
76729: LD_INT 2
76731: ARRAY
76732: IN
76733: NOT
76734: AND
76735: IFFALSE 76746
// ComSpaceTimeShoot ( j ) ;
76737: LD_VAR 0 3
76741: PPUSH
76742: CALL 15897 0 1
76746: GO 76688
76748: POP
76749: POP
// end ;
76750: GO 76591
76752: POP
76753: POP
// end ;
76754: LD_VAR 0 1
76758: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76759: LD_INT 0
76761: PPUSH
76762: PPUSH
76763: PPUSH
76764: PPUSH
76765: PPUSH
76766: PPUSH
76767: PPUSH
76768: PPUSH
76769: PPUSH
// if not mc_bases then
76770: LD_EXP 61
76774: NOT
76775: IFFALSE 76779
// exit ;
76777: GO 77401
// for i = 1 to mc_bases do
76779: LD_ADDR_VAR 0 2
76783: PUSH
76784: DOUBLE
76785: LD_INT 1
76787: DEC
76788: ST_TO_ADDR
76789: LD_EXP 61
76793: PUSH
76794: FOR_TO
76795: IFFALSE 77399
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76797: LD_EXP 96
76801: PUSH
76802: LD_VAR 0 2
76806: ARRAY
76807: NOT
76808: PUSH
76809: LD_INT 38
76811: PPUSH
76812: LD_EXP 87
76816: PUSH
76817: LD_VAR 0 2
76821: ARRAY
76822: PPUSH
76823: CALL_OW 321
76827: PUSH
76828: LD_INT 2
76830: NONEQUAL
76831: OR
76832: IFFALSE 76836
// continue ;
76834: GO 76794
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76836: LD_ADDR_VAR 0 8
76840: PUSH
76841: LD_EXP 61
76845: PUSH
76846: LD_VAR 0 2
76850: ARRAY
76851: PPUSH
76852: LD_INT 30
76854: PUSH
76855: LD_INT 34
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PPUSH
76862: CALL_OW 72
76866: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76867: LD_ADDR_VAR 0 9
76871: PUSH
76872: LD_EXP 61
76876: PUSH
76877: LD_VAR 0 2
76881: ARRAY
76882: PPUSH
76883: LD_INT 25
76885: PUSH
76886: LD_INT 4
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PPUSH
76893: CALL_OW 72
76897: PPUSH
76898: LD_INT 0
76900: PPUSH
76901: CALL 49824 0 2
76905: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76906: LD_VAR 0 9
76910: NOT
76911: PUSH
76912: LD_VAR 0 8
76916: NOT
76917: OR
76918: PUSH
76919: LD_EXP 61
76923: PUSH
76924: LD_VAR 0 2
76928: ARRAY
76929: PPUSH
76930: LD_INT 124
76932: PPUSH
76933: CALL 49824 0 2
76937: OR
76938: IFFALSE 76942
// continue ;
76940: GO 76794
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76942: LD_EXP 97
76946: PUSH
76947: LD_VAR 0 2
76951: ARRAY
76952: PUSH
76953: LD_EXP 96
76957: PUSH
76958: LD_VAR 0 2
76962: ARRAY
76963: LESS
76964: PUSH
76965: LD_EXP 97
76969: PUSH
76970: LD_VAR 0 2
76974: ARRAY
76975: PUSH
76976: LD_VAR 0 8
76980: LESS
76981: AND
76982: IFFALSE 77397
// begin tmp := sci [ 1 ] ;
76984: LD_ADDR_VAR 0 7
76988: PUSH
76989: LD_VAR 0 9
76993: PUSH
76994: LD_INT 1
76996: ARRAY
76997: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76998: LD_VAR 0 7
77002: PPUSH
77003: LD_INT 124
77005: PPUSH
77006: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77010: LD_ADDR_VAR 0 3
77014: PUSH
77015: DOUBLE
77016: LD_EXP 96
77020: PUSH
77021: LD_VAR 0 2
77025: ARRAY
77026: INC
77027: ST_TO_ADDR
77028: LD_EXP 96
77032: PUSH
77033: LD_VAR 0 2
77037: ARRAY
77038: PUSH
77039: FOR_DOWNTO
77040: IFFALSE 77383
// begin if IsInUnit ( tmp ) then
77042: LD_VAR 0 7
77046: PPUSH
77047: CALL_OW 310
77051: IFFALSE 77062
// ComExitBuilding ( tmp ) ;
77053: LD_VAR 0 7
77057: PPUSH
77058: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77062: LD_INT 35
77064: PPUSH
77065: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77069: LD_VAR 0 7
77073: PPUSH
77074: CALL_OW 310
77078: NOT
77079: PUSH
77080: LD_VAR 0 7
77084: PPUSH
77085: CALL_OW 314
77089: NOT
77090: AND
77091: IFFALSE 77062
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77093: LD_ADDR_VAR 0 6
77097: PUSH
77098: LD_VAR 0 7
77102: PPUSH
77103: CALL_OW 250
77107: PUSH
77108: LD_VAR 0 7
77112: PPUSH
77113: CALL_OW 251
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77122: LD_INT 35
77124: PPUSH
77125: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77129: LD_ADDR_VAR 0 4
77133: PUSH
77134: LD_EXP 96
77138: PUSH
77139: LD_VAR 0 2
77143: ARRAY
77144: PUSH
77145: LD_VAR 0 3
77149: ARRAY
77150: PUSH
77151: LD_INT 1
77153: ARRAY
77154: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77155: LD_ADDR_VAR 0 5
77159: PUSH
77160: LD_EXP 96
77164: PUSH
77165: LD_VAR 0 2
77169: ARRAY
77170: PUSH
77171: LD_VAR 0 3
77175: ARRAY
77176: PUSH
77177: LD_INT 2
77179: ARRAY
77180: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77181: LD_VAR 0 7
77185: PPUSH
77186: LD_INT 10
77188: PPUSH
77189: CALL 22509 0 2
77193: PUSH
77194: LD_INT 4
77196: ARRAY
77197: IFFALSE 77235
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77199: LD_VAR 0 7
77203: PPUSH
77204: LD_VAR 0 6
77208: PUSH
77209: LD_INT 1
77211: ARRAY
77212: PPUSH
77213: LD_VAR 0 6
77217: PUSH
77218: LD_INT 2
77220: ARRAY
77221: PPUSH
77222: CALL_OW 111
// wait ( 0 0$10 ) ;
77226: LD_INT 350
77228: PPUSH
77229: CALL_OW 67
// end else
77233: GO 77261
// begin ComMoveXY ( tmp , x , y ) ;
77235: LD_VAR 0 7
77239: PPUSH
77240: LD_VAR 0 4
77244: PPUSH
77245: LD_VAR 0 5
77249: PPUSH
77250: CALL_OW 111
// wait ( 0 0$3 ) ;
77254: LD_INT 105
77256: PPUSH
77257: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77261: LD_VAR 0 7
77265: PPUSH
77266: LD_VAR 0 4
77270: PPUSH
77271: LD_VAR 0 5
77275: PPUSH
77276: CALL_OW 307
77280: IFFALSE 77122
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77282: LD_VAR 0 7
77286: PPUSH
77287: LD_VAR 0 4
77291: PPUSH
77292: LD_VAR 0 5
77296: PPUSH
77297: LD_VAR 0 8
77301: PUSH
77302: LD_VAR 0 3
77306: ARRAY
77307: PPUSH
77308: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77312: LD_INT 35
77314: PPUSH
77315: CALL_OW 67
// until not HasTask ( tmp ) ;
77319: LD_VAR 0 7
77323: PPUSH
77324: CALL_OW 314
77328: NOT
77329: IFFALSE 77312
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77331: LD_ADDR_EXP 97
77335: PUSH
77336: LD_EXP 97
77340: PPUSH
77341: LD_VAR 0 2
77345: PUSH
77346: LD_EXP 97
77350: PUSH
77351: LD_VAR 0 2
77355: ARRAY
77356: PUSH
77357: LD_INT 1
77359: PLUS
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PPUSH
77365: LD_VAR 0 8
77369: PUSH
77370: LD_VAR 0 3
77374: ARRAY
77375: PPUSH
77376: CALL 19912 0 3
77380: ST_TO_ADDR
// end ;
77381: GO 77039
77383: POP
77384: POP
// MC_Reset ( i , 124 ) ;
77385: LD_VAR 0 2
77389: PPUSH
77390: LD_INT 124
77392: PPUSH
77393: CALL 60483 0 2
// end ; end ;
77397: GO 76794
77399: POP
77400: POP
// end ;
77401: LD_VAR 0 1
77405: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77406: LD_INT 0
77408: PPUSH
77409: PPUSH
77410: PPUSH
// if not mc_bases then
77411: LD_EXP 61
77415: NOT
77416: IFFALSE 77420
// exit ;
77418: GO 78026
// for i = 1 to mc_bases do
77420: LD_ADDR_VAR 0 2
77424: PUSH
77425: DOUBLE
77426: LD_INT 1
77428: DEC
77429: ST_TO_ADDR
77430: LD_EXP 61
77434: PUSH
77435: FOR_TO
77436: IFFALSE 78024
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77438: LD_ADDR_VAR 0 3
77442: PUSH
77443: LD_EXP 61
77447: PUSH
77448: LD_VAR 0 2
77452: ARRAY
77453: PPUSH
77454: LD_INT 25
77456: PUSH
77457: LD_INT 4
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PPUSH
77464: CALL_OW 72
77468: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77469: LD_VAR 0 3
77473: NOT
77474: PUSH
77475: LD_EXP 98
77479: PUSH
77480: LD_VAR 0 2
77484: ARRAY
77485: NOT
77486: OR
77487: PUSH
77488: LD_EXP 61
77492: PUSH
77493: LD_VAR 0 2
77497: ARRAY
77498: PPUSH
77499: LD_INT 2
77501: PUSH
77502: LD_INT 30
77504: PUSH
77505: LD_INT 0
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 30
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: LIST
77526: PPUSH
77527: CALL_OW 72
77531: NOT
77532: OR
77533: IFFALSE 77583
// begin if mc_deposits_finder [ i ] then
77535: LD_EXP 99
77539: PUSH
77540: LD_VAR 0 2
77544: ARRAY
77545: IFFALSE 77581
// begin MC_Reset ( i , 125 ) ;
77547: LD_VAR 0 2
77551: PPUSH
77552: LD_INT 125
77554: PPUSH
77555: CALL 60483 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77559: LD_ADDR_EXP 99
77563: PUSH
77564: LD_EXP 99
77568: PPUSH
77569: LD_VAR 0 2
77573: PPUSH
77574: EMPTY
77575: PPUSH
77576: CALL_OW 1
77580: ST_TO_ADDR
// end ; continue ;
77581: GO 77435
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77583: LD_EXP 98
77587: PUSH
77588: LD_VAR 0 2
77592: ARRAY
77593: PUSH
77594: LD_INT 1
77596: ARRAY
77597: PUSH
77598: LD_INT 3
77600: ARRAY
77601: PUSH
77602: LD_INT 1
77604: EQUAL
77605: PUSH
77606: LD_INT 20
77608: PPUSH
77609: LD_EXP 87
77613: PUSH
77614: LD_VAR 0 2
77618: ARRAY
77619: PPUSH
77620: CALL_OW 321
77624: PUSH
77625: LD_INT 2
77627: NONEQUAL
77628: AND
77629: IFFALSE 77679
// begin if mc_deposits_finder [ i ] then
77631: LD_EXP 99
77635: PUSH
77636: LD_VAR 0 2
77640: ARRAY
77641: IFFALSE 77677
// begin MC_Reset ( i , 125 ) ;
77643: LD_VAR 0 2
77647: PPUSH
77648: LD_INT 125
77650: PPUSH
77651: CALL 60483 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77655: LD_ADDR_EXP 99
77659: PUSH
77660: LD_EXP 99
77664: PPUSH
77665: LD_VAR 0 2
77669: PPUSH
77670: EMPTY
77671: PPUSH
77672: CALL_OW 1
77676: ST_TO_ADDR
// end ; continue ;
77677: GO 77435
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77679: LD_EXP 98
77683: PUSH
77684: LD_VAR 0 2
77688: ARRAY
77689: PUSH
77690: LD_INT 1
77692: ARRAY
77693: PUSH
77694: LD_INT 1
77696: ARRAY
77697: PPUSH
77698: LD_EXP 98
77702: PUSH
77703: LD_VAR 0 2
77707: ARRAY
77708: PUSH
77709: LD_INT 1
77711: ARRAY
77712: PUSH
77713: LD_INT 2
77715: ARRAY
77716: PPUSH
77717: LD_EXP 87
77721: PUSH
77722: LD_VAR 0 2
77726: ARRAY
77727: PPUSH
77728: CALL_OW 440
77732: IFFALSE 77775
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77734: LD_ADDR_EXP 98
77738: PUSH
77739: LD_EXP 98
77743: PPUSH
77744: LD_VAR 0 2
77748: PPUSH
77749: LD_EXP 98
77753: PUSH
77754: LD_VAR 0 2
77758: ARRAY
77759: PPUSH
77760: LD_INT 1
77762: PPUSH
77763: CALL_OW 3
77767: PPUSH
77768: CALL_OW 1
77772: ST_TO_ADDR
77773: GO 78022
// begin if not mc_deposits_finder [ i ] then
77775: LD_EXP 99
77779: PUSH
77780: LD_VAR 0 2
77784: ARRAY
77785: NOT
77786: IFFALSE 77838
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77788: LD_ADDR_EXP 99
77792: PUSH
77793: LD_EXP 99
77797: PPUSH
77798: LD_VAR 0 2
77802: PPUSH
77803: LD_VAR 0 3
77807: PUSH
77808: LD_INT 1
77810: ARRAY
77811: PUSH
77812: EMPTY
77813: LIST
77814: PPUSH
77815: CALL_OW 1
77819: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77820: LD_VAR 0 3
77824: PUSH
77825: LD_INT 1
77827: ARRAY
77828: PPUSH
77829: LD_INT 125
77831: PPUSH
77832: CALL_OW 109
// end else
77836: GO 78022
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77838: LD_EXP 99
77842: PUSH
77843: LD_VAR 0 2
77847: ARRAY
77848: PUSH
77849: LD_INT 1
77851: ARRAY
77852: PPUSH
77853: CALL_OW 310
77857: IFFALSE 77880
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77859: LD_EXP 99
77863: PUSH
77864: LD_VAR 0 2
77868: ARRAY
77869: PUSH
77870: LD_INT 1
77872: ARRAY
77873: PPUSH
77874: CALL_OW 122
77878: GO 78022
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77880: LD_EXP 99
77884: PUSH
77885: LD_VAR 0 2
77889: ARRAY
77890: PUSH
77891: LD_INT 1
77893: ARRAY
77894: PPUSH
77895: CALL_OW 314
77899: NOT
77900: PUSH
77901: LD_EXP 99
77905: PUSH
77906: LD_VAR 0 2
77910: ARRAY
77911: PUSH
77912: LD_INT 1
77914: ARRAY
77915: PPUSH
77916: LD_EXP 98
77920: PUSH
77921: LD_VAR 0 2
77925: ARRAY
77926: PUSH
77927: LD_INT 1
77929: ARRAY
77930: PUSH
77931: LD_INT 1
77933: ARRAY
77934: PPUSH
77935: LD_EXP 98
77939: PUSH
77940: LD_VAR 0 2
77944: ARRAY
77945: PUSH
77946: LD_INT 1
77948: ARRAY
77949: PUSH
77950: LD_INT 2
77952: ARRAY
77953: PPUSH
77954: CALL_OW 297
77958: PUSH
77959: LD_INT 6
77961: GREATER
77962: AND
77963: IFFALSE 78022
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77965: LD_EXP 99
77969: PUSH
77970: LD_VAR 0 2
77974: ARRAY
77975: PUSH
77976: LD_INT 1
77978: ARRAY
77979: PPUSH
77980: LD_EXP 98
77984: PUSH
77985: LD_VAR 0 2
77989: ARRAY
77990: PUSH
77991: LD_INT 1
77993: ARRAY
77994: PUSH
77995: LD_INT 1
77997: ARRAY
77998: PPUSH
77999: LD_EXP 98
78003: PUSH
78004: LD_VAR 0 2
78008: ARRAY
78009: PUSH
78010: LD_INT 1
78012: ARRAY
78013: PUSH
78014: LD_INT 2
78016: ARRAY
78017: PPUSH
78018: CALL_OW 111
// end ; end ; end ;
78022: GO 77435
78024: POP
78025: POP
// end ;
78026: LD_VAR 0 1
78030: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78031: LD_INT 0
78033: PPUSH
78034: PPUSH
78035: PPUSH
78036: PPUSH
78037: PPUSH
78038: PPUSH
78039: PPUSH
78040: PPUSH
78041: PPUSH
78042: PPUSH
78043: PPUSH
// if not mc_bases then
78044: LD_EXP 61
78048: NOT
78049: IFFALSE 78053
// exit ;
78051: GO 78993
// for i = 1 to mc_bases do
78053: LD_ADDR_VAR 0 2
78057: PUSH
78058: DOUBLE
78059: LD_INT 1
78061: DEC
78062: ST_TO_ADDR
78063: LD_EXP 61
78067: PUSH
78068: FOR_TO
78069: IFFALSE 78991
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78071: LD_EXP 61
78075: PUSH
78076: LD_VAR 0 2
78080: ARRAY
78081: NOT
78082: PUSH
78083: LD_EXP 84
78087: PUSH
78088: LD_VAR 0 2
78092: ARRAY
78093: OR
78094: IFFALSE 78098
// continue ;
78096: GO 78068
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78098: LD_ADDR_VAR 0 7
78102: PUSH
78103: LD_EXP 61
78107: PUSH
78108: LD_VAR 0 2
78112: ARRAY
78113: PUSH
78114: LD_INT 1
78116: ARRAY
78117: PPUSH
78118: CALL_OW 248
78122: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78123: LD_VAR 0 7
78127: PUSH
78128: LD_INT 3
78130: EQUAL
78131: PUSH
78132: LD_EXP 80
78136: PUSH
78137: LD_VAR 0 2
78141: ARRAY
78142: PUSH
78143: LD_EXP 83
78147: PUSH
78148: LD_VAR 0 2
78152: ARRAY
78153: UNION
78154: PPUSH
78155: LD_INT 33
78157: PUSH
78158: LD_INT 2
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PPUSH
78165: CALL_OW 72
78169: NOT
78170: OR
78171: IFFALSE 78175
// continue ;
78173: GO 78068
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78175: LD_ADDR_VAR 0 9
78179: PUSH
78180: LD_EXP 61
78184: PUSH
78185: LD_VAR 0 2
78189: ARRAY
78190: PPUSH
78191: LD_INT 30
78193: PUSH
78194: LD_INT 36
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PPUSH
78201: CALL_OW 72
78205: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78206: LD_ADDR_VAR 0 10
78210: PUSH
78211: LD_EXP 80
78215: PUSH
78216: LD_VAR 0 2
78220: ARRAY
78221: PPUSH
78222: LD_INT 34
78224: PUSH
78225: LD_INT 31
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PPUSH
78232: CALL_OW 72
78236: ST_TO_ADDR
// if not cts and not mcts then
78237: LD_VAR 0 9
78241: NOT
78242: PUSH
78243: LD_VAR 0 10
78247: NOT
78248: AND
78249: IFFALSE 78253
// continue ;
78251: GO 78068
// x := cts ;
78253: LD_ADDR_VAR 0 11
78257: PUSH
78258: LD_VAR 0 9
78262: ST_TO_ADDR
// if not x then
78263: LD_VAR 0 11
78267: NOT
78268: IFFALSE 78280
// x := mcts ;
78270: LD_ADDR_VAR 0 11
78274: PUSH
78275: LD_VAR 0 10
78279: ST_TO_ADDR
// if not x then
78280: LD_VAR 0 11
78284: NOT
78285: IFFALSE 78289
// continue ;
78287: GO 78068
// if mc_remote_driver [ i ] then
78289: LD_EXP 101
78293: PUSH
78294: LD_VAR 0 2
78298: ARRAY
78299: IFFALSE 78686
// for j in mc_remote_driver [ i ] do
78301: LD_ADDR_VAR 0 3
78305: PUSH
78306: LD_EXP 101
78310: PUSH
78311: LD_VAR 0 2
78315: ARRAY
78316: PUSH
78317: FOR_IN
78318: IFFALSE 78684
// begin if GetClass ( j ) <> 3 then
78320: LD_VAR 0 3
78324: PPUSH
78325: CALL_OW 257
78329: PUSH
78330: LD_INT 3
78332: NONEQUAL
78333: IFFALSE 78386
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78335: LD_ADDR_EXP 101
78339: PUSH
78340: LD_EXP 101
78344: PPUSH
78345: LD_VAR 0 2
78349: PPUSH
78350: LD_EXP 101
78354: PUSH
78355: LD_VAR 0 2
78359: ARRAY
78360: PUSH
78361: LD_VAR 0 3
78365: DIFF
78366: PPUSH
78367: CALL_OW 1
78371: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78372: LD_VAR 0 3
78376: PPUSH
78377: LD_INT 0
78379: PPUSH
78380: CALL_OW 109
// continue ;
78384: GO 78317
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78386: LD_EXP 80
78390: PUSH
78391: LD_VAR 0 2
78395: ARRAY
78396: PPUSH
78397: LD_INT 34
78399: PUSH
78400: LD_INT 31
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 58
78409: PUSH
78410: EMPTY
78411: LIST
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PPUSH
78417: CALL_OW 72
78421: PUSH
78422: LD_VAR 0 3
78426: PPUSH
78427: CALL 49859 0 1
78431: NOT
78432: AND
78433: IFFALSE 78504
// begin if IsInUnit ( j ) then
78435: LD_VAR 0 3
78439: PPUSH
78440: CALL_OW 310
78444: IFFALSE 78455
// ComExitBuilding ( j ) ;
78446: LD_VAR 0 3
78450: PPUSH
78451: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78455: LD_VAR 0 3
78459: PPUSH
78460: LD_EXP 80
78464: PUSH
78465: LD_VAR 0 2
78469: ARRAY
78470: PPUSH
78471: LD_INT 34
78473: PUSH
78474: LD_INT 31
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 58
78483: PUSH
78484: EMPTY
78485: LIST
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PPUSH
78491: CALL_OW 72
78495: PUSH
78496: LD_INT 1
78498: ARRAY
78499: PPUSH
78500: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78504: LD_VAR 0 3
78508: PPUSH
78509: CALL_OW 310
78513: NOT
78514: PUSH
78515: LD_VAR 0 3
78519: PPUSH
78520: CALL_OW 310
78524: PPUSH
78525: CALL_OW 266
78529: PUSH
78530: LD_INT 36
78532: NONEQUAL
78533: PUSH
78534: LD_VAR 0 3
78538: PPUSH
78539: CALL 49859 0 1
78543: NOT
78544: AND
78545: OR
78546: IFFALSE 78682
// begin if IsInUnit ( j ) then
78548: LD_VAR 0 3
78552: PPUSH
78553: CALL_OW 310
78557: IFFALSE 78568
// ComExitBuilding ( j ) ;
78559: LD_VAR 0 3
78563: PPUSH
78564: CALL_OW 122
// ct := 0 ;
78568: LD_ADDR_VAR 0 8
78572: PUSH
78573: LD_INT 0
78575: ST_TO_ADDR
// for k in x do
78576: LD_ADDR_VAR 0 4
78580: PUSH
78581: LD_VAR 0 11
78585: PUSH
78586: FOR_IN
78587: IFFALSE 78660
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78589: LD_VAR 0 4
78593: PPUSH
78594: CALL_OW 264
78598: PUSH
78599: LD_INT 31
78601: EQUAL
78602: PUSH
78603: LD_VAR 0 4
78607: PPUSH
78608: CALL_OW 311
78612: NOT
78613: AND
78614: PUSH
78615: LD_VAR 0 4
78619: PPUSH
78620: CALL_OW 266
78624: PUSH
78625: LD_INT 36
78627: EQUAL
78628: PUSH
78629: LD_VAR 0 4
78633: PPUSH
78634: CALL_OW 313
78638: PUSH
78639: LD_INT 3
78641: LESS
78642: AND
78643: OR
78644: IFFALSE 78658
// begin ct := k ;
78646: LD_ADDR_VAR 0 8
78650: PUSH
78651: LD_VAR 0 4
78655: ST_TO_ADDR
// break ;
78656: GO 78660
// end ;
78658: GO 78586
78660: POP
78661: POP
// if ct then
78662: LD_VAR 0 8
78666: IFFALSE 78682
// ComEnterUnit ( j , ct ) ;
78668: LD_VAR 0 3
78672: PPUSH
78673: LD_VAR 0 8
78677: PPUSH
78678: CALL_OW 120
// end ; end ;
78682: GO 78317
78684: POP
78685: POP
// places := 0 ;
78686: LD_ADDR_VAR 0 5
78690: PUSH
78691: LD_INT 0
78693: ST_TO_ADDR
// for j = 1 to x do
78694: LD_ADDR_VAR 0 3
78698: PUSH
78699: DOUBLE
78700: LD_INT 1
78702: DEC
78703: ST_TO_ADDR
78704: LD_VAR 0 11
78708: PUSH
78709: FOR_TO
78710: IFFALSE 78786
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78712: LD_VAR 0 11
78716: PUSH
78717: LD_VAR 0 3
78721: ARRAY
78722: PPUSH
78723: CALL_OW 264
78727: PUSH
78728: LD_INT 31
78730: EQUAL
78731: IFFALSE 78749
// places := places + 1 else
78733: LD_ADDR_VAR 0 5
78737: PUSH
78738: LD_VAR 0 5
78742: PUSH
78743: LD_INT 1
78745: PLUS
78746: ST_TO_ADDR
78747: GO 78784
// if GetBType ( x [ j ] ) = b_control_tower then
78749: LD_VAR 0 11
78753: PUSH
78754: LD_VAR 0 3
78758: ARRAY
78759: PPUSH
78760: CALL_OW 266
78764: PUSH
78765: LD_INT 36
78767: EQUAL
78768: IFFALSE 78784
// places := places + 3 ;
78770: LD_ADDR_VAR 0 5
78774: PUSH
78775: LD_VAR 0 5
78779: PUSH
78780: LD_INT 3
78782: PLUS
78783: ST_TO_ADDR
78784: GO 78709
78786: POP
78787: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78788: LD_VAR 0 5
78792: PUSH
78793: LD_INT 0
78795: EQUAL
78796: PUSH
78797: LD_VAR 0 5
78801: PUSH
78802: LD_EXP 101
78806: PUSH
78807: LD_VAR 0 2
78811: ARRAY
78812: LESSEQUAL
78813: OR
78814: IFFALSE 78818
// continue ;
78816: GO 78068
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78818: LD_ADDR_VAR 0 6
78822: PUSH
78823: LD_EXP 61
78827: PUSH
78828: LD_VAR 0 2
78832: ARRAY
78833: PPUSH
78834: LD_INT 25
78836: PUSH
78837: LD_INT 3
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PPUSH
78844: CALL_OW 72
78848: PUSH
78849: LD_EXP 101
78853: PUSH
78854: LD_VAR 0 2
78858: ARRAY
78859: DIFF
78860: PPUSH
78861: LD_INT 3
78863: PPUSH
78864: CALL 50759 0 2
78868: ST_TO_ADDR
// for j in tmp do
78869: LD_ADDR_VAR 0 3
78873: PUSH
78874: LD_VAR 0 6
78878: PUSH
78879: FOR_IN
78880: IFFALSE 78915
// if GetTag ( j ) > 0 then
78882: LD_VAR 0 3
78886: PPUSH
78887: CALL_OW 110
78891: PUSH
78892: LD_INT 0
78894: GREATER
78895: IFFALSE 78913
// tmp := tmp diff j ;
78897: LD_ADDR_VAR 0 6
78901: PUSH
78902: LD_VAR 0 6
78906: PUSH
78907: LD_VAR 0 3
78911: DIFF
78912: ST_TO_ADDR
78913: GO 78879
78915: POP
78916: POP
// if not tmp then
78917: LD_VAR 0 6
78921: NOT
78922: IFFALSE 78926
// continue ;
78924: GO 78068
// if places then
78926: LD_VAR 0 5
78930: IFFALSE 78989
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78932: LD_ADDR_EXP 101
78936: PUSH
78937: LD_EXP 101
78941: PPUSH
78942: LD_VAR 0 2
78946: PPUSH
78947: LD_EXP 101
78951: PUSH
78952: LD_VAR 0 2
78956: ARRAY
78957: PUSH
78958: LD_VAR 0 6
78962: PUSH
78963: LD_INT 1
78965: ARRAY
78966: UNION
78967: PPUSH
78968: CALL_OW 1
78972: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78973: LD_VAR 0 6
78977: PUSH
78978: LD_INT 1
78980: ARRAY
78981: PPUSH
78982: LD_INT 126
78984: PPUSH
78985: CALL_OW 109
// end ; end ;
78989: GO 78068
78991: POP
78992: POP
// end ;
78993: LD_VAR 0 1
78997: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78998: LD_INT 0
79000: PPUSH
79001: PPUSH
79002: PPUSH
79003: PPUSH
79004: PPUSH
79005: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79006: LD_VAR 0 1
79010: NOT
79011: PUSH
79012: LD_VAR 0 2
79016: NOT
79017: OR
79018: PUSH
79019: LD_VAR 0 3
79023: NOT
79024: OR
79025: PUSH
79026: LD_VAR 0 4
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 2
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: LD_INT 4
79042: PUSH
79043: LD_INT 5
79045: PUSH
79046: LD_INT 8
79048: PUSH
79049: LD_INT 9
79051: PUSH
79052: LD_INT 15
79054: PUSH
79055: LD_INT 16
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: IN
79069: NOT
79070: OR
79071: IFFALSE 79075
// exit ;
79073: GO 79933
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79075: LD_ADDR_VAR 0 2
79079: PUSH
79080: LD_VAR 0 2
79084: PPUSH
79085: LD_INT 21
79087: PUSH
79088: LD_INT 3
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 24
79097: PUSH
79098: LD_INT 250
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PPUSH
79109: CALL_OW 72
79113: ST_TO_ADDR
// case class of 1 , 15 :
79114: LD_VAR 0 4
79118: PUSH
79119: LD_INT 1
79121: DOUBLE
79122: EQUAL
79123: IFTRUE 79133
79125: LD_INT 15
79127: DOUBLE
79128: EQUAL
79129: IFTRUE 79133
79131: GO 79218
79133: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79134: LD_ADDR_VAR 0 8
79138: PUSH
79139: LD_VAR 0 2
79143: PPUSH
79144: LD_INT 2
79146: PUSH
79147: LD_INT 30
79149: PUSH
79150: LD_INT 32
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 30
79159: PUSH
79160: LD_INT 31
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: LIST
79171: PPUSH
79172: CALL_OW 72
79176: PUSH
79177: LD_VAR 0 2
79181: PPUSH
79182: LD_INT 2
79184: PUSH
79185: LD_INT 30
79187: PUSH
79188: LD_INT 4
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 30
79197: PUSH
79198: LD_INT 5
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: LIST
79209: PPUSH
79210: CALL_OW 72
79214: ADD
79215: ST_TO_ADDR
79216: GO 79464
79218: LD_INT 2
79220: DOUBLE
79221: EQUAL
79222: IFTRUE 79232
79224: LD_INT 16
79226: DOUBLE
79227: EQUAL
79228: IFTRUE 79232
79230: GO 79278
79232: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79233: LD_ADDR_VAR 0 8
79237: PUSH
79238: LD_VAR 0 2
79242: PPUSH
79243: LD_INT 2
79245: PUSH
79246: LD_INT 30
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 30
79258: PUSH
79259: LD_INT 1
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: LIST
79270: PPUSH
79271: CALL_OW 72
79275: ST_TO_ADDR
79276: GO 79464
79278: LD_INT 3
79280: DOUBLE
79281: EQUAL
79282: IFTRUE 79286
79284: GO 79332
79286: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79287: LD_ADDR_VAR 0 8
79291: PUSH
79292: LD_VAR 0 2
79296: PPUSH
79297: LD_INT 2
79299: PUSH
79300: LD_INT 30
79302: PUSH
79303: LD_INT 2
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 30
79312: PUSH
79313: LD_INT 3
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: LIST
79324: PPUSH
79325: CALL_OW 72
79329: ST_TO_ADDR
79330: GO 79464
79332: LD_INT 4
79334: DOUBLE
79335: EQUAL
79336: IFTRUE 79340
79338: GO 79397
79340: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79341: LD_ADDR_VAR 0 8
79345: PUSH
79346: LD_VAR 0 2
79350: PPUSH
79351: LD_INT 2
79353: PUSH
79354: LD_INT 30
79356: PUSH
79357: LD_INT 6
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 30
79366: PUSH
79367: LD_INT 7
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 30
79376: PUSH
79377: LD_INT 8
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: PPUSH
79390: CALL_OW 72
79394: ST_TO_ADDR
79395: GO 79464
79397: LD_INT 5
79399: DOUBLE
79400: EQUAL
79401: IFTRUE 79417
79403: LD_INT 8
79405: DOUBLE
79406: EQUAL
79407: IFTRUE 79417
79409: LD_INT 9
79411: DOUBLE
79412: EQUAL
79413: IFTRUE 79417
79415: GO 79463
79417: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79418: LD_ADDR_VAR 0 8
79422: PUSH
79423: LD_VAR 0 2
79427: PPUSH
79428: LD_INT 2
79430: PUSH
79431: LD_INT 30
79433: PUSH
79434: LD_INT 4
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 30
79443: PUSH
79444: LD_INT 5
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: LIST
79455: PPUSH
79456: CALL_OW 72
79460: ST_TO_ADDR
79461: GO 79464
79463: POP
// if not tmp then
79464: LD_VAR 0 8
79468: NOT
79469: IFFALSE 79473
// exit ;
79471: GO 79933
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79473: LD_VAR 0 4
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: LD_INT 15
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: IN
79488: PUSH
79489: LD_EXP 70
79493: PUSH
79494: LD_VAR 0 1
79498: ARRAY
79499: AND
79500: IFFALSE 79656
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79502: LD_ADDR_VAR 0 9
79506: PUSH
79507: LD_EXP 70
79511: PUSH
79512: LD_VAR 0 1
79516: ARRAY
79517: PUSH
79518: LD_INT 1
79520: ARRAY
79521: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79522: LD_VAR 0 9
79526: PUSH
79527: LD_EXP 71
79531: PUSH
79532: LD_VAR 0 1
79536: ARRAY
79537: IN
79538: NOT
79539: IFFALSE 79654
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79541: LD_ADDR_EXP 71
79545: PUSH
79546: LD_EXP 71
79550: PPUSH
79551: LD_VAR 0 1
79555: PUSH
79556: LD_EXP 71
79560: PUSH
79561: LD_VAR 0 1
79565: ARRAY
79566: PUSH
79567: LD_INT 1
79569: PLUS
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PPUSH
79575: LD_VAR 0 9
79579: PPUSH
79580: CALL 19912 0 3
79584: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79585: LD_ADDR_EXP 70
79589: PUSH
79590: LD_EXP 70
79594: PPUSH
79595: LD_VAR 0 1
79599: PPUSH
79600: LD_EXP 70
79604: PUSH
79605: LD_VAR 0 1
79609: ARRAY
79610: PUSH
79611: LD_VAR 0 9
79615: DIFF
79616: PPUSH
79617: CALL_OW 1
79621: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79622: LD_VAR 0 3
79626: PPUSH
79627: LD_EXP 71
79631: PUSH
79632: LD_VAR 0 1
79636: ARRAY
79637: PUSH
79638: LD_EXP 71
79642: PUSH
79643: LD_VAR 0 1
79647: ARRAY
79648: ARRAY
79649: PPUSH
79650: CALL_OW 120
// end ; exit ;
79654: GO 79933
// end ; if tmp > 1 then
79656: LD_VAR 0 8
79660: PUSH
79661: LD_INT 1
79663: GREATER
79664: IFFALSE 79768
// for i = 2 to tmp do
79666: LD_ADDR_VAR 0 6
79670: PUSH
79671: DOUBLE
79672: LD_INT 2
79674: DEC
79675: ST_TO_ADDR
79676: LD_VAR 0 8
79680: PUSH
79681: FOR_TO
79682: IFFALSE 79766
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79684: LD_VAR 0 8
79688: PUSH
79689: LD_VAR 0 6
79693: ARRAY
79694: PPUSH
79695: CALL_OW 461
79699: PUSH
79700: LD_INT 6
79702: EQUAL
79703: IFFALSE 79764
// begin x := tmp [ i ] ;
79705: LD_ADDR_VAR 0 9
79709: PUSH
79710: LD_VAR 0 8
79714: PUSH
79715: LD_VAR 0 6
79719: ARRAY
79720: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79721: LD_ADDR_VAR 0 8
79725: PUSH
79726: LD_VAR 0 8
79730: PPUSH
79731: LD_VAR 0 6
79735: PPUSH
79736: CALL_OW 3
79740: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79741: LD_ADDR_VAR 0 8
79745: PUSH
79746: LD_VAR 0 8
79750: PPUSH
79751: LD_INT 1
79753: PPUSH
79754: LD_VAR 0 9
79758: PPUSH
79759: CALL_OW 2
79763: ST_TO_ADDR
// end ;
79764: GO 79681
79766: POP
79767: POP
// for i in tmp do
79768: LD_ADDR_VAR 0 6
79772: PUSH
79773: LD_VAR 0 8
79777: PUSH
79778: FOR_IN
79779: IFFALSE 79806
// begin if IsNotFull ( i ) then
79781: LD_VAR 0 6
79785: PPUSH
79786: CALL 17134 0 1
79790: IFFALSE 79804
// begin j := i ;
79792: LD_ADDR_VAR 0 7
79796: PUSH
79797: LD_VAR 0 6
79801: ST_TO_ADDR
// break ;
79802: GO 79806
// end ; end ;
79804: GO 79778
79806: POP
79807: POP
// if j then
79808: LD_VAR 0 7
79812: IFFALSE 79830
// ComEnterUnit ( unit , j ) else
79814: LD_VAR 0 3
79818: PPUSH
79819: LD_VAR 0 7
79823: PPUSH
79824: CALL_OW 120
79828: GO 79933
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79830: LD_ADDR_VAR 0 10
79834: PUSH
79835: LD_VAR 0 2
79839: PPUSH
79840: LD_INT 2
79842: PUSH
79843: LD_INT 30
79845: PUSH
79846: LD_INT 0
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 30
79855: PUSH
79856: LD_INT 1
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: LIST
79867: PPUSH
79868: CALL_OW 72
79872: ST_TO_ADDR
// if depot then
79873: LD_VAR 0 10
79877: IFFALSE 79933
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79879: LD_ADDR_VAR 0 10
79883: PUSH
79884: LD_VAR 0 10
79888: PPUSH
79889: LD_VAR 0 3
79893: PPUSH
79894: CALL_OW 74
79898: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79899: LD_VAR 0 3
79903: PPUSH
79904: LD_VAR 0 10
79908: PPUSH
79909: CALL_OW 296
79913: PUSH
79914: LD_INT 10
79916: GREATER
79917: IFFALSE 79933
// ComStandNearbyBuilding ( unit , depot ) ;
79919: LD_VAR 0 3
79923: PPUSH
79924: LD_VAR 0 10
79928: PPUSH
79929: CALL 16514 0 2
// end ; end ; end ;
79933: LD_VAR 0 5
79937: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79938: LD_INT 0
79940: PPUSH
79941: PPUSH
79942: PPUSH
79943: PPUSH
// if not mc_bases then
79944: LD_EXP 61
79948: NOT
79949: IFFALSE 79953
// exit ;
79951: GO 80192
// for i = 1 to mc_bases do
79953: LD_ADDR_VAR 0 2
79957: PUSH
79958: DOUBLE
79959: LD_INT 1
79961: DEC
79962: ST_TO_ADDR
79963: LD_EXP 61
79967: PUSH
79968: FOR_TO
79969: IFFALSE 80190
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79971: LD_ADDR_VAR 0 4
79975: PUSH
79976: LD_EXP 61
79980: PUSH
79981: LD_VAR 0 2
79985: ARRAY
79986: PPUSH
79987: LD_INT 21
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PPUSH
79997: CALL_OW 72
80001: PUSH
80002: LD_EXP 90
80006: PUSH
80007: LD_VAR 0 2
80011: ARRAY
80012: UNION
80013: ST_TO_ADDR
// if not tmp then
80014: LD_VAR 0 4
80018: NOT
80019: IFFALSE 80023
// continue ;
80021: GO 79968
// for j in tmp do
80023: LD_ADDR_VAR 0 3
80027: PUSH
80028: LD_VAR 0 4
80032: PUSH
80033: FOR_IN
80034: IFFALSE 80186
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80036: LD_VAR 0 3
80040: PPUSH
80041: CALL_OW 110
80045: NOT
80046: PUSH
80047: LD_VAR 0 3
80051: PPUSH
80052: CALL_OW 314
80056: NOT
80057: AND
80058: PUSH
80059: LD_VAR 0 3
80063: PPUSH
80064: CALL_OW 311
80068: NOT
80069: AND
80070: PUSH
80071: LD_VAR 0 3
80075: PPUSH
80076: CALL_OW 310
80080: NOT
80081: AND
80082: PUSH
80083: LD_VAR 0 3
80087: PUSH
80088: LD_EXP 64
80092: PUSH
80093: LD_VAR 0 2
80097: ARRAY
80098: PUSH
80099: LD_INT 1
80101: ARRAY
80102: IN
80103: NOT
80104: AND
80105: PUSH
80106: LD_VAR 0 3
80110: PUSH
80111: LD_EXP 64
80115: PUSH
80116: LD_VAR 0 2
80120: ARRAY
80121: PUSH
80122: LD_INT 2
80124: ARRAY
80125: IN
80126: NOT
80127: AND
80128: PUSH
80129: LD_VAR 0 3
80133: PUSH
80134: LD_EXP 73
80138: PUSH
80139: LD_VAR 0 2
80143: ARRAY
80144: IN
80145: NOT
80146: AND
80147: IFFALSE 80184
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80149: LD_VAR 0 2
80153: PPUSH
80154: LD_EXP 61
80158: PUSH
80159: LD_VAR 0 2
80163: ARRAY
80164: PPUSH
80165: LD_VAR 0 3
80169: PPUSH
80170: LD_VAR 0 3
80174: PPUSH
80175: CALL_OW 257
80179: PPUSH
80180: CALL 78998 0 4
// end ;
80184: GO 80033
80186: POP
80187: POP
// end ;
80188: GO 79968
80190: POP
80191: POP
// end ;
80192: LD_VAR 0 1
80196: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
80197: LD_INT 0
80199: PPUSH
80200: PPUSH
80201: PPUSH
80202: PPUSH
80203: PPUSH
80204: PPUSH
// if not mc_bases [ base ] then
80205: LD_EXP 61
80209: PUSH
80210: LD_VAR 0 1
80214: ARRAY
80215: NOT
80216: IFFALSE 80220
// exit ;
80218: GO 80421
// tmp := [ ] ;
80220: LD_ADDR_VAR 0 6
80224: PUSH
80225: EMPTY
80226: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80227: LD_ADDR_VAR 0 7
80231: PUSH
80232: LD_VAR 0 3
80236: PPUSH
80237: LD_INT 0
80239: PPUSH
80240: CALL_OW 517
80244: ST_TO_ADDR
// if not list then
80245: LD_VAR 0 7
80249: NOT
80250: IFFALSE 80254
// exit ;
80252: GO 80421
// c := Count ( list [ 1 ] ) ;
80254: LD_ADDR_VAR 0 9
80258: PUSH
80259: LD_VAR 0 7
80263: PUSH
80264: LD_INT 1
80266: ARRAY
80267: PPUSH
80268: CALL 17052 0 1
80272: ST_TO_ADDR
// if amount > c then
80273: LD_VAR 0 2
80277: PUSH
80278: LD_VAR 0 9
80282: GREATER
80283: IFFALSE 80295
// amount := c ;
80285: LD_ADDR_VAR 0 2
80289: PUSH
80290: LD_VAR 0 9
80294: ST_TO_ADDR
// for i := 1 to amount do
80295: LD_ADDR_VAR 0 5
80299: PUSH
80300: DOUBLE
80301: LD_INT 1
80303: DEC
80304: ST_TO_ADDR
80305: LD_VAR 0 2
80309: PUSH
80310: FOR_TO
80311: IFFALSE 80369
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
80313: LD_ADDR_VAR 0 6
80317: PUSH
80318: LD_VAR 0 6
80322: PPUSH
80323: LD_VAR 0 5
80327: PPUSH
80328: LD_VAR 0 7
80332: PUSH
80333: LD_INT 1
80335: ARRAY
80336: PUSH
80337: LD_VAR 0 5
80341: ARRAY
80342: PUSH
80343: LD_VAR 0 7
80347: PUSH
80348: LD_INT 2
80350: ARRAY
80351: PUSH
80352: LD_VAR 0 5
80356: ARRAY
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PPUSH
80362: CALL_OW 1
80366: ST_TO_ADDR
80367: GO 80310
80369: POP
80370: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80371: LD_ADDR_EXP 74
80375: PUSH
80376: LD_EXP 74
80380: PPUSH
80381: LD_VAR 0 1
80385: PPUSH
80386: LD_VAR 0 6
80390: PPUSH
80391: CALL_OW 1
80395: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80396: LD_ADDR_EXP 76
80400: PUSH
80401: LD_EXP 76
80405: PPUSH
80406: LD_VAR 0 1
80410: PPUSH
80411: LD_VAR 0 3
80415: PPUSH
80416: CALL_OW 1
80420: ST_TO_ADDR
// end ;
80421: LD_VAR 0 4
80425: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80426: LD_INT 0
80428: PPUSH
// if not mc_bases [ base ] then
80429: LD_EXP 61
80433: PUSH
80434: LD_VAR 0 1
80438: ARRAY
80439: NOT
80440: IFFALSE 80444
// exit ;
80442: GO 80469
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80444: LD_ADDR_EXP 66
80448: PUSH
80449: LD_EXP 66
80453: PPUSH
80454: LD_VAR 0 1
80458: PPUSH
80459: LD_VAR 0 2
80463: PPUSH
80464: CALL_OW 1
80468: ST_TO_ADDR
// end ;
80469: LD_VAR 0 3
80473: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80474: LD_INT 0
80476: PPUSH
// if not mc_bases [ base ] then
80477: LD_EXP 61
80481: PUSH
80482: LD_VAR 0 1
80486: ARRAY
80487: NOT
80488: IFFALSE 80492
// exit ;
80490: GO 80529
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80492: LD_ADDR_EXP 66
80496: PUSH
80497: LD_EXP 66
80501: PPUSH
80502: LD_VAR 0 1
80506: PPUSH
80507: LD_EXP 66
80511: PUSH
80512: LD_VAR 0 1
80516: ARRAY
80517: PUSH
80518: LD_VAR 0 2
80522: UNION
80523: PPUSH
80524: CALL_OW 1
80528: ST_TO_ADDR
// end ;
80529: LD_VAR 0 3
80533: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80534: LD_INT 0
80536: PPUSH
// if not mc_bases [ base ] then
80537: LD_EXP 61
80541: PUSH
80542: LD_VAR 0 1
80546: ARRAY
80547: NOT
80548: IFFALSE 80552
// exit ;
80550: GO 80577
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80552: LD_ADDR_EXP 82
80556: PUSH
80557: LD_EXP 82
80561: PPUSH
80562: LD_VAR 0 1
80566: PPUSH
80567: LD_VAR 0 2
80571: PPUSH
80572: CALL_OW 1
80576: ST_TO_ADDR
// end ;
80577: LD_VAR 0 3
80581: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80582: LD_INT 0
80584: PPUSH
// if not mc_bases [ base ] then
80585: LD_EXP 61
80589: PUSH
80590: LD_VAR 0 1
80594: ARRAY
80595: NOT
80596: IFFALSE 80600
// exit ;
80598: GO 80637
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80600: LD_ADDR_EXP 82
80604: PUSH
80605: LD_EXP 82
80609: PPUSH
80610: LD_VAR 0 1
80614: PPUSH
80615: LD_EXP 82
80619: PUSH
80620: LD_VAR 0 1
80624: ARRAY
80625: PUSH
80626: LD_VAR 0 2
80630: ADD
80631: PPUSH
80632: CALL_OW 1
80636: ST_TO_ADDR
// end ;
80637: LD_VAR 0 3
80641: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80642: LD_INT 0
80644: PPUSH
// if not mc_bases [ base ] then
80645: LD_EXP 61
80649: PUSH
80650: LD_VAR 0 1
80654: ARRAY
80655: NOT
80656: IFFALSE 80660
// exit ;
80658: GO 80714
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80660: LD_ADDR_EXP 83
80664: PUSH
80665: LD_EXP 83
80669: PPUSH
80670: LD_VAR 0 1
80674: PPUSH
80675: LD_VAR 0 2
80679: PPUSH
80680: CALL_OW 1
80684: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80685: LD_ADDR_EXP 72
80689: PUSH
80690: LD_EXP 72
80694: PPUSH
80695: LD_VAR 0 1
80699: PPUSH
80700: LD_VAR 0 2
80704: PUSH
80705: LD_INT 0
80707: PLUS
80708: PPUSH
80709: CALL_OW 1
80713: ST_TO_ADDR
// end ;
80714: LD_VAR 0 3
80718: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80719: LD_INT 0
80721: PPUSH
// if not mc_bases [ base ] then
80722: LD_EXP 61
80726: PUSH
80727: LD_VAR 0 1
80731: ARRAY
80732: NOT
80733: IFFALSE 80737
// exit ;
80735: GO 80762
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80737: LD_ADDR_EXP 72
80741: PUSH
80742: LD_EXP 72
80746: PPUSH
80747: LD_VAR 0 1
80751: PPUSH
80752: LD_VAR 0 2
80756: PPUSH
80757: CALL_OW 1
80761: ST_TO_ADDR
// end ;
80762: LD_VAR 0 3
80766: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80767: LD_INT 0
80769: PPUSH
80770: PPUSH
80771: PPUSH
80772: PPUSH
// if not mc_bases [ base ] then
80773: LD_EXP 61
80777: PUSH
80778: LD_VAR 0 1
80782: ARRAY
80783: NOT
80784: IFFALSE 80788
// exit ;
80786: GO 80853
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80788: LD_ADDR_EXP 81
80792: PUSH
80793: LD_EXP 81
80797: PPUSH
80798: LD_VAR 0 1
80802: PUSH
80803: LD_EXP 81
80807: PUSH
80808: LD_VAR 0 1
80812: ARRAY
80813: PUSH
80814: LD_INT 1
80816: PLUS
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PPUSH
80822: LD_VAR 0 1
80826: PUSH
80827: LD_VAR 0 2
80831: PUSH
80832: LD_VAR 0 3
80836: PUSH
80837: LD_VAR 0 4
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: LIST
80846: LIST
80847: PPUSH
80848: CALL 19912 0 3
80852: ST_TO_ADDR
// end ;
80853: LD_VAR 0 5
80857: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80858: LD_INT 0
80860: PPUSH
// if not mc_bases [ base ] then
80861: LD_EXP 61
80865: PUSH
80866: LD_VAR 0 1
80870: ARRAY
80871: NOT
80872: IFFALSE 80876
// exit ;
80874: GO 80901
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80876: LD_ADDR_EXP 98
80880: PUSH
80881: LD_EXP 98
80885: PPUSH
80886: LD_VAR 0 1
80890: PPUSH
80891: LD_VAR 0 2
80895: PPUSH
80896: CALL_OW 1
80900: ST_TO_ADDR
// end ;
80901: LD_VAR 0 3
80905: RET
// export function MC_GetMinesField ( base ) ; begin
80906: LD_INT 0
80908: PPUSH
// result := mc_mines [ base ] ;
80909: LD_ADDR_VAR 0 2
80913: PUSH
80914: LD_EXP 74
80918: PUSH
80919: LD_VAR 0 1
80923: ARRAY
80924: ST_TO_ADDR
// end ;
80925: LD_VAR 0 2
80929: RET
// export function MC_GetProduceList ( base ) ; begin
80930: LD_INT 0
80932: PPUSH
// result := mc_produce [ base ] ;
80933: LD_ADDR_VAR 0 2
80937: PUSH
80938: LD_EXP 82
80942: PUSH
80943: LD_VAR 0 1
80947: ARRAY
80948: ST_TO_ADDR
// end ;
80949: LD_VAR 0 2
80953: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80954: LD_INT 0
80956: PPUSH
80957: PPUSH
// if not mc_bases then
80958: LD_EXP 61
80962: NOT
80963: IFFALSE 80967
// exit ;
80965: GO 81032
// if mc_bases [ base ] then
80967: LD_EXP 61
80971: PUSH
80972: LD_VAR 0 1
80976: ARRAY
80977: IFFALSE 81032
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80979: LD_ADDR_VAR 0 3
80983: PUSH
80984: LD_EXP 61
80988: PUSH
80989: LD_VAR 0 1
80993: ARRAY
80994: PPUSH
80995: LD_INT 30
80997: PUSH
80998: LD_VAR 0 2
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PPUSH
81007: CALL_OW 72
81011: ST_TO_ADDR
// if result then
81012: LD_VAR 0 3
81016: IFFALSE 81032
// result := result [ 1 ] ;
81018: LD_ADDR_VAR 0 3
81022: PUSH
81023: LD_VAR 0 3
81027: PUSH
81028: LD_INT 1
81030: ARRAY
81031: ST_TO_ADDR
// end ; end ;
81032: LD_VAR 0 3
81036: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81037: LD_INT 0
81039: PPUSH
81040: PPUSH
// if not mc_bases then
81041: LD_EXP 61
81045: NOT
81046: IFFALSE 81050
// exit ;
81048: GO 81095
// if mc_bases [ base ] then
81050: LD_EXP 61
81054: PUSH
81055: LD_VAR 0 1
81059: ARRAY
81060: IFFALSE 81095
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81062: LD_ADDR_VAR 0 3
81066: PUSH
81067: LD_EXP 61
81071: PUSH
81072: LD_VAR 0 1
81076: ARRAY
81077: PPUSH
81078: LD_INT 30
81080: PUSH
81081: LD_VAR 0 2
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PPUSH
81090: CALL_OW 72
81094: ST_TO_ADDR
// end ;
81095: LD_VAR 0 3
81099: RET
// export function MC_SetTame ( base , area ) ; begin
81100: LD_INT 0
81102: PPUSH
// if not mc_bases or not base then
81103: LD_EXP 61
81107: NOT
81108: PUSH
81109: LD_VAR 0 1
81113: NOT
81114: OR
81115: IFFALSE 81119
// exit ;
81117: GO 81144
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81119: LD_ADDR_EXP 89
81123: PUSH
81124: LD_EXP 89
81128: PPUSH
81129: LD_VAR 0 1
81133: PPUSH
81134: LD_VAR 0 2
81138: PPUSH
81139: CALL_OW 1
81143: ST_TO_ADDR
// end ;
81144: LD_VAR 0 3
81148: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81149: LD_INT 0
81151: PPUSH
81152: PPUSH
// if not mc_bases or not base then
81153: LD_EXP 61
81157: NOT
81158: PUSH
81159: LD_VAR 0 1
81163: NOT
81164: OR
81165: IFFALSE 81169
// exit ;
81167: GO 81271
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81169: LD_ADDR_VAR 0 4
81173: PUSH
81174: LD_EXP 61
81178: PUSH
81179: LD_VAR 0 1
81183: ARRAY
81184: PPUSH
81185: LD_INT 30
81187: PUSH
81188: LD_VAR 0 2
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PPUSH
81197: CALL_OW 72
81201: ST_TO_ADDR
// if not tmp then
81202: LD_VAR 0 4
81206: NOT
81207: IFFALSE 81211
// exit ;
81209: GO 81271
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81211: LD_ADDR_EXP 93
81215: PUSH
81216: LD_EXP 93
81220: PPUSH
81221: LD_VAR 0 1
81225: PPUSH
81226: LD_EXP 93
81230: PUSH
81231: LD_VAR 0 1
81235: ARRAY
81236: PPUSH
81237: LD_EXP 93
81241: PUSH
81242: LD_VAR 0 1
81246: ARRAY
81247: PUSH
81248: LD_INT 1
81250: PLUS
81251: PPUSH
81252: LD_VAR 0 4
81256: PUSH
81257: LD_INT 1
81259: ARRAY
81260: PPUSH
81261: CALL_OW 2
81265: PPUSH
81266: CALL_OW 1
81270: ST_TO_ADDR
// end ;
81271: LD_VAR 0 3
81275: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81276: LD_INT 0
81278: PPUSH
81279: PPUSH
// if not mc_bases or not base or not kinds then
81280: LD_EXP 61
81284: NOT
81285: PUSH
81286: LD_VAR 0 1
81290: NOT
81291: OR
81292: PUSH
81293: LD_VAR 0 2
81297: NOT
81298: OR
81299: IFFALSE 81303
// exit ;
81301: GO 81364
// for i in kinds do
81303: LD_ADDR_VAR 0 4
81307: PUSH
81308: LD_VAR 0 2
81312: PUSH
81313: FOR_IN
81314: IFFALSE 81362
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81316: LD_ADDR_EXP 95
81320: PUSH
81321: LD_EXP 95
81325: PPUSH
81326: LD_VAR 0 1
81330: PUSH
81331: LD_EXP 95
81335: PUSH
81336: LD_VAR 0 1
81340: ARRAY
81341: PUSH
81342: LD_INT 1
81344: PLUS
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PPUSH
81350: LD_VAR 0 4
81354: PPUSH
81355: CALL 19912 0 3
81359: ST_TO_ADDR
81360: GO 81313
81362: POP
81363: POP
// end ;
81364: LD_VAR 0 3
81368: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81369: LD_INT 0
81371: PPUSH
// if not mc_bases or not base or not areas then
81372: LD_EXP 61
81376: NOT
81377: PUSH
81378: LD_VAR 0 1
81382: NOT
81383: OR
81384: PUSH
81385: LD_VAR 0 2
81389: NOT
81390: OR
81391: IFFALSE 81395
// exit ;
81393: GO 81420
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81395: LD_ADDR_EXP 79
81399: PUSH
81400: LD_EXP 79
81404: PPUSH
81405: LD_VAR 0 1
81409: PPUSH
81410: LD_VAR 0 2
81414: PPUSH
81415: CALL_OW 1
81419: ST_TO_ADDR
// end ;
81420: LD_VAR 0 3
81424: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81425: LD_INT 0
81427: PPUSH
// if not mc_bases or not base or not teleports_exit then
81428: LD_EXP 61
81432: NOT
81433: PUSH
81434: LD_VAR 0 1
81438: NOT
81439: OR
81440: PUSH
81441: LD_VAR 0 2
81445: NOT
81446: OR
81447: IFFALSE 81451
// exit ;
81449: GO 81476
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81451: LD_ADDR_EXP 96
81455: PUSH
81456: LD_EXP 96
81460: PPUSH
81461: LD_VAR 0 1
81465: PPUSH
81466: LD_VAR 0 2
81470: PPUSH
81471: CALL_OW 1
81475: ST_TO_ADDR
// end ;
81476: LD_VAR 0 3
81480: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81481: LD_INT 0
81483: PPUSH
81484: PPUSH
81485: PPUSH
// if not mc_bases or not base or not ext_list then
81486: LD_EXP 61
81490: NOT
81491: PUSH
81492: LD_VAR 0 1
81496: NOT
81497: OR
81498: PUSH
81499: LD_VAR 0 5
81503: NOT
81504: OR
81505: IFFALSE 81509
// exit ;
81507: GO 81682
// tmp := GetFacExtXYD ( x , y , d ) ;
81509: LD_ADDR_VAR 0 8
81513: PUSH
81514: LD_VAR 0 2
81518: PPUSH
81519: LD_VAR 0 3
81523: PPUSH
81524: LD_VAR 0 4
81528: PPUSH
81529: CALL 49889 0 3
81533: ST_TO_ADDR
// if not tmp then
81534: LD_VAR 0 8
81538: NOT
81539: IFFALSE 81543
// exit ;
81541: GO 81682
// for i in tmp do
81543: LD_ADDR_VAR 0 7
81547: PUSH
81548: LD_VAR 0 8
81552: PUSH
81553: FOR_IN
81554: IFFALSE 81680
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81556: LD_ADDR_EXP 66
81560: PUSH
81561: LD_EXP 66
81565: PPUSH
81566: LD_VAR 0 1
81570: PPUSH
81571: LD_EXP 66
81575: PUSH
81576: LD_VAR 0 1
81580: ARRAY
81581: PPUSH
81582: LD_EXP 66
81586: PUSH
81587: LD_VAR 0 1
81591: ARRAY
81592: PUSH
81593: LD_INT 1
81595: PLUS
81596: PPUSH
81597: LD_VAR 0 5
81601: PUSH
81602: LD_INT 1
81604: ARRAY
81605: PUSH
81606: LD_VAR 0 7
81610: PUSH
81611: LD_INT 1
81613: ARRAY
81614: PUSH
81615: LD_VAR 0 7
81619: PUSH
81620: LD_INT 2
81622: ARRAY
81623: PUSH
81624: LD_VAR 0 7
81628: PUSH
81629: LD_INT 3
81631: ARRAY
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: PPUSH
81639: CALL_OW 2
81643: PPUSH
81644: CALL_OW 1
81648: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81649: LD_ADDR_VAR 0 5
81653: PUSH
81654: LD_VAR 0 5
81658: PPUSH
81659: LD_INT 1
81661: PPUSH
81662: CALL_OW 3
81666: ST_TO_ADDR
// if not ext_list then
81667: LD_VAR 0 5
81671: NOT
81672: IFFALSE 81678
// exit ;
81674: POP
81675: POP
81676: GO 81682
// end ;
81678: GO 81553
81680: POP
81681: POP
// end ;
81682: LD_VAR 0 6
81686: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81687: LD_INT 0
81689: PPUSH
// if not mc_bases or not base or not weapon_list then
81690: LD_EXP 61
81694: NOT
81695: PUSH
81696: LD_VAR 0 1
81700: NOT
81701: OR
81702: PUSH
81703: LD_VAR 0 2
81707: NOT
81708: OR
81709: IFFALSE 81713
// exit ;
81711: GO 81738
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81713: LD_ADDR_EXP 100
81717: PUSH
81718: LD_EXP 100
81722: PPUSH
81723: LD_VAR 0 1
81727: PPUSH
81728: LD_VAR 0 2
81732: PPUSH
81733: CALL_OW 1
81737: ST_TO_ADDR
// end ;
81738: LD_VAR 0 3
81742: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81743: LD_INT 0
81745: PPUSH
// if not mc_bases or not base or not tech_list then
81746: LD_EXP 61
81750: NOT
81751: PUSH
81752: LD_VAR 0 1
81756: NOT
81757: OR
81758: PUSH
81759: LD_VAR 0 2
81763: NOT
81764: OR
81765: IFFALSE 81769
// exit ;
81767: GO 81794
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81769: LD_ADDR_EXP 88
81773: PUSH
81774: LD_EXP 88
81778: PPUSH
81779: LD_VAR 0 1
81783: PPUSH
81784: LD_VAR 0 2
81788: PPUSH
81789: CALL_OW 1
81793: ST_TO_ADDR
// end ;
81794: LD_VAR 0 3
81798: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81799: LD_INT 0
81801: PPUSH
// if not mc_bases or not parking_area or not base then
81802: LD_EXP 61
81806: NOT
81807: PUSH
81808: LD_VAR 0 2
81812: NOT
81813: OR
81814: PUSH
81815: LD_VAR 0 1
81819: NOT
81820: OR
81821: IFFALSE 81825
// exit ;
81823: GO 81850
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81825: LD_ADDR_EXP 85
81829: PUSH
81830: LD_EXP 85
81834: PPUSH
81835: LD_VAR 0 1
81839: PPUSH
81840: LD_VAR 0 2
81844: PPUSH
81845: CALL_OW 1
81849: ST_TO_ADDR
// end ;
81850: LD_VAR 0 3
81854: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81855: LD_INT 0
81857: PPUSH
// if not mc_bases or not base or not scan_area then
81858: LD_EXP 61
81862: NOT
81863: PUSH
81864: LD_VAR 0 1
81868: NOT
81869: OR
81870: PUSH
81871: LD_VAR 0 2
81875: NOT
81876: OR
81877: IFFALSE 81881
// exit ;
81879: GO 81906
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81881: LD_ADDR_EXP 86
81885: PUSH
81886: LD_EXP 86
81890: PPUSH
81891: LD_VAR 0 1
81895: PPUSH
81896: LD_VAR 0 2
81900: PPUSH
81901: CALL_OW 1
81905: ST_TO_ADDR
// end ;
81906: LD_VAR 0 3
81910: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81911: LD_INT 0
81913: PPUSH
81914: PPUSH
// if not mc_bases or not base then
81915: LD_EXP 61
81919: NOT
81920: PUSH
81921: LD_VAR 0 1
81925: NOT
81926: OR
81927: IFFALSE 81931
// exit ;
81929: GO 81995
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81931: LD_ADDR_VAR 0 3
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: LD_INT 2
81941: PUSH
81942: LD_INT 3
81944: PUSH
81945: LD_INT 4
81947: PUSH
81948: LD_INT 11
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81958: LD_ADDR_EXP 88
81962: PUSH
81963: LD_EXP 88
81967: PPUSH
81968: LD_VAR 0 1
81972: PPUSH
81973: LD_EXP 88
81977: PUSH
81978: LD_VAR 0 1
81982: ARRAY
81983: PUSH
81984: LD_VAR 0 3
81988: DIFF
81989: PPUSH
81990: CALL_OW 1
81994: ST_TO_ADDR
// end ;
81995: LD_VAR 0 2
81999: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82000: LD_INT 0
82002: PPUSH
// result := mc_vehicles [ base ] ;
82003: LD_ADDR_VAR 0 3
82007: PUSH
82008: LD_EXP 80
82012: PUSH
82013: LD_VAR 0 1
82017: ARRAY
82018: ST_TO_ADDR
// if onlyCombat then
82019: LD_VAR 0 2
82023: IFFALSE 82195
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82025: LD_ADDR_VAR 0 3
82029: PUSH
82030: LD_VAR 0 3
82034: PUSH
82035: LD_VAR 0 3
82039: PPUSH
82040: LD_INT 2
82042: PUSH
82043: LD_INT 34
82045: PUSH
82046: LD_INT 12
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 34
82055: PUSH
82056: LD_INT 51
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 34
82065: PUSH
82066: LD_INT 89
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 34
82075: PUSH
82076: LD_INT 32
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 34
82085: PUSH
82086: LD_INT 13
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 34
82095: PUSH
82096: LD_INT 52
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 34
82105: PUSH
82106: LD_INT 88
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 34
82115: PUSH
82116: LD_INT 14
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 34
82125: PUSH
82126: LD_INT 53
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 34
82135: PUSH
82136: LD_INT 98
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 34
82145: PUSH
82146: LD_INT 31
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 34
82155: PUSH
82156: LD_INT 48
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 34
82165: PUSH
82166: LD_INT 8
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: PPUSH
82189: CALL_OW 72
82193: DIFF
82194: ST_TO_ADDR
// end ; end_of_file
82195: LD_VAR 0 3
82199: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82200: LD_INT 0
82202: PPUSH
82203: PPUSH
82204: PPUSH
// if not mc_bases or not skirmish then
82205: LD_EXP 61
82209: NOT
82210: PUSH
82211: LD_EXP 59
82215: NOT
82216: OR
82217: IFFALSE 82221
// exit ;
82219: GO 82386
// for i = 1 to mc_bases do
82221: LD_ADDR_VAR 0 4
82225: PUSH
82226: DOUBLE
82227: LD_INT 1
82229: DEC
82230: ST_TO_ADDR
82231: LD_EXP 61
82235: PUSH
82236: FOR_TO
82237: IFFALSE 82384
// begin if sci in mc_bases [ i ] then
82239: LD_VAR 0 2
82243: PUSH
82244: LD_EXP 61
82248: PUSH
82249: LD_VAR 0 4
82253: ARRAY
82254: IN
82255: IFFALSE 82382
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82257: LD_ADDR_EXP 90
82261: PUSH
82262: LD_EXP 90
82266: PPUSH
82267: LD_VAR 0 4
82271: PUSH
82272: LD_EXP 90
82276: PUSH
82277: LD_VAR 0 4
82281: ARRAY
82282: PUSH
82283: LD_INT 1
82285: PLUS
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PPUSH
82291: LD_VAR 0 1
82295: PPUSH
82296: CALL 19912 0 3
82300: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82301: LD_ADDR_VAR 0 5
82305: PUSH
82306: LD_EXP 61
82310: PUSH
82311: LD_VAR 0 4
82315: ARRAY
82316: PPUSH
82317: LD_INT 2
82319: PUSH
82320: LD_INT 30
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 30
82332: PUSH
82333: LD_INT 1
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: LIST
82344: PPUSH
82345: CALL_OW 72
82349: PPUSH
82350: LD_VAR 0 1
82354: PPUSH
82355: CALL_OW 74
82359: ST_TO_ADDR
// if tmp then
82360: LD_VAR 0 5
82364: IFFALSE 82380
// ComStandNearbyBuilding ( ape , tmp ) ;
82366: LD_VAR 0 1
82370: PPUSH
82371: LD_VAR 0 5
82375: PPUSH
82376: CALL 16514 0 2
// break ;
82380: GO 82384
// end ; end ;
82382: GO 82236
82384: POP
82385: POP
// end ;
82386: LD_VAR 0 3
82390: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82391: LD_INT 0
82393: PPUSH
82394: PPUSH
82395: PPUSH
// if not mc_bases or not skirmish then
82396: LD_EXP 61
82400: NOT
82401: PUSH
82402: LD_EXP 59
82406: NOT
82407: OR
82408: IFFALSE 82412
// exit ;
82410: GO 82501
// for i = 1 to mc_bases do
82412: LD_ADDR_VAR 0 4
82416: PUSH
82417: DOUBLE
82418: LD_INT 1
82420: DEC
82421: ST_TO_ADDR
82422: LD_EXP 61
82426: PUSH
82427: FOR_TO
82428: IFFALSE 82499
// begin if building in mc_busy_turret_list [ i ] then
82430: LD_VAR 0 1
82434: PUSH
82435: LD_EXP 71
82439: PUSH
82440: LD_VAR 0 4
82444: ARRAY
82445: IN
82446: IFFALSE 82497
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82448: LD_ADDR_VAR 0 5
82452: PUSH
82453: LD_EXP 71
82457: PUSH
82458: LD_VAR 0 4
82462: ARRAY
82463: PUSH
82464: LD_VAR 0 1
82468: DIFF
82469: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82470: LD_ADDR_EXP 71
82474: PUSH
82475: LD_EXP 71
82479: PPUSH
82480: LD_VAR 0 4
82484: PPUSH
82485: LD_VAR 0 5
82489: PPUSH
82490: CALL_OW 1
82494: ST_TO_ADDR
// break ;
82495: GO 82499
// end ; end ;
82497: GO 82427
82499: POP
82500: POP
// end ;
82501: LD_VAR 0 3
82505: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82506: LD_INT 0
82508: PPUSH
82509: PPUSH
82510: PPUSH
// if not mc_bases or not skirmish then
82511: LD_EXP 61
82515: NOT
82516: PUSH
82517: LD_EXP 59
82521: NOT
82522: OR
82523: IFFALSE 82527
// exit ;
82525: GO 82726
// for i = 1 to mc_bases do
82527: LD_ADDR_VAR 0 5
82531: PUSH
82532: DOUBLE
82533: LD_INT 1
82535: DEC
82536: ST_TO_ADDR
82537: LD_EXP 61
82541: PUSH
82542: FOR_TO
82543: IFFALSE 82724
// if building in mc_bases [ i ] then
82545: LD_VAR 0 1
82549: PUSH
82550: LD_EXP 61
82554: PUSH
82555: LD_VAR 0 5
82559: ARRAY
82560: IN
82561: IFFALSE 82722
// begin tmp := mc_bases [ i ] diff building ;
82563: LD_ADDR_VAR 0 6
82567: PUSH
82568: LD_EXP 61
82572: PUSH
82573: LD_VAR 0 5
82577: ARRAY
82578: PUSH
82579: LD_VAR 0 1
82583: DIFF
82584: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82585: LD_ADDR_EXP 61
82589: PUSH
82590: LD_EXP 61
82594: PPUSH
82595: LD_VAR 0 5
82599: PPUSH
82600: LD_VAR 0 6
82604: PPUSH
82605: CALL_OW 1
82609: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82610: LD_VAR 0 1
82614: PUSH
82615: LD_EXP 69
82619: PUSH
82620: LD_VAR 0 5
82624: ARRAY
82625: IN
82626: IFFALSE 82665
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82628: LD_ADDR_EXP 69
82632: PUSH
82633: LD_EXP 69
82637: PPUSH
82638: LD_VAR 0 5
82642: PPUSH
82643: LD_EXP 69
82647: PUSH
82648: LD_VAR 0 5
82652: ARRAY
82653: PUSH
82654: LD_VAR 0 1
82658: DIFF
82659: PPUSH
82660: CALL_OW 1
82664: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82665: LD_VAR 0 1
82669: PUSH
82670: LD_EXP 70
82674: PUSH
82675: LD_VAR 0 5
82679: ARRAY
82680: IN
82681: IFFALSE 82720
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82683: LD_ADDR_EXP 70
82687: PUSH
82688: LD_EXP 70
82692: PPUSH
82693: LD_VAR 0 5
82697: PPUSH
82698: LD_EXP 70
82702: PUSH
82703: LD_VAR 0 5
82707: ARRAY
82708: PUSH
82709: LD_VAR 0 1
82713: DIFF
82714: PPUSH
82715: CALL_OW 1
82719: ST_TO_ADDR
// break ;
82720: GO 82724
// end ;
82722: GO 82542
82724: POP
82725: POP
// end ;
82726: LD_VAR 0 4
82730: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82731: LD_INT 0
82733: PPUSH
82734: PPUSH
82735: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82736: LD_EXP 61
82740: NOT
82741: PUSH
82742: LD_EXP 59
82746: NOT
82747: OR
82748: PUSH
82749: LD_VAR 0 3
82753: PUSH
82754: LD_EXP 87
82758: IN
82759: NOT
82760: OR
82761: IFFALSE 82765
// exit ;
82763: GO 82888
// for i = 1 to mc_vehicles do
82765: LD_ADDR_VAR 0 6
82769: PUSH
82770: DOUBLE
82771: LD_INT 1
82773: DEC
82774: ST_TO_ADDR
82775: LD_EXP 80
82779: PUSH
82780: FOR_TO
82781: IFFALSE 82886
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82783: LD_VAR 0 2
82787: PUSH
82788: LD_EXP 80
82792: PUSH
82793: LD_VAR 0 6
82797: ARRAY
82798: IN
82799: PUSH
82800: LD_VAR 0 1
82804: PUSH
82805: LD_EXP 80
82809: PUSH
82810: LD_VAR 0 6
82814: ARRAY
82815: IN
82816: OR
82817: IFFALSE 82884
// begin tmp := mc_vehicles [ i ] diff old ;
82819: LD_ADDR_VAR 0 7
82823: PUSH
82824: LD_EXP 80
82828: PUSH
82829: LD_VAR 0 6
82833: ARRAY
82834: PUSH
82835: LD_VAR 0 2
82839: DIFF
82840: ST_TO_ADDR
// tmp := tmp diff new ;
82841: LD_ADDR_VAR 0 7
82845: PUSH
82846: LD_VAR 0 7
82850: PUSH
82851: LD_VAR 0 1
82855: DIFF
82856: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82857: LD_ADDR_EXP 80
82861: PUSH
82862: LD_EXP 80
82866: PPUSH
82867: LD_VAR 0 6
82871: PPUSH
82872: LD_VAR 0 7
82876: PPUSH
82877: CALL_OW 1
82881: ST_TO_ADDR
// break ;
82882: GO 82886
// end ;
82884: GO 82780
82886: POP
82887: POP
// end ;
82888: LD_VAR 0 5
82892: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82893: LD_INT 0
82895: PPUSH
82896: PPUSH
82897: PPUSH
82898: PPUSH
// if not mc_bases or not skirmish then
82899: LD_EXP 61
82903: NOT
82904: PUSH
82905: LD_EXP 59
82909: NOT
82910: OR
82911: IFFALSE 82915
// exit ;
82913: GO 83335
// repeat wait ( 0 0$1 ) ;
82915: LD_INT 35
82917: PPUSH
82918: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
82922: LD_EXP 105
82926: NOT
82927: IFFALSE 82915
// mc_block_vehicle_constructed_thread := true ;
82929: LD_ADDR_EXP 105
82933: PUSH
82934: LD_INT 1
82936: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
82937: LD_ADDR_VAR 0 5
82941: PUSH
82942: LD_VAR 0 1
82946: PPUSH
82947: CALL_OW 255
82951: ST_TO_ADDR
// for i = 1 to mc_bases do
82952: LD_ADDR_VAR 0 4
82956: PUSH
82957: DOUBLE
82958: LD_INT 1
82960: DEC
82961: ST_TO_ADDR
82962: LD_EXP 61
82966: PUSH
82967: FOR_TO
82968: IFFALSE 83325
// begin if factory in mc_bases [ i ] then
82970: LD_VAR 0 2
82974: PUSH
82975: LD_EXP 61
82979: PUSH
82980: LD_VAR 0 4
82984: ARRAY
82985: IN
82986: IFFALSE 83323
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
82988: LD_EXP 83
82992: PUSH
82993: LD_VAR 0 4
82997: ARRAY
82998: PUSH
82999: LD_EXP 72
83003: PUSH
83004: LD_VAR 0 4
83008: ARRAY
83009: LESS
83010: PUSH
83011: LD_VAR 0 1
83015: PPUSH
83016: CALL_OW 264
83020: PUSH
83021: LD_INT 31
83023: PUSH
83024: LD_INT 32
83026: PUSH
83027: LD_INT 51
83029: PUSH
83030: LD_INT 89
83032: PUSH
83033: LD_INT 12
83035: PUSH
83036: LD_INT 30
83038: PUSH
83039: LD_INT 98
83041: PUSH
83042: LD_INT 11
83044: PUSH
83045: LD_INT 53
83047: PUSH
83048: LD_INT 14
83050: PUSH
83051: LD_INT 91
83053: PUSH
83054: LD_INT 29
83056: PUSH
83057: LD_INT 99
83059: PUSH
83060: LD_INT 13
83062: PUSH
83063: LD_INT 52
83065: PUSH
83066: LD_INT 88
83068: PUSH
83069: LD_INT 48
83071: PUSH
83072: LD_INT 8
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: IN
83095: NOT
83096: AND
83097: IFFALSE 83145
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83099: LD_ADDR_EXP 83
83103: PUSH
83104: LD_EXP 83
83108: PPUSH
83109: LD_VAR 0 4
83113: PUSH
83114: LD_EXP 83
83118: PUSH
83119: LD_VAR 0 4
83123: ARRAY
83124: PUSH
83125: LD_INT 1
83127: PLUS
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PPUSH
83133: LD_VAR 0 1
83137: PPUSH
83138: CALL 19912 0 3
83142: ST_TO_ADDR
83143: GO 83189
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83145: LD_ADDR_EXP 80
83149: PUSH
83150: LD_EXP 80
83154: PPUSH
83155: LD_VAR 0 4
83159: PUSH
83160: LD_EXP 80
83164: PUSH
83165: LD_VAR 0 4
83169: ARRAY
83170: PUSH
83171: LD_INT 1
83173: PLUS
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PPUSH
83179: LD_VAR 0 1
83183: PPUSH
83184: CALL 19912 0 3
83188: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
83189: LD_ADDR_EXP 105
83193: PUSH
83194: LD_INT 0
83196: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83197: LD_VAR 0 1
83201: PPUSH
83202: CALL_OW 263
83206: PUSH
83207: LD_INT 2
83209: EQUAL
83210: IFFALSE 83239
// begin repeat wait ( 0 0$3 ) ;
83212: LD_INT 105
83214: PPUSH
83215: CALL_OW 67
// Connect ( vehicle ) ;
83219: LD_VAR 0 1
83223: PPUSH
83224: CALL 22881 0 1
// until IsControledBy ( vehicle ) ;
83228: LD_VAR 0 1
83232: PPUSH
83233: CALL_OW 312
83237: IFFALSE 83212
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83239: LD_VAR 0 1
83243: PPUSH
83244: LD_EXP 85
83248: PUSH
83249: LD_VAR 0 4
83253: ARRAY
83254: PPUSH
83255: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83259: LD_VAR 0 1
83263: PPUSH
83264: CALL_OW 263
83268: PUSH
83269: LD_INT 1
83271: NONEQUAL
83272: IFFALSE 83276
// break ;
83274: GO 83325
// repeat wait ( 0 0$1 ) ;
83276: LD_INT 35
83278: PPUSH
83279: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83283: LD_VAR 0 1
83287: PPUSH
83288: LD_EXP 85
83292: PUSH
83293: LD_VAR 0 4
83297: ARRAY
83298: PPUSH
83299: CALL_OW 308
83303: IFFALSE 83276
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83305: LD_VAR 0 1
83309: PPUSH
83310: CALL_OW 311
83314: PPUSH
83315: CALL_OW 121
// exit ;
83319: POP
83320: POP
83321: GO 83335
// end ; end ;
83323: GO 82967
83325: POP
83326: POP
// mc_block_vehicle_constructed_thread := false ;
83327: LD_ADDR_EXP 105
83331: PUSH
83332: LD_INT 0
83334: ST_TO_ADDR
// end ;
83335: LD_VAR 0 3
83339: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83340: LD_INT 0
83342: PPUSH
83343: PPUSH
83344: PPUSH
83345: PPUSH
// if not mc_bases or not skirmish then
83346: LD_EXP 61
83350: NOT
83351: PUSH
83352: LD_EXP 59
83356: NOT
83357: OR
83358: IFFALSE 83362
// exit ;
83360: GO 83715
// repeat wait ( 0 0$1 ) ;
83362: LD_INT 35
83364: PPUSH
83365: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83369: LD_VAR 0 2
83373: PPUSH
83374: LD_VAR 0 3
83378: PPUSH
83379: CALL_OW 284
83383: IFFALSE 83362
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83385: LD_VAR 0 2
83389: PPUSH
83390: LD_VAR 0 3
83394: PPUSH
83395: CALL_OW 283
83399: PUSH
83400: LD_INT 4
83402: EQUAL
83403: IFFALSE 83407
// exit ;
83405: GO 83715
// for i = 1 to mc_bases do
83407: LD_ADDR_VAR 0 7
83411: PUSH
83412: DOUBLE
83413: LD_INT 1
83415: DEC
83416: ST_TO_ADDR
83417: LD_EXP 61
83421: PUSH
83422: FOR_TO
83423: IFFALSE 83713
// begin if mc_crates_area [ i ] then
83425: LD_EXP 79
83429: PUSH
83430: LD_VAR 0 7
83434: ARRAY
83435: IFFALSE 83546
// for j in mc_crates_area [ i ] do
83437: LD_ADDR_VAR 0 8
83441: PUSH
83442: LD_EXP 79
83446: PUSH
83447: LD_VAR 0 7
83451: ARRAY
83452: PUSH
83453: FOR_IN
83454: IFFALSE 83544
// if InArea ( x , y , j ) then
83456: LD_VAR 0 2
83460: PPUSH
83461: LD_VAR 0 3
83465: PPUSH
83466: LD_VAR 0 8
83470: PPUSH
83471: CALL_OW 309
83475: IFFALSE 83542
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83477: LD_ADDR_EXP 77
83481: PUSH
83482: LD_EXP 77
83486: PPUSH
83487: LD_VAR 0 7
83491: PUSH
83492: LD_EXP 77
83496: PUSH
83497: LD_VAR 0 7
83501: ARRAY
83502: PUSH
83503: LD_INT 1
83505: PLUS
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PPUSH
83511: LD_VAR 0 4
83515: PUSH
83516: LD_VAR 0 2
83520: PUSH
83521: LD_VAR 0 3
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: LIST
83530: PPUSH
83531: CALL 19912 0 3
83535: ST_TO_ADDR
// exit ;
83536: POP
83537: POP
83538: POP
83539: POP
83540: GO 83715
// end ;
83542: GO 83453
83544: POP
83545: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83546: LD_ADDR_VAR 0 9
83550: PUSH
83551: LD_EXP 61
83555: PUSH
83556: LD_VAR 0 7
83560: ARRAY
83561: PPUSH
83562: LD_INT 2
83564: PUSH
83565: LD_INT 30
83567: PUSH
83568: LD_INT 0
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 30
83577: PUSH
83578: LD_INT 1
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: LIST
83589: PPUSH
83590: CALL_OW 72
83594: ST_TO_ADDR
// if not depot then
83595: LD_VAR 0 9
83599: NOT
83600: IFFALSE 83604
// continue ;
83602: GO 83422
// for j in depot do
83604: LD_ADDR_VAR 0 8
83608: PUSH
83609: LD_VAR 0 9
83613: PUSH
83614: FOR_IN
83615: IFFALSE 83709
// if GetDistUnitXY ( j , x , y ) < 30 then
83617: LD_VAR 0 8
83621: PPUSH
83622: LD_VAR 0 2
83626: PPUSH
83627: LD_VAR 0 3
83631: PPUSH
83632: CALL_OW 297
83636: PUSH
83637: LD_INT 30
83639: LESS
83640: IFFALSE 83707
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83642: LD_ADDR_EXP 77
83646: PUSH
83647: LD_EXP 77
83651: PPUSH
83652: LD_VAR 0 7
83656: PUSH
83657: LD_EXP 77
83661: PUSH
83662: LD_VAR 0 7
83666: ARRAY
83667: PUSH
83668: LD_INT 1
83670: PLUS
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PPUSH
83676: LD_VAR 0 4
83680: PUSH
83681: LD_VAR 0 2
83685: PUSH
83686: LD_VAR 0 3
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: LIST
83695: PPUSH
83696: CALL 19912 0 3
83700: ST_TO_ADDR
// exit ;
83701: POP
83702: POP
83703: POP
83704: POP
83705: GO 83715
// end ;
83707: GO 83614
83709: POP
83710: POP
// end ;
83711: GO 83422
83713: POP
83714: POP
// end ;
83715: LD_VAR 0 6
83719: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83720: LD_INT 0
83722: PPUSH
83723: PPUSH
83724: PPUSH
83725: PPUSH
// if not mc_bases or not skirmish then
83726: LD_EXP 61
83730: NOT
83731: PUSH
83732: LD_EXP 59
83736: NOT
83737: OR
83738: IFFALSE 83742
// exit ;
83740: GO 84019
// side := GetSide ( lab ) ;
83742: LD_ADDR_VAR 0 4
83746: PUSH
83747: LD_VAR 0 2
83751: PPUSH
83752: CALL_OW 255
83756: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83757: LD_VAR 0 4
83761: PUSH
83762: LD_EXP 87
83766: IN
83767: NOT
83768: PUSH
83769: LD_EXP 88
83773: NOT
83774: OR
83775: PUSH
83776: LD_EXP 61
83780: NOT
83781: OR
83782: IFFALSE 83786
// exit ;
83784: GO 84019
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83786: LD_ADDR_EXP 88
83790: PUSH
83791: LD_EXP 88
83795: PPUSH
83796: LD_VAR 0 4
83800: PPUSH
83801: LD_EXP 88
83805: PUSH
83806: LD_VAR 0 4
83810: ARRAY
83811: PUSH
83812: LD_VAR 0 1
83816: DIFF
83817: PPUSH
83818: CALL_OW 1
83822: ST_TO_ADDR
// for i = 1 to mc_bases do
83823: LD_ADDR_VAR 0 5
83827: PUSH
83828: DOUBLE
83829: LD_INT 1
83831: DEC
83832: ST_TO_ADDR
83833: LD_EXP 61
83837: PUSH
83838: FOR_TO
83839: IFFALSE 84017
// begin if lab in mc_bases [ i ] then
83841: LD_VAR 0 2
83845: PUSH
83846: LD_EXP 61
83850: PUSH
83851: LD_VAR 0 5
83855: ARRAY
83856: IN
83857: IFFALSE 84015
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83859: LD_VAR 0 1
83863: PUSH
83864: LD_INT 11
83866: PUSH
83867: LD_INT 4
83869: PUSH
83870: LD_INT 3
83872: PUSH
83873: LD_INT 2
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: IN
83882: PUSH
83883: LD_EXP 91
83887: PUSH
83888: LD_VAR 0 5
83892: ARRAY
83893: AND
83894: IFFALSE 84015
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83896: LD_ADDR_VAR 0 6
83900: PUSH
83901: LD_EXP 91
83905: PUSH
83906: LD_VAR 0 5
83910: ARRAY
83911: PUSH
83912: LD_INT 1
83914: ARRAY
83915: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83916: LD_ADDR_EXP 91
83920: PUSH
83921: LD_EXP 91
83925: PPUSH
83926: LD_VAR 0 5
83930: PPUSH
83931: EMPTY
83932: PPUSH
83933: CALL_OW 1
83937: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83938: LD_VAR 0 6
83942: PPUSH
83943: LD_INT 0
83945: PPUSH
83946: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83950: LD_VAR 0 6
83954: PPUSH
83955: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83959: LD_ADDR_EXP 90
83963: PUSH
83964: LD_EXP 90
83968: PPUSH
83969: LD_VAR 0 5
83973: PPUSH
83974: LD_EXP 90
83978: PUSH
83979: LD_VAR 0 5
83983: ARRAY
83984: PPUSH
83985: LD_INT 1
83987: PPUSH
83988: LD_VAR 0 6
83992: PPUSH
83993: CALL_OW 2
83997: PPUSH
83998: CALL_OW 1
84002: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84003: LD_VAR 0 5
84007: PPUSH
84008: LD_INT 112
84010: PPUSH
84011: CALL 60483 0 2
// end ; end ; end ;
84015: GO 83838
84017: POP
84018: POP
// end ;
84019: LD_VAR 0 3
84023: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84024: LD_INT 0
84026: PPUSH
84027: PPUSH
84028: PPUSH
84029: PPUSH
84030: PPUSH
84031: PPUSH
84032: PPUSH
84033: PPUSH
// if not mc_bases or not skirmish then
84034: LD_EXP 61
84038: NOT
84039: PUSH
84040: LD_EXP 59
84044: NOT
84045: OR
84046: IFFALSE 84050
// exit ;
84048: GO 85419
// for i = 1 to mc_bases do
84050: LD_ADDR_VAR 0 3
84054: PUSH
84055: DOUBLE
84056: LD_INT 1
84058: DEC
84059: ST_TO_ADDR
84060: LD_EXP 61
84064: PUSH
84065: FOR_TO
84066: IFFALSE 85417
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84068: LD_VAR 0 1
84072: PUSH
84073: LD_EXP 61
84077: PUSH
84078: LD_VAR 0 3
84082: ARRAY
84083: IN
84084: PUSH
84085: LD_VAR 0 1
84089: PUSH
84090: LD_EXP 68
84094: PUSH
84095: LD_VAR 0 3
84099: ARRAY
84100: IN
84101: OR
84102: PUSH
84103: LD_VAR 0 1
84107: PUSH
84108: LD_EXP 83
84112: PUSH
84113: LD_VAR 0 3
84117: ARRAY
84118: IN
84119: OR
84120: PUSH
84121: LD_VAR 0 1
84125: PUSH
84126: LD_EXP 80
84130: PUSH
84131: LD_VAR 0 3
84135: ARRAY
84136: IN
84137: OR
84138: PUSH
84139: LD_VAR 0 1
84143: PUSH
84144: LD_EXP 90
84148: PUSH
84149: LD_VAR 0 3
84153: ARRAY
84154: IN
84155: OR
84156: PUSH
84157: LD_VAR 0 1
84161: PUSH
84162: LD_EXP 91
84166: PUSH
84167: LD_VAR 0 3
84171: ARRAY
84172: IN
84173: OR
84174: IFFALSE 85415
// begin if un in mc_ape [ i ] then
84176: LD_VAR 0 1
84180: PUSH
84181: LD_EXP 90
84185: PUSH
84186: LD_VAR 0 3
84190: ARRAY
84191: IN
84192: IFFALSE 84231
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84194: LD_ADDR_EXP 90
84198: PUSH
84199: LD_EXP 90
84203: PPUSH
84204: LD_VAR 0 3
84208: PPUSH
84209: LD_EXP 90
84213: PUSH
84214: LD_VAR 0 3
84218: ARRAY
84219: PUSH
84220: LD_VAR 0 1
84224: DIFF
84225: PPUSH
84226: CALL_OW 1
84230: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84231: LD_VAR 0 1
84235: PUSH
84236: LD_EXP 91
84240: PUSH
84241: LD_VAR 0 3
84245: ARRAY
84246: IN
84247: IFFALSE 84271
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84249: LD_ADDR_EXP 91
84253: PUSH
84254: LD_EXP 91
84258: PPUSH
84259: LD_VAR 0 3
84263: PPUSH
84264: EMPTY
84265: PPUSH
84266: CALL_OW 1
84270: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84271: LD_VAR 0 1
84275: PPUSH
84276: CALL_OW 247
84280: PUSH
84281: LD_INT 2
84283: EQUAL
84284: PUSH
84285: LD_VAR 0 1
84289: PPUSH
84290: CALL_OW 110
84294: PUSH
84295: LD_INT 20
84297: EQUAL
84298: PUSH
84299: LD_VAR 0 1
84303: PUSH
84304: LD_EXP 83
84308: PUSH
84309: LD_VAR 0 3
84313: ARRAY
84314: IN
84315: OR
84316: PUSH
84317: LD_VAR 0 1
84321: PPUSH
84322: CALL_OW 264
84326: PUSH
84327: LD_INT 12
84329: PUSH
84330: LD_INT 51
84332: PUSH
84333: LD_INT 89
84335: PUSH
84336: LD_INT 32
84338: PUSH
84339: LD_INT 13
84341: PUSH
84342: LD_INT 52
84344: PUSH
84345: LD_INT 31
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: IN
84357: OR
84358: AND
84359: IFFALSE 84667
// begin if un in mc_defender [ i ] then
84361: LD_VAR 0 1
84365: PUSH
84366: LD_EXP 83
84370: PUSH
84371: LD_VAR 0 3
84375: ARRAY
84376: IN
84377: IFFALSE 84416
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84379: LD_ADDR_EXP 83
84383: PUSH
84384: LD_EXP 83
84388: PPUSH
84389: LD_VAR 0 3
84393: PPUSH
84394: LD_EXP 83
84398: PUSH
84399: LD_VAR 0 3
84403: ARRAY
84404: PUSH
84405: LD_VAR 0 1
84409: DIFF
84410: PPUSH
84411: CALL_OW 1
84415: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84416: LD_ADDR_VAR 0 8
84420: PUSH
84421: LD_VAR 0 3
84425: PPUSH
84426: LD_INT 3
84428: PPUSH
84429: CALL 81037 0 2
84433: ST_TO_ADDR
// if fac then
84434: LD_VAR 0 8
84438: IFFALSE 84667
// begin for j in fac do
84440: LD_ADDR_VAR 0 4
84444: PUSH
84445: LD_VAR 0 8
84449: PUSH
84450: FOR_IN
84451: IFFALSE 84665
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84453: LD_ADDR_VAR 0 9
84457: PUSH
84458: LD_VAR 0 8
84462: PPUSH
84463: LD_VAR 0 1
84467: PPUSH
84468: CALL_OW 265
84472: PPUSH
84473: LD_VAR 0 1
84477: PPUSH
84478: CALL_OW 262
84482: PPUSH
84483: LD_VAR 0 1
84487: PPUSH
84488: CALL_OW 263
84492: PPUSH
84493: LD_VAR 0 1
84497: PPUSH
84498: CALL_OW 264
84502: PPUSH
84503: CALL 17410 0 5
84507: ST_TO_ADDR
// if components then
84508: LD_VAR 0 9
84512: IFFALSE 84663
// begin if GetWeapon ( un ) = ar_control_tower then
84514: LD_VAR 0 1
84518: PPUSH
84519: CALL_OW 264
84523: PUSH
84524: LD_INT 31
84526: EQUAL
84527: IFFALSE 84644
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84529: LD_VAR 0 1
84533: PPUSH
84534: CALL_OW 311
84538: PPUSH
84539: LD_INT 0
84541: PPUSH
84542: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84546: LD_ADDR_EXP 101
84550: PUSH
84551: LD_EXP 101
84555: PPUSH
84556: LD_VAR 0 3
84560: PPUSH
84561: LD_EXP 101
84565: PUSH
84566: LD_VAR 0 3
84570: ARRAY
84571: PUSH
84572: LD_VAR 0 1
84576: PPUSH
84577: CALL_OW 311
84581: DIFF
84582: PPUSH
84583: CALL_OW 1
84587: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84588: LD_ADDR_VAR 0 7
84592: PUSH
84593: LD_EXP 82
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: PPUSH
84604: LD_INT 1
84606: PPUSH
84607: LD_VAR 0 9
84611: PPUSH
84612: CALL_OW 2
84616: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84617: LD_ADDR_EXP 82
84621: PUSH
84622: LD_EXP 82
84626: PPUSH
84627: LD_VAR 0 3
84631: PPUSH
84632: LD_VAR 0 7
84636: PPUSH
84637: CALL_OW 1
84641: ST_TO_ADDR
// end else
84642: GO 84661
// MC_InsertProduceList ( i , [ components ] ) ;
84644: LD_VAR 0 3
84648: PPUSH
84649: LD_VAR 0 9
84653: PUSH
84654: EMPTY
84655: LIST
84656: PPUSH
84657: CALL 80582 0 2
// break ;
84661: GO 84665
// end ; end ;
84663: GO 84450
84665: POP
84666: POP
// end ; end ; if GetType ( un ) = unit_building then
84667: LD_VAR 0 1
84671: PPUSH
84672: CALL_OW 247
84676: PUSH
84677: LD_INT 3
84679: EQUAL
84680: IFFALSE 85083
// begin btype := GetBType ( un ) ;
84682: LD_ADDR_VAR 0 5
84686: PUSH
84687: LD_VAR 0 1
84691: PPUSH
84692: CALL_OW 266
84696: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84697: LD_VAR 0 5
84701: PUSH
84702: LD_INT 29
84704: PUSH
84705: LD_INT 30
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: IN
84712: IFFALSE 84785
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84714: LD_VAR 0 1
84718: PPUSH
84719: CALL_OW 250
84723: PPUSH
84724: LD_VAR 0 1
84728: PPUSH
84729: CALL_OW 251
84733: PPUSH
84734: LD_VAR 0 1
84738: PPUSH
84739: CALL_OW 255
84743: PPUSH
84744: CALL_OW 440
84748: NOT
84749: IFFALSE 84785
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84751: LD_VAR 0 1
84755: PPUSH
84756: CALL_OW 250
84760: PPUSH
84761: LD_VAR 0 1
84765: PPUSH
84766: CALL_OW 251
84770: PPUSH
84771: LD_VAR 0 1
84775: PPUSH
84776: CALL_OW 255
84780: PPUSH
84781: CALL_OW 441
// end ; if btype = b_warehouse then
84785: LD_VAR 0 5
84789: PUSH
84790: LD_INT 1
84792: EQUAL
84793: IFFALSE 84811
// begin btype := b_depot ;
84795: LD_ADDR_VAR 0 5
84799: PUSH
84800: LD_INT 0
84802: ST_TO_ADDR
// pos := 1 ;
84803: LD_ADDR_VAR 0 6
84807: PUSH
84808: LD_INT 1
84810: ST_TO_ADDR
// end ; if btype = b_factory then
84811: LD_VAR 0 5
84815: PUSH
84816: LD_INT 3
84818: EQUAL
84819: IFFALSE 84837
// begin btype := b_workshop ;
84821: LD_ADDR_VAR 0 5
84825: PUSH
84826: LD_INT 2
84828: ST_TO_ADDR
// pos := 1 ;
84829: LD_ADDR_VAR 0 6
84833: PUSH
84834: LD_INT 1
84836: ST_TO_ADDR
// end ; if btype = b_barracks then
84837: LD_VAR 0 5
84841: PUSH
84842: LD_INT 5
84844: EQUAL
84845: IFFALSE 84855
// btype := b_armoury ;
84847: LD_ADDR_VAR 0 5
84851: PUSH
84852: LD_INT 4
84854: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84855: LD_VAR 0 5
84859: PUSH
84860: LD_INT 7
84862: PUSH
84863: LD_INT 8
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: IN
84870: IFFALSE 84880
// btype := b_lab ;
84872: LD_ADDR_VAR 0 5
84876: PUSH
84877: LD_INT 6
84879: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84880: LD_ADDR_EXP 66
84884: PUSH
84885: LD_EXP 66
84889: PPUSH
84890: LD_VAR 0 3
84894: PUSH
84895: LD_EXP 66
84899: PUSH
84900: LD_VAR 0 3
84904: ARRAY
84905: PUSH
84906: LD_INT 1
84908: PLUS
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PPUSH
84914: LD_VAR 0 5
84918: PUSH
84919: LD_VAR 0 1
84923: PPUSH
84924: CALL_OW 250
84928: PUSH
84929: LD_VAR 0 1
84933: PPUSH
84934: CALL_OW 251
84938: PUSH
84939: LD_VAR 0 1
84943: PPUSH
84944: CALL_OW 254
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: PPUSH
84955: CALL 19912 0 3
84959: ST_TO_ADDR
// if pos = 1 then
84960: LD_VAR 0 6
84964: PUSH
84965: LD_INT 1
84967: EQUAL
84968: IFFALSE 85083
// begin tmp := mc_build_list [ i ] ;
84970: LD_ADDR_VAR 0 7
84974: PUSH
84975: LD_EXP 66
84979: PUSH
84980: LD_VAR 0 3
84984: ARRAY
84985: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84986: LD_VAR 0 7
84990: PPUSH
84991: LD_INT 2
84993: PUSH
84994: LD_INT 30
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 30
85006: PUSH
85007: LD_INT 1
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: LIST
85018: PPUSH
85019: CALL_OW 72
85023: IFFALSE 85033
// pos := 2 ;
85025: LD_ADDR_VAR 0 6
85029: PUSH
85030: LD_INT 2
85032: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85033: LD_ADDR_VAR 0 7
85037: PUSH
85038: LD_VAR 0 7
85042: PPUSH
85043: LD_VAR 0 6
85047: PPUSH
85048: LD_VAR 0 7
85052: PPUSH
85053: CALL 20238 0 3
85057: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85058: LD_ADDR_EXP 66
85062: PUSH
85063: LD_EXP 66
85067: PPUSH
85068: LD_VAR 0 3
85072: PPUSH
85073: LD_VAR 0 7
85077: PPUSH
85078: CALL_OW 1
85082: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85083: LD_VAR 0 1
85087: PUSH
85088: LD_EXP 61
85092: PUSH
85093: LD_VAR 0 3
85097: ARRAY
85098: IN
85099: IFFALSE 85138
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85101: LD_ADDR_EXP 61
85105: PUSH
85106: LD_EXP 61
85110: PPUSH
85111: LD_VAR 0 3
85115: PPUSH
85116: LD_EXP 61
85120: PUSH
85121: LD_VAR 0 3
85125: ARRAY
85126: PUSH
85127: LD_VAR 0 1
85131: DIFF
85132: PPUSH
85133: CALL_OW 1
85137: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85138: LD_VAR 0 1
85142: PUSH
85143: LD_EXP 68
85147: PUSH
85148: LD_VAR 0 3
85152: ARRAY
85153: IN
85154: IFFALSE 85193
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85156: LD_ADDR_EXP 68
85160: PUSH
85161: LD_EXP 68
85165: PPUSH
85166: LD_VAR 0 3
85170: PPUSH
85171: LD_EXP 68
85175: PUSH
85176: LD_VAR 0 3
85180: ARRAY
85181: PUSH
85182: LD_VAR 0 1
85186: DIFF
85187: PPUSH
85188: CALL_OW 1
85192: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85193: LD_VAR 0 1
85197: PUSH
85198: LD_EXP 80
85202: PUSH
85203: LD_VAR 0 3
85207: ARRAY
85208: IN
85209: IFFALSE 85248
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85211: LD_ADDR_EXP 80
85215: PUSH
85216: LD_EXP 80
85220: PPUSH
85221: LD_VAR 0 3
85225: PPUSH
85226: LD_EXP 80
85230: PUSH
85231: LD_VAR 0 3
85235: ARRAY
85236: PUSH
85237: LD_VAR 0 1
85241: DIFF
85242: PPUSH
85243: CALL_OW 1
85247: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85248: LD_VAR 0 1
85252: PUSH
85253: LD_EXP 83
85257: PUSH
85258: LD_VAR 0 3
85262: ARRAY
85263: IN
85264: IFFALSE 85303
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85266: LD_ADDR_EXP 83
85270: PUSH
85271: LD_EXP 83
85275: PPUSH
85276: LD_VAR 0 3
85280: PPUSH
85281: LD_EXP 83
85285: PUSH
85286: LD_VAR 0 3
85290: ARRAY
85291: PUSH
85292: LD_VAR 0 1
85296: DIFF
85297: PPUSH
85298: CALL_OW 1
85302: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85303: LD_VAR 0 1
85307: PUSH
85308: LD_EXP 70
85312: PUSH
85313: LD_VAR 0 3
85317: ARRAY
85318: IN
85319: IFFALSE 85358
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85321: LD_ADDR_EXP 70
85325: PUSH
85326: LD_EXP 70
85330: PPUSH
85331: LD_VAR 0 3
85335: PPUSH
85336: LD_EXP 70
85340: PUSH
85341: LD_VAR 0 3
85345: ARRAY
85346: PUSH
85347: LD_VAR 0 1
85351: DIFF
85352: PPUSH
85353: CALL_OW 1
85357: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85358: LD_VAR 0 1
85362: PUSH
85363: LD_EXP 69
85367: PUSH
85368: LD_VAR 0 3
85372: ARRAY
85373: IN
85374: IFFALSE 85413
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85376: LD_ADDR_EXP 69
85380: PUSH
85381: LD_EXP 69
85385: PPUSH
85386: LD_VAR 0 3
85390: PPUSH
85391: LD_EXP 69
85395: PUSH
85396: LD_VAR 0 3
85400: ARRAY
85401: PUSH
85402: LD_VAR 0 1
85406: DIFF
85407: PPUSH
85408: CALL_OW 1
85412: ST_TO_ADDR
// end ; break ;
85413: GO 85417
// end ;
85415: GO 84065
85417: POP
85418: POP
// end ;
85419: LD_VAR 0 2
85423: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85424: LD_INT 0
85426: PPUSH
85427: PPUSH
85428: PPUSH
// if not mc_bases or not skirmish then
85429: LD_EXP 61
85433: NOT
85434: PUSH
85435: LD_EXP 59
85439: NOT
85440: OR
85441: IFFALSE 85445
// exit ;
85443: GO 85660
// for i = 1 to mc_bases do
85445: LD_ADDR_VAR 0 3
85449: PUSH
85450: DOUBLE
85451: LD_INT 1
85453: DEC
85454: ST_TO_ADDR
85455: LD_EXP 61
85459: PUSH
85460: FOR_TO
85461: IFFALSE 85658
// begin if building in mc_construct_list [ i ] then
85463: LD_VAR 0 1
85467: PUSH
85468: LD_EXP 68
85472: PUSH
85473: LD_VAR 0 3
85477: ARRAY
85478: IN
85479: IFFALSE 85656
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85481: LD_ADDR_EXP 68
85485: PUSH
85486: LD_EXP 68
85490: PPUSH
85491: LD_VAR 0 3
85495: PPUSH
85496: LD_EXP 68
85500: PUSH
85501: LD_VAR 0 3
85505: ARRAY
85506: PUSH
85507: LD_VAR 0 1
85511: DIFF
85512: PPUSH
85513: CALL_OW 1
85517: ST_TO_ADDR
// if building in mc_lab [ i ] then
85518: LD_VAR 0 1
85522: PUSH
85523: LD_EXP 94
85527: PUSH
85528: LD_VAR 0 3
85532: ARRAY
85533: IN
85534: IFFALSE 85589
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85536: LD_ADDR_EXP 95
85540: PUSH
85541: LD_EXP 95
85545: PPUSH
85546: LD_VAR 0 3
85550: PPUSH
85551: LD_EXP 95
85555: PUSH
85556: LD_VAR 0 3
85560: ARRAY
85561: PPUSH
85562: LD_INT 1
85564: PPUSH
85565: LD_EXP 95
85569: PUSH
85570: LD_VAR 0 3
85574: ARRAY
85575: PPUSH
85576: LD_INT 0
85578: PPUSH
85579: CALL 19330 0 4
85583: PPUSH
85584: CALL_OW 1
85588: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85589: LD_VAR 0 1
85593: PUSH
85594: LD_EXP 61
85598: PUSH
85599: LD_VAR 0 3
85603: ARRAY
85604: IN
85605: NOT
85606: IFFALSE 85652
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85608: LD_ADDR_EXP 61
85612: PUSH
85613: LD_EXP 61
85617: PPUSH
85618: LD_VAR 0 3
85622: PUSH
85623: LD_EXP 61
85627: PUSH
85628: LD_VAR 0 3
85632: ARRAY
85633: PUSH
85634: LD_INT 1
85636: PLUS
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PPUSH
85642: LD_VAR 0 1
85646: PPUSH
85647: CALL 19912 0 3
85651: ST_TO_ADDR
// exit ;
85652: POP
85653: POP
85654: GO 85660
// end ; end ;
85656: GO 85460
85658: POP
85659: POP
// end ;
85660: LD_VAR 0 2
85664: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85665: LD_INT 0
85667: PPUSH
85668: PPUSH
85669: PPUSH
85670: PPUSH
85671: PPUSH
85672: PPUSH
85673: PPUSH
// if not mc_bases or not skirmish then
85674: LD_EXP 61
85678: NOT
85679: PUSH
85680: LD_EXP 59
85684: NOT
85685: OR
85686: IFFALSE 85690
// exit ;
85688: GO 86351
// for i = 1 to mc_bases do
85690: LD_ADDR_VAR 0 3
85694: PUSH
85695: DOUBLE
85696: LD_INT 1
85698: DEC
85699: ST_TO_ADDR
85700: LD_EXP 61
85704: PUSH
85705: FOR_TO
85706: IFFALSE 86349
// begin if building in mc_construct_list [ i ] then
85708: LD_VAR 0 1
85712: PUSH
85713: LD_EXP 68
85717: PUSH
85718: LD_VAR 0 3
85722: ARRAY
85723: IN
85724: IFFALSE 86347
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85726: LD_ADDR_EXP 68
85730: PUSH
85731: LD_EXP 68
85735: PPUSH
85736: LD_VAR 0 3
85740: PPUSH
85741: LD_EXP 68
85745: PUSH
85746: LD_VAR 0 3
85750: ARRAY
85751: PUSH
85752: LD_VAR 0 1
85756: DIFF
85757: PPUSH
85758: CALL_OW 1
85762: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85763: LD_ADDR_EXP 61
85767: PUSH
85768: LD_EXP 61
85772: PPUSH
85773: LD_VAR 0 3
85777: PUSH
85778: LD_EXP 61
85782: PUSH
85783: LD_VAR 0 3
85787: ARRAY
85788: PUSH
85789: LD_INT 1
85791: PLUS
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PPUSH
85797: LD_VAR 0 1
85801: PPUSH
85802: CALL 19912 0 3
85806: ST_TO_ADDR
// btype := GetBType ( building ) ;
85807: LD_ADDR_VAR 0 5
85811: PUSH
85812: LD_VAR 0 1
85816: PPUSH
85817: CALL_OW 266
85821: ST_TO_ADDR
// side := GetSide ( building ) ;
85822: LD_ADDR_VAR 0 8
85826: PUSH
85827: LD_VAR 0 1
85831: PPUSH
85832: CALL_OW 255
85836: ST_TO_ADDR
// if btype = b_lab then
85837: LD_VAR 0 5
85841: PUSH
85842: LD_INT 6
85844: EQUAL
85845: IFFALSE 85895
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85847: LD_ADDR_EXP 94
85851: PUSH
85852: LD_EXP 94
85856: PPUSH
85857: LD_VAR 0 3
85861: PUSH
85862: LD_EXP 94
85866: PUSH
85867: LD_VAR 0 3
85871: ARRAY
85872: PUSH
85873: LD_INT 1
85875: PLUS
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PPUSH
85881: LD_VAR 0 1
85885: PPUSH
85886: CALL 19912 0 3
85890: ST_TO_ADDR
// exit ;
85891: POP
85892: POP
85893: GO 86351
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85895: LD_VAR 0 5
85899: PUSH
85900: LD_INT 0
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: LD_INT 4
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: LIST
85913: IN
85914: IFFALSE 86038
// begin if btype = b_armoury then
85916: LD_VAR 0 5
85920: PUSH
85921: LD_INT 4
85923: EQUAL
85924: IFFALSE 85934
// btype := b_barracks ;
85926: LD_ADDR_VAR 0 5
85930: PUSH
85931: LD_INT 5
85933: ST_TO_ADDR
// if btype = b_depot then
85934: LD_VAR 0 5
85938: PUSH
85939: LD_INT 0
85941: EQUAL
85942: IFFALSE 85952
// btype := b_warehouse ;
85944: LD_ADDR_VAR 0 5
85948: PUSH
85949: LD_INT 1
85951: ST_TO_ADDR
// if btype = b_workshop then
85952: LD_VAR 0 5
85956: PUSH
85957: LD_INT 2
85959: EQUAL
85960: IFFALSE 85970
// btype := b_factory ;
85962: LD_ADDR_VAR 0 5
85966: PUSH
85967: LD_INT 3
85969: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85970: LD_VAR 0 5
85974: PPUSH
85975: LD_VAR 0 8
85979: PPUSH
85980: CALL_OW 323
85984: PUSH
85985: LD_INT 1
85987: EQUAL
85988: IFFALSE 86034
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85990: LD_ADDR_EXP 93
85994: PUSH
85995: LD_EXP 93
85999: PPUSH
86000: LD_VAR 0 3
86004: PUSH
86005: LD_EXP 93
86009: PUSH
86010: LD_VAR 0 3
86014: ARRAY
86015: PUSH
86016: LD_INT 1
86018: PLUS
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PPUSH
86024: LD_VAR 0 1
86028: PPUSH
86029: CALL 19912 0 3
86033: ST_TO_ADDR
// exit ;
86034: POP
86035: POP
86036: GO 86351
// end ; if btype in [ b_bunker , b_turret ] then
86038: LD_VAR 0 5
86042: PUSH
86043: LD_INT 32
86045: PUSH
86046: LD_INT 33
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: IN
86053: IFFALSE 86343
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86055: LD_ADDR_EXP 69
86059: PUSH
86060: LD_EXP 69
86064: PPUSH
86065: LD_VAR 0 3
86069: PUSH
86070: LD_EXP 69
86074: PUSH
86075: LD_VAR 0 3
86079: ARRAY
86080: PUSH
86081: LD_INT 1
86083: PLUS
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PPUSH
86089: LD_VAR 0 1
86093: PPUSH
86094: CALL 19912 0 3
86098: ST_TO_ADDR
// if btype = b_bunker then
86099: LD_VAR 0 5
86103: PUSH
86104: LD_INT 32
86106: EQUAL
86107: IFFALSE 86343
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86109: LD_ADDR_EXP 70
86113: PUSH
86114: LD_EXP 70
86118: PPUSH
86119: LD_VAR 0 3
86123: PUSH
86124: LD_EXP 70
86128: PUSH
86129: LD_VAR 0 3
86133: ARRAY
86134: PUSH
86135: LD_INT 1
86137: PLUS
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PPUSH
86143: LD_VAR 0 1
86147: PPUSH
86148: CALL 19912 0 3
86152: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86153: LD_ADDR_VAR 0 6
86157: PUSH
86158: LD_EXP 61
86162: PUSH
86163: LD_VAR 0 3
86167: ARRAY
86168: PPUSH
86169: LD_INT 25
86171: PUSH
86172: LD_INT 1
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 3
86181: PUSH
86182: LD_INT 54
86184: PUSH
86185: EMPTY
86186: LIST
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PPUSH
86196: CALL_OW 72
86200: ST_TO_ADDR
// if tmp then
86201: LD_VAR 0 6
86205: IFFALSE 86211
// exit ;
86207: POP
86208: POP
86209: GO 86351
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86211: LD_ADDR_VAR 0 6
86215: PUSH
86216: LD_EXP 61
86220: PUSH
86221: LD_VAR 0 3
86225: ARRAY
86226: PPUSH
86227: LD_INT 2
86229: PUSH
86230: LD_INT 30
86232: PUSH
86233: LD_INT 4
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 30
86242: PUSH
86243: LD_INT 5
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: LIST
86254: PPUSH
86255: CALL_OW 72
86259: ST_TO_ADDR
// if not tmp then
86260: LD_VAR 0 6
86264: NOT
86265: IFFALSE 86271
// exit ;
86267: POP
86268: POP
86269: GO 86351
// for j in tmp do
86271: LD_ADDR_VAR 0 4
86275: PUSH
86276: LD_VAR 0 6
86280: PUSH
86281: FOR_IN
86282: IFFALSE 86341
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86284: LD_ADDR_VAR 0 7
86288: PUSH
86289: LD_VAR 0 4
86293: PPUSH
86294: CALL_OW 313
86298: PPUSH
86299: LD_INT 25
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PPUSH
86309: CALL_OW 72
86313: ST_TO_ADDR
// if units then
86314: LD_VAR 0 7
86318: IFFALSE 86339
// begin ComExitBuilding ( units [ 1 ] ) ;
86320: LD_VAR 0 7
86324: PUSH
86325: LD_INT 1
86327: ARRAY
86328: PPUSH
86329: CALL_OW 122
// exit ;
86333: POP
86334: POP
86335: POP
86336: POP
86337: GO 86351
// end ; end ;
86339: GO 86281
86341: POP
86342: POP
// end ; end ; exit ;
86343: POP
86344: POP
86345: GO 86351
// end ; end ;
86347: GO 85705
86349: POP
86350: POP
// end ;
86351: LD_VAR 0 2
86355: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86356: LD_INT 0
86358: PPUSH
86359: PPUSH
86360: PPUSH
86361: PPUSH
86362: PPUSH
86363: PPUSH
86364: PPUSH
// if not mc_bases or not skirmish then
86365: LD_EXP 61
86369: NOT
86370: PUSH
86371: LD_EXP 59
86375: NOT
86376: OR
86377: IFFALSE 86381
// exit ;
86379: GO 86646
// btype := GetBType ( building ) ;
86381: LD_ADDR_VAR 0 6
86385: PUSH
86386: LD_VAR 0 1
86390: PPUSH
86391: CALL_OW 266
86395: ST_TO_ADDR
// x := GetX ( building ) ;
86396: LD_ADDR_VAR 0 7
86400: PUSH
86401: LD_VAR 0 1
86405: PPUSH
86406: CALL_OW 250
86410: ST_TO_ADDR
// y := GetY ( building ) ;
86411: LD_ADDR_VAR 0 8
86415: PUSH
86416: LD_VAR 0 1
86420: PPUSH
86421: CALL_OW 251
86425: ST_TO_ADDR
// d := GetDir ( building ) ;
86426: LD_ADDR_VAR 0 9
86430: PUSH
86431: LD_VAR 0 1
86435: PPUSH
86436: CALL_OW 254
86440: ST_TO_ADDR
// for i = 1 to mc_bases do
86441: LD_ADDR_VAR 0 4
86445: PUSH
86446: DOUBLE
86447: LD_INT 1
86449: DEC
86450: ST_TO_ADDR
86451: LD_EXP 61
86455: PUSH
86456: FOR_TO
86457: IFFALSE 86644
// begin if not mc_build_list [ i ] then
86459: LD_EXP 66
86463: PUSH
86464: LD_VAR 0 4
86468: ARRAY
86469: NOT
86470: IFFALSE 86474
// continue ;
86472: GO 86456
// for j := 1 to mc_build_list [ i ] do
86474: LD_ADDR_VAR 0 5
86478: PUSH
86479: DOUBLE
86480: LD_INT 1
86482: DEC
86483: ST_TO_ADDR
86484: LD_EXP 66
86488: PUSH
86489: LD_VAR 0 4
86493: ARRAY
86494: PUSH
86495: FOR_TO
86496: IFFALSE 86640
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86498: LD_VAR 0 6
86502: PUSH
86503: LD_VAR 0 7
86507: PUSH
86508: LD_VAR 0 8
86512: PUSH
86513: LD_VAR 0 9
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: PPUSH
86524: LD_EXP 66
86528: PUSH
86529: LD_VAR 0 4
86533: ARRAY
86534: PUSH
86535: LD_VAR 0 5
86539: ARRAY
86540: PPUSH
86541: CALL 26092 0 2
86545: IFFALSE 86638
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86547: LD_ADDR_EXP 66
86551: PUSH
86552: LD_EXP 66
86556: PPUSH
86557: LD_VAR 0 4
86561: PPUSH
86562: LD_EXP 66
86566: PUSH
86567: LD_VAR 0 4
86571: ARRAY
86572: PPUSH
86573: LD_VAR 0 5
86577: PPUSH
86578: CALL_OW 3
86582: PPUSH
86583: CALL_OW 1
86587: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86588: LD_ADDR_EXP 68
86592: PUSH
86593: LD_EXP 68
86597: PPUSH
86598: LD_VAR 0 4
86602: PUSH
86603: LD_EXP 68
86607: PUSH
86608: LD_VAR 0 4
86612: ARRAY
86613: PUSH
86614: LD_INT 1
86616: PLUS
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PPUSH
86622: LD_VAR 0 1
86626: PPUSH
86627: CALL 19912 0 3
86631: ST_TO_ADDR
// exit ;
86632: POP
86633: POP
86634: POP
86635: POP
86636: GO 86646
// end ;
86638: GO 86495
86640: POP
86641: POP
// end ;
86642: GO 86456
86644: POP
86645: POP
// end ;
86646: LD_VAR 0 3
86650: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86651: LD_INT 0
86653: PPUSH
86654: PPUSH
86655: PPUSH
// if not mc_bases or not skirmish then
86656: LD_EXP 61
86660: NOT
86661: PUSH
86662: LD_EXP 59
86666: NOT
86667: OR
86668: IFFALSE 86672
// exit ;
86670: GO 86862
// for i = 1 to mc_bases do
86672: LD_ADDR_VAR 0 4
86676: PUSH
86677: DOUBLE
86678: LD_INT 1
86680: DEC
86681: ST_TO_ADDR
86682: LD_EXP 61
86686: PUSH
86687: FOR_TO
86688: IFFALSE 86775
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86690: LD_VAR 0 1
86694: PUSH
86695: LD_EXP 69
86699: PUSH
86700: LD_VAR 0 4
86704: ARRAY
86705: IN
86706: PUSH
86707: LD_VAR 0 1
86711: PUSH
86712: LD_EXP 70
86716: PUSH
86717: LD_VAR 0 4
86721: ARRAY
86722: IN
86723: NOT
86724: AND
86725: IFFALSE 86773
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86727: LD_ADDR_EXP 70
86731: PUSH
86732: LD_EXP 70
86736: PPUSH
86737: LD_VAR 0 4
86741: PUSH
86742: LD_EXP 70
86746: PUSH
86747: LD_VAR 0 4
86751: ARRAY
86752: PUSH
86753: LD_INT 1
86755: PLUS
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PPUSH
86761: LD_VAR 0 1
86765: PPUSH
86766: CALL 19912 0 3
86770: ST_TO_ADDR
// break ;
86771: GO 86775
// end ; end ;
86773: GO 86687
86775: POP
86776: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86777: LD_VAR 0 1
86781: PPUSH
86782: CALL_OW 257
86786: PUSH
86787: LD_EXP 87
86791: IN
86792: PUSH
86793: LD_VAR 0 1
86797: PPUSH
86798: CALL_OW 266
86802: PUSH
86803: LD_INT 5
86805: EQUAL
86806: AND
86807: PUSH
86808: LD_VAR 0 2
86812: PPUSH
86813: CALL_OW 110
86817: PUSH
86818: LD_INT 18
86820: NONEQUAL
86821: AND
86822: IFFALSE 86862
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86824: LD_VAR 0 2
86828: PPUSH
86829: CALL_OW 257
86833: PUSH
86834: LD_INT 5
86836: PUSH
86837: LD_INT 8
86839: PUSH
86840: LD_INT 9
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: LIST
86847: IN
86848: IFFALSE 86862
// SetClass ( unit , 1 ) ;
86850: LD_VAR 0 2
86854: PPUSH
86855: LD_INT 1
86857: PPUSH
86858: CALL_OW 336
// end ;
86862: LD_VAR 0 3
86866: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86867: LD_INT 0
86869: PPUSH
86870: PPUSH
// if not mc_bases or not skirmish then
86871: LD_EXP 61
86875: NOT
86876: PUSH
86877: LD_EXP 59
86881: NOT
86882: OR
86883: IFFALSE 86887
// exit ;
86885: GO 87003
// if GetLives ( abandoned_vehicle ) > 250 then
86887: LD_VAR 0 2
86891: PPUSH
86892: CALL_OW 256
86896: PUSH
86897: LD_INT 250
86899: GREATER
86900: IFFALSE 86904
// exit ;
86902: GO 87003
// for i = 1 to mc_bases do
86904: LD_ADDR_VAR 0 6
86908: PUSH
86909: DOUBLE
86910: LD_INT 1
86912: DEC
86913: ST_TO_ADDR
86914: LD_EXP 61
86918: PUSH
86919: FOR_TO
86920: IFFALSE 87001
// begin if driver in mc_bases [ i ] then
86922: LD_VAR 0 1
86926: PUSH
86927: LD_EXP 61
86931: PUSH
86932: LD_VAR 0 6
86936: ARRAY
86937: IN
86938: IFFALSE 86999
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86940: LD_VAR 0 1
86944: PPUSH
86945: LD_EXP 61
86949: PUSH
86950: LD_VAR 0 6
86954: ARRAY
86955: PPUSH
86956: LD_INT 2
86958: PUSH
86959: LD_INT 30
86961: PUSH
86962: LD_INT 0
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 30
86971: PUSH
86972: LD_INT 1
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: LIST
86983: PPUSH
86984: CALL_OW 72
86988: PUSH
86989: LD_INT 1
86991: ARRAY
86992: PPUSH
86993: CALL 53119 0 2
// break ;
86997: GO 87001
// end ; end ;
86999: GO 86919
87001: POP
87002: POP
// end ; end_of_file end_of_file
87003: LD_VAR 0 5
87007: RET
// export globalGameSaveCounter ; every 0 0$1 do
87008: GO 87010
87010: DISABLE
// begin enable ;
87011: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87012: LD_STRING updateTimer(
87014: PUSH
87015: LD_OWVAR 1
87019: STR
87020: PUSH
87021: LD_STRING );
87023: STR
87024: PPUSH
87025: CALL_OW 559
// end ;
87029: END
// every 0 0$1 do
87030: GO 87032
87032: DISABLE
// begin globalGameSaveCounter := 0 ;
87033: LD_ADDR_EXP 106
87037: PUSH
87038: LD_INT 0
87040: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
87041: LD_STRING setGameSaveCounter(0)
87043: PPUSH
87044: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
87048: LD_STRING initStreamRollete();
87050: PPUSH
87051: CALL_OW 559
// InitStreamMode ;
87055: CALL 88381 0 0
// DefineStreamItems ( false ) ;
87059: LD_INT 0
87061: PPUSH
87062: CALL 88845 0 1
// end ;
87066: END
// export function SOS_MapStart ( ) ; begin
87067: LD_INT 0
87069: PPUSH
// if streamModeActive then
87070: LD_EXP 107
87074: IFFALSE 87083
// DefineStreamItems ( true ) ;
87076: LD_INT 1
87078: PPUSH
87079: CALL 88845 0 1
// UpdateLuaVariables ( ) ;
87083: CALL 87100 0 0
// UpdateFactoryWaypoints ( ) ;
87087: CALL 101706 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87091: CALL 101963 0 0
// end ;
87095: LD_VAR 0 1
87099: RET
// function UpdateLuaVariables ( ) ; begin
87100: LD_INT 0
87102: PPUSH
// if globalGameSaveCounter then
87103: LD_EXP 106
87107: IFFALSE 87141
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87109: LD_ADDR_EXP 106
87113: PUSH
87114: LD_EXP 106
87118: PPUSH
87119: CALL 53603 0 1
87123: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87124: LD_STRING setGameSaveCounter(
87126: PUSH
87127: LD_EXP 106
87131: STR
87132: PUSH
87133: LD_STRING )
87135: STR
87136: PPUSH
87137: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87141: LD_STRING setGameDifficulty(
87143: PUSH
87144: LD_OWVAR 67
87148: STR
87149: PUSH
87150: LD_STRING )
87152: STR
87153: PPUSH
87154: CALL_OW 559
// end ;
87158: LD_VAR 0 1
87162: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87163: LD_INT 0
87165: PPUSH
// if p2 = stream_mode then
87166: LD_VAR 0 2
87170: PUSH
87171: LD_INT 100
87173: EQUAL
87174: IFFALSE 88177
// begin if not StreamModeActive then
87176: LD_EXP 107
87180: NOT
87181: IFFALSE 87191
// StreamModeActive := true ;
87183: LD_ADDR_EXP 107
87187: PUSH
87188: LD_INT 1
87190: ST_TO_ADDR
// if p3 = 0 then
87191: LD_VAR 0 3
87195: PUSH
87196: LD_INT 0
87198: EQUAL
87199: IFFALSE 87205
// InitStreamMode ;
87201: CALL 88381 0 0
// if p3 = 1 then
87205: LD_VAR 0 3
87209: PUSH
87210: LD_INT 1
87212: EQUAL
87213: IFFALSE 87223
// sRocket := true ;
87215: LD_ADDR_EXP 112
87219: PUSH
87220: LD_INT 1
87222: ST_TO_ADDR
// if p3 = 2 then
87223: LD_VAR 0 3
87227: PUSH
87228: LD_INT 2
87230: EQUAL
87231: IFFALSE 87241
// sSpeed := true ;
87233: LD_ADDR_EXP 111
87237: PUSH
87238: LD_INT 1
87240: ST_TO_ADDR
// if p3 = 3 then
87241: LD_VAR 0 3
87245: PUSH
87246: LD_INT 3
87248: EQUAL
87249: IFFALSE 87259
// sEngine := true ;
87251: LD_ADDR_EXP 113
87255: PUSH
87256: LD_INT 1
87258: ST_TO_ADDR
// if p3 = 4 then
87259: LD_VAR 0 3
87263: PUSH
87264: LD_INT 4
87266: EQUAL
87267: IFFALSE 87277
// sSpec := true ;
87269: LD_ADDR_EXP 110
87273: PUSH
87274: LD_INT 1
87276: ST_TO_ADDR
// if p3 = 5 then
87277: LD_VAR 0 3
87281: PUSH
87282: LD_INT 5
87284: EQUAL
87285: IFFALSE 87295
// sLevel := true ;
87287: LD_ADDR_EXP 114
87291: PUSH
87292: LD_INT 1
87294: ST_TO_ADDR
// if p3 = 6 then
87295: LD_VAR 0 3
87299: PUSH
87300: LD_INT 6
87302: EQUAL
87303: IFFALSE 87313
// sArmoury := true ;
87305: LD_ADDR_EXP 115
87309: PUSH
87310: LD_INT 1
87312: ST_TO_ADDR
// if p3 = 7 then
87313: LD_VAR 0 3
87317: PUSH
87318: LD_INT 7
87320: EQUAL
87321: IFFALSE 87331
// sRadar := true ;
87323: LD_ADDR_EXP 116
87327: PUSH
87328: LD_INT 1
87330: ST_TO_ADDR
// if p3 = 8 then
87331: LD_VAR 0 3
87335: PUSH
87336: LD_INT 8
87338: EQUAL
87339: IFFALSE 87349
// sBunker := true ;
87341: LD_ADDR_EXP 117
87345: PUSH
87346: LD_INT 1
87348: ST_TO_ADDR
// if p3 = 9 then
87349: LD_VAR 0 3
87353: PUSH
87354: LD_INT 9
87356: EQUAL
87357: IFFALSE 87367
// sHack := true ;
87359: LD_ADDR_EXP 118
87363: PUSH
87364: LD_INT 1
87366: ST_TO_ADDR
// if p3 = 10 then
87367: LD_VAR 0 3
87371: PUSH
87372: LD_INT 10
87374: EQUAL
87375: IFFALSE 87385
// sFire := true ;
87377: LD_ADDR_EXP 119
87381: PUSH
87382: LD_INT 1
87384: ST_TO_ADDR
// if p3 = 11 then
87385: LD_VAR 0 3
87389: PUSH
87390: LD_INT 11
87392: EQUAL
87393: IFFALSE 87403
// sRefresh := true ;
87395: LD_ADDR_EXP 120
87399: PUSH
87400: LD_INT 1
87402: ST_TO_ADDR
// if p3 = 12 then
87403: LD_VAR 0 3
87407: PUSH
87408: LD_INT 12
87410: EQUAL
87411: IFFALSE 87421
// sExp := true ;
87413: LD_ADDR_EXP 121
87417: PUSH
87418: LD_INT 1
87420: ST_TO_ADDR
// if p3 = 13 then
87421: LD_VAR 0 3
87425: PUSH
87426: LD_INT 13
87428: EQUAL
87429: IFFALSE 87439
// sDepot := true ;
87431: LD_ADDR_EXP 122
87435: PUSH
87436: LD_INT 1
87438: ST_TO_ADDR
// if p3 = 14 then
87439: LD_VAR 0 3
87443: PUSH
87444: LD_INT 14
87446: EQUAL
87447: IFFALSE 87457
// sFlag := true ;
87449: LD_ADDR_EXP 123
87453: PUSH
87454: LD_INT 1
87456: ST_TO_ADDR
// if p3 = 15 then
87457: LD_VAR 0 3
87461: PUSH
87462: LD_INT 15
87464: EQUAL
87465: IFFALSE 87475
// sKamikadze := true ;
87467: LD_ADDR_EXP 131
87471: PUSH
87472: LD_INT 1
87474: ST_TO_ADDR
// if p3 = 16 then
87475: LD_VAR 0 3
87479: PUSH
87480: LD_INT 16
87482: EQUAL
87483: IFFALSE 87493
// sTroll := true ;
87485: LD_ADDR_EXP 132
87489: PUSH
87490: LD_INT 1
87492: ST_TO_ADDR
// if p3 = 17 then
87493: LD_VAR 0 3
87497: PUSH
87498: LD_INT 17
87500: EQUAL
87501: IFFALSE 87511
// sSlow := true ;
87503: LD_ADDR_EXP 133
87507: PUSH
87508: LD_INT 1
87510: ST_TO_ADDR
// if p3 = 18 then
87511: LD_VAR 0 3
87515: PUSH
87516: LD_INT 18
87518: EQUAL
87519: IFFALSE 87529
// sLack := true ;
87521: LD_ADDR_EXP 134
87525: PUSH
87526: LD_INT 1
87528: ST_TO_ADDR
// if p3 = 19 then
87529: LD_VAR 0 3
87533: PUSH
87534: LD_INT 19
87536: EQUAL
87537: IFFALSE 87547
// sTank := true ;
87539: LD_ADDR_EXP 136
87543: PUSH
87544: LD_INT 1
87546: ST_TO_ADDR
// if p3 = 20 then
87547: LD_VAR 0 3
87551: PUSH
87552: LD_INT 20
87554: EQUAL
87555: IFFALSE 87565
// sRemote := true ;
87557: LD_ADDR_EXP 137
87561: PUSH
87562: LD_INT 1
87564: ST_TO_ADDR
// if p3 = 21 then
87565: LD_VAR 0 3
87569: PUSH
87570: LD_INT 21
87572: EQUAL
87573: IFFALSE 87583
// sPowell := true ;
87575: LD_ADDR_EXP 138
87579: PUSH
87580: LD_INT 1
87582: ST_TO_ADDR
// if p3 = 22 then
87583: LD_VAR 0 3
87587: PUSH
87588: LD_INT 22
87590: EQUAL
87591: IFFALSE 87601
// sTeleport := true ;
87593: LD_ADDR_EXP 141
87597: PUSH
87598: LD_INT 1
87600: ST_TO_ADDR
// if p3 = 23 then
87601: LD_VAR 0 3
87605: PUSH
87606: LD_INT 23
87608: EQUAL
87609: IFFALSE 87619
// sOilTower := true ;
87611: LD_ADDR_EXP 143
87615: PUSH
87616: LD_INT 1
87618: ST_TO_ADDR
// if p3 = 24 then
87619: LD_VAR 0 3
87623: PUSH
87624: LD_INT 24
87626: EQUAL
87627: IFFALSE 87637
// sShovel := true ;
87629: LD_ADDR_EXP 144
87633: PUSH
87634: LD_INT 1
87636: ST_TO_ADDR
// if p3 = 25 then
87637: LD_VAR 0 3
87641: PUSH
87642: LD_INT 25
87644: EQUAL
87645: IFFALSE 87655
// sSheik := true ;
87647: LD_ADDR_EXP 145
87651: PUSH
87652: LD_INT 1
87654: ST_TO_ADDR
// if p3 = 26 then
87655: LD_VAR 0 3
87659: PUSH
87660: LD_INT 26
87662: EQUAL
87663: IFFALSE 87673
// sEarthquake := true ;
87665: LD_ADDR_EXP 147
87669: PUSH
87670: LD_INT 1
87672: ST_TO_ADDR
// if p3 = 27 then
87673: LD_VAR 0 3
87677: PUSH
87678: LD_INT 27
87680: EQUAL
87681: IFFALSE 87691
// sAI := true ;
87683: LD_ADDR_EXP 148
87687: PUSH
87688: LD_INT 1
87690: ST_TO_ADDR
// if p3 = 28 then
87691: LD_VAR 0 3
87695: PUSH
87696: LD_INT 28
87698: EQUAL
87699: IFFALSE 87709
// sCargo := true ;
87701: LD_ADDR_EXP 151
87705: PUSH
87706: LD_INT 1
87708: ST_TO_ADDR
// if p3 = 29 then
87709: LD_VAR 0 3
87713: PUSH
87714: LD_INT 29
87716: EQUAL
87717: IFFALSE 87727
// sDLaser := true ;
87719: LD_ADDR_EXP 152
87723: PUSH
87724: LD_INT 1
87726: ST_TO_ADDR
// if p3 = 30 then
87727: LD_VAR 0 3
87731: PUSH
87732: LD_INT 30
87734: EQUAL
87735: IFFALSE 87745
// sExchange := true ;
87737: LD_ADDR_EXP 153
87741: PUSH
87742: LD_INT 1
87744: ST_TO_ADDR
// if p3 = 31 then
87745: LD_VAR 0 3
87749: PUSH
87750: LD_INT 31
87752: EQUAL
87753: IFFALSE 87763
// sFac := true ;
87755: LD_ADDR_EXP 154
87759: PUSH
87760: LD_INT 1
87762: ST_TO_ADDR
// if p3 = 32 then
87763: LD_VAR 0 3
87767: PUSH
87768: LD_INT 32
87770: EQUAL
87771: IFFALSE 87781
// sPower := true ;
87773: LD_ADDR_EXP 155
87777: PUSH
87778: LD_INT 1
87780: ST_TO_ADDR
// if p3 = 33 then
87781: LD_VAR 0 3
87785: PUSH
87786: LD_INT 33
87788: EQUAL
87789: IFFALSE 87799
// sRandom := true ;
87791: LD_ADDR_EXP 156
87795: PUSH
87796: LD_INT 1
87798: ST_TO_ADDR
// if p3 = 34 then
87799: LD_VAR 0 3
87803: PUSH
87804: LD_INT 34
87806: EQUAL
87807: IFFALSE 87817
// sShield := true ;
87809: LD_ADDR_EXP 157
87813: PUSH
87814: LD_INT 1
87816: ST_TO_ADDR
// if p3 = 35 then
87817: LD_VAR 0 3
87821: PUSH
87822: LD_INT 35
87824: EQUAL
87825: IFFALSE 87835
// sTime := true ;
87827: LD_ADDR_EXP 158
87831: PUSH
87832: LD_INT 1
87834: ST_TO_ADDR
// if p3 = 36 then
87835: LD_VAR 0 3
87839: PUSH
87840: LD_INT 36
87842: EQUAL
87843: IFFALSE 87853
// sTools := true ;
87845: LD_ADDR_EXP 159
87849: PUSH
87850: LD_INT 1
87852: ST_TO_ADDR
// if p3 = 101 then
87853: LD_VAR 0 3
87857: PUSH
87858: LD_INT 101
87860: EQUAL
87861: IFFALSE 87871
// sSold := true ;
87863: LD_ADDR_EXP 124
87867: PUSH
87868: LD_INT 1
87870: ST_TO_ADDR
// if p3 = 102 then
87871: LD_VAR 0 3
87875: PUSH
87876: LD_INT 102
87878: EQUAL
87879: IFFALSE 87889
// sDiff := true ;
87881: LD_ADDR_EXP 125
87885: PUSH
87886: LD_INT 1
87888: ST_TO_ADDR
// if p3 = 103 then
87889: LD_VAR 0 3
87893: PUSH
87894: LD_INT 103
87896: EQUAL
87897: IFFALSE 87907
// sFog := true ;
87899: LD_ADDR_EXP 128
87903: PUSH
87904: LD_INT 1
87906: ST_TO_ADDR
// if p3 = 104 then
87907: LD_VAR 0 3
87911: PUSH
87912: LD_INT 104
87914: EQUAL
87915: IFFALSE 87925
// sReset := true ;
87917: LD_ADDR_EXP 129
87921: PUSH
87922: LD_INT 1
87924: ST_TO_ADDR
// if p3 = 105 then
87925: LD_VAR 0 3
87929: PUSH
87930: LD_INT 105
87932: EQUAL
87933: IFFALSE 87943
// sSun := true ;
87935: LD_ADDR_EXP 130
87939: PUSH
87940: LD_INT 1
87942: ST_TO_ADDR
// if p3 = 106 then
87943: LD_VAR 0 3
87947: PUSH
87948: LD_INT 106
87950: EQUAL
87951: IFFALSE 87961
// sTiger := true ;
87953: LD_ADDR_EXP 126
87957: PUSH
87958: LD_INT 1
87960: ST_TO_ADDR
// if p3 = 107 then
87961: LD_VAR 0 3
87965: PUSH
87966: LD_INT 107
87968: EQUAL
87969: IFFALSE 87979
// sBomb := true ;
87971: LD_ADDR_EXP 127
87975: PUSH
87976: LD_INT 1
87978: ST_TO_ADDR
// if p3 = 108 then
87979: LD_VAR 0 3
87983: PUSH
87984: LD_INT 108
87986: EQUAL
87987: IFFALSE 87997
// sWound := true ;
87989: LD_ADDR_EXP 135
87993: PUSH
87994: LD_INT 1
87996: ST_TO_ADDR
// if p3 = 109 then
87997: LD_VAR 0 3
88001: PUSH
88002: LD_INT 109
88004: EQUAL
88005: IFFALSE 88015
// sBetray := true ;
88007: LD_ADDR_EXP 139
88011: PUSH
88012: LD_INT 1
88014: ST_TO_ADDR
// if p3 = 110 then
88015: LD_VAR 0 3
88019: PUSH
88020: LD_INT 110
88022: EQUAL
88023: IFFALSE 88033
// sContamin := true ;
88025: LD_ADDR_EXP 140
88029: PUSH
88030: LD_INT 1
88032: ST_TO_ADDR
// if p3 = 111 then
88033: LD_VAR 0 3
88037: PUSH
88038: LD_INT 111
88040: EQUAL
88041: IFFALSE 88051
// sOil := true ;
88043: LD_ADDR_EXP 142
88047: PUSH
88048: LD_INT 1
88050: ST_TO_ADDR
// if p3 = 112 then
88051: LD_VAR 0 3
88055: PUSH
88056: LD_INT 112
88058: EQUAL
88059: IFFALSE 88069
// sStu := true ;
88061: LD_ADDR_EXP 146
88065: PUSH
88066: LD_INT 1
88068: ST_TO_ADDR
// if p3 = 113 then
88069: LD_VAR 0 3
88073: PUSH
88074: LD_INT 113
88076: EQUAL
88077: IFFALSE 88087
// sBazooka := true ;
88079: LD_ADDR_EXP 149
88083: PUSH
88084: LD_INT 1
88086: ST_TO_ADDR
// if p3 = 114 then
88087: LD_VAR 0 3
88091: PUSH
88092: LD_INT 114
88094: EQUAL
88095: IFFALSE 88105
// sMortar := true ;
88097: LD_ADDR_EXP 150
88101: PUSH
88102: LD_INT 1
88104: ST_TO_ADDR
// if p3 = 115 then
88105: LD_VAR 0 3
88109: PUSH
88110: LD_INT 115
88112: EQUAL
88113: IFFALSE 88123
// sRanger := true ;
88115: LD_ADDR_EXP 160
88119: PUSH
88120: LD_INT 1
88122: ST_TO_ADDR
// if p3 = 116 then
88123: LD_VAR 0 3
88127: PUSH
88128: LD_INT 116
88130: EQUAL
88131: IFFALSE 88141
// sComputer := true ;
88133: LD_ADDR_EXP 161
88137: PUSH
88138: LD_INT 1
88140: ST_TO_ADDR
// if p3 = 117 then
88141: LD_VAR 0 3
88145: PUSH
88146: LD_INT 117
88148: EQUAL
88149: IFFALSE 88159
// s30 := true ;
88151: LD_ADDR_EXP 162
88155: PUSH
88156: LD_INT 1
88158: ST_TO_ADDR
// if p3 = 118 then
88159: LD_VAR 0 3
88163: PUSH
88164: LD_INT 118
88166: EQUAL
88167: IFFALSE 88177
// s60 := true ;
88169: LD_ADDR_EXP 163
88173: PUSH
88174: LD_INT 1
88176: ST_TO_ADDR
// end ; if p2 = hack_mode then
88177: LD_VAR 0 2
88181: PUSH
88182: LD_INT 101
88184: EQUAL
88185: IFFALSE 88313
// begin case p3 of 1 :
88187: LD_VAR 0 3
88191: PUSH
88192: LD_INT 1
88194: DOUBLE
88195: EQUAL
88196: IFTRUE 88200
88198: GO 88207
88200: POP
// hHackUnlimitedResources ; 2 :
88201: CALL 100452 0 0
88205: GO 88313
88207: LD_INT 2
88209: DOUBLE
88210: EQUAL
88211: IFTRUE 88215
88213: GO 88222
88215: POP
// hHackSetLevel10 ; 3 :
88216: CALL 100585 0 0
88220: GO 88313
88222: LD_INT 3
88224: DOUBLE
88225: EQUAL
88226: IFTRUE 88230
88228: GO 88237
88230: POP
// hHackSetLevel10YourUnits ; 4 :
88231: CALL 100670 0 0
88235: GO 88313
88237: LD_INT 4
88239: DOUBLE
88240: EQUAL
88241: IFTRUE 88245
88243: GO 88252
88245: POP
// hHackInvincible ; 5 :
88246: CALL 101118 0 0
88250: GO 88313
88252: LD_INT 5
88254: DOUBLE
88255: EQUAL
88256: IFTRUE 88260
88258: GO 88267
88260: POP
// hHackInvisible ; 6 :
88261: CALL 101229 0 0
88265: GO 88313
88267: LD_INT 6
88269: DOUBLE
88270: EQUAL
88271: IFTRUE 88275
88273: GO 88282
88275: POP
// hHackChangeYourSide ; 7 :
88276: CALL 101286 0 0
88280: GO 88313
88282: LD_INT 7
88284: DOUBLE
88285: EQUAL
88286: IFTRUE 88290
88288: GO 88297
88290: POP
// hHackChangeUnitSide ; 8 :
88291: CALL 101328 0 0
88295: GO 88313
88297: LD_INT 8
88299: DOUBLE
88300: EQUAL
88301: IFTRUE 88305
88303: GO 88312
88305: POP
// hHackFog ; end ;
88306: CALL 101429 0 0
88310: GO 88313
88312: POP
// end ; if p2 = game_save_mode then
88313: LD_VAR 0 2
88317: PUSH
88318: LD_INT 102
88320: EQUAL
88321: IFFALSE 88376
// begin if p3 = 1 then
88323: LD_VAR 0 3
88327: PUSH
88328: LD_INT 1
88330: EQUAL
88331: IFFALSE 88343
// globalGameSaveCounter := p4 ;
88333: LD_ADDR_EXP 106
88337: PUSH
88338: LD_VAR 0 4
88342: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
88343: LD_VAR 0 3
88347: PUSH
88348: LD_INT 2
88350: EQUAL
88351: PUSH
88352: LD_EXP 106
88356: AND
88357: IFFALSE 88376
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
88359: LD_STRING setGameSaveCounter(
88361: PUSH
88362: LD_EXP 106
88366: STR
88367: PUSH
88368: LD_STRING )
88370: STR
88371: PPUSH
88372: CALL_OW 559
// end ; end ;
88376: LD_VAR 0 7
88380: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
88381: LD_INT 0
88383: PPUSH
// streamModeActive := false ;
88384: LD_ADDR_EXP 107
88388: PUSH
88389: LD_INT 0
88391: ST_TO_ADDR
// normalCounter := 36 ;
88392: LD_ADDR_EXP 108
88396: PUSH
88397: LD_INT 36
88399: ST_TO_ADDR
// hardcoreCounter := 18 ;
88400: LD_ADDR_EXP 109
88404: PUSH
88405: LD_INT 18
88407: ST_TO_ADDR
// sRocket := false ;
88408: LD_ADDR_EXP 112
88412: PUSH
88413: LD_INT 0
88415: ST_TO_ADDR
// sSpeed := false ;
88416: LD_ADDR_EXP 111
88420: PUSH
88421: LD_INT 0
88423: ST_TO_ADDR
// sEngine := false ;
88424: LD_ADDR_EXP 113
88428: PUSH
88429: LD_INT 0
88431: ST_TO_ADDR
// sSpec := false ;
88432: LD_ADDR_EXP 110
88436: PUSH
88437: LD_INT 0
88439: ST_TO_ADDR
// sLevel := false ;
88440: LD_ADDR_EXP 114
88444: PUSH
88445: LD_INT 0
88447: ST_TO_ADDR
// sArmoury := false ;
88448: LD_ADDR_EXP 115
88452: PUSH
88453: LD_INT 0
88455: ST_TO_ADDR
// sRadar := false ;
88456: LD_ADDR_EXP 116
88460: PUSH
88461: LD_INT 0
88463: ST_TO_ADDR
// sBunker := false ;
88464: LD_ADDR_EXP 117
88468: PUSH
88469: LD_INT 0
88471: ST_TO_ADDR
// sHack := false ;
88472: LD_ADDR_EXP 118
88476: PUSH
88477: LD_INT 0
88479: ST_TO_ADDR
// sFire := false ;
88480: LD_ADDR_EXP 119
88484: PUSH
88485: LD_INT 0
88487: ST_TO_ADDR
// sRefresh := false ;
88488: LD_ADDR_EXP 120
88492: PUSH
88493: LD_INT 0
88495: ST_TO_ADDR
// sExp := false ;
88496: LD_ADDR_EXP 121
88500: PUSH
88501: LD_INT 0
88503: ST_TO_ADDR
// sDepot := false ;
88504: LD_ADDR_EXP 122
88508: PUSH
88509: LD_INT 0
88511: ST_TO_ADDR
// sFlag := false ;
88512: LD_ADDR_EXP 123
88516: PUSH
88517: LD_INT 0
88519: ST_TO_ADDR
// sKamikadze := false ;
88520: LD_ADDR_EXP 131
88524: PUSH
88525: LD_INT 0
88527: ST_TO_ADDR
// sTroll := false ;
88528: LD_ADDR_EXP 132
88532: PUSH
88533: LD_INT 0
88535: ST_TO_ADDR
// sSlow := false ;
88536: LD_ADDR_EXP 133
88540: PUSH
88541: LD_INT 0
88543: ST_TO_ADDR
// sLack := false ;
88544: LD_ADDR_EXP 134
88548: PUSH
88549: LD_INT 0
88551: ST_TO_ADDR
// sTank := false ;
88552: LD_ADDR_EXP 136
88556: PUSH
88557: LD_INT 0
88559: ST_TO_ADDR
// sRemote := false ;
88560: LD_ADDR_EXP 137
88564: PUSH
88565: LD_INT 0
88567: ST_TO_ADDR
// sPowell := false ;
88568: LD_ADDR_EXP 138
88572: PUSH
88573: LD_INT 0
88575: ST_TO_ADDR
// sTeleport := false ;
88576: LD_ADDR_EXP 141
88580: PUSH
88581: LD_INT 0
88583: ST_TO_ADDR
// sOilTower := false ;
88584: LD_ADDR_EXP 143
88588: PUSH
88589: LD_INT 0
88591: ST_TO_ADDR
// sShovel := false ;
88592: LD_ADDR_EXP 144
88596: PUSH
88597: LD_INT 0
88599: ST_TO_ADDR
// sSheik := false ;
88600: LD_ADDR_EXP 145
88604: PUSH
88605: LD_INT 0
88607: ST_TO_ADDR
// sEarthquake := false ;
88608: LD_ADDR_EXP 147
88612: PUSH
88613: LD_INT 0
88615: ST_TO_ADDR
// sAI := false ;
88616: LD_ADDR_EXP 148
88620: PUSH
88621: LD_INT 0
88623: ST_TO_ADDR
// sCargo := false ;
88624: LD_ADDR_EXP 151
88628: PUSH
88629: LD_INT 0
88631: ST_TO_ADDR
// sDLaser := false ;
88632: LD_ADDR_EXP 152
88636: PUSH
88637: LD_INT 0
88639: ST_TO_ADDR
// sExchange := false ;
88640: LD_ADDR_EXP 153
88644: PUSH
88645: LD_INT 0
88647: ST_TO_ADDR
// sFac := false ;
88648: LD_ADDR_EXP 154
88652: PUSH
88653: LD_INT 0
88655: ST_TO_ADDR
// sPower := false ;
88656: LD_ADDR_EXP 155
88660: PUSH
88661: LD_INT 0
88663: ST_TO_ADDR
// sRandom := false ;
88664: LD_ADDR_EXP 156
88668: PUSH
88669: LD_INT 0
88671: ST_TO_ADDR
// sShield := false ;
88672: LD_ADDR_EXP 157
88676: PUSH
88677: LD_INT 0
88679: ST_TO_ADDR
// sTime := false ;
88680: LD_ADDR_EXP 158
88684: PUSH
88685: LD_INT 0
88687: ST_TO_ADDR
// sTools := false ;
88688: LD_ADDR_EXP 159
88692: PUSH
88693: LD_INT 0
88695: ST_TO_ADDR
// sSold := false ;
88696: LD_ADDR_EXP 124
88700: PUSH
88701: LD_INT 0
88703: ST_TO_ADDR
// sDiff := false ;
88704: LD_ADDR_EXP 125
88708: PUSH
88709: LD_INT 0
88711: ST_TO_ADDR
// sFog := false ;
88712: LD_ADDR_EXP 128
88716: PUSH
88717: LD_INT 0
88719: ST_TO_ADDR
// sReset := false ;
88720: LD_ADDR_EXP 129
88724: PUSH
88725: LD_INT 0
88727: ST_TO_ADDR
// sSun := false ;
88728: LD_ADDR_EXP 130
88732: PUSH
88733: LD_INT 0
88735: ST_TO_ADDR
// sTiger := false ;
88736: LD_ADDR_EXP 126
88740: PUSH
88741: LD_INT 0
88743: ST_TO_ADDR
// sBomb := false ;
88744: LD_ADDR_EXP 127
88748: PUSH
88749: LD_INT 0
88751: ST_TO_ADDR
// sWound := false ;
88752: LD_ADDR_EXP 135
88756: PUSH
88757: LD_INT 0
88759: ST_TO_ADDR
// sBetray := false ;
88760: LD_ADDR_EXP 139
88764: PUSH
88765: LD_INT 0
88767: ST_TO_ADDR
// sContamin := false ;
88768: LD_ADDR_EXP 140
88772: PUSH
88773: LD_INT 0
88775: ST_TO_ADDR
// sOil := false ;
88776: LD_ADDR_EXP 142
88780: PUSH
88781: LD_INT 0
88783: ST_TO_ADDR
// sStu := false ;
88784: LD_ADDR_EXP 146
88788: PUSH
88789: LD_INT 0
88791: ST_TO_ADDR
// sBazooka := false ;
88792: LD_ADDR_EXP 149
88796: PUSH
88797: LD_INT 0
88799: ST_TO_ADDR
// sMortar := false ;
88800: LD_ADDR_EXP 150
88804: PUSH
88805: LD_INT 0
88807: ST_TO_ADDR
// sRanger := false ;
88808: LD_ADDR_EXP 160
88812: PUSH
88813: LD_INT 0
88815: ST_TO_ADDR
// sComputer := false ;
88816: LD_ADDR_EXP 161
88820: PUSH
88821: LD_INT 0
88823: ST_TO_ADDR
// s30 := false ;
88824: LD_ADDR_EXP 162
88828: PUSH
88829: LD_INT 0
88831: ST_TO_ADDR
// s60 := false ;
88832: LD_ADDR_EXP 163
88836: PUSH
88837: LD_INT 0
88839: ST_TO_ADDR
// end ;
88840: LD_VAR 0 1
88844: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88845: LD_INT 0
88847: PPUSH
88848: PPUSH
88849: PPUSH
88850: PPUSH
88851: PPUSH
88852: PPUSH
88853: PPUSH
// result := [ ] ;
88854: LD_ADDR_VAR 0 2
88858: PUSH
88859: EMPTY
88860: ST_TO_ADDR
// if campaign_id = 1 then
88861: LD_OWVAR 69
88865: PUSH
88866: LD_INT 1
88868: EQUAL
88869: IFFALSE 92035
// begin case mission_number of 1 :
88871: LD_OWVAR 70
88875: PUSH
88876: LD_INT 1
88878: DOUBLE
88879: EQUAL
88880: IFTRUE 88884
88882: GO 88960
88884: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88885: LD_ADDR_VAR 0 2
88889: PUSH
88890: LD_INT 2
88892: PUSH
88893: LD_INT 4
88895: PUSH
88896: LD_INT 11
88898: PUSH
88899: LD_INT 12
88901: PUSH
88902: LD_INT 15
88904: PUSH
88905: LD_INT 16
88907: PUSH
88908: LD_INT 22
88910: PUSH
88911: LD_INT 23
88913: PUSH
88914: LD_INT 26
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 101
88930: PUSH
88931: LD_INT 102
88933: PUSH
88934: LD_INT 106
88936: PUSH
88937: LD_INT 116
88939: PUSH
88940: LD_INT 117
88942: PUSH
88943: LD_INT 118
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: ST_TO_ADDR
88958: GO 92033
88960: LD_INT 2
88962: DOUBLE
88963: EQUAL
88964: IFTRUE 88968
88966: GO 89052
88968: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88969: LD_ADDR_VAR 0 2
88973: PUSH
88974: LD_INT 2
88976: PUSH
88977: LD_INT 4
88979: PUSH
88980: LD_INT 11
88982: PUSH
88983: LD_INT 12
88985: PUSH
88986: LD_INT 15
88988: PUSH
88989: LD_INT 16
88991: PUSH
88992: LD_INT 22
88994: PUSH
88995: LD_INT 23
88997: PUSH
88998: LD_INT 26
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 101
89014: PUSH
89015: LD_INT 102
89017: PUSH
89018: LD_INT 105
89020: PUSH
89021: LD_INT 106
89023: PUSH
89024: LD_INT 108
89026: PUSH
89027: LD_INT 116
89029: PUSH
89030: LD_INT 117
89032: PUSH
89033: LD_INT 118
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: ST_TO_ADDR
89050: GO 92033
89052: LD_INT 3
89054: DOUBLE
89055: EQUAL
89056: IFTRUE 89060
89058: GO 89148
89060: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89061: LD_ADDR_VAR 0 2
89065: PUSH
89066: LD_INT 2
89068: PUSH
89069: LD_INT 4
89071: PUSH
89072: LD_INT 5
89074: PUSH
89075: LD_INT 11
89077: PUSH
89078: LD_INT 12
89080: PUSH
89081: LD_INT 15
89083: PUSH
89084: LD_INT 16
89086: PUSH
89087: LD_INT 22
89089: PUSH
89090: LD_INT 26
89092: PUSH
89093: LD_INT 36
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 101
89110: PUSH
89111: LD_INT 102
89113: PUSH
89114: LD_INT 105
89116: PUSH
89117: LD_INT 106
89119: PUSH
89120: LD_INT 108
89122: PUSH
89123: LD_INT 116
89125: PUSH
89126: LD_INT 117
89128: PUSH
89129: LD_INT 118
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: ST_TO_ADDR
89146: GO 92033
89148: LD_INT 4
89150: DOUBLE
89151: EQUAL
89152: IFTRUE 89156
89154: GO 89252
89156: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89157: LD_ADDR_VAR 0 2
89161: PUSH
89162: LD_INT 2
89164: PUSH
89165: LD_INT 4
89167: PUSH
89168: LD_INT 5
89170: PUSH
89171: LD_INT 8
89173: PUSH
89174: LD_INT 11
89176: PUSH
89177: LD_INT 12
89179: PUSH
89180: LD_INT 15
89182: PUSH
89183: LD_INT 16
89185: PUSH
89186: LD_INT 22
89188: PUSH
89189: LD_INT 23
89191: PUSH
89192: LD_INT 26
89194: PUSH
89195: LD_INT 36
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 101
89214: PUSH
89215: LD_INT 102
89217: PUSH
89218: LD_INT 105
89220: PUSH
89221: LD_INT 106
89223: PUSH
89224: LD_INT 108
89226: PUSH
89227: LD_INT 116
89229: PUSH
89230: LD_INT 117
89232: PUSH
89233: LD_INT 118
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: ST_TO_ADDR
89250: GO 92033
89252: LD_INT 5
89254: DOUBLE
89255: EQUAL
89256: IFTRUE 89260
89258: GO 89372
89260: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89261: LD_ADDR_VAR 0 2
89265: PUSH
89266: LD_INT 2
89268: PUSH
89269: LD_INT 4
89271: PUSH
89272: LD_INT 5
89274: PUSH
89275: LD_INT 6
89277: PUSH
89278: LD_INT 8
89280: PUSH
89281: LD_INT 11
89283: PUSH
89284: LD_INT 12
89286: PUSH
89287: LD_INT 15
89289: PUSH
89290: LD_INT 16
89292: PUSH
89293: LD_INT 22
89295: PUSH
89296: LD_INT 23
89298: PUSH
89299: LD_INT 25
89301: PUSH
89302: LD_INT 26
89304: PUSH
89305: LD_INT 36
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 101
89326: PUSH
89327: LD_INT 102
89329: PUSH
89330: LD_INT 105
89332: PUSH
89333: LD_INT 106
89335: PUSH
89336: LD_INT 108
89338: PUSH
89339: LD_INT 109
89341: PUSH
89342: LD_INT 112
89344: PUSH
89345: LD_INT 116
89347: PUSH
89348: LD_INT 117
89350: PUSH
89351: LD_INT 118
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: ST_TO_ADDR
89370: GO 92033
89372: LD_INT 6
89374: DOUBLE
89375: EQUAL
89376: IFTRUE 89380
89378: GO 89512
89380: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89381: LD_ADDR_VAR 0 2
89385: PUSH
89386: LD_INT 2
89388: PUSH
89389: LD_INT 4
89391: PUSH
89392: LD_INT 5
89394: PUSH
89395: LD_INT 6
89397: PUSH
89398: LD_INT 8
89400: PUSH
89401: LD_INT 11
89403: PUSH
89404: LD_INT 12
89406: PUSH
89407: LD_INT 15
89409: PUSH
89410: LD_INT 16
89412: PUSH
89413: LD_INT 20
89415: PUSH
89416: LD_INT 21
89418: PUSH
89419: LD_INT 22
89421: PUSH
89422: LD_INT 23
89424: PUSH
89425: LD_INT 25
89427: PUSH
89428: LD_INT 26
89430: PUSH
89431: LD_INT 30
89433: PUSH
89434: LD_INT 31
89436: PUSH
89437: LD_INT 32
89439: PUSH
89440: LD_INT 36
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 101
89466: PUSH
89467: LD_INT 102
89469: PUSH
89470: LD_INT 105
89472: PUSH
89473: LD_INT 106
89475: PUSH
89476: LD_INT 108
89478: PUSH
89479: LD_INT 109
89481: PUSH
89482: LD_INT 112
89484: PUSH
89485: LD_INT 116
89487: PUSH
89488: LD_INT 117
89490: PUSH
89491: LD_INT 118
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: ST_TO_ADDR
89510: GO 92033
89512: LD_INT 7
89514: DOUBLE
89515: EQUAL
89516: IFTRUE 89520
89518: GO 89632
89520: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89521: LD_ADDR_VAR 0 2
89525: PUSH
89526: LD_INT 2
89528: PUSH
89529: LD_INT 4
89531: PUSH
89532: LD_INT 5
89534: PUSH
89535: LD_INT 7
89537: PUSH
89538: LD_INT 11
89540: PUSH
89541: LD_INT 12
89543: PUSH
89544: LD_INT 15
89546: PUSH
89547: LD_INT 16
89549: PUSH
89550: LD_INT 20
89552: PUSH
89553: LD_INT 21
89555: PUSH
89556: LD_INT 22
89558: PUSH
89559: LD_INT 23
89561: PUSH
89562: LD_INT 25
89564: PUSH
89565: LD_INT 26
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: PUSH
89584: LD_INT 101
89586: PUSH
89587: LD_INT 102
89589: PUSH
89590: LD_INT 103
89592: PUSH
89593: LD_INT 105
89595: PUSH
89596: LD_INT 106
89598: PUSH
89599: LD_INT 108
89601: PUSH
89602: LD_INT 112
89604: PUSH
89605: LD_INT 116
89607: PUSH
89608: LD_INT 117
89610: PUSH
89611: LD_INT 118
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: ST_TO_ADDR
89630: GO 92033
89632: LD_INT 8
89634: DOUBLE
89635: EQUAL
89636: IFTRUE 89640
89638: GO 89780
89640: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89641: LD_ADDR_VAR 0 2
89645: PUSH
89646: LD_INT 2
89648: PUSH
89649: LD_INT 4
89651: PUSH
89652: LD_INT 5
89654: PUSH
89655: LD_INT 6
89657: PUSH
89658: LD_INT 7
89660: PUSH
89661: LD_INT 8
89663: PUSH
89664: LD_INT 11
89666: PUSH
89667: LD_INT 12
89669: PUSH
89670: LD_INT 15
89672: PUSH
89673: LD_INT 16
89675: PUSH
89676: LD_INT 20
89678: PUSH
89679: LD_INT 21
89681: PUSH
89682: LD_INT 22
89684: PUSH
89685: LD_INT 23
89687: PUSH
89688: LD_INT 25
89690: PUSH
89691: LD_INT 26
89693: PUSH
89694: LD_INT 30
89696: PUSH
89697: LD_INT 31
89699: PUSH
89700: LD_INT 32
89702: PUSH
89703: LD_INT 36
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 101
89730: PUSH
89731: LD_INT 102
89733: PUSH
89734: LD_INT 103
89736: PUSH
89737: LD_INT 105
89739: PUSH
89740: LD_INT 106
89742: PUSH
89743: LD_INT 108
89745: PUSH
89746: LD_INT 109
89748: PUSH
89749: LD_INT 112
89751: PUSH
89752: LD_INT 116
89754: PUSH
89755: LD_INT 117
89757: PUSH
89758: LD_INT 118
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: ST_TO_ADDR
89778: GO 92033
89780: LD_INT 9
89782: DOUBLE
89783: EQUAL
89784: IFTRUE 89788
89786: GO 89936
89788: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89789: LD_ADDR_VAR 0 2
89793: PUSH
89794: LD_INT 2
89796: PUSH
89797: LD_INT 4
89799: PUSH
89800: LD_INT 5
89802: PUSH
89803: LD_INT 6
89805: PUSH
89806: LD_INT 7
89808: PUSH
89809: LD_INT 8
89811: PUSH
89812: LD_INT 11
89814: PUSH
89815: LD_INT 12
89817: PUSH
89818: LD_INT 15
89820: PUSH
89821: LD_INT 16
89823: PUSH
89824: LD_INT 20
89826: PUSH
89827: LD_INT 21
89829: PUSH
89830: LD_INT 22
89832: PUSH
89833: LD_INT 23
89835: PUSH
89836: LD_INT 25
89838: PUSH
89839: LD_INT 26
89841: PUSH
89842: LD_INT 28
89844: PUSH
89845: LD_INT 30
89847: PUSH
89848: LD_INT 31
89850: PUSH
89851: LD_INT 32
89853: PUSH
89854: LD_INT 36
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 101
89882: PUSH
89883: LD_INT 102
89885: PUSH
89886: LD_INT 103
89888: PUSH
89889: LD_INT 105
89891: PUSH
89892: LD_INT 106
89894: PUSH
89895: LD_INT 108
89897: PUSH
89898: LD_INT 109
89900: PUSH
89901: LD_INT 112
89903: PUSH
89904: LD_INT 114
89906: PUSH
89907: LD_INT 116
89909: PUSH
89910: LD_INT 117
89912: PUSH
89913: LD_INT 118
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: ST_TO_ADDR
89934: GO 92033
89936: LD_INT 10
89938: DOUBLE
89939: EQUAL
89940: IFTRUE 89944
89942: GO 90140
89944: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89945: LD_ADDR_VAR 0 2
89949: PUSH
89950: LD_INT 2
89952: PUSH
89953: LD_INT 4
89955: PUSH
89956: LD_INT 5
89958: PUSH
89959: LD_INT 6
89961: PUSH
89962: LD_INT 7
89964: PUSH
89965: LD_INT 8
89967: PUSH
89968: LD_INT 9
89970: PUSH
89971: LD_INT 10
89973: PUSH
89974: LD_INT 11
89976: PUSH
89977: LD_INT 12
89979: PUSH
89980: LD_INT 13
89982: PUSH
89983: LD_INT 14
89985: PUSH
89986: LD_INT 15
89988: PUSH
89989: LD_INT 16
89991: PUSH
89992: LD_INT 17
89994: PUSH
89995: LD_INT 18
89997: PUSH
89998: LD_INT 19
90000: PUSH
90001: LD_INT 20
90003: PUSH
90004: LD_INT 21
90006: PUSH
90007: LD_INT 22
90009: PUSH
90010: LD_INT 23
90012: PUSH
90013: LD_INT 24
90015: PUSH
90016: LD_INT 25
90018: PUSH
90019: LD_INT 26
90021: PUSH
90022: LD_INT 28
90024: PUSH
90025: LD_INT 30
90027: PUSH
90028: LD_INT 31
90030: PUSH
90031: LD_INT 32
90033: PUSH
90034: LD_INT 36
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 101
90070: PUSH
90071: LD_INT 102
90073: PUSH
90074: LD_INT 103
90076: PUSH
90077: LD_INT 104
90079: PUSH
90080: LD_INT 105
90082: PUSH
90083: LD_INT 106
90085: PUSH
90086: LD_INT 107
90088: PUSH
90089: LD_INT 108
90091: PUSH
90092: LD_INT 109
90094: PUSH
90095: LD_INT 110
90097: PUSH
90098: LD_INT 111
90100: PUSH
90101: LD_INT 112
90103: PUSH
90104: LD_INT 114
90106: PUSH
90107: LD_INT 116
90109: PUSH
90110: LD_INT 117
90112: PUSH
90113: LD_INT 118
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: ST_TO_ADDR
90138: GO 92033
90140: LD_INT 11
90142: DOUBLE
90143: EQUAL
90144: IFTRUE 90148
90146: GO 90352
90148: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90149: LD_ADDR_VAR 0 2
90153: PUSH
90154: LD_INT 2
90156: PUSH
90157: LD_INT 3
90159: PUSH
90160: LD_INT 4
90162: PUSH
90163: LD_INT 5
90165: PUSH
90166: LD_INT 6
90168: PUSH
90169: LD_INT 7
90171: PUSH
90172: LD_INT 8
90174: PUSH
90175: LD_INT 9
90177: PUSH
90178: LD_INT 10
90180: PUSH
90181: LD_INT 11
90183: PUSH
90184: LD_INT 12
90186: PUSH
90187: LD_INT 13
90189: PUSH
90190: LD_INT 14
90192: PUSH
90193: LD_INT 15
90195: PUSH
90196: LD_INT 16
90198: PUSH
90199: LD_INT 17
90201: PUSH
90202: LD_INT 18
90204: PUSH
90205: LD_INT 19
90207: PUSH
90208: LD_INT 20
90210: PUSH
90211: LD_INT 21
90213: PUSH
90214: LD_INT 22
90216: PUSH
90217: LD_INT 23
90219: PUSH
90220: LD_INT 24
90222: PUSH
90223: LD_INT 25
90225: PUSH
90226: LD_INT 26
90228: PUSH
90229: LD_INT 28
90231: PUSH
90232: LD_INT 30
90234: PUSH
90235: LD_INT 31
90237: PUSH
90238: LD_INT 32
90240: PUSH
90241: LD_INT 34
90243: PUSH
90244: LD_INT 36
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 101
90282: PUSH
90283: LD_INT 102
90285: PUSH
90286: LD_INT 103
90288: PUSH
90289: LD_INT 104
90291: PUSH
90292: LD_INT 105
90294: PUSH
90295: LD_INT 106
90297: PUSH
90298: LD_INT 107
90300: PUSH
90301: LD_INT 108
90303: PUSH
90304: LD_INT 109
90306: PUSH
90307: LD_INT 110
90309: PUSH
90310: LD_INT 111
90312: PUSH
90313: LD_INT 112
90315: PUSH
90316: LD_INT 114
90318: PUSH
90319: LD_INT 116
90321: PUSH
90322: LD_INT 117
90324: PUSH
90325: LD_INT 118
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: ST_TO_ADDR
90350: GO 92033
90352: LD_INT 12
90354: DOUBLE
90355: EQUAL
90356: IFTRUE 90360
90358: GO 90580
90360: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90361: LD_ADDR_VAR 0 2
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: LD_INT 2
90371: PUSH
90372: LD_INT 3
90374: PUSH
90375: LD_INT 4
90377: PUSH
90378: LD_INT 5
90380: PUSH
90381: LD_INT 6
90383: PUSH
90384: LD_INT 7
90386: PUSH
90387: LD_INT 8
90389: PUSH
90390: LD_INT 9
90392: PUSH
90393: LD_INT 10
90395: PUSH
90396: LD_INT 11
90398: PUSH
90399: LD_INT 12
90401: PUSH
90402: LD_INT 13
90404: PUSH
90405: LD_INT 14
90407: PUSH
90408: LD_INT 15
90410: PUSH
90411: LD_INT 16
90413: PUSH
90414: LD_INT 17
90416: PUSH
90417: LD_INT 18
90419: PUSH
90420: LD_INT 19
90422: PUSH
90423: LD_INT 20
90425: PUSH
90426: LD_INT 21
90428: PUSH
90429: LD_INT 22
90431: PUSH
90432: LD_INT 23
90434: PUSH
90435: LD_INT 24
90437: PUSH
90438: LD_INT 25
90440: PUSH
90441: LD_INT 26
90443: PUSH
90444: LD_INT 27
90446: PUSH
90447: LD_INT 28
90449: PUSH
90450: LD_INT 30
90452: PUSH
90453: LD_INT 31
90455: PUSH
90456: LD_INT 32
90458: PUSH
90459: LD_INT 33
90461: PUSH
90462: LD_INT 34
90464: PUSH
90465: LD_INT 36
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: PUSH
90504: LD_INT 101
90506: PUSH
90507: LD_INT 102
90509: PUSH
90510: LD_INT 103
90512: PUSH
90513: LD_INT 104
90515: PUSH
90516: LD_INT 105
90518: PUSH
90519: LD_INT 106
90521: PUSH
90522: LD_INT 107
90524: PUSH
90525: LD_INT 108
90527: PUSH
90528: LD_INT 109
90530: PUSH
90531: LD_INT 110
90533: PUSH
90534: LD_INT 111
90536: PUSH
90537: LD_INT 112
90539: PUSH
90540: LD_INT 113
90542: PUSH
90543: LD_INT 114
90545: PUSH
90546: LD_INT 116
90548: PUSH
90549: LD_INT 117
90551: PUSH
90552: LD_INT 118
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: ST_TO_ADDR
90578: GO 92033
90580: LD_INT 13
90582: DOUBLE
90583: EQUAL
90584: IFTRUE 90588
90586: GO 90796
90588: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90589: LD_ADDR_VAR 0 2
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: LD_INT 2
90599: PUSH
90600: LD_INT 3
90602: PUSH
90603: LD_INT 4
90605: PUSH
90606: LD_INT 5
90608: PUSH
90609: LD_INT 8
90611: PUSH
90612: LD_INT 9
90614: PUSH
90615: LD_INT 10
90617: PUSH
90618: LD_INT 11
90620: PUSH
90621: LD_INT 12
90623: PUSH
90624: LD_INT 14
90626: PUSH
90627: LD_INT 15
90629: PUSH
90630: LD_INT 16
90632: PUSH
90633: LD_INT 17
90635: PUSH
90636: LD_INT 18
90638: PUSH
90639: LD_INT 19
90641: PUSH
90642: LD_INT 20
90644: PUSH
90645: LD_INT 21
90647: PUSH
90648: LD_INT 22
90650: PUSH
90651: LD_INT 23
90653: PUSH
90654: LD_INT 24
90656: PUSH
90657: LD_INT 25
90659: PUSH
90660: LD_INT 26
90662: PUSH
90663: LD_INT 27
90665: PUSH
90666: LD_INT 28
90668: PUSH
90669: LD_INT 30
90671: PUSH
90672: LD_INT 31
90674: PUSH
90675: LD_INT 32
90677: PUSH
90678: LD_INT 33
90680: PUSH
90681: LD_INT 34
90683: PUSH
90684: LD_INT 36
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 101
90722: PUSH
90723: LD_INT 102
90725: PUSH
90726: LD_INT 103
90728: PUSH
90729: LD_INT 104
90731: PUSH
90732: LD_INT 105
90734: PUSH
90735: LD_INT 106
90737: PUSH
90738: LD_INT 107
90740: PUSH
90741: LD_INT 108
90743: PUSH
90744: LD_INT 109
90746: PUSH
90747: LD_INT 110
90749: PUSH
90750: LD_INT 111
90752: PUSH
90753: LD_INT 112
90755: PUSH
90756: LD_INT 113
90758: PUSH
90759: LD_INT 114
90761: PUSH
90762: LD_INT 116
90764: PUSH
90765: LD_INT 117
90767: PUSH
90768: LD_INT 118
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: ST_TO_ADDR
90794: GO 92033
90796: LD_INT 14
90798: DOUBLE
90799: EQUAL
90800: IFTRUE 90804
90802: GO 91028
90804: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90805: LD_ADDR_VAR 0 2
90809: PUSH
90810: LD_INT 1
90812: PUSH
90813: LD_INT 2
90815: PUSH
90816: LD_INT 3
90818: PUSH
90819: LD_INT 4
90821: PUSH
90822: LD_INT 5
90824: PUSH
90825: LD_INT 6
90827: PUSH
90828: LD_INT 7
90830: PUSH
90831: LD_INT 8
90833: PUSH
90834: LD_INT 9
90836: PUSH
90837: LD_INT 10
90839: PUSH
90840: LD_INT 11
90842: PUSH
90843: LD_INT 12
90845: PUSH
90846: LD_INT 13
90848: PUSH
90849: LD_INT 14
90851: PUSH
90852: LD_INT 15
90854: PUSH
90855: LD_INT 16
90857: PUSH
90858: LD_INT 17
90860: PUSH
90861: LD_INT 18
90863: PUSH
90864: LD_INT 19
90866: PUSH
90867: LD_INT 20
90869: PUSH
90870: LD_INT 21
90872: PUSH
90873: LD_INT 22
90875: PUSH
90876: LD_INT 23
90878: PUSH
90879: LD_INT 24
90881: PUSH
90882: LD_INT 25
90884: PUSH
90885: LD_INT 26
90887: PUSH
90888: LD_INT 27
90890: PUSH
90891: LD_INT 28
90893: PUSH
90894: LD_INT 29
90896: PUSH
90897: LD_INT 30
90899: PUSH
90900: LD_INT 31
90902: PUSH
90903: LD_INT 32
90905: PUSH
90906: LD_INT 33
90908: PUSH
90909: LD_INT 34
90911: PUSH
90912: LD_INT 36
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 101
90954: PUSH
90955: LD_INT 102
90957: PUSH
90958: LD_INT 103
90960: PUSH
90961: LD_INT 104
90963: PUSH
90964: LD_INT 105
90966: PUSH
90967: LD_INT 106
90969: PUSH
90970: LD_INT 107
90972: PUSH
90973: LD_INT 108
90975: PUSH
90976: LD_INT 109
90978: PUSH
90979: LD_INT 110
90981: PUSH
90982: LD_INT 111
90984: PUSH
90985: LD_INT 112
90987: PUSH
90988: LD_INT 113
90990: PUSH
90991: LD_INT 114
90993: PUSH
90994: LD_INT 116
90996: PUSH
90997: LD_INT 117
90999: PUSH
91000: LD_INT 118
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: ST_TO_ADDR
91026: GO 92033
91028: LD_INT 15
91030: DOUBLE
91031: EQUAL
91032: IFTRUE 91036
91034: GO 91260
91036: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91037: LD_ADDR_VAR 0 2
91041: PUSH
91042: LD_INT 1
91044: PUSH
91045: LD_INT 2
91047: PUSH
91048: LD_INT 3
91050: PUSH
91051: LD_INT 4
91053: PUSH
91054: LD_INT 5
91056: PUSH
91057: LD_INT 6
91059: PUSH
91060: LD_INT 7
91062: PUSH
91063: LD_INT 8
91065: PUSH
91066: LD_INT 9
91068: PUSH
91069: LD_INT 10
91071: PUSH
91072: LD_INT 11
91074: PUSH
91075: LD_INT 12
91077: PUSH
91078: LD_INT 13
91080: PUSH
91081: LD_INT 14
91083: PUSH
91084: LD_INT 15
91086: PUSH
91087: LD_INT 16
91089: PUSH
91090: LD_INT 17
91092: PUSH
91093: LD_INT 18
91095: PUSH
91096: LD_INT 19
91098: PUSH
91099: LD_INT 20
91101: PUSH
91102: LD_INT 21
91104: PUSH
91105: LD_INT 22
91107: PUSH
91108: LD_INT 23
91110: PUSH
91111: LD_INT 24
91113: PUSH
91114: LD_INT 25
91116: PUSH
91117: LD_INT 26
91119: PUSH
91120: LD_INT 27
91122: PUSH
91123: LD_INT 28
91125: PUSH
91126: LD_INT 29
91128: PUSH
91129: LD_INT 30
91131: PUSH
91132: LD_INT 31
91134: PUSH
91135: LD_INT 32
91137: PUSH
91138: LD_INT 33
91140: PUSH
91141: LD_INT 34
91143: PUSH
91144: LD_INT 36
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: PUSH
91184: LD_INT 101
91186: PUSH
91187: LD_INT 102
91189: PUSH
91190: LD_INT 103
91192: PUSH
91193: LD_INT 104
91195: PUSH
91196: LD_INT 105
91198: PUSH
91199: LD_INT 106
91201: PUSH
91202: LD_INT 107
91204: PUSH
91205: LD_INT 108
91207: PUSH
91208: LD_INT 109
91210: PUSH
91211: LD_INT 110
91213: PUSH
91214: LD_INT 111
91216: PUSH
91217: LD_INT 112
91219: PUSH
91220: LD_INT 113
91222: PUSH
91223: LD_INT 114
91225: PUSH
91226: LD_INT 116
91228: PUSH
91229: LD_INT 117
91231: PUSH
91232: LD_INT 118
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: ST_TO_ADDR
91258: GO 92033
91260: LD_INT 16
91262: DOUBLE
91263: EQUAL
91264: IFTRUE 91268
91266: GO 91404
91268: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91269: LD_ADDR_VAR 0 2
91273: PUSH
91274: LD_INT 2
91276: PUSH
91277: LD_INT 4
91279: PUSH
91280: LD_INT 5
91282: PUSH
91283: LD_INT 7
91285: PUSH
91286: LD_INT 11
91288: PUSH
91289: LD_INT 12
91291: PUSH
91292: LD_INT 15
91294: PUSH
91295: LD_INT 16
91297: PUSH
91298: LD_INT 20
91300: PUSH
91301: LD_INT 21
91303: PUSH
91304: LD_INT 22
91306: PUSH
91307: LD_INT 23
91309: PUSH
91310: LD_INT 25
91312: PUSH
91313: LD_INT 26
91315: PUSH
91316: LD_INT 30
91318: PUSH
91319: LD_INT 31
91321: PUSH
91322: LD_INT 32
91324: PUSH
91325: LD_INT 33
91327: PUSH
91328: LD_INT 34
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 101
91354: PUSH
91355: LD_INT 102
91357: PUSH
91358: LD_INT 103
91360: PUSH
91361: LD_INT 106
91363: PUSH
91364: LD_INT 108
91366: PUSH
91367: LD_INT 112
91369: PUSH
91370: LD_INT 113
91372: PUSH
91373: LD_INT 114
91375: PUSH
91376: LD_INT 116
91378: PUSH
91379: LD_INT 117
91381: PUSH
91382: LD_INT 118
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: ST_TO_ADDR
91402: GO 92033
91404: LD_INT 17
91406: DOUBLE
91407: EQUAL
91408: IFTRUE 91412
91410: GO 91636
91412: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91413: LD_ADDR_VAR 0 2
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: LD_INT 2
91423: PUSH
91424: LD_INT 3
91426: PUSH
91427: LD_INT 4
91429: PUSH
91430: LD_INT 5
91432: PUSH
91433: LD_INT 6
91435: PUSH
91436: LD_INT 7
91438: PUSH
91439: LD_INT 8
91441: PUSH
91442: LD_INT 9
91444: PUSH
91445: LD_INT 10
91447: PUSH
91448: LD_INT 11
91450: PUSH
91451: LD_INT 12
91453: PUSH
91454: LD_INT 13
91456: PUSH
91457: LD_INT 14
91459: PUSH
91460: LD_INT 15
91462: PUSH
91463: LD_INT 16
91465: PUSH
91466: LD_INT 17
91468: PUSH
91469: LD_INT 18
91471: PUSH
91472: LD_INT 19
91474: PUSH
91475: LD_INT 20
91477: PUSH
91478: LD_INT 21
91480: PUSH
91481: LD_INT 22
91483: PUSH
91484: LD_INT 23
91486: PUSH
91487: LD_INT 24
91489: PUSH
91490: LD_INT 25
91492: PUSH
91493: LD_INT 26
91495: PUSH
91496: LD_INT 27
91498: PUSH
91499: LD_INT 28
91501: PUSH
91502: LD_INT 29
91504: PUSH
91505: LD_INT 30
91507: PUSH
91508: LD_INT 31
91510: PUSH
91511: LD_INT 32
91513: PUSH
91514: LD_INT 33
91516: PUSH
91517: LD_INT 34
91519: PUSH
91520: LD_INT 36
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 101
91562: PUSH
91563: LD_INT 102
91565: PUSH
91566: LD_INT 103
91568: PUSH
91569: LD_INT 104
91571: PUSH
91572: LD_INT 105
91574: PUSH
91575: LD_INT 106
91577: PUSH
91578: LD_INT 107
91580: PUSH
91581: LD_INT 108
91583: PUSH
91584: LD_INT 109
91586: PUSH
91587: LD_INT 110
91589: PUSH
91590: LD_INT 111
91592: PUSH
91593: LD_INT 112
91595: PUSH
91596: LD_INT 113
91598: PUSH
91599: LD_INT 114
91601: PUSH
91602: LD_INT 116
91604: PUSH
91605: LD_INT 117
91607: PUSH
91608: LD_INT 118
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: ST_TO_ADDR
91634: GO 92033
91636: LD_INT 18
91638: DOUBLE
91639: EQUAL
91640: IFTRUE 91644
91642: GO 91792
91644: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91645: LD_ADDR_VAR 0 2
91649: PUSH
91650: LD_INT 2
91652: PUSH
91653: LD_INT 4
91655: PUSH
91656: LD_INT 5
91658: PUSH
91659: LD_INT 7
91661: PUSH
91662: LD_INT 11
91664: PUSH
91665: LD_INT 12
91667: PUSH
91668: LD_INT 15
91670: PUSH
91671: LD_INT 16
91673: PUSH
91674: LD_INT 20
91676: PUSH
91677: LD_INT 21
91679: PUSH
91680: LD_INT 22
91682: PUSH
91683: LD_INT 23
91685: PUSH
91686: LD_INT 25
91688: PUSH
91689: LD_INT 26
91691: PUSH
91692: LD_INT 30
91694: PUSH
91695: LD_INT 31
91697: PUSH
91698: LD_INT 32
91700: PUSH
91701: LD_INT 33
91703: PUSH
91704: LD_INT 34
91706: PUSH
91707: LD_INT 35
91709: PUSH
91710: LD_INT 36
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 101
91738: PUSH
91739: LD_INT 102
91741: PUSH
91742: LD_INT 103
91744: PUSH
91745: LD_INT 106
91747: PUSH
91748: LD_INT 108
91750: PUSH
91751: LD_INT 112
91753: PUSH
91754: LD_INT 113
91756: PUSH
91757: LD_INT 114
91759: PUSH
91760: LD_INT 115
91762: PUSH
91763: LD_INT 116
91765: PUSH
91766: LD_INT 117
91768: PUSH
91769: LD_INT 118
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: ST_TO_ADDR
91790: GO 92033
91792: LD_INT 19
91794: DOUBLE
91795: EQUAL
91796: IFTRUE 91800
91798: GO 92032
91800: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91801: LD_ADDR_VAR 0 2
91805: PUSH
91806: LD_INT 1
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: LD_INT 3
91814: PUSH
91815: LD_INT 4
91817: PUSH
91818: LD_INT 5
91820: PUSH
91821: LD_INT 6
91823: PUSH
91824: LD_INT 7
91826: PUSH
91827: LD_INT 8
91829: PUSH
91830: LD_INT 9
91832: PUSH
91833: LD_INT 10
91835: PUSH
91836: LD_INT 11
91838: PUSH
91839: LD_INT 12
91841: PUSH
91842: LD_INT 13
91844: PUSH
91845: LD_INT 14
91847: PUSH
91848: LD_INT 15
91850: PUSH
91851: LD_INT 16
91853: PUSH
91854: LD_INT 17
91856: PUSH
91857: LD_INT 18
91859: PUSH
91860: LD_INT 19
91862: PUSH
91863: LD_INT 20
91865: PUSH
91866: LD_INT 21
91868: PUSH
91869: LD_INT 22
91871: PUSH
91872: LD_INT 23
91874: PUSH
91875: LD_INT 24
91877: PUSH
91878: LD_INT 25
91880: PUSH
91881: LD_INT 26
91883: PUSH
91884: LD_INT 27
91886: PUSH
91887: LD_INT 28
91889: PUSH
91890: LD_INT 29
91892: PUSH
91893: LD_INT 30
91895: PUSH
91896: LD_INT 31
91898: PUSH
91899: LD_INT 32
91901: PUSH
91902: LD_INT 33
91904: PUSH
91905: LD_INT 34
91907: PUSH
91908: LD_INT 35
91910: PUSH
91911: LD_INT 36
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 101
91954: PUSH
91955: LD_INT 102
91957: PUSH
91958: LD_INT 103
91960: PUSH
91961: LD_INT 104
91963: PUSH
91964: LD_INT 105
91966: PUSH
91967: LD_INT 106
91969: PUSH
91970: LD_INT 107
91972: PUSH
91973: LD_INT 108
91975: PUSH
91976: LD_INT 109
91978: PUSH
91979: LD_INT 110
91981: PUSH
91982: LD_INT 111
91984: PUSH
91985: LD_INT 112
91987: PUSH
91988: LD_INT 113
91990: PUSH
91991: LD_INT 114
91993: PUSH
91994: LD_INT 115
91996: PUSH
91997: LD_INT 116
91999: PUSH
92000: LD_INT 117
92002: PUSH
92003: LD_INT 118
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: ST_TO_ADDR
92030: GO 92033
92032: POP
// end else
92033: GO 92264
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92035: LD_ADDR_VAR 0 2
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: LD_INT 2
92045: PUSH
92046: LD_INT 3
92048: PUSH
92049: LD_INT 4
92051: PUSH
92052: LD_INT 5
92054: PUSH
92055: LD_INT 6
92057: PUSH
92058: LD_INT 7
92060: PUSH
92061: LD_INT 8
92063: PUSH
92064: LD_INT 9
92066: PUSH
92067: LD_INT 10
92069: PUSH
92070: LD_INT 11
92072: PUSH
92073: LD_INT 12
92075: PUSH
92076: LD_INT 13
92078: PUSH
92079: LD_INT 14
92081: PUSH
92082: LD_INT 15
92084: PUSH
92085: LD_INT 16
92087: PUSH
92088: LD_INT 17
92090: PUSH
92091: LD_INT 18
92093: PUSH
92094: LD_INT 19
92096: PUSH
92097: LD_INT 20
92099: PUSH
92100: LD_INT 21
92102: PUSH
92103: LD_INT 22
92105: PUSH
92106: LD_INT 23
92108: PUSH
92109: LD_INT 24
92111: PUSH
92112: LD_INT 25
92114: PUSH
92115: LD_INT 26
92117: PUSH
92118: LD_INT 27
92120: PUSH
92121: LD_INT 28
92123: PUSH
92124: LD_INT 29
92126: PUSH
92127: LD_INT 30
92129: PUSH
92130: LD_INT 31
92132: PUSH
92133: LD_INT 32
92135: PUSH
92136: LD_INT 33
92138: PUSH
92139: LD_INT 34
92141: PUSH
92142: LD_INT 35
92144: PUSH
92145: LD_INT 36
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: PUSH
92186: LD_INT 101
92188: PUSH
92189: LD_INT 102
92191: PUSH
92192: LD_INT 103
92194: PUSH
92195: LD_INT 104
92197: PUSH
92198: LD_INT 105
92200: PUSH
92201: LD_INT 106
92203: PUSH
92204: LD_INT 107
92206: PUSH
92207: LD_INT 108
92209: PUSH
92210: LD_INT 109
92212: PUSH
92213: LD_INT 110
92215: PUSH
92216: LD_INT 111
92218: PUSH
92219: LD_INT 112
92221: PUSH
92222: LD_INT 113
92224: PUSH
92225: LD_INT 114
92227: PUSH
92228: LD_INT 115
92230: PUSH
92231: LD_INT 116
92233: PUSH
92234: LD_INT 117
92236: PUSH
92237: LD_INT 118
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: ST_TO_ADDR
// if result then
92264: LD_VAR 0 2
92268: IFFALSE 93054
// begin normal :=  ;
92270: LD_ADDR_VAR 0 5
92274: PUSH
92275: LD_STRING 
92277: ST_TO_ADDR
// hardcore :=  ;
92278: LD_ADDR_VAR 0 6
92282: PUSH
92283: LD_STRING 
92285: ST_TO_ADDR
// active :=  ;
92286: LD_ADDR_VAR 0 7
92290: PUSH
92291: LD_STRING 
92293: ST_TO_ADDR
// for i = 1 to normalCounter do
92294: LD_ADDR_VAR 0 8
92298: PUSH
92299: DOUBLE
92300: LD_INT 1
92302: DEC
92303: ST_TO_ADDR
92304: LD_EXP 108
92308: PUSH
92309: FOR_TO
92310: IFFALSE 92411
// begin tmp := 0 ;
92312: LD_ADDR_VAR 0 3
92316: PUSH
92317: LD_STRING 0
92319: ST_TO_ADDR
// if result [ 1 ] then
92320: LD_VAR 0 2
92324: PUSH
92325: LD_INT 1
92327: ARRAY
92328: IFFALSE 92393
// if result [ 1 ] [ 1 ] = i then
92330: LD_VAR 0 2
92334: PUSH
92335: LD_INT 1
92337: ARRAY
92338: PUSH
92339: LD_INT 1
92341: ARRAY
92342: PUSH
92343: LD_VAR 0 8
92347: EQUAL
92348: IFFALSE 92393
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92350: LD_ADDR_VAR 0 2
92354: PUSH
92355: LD_VAR 0 2
92359: PPUSH
92360: LD_INT 1
92362: PPUSH
92363: LD_VAR 0 2
92367: PUSH
92368: LD_INT 1
92370: ARRAY
92371: PPUSH
92372: LD_INT 1
92374: PPUSH
92375: CALL_OW 3
92379: PPUSH
92380: CALL_OW 1
92384: ST_TO_ADDR
// tmp := 1 ;
92385: LD_ADDR_VAR 0 3
92389: PUSH
92390: LD_STRING 1
92392: ST_TO_ADDR
// end ; normal := normal & tmp ;
92393: LD_ADDR_VAR 0 5
92397: PUSH
92398: LD_VAR 0 5
92402: PUSH
92403: LD_VAR 0 3
92407: STR
92408: ST_TO_ADDR
// end ;
92409: GO 92309
92411: POP
92412: POP
// for i = 1 to hardcoreCounter do
92413: LD_ADDR_VAR 0 8
92417: PUSH
92418: DOUBLE
92419: LD_INT 1
92421: DEC
92422: ST_TO_ADDR
92423: LD_EXP 109
92427: PUSH
92428: FOR_TO
92429: IFFALSE 92534
// begin tmp := 0 ;
92431: LD_ADDR_VAR 0 3
92435: PUSH
92436: LD_STRING 0
92438: ST_TO_ADDR
// if result [ 2 ] then
92439: LD_VAR 0 2
92443: PUSH
92444: LD_INT 2
92446: ARRAY
92447: IFFALSE 92516
// if result [ 2 ] [ 1 ] = 100 + i then
92449: LD_VAR 0 2
92453: PUSH
92454: LD_INT 2
92456: ARRAY
92457: PUSH
92458: LD_INT 1
92460: ARRAY
92461: PUSH
92462: LD_INT 100
92464: PUSH
92465: LD_VAR 0 8
92469: PLUS
92470: EQUAL
92471: IFFALSE 92516
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92473: LD_ADDR_VAR 0 2
92477: PUSH
92478: LD_VAR 0 2
92482: PPUSH
92483: LD_INT 2
92485: PPUSH
92486: LD_VAR 0 2
92490: PUSH
92491: LD_INT 2
92493: ARRAY
92494: PPUSH
92495: LD_INT 1
92497: PPUSH
92498: CALL_OW 3
92502: PPUSH
92503: CALL_OW 1
92507: ST_TO_ADDR
// tmp := 1 ;
92508: LD_ADDR_VAR 0 3
92512: PUSH
92513: LD_STRING 1
92515: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92516: LD_ADDR_VAR 0 6
92520: PUSH
92521: LD_VAR 0 6
92525: PUSH
92526: LD_VAR 0 3
92530: STR
92531: ST_TO_ADDR
// end ;
92532: GO 92428
92534: POP
92535: POP
// if isGameLoad then
92536: LD_VAR 0 1
92540: IFFALSE 93015
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92542: LD_ADDR_VAR 0 4
92546: PUSH
92547: LD_EXP 112
92551: PUSH
92552: LD_EXP 111
92556: PUSH
92557: LD_EXP 113
92561: PUSH
92562: LD_EXP 110
92566: PUSH
92567: LD_EXP 114
92571: PUSH
92572: LD_EXP 115
92576: PUSH
92577: LD_EXP 116
92581: PUSH
92582: LD_EXP 117
92586: PUSH
92587: LD_EXP 118
92591: PUSH
92592: LD_EXP 119
92596: PUSH
92597: LD_EXP 120
92601: PUSH
92602: LD_EXP 121
92606: PUSH
92607: LD_EXP 122
92611: PUSH
92612: LD_EXP 123
92616: PUSH
92617: LD_EXP 131
92621: PUSH
92622: LD_EXP 132
92626: PUSH
92627: LD_EXP 133
92631: PUSH
92632: LD_EXP 134
92636: PUSH
92637: LD_EXP 136
92641: PUSH
92642: LD_EXP 137
92646: PUSH
92647: LD_EXP 138
92651: PUSH
92652: LD_EXP 141
92656: PUSH
92657: LD_EXP 143
92661: PUSH
92662: LD_EXP 144
92666: PUSH
92667: LD_EXP 145
92671: PUSH
92672: LD_EXP 147
92676: PUSH
92677: LD_EXP 148
92681: PUSH
92682: LD_EXP 151
92686: PUSH
92687: LD_EXP 152
92691: PUSH
92692: LD_EXP 153
92696: PUSH
92697: LD_EXP 154
92701: PUSH
92702: LD_EXP 155
92706: PUSH
92707: LD_EXP 156
92711: PUSH
92712: LD_EXP 157
92716: PUSH
92717: LD_EXP 158
92721: PUSH
92722: LD_EXP 159
92726: PUSH
92727: LD_EXP 124
92731: PUSH
92732: LD_EXP 125
92736: PUSH
92737: LD_EXP 128
92741: PUSH
92742: LD_EXP 129
92746: PUSH
92747: LD_EXP 130
92751: PUSH
92752: LD_EXP 126
92756: PUSH
92757: LD_EXP 127
92761: PUSH
92762: LD_EXP 135
92766: PUSH
92767: LD_EXP 139
92771: PUSH
92772: LD_EXP 140
92776: PUSH
92777: LD_EXP 142
92781: PUSH
92782: LD_EXP 146
92786: PUSH
92787: LD_EXP 149
92791: PUSH
92792: LD_EXP 150
92796: PUSH
92797: LD_EXP 160
92801: PUSH
92802: LD_EXP 161
92806: PUSH
92807: LD_EXP 162
92811: PUSH
92812: LD_EXP 163
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: ST_TO_ADDR
// tmp :=  ;
92873: LD_ADDR_VAR 0 3
92877: PUSH
92878: LD_STRING 
92880: ST_TO_ADDR
// for i = 1 to normalCounter do
92881: LD_ADDR_VAR 0 8
92885: PUSH
92886: DOUBLE
92887: LD_INT 1
92889: DEC
92890: ST_TO_ADDR
92891: LD_EXP 108
92895: PUSH
92896: FOR_TO
92897: IFFALSE 92933
// begin if flags [ i ] then
92899: LD_VAR 0 4
92903: PUSH
92904: LD_VAR 0 8
92908: ARRAY
92909: IFFALSE 92931
// tmp := tmp & i & ; ;
92911: LD_ADDR_VAR 0 3
92915: PUSH
92916: LD_VAR 0 3
92920: PUSH
92921: LD_VAR 0 8
92925: STR
92926: PUSH
92927: LD_STRING ;
92929: STR
92930: ST_TO_ADDR
// end ;
92931: GO 92896
92933: POP
92934: POP
// for i = 1 to hardcoreCounter do
92935: LD_ADDR_VAR 0 8
92939: PUSH
92940: DOUBLE
92941: LD_INT 1
92943: DEC
92944: ST_TO_ADDR
92945: LD_EXP 109
92949: PUSH
92950: FOR_TO
92951: IFFALSE 92997
// begin if flags [ normalCounter + i ] then
92953: LD_VAR 0 4
92957: PUSH
92958: LD_EXP 108
92962: PUSH
92963: LD_VAR 0 8
92967: PLUS
92968: ARRAY
92969: IFFALSE 92995
// tmp := tmp & ( 100 + i ) & ; ;
92971: LD_ADDR_VAR 0 3
92975: PUSH
92976: LD_VAR 0 3
92980: PUSH
92981: LD_INT 100
92983: PUSH
92984: LD_VAR 0 8
92988: PLUS
92989: STR
92990: PUSH
92991: LD_STRING ;
92993: STR
92994: ST_TO_ADDR
// end ;
92995: GO 92950
92997: POP
92998: POP
// if tmp then
92999: LD_VAR 0 3
93003: IFFALSE 93015
// active := tmp ;
93005: LD_ADDR_VAR 0 7
93009: PUSH
93010: LD_VAR 0 3
93014: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93015: LD_STRING getStreamItemsFromMission("
93017: PUSH
93018: LD_VAR 0 5
93022: STR
93023: PUSH
93024: LD_STRING ","
93026: STR
93027: PUSH
93028: LD_VAR 0 6
93032: STR
93033: PUSH
93034: LD_STRING ","
93036: STR
93037: PUSH
93038: LD_VAR 0 7
93042: STR
93043: PUSH
93044: LD_STRING ")
93046: STR
93047: PPUSH
93048: CALL_OW 559
// end else
93052: GO 93061
// ToLua ( getStreamItemsFromMission("","","") ) ;
93054: LD_STRING getStreamItemsFromMission("","","")
93056: PPUSH
93057: CALL_OW 559
// end ;
93061: LD_VAR 0 2
93065: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93066: LD_EXP 107
93070: PUSH
93071: LD_EXP 112
93075: AND
93076: IFFALSE 93200
93078: GO 93080
93080: DISABLE
93081: LD_INT 0
93083: PPUSH
93084: PPUSH
// begin enable ;
93085: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93086: LD_ADDR_VAR 0 2
93090: PUSH
93091: LD_INT 22
93093: PUSH
93094: LD_OWVAR 2
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 2
93105: PUSH
93106: LD_INT 34
93108: PUSH
93109: LD_INT 7
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: LD_INT 34
93118: PUSH
93119: LD_INT 45
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 34
93128: PUSH
93129: LD_INT 28
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 34
93138: PUSH
93139: LD_INT 47
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PPUSH
93157: CALL_OW 69
93161: ST_TO_ADDR
// if not tmp then
93162: LD_VAR 0 2
93166: NOT
93167: IFFALSE 93171
// exit ;
93169: GO 93200
// for i in tmp do
93171: LD_ADDR_VAR 0 1
93175: PUSH
93176: LD_VAR 0 2
93180: PUSH
93181: FOR_IN
93182: IFFALSE 93198
// begin SetLives ( i , 0 ) ;
93184: LD_VAR 0 1
93188: PPUSH
93189: LD_INT 0
93191: PPUSH
93192: CALL_OW 234
// end ;
93196: GO 93181
93198: POP
93199: POP
// end ;
93200: PPOPN 2
93202: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93203: LD_EXP 107
93207: PUSH
93208: LD_EXP 113
93212: AND
93213: IFFALSE 93297
93215: GO 93217
93217: DISABLE
93218: LD_INT 0
93220: PPUSH
93221: PPUSH
// begin enable ;
93222: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93223: LD_ADDR_VAR 0 2
93227: PUSH
93228: LD_INT 22
93230: PUSH
93231: LD_OWVAR 2
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 32
93242: PUSH
93243: LD_INT 3
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PPUSH
93254: CALL_OW 69
93258: ST_TO_ADDR
// if not tmp then
93259: LD_VAR 0 2
93263: NOT
93264: IFFALSE 93268
// exit ;
93266: GO 93297
// for i in tmp do
93268: LD_ADDR_VAR 0 1
93272: PUSH
93273: LD_VAR 0 2
93277: PUSH
93278: FOR_IN
93279: IFFALSE 93295
// begin SetLives ( i , 0 ) ;
93281: LD_VAR 0 1
93285: PPUSH
93286: LD_INT 0
93288: PPUSH
93289: CALL_OW 234
// end ;
93293: GO 93278
93295: POP
93296: POP
// end ;
93297: PPOPN 2
93299: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93300: LD_EXP 107
93304: PUSH
93305: LD_EXP 110
93309: AND
93310: IFFALSE 93403
93312: GO 93314
93314: DISABLE
93315: LD_INT 0
93317: PPUSH
// begin enable ;
93318: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93319: LD_ADDR_VAR 0 1
93323: PUSH
93324: LD_INT 22
93326: PUSH
93327: LD_OWVAR 2
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 2
93338: PUSH
93339: LD_INT 25
93341: PUSH
93342: LD_INT 5
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 25
93351: PUSH
93352: LD_INT 9
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 25
93361: PUSH
93362: LD_INT 8
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: PPUSH
93379: CALL_OW 69
93383: PUSH
93384: FOR_IN
93385: IFFALSE 93401
// begin SetClass ( i , 1 ) ;
93387: LD_VAR 0 1
93391: PPUSH
93392: LD_INT 1
93394: PPUSH
93395: CALL_OW 336
// end ;
93399: GO 93384
93401: POP
93402: POP
// end ;
93403: PPOPN 1
93405: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93406: LD_EXP 107
93410: PUSH
93411: LD_EXP 111
93415: AND
93416: PUSH
93417: LD_OWVAR 65
93421: PUSH
93422: LD_INT 7
93424: LESS
93425: AND
93426: IFFALSE 93440
93428: GO 93430
93430: DISABLE
// begin enable ;
93431: ENABLE
// game_speed := 7 ;
93432: LD_ADDR_OWVAR 65
93436: PUSH
93437: LD_INT 7
93439: ST_TO_ADDR
// end ;
93440: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93441: LD_EXP 107
93445: PUSH
93446: LD_EXP 114
93450: AND
93451: IFFALSE 93653
93453: GO 93455
93455: DISABLE
93456: LD_INT 0
93458: PPUSH
93459: PPUSH
93460: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93461: LD_ADDR_VAR 0 3
93465: PUSH
93466: LD_INT 81
93468: PUSH
93469: LD_OWVAR 2
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 21
93480: PUSH
93481: LD_INT 1
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PPUSH
93492: CALL_OW 69
93496: ST_TO_ADDR
// if not tmp then
93497: LD_VAR 0 3
93501: NOT
93502: IFFALSE 93506
// exit ;
93504: GO 93653
// if tmp > 5 then
93506: LD_VAR 0 3
93510: PUSH
93511: LD_INT 5
93513: GREATER
93514: IFFALSE 93526
// k := 5 else
93516: LD_ADDR_VAR 0 2
93520: PUSH
93521: LD_INT 5
93523: ST_TO_ADDR
93524: GO 93536
// k := tmp ;
93526: LD_ADDR_VAR 0 2
93530: PUSH
93531: LD_VAR 0 3
93535: ST_TO_ADDR
// for i := 1 to k do
93536: LD_ADDR_VAR 0 1
93540: PUSH
93541: DOUBLE
93542: LD_INT 1
93544: DEC
93545: ST_TO_ADDR
93546: LD_VAR 0 2
93550: PUSH
93551: FOR_TO
93552: IFFALSE 93651
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93554: LD_VAR 0 3
93558: PUSH
93559: LD_VAR 0 1
93563: ARRAY
93564: PPUSH
93565: LD_VAR 0 1
93569: PUSH
93570: LD_INT 4
93572: MOD
93573: PUSH
93574: LD_INT 1
93576: PLUS
93577: PPUSH
93578: CALL_OW 259
93582: PUSH
93583: LD_INT 10
93585: LESS
93586: IFFALSE 93649
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93588: LD_VAR 0 3
93592: PUSH
93593: LD_VAR 0 1
93597: ARRAY
93598: PPUSH
93599: LD_VAR 0 1
93603: PUSH
93604: LD_INT 4
93606: MOD
93607: PUSH
93608: LD_INT 1
93610: PLUS
93611: PPUSH
93612: LD_VAR 0 3
93616: PUSH
93617: LD_VAR 0 1
93621: ARRAY
93622: PPUSH
93623: LD_VAR 0 1
93627: PUSH
93628: LD_INT 4
93630: MOD
93631: PUSH
93632: LD_INT 1
93634: PLUS
93635: PPUSH
93636: CALL_OW 259
93640: PUSH
93641: LD_INT 1
93643: PLUS
93644: PPUSH
93645: CALL_OW 237
93649: GO 93551
93651: POP
93652: POP
// end ;
93653: PPOPN 3
93655: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93656: LD_EXP 107
93660: PUSH
93661: LD_EXP 115
93665: AND
93666: IFFALSE 93686
93668: GO 93670
93670: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93671: LD_INT 4
93673: PPUSH
93674: LD_OWVAR 2
93678: PPUSH
93679: LD_INT 0
93681: PPUSH
93682: CALL_OW 324
93686: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93687: LD_EXP 107
93691: PUSH
93692: LD_EXP 144
93696: AND
93697: IFFALSE 93717
93699: GO 93701
93701: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93702: LD_INT 19
93704: PPUSH
93705: LD_OWVAR 2
93709: PPUSH
93710: LD_INT 0
93712: PPUSH
93713: CALL_OW 324
93717: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93718: LD_EXP 107
93722: PUSH
93723: LD_EXP 116
93727: AND
93728: IFFALSE 93830
93730: GO 93732
93732: DISABLE
93733: LD_INT 0
93735: PPUSH
93736: PPUSH
// begin enable ;
93737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93738: LD_ADDR_VAR 0 2
93742: PUSH
93743: LD_INT 22
93745: PUSH
93746: LD_OWVAR 2
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: LD_INT 2
93757: PUSH
93758: LD_INT 34
93760: PUSH
93761: LD_INT 11
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: PUSH
93768: LD_INT 34
93770: PUSH
93771: LD_INT 30
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: LIST
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PPUSH
93787: CALL_OW 69
93791: ST_TO_ADDR
// if not tmp then
93792: LD_VAR 0 2
93796: NOT
93797: IFFALSE 93801
// exit ;
93799: GO 93830
// for i in tmp do
93801: LD_ADDR_VAR 0 1
93805: PUSH
93806: LD_VAR 0 2
93810: PUSH
93811: FOR_IN
93812: IFFALSE 93828
// begin SetLives ( i , 0 ) ;
93814: LD_VAR 0 1
93818: PPUSH
93819: LD_INT 0
93821: PPUSH
93822: CALL_OW 234
// end ;
93826: GO 93811
93828: POP
93829: POP
// end ;
93830: PPOPN 2
93832: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93833: LD_EXP 107
93837: PUSH
93838: LD_EXP 117
93842: AND
93843: IFFALSE 93863
93845: GO 93847
93847: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93848: LD_INT 32
93850: PPUSH
93851: LD_OWVAR 2
93855: PPUSH
93856: LD_INT 0
93858: PPUSH
93859: CALL_OW 324
93863: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93864: LD_EXP 107
93868: PUSH
93869: LD_EXP 118
93873: AND
93874: IFFALSE 94055
93876: GO 93878
93878: DISABLE
93879: LD_INT 0
93881: PPUSH
93882: PPUSH
93883: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93884: LD_ADDR_VAR 0 2
93888: PUSH
93889: LD_INT 22
93891: PUSH
93892: LD_OWVAR 2
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 33
93903: PUSH
93904: LD_INT 3
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PPUSH
93915: CALL_OW 69
93919: ST_TO_ADDR
// if not tmp then
93920: LD_VAR 0 2
93924: NOT
93925: IFFALSE 93929
// exit ;
93927: GO 94055
// side := 0 ;
93929: LD_ADDR_VAR 0 3
93933: PUSH
93934: LD_INT 0
93936: ST_TO_ADDR
// for i := 1 to 8 do
93937: LD_ADDR_VAR 0 1
93941: PUSH
93942: DOUBLE
93943: LD_INT 1
93945: DEC
93946: ST_TO_ADDR
93947: LD_INT 8
93949: PUSH
93950: FOR_TO
93951: IFFALSE 93999
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93953: LD_OWVAR 2
93957: PUSH
93958: LD_VAR 0 1
93962: NONEQUAL
93963: PUSH
93964: LD_OWVAR 2
93968: PPUSH
93969: LD_VAR 0 1
93973: PPUSH
93974: CALL_OW 81
93978: PUSH
93979: LD_INT 2
93981: EQUAL
93982: AND
93983: IFFALSE 93997
// begin side := i ;
93985: LD_ADDR_VAR 0 3
93989: PUSH
93990: LD_VAR 0 1
93994: ST_TO_ADDR
// break ;
93995: GO 93999
// end ;
93997: GO 93950
93999: POP
94000: POP
// if not side then
94001: LD_VAR 0 3
94005: NOT
94006: IFFALSE 94010
// exit ;
94008: GO 94055
// for i := 1 to tmp do
94010: LD_ADDR_VAR 0 1
94014: PUSH
94015: DOUBLE
94016: LD_INT 1
94018: DEC
94019: ST_TO_ADDR
94020: LD_VAR 0 2
94024: PUSH
94025: FOR_TO
94026: IFFALSE 94053
// if Prob ( 60 ) then
94028: LD_INT 60
94030: PPUSH
94031: CALL_OW 13
94035: IFFALSE 94051
// SetSide ( i , side ) ;
94037: LD_VAR 0 1
94041: PPUSH
94042: LD_VAR 0 3
94046: PPUSH
94047: CALL_OW 235
94051: GO 94025
94053: POP
94054: POP
// end ;
94055: PPOPN 3
94057: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94058: LD_EXP 107
94062: PUSH
94063: LD_EXP 120
94067: AND
94068: IFFALSE 94187
94070: GO 94072
94072: DISABLE
94073: LD_INT 0
94075: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94076: LD_ADDR_VAR 0 1
94080: PUSH
94081: LD_INT 22
94083: PUSH
94084: LD_OWVAR 2
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 21
94095: PUSH
94096: LD_INT 1
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 3
94105: PUSH
94106: LD_INT 23
94108: PUSH
94109: LD_INT 0
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: LIST
94124: PPUSH
94125: CALL_OW 69
94129: PUSH
94130: FOR_IN
94131: IFFALSE 94185
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94133: LD_VAR 0 1
94137: PPUSH
94138: CALL_OW 257
94142: PUSH
94143: LD_INT 1
94145: PUSH
94146: LD_INT 2
94148: PUSH
94149: LD_INT 3
94151: PUSH
94152: LD_INT 4
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: IN
94161: IFFALSE 94183
// SetClass ( un , rand ( 1 , 4 ) ) ;
94163: LD_VAR 0 1
94167: PPUSH
94168: LD_INT 1
94170: PPUSH
94171: LD_INT 4
94173: PPUSH
94174: CALL_OW 12
94178: PPUSH
94179: CALL_OW 336
94183: GO 94130
94185: POP
94186: POP
// end ;
94187: PPOPN 1
94189: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94190: LD_EXP 107
94194: PUSH
94195: LD_EXP 119
94199: AND
94200: IFFALSE 94279
94202: GO 94204
94204: DISABLE
94205: LD_INT 0
94207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94208: LD_ADDR_VAR 0 1
94212: PUSH
94213: LD_INT 22
94215: PUSH
94216: LD_OWVAR 2
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 21
94227: PUSH
94228: LD_INT 3
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PPUSH
94239: CALL_OW 69
94243: ST_TO_ADDR
// if not tmp then
94244: LD_VAR 0 1
94248: NOT
94249: IFFALSE 94253
// exit ;
94251: GO 94279
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94253: LD_VAR 0 1
94257: PUSH
94258: LD_INT 1
94260: PPUSH
94261: LD_VAR 0 1
94265: PPUSH
94266: CALL_OW 12
94270: ARRAY
94271: PPUSH
94272: LD_INT 100
94274: PPUSH
94275: CALL_OW 234
// end ;
94279: PPOPN 1
94281: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94282: LD_EXP 107
94286: PUSH
94287: LD_EXP 121
94291: AND
94292: IFFALSE 94390
94294: GO 94296
94296: DISABLE
94297: LD_INT 0
94299: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94300: LD_ADDR_VAR 0 1
94304: PUSH
94305: LD_INT 22
94307: PUSH
94308: LD_OWVAR 2
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 21
94319: PUSH
94320: LD_INT 1
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PPUSH
94331: CALL_OW 69
94335: ST_TO_ADDR
// if not tmp then
94336: LD_VAR 0 1
94340: NOT
94341: IFFALSE 94345
// exit ;
94343: GO 94390
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94345: LD_VAR 0 1
94349: PUSH
94350: LD_INT 1
94352: PPUSH
94353: LD_VAR 0 1
94357: PPUSH
94358: CALL_OW 12
94362: ARRAY
94363: PPUSH
94364: LD_INT 1
94366: PPUSH
94367: LD_INT 4
94369: PPUSH
94370: CALL_OW 12
94374: PPUSH
94375: LD_INT 3000
94377: PPUSH
94378: LD_INT 9000
94380: PPUSH
94381: CALL_OW 12
94385: PPUSH
94386: CALL_OW 492
// end ;
94390: PPOPN 1
94392: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94393: LD_EXP 107
94397: PUSH
94398: LD_EXP 122
94402: AND
94403: IFFALSE 94423
94405: GO 94407
94407: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94408: LD_INT 1
94410: PPUSH
94411: LD_OWVAR 2
94415: PPUSH
94416: LD_INT 0
94418: PPUSH
94419: CALL_OW 324
94423: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94424: LD_EXP 107
94428: PUSH
94429: LD_EXP 123
94433: AND
94434: IFFALSE 94517
94436: GO 94438
94438: DISABLE
94439: LD_INT 0
94441: PPUSH
94442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94443: LD_ADDR_VAR 0 2
94447: PUSH
94448: LD_INT 22
94450: PUSH
94451: LD_OWVAR 2
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 21
94462: PUSH
94463: LD_INT 3
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PPUSH
94474: CALL_OW 69
94478: ST_TO_ADDR
// if not tmp then
94479: LD_VAR 0 2
94483: NOT
94484: IFFALSE 94488
// exit ;
94486: GO 94517
// for i in tmp do
94488: LD_ADDR_VAR 0 1
94492: PUSH
94493: LD_VAR 0 2
94497: PUSH
94498: FOR_IN
94499: IFFALSE 94515
// SetBLevel ( i , 10 ) ;
94501: LD_VAR 0 1
94505: PPUSH
94506: LD_INT 10
94508: PPUSH
94509: CALL_OW 241
94513: GO 94498
94515: POP
94516: POP
// end ;
94517: PPOPN 2
94519: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94520: LD_EXP 107
94524: PUSH
94525: LD_EXP 124
94529: AND
94530: IFFALSE 94641
94532: GO 94534
94534: DISABLE
94535: LD_INT 0
94537: PPUSH
94538: PPUSH
94539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94540: LD_ADDR_VAR 0 3
94544: PUSH
94545: LD_INT 22
94547: PUSH
94548: LD_OWVAR 2
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 25
94559: PUSH
94560: LD_INT 1
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PPUSH
94571: CALL_OW 69
94575: ST_TO_ADDR
// if not tmp then
94576: LD_VAR 0 3
94580: NOT
94581: IFFALSE 94585
// exit ;
94583: GO 94641
// un := tmp [ rand ( 1 , tmp ) ] ;
94585: LD_ADDR_VAR 0 2
94589: PUSH
94590: LD_VAR 0 3
94594: PUSH
94595: LD_INT 1
94597: PPUSH
94598: LD_VAR 0 3
94602: PPUSH
94603: CALL_OW 12
94607: ARRAY
94608: ST_TO_ADDR
// if Crawls ( un ) then
94609: LD_VAR 0 2
94613: PPUSH
94614: CALL_OW 318
94618: IFFALSE 94629
// ComWalk ( un ) ;
94620: LD_VAR 0 2
94624: PPUSH
94625: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94629: LD_VAR 0 2
94633: PPUSH
94634: LD_INT 5
94636: PPUSH
94637: CALL_OW 336
// end ;
94641: PPOPN 3
94643: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94644: LD_EXP 107
94648: PUSH
94649: LD_EXP 125
94653: AND
94654: PUSH
94655: LD_OWVAR 67
94659: PUSH
94660: LD_INT 4
94662: LESS
94663: AND
94664: IFFALSE 94683
94666: GO 94668
94668: DISABLE
// begin Difficulty := Difficulty + 1 ;
94669: LD_ADDR_OWVAR 67
94673: PUSH
94674: LD_OWVAR 67
94678: PUSH
94679: LD_INT 1
94681: PLUS
94682: ST_TO_ADDR
// end ;
94683: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94684: LD_EXP 107
94688: PUSH
94689: LD_EXP 126
94693: AND
94694: IFFALSE 94797
94696: GO 94698
94698: DISABLE
94699: LD_INT 0
94701: PPUSH
// begin for i := 1 to 5 do
94702: LD_ADDR_VAR 0 1
94706: PUSH
94707: DOUBLE
94708: LD_INT 1
94710: DEC
94711: ST_TO_ADDR
94712: LD_INT 5
94714: PUSH
94715: FOR_TO
94716: IFFALSE 94795
// begin uc_nation := nation_nature ;
94718: LD_ADDR_OWVAR 21
94722: PUSH
94723: LD_INT 0
94725: ST_TO_ADDR
// uc_side := 0 ;
94726: LD_ADDR_OWVAR 20
94730: PUSH
94731: LD_INT 0
94733: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94734: LD_ADDR_OWVAR 29
94738: PUSH
94739: LD_INT 12
94741: PUSH
94742: LD_INT 12
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: ST_TO_ADDR
// hc_agressivity := 20 ;
94749: LD_ADDR_OWVAR 35
94753: PUSH
94754: LD_INT 20
94756: ST_TO_ADDR
// hc_class := class_tiger ;
94757: LD_ADDR_OWVAR 28
94761: PUSH
94762: LD_INT 14
94764: ST_TO_ADDR
// hc_gallery :=  ;
94765: LD_ADDR_OWVAR 33
94769: PUSH
94770: LD_STRING 
94772: ST_TO_ADDR
// hc_name :=  ;
94773: LD_ADDR_OWVAR 26
94777: PUSH
94778: LD_STRING 
94780: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94781: CALL_OW 44
94785: PPUSH
94786: LD_INT 0
94788: PPUSH
94789: CALL_OW 51
// end ;
94793: GO 94715
94795: POP
94796: POP
// end ;
94797: PPOPN 1
94799: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94800: LD_EXP 107
94804: PUSH
94805: LD_EXP 127
94809: AND
94810: IFFALSE 94819
94812: GO 94814
94814: DISABLE
// StreamSibBomb ;
94815: CALL 94820 0 0
94819: END
// export function StreamSibBomb ; var i , x , y ; begin
94820: LD_INT 0
94822: PPUSH
94823: PPUSH
94824: PPUSH
94825: PPUSH
// result := false ;
94826: LD_ADDR_VAR 0 1
94830: PUSH
94831: LD_INT 0
94833: ST_TO_ADDR
// for i := 1 to 16 do
94834: LD_ADDR_VAR 0 2
94838: PUSH
94839: DOUBLE
94840: LD_INT 1
94842: DEC
94843: ST_TO_ADDR
94844: LD_INT 16
94846: PUSH
94847: FOR_TO
94848: IFFALSE 95047
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94850: LD_ADDR_VAR 0 3
94854: PUSH
94855: LD_INT 10
94857: PUSH
94858: LD_INT 20
94860: PUSH
94861: LD_INT 30
94863: PUSH
94864: LD_INT 40
94866: PUSH
94867: LD_INT 50
94869: PUSH
94870: LD_INT 60
94872: PUSH
94873: LD_INT 70
94875: PUSH
94876: LD_INT 80
94878: PUSH
94879: LD_INT 90
94881: PUSH
94882: LD_INT 100
94884: PUSH
94885: LD_INT 110
94887: PUSH
94888: LD_INT 120
94890: PUSH
94891: LD_INT 130
94893: PUSH
94894: LD_INT 140
94896: PUSH
94897: LD_INT 150
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 1
94919: PPUSH
94920: LD_INT 15
94922: PPUSH
94923: CALL_OW 12
94927: ARRAY
94928: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94929: LD_ADDR_VAR 0 4
94933: PUSH
94934: LD_INT 10
94936: PUSH
94937: LD_INT 20
94939: PUSH
94940: LD_INT 30
94942: PUSH
94943: LD_INT 40
94945: PUSH
94946: LD_INT 50
94948: PUSH
94949: LD_INT 60
94951: PUSH
94952: LD_INT 70
94954: PUSH
94955: LD_INT 80
94957: PUSH
94958: LD_INT 90
94960: PUSH
94961: LD_INT 100
94963: PUSH
94964: LD_INT 110
94966: PUSH
94967: LD_INT 120
94969: PUSH
94970: LD_INT 130
94972: PUSH
94973: LD_INT 140
94975: PUSH
94976: LD_INT 150
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: PPUSH
94999: LD_INT 15
95001: PPUSH
95002: CALL_OW 12
95006: ARRAY
95007: ST_TO_ADDR
// if ValidHex ( x , y ) then
95008: LD_VAR 0 3
95012: PPUSH
95013: LD_VAR 0 4
95017: PPUSH
95018: CALL_OW 488
95022: IFFALSE 95045
// begin result := [ x , y ] ;
95024: LD_ADDR_VAR 0 1
95028: PUSH
95029: LD_VAR 0 3
95033: PUSH
95034: LD_VAR 0 4
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: ST_TO_ADDR
// break ;
95043: GO 95047
// end ; end ;
95045: GO 94847
95047: POP
95048: POP
// if result then
95049: LD_VAR 0 1
95053: IFFALSE 95113
// begin ToLua ( playSibBomb() ) ;
95055: LD_STRING playSibBomb()
95057: PPUSH
95058: CALL_OW 559
// wait ( 0 0$14 ) ;
95062: LD_INT 490
95064: PPUSH
95065: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95069: LD_VAR 0 1
95073: PUSH
95074: LD_INT 1
95076: ARRAY
95077: PPUSH
95078: LD_VAR 0 1
95082: PUSH
95083: LD_INT 2
95085: ARRAY
95086: PPUSH
95087: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95091: LD_VAR 0 1
95095: PUSH
95096: LD_INT 1
95098: ARRAY
95099: PPUSH
95100: LD_VAR 0 1
95104: PUSH
95105: LD_INT 2
95107: ARRAY
95108: PPUSH
95109: CALL_OW 429
// end ; end ;
95113: LD_VAR 0 1
95117: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95118: LD_EXP 107
95122: PUSH
95123: LD_EXP 129
95127: AND
95128: IFFALSE 95140
95130: GO 95132
95132: DISABLE
// YouLost (  ) ;
95133: LD_STRING 
95135: PPUSH
95136: CALL_OW 104
95140: END
// every 0 0$1 trigger StreamModeActive and sFog do
95141: LD_EXP 107
95145: PUSH
95146: LD_EXP 128
95150: AND
95151: IFFALSE 95165
95153: GO 95155
95155: DISABLE
// FogOff ( your_side ) ;
95156: LD_OWVAR 2
95160: PPUSH
95161: CALL_OW 344
95165: END
// every 0 0$1 trigger StreamModeActive and sSun do
95166: LD_EXP 107
95170: PUSH
95171: LD_EXP 130
95175: AND
95176: IFFALSE 95204
95178: GO 95180
95180: DISABLE
// begin solar_recharge_percent := 0 ;
95181: LD_ADDR_OWVAR 79
95185: PUSH
95186: LD_INT 0
95188: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95189: LD_INT 10500
95191: PPUSH
95192: CALL_OW 67
// solar_recharge_percent := 100 ;
95196: LD_ADDR_OWVAR 79
95200: PUSH
95201: LD_INT 100
95203: ST_TO_ADDR
// end ;
95204: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95205: LD_EXP 107
95209: PUSH
95210: LD_EXP 131
95214: AND
95215: IFFALSE 95454
95217: GO 95219
95219: DISABLE
95220: LD_INT 0
95222: PPUSH
95223: PPUSH
95224: PPUSH
// begin tmp := [ ] ;
95225: LD_ADDR_VAR 0 3
95229: PUSH
95230: EMPTY
95231: ST_TO_ADDR
// for i := 1 to 6 do
95232: LD_ADDR_VAR 0 1
95236: PUSH
95237: DOUBLE
95238: LD_INT 1
95240: DEC
95241: ST_TO_ADDR
95242: LD_INT 6
95244: PUSH
95245: FOR_TO
95246: IFFALSE 95351
// begin uc_nation := nation_nature ;
95248: LD_ADDR_OWVAR 21
95252: PUSH
95253: LD_INT 0
95255: ST_TO_ADDR
// uc_side := 0 ;
95256: LD_ADDR_OWVAR 20
95260: PUSH
95261: LD_INT 0
95263: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95264: LD_ADDR_OWVAR 29
95268: PUSH
95269: LD_INT 12
95271: PUSH
95272: LD_INT 12
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: ST_TO_ADDR
// hc_agressivity := 20 ;
95279: LD_ADDR_OWVAR 35
95283: PUSH
95284: LD_INT 20
95286: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95287: LD_ADDR_OWVAR 28
95291: PUSH
95292: LD_INT 17
95294: ST_TO_ADDR
// hc_gallery :=  ;
95295: LD_ADDR_OWVAR 33
95299: PUSH
95300: LD_STRING 
95302: ST_TO_ADDR
// hc_name :=  ;
95303: LD_ADDR_OWVAR 26
95307: PUSH
95308: LD_STRING 
95310: ST_TO_ADDR
// un := CreateHuman ;
95311: LD_ADDR_VAR 0 2
95315: PUSH
95316: CALL_OW 44
95320: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95321: LD_VAR 0 2
95325: PPUSH
95326: LD_INT 1
95328: PPUSH
95329: CALL_OW 51
// tmp := tmp ^ un ;
95333: LD_ADDR_VAR 0 3
95337: PUSH
95338: LD_VAR 0 3
95342: PUSH
95343: LD_VAR 0 2
95347: ADD
95348: ST_TO_ADDR
// end ;
95349: GO 95245
95351: POP
95352: POP
// repeat wait ( 0 0$1 ) ;
95353: LD_INT 35
95355: PPUSH
95356: CALL_OW 67
// for un in tmp do
95360: LD_ADDR_VAR 0 2
95364: PUSH
95365: LD_VAR 0 3
95369: PUSH
95370: FOR_IN
95371: IFFALSE 95445
// begin if IsDead ( un ) then
95373: LD_VAR 0 2
95377: PPUSH
95378: CALL_OW 301
95382: IFFALSE 95402
// begin tmp := tmp diff un ;
95384: LD_ADDR_VAR 0 3
95388: PUSH
95389: LD_VAR 0 3
95393: PUSH
95394: LD_VAR 0 2
95398: DIFF
95399: ST_TO_ADDR
// continue ;
95400: GO 95370
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95402: LD_VAR 0 2
95406: PPUSH
95407: LD_INT 3
95409: PUSH
95410: LD_INT 22
95412: PUSH
95413: LD_INT 0
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PPUSH
95424: CALL_OW 69
95428: PPUSH
95429: LD_VAR 0 2
95433: PPUSH
95434: CALL_OW 74
95438: PPUSH
95439: CALL_OW 115
// end ;
95443: GO 95370
95445: POP
95446: POP
// until not tmp ;
95447: LD_VAR 0 3
95451: NOT
95452: IFFALSE 95353
// end ;
95454: PPOPN 3
95456: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95457: LD_EXP 107
95461: PUSH
95462: LD_EXP 132
95466: AND
95467: IFFALSE 95521
95469: GO 95471
95471: DISABLE
// begin ToLua ( displayTroll(); ) ;
95472: LD_STRING displayTroll();
95474: PPUSH
95475: CALL_OW 559
// wait ( 3 3$00 ) ;
95479: LD_INT 6300
95481: PPUSH
95482: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95486: LD_STRING hideTroll();
95488: PPUSH
95489: CALL_OW 559
// wait ( 1 1$00 ) ;
95493: LD_INT 2100
95495: PPUSH
95496: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95500: LD_STRING displayTroll();
95502: PPUSH
95503: CALL_OW 559
// wait ( 1 1$00 ) ;
95507: LD_INT 2100
95509: PPUSH
95510: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95514: LD_STRING hideTroll();
95516: PPUSH
95517: CALL_OW 559
// end ;
95521: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95522: LD_EXP 107
95526: PUSH
95527: LD_EXP 133
95531: AND
95532: IFFALSE 95595
95534: GO 95536
95536: DISABLE
95537: LD_INT 0
95539: PPUSH
// begin p := 0 ;
95540: LD_ADDR_VAR 0 1
95544: PUSH
95545: LD_INT 0
95547: ST_TO_ADDR
// repeat game_speed := 1 ;
95548: LD_ADDR_OWVAR 65
95552: PUSH
95553: LD_INT 1
95555: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95556: LD_INT 35
95558: PPUSH
95559: CALL_OW 67
// p := p + 1 ;
95563: LD_ADDR_VAR 0 1
95567: PUSH
95568: LD_VAR 0 1
95572: PUSH
95573: LD_INT 1
95575: PLUS
95576: ST_TO_ADDR
// until p >= 60 ;
95577: LD_VAR 0 1
95581: PUSH
95582: LD_INT 60
95584: GREATEREQUAL
95585: IFFALSE 95548
// game_speed := 4 ;
95587: LD_ADDR_OWVAR 65
95591: PUSH
95592: LD_INT 4
95594: ST_TO_ADDR
// end ;
95595: PPOPN 1
95597: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95598: LD_EXP 107
95602: PUSH
95603: LD_EXP 134
95607: AND
95608: IFFALSE 95754
95610: GO 95612
95612: DISABLE
95613: LD_INT 0
95615: PPUSH
95616: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95617: LD_ADDR_VAR 0 1
95621: PUSH
95622: LD_INT 22
95624: PUSH
95625: LD_OWVAR 2
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: LD_INT 30
95639: PUSH
95640: LD_INT 0
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 30
95649: PUSH
95650: LD_INT 1
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: LIST
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PPUSH
95666: CALL_OW 69
95670: ST_TO_ADDR
// if not depot then
95671: LD_VAR 0 1
95675: NOT
95676: IFFALSE 95680
// exit ;
95678: GO 95754
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95680: LD_ADDR_VAR 0 2
95684: PUSH
95685: LD_VAR 0 1
95689: PUSH
95690: LD_INT 1
95692: PPUSH
95693: LD_VAR 0 1
95697: PPUSH
95698: CALL_OW 12
95702: ARRAY
95703: PPUSH
95704: CALL_OW 274
95708: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95709: LD_VAR 0 2
95713: PPUSH
95714: LD_INT 1
95716: PPUSH
95717: LD_INT 0
95719: PPUSH
95720: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95724: LD_VAR 0 2
95728: PPUSH
95729: LD_INT 2
95731: PPUSH
95732: LD_INT 0
95734: PPUSH
95735: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95739: LD_VAR 0 2
95743: PPUSH
95744: LD_INT 3
95746: PPUSH
95747: LD_INT 0
95749: PPUSH
95750: CALL_OW 277
// end ;
95754: PPOPN 2
95756: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95757: LD_EXP 107
95761: PUSH
95762: LD_EXP 135
95766: AND
95767: IFFALSE 95864
95769: GO 95771
95771: DISABLE
95772: LD_INT 0
95774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95775: LD_ADDR_VAR 0 1
95779: PUSH
95780: LD_INT 22
95782: PUSH
95783: LD_OWVAR 2
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 21
95794: PUSH
95795: LD_INT 1
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 3
95804: PUSH
95805: LD_INT 23
95807: PUSH
95808: LD_INT 0
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: LIST
95823: PPUSH
95824: CALL_OW 69
95828: ST_TO_ADDR
// if not tmp then
95829: LD_VAR 0 1
95833: NOT
95834: IFFALSE 95838
// exit ;
95836: GO 95864
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95838: LD_VAR 0 1
95842: PUSH
95843: LD_INT 1
95845: PPUSH
95846: LD_VAR 0 1
95850: PPUSH
95851: CALL_OW 12
95855: ARRAY
95856: PPUSH
95857: LD_INT 200
95859: PPUSH
95860: CALL_OW 234
// end ;
95864: PPOPN 1
95866: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95867: LD_EXP 107
95871: PUSH
95872: LD_EXP 136
95876: AND
95877: IFFALSE 95956
95879: GO 95881
95881: DISABLE
95882: LD_INT 0
95884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95885: LD_ADDR_VAR 0 1
95889: PUSH
95890: LD_INT 22
95892: PUSH
95893: LD_OWVAR 2
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: PUSH
95902: LD_INT 21
95904: PUSH
95905: LD_INT 2
95907: PUSH
95908: EMPTY
95909: LIST
95910: LIST
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PPUSH
95916: CALL_OW 69
95920: ST_TO_ADDR
// if not tmp then
95921: LD_VAR 0 1
95925: NOT
95926: IFFALSE 95930
// exit ;
95928: GO 95956
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95930: LD_VAR 0 1
95934: PUSH
95935: LD_INT 1
95937: PPUSH
95938: LD_VAR 0 1
95942: PPUSH
95943: CALL_OW 12
95947: ARRAY
95948: PPUSH
95949: LD_INT 60
95951: PPUSH
95952: CALL_OW 234
// end ;
95956: PPOPN 1
95958: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95959: LD_EXP 107
95963: PUSH
95964: LD_EXP 137
95968: AND
95969: IFFALSE 96068
95971: GO 95973
95973: DISABLE
95974: LD_INT 0
95976: PPUSH
95977: PPUSH
// begin enable ;
95978: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95979: LD_ADDR_VAR 0 1
95983: PUSH
95984: LD_INT 22
95986: PUSH
95987: LD_OWVAR 2
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: PUSH
95996: LD_INT 61
95998: PUSH
95999: EMPTY
96000: LIST
96001: PUSH
96002: LD_INT 33
96004: PUSH
96005: LD_INT 2
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: LIST
96016: PPUSH
96017: CALL_OW 69
96021: ST_TO_ADDR
// if not tmp then
96022: LD_VAR 0 1
96026: NOT
96027: IFFALSE 96031
// exit ;
96029: GO 96068
// for i in tmp do
96031: LD_ADDR_VAR 0 2
96035: PUSH
96036: LD_VAR 0 1
96040: PUSH
96041: FOR_IN
96042: IFFALSE 96066
// if IsControledBy ( i ) then
96044: LD_VAR 0 2
96048: PPUSH
96049: CALL_OW 312
96053: IFFALSE 96064
// ComUnlink ( i ) ;
96055: LD_VAR 0 2
96059: PPUSH
96060: CALL_OW 136
96064: GO 96041
96066: POP
96067: POP
// end ;
96068: PPOPN 2
96070: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96071: LD_EXP 107
96075: PUSH
96076: LD_EXP 138
96080: AND
96081: IFFALSE 96221
96083: GO 96085
96085: DISABLE
96086: LD_INT 0
96088: PPUSH
96089: PPUSH
// begin ToLua ( displayPowell(); ) ;
96090: LD_STRING displayPowell();
96092: PPUSH
96093: CALL_OW 559
// uc_side := 0 ;
96097: LD_ADDR_OWVAR 20
96101: PUSH
96102: LD_INT 0
96104: ST_TO_ADDR
// uc_nation := 2 ;
96105: LD_ADDR_OWVAR 21
96109: PUSH
96110: LD_INT 2
96112: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96113: LD_ADDR_OWVAR 37
96117: PUSH
96118: LD_INT 14
96120: ST_TO_ADDR
// vc_engine := engine_siberite ;
96121: LD_ADDR_OWVAR 39
96125: PUSH
96126: LD_INT 3
96128: ST_TO_ADDR
// vc_control := control_apeman ;
96129: LD_ADDR_OWVAR 38
96133: PUSH
96134: LD_INT 5
96136: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96137: LD_ADDR_OWVAR 40
96141: PUSH
96142: LD_INT 29
96144: ST_TO_ADDR
// un := CreateVehicle ;
96145: LD_ADDR_VAR 0 2
96149: PUSH
96150: CALL_OW 45
96154: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96155: LD_VAR 0 2
96159: PPUSH
96160: LD_INT 1
96162: PPUSH
96163: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96167: LD_INT 35
96169: PPUSH
96170: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96174: LD_VAR 0 2
96178: PPUSH
96179: LD_INT 22
96181: PUSH
96182: LD_OWVAR 2
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PPUSH
96191: CALL_OW 69
96195: PPUSH
96196: LD_VAR 0 2
96200: PPUSH
96201: CALL_OW 74
96205: PPUSH
96206: CALL_OW 115
// until IsDead ( un ) ;
96210: LD_VAR 0 2
96214: PPUSH
96215: CALL_OW 301
96219: IFFALSE 96167
// end ;
96221: PPOPN 2
96223: END
// every 0 0$1 trigger StreamModeActive and sStu do
96224: LD_EXP 107
96228: PUSH
96229: LD_EXP 146
96233: AND
96234: IFFALSE 96250
96236: GO 96238
96238: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96239: LD_STRING displayStucuk();
96241: PPUSH
96242: CALL_OW 559
// ResetFog ;
96246: CALL_OW 335
// end ;
96250: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96251: LD_EXP 107
96255: PUSH
96256: LD_EXP 139
96260: AND
96261: IFFALSE 96402
96263: GO 96265
96265: DISABLE
96266: LD_INT 0
96268: PPUSH
96269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96270: LD_ADDR_VAR 0 2
96274: PUSH
96275: LD_INT 22
96277: PUSH
96278: LD_OWVAR 2
96282: PUSH
96283: EMPTY
96284: LIST
96285: LIST
96286: PUSH
96287: LD_INT 21
96289: PUSH
96290: LD_INT 1
96292: PUSH
96293: EMPTY
96294: LIST
96295: LIST
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PPUSH
96301: CALL_OW 69
96305: ST_TO_ADDR
// if not tmp then
96306: LD_VAR 0 2
96310: NOT
96311: IFFALSE 96315
// exit ;
96313: GO 96402
// un := tmp [ rand ( 1 , tmp ) ] ;
96315: LD_ADDR_VAR 0 1
96319: PUSH
96320: LD_VAR 0 2
96324: PUSH
96325: LD_INT 1
96327: PPUSH
96328: LD_VAR 0 2
96332: PPUSH
96333: CALL_OW 12
96337: ARRAY
96338: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96339: LD_VAR 0 1
96343: PPUSH
96344: LD_INT 0
96346: PPUSH
96347: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96351: LD_VAR 0 1
96355: PPUSH
96356: LD_OWVAR 3
96360: PUSH
96361: LD_VAR 0 1
96365: DIFF
96366: PPUSH
96367: LD_VAR 0 1
96371: PPUSH
96372: CALL_OW 74
96376: PPUSH
96377: CALL_OW 115
// wait ( 0 0$20 ) ;
96381: LD_INT 700
96383: PPUSH
96384: CALL_OW 67
// SetSide ( un , your_side ) ;
96388: LD_VAR 0 1
96392: PPUSH
96393: LD_OWVAR 2
96397: PPUSH
96398: CALL_OW 235
// end ;
96402: PPOPN 2
96404: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96405: LD_EXP 107
96409: PUSH
96410: LD_EXP 140
96414: AND
96415: IFFALSE 96521
96417: GO 96419
96419: DISABLE
96420: LD_INT 0
96422: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96423: LD_ADDR_VAR 0 1
96427: PUSH
96428: LD_INT 22
96430: PUSH
96431: LD_OWVAR 2
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_INT 2
96442: PUSH
96443: LD_INT 30
96445: PUSH
96446: LD_INT 0
96448: PUSH
96449: EMPTY
96450: LIST
96451: LIST
96452: PUSH
96453: LD_INT 30
96455: PUSH
96456: LD_INT 1
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: LIST
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PPUSH
96472: CALL_OW 69
96476: ST_TO_ADDR
// if not depot then
96477: LD_VAR 0 1
96481: NOT
96482: IFFALSE 96486
// exit ;
96484: GO 96521
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96486: LD_VAR 0 1
96490: PUSH
96491: LD_INT 1
96493: ARRAY
96494: PPUSH
96495: CALL_OW 250
96499: PPUSH
96500: LD_VAR 0 1
96504: PUSH
96505: LD_INT 1
96507: ARRAY
96508: PPUSH
96509: CALL_OW 251
96513: PPUSH
96514: LD_INT 70
96516: PPUSH
96517: CALL_OW 495
// end ;
96521: PPOPN 1
96523: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96524: LD_EXP 107
96528: PUSH
96529: LD_EXP 141
96533: AND
96534: IFFALSE 96745
96536: GO 96538
96538: DISABLE
96539: LD_INT 0
96541: PPUSH
96542: PPUSH
96543: PPUSH
96544: PPUSH
96545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96546: LD_ADDR_VAR 0 5
96550: PUSH
96551: LD_INT 22
96553: PUSH
96554: LD_OWVAR 2
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 21
96565: PUSH
96566: LD_INT 1
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PPUSH
96577: CALL_OW 69
96581: ST_TO_ADDR
// if not tmp then
96582: LD_VAR 0 5
96586: NOT
96587: IFFALSE 96591
// exit ;
96589: GO 96745
// for i in tmp do
96591: LD_ADDR_VAR 0 1
96595: PUSH
96596: LD_VAR 0 5
96600: PUSH
96601: FOR_IN
96602: IFFALSE 96743
// begin d := rand ( 0 , 5 ) ;
96604: LD_ADDR_VAR 0 4
96608: PUSH
96609: LD_INT 0
96611: PPUSH
96612: LD_INT 5
96614: PPUSH
96615: CALL_OW 12
96619: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96620: LD_ADDR_VAR 0 2
96624: PUSH
96625: LD_VAR 0 1
96629: PPUSH
96630: CALL_OW 250
96634: PPUSH
96635: LD_VAR 0 4
96639: PPUSH
96640: LD_INT 3
96642: PPUSH
96643: LD_INT 12
96645: PPUSH
96646: CALL_OW 12
96650: PPUSH
96651: CALL_OW 272
96655: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96656: LD_ADDR_VAR 0 3
96660: PUSH
96661: LD_VAR 0 1
96665: PPUSH
96666: CALL_OW 251
96670: PPUSH
96671: LD_VAR 0 4
96675: PPUSH
96676: LD_INT 3
96678: PPUSH
96679: LD_INT 12
96681: PPUSH
96682: CALL_OW 12
96686: PPUSH
96687: CALL_OW 273
96691: ST_TO_ADDR
// if ValidHex ( x , y ) then
96692: LD_VAR 0 2
96696: PPUSH
96697: LD_VAR 0 3
96701: PPUSH
96702: CALL_OW 488
96706: IFFALSE 96741
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96708: LD_VAR 0 1
96712: PPUSH
96713: LD_VAR 0 2
96717: PPUSH
96718: LD_VAR 0 3
96722: PPUSH
96723: LD_INT 3
96725: PPUSH
96726: LD_INT 6
96728: PPUSH
96729: CALL_OW 12
96733: PPUSH
96734: LD_INT 1
96736: PPUSH
96737: CALL_OW 483
// end ;
96741: GO 96601
96743: POP
96744: POP
// end ;
96745: PPOPN 5
96747: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96748: LD_EXP 107
96752: PUSH
96753: LD_EXP 142
96757: AND
96758: IFFALSE 96852
96760: GO 96762
96762: DISABLE
96763: LD_INT 0
96765: PPUSH
96766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96767: LD_ADDR_VAR 0 2
96771: PUSH
96772: LD_INT 22
96774: PUSH
96775: LD_OWVAR 2
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 32
96786: PUSH
96787: LD_INT 1
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: PUSH
96794: LD_INT 21
96796: PUSH
96797: LD_INT 2
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: LIST
96808: PPUSH
96809: CALL_OW 69
96813: ST_TO_ADDR
// if not tmp then
96814: LD_VAR 0 2
96818: NOT
96819: IFFALSE 96823
// exit ;
96821: GO 96852
// for i in tmp do
96823: LD_ADDR_VAR 0 1
96827: PUSH
96828: LD_VAR 0 2
96832: PUSH
96833: FOR_IN
96834: IFFALSE 96850
// SetFuel ( i , 0 ) ;
96836: LD_VAR 0 1
96840: PPUSH
96841: LD_INT 0
96843: PPUSH
96844: CALL_OW 240
96848: GO 96833
96850: POP
96851: POP
// end ;
96852: PPOPN 2
96854: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96855: LD_EXP 107
96859: PUSH
96860: LD_EXP 143
96864: AND
96865: IFFALSE 96931
96867: GO 96869
96869: DISABLE
96870: LD_INT 0
96872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96873: LD_ADDR_VAR 0 1
96877: PUSH
96878: LD_INT 22
96880: PUSH
96881: LD_OWVAR 2
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 30
96892: PUSH
96893: LD_INT 29
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PPUSH
96904: CALL_OW 69
96908: ST_TO_ADDR
// if not tmp then
96909: LD_VAR 0 1
96913: NOT
96914: IFFALSE 96918
// exit ;
96916: GO 96931
// DestroyUnit ( tmp [ 1 ] ) ;
96918: LD_VAR 0 1
96922: PUSH
96923: LD_INT 1
96925: ARRAY
96926: PPUSH
96927: CALL_OW 65
// end ;
96931: PPOPN 1
96933: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96934: LD_EXP 107
96938: PUSH
96939: LD_EXP 145
96943: AND
96944: IFFALSE 97073
96946: GO 96948
96948: DISABLE
96949: LD_INT 0
96951: PPUSH
// begin uc_side := 0 ;
96952: LD_ADDR_OWVAR 20
96956: PUSH
96957: LD_INT 0
96959: ST_TO_ADDR
// uc_nation := nation_arabian ;
96960: LD_ADDR_OWVAR 21
96964: PUSH
96965: LD_INT 2
96967: ST_TO_ADDR
// hc_gallery :=  ;
96968: LD_ADDR_OWVAR 33
96972: PUSH
96973: LD_STRING 
96975: ST_TO_ADDR
// hc_name :=  ;
96976: LD_ADDR_OWVAR 26
96980: PUSH
96981: LD_STRING 
96983: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96984: LD_INT 1
96986: PPUSH
96987: LD_INT 11
96989: PPUSH
96990: LD_INT 10
96992: PPUSH
96993: CALL_OW 380
// un := CreateHuman ;
96997: LD_ADDR_VAR 0 1
97001: PUSH
97002: CALL_OW 44
97006: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97007: LD_VAR 0 1
97011: PPUSH
97012: LD_INT 1
97014: PPUSH
97015: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97019: LD_INT 35
97021: PPUSH
97022: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97026: LD_VAR 0 1
97030: PPUSH
97031: LD_INT 22
97033: PUSH
97034: LD_OWVAR 2
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PPUSH
97043: CALL_OW 69
97047: PPUSH
97048: LD_VAR 0 1
97052: PPUSH
97053: CALL_OW 74
97057: PPUSH
97058: CALL_OW 115
// until IsDead ( un ) ;
97062: LD_VAR 0 1
97066: PPUSH
97067: CALL_OW 301
97071: IFFALSE 97019
// end ;
97073: PPOPN 1
97075: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97076: LD_EXP 107
97080: PUSH
97081: LD_EXP 147
97085: AND
97086: IFFALSE 97098
97088: GO 97090
97090: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97091: LD_STRING earthquake(getX(game), 0, 32)
97093: PPUSH
97094: CALL_OW 559
97098: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97099: LD_EXP 107
97103: PUSH
97104: LD_EXP 148
97108: AND
97109: IFFALSE 97200
97111: GO 97113
97113: DISABLE
97114: LD_INT 0
97116: PPUSH
// begin enable ;
97117: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97118: LD_ADDR_VAR 0 1
97122: PUSH
97123: LD_INT 22
97125: PUSH
97126: LD_OWVAR 2
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 21
97137: PUSH
97138: LD_INT 2
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 33
97147: PUSH
97148: LD_INT 3
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: LIST
97159: PPUSH
97160: CALL_OW 69
97164: ST_TO_ADDR
// if not tmp then
97165: LD_VAR 0 1
97169: NOT
97170: IFFALSE 97174
// exit ;
97172: GO 97200
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97174: LD_VAR 0 1
97178: PUSH
97179: LD_INT 1
97181: PPUSH
97182: LD_VAR 0 1
97186: PPUSH
97187: CALL_OW 12
97191: ARRAY
97192: PPUSH
97193: LD_INT 1
97195: PPUSH
97196: CALL_OW 234
// end ;
97200: PPOPN 1
97202: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97203: LD_EXP 107
97207: PUSH
97208: LD_EXP 149
97212: AND
97213: IFFALSE 97354
97215: GO 97217
97217: DISABLE
97218: LD_INT 0
97220: PPUSH
97221: PPUSH
97222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97223: LD_ADDR_VAR 0 3
97227: PUSH
97228: LD_INT 22
97230: PUSH
97231: LD_OWVAR 2
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 25
97242: PUSH
97243: LD_INT 1
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PPUSH
97254: CALL_OW 69
97258: ST_TO_ADDR
// if not tmp then
97259: LD_VAR 0 3
97263: NOT
97264: IFFALSE 97268
// exit ;
97266: GO 97354
// un := tmp [ rand ( 1 , tmp ) ] ;
97268: LD_ADDR_VAR 0 2
97272: PUSH
97273: LD_VAR 0 3
97277: PUSH
97278: LD_INT 1
97280: PPUSH
97281: LD_VAR 0 3
97285: PPUSH
97286: CALL_OW 12
97290: ARRAY
97291: ST_TO_ADDR
// if Crawls ( un ) then
97292: LD_VAR 0 2
97296: PPUSH
97297: CALL_OW 318
97301: IFFALSE 97312
// ComWalk ( un ) ;
97303: LD_VAR 0 2
97307: PPUSH
97308: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97312: LD_VAR 0 2
97316: PPUSH
97317: LD_INT 9
97319: PPUSH
97320: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97324: LD_INT 28
97326: PPUSH
97327: LD_OWVAR 2
97331: PPUSH
97332: LD_INT 2
97334: PPUSH
97335: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97339: LD_INT 29
97341: PPUSH
97342: LD_OWVAR 2
97346: PPUSH
97347: LD_INT 2
97349: PPUSH
97350: CALL_OW 322
// end ;
97354: PPOPN 3
97356: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97357: LD_EXP 107
97361: PUSH
97362: LD_EXP 150
97366: AND
97367: IFFALSE 97478
97369: GO 97371
97371: DISABLE
97372: LD_INT 0
97374: PPUSH
97375: PPUSH
97376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97377: LD_ADDR_VAR 0 3
97381: PUSH
97382: LD_INT 22
97384: PUSH
97385: LD_OWVAR 2
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: PUSH
97394: LD_INT 25
97396: PUSH
97397: LD_INT 1
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PPUSH
97408: CALL_OW 69
97412: ST_TO_ADDR
// if not tmp then
97413: LD_VAR 0 3
97417: NOT
97418: IFFALSE 97422
// exit ;
97420: GO 97478
// un := tmp [ rand ( 1 , tmp ) ] ;
97422: LD_ADDR_VAR 0 2
97426: PUSH
97427: LD_VAR 0 3
97431: PUSH
97432: LD_INT 1
97434: PPUSH
97435: LD_VAR 0 3
97439: PPUSH
97440: CALL_OW 12
97444: ARRAY
97445: ST_TO_ADDR
// if Crawls ( un ) then
97446: LD_VAR 0 2
97450: PPUSH
97451: CALL_OW 318
97455: IFFALSE 97466
// ComWalk ( un ) ;
97457: LD_VAR 0 2
97461: PPUSH
97462: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97466: LD_VAR 0 2
97470: PPUSH
97471: LD_INT 8
97473: PPUSH
97474: CALL_OW 336
// end ;
97478: PPOPN 3
97480: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97481: LD_EXP 107
97485: PUSH
97486: LD_EXP 151
97490: AND
97491: IFFALSE 97635
97493: GO 97495
97495: DISABLE
97496: LD_INT 0
97498: PPUSH
97499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97500: LD_ADDR_VAR 0 2
97504: PUSH
97505: LD_INT 22
97507: PUSH
97508: LD_OWVAR 2
97512: PUSH
97513: EMPTY
97514: LIST
97515: LIST
97516: PUSH
97517: LD_INT 21
97519: PUSH
97520: LD_INT 2
97522: PUSH
97523: EMPTY
97524: LIST
97525: LIST
97526: PUSH
97527: LD_INT 2
97529: PUSH
97530: LD_INT 34
97532: PUSH
97533: LD_INT 12
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: LD_INT 34
97542: PUSH
97543: LD_INT 51
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 34
97552: PUSH
97553: LD_INT 32
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: LIST
97570: PPUSH
97571: CALL_OW 69
97575: ST_TO_ADDR
// if not tmp then
97576: LD_VAR 0 2
97580: NOT
97581: IFFALSE 97585
// exit ;
97583: GO 97635
// for i in tmp do
97585: LD_ADDR_VAR 0 1
97589: PUSH
97590: LD_VAR 0 2
97594: PUSH
97595: FOR_IN
97596: IFFALSE 97633
// if GetCargo ( i , mat_artifact ) = 0 then
97598: LD_VAR 0 1
97602: PPUSH
97603: LD_INT 4
97605: PPUSH
97606: CALL_OW 289
97610: PUSH
97611: LD_INT 0
97613: EQUAL
97614: IFFALSE 97631
// SetCargo ( i , mat_siberit , 100 ) ;
97616: LD_VAR 0 1
97620: PPUSH
97621: LD_INT 3
97623: PPUSH
97624: LD_INT 100
97626: PPUSH
97627: CALL_OW 290
97631: GO 97595
97633: POP
97634: POP
// end ;
97635: PPOPN 2
97637: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97638: LD_EXP 107
97642: PUSH
97643: LD_EXP 152
97647: AND
97648: IFFALSE 97831
97650: GO 97652
97652: DISABLE
97653: LD_INT 0
97655: PPUSH
97656: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97657: LD_ADDR_VAR 0 2
97661: PUSH
97662: LD_INT 22
97664: PUSH
97665: LD_OWVAR 2
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: PPUSH
97674: CALL_OW 69
97678: ST_TO_ADDR
// if not tmp then
97679: LD_VAR 0 2
97683: NOT
97684: IFFALSE 97688
// exit ;
97686: GO 97831
// for i := 1 to 2 do
97688: LD_ADDR_VAR 0 1
97692: PUSH
97693: DOUBLE
97694: LD_INT 1
97696: DEC
97697: ST_TO_ADDR
97698: LD_INT 2
97700: PUSH
97701: FOR_TO
97702: IFFALSE 97829
// begin uc_side := your_side ;
97704: LD_ADDR_OWVAR 20
97708: PUSH
97709: LD_OWVAR 2
97713: ST_TO_ADDR
// uc_nation := nation_american ;
97714: LD_ADDR_OWVAR 21
97718: PUSH
97719: LD_INT 1
97721: ST_TO_ADDR
// vc_chassis := us_morphling ;
97722: LD_ADDR_OWVAR 37
97726: PUSH
97727: LD_INT 5
97729: ST_TO_ADDR
// vc_engine := engine_siberite ;
97730: LD_ADDR_OWVAR 39
97734: PUSH
97735: LD_INT 3
97737: ST_TO_ADDR
// vc_control := control_computer ;
97738: LD_ADDR_OWVAR 38
97742: PUSH
97743: LD_INT 3
97745: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97746: LD_ADDR_OWVAR 40
97750: PUSH
97751: LD_INT 10
97753: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97754: LD_VAR 0 2
97758: PUSH
97759: LD_INT 1
97761: ARRAY
97762: PPUSH
97763: CALL_OW 310
97767: NOT
97768: IFFALSE 97815
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97770: CALL_OW 45
97774: PPUSH
97775: LD_VAR 0 2
97779: PUSH
97780: LD_INT 1
97782: ARRAY
97783: PPUSH
97784: CALL_OW 250
97788: PPUSH
97789: LD_VAR 0 2
97793: PUSH
97794: LD_INT 1
97796: ARRAY
97797: PPUSH
97798: CALL_OW 251
97802: PPUSH
97803: LD_INT 12
97805: PPUSH
97806: LD_INT 1
97808: PPUSH
97809: CALL_OW 50
97813: GO 97827
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97815: CALL_OW 45
97819: PPUSH
97820: LD_INT 1
97822: PPUSH
97823: CALL_OW 51
// end ;
97827: GO 97701
97829: POP
97830: POP
// end ;
97831: PPOPN 2
97833: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97834: LD_EXP 107
97838: PUSH
97839: LD_EXP 153
97843: AND
97844: IFFALSE 98066
97846: GO 97848
97848: DISABLE
97849: LD_INT 0
97851: PPUSH
97852: PPUSH
97853: PPUSH
97854: PPUSH
97855: PPUSH
97856: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97857: LD_ADDR_VAR 0 6
97861: PUSH
97862: LD_INT 22
97864: PUSH
97865: LD_OWVAR 2
97869: PUSH
97870: EMPTY
97871: LIST
97872: LIST
97873: PUSH
97874: LD_INT 21
97876: PUSH
97877: LD_INT 1
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: PUSH
97884: LD_INT 3
97886: PUSH
97887: LD_INT 23
97889: PUSH
97890: LD_INT 0
97892: PUSH
97893: EMPTY
97894: LIST
97895: LIST
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: PUSH
97901: EMPTY
97902: LIST
97903: LIST
97904: LIST
97905: PPUSH
97906: CALL_OW 69
97910: ST_TO_ADDR
// if not tmp then
97911: LD_VAR 0 6
97915: NOT
97916: IFFALSE 97920
// exit ;
97918: GO 98066
// s1 := rand ( 1 , 4 ) ;
97920: LD_ADDR_VAR 0 2
97924: PUSH
97925: LD_INT 1
97927: PPUSH
97928: LD_INT 4
97930: PPUSH
97931: CALL_OW 12
97935: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97936: LD_ADDR_VAR 0 4
97940: PUSH
97941: LD_VAR 0 6
97945: PUSH
97946: LD_INT 1
97948: ARRAY
97949: PPUSH
97950: LD_VAR 0 2
97954: PPUSH
97955: CALL_OW 259
97959: ST_TO_ADDR
// if s1 = 1 then
97960: LD_VAR 0 2
97964: PUSH
97965: LD_INT 1
97967: EQUAL
97968: IFFALSE 97988
// s2 := rand ( 2 , 4 ) else
97970: LD_ADDR_VAR 0 3
97974: PUSH
97975: LD_INT 2
97977: PPUSH
97978: LD_INT 4
97980: PPUSH
97981: CALL_OW 12
97985: ST_TO_ADDR
97986: GO 97996
// s2 := 1 ;
97988: LD_ADDR_VAR 0 3
97992: PUSH
97993: LD_INT 1
97995: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97996: LD_ADDR_VAR 0 5
98000: PUSH
98001: LD_VAR 0 6
98005: PUSH
98006: LD_INT 1
98008: ARRAY
98009: PPUSH
98010: LD_VAR 0 3
98014: PPUSH
98015: CALL_OW 259
98019: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98020: LD_VAR 0 6
98024: PUSH
98025: LD_INT 1
98027: ARRAY
98028: PPUSH
98029: LD_VAR 0 2
98033: PPUSH
98034: LD_VAR 0 5
98038: PPUSH
98039: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98043: LD_VAR 0 6
98047: PUSH
98048: LD_INT 1
98050: ARRAY
98051: PPUSH
98052: LD_VAR 0 3
98056: PPUSH
98057: LD_VAR 0 4
98061: PPUSH
98062: CALL_OW 237
// end ;
98066: PPOPN 6
98068: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98069: LD_EXP 107
98073: PUSH
98074: LD_EXP 154
98078: AND
98079: IFFALSE 98158
98081: GO 98083
98083: DISABLE
98084: LD_INT 0
98086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98087: LD_ADDR_VAR 0 1
98091: PUSH
98092: LD_INT 22
98094: PUSH
98095: LD_OWVAR 2
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_INT 30
98106: PUSH
98107: LD_INT 3
98109: PUSH
98110: EMPTY
98111: LIST
98112: LIST
98113: PUSH
98114: EMPTY
98115: LIST
98116: LIST
98117: PPUSH
98118: CALL_OW 69
98122: ST_TO_ADDR
// if not tmp then
98123: LD_VAR 0 1
98127: NOT
98128: IFFALSE 98132
// exit ;
98130: GO 98158
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98132: LD_VAR 0 1
98136: PUSH
98137: LD_INT 1
98139: PPUSH
98140: LD_VAR 0 1
98144: PPUSH
98145: CALL_OW 12
98149: ARRAY
98150: PPUSH
98151: LD_INT 1
98153: PPUSH
98154: CALL_OW 234
// end ;
98158: PPOPN 1
98160: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98161: LD_EXP 107
98165: PUSH
98166: LD_EXP 155
98170: AND
98171: IFFALSE 98283
98173: GO 98175
98175: DISABLE
98176: LD_INT 0
98178: PPUSH
98179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98180: LD_ADDR_VAR 0 2
98184: PUSH
98185: LD_INT 22
98187: PUSH
98188: LD_OWVAR 2
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: LD_INT 2
98199: PUSH
98200: LD_INT 30
98202: PUSH
98203: LD_INT 27
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: PUSH
98210: LD_INT 30
98212: PUSH
98213: LD_INT 26
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: PUSH
98220: LD_INT 30
98222: PUSH
98223: LD_INT 28
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: EMPTY
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: PUSH
98236: EMPTY
98237: LIST
98238: LIST
98239: PPUSH
98240: CALL_OW 69
98244: ST_TO_ADDR
// if not tmp then
98245: LD_VAR 0 2
98249: NOT
98250: IFFALSE 98254
// exit ;
98252: GO 98283
// for i in tmp do
98254: LD_ADDR_VAR 0 1
98258: PUSH
98259: LD_VAR 0 2
98263: PUSH
98264: FOR_IN
98265: IFFALSE 98281
// SetLives ( i , 1 ) ;
98267: LD_VAR 0 1
98271: PPUSH
98272: LD_INT 1
98274: PPUSH
98275: CALL_OW 234
98279: GO 98264
98281: POP
98282: POP
// end ;
98283: PPOPN 2
98285: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98286: LD_EXP 107
98290: PUSH
98291: LD_EXP 156
98295: AND
98296: IFFALSE 98583
98298: GO 98300
98300: DISABLE
98301: LD_INT 0
98303: PPUSH
98304: PPUSH
98305: PPUSH
// begin i := rand ( 1 , 7 ) ;
98306: LD_ADDR_VAR 0 1
98310: PUSH
98311: LD_INT 1
98313: PPUSH
98314: LD_INT 7
98316: PPUSH
98317: CALL_OW 12
98321: ST_TO_ADDR
// case i of 1 :
98322: LD_VAR 0 1
98326: PUSH
98327: LD_INT 1
98329: DOUBLE
98330: EQUAL
98331: IFTRUE 98335
98333: GO 98345
98335: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98336: LD_STRING earthquake(getX(game), 0, 32)
98338: PPUSH
98339: CALL_OW 559
98343: GO 98583
98345: LD_INT 2
98347: DOUBLE
98348: EQUAL
98349: IFTRUE 98353
98351: GO 98367
98353: POP
// begin ToLua ( displayStucuk(); ) ;
98354: LD_STRING displayStucuk();
98356: PPUSH
98357: CALL_OW 559
// ResetFog ;
98361: CALL_OW 335
// end ; 3 :
98365: GO 98583
98367: LD_INT 3
98369: DOUBLE
98370: EQUAL
98371: IFTRUE 98375
98373: GO 98479
98375: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98376: LD_ADDR_VAR 0 2
98380: PUSH
98381: LD_INT 22
98383: PUSH
98384: LD_OWVAR 2
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: PUSH
98393: LD_INT 25
98395: PUSH
98396: LD_INT 1
98398: PUSH
98399: EMPTY
98400: LIST
98401: LIST
98402: PUSH
98403: EMPTY
98404: LIST
98405: LIST
98406: PPUSH
98407: CALL_OW 69
98411: ST_TO_ADDR
// if not tmp then
98412: LD_VAR 0 2
98416: NOT
98417: IFFALSE 98421
// exit ;
98419: GO 98583
// un := tmp [ rand ( 1 , tmp ) ] ;
98421: LD_ADDR_VAR 0 3
98425: PUSH
98426: LD_VAR 0 2
98430: PUSH
98431: LD_INT 1
98433: PPUSH
98434: LD_VAR 0 2
98438: PPUSH
98439: CALL_OW 12
98443: ARRAY
98444: ST_TO_ADDR
// if Crawls ( un ) then
98445: LD_VAR 0 3
98449: PPUSH
98450: CALL_OW 318
98454: IFFALSE 98465
// ComWalk ( un ) ;
98456: LD_VAR 0 3
98460: PPUSH
98461: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98465: LD_VAR 0 3
98469: PPUSH
98470: LD_INT 8
98472: PPUSH
98473: CALL_OW 336
// end ; 4 :
98477: GO 98583
98479: LD_INT 4
98481: DOUBLE
98482: EQUAL
98483: IFTRUE 98487
98485: GO 98561
98487: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98488: LD_ADDR_VAR 0 2
98492: PUSH
98493: LD_INT 22
98495: PUSH
98496: LD_OWVAR 2
98500: PUSH
98501: EMPTY
98502: LIST
98503: LIST
98504: PUSH
98505: LD_INT 30
98507: PUSH
98508: LD_INT 29
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PPUSH
98519: CALL_OW 69
98523: ST_TO_ADDR
// if not tmp then
98524: LD_VAR 0 2
98528: NOT
98529: IFFALSE 98533
// exit ;
98531: GO 98583
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98533: LD_VAR 0 2
98537: PUSH
98538: LD_INT 1
98540: ARRAY
98541: PPUSH
98542: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98546: LD_VAR 0 2
98550: PUSH
98551: LD_INT 1
98553: ARRAY
98554: PPUSH
98555: CALL_OW 65
// end ; 5 .. 7 :
98559: GO 98583
98561: LD_INT 5
98563: DOUBLE
98564: GREATEREQUAL
98565: IFFALSE 98573
98567: LD_INT 7
98569: DOUBLE
98570: LESSEQUAL
98571: IFTRUE 98575
98573: GO 98582
98575: POP
// StreamSibBomb ; end ;
98576: CALL 94820 0 0
98580: GO 98583
98582: POP
// end ;
98583: PPOPN 3
98585: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98586: LD_EXP 107
98590: PUSH
98591: LD_EXP 157
98595: AND
98596: IFFALSE 98752
98598: GO 98600
98600: DISABLE
98601: LD_INT 0
98603: PPUSH
98604: PPUSH
98605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98606: LD_ADDR_VAR 0 2
98610: PUSH
98611: LD_INT 81
98613: PUSH
98614: LD_OWVAR 2
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: PUSH
98623: LD_INT 2
98625: PUSH
98626: LD_INT 21
98628: PUSH
98629: LD_INT 1
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 21
98638: PUSH
98639: LD_INT 2
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PUSH
98646: EMPTY
98647: LIST
98648: LIST
98649: LIST
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: PPUSH
98655: CALL_OW 69
98659: ST_TO_ADDR
// if not tmp then
98660: LD_VAR 0 2
98664: NOT
98665: IFFALSE 98669
// exit ;
98667: GO 98752
// p := 0 ;
98669: LD_ADDR_VAR 0 3
98673: PUSH
98674: LD_INT 0
98676: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98677: LD_INT 35
98679: PPUSH
98680: CALL_OW 67
// p := p + 1 ;
98684: LD_ADDR_VAR 0 3
98688: PUSH
98689: LD_VAR 0 3
98693: PUSH
98694: LD_INT 1
98696: PLUS
98697: ST_TO_ADDR
// for i in tmp do
98698: LD_ADDR_VAR 0 1
98702: PUSH
98703: LD_VAR 0 2
98707: PUSH
98708: FOR_IN
98709: IFFALSE 98740
// if GetLives ( i ) < 1000 then
98711: LD_VAR 0 1
98715: PPUSH
98716: CALL_OW 256
98720: PUSH
98721: LD_INT 1000
98723: LESS
98724: IFFALSE 98738
// SetLives ( i , 1000 ) ;
98726: LD_VAR 0 1
98730: PPUSH
98731: LD_INT 1000
98733: PPUSH
98734: CALL_OW 234
98738: GO 98708
98740: POP
98741: POP
// until p > 20 ;
98742: LD_VAR 0 3
98746: PUSH
98747: LD_INT 20
98749: GREATER
98750: IFFALSE 98677
// end ;
98752: PPOPN 3
98754: END
// every 0 0$1 trigger StreamModeActive and sTime do
98755: LD_EXP 107
98759: PUSH
98760: LD_EXP 158
98764: AND
98765: IFFALSE 98800
98767: GO 98769
98769: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98770: LD_INT 28
98772: PPUSH
98773: LD_OWVAR 2
98777: PPUSH
98778: LD_INT 2
98780: PPUSH
98781: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98785: LD_INT 30
98787: PPUSH
98788: LD_OWVAR 2
98792: PPUSH
98793: LD_INT 2
98795: PPUSH
98796: CALL_OW 322
// end ;
98800: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98801: LD_EXP 107
98805: PUSH
98806: LD_EXP 159
98810: AND
98811: IFFALSE 98932
98813: GO 98815
98815: DISABLE
98816: LD_INT 0
98818: PPUSH
98819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98820: LD_ADDR_VAR 0 2
98824: PUSH
98825: LD_INT 22
98827: PUSH
98828: LD_OWVAR 2
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: PUSH
98837: LD_INT 21
98839: PUSH
98840: LD_INT 1
98842: PUSH
98843: EMPTY
98844: LIST
98845: LIST
98846: PUSH
98847: LD_INT 3
98849: PUSH
98850: LD_INT 23
98852: PUSH
98853: LD_INT 0
98855: PUSH
98856: EMPTY
98857: LIST
98858: LIST
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: EMPTY
98865: LIST
98866: LIST
98867: LIST
98868: PPUSH
98869: CALL_OW 69
98873: ST_TO_ADDR
// if not tmp then
98874: LD_VAR 0 2
98878: NOT
98879: IFFALSE 98883
// exit ;
98881: GO 98932
// for i in tmp do
98883: LD_ADDR_VAR 0 1
98887: PUSH
98888: LD_VAR 0 2
98892: PUSH
98893: FOR_IN
98894: IFFALSE 98930
// begin if Crawls ( i ) then
98896: LD_VAR 0 1
98900: PPUSH
98901: CALL_OW 318
98905: IFFALSE 98916
// ComWalk ( i ) ;
98907: LD_VAR 0 1
98911: PPUSH
98912: CALL_OW 138
// SetClass ( i , 2 ) ;
98916: LD_VAR 0 1
98920: PPUSH
98921: LD_INT 2
98923: PPUSH
98924: CALL_OW 336
// end ;
98928: GO 98893
98930: POP
98931: POP
// end ;
98932: PPOPN 2
98934: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98935: LD_EXP 107
98939: PUSH
98940: LD_EXP 160
98944: AND
98945: IFFALSE 99233
98947: GO 98949
98949: DISABLE
98950: LD_INT 0
98952: PPUSH
98953: PPUSH
98954: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98955: LD_OWVAR 2
98959: PPUSH
98960: LD_INT 9
98962: PPUSH
98963: LD_INT 1
98965: PPUSH
98966: LD_INT 1
98968: PPUSH
98969: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98973: LD_INT 9
98975: PPUSH
98976: LD_OWVAR 2
98980: PPUSH
98981: CALL_OW 343
// uc_side := 9 ;
98985: LD_ADDR_OWVAR 20
98989: PUSH
98990: LD_INT 9
98992: ST_TO_ADDR
// uc_nation := 2 ;
98993: LD_ADDR_OWVAR 21
98997: PUSH
98998: LD_INT 2
99000: ST_TO_ADDR
// hc_name := Dark Warrior ;
99001: LD_ADDR_OWVAR 26
99005: PUSH
99006: LD_STRING Dark Warrior
99008: ST_TO_ADDR
// hc_gallery :=  ;
99009: LD_ADDR_OWVAR 33
99013: PUSH
99014: LD_STRING 
99016: ST_TO_ADDR
// hc_noskilllimit := true ;
99017: LD_ADDR_OWVAR 76
99021: PUSH
99022: LD_INT 1
99024: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99025: LD_ADDR_OWVAR 31
99029: PUSH
99030: LD_INT 30
99032: PUSH
99033: LD_INT 30
99035: PUSH
99036: LD_INT 30
99038: PUSH
99039: LD_INT 30
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: ST_TO_ADDR
// un := CreateHuman ;
99048: LD_ADDR_VAR 0 3
99052: PUSH
99053: CALL_OW 44
99057: ST_TO_ADDR
// hc_noskilllimit := false ;
99058: LD_ADDR_OWVAR 76
99062: PUSH
99063: LD_INT 0
99065: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99066: LD_VAR 0 3
99070: PPUSH
99071: LD_INT 1
99073: PPUSH
99074: CALL_OW 51
// ToLua ( playRanger() ) ;
99078: LD_STRING playRanger()
99080: PPUSH
99081: CALL_OW 559
// p := 0 ;
99085: LD_ADDR_VAR 0 2
99089: PUSH
99090: LD_INT 0
99092: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99093: LD_INT 35
99095: PPUSH
99096: CALL_OW 67
// p := p + 1 ;
99100: LD_ADDR_VAR 0 2
99104: PUSH
99105: LD_VAR 0 2
99109: PUSH
99110: LD_INT 1
99112: PLUS
99113: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99114: LD_VAR 0 3
99118: PPUSH
99119: CALL_OW 256
99123: PUSH
99124: LD_INT 1000
99126: LESS
99127: IFFALSE 99141
// SetLives ( un , 1000 ) ;
99129: LD_VAR 0 3
99133: PPUSH
99134: LD_INT 1000
99136: PPUSH
99137: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99141: LD_VAR 0 3
99145: PPUSH
99146: LD_INT 81
99148: PUSH
99149: LD_OWVAR 2
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PUSH
99158: LD_INT 91
99160: PUSH
99161: LD_VAR 0 3
99165: PUSH
99166: LD_INT 30
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PPUSH
99178: CALL_OW 69
99182: PPUSH
99183: LD_VAR 0 3
99187: PPUSH
99188: CALL_OW 74
99192: PPUSH
99193: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99197: LD_VAR 0 2
99201: PUSH
99202: LD_INT 80
99204: GREATER
99205: PUSH
99206: LD_VAR 0 3
99210: PPUSH
99211: CALL_OW 301
99215: OR
99216: IFFALSE 99093
// if un then
99218: LD_VAR 0 3
99222: IFFALSE 99233
// RemoveUnit ( un ) ;
99224: LD_VAR 0 3
99228: PPUSH
99229: CALL_OW 64
// end ;
99233: PPOPN 3
99235: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99236: LD_EXP 161
99240: IFFALSE 99356
99242: GO 99244
99244: DISABLE
99245: LD_INT 0
99247: PPUSH
99248: PPUSH
99249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99250: LD_ADDR_VAR 0 2
99254: PUSH
99255: LD_INT 81
99257: PUSH
99258: LD_OWVAR 2
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: PUSH
99267: LD_INT 21
99269: PUSH
99270: LD_INT 1
99272: PUSH
99273: EMPTY
99274: LIST
99275: LIST
99276: PUSH
99277: EMPTY
99278: LIST
99279: LIST
99280: PPUSH
99281: CALL_OW 69
99285: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99286: LD_STRING playComputer()
99288: PPUSH
99289: CALL_OW 559
// if not tmp then
99293: LD_VAR 0 2
99297: NOT
99298: IFFALSE 99302
// exit ;
99300: GO 99356
// for i in tmp do
99302: LD_ADDR_VAR 0 1
99306: PUSH
99307: LD_VAR 0 2
99311: PUSH
99312: FOR_IN
99313: IFFALSE 99354
// for j := 1 to 4 do
99315: LD_ADDR_VAR 0 3
99319: PUSH
99320: DOUBLE
99321: LD_INT 1
99323: DEC
99324: ST_TO_ADDR
99325: LD_INT 4
99327: PUSH
99328: FOR_TO
99329: IFFALSE 99350
// SetSkill ( i , j , 10 ) ;
99331: LD_VAR 0 1
99335: PPUSH
99336: LD_VAR 0 3
99340: PPUSH
99341: LD_INT 10
99343: PPUSH
99344: CALL_OW 237
99348: GO 99328
99350: POP
99351: POP
99352: GO 99312
99354: POP
99355: POP
// end ;
99356: PPOPN 3
99358: END
// every 0 0$1 trigger s30 do var i , tmp ;
99359: LD_EXP 162
99363: IFFALSE 99432
99365: GO 99367
99367: DISABLE
99368: LD_INT 0
99370: PPUSH
99371: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99372: LD_ADDR_VAR 0 2
99376: PUSH
99377: LD_INT 22
99379: PUSH
99380: LD_OWVAR 2
99384: PUSH
99385: EMPTY
99386: LIST
99387: LIST
99388: PPUSH
99389: CALL_OW 69
99393: ST_TO_ADDR
// if not tmp then
99394: LD_VAR 0 2
99398: NOT
99399: IFFALSE 99403
// exit ;
99401: GO 99432
// for i in tmp do
99403: LD_ADDR_VAR 0 1
99407: PUSH
99408: LD_VAR 0 2
99412: PUSH
99413: FOR_IN
99414: IFFALSE 99430
// SetLives ( i , 300 ) ;
99416: LD_VAR 0 1
99420: PPUSH
99421: LD_INT 300
99423: PPUSH
99424: CALL_OW 234
99428: GO 99413
99430: POP
99431: POP
// end ;
99432: PPOPN 2
99434: END
// every 0 0$1 trigger s60 do var i , tmp ;
99435: LD_EXP 163
99439: IFFALSE 99508
99441: GO 99443
99443: DISABLE
99444: LD_INT 0
99446: PPUSH
99447: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99448: LD_ADDR_VAR 0 2
99452: PUSH
99453: LD_INT 22
99455: PUSH
99456: LD_OWVAR 2
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PPUSH
99465: CALL_OW 69
99469: ST_TO_ADDR
// if not tmp then
99470: LD_VAR 0 2
99474: NOT
99475: IFFALSE 99479
// exit ;
99477: GO 99508
// for i in tmp do
99479: LD_ADDR_VAR 0 1
99483: PUSH
99484: LD_VAR 0 2
99488: PUSH
99489: FOR_IN
99490: IFFALSE 99506
// SetLives ( i , 600 ) ;
99492: LD_VAR 0 1
99496: PPUSH
99497: LD_INT 600
99499: PPUSH
99500: CALL_OW 234
99504: GO 99489
99506: POP
99507: POP
// end ;
99508: PPOPN 2
99510: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99511: LD_INT 0
99513: PPUSH
// case cmd of 301 :
99514: LD_VAR 0 1
99518: PUSH
99519: LD_INT 301
99521: DOUBLE
99522: EQUAL
99523: IFTRUE 99527
99525: GO 99559
99527: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99528: LD_VAR 0 6
99532: PPUSH
99533: LD_VAR 0 7
99537: PPUSH
99538: LD_VAR 0 8
99542: PPUSH
99543: LD_VAR 0 4
99547: PPUSH
99548: LD_VAR 0 5
99552: PPUSH
99553: CALL 100760 0 5
99557: GO 99680
99559: LD_INT 302
99561: DOUBLE
99562: EQUAL
99563: IFTRUE 99567
99565: GO 99604
99567: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99568: LD_VAR 0 6
99572: PPUSH
99573: LD_VAR 0 7
99577: PPUSH
99578: LD_VAR 0 8
99582: PPUSH
99583: LD_VAR 0 9
99587: PPUSH
99588: LD_VAR 0 4
99592: PPUSH
99593: LD_VAR 0 5
99597: PPUSH
99598: CALL 100851 0 6
99602: GO 99680
99604: LD_INT 303
99606: DOUBLE
99607: EQUAL
99608: IFTRUE 99612
99610: GO 99649
99612: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99613: LD_VAR 0 6
99617: PPUSH
99618: LD_VAR 0 7
99622: PPUSH
99623: LD_VAR 0 8
99627: PPUSH
99628: LD_VAR 0 9
99632: PPUSH
99633: LD_VAR 0 4
99637: PPUSH
99638: LD_VAR 0 5
99642: PPUSH
99643: CALL 99685 0 6
99647: GO 99680
99649: LD_INT 304
99651: DOUBLE
99652: EQUAL
99653: IFTRUE 99657
99655: GO 99679
99657: POP
// hHackTeleport ( unit , x , y ) ; end ;
99658: LD_VAR 0 2
99662: PPUSH
99663: LD_VAR 0 4
99667: PPUSH
99668: LD_VAR 0 5
99672: PPUSH
99673: CALL 101444 0 3
99677: GO 99680
99679: POP
// end ;
99680: LD_VAR 0 12
99684: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99685: LD_INT 0
99687: PPUSH
99688: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99689: LD_VAR 0 1
99693: PUSH
99694: LD_INT 1
99696: LESS
99697: PUSH
99698: LD_VAR 0 1
99702: PUSH
99703: LD_INT 3
99705: GREATER
99706: OR
99707: PUSH
99708: LD_VAR 0 5
99712: PPUSH
99713: LD_VAR 0 6
99717: PPUSH
99718: CALL_OW 428
99722: OR
99723: IFFALSE 99727
// exit ;
99725: GO 100447
// uc_side := your_side ;
99727: LD_ADDR_OWVAR 20
99731: PUSH
99732: LD_OWVAR 2
99736: ST_TO_ADDR
// uc_nation := nation ;
99737: LD_ADDR_OWVAR 21
99741: PUSH
99742: LD_VAR 0 1
99746: ST_TO_ADDR
// bc_level = 1 ;
99747: LD_ADDR_OWVAR 43
99751: PUSH
99752: LD_INT 1
99754: ST_TO_ADDR
// case btype of 1 :
99755: LD_VAR 0 2
99759: PUSH
99760: LD_INT 1
99762: DOUBLE
99763: EQUAL
99764: IFTRUE 99768
99766: GO 99779
99768: POP
// bc_type := b_depot ; 2 :
99769: LD_ADDR_OWVAR 42
99773: PUSH
99774: LD_INT 0
99776: ST_TO_ADDR
99777: GO 100391
99779: LD_INT 2
99781: DOUBLE
99782: EQUAL
99783: IFTRUE 99787
99785: GO 99798
99787: POP
// bc_type := b_warehouse ; 3 :
99788: LD_ADDR_OWVAR 42
99792: PUSH
99793: LD_INT 1
99795: ST_TO_ADDR
99796: GO 100391
99798: LD_INT 3
99800: DOUBLE
99801: EQUAL
99802: IFTRUE 99806
99804: GO 99817
99806: POP
// bc_type := b_lab ; 4 .. 9 :
99807: LD_ADDR_OWVAR 42
99811: PUSH
99812: LD_INT 6
99814: ST_TO_ADDR
99815: GO 100391
99817: LD_INT 4
99819: DOUBLE
99820: GREATEREQUAL
99821: IFFALSE 99829
99823: LD_INT 9
99825: DOUBLE
99826: LESSEQUAL
99827: IFTRUE 99831
99829: GO 99883
99831: POP
// begin bc_type := b_lab_half ;
99832: LD_ADDR_OWVAR 42
99836: PUSH
99837: LD_INT 7
99839: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99840: LD_ADDR_OWVAR 44
99844: PUSH
99845: LD_INT 10
99847: PUSH
99848: LD_INT 11
99850: PUSH
99851: LD_INT 12
99853: PUSH
99854: LD_INT 15
99856: PUSH
99857: LD_INT 14
99859: PUSH
99860: LD_INT 13
99862: PUSH
99863: EMPTY
99864: LIST
99865: LIST
99866: LIST
99867: LIST
99868: LIST
99869: LIST
99870: PUSH
99871: LD_VAR 0 2
99875: PUSH
99876: LD_INT 3
99878: MINUS
99879: ARRAY
99880: ST_TO_ADDR
// end ; 10 .. 13 :
99881: GO 100391
99883: LD_INT 10
99885: DOUBLE
99886: GREATEREQUAL
99887: IFFALSE 99895
99889: LD_INT 13
99891: DOUBLE
99892: LESSEQUAL
99893: IFTRUE 99897
99895: GO 99974
99897: POP
// begin bc_type := b_lab_full ;
99898: LD_ADDR_OWVAR 42
99902: PUSH
99903: LD_INT 8
99905: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99906: LD_ADDR_OWVAR 44
99910: PUSH
99911: LD_INT 10
99913: PUSH
99914: LD_INT 12
99916: PUSH
99917: LD_INT 14
99919: PUSH
99920: LD_INT 13
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: PUSH
99929: LD_VAR 0 2
99933: PUSH
99934: LD_INT 9
99936: MINUS
99937: ARRAY
99938: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99939: LD_ADDR_OWVAR 45
99943: PUSH
99944: LD_INT 11
99946: PUSH
99947: LD_INT 15
99949: PUSH
99950: LD_INT 12
99952: PUSH
99953: LD_INT 15
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: PUSH
99962: LD_VAR 0 2
99966: PUSH
99967: LD_INT 9
99969: MINUS
99970: ARRAY
99971: ST_TO_ADDR
// end ; 14 :
99972: GO 100391
99974: LD_INT 14
99976: DOUBLE
99977: EQUAL
99978: IFTRUE 99982
99980: GO 99993
99982: POP
// bc_type := b_workshop ; 15 :
99983: LD_ADDR_OWVAR 42
99987: PUSH
99988: LD_INT 2
99990: ST_TO_ADDR
99991: GO 100391
99993: LD_INT 15
99995: DOUBLE
99996: EQUAL
99997: IFTRUE 100001
99999: GO 100012
100001: POP
// bc_type := b_factory ; 16 :
100002: LD_ADDR_OWVAR 42
100006: PUSH
100007: LD_INT 3
100009: ST_TO_ADDR
100010: GO 100391
100012: LD_INT 16
100014: DOUBLE
100015: EQUAL
100016: IFTRUE 100020
100018: GO 100031
100020: POP
// bc_type := b_ext_gun ; 17 :
100021: LD_ADDR_OWVAR 42
100025: PUSH
100026: LD_INT 17
100028: ST_TO_ADDR
100029: GO 100391
100031: LD_INT 17
100033: DOUBLE
100034: EQUAL
100035: IFTRUE 100039
100037: GO 100067
100039: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100040: LD_ADDR_OWVAR 42
100044: PUSH
100045: LD_INT 19
100047: PUSH
100048: LD_INT 23
100050: PUSH
100051: LD_INT 19
100053: PUSH
100054: EMPTY
100055: LIST
100056: LIST
100057: LIST
100058: PUSH
100059: LD_VAR 0 1
100063: ARRAY
100064: ST_TO_ADDR
100065: GO 100391
100067: LD_INT 18
100069: DOUBLE
100070: EQUAL
100071: IFTRUE 100075
100073: GO 100086
100075: POP
// bc_type := b_ext_radar ; 19 :
100076: LD_ADDR_OWVAR 42
100080: PUSH
100081: LD_INT 20
100083: ST_TO_ADDR
100084: GO 100391
100086: LD_INT 19
100088: DOUBLE
100089: EQUAL
100090: IFTRUE 100094
100092: GO 100105
100094: POP
// bc_type := b_ext_radio ; 20 :
100095: LD_ADDR_OWVAR 42
100099: PUSH
100100: LD_INT 22
100102: ST_TO_ADDR
100103: GO 100391
100105: LD_INT 20
100107: DOUBLE
100108: EQUAL
100109: IFTRUE 100113
100111: GO 100124
100113: POP
// bc_type := b_ext_siberium ; 21 :
100114: LD_ADDR_OWVAR 42
100118: PUSH
100119: LD_INT 21
100121: ST_TO_ADDR
100122: GO 100391
100124: LD_INT 21
100126: DOUBLE
100127: EQUAL
100128: IFTRUE 100132
100130: GO 100143
100132: POP
// bc_type := b_ext_computer ; 22 :
100133: LD_ADDR_OWVAR 42
100137: PUSH
100138: LD_INT 24
100140: ST_TO_ADDR
100141: GO 100391
100143: LD_INT 22
100145: DOUBLE
100146: EQUAL
100147: IFTRUE 100151
100149: GO 100162
100151: POP
// bc_type := b_ext_track ; 23 :
100152: LD_ADDR_OWVAR 42
100156: PUSH
100157: LD_INT 16
100159: ST_TO_ADDR
100160: GO 100391
100162: LD_INT 23
100164: DOUBLE
100165: EQUAL
100166: IFTRUE 100170
100168: GO 100181
100170: POP
// bc_type := b_ext_laser ; 24 :
100171: LD_ADDR_OWVAR 42
100175: PUSH
100176: LD_INT 25
100178: ST_TO_ADDR
100179: GO 100391
100181: LD_INT 24
100183: DOUBLE
100184: EQUAL
100185: IFTRUE 100189
100187: GO 100200
100189: POP
// bc_type := b_control_tower ; 25 :
100190: LD_ADDR_OWVAR 42
100194: PUSH
100195: LD_INT 36
100197: ST_TO_ADDR
100198: GO 100391
100200: LD_INT 25
100202: DOUBLE
100203: EQUAL
100204: IFTRUE 100208
100206: GO 100219
100208: POP
// bc_type := b_breastwork ; 26 :
100209: LD_ADDR_OWVAR 42
100213: PUSH
100214: LD_INT 31
100216: ST_TO_ADDR
100217: GO 100391
100219: LD_INT 26
100221: DOUBLE
100222: EQUAL
100223: IFTRUE 100227
100225: GO 100238
100227: POP
// bc_type := b_bunker ; 27 :
100228: LD_ADDR_OWVAR 42
100232: PUSH
100233: LD_INT 32
100235: ST_TO_ADDR
100236: GO 100391
100238: LD_INT 27
100240: DOUBLE
100241: EQUAL
100242: IFTRUE 100246
100244: GO 100257
100246: POP
// bc_type := b_turret ; 28 :
100247: LD_ADDR_OWVAR 42
100251: PUSH
100252: LD_INT 33
100254: ST_TO_ADDR
100255: GO 100391
100257: LD_INT 28
100259: DOUBLE
100260: EQUAL
100261: IFTRUE 100265
100263: GO 100276
100265: POP
// bc_type := b_armoury ; 29 :
100266: LD_ADDR_OWVAR 42
100270: PUSH
100271: LD_INT 4
100273: ST_TO_ADDR
100274: GO 100391
100276: LD_INT 29
100278: DOUBLE
100279: EQUAL
100280: IFTRUE 100284
100282: GO 100295
100284: POP
// bc_type := b_barracks ; 30 :
100285: LD_ADDR_OWVAR 42
100289: PUSH
100290: LD_INT 5
100292: ST_TO_ADDR
100293: GO 100391
100295: LD_INT 30
100297: DOUBLE
100298: EQUAL
100299: IFTRUE 100303
100301: GO 100314
100303: POP
// bc_type := b_solar_power ; 31 :
100304: LD_ADDR_OWVAR 42
100308: PUSH
100309: LD_INT 27
100311: ST_TO_ADDR
100312: GO 100391
100314: LD_INT 31
100316: DOUBLE
100317: EQUAL
100318: IFTRUE 100322
100320: GO 100333
100322: POP
// bc_type := b_oil_power ; 32 :
100323: LD_ADDR_OWVAR 42
100327: PUSH
100328: LD_INT 26
100330: ST_TO_ADDR
100331: GO 100391
100333: LD_INT 32
100335: DOUBLE
100336: EQUAL
100337: IFTRUE 100341
100339: GO 100352
100341: POP
// bc_type := b_siberite_power ; 33 :
100342: LD_ADDR_OWVAR 42
100346: PUSH
100347: LD_INT 28
100349: ST_TO_ADDR
100350: GO 100391
100352: LD_INT 33
100354: DOUBLE
100355: EQUAL
100356: IFTRUE 100360
100358: GO 100371
100360: POP
// bc_type := b_oil_mine ; 34 :
100361: LD_ADDR_OWVAR 42
100365: PUSH
100366: LD_INT 29
100368: ST_TO_ADDR
100369: GO 100391
100371: LD_INT 34
100373: DOUBLE
100374: EQUAL
100375: IFTRUE 100379
100377: GO 100390
100379: POP
// bc_type := b_siberite_mine ; end ;
100380: LD_ADDR_OWVAR 42
100384: PUSH
100385: LD_INT 30
100387: ST_TO_ADDR
100388: GO 100391
100390: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100391: LD_ADDR_VAR 0 8
100395: PUSH
100396: LD_VAR 0 5
100400: PPUSH
100401: LD_VAR 0 6
100405: PPUSH
100406: LD_VAR 0 3
100410: PPUSH
100411: CALL_OW 47
100415: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100416: LD_OWVAR 42
100420: PUSH
100421: LD_INT 32
100423: PUSH
100424: LD_INT 33
100426: PUSH
100427: EMPTY
100428: LIST
100429: LIST
100430: IN
100431: IFFALSE 100447
// PlaceWeaponTurret ( b , weapon ) ;
100433: LD_VAR 0 8
100437: PPUSH
100438: LD_VAR 0 4
100442: PPUSH
100443: CALL_OW 431
// end ;
100447: LD_VAR 0 7
100451: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100452: LD_INT 0
100454: PPUSH
100455: PPUSH
100456: PPUSH
100457: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100458: LD_ADDR_VAR 0 4
100462: PUSH
100463: LD_INT 22
100465: PUSH
100466: LD_OWVAR 2
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: PUSH
100475: LD_INT 2
100477: PUSH
100478: LD_INT 30
100480: PUSH
100481: LD_INT 0
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: LD_INT 30
100490: PUSH
100491: LD_INT 1
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: PUSH
100498: EMPTY
100499: LIST
100500: LIST
100501: LIST
100502: PUSH
100503: EMPTY
100504: LIST
100505: LIST
100506: PPUSH
100507: CALL_OW 69
100511: ST_TO_ADDR
// if not tmp then
100512: LD_VAR 0 4
100516: NOT
100517: IFFALSE 100521
// exit ;
100519: GO 100580
// for i in tmp do
100521: LD_ADDR_VAR 0 2
100525: PUSH
100526: LD_VAR 0 4
100530: PUSH
100531: FOR_IN
100532: IFFALSE 100578
// for j = 1 to 3 do
100534: LD_ADDR_VAR 0 3
100538: PUSH
100539: DOUBLE
100540: LD_INT 1
100542: DEC
100543: ST_TO_ADDR
100544: LD_INT 3
100546: PUSH
100547: FOR_TO
100548: IFFALSE 100574
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100550: LD_VAR 0 2
100554: PPUSH
100555: CALL_OW 274
100559: PPUSH
100560: LD_VAR 0 3
100564: PPUSH
100565: LD_INT 99999
100567: PPUSH
100568: CALL_OW 277
100572: GO 100547
100574: POP
100575: POP
100576: GO 100531
100578: POP
100579: POP
// end ;
100580: LD_VAR 0 1
100584: RET
// export function hHackSetLevel10 ; var i , j ; begin
100585: LD_INT 0
100587: PPUSH
100588: PPUSH
100589: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100590: LD_ADDR_VAR 0 2
100594: PUSH
100595: LD_INT 21
100597: PUSH
100598: LD_INT 1
100600: PUSH
100601: EMPTY
100602: LIST
100603: LIST
100604: PPUSH
100605: CALL_OW 69
100609: PUSH
100610: FOR_IN
100611: IFFALSE 100663
// if IsSelected ( i ) then
100613: LD_VAR 0 2
100617: PPUSH
100618: CALL_OW 306
100622: IFFALSE 100661
// begin for j := 1 to 4 do
100624: LD_ADDR_VAR 0 3
100628: PUSH
100629: DOUBLE
100630: LD_INT 1
100632: DEC
100633: ST_TO_ADDR
100634: LD_INT 4
100636: PUSH
100637: FOR_TO
100638: IFFALSE 100659
// SetSkill ( i , j , 10 ) ;
100640: LD_VAR 0 2
100644: PPUSH
100645: LD_VAR 0 3
100649: PPUSH
100650: LD_INT 10
100652: PPUSH
100653: CALL_OW 237
100657: GO 100637
100659: POP
100660: POP
// end ;
100661: GO 100610
100663: POP
100664: POP
// end ;
100665: LD_VAR 0 1
100669: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100670: LD_INT 0
100672: PPUSH
100673: PPUSH
100674: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100675: LD_ADDR_VAR 0 2
100679: PUSH
100680: LD_INT 22
100682: PUSH
100683: LD_OWVAR 2
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: PUSH
100692: LD_INT 21
100694: PUSH
100695: LD_INT 1
100697: PUSH
100698: EMPTY
100699: LIST
100700: LIST
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PPUSH
100706: CALL_OW 69
100710: PUSH
100711: FOR_IN
100712: IFFALSE 100753
// begin for j := 1 to 4 do
100714: LD_ADDR_VAR 0 3
100718: PUSH
100719: DOUBLE
100720: LD_INT 1
100722: DEC
100723: ST_TO_ADDR
100724: LD_INT 4
100726: PUSH
100727: FOR_TO
100728: IFFALSE 100749
// SetSkill ( i , j , 10 ) ;
100730: LD_VAR 0 2
100734: PPUSH
100735: LD_VAR 0 3
100739: PPUSH
100740: LD_INT 10
100742: PPUSH
100743: CALL_OW 237
100747: GO 100727
100749: POP
100750: POP
// end ;
100751: GO 100711
100753: POP
100754: POP
// end ;
100755: LD_VAR 0 1
100759: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100760: LD_INT 0
100762: PPUSH
// uc_side := your_side ;
100763: LD_ADDR_OWVAR 20
100767: PUSH
100768: LD_OWVAR 2
100772: ST_TO_ADDR
// uc_nation := nation ;
100773: LD_ADDR_OWVAR 21
100777: PUSH
100778: LD_VAR 0 1
100782: ST_TO_ADDR
// InitHc ;
100783: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100787: LD_INT 0
100789: PPUSH
100790: LD_VAR 0 2
100794: PPUSH
100795: LD_VAR 0 3
100799: PPUSH
100800: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100804: LD_VAR 0 4
100808: PPUSH
100809: LD_VAR 0 5
100813: PPUSH
100814: CALL_OW 428
100818: PUSH
100819: LD_INT 0
100821: EQUAL
100822: IFFALSE 100846
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100824: CALL_OW 44
100828: PPUSH
100829: LD_VAR 0 4
100833: PPUSH
100834: LD_VAR 0 5
100838: PPUSH
100839: LD_INT 1
100841: PPUSH
100842: CALL_OW 48
// end ;
100846: LD_VAR 0 6
100850: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100851: LD_INT 0
100853: PPUSH
100854: PPUSH
// uc_side := your_side ;
100855: LD_ADDR_OWVAR 20
100859: PUSH
100860: LD_OWVAR 2
100864: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100865: LD_VAR 0 1
100869: PUSH
100870: LD_INT 1
100872: PUSH
100873: LD_INT 2
100875: PUSH
100876: LD_INT 3
100878: PUSH
100879: LD_INT 4
100881: PUSH
100882: LD_INT 5
100884: PUSH
100885: EMPTY
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: IN
100892: IFFALSE 100904
// uc_nation := nation_american else
100894: LD_ADDR_OWVAR 21
100898: PUSH
100899: LD_INT 1
100901: ST_TO_ADDR
100902: GO 100947
// if chassis in [ 11 , 12 , 13 , 14 ] then
100904: LD_VAR 0 1
100908: PUSH
100909: LD_INT 11
100911: PUSH
100912: LD_INT 12
100914: PUSH
100915: LD_INT 13
100917: PUSH
100918: LD_INT 14
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: LIST
100925: LIST
100926: IN
100927: IFFALSE 100939
// uc_nation := nation_arabian else
100929: LD_ADDR_OWVAR 21
100933: PUSH
100934: LD_INT 2
100936: ST_TO_ADDR
100937: GO 100947
// uc_nation := nation_russian ;
100939: LD_ADDR_OWVAR 21
100943: PUSH
100944: LD_INT 3
100946: ST_TO_ADDR
// vc_chassis := chassis ;
100947: LD_ADDR_OWVAR 37
100951: PUSH
100952: LD_VAR 0 1
100956: ST_TO_ADDR
// vc_engine := engine ;
100957: LD_ADDR_OWVAR 39
100961: PUSH
100962: LD_VAR 0 2
100966: ST_TO_ADDR
// vc_control := control ;
100967: LD_ADDR_OWVAR 38
100971: PUSH
100972: LD_VAR 0 3
100976: ST_TO_ADDR
// vc_weapon := weapon ;
100977: LD_ADDR_OWVAR 40
100981: PUSH
100982: LD_VAR 0 4
100986: ST_TO_ADDR
// un := CreateVehicle ;
100987: LD_ADDR_VAR 0 8
100991: PUSH
100992: CALL_OW 45
100996: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100997: LD_VAR 0 8
101001: PPUSH
101002: LD_INT 0
101004: PPUSH
101005: LD_INT 5
101007: PPUSH
101008: CALL_OW 12
101012: PPUSH
101013: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101017: LD_VAR 0 8
101021: PPUSH
101022: LD_VAR 0 5
101026: PPUSH
101027: LD_VAR 0 6
101031: PPUSH
101032: LD_INT 1
101034: PPUSH
101035: CALL_OW 48
// end ;
101039: LD_VAR 0 7
101043: RET
// export hInvincible ; every 1 do
101044: GO 101046
101046: DISABLE
// hInvincible := [ ] ;
101047: LD_ADDR_EXP 164
101051: PUSH
101052: EMPTY
101053: ST_TO_ADDR
101054: END
// every 10 do var i ;
101055: GO 101057
101057: DISABLE
101058: LD_INT 0
101060: PPUSH
// begin enable ;
101061: ENABLE
// if not hInvincible then
101062: LD_EXP 164
101066: NOT
101067: IFFALSE 101071
// exit ;
101069: GO 101115
// for i in hInvincible do
101071: LD_ADDR_VAR 0 1
101075: PUSH
101076: LD_EXP 164
101080: PUSH
101081: FOR_IN
101082: IFFALSE 101113
// if GetLives ( i ) < 1000 then
101084: LD_VAR 0 1
101088: PPUSH
101089: CALL_OW 256
101093: PUSH
101094: LD_INT 1000
101096: LESS
101097: IFFALSE 101111
// SetLives ( i , 1000 ) ;
101099: LD_VAR 0 1
101103: PPUSH
101104: LD_INT 1000
101106: PPUSH
101107: CALL_OW 234
101111: GO 101081
101113: POP
101114: POP
// end ;
101115: PPOPN 1
101117: END
// export function hHackInvincible ; var i ; begin
101118: LD_INT 0
101120: PPUSH
101121: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101122: LD_ADDR_VAR 0 2
101126: PUSH
101127: LD_INT 2
101129: PUSH
101130: LD_INT 21
101132: PUSH
101133: LD_INT 1
101135: PUSH
101136: EMPTY
101137: LIST
101138: LIST
101139: PUSH
101140: LD_INT 21
101142: PUSH
101143: LD_INT 2
101145: PUSH
101146: EMPTY
101147: LIST
101148: LIST
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: LIST
101154: PPUSH
101155: CALL_OW 69
101159: PUSH
101160: FOR_IN
101161: IFFALSE 101222
// if IsSelected ( i ) then
101163: LD_VAR 0 2
101167: PPUSH
101168: CALL_OW 306
101172: IFFALSE 101220
// begin if i in hInvincible then
101174: LD_VAR 0 2
101178: PUSH
101179: LD_EXP 164
101183: IN
101184: IFFALSE 101204
// hInvincible := hInvincible diff i else
101186: LD_ADDR_EXP 164
101190: PUSH
101191: LD_EXP 164
101195: PUSH
101196: LD_VAR 0 2
101200: DIFF
101201: ST_TO_ADDR
101202: GO 101220
// hInvincible := hInvincible union i ;
101204: LD_ADDR_EXP 164
101208: PUSH
101209: LD_EXP 164
101213: PUSH
101214: LD_VAR 0 2
101218: UNION
101219: ST_TO_ADDR
// end ;
101220: GO 101160
101222: POP
101223: POP
// end ;
101224: LD_VAR 0 1
101228: RET
// export function hHackInvisible ; var i , j ; begin
101229: LD_INT 0
101231: PPUSH
101232: PPUSH
101233: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101234: LD_ADDR_VAR 0 2
101238: PUSH
101239: LD_INT 21
101241: PUSH
101242: LD_INT 1
101244: PUSH
101245: EMPTY
101246: LIST
101247: LIST
101248: PPUSH
101249: CALL_OW 69
101253: PUSH
101254: FOR_IN
101255: IFFALSE 101279
// if IsSelected ( i ) then
101257: LD_VAR 0 2
101261: PPUSH
101262: CALL_OW 306
101266: IFFALSE 101277
// ComForceInvisible ( i ) ;
101268: LD_VAR 0 2
101272: PPUSH
101273: CALL_OW 496
101277: GO 101254
101279: POP
101280: POP
// end ;
101281: LD_VAR 0 1
101285: RET
// export function hHackChangeYourSide ; begin
101286: LD_INT 0
101288: PPUSH
// if your_side = 8 then
101289: LD_OWVAR 2
101293: PUSH
101294: LD_INT 8
101296: EQUAL
101297: IFFALSE 101309
// your_side := 0 else
101299: LD_ADDR_OWVAR 2
101303: PUSH
101304: LD_INT 0
101306: ST_TO_ADDR
101307: GO 101323
// your_side := your_side + 1 ;
101309: LD_ADDR_OWVAR 2
101313: PUSH
101314: LD_OWVAR 2
101318: PUSH
101319: LD_INT 1
101321: PLUS
101322: ST_TO_ADDR
// end ;
101323: LD_VAR 0 1
101327: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101328: LD_INT 0
101330: PPUSH
101331: PPUSH
101332: PPUSH
// for i in all_units do
101333: LD_ADDR_VAR 0 2
101337: PUSH
101338: LD_OWVAR 3
101342: PUSH
101343: FOR_IN
101344: IFFALSE 101422
// if IsSelected ( i ) then
101346: LD_VAR 0 2
101350: PPUSH
101351: CALL_OW 306
101355: IFFALSE 101420
// begin j := GetSide ( i ) ;
101357: LD_ADDR_VAR 0 3
101361: PUSH
101362: LD_VAR 0 2
101366: PPUSH
101367: CALL_OW 255
101371: ST_TO_ADDR
// if j = 8 then
101372: LD_VAR 0 3
101376: PUSH
101377: LD_INT 8
101379: EQUAL
101380: IFFALSE 101392
// j := 0 else
101382: LD_ADDR_VAR 0 3
101386: PUSH
101387: LD_INT 0
101389: ST_TO_ADDR
101390: GO 101406
// j := j + 1 ;
101392: LD_ADDR_VAR 0 3
101396: PUSH
101397: LD_VAR 0 3
101401: PUSH
101402: LD_INT 1
101404: PLUS
101405: ST_TO_ADDR
// SetSide ( i , j ) ;
101406: LD_VAR 0 2
101410: PPUSH
101411: LD_VAR 0 3
101415: PPUSH
101416: CALL_OW 235
// end ;
101420: GO 101343
101422: POP
101423: POP
// end ;
101424: LD_VAR 0 1
101428: RET
// export function hHackFog ; begin
101429: LD_INT 0
101431: PPUSH
// FogOff ( true ) ;
101432: LD_INT 1
101434: PPUSH
101435: CALL_OW 344
// end ;
101439: LD_VAR 0 1
101443: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101444: LD_INT 0
101446: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101447: LD_VAR 0 1
101451: PPUSH
101452: LD_VAR 0 2
101456: PPUSH
101457: LD_VAR 0 3
101461: PPUSH
101462: LD_INT 1
101464: PPUSH
101465: LD_INT 1
101467: PPUSH
101468: CALL_OW 483
// CenterOnXY ( x , y ) ;
101472: LD_VAR 0 2
101476: PPUSH
101477: LD_VAR 0 3
101481: PPUSH
101482: CALL_OW 84
// end ;
101486: LD_VAR 0 4
101490: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101491: LD_INT 0
101493: PPUSH
101494: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101495: LD_VAR 0 1
101499: NOT
101500: PUSH
101501: LD_VAR 0 2
101505: PPUSH
101506: LD_VAR 0 3
101510: PPUSH
101511: CALL_OW 488
101515: NOT
101516: OR
101517: PUSH
101518: LD_VAR 0 1
101522: PPUSH
101523: CALL_OW 266
101527: PUSH
101528: LD_INT 3
101530: NONEQUAL
101531: PUSH
101532: LD_VAR 0 1
101536: PPUSH
101537: CALL_OW 247
101541: PUSH
101542: LD_INT 1
101544: EQUAL
101545: NOT
101546: AND
101547: OR
101548: IFFALSE 101552
// exit ;
101550: GO 101701
// if GetType ( factory ) = unit_human then
101552: LD_VAR 0 1
101556: PPUSH
101557: CALL_OW 247
101561: PUSH
101562: LD_INT 1
101564: EQUAL
101565: IFFALSE 101582
// factory := IsInUnit ( factory ) ;
101567: LD_ADDR_VAR 0 1
101571: PUSH
101572: LD_VAR 0 1
101576: PPUSH
101577: CALL_OW 310
101581: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101582: LD_VAR 0 1
101586: PPUSH
101587: CALL_OW 266
101591: PUSH
101592: LD_INT 3
101594: NONEQUAL
101595: IFFALSE 101599
// exit ;
101597: GO 101701
// if HexInfo ( x , y ) = factory then
101599: LD_VAR 0 2
101603: PPUSH
101604: LD_VAR 0 3
101608: PPUSH
101609: CALL_OW 428
101613: PUSH
101614: LD_VAR 0 1
101618: EQUAL
101619: IFFALSE 101646
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101621: LD_ADDR_EXP 165
101625: PUSH
101626: LD_EXP 165
101630: PPUSH
101631: LD_VAR 0 1
101635: PPUSH
101636: LD_INT 0
101638: PPUSH
101639: CALL_OW 1
101643: ST_TO_ADDR
101644: GO 101697
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101646: LD_ADDR_EXP 165
101650: PUSH
101651: LD_EXP 165
101655: PPUSH
101656: LD_VAR 0 1
101660: PPUSH
101661: LD_VAR 0 1
101665: PPUSH
101666: CALL_OW 255
101670: PUSH
101671: LD_VAR 0 1
101675: PUSH
101676: LD_VAR 0 2
101680: PUSH
101681: LD_VAR 0 3
101685: PUSH
101686: EMPTY
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: PPUSH
101692: CALL_OW 1
101696: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101697: CALL 101706 0 0
// end ;
101701: LD_VAR 0 4
101705: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101706: LD_INT 0
101708: PPUSH
101709: PPUSH
101710: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101711: LD_STRING resetFactoryWaypoint();
101713: PPUSH
101714: CALL_OW 559
// if factoryWaypoints then
101718: LD_EXP 165
101722: IFFALSE 101848
// begin list := PrepareArray ( factoryWaypoints ) ;
101724: LD_ADDR_VAR 0 3
101728: PUSH
101729: LD_EXP 165
101733: PPUSH
101734: CALL 56000 0 1
101738: ST_TO_ADDR
// for i := 1 to list do
101739: LD_ADDR_VAR 0 2
101743: PUSH
101744: DOUBLE
101745: LD_INT 1
101747: DEC
101748: ST_TO_ADDR
101749: LD_VAR 0 3
101753: PUSH
101754: FOR_TO
101755: IFFALSE 101846
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101757: LD_STRING setFactoryWaypointXY(
101759: PUSH
101760: LD_VAR 0 3
101764: PUSH
101765: LD_VAR 0 2
101769: ARRAY
101770: PUSH
101771: LD_INT 1
101773: ARRAY
101774: STR
101775: PUSH
101776: LD_STRING ,
101778: STR
101779: PUSH
101780: LD_VAR 0 3
101784: PUSH
101785: LD_VAR 0 2
101789: ARRAY
101790: PUSH
101791: LD_INT 2
101793: ARRAY
101794: STR
101795: PUSH
101796: LD_STRING ,
101798: STR
101799: PUSH
101800: LD_VAR 0 3
101804: PUSH
101805: LD_VAR 0 2
101809: ARRAY
101810: PUSH
101811: LD_INT 3
101813: ARRAY
101814: STR
101815: PUSH
101816: LD_STRING ,
101818: STR
101819: PUSH
101820: LD_VAR 0 3
101824: PUSH
101825: LD_VAR 0 2
101829: ARRAY
101830: PUSH
101831: LD_INT 4
101833: ARRAY
101834: STR
101835: PUSH
101836: LD_STRING )
101838: STR
101839: PPUSH
101840: CALL_OW 559
101844: GO 101754
101846: POP
101847: POP
// end ; end ;
101848: LD_VAR 0 1
101852: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101853: LD_INT 0
101855: PPUSH
// if HexInfo ( x , y ) = warehouse then
101856: LD_VAR 0 2
101860: PPUSH
101861: LD_VAR 0 3
101865: PPUSH
101866: CALL_OW 428
101870: PUSH
101871: LD_VAR 0 1
101875: EQUAL
101876: IFFALSE 101903
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101878: LD_ADDR_EXP 166
101882: PUSH
101883: LD_EXP 166
101887: PPUSH
101888: LD_VAR 0 1
101892: PPUSH
101893: LD_INT 0
101895: PPUSH
101896: CALL_OW 1
101900: ST_TO_ADDR
101901: GO 101954
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101903: LD_ADDR_EXP 166
101907: PUSH
101908: LD_EXP 166
101912: PPUSH
101913: LD_VAR 0 1
101917: PPUSH
101918: LD_VAR 0 1
101922: PPUSH
101923: CALL_OW 255
101927: PUSH
101928: LD_VAR 0 1
101932: PUSH
101933: LD_VAR 0 2
101937: PUSH
101938: LD_VAR 0 3
101942: PUSH
101943: EMPTY
101944: LIST
101945: LIST
101946: LIST
101947: LIST
101948: PPUSH
101949: CALL_OW 1
101953: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
101954: CALL 101963 0 0
// end ;
101958: LD_VAR 0 4
101962: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
101963: LD_INT 0
101965: PPUSH
101966: PPUSH
101967: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
101968: LD_STRING resetWarehouseGatheringPoints();
101970: PPUSH
101971: CALL_OW 559
// if warehouseGatheringPoints then
101975: LD_EXP 166
101979: IFFALSE 102105
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
101981: LD_ADDR_VAR 0 3
101985: PUSH
101986: LD_EXP 166
101990: PPUSH
101991: CALL 56000 0 1
101995: ST_TO_ADDR
// for i := 1 to list do
101996: LD_ADDR_VAR 0 2
102000: PUSH
102001: DOUBLE
102002: LD_INT 1
102004: DEC
102005: ST_TO_ADDR
102006: LD_VAR 0 3
102010: PUSH
102011: FOR_TO
102012: IFFALSE 102103
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102014: LD_STRING setWarehouseGatheringPointXY(
102016: PUSH
102017: LD_VAR 0 3
102021: PUSH
102022: LD_VAR 0 2
102026: ARRAY
102027: PUSH
102028: LD_INT 1
102030: ARRAY
102031: STR
102032: PUSH
102033: LD_STRING ,
102035: STR
102036: PUSH
102037: LD_VAR 0 3
102041: PUSH
102042: LD_VAR 0 2
102046: ARRAY
102047: PUSH
102048: LD_INT 2
102050: ARRAY
102051: STR
102052: PUSH
102053: LD_STRING ,
102055: STR
102056: PUSH
102057: LD_VAR 0 3
102061: PUSH
102062: LD_VAR 0 2
102066: ARRAY
102067: PUSH
102068: LD_INT 3
102070: ARRAY
102071: STR
102072: PUSH
102073: LD_STRING ,
102075: STR
102076: PUSH
102077: LD_VAR 0 3
102081: PUSH
102082: LD_VAR 0 2
102086: ARRAY
102087: PUSH
102088: LD_INT 4
102090: ARRAY
102091: STR
102092: PUSH
102093: LD_STRING )
102095: STR
102096: PPUSH
102097: CALL_OW 559
102101: GO 102011
102103: POP
102104: POP
// end ; end ;
102105: LD_VAR 0 1
102109: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102110: LD_EXP 166
102114: IFFALSE 102799
102116: GO 102118
102118: DISABLE
102119: LD_INT 0
102121: PPUSH
102122: PPUSH
102123: PPUSH
102124: PPUSH
102125: PPUSH
102126: PPUSH
102127: PPUSH
102128: PPUSH
102129: PPUSH
// begin enable ;
102130: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102131: LD_ADDR_VAR 0 3
102135: PUSH
102136: LD_EXP 166
102140: PPUSH
102141: CALL 56000 0 1
102145: ST_TO_ADDR
// if not list then
102146: LD_VAR 0 3
102150: NOT
102151: IFFALSE 102155
// exit ;
102153: GO 102799
// for i := 1 to list do
102155: LD_ADDR_VAR 0 1
102159: PUSH
102160: DOUBLE
102161: LD_INT 1
102163: DEC
102164: ST_TO_ADDR
102165: LD_VAR 0 3
102169: PUSH
102170: FOR_TO
102171: IFFALSE 102797
// begin depot := list [ i ] [ 2 ] ;
102173: LD_ADDR_VAR 0 8
102177: PUSH
102178: LD_VAR 0 3
102182: PUSH
102183: LD_VAR 0 1
102187: ARRAY
102188: PUSH
102189: LD_INT 2
102191: ARRAY
102192: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102193: LD_ADDR_VAR 0 5
102197: PUSH
102198: LD_VAR 0 3
102202: PUSH
102203: LD_VAR 0 1
102207: ARRAY
102208: PUSH
102209: LD_INT 1
102211: ARRAY
102212: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102213: LD_VAR 0 8
102217: PPUSH
102218: CALL_OW 301
102222: PUSH
102223: LD_VAR 0 5
102227: PUSH
102228: LD_VAR 0 8
102232: PPUSH
102233: CALL_OW 255
102237: NONEQUAL
102238: OR
102239: IFFALSE 102268
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102241: LD_ADDR_EXP 166
102245: PUSH
102246: LD_EXP 166
102250: PPUSH
102251: LD_VAR 0 8
102255: PPUSH
102256: LD_INT 0
102258: PPUSH
102259: CALL_OW 1
102263: ST_TO_ADDR
// exit ;
102264: POP
102265: POP
102266: GO 102799
// end ; x := list [ i ] [ 3 ] ;
102268: LD_ADDR_VAR 0 6
102272: PUSH
102273: LD_VAR 0 3
102277: PUSH
102278: LD_VAR 0 1
102282: ARRAY
102283: PUSH
102284: LD_INT 3
102286: ARRAY
102287: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102288: LD_ADDR_VAR 0 7
102292: PUSH
102293: LD_VAR 0 3
102297: PUSH
102298: LD_VAR 0 1
102302: ARRAY
102303: PUSH
102304: LD_INT 4
102306: ARRAY
102307: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102308: LD_ADDR_VAR 0 9
102312: PUSH
102313: LD_VAR 0 6
102317: PPUSH
102318: LD_VAR 0 7
102322: PPUSH
102323: LD_INT 16
102325: PPUSH
102326: CALL 54588 0 3
102330: ST_TO_ADDR
// if not cratesNearbyPoint then
102331: LD_VAR 0 9
102335: NOT
102336: IFFALSE 102342
// exit ;
102338: POP
102339: POP
102340: GO 102799
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102342: LD_ADDR_VAR 0 4
102346: PUSH
102347: LD_INT 22
102349: PUSH
102350: LD_VAR 0 5
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: PUSH
102359: LD_INT 3
102361: PUSH
102362: LD_INT 60
102364: PUSH
102365: EMPTY
102366: LIST
102367: PUSH
102368: EMPTY
102369: LIST
102370: LIST
102371: PUSH
102372: LD_INT 91
102374: PUSH
102375: LD_VAR 0 8
102379: PUSH
102380: LD_INT 6
102382: PUSH
102383: EMPTY
102384: LIST
102385: LIST
102386: LIST
102387: PUSH
102388: LD_INT 2
102390: PUSH
102391: LD_INT 25
102393: PUSH
102394: LD_INT 2
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: LD_INT 25
102403: PUSH
102404: LD_INT 16
102406: PUSH
102407: EMPTY
102408: LIST
102409: LIST
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: LIST
102415: PUSH
102416: EMPTY
102417: LIST
102418: LIST
102419: LIST
102420: LIST
102421: PPUSH
102422: CALL_OW 69
102426: PUSH
102427: LD_VAR 0 8
102431: PPUSH
102432: CALL_OW 313
102436: PPUSH
102437: LD_INT 3
102439: PUSH
102440: LD_INT 60
102442: PUSH
102443: EMPTY
102444: LIST
102445: PUSH
102446: EMPTY
102447: LIST
102448: LIST
102449: PUSH
102450: LD_INT 2
102452: PUSH
102453: LD_INT 25
102455: PUSH
102456: LD_INT 2
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: PUSH
102463: LD_INT 25
102465: PUSH
102466: LD_INT 16
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: PUSH
102473: EMPTY
102474: LIST
102475: LIST
102476: LIST
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: PPUSH
102482: CALL_OW 72
102486: UNION
102487: ST_TO_ADDR
// if tmp then
102488: LD_VAR 0 4
102492: IFFALSE 102572
// begin tmp := ShrinkArray ( tmp , 3 ) ;
102494: LD_ADDR_VAR 0 4
102498: PUSH
102499: LD_VAR 0 4
102503: PPUSH
102504: LD_INT 3
102506: PPUSH
102507: CALL 52557 0 2
102511: ST_TO_ADDR
// for j in tmp do
102512: LD_ADDR_VAR 0 2
102516: PUSH
102517: LD_VAR 0 4
102521: PUSH
102522: FOR_IN
102523: IFFALSE 102566
// begin if IsInUnit ( j ) then
102525: LD_VAR 0 2
102529: PPUSH
102530: CALL_OW 310
102534: IFFALSE 102545
// ComExit ( j ) ;
102536: LD_VAR 0 2
102540: PPUSH
102541: CALL 52640 0 1
// AddComCollect ( j , x , y ) ;
102545: LD_VAR 0 2
102549: PPUSH
102550: LD_VAR 0 6
102554: PPUSH
102555: LD_VAR 0 7
102559: PPUSH
102560: CALL_OW 177
// end ;
102564: GO 102522
102566: POP
102567: POP
// exit ;
102568: POP
102569: POP
102570: GO 102799
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102572: LD_ADDR_VAR 0 4
102576: PUSH
102577: LD_INT 22
102579: PUSH
102580: LD_VAR 0 5
102584: PUSH
102585: EMPTY
102586: LIST
102587: LIST
102588: PUSH
102589: LD_INT 91
102591: PUSH
102592: LD_VAR 0 8
102596: PUSH
102597: LD_INT 8
102599: PUSH
102600: EMPTY
102601: LIST
102602: LIST
102603: LIST
102604: PUSH
102605: LD_INT 2
102607: PUSH
102608: LD_INT 34
102610: PUSH
102611: LD_INT 12
102613: PUSH
102614: EMPTY
102615: LIST
102616: LIST
102617: PUSH
102618: LD_INT 34
102620: PUSH
102621: LD_INT 51
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PUSH
102628: LD_INT 34
102630: PUSH
102631: LD_INT 32
102633: PUSH
102634: EMPTY
102635: LIST
102636: LIST
102637: PUSH
102638: LD_INT 34
102640: PUSH
102641: LD_INT 89
102643: PUSH
102644: EMPTY
102645: LIST
102646: LIST
102647: PUSH
102648: EMPTY
102649: LIST
102650: LIST
102651: LIST
102652: LIST
102653: LIST
102654: PUSH
102655: EMPTY
102656: LIST
102657: LIST
102658: LIST
102659: PPUSH
102660: CALL_OW 69
102664: ST_TO_ADDR
// if tmp then
102665: LD_VAR 0 4
102669: IFFALSE 102795
// begin for j in tmp do
102671: LD_ADDR_VAR 0 2
102675: PUSH
102676: LD_VAR 0 4
102680: PUSH
102681: FOR_IN
102682: IFFALSE 102793
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102684: LD_VAR 0 2
102688: PPUSH
102689: CALL_OW 262
102693: PUSH
102694: LD_INT 3
102696: EQUAL
102697: PUSH
102698: LD_VAR 0 2
102702: PPUSH
102703: CALL_OW 261
102707: PUSH
102708: LD_INT 20
102710: GREATER
102711: OR
102712: PUSH
102713: LD_VAR 0 2
102717: PPUSH
102718: CALL_OW 314
102722: NOT
102723: AND
102724: PUSH
102725: LD_VAR 0 2
102729: PPUSH
102730: CALL_OW 263
102734: PUSH
102735: LD_INT 1
102737: NONEQUAL
102738: PUSH
102739: LD_VAR 0 2
102743: PPUSH
102744: CALL_OW 311
102748: OR
102749: AND
102750: IFFALSE 102791
// begin ComCollect ( j , x , y ) ;
102752: LD_VAR 0 2
102756: PPUSH
102757: LD_VAR 0 6
102761: PPUSH
102762: LD_VAR 0 7
102766: PPUSH
102767: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102771: LD_VAR 0 2
102775: PPUSH
102776: LD_VAR 0 8
102780: PPUSH
102781: CALL_OW 172
// exit ;
102785: POP
102786: POP
102787: POP
102788: POP
102789: GO 102799
// end ;
102791: GO 102681
102793: POP
102794: POP
// end ; end ;
102795: GO 102170
102797: POP
102798: POP
// end ; end_of_file
102799: PPOPN 9
102801: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102802: LD_INT 0
102804: PPUSH
102805: PPUSH
102806: PPUSH
102807: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102808: LD_VAR 0 1
102812: PPUSH
102813: CALL_OW 264
102817: PUSH
102818: LD_INT 91
102820: EQUAL
102821: IFFALSE 102893
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102823: LD_INT 68
102825: PPUSH
102826: LD_VAR 0 1
102830: PPUSH
102831: CALL_OW 255
102835: PPUSH
102836: CALL_OW 321
102840: PUSH
102841: LD_INT 2
102843: EQUAL
102844: IFFALSE 102856
// eff := 70 else
102846: LD_ADDR_VAR 0 4
102850: PUSH
102851: LD_INT 70
102853: ST_TO_ADDR
102854: GO 102864
// eff := 30 ;
102856: LD_ADDR_VAR 0 4
102860: PUSH
102861: LD_INT 30
102863: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102864: LD_VAR 0 1
102868: PPUSH
102869: CALL_OW 250
102873: PPUSH
102874: LD_VAR 0 1
102878: PPUSH
102879: CALL_OW 251
102883: PPUSH
102884: LD_VAR 0 4
102888: PPUSH
102889: CALL_OW 495
// end ; end ;
102893: LD_VAR 0 2
102897: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102898: LD_INT 0
102900: PPUSH
// end ;
102901: LD_VAR 0 4
102905: RET
// export function SOS_Command ( cmd ) ; begin
102906: LD_INT 0
102908: PPUSH
// end ;
102909: LD_VAR 0 2
102913: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102914: LD_INT 0
102916: PPUSH
// end ;
102917: LD_VAR 0 6
102921: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102922: LD_INT 0
102924: PPUSH
102925: PPUSH
// if not vehicle or not factory then
102926: LD_VAR 0 1
102930: NOT
102931: PUSH
102932: LD_VAR 0 2
102936: NOT
102937: OR
102938: IFFALSE 102942
// exit ;
102940: GO 103173
// if factoryWaypoints >= factory then
102942: LD_EXP 165
102946: PUSH
102947: LD_VAR 0 2
102951: GREATEREQUAL
102952: IFFALSE 103173
// if factoryWaypoints [ factory ] then
102954: LD_EXP 165
102958: PUSH
102959: LD_VAR 0 2
102963: ARRAY
102964: IFFALSE 103173
// begin if GetControl ( vehicle ) = control_manual then
102966: LD_VAR 0 1
102970: PPUSH
102971: CALL_OW 263
102975: PUSH
102976: LD_INT 1
102978: EQUAL
102979: IFFALSE 103060
// begin driver := IsDrivenBy ( vehicle ) ;
102981: LD_ADDR_VAR 0 4
102985: PUSH
102986: LD_VAR 0 1
102990: PPUSH
102991: CALL_OW 311
102995: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102996: LD_VAR 0 4
103000: PPUSH
103001: LD_EXP 165
103005: PUSH
103006: LD_VAR 0 2
103010: ARRAY
103011: PUSH
103012: LD_INT 3
103014: ARRAY
103015: PPUSH
103016: LD_EXP 165
103020: PUSH
103021: LD_VAR 0 2
103025: ARRAY
103026: PUSH
103027: LD_INT 4
103029: ARRAY
103030: PPUSH
103031: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103035: LD_VAR 0 4
103039: PPUSH
103040: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103044: LD_VAR 0 4
103048: PPUSH
103049: LD_VAR 0 2
103053: PPUSH
103054: CALL_OW 180
// end else
103058: GO 103173
// if GetControl ( vehicle ) = control_remote then
103060: LD_VAR 0 1
103064: PPUSH
103065: CALL_OW 263
103069: PUSH
103070: LD_INT 2
103072: EQUAL
103073: IFFALSE 103134
// begin wait ( 0 0$2 ) ;
103075: LD_INT 70
103077: PPUSH
103078: CALL_OW 67
// if Connect ( vehicle ) then
103082: LD_VAR 0 1
103086: PPUSH
103087: CALL 22881 0 1
103091: IFFALSE 103132
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103093: LD_VAR 0 1
103097: PPUSH
103098: LD_EXP 165
103102: PUSH
103103: LD_VAR 0 2
103107: ARRAY
103108: PUSH
103109: LD_INT 3
103111: ARRAY
103112: PPUSH
103113: LD_EXP 165
103117: PUSH
103118: LD_VAR 0 2
103122: ARRAY
103123: PUSH
103124: LD_INT 4
103126: ARRAY
103127: PPUSH
103128: CALL_OW 171
// end else
103132: GO 103173
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103134: LD_VAR 0 1
103138: PPUSH
103139: LD_EXP 165
103143: PUSH
103144: LD_VAR 0 2
103148: ARRAY
103149: PUSH
103150: LD_INT 3
103152: ARRAY
103153: PPUSH
103154: LD_EXP 165
103158: PUSH
103159: LD_VAR 0 2
103163: ARRAY
103164: PUSH
103165: LD_INT 4
103167: ARRAY
103168: PPUSH
103169: CALL_OW 171
// end ; end ;
103173: LD_VAR 0 3
103177: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103178: LD_INT 0
103180: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103181: LD_VAR 0 1
103185: PUSH
103186: LD_INT 250
103188: EQUAL
103189: PUSH
103190: LD_VAR 0 2
103194: PPUSH
103195: CALL_OW 264
103199: PUSH
103200: LD_INT 81
103202: EQUAL
103203: AND
103204: IFFALSE 103225
// MinerPlaceMine ( unit , x , y ) ;
103206: LD_VAR 0 2
103210: PPUSH
103211: LD_VAR 0 4
103215: PPUSH
103216: LD_VAR 0 5
103220: PPUSH
103221: CALL 105610 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103225: LD_VAR 0 1
103229: PUSH
103230: LD_INT 251
103232: EQUAL
103233: PUSH
103234: LD_VAR 0 2
103238: PPUSH
103239: CALL_OW 264
103243: PUSH
103244: LD_INT 81
103246: EQUAL
103247: AND
103248: IFFALSE 103269
// MinerDetonateMine ( unit , x , y ) ;
103250: LD_VAR 0 2
103254: PPUSH
103255: LD_VAR 0 4
103259: PPUSH
103260: LD_VAR 0 5
103264: PPUSH
103265: CALL 105885 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103269: LD_VAR 0 1
103273: PUSH
103274: LD_INT 252
103276: EQUAL
103277: PUSH
103278: LD_VAR 0 2
103282: PPUSH
103283: CALL_OW 264
103287: PUSH
103288: LD_INT 81
103290: EQUAL
103291: AND
103292: IFFALSE 103313
// MinerCreateMinefield ( unit , x , y ) ;
103294: LD_VAR 0 2
103298: PPUSH
103299: LD_VAR 0 4
103303: PPUSH
103304: LD_VAR 0 5
103308: PPUSH
103309: CALL 106302 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103313: LD_VAR 0 1
103317: PUSH
103318: LD_INT 253
103320: EQUAL
103321: PUSH
103322: LD_VAR 0 2
103326: PPUSH
103327: CALL_OW 257
103331: PUSH
103332: LD_INT 5
103334: EQUAL
103335: AND
103336: IFFALSE 103357
// ComBinocular ( unit , x , y ) ;
103338: LD_VAR 0 2
103342: PPUSH
103343: LD_VAR 0 4
103347: PPUSH
103348: LD_VAR 0 5
103352: PPUSH
103353: CALL 106671 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103357: LD_VAR 0 1
103361: PUSH
103362: LD_INT 254
103364: EQUAL
103365: PUSH
103366: LD_VAR 0 2
103370: PPUSH
103371: CALL_OW 264
103375: PUSH
103376: LD_INT 99
103378: EQUAL
103379: AND
103380: PUSH
103381: LD_VAR 0 3
103385: PPUSH
103386: CALL_OW 263
103390: PUSH
103391: LD_INT 3
103393: EQUAL
103394: AND
103395: IFFALSE 103411
// HackDestroyVehicle ( unit , selectedUnit ) ;
103397: LD_VAR 0 2
103401: PPUSH
103402: LD_VAR 0 3
103406: PPUSH
103407: CALL 104974 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103411: LD_VAR 0 1
103415: PUSH
103416: LD_INT 255
103418: EQUAL
103419: PUSH
103420: LD_VAR 0 2
103424: PPUSH
103425: CALL_OW 264
103429: PUSH
103430: LD_INT 14
103432: PUSH
103433: LD_INT 53
103435: PUSH
103436: EMPTY
103437: LIST
103438: LIST
103439: IN
103440: AND
103441: PUSH
103442: LD_VAR 0 4
103446: PPUSH
103447: LD_VAR 0 5
103451: PPUSH
103452: CALL_OW 488
103456: AND
103457: IFFALSE 103481
// CutTreeXYR ( unit , x , y , 12 ) ;
103459: LD_VAR 0 2
103463: PPUSH
103464: LD_VAR 0 4
103468: PPUSH
103469: LD_VAR 0 5
103473: PPUSH
103474: LD_INT 12
103476: PPUSH
103477: CALL 103544 0 4
// if cmd = 256 then
103481: LD_VAR 0 1
103485: PUSH
103486: LD_INT 256
103488: EQUAL
103489: IFFALSE 103510
// SetFactoryWaypoint ( unit , x , y ) ;
103491: LD_VAR 0 2
103495: PPUSH
103496: LD_VAR 0 4
103500: PPUSH
103501: LD_VAR 0 5
103505: PPUSH
103506: CALL 101491 0 3
// if cmd = 257 then
103510: LD_VAR 0 1
103514: PUSH
103515: LD_INT 257
103517: EQUAL
103518: IFFALSE 103539
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103520: LD_VAR 0 2
103524: PPUSH
103525: LD_VAR 0 4
103529: PPUSH
103530: LD_VAR 0 5
103534: PPUSH
103535: CALL 101853 0 3
// end ;
103539: LD_VAR 0 6
103543: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103544: LD_INT 0
103546: PPUSH
103547: PPUSH
103548: PPUSH
103549: PPUSH
103550: PPUSH
103551: PPUSH
103552: PPUSH
103553: PPUSH
103554: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103555: LD_VAR 0 1
103559: NOT
103560: PUSH
103561: LD_VAR 0 2
103565: PPUSH
103566: LD_VAR 0 3
103570: PPUSH
103571: CALL_OW 488
103575: NOT
103576: OR
103577: PUSH
103578: LD_VAR 0 4
103582: NOT
103583: OR
103584: IFFALSE 103588
// exit ;
103586: GO 103928
// list := [ ] ;
103588: LD_ADDR_VAR 0 13
103592: PUSH
103593: EMPTY
103594: ST_TO_ADDR
// if x - r < 0 then
103595: LD_VAR 0 2
103599: PUSH
103600: LD_VAR 0 4
103604: MINUS
103605: PUSH
103606: LD_INT 0
103608: LESS
103609: IFFALSE 103621
// min_x := 0 else
103611: LD_ADDR_VAR 0 7
103615: PUSH
103616: LD_INT 0
103618: ST_TO_ADDR
103619: GO 103637
// min_x := x - r ;
103621: LD_ADDR_VAR 0 7
103625: PUSH
103626: LD_VAR 0 2
103630: PUSH
103631: LD_VAR 0 4
103635: MINUS
103636: ST_TO_ADDR
// if y - r < 0 then
103637: LD_VAR 0 3
103641: PUSH
103642: LD_VAR 0 4
103646: MINUS
103647: PUSH
103648: LD_INT 0
103650: LESS
103651: IFFALSE 103663
// min_y := 0 else
103653: LD_ADDR_VAR 0 8
103657: PUSH
103658: LD_INT 0
103660: ST_TO_ADDR
103661: GO 103679
// min_y := y - r ;
103663: LD_ADDR_VAR 0 8
103667: PUSH
103668: LD_VAR 0 3
103672: PUSH
103673: LD_VAR 0 4
103677: MINUS
103678: ST_TO_ADDR
// max_x := x + r ;
103679: LD_ADDR_VAR 0 9
103683: PUSH
103684: LD_VAR 0 2
103688: PUSH
103689: LD_VAR 0 4
103693: PLUS
103694: ST_TO_ADDR
// max_y := y + r ;
103695: LD_ADDR_VAR 0 10
103699: PUSH
103700: LD_VAR 0 3
103704: PUSH
103705: LD_VAR 0 4
103709: PLUS
103710: ST_TO_ADDR
// for _x = min_x to max_x do
103711: LD_ADDR_VAR 0 11
103715: PUSH
103716: DOUBLE
103717: LD_VAR 0 7
103721: DEC
103722: ST_TO_ADDR
103723: LD_VAR 0 9
103727: PUSH
103728: FOR_TO
103729: IFFALSE 103846
// for _y = min_y to max_y do
103731: LD_ADDR_VAR 0 12
103735: PUSH
103736: DOUBLE
103737: LD_VAR 0 8
103741: DEC
103742: ST_TO_ADDR
103743: LD_VAR 0 10
103747: PUSH
103748: FOR_TO
103749: IFFALSE 103842
// begin if not ValidHex ( _x , _y ) then
103751: LD_VAR 0 11
103755: PPUSH
103756: LD_VAR 0 12
103760: PPUSH
103761: CALL_OW 488
103765: NOT
103766: IFFALSE 103770
// continue ;
103768: GO 103748
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103770: LD_VAR 0 11
103774: PPUSH
103775: LD_VAR 0 12
103779: PPUSH
103780: CALL_OW 351
103784: PUSH
103785: LD_VAR 0 11
103789: PPUSH
103790: LD_VAR 0 12
103794: PPUSH
103795: CALL_OW 554
103799: AND
103800: IFFALSE 103840
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103802: LD_ADDR_VAR 0 13
103806: PUSH
103807: LD_VAR 0 13
103811: PPUSH
103812: LD_VAR 0 13
103816: PUSH
103817: LD_INT 1
103819: PLUS
103820: PPUSH
103821: LD_VAR 0 11
103825: PUSH
103826: LD_VAR 0 12
103830: PUSH
103831: EMPTY
103832: LIST
103833: LIST
103834: PPUSH
103835: CALL_OW 2
103839: ST_TO_ADDR
// end ;
103840: GO 103748
103842: POP
103843: POP
103844: GO 103728
103846: POP
103847: POP
// if not list then
103848: LD_VAR 0 13
103852: NOT
103853: IFFALSE 103857
// exit ;
103855: GO 103928
// for i in list do
103857: LD_ADDR_VAR 0 6
103861: PUSH
103862: LD_VAR 0 13
103866: PUSH
103867: FOR_IN
103868: IFFALSE 103926
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103870: LD_VAR 0 1
103874: PPUSH
103875: LD_STRING M
103877: PUSH
103878: LD_VAR 0 6
103882: PUSH
103883: LD_INT 1
103885: ARRAY
103886: PUSH
103887: LD_VAR 0 6
103891: PUSH
103892: LD_INT 2
103894: ARRAY
103895: PUSH
103896: LD_INT 0
103898: PUSH
103899: LD_INT 0
103901: PUSH
103902: LD_INT 0
103904: PUSH
103905: LD_INT 0
103907: PUSH
103908: EMPTY
103909: LIST
103910: LIST
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: LIST
103916: PUSH
103917: EMPTY
103918: LIST
103919: PPUSH
103920: CALL_OW 447
103924: GO 103867
103926: POP
103927: POP
// end ;
103928: LD_VAR 0 5
103932: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103933: LD_EXP 168
103937: NOT
103938: IFFALSE 103988
103940: GO 103942
103942: DISABLE
// begin initHack := true ;
103943: LD_ADDR_EXP 168
103947: PUSH
103948: LD_INT 1
103950: ST_TO_ADDR
// hackTanks := [ ] ;
103951: LD_ADDR_EXP 169
103955: PUSH
103956: EMPTY
103957: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103958: LD_ADDR_EXP 170
103962: PUSH
103963: EMPTY
103964: ST_TO_ADDR
// hackLimit := 3 ;
103965: LD_ADDR_EXP 171
103969: PUSH
103970: LD_INT 3
103972: ST_TO_ADDR
// hackDist := 12 ;
103973: LD_ADDR_EXP 172
103977: PUSH
103978: LD_INT 12
103980: ST_TO_ADDR
// hackCounter := [ ] ;
103981: LD_ADDR_EXP 173
103985: PUSH
103986: EMPTY
103987: ST_TO_ADDR
// end ;
103988: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103989: LD_EXP 168
103993: PUSH
103994: LD_INT 34
103996: PUSH
103997: LD_INT 99
103999: PUSH
104000: EMPTY
104001: LIST
104002: LIST
104003: PPUSH
104004: CALL_OW 69
104008: AND
104009: IFFALSE 104262
104011: GO 104013
104013: DISABLE
104014: LD_INT 0
104016: PPUSH
104017: PPUSH
// begin enable ;
104018: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104019: LD_ADDR_VAR 0 1
104023: PUSH
104024: LD_INT 34
104026: PUSH
104027: LD_INT 99
104029: PUSH
104030: EMPTY
104031: LIST
104032: LIST
104033: PPUSH
104034: CALL_OW 69
104038: PUSH
104039: FOR_IN
104040: IFFALSE 104260
// begin if not i in hackTanks then
104042: LD_VAR 0 1
104046: PUSH
104047: LD_EXP 169
104051: IN
104052: NOT
104053: IFFALSE 104136
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104055: LD_ADDR_EXP 169
104059: PUSH
104060: LD_EXP 169
104064: PPUSH
104065: LD_EXP 169
104069: PUSH
104070: LD_INT 1
104072: PLUS
104073: PPUSH
104074: LD_VAR 0 1
104078: PPUSH
104079: CALL_OW 1
104083: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104084: LD_ADDR_EXP 170
104088: PUSH
104089: LD_EXP 170
104093: PPUSH
104094: LD_EXP 170
104098: PUSH
104099: LD_INT 1
104101: PLUS
104102: PPUSH
104103: EMPTY
104104: PPUSH
104105: CALL_OW 1
104109: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104110: LD_ADDR_EXP 173
104114: PUSH
104115: LD_EXP 173
104119: PPUSH
104120: LD_EXP 173
104124: PUSH
104125: LD_INT 1
104127: PLUS
104128: PPUSH
104129: EMPTY
104130: PPUSH
104131: CALL_OW 1
104135: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104136: LD_VAR 0 1
104140: PPUSH
104141: CALL_OW 302
104145: NOT
104146: IFFALSE 104159
// begin HackUnlinkAll ( i ) ;
104148: LD_VAR 0 1
104152: PPUSH
104153: CALL 104265 0 1
// continue ;
104157: GO 104039
// end ; HackCheckCapturedStatus ( i ) ;
104159: LD_VAR 0 1
104163: PPUSH
104164: CALL 104708 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104168: LD_ADDR_VAR 0 2
104172: PUSH
104173: LD_INT 81
104175: PUSH
104176: LD_VAR 0 1
104180: PPUSH
104181: CALL_OW 255
104185: PUSH
104186: EMPTY
104187: LIST
104188: LIST
104189: PUSH
104190: LD_INT 33
104192: PUSH
104193: LD_INT 3
104195: PUSH
104196: EMPTY
104197: LIST
104198: LIST
104199: PUSH
104200: LD_INT 91
104202: PUSH
104203: LD_VAR 0 1
104207: PUSH
104208: LD_EXP 172
104212: PUSH
104213: EMPTY
104214: LIST
104215: LIST
104216: LIST
104217: PUSH
104218: LD_INT 50
104220: PUSH
104221: EMPTY
104222: LIST
104223: PUSH
104224: EMPTY
104225: LIST
104226: LIST
104227: LIST
104228: LIST
104229: PPUSH
104230: CALL_OW 69
104234: ST_TO_ADDR
// if not tmp then
104235: LD_VAR 0 2
104239: NOT
104240: IFFALSE 104244
// continue ;
104242: GO 104039
// HackLink ( i , tmp ) ;
104244: LD_VAR 0 1
104248: PPUSH
104249: LD_VAR 0 2
104253: PPUSH
104254: CALL 104401 0 2
// end ;
104258: GO 104039
104260: POP
104261: POP
// end ;
104262: PPOPN 2
104264: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104265: LD_INT 0
104267: PPUSH
104268: PPUSH
104269: PPUSH
// if not hack in hackTanks then
104270: LD_VAR 0 1
104274: PUSH
104275: LD_EXP 169
104279: IN
104280: NOT
104281: IFFALSE 104285
// exit ;
104283: GO 104396
// index := GetElementIndex ( hackTanks , hack ) ;
104285: LD_ADDR_VAR 0 4
104289: PUSH
104290: LD_EXP 169
104294: PPUSH
104295: LD_VAR 0 1
104299: PPUSH
104300: CALL 19697 0 2
104304: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104305: LD_EXP 170
104309: PUSH
104310: LD_VAR 0 4
104314: ARRAY
104315: IFFALSE 104396
// begin for i in hackTanksCaptured [ index ] do
104317: LD_ADDR_VAR 0 3
104321: PUSH
104322: LD_EXP 170
104326: PUSH
104327: LD_VAR 0 4
104331: ARRAY
104332: PUSH
104333: FOR_IN
104334: IFFALSE 104360
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104336: LD_VAR 0 3
104340: PUSH
104341: LD_INT 1
104343: ARRAY
104344: PPUSH
104345: LD_VAR 0 3
104349: PUSH
104350: LD_INT 2
104352: ARRAY
104353: PPUSH
104354: CALL_OW 235
104358: GO 104333
104360: POP
104361: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104362: LD_ADDR_EXP 170
104366: PUSH
104367: LD_EXP 170
104371: PPUSH
104372: LD_VAR 0 4
104376: PPUSH
104377: EMPTY
104378: PPUSH
104379: CALL_OW 1
104383: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104384: LD_VAR 0 1
104388: PPUSH
104389: LD_INT 0
104391: PPUSH
104392: CALL_OW 505
// end ; end ;
104396: LD_VAR 0 2
104400: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104401: LD_INT 0
104403: PPUSH
104404: PPUSH
104405: PPUSH
// if not hack in hackTanks or not vehicles then
104406: LD_VAR 0 1
104410: PUSH
104411: LD_EXP 169
104415: IN
104416: NOT
104417: PUSH
104418: LD_VAR 0 2
104422: NOT
104423: OR
104424: IFFALSE 104428
// exit ;
104426: GO 104703
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104428: LD_ADDR_VAR 0 2
104432: PUSH
104433: LD_VAR 0 1
104437: PPUSH
104438: LD_VAR 0 2
104442: PPUSH
104443: LD_INT 1
104445: PPUSH
104446: LD_INT 1
104448: PPUSH
104449: CALL 20347 0 4
104453: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104454: LD_ADDR_VAR 0 5
104458: PUSH
104459: LD_EXP 169
104463: PPUSH
104464: LD_VAR 0 1
104468: PPUSH
104469: CALL 19697 0 2
104473: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104474: LD_EXP 170
104478: PUSH
104479: LD_VAR 0 5
104483: ARRAY
104484: PUSH
104485: LD_EXP 171
104489: LESS
104490: IFFALSE 104679
// begin for i := 1 to vehicles do
104492: LD_ADDR_VAR 0 4
104496: PUSH
104497: DOUBLE
104498: LD_INT 1
104500: DEC
104501: ST_TO_ADDR
104502: LD_VAR 0 2
104506: PUSH
104507: FOR_TO
104508: IFFALSE 104677
// begin if hackTanksCaptured [ index ] = hackLimit then
104510: LD_EXP 170
104514: PUSH
104515: LD_VAR 0 5
104519: ARRAY
104520: PUSH
104521: LD_EXP 171
104525: EQUAL
104526: IFFALSE 104530
// break ;
104528: GO 104677
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104530: LD_ADDR_EXP 173
104534: PUSH
104535: LD_EXP 173
104539: PPUSH
104540: LD_VAR 0 5
104544: PPUSH
104545: LD_EXP 173
104549: PUSH
104550: LD_VAR 0 5
104554: ARRAY
104555: PUSH
104556: LD_INT 1
104558: PLUS
104559: PPUSH
104560: CALL_OW 1
104564: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104565: LD_ADDR_EXP 170
104569: PUSH
104570: LD_EXP 170
104574: PPUSH
104575: LD_VAR 0 5
104579: PUSH
104580: LD_EXP 170
104584: PUSH
104585: LD_VAR 0 5
104589: ARRAY
104590: PUSH
104591: LD_INT 1
104593: PLUS
104594: PUSH
104595: EMPTY
104596: LIST
104597: LIST
104598: PPUSH
104599: LD_VAR 0 2
104603: PUSH
104604: LD_VAR 0 4
104608: ARRAY
104609: PUSH
104610: LD_VAR 0 2
104614: PUSH
104615: LD_VAR 0 4
104619: ARRAY
104620: PPUSH
104621: CALL_OW 255
104625: PUSH
104626: EMPTY
104627: LIST
104628: LIST
104629: PPUSH
104630: CALL 19912 0 3
104634: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104635: LD_VAR 0 2
104639: PUSH
104640: LD_VAR 0 4
104644: ARRAY
104645: PPUSH
104646: LD_VAR 0 1
104650: PPUSH
104651: CALL_OW 255
104655: PPUSH
104656: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104660: LD_VAR 0 2
104664: PUSH
104665: LD_VAR 0 4
104669: ARRAY
104670: PPUSH
104671: CALL_OW 141
// end ;
104675: GO 104507
104677: POP
104678: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104679: LD_VAR 0 1
104683: PPUSH
104684: LD_EXP 170
104688: PUSH
104689: LD_VAR 0 5
104693: ARRAY
104694: PUSH
104695: LD_INT 0
104697: PLUS
104698: PPUSH
104699: CALL_OW 505
// end ;
104703: LD_VAR 0 3
104707: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104708: LD_INT 0
104710: PPUSH
104711: PPUSH
104712: PPUSH
104713: PPUSH
// if not hack in hackTanks then
104714: LD_VAR 0 1
104718: PUSH
104719: LD_EXP 169
104723: IN
104724: NOT
104725: IFFALSE 104729
// exit ;
104727: GO 104969
// index := GetElementIndex ( hackTanks , hack ) ;
104729: LD_ADDR_VAR 0 4
104733: PUSH
104734: LD_EXP 169
104738: PPUSH
104739: LD_VAR 0 1
104743: PPUSH
104744: CALL 19697 0 2
104748: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104749: LD_ADDR_VAR 0 3
104753: PUSH
104754: DOUBLE
104755: LD_EXP 170
104759: PUSH
104760: LD_VAR 0 4
104764: ARRAY
104765: INC
104766: ST_TO_ADDR
104767: LD_INT 1
104769: PUSH
104770: FOR_DOWNTO
104771: IFFALSE 104943
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104773: LD_ADDR_VAR 0 5
104777: PUSH
104778: LD_EXP 170
104782: PUSH
104783: LD_VAR 0 4
104787: ARRAY
104788: PUSH
104789: LD_VAR 0 3
104793: ARRAY
104794: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104795: LD_VAR 0 5
104799: PUSH
104800: LD_INT 1
104802: ARRAY
104803: PPUSH
104804: CALL_OW 302
104808: NOT
104809: PUSH
104810: LD_VAR 0 5
104814: PUSH
104815: LD_INT 1
104817: ARRAY
104818: PPUSH
104819: CALL_OW 255
104823: PUSH
104824: LD_VAR 0 1
104828: PPUSH
104829: CALL_OW 255
104833: NONEQUAL
104834: OR
104835: IFFALSE 104941
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104837: LD_VAR 0 5
104841: PUSH
104842: LD_INT 1
104844: ARRAY
104845: PPUSH
104846: CALL_OW 305
104850: PUSH
104851: LD_VAR 0 5
104855: PUSH
104856: LD_INT 1
104858: ARRAY
104859: PPUSH
104860: CALL_OW 255
104864: PUSH
104865: LD_VAR 0 1
104869: PPUSH
104870: CALL_OW 255
104874: EQUAL
104875: AND
104876: IFFALSE 104900
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104878: LD_VAR 0 5
104882: PUSH
104883: LD_INT 1
104885: ARRAY
104886: PPUSH
104887: LD_VAR 0 5
104891: PUSH
104892: LD_INT 2
104894: ARRAY
104895: PPUSH
104896: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104900: LD_ADDR_EXP 170
104904: PUSH
104905: LD_EXP 170
104909: PPUSH
104910: LD_VAR 0 4
104914: PPUSH
104915: LD_EXP 170
104919: PUSH
104920: LD_VAR 0 4
104924: ARRAY
104925: PPUSH
104926: LD_VAR 0 3
104930: PPUSH
104931: CALL_OW 3
104935: PPUSH
104936: CALL_OW 1
104940: ST_TO_ADDR
// end ; end ;
104941: GO 104770
104943: POP
104944: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104945: LD_VAR 0 1
104949: PPUSH
104950: LD_EXP 170
104954: PUSH
104955: LD_VAR 0 4
104959: ARRAY
104960: PUSH
104961: LD_INT 0
104963: PLUS
104964: PPUSH
104965: CALL_OW 505
// end ;
104969: LD_VAR 0 2
104973: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104974: LD_INT 0
104976: PPUSH
104977: PPUSH
104978: PPUSH
104979: PPUSH
// if not hack in hackTanks then
104980: LD_VAR 0 1
104984: PUSH
104985: LD_EXP 169
104989: IN
104990: NOT
104991: IFFALSE 104995
// exit ;
104993: GO 105080
// index := GetElementIndex ( hackTanks , hack ) ;
104995: LD_ADDR_VAR 0 5
104999: PUSH
105000: LD_EXP 169
105004: PPUSH
105005: LD_VAR 0 1
105009: PPUSH
105010: CALL 19697 0 2
105014: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105015: LD_ADDR_VAR 0 4
105019: PUSH
105020: DOUBLE
105021: LD_INT 1
105023: DEC
105024: ST_TO_ADDR
105025: LD_EXP 170
105029: PUSH
105030: LD_VAR 0 5
105034: ARRAY
105035: PUSH
105036: FOR_TO
105037: IFFALSE 105078
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105039: LD_EXP 170
105043: PUSH
105044: LD_VAR 0 5
105048: ARRAY
105049: PUSH
105050: LD_VAR 0 4
105054: ARRAY
105055: PUSH
105056: LD_INT 1
105058: ARRAY
105059: PUSH
105060: LD_VAR 0 2
105064: EQUAL
105065: IFFALSE 105076
// KillUnit ( vehicle ) ;
105067: LD_VAR 0 2
105071: PPUSH
105072: CALL_OW 66
105076: GO 105036
105078: POP
105079: POP
// end ;
105080: LD_VAR 0 3
105084: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105085: LD_EXP 174
105089: NOT
105090: IFFALSE 105125
105092: GO 105094
105094: DISABLE
// begin initMiner := true ;
105095: LD_ADDR_EXP 174
105099: PUSH
105100: LD_INT 1
105102: ST_TO_ADDR
// minersList := [ ] ;
105103: LD_ADDR_EXP 175
105107: PUSH
105108: EMPTY
105109: ST_TO_ADDR
// minerMinesList := [ ] ;
105110: LD_ADDR_EXP 176
105114: PUSH
105115: EMPTY
105116: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105117: LD_ADDR_EXP 177
105121: PUSH
105122: LD_INT 5
105124: ST_TO_ADDR
// end ;
105125: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105126: LD_EXP 174
105130: PUSH
105131: LD_INT 34
105133: PUSH
105134: LD_INT 81
105136: PUSH
105137: EMPTY
105138: LIST
105139: LIST
105140: PPUSH
105141: CALL_OW 69
105145: AND
105146: IFFALSE 105607
105148: GO 105150
105150: DISABLE
105151: LD_INT 0
105153: PPUSH
105154: PPUSH
105155: PPUSH
105156: PPUSH
// begin enable ;
105157: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105158: LD_ADDR_VAR 0 1
105162: PUSH
105163: LD_INT 34
105165: PUSH
105166: LD_INT 81
105168: PUSH
105169: EMPTY
105170: LIST
105171: LIST
105172: PPUSH
105173: CALL_OW 69
105177: PUSH
105178: FOR_IN
105179: IFFALSE 105251
// begin if not i in minersList then
105181: LD_VAR 0 1
105185: PUSH
105186: LD_EXP 175
105190: IN
105191: NOT
105192: IFFALSE 105249
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105194: LD_ADDR_EXP 175
105198: PUSH
105199: LD_EXP 175
105203: PPUSH
105204: LD_EXP 175
105208: PUSH
105209: LD_INT 1
105211: PLUS
105212: PPUSH
105213: LD_VAR 0 1
105217: PPUSH
105218: CALL_OW 1
105222: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105223: LD_ADDR_EXP 176
105227: PUSH
105228: LD_EXP 176
105232: PPUSH
105233: LD_EXP 176
105237: PUSH
105238: LD_INT 1
105240: PLUS
105241: PPUSH
105242: EMPTY
105243: PPUSH
105244: CALL_OW 1
105248: ST_TO_ADDR
// end end ;
105249: GO 105178
105251: POP
105252: POP
// for i := minerMinesList downto 1 do
105253: LD_ADDR_VAR 0 1
105257: PUSH
105258: DOUBLE
105259: LD_EXP 176
105263: INC
105264: ST_TO_ADDR
105265: LD_INT 1
105267: PUSH
105268: FOR_DOWNTO
105269: IFFALSE 105605
// begin if IsLive ( minersList [ i ] ) then
105271: LD_EXP 175
105275: PUSH
105276: LD_VAR 0 1
105280: ARRAY
105281: PPUSH
105282: CALL_OW 300
105286: IFFALSE 105314
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105288: LD_EXP 175
105292: PUSH
105293: LD_VAR 0 1
105297: ARRAY
105298: PPUSH
105299: LD_EXP 176
105303: PUSH
105304: LD_VAR 0 1
105308: ARRAY
105309: PPUSH
105310: CALL_OW 505
// if not minerMinesList [ i ] then
105314: LD_EXP 176
105318: PUSH
105319: LD_VAR 0 1
105323: ARRAY
105324: NOT
105325: IFFALSE 105329
// continue ;
105327: GO 105268
// for j := minerMinesList [ i ] downto 1 do
105329: LD_ADDR_VAR 0 2
105333: PUSH
105334: DOUBLE
105335: LD_EXP 176
105339: PUSH
105340: LD_VAR 0 1
105344: ARRAY
105345: INC
105346: ST_TO_ADDR
105347: LD_INT 1
105349: PUSH
105350: FOR_DOWNTO
105351: IFFALSE 105601
// begin side := GetSide ( minersList [ i ] ) ;
105353: LD_ADDR_VAR 0 3
105357: PUSH
105358: LD_EXP 175
105362: PUSH
105363: LD_VAR 0 1
105367: ARRAY
105368: PPUSH
105369: CALL_OW 255
105373: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105374: LD_ADDR_VAR 0 4
105378: PUSH
105379: LD_EXP 176
105383: PUSH
105384: LD_VAR 0 1
105388: ARRAY
105389: PUSH
105390: LD_VAR 0 2
105394: ARRAY
105395: PUSH
105396: LD_INT 1
105398: ARRAY
105399: PPUSH
105400: LD_EXP 176
105404: PUSH
105405: LD_VAR 0 1
105409: ARRAY
105410: PUSH
105411: LD_VAR 0 2
105415: ARRAY
105416: PUSH
105417: LD_INT 2
105419: ARRAY
105420: PPUSH
105421: CALL_OW 428
105425: ST_TO_ADDR
// if not tmp then
105426: LD_VAR 0 4
105430: NOT
105431: IFFALSE 105435
// continue ;
105433: GO 105350
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105435: LD_VAR 0 4
105439: PUSH
105440: LD_INT 81
105442: PUSH
105443: LD_VAR 0 3
105447: PUSH
105448: EMPTY
105449: LIST
105450: LIST
105451: PPUSH
105452: CALL_OW 69
105456: IN
105457: PUSH
105458: LD_EXP 176
105462: PUSH
105463: LD_VAR 0 1
105467: ARRAY
105468: PUSH
105469: LD_VAR 0 2
105473: ARRAY
105474: PUSH
105475: LD_INT 1
105477: ARRAY
105478: PPUSH
105479: LD_EXP 176
105483: PUSH
105484: LD_VAR 0 1
105488: ARRAY
105489: PUSH
105490: LD_VAR 0 2
105494: ARRAY
105495: PUSH
105496: LD_INT 2
105498: ARRAY
105499: PPUSH
105500: CALL_OW 458
105504: AND
105505: IFFALSE 105599
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105507: LD_EXP 176
105511: PUSH
105512: LD_VAR 0 1
105516: ARRAY
105517: PUSH
105518: LD_VAR 0 2
105522: ARRAY
105523: PUSH
105524: LD_INT 1
105526: ARRAY
105527: PPUSH
105528: LD_EXP 176
105532: PUSH
105533: LD_VAR 0 1
105537: ARRAY
105538: PUSH
105539: LD_VAR 0 2
105543: ARRAY
105544: PUSH
105545: LD_INT 2
105547: ARRAY
105548: PPUSH
105549: LD_VAR 0 3
105553: PPUSH
105554: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105558: LD_ADDR_EXP 176
105562: PUSH
105563: LD_EXP 176
105567: PPUSH
105568: LD_VAR 0 1
105572: PPUSH
105573: LD_EXP 176
105577: PUSH
105578: LD_VAR 0 1
105582: ARRAY
105583: PPUSH
105584: LD_VAR 0 2
105588: PPUSH
105589: CALL_OW 3
105593: PPUSH
105594: CALL_OW 1
105598: ST_TO_ADDR
// end ; end ;
105599: GO 105350
105601: POP
105602: POP
// end ;
105603: GO 105268
105605: POP
105606: POP
// end ;
105607: PPOPN 4
105609: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105610: LD_INT 0
105612: PPUSH
105613: PPUSH
// result := false ;
105614: LD_ADDR_VAR 0 4
105618: PUSH
105619: LD_INT 0
105621: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105622: LD_VAR 0 1
105626: PPUSH
105627: CALL_OW 264
105631: PUSH
105632: LD_INT 81
105634: EQUAL
105635: NOT
105636: IFFALSE 105640
// exit ;
105638: GO 105880
// index := GetElementIndex ( minersList , unit ) ;
105640: LD_ADDR_VAR 0 5
105644: PUSH
105645: LD_EXP 175
105649: PPUSH
105650: LD_VAR 0 1
105654: PPUSH
105655: CALL 19697 0 2
105659: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105660: LD_EXP 176
105664: PUSH
105665: LD_VAR 0 5
105669: ARRAY
105670: PUSH
105671: LD_EXP 177
105675: GREATEREQUAL
105676: IFFALSE 105680
// exit ;
105678: GO 105880
// ComMoveXY ( unit , x , y ) ;
105680: LD_VAR 0 1
105684: PPUSH
105685: LD_VAR 0 2
105689: PPUSH
105690: LD_VAR 0 3
105694: PPUSH
105695: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105699: LD_INT 35
105701: PPUSH
105702: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105706: LD_VAR 0 1
105710: PPUSH
105711: LD_VAR 0 2
105715: PPUSH
105716: LD_VAR 0 3
105720: PPUSH
105721: CALL 51052 0 3
105725: NOT
105726: PUSH
105727: LD_VAR 0 1
105731: PPUSH
105732: CALL_OW 314
105736: AND
105737: IFFALSE 105741
// exit ;
105739: GO 105880
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105741: LD_VAR 0 2
105745: PPUSH
105746: LD_VAR 0 3
105750: PPUSH
105751: CALL_OW 428
105755: PUSH
105756: LD_VAR 0 1
105760: EQUAL
105761: PUSH
105762: LD_VAR 0 1
105766: PPUSH
105767: CALL_OW 314
105771: NOT
105772: AND
105773: IFFALSE 105699
// PlaySoundXY ( x , y , PlantMine ) ;
105775: LD_VAR 0 2
105779: PPUSH
105780: LD_VAR 0 3
105784: PPUSH
105785: LD_STRING PlantMine
105787: PPUSH
105788: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105792: LD_VAR 0 2
105796: PPUSH
105797: LD_VAR 0 3
105801: PPUSH
105802: LD_VAR 0 1
105806: PPUSH
105807: CALL_OW 255
105811: PPUSH
105812: LD_INT 0
105814: PPUSH
105815: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105819: LD_ADDR_EXP 176
105823: PUSH
105824: LD_EXP 176
105828: PPUSH
105829: LD_VAR 0 5
105833: PUSH
105834: LD_EXP 176
105838: PUSH
105839: LD_VAR 0 5
105843: ARRAY
105844: PUSH
105845: LD_INT 1
105847: PLUS
105848: PUSH
105849: EMPTY
105850: LIST
105851: LIST
105852: PPUSH
105853: LD_VAR 0 2
105857: PUSH
105858: LD_VAR 0 3
105862: PUSH
105863: EMPTY
105864: LIST
105865: LIST
105866: PPUSH
105867: CALL 19912 0 3
105871: ST_TO_ADDR
// result := true ;
105872: LD_ADDR_VAR 0 4
105876: PUSH
105877: LD_INT 1
105879: ST_TO_ADDR
// end ;
105880: LD_VAR 0 4
105884: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105885: LD_INT 0
105887: PPUSH
105888: PPUSH
105889: PPUSH
// if not unit in minersList then
105890: LD_VAR 0 1
105894: PUSH
105895: LD_EXP 175
105899: IN
105900: NOT
105901: IFFALSE 105905
// exit ;
105903: GO 106297
// index := GetElementIndex ( minersList , unit ) ;
105905: LD_ADDR_VAR 0 6
105909: PUSH
105910: LD_EXP 175
105914: PPUSH
105915: LD_VAR 0 1
105919: PPUSH
105920: CALL 19697 0 2
105924: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105925: LD_ADDR_VAR 0 5
105929: PUSH
105930: DOUBLE
105931: LD_EXP 176
105935: PUSH
105936: LD_VAR 0 6
105940: ARRAY
105941: INC
105942: ST_TO_ADDR
105943: LD_INT 1
105945: PUSH
105946: FOR_DOWNTO
105947: IFFALSE 106108
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105949: LD_EXP 176
105953: PUSH
105954: LD_VAR 0 6
105958: ARRAY
105959: PUSH
105960: LD_VAR 0 5
105964: ARRAY
105965: PUSH
105966: LD_INT 1
105968: ARRAY
105969: PUSH
105970: LD_VAR 0 2
105974: EQUAL
105975: PUSH
105976: LD_EXP 176
105980: PUSH
105981: LD_VAR 0 6
105985: ARRAY
105986: PUSH
105987: LD_VAR 0 5
105991: ARRAY
105992: PUSH
105993: LD_INT 2
105995: ARRAY
105996: PUSH
105997: LD_VAR 0 3
106001: EQUAL
106002: AND
106003: IFFALSE 106106
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106005: LD_EXP 176
106009: PUSH
106010: LD_VAR 0 6
106014: ARRAY
106015: PUSH
106016: LD_VAR 0 5
106020: ARRAY
106021: PUSH
106022: LD_INT 1
106024: ARRAY
106025: PPUSH
106026: LD_EXP 176
106030: PUSH
106031: LD_VAR 0 6
106035: ARRAY
106036: PUSH
106037: LD_VAR 0 5
106041: ARRAY
106042: PUSH
106043: LD_INT 2
106045: ARRAY
106046: PPUSH
106047: LD_VAR 0 1
106051: PPUSH
106052: CALL_OW 255
106056: PPUSH
106057: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106061: LD_ADDR_EXP 176
106065: PUSH
106066: LD_EXP 176
106070: PPUSH
106071: LD_VAR 0 6
106075: PPUSH
106076: LD_EXP 176
106080: PUSH
106081: LD_VAR 0 6
106085: ARRAY
106086: PPUSH
106087: LD_VAR 0 5
106091: PPUSH
106092: CALL_OW 3
106096: PPUSH
106097: CALL_OW 1
106101: ST_TO_ADDR
// exit ;
106102: POP
106103: POP
106104: GO 106297
// end ; end ;
106106: GO 105946
106108: POP
106109: POP
// for i := minerMinesList [ index ] downto 1 do
106110: LD_ADDR_VAR 0 5
106114: PUSH
106115: DOUBLE
106116: LD_EXP 176
106120: PUSH
106121: LD_VAR 0 6
106125: ARRAY
106126: INC
106127: ST_TO_ADDR
106128: LD_INT 1
106130: PUSH
106131: FOR_DOWNTO
106132: IFFALSE 106295
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106134: LD_EXP 176
106138: PUSH
106139: LD_VAR 0 6
106143: ARRAY
106144: PUSH
106145: LD_VAR 0 5
106149: ARRAY
106150: PUSH
106151: LD_INT 1
106153: ARRAY
106154: PPUSH
106155: LD_EXP 176
106159: PUSH
106160: LD_VAR 0 6
106164: ARRAY
106165: PUSH
106166: LD_VAR 0 5
106170: ARRAY
106171: PUSH
106172: LD_INT 2
106174: ARRAY
106175: PPUSH
106176: LD_VAR 0 2
106180: PPUSH
106181: LD_VAR 0 3
106185: PPUSH
106186: CALL_OW 298
106190: PUSH
106191: LD_INT 6
106193: LESS
106194: IFFALSE 106293
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106196: LD_EXP 176
106200: PUSH
106201: LD_VAR 0 6
106205: ARRAY
106206: PUSH
106207: LD_VAR 0 5
106211: ARRAY
106212: PUSH
106213: LD_INT 1
106215: ARRAY
106216: PPUSH
106217: LD_EXP 176
106221: PUSH
106222: LD_VAR 0 6
106226: ARRAY
106227: PUSH
106228: LD_VAR 0 5
106232: ARRAY
106233: PUSH
106234: LD_INT 2
106236: ARRAY
106237: PPUSH
106238: LD_VAR 0 1
106242: PPUSH
106243: CALL_OW 255
106247: PPUSH
106248: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106252: LD_ADDR_EXP 176
106256: PUSH
106257: LD_EXP 176
106261: PPUSH
106262: LD_VAR 0 6
106266: PPUSH
106267: LD_EXP 176
106271: PUSH
106272: LD_VAR 0 6
106276: ARRAY
106277: PPUSH
106278: LD_VAR 0 5
106282: PPUSH
106283: CALL_OW 3
106287: PPUSH
106288: CALL_OW 1
106292: ST_TO_ADDR
// end ; end ;
106293: GO 106131
106295: POP
106296: POP
// end ;
106297: LD_VAR 0 4
106301: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106302: LD_INT 0
106304: PPUSH
106305: PPUSH
106306: PPUSH
106307: PPUSH
106308: PPUSH
106309: PPUSH
106310: PPUSH
106311: PPUSH
106312: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106313: LD_VAR 0 1
106317: PPUSH
106318: CALL_OW 264
106322: PUSH
106323: LD_INT 81
106325: EQUAL
106326: NOT
106327: PUSH
106328: LD_VAR 0 1
106332: PUSH
106333: LD_EXP 175
106337: IN
106338: NOT
106339: OR
106340: IFFALSE 106344
// exit ;
106342: GO 106666
// index := GetElementIndex ( minersList , unit ) ;
106344: LD_ADDR_VAR 0 6
106348: PUSH
106349: LD_EXP 175
106353: PPUSH
106354: LD_VAR 0 1
106358: PPUSH
106359: CALL 19697 0 2
106363: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106364: LD_ADDR_VAR 0 8
106368: PUSH
106369: LD_EXP 177
106373: PUSH
106374: LD_EXP 176
106378: PUSH
106379: LD_VAR 0 6
106383: ARRAY
106384: MINUS
106385: ST_TO_ADDR
// if not minesFreeAmount then
106386: LD_VAR 0 8
106390: NOT
106391: IFFALSE 106395
// exit ;
106393: GO 106666
// tmp := [ ] ;
106395: LD_ADDR_VAR 0 7
106399: PUSH
106400: EMPTY
106401: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106402: LD_ADDR_VAR 0 5
106406: PUSH
106407: DOUBLE
106408: LD_INT 1
106410: DEC
106411: ST_TO_ADDR
106412: LD_VAR 0 8
106416: PUSH
106417: FOR_TO
106418: IFFALSE 106613
// begin _d := rand ( 0 , 5 ) ;
106420: LD_ADDR_VAR 0 11
106424: PUSH
106425: LD_INT 0
106427: PPUSH
106428: LD_INT 5
106430: PPUSH
106431: CALL_OW 12
106435: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106436: LD_ADDR_VAR 0 12
106440: PUSH
106441: LD_INT 2
106443: PPUSH
106444: LD_INT 6
106446: PPUSH
106447: CALL_OW 12
106451: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106452: LD_ADDR_VAR 0 9
106456: PUSH
106457: LD_VAR 0 2
106461: PPUSH
106462: LD_VAR 0 11
106466: PPUSH
106467: LD_VAR 0 12
106471: PPUSH
106472: CALL_OW 272
106476: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106477: LD_ADDR_VAR 0 10
106481: PUSH
106482: LD_VAR 0 3
106486: PPUSH
106487: LD_VAR 0 11
106491: PPUSH
106492: LD_VAR 0 12
106496: PPUSH
106497: CALL_OW 273
106501: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106502: LD_VAR 0 9
106506: PPUSH
106507: LD_VAR 0 10
106511: PPUSH
106512: CALL_OW 488
106516: PUSH
106517: LD_VAR 0 9
106521: PUSH
106522: LD_VAR 0 10
106526: PUSH
106527: EMPTY
106528: LIST
106529: LIST
106530: PUSH
106531: LD_VAR 0 7
106535: IN
106536: NOT
106537: AND
106538: PUSH
106539: LD_VAR 0 9
106543: PPUSH
106544: LD_VAR 0 10
106548: PPUSH
106549: CALL_OW 458
106553: NOT
106554: AND
106555: IFFALSE 106597
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106557: LD_ADDR_VAR 0 7
106561: PUSH
106562: LD_VAR 0 7
106566: PPUSH
106567: LD_VAR 0 7
106571: PUSH
106572: LD_INT 1
106574: PLUS
106575: PPUSH
106576: LD_VAR 0 9
106580: PUSH
106581: LD_VAR 0 10
106585: PUSH
106586: EMPTY
106587: LIST
106588: LIST
106589: PPUSH
106590: CALL_OW 1
106594: ST_TO_ADDR
106595: GO 106611
// i := i - 1 ;
106597: LD_ADDR_VAR 0 5
106601: PUSH
106602: LD_VAR 0 5
106606: PUSH
106607: LD_INT 1
106609: MINUS
106610: ST_TO_ADDR
// end ;
106611: GO 106417
106613: POP
106614: POP
// for i in tmp do
106615: LD_ADDR_VAR 0 5
106619: PUSH
106620: LD_VAR 0 7
106624: PUSH
106625: FOR_IN
106626: IFFALSE 106664
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106628: LD_VAR 0 1
106632: PPUSH
106633: LD_VAR 0 5
106637: PUSH
106638: LD_INT 1
106640: ARRAY
106641: PPUSH
106642: LD_VAR 0 5
106646: PUSH
106647: LD_INT 2
106649: ARRAY
106650: PPUSH
106651: CALL 105610 0 3
106655: NOT
106656: IFFALSE 106662
// exit ;
106658: POP
106659: POP
106660: GO 106666
106662: GO 106625
106664: POP
106665: POP
// end ;
106666: LD_VAR 0 4
106670: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106671: LD_INT 0
106673: PPUSH
106674: PPUSH
106675: PPUSH
106676: PPUSH
106677: PPUSH
106678: PPUSH
106679: PPUSH
// if not GetClass ( unit ) = class_sniper then
106680: LD_VAR 0 1
106684: PPUSH
106685: CALL_OW 257
106689: PUSH
106690: LD_INT 5
106692: EQUAL
106693: NOT
106694: IFFALSE 106698
// exit ;
106696: GO 107086
// dist := 8 ;
106698: LD_ADDR_VAR 0 5
106702: PUSH
106703: LD_INT 8
106705: ST_TO_ADDR
// viewRange := 12 ;
106706: LD_ADDR_VAR 0 7
106710: PUSH
106711: LD_INT 12
106713: ST_TO_ADDR
// side := GetSide ( unit ) ;
106714: LD_ADDR_VAR 0 6
106718: PUSH
106719: LD_VAR 0 1
106723: PPUSH
106724: CALL_OW 255
106728: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106729: LD_INT 61
106731: PPUSH
106732: LD_VAR 0 6
106736: PPUSH
106737: CALL_OW 321
106741: PUSH
106742: LD_INT 2
106744: EQUAL
106745: IFFALSE 106755
// viewRange := 16 ;
106747: LD_ADDR_VAR 0 7
106751: PUSH
106752: LD_INT 16
106754: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106755: LD_VAR 0 1
106759: PPUSH
106760: LD_VAR 0 2
106764: PPUSH
106765: LD_VAR 0 3
106769: PPUSH
106770: CALL_OW 297
106774: PUSH
106775: LD_VAR 0 5
106779: GREATER
106780: IFFALSE 106859
// begin ComMoveXY ( unit , x , y ) ;
106782: LD_VAR 0 1
106786: PPUSH
106787: LD_VAR 0 2
106791: PPUSH
106792: LD_VAR 0 3
106796: PPUSH
106797: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106801: LD_INT 35
106803: PPUSH
106804: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106808: LD_VAR 0 1
106812: PPUSH
106813: LD_VAR 0 2
106817: PPUSH
106818: LD_VAR 0 3
106822: PPUSH
106823: CALL 51052 0 3
106827: NOT
106828: IFFALSE 106832
// exit ;
106830: GO 107086
// until GetDistUnitXY ( unit , x , y ) < dist ;
106832: LD_VAR 0 1
106836: PPUSH
106837: LD_VAR 0 2
106841: PPUSH
106842: LD_VAR 0 3
106846: PPUSH
106847: CALL_OW 297
106851: PUSH
106852: LD_VAR 0 5
106856: LESS
106857: IFFALSE 106801
// end ; ComTurnXY ( unit , x , y ) ;
106859: LD_VAR 0 1
106863: PPUSH
106864: LD_VAR 0 2
106868: PPUSH
106869: LD_VAR 0 3
106873: PPUSH
106874: CALL_OW 118
// wait ( 5 ) ;
106878: LD_INT 5
106880: PPUSH
106881: CALL_OW 67
// _d := GetDir ( unit ) ;
106885: LD_ADDR_VAR 0 10
106889: PUSH
106890: LD_VAR 0 1
106894: PPUSH
106895: CALL_OW 254
106899: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106900: LD_ADDR_VAR 0 8
106904: PUSH
106905: LD_VAR 0 1
106909: PPUSH
106910: CALL_OW 250
106914: PPUSH
106915: LD_VAR 0 10
106919: PPUSH
106920: LD_VAR 0 5
106924: PPUSH
106925: CALL_OW 272
106929: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106930: LD_ADDR_VAR 0 9
106934: PUSH
106935: LD_VAR 0 1
106939: PPUSH
106940: CALL_OW 251
106944: PPUSH
106945: LD_VAR 0 10
106949: PPUSH
106950: LD_VAR 0 5
106954: PPUSH
106955: CALL_OW 273
106959: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106960: LD_VAR 0 8
106964: PPUSH
106965: LD_VAR 0 9
106969: PPUSH
106970: CALL_OW 488
106974: NOT
106975: IFFALSE 106979
// exit ;
106977: GO 107086
// ComAnimCustom ( unit , 1 ) ;
106979: LD_VAR 0 1
106983: PPUSH
106984: LD_INT 1
106986: PPUSH
106987: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106991: LD_VAR 0 8
106995: PPUSH
106996: LD_VAR 0 9
107000: PPUSH
107001: LD_VAR 0 6
107005: PPUSH
107006: LD_VAR 0 7
107010: PPUSH
107011: CALL_OW 330
// repeat wait ( 1 ) ;
107015: LD_INT 1
107017: PPUSH
107018: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107022: LD_VAR 0 1
107026: PPUSH
107027: CALL_OW 316
107031: PUSH
107032: LD_VAR 0 1
107036: PPUSH
107037: CALL_OW 314
107041: OR
107042: PUSH
107043: LD_VAR 0 1
107047: PPUSH
107048: CALL_OW 302
107052: NOT
107053: OR
107054: PUSH
107055: LD_VAR 0 1
107059: PPUSH
107060: CALL_OW 301
107064: OR
107065: IFFALSE 107015
// RemoveSeeing ( _x , _y , side ) ;
107067: LD_VAR 0 8
107071: PPUSH
107072: LD_VAR 0 9
107076: PPUSH
107077: LD_VAR 0 6
107081: PPUSH
107082: CALL_OW 331
// end ; end_of_file
107086: LD_VAR 0 4
107090: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107091: LD_INT 0
107093: PPUSH
107094: PPUSH
107095: PPUSH
107096: PPUSH
107097: PPUSH
107098: PPUSH
107099: PPUSH
107100: PPUSH
107101: PPUSH
107102: PPUSH
107103: PPUSH
107104: PPUSH
107105: PPUSH
107106: PPUSH
107107: PPUSH
107108: PPUSH
107109: PPUSH
107110: PPUSH
107111: PPUSH
107112: PPUSH
107113: PPUSH
107114: PPUSH
107115: PPUSH
107116: PPUSH
107117: PPUSH
107118: PPUSH
107119: PPUSH
107120: PPUSH
107121: PPUSH
107122: PPUSH
107123: PPUSH
107124: PPUSH
107125: PPUSH
107126: PPUSH
// if not list then
107127: LD_VAR 0 1
107131: NOT
107132: IFFALSE 107136
// exit ;
107134: GO 111795
// base := list [ 1 ] ;
107136: LD_ADDR_VAR 0 3
107140: PUSH
107141: LD_VAR 0 1
107145: PUSH
107146: LD_INT 1
107148: ARRAY
107149: ST_TO_ADDR
// group := list [ 2 ] ;
107150: LD_ADDR_VAR 0 4
107154: PUSH
107155: LD_VAR 0 1
107159: PUSH
107160: LD_INT 2
107162: ARRAY
107163: ST_TO_ADDR
// path := list [ 3 ] ;
107164: LD_ADDR_VAR 0 5
107168: PUSH
107169: LD_VAR 0 1
107173: PUSH
107174: LD_INT 3
107176: ARRAY
107177: ST_TO_ADDR
// flags := list [ 4 ] ;
107178: LD_ADDR_VAR 0 6
107182: PUSH
107183: LD_VAR 0 1
107187: PUSH
107188: LD_INT 4
107190: ARRAY
107191: ST_TO_ADDR
// mined := [ ] ;
107192: LD_ADDR_VAR 0 27
107196: PUSH
107197: EMPTY
107198: ST_TO_ADDR
// bombed := [ ] ;
107199: LD_ADDR_VAR 0 28
107203: PUSH
107204: EMPTY
107205: ST_TO_ADDR
// healers := [ ] ;
107206: LD_ADDR_VAR 0 31
107210: PUSH
107211: EMPTY
107212: ST_TO_ADDR
// to_heal := [ ] ;
107213: LD_ADDR_VAR 0 30
107217: PUSH
107218: EMPTY
107219: ST_TO_ADDR
// repairs := [ ] ;
107220: LD_ADDR_VAR 0 33
107224: PUSH
107225: EMPTY
107226: ST_TO_ADDR
// to_repair := [ ] ;
107227: LD_ADDR_VAR 0 32
107231: PUSH
107232: EMPTY
107233: ST_TO_ADDR
// if not group or not path then
107234: LD_VAR 0 4
107238: NOT
107239: PUSH
107240: LD_VAR 0 5
107244: NOT
107245: OR
107246: IFFALSE 107250
// exit ;
107248: GO 111795
// side := GetSide ( group [ 1 ] ) ;
107250: LD_ADDR_VAR 0 35
107254: PUSH
107255: LD_VAR 0 4
107259: PUSH
107260: LD_INT 1
107262: ARRAY
107263: PPUSH
107264: CALL_OW 255
107268: ST_TO_ADDR
// if flags then
107269: LD_VAR 0 6
107273: IFFALSE 107417
// begin f_ignore_area := flags [ 1 ] ;
107275: LD_ADDR_VAR 0 17
107279: PUSH
107280: LD_VAR 0 6
107284: PUSH
107285: LD_INT 1
107287: ARRAY
107288: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107289: LD_ADDR_VAR 0 18
107293: PUSH
107294: LD_VAR 0 6
107298: PUSH
107299: LD_INT 2
107301: ARRAY
107302: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107303: LD_ADDR_VAR 0 19
107307: PUSH
107308: LD_VAR 0 6
107312: PUSH
107313: LD_INT 3
107315: ARRAY
107316: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107317: LD_ADDR_VAR 0 20
107321: PUSH
107322: LD_VAR 0 6
107326: PUSH
107327: LD_INT 4
107329: ARRAY
107330: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107331: LD_ADDR_VAR 0 21
107335: PUSH
107336: LD_VAR 0 6
107340: PUSH
107341: LD_INT 5
107343: ARRAY
107344: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107345: LD_ADDR_VAR 0 22
107349: PUSH
107350: LD_VAR 0 6
107354: PUSH
107355: LD_INT 6
107357: ARRAY
107358: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107359: LD_ADDR_VAR 0 23
107363: PUSH
107364: LD_VAR 0 6
107368: PUSH
107369: LD_INT 7
107371: ARRAY
107372: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107373: LD_ADDR_VAR 0 24
107377: PUSH
107378: LD_VAR 0 6
107382: PUSH
107383: LD_INT 8
107385: ARRAY
107386: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107387: LD_ADDR_VAR 0 25
107391: PUSH
107392: LD_VAR 0 6
107396: PUSH
107397: LD_INT 9
107399: ARRAY
107400: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107401: LD_ADDR_VAR 0 26
107405: PUSH
107406: LD_VAR 0 6
107410: PUSH
107411: LD_INT 10
107413: ARRAY
107414: ST_TO_ADDR
// end else
107415: GO 107497
// begin f_ignore_area := false ;
107417: LD_ADDR_VAR 0 17
107421: PUSH
107422: LD_INT 0
107424: ST_TO_ADDR
// f_capture := false ;
107425: LD_ADDR_VAR 0 18
107429: PUSH
107430: LD_INT 0
107432: ST_TO_ADDR
// f_ignore_civ := false ;
107433: LD_ADDR_VAR 0 19
107437: PUSH
107438: LD_INT 0
107440: ST_TO_ADDR
// f_murder := false ;
107441: LD_ADDR_VAR 0 20
107445: PUSH
107446: LD_INT 0
107448: ST_TO_ADDR
// f_mines := false ;
107449: LD_ADDR_VAR 0 21
107453: PUSH
107454: LD_INT 0
107456: ST_TO_ADDR
// f_repair := false ;
107457: LD_ADDR_VAR 0 22
107461: PUSH
107462: LD_INT 0
107464: ST_TO_ADDR
// f_heal := false ;
107465: LD_ADDR_VAR 0 23
107469: PUSH
107470: LD_INT 0
107472: ST_TO_ADDR
// f_spacetime := false ;
107473: LD_ADDR_VAR 0 24
107477: PUSH
107478: LD_INT 0
107480: ST_TO_ADDR
// f_attack_depot := false ;
107481: LD_ADDR_VAR 0 25
107485: PUSH
107486: LD_INT 0
107488: ST_TO_ADDR
// f_crawl := false ;
107489: LD_ADDR_VAR 0 26
107493: PUSH
107494: LD_INT 0
107496: ST_TO_ADDR
// end ; if f_heal then
107497: LD_VAR 0 23
107501: IFFALSE 107528
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107503: LD_ADDR_VAR 0 31
107507: PUSH
107508: LD_VAR 0 4
107512: PPUSH
107513: LD_INT 25
107515: PUSH
107516: LD_INT 4
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: PPUSH
107523: CALL_OW 72
107527: ST_TO_ADDR
// if f_repair then
107528: LD_VAR 0 22
107532: IFFALSE 107559
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107534: LD_ADDR_VAR 0 33
107538: PUSH
107539: LD_VAR 0 4
107543: PPUSH
107544: LD_INT 25
107546: PUSH
107547: LD_INT 3
107549: PUSH
107550: EMPTY
107551: LIST
107552: LIST
107553: PPUSH
107554: CALL_OW 72
107558: ST_TO_ADDR
// units_path := [ ] ;
107559: LD_ADDR_VAR 0 16
107563: PUSH
107564: EMPTY
107565: ST_TO_ADDR
// for i = 1 to group do
107566: LD_ADDR_VAR 0 7
107570: PUSH
107571: DOUBLE
107572: LD_INT 1
107574: DEC
107575: ST_TO_ADDR
107576: LD_VAR 0 4
107580: PUSH
107581: FOR_TO
107582: IFFALSE 107611
// units_path := Replace ( units_path , i , path ) ;
107584: LD_ADDR_VAR 0 16
107588: PUSH
107589: LD_VAR 0 16
107593: PPUSH
107594: LD_VAR 0 7
107598: PPUSH
107599: LD_VAR 0 5
107603: PPUSH
107604: CALL_OW 1
107608: ST_TO_ADDR
107609: GO 107581
107611: POP
107612: POP
// repeat for i = group downto 1 do
107613: LD_ADDR_VAR 0 7
107617: PUSH
107618: DOUBLE
107619: LD_VAR 0 4
107623: INC
107624: ST_TO_ADDR
107625: LD_INT 1
107627: PUSH
107628: FOR_DOWNTO
107629: IFFALSE 111751
// begin wait ( 5 ) ;
107631: LD_INT 5
107633: PPUSH
107634: CALL_OW 67
// tmp := [ ] ;
107638: LD_ADDR_VAR 0 14
107642: PUSH
107643: EMPTY
107644: ST_TO_ADDR
// attacking := false ;
107645: LD_ADDR_VAR 0 29
107649: PUSH
107650: LD_INT 0
107652: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107653: LD_VAR 0 4
107657: PUSH
107658: LD_VAR 0 7
107662: ARRAY
107663: PPUSH
107664: CALL_OW 301
107668: PUSH
107669: LD_VAR 0 4
107673: PUSH
107674: LD_VAR 0 7
107678: ARRAY
107679: NOT
107680: OR
107681: IFFALSE 107790
// begin if GetType ( group [ i ] ) = unit_human then
107683: LD_VAR 0 4
107687: PUSH
107688: LD_VAR 0 7
107692: ARRAY
107693: PPUSH
107694: CALL_OW 247
107698: PUSH
107699: LD_INT 1
107701: EQUAL
107702: IFFALSE 107748
// begin to_heal := to_heal diff group [ i ] ;
107704: LD_ADDR_VAR 0 30
107708: PUSH
107709: LD_VAR 0 30
107713: PUSH
107714: LD_VAR 0 4
107718: PUSH
107719: LD_VAR 0 7
107723: ARRAY
107724: DIFF
107725: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107726: LD_ADDR_VAR 0 31
107730: PUSH
107731: LD_VAR 0 31
107735: PUSH
107736: LD_VAR 0 4
107740: PUSH
107741: LD_VAR 0 7
107745: ARRAY
107746: DIFF
107747: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107748: LD_ADDR_VAR 0 4
107752: PUSH
107753: LD_VAR 0 4
107757: PPUSH
107758: LD_VAR 0 7
107762: PPUSH
107763: CALL_OW 3
107767: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107768: LD_ADDR_VAR 0 16
107772: PUSH
107773: LD_VAR 0 16
107777: PPUSH
107778: LD_VAR 0 7
107782: PPUSH
107783: CALL_OW 3
107787: ST_TO_ADDR
// continue ;
107788: GO 107628
// end ; if f_repair then
107790: LD_VAR 0 22
107794: IFFALSE 108283
// begin if GetType ( group [ i ] ) = unit_vehicle then
107796: LD_VAR 0 4
107800: PUSH
107801: LD_VAR 0 7
107805: ARRAY
107806: PPUSH
107807: CALL_OW 247
107811: PUSH
107812: LD_INT 2
107814: EQUAL
107815: IFFALSE 108005
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107817: LD_VAR 0 4
107821: PUSH
107822: LD_VAR 0 7
107826: ARRAY
107827: PPUSH
107828: CALL_OW 256
107832: PUSH
107833: LD_INT 700
107835: LESS
107836: PUSH
107837: LD_VAR 0 4
107841: PUSH
107842: LD_VAR 0 7
107846: ARRAY
107847: PUSH
107848: LD_VAR 0 32
107852: IN
107853: NOT
107854: AND
107855: IFFALSE 107879
// to_repair := to_repair union group [ i ] ;
107857: LD_ADDR_VAR 0 32
107861: PUSH
107862: LD_VAR 0 32
107866: PUSH
107867: LD_VAR 0 4
107871: PUSH
107872: LD_VAR 0 7
107876: ARRAY
107877: UNION
107878: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107879: LD_VAR 0 4
107883: PUSH
107884: LD_VAR 0 7
107888: ARRAY
107889: PPUSH
107890: CALL_OW 256
107894: PUSH
107895: LD_INT 1000
107897: EQUAL
107898: PUSH
107899: LD_VAR 0 4
107903: PUSH
107904: LD_VAR 0 7
107908: ARRAY
107909: PUSH
107910: LD_VAR 0 32
107914: IN
107915: AND
107916: IFFALSE 107940
// to_repair := to_repair diff group [ i ] ;
107918: LD_ADDR_VAR 0 32
107922: PUSH
107923: LD_VAR 0 32
107927: PUSH
107928: LD_VAR 0 4
107932: PUSH
107933: LD_VAR 0 7
107937: ARRAY
107938: DIFF
107939: ST_TO_ADDR
// if group [ i ] in to_repair then
107940: LD_VAR 0 4
107944: PUSH
107945: LD_VAR 0 7
107949: ARRAY
107950: PUSH
107951: LD_VAR 0 32
107955: IN
107956: IFFALSE 108003
// begin if not IsInArea ( group [ i ] , f_repair ) then
107958: LD_VAR 0 4
107962: PUSH
107963: LD_VAR 0 7
107967: ARRAY
107968: PPUSH
107969: LD_VAR 0 22
107973: PPUSH
107974: CALL_OW 308
107978: NOT
107979: IFFALSE 108001
// ComMoveToArea ( group [ i ] , f_repair ) ;
107981: LD_VAR 0 4
107985: PUSH
107986: LD_VAR 0 7
107990: ARRAY
107991: PPUSH
107992: LD_VAR 0 22
107996: PPUSH
107997: CALL_OW 113
// continue ;
108001: GO 107628
// end ; end else
108003: GO 108283
// if group [ i ] in repairs then
108005: LD_VAR 0 4
108009: PUSH
108010: LD_VAR 0 7
108014: ARRAY
108015: PUSH
108016: LD_VAR 0 33
108020: IN
108021: IFFALSE 108283
// begin if IsInUnit ( group [ i ] ) then
108023: LD_VAR 0 4
108027: PUSH
108028: LD_VAR 0 7
108032: ARRAY
108033: PPUSH
108034: CALL_OW 310
108038: IFFALSE 108106
// begin z := IsInUnit ( group [ i ] ) ;
108040: LD_ADDR_VAR 0 13
108044: PUSH
108045: LD_VAR 0 4
108049: PUSH
108050: LD_VAR 0 7
108054: ARRAY
108055: PPUSH
108056: CALL_OW 310
108060: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108061: LD_VAR 0 13
108065: PUSH
108066: LD_VAR 0 32
108070: IN
108071: PUSH
108072: LD_VAR 0 13
108076: PPUSH
108077: LD_VAR 0 22
108081: PPUSH
108082: CALL_OW 308
108086: AND
108087: IFFALSE 108104
// ComExitVehicle ( group [ i ] ) ;
108089: LD_VAR 0 4
108093: PUSH
108094: LD_VAR 0 7
108098: ARRAY
108099: PPUSH
108100: CALL_OW 121
// end else
108104: GO 108283
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108106: LD_ADDR_VAR 0 13
108110: PUSH
108111: LD_VAR 0 4
108115: PPUSH
108116: LD_INT 95
108118: PUSH
108119: LD_VAR 0 22
108123: PUSH
108124: EMPTY
108125: LIST
108126: LIST
108127: PUSH
108128: LD_INT 58
108130: PUSH
108131: EMPTY
108132: LIST
108133: PUSH
108134: EMPTY
108135: LIST
108136: LIST
108137: PPUSH
108138: CALL_OW 72
108142: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108143: LD_VAR 0 4
108147: PUSH
108148: LD_VAR 0 7
108152: ARRAY
108153: PPUSH
108154: CALL_OW 314
108158: NOT
108159: IFFALSE 108281
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108161: LD_ADDR_VAR 0 10
108165: PUSH
108166: LD_VAR 0 13
108170: PPUSH
108171: LD_VAR 0 4
108175: PUSH
108176: LD_VAR 0 7
108180: ARRAY
108181: PPUSH
108182: CALL_OW 74
108186: ST_TO_ADDR
// if not x then
108187: LD_VAR 0 10
108191: NOT
108192: IFFALSE 108196
// continue ;
108194: GO 107628
// if GetLives ( x ) < 1000 then
108196: LD_VAR 0 10
108200: PPUSH
108201: CALL_OW 256
108205: PUSH
108206: LD_INT 1000
108208: LESS
108209: IFFALSE 108233
// ComRepairVehicle ( group [ i ] , x ) else
108211: LD_VAR 0 4
108215: PUSH
108216: LD_VAR 0 7
108220: ARRAY
108221: PPUSH
108222: LD_VAR 0 10
108226: PPUSH
108227: CALL_OW 129
108231: GO 108281
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108233: LD_VAR 0 23
108237: PUSH
108238: LD_VAR 0 4
108242: PUSH
108243: LD_VAR 0 7
108247: ARRAY
108248: PPUSH
108249: CALL_OW 256
108253: PUSH
108254: LD_INT 1000
108256: LESS
108257: AND
108258: NOT
108259: IFFALSE 108281
// ComEnterUnit ( group [ i ] , x ) ;
108261: LD_VAR 0 4
108265: PUSH
108266: LD_VAR 0 7
108270: ARRAY
108271: PPUSH
108272: LD_VAR 0 10
108276: PPUSH
108277: CALL_OW 120
// end ; continue ;
108281: GO 107628
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108283: LD_VAR 0 23
108287: PUSH
108288: LD_VAR 0 4
108292: PUSH
108293: LD_VAR 0 7
108297: ARRAY
108298: PPUSH
108299: CALL_OW 247
108303: PUSH
108304: LD_INT 1
108306: EQUAL
108307: AND
108308: IFFALSE 108786
// begin if group [ i ] in healers then
108310: LD_VAR 0 4
108314: PUSH
108315: LD_VAR 0 7
108319: ARRAY
108320: PUSH
108321: LD_VAR 0 31
108325: IN
108326: IFFALSE 108599
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108328: LD_VAR 0 4
108332: PUSH
108333: LD_VAR 0 7
108337: ARRAY
108338: PPUSH
108339: LD_VAR 0 23
108343: PPUSH
108344: CALL_OW 308
108348: NOT
108349: PUSH
108350: LD_VAR 0 4
108354: PUSH
108355: LD_VAR 0 7
108359: ARRAY
108360: PPUSH
108361: CALL_OW 314
108365: NOT
108366: AND
108367: IFFALSE 108391
// ComMoveToArea ( group [ i ] , f_heal ) else
108369: LD_VAR 0 4
108373: PUSH
108374: LD_VAR 0 7
108378: ARRAY
108379: PPUSH
108380: LD_VAR 0 23
108384: PPUSH
108385: CALL_OW 113
108389: GO 108597
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108391: LD_VAR 0 4
108395: PUSH
108396: LD_VAR 0 7
108400: ARRAY
108401: PPUSH
108402: CALL 49635 0 1
108406: PPUSH
108407: CALL_OW 256
108411: PUSH
108412: LD_INT 1000
108414: EQUAL
108415: IFFALSE 108434
// ComStop ( group [ i ] ) else
108417: LD_VAR 0 4
108421: PUSH
108422: LD_VAR 0 7
108426: ARRAY
108427: PPUSH
108428: CALL_OW 141
108432: GO 108597
// if not HasTask ( group [ i ] ) and to_heal then
108434: LD_VAR 0 4
108438: PUSH
108439: LD_VAR 0 7
108443: ARRAY
108444: PPUSH
108445: CALL_OW 314
108449: NOT
108450: PUSH
108451: LD_VAR 0 30
108455: AND
108456: IFFALSE 108597
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108458: LD_ADDR_VAR 0 13
108462: PUSH
108463: LD_VAR 0 30
108467: PPUSH
108468: LD_INT 3
108470: PUSH
108471: LD_INT 54
108473: PUSH
108474: EMPTY
108475: LIST
108476: PUSH
108477: EMPTY
108478: LIST
108479: LIST
108480: PPUSH
108481: CALL_OW 72
108485: PPUSH
108486: LD_VAR 0 4
108490: PUSH
108491: LD_VAR 0 7
108495: ARRAY
108496: PPUSH
108497: CALL_OW 74
108501: ST_TO_ADDR
// if z then
108502: LD_VAR 0 13
108506: IFFALSE 108597
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108508: LD_INT 91
108510: PUSH
108511: LD_VAR 0 13
108515: PUSH
108516: LD_INT 10
108518: PUSH
108519: EMPTY
108520: LIST
108521: LIST
108522: LIST
108523: PUSH
108524: LD_INT 81
108526: PUSH
108527: LD_VAR 0 13
108531: PPUSH
108532: CALL_OW 255
108536: PUSH
108537: EMPTY
108538: LIST
108539: LIST
108540: PUSH
108541: EMPTY
108542: LIST
108543: LIST
108544: PPUSH
108545: CALL_OW 69
108549: PUSH
108550: LD_INT 0
108552: EQUAL
108553: IFFALSE 108577
// ComHeal ( group [ i ] , z ) else
108555: LD_VAR 0 4
108559: PUSH
108560: LD_VAR 0 7
108564: ARRAY
108565: PPUSH
108566: LD_VAR 0 13
108570: PPUSH
108571: CALL_OW 128
108575: GO 108597
// ComMoveToArea ( group [ i ] , f_heal ) ;
108577: LD_VAR 0 4
108581: PUSH
108582: LD_VAR 0 7
108586: ARRAY
108587: PPUSH
108588: LD_VAR 0 23
108592: PPUSH
108593: CALL_OW 113
// end ; continue ;
108597: GO 107628
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108599: LD_VAR 0 4
108603: PUSH
108604: LD_VAR 0 7
108608: ARRAY
108609: PPUSH
108610: CALL_OW 256
108614: PUSH
108615: LD_INT 700
108617: LESS
108618: PUSH
108619: LD_VAR 0 4
108623: PUSH
108624: LD_VAR 0 7
108628: ARRAY
108629: PUSH
108630: LD_VAR 0 30
108634: IN
108635: NOT
108636: AND
108637: IFFALSE 108661
// to_heal := to_heal union group [ i ] ;
108639: LD_ADDR_VAR 0 30
108643: PUSH
108644: LD_VAR 0 30
108648: PUSH
108649: LD_VAR 0 4
108653: PUSH
108654: LD_VAR 0 7
108658: ARRAY
108659: UNION
108660: ST_TO_ADDR
// if group [ i ] in to_heal then
108661: LD_VAR 0 4
108665: PUSH
108666: LD_VAR 0 7
108670: ARRAY
108671: PUSH
108672: LD_VAR 0 30
108676: IN
108677: IFFALSE 108786
// begin if GetLives ( group [ i ] ) = 1000 then
108679: LD_VAR 0 4
108683: PUSH
108684: LD_VAR 0 7
108688: ARRAY
108689: PPUSH
108690: CALL_OW 256
108694: PUSH
108695: LD_INT 1000
108697: EQUAL
108698: IFFALSE 108724
// to_heal := to_heal diff group [ i ] else
108700: LD_ADDR_VAR 0 30
108704: PUSH
108705: LD_VAR 0 30
108709: PUSH
108710: LD_VAR 0 4
108714: PUSH
108715: LD_VAR 0 7
108719: ARRAY
108720: DIFF
108721: ST_TO_ADDR
108722: GO 108786
// begin if not IsInArea ( group [ i ] , to_heal ) then
108724: LD_VAR 0 4
108728: PUSH
108729: LD_VAR 0 7
108733: ARRAY
108734: PPUSH
108735: LD_VAR 0 30
108739: PPUSH
108740: CALL_OW 308
108744: NOT
108745: IFFALSE 108769
// ComMoveToArea ( group [ i ] , f_heal ) else
108747: LD_VAR 0 4
108751: PUSH
108752: LD_VAR 0 7
108756: ARRAY
108757: PPUSH
108758: LD_VAR 0 23
108762: PPUSH
108763: CALL_OW 113
108767: GO 108784
// ComHold ( group [ i ] ) ;
108769: LD_VAR 0 4
108773: PUSH
108774: LD_VAR 0 7
108778: ARRAY
108779: PPUSH
108780: CALL_OW 140
// continue ;
108784: GO 107628
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108786: LD_VAR 0 4
108790: PUSH
108791: LD_VAR 0 7
108795: ARRAY
108796: PPUSH
108797: LD_INT 10
108799: PPUSH
108800: CALL 47406 0 2
108804: NOT
108805: PUSH
108806: LD_VAR 0 16
108810: PUSH
108811: LD_VAR 0 7
108815: ARRAY
108816: PUSH
108817: EMPTY
108818: EQUAL
108819: NOT
108820: AND
108821: IFFALSE 109087
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108823: LD_VAR 0 4
108827: PUSH
108828: LD_VAR 0 7
108832: ARRAY
108833: PPUSH
108834: CALL_OW 262
108838: PUSH
108839: LD_INT 1
108841: PUSH
108842: LD_INT 2
108844: PUSH
108845: EMPTY
108846: LIST
108847: LIST
108848: IN
108849: IFFALSE 108890
// if GetFuel ( group [ i ] ) < 10 then
108851: LD_VAR 0 4
108855: PUSH
108856: LD_VAR 0 7
108860: ARRAY
108861: PPUSH
108862: CALL_OW 261
108866: PUSH
108867: LD_INT 10
108869: LESS
108870: IFFALSE 108890
// SetFuel ( group [ i ] , 12 ) ;
108872: LD_VAR 0 4
108876: PUSH
108877: LD_VAR 0 7
108881: ARRAY
108882: PPUSH
108883: LD_INT 12
108885: PPUSH
108886: CALL_OW 240
// if units_path [ i ] then
108890: LD_VAR 0 16
108894: PUSH
108895: LD_VAR 0 7
108899: ARRAY
108900: IFFALSE 109085
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108902: LD_VAR 0 4
108906: PUSH
108907: LD_VAR 0 7
108911: ARRAY
108912: PPUSH
108913: LD_VAR 0 16
108917: PUSH
108918: LD_VAR 0 7
108922: ARRAY
108923: PUSH
108924: LD_INT 1
108926: ARRAY
108927: PUSH
108928: LD_INT 1
108930: ARRAY
108931: PPUSH
108932: LD_VAR 0 16
108936: PUSH
108937: LD_VAR 0 7
108941: ARRAY
108942: PUSH
108943: LD_INT 1
108945: ARRAY
108946: PUSH
108947: LD_INT 2
108949: ARRAY
108950: PPUSH
108951: CALL_OW 297
108955: PUSH
108956: LD_INT 6
108958: GREATER
108959: IFFALSE 109034
// begin if not HasTask ( group [ i ] ) then
108961: LD_VAR 0 4
108965: PUSH
108966: LD_VAR 0 7
108970: ARRAY
108971: PPUSH
108972: CALL_OW 314
108976: NOT
108977: IFFALSE 109032
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108979: LD_VAR 0 4
108983: PUSH
108984: LD_VAR 0 7
108988: ARRAY
108989: PPUSH
108990: LD_VAR 0 16
108994: PUSH
108995: LD_VAR 0 7
108999: ARRAY
109000: PUSH
109001: LD_INT 1
109003: ARRAY
109004: PUSH
109005: LD_INT 1
109007: ARRAY
109008: PPUSH
109009: LD_VAR 0 16
109013: PUSH
109014: LD_VAR 0 7
109018: ARRAY
109019: PUSH
109020: LD_INT 1
109022: ARRAY
109023: PUSH
109024: LD_INT 2
109026: ARRAY
109027: PPUSH
109028: CALL_OW 114
// end else
109032: GO 109085
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109034: LD_ADDR_VAR 0 15
109038: PUSH
109039: LD_VAR 0 16
109043: PUSH
109044: LD_VAR 0 7
109048: ARRAY
109049: PPUSH
109050: LD_INT 1
109052: PPUSH
109053: CALL_OW 3
109057: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109058: LD_ADDR_VAR 0 16
109062: PUSH
109063: LD_VAR 0 16
109067: PPUSH
109068: LD_VAR 0 7
109072: PPUSH
109073: LD_VAR 0 15
109077: PPUSH
109078: CALL_OW 1
109082: ST_TO_ADDR
// continue ;
109083: GO 107628
// end ; end ; end else
109085: GO 111749
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109087: LD_ADDR_VAR 0 14
109091: PUSH
109092: LD_INT 81
109094: PUSH
109095: LD_VAR 0 4
109099: PUSH
109100: LD_VAR 0 7
109104: ARRAY
109105: PPUSH
109106: CALL_OW 255
109110: PUSH
109111: EMPTY
109112: LIST
109113: LIST
109114: PPUSH
109115: CALL_OW 69
109119: ST_TO_ADDR
// if not tmp then
109120: LD_VAR 0 14
109124: NOT
109125: IFFALSE 109129
// continue ;
109127: GO 107628
// if f_ignore_area then
109129: LD_VAR 0 17
109133: IFFALSE 109221
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109135: LD_ADDR_VAR 0 15
109139: PUSH
109140: LD_VAR 0 14
109144: PPUSH
109145: LD_INT 3
109147: PUSH
109148: LD_INT 92
109150: PUSH
109151: LD_VAR 0 17
109155: PUSH
109156: LD_INT 1
109158: ARRAY
109159: PUSH
109160: LD_VAR 0 17
109164: PUSH
109165: LD_INT 2
109167: ARRAY
109168: PUSH
109169: LD_VAR 0 17
109173: PUSH
109174: LD_INT 3
109176: ARRAY
109177: PUSH
109178: EMPTY
109179: LIST
109180: LIST
109181: LIST
109182: LIST
109183: PUSH
109184: EMPTY
109185: LIST
109186: LIST
109187: PPUSH
109188: CALL_OW 72
109192: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109193: LD_VAR 0 14
109197: PUSH
109198: LD_VAR 0 15
109202: DIFF
109203: IFFALSE 109221
// tmp := tmp diff tmp2 ;
109205: LD_ADDR_VAR 0 14
109209: PUSH
109210: LD_VAR 0 14
109214: PUSH
109215: LD_VAR 0 15
109219: DIFF
109220: ST_TO_ADDR
// end ; if not f_murder then
109221: LD_VAR 0 20
109225: NOT
109226: IFFALSE 109284
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109228: LD_ADDR_VAR 0 15
109232: PUSH
109233: LD_VAR 0 14
109237: PPUSH
109238: LD_INT 3
109240: PUSH
109241: LD_INT 50
109243: PUSH
109244: EMPTY
109245: LIST
109246: PUSH
109247: EMPTY
109248: LIST
109249: LIST
109250: PPUSH
109251: CALL_OW 72
109255: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109256: LD_VAR 0 14
109260: PUSH
109261: LD_VAR 0 15
109265: DIFF
109266: IFFALSE 109284
// tmp := tmp diff tmp2 ;
109268: LD_ADDR_VAR 0 14
109272: PUSH
109273: LD_VAR 0 14
109277: PUSH
109278: LD_VAR 0 15
109282: DIFF
109283: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109284: LD_ADDR_VAR 0 14
109288: PUSH
109289: LD_VAR 0 4
109293: PUSH
109294: LD_VAR 0 7
109298: ARRAY
109299: PPUSH
109300: LD_VAR 0 14
109304: PPUSH
109305: LD_INT 1
109307: PPUSH
109308: LD_INT 1
109310: PPUSH
109311: CALL 20347 0 4
109315: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109316: LD_VAR 0 4
109320: PUSH
109321: LD_VAR 0 7
109325: ARRAY
109326: PPUSH
109327: CALL_OW 257
109331: PUSH
109332: LD_INT 1
109334: EQUAL
109335: IFFALSE 109783
// begin if WantPlant ( group [ i ] ) then
109337: LD_VAR 0 4
109341: PUSH
109342: LD_VAR 0 7
109346: ARRAY
109347: PPUSH
109348: CALL 19848 0 1
109352: IFFALSE 109356
// continue ;
109354: GO 107628
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109356: LD_VAR 0 18
109360: PUSH
109361: LD_VAR 0 4
109365: PUSH
109366: LD_VAR 0 7
109370: ARRAY
109371: PPUSH
109372: CALL_OW 310
109376: NOT
109377: AND
109378: PUSH
109379: LD_VAR 0 14
109383: PUSH
109384: LD_INT 1
109386: ARRAY
109387: PUSH
109388: LD_VAR 0 14
109392: PPUSH
109393: LD_INT 21
109395: PUSH
109396: LD_INT 2
109398: PUSH
109399: EMPTY
109400: LIST
109401: LIST
109402: PUSH
109403: LD_INT 58
109405: PUSH
109406: EMPTY
109407: LIST
109408: PUSH
109409: EMPTY
109410: LIST
109411: LIST
109412: PPUSH
109413: CALL_OW 72
109417: IN
109418: AND
109419: IFFALSE 109455
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109421: LD_VAR 0 4
109425: PUSH
109426: LD_VAR 0 7
109430: ARRAY
109431: PPUSH
109432: LD_VAR 0 14
109436: PUSH
109437: LD_INT 1
109439: ARRAY
109440: PPUSH
109441: CALL_OW 120
// attacking := true ;
109445: LD_ADDR_VAR 0 29
109449: PUSH
109450: LD_INT 1
109452: ST_TO_ADDR
// continue ;
109453: GO 107628
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109455: LD_VAR 0 26
109459: PUSH
109460: LD_VAR 0 4
109464: PUSH
109465: LD_VAR 0 7
109469: ARRAY
109470: PPUSH
109471: CALL_OW 257
109475: PUSH
109476: LD_INT 1
109478: EQUAL
109479: AND
109480: PUSH
109481: LD_VAR 0 4
109485: PUSH
109486: LD_VAR 0 7
109490: ARRAY
109491: PPUSH
109492: CALL_OW 256
109496: PUSH
109497: LD_INT 800
109499: LESS
109500: AND
109501: PUSH
109502: LD_VAR 0 4
109506: PUSH
109507: LD_VAR 0 7
109511: ARRAY
109512: PPUSH
109513: CALL_OW 318
109517: NOT
109518: AND
109519: IFFALSE 109536
// ComCrawl ( group [ i ] ) ;
109521: LD_VAR 0 4
109525: PUSH
109526: LD_VAR 0 7
109530: ARRAY
109531: PPUSH
109532: CALL_OW 137
// if f_mines then
109536: LD_VAR 0 21
109540: IFFALSE 109783
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109542: LD_VAR 0 14
109546: PUSH
109547: LD_INT 1
109549: ARRAY
109550: PPUSH
109551: CALL_OW 247
109555: PUSH
109556: LD_INT 3
109558: EQUAL
109559: PUSH
109560: LD_VAR 0 14
109564: PUSH
109565: LD_INT 1
109567: ARRAY
109568: PUSH
109569: LD_VAR 0 27
109573: IN
109574: NOT
109575: AND
109576: IFFALSE 109783
// begin x := GetX ( tmp [ 1 ] ) ;
109578: LD_ADDR_VAR 0 10
109582: PUSH
109583: LD_VAR 0 14
109587: PUSH
109588: LD_INT 1
109590: ARRAY
109591: PPUSH
109592: CALL_OW 250
109596: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109597: LD_ADDR_VAR 0 11
109601: PUSH
109602: LD_VAR 0 14
109606: PUSH
109607: LD_INT 1
109609: ARRAY
109610: PPUSH
109611: CALL_OW 251
109615: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109616: LD_ADDR_VAR 0 12
109620: PUSH
109621: LD_VAR 0 4
109625: PUSH
109626: LD_VAR 0 7
109630: ARRAY
109631: PPUSH
109632: CALL 47491 0 1
109636: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109637: LD_VAR 0 4
109641: PUSH
109642: LD_VAR 0 7
109646: ARRAY
109647: PPUSH
109648: LD_VAR 0 10
109652: PPUSH
109653: LD_VAR 0 11
109657: PPUSH
109658: LD_VAR 0 14
109662: PUSH
109663: LD_INT 1
109665: ARRAY
109666: PPUSH
109667: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109671: LD_VAR 0 4
109675: PUSH
109676: LD_VAR 0 7
109680: ARRAY
109681: PPUSH
109682: LD_VAR 0 10
109686: PPUSH
109687: LD_VAR 0 12
109691: PPUSH
109692: LD_INT 7
109694: PPUSH
109695: CALL_OW 272
109699: PPUSH
109700: LD_VAR 0 11
109704: PPUSH
109705: LD_VAR 0 12
109709: PPUSH
109710: LD_INT 7
109712: PPUSH
109713: CALL_OW 273
109717: PPUSH
109718: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109722: LD_VAR 0 4
109726: PUSH
109727: LD_VAR 0 7
109731: ARRAY
109732: PPUSH
109733: LD_INT 71
109735: PPUSH
109736: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109740: LD_ADDR_VAR 0 27
109744: PUSH
109745: LD_VAR 0 27
109749: PPUSH
109750: LD_VAR 0 27
109754: PUSH
109755: LD_INT 1
109757: PLUS
109758: PPUSH
109759: LD_VAR 0 14
109763: PUSH
109764: LD_INT 1
109766: ARRAY
109767: PPUSH
109768: CALL_OW 1
109772: ST_TO_ADDR
// attacking := true ;
109773: LD_ADDR_VAR 0 29
109777: PUSH
109778: LD_INT 1
109780: ST_TO_ADDR
// continue ;
109781: GO 107628
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109783: LD_VAR 0 4
109787: PUSH
109788: LD_VAR 0 7
109792: ARRAY
109793: PPUSH
109794: CALL_OW 257
109798: PUSH
109799: LD_INT 17
109801: EQUAL
109802: PUSH
109803: LD_VAR 0 4
109807: PUSH
109808: LD_VAR 0 7
109812: ARRAY
109813: PPUSH
109814: CALL_OW 110
109818: PUSH
109819: LD_INT 71
109821: EQUAL
109822: NOT
109823: AND
109824: IFFALSE 109970
// begin attacking := false ;
109826: LD_ADDR_VAR 0 29
109830: PUSH
109831: LD_INT 0
109833: ST_TO_ADDR
// k := 5 ;
109834: LD_ADDR_VAR 0 9
109838: PUSH
109839: LD_INT 5
109841: ST_TO_ADDR
// if tmp < k then
109842: LD_VAR 0 14
109846: PUSH
109847: LD_VAR 0 9
109851: LESS
109852: IFFALSE 109864
// k := tmp ;
109854: LD_ADDR_VAR 0 9
109858: PUSH
109859: LD_VAR 0 14
109863: ST_TO_ADDR
// for j = 1 to k do
109864: LD_ADDR_VAR 0 8
109868: PUSH
109869: DOUBLE
109870: LD_INT 1
109872: DEC
109873: ST_TO_ADDR
109874: LD_VAR 0 9
109878: PUSH
109879: FOR_TO
109880: IFFALSE 109968
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109882: LD_VAR 0 14
109886: PUSH
109887: LD_VAR 0 8
109891: ARRAY
109892: PUSH
109893: LD_VAR 0 14
109897: PPUSH
109898: LD_INT 58
109900: PUSH
109901: EMPTY
109902: LIST
109903: PPUSH
109904: CALL_OW 72
109908: IN
109909: NOT
109910: IFFALSE 109966
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109912: LD_VAR 0 4
109916: PUSH
109917: LD_VAR 0 7
109921: ARRAY
109922: PPUSH
109923: LD_VAR 0 14
109927: PUSH
109928: LD_VAR 0 8
109932: ARRAY
109933: PPUSH
109934: CALL_OW 115
// attacking := true ;
109938: LD_ADDR_VAR 0 29
109942: PUSH
109943: LD_INT 1
109945: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109946: LD_VAR 0 4
109950: PUSH
109951: LD_VAR 0 7
109955: ARRAY
109956: PPUSH
109957: LD_INT 71
109959: PPUSH
109960: CALL_OW 109
// continue ;
109964: GO 109879
// end ; end ;
109966: GO 109879
109968: POP
109969: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109970: LD_VAR 0 4
109974: PUSH
109975: LD_VAR 0 7
109979: ARRAY
109980: PPUSH
109981: CALL_OW 257
109985: PUSH
109986: LD_INT 8
109988: EQUAL
109989: PUSH
109990: LD_VAR 0 4
109994: PUSH
109995: LD_VAR 0 7
109999: ARRAY
110000: PPUSH
110001: CALL_OW 264
110005: PUSH
110006: LD_INT 28
110008: PUSH
110009: LD_INT 45
110011: PUSH
110012: LD_INT 7
110014: PUSH
110015: LD_INT 47
110017: PUSH
110018: EMPTY
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: IN
110024: OR
110025: IFFALSE 110281
// begin attacking := false ;
110027: LD_ADDR_VAR 0 29
110031: PUSH
110032: LD_INT 0
110034: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110035: LD_VAR 0 14
110039: PUSH
110040: LD_INT 1
110042: ARRAY
110043: PPUSH
110044: CALL_OW 266
110048: PUSH
110049: LD_INT 32
110051: PUSH
110052: LD_INT 31
110054: PUSH
110055: LD_INT 33
110057: PUSH
110058: LD_INT 4
110060: PUSH
110061: LD_INT 5
110063: PUSH
110064: EMPTY
110065: LIST
110066: LIST
110067: LIST
110068: LIST
110069: LIST
110070: IN
110071: IFFALSE 110257
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110073: LD_ADDR_VAR 0 9
110077: PUSH
110078: LD_VAR 0 14
110082: PUSH
110083: LD_INT 1
110085: ARRAY
110086: PPUSH
110087: CALL_OW 266
110091: PPUSH
110092: LD_VAR 0 14
110096: PUSH
110097: LD_INT 1
110099: ARRAY
110100: PPUSH
110101: CALL_OW 250
110105: PPUSH
110106: LD_VAR 0 14
110110: PUSH
110111: LD_INT 1
110113: ARRAY
110114: PPUSH
110115: CALL_OW 251
110119: PPUSH
110120: LD_VAR 0 14
110124: PUSH
110125: LD_INT 1
110127: ARRAY
110128: PPUSH
110129: CALL_OW 254
110133: PPUSH
110134: LD_VAR 0 14
110138: PUSH
110139: LD_INT 1
110141: ARRAY
110142: PPUSH
110143: CALL_OW 248
110147: PPUSH
110148: LD_INT 0
110150: PPUSH
110151: CALL 28861 0 6
110155: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110156: LD_ADDR_VAR 0 8
110160: PUSH
110161: LD_VAR 0 4
110165: PUSH
110166: LD_VAR 0 7
110170: ARRAY
110171: PPUSH
110172: LD_VAR 0 9
110176: PPUSH
110177: CALL 47604 0 2
110181: ST_TO_ADDR
// if j then
110182: LD_VAR 0 8
110186: IFFALSE 110255
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110188: LD_VAR 0 8
110192: PUSH
110193: LD_INT 1
110195: ARRAY
110196: PPUSH
110197: LD_VAR 0 8
110201: PUSH
110202: LD_INT 2
110204: ARRAY
110205: PPUSH
110206: CALL_OW 488
110210: IFFALSE 110255
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110212: LD_VAR 0 4
110216: PUSH
110217: LD_VAR 0 7
110221: ARRAY
110222: PPUSH
110223: LD_VAR 0 8
110227: PUSH
110228: LD_INT 1
110230: ARRAY
110231: PPUSH
110232: LD_VAR 0 8
110236: PUSH
110237: LD_INT 2
110239: ARRAY
110240: PPUSH
110241: CALL_OW 116
// attacking := true ;
110245: LD_ADDR_VAR 0 29
110249: PUSH
110250: LD_INT 1
110252: ST_TO_ADDR
// continue ;
110253: GO 107628
// end ; end else
110255: GO 110281
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110257: LD_VAR 0 4
110261: PUSH
110262: LD_VAR 0 7
110266: ARRAY
110267: PPUSH
110268: LD_VAR 0 14
110272: PUSH
110273: LD_INT 1
110275: ARRAY
110276: PPUSH
110277: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110281: LD_VAR 0 4
110285: PUSH
110286: LD_VAR 0 7
110290: ARRAY
110291: PPUSH
110292: CALL_OW 265
110296: PUSH
110297: LD_INT 11
110299: EQUAL
110300: IFFALSE 110578
// begin k := 10 ;
110302: LD_ADDR_VAR 0 9
110306: PUSH
110307: LD_INT 10
110309: ST_TO_ADDR
// x := 0 ;
110310: LD_ADDR_VAR 0 10
110314: PUSH
110315: LD_INT 0
110317: ST_TO_ADDR
// if tmp < k then
110318: LD_VAR 0 14
110322: PUSH
110323: LD_VAR 0 9
110327: LESS
110328: IFFALSE 110340
// k := tmp ;
110330: LD_ADDR_VAR 0 9
110334: PUSH
110335: LD_VAR 0 14
110339: ST_TO_ADDR
// for j = k downto 1 do
110340: LD_ADDR_VAR 0 8
110344: PUSH
110345: DOUBLE
110346: LD_VAR 0 9
110350: INC
110351: ST_TO_ADDR
110352: LD_INT 1
110354: PUSH
110355: FOR_DOWNTO
110356: IFFALSE 110431
// begin if GetType ( tmp [ j ] ) = unit_human then
110358: LD_VAR 0 14
110362: PUSH
110363: LD_VAR 0 8
110367: ARRAY
110368: PPUSH
110369: CALL_OW 247
110373: PUSH
110374: LD_INT 1
110376: EQUAL
110377: IFFALSE 110429
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110379: LD_VAR 0 4
110383: PUSH
110384: LD_VAR 0 7
110388: ARRAY
110389: PPUSH
110390: LD_VAR 0 14
110394: PUSH
110395: LD_VAR 0 8
110399: ARRAY
110400: PPUSH
110401: CALL 47858 0 2
// x := tmp [ j ] ;
110405: LD_ADDR_VAR 0 10
110409: PUSH
110410: LD_VAR 0 14
110414: PUSH
110415: LD_VAR 0 8
110419: ARRAY
110420: ST_TO_ADDR
// attacking := true ;
110421: LD_ADDR_VAR 0 29
110425: PUSH
110426: LD_INT 1
110428: ST_TO_ADDR
// end ; end ;
110429: GO 110355
110431: POP
110432: POP
// if not x then
110433: LD_VAR 0 10
110437: NOT
110438: IFFALSE 110578
// begin attacking := true ;
110440: LD_ADDR_VAR 0 29
110444: PUSH
110445: LD_INT 1
110447: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110448: LD_VAR 0 4
110452: PUSH
110453: LD_VAR 0 7
110457: ARRAY
110458: PPUSH
110459: CALL_OW 250
110463: PPUSH
110464: LD_VAR 0 4
110468: PUSH
110469: LD_VAR 0 7
110473: ARRAY
110474: PPUSH
110475: CALL_OW 251
110479: PPUSH
110480: CALL_OW 546
110484: PUSH
110485: LD_INT 2
110487: ARRAY
110488: PUSH
110489: LD_VAR 0 14
110493: PUSH
110494: LD_INT 1
110496: ARRAY
110497: PPUSH
110498: CALL_OW 250
110502: PPUSH
110503: LD_VAR 0 14
110507: PUSH
110508: LD_INT 1
110510: ARRAY
110511: PPUSH
110512: CALL_OW 251
110516: PPUSH
110517: CALL_OW 546
110521: PUSH
110522: LD_INT 2
110524: ARRAY
110525: EQUAL
110526: IFFALSE 110554
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110528: LD_VAR 0 4
110532: PUSH
110533: LD_VAR 0 7
110537: ARRAY
110538: PPUSH
110539: LD_VAR 0 14
110543: PUSH
110544: LD_INT 1
110546: ARRAY
110547: PPUSH
110548: CALL 47858 0 2
110552: GO 110578
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110554: LD_VAR 0 4
110558: PUSH
110559: LD_VAR 0 7
110563: ARRAY
110564: PPUSH
110565: LD_VAR 0 14
110569: PUSH
110570: LD_INT 1
110572: ARRAY
110573: PPUSH
110574: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110578: LD_VAR 0 4
110582: PUSH
110583: LD_VAR 0 7
110587: ARRAY
110588: PPUSH
110589: CALL_OW 264
110593: PUSH
110594: LD_INT 29
110596: EQUAL
110597: IFFALSE 110963
// begin if WantsToAttack ( group [ i ] ) in bombed then
110599: LD_VAR 0 4
110603: PUSH
110604: LD_VAR 0 7
110608: ARRAY
110609: PPUSH
110610: CALL_OW 319
110614: PUSH
110615: LD_VAR 0 28
110619: IN
110620: IFFALSE 110624
// continue ;
110622: GO 107628
// k := 8 ;
110624: LD_ADDR_VAR 0 9
110628: PUSH
110629: LD_INT 8
110631: ST_TO_ADDR
// x := 0 ;
110632: LD_ADDR_VAR 0 10
110636: PUSH
110637: LD_INT 0
110639: ST_TO_ADDR
// if tmp < k then
110640: LD_VAR 0 14
110644: PUSH
110645: LD_VAR 0 9
110649: LESS
110650: IFFALSE 110662
// k := tmp ;
110652: LD_ADDR_VAR 0 9
110656: PUSH
110657: LD_VAR 0 14
110661: ST_TO_ADDR
// for j = 1 to k do
110662: LD_ADDR_VAR 0 8
110666: PUSH
110667: DOUBLE
110668: LD_INT 1
110670: DEC
110671: ST_TO_ADDR
110672: LD_VAR 0 9
110676: PUSH
110677: FOR_TO
110678: IFFALSE 110810
// begin if GetType ( tmp [ j ] ) = unit_building then
110680: LD_VAR 0 14
110684: PUSH
110685: LD_VAR 0 8
110689: ARRAY
110690: PPUSH
110691: CALL_OW 247
110695: PUSH
110696: LD_INT 3
110698: EQUAL
110699: IFFALSE 110808
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110701: LD_VAR 0 14
110705: PUSH
110706: LD_VAR 0 8
110710: ARRAY
110711: PUSH
110712: LD_VAR 0 28
110716: IN
110717: NOT
110718: PUSH
110719: LD_VAR 0 14
110723: PUSH
110724: LD_VAR 0 8
110728: ARRAY
110729: PPUSH
110730: CALL_OW 313
110734: AND
110735: IFFALSE 110808
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110737: LD_VAR 0 4
110741: PUSH
110742: LD_VAR 0 7
110746: ARRAY
110747: PPUSH
110748: LD_VAR 0 14
110752: PUSH
110753: LD_VAR 0 8
110757: ARRAY
110758: PPUSH
110759: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110763: LD_ADDR_VAR 0 28
110767: PUSH
110768: LD_VAR 0 28
110772: PPUSH
110773: LD_VAR 0 28
110777: PUSH
110778: LD_INT 1
110780: PLUS
110781: PPUSH
110782: LD_VAR 0 14
110786: PUSH
110787: LD_VAR 0 8
110791: ARRAY
110792: PPUSH
110793: CALL_OW 1
110797: ST_TO_ADDR
// attacking := true ;
110798: LD_ADDR_VAR 0 29
110802: PUSH
110803: LD_INT 1
110805: ST_TO_ADDR
// break ;
110806: GO 110810
// end ; end ;
110808: GO 110677
110810: POP
110811: POP
// if not attacking and f_attack_depot then
110812: LD_VAR 0 29
110816: NOT
110817: PUSH
110818: LD_VAR 0 25
110822: AND
110823: IFFALSE 110918
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110825: LD_ADDR_VAR 0 13
110829: PUSH
110830: LD_VAR 0 14
110834: PPUSH
110835: LD_INT 2
110837: PUSH
110838: LD_INT 30
110840: PUSH
110841: LD_INT 0
110843: PUSH
110844: EMPTY
110845: LIST
110846: LIST
110847: PUSH
110848: LD_INT 30
110850: PUSH
110851: LD_INT 1
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: PUSH
110858: EMPTY
110859: LIST
110860: LIST
110861: LIST
110862: PPUSH
110863: CALL_OW 72
110867: ST_TO_ADDR
// if z then
110868: LD_VAR 0 13
110872: IFFALSE 110918
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110874: LD_VAR 0 4
110878: PUSH
110879: LD_VAR 0 7
110883: ARRAY
110884: PPUSH
110885: LD_VAR 0 13
110889: PPUSH
110890: LD_VAR 0 4
110894: PUSH
110895: LD_VAR 0 7
110899: ARRAY
110900: PPUSH
110901: CALL_OW 74
110905: PPUSH
110906: CALL_OW 115
// attacking := true ;
110910: LD_ADDR_VAR 0 29
110914: PUSH
110915: LD_INT 1
110917: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110918: LD_VAR 0 4
110922: PUSH
110923: LD_VAR 0 7
110927: ARRAY
110928: PPUSH
110929: CALL_OW 256
110933: PUSH
110934: LD_INT 500
110936: LESS
110937: IFFALSE 110963
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110939: LD_VAR 0 4
110943: PUSH
110944: LD_VAR 0 7
110948: ARRAY
110949: PPUSH
110950: LD_VAR 0 14
110954: PUSH
110955: LD_INT 1
110957: ARRAY
110958: PPUSH
110959: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110963: LD_VAR 0 4
110967: PUSH
110968: LD_VAR 0 7
110972: ARRAY
110973: PPUSH
110974: CALL_OW 264
110978: PUSH
110979: LD_INT 49
110981: EQUAL
110982: IFFALSE 111103
// begin if not HasTask ( group [ i ] ) then
110984: LD_VAR 0 4
110988: PUSH
110989: LD_VAR 0 7
110993: ARRAY
110994: PPUSH
110995: CALL_OW 314
110999: NOT
111000: IFFALSE 111103
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111002: LD_ADDR_VAR 0 9
111006: PUSH
111007: LD_INT 81
111009: PUSH
111010: LD_VAR 0 4
111014: PUSH
111015: LD_VAR 0 7
111019: ARRAY
111020: PPUSH
111021: CALL_OW 255
111025: PUSH
111026: EMPTY
111027: LIST
111028: LIST
111029: PPUSH
111030: CALL_OW 69
111034: PPUSH
111035: LD_VAR 0 4
111039: PUSH
111040: LD_VAR 0 7
111044: ARRAY
111045: PPUSH
111046: CALL_OW 74
111050: ST_TO_ADDR
// if k then
111051: LD_VAR 0 9
111055: IFFALSE 111103
// if GetDistUnits ( group [ i ] , k ) > 10 then
111057: LD_VAR 0 4
111061: PUSH
111062: LD_VAR 0 7
111066: ARRAY
111067: PPUSH
111068: LD_VAR 0 9
111072: PPUSH
111073: CALL_OW 296
111077: PUSH
111078: LD_INT 10
111080: GREATER
111081: IFFALSE 111103
// ComMoveUnit ( group [ i ] , k ) ;
111083: LD_VAR 0 4
111087: PUSH
111088: LD_VAR 0 7
111092: ARRAY
111093: PPUSH
111094: LD_VAR 0 9
111098: PPUSH
111099: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111103: LD_VAR 0 4
111107: PUSH
111108: LD_VAR 0 7
111112: ARRAY
111113: PPUSH
111114: CALL_OW 256
111118: PUSH
111119: LD_INT 250
111121: LESS
111122: PUSH
111123: LD_VAR 0 4
111127: PUSH
111128: LD_VAR 0 7
111132: ARRAY
111133: PUSH
111134: LD_INT 21
111136: PUSH
111137: LD_INT 2
111139: PUSH
111140: EMPTY
111141: LIST
111142: LIST
111143: PUSH
111144: LD_INT 23
111146: PUSH
111147: LD_INT 2
111149: PUSH
111150: EMPTY
111151: LIST
111152: LIST
111153: PUSH
111154: EMPTY
111155: LIST
111156: LIST
111157: PPUSH
111158: CALL_OW 69
111162: IN
111163: AND
111164: IFFALSE 111289
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111166: LD_ADDR_VAR 0 9
111170: PUSH
111171: LD_OWVAR 3
111175: PUSH
111176: LD_VAR 0 4
111180: PUSH
111181: LD_VAR 0 7
111185: ARRAY
111186: DIFF
111187: PPUSH
111188: LD_VAR 0 4
111192: PUSH
111193: LD_VAR 0 7
111197: ARRAY
111198: PPUSH
111199: CALL_OW 74
111203: ST_TO_ADDR
// if not k then
111204: LD_VAR 0 9
111208: NOT
111209: IFFALSE 111213
// continue ;
111211: GO 107628
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111213: LD_VAR 0 9
111217: PUSH
111218: LD_INT 81
111220: PUSH
111221: LD_VAR 0 4
111225: PUSH
111226: LD_VAR 0 7
111230: ARRAY
111231: PPUSH
111232: CALL_OW 255
111236: PUSH
111237: EMPTY
111238: LIST
111239: LIST
111240: PPUSH
111241: CALL_OW 69
111245: IN
111246: PUSH
111247: LD_VAR 0 9
111251: PPUSH
111252: LD_VAR 0 4
111256: PUSH
111257: LD_VAR 0 7
111261: ARRAY
111262: PPUSH
111263: CALL_OW 296
111267: PUSH
111268: LD_INT 5
111270: LESS
111271: AND
111272: IFFALSE 111289
// ComAutodestruct ( group [ i ] ) ;
111274: LD_VAR 0 4
111278: PUSH
111279: LD_VAR 0 7
111283: ARRAY
111284: PPUSH
111285: CALL 47756 0 1
// end ; if f_attack_depot then
111289: LD_VAR 0 25
111293: IFFALSE 111405
// begin k := 6 ;
111295: LD_ADDR_VAR 0 9
111299: PUSH
111300: LD_INT 6
111302: ST_TO_ADDR
// if tmp < k then
111303: LD_VAR 0 14
111307: PUSH
111308: LD_VAR 0 9
111312: LESS
111313: IFFALSE 111325
// k := tmp ;
111315: LD_ADDR_VAR 0 9
111319: PUSH
111320: LD_VAR 0 14
111324: ST_TO_ADDR
// for j = 1 to k do
111325: LD_ADDR_VAR 0 8
111329: PUSH
111330: DOUBLE
111331: LD_INT 1
111333: DEC
111334: ST_TO_ADDR
111335: LD_VAR 0 9
111339: PUSH
111340: FOR_TO
111341: IFFALSE 111403
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111343: LD_VAR 0 8
111347: PPUSH
111348: CALL_OW 266
111352: PUSH
111353: LD_INT 0
111355: PUSH
111356: LD_INT 1
111358: PUSH
111359: EMPTY
111360: LIST
111361: LIST
111362: IN
111363: IFFALSE 111401
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111365: LD_VAR 0 4
111369: PUSH
111370: LD_VAR 0 7
111374: ARRAY
111375: PPUSH
111376: LD_VAR 0 14
111380: PUSH
111381: LD_VAR 0 8
111385: ARRAY
111386: PPUSH
111387: CALL_OW 115
// attacking := true ;
111391: LD_ADDR_VAR 0 29
111395: PUSH
111396: LD_INT 1
111398: ST_TO_ADDR
// break ;
111399: GO 111403
// end ;
111401: GO 111340
111403: POP
111404: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111405: LD_VAR 0 4
111409: PUSH
111410: LD_VAR 0 7
111414: ARRAY
111415: PPUSH
111416: CALL_OW 302
111420: PUSH
111421: LD_VAR 0 29
111425: NOT
111426: AND
111427: IFFALSE 111749
// begin if GetTag ( group [ i ] ) = 71 then
111429: LD_VAR 0 4
111433: PUSH
111434: LD_VAR 0 7
111438: ARRAY
111439: PPUSH
111440: CALL_OW 110
111444: PUSH
111445: LD_INT 71
111447: EQUAL
111448: IFFALSE 111489
// begin if HasTask ( group [ i ] ) then
111450: LD_VAR 0 4
111454: PUSH
111455: LD_VAR 0 7
111459: ARRAY
111460: PPUSH
111461: CALL_OW 314
111465: IFFALSE 111471
// continue else
111467: GO 107628
111469: GO 111489
// SetTag ( group [ i ] , 0 ) ;
111471: LD_VAR 0 4
111475: PUSH
111476: LD_VAR 0 7
111480: ARRAY
111481: PPUSH
111482: LD_INT 0
111484: PPUSH
111485: CALL_OW 109
// end ; k := 8 ;
111489: LD_ADDR_VAR 0 9
111493: PUSH
111494: LD_INT 8
111496: ST_TO_ADDR
// x := 0 ;
111497: LD_ADDR_VAR 0 10
111501: PUSH
111502: LD_INT 0
111504: ST_TO_ADDR
// if tmp < k then
111505: LD_VAR 0 14
111509: PUSH
111510: LD_VAR 0 9
111514: LESS
111515: IFFALSE 111527
// k := tmp ;
111517: LD_ADDR_VAR 0 9
111521: PUSH
111522: LD_VAR 0 14
111526: ST_TO_ADDR
// for j = 1 to k do
111527: LD_ADDR_VAR 0 8
111531: PUSH
111532: DOUBLE
111533: LD_INT 1
111535: DEC
111536: ST_TO_ADDR
111537: LD_VAR 0 9
111541: PUSH
111542: FOR_TO
111543: IFFALSE 111641
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111545: LD_VAR 0 14
111549: PUSH
111550: LD_VAR 0 8
111554: ARRAY
111555: PPUSH
111556: CALL_OW 247
111560: PUSH
111561: LD_INT 1
111563: EQUAL
111564: PUSH
111565: LD_VAR 0 14
111569: PUSH
111570: LD_VAR 0 8
111574: ARRAY
111575: PPUSH
111576: CALL_OW 256
111580: PUSH
111581: LD_INT 250
111583: LESS
111584: PUSH
111585: LD_VAR 0 20
111589: AND
111590: PUSH
111591: LD_VAR 0 20
111595: NOT
111596: PUSH
111597: LD_VAR 0 14
111601: PUSH
111602: LD_VAR 0 8
111606: ARRAY
111607: PPUSH
111608: CALL_OW 256
111612: PUSH
111613: LD_INT 250
111615: GREATEREQUAL
111616: AND
111617: OR
111618: AND
111619: IFFALSE 111639
// begin x := tmp [ j ] ;
111621: LD_ADDR_VAR 0 10
111625: PUSH
111626: LD_VAR 0 14
111630: PUSH
111631: LD_VAR 0 8
111635: ARRAY
111636: ST_TO_ADDR
// break ;
111637: GO 111641
// end ;
111639: GO 111542
111641: POP
111642: POP
// if x then
111643: LD_VAR 0 10
111647: IFFALSE 111671
// ComAttackUnit ( group [ i ] , x ) else
111649: LD_VAR 0 4
111653: PUSH
111654: LD_VAR 0 7
111658: ARRAY
111659: PPUSH
111660: LD_VAR 0 10
111664: PPUSH
111665: CALL_OW 115
111669: GO 111695
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111671: LD_VAR 0 4
111675: PUSH
111676: LD_VAR 0 7
111680: ARRAY
111681: PPUSH
111682: LD_VAR 0 14
111686: PUSH
111687: LD_INT 1
111689: ARRAY
111690: PPUSH
111691: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111695: LD_VAR 0 4
111699: PUSH
111700: LD_VAR 0 7
111704: ARRAY
111705: PPUSH
111706: CALL_OW 314
111710: NOT
111711: IFFALSE 111749
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111713: LD_VAR 0 4
111717: PUSH
111718: LD_VAR 0 7
111722: ARRAY
111723: PPUSH
111724: LD_VAR 0 14
111728: PPUSH
111729: LD_VAR 0 4
111733: PUSH
111734: LD_VAR 0 7
111738: ARRAY
111739: PPUSH
111740: CALL_OW 74
111744: PPUSH
111745: CALL_OW 115
// end ; end ; end ;
111749: GO 107628
111751: POP
111752: POP
// wait ( 0 0$2 ) ;
111753: LD_INT 70
111755: PPUSH
111756: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111760: LD_VAR 0 4
111764: NOT
111765: PUSH
111766: LD_VAR 0 4
111770: PUSH
111771: EMPTY
111772: EQUAL
111773: OR
111774: PUSH
111775: LD_INT 81
111777: PUSH
111778: LD_VAR 0 35
111782: PUSH
111783: EMPTY
111784: LIST
111785: LIST
111786: PPUSH
111787: CALL_OW 69
111791: NOT
111792: OR
111793: IFFALSE 107613
// end ;
111795: LD_VAR 0 2
111799: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111800: LD_INT 0
111802: PPUSH
111803: PPUSH
111804: PPUSH
111805: PPUSH
111806: PPUSH
111807: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111808: LD_VAR 0 1
111812: NOT
111813: PUSH
111814: LD_EXP 61
111818: PUSH
111819: LD_VAR 0 1
111823: ARRAY
111824: NOT
111825: OR
111826: PUSH
111827: LD_VAR 0 2
111831: NOT
111832: OR
111833: IFFALSE 111837
// exit ;
111835: GO 112391
// side := mc_sides [ base ] ;
111837: LD_ADDR_VAR 0 6
111841: PUSH
111842: LD_EXP 87
111846: PUSH
111847: LD_VAR 0 1
111851: ARRAY
111852: ST_TO_ADDR
// if not side then
111853: LD_VAR 0 6
111857: NOT
111858: IFFALSE 111862
// exit ;
111860: GO 112391
// for i in solds do
111862: LD_ADDR_VAR 0 7
111866: PUSH
111867: LD_VAR 0 2
111871: PUSH
111872: FOR_IN
111873: IFFALSE 111934
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111875: LD_VAR 0 7
111879: PPUSH
111880: CALL_OW 310
111884: PPUSH
111885: CALL_OW 266
111889: PUSH
111890: LD_INT 32
111892: PUSH
111893: LD_INT 31
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: IN
111900: IFFALSE 111920
// solds := solds diff i else
111902: LD_ADDR_VAR 0 2
111906: PUSH
111907: LD_VAR 0 2
111911: PUSH
111912: LD_VAR 0 7
111916: DIFF
111917: ST_TO_ADDR
111918: GO 111932
// SetTag ( i , 18 ) ;
111920: LD_VAR 0 7
111924: PPUSH
111925: LD_INT 18
111927: PPUSH
111928: CALL_OW 109
111932: GO 111872
111934: POP
111935: POP
// if not solds then
111936: LD_VAR 0 2
111940: NOT
111941: IFFALSE 111945
// exit ;
111943: GO 112391
// repeat wait ( 0 0$2 ) ;
111945: LD_INT 70
111947: PPUSH
111948: CALL_OW 67
// enemy := mc_scan [ base ] ;
111952: LD_ADDR_VAR 0 4
111956: PUSH
111957: LD_EXP 84
111961: PUSH
111962: LD_VAR 0 1
111966: ARRAY
111967: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111968: LD_EXP 61
111972: PUSH
111973: LD_VAR 0 1
111977: ARRAY
111978: NOT
111979: PUSH
111980: LD_EXP 61
111984: PUSH
111985: LD_VAR 0 1
111989: ARRAY
111990: PUSH
111991: EMPTY
111992: EQUAL
111993: OR
111994: IFFALSE 112031
// begin for i in solds do
111996: LD_ADDR_VAR 0 7
112000: PUSH
112001: LD_VAR 0 2
112005: PUSH
112006: FOR_IN
112007: IFFALSE 112020
// ComStop ( i ) ;
112009: LD_VAR 0 7
112013: PPUSH
112014: CALL_OW 141
112018: GO 112006
112020: POP
112021: POP
// solds := [ ] ;
112022: LD_ADDR_VAR 0 2
112026: PUSH
112027: EMPTY
112028: ST_TO_ADDR
// exit ;
112029: GO 112391
// end ; for i in solds do
112031: LD_ADDR_VAR 0 7
112035: PUSH
112036: LD_VAR 0 2
112040: PUSH
112041: FOR_IN
112042: IFFALSE 112363
// begin if IsInUnit ( i ) then
112044: LD_VAR 0 7
112048: PPUSH
112049: CALL_OW 310
112053: IFFALSE 112064
// ComExitBuilding ( i ) ;
112055: LD_VAR 0 7
112059: PPUSH
112060: CALL_OW 122
// if GetLives ( i ) > 500 then
112064: LD_VAR 0 7
112068: PPUSH
112069: CALL_OW 256
112073: PUSH
112074: LD_INT 500
112076: GREATER
112077: IFFALSE 112130
// begin e := NearestUnitToUnit ( enemy , i ) ;
112079: LD_ADDR_VAR 0 5
112083: PUSH
112084: LD_VAR 0 4
112088: PPUSH
112089: LD_VAR 0 7
112093: PPUSH
112094: CALL_OW 74
112098: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112099: LD_VAR 0 7
112103: PPUSH
112104: LD_VAR 0 5
112108: PPUSH
112109: CALL_OW 250
112113: PPUSH
112114: LD_VAR 0 5
112118: PPUSH
112119: CALL_OW 251
112123: PPUSH
112124: CALL_OW 114
// end else
112128: GO 112361
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112130: LD_VAR 0 7
112134: PPUSH
112135: LD_EXP 61
112139: PUSH
112140: LD_VAR 0 1
112144: ARRAY
112145: PPUSH
112146: LD_INT 2
112148: PUSH
112149: LD_INT 30
112151: PUSH
112152: LD_INT 0
112154: PUSH
112155: EMPTY
112156: LIST
112157: LIST
112158: PUSH
112159: LD_INT 30
112161: PUSH
112162: LD_INT 1
112164: PUSH
112165: EMPTY
112166: LIST
112167: LIST
112168: PUSH
112169: LD_INT 30
112171: PUSH
112172: LD_INT 6
112174: PUSH
112175: EMPTY
112176: LIST
112177: LIST
112178: PUSH
112179: EMPTY
112180: LIST
112181: LIST
112182: LIST
112183: LIST
112184: PPUSH
112185: CALL_OW 72
112189: PPUSH
112190: LD_VAR 0 7
112194: PPUSH
112195: CALL_OW 74
112199: PPUSH
112200: CALL_OW 296
112204: PUSH
112205: LD_INT 10
112207: GREATER
112208: IFFALSE 112361
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112210: LD_ADDR_VAR 0 8
112214: PUSH
112215: LD_EXP 61
112219: PUSH
112220: LD_VAR 0 1
112224: ARRAY
112225: PPUSH
112226: LD_INT 2
112228: PUSH
112229: LD_INT 30
112231: PUSH
112232: LD_INT 0
112234: PUSH
112235: EMPTY
112236: LIST
112237: LIST
112238: PUSH
112239: LD_INT 30
112241: PUSH
112242: LD_INT 1
112244: PUSH
112245: EMPTY
112246: LIST
112247: LIST
112248: PUSH
112249: LD_INT 30
112251: PUSH
112252: LD_INT 6
112254: PUSH
112255: EMPTY
112256: LIST
112257: LIST
112258: PUSH
112259: EMPTY
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: PPUSH
112265: CALL_OW 72
112269: PPUSH
112270: LD_VAR 0 7
112274: PPUSH
112275: CALL_OW 74
112279: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112280: LD_VAR 0 7
112284: PPUSH
112285: LD_VAR 0 8
112289: PPUSH
112290: CALL_OW 250
112294: PPUSH
112295: LD_INT 3
112297: PPUSH
112298: LD_INT 5
112300: PPUSH
112301: CALL_OW 272
112305: PPUSH
112306: LD_VAR 0 8
112310: PPUSH
112311: CALL_OW 251
112315: PPUSH
112316: LD_INT 3
112318: PPUSH
112319: LD_INT 5
112321: PPUSH
112322: CALL_OW 273
112326: PPUSH
112327: CALL_OW 111
// SetTag ( i , 0 ) ;
112331: LD_VAR 0 7
112335: PPUSH
112336: LD_INT 0
112338: PPUSH
112339: CALL_OW 109
// solds := solds diff i ;
112343: LD_ADDR_VAR 0 2
112347: PUSH
112348: LD_VAR 0 2
112352: PUSH
112353: LD_VAR 0 7
112357: DIFF
112358: ST_TO_ADDR
// continue ;
112359: GO 112041
// end ; end ;
112361: GO 112041
112363: POP
112364: POP
// until not solds or not enemy ;
112365: LD_VAR 0 2
112369: NOT
112370: PUSH
112371: LD_VAR 0 4
112375: NOT
112376: OR
112377: IFFALSE 111945
// MC_Reset ( base , 18 ) ;
112379: LD_VAR 0 1
112383: PPUSH
112384: LD_INT 18
112386: PPUSH
112387: CALL 60483 0 2
// end ;
112391: LD_VAR 0 3
112395: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112396: LD_INT 0
112398: PPUSH
112399: PPUSH
112400: PPUSH
112401: PPUSH
112402: PPUSH
112403: PPUSH
112404: PPUSH
112405: PPUSH
112406: PPUSH
112407: PPUSH
112408: PPUSH
112409: PPUSH
112410: PPUSH
112411: PPUSH
112412: PPUSH
112413: PPUSH
112414: PPUSH
112415: PPUSH
112416: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112417: LD_ADDR_VAR 0 12
112421: PUSH
112422: LD_EXP 61
112426: PUSH
112427: LD_VAR 0 1
112431: ARRAY
112432: PPUSH
112433: LD_INT 25
112435: PUSH
112436: LD_INT 3
112438: PUSH
112439: EMPTY
112440: LIST
112441: LIST
112442: PPUSH
112443: CALL_OW 72
112447: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112448: LD_EXP 101
112452: PUSH
112453: LD_VAR 0 1
112457: ARRAY
112458: IFFALSE 112482
// mechs := mechs diff mc_remote_driver [ base ] ;
112460: LD_ADDR_VAR 0 12
112464: PUSH
112465: LD_VAR 0 12
112469: PUSH
112470: LD_EXP 101
112474: PUSH
112475: LD_VAR 0 1
112479: ARRAY
112480: DIFF
112481: ST_TO_ADDR
// for i in mechs do
112482: LD_ADDR_VAR 0 4
112486: PUSH
112487: LD_VAR 0 12
112491: PUSH
112492: FOR_IN
112493: IFFALSE 112528
// if GetTag ( i ) > 0 then
112495: LD_VAR 0 4
112499: PPUSH
112500: CALL_OW 110
112504: PUSH
112505: LD_INT 0
112507: GREATER
112508: IFFALSE 112526
// mechs := mechs diff i ;
112510: LD_ADDR_VAR 0 12
112514: PUSH
112515: LD_VAR 0 12
112519: PUSH
112520: LD_VAR 0 4
112524: DIFF
112525: ST_TO_ADDR
112526: GO 112492
112528: POP
112529: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112530: LD_ADDR_VAR 0 8
112534: PUSH
112535: LD_EXP 61
112539: PUSH
112540: LD_VAR 0 1
112544: ARRAY
112545: PPUSH
112546: LD_INT 2
112548: PUSH
112549: LD_INT 25
112551: PUSH
112552: LD_INT 1
112554: PUSH
112555: EMPTY
112556: LIST
112557: LIST
112558: PUSH
112559: LD_INT 25
112561: PUSH
112562: LD_INT 5
112564: PUSH
112565: EMPTY
112566: LIST
112567: LIST
112568: PUSH
112569: LD_INT 25
112571: PUSH
112572: LD_INT 8
112574: PUSH
112575: EMPTY
112576: LIST
112577: LIST
112578: PUSH
112579: LD_INT 25
112581: PUSH
112582: LD_INT 9
112584: PUSH
112585: EMPTY
112586: LIST
112587: LIST
112588: PUSH
112589: EMPTY
112590: LIST
112591: LIST
112592: LIST
112593: LIST
112594: LIST
112595: PPUSH
112596: CALL_OW 72
112600: ST_TO_ADDR
// if not defenders and not solds then
112601: LD_VAR 0 2
112605: NOT
112606: PUSH
112607: LD_VAR 0 8
112611: NOT
112612: AND
112613: IFFALSE 112617
// exit ;
112615: GO 114387
// depot_under_attack := false ;
112617: LD_ADDR_VAR 0 16
112621: PUSH
112622: LD_INT 0
112624: ST_TO_ADDR
// sold_defenders := [ ] ;
112625: LD_ADDR_VAR 0 17
112629: PUSH
112630: EMPTY
112631: ST_TO_ADDR
// if mechs then
112632: LD_VAR 0 12
112636: IFFALSE 112789
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112638: LD_ADDR_VAR 0 4
112642: PUSH
112643: LD_VAR 0 2
112647: PPUSH
112648: LD_INT 21
112650: PUSH
112651: LD_INT 2
112653: PUSH
112654: EMPTY
112655: LIST
112656: LIST
112657: PPUSH
112658: CALL_OW 72
112662: PUSH
112663: FOR_IN
112664: IFFALSE 112787
// begin if GetTag ( i ) <> 20 then
112666: LD_VAR 0 4
112670: PPUSH
112671: CALL_OW 110
112675: PUSH
112676: LD_INT 20
112678: NONEQUAL
112679: IFFALSE 112693
// SetTag ( i , 20 ) ;
112681: LD_VAR 0 4
112685: PPUSH
112686: LD_INT 20
112688: PPUSH
112689: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112693: LD_VAR 0 4
112697: PPUSH
112698: CALL_OW 263
112702: PUSH
112703: LD_INT 1
112705: EQUAL
112706: PUSH
112707: LD_VAR 0 4
112711: PPUSH
112712: CALL_OW 311
112716: NOT
112717: AND
112718: IFFALSE 112785
// begin un := mechs [ 1 ] ;
112720: LD_ADDR_VAR 0 10
112724: PUSH
112725: LD_VAR 0 12
112729: PUSH
112730: LD_INT 1
112732: ARRAY
112733: ST_TO_ADDR
// ComExit ( un ) ;
112734: LD_VAR 0 10
112738: PPUSH
112739: CALL 52640 0 1
// AddComEnterUnit ( un , i ) ;
112743: LD_VAR 0 10
112747: PPUSH
112748: LD_VAR 0 4
112752: PPUSH
112753: CALL_OW 180
// SetTag ( un , 19 ) ;
112757: LD_VAR 0 10
112761: PPUSH
112762: LD_INT 19
112764: PPUSH
112765: CALL_OW 109
// mechs := mechs diff un ;
112769: LD_ADDR_VAR 0 12
112773: PUSH
112774: LD_VAR 0 12
112778: PUSH
112779: LD_VAR 0 10
112783: DIFF
112784: ST_TO_ADDR
// end ; end ;
112785: GO 112663
112787: POP
112788: POP
// if solds then
112789: LD_VAR 0 8
112793: IFFALSE 112852
// for i in solds do
112795: LD_ADDR_VAR 0 4
112799: PUSH
112800: LD_VAR 0 8
112804: PUSH
112805: FOR_IN
112806: IFFALSE 112850
// if not GetTag ( i ) then
112808: LD_VAR 0 4
112812: PPUSH
112813: CALL_OW 110
112817: NOT
112818: IFFALSE 112848
// begin defenders := defenders union i ;
112820: LD_ADDR_VAR 0 2
112824: PUSH
112825: LD_VAR 0 2
112829: PUSH
112830: LD_VAR 0 4
112834: UNION
112835: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112836: LD_VAR 0 4
112840: PPUSH
112841: LD_INT 18
112843: PPUSH
112844: CALL_OW 109
// end ;
112848: GO 112805
112850: POP
112851: POP
// repeat wait ( 0 0$2 ) ;
112852: LD_INT 70
112854: PPUSH
112855: CALL_OW 67
// enemy := mc_scan [ base ] ;
112859: LD_ADDR_VAR 0 21
112863: PUSH
112864: LD_EXP 84
112868: PUSH
112869: LD_VAR 0 1
112873: ARRAY
112874: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112875: LD_EXP 61
112879: PUSH
112880: LD_VAR 0 1
112884: ARRAY
112885: NOT
112886: PUSH
112887: LD_EXP 61
112891: PUSH
112892: LD_VAR 0 1
112896: ARRAY
112897: PUSH
112898: EMPTY
112899: EQUAL
112900: OR
112901: IFFALSE 112938
// begin for i in defenders do
112903: LD_ADDR_VAR 0 4
112907: PUSH
112908: LD_VAR 0 2
112912: PUSH
112913: FOR_IN
112914: IFFALSE 112927
// ComStop ( i ) ;
112916: LD_VAR 0 4
112920: PPUSH
112921: CALL_OW 141
112925: GO 112913
112927: POP
112928: POP
// defenders := [ ] ;
112929: LD_ADDR_VAR 0 2
112933: PUSH
112934: EMPTY
112935: ST_TO_ADDR
// exit ;
112936: GO 114387
// end ; for i in defenders do
112938: LD_ADDR_VAR 0 4
112942: PUSH
112943: LD_VAR 0 2
112947: PUSH
112948: FOR_IN
112949: IFFALSE 113847
// begin e := NearestUnitToUnit ( enemy , i ) ;
112951: LD_ADDR_VAR 0 13
112955: PUSH
112956: LD_VAR 0 21
112960: PPUSH
112961: LD_VAR 0 4
112965: PPUSH
112966: CALL_OW 74
112970: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112971: LD_ADDR_VAR 0 7
112975: PUSH
112976: LD_EXP 61
112980: PUSH
112981: LD_VAR 0 1
112985: ARRAY
112986: PPUSH
112987: LD_INT 2
112989: PUSH
112990: LD_INT 30
112992: PUSH
112993: LD_INT 0
112995: PUSH
112996: EMPTY
112997: LIST
112998: LIST
112999: PUSH
113000: LD_INT 30
113002: PUSH
113003: LD_INT 1
113005: PUSH
113006: EMPTY
113007: LIST
113008: LIST
113009: PUSH
113010: EMPTY
113011: LIST
113012: LIST
113013: LIST
113014: PPUSH
113015: CALL_OW 72
113019: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113020: LD_ADDR_VAR 0 16
113024: PUSH
113025: LD_VAR 0 7
113029: NOT
113030: PUSH
113031: LD_VAR 0 7
113035: PPUSH
113036: LD_INT 3
113038: PUSH
113039: LD_INT 24
113041: PUSH
113042: LD_INT 600
113044: PUSH
113045: EMPTY
113046: LIST
113047: LIST
113048: PUSH
113049: EMPTY
113050: LIST
113051: LIST
113052: PPUSH
113053: CALL_OW 72
113057: OR
113058: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113059: LD_VAR 0 4
113063: PPUSH
113064: CALL_OW 247
113068: PUSH
113069: LD_INT 2
113071: DOUBLE
113072: EQUAL
113073: IFTRUE 113077
113075: GO 113473
113077: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113078: LD_VAR 0 4
113082: PPUSH
113083: CALL_OW 256
113087: PUSH
113088: LD_INT 1000
113090: EQUAL
113091: PUSH
113092: LD_VAR 0 4
113096: PPUSH
113097: LD_VAR 0 13
113101: PPUSH
113102: CALL_OW 296
113106: PUSH
113107: LD_INT 40
113109: LESS
113110: PUSH
113111: LD_VAR 0 13
113115: PPUSH
113116: LD_EXP 86
113120: PUSH
113121: LD_VAR 0 1
113125: ARRAY
113126: PPUSH
113127: CALL_OW 308
113131: OR
113132: AND
113133: IFFALSE 113255
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113135: LD_VAR 0 4
113139: PPUSH
113140: CALL_OW 262
113144: PUSH
113145: LD_INT 1
113147: EQUAL
113148: PUSH
113149: LD_VAR 0 4
113153: PPUSH
113154: CALL_OW 261
113158: PUSH
113159: LD_INT 30
113161: LESS
113162: AND
113163: PUSH
113164: LD_VAR 0 7
113168: AND
113169: IFFALSE 113239
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113171: LD_VAR 0 4
113175: PPUSH
113176: LD_VAR 0 7
113180: PPUSH
113181: LD_VAR 0 4
113185: PPUSH
113186: CALL_OW 74
113190: PPUSH
113191: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113195: LD_VAR 0 4
113199: PPUSH
113200: LD_VAR 0 7
113204: PPUSH
113205: LD_VAR 0 4
113209: PPUSH
113210: CALL_OW 74
113214: PPUSH
113215: CALL_OW 296
113219: PUSH
113220: LD_INT 6
113222: LESS
113223: IFFALSE 113237
// SetFuel ( i , 100 ) ;
113225: LD_VAR 0 4
113229: PPUSH
113230: LD_INT 100
113232: PPUSH
113233: CALL_OW 240
// end else
113237: GO 113253
// ComAttackUnit ( i , e ) ;
113239: LD_VAR 0 4
113243: PPUSH
113244: LD_VAR 0 13
113248: PPUSH
113249: CALL_OW 115
// end else
113253: GO 113356
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113255: LD_VAR 0 13
113259: PPUSH
113260: LD_EXP 86
113264: PUSH
113265: LD_VAR 0 1
113269: ARRAY
113270: PPUSH
113271: CALL_OW 308
113275: NOT
113276: PUSH
113277: LD_VAR 0 4
113281: PPUSH
113282: LD_VAR 0 13
113286: PPUSH
113287: CALL_OW 296
113291: PUSH
113292: LD_INT 40
113294: GREATEREQUAL
113295: AND
113296: PUSH
113297: LD_VAR 0 4
113301: PPUSH
113302: CALL_OW 256
113306: PUSH
113307: LD_INT 650
113309: LESSEQUAL
113310: OR
113311: PUSH
113312: LD_VAR 0 4
113316: PPUSH
113317: LD_EXP 85
113321: PUSH
113322: LD_VAR 0 1
113326: ARRAY
113327: PPUSH
113328: CALL_OW 308
113332: NOT
113333: AND
113334: IFFALSE 113356
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113336: LD_VAR 0 4
113340: PPUSH
113341: LD_EXP 85
113345: PUSH
113346: LD_VAR 0 1
113350: ARRAY
113351: PPUSH
113352: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113356: LD_VAR 0 4
113360: PPUSH
113361: CALL_OW 256
113365: PUSH
113366: LD_INT 1000
113368: LESS
113369: PUSH
113370: LD_VAR 0 4
113374: PPUSH
113375: CALL_OW 263
113379: PUSH
113380: LD_INT 1
113382: EQUAL
113383: AND
113384: PUSH
113385: LD_VAR 0 4
113389: PPUSH
113390: CALL_OW 311
113394: AND
113395: PUSH
113396: LD_VAR 0 4
113400: PPUSH
113401: LD_EXP 85
113405: PUSH
113406: LD_VAR 0 1
113410: ARRAY
113411: PPUSH
113412: CALL_OW 308
113416: AND
113417: IFFALSE 113471
// begin mech := IsDrivenBy ( i ) ;
113419: LD_ADDR_VAR 0 9
113423: PUSH
113424: LD_VAR 0 4
113428: PPUSH
113429: CALL_OW 311
113433: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113434: LD_VAR 0 9
113438: PPUSH
113439: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113443: LD_VAR 0 9
113447: PPUSH
113448: LD_VAR 0 4
113452: PPUSH
113453: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113457: LD_VAR 0 9
113461: PPUSH
113462: LD_VAR 0 4
113466: PPUSH
113467: CALL_OW 180
// end ; end ; unit_human :
113471: GO 113818
113473: LD_INT 1
113475: DOUBLE
113476: EQUAL
113477: IFTRUE 113481
113479: GO 113817
113481: POP
// begin b := IsInUnit ( i ) ;
113482: LD_ADDR_VAR 0 18
113486: PUSH
113487: LD_VAR 0 4
113491: PPUSH
113492: CALL_OW 310
113496: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113497: LD_ADDR_VAR 0 19
113501: PUSH
113502: LD_VAR 0 18
113506: NOT
113507: PUSH
113508: LD_VAR 0 18
113512: PPUSH
113513: CALL_OW 266
113517: PUSH
113518: LD_INT 32
113520: PUSH
113521: LD_INT 31
113523: PUSH
113524: EMPTY
113525: LIST
113526: LIST
113527: IN
113528: OR
113529: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113530: LD_VAR 0 18
113534: PPUSH
113535: CALL_OW 266
113539: PUSH
113540: LD_INT 5
113542: EQUAL
113543: PUSH
113544: LD_VAR 0 4
113548: PPUSH
113549: CALL_OW 257
113553: PUSH
113554: LD_INT 1
113556: PUSH
113557: LD_INT 2
113559: PUSH
113560: LD_INT 3
113562: PUSH
113563: LD_INT 4
113565: PUSH
113566: EMPTY
113567: LIST
113568: LIST
113569: LIST
113570: LIST
113571: IN
113572: AND
113573: IFFALSE 113610
// begin class := AllowSpecClass ( i ) ;
113575: LD_ADDR_VAR 0 20
113579: PUSH
113580: LD_VAR 0 4
113584: PPUSH
113585: CALL 16736 0 1
113589: ST_TO_ADDR
// if class then
113590: LD_VAR 0 20
113594: IFFALSE 113610
// ComChangeProfession ( i , class ) ;
113596: LD_VAR 0 4
113600: PPUSH
113601: LD_VAR 0 20
113605: PPUSH
113606: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113610: LD_VAR 0 16
113614: PUSH
113615: LD_VAR 0 2
113619: PPUSH
113620: LD_INT 21
113622: PUSH
113623: LD_INT 2
113625: PUSH
113626: EMPTY
113627: LIST
113628: LIST
113629: PPUSH
113630: CALL_OW 72
113634: PUSH
113635: LD_INT 1
113637: LESSEQUAL
113638: OR
113639: PUSH
113640: LD_VAR 0 19
113644: AND
113645: PUSH
113646: LD_VAR 0 4
113650: PUSH
113651: LD_VAR 0 17
113655: IN
113656: NOT
113657: AND
113658: IFFALSE 113751
// begin if b then
113660: LD_VAR 0 18
113664: IFFALSE 113713
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113666: LD_VAR 0 18
113670: PPUSH
113671: LD_VAR 0 21
113675: PPUSH
113676: LD_VAR 0 18
113680: PPUSH
113681: CALL_OW 74
113685: PPUSH
113686: CALL_OW 296
113690: PUSH
113691: LD_INT 10
113693: LESS
113694: PUSH
113695: LD_VAR 0 18
113699: PPUSH
113700: CALL_OW 461
113704: PUSH
113705: LD_INT 7
113707: NONEQUAL
113708: AND
113709: IFFALSE 113713
// continue ;
113711: GO 112948
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113713: LD_ADDR_VAR 0 17
113717: PUSH
113718: LD_VAR 0 17
113722: PPUSH
113723: LD_VAR 0 17
113727: PUSH
113728: LD_INT 1
113730: PLUS
113731: PPUSH
113732: LD_VAR 0 4
113736: PPUSH
113737: CALL_OW 1
113741: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113742: LD_VAR 0 4
113746: PPUSH
113747: CALL_OW 122
// end ; if sold_defenders then
113751: LD_VAR 0 17
113755: IFFALSE 113815
// if i in sold_defenders then
113757: LD_VAR 0 4
113761: PUSH
113762: LD_VAR 0 17
113766: IN
113767: IFFALSE 113815
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113769: LD_VAR 0 4
113773: PPUSH
113774: CALL_OW 314
113778: NOT
113779: PUSH
113780: LD_VAR 0 4
113784: PPUSH
113785: LD_VAR 0 13
113789: PPUSH
113790: CALL_OW 296
113794: PUSH
113795: LD_INT 30
113797: LESS
113798: AND
113799: IFFALSE 113815
// ComAttackUnit ( i , e ) ;
113801: LD_VAR 0 4
113805: PPUSH
113806: LD_VAR 0 13
113810: PPUSH
113811: CALL_OW 115
// end ; end ; end ;
113815: GO 113818
113817: POP
// if IsDead ( i ) then
113818: LD_VAR 0 4
113822: PPUSH
113823: CALL_OW 301
113827: IFFALSE 113845
// defenders := defenders diff i ;
113829: LD_ADDR_VAR 0 2
113833: PUSH
113834: LD_VAR 0 2
113838: PUSH
113839: LD_VAR 0 4
113843: DIFF
113844: ST_TO_ADDR
// end ;
113845: GO 112948
113847: POP
113848: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113849: LD_VAR 0 21
113853: NOT
113854: PUSH
113855: LD_VAR 0 2
113859: NOT
113860: OR
113861: PUSH
113862: LD_EXP 61
113866: PUSH
113867: LD_VAR 0 1
113871: ARRAY
113872: NOT
113873: OR
113874: IFFALSE 112852
// MC_Reset ( base , 18 ) ;
113876: LD_VAR 0 1
113880: PPUSH
113881: LD_INT 18
113883: PPUSH
113884: CALL 60483 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113888: LD_ADDR_VAR 0 2
113892: PUSH
113893: LD_VAR 0 2
113897: PUSH
113898: LD_VAR 0 2
113902: PPUSH
113903: LD_INT 2
113905: PUSH
113906: LD_INT 25
113908: PUSH
113909: LD_INT 1
113911: PUSH
113912: EMPTY
113913: LIST
113914: LIST
113915: PUSH
113916: LD_INT 25
113918: PUSH
113919: LD_INT 5
113921: PUSH
113922: EMPTY
113923: LIST
113924: LIST
113925: PUSH
113926: LD_INT 25
113928: PUSH
113929: LD_INT 8
113931: PUSH
113932: EMPTY
113933: LIST
113934: LIST
113935: PUSH
113936: LD_INT 25
113938: PUSH
113939: LD_INT 9
113941: PUSH
113942: EMPTY
113943: LIST
113944: LIST
113945: PUSH
113946: EMPTY
113947: LIST
113948: LIST
113949: LIST
113950: LIST
113951: LIST
113952: PPUSH
113953: CALL_OW 72
113957: DIFF
113958: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113959: LD_VAR 0 21
113963: NOT
113964: PUSH
113965: LD_VAR 0 2
113969: PPUSH
113970: LD_INT 21
113972: PUSH
113973: LD_INT 2
113975: PUSH
113976: EMPTY
113977: LIST
113978: LIST
113979: PPUSH
113980: CALL_OW 72
113984: AND
113985: IFFALSE 114323
// begin tmp := FilterByTag ( defenders , 19 ) ;
113987: LD_ADDR_VAR 0 11
113991: PUSH
113992: LD_VAR 0 2
113996: PPUSH
113997: LD_INT 19
113999: PPUSH
114000: CALL 49824 0 2
114004: ST_TO_ADDR
// if tmp then
114005: LD_VAR 0 11
114009: IFFALSE 114079
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114011: LD_ADDR_VAR 0 11
114015: PUSH
114016: LD_VAR 0 11
114020: PPUSH
114021: LD_INT 25
114023: PUSH
114024: LD_INT 3
114026: PUSH
114027: EMPTY
114028: LIST
114029: LIST
114030: PPUSH
114031: CALL_OW 72
114035: ST_TO_ADDR
// if tmp then
114036: LD_VAR 0 11
114040: IFFALSE 114079
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114042: LD_ADDR_EXP 73
114046: PUSH
114047: LD_EXP 73
114051: PPUSH
114052: LD_VAR 0 1
114056: PPUSH
114057: LD_EXP 73
114061: PUSH
114062: LD_VAR 0 1
114066: ARRAY
114067: PUSH
114068: LD_VAR 0 11
114072: UNION
114073: PPUSH
114074: CALL_OW 1
114078: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114079: LD_VAR 0 1
114083: PPUSH
114084: LD_INT 19
114086: PPUSH
114087: CALL 60483 0 2
// repeat wait ( 0 0$1 ) ;
114091: LD_INT 35
114093: PPUSH
114094: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114098: LD_EXP 61
114102: PUSH
114103: LD_VAR 0 1
114107: ARRAY
114108: NOT
114109: PUSH
114110: LD_EXP 61
114114: PUSH
114115: LD_VAR 0 1
114119: ARRAY
114120: PUSH
114121: EMPTY
114122: EQUAL
114123: OR
114124: IFFALSE 114161
// begin for i in defenders do
114126: LD_ADDR_VAR 0 4
114130: PUSH
114131: LD_VAR 0 2
114135: PUSH
114136: FOR_IN
114137: IFFALSE 114150
// ComStop ( i ) ;
114139: LD_VAR 0 4
114143: PPUSH
114144: CALL_OW 141
114148: GO 114136
114150: POP
114151: POP
// defenders := [ ] ;
114152: LD_ADDR_VAR 0 2
114156: PUSH
114157: EMPTY
114158: ST_TO_ADDR
// exit ;
114159: GO 114387
// end ; for i in defenders do
114161: LD_ADDR_VAR 0 4
114165: PUSH
114166: LD_VAR 0 2
114170: PUSH
114171: FOR_IN
114172: IFFALSE 114261
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114174: LD_VAR 0 4
114178: PPUSH
114179: LD_EXP 85
114183: PUSH
114184: LD_VAR 0 1
114188: ARRAY
114189: PPUSH
114190: CALL_OW 308
114194: NOT
114195: IFFALSE 114219
// ComMoveToArea ( i , mc_parking [ base ] ) else
114197: LD_VAR 0 4
114201: PPUSH
114202: LD_EXP 85
114206: PUSH
114207: LD_VAR 0 1
114211: ARRAY
114212: PPUSH
114213: CALL_OW 113
114217: GO 114259
// if GetControl ( i ) = control_manual then
114219: LD_VAR 0 4
114223: PPUSH
114224: CALL_OW 263
114228: PUSH
114229: LD_INT 1
114231: EQUAL
114232: IFFALSE 114259
// if IsDrivenBy ( i ) then
114234: LD_VAR 0 4
114238: PPUSH
114239: CALL_OW 311
114243: IFFALSE 114259
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114245: LD_VAR 0 4
114249: PPUSH
114250: CALL_OW 311
114254: PPUSH
114255: CALL_OW 121
// end ;
114259: GO 114171
114261: POP
114262: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114263: LD_VAR 0 2
114267: PPUSH
114268: LD_INT 95
114270: PUSH
114271: LD_EXP 85
114275: PUSH
114276: LD_VAR 0 1
114280: ARRAY
114281: PUSH
114282: EMPTY
114283: LIST
114284: LIST
114285: PPUSH
114286: CALL_OW 72
114290: PUSH
114291: LD_VAR 0 2
114295: EQUAL
114296: PUSH
114297: LD_EXP 84
114301: PUSH
114302: LD_VAR 0 1
114306: ARRAY
114307: OR
114308: PUSH
114309: LD_EXP 61
114313: PUSH
114314: LD_VAR 0 1
114318: ARRAY
114319: NOT
114320: OR
114321: IFFALSE 114091
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114323: LD_ADDR_EXP 83
114327: PUSH
114328: LD_EXP 83
114332: PPUSH
114333: LD_VAR 0 1
114337: PPUSH
114338: LD_VAR 0 2
114342: PPUSH
114343: LD_INT 21
114345: PUSH
114346: LD_INT 2
114348: PUSH
114349: EMPTY
114350: LIST
114351: LIST
114352: PPUSH
114353: CALL_OW 72
114357: PPUSH
114358: CALL_OW 1
114362: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114363: LD_VAR 0 1
114367: PPUSH
114368: LD_INT 19
114370: PPUSH
114371: CALL 60483 0 2
// MC_Reset ( base , 20 ) ;
114375: LD_VAR 0 1
114379: PPUSH
114380: LD_INT 20
114382: PPUSH
114383: CALL 60483 0 2
// end ; end_of_file
114387: LD_VAR 0 3
114391: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114392: LD_VAR 0 1
114396: PUSH
114397: LD_INT 200
114399: DOUBLE
114400: GREATEREQUAL
114401: IFFALSE 114409
114403: LD_INT 299
114405: DOUBLE
114406: LESSEQUAL
114407: IFTRUE 114411
114409: GO 114443
114411: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114412: LD_VAR 0 1
114416: PPUSH
114417: LD_VAR 0 2
114421: PPUSH
114422: LD_VAR 0 3
114426: PPUSH
114427: LD_VAR 0 4
114431: PPUSH
114432: LD_VAR 0 5
114436: PPUSH
114437: CALL 103178 0 5
114441: GO 114520
114443: LD_INT 300
114445: DOUBLE
114446: GREATEREQUAL
114447: IFFALSE 114455
114449: LD_INT 399
114451: DOUBLE
114452: LESSEQUAL
114453: IFTRUE 114457
114455: GO 114519
114457: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114458: LD_VAR 0 1
114462: PPUSH
114463: LD_VAR 0 2
114467: PPUSH
114468: LD_VAR 0 3
114472: PPUSH
114473: LD_VAR 0 4
114477: PPUSH
114478: LD_VAR 0 5
114482: PPUSH
114483: LD_VAR 0 6
114487: PPUSH
114488: LD_VAR 0 7
114492: PPUSH
114493: LD_VAR 0 8
114497: PPUSH
114498: LD_VAR 0 9
114502: PPUSH
114503: LD_VAR 0 10
114507: PPUSH
114508: LD_VAR 0 11
114512: PPUSH
114513: CALL 99511 0 11
114517: GO 114520
114519: POP
// end ;
114520: PPOPN 11
114522: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114523: LD_VAR 0 1
114527: PPUSH
114528: LD_VAR 0 2
114532: PPUSH
114533: LD_VAR 0 3
114537: PPUSH
114538: LD_VAR 0 4
114542: PPUSH
114543: LD_VAR 0 5
114547: PPUSH
114548: CALL 102914 0 5
// end ; end_of_file
114552: PPOPN 5
114554: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114555: LD_VAR 0 1
114559: PPUSH
114560: LD_VAR 0 2
114564: PPUSH
114565: LD_VAR 0 3
114569: PPUSH
114570: LD_VAR 0 4
114574: PPUSH
114575: LD_VAR 0 5
114579: PPUSH
114580: LD_VAR 0 6
114584: PPUSH
114585: CALL 87163 0 6
// end ;
114589: PPOPN 6
114591: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114592: LD_INT 0
114594: PPUSH
// begin if not units then
114595: LD_VAR 0 1
114599: NOT
114600: IFFALSE 114604
// exit ;
114602: GO 114604
// end ;
114604: PPOPN 7
114606: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114607: CALL 87067 0 0
// end ;
114611: PPOPN 1
114613: END
