// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 682 0 0
// InitGlobalVariables ;
  19: CALL 82659 0 0
// InitMacro ;
  23: CALL 52366 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 47658 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 47658 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 47658 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 47658 0 9
// PrepareArabian ;
 168: CALL 3932 0 0
// PrepareRussian ;
 172: CALL 2911 0 0
// PrepareAlliance ;
 176: CALL 884 0 0
// MC_Start ( ) ;
 180: CALL 54531 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7274 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 83
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 84
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: PUSH
 253: LD_OWVAR 67
 257: ARRAY
 258: PPUSH
 259: LD_INT 7
 261: PPUSH
 262: CALL 75896 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_EXP 54
 273: PPUSH
 274: CALL 76322 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 278: LD_INT 1
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL 76780 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 288: LD_INT 1
 290: PPUSH
 291: LD_INT 9
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77049 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 13
 306: PUSH
 307: LD_INT 1
 309: PUSH
 310: LD_INT 2
 312: PUSH
 313: LD_INT 32
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_INT 13
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_EXP 109
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: PUSH
 342: EMPTY
 343: LIST
 344: LIST
 345: PPUSH
 346: CALL 76262 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 350: LD_INT 2
 352: PPUSH
 353: LD_INT 12
 355: PUSH
 356: LD_INT 14
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: LD_INT 11
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL 76956 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 375: LD_INT 2
 377: PPUSH
 378: LD_EXP 51
 382: PPUSH
 383: CALL 76322 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 387: LD_INT 2
 389: PPUSH
 390: LD_INT 8
 392: PPUSH
 393: CALL 76780 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 397: LD_INT 2
 399: PPUSH
 400: LD_INT 10
 402: PUSH
 403: EMPTY
 404: LIST
 405: PPUSH
 406: CALL 77049 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 6
 415: PUSH
 416: LD_INT 71
 418: PUSH
 419: LD_INT 116
 421: PUSH
 422: LD_INT 4
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_INT 4
 433: PUSH
 434: LD_INT 85
 436: PUSH
 437: LD_INT 116
 439: PUSH
 440: LD_INT 4
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: PUSH
 449: LD_INT 32
 451: PUSH
 452: LD_INT 83
 454: PUSH
 455: LD_INT 111
 457: PUSH
 458: LD_INT 4
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: PUSH
 467: LD_INT 32
 469: PUSH
 470: LD_INT 87
 472: PUSH
 473: LD_INT 121
 475: PUSH
 476: LD_INT 4
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: LIST
 483: LIST
 484: PUSH
 485: LD_INT 33
 487: PUSH
 488: LD_INT 88
 490: PUSH
 491: LD_INT 128
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 32
 505: PUSH
 506: LD_INT 59
 508: PUSH
 509: LD_INT 89
 511: PUSH
 512: LD_INT 3
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: LD_INT 33
 523: PUSH
 524: LD_INT 69
 526: PUSH
 527: LD_INT 98
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: PUSH
 539: LD_INT 33
 541: PUSH
 542: LD_INT 77
 544: PUSH
 545: LD_INT 103
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: PUSH
 557: LD_INT 33
 559: PUSH
 560: LD_INT 83
 562: PUSH
 563: LD_INT 105
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 33
 577: PUSH
 578: LD_INT 71
 580: PUSH
 581: LD_INT 125
 583: PUSH
 584: LD_INT 5
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PPUSH
 605: CALL 76106 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 609: LD_INT 2
 611: PPUSH
 612: LD_INT 43
 614: PUSH
 615: LD_INT 47
 617: PUSH
 618: LD_INT 46
 620: PUSH
 621: EMPTY
 622: LIST
 623: LIST
 624: LIST
 625: PPUSH
 626: CALL 77367 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 630: LD_INT 2
 632: PPUSH
 633: LD_INT 21
 635: PUSH
 636: LD_INT 1
 638: PUSH
 639: LD_INT 3
 641: PUSH
 642: LD_INT 51
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 22
 653: PUSH
 654: LD_INT 1
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 52
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: PPUSH
 673: CALL 76262 0 2
// end ;
 677: LD_VAR 0 1
 681: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 682: LD_INT 0
 684: PPUSH
// debug := false ;
 685: LD_ADDR_EXP 1
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// game := true ;
 693: LD_ADDR_EXP 2
 697: PUSH
 698: LD_INT 1
 700: ST_TO_ADDR
// gossudarov_arrive := false ;
 701: LD_ADDR_EXP 4
 705: PUSH
 706: LD_INT 0
 708: ST_TO_ADDR
// ru_lab_builded := false ;
 709: LD_ADDR_EXP 5
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// player_spotted := false ;
 717: LD_ADDR_EXP 6
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// first_attack := false ;
 725: LD_ADDR_EXP 7
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// ru_attackers := [ ] ;
 733: LD_ADDR_EXP 52
 737: PUSH
 738: EMPTY
 739: ST_TO_ADDR
// ar_base_spotted := false ;
 740: LD_ADDR_EXP 8
 744: PUSH
 745: LD_INT 0
 747: ST_TO_ADDR
// ar_active_attack := false ;
 748: LD_ADDR_EXP 9
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_attackers := [ ] ;
 756: LD_ADDR_EXP 10
 760: PUSH
 761: EMPTY
 762: ST_TO_ADDR
// first_powell_attack := false ;
 763: LD_ADDR_EXP 11
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// abdul_escaped := true ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 1
 778: ST_TO_ADDR
// loss_counter := 0 ;
 779: LD_ADDR_EXP 13
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// hack_counter := 0 ;
 787: LD_ADDR_EXP 14
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// end ;
 795: LD_VAR 0 1
 799: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 800: LD_EXP 48
 804: PPUSH
 805: CALL_OW 255
 809: PUSH
 810: LD_INT 7
 812: EQUAL
 813: PUSH
 814: LD_EXP 47
 818: PPUSH
 819: CALL_OW 255
 823: PUSH
 824: LD_INT 7
 826: EQUAL
 827: AND
 828: PUSH
 829: LD_EXP 48
 833: PPUSH
 834: CALL_OW 302
 838: AND
 839: PUSH
 840: LD_EXP 47
 844: PPUSH
 845: CALL_OW 302
 849: AND
 850: IFFALSE 862
 852: GO 854
 854: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 855: LD_STRING ACH_COMRADE
 857: PPUSH
 858: CALL_OW 543
 862: END
// every 0 0$1 trigger hack_counter >= 10 do
 863: LD_EXP 14
 867: PUSH
 868: LD_INT 10
 870: GREATEREQUAL
 871: IFFALSE 883
 873: GO 875
 875: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 876: LD_STRING ACH_HACK
 878: PPUSH
 879: CALL_OW 543
 883: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 884: LD_INT 0
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// uc_side := 7 ;
 890: LD_ADDR_OWVAR 20
 894: PUSH
 895: LD_INT 7
 897: ST_TO_ADDR
// uc_nation := 1 ;
 898: LD_ADDR_OWVAR 21
 902: PUSH
 903: LD_INT 1
 905: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 906: LD_ADDR_EXP 15
 910: PUSH
 911: LD_STRING JMM
 913: PPUSH
 914: LD_EXP 1
 918: NOT
 919: PPUSH
 920: LD_STRING 12a_
 922: PPUSH
 923: CALL 14740 0 3
 927: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 928: LD_EXP 15
 932: PPUSH
 933: LD_INT 71
 935: PPUSH
 936: LD_INT 23
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 946: LD_EXP 15
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 958: LD_ADDR_EXP 16
 962: PUSH
 963: LD_STRING Roth
 965: PPUSH
 966: LD_EXP 1
 970: NOT
 971: PPUSH
 972: LD_STRING 12a_
 974: PPUSH
 975: CALL 14740 0 3
 979: ST_TO_ADDR
// if Roth then
 980: LD_EXP 16
 984: IFFALSE 1004
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 986: LD_EXP 16
 990: PPUSH
 991: LD_INT 71
 993: PPUSH
 994: LD_INT 21
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1004: LD_ADDR_EXP 17
1008: PUSH
1009: LD_STRING Lisa
1011: PPUSH
1012: LD_EXP 1
1016: NOT
1017: PPUSH
1018: LD_STRING 12a_
1020: PPUSH
1021: CALL 14740 0 3
1025: ST_TO_ADDR
// if Lisa then
1026: LD_EXP 17
1030: IFFALSE 1047
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1032: LD_EXP 17
1036: PPUSH
1037: LD_INT 13
1039: PPUSH
1040: LD_INT 0
1042: PPUSH
1043: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1047: LD_ADDR_EXP 18
1051: PUSH
1052: LD_STRING Donaldson
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_STRING 12a_
1063: PPUSH
1064: CALL 14740 0 3
1068: ST_TO_ADDR
// if Donaldson then
1069: LD_EXP 18
1073: IFFALSE 1090
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1075: LD_EXP 18
1079: PPUSH
1080: LD_INT 13
1082: PPUSH
1083: LD_INT 0
1085: PPUSH
1086: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1090: LD_ADDR_EXP 19
1094: PUSH
1095: LD_STRING Bobby
1097: PPUSH
1098: LD_EXP 1
1102: NOT
1103: PPUSH
1104: LD_STRING 12a_
1106: PPUSH
1107: CALL 14740 0 3
1111: ST_TO_ADDR
// if Bobby then
1112: LD_EXP 19
1116: IFFALSE 1133
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1118: LD_EXP 19
1122: PPUSH
1123: LD_INT 13
1125: PPUSH
1126: LD_INT 0
1128: PPUSH
1129: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1133: LD_ADDR_EXP 20
1137: PUSH
1138: LD_STRING Cyrus
1140: PPUSH
1141: LD_EXP 1
1145: NOT
1146: PPUSH
1147: LD_STRING 12a_
1149: PPUSH
1150: CALL 14740 0 3
1154: ST_TO_ADDR
// if Cyrus then
1155: LD_EXP 20
1159: IFFALSE 1176
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1161: LD_EXP 20
1165: PPUSH
1166: LD_INT 13
1168: PPUSH
1169: LD_INT 0
1171: PPUSH
1172: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1176: LD_ADDR_EXP 21
1180: PUSH
1181: LD_STRING Denis
1183: PPUSH
1184: LD_EXP 1
1188: NOT
1189: PPUSH
1190: LD_STRING 12a_
1192: PPUSH
1193: CALL 14740 0 3
1197: ST_TO_ADDR
// if Denis then
1198: LD_EXP 21
1202: IFFALSE 1219
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1204: LD_EXP 21
1208: PPUSH
1209: LD_INT 13
1211: PPUSH
1212: LD_INT 0
1214: PPUSH
1215: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1219: LD_ADDR_EXP 22
1223: PUSH
1224: LD_STRING Brown
1226: PPUSH
1227: LD_EXP 1
1231: NOT
1232: PPUSH
1233: LD_STRING 12a_
1235: PPUSH
1236: CALL 14740 0 3
1240: ST_TO_ADDR
// if Brown then
1241: LD_EXP 22
1245: IFFALSE 1262
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1247: LD_EXP 22
1251: PPUSH
1252: LD_INT 13
1254: PPUSH
1255: LD_INT 0
1257: PPUSH
1258: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1262: LD_ADDR_EXP 23
1266: PUSH
1267: LD_STRING Gladstone
1269: PPUSH
1270: LD_EXP 1
1274: NOT
1275: PPUSH
1276: LD_STRING 12a_
1278: PPUSH
1279: CALL 14740 0 3
1283: ST_TO_ADDR
// if Gladstone then
1284: LD_EXP 23
1288: IFFALSE 1305
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1290: LD_EXP 23
1294: PPUSH
1295: LD_INT 13
1297: PPUSH
1298: LD_INT 0
1300: PPUSH
1301: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1305: LD_ADDR_EXP 24
1309: PUSH
1310: LD_STRING Houten
1312: PPUSH
1313: LD_EXP 1
1317: NOT
1318: PPUSH
1319: LD_STRING 12a_
1321: PPUSH
1322: CALL 14740 0 3
1326: ST_TO_ADDR
// if Houten then
1327: LD_EXP 24
1331: IFFALSE 1348
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1333: LD_EXP 24
1337: PPUSH
1338: LD_INT 13
1340: PPUSH
1341: LD_INT 0
1343: PPUSH
1344: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1348: LD_ADDR_EXP 25
1352: PUSH
1353: LD_STRING Cornell
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: LD_STRING 12a_
1364: PPUSH
1365: CALL 14740 0 3
1369: ST_TO_ADDR
// if Cornel then
1370: LD_EXP 25
1374: IFFALSE 1391
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1376: LD_EXP 25
1380: PPUSH
1381: LD_INT 13
1383: PPUSH
1384: LD_INT 0
1386: PPUSH
1387: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1391: LD_ADDR_EXP 26
1395: PUSH
1396: LD_STRING Gary
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: LD_STRING 12a_
1407: PPUSH
1408: CALL 14740 0 3
1412: ST_TO_ADDR
// if Gary then
1413: LD_EXP 26
1417: IFFALSE 1434
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1419: LD_EXP 26
1423: PPUSH
1424: LD_INT 13
1426: PPUSH
1427: LD_INT 0
1429: PPUSH
1430: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1434: LD_ADDR_EXP 27
1438: PUSH
1439: LD_STRING Frank
1441: PPUSH
1442: LD_EXP 1
1446: NOT
1447: PPUSH
1448: LD_STRING 12a_
1450: PPUSH
1451: CALL 14740 0 3
1455: ST_TO_ADDR
// if Frank then
1456: LD_EXP 27
1460: IFFALSE 1477
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1462: LD_EXP 27
1466: PPUSH
1467: LD_INT 13
1469: PPUSH
1470: LD_INT 0
1472: PPUSH
1473: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1477: LD_ADDR_EXP 28
1481: PUSH
1482: LD_STRING Kikuchi
1484: PPUSH
1485: LD_EXP 1
1489: NOT
1490: PPUSH
1491: LD_STRING 12a_
1493: PPUSH
1494: CALL 14740 0 3
1498: ST_TO_ADDR
// if Kikuchi then
1499: LD_EXP 28
1503: IFFALSE 1520
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1505: LD_EXP 28
1509: PPUSH
1510: LD_INT 13
1512: PPUSH
1513: LD_INT 0
1515: PPUSH
1516: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1520: LD_ADDR_EXP 29
1524: PUSH
1525: LD_STRING Simms
1527: PPUSH
1528: LD_EXP 1
1532: NOT
1533: PPUSH
1534: LD_STRING 12a_
1536: PPUSH
1537: CALL 14740 0 3
1541: ST_TO_ADDR
// if Simms then
1542: LD_EXP 29
1546: IFFALSE 1563
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1548: LD_EXP 29
1552: PPUSH
1553: LD_INT 13
1555: PPUSH
1556: LD_INT 0
1558: PPUSH
1559: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1563: LD_ADDR_EXP 30
1567: PUSH
1568: LD_STRING Joan
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: LD_STRING 12a_
1579: PPUSH
1580: CALL 14740 0 3
1584: ST_TO_ADDR
// if Joan then
1585: LD_EXP 30
1589: IFFALSE 1606
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1591: LD_EXP 30
1595: PPUSH
1596: LD_INT 13
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1606: LD_ADDR_EXP 31
1610: PUSH
1611: LD_STRING DeltaDoctor
1613: PPUSH
1614: LD_EXP 1
1618: NOT
1619: PPUSH
1620: LD_STRING 12a_
1622: PPUSH
1623: CALL 14740 0 3
1627: ST_TO_ADDR
// if DeltaDoctor then
1628: LD_EXP 31
1632: IFFALSE 1649
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1634: LD_EXP 31
1638: PPUSH
1639: LD_INT 13
1641: PPUSH
1642: LD_INT 0
1644: PPUSH
1645: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: LD_STRING 12a_others
1656: PPUSH
1657: CALL_OW 31
1661: ST_TO_ADDR
// if tmp then
1662: LD_VAR 0 4
1666: IFFALSE 1700
// for i in tmp do
1668: LD_ADDR_VAR 0 3
1672: PUSH
1673: LD_VAR 0 4
1677: PUSH
1678: FOR_IN
1679: IFFALSE 1698
// PlaceUnitArea ( i , alliance_start , false ) ;
1681: LD_VAR 0 3
1685: PPUSH
1686: LD_INT 13
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 49
1696: GO 1678
1698: POP
1699: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1700: LD_INT 3
1702: PPUSH
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 100
1714: PPUSH
1715: CALL 19564 0 5
// veh := CreateVehicle ;
1719: LD_ADDR_VAR 0 2
1723: PUSH
1724: CALL_OW 45
1728: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1729: LD_VAR 0 2
1733: PPUSH
1734: LD_INT 2
1736: PPUSH
1737: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1741: LD_VAR 0 2
1745: PPUSH
1746: LD_INT 60
1748: PPUSH
1749: LD_INT 6
1751: PPUSH
1752: LD_INT 0
1754: PPUSH
1755: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1759: LD_VAR 0 2
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: LD_INT 30
1769: PPUSH
1770: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1774: LD_STRING 11_artifact_captured
1776: PPUSH
1777: LD_INT 0
1779: PPUSH
1780: CALL_OW 30
1784: IFFALSE 1860
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1786: LD_INT 3
1788: PPUSH
1789: LD_INT 3
1791: PPUSH
1792: LD_INT 3
1794: PPUSH
1795: LD_INT 12
1797: PPUSH
1798: LD_INT 100
1800: PPUSH
1801: CALL 19564 0 5
// veh := CreateVehicle ;
1805: LD_ADDR_VAR 0 2
1809: PUSH
1810: CALL_OW 45
1814: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1815: LD_VAR 0 2
1819: PPUSH
1820: LD_INT 3
1822: PPUSH
1823: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1827: LD_VAR 0 2
1831: PPUSH
1832: LD_INT 75
1834: PPUSH
1835: LD_INT 6
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: LD_INT 4
1852: PPUSH
1853: LD_INT 50
1855: PPUSH
1856: CALL_OW 290
// end ; end ;
1860: LD_VAR 0 1
1864: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1865: LD_INT 0
1867: PPUSH
1868: PPUSH
1869: PPUSH
1870: PPUSH
// uc_side := 6 ;
1871: LD_ADDR_OWVAR 20
1875: PUSH
1876: LD_INT 6
1878: ST_TO_ADDR
// uc_nation := 3 ;
1879: LD_ADDR_OWVAR 21
1883: PUSH
1884: LD_INT 3
1886: ST_TO_ADDR
// InitHc ;
1887: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1891: LD_ADDR_EXP 32
1895: PUSH
1896: LD_STRING Gossudarov
1898: PPUSH
1899: CALL_OW 25
1903: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1904: LD_ADDR_EXP 33
1908: PUSH
1909: LD_STRING Kirilenkova
1911: PPUSH
1912: CALL_OW 25
1916: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1917: LD_ADDR_EXP 34
1921: PUSH
1922: LD_STRING Titov
1924: PPUSH
1925: CALL_OW 25
1929: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Oblukov
1937: PPUSH
1938: CALL_OW 25
1942: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1943: LD_ADDR_EXP 36
1947: PUSH
1948: LD_STRING Dolgov
1950: PPUSH
1951: CALL_OW 25
1955: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1956: LD_ADDR_EXP 37
1960: PUSH
1961: LD_STRING Petrosyan
1963: PPUSH
1964: CALL_OW 25
1968: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1969: LD_ADDR_EXP 38
1973: PUSH
1974: LD_STRING Scholtze
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1982: LD_ADDR_EXP 40
1986: PUSH
1987: LD_STRING Kapitsova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_EXP 32
2004: PUSH
2005: LD_EXP 33
2009: PUSH
2010: LD_EXP 34
2014: PUSH
2015: LD_EXP 39
2019: PUSH
2020: LD_EXP 36
2024: PUSH
2025: LD_EXP 37
2029: PUSH
2030: LD_EXP 38
2034: PUSH
2035: LD_EXP 40
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 4
2055: PPUSH
2056: LD_INT 8
2058: PPUSH
2059: CALL_OW 380
// un := CreateHuman ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: CALL_OW 44
2072: ST_TO_ADDR
// tmp := tmp ^ un ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_VAR 0 2
2082: PUSH
2083: LD_VAR 0 4
2087: ADD
2088: ST_TO_ADDR
// for i in tmp do
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: FOR_IN
2100: IFFALSE 2119
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 14
2109: PPUSH
2110: LD_INT 0
2112: PPUSH
2113: CALL_OW 49
2117: GO 2099
2119: POP
2120: POP
// if freedom then
2121: LD_EXP 3
2125: IFFALSE 2158
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2127: LD_VAR 0 2
2131: PPUSH
2132: LD_EXP 3
2136: PPUSH
2137: CALL_OW 250
2141: PPUSH
2142: LD_EXP 3
2146: PPUSH
2147: CALL_OW 251
2151: PPUSH
2152: CALL_OW 111
2156: GO 2173
// ComMoveXY ( tmp , 70 , 48 ) ;
2158: LD_VAR 0 2
2162: PPUSH
2163: LD_INT 70
2165: PPUSH
2166: LD_INT 48
2168: PPUSH
2169: CALL_OW 111
// end ;
2173: LD_VAR 0 1
2177: RET
// export function PrepareBelkov ; begin
2178: LD_INT 0
2180: PPUSH
// uc_side := 4 ;
2181: LD_ADDR_OWVAR 20
2185: PUSH
2186: LD_INT 4
2188: ST_TO_ADDR
// uc_nation := 3 ;
2189: LD_ADDR_OWVAR 21
2193: PUSH
2194: LD_INT 3
2196: ST_TO_ADDR
// InitHc ;
2197: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2201: LD_ADDR_EXP 47
2205: PUSH
2206: LD_STRING Belkov
2208: PPUSH
2209: CALL_OW 25
2213: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2214: LD_EXP 47
2218: PPUSH
2219: LD_INT 14
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 49
// end ;
2229: LD_VAR 0 1
2233: RET
// export function PrepareGnyevko ; begin
2234: LD_INT 0
2236: PPUSH
// uc_side := 4 ;
2237: LD_ADDR_OWVAR 20
2241: PUSH
2242: LD_INT 4
2244: ST_TO_ADDR
// uc_nation := 3 ;
2245: LD_ADDR_OWVAR 21
2249: PUSH
2250: LD_INT 3
2252: ST_TO_ADDR
// InitHc ;
2253: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2257: LD_ADDR_EXP 48
2261: PUSH
2262: LD_STRING Gnyevko
2264: PPUSH
2265: CALL_OW 25
2269: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2270: LD_EXP 48
2274: PPUSH
2275: LD_INT 14
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// end ;
2285: LD_VAR 0 1
2289: RET
// export function PrepareBurlak ; var i , tmp ; begin
2290: LD_INT 0
2292: PPUSH
2293: PPUSH
2294: PPUSH
// uc_side := 4 ;
2295: LD_ADDR_OWVAR 20
2299: PUSH
2300: LD_INT 4
2302: ST_TO_ADDR
// uc_nation := 3 ;
2303: LD_ADDR_OWVAR 21
2307: PUSH
2308: LD_INT 3
2310: ST_TO_ADDR
// InitHc ;
2311: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2315: LD_ADDR_EXP 46
2319: PUSH
2320: LD_STRING Burlak
2322: PPUSH
2323: CALL_OW 25
2327: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2328: LD_INT 24
2330: PUSH
2331: LD_INT 23
2333: PUSH
2334: LD_INT 22
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: LIST
2341: PUSH
2342: LD_OWVAR 67
2346: ARRAY
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_INT 1
2353: PPUSH
2354: LD_INT 45
2356: PUSH
2357: LD_INT 44
2359: PUSH
2360: LD_INT 43
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: LIST
2367: PUSH
2368: LD_OWVAR 67
2372: ARRAY
2373: PPUSH
2374: LD_INT 0
2376: PPUSH
2377: CALL 19564 0 5
// Masha := CreateVehicle ;
2381: LD_ADDR_EXP 49
2385: PUSH
2386: CALL_OW 45
2390: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2391: LD_EXP 49
2395: PUSH
2396: LD_EXP 46
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PPUSH
2405: LD_INT 499
2407: PPUSH
2408: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2412: LD_EXP 49
2416: PPUSH
2417: LD_INT 3
2419: PPUSH
2420: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2424: LD_EXP 49
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 18
2441: PPUSH
2442: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2446: LD_INT 35
2448: PPUSH
2449: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_INT 18
2460: PPUSH
2461: EMPTY
2462: PPUSH
2463: CALL_OW 70
2467: ST_TO_ADDR
// if tmp then
2468: LD_VAR 0 3
2472: IFFALSE 2506
// for i in tmp do
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 3
2483: PUSH
2484: FOR_IN
2485: IFFALSE 2504
// ComMoveXY ( i , 114 , 9 ) ;
2487: LD_VAR 0 2
2491: PPUSH
2492: LD_INT 114
2494: PPUSH
2495: LD_INT 9
2497: PPUSH
2498: CALL_OW 111
2502: GO 2484
2504: POP
2505: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2506: LD_INT 18
2508: PPUSH
2509: EMPTY
2510: PPUSH
2511: CALL_OW 70
2515: NOT
2516: PUSH
2517: LD_INT 123
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: CALL_OW 428
2527: PUSH
2528: LD_INT 0
2530: EQUAL
2531: AND
2532: IFFALSE 2446
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2534: LD_EXP 49
2538: PPUSH
2539: LD_INT 123
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2552: LD_EXP 46
2556: PPUSH
2557: LD_INT 125
2559: PPUSH
2560: LD_INT 1
2562: PPUSH
2563: LD_INT 0
2565: PPUSH
2566: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2570: LD_EXP 46
2574: PPUSH
2575: LD_EXP 49
2579: PPUSH
2580: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2584: LD_INT 10
2586: PPUSH
2587: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2591: LD_EXP 49
2595: PPUSH
2596: LD_INT 110
2598: PPUSH
2599: LD_INT 10
2601: PPUSH
2602: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2606: LD_ADDR_EXP 42
2610: PUSH
2611: LD_STRING Petrovova
2613: PPUSH
2614: CALL_OW 25
2618: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2619: LD_ADDR_EXP 44
2623: PUSH
2624: LD_STRING Kuzmov
2626: PPUSH
2627: CALL_OW 25
2631: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2632: LD_ADDR_EXP 43
2636: PUSH
2637: LD_STRING Kovalyuk
2639: PPUSH
2640: CALL_OW 25
2644: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2645: LD_ADDR_EXP 41
2649: PUSH
2650: LD_STRING Lipshchin
2652: PPUSH
2653: CALL_OW 25
2657: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2658: LD_ADDR_EXP 45
2662: PUSH
2663: LD_STRING Karamazov
2665: PPUSH
2666: CALL_OW 25
2670: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 42
2680: PUSH
2681: LD_EXP 44
2685: PUSH
2686: LD_EXP 43
2690: PUSH
2691: LD_EXP 41
2695: PUSH
2696: LD_EXP 45
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: ST_TO_ADDR
// for i in tmp do
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 3
2717: PUSH
2718: FOR_IN
2719: IFFALSE 2758
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2721: LD_VAR 0 2
2725: PPUSH
2726: LD_INT 399
2728: PPUSH
2729: LD_INT 799
2731: PPUSH
2732: CALL_OW 12
2736: PPUSH
2737: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: LD_INT 0
2751: PPUSH
2752: CALL_OW 49
// end ;
2756: GO 2718
2758: POP
2759: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 116
2767: PPUSH
2768: LD_INT 8
2770: PPUSH
2771: CALL_OW 111
// AddComHold ( tmp ) ;
2775: LD_VAR 0 3
2779: PPUSH
2780: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2784: LD_ADDR_VAR 0 2
2788: PUSH
2789: LD_VAR 0 3
2793: PPUSH
2794: LD_INT 25
2796: PUSH
2797: LD_INT 1
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PPUSH
2804: CALL_OW 72
2808: PUSH
2809: FOR_IN
2810: IFFALSE 2850
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2812: LD_VAR 0 2
2816: PPUSH
2817: LD_INT 20
2819: PPUSH
2820: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2824: LD_VAR 0 2
2828: PPUSH
2829: LD_INT 147
2831: PPUSH
2832: LD_INT 45
2834: PPUSH
2835: CALL_OW 178
// AddComCrawl ( i ) ;
2839: LD_VAR 0 2
2843: PPUSH
2844: CALL_OW 197
// end ;
2848: GO 2809
2850: POP
2851: POP
// repeat wait ( 0 0$1 ) ;
2852: LD_INT 35
2854: PPUSH
2855: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2859: LD_EXP 49
2863: PPUSH
2864: LD_INT 110
2866: PPUSH
2867: LD_INT 10
2869: PPUSH
2870: CALL_OW 307
2874: PUSH
2875: LD_EXP 49
2879: PPUSH
2880: CALL_OW 305
2884: NOT
2885: OR
2886: IFFALSE 2852
// ComStop ( Burlak ) ;
2888: LD_EXP 46
2892: PPUSH
2893: CALL_OW 141
// AddComHold ( Burlak ) ;
2897: LD_EXP 46
2901: PPUSH
2902: CALL_OW 200
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// uc_side := 3 ;
2918: LD_ADDR_OWVAR 20
2922: PUSH
2923: LD_INT 3
2925: ST_TO_ADDR
// uc_nation := 3 ;
2926: LD_ADDR_OWVAR 21
2930: PUSH
2931: LD_INT 3
2933: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2934: LD_ADDR_EXP 50
2938: PUSH
2939: LD_INT 47
2941: PPUSH
2942: LD_INT 4
2944: PPUSH
2945: LD_STRING 
2947: PPUSH
2948: LD_INT 7
2950: PUSH
2951: LD_INT 8
2953: PUSH
2954: LD_INT 10
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: PUSH
2962: LD_OWVAR 67
2966: ARRAY
2967: PPUSH
2968: LD_INT 10000
2970: PUSH
2971: LD_INT 3000
2973: PUSH
2974: LD_INT 300
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PPUSH
2982: LD_INT 9
2984: PUSH
2985: LD_INT 5
2987: PUSH
2988: LD_INT 6
2990: PUSH
2991: LD_INT 6
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL 23005 0 6
3004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3005: LD_ADDR_EXP 59
3009: PUSH
3010: LD_EXP 59
3014: PPUSH
3015: LD_INT 2
3017: PPUSH
3018: LD_EXP 50
3022: PPUSH
3023: CALL_OW 1
3027: ST_TO_ADDR
// tmp := [ ] ;
3028: LD_ADDR_VAR 0 4
3032: PUSH
3033: EMPTY
3034: ST_TO_ADDR
// for i = 1 to 4 do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: DOUBLE
3041: LD_INT 1
3043: DEC
3044: ST_TO_ADDR
3045: LD_INT 4
3047: PUSH
3048: FOR_TO
3049: IFFALSE 3142
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3051: LD_INT 22
3053: PPUSH
3054: LD_INT 3
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: LD_INT 43
3062: PUSH
3063: LD_INT 45
3065: PUSH
3066: LD_INT 45
3068: PUSH
3069: LD_INT 44
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_INT 4
3085: MOD
3086: PUSH
3087: LD_INT 1
3089: PLUS
3090: ARRAY
3091: PPUSH
3092: LD_INT 100
3094: PPUSH
3095: CALL 19564 0 5
// veh := CreateVehicle ;
3099: LD_ADDR_VAR 0 3
3103: PUSH
3104: CALL_OW 45
3108: ST_TO_ADDR
// tmp := tmp ^ veh ;
3109: LD_ADDR_VAR 0 4
3113: PUSH
3114: LD_VAR 0 4
3118: PUSH
3119: LD_VAR 0 3
3123: ADD
3124: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3125: LD_VAR 0 3
3129: PPUSH
3130: LD_INT 2
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 49
// end ;
3140: GO 3048
3142: POP
3143: POP
// russian_guard := tmp ;
3144: LD_ADDR_EXP 51
3148: PUSH
3149: LD_VAR 0 4
3153: ST_TO_ADDR
// if Difficulty = 3 then
3154: LD_OWVAR 67
3158: PUSH
3159: LD_INT 3
3161: EQUAL
3162: IFFALSE 3226
// begin bc_type := b_breastwork ;
3164: LD_ADDR_OWVAR 42
3168: PUSH
3169: LD_INT 31
3171: ST_TO_ADDR
// bc_level := 10 ;
3172: LD_ADDR_OWVAR 43
3176: PUSH
3177: LD_INT 10
3179: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3180: LD_ADDR_VAR 0 5
3184: PUSH
3185: LD_INT 96
3187: PPUSH
3188: LD_INT 105
3190: PPUSH
3191: LD_INT 3
3193: PPUSH
3194: CALL_OW 47
3198: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3199: LD_INT 0
3201: PPUSH
3202: LD_INT 9
3204: PPUSH
3205: LD_INT 10
3207: PPUSH
3208: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3212: CALL_OW 44
3216: PPUSH
3217: LD_VAR 0 5
3221: PPUSH
3222: CALL_OW 52
// end ; end ;
3226: LD_VAR 0 1
3230: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3231: LD_INT 47
3233: PPUSH
3234: CALL_OW 302
3238: PUSH
3239: LD_EXP 6
3243: AND
3244: IFFALSE 3929
3246: GO 3248
3248: DISABLE
3249: LD_INT 0
3251: PPUSH
3252: PPUSH
3253: PPUSH
3254: PPUSH
3255: PPUSH
3256: PPUSH
3257: PPUSH
// begin enable ;
3258: ENABLE
// base := 2 ;
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: LD_INT 2
3266: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3267: LD_ADDR_VAR 0 4
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: LD_INT 0
3277: PUSH
3278: LD_INT 0
3280: PUSH
3281: LD_INT 0
3283: PUSH
3284: LD_INT 0
3286: PUSH
3287: LD_INT 0
3289: PUSH
3290: LD_INT 0
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 1
3298: PUSH
3299: LD_INT 0
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: LIST
3311: LIST
3312: LIST
3313: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3314: LD_ADDR_VAR 0 3
3318: PUSH
3319: LD_INT 22
3321: PUSH
3322: LD_INT 1
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 45
3330: PUSH
3331: EMPTY
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_INT 21
3339: PUSH
3340: LD_INT 1
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 45
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: PUSH
3355: LD_INT 22
3357: PUSH
3358: LD_INT 1
3360: PUSH
3361: LD_INT 3
3363: PUSH
3364: LD_INT 45
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 23
3375: PUSH
3376: LD_INT 1
3378: PUSH
3379: LD_INT 3
3381: PUSH
3382: LD_INT 46
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// amount := Difficulty ;
3397: LD_ADDR_VAR 0 7
3401: PUSH
3402: LD_OWVAR 67
3406: ST_TO_ADDR
// if tick > 30 30$00 then
3407: LD_OWVAR 1
3411: PUSH
3412: LD_INT 63000
3414: GREATER
3415: IFFALSE 3448
// amount := amount + [ 2 , 3 , 4 ] [ Difficulty ] ;
3417: LD_ADDR_VAR 0 7
3421: PUSH
3422: LD_VAR 0 7
3426: PUSH
3427: LD_INT 2
3429: PUSH
3430: LD_INT 3
3432: PUSH
3433: LD_INT 4
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: LD_OWVAR 67
3445: ARRAY
3446: PLUS
3447: ST_TO_ADDR
// for i = 1 to amount do
3448: LD_ADDR_VAR 0 1
3452: PUSH
3453: DOUBLE
3454: LD_INT 1
3456: DEC
3457: ST_TO_ADDR
3458: LD_VAR 0 7
3462: PUSH
3463: FOR_TO
3464: IFFALSE 3552
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3466: LD_ADDR_VAR 0 3
3470: PUSH
3471: LD_VAR 0 3
3475: PPUSH
3476: LD_VAR 0 3
3480: PUSH
3481: LD_INT 1
3483: PLUS
3484: PPUSH
3485: LD_INT 23
3487: PUSH
3488: LD_INT 24
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 2
3500: PPUSH
3501: CALL_OW 12
3505: ARRAY
3506: PUSH
3507: LD_INT 1
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: LD_INT 46
3515: PUSH
3516: LD_INT 47
3518: PUSH
3519: LD_INT 45
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 3
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 2
3549: ST_TO_ADDR
3550: GO 3463
3552: POP
3553: POP
// MC_InsertProduceList ( base , tmp ) ;
3554: LD_VAR 0 2
3558: PPUSH
3559: LD_VAR 0 3
3563: PPUSH
3564: CALL 76262 0 2
// repeat wait ( 0 0$1 ) ;
3568: LD_INT 35
3570: PPUSH
3571: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3575: LD_VAR 0 2
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL 77680 0 2
3587: PUSH
3588: LD_VAR 0 7
3592: GREATEREQUAL
3593: IFFALSE 3568
// wait ( 0 0$30 ) ;
3595: LD_INT 1050
3597: PPUSH
3598: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_INT 71
3609: PUSH
3610: LD_INT 19
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 91
3619: PUSH
3620: LD_INT 67
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 52
3629: PUSH
3630: LD_INT 44
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 68
3639: PUSH
3640: LD_INT 48
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_EXP 78
3662: PUSH
3663: LD_VAR 0 2
3667: ARRAY
3668: PUSH
3669: LD_EXP 78
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: PPUSH
3680: LD_INT 2
3682: PUSH
3683: LD_INT 34
3685: PUSH
3686: LD_INT 51
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: LD_INT 34
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PPUSH
3708: CALL_OW 72
3712: DIFF
3713: ST_TO_ADDR
// if not attackers then
3714: LD_VAR 0 6
3718: NOT
3719: IFFALSE 3723
// exit ;
3721: GO 3929
// ru_attackers := attackers ;
3723: LD_ADDR_EXP 52
3727: PUSH
3728: LD_VAR 0 6
3732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3733: LD_ADDR_EXP 78
3737: PUSH
3738: LD_EXP 78
3742: PPUSH
3743: LD_VAR 0 2
3747: PPUSH
3748: LD_EXP 78
3752: PUSH
3753: LD_VAR 0 2
3757: ARRAY
3758: PUSH
3759: LD_VAR 0 6
3763: DIFF
3764: PPUSH
3765: CALL_OW 1
3769: ST_TO_ADDR
// for i = 1 to attackers do
3770: LD_ADDR_VAR 0 1
3774: PUSH
3775: DOUBLE
3776: LD_INT 1
3778: DEC
3779: ST_TO_ADDR
3780: LD_VAR 0 6
3784: PUSH
3785: FOR_TO
3786: IFFALSE 3863
// begin case i mod 3 of 0 :
3788: LD_VAR 0 1
3792: PUSH
3793: LD_INT 3
3795: MOD
3796: PUSH
3797: LD_INT 0
3799: DOUBLE
3800: EQUAL
3801: IFTRUE 3805
3803: GO 3808
3805: POP
// ; 1 :
3806: GO 3861
3808: LD_INT 1
3810: DOUBLE
3811: EQUAL
3812: IFTRUE 3816
3814: GO 3834
3816: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3817: LD_VAR 0 1
3821: PPUSH
3822: LD_INT 32
3824: PPUSH
3825: LD_INT 49
3827: PPUSH
3828: CALL_OW 114
3832: GO 3861
3834: LD_INT 2
3836: DOUBLE
3837: EQUAL
3838: IFTRUE 3842
3840: GO 3860
3842: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3843: LD_VAR 0 1
3847: PPUSH
3848: LD_INT 117
3850: PPUSH
3851: LD_INT 107
3853: PPUSH
3854: CALL_OW 114
3858: GO 3861
3860: POP
// end ;
3861: GO 3785
3863: POP
3864: POP
// repeat wait ( 0 0$1 ) ;
3865: LD_INT 35
3867: PPUSH
3868: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_INT 60
3879: PUSH
3880: EMPTY
3881: LIST
3882: PPUSH
3883: CALL_OW 72
3887: NOT
3888: IFFALSE 3865
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3890: LD_VAR 0 2
3894: PPUSH
3895: LD_VAR 0 6
3899: PPUSH
3900: LD_VAR 0 5
3904: PPUSH
3905: LD_VAR 0 4
3909: PPUSH
3910: CALL 76447 0 4
// if not first_attack then
3914: LD_EXP 7
3918: NOT
3919: IFFALSE 3929
// first_attack := true ;
3921: LD_ADDR_EXP 7
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// end ; end_of_file
3929: PPOPN 7
3931: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3932: LD_INT 0
3934: PPUSH
3935: PPUSH
3936: PPUSH
3937: PPUSH
3938: PPUSH
3939: PPUSH
3940: PPUSH
// uc_side := 2 ;
3941: LD_ADDR_OWVAR 20
3945: PUSH
3946: LD_INT 2
3948: ST_TO_ADDR
// uc_nation := 2 ;
3949: LD_ADDR_OWVAR 21
3953: PUSH
3954: LD_INT 2
3956: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3957: LD_ADDR_EXP 55
3961: PUSH
3962: LD_STRING Abdul
3964: PPUSH
3965: CALL_OW 25
3969: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3970: LD_EXP 55
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3982: LD_EXP 55
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: CALL_OW 52
// vc_chassis := 31 ;
3994: LD_ADDR_OWVAR 37
3998: PUSH
3999: LD_INT 31
4001: ST_TO_ADDR
// vc_control := control_rider ;
4002: LD_ADDR_OWVAR 38
4006: PUSH
4007: LD_INT 4
4009: ST_TO_ADDR
// mastodont := CreateVehicle ;
4010: LD_ADDR_EXP 56
4014: PUSH
4015: CALL_OW 45
4019: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4020: LD_EXP 56
4024: PPUSH
4025: LD_INT 153
4027: PPUSH
4028: LD_INT 71
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 48
// InitVc ;
4038: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 3
4052: PPUSH
4053: LD_STRING 
4055: PPUSH
4056: LD_INT 7
4058: PUSH
4059: LD_INT 8
4061: PUSH
4062: LD_INT 10
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: LIST
4069: PUSH
4070: LD_OWVAR 67
4074: ARRAY
4075: PPUSH
4076: LD_INT 5000
4078: PUSH
4079: LD_INT 1000
4081: PUSH
4082: LD_INT 300
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PPUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 5
4095: PUSH
4096: LD_INT 6
4098: PUSH
4099: LD_INT 9
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PPUSH
4108: CALL 23005 0 6
4112: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4113: LD_ADDR_EXP 59
4117: PUSH
4118: LD_EXP 59
4122: PPUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_EXP 53
4130: PPUSH
4131: CALL_OW 1
4135: ST_TO_ADDR
// tmp := [ ] ;
4136: LD_ADDR_VAR 0 4
4140: PUSH
4141: EMPTY
4142: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4143: LD_ADDR_OWVAR 37
4147: PUSH
4148: LD_INT 14
4150: ST_TO_ADDR
// vc_engine := engine_siberite ;
4151: LD_ADDR_OWVAR 39
4155: PUSH
4156: LD_INT 3
4158: ST_TO_ADDR
// vc_control := control_manual ;
4159: LD_ADDR_OWVAR 38
4163: PUSH
4164: LD_INT 1
4166: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4167: LD_ADDR_OWVAR 40
4171: PUSH
4172: LD_INT 31
4174: ST_TO_ADDR
// for i = 1 to 3 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 3
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4433
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 153
4198: PUSH
4199: LD_INT 71
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 155
4208: PUSH
4209: LD_INT 81
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_VAR 0 2
4224: PUSH
4225: LD_INT 2
4227: MOD
4228: PUSH
4229: LD_INT 1
4231: PLUS
4232: ARRAY
4233: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 ] [ Difficulty ] ) ;
4234: LD_INT 0
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 7
4242: PUSH
4243: LD_INT 8
4245: PUSH
4246: LD_INT 10
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: PUSH
4254: LD_OWVAR 67
4258: ARRAY
4259: PPUSH
4260: CALL_OW 380
// un := CreateVehicle ;
4264: LD_ADDR_VAR 0 6
4268: PUSH
4269: CALL_OW 45
4273: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4274: LD_VAR 0 6
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: LD_INT 5
4284: PPUSH
4285: CALL_OW 12
4289: PPUSH
4290: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4294: LD_VAR 0 6
4298: PPUSH
4299: LD_VAR 0 5
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PPUSH
4308: LD_VAR 0 5
4312: PUSH
4313: LD_INT 2
4315: ARRAY
4316: PPUSH
4317: LD_INT 6
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 50
// un2 := CreateHuman ;
4327: LD_ADDR_VAR 0 7
4331: PUSH
4332: CALL_OW 44
4336: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4337: LD_VAR 0 7
4341: PPUSH
4342: LD_VAR 0 6
4346: PPUSH
4347: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4351: LD_ADDR_EXP 59
4355: PUSH
4356: LD_EXP 59
4360: PPUSH
4361: LD_INT 1
4363: PUSH
4364: LD_EXP 59
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: PUSH
4373: LD_INT 1
4375: PLUS
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: LD_VAR 0 6
4385: PPUSH
4386: CALL 19686 0 3
4390: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4391: LD_ADDR_EXP 59
4395: PUSH
4396: LD_EXP 59
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 59
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 7
4425: PPUSH
4426: CALL 19686 0 3
4430: ST_TO_ADDR
// end ;
4431: GO 4188
4433: POP
4434: POP
// for i = 1 to 5 do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: DOUBLE
4441: LD_INT 1
4443: DEC
4444: ST_TO_ADDR
4445: LD_INT 5
4447: PUSH
4448: FOR_TO
4449: IFFALSE 4542
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4451: LD_INT 14
4453: PPUSH
4454: LD_INT 3
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 25
4462: PUSH
4463: LD_INT 28
4465: PUSH
4466: LD_INT 28
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_VAR 0 2
4482: PUSH
4483: LD_INT 4
4485: MOD
4486: PUSH
4487: LD_INT 1
4489: PLUS
4490: ARRAY
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 19564 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// tmp := tmp ^ veh ;
4509: LD_ADDR_VAR 0 4
4513: PUSH
4514: LD_VAR 0 4
4518: PUSH
4519: LD_VAR 0 3
4523: ADD
4524: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4525: LD_VAR 0 3
4529: PPUSH
4530: LD_INT 1
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 49
// end ;
4540: GO 4448
4542: POP
4543: POP
// arabian_guard := tmp ;
4544: LD_ADDR_EXP 54
4548: PUSH
4549: LD_VAR 0 4
4553: ST_TO_ADDR
// end ;
4554: LD_VAR 0 1
4558: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4559: LD_INT 22
4561: PUSH
4562: LD_INT 7
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 91
4571: PUSH
4572: LD_INT 1
4574: PUSH
4575: LD_INT 12
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 69
4591: PUSH
4592: LD_EXP 56
4596: PPUSH
4597: CALL_OW 256
4601: PUSH
4602: LD_INT 990
4604: LESS
4605: OR
4606: PUSH
4607: LD_EXP 55
4611: PPUSH
4612: CALL_OW 256
4616: PUSH
4617: LD_INT 990
4619: LESS
4620: OR
4621: IFFALSE 4764
4623: GO 4625
4625: DISABLE
// begin if IsInUnit ( Abdul ) then
4626: LD_EXP 55
4630: PPUSH
4631: CALL_OW 310
4635: IFFALSE 4646
// ComExitBuilding ( Abdul ) ;
4637: LD_EXP 55
4641: PPUSH
4642: CALL_OW 122
// if Mastodont then
4646: LD_EXP 56
4650: IFFALSE 4667
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4652: LD_EXP 56
4656: PPUSH
4657: LD_INT 205
4659: PPUSH
4660: LD_INT 132
4662: PPUSH
4663: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4667: LD_EXP 55
4671: PPUSH
4672: LD_INT 205
4674: PPUSH
4675: LD_INT 132
4677: PPUSH
4678: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4682: LD_INT 35
4684: PPUSH
4685: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4689: LD_EXP 55
4693: PPUSH
4694: LD_INT 21
4696: PPUSH
4697: CALL_OW 308
4701: IFFALSE 4682
// RemoveUnit ( Abdul ) ;
4703: LD_EXP 55
4707: PPUSH
4708: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4712: LD_INT 35
4714: PPUSH
4715: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4719: LD_EXP 56
4723: PPUSH
4724: LD_INT 21
4726: PPUSH
4727: CALL_OW 308
4731: PUSH
4732: LD_EXP 56
4736: PPUSH
4737: CALL_OW 301
4741: OR
4742: IFFALSE 4712
// if IsOk ( Mastodont ) then
4744: LD_EXP 56
4748: PPUSH
4749: CALL_OW 302
4753: IFFALSE 4764
// RemoveUnit ( Mastodont ) ;
4755: LD_EXP 56
4759: PPUSH
4760: CALL_OW 64
// end ;
4764: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4765: LD_EXP 55
4769: PPUSH
4770: CALL_OW 301
4774: PUSH
4775: LD_INT 22
4777: PUSH
4778: LD_INT 2
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 2
4787: PUSH
4788: LD_INT 25
4790: PUSH
4791: LD_INT 1
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 25
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 25
4810: PUSH
4811: LD_INT 3
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 25
4820: PUSH
4821: LD_INT 4
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 8
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PPUSH
4850: CALL_OW 69
4854: PUSH
4855: LD_INT 16
4857: PUSH
4858: LD_INT 19
4860: PUSH
4861: LD_INT 22
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: PUSH
4869: LD_OWVAR 67
4873: ARRAY
4874: LESS
4875: OR
4876: IFFALSE 5549
4878: GO 4880
4880: DISABLE
4881: LD_INT 0
4883: PPUSH
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// begin MC_Kill ( 1 ) ;
4889: LD_INT 1
4891: PPUSH
4892: CALL 52608 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4896: LD_ADDR_VAR 0 2
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 2
4913: PUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 1
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PUSH
4924: LD_INT 25
4926: PUSH
4927: LD_INT 2
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 25
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 25
4946: PUSH
4947: LD_INT 4
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 25
4956: PUSH
4957: LD_INT 8
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PPUSH
4976: CALL_OW 69
4980: ST_TO_ADDR
// for i in tmp do
4981: LD_ADDR_VAR 0 5
4985: PUSH
4986: LD_VAR 0 2
4990: PUSH
4991: FOR_IN
4992: IFFALSE 5008
// SetTag ( i , 10 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 10
5001: PPUSH
5002: CALL_OW 109
5006: GO 4991
5008: POP
5009: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5010: LD_ADDR_VAR 0 3
5014: PUSH
5015: LD_INT 22
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 21
5027: PUSH
5028: LD_INT 1
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PPUSH
5039: CALL_OW 69
5043: PUSH
5044: LD_VAR 0 2
5048: DIFF
5049: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_INT 2
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 2
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 24
5077: PUSH
5078: LD_INT 300
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5095: LD_ADDR_VAR 0 4
5099: PUSH
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_INT 33
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: LD_INT 58
5117: PUSH
5118: EMPTY
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 72
5129: ST_TO_ADDR
// for i in tmp do
5130: LD_ADDR_VAR 0 5
5134: PUSH
5135: LD_VAR 0 2
5139: PUSH
5140: FOR_IN
5141: IFFALSE 5325
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5143: LD_VAR 0 5
5147: PUSH
5148: LD_INT 55
5150: PUSH
5151: EMPTY
5152: LIST
5153: PPUSH
5154: CALL_OW 69
5158: IN
5159: IFFALSE 5178
// begin AddComMoveXY ( i , 209 , 132 ) ;
5161: LD_VAR 0 5
5165: PPUSH
5166: LD_INT 209
5168: PPUSH
5169: LD_INT 132
5171: PPUSH
5172: CALL_OW 171
// continue ;
5176: GO 5140
// end ; if IsInUnit ( i ) then
5178: LD_VAR 0 5
5182: PPUSH
5183: CALL_OW 310
5187: IFFALSE 5205
// begin ComExitBuilding ( i ) ;
5189: LD_VAR 0 5
5193: PPUSH
5194: CALL_OW 122
// wait ( 3 ) ;
5198: LD_INT 3
5200: PPUSH
5201: CALL_OW 67
// end ; if tmp_empty then
5205: LD_VAR 0 4
5209: IFFALSE 5308
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5211: LD_VAR 0 5
5215: PPUSH
5216: LD_VAR 0 4
5220: PPUSH
5221: LD_VAR 0 5
5225: PPUSH
5226: CALL_OW 74
5230: PPUSH
5231: CALL_OW 296
5235: PUSH
5236: LD_INT 25
5238: LESS
5239: IFFALSE 5308
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5241: LD_ADDR_VAR 0 6
5245: PUSH
5246: LD_VAR 0 4
5250: PPUSH
5251: LD_VAR 0 5
5255: PPUSH
5256: CALL_OW 74
5260: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5261: LD_VAR 0 5
5265: PPUSH
5266: LD_VAR 0 6
5270: PPUSH
5271: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5275: LD_VAR 0 5
5279: PPUSH
5280: LD_INT 209
5282: PPUSH
5283: LD_INT 132
5285: PPUSH
5286: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: LD_VAR 0 4
5299: PUSH
5300: LD_VAR 0 6
5304: DIFF
5305: ST_TO_ADDR
// continue ;
5306: GO 5140
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5308: LD_VAR 0 5
5312: PPUSH
5313: LD_INT 201
5315: PPUSH
5316: LD_INT 132
5318: PPUSH
5319: CALL_OW 171
// end ;
5323: GO 5140
5325: POP
5326: POP
// for i in tmp_ape do
5327: LD_ADDR_VAR 0 5
5331: PUSH
5332: LD_VAR 0 3
5336: PUSH
5337: FOR_IN
5338: IFFALSE 5377
// begin if IsInUnit ( i ) then
5340: LD_VAR 0 5
5344: PPUSH
5345: CALL_OW 310
5349: IFFALSE 5360
// ComExitBuilding ( i ) ;
5351: LD_VAR 0 5
5355: PPUSH
5356: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5360: LD_VAR 0 5
5364: PPUSH
5365: LD_INT 201
5367: PPUSH
5368: LD_INT 132
5370: PPUSH
5371: CALL_OW 171
// end ;
5375: GO 5337
5377: POP
5378: POP
// repeat wait ( 0 0$1 ) ;
5379: LD_INT 35
5381: PPUSH
5382: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5386: LD_ADDR_VAR 0 5
5390: PUSH
5391: LD_VAR 0 2
5395: PUSH
5396: LD_VAR 0 3
5400: UNION
5401: PUSH
5402: LD_VAR 0 1
5406: UNION
5407: PUSH
5408: FOR_IN
5409: IFFALSE 5440
// if not HasTask ( i ) then
5411: LD_VAR 0 5
5415: PPUSH
5416: CALL_OW 314
5420: NOT
5421: IFFALSE 5438
// ComMoveXY ( i , 201 , 132 ) ;
5423: LD_VAR 0 5
5427: PPUSH
5428: LD_INT 201
5430: PPUSH
5431: LD_INT 132
5433: PPUSH
5434: CALL_OW 111
5438: GO 5408
5440: POP
5441: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5442: LD_INT 21
5444: PPUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 2
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PPUSH
5455: CALL_OW 70
5459: IFFALSE 5500
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5461: LD_ADDR_VAR 0 5
5465: PUSH
5466: LD_INT 21
5468: PPUSH
5469: LD_INT 22
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: CALL_OW 70
5483: PUSH
5484: FOR_IN
5485: IFFALSE 5498
// RemoveUnit ( i ) ;
5487: LD_VAR 0 5
5491: PPUSH
5492: CALL_OW 64
5496: GO 5484
5498: POP
5499: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5500: LD_INT 22
5502: PUSH
5503: LD_INT 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: LD_INT 21
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 21
5525: PUSH
5526: LD_INT 2
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL_OW 69
5546: NOT
5547: IFFALSE 5379
// end ;
5549: PPOPN 6
5551: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5552: LD_EXP 9
5556: PUSH
5557: LD_INT 92
5559: PPUSH
5560: LD_INT 40
5562: PPUSH
5563: CALL_OW 428
5567: PPUSH
5568: CALL_OW 266
5572: PUSH
5573: LD_INT 30
5575: EQUAL
5576: AND
5577: IFFALSE 5773
5579: GO 5581
5581: DISABLE
5582: LD_INT 0
5584: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: LD_EXP 59
5594: PUSH
5595: LD_INT 1
5597: ARRAY
5598: PPUSH
5599: LD_INT 25
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 72
5613: ST_TO_ADDR
// if not sci then
5614: LD_VAR 0 1
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 5773
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5623: LD_ADDR_EXP 59
5627: PUSH
5628: LD_EXP 59
5632: PPUSH
5633: LD_INT 1
5635: PPUSH
5636: LD_EXP 59
5640: PUSH
5641: LD_INT 1
5643: ARRAY
5644: PUSH
5645: LD_VAR 0 1
5649: PUSH
5650: LD_INT 1
5652: ARRAY
5653: DIFF
5654: PPUSH
5655: CALL_OW 1
5659: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5660: LD_VAR 0 1
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 310
5673: IFFALSE 5688
// ComExitBuilding ( sci [ 1 ] ) ;
5675: LD_VAR 0 1
5679: PUSH
5680: LD_INT 1
5682: ARRAY
5683: PPUSH
5684: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5688: LD_INT 2
5690: PPUSH
5691: LD_INT 105
5693: PPUSH
5694: LD_INT 14
5696: PPUSH
5697: LD_INT 20
5699: PPUSH
5700: CALL 20582 0 4
5704: PUSH
5705: LD_INT 4
5707: ARRAY
5708: PUSH
5709: LD_INT 10
5711: LESS
5712: IFFALSE 5735
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5714: LD_VAR 0 1
5718: PUSH
5719: LD_INT 1
5721: ARRAY
5722: PPUSH
5723: LD_INT 105
5725: PPUSH
5726: LD_INT 14
5728: PPUSH
5729: CALL_OW 171
5733: GO 5754
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5735: LD_VAR 0 1
5739: PUSH
5740: LD_INT 1
5742: ARRAY
5743: PPUSH
5744: LD_INT 118
5746: PPUSH
5747: LD_INT 77
5749: PPUSH
5750: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 1
5761: ARRAY
5762: PPUSH
5763: LD_INT 92
5765: PPUSH
5766: LD_INT 40
5768: PPUSH
5769: CALL_OW 218
// end ;
5773: PPOPN 1
5775: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5776: LD_INT 1
5778: PPUSH
5779: CALL_OW 302
5783: PUSH
5784: LD_EXP 9
5788: AND
5789: IFFALSE 6268
5791: GO 5793
5793: DISABLE
5794: LD_INT 0
5796: PPUSH
5797: PPUSH
5798: PPUSH
5799: PPUSH
5800: PPUSH
5801: PPUSH
// begin enable ;
5802: ENABLE
// base := 1 ;
5803: LD_ADDR_VAR 0 2
5807: PUSH
5808: LD_INT 1
5810: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5811: LD_ADDR_VAR 0 4
5815: PUSH
5816: LD_INT 0
5818: PUSH
5819: LD_INT 0
5821: PUSH
5822: LD_INT 0
5824: PUSH
5825: LD_INT 0
5827: PUSH
5828: LD_INT 0
5830: PUSH
5831: LD_INT 0
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 1
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5858: LD_ADDR_VAR 0 3
5862: PUSH
5863: LD_INT 14
5865: PUSH
5866: LD_INT 1
5868: PUSH
5869: LD_INT 2
5871: PUSH
5872: LD_INT 26
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 14
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 29
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5922: LD_ADDR_VAR 0 1
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_OWVAR 67
5936: PUSH
5937: LD_OWVAR 1
5941: PUSH
5942: LD_INT 21000
5944: DIV
5945: PLUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 6040
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5950: LD_ADDR_VAR 0 3
5954: PUSH
5955: LD_VAR 0 3
5959: PPUSH
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 1
5967: PLUS
5968: PPUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 14
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 1
5981: PPUSH
5982: LD_INT 2
5984: PPUSH
5985: CALL_OW 12
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: LD_INT 2
5996: PUSH
5997: LD_INT 28
5999: PUSH
6000: LD_INT 29
6002: PUSH
6003: LD_INT 25
6005: PUSH
6006: LD_INT 26
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 4
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 2
6037: ST_TO_ADDR
6038: GO 5947
6040: POP
6041: POP
// MC_InsertProduceList ( base , tmp ) ;
6042: LD_VAR 0 2
6046: PPUSH
6047: LD_VAR 0 3
6051: PPUSH
6052: CALL 76262 0 2
// repeat wait ( 0 0$1 ) ;
6056: LD_INT 35
6058: PPUSH
6059: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6063: LD_EXP 78
6067: PUSH
6068: LD_VAR 0 2
6072: ARRAY
6073: PUSH
6074: LD_INT 6
6076: GREATER
6077: IFFALSE 6056
// wait ( 0 0$20 ) ;
6079: LD_INT 700
6081: PPUSH
6082: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6086: LD_ADDR_VAR 0 5
6090: PUSH
6091: LD_INT 124
6093: PUSH
6094: LD_INT 85
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 90
6103: PUSH
6104: LD_INT 61
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 69
6113: PUSH
6114: LD_INT 48
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 68
6123: PUSH
6124: LD_INT 48
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6137: LD_ADDR_VAR 0 6
6141: PUSH
6142: LD_EXP 78
6146: PUSH
6147: LD_VAR 0 2
6151: ARRAY
6152: PUSH
6153: LD_EXP 78
6157: PUSH
6158: LD_VAR 0 2
6162: ARRAY
6163: PPUSH
6164: LD_INT 2
6166: PUSH
6167: LD_INT 34
6169: PUSH
6170: LD_INT 32
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 34
6179: PUSH
6180: LD_EXP 109
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: DIFF
6199: ST_TO_ADDR
// if not attackers then
6200: LD_VAR 0 6
6204: NOT
6205: IFFALSE 6209
// exit ;
6207: GO 6268
// ar_attackers := attackers ;
6209: LD_ADDR_EXP 10
6213: PUSH
6214: LD_VAR 0 6
6218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6219: LD_INT 35
6221: PPUSH
6222: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6226: LD_VAR 0 6
6230: PPUSH
6231: LD_INT 60
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: NOT
6242: IFFALSE 6219
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6244: LD_VAR 0 2
6248: PPUSH
6249: LD_VAR 0 6
6253: PPUSH
6254: LD_VAR 0 5
6258: PPUSH
6259: LD_VAR 0 4
6263: PPUSH
6264: CALL 76447 0 4
// end ;
6268: PPOPN 6
6270: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 302
6278: PUSH
6279: LD_EXP 9
6283: AND
6284: PUSH
6285: LD_EXP 49
6289: PPUSH
6290: LD_INT 22
6292: PPUSH
6293: CALL_OW 308
6297: AND
6298: PUSH
6299: LD_INT 1
6301: PPUSH
6302: CALL 76610 0 1
6306: PUSH
6307: LD_INT 0
6309: EQUAL
6310: AND
6311: PUSH
6312: LD_EXP 10
6316: NOT
6317: AND
6318: IFFALSE 6802
6320: GO 6322
6322: DISABLE
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
6331: PPUSH
// begin base := 1 ;
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: LD_INT 1
6339: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: LD_INT 0
6362: PUSH
6363: LD_INT 0
6365: PUSH
6366: LD_INT 0
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: LD_INT 0
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: LIST
6385: LIST
6386: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_INT 13
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 28
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 13
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 27
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 11
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 24
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6489: LD_VAR 0 2
6493: PPUSH
6494: LD_VAR 0 3
6498: PPUSH
6499: CALL 76262 0 2
// repeat wait ( 0 0$1 ) ;
6503: LD_INT 35
6505: PPUSH
6506: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6510: LD_EXP 78
6514: PUSH
6515: LD_VAR 0 2
6519: ARRAY
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: IFFALSE 6503
// wait ( 0 0$20 ) ;
6526: LD_INT 700
6528: PPUSH
6529: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6533: LD_ADDR_VAR 0 5
6537: PUSH
6538: LD_INT 119
6540: PUSH
6541: LD_INT 9
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6551: LD_ADDR_VAR 0 6
6555: PUSH
6556: LD_EXP 78
6560: PUSH
6561: LD_VAR 0 2
6565: ARRAY
6566: PUSH
6567: LD_EXP 78
6571: PUSH
6572: LD_VAR 0 2
6576: ARRAY
6577: PPUSH
6578: LD_INT 2
6580: PUSH
6581: LD_INT 34
6583: PUSH
6584: LD_INT 32
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 34
6593: PUSH
6594: LD_EXP 109
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: DIFF
6613: ST_TO_ADDR
// if not attackers then
6614: LD_VAR 0 6
6618: NOT
6619: IFFALSE 6623
// exit ;
6621: GO 6802
// uc_side := 2 ;
6623: LD_ADDR_OWVAR 20
6627: PUSH
6628: LD_INT 2
6630: ST_TO_ADDR
// uc_nation := 2 ;
6631: LD_ADDR_OWVAR 21
6635: PUSH
6636: LD_INT 2
6638: ST_TO_ADDR
// InitHc ;
6639: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6643: LD_ADDR_VAR 0 1
6647: PUSH
6648: DOUBLE
6649: LD_INT 1
6651: DEC
6652: ST_TO_ADDR
6653: LD_INT 4
6655: PUSH
6656: LD_INT 5
6658: PUSH
6659: LD_INT 6
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: PUSH
6667: LD_OWVAR 67
6671: ARRAY
6672: PUSH
6673: FOR_TO
6674: IFFALSE 6751
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6676: LD_INT 0
6678: PPUSH
6679: LD_INT 15
6681: PUSH
6682: LD_INT 17
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 2
6694: PPUSH
6695: CALL_OW 12
6699: ARRAY
6700: PPUSH
6701: LD_INT 8
6703: PPUSH
6704: CALL_OW 380
// un := CreateHuman ;
6708: LD_ADDR_VAR 0 7
6712: PUSH
6713: CALL_OW 44
6717: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6718: LD_VAR 0 7
6722: PPUSH
6723: LD_INT 23
6725: PPUSH
6726: LD_INT 0
6728: PPUSH
6729: CALL_OW 49
// attackers := attackers union un ;
6733: LD_ADDR_VAR 0 6
6737: PUSH
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 7
6747: UNION
6748: ST_TO_ADDR
// end ;
6749: GO 6673
6751: POP
6752: POP
// repeat wait ( 0 0$1 ) ;
6753: LD_INT 35
6755: PPUSH
6756: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_INT 60
6767: PUSH
6768: EMPTY
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: NOT
6776: IFFALSE 6753
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6778: LD_VAR 0 2
6782: PPUSH
6783: LD_VAR 0 6
6787: PPUSH
6788: LD_VAR 0 5
6792: PPUSH
6793: LD_VAR 0 4
6797: PPUSH
6798: CALL 76447 0 4
// end ; end_of_file
6802: PPOPN 7
6804: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6805: LD_INT 0
6807: PPUSH
6808: PPUSH
6809: PPUSH
6810: PPUSH
6811: PPUSH
6812: PPUSH
// uc_side := 1 ;
6813: LD_ADDR_OWVAR 20
6817: PUSH
6818: LD_INT 1
6820: ST_TO_ADDR
// uc_nation := 1 ;
6821: LD_ADDR_OWVAR 21
6825: PUSH
6826: LD_INT 1
6828: ST_TO_ADDR
// InitHc ;
6829: CALL_OW 19
// InitVc ;
6833: CALL_OW 20
// tmp := [ ] ;
6837: LD_ADDR_VAR 0 3
6841: PUSH
6842: EMPTY
6843: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 ] [ Difficulty ] do
6844: LD_ADDR_VAR 0 2
6848: PUSH
6849: DOUBLE
6850: LD_INT 1
6852: DEC
6853: ST_TO_ADDR
6854: LD_INT 6
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: LD_INT 10
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_OWVAR 67
6872: ARRAY
6873: PUSH
6874: FOR_TO
6875: IFFALSE 7149
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6877: LD_ADDR_VAR 0 5
6881: PUSH
6882: LD_INT 2
6884: PUSH
6885: LD_INT 4
6887: PUSH
6888: LD_INT 5
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 1
6898: PPUSH
6899: LD_INT 3
6901: PPUSH
6902: CALL_OW 12
6906: ARRAY
6907: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6908: LD_VAR 0 5
6912: PUSH
6913: LD_INT 2
6915: DOUBLE
6916: EQUAL
6917: IFTRUE 6921
6919: GO 6955
6921: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6922: LD_ADDR_VAR 0 6
6926: PUSH
6927: LD_INT 9
6929: PUSH
6930: LD_INT 5
6932: PUSH
6933: LD_INT 7
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 3
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: ST_TO_ADDR
6953: GO 7044
6955: LD_INT 4
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 7001
6963: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: LD_INT 9
6971: PUSH
6972: LD_INT 6
6974: PUSH
6975: LD_INT 6
6977: PUSH
6978: LD_INT 7
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: LD_INT 1
6989: PPUSH
6990: LD_INT 4
6992: PPUSH
6993: CALL_OW 12
6997: ARRAY
6998: ST_TO_ADDR
6999: GO 7044
7001: LD_INT 5
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7043
7009: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7010: LD_ADDR_VAR 0 6
7014: PUSH
7015: LD_INT 9
7017: PUSH
7018: LD_INT 6
7020: PUSH
7021: LD_INT 7
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 1
7031: PPUSH
7032: LD_INT 3
7034: PPUSH
7035: CALL_OW 12
7039: ARRAY
7040: ST_TO_ADDR
7041: GO 7044
7043: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7044: LD_VAR 0 5
7048: PPUSH
7049: LD_INT 1
7051: PUSH
7052: LD_INT 3
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 1
7061: PPUSH
7062: LD_INT 2
7064: PPUSH
7065: CALL_OW 12
7069: ARRAY
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_VAR 0 6
7078: PPUSH
7079: LD_INT 70
7081: PPUSH
7082: LD_INT 90
7084: PPUSH
7085: CALL_OW 12
7089: PPUSH
7090: CALL 19564 0 5
// veh := CreateVehicle ;
7094: LD_ADDR_VAR 0 4
7098: PUSH
7099: CALL_OW 45
7103: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7104: LD_VAR 0 4
7108: PPUSH
7109: LD_INT 2
7111: PPUSH
7112: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7116: LD_VAR 0 4
7120: PPUSH
7121: LD_INT 17
7123: PPUSH
7124: LD_INT 0
7126: PPUSH
7127: CALL_OW 49
// tmp := tmp ^ veh ;
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: LD_VAR 0 3
7140: PUSH
7141: LD_VAR 0 4
7145: ADD
7146: ST_TO_ADDR
// end ;
7147: GO 6874
7149: POP
7150: POP
// if not tmp then
7151: LD_VAR 0 3
7155: NOT
7156: IFFALSE 7160
// exit ;
7158: GO 7269
// if not first_powell_attack then
7160: LD_EXP 11
7164: NOT
7165: IFFALSE 7175
// first_powell_attack := true ;
7167: LD_ADDR_EXP 11
7171: PUSH
7172: LD_INT 1
7174: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7175: LD_INT 70
7177: PPUSH
7178: CALL_OW 67
// for i in tmp do
7182: LD_ADDR_VAR 0 2
7186: PUSH
7187: LD_VAR 0 3
7191: PUSH
7192: FOR_IN
7193: IFFALSE 7260
// if IsOk ( i ) then
7195: LD_VAR 0 2
7199: PPUSH
7200: CALL_OW 302
7204: IFFALSE 7242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7206: LD_VAR 0 2
7210: PPUSH
7211: LD_INT 81
7213: PUSH
7214: LD_INT 1
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: LD_VAR 0 2
7230: PPUSH
7231: CALL_OW 74
7235: PPUSH
7236: CALL_OW 115
7240: GO 7258
// tmp := tmp diff i ;
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: LD_VAR 0 3
7251: PUSH
7252: LD_VAR 0 2
7256: DIFF
7257: ST_TO_ADDR
7258: GO 7192
7260: POP
7261: POP
// until not tmp ;
7262: LD_VAR 0 3
7266: NOT
7267: IFFALSE 7175
// end ; end_of_file
7269: LD_VAR 0 1
7273: RET
// export function Action ; var tmp , i , un ; begin
7274: LD_INT 0
7276: PPUSH
7277: PPUSH
7278: PPUSH
7279: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7280: LD_INT 68
7282: PPUSH
7283: LD_INT 39
7285: PPUSH
7286: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: ST_TO_ADDR
// InGameOn ;
7310: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7314: LD_VAR 0 2
7318: PPUSH
7319: LD_INT 71
7321: PPUSH
7322: LD_INT 49
7324: PPUSH
7325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7329: LD_INT 35
7331: PPUSH
7332: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7336: LD_INT 7
7338: PPUSH
7339: LD_INT 71
7341: PPUSH
7342: LD_INT 51
7344: PPUSH
7345: CALL_OW 293
7349: IFFALSE 7329
// DialogueOn ;
7351: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7355: LD_EXP 15
7359: PPUSH
7360: LD_STRING D1-JMM-1
7362: PPUSH
7363: CALL_OW 88
// if Joan then
7367: LD_EXP 30
7371: IFFALSE 7385
// Say ( Joan , D1-Joan-1 ) ;
7373: LD_EXP 30
7377: PPUSH
7378: LD_STRING D1-Joan-1
7380: PPUSH
7381: CALL_OW 88
// if Lisa then
7385: LD_EXP 17
7389: IFFALSE 7403
// Say ( Lisa , D1-Lisa-1 ) ;
7391: LD_EXP 17
7395: PPUSH
7396: LD_STRING D1-Lisa-1
7398: PPUSH
7399: CALL_OW 88
// if Joan or Lisa then
7403: LD_EXP 30
7407: PUSH
7408: LD_EXP 17
7412: OR
7413: IFFALSE 7427
// Say ( JMM , D1-JMM-2 ) ;
7415: LD_EXP 15
7419: PPUSH
7420: LD_STRING D1-JMM-2
7422: PPUSH
7423: CALL_OW 88
// DialogueOff ;
7427: CALL_OW 7
// InGameOff ;
7431: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7435: LD_INT 71
7437: PPUSH
7438: LD_INT 50
7440: PPUSH
7441: LD_INT 7
7443: PPUSH
7444: LD_INT 30
7446: NEG
7447: PPUSH
7448: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7452: LD_INT 71
7454: PPUSH
7455: LD_INT 50
7457: PPUSH
7458: LD_INT 7
7460: PPUSH
7461: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7465: LD_STRING M1
7467: PPUSH
7468: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7472: LD_INT 35
7474: PPUSH
7475: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7479: LD_EXP 3
7483: PUSH
7484: LD_OWVAR 1
7488: PUSH
7489: LD_INT 2100
7491: GREATER
7492: OR
7493: IFFALSE 7472
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7495: LD_INT 350
7497: PPUSH
7498: LD_INT 700
7500: PPUSH
7501: CALL_OW 12
7505: PPUSH
7506: CALL_OW 67
// PrepareGossudarov ;
7510: CALL 1865 0 0
// repeat wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7521: LD_INT 22
7523: PUSH
7524: LD_INT 6
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PUSH
7531: LD_INT 3
7533: PUSH
7534: LD_INT 24
7536: PUSH
7537: LD_INT 1000
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: PUSH
7557: LD_INT 7
7559: PPUSH
7560: LD_EXP 32
7564: PPUSH
7565: CALL_OW 292
7569: OR
7570: IFFALSE 7514
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_INT 22
7579: PUSH
7580: LD_INT 6
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 69
7591: ST_TO_ADDR
// for i in tmp do
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_VAR 0 2
7601: PUSH
7602: FOR_IN
7603: IFFALSE 7619
// SetSide ( i , 7 ) ;
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 7
7612: PPUSH
7613: CALL_OW 235
7617: GO 7602
7619: POP
7620: POP
// DialogueOn ;
7621: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7625: LD_EXP 15
7629: PUSH
7630: LD_EXP 16
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: LD_EXP 32
7643: PPUSH
7644: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7648: LD_EXP 32
7652: PPUSH
7653: CALL_OW 87
// if not Roth then
7657: LD_EXP 16
7661: NOT
7662: IFFALSE 7754
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7664: LD_VAR 0 2
7668: PPUSH
7669: LD_INT 3
7671: PUSH
7672: LD_INT 24
7674: PUSH
7675: LD_INT 1000
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PPUSH
7686: CALL_OW 72
7690: IFFALSE 7704
// Say ( JMM , D2-JMM-1 ) ;
7692: LD_EXP 15
7696: PPUSH
7697: LD_STRING D2-JMM-1
7699: PPUSH
7700: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7704: LD_EXP 15
7708: PPUSH
7709: LD_STRING D2-JMM-1b
7711: PPUSH
7712: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7716: LD_EXP 32
7720: PPUSH
7721: LD_STRING D2-Gos-1
7723: PPUSH
7724: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7728: LD_EXP 15
7732: PPUSH
7733: LD_STRING D2-JMM-2
7735: PPUSH
7736: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7740: LD_EXP 32
7744: PPUSH
7745: LD_STRING D2-Gos-2
7747: PPUSH
7748: CALL_OW 88
// end else
7752: GO 7906
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7754: LD_VAR 0 2
7758: PPUSH
7759: LD_INT 3
7761: PUSH
7762: LD_INT 24
7764: PUSH
7765: LD_INT 1000
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PPUSH
7776: CALL_OW 72
7780: IFFALSE 7806
// begin Say ( Roth , D2-Roth-2 ) ;
7782: LD_EXP 16
7786: PPUSH
7787: LD_STRING D2-Roth-2
7789: PPUSH
7790: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7794: LD_EXP 15
7798: PPUSH
7799: LD_STRING D2-JMM-1a
7801: PPUSH
7802: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-Roth-2a
7813: PPUSH
7814: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7818: LD_EXP 16
7822: PPUSH
7823: LD_STRING D2-Roth-2b
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7830: LD_EXP 15
7834: PPUSH
7835: LD_STRING D2-JMM-3
7837: PPUSH
7838: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7842: LD_VAR 0 2
7846: PPUSH
7847: LD_INT 3
7849: PUSH
7850: LD_INT 24
7852: PUSH
7853: LD_INT 1000
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PPUSH
7864: CALL_OW 72
7868: IFFALSE 7906
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7870: LD_EXP 32
7874: PPUSH
7875: LD_STRING D2-Gos-3
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7882: LD_EXP 15
7886: PPUSH
7887: LD_STRING D2-JMM-4
7889: PPUSH
7890: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7894: LD_EXP 32
7898: PPUSH
7899: LD_STRING D2-Gos-4
7901: PPUSH
7902: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7906: LD_EXP 15
7910: PPUSH
7911: LD_STRING D2-JMM-5
7913: PPUSH
7914: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7918: LD_EXP 32
7922: PPUSH
7923: LD_STRING D2-Gos-5
7925: PPUSH
7926: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7930: LD_EXP 15
7934: PPUSH
7935: LD_STRING D2-JMM-6
7937: PPUSH
7938: CALL_OW 88
// DialogueOff ;
7942: CALL_OW 7
// wait ( 0 0$2 ) ;
7946: LD_INT 70
7948: PPUSH
7949: CALL_OW 67
// if Kirilenkova then
7953: LD_EXP 33
7957: IFFALSE 7971
// Say ( Kirilenkova , D3-Kir-1 ) ;
7959: LD_EXP 33
7963: PPUSH
7964: LD_STRING D3-Kir-1
7966: PPUSH
7967: CALL_OW 88
// gossudarov_arrive := true ;
7971: LD_ADDR_EXP 4
7975: PUSH
7976: LD_INT 1
7978: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7979: LD_INT 35
7981: PPUSH
7982: CALL_OW 67
// until ru_lab_builded ;
7986: LD_EXP 5
7990: IFFALSE 7979
// DialogueOn ;
7992: CALL_OW 6
// if Kirilenkova then
7996: LD_EXP 33
8000: IFFALSE 8016
// Say ( Kirilenkova , D3a-Kir-1 ) else
8002: LD_EXP 33
8006: PPUSH
8007: LD_STRING D3a-Kir-1
8009: PPUSH
8010: CALL_OW 88
8014: GO 8038
// begin un := SciRu ;
8016: LD_ADDR_VAR 0 4
8020: PUSH
8021: CALL 13167 0 0
8025: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8026: LD_VAR 0 4
8030: PPUSH
8031: LD_STRING D3a-Sci1-1
8033: PPUSH
8034: CALL_OW 88
// end ; if Kirilenkova or un then
8038: LD_EXP 33
8042: PUSH
8043: LD_VAR 0 4
8047: OR
8048: IFFALSE 8062
// Say ( JMM , D3a-JMM-1 ) ;
8050: LD_EXP 15
8054: PPUSH
8055: LD_STRING D3a-JMM-1
8057: PPUSH
8058: CALL_OW 88
// DialogueOff ;
8062: CALL_OW 7
// end ;
8066: LD_VAR 0 1
8070: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8071: LD_EXP 4
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 7
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 2
8088: PUSH
8089: LD_INT 25
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 25
8101: PUSH
8102: LD_INT 2
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 25
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: LD_INT 25
8121: PUSH
8122: LD_INT 4
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: LD_INT 25
8131: PUSH
8132: LD_INT 5
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_INT 25
8141: PUSH
8142: LD_INT 8
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 25
8151: PUSH
8152: LD_INT 9
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 7
8180: LESS
8181: AND
8182: IFFALSE 8194
8184: GO 8186
8186: DISABLE
// YouLost ( TooMany ) ;
8187: LD_STRING TooMany
8189: PPUSH
8190: CALL_OW 104
8194: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8195: LD_EXP 32
8199: PPUSH
8200: CALL_OW 255
8204: PUSH
8205: LD_INT 7
8207: EQUAL
8208: IFFALSE 8425
8210: GO 8212
8212: DISABLE
8213: LD_INT 0
8215: PPUSH
8216: PPUSH
8217: PPUSH
// begin uc_side := 3 ;
8218: LD_ADDR_OWVAR 20
8222: PUSH
8223: LD_INT 3
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8234: LD_INT 21
8236: PPUSH
8237: LD_INT 3
8239: PPUSH
8240: LD_INT 3
8242: PPUSH
8243: LD_INT 42
8245: PPUSH
8246: LD_INT 100
8248: PPUSH
8249: CALL 19564 0 5
// un := CreateVehicle ;
8253: LD_ADDR_VAR 0 3
8257: PUSH
8258: CALL_OW 45
8262: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8263: LD_VAR 0 3
8267: PPUSH
8268: LD_INT 15
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8278: LD_VAR 0 3
8282: PPUSH
8283: LD_INT 67
8285: PPUSH
8286: LD_INT 45
8288: PPUSH
8289: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8293: LD_VAR 0 3
8297: PPUSH
8298: LD_INT 70
8300: PPUSH
8301: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 69
8312: PPUSH
8313: LD_INT 18
8315: PPUSH
8316: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_INT 60
8327: PPUSH
8328: LD_INT 3
8330: PPUSH
8331: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8335: LD_INT 35
8337: PPUSH
8338: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8342: LD_VAR 0 3
8346: PPUSH
8347: CALL_OW 302
8351: NOT
8352: PUSH
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 17
8360: PPUSH
8361: CALL_OW 308
8365: OR
8366: PUSH
8367: LD_VAR 0 3
8371: PPUSH
8372: LD_INT 60
8374: PPUSH
8375: LD_INT 3
8377: PPUSH
8378: CALL_OW 307
8382: OR
8383: IFFALSE 8335
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_INT 17
8392: PPUSH
8393: CALL_OW 308
8397: PUSH
8398: LD_VAR 0 3
8402: PPUSH
8403: LD_INT 60
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: CALL_OW 307
8413: OR
8414: IFFALSE 8425
// RemoveUnit ( un ) ;
8416: LD_VAR 0 3
8420: PPUSH
8421: CALL_OW 64
// end ;
8425: PPOPN 3
8427: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8428: LD_EXP 4
8432: IFFALSE 8674
8434: GO 8436
8436: DISABLE
8437: LD_INT 0
8439: PPUSH
8440: PPUSH
8441: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8442: LD_INT 70
8444: PPUSH
8445: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8449: LD_ADDR_VAR 0 3
8453: PUSH
8454: LD_INT 22
8456: PUSH
8457: LD_INT 7
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: PUSH
8464: LD_INT 101
8466: PUSH
8467: LD_INT 3
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PPUSH
8478: CALL_OW 69
8482: ST_TO_ADDR
// until tmp ;
8483: LD_VAR 0 3
8487: IFFALSE 8442
// un := NearestUnitToUnit ( tmp , JMM ) ;
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_VAR 0 3
8498: PPUSH
8499: LD_EXP 15
8503: PPUSH
8504: CALL_OW 74
8508: ST_TO_ADDR
// player_spotted := true ;
8509: LD_ADDR_EXP 6
8513: PUSH
8514: LD_INT 1
8516: ST_TO_ADDR
// tmp := SciRu ;
8517: LD_ADDR_VAR 0 3
8521: PUSH
8522: CALL 13167 0 0
8526: ST_TO_ADDR
// if not tmp then
8527: LD_VAR 0 3
8531: NOT
8532: IFFALSE 8544
// tmp := SolRu ;
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: CALL 13314 0 0
8543: ST_TO_ADDR
// DialogueOn ;
8544: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8548: LD_VAR 0 2
8552: PPUSH
8553: CALL_OW 250
8557: PPUSH
8558: LD_VAR 0 2
8562: PPUSH
8563: CALL_OW 251
8567: PPUSH
8568: LD_INT 7
8570: PPUSH
8571: LD_INT 8
8573: NEG
8574: PPUSH
8575: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8579: LD_VAR 0 2
8583: PPUSH
8584: CALL_OW 87
// if tmp then
8588: LD_VAR 0 3
8592: IFFALSE 8606
// Say ( tmp , D4-RSci1-1 ) ;
8594: LD_VAR 0 3
8598: PPUSH
8599: LD_STRING D4-RSci1-1
8601: PPUSH
8602: CALL_OW 88
// if Gossudarov then
8606: LD_EXP 32
8610: IFFALSE 8636
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8612: LD_EXP 32
8616: PPUSH
8617: LD_STRING D4-Gos-1
8619: PPUSH
8620: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8624: LD_EXP 15
8628: PPUSH
8629: LD_STRING D4-JMM-1
8631: PPUSH
8632: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8636: LD_VAR 0 2
8640: PPUSH
8641: CALL_OW 250
8645: PPUSH
8646: LD_VAR 0 2
8650: PPUSH
8651: CALL_OW 251
8655: PPUSH
8656: LD_INT 7
8658: PPUSH
8659: CALL_OW 331
// DialogueOff ;
8663: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8667: LD_STRING M5
8669: PPUSH
8670: CALL_OW 337
// end ;
8674: PPOPN 3
8676: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8677: LD_EXP 6
8681: IFFALSE 9270
8683: GO 8685
8685: DISABLE
8686: LD_INT 0
8688: PPUSH
8689: PPUSH
8690: PPUSH
// begin PrepareBelkov ;
8691: CALL 2178 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8695: LD_EXP 47
8699: PPUSH
8700: LD_INT 118
8702: PPUSH
8703: LD_INT 106
8705: PPUSH
8706: CALL_OW 111
// AddComHold ( Belkov ) ;
8710: LD_EXP 47
8714: PPUSH
8715: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8719: LD_INT 35
8721: PPUSH
8722: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8726: LD_EXP 47
8730: PPUSH
8731: LD_INT 118
8733: PPUSH
8734: LD_INT 106
8736: PPUSH
8737: CALL_OW 307
8741: IFFALSE 8719
// ChangeSideFog ( 4 , 7 ) ;
8743: LD_INT 4
8745: PPUSH
8746: LD_INT 7
8748: PPUSH
8749: CALL_OW 343
// if IsOk ( Belkov ) then
8753: LD_EXP 47
8757: PPUSH
8758: CALL_OW 302
8762: IFFALSE 8846
// begin InGameOn ;
8764: CALL_OW 8
// DialogueOn ;
8768: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8772: LD_EXP 47
8776: PPUSH
8777: LD_STRING D5-Bel-1
8779: PPUSH
8780: CALL_OW 94
// if Gossudarov then
8784: LD_EXP 32
8788: IFFALSE 8838
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8790: LD_EXP 32
8794: PPUSH
8795: LD_STRING D5-Gos-1
8797: PPUSH
8798: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8802: LD_EXP 15
8806: PPUSH
8807: LD_STRING D5-JMM-1
8809: PPUSH
8810: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8814: LD_EXP 32
8818: PPUSH
8819: LD_STRING D5-Gos-2
8821: PPUSH
8822: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8826: LD_EXP 15
8830: PPUSH
8831: LD_STRING D5-JMM-2
8833: PPUSH
8834: CALL_OW 88
// end ; DialogueOff ;
8838: CALL_OW 7
// InGameOff ;
8842: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8846: LD_STRING QSaveBelkov
8848: PPUSH
8849: CALL_OW 97
8853: PUSH
8854: LD_INT 1
8856: DOUBLE
8857: EQUAL
8858: IFTRUE 8862
8860: GO 8912
8862: POP
// begin DialogueOn ;
8863: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8867: LD_EXP 15
8871: PPUSH
8872: LD_STRING D5a-JMM-1
8874: PPUSH
8875: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8879: LD_EXP 47
8883: PPUSH
8884: LD_STRING D5a-Bel-1
8886: PPUSH
8887: CALL_OW 94
// DialogueOff ;
8891: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8895: LD_EXP 47
8899: PPUSH
8900: LD_INT 83
8902: PPUSH
8903: LD_INT 49
8905: PPUSH
8906: CALL_OW 111
// end ; 2 :
8910: GO 8945
8912: LD_INT 2
8914: DOUBLE
8915: EQUAL
8916: IFTRUE 8920
8918: GO 8944
8920: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8921: LD_EXP 15
8925: PPUSH
8926: LD_STRING D5a-JMM-2
8928: PPUSH
8929: CALL_OW 88
// ComHold ( Belkov ) ;
8933: LD_EXP 47
8937: PPUSH
8938: CALL_OW 140
// end ; end ;
8942: GO 8945
8944: POP
// time := 0 0$00 ;
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: LD_INT 0
8952: ST_TO_ADDR
// vehSpawned := false ;
8953: LD_ADDR_VAR 0 3
8957: PUSH
8958: LD_INT 0
8960: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8961: LD_INT 35
8963: PPUSH
8964: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8968: LD_VAR 0 1
8972: PUSH
8973: LD_INT 350
8975: PUSH
8976: LD_INT 175
8978: PUSH
8979: LD_INT 70
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: LIST
8986: PUSH
8987: LD_OWVAR 67
8991: ARRAY
8992: GREATEREQUAL
8993: PUSH
8994: LD_VAR 0 3
8998: NOT
8999: AND
9000: IFFALSE 9090
// begin vehSpawned := true ;
9002: LD_ADDR_VAR 0 3
9006: PUSH
9007: LD_INT 1
9009: ST_TO_ADDR
// uc_side := 3 ;
9010: LD_ADDR_OWVAR 20
9014: PUSH
9015: LD_INT 3
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9026: LD_INT 22
9028: PPUSH
9029: LD_INT 3
9031: PPUSH
9032: LD_INT 3
9034: PPUSH
9035: LD_INT 43
9037: PPUSH
9038: LD_INT 100
9040: PPUSH
9041: CALL 19564 0 5
// veh := CreateVehicle ;
9045: LD_ADDR_VAR 0 2
9049: PUSH
9050: CALL_OW 45
9054: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: LD_INT 130
9062: PPUSH
9063: LD_INT 131
9065: PPUSH
9066: LD_INT 0
9068: PPUSH
9069: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9073: LD_VAR 0 2
9077: PPUSH
9078: LD_INT 100
9080: PPUSH
9081: LD_INT 82
9083: PPUSH
9084: CALL_OW 114
// end else
9088: GO 9104
// time := time + 0 0$1 ;
9090: LD_ADDR_VAR 0 1
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: LD_INT 35
9102: PLUS
9103: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9104: LD_EXP 47
9108: PPUSH
9109: CALL_OW 301
9113: PUSH
9114: LD_EXP 47
9118: PPUSH
9119: CALL_OW 255
9123: PUSH
9124: LD_INT 4
9126: EQUAL
9127: AND
9128: PUSH
9129: LD_INT 22
9131: PUSH
9132: LD_INT 7
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: PPUSH
9144: LD_EXP 47
9148: PPUSH
9149: CALL_OW 74
9153: PPUSH
9154: LD_EXP 47
9158: PPUSH
9159: CALL_OW 296
9163: PUSH
9164: LD_INT 10
9166: LESS
9167: OR
9168: IFFALSE 8961
// if IsDead ( Belkov ) then
9170: LD_EXP 47
9174: PPUSH
9175: CALL_OW 301
9179: IFFALSE 9204
// begin CenterNowOnUnits ( Belkov ) ;
9181: LD_EXP 47
9185: PPUSH
9186: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9190: LD_EXP 15
9194: PPUSH
9195: LD_STRING D5a-JMM-2a
9197: PPUSH
9198: CALL_OW 88
// exit ;
9202: GO 9270
// end ; if See ( 7 , Belkov ) then
9204: LD_INT 7
9206: PPUSH
9207: LD_EXP 47
9211: PPUSH
9212: CALL_OW 292
9216: IFFALSE 9230
// SetSide ( Belkov , 7 ) ;
9218: LD_EXP 47
9222: PPUSH
9223: LD_INT 7
9225: PPUSH
9226: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9230: LD_INT 35
9232: PPUSH
9233: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9237: LD_EXP 47
9241: PPUSH
9242: LD_INT 66
9244: PPUSH
9245: LD_INT 45
9247: PPUSH
9248: CALL_OW 297
9252: PUSH
9253: LD_INT 30
9255: LESS
9256: IFFALSE 9230
// Say ( Belkov , D6-Bel-1 ) ;
9258: LD_EXP 47
9262: PPUSH
9263: LD_STRING D6-Bel-1
9265: PPUSH
9266: CALL_OW 88
// end ;
9270: PPOPN 3
9272: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9273: LD_EXP 47
9277: PPUSH
9278: CALL_OW 302
9282: PUSH
9283: LD_EXP 47
9287: PPUSH
9288: CALL_OW 504
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: LD_INT 34
9298: PUSH
9299: LD_INT 47
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: LD_INT 34
9308: PUSH
9309: LD_INT 45
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: LIST
9320: PPUSH
9321: CALL_OW 69
9325: IN
9326: AND
9327: IFFALSE 9344
9329: GO 9331
9331: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9332: LD_EXP 47
9336: PPUSH
9337: LD_STRING D7-Bel-1
9339: PPUSH
9340: CALL_OW 88
9344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9345: LD_INT 22
9347: PUSH
9348: LD_INT 7
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: LD_INT 101
9357: PUSH
9358: LD_INT 2
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PPUSH
9369: CALL_OW 69
9373: PUSH
9374: LD_EXP 8
9378: NOT
9379: AND
9380: PUSH
9381: LD_EXP 46
9385: PPUSH
9386: CALL_OW 305
9390: NOT
9391: AND
9392: IFFALSE 9862
9394: GO 9396
9396: DISABLE
9397: LD_INT 0
9399: PPUSH
// begin ar_base_spotted := true ;
9400: LD_ADDR_EXP 8
9404: PUSH
9405: LD_INT 1
9407: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9408: LD_ADDR_VAR 0 1
9412: PUSH
9413: LD_INT 22
9415: PUSH
9416: LD_INT 2
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 21
9425: PUSH
9426: LD_INT 3
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PPUSH
9437: CALL_OW 69
9441: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_VAR 0 1
9451: PPUSH
9452: LD_EXP 15
9456: PPUSH
9457: CALL_OW 74
9461: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9462: LD_INT 7
9464: PPUSH
9465: LD_INT 3
9467: PPUSH
9468: CALL_OW 332
// DialogueOn ;
9472: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 250
9485: PPUSH
9486: LD_VAR 0 1
9490: PPUSH
9491: CALL_OW 251
9495: PPUSH
9496: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9500: LD_ADDR_VAR 0 1
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_INT 7
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 23
9517: PUSH
9518: LD_INT 1
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 26
9527: PUSH
9528: LD_INT 1
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: PUSH
9545: LD_EXP 15
9549: PUSH
9550: LD_EXP 19
9554: PUSH
9555: LD_EXP 20
9559: PUSH
9560: LD_EXP 27
9564: PUSH
9565: LD_EXP 16
9569: PUSH
9570: LD_EXP 25
9574: PUSH
9575: LD_EXP 21
9579: PUSH
9580: LD_EXP 23
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: DIFF
9595: ST_TO_ADDR
// if not tmp then
9596: LD_VAR 0 1
9600: NOT
9601: IFFALSE 9675
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9603: LD_ADDR_VAR 0 1
9607: PUSH
9608: LD_INT 22
9610: PUSH
9611: LD_INT 7
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PUSH
9618: LD_INT 23
9620: PUSH
9621: LD_INT 1
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: PUSH
9628: LD_INT 26
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: LIST
9642: PPUSH
9643: CALL_OW 69
9647: PUSH
9648: LD_EXP 30
9652: PUSH
9653: LD_EXP 17
9657: PUSH
9658: LD_EXP 28
9662: PUSH
9663: LD_EXP 29
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: DIFF
9674: ST_TO_ADDR
// if tmp then
9675: LD_VAR 0 1
9679: IFFALSE 9750
// case GetSex ( tmp [ 1 ] ) of sex_male :
9681: LD_VAR 0 1
9685: PUSH
9686: LD_INT 1
9688: ARRAY
9689: PPUSH
9690: CALL_OW 258
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9722
9703: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9704: LD_VAR 0 1
9708: PUSH
9709: LD_INT 1
9711: ARRAY
9712: PPUSH
9713: LD_STRING D9-Sol1-1
9715: PPUSH
9716: CALL_OW 88
9720: GO 9750
9722: LD_INT 2
9724: DOUBLE
9725: EQUAL
9726: IFTRUE 9730
9728: GO 9749
9730: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9731: LD_VAR 0 1
9735: PUSH
9736: LD_INT 1
9738: ARRAY
9739: PPUSH
9740: LD_STRING D9-FSol1-1
9742: PPUSH
9743: CALL_OW 88
9747: GO 9750
9749: POP
// if Frank then
9750: LD_EXP 27
9754: IFFALSE 9858
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9756: LD_EXP 56
9760: PPUSH
9761: CALL_OW 250
9765: PPUSH
9766: LD_EXP 56
9770: PPUSH
9771: CALL_OW 251
9775: PPUSH
9776: LD_INT 7
9778: PPUSH
9779: LD_INT 8
9781: PPUSH
9782: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9786: LD_EXP 56
9790: PPUSH
9791: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9795: LD_EXP 27
9799: PPUSH
9800: LD_STRING D9-Frank-1
9802: PPUSH
9803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9807: LD_EXP 15
9811: PPUSH
9812: LD_STRING D9-JMM-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9819: LD_EXP 27
9823: PPUSH
9824: LD_STRING D9-Frank-2
9826: PPUSH
9827: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9831: LD_EXP 56
9835: PPUSH
9836: CALL_OW 250
9840: PPUSH
9841: LD_EXP 56
9845: PPUSH
9846: CALL_OW 251
9850: PPUSH
9851: LD_INT 7
9853: PPUSH
9854: CALL_OW 331
// end ; DialogueOff ;
9858: CALL_OW 7
// end ;
9862: PPOPN 1
9864: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9865: LD_EXP 7
9869: PUSH
9870: LD_OWVAR 1
9874: PUSH
9875: LD_INT 42000
9877: GREATEREQUAL
9878: OR
9879: IFFALSE 10906
9881: GO 9883
9883: DISABLE
9884: LD_INT 0
9886: PPUSH
9887: PPUSH
// begin selected_option := 1 ;
9888: LD_ADDR_VAR 0 2
9892: PUSH
9893: LD_INT 1
9895: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9896: LD_INT 10500
9898: PPUSH
9899: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9903: LD_INT 35
9905: PPUSH
9906: CALL_OW 67
// until not ru_attackers ;
9910: LD_EXP 52
9914: NOT
9915: IFFALSE 9903
// PrepareBurlak ;
9917: CALL 2290 0 0
// repeat wait ( 0 0$2 ) ;
9921: LD_INT 70
9923: PPUSH
9924: CALL_OW 67
// until not HasTask ( Burlak ) ;
9928: LD_EXP 46
9932: PPUSH
9933: CALL_OW 314
9937: NOT
9938: IFFALSE 9921
// InGameOn ;
9940: CALL_OW 8
// DialogueOn ;
9944: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9948: LD_EXP 49
9952: PPUSH
9953: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9957: LD_EXP 46
9961: PPUSH
9962: LD_STRING D10-Bur-1
9964: PPUSH
9965: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9969: LD_EXP 47
9973: PUSH
9974: LD_EXP 47
9978: PPUSH
9979: CALL_OW 255
9983: PUSH
9984: LD_INT 7
9986: EQUAL
9987: AND
9988: IFFALSE 10002
// Say ( Belkov , D10-Bel-1 ) ;
9990: LD_EXP 47
9994: PPUSH
9995: LD_STRING D10-Bel-1
9997: PPUSH
9998: CALL_OW 88
// if Gossudarov then
10002: LD_EXP 32
10006: IFFALSE 10020
// Say ( Gossudarov , D10-Gos-1 ) ;
10008: LD_EXP 32
10012: PPUSH
10013: LD_STRING D10-Gos-1
10015: PPUSH
10016: CALL_OW 88
// if Kirilenkova then
10020: LD_EXP 33
10024: IFFALSE 10038
// Say ( Kirilenkova , D10-Kir-1 ) ;
10026: LD_EXP 33
10030: PPUSH
10031: LD_STRING D10-Kir-1
10033: PPUSH
10034: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10038: CALL 13314 0 0
10042: PPUSH
10043: LD_STRING D10-RSol1-1
10045: PPUSH
10046: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10050: LD_EXP 46
10054: PPUSH
10055: LD_STRING D10-Bur-2
10057: PPUSH
10058: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10062: LD_EXP 15
10066: PPUSH
10067: LD_STRING D10-JMM-2
10069: PPUSH
10070: CALL_OW 88
// if Kirilenkova then
10074: LD_EXP 33
10078: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-2 ) else
10080: LD_EXP 33
10084: PPUSH
10085: LD_STRING D10-Kir-2
10087: PPUSH
10088: CALL_OW 88
10092: GO 10106
// Say ( SolRu , D10-RSol1-2 ) ;
10094: CALL 13314 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-2
10101: PPUSH
10102: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10106: LD_EXP 15
10110: PPUSH
10111: LD_STRING D10-JMM-3
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10118: LD_EXP 46
10122: PPUSH
10123: LD_STRING D10-Bur-3
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10130: LD_EXP 15
10134: PPUSH
10135: LD_STRING D10-JMM-4
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// InGameOff ;
10146: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10150: LD_STRING M2
10152: PPUSH
10153: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10157: LD_INT 35
10159: PPUSH
10160: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10164: LD_INT 22
10166: PUSH
10167: LD_INT 7
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 91
10176: PUSH
10177: LD_EXP 46
10181: PUSH
10182: LD_INT 8
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10157
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10200: LD_ADDR_VAR 0 1
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 4
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PPUSH
10215: CALL_OW 69
10219: PUSH
10220: FOR_IN
10221: IFFALSE 10237
// SetSide ( i , 7 ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 7
10230: PPUSH
10231: CALL_OW 235
10235: GO 10220
10237: POP
10238: POP
// ChangeMissionObjectives ( M3 ) ;
10239: LD_STRING M3
10241: PPUSH
10242: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10253: LD_EXP 15
10257: PPUSH
10258: LD_EXP 46
10262: PPUSH
10263: CALL_OW 296
10267: PUSH
10268: LD_INT 8
10270: LESS
10271: IFFALSE 10246
// ComTurnUnit ( JMM , Burlak ) ;
10273: LD_EXP 15
10277: PPUSH
10278: LD_EXP 46
10282: PPUSH
10283: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10287: LD_EXP 46
10291: PPUSH
10292: LD_EXP 15
10296: PPUSH
10297: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10301: LD_INT 10
10303: PPUSH
10304: CALL_OW 67
// DialogueOn ;
10308: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10312: LD_EXP 15
10316: PPUSH
10317: LD_STRING D11-JMM-1
10319: PPUSH
10320: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10324: LD_EXP 46
10328: PPUSH
10329: LD_STRING D11-Bur-1
10331: PPUSH
10332: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10336: LD_EXP 15
10340: PPUSH
10341: LD_STRING D11-JMM-2
10343: PPUSH
10344: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10348: LD_EXP 46
10352: PPUSH
10353: LD_STRING D11-Bur-2
10355: PPUSH
10356: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10360: LD_EXP 15
10364: PPUSH
10365: LD_STRING D11-JMM-3
10367: PPUSH
10368: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10372: LD_EXP 46
10376: PPUSH
10377: LD_STRING D11-Bur-3
10379: PPUSH
10380: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10384: LD_EXP 15
10388: PPUSH
10389: LD_STRING D11-JMM-4
10391: PPUSH
10392: CALL_OW 88
// if ar_base_spotted then
10396: LD_EXP 8
10400: IFFALSE 10416
// Say ( Burlak , D12-Bur-1 ) else
10402: LD_EXP 46
10406: PPUSH
10407: LD_STRING D12-Bur-1
10409: PPUSH
10410: CALL_OW 88
10414: GO 10455
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10416: LD_INT 7
10418: PPUSH
10419: LD_INT 3
10421: PPUSH
10422: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10426: LD_INT 127
10428: PPUSH
10429: LD_INT 45
10431: PPUSH
10432: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10436: LD_EXP 46
10440: PPUSH
10441: LD_STRING D12-Bur-1a
10443: PPUSH
10444: CALL_OW 88
// dwait ( 0 0$2 ) ;
10448: LD_INT 70
10450: PPUSH
10451: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10455: LD_EXP 46
10459: PPUSH
10460: LD_STRING D12-Bur-1b
10462: PPUSH
10463: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10467: LD_EXP 15
10471: PPUSH
10472: LD_STRING D12-JMM-1
10474: PPUSH
10475: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10479: LD_EXP 46
10483: PPUSH
10484: LD_STRING D12-Bur-2
10486: PPUSH
10487: CALL_OW 88
// if Roth then
10491: LD_EXP 16
10495: IFFALSE 10511
// Say ( Roth , D12-Roth-2 ) else
10497: LD_EXP 16
10501: PPUSH
10502: LD_STRING D12-Roth-2
10504: PPUSH
10505: CALL_OW 88
10509: GO 10523
// Say ( SciRu , D12-RSci1-2 ) ;
10511: CALL 13167 0 0
10515: PPUSH
10516: LD_STRING D12-RSci1-2
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10523: LD_EXP 15
10527: PPUSH
10528: LD_STRING D12-JMM-2
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10535: LD_EXP 46
10539: PPUSH
10540: LD_STRING D12-Bur-3
10542: PPUSH
10543: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10547: LD_EXP 15
10551: PPUSH
10552: LD_STRING D12-JMM-3
10554: PPUSH
10555: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10559: LD_EXP 46
10563: PPUSH
10564: LD_STRING D12-Bur-4
10566: PPUSH
10567: CALL_OW 88
// case Query ( QBase ) of 1 :
10571: LD_STRING QBase
10573: PPUSH
10574: CALL_OW 97
10578: PUSH
10579: LD_INT 1
10581: DOUBLE
10582: EQUAL
10583: IFTRUE 10587
10585: GO 10705
10587: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10588: LD_EXP 15
10592: PPUSH
10593: LD_STRING D13a-JMM-1
10595: PPUSH
10596: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10600: LD_EXP 46
10604: PPUSH
10605: LD_STRING D13a-Bur-1
10607: PPUSH
10608: CALL_OW 88
// if Roth then
10612: LD_EXP 16
10616: IFFALSE 10632
// Say ( Roth , D13a-Roth-1 ) else
10618: LD_EXP 16
10622: PPUSH
10623: LD_STRING D13a-Roth-1
10625: PPUSH
10626: CALL_OW 88
10630: GO 10644
// Say ( SciRu , D13a-RSci1-1 ) ;
10632: CALL 13167 0 0
10636: PPUSH
10637: LD_STRING D13a-RSci1-1
10639: PPUSH
10640: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10644: LD_EXP 15
10648: PPUSH
10649: LD_STRING D13a-JMM-2
10651: PPUSH
10652: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10656: LD_STRING QBaseAgain
10658: PPUSH
10659: CALL_OW 97
10663: PUSH
10664: LD_INT 1
10666: DOUBLE
10667: EQUAL
10668: IFTRUE 10672
10670: GO 10683
10672: POP
// selected_option := 2 ; 2 :
10673: LD_ADDR_VAR 0 2
10677: PUSH
10678: LD_INT 2
10680: ST_TO_ADDR
10681: GO 10703
10683: LD_INT 2
10685: DOUBLE
10686: EQUAL
10687: IFTRUE 10691
10689: GO 10702
10691: POP
// selected_option := 3 ; end ;
10692: LD_ADDR_VAR 0 2
10696: PUSH
10697: LD_INT 3
10699: ST_TO_ADDR
10700: GO 10703
10702: POP
// end ; 2 :
10703: GO 10744
10705: LD_INT 2
10707: DOUBLE
10708: EQUAL
10709: IFTRUE 10713
10711: GO 10724
10713: POP
// selected_option := 2 ; 3 :
10714: LD_ADDR_VAR 0 2
10718: PUSH
10719: LD_INT 2
10721: ST_TO_ADDR
10722: GO 10744
10724: LD_INT 3
10726: DOUBLE
10727: EQUAL
10728: IFTRUE 10732
10730: GO 10743
10732: POP
// selected_option := 3 ; end ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 3
10740: ST_TO_ADDR
10741: GO 10744
10743: POP
// if selected_option = 2 then
10744: LD_VAR 0 2
10748: PUSH
10749: LD_INT 2
10751: EQUAL
10752: IFFALSE 10846
// begin Say ( JMM , D13b-JMM-1 ) ;
10754: LD_EXP 15
10758: PPUSH
10759: LD_STRING D13b-JMM-1
10761: PPUSH
10762: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10766: LD_EXP 46
10770: PPUSH
10771: LD_STRING D13b-Bur-1
10773: PPUSH
10774: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10778: LD_EXP 15
10782: PPUSH
10783: LD_STRING D13b-JMM-2
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10790: LD_EXP 55
10794: PPUSH
10795: LD_STRING D13b-Abd-2
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10802: LD_EXP 15
10806: PPUSH
10807: LD_STRING D13b-JMM-3
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10814: LD_EXP 55
10818: PPUSH
10819: LD_STRING D13b-Abd-3
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10826: LD_EXP 15
10830: PPUSH
10831: LD_STRING D13b-JMM-4
10833: PPUSH
10834: CALL_OW 88
// ar_active_attack := true ;
10838: LD_ADDR_EXP 9
10842: PUSH
10843: LD_INT 1
10845: ST_TO_ADDR
// end ; if selected_option = 3 then
10846: LD_VAR 0 2
10850: PUSH
10851: LD_INT 3
10853: EQUAL
10854: IFFALSE 10880
// begin Say ( JMM , D13c-JMM-1 ) ;
10856: LD_EXP 15
10860: PPUSH
10861: LD_STRING D13c-JMM-1
10863: PPUSH
10864: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10868: LD_EXP 46
10872: PPUSH
10873: LD_STRING D13c-Bur-1
10875: PPUSH
10876: CALL_OW 88
// end ; DialogueOff ;
10880: CALL_OW 7
// if not ar_active_attack then
10884: LD_EXP 9
10888: NOT
10889: IFFALSE 10906
// begin wait ( 6 6$00 ) ;
10891: LD_INT 12600
10893: PPUSH
10894: CALL_OW 67
// ar_active_attack := true ;
10898: LD_ADDR_EXP 9
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// end ; end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10909: LD_EXP 46
10913: PPUSH
10914: CALL_OW 305
10918: PUSH
10919: LD_EXP 46
10923: PPUSH
10924: CALL_OW 255
10928: PUSH
10929: LD_INT 7
10931: EQUAL
10932: AND
10933: IFFALSE 11129
10935: GO 10937
10937: DISABLE
10938: LD_INT 0
10940: PPUSH
// begin wait ( 4 4$40 ) ;
10941: LD_INT 9800
10943: PPUSH
10944: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// until not ru_attackers ;
10955: LD_EXP 52
10959: NOT
10960: IFFALSE 10948
// PrepareGnyevko ;
10962: CALL 2234 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10966: LD_EXP 48
10970: PPUSH
10971: LD_INT 124
10973: PPUSH
10974: LD_INT 118
10976: PPUSH
10977: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10981: LD_EXP 48
10985: PPUSH
10986: CALL_OW 200
// time := 0 0$00 ;
10990: LD_ADDR_VAR 0 1
10994: PUSH
10995: LD_INT 0
10997: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10998: LD_INT 35
11000: PPUSH
11001: CALL_OW 67
// time := time + 0 0$1 ;
11005: LD_ADDR_VAR 0 1
11009: PUSH
11010: LD_VAR 0 1
11014: PUSH
11015: LD_INT 35
11017: PLUS
11018: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11019: LD_EXP 48
11023: PPUSH
11024: LD_INT 124
11026: PPUSH
11027: LD_INT 118
11029: PPUSH
11030: CALL_OW 307
11034: PUSH
11035: LD_VAR 0 1
11039: PUSH
11040: LD_INT 1050
11042: GREATEREQUAL
11043: OR
11044: IFFALSE 10998
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11046: LD_EXP 48
11050: PPUSH
11051: LD_STRING DBelkov-Gny-1
11053: PPUSH
11054: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11058: LD_EXP 46
11062: PPUSH
11063: LD_STRING DBelkov-Bur-1a
11065: PPUSH
11066: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11070: LD_INT 35
11072: PPUSH
11073: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11077: LD_EXP 48
11081: PPUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 7
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: PPUSH
11097: LD_EXP 48
11101: PPUSH
11102: CALL_OW 74
11106: PPUSH
11107: CALL_OW 296
11111: PUSH
11112: LD_INT 8
11114: LESS
11115: IFFALSE 11070
// SetSide ( Gnyevko , 7 ) ;
11117: LD_EXP 48
11121: PPUSH
11122: LD_INT 7
11124: PPUSH
11125: CALL_OW 235
// end ;
11129: PPOPN 1
11131: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11132: LD_EXP 46
11136: PPUSH
11137: CALL_OW 255
11141: PUSH
11142: LD_INT 7
11144: EQUAL
11145: IFFALSE 11155
11147: GO 11149
11149: DISABLE
// begin enable ;
11150: ENABLE
// PrepareAmericanAttack ;
11151: CALL 6805 0 0
// end ;
11155: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11156: LD_INT 22
11158: PUSH
11159: LD_INT 1
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: IFFALSE 11354
11172: GO 11174
11174: DISABLE
11175: LD_INT 0
11177: PPUSH
11178: PPUSH
// begin while true do
11179: LD_INT 1
11181: IFFALSE 11238
// begin wait ( 0 0$1 ) ;
11183: LD_INT 35
11185: PPUSH
11186: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11190: LD_ADDR_VAR 0 2
11194: PUSH
11195: LD_INT 22
11197: PUSH
11198: LD_INT 1
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: PPUSH
11210: LD_EXP 15
11214: PPUSH
11215: CALL_OW 74
11219: ST_TO_ADDR
// if See ( 7 , tmp ) then
11220: LD_INT 7
11222: PPUSH
11223: LD_VAR 0 2
11227: PPUSH
11228: CALL_OW 292
11232: IFFALSE 11236
// break ;
11234: GO 11238
// end ;
11236: GO 11179
// DialogueOn ;
11238: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 250
11260: PPUSH
11261: LD_VAR 0 2
11265: PPUSH
11266: CALL_OW 251
11270: PPUSH
11271: LD_INT 7
11273: PPUSH
11274: LD_INT 8
11276: PPUSH
11277: CALL_OW 330
// if Denis then
11281: LD_EXP 21
11285: IFFALSE 11299
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11287: LD_EXP 21
11291: PPUSH
11292: LD_STRING DAmerAttack-Pet-1
11294: PPUSH
11295: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11299: LD_EXP 15
11303: PPUSH
11304: LD_STRING DAmerAttack-JMM-1
11306: PPUSH
11307: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11311: LD_EXP 46
11315: PPUSH
11316: LD_STRING DStop-Bur-1
11318: PPUSH
11319: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11323: LD_VAR 0 2
11327: PPUSH
11328: CALL_OW 250
11332: PPUSH
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 251
11342: PPUSH
11343: LD_INT 7
11345: PPUSH
11346: CALL_OW 331
// DialogueOff ;
11350: CALL_OW 7
// end ;
11354: PPOPN 2
11356: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11357: LD_INT 22
11359: PUSH
11360: LD_INT 3
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: PUSH
11367: LD_INT 21
11369: PUSH
11370: LD_INT 1
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PPUSH
11381: CALL_OW 69
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11431
11391: GO 11393
11393: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11394: LD_STRING M5a
11396: PPUSH
11397: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11401: LD_EXP 15
11405: PPUSH
11406: LD_STRING D8-JMM-1
11408: PPUSH
11409: CALL_OW 88
// if Gossudarov then
11413: LD_EXP 32
11417: IFFALSE 11431
// Say ( Gossudarov , D8-Gos-1 ) ;
11419: LD_EXP 32
11423: PPUSH
11424: LD_STRING D8-Gos-1
11426: PPUSH
11427: CALL_OW 88
// end ;
11431: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11432: LD_INT 22
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PUSH
11442: LD_INT 21
11444: PUSH
11445: LD_INT 1
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PPUSH
11456: CALL_OW 69
11460: PUSH
11461: LD_INT 0
11463: EQUAL
11464: IFFALSE 11514
11466: GO 11468
11468: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11469: LD_STRING M4c
11471: PPUSH
11472: CALL_OW 337
// if Roth then
11476: LD_EXP 16
11480: IFFALSE 11496
// Say ( Roth , DStop-Roth-1 ) else
11482: LD_EXP 16
11486: PPUSH
11487: LD_STRING DStop-Roth-1
11489: PPUSH
11490: CALL_OW 88
11494: GO 11514
// if Gossudarov then
11496: LD_EXP 32
11500: IFFALSE 11514
// Say ( Gossudarov , D8-Gos-1a ) ;
11502: LD_EXP 32
11506: PPUSH
11507: LD_STRING D8-Gos-1a
11509: PPUSH
11510: CALL_OW 88
// end ;
11514: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11515: LD_INT 7
11517: PPUSH
11518: LD_INT 1
11520: PPUSH
11521: LD_INT 1
11523: PPUSH
11524: CALL 14803 0 3
11528: PUSH
11529: LD_INT 0
11531: EQUAL
11532: PUSH
11533: LD_INT 7
11535: PPUSH
11536: LD_INT 3
11538: PPUSH
11539: LD_INT 1
11541: PPUSH
11542: CALL 14803 0 3
11546: PUSH
11547: LD_INT 0
11549: EQUAL
11550: AND
11551: IFFALSE 11563
11553: GO 11555
11555: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11556: LD_STRING M1a
11558: PPUSH
11559: CALL_OW 337
// end ;
11563: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11564: LD_INT 22
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 21
11576: PUSH
11577: LD_INT 1
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 69
11592: PUSH
11593: LD_INT 0
11595: EQUAL
11596: PUSH
11597: LD_INT 22
11599: PUSH
11600: LD_INT 3
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 21
11609: PUSH
11610: LD_INT 1
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PPUSH
11621: CALL_OW 69
11625: PUSH
11626: LD_INT 0
11628: EQUAL
11629: AND
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 69
11645: PUSH
11646: LD_INT 0
11648: EQUAL
11649: AND
11650: PUSH
11651: LD_INT 7
11653: PPUSH
11654: LD_INT 1
11656: PPUSH
11657: LD_INT 1
11659: PPUSH
11660: CALL 14803 0 3
11664: PUSH
11665: LD_INT 0
11667: EQUAL
11668: AND
11669: PUSH
11670: LD_INT 7
11672: PPUSH
11673: LD_INT 3
11675: PPUSH
11676: LD_INT 1
11678: PPUSH
11679: CALL 14803 0 3
11683: PUSH
11684: LD_INT 0
11686: EQUAL
11687: AND
11688: IFFALSE 13164
11690: GO 11692
11692: DISABLE
11693: LD_INT 0
11695: PPUSH
11696: PPUSH
11697: PPUSH
11698: PPUSH
11699: PPUSH
11700: PPUSH
// begin m1 := false ;
11701: LD_ADDR_VAR 0 4
11705: PUSH
11706: LD_INT 0
11708: ST_TO_ADDR
// m2 := false ;
11709: LD_ADDR_VAR 0 5
11713: PUSH
11714: LD_INT 0
11716: ST_TO_ADDR
// m3 := false ;
11717: LD_ADDR_VAR 0 6
11721: PUSH
11722: LD_INT 0
11724: ST_TO_ADDR
// if tick < 40 40$00 then
11725: LD_OWVAR 1
11729: PUSH
11730: LD_INT 84000
11732: LESS
11733: IFFALSE 11742
// SetAchievement ( ACH_ASPEED_17 ) ;
11735: LD_STRING ACH_ASPEED_17
11737: PPUSH
11738: CALL_OW 543
// wait ( 0 0$5 ) ;
11742: LD_INT 175
11744: PPUSH
11745: CALL_OW 67
// if not IsDead ( Masha ) then
11749: LD_EXP 49
11753: PPUSH
11754: CALL_OW 301
11758: NOT
11759: IFFALSE 11781
// begin m1 := true ;
11761: LD_ADDR_VAR 0 4
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11769: LD_STRING Masha
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: CALL_OW 101
// end else
11779: GO 11792
// AddMedal ( Masha , - 1 ) ;
11781: LD_STRING Masha
11783: PPUSH
11784: LD_INT 1
11786: NEG
11787: PPUSH
11788: CALL_OW 101
// if abdul_escaped then
11792: LD_EXP 12
11796: IFFALSE 11811
// AddMedal ( Abdul , - 1 ) else
11798: LD_STRING Abdul
11800: PPUSH
11801: LD_INT 1
11803: NEG
11804: PPUSH
11805: CALL_OW 101
11809: GO 11829
// begin m2 := true ;
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_INT 1
11818: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11819: LD_STRING Abdul
11821: PPUSH
11822: LD_INT 1
11824: PPUSH
11825: CALL_OW 101
// end ; if loss_counter = 0 then
11829: LD_EXP 13
11833: PUSH
11834: LD_INT 0
11836: EQUAL
11837: IFFALSE 11859
// begin m3 := true ;
11839: LD_ADDR_VAR 0 6
11843: PUSH
11844: LD_INT 1
11846: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11847: LD_STRING People
11849: PPUSH
11850: LD_INT 2
11852: PPUSH
11853: CALL_OW 101
// end else
11857: GO 11917
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11859: LD_EXP 13
11863: PUSH
11864: LD_INT 3
11866: PUSH
11867: LD_INT 2
11869: PUSH
11870: LD_INT 2
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PUSH
11878: LD_OWVAR 67
11882: ARRAY
11883: LESSEQUAL
11884: IFFALSE 11906
// begin AddMedal ( People , 1 ) ;
11886: LD_STRING People
11888: PPUSH
11889: LD_INT 1
11891: PPUSH
11892: CALL_OW 101
// m3 := true ;
11896: LD_ADDR_VAR 0 6
11900: PUSH
11901: LD_INT 1
11903: ST_TO_ADDR
// end else
11904: GO 11917
// AddMedal ( People , - 1 ) ;
11906: LD_STRING People
11908: PPUSH
11909: LD_INT 1
11911: NEG
11912: PPUSH
11913: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11917: LD_OWVAR 67
11921: PUSH
11922: LD_INT 3
11924: EQUAL
11925: PUSH
11926: LD_VAR 0 4
11930: AND
11931: PUSH
11932: LD_VAR 0 5
11936: AND
11937: PUSH
11938: LD_VAR 0 6
11942: AND
11943: IFFALSE 11955
// SetAchievementEX ( ACH_AMER , 17 ) ;
11945: LD_STRING ACH_AMER
11947: PPUSH
11948: LD_INT 17
11950: PPUSH
11951: CALL_OW 564
// GiveMedals ( MAIN ) ;
11955: LD_STRING MAIN
11957: PPUSH
11958: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11962: LD_ADDR_VAR 0 2
11966: PUSH
11967: LD_INT 22
11969: PUSH
11970: LD_INT 7
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: LD_INT 25
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 25
11992: PUSH
11993: LD_INT 2
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: LD_INT 25
12002: PUSH
12003: LD_INT 3
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 25
12012: PUSH
12013: LD_INT 4
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 25
12022: PUSH
12023: LD_INT 5
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 25
12032: PUSH
12033: LD_INT 8
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 25
12042: PUSH
12043: LD_INT 9
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: LIST
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12069: LD_VAR 0 2
12073: PPUSH
12074: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12078: LD_ADDR_VAR 0 3
12082: PUSH
12083: LD_EXP 15
12087: PUSH
12088: LD_EXP 16
12092: PUSH
12093: LD_EXP 17
12097: PUSH
12098: LD_EXP 18
12102: PUSH
12103: LD_EXP 19
12107: PUSH
12108: LD_EXP 20
12112: PUSH
12113: LD_EXP 21
12117: PUSH
12118: LD_EXP 22
12122: PUSH
12123: LD_EXP 23
12127: PUSH
12128: LD_EXP 24
12132: PUSH
12133: LD_EXP 25
12137: PUSH
12138: LD_EXP 26
12142: PUSH
12143: LD_EXP 27
12147: PUSH
12148: LD_EXP 28
12152: PUSH
12153: LD_EXP 29
12157: PUSH
12158: LD_EXP 30
12162: PUSH
12163: LD_EXP 31
12167: PUSH
12168: LD_EXP 32
12172: PUSH
12173: LD_EXP 33
12177: PUSH
12178: LD_EXP 34
12182: PUSH
12183: LD_EXP 36
12187: PUSH
12188: LD_EXP 37
12192: PUSH
12193: LD_EXP 38
12197: PUSH
12198: LD_EXP 39
12202: PUSH
12203: LD_EXP 40
12207: PUSH
12208: LD_EXP 41
12212: PUSH
12213: LD_EXP 42
12217: PUSH
12218: LD_EXP 43
12222: PUSH
12223: LD_EXP 44
12227: PUSH
12228: LD_EXP 45
12232: PUSH
12233: LD_EXP 46
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 48
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: LIST
12280: LIST
12281: LIST
12282: ST_TO_ADDR
// if tmp diff tmp2 then
12283: LD_VAR 0 2
12287: PUSH
12288: LD_VAR 0 3
12292: DIFF
12293: IFFALSE 12313
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12295: LD_VAR 0 2
12299: PUSH
12300: LD_VAR 0 3
12304: DIFF
12305: PPUSH
12306: LD_STRING 13a_others
12308: PPUSH
12309: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12313: LD_EXP 15
12317: PPUSH
12318: LD_STRING 13a_JMM
12320: PPUSH
12321: CALL_OW 38
// if Titov then
12325: LD_EXP 34
12329: IFFALSE 12343
// SaveCharacters ( Titov , 13a_Titov ) ;
12331: LD_EXP 34
12335: PPUSH
12336: LD_STRING 13a_Titov
12338: PPUSH
12339: CALL_OW 38
// if Dolgov then
12343: LD_EXP 36
12347: IFFALSE 12361
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12349: LD_EXP 36
12353: PPUSH
12354: LD_STRING 13a_Dolgov
12356: PPUSH
12357: CALL_OW 38
// if Petrosyan then
12361: LD_EXP 37
12365: IFFALSE 12379
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12367: LD_EXP 37
12371: PPUSH
12372: LD_STRING 13a_Petrosyan
12374: PPUSH
12375: CALL_OW 38
// if Scholtze then
12379: LD_EXP 38
12383: IFFALSE 12397
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12385: LD_EXP 38
12389: PPUSH
12390: LD_STRING 13a_Scholtze
12392: PPUSH
12393: CALL_OW 38
// if Oblukov then
12397: LD_EXP 39
12401: IFFALSE 12415
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12403: LD_EXP 39
12407: PPUSH
12408: LD_STRING 13a_Oblukov
12410: PPUSH
12411: CALL_OW 38
// if Kapitsova then
12415: LD_EXP 40
12419: IFFALSE 12433
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12421: LD_EXP 40
12425: PPUSH
12426: LD_STRING 13a_Kapitsova
12428: PPUSH
12429: CALL_OW 38
// if Lipshchin then
12433: LD_EXP 41
12437: IFFALSE 12451
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12439: LD_EXP 41
12443: PPUSH
12444: LD_STRING 13a_Lipshchin
12446: PPUSH
12447: CALL_OW 38
// if Petrovova then
12451: LD_EXP 42
12455: IFFALSE 12469
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12457: LD_EXP 42
12461: PPUSH
12462: LD_STRING 13a_Petrovova
12464: PPUSH
12465: CALL_OW 38
// if Kovalyuk then
12469: LD_EXP 43
12473: IFFALSE 12487
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12475: LD_EXP 43
12479: PPUSH
12480: LD_STRING 13a_Kovalyuk
12482: PPUSH
12483: CALL_OW 38
// if Kuzmov then
12487: LD_EXP 44
12491: IFFALSE 12505
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12493: LD_EXP 44
12497: PPUSH
12498: LD_STRING 13a_Kuzmov
12500: PPUSH
12501: CALL_OW 38
// if Karamazov then
12505: LD_EXP 45
12509: IFFALSE 12523
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12511: LD_EXP 45
12515: PPUSH
12516: LD_STRING 13a_Karamazov
12518: PPUSH
12519: CALL_OW 38
// if Burlak then
12523: LD_EXP 46
12527: IFFALSE 12541
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12529: LD_EXP 46
12533: PPUSH
12534: LD_STRING 13a_Burlak
12536: PPUSH
12537: CALL_OW 38
// if Belkov then
12541: LD_EXP 47
12545: IFFALSE 12559
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12547: LD_EXP 47
12551: PPUSH
12552: LD_STRING 13a_Belkov
12554: PPUSH
12555: CALL_OW 38
// if Gnyevko then
12559: LD_EXP 48
12563: IFFALSE 12577
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12565: LD_EXP 48
12569: PPUSH
12570: LD_STRING 13a_Gnyevko
12572: PPUSH
12573: CALL_OW 38
// if Lisa then
12577: LD_EXP 17
12581: IFFALSE 12595
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12583: LD_EXP 17
12587: PPUSH
12588: LD_STRING 13a_Lisa
12590: PPUSH
12591: CALL_OW 38
// if Donaldson then
12595: LD_EXP 18
12599: IFFALSE 12613
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12601: LD_EXP 18
12605: PPUSH
12606: LD_STRING 13a_Donaldson
12608: PPUSH
12609: CALL_OW 38
// if Bobby then
12613: LD_EXP 19
12617: IFFALSE 12631
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12619: LD_EXP 19
12623: PPUSH
12624: LD_STRING 13a_Bobby
12626: PPUSH
12627: CALL_OW 38
// if Cyrus then
12631: LD_EXP 20
12635: IFFALSE 12649
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12637: LD_EXP 20
12641: PPUSH
12642: LD_STRING 13a_Cyrus
12644: PPUSH
12645: CALL_OW 38
// if Denis then
12649: LD_EXP 21
12653: IFFALSE 12667
// SaveCharacters ( Denis , 13a_Denis ) ;
12655: LD_EXP 21
12659: PPUSH
12660: LD_STRING 13a_Denis
12662: PPUSH
12663: CALL_OW 38
// if Brown then
12667: LD_EXP 22
12671: IFFALSE 12685
// SaveCharacters ( Brown , 13a_Brown ) ;
12673: LD_EXP 22
12677: PPUSH
12678: LD_STRING 13a_Brown
12680: PPUSH
12681: CALL_OW 38
// if Gladstone then
12685: LD_EXP 23
12689: IFFALSE 12703
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12691: LD_EXP 23
12695: PPUSH
12696: LD_STRING 13a_Gladstone
12698: PPUSH
12699: CALL_OW 38
// if Houten then
12703: LD_EXP 24
12707: IFFALSE 12721
// SaveCharacters ( Houten , 13a_Houten ) ;
12709: LD_EXP 24
12713: PPUSH
12714: LD_STRING 13a_Houten
12716: PPUSH
12717: CALL_OW 38
// if Cornel then
12721: LD_EXP 25
12725: IFFALSE 12739
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12727: LD_EXP 25
12731: PPUSH
12732: LD_STRING 13a_Cornel
12734: PPUSH
12735: CALL_OW 38
// if Gary then
12739: LD_EXP 26
12743: IFFALSE 12757
// SaveCharacters ( Gary , 13a_Gary ) ;
12745: LD_EXP 26
12749: PPUSH
12750: LD_STRING 13a_Gary
12752: PPUSH
12753: CALL_OW 38
// if Frank then
12757: LD_EXP 27
12761: IFFALSE 12775
// SaveCharacters ( Frank , 13a_Frank ) ;
12763: LD_EXP 27
12767: PPUSH
12768: LD_STRING 13a_Frank
12770: PPUSH
12771: CALL_OW 38
// if Kikuchi then
12775: LD_EXP 28
12779: IFFALSE 12793
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12781: LD_EXP 28
12785: PPUSH
12786: LD_STRING 13a_Kikuchi
12788: PPUSH
12789: CALL_OW 38
// if Simms then
12793: LD_EXP 29
12797: IFFALSE 12811
// SaveCharacters ( Simms , 13a_Simms ) ;
12799: LD_EXP 29
12803: PPUSH
12804: LD_STRING 13a_Simms
12806: PPUSH
12807: CALL_OW 38
// if Joan then
12811: LD_EXP 30
12815: IFFALSE 12829
// SaveCharacters ( Joan , 13a_Joan ) ;
12817: LD_EXP 30
12821: PPUSH
12822: LD_STRING 13a_Joan
12824: PPUSH
12825: CALL_OW 38
// if DeltaDoctor then
12829: LD_EXP 31
12833: IFFALSE 12847
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12835: LD_EXP 31
12839: PPUSH
12840: LD_STRING 13a_DeltaDoctor
12842: PPUSH
12843: CALL_OW 38
// if Gossudarov then
12847: LD_EXP 32
12851: IFFALSE 12865
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12853: LD_EXP 32
12857: PPUSH
12858: LD_STRING 13a_Gossudarov
12860: PPUSH
12861: CALL_OW 38
// if Kirilenkova then
12865: LD_EXP 33
12869: IFFALSE 12883
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12871: LD_EXP 33
12875: PPUSH
12876: LD_STRING 13a_Kirilenkova
12878: PPUSH
12879: CALL_OW 38
// if Roth then
12883: LD_EXP 16
12887: IFFALSE 12901
// SaveCharacters ( Roth , 13a_Roth ) ;
12889: LD_EXP 16
12893: PPUSH
12894: LD_STRING 13a_Roth
12896: PPUSH
12897: CALL_OW 38
// if Masha then
12901: LD_EXP 49
12905: IFFALSE 12960
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12907: LD_EXP 49
12911: PPUSH
12912: CALL_OW 265
12916: PUSH
12917: LD_EXP 49
12921: PPUSH
12922: CALL_OW 262
12926: PUSH
12927: LD_EXP 49
12931: PPUSH
12932: CALL_OW 263
12936: PUSH
12937: LD_EXP 49
12941: PPUSH
12942: CALL_OW 264
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: PPUSH
12953: LD_STRING 13a_Masha
12955: PPUSH
12956: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12960: LD_ADDR_VAR 0 2
12964: PUSH
12965: LD_INT 21
12967: PUSH
12968: LD_INT 3
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: PPUSH
12975: CALL_OW 69
12979: ST_TO_ADDR
// tmp2 := [ ] ;
12980: LD_ADDR_VAR 0 3
12984: PUSH
12985: EMPTY
12986: ST_TO_ADDR
// if tmp then
12987: LD_VAR 0 2
12991: IFFALSE 13142
// for i in tmp do
12993: LD_ADDR_VAR 0 1
12997: PUSH
12998: LD_VAR 0 2
13002: PUSH
13003: FOR_IN
13004: IFFALSE 13140
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13006: LD_ADDR_VAR 0 3
13010: PUSH
13011: LD_VAR 0 3
13015: PUSH
13016: LD_VAR 0 1
13020: PPUSH
13021: CALL_OW 255
13025: PUSH
13026: LD_VAR 0 1
13030: PPUSH
13031: CALL_OW 248
13035: PUSH
13036: LD_VAR 0 1
13040: PPUSH
13041: CALL_OW 266
13045: PUSH
13046: LD_VAR 0 1
13050: PPUSH
13051: CALL_OW 250
13055: PUSH
13056: LD_VAR 0 1
13060: PPUSH
13061: CALL_OW 251
13065: PUSH
13066: LD_VAR 0 1
13070: PPUSH
13071: CALL_OW 254
13075: PUSH
13076: LD_VAR 0 1
13080: PPUSH
13081: CALL_OW 267
13085: PUSH
13086: LD_VAR 0 1
13090: PPUSH
13091: LD_INT 1
13093: PPUSH
13094: CALL_OW 268
13098: PUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: LD_INT 2
13106: PPUSH
13107: CALL_OW 268
13111: PUSH
13112: LD_VAR 0 1
13116: PPUSH
13117: CALL_OW 269
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: PUSH
13134: EMPTY
13135: LIST
13136: ADD
13137: ST_TO_ADDR
13138: GO 13003
13140: POP
13141: POP
// if tmp2 then
13142: LD_VAR 0 3
13146: IFFALSE 13160
// SaveVariable ( tmp2 , 13a_buildings ) ;
13148: LD_VAR 0 3
13152: PPUSH
13153: LD_STRING 13a_buildings
13155: PPUSH
13156: CALL_OW 39
// YouWin ;
13160: CALL_OW 103
// end ;
13164: PPOPN 6
13166: END
// export function SciRu ; var tmp , t ; begin
13167: LD_INT 0
13169: PPUSH
13170: PPUSH
13171: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13172: LD_ADDR_VAR 0 3
13176: PUSH
13177: LD_EXP 32
13181: PUSH
13182: LD_EXP 46
13186: PUSH
13187: LD_EXP 34
13191: PUSH
13192: LD_EXP 47
13196: PUSH
13197: LD_EXP 48
13201: PUSH
13202: LD_EXP 37
13206: PUSH
13207: LD_EXP 38
13211: PUSH
13212: LD_EXP 36
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13227: LD_ADDR_VAR 0 2
13231: PUSH
13232: LD_INT 22
13234: PUSH
13235: LD_INT 7
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 23
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 25
13254: PUSH
13255: LD_INT 4
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 26
13264: PUSH
13265: LD_INT 1
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: PPUSH
13278: CALL_OW 69
13282: PUSH
13283: LD_VAR 0 3
13287: DIFF
13288: ST_TO_ADDR
// if tmp then
13289: LD_VAR 0 2
13293: IFFALSE 13309
// result := tmp [ 1 ] ;
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: LD_INT 1
13307: ARRAY
13308: ST_TO_ADDR
// end ;
13309: LD_VAR 0 1
13313: RET
// export function SolRu ; var tmp , t ; begin
13314: LD_INT 0
13316: PPUSH
13317: PPUSH
13318: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_EXP 32
13328: PUSH
13329: LD_EXP 46
13333: PUSH
13334: LD_EXP 34
13338: PUSH
13339: LD_EXP 47
13343: PUSH
13344: LD_EXP 48
13348: PUSH
13349: LD_EXP 37
13353: PUSH
13354: LD_EXP 38
13358: PUSH
13359: LD_EXP 36
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13374: LD_ADDR_VAR 0 2
13378: PUSH
13379: LD_INT 22
13381: PUSH
13382: LD_INT 7
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 23
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PUSH
13399: LD_INT 25
13401: PUSH
13402: LD_INT 1
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 26
13411: PUSH
13412: LD_INT 1
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 69
13429: PUSH
13430: LD_VAR 0 3
13434: DIFF
13435: ST_TO_ADDR
// if tmp then
13436: LD_VAR 0 2
13440: IFFALSE 13456
// result := tmp [ 1 ] ;
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_VAR 0 2
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: ST_TO_ADDR
// end ; end_of_file
13456: LD_VAR 0 1
13460: RET
// export function CustomEvent ( event ) ; begin
13461: LD_INT 0
13463: PPUSH
// end ;
13464: LD_VAR 0 2
13468: RET
// on UnitDestroyed ( un ) do var i , side ;
13469: LD_INT 0
13471: PPUSH
13472: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13473: LD_VAR 0 1
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_INT 7
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 2
13490: PUSH
13491: LD_INT 25
13493: PUSH
13494: LD_INT 1
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PUSH
13501: LD_INT 25
13503: PUSH
13504: LD_INT 2
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 25
13513: PUSH
13514: LD_INT 3
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PUSH
13521: LD_INT 25
13523: PUSH
13524: LD_INT 4
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: LD_INT 25
13533: PUSH
13534: LD_INT 5
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 25
13543: PUSH
13544: LD_INT 8
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: LD_INT 25
13553: PUSH
13554: LD_INT 9
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: IN
13580: IFFALSE 13596
// loss_counter := loss_counter + 1 ;
13582: LD_ADDR_EXP 13
13586: PUSH
13587: LD_EXP 13
13591: PUSH
13592: LD_INT 1
13594: PLUS
13595: ST_TO_ADDR
// if un = Abdul then
13596: LD_VAR 0 1
13600: PUSH
13601: LD_EXP 55
13605: EQUAL
13606: IFFALSE 13616
// abdul_escaped := false ;
13608: LD_ADDR_EXP 12
13612: PUSH
13613: LD_INT 0
13615: ST_TO_ADDR
// if un in ru_attackers then
13616: LD_VAR 0 1
13620: PUSH
13621: LD_EXP 52
13625: IN
13626: IFFALSE 13644
// ru_attackers := ru_attackers diff un ;
13628: LD_ADDR_EXP 52
13632: PUSH
13633: LD_EXP 52
13637: PUSH
13638: LD_VAR 0 1
13642: DIFF
13643: ST_TO_ADDR
// if un in ar_attackers then
13644: LD_VAR 0 1
13648: PUSH
13649: LD_EXP 10
13653: IN
13654: IFFALSE 13672
// ar_attackers := ar_attackers diff un ;
13656: LD_ADDR_EXP 10
13660: PUSH
13661: LD_EXP 10
13665: PUSH
13666: LD_VAR 0 1
13670: DIFF
13671: ST_TO_ADDR
// if un = JMM then
13672: LD_VAR 0 1
13676: PUSH
13677: LD_EXP 15
13681: EQUAL
13682: IFFALSE 13693
// begin YouLost ( JMM ) ;
13684: LD_STRING JMM
13686: PPUSH
13687: CALL_OW 104
// exit ;
13691: GO 13782
// end ; if un = Burlak then
13693: LD_VAR 0 1
13697: PUSH
13698: LD_EXP 46
13702: EQUAL
13703: IFFALSE 13714
// begin YouLost ( Burlak ) ;
13705: LD_STRING Burlak
13707: PPUSH
13708: CALL_OW 104
// exit ;
13712: GO 13782
// end ; if un = freedom then
13714: LD_VAR 0 1
13718: PUSH
13719: LD_EXP 3
13723: EQUAL
13724: IFFALSE 13735
// begin YouLost ( Destroyed ) ;
13726: LD_STRING Destroyed
13728: PPUSH
13729: CALL_OW 104
// exit ;
13733: GO 13782
// end ; if un = Masha then
13735: LD_VAR 0 1
13739: PUSH
13740: LD_EXP 49
13744: EQUAL
13745: IFFALSE 13754
// ChangeMissionObjectives ( M4b ) ;
13747: LD_STRING M4b
13749: PPUSH
13750: CALL_OW 337
// if un = Mastodont then
13754: LD_VAR 0 1
13758: PUSH
13759: LD_EXP 56
13763: EQUAL
13764: IFFALSE 13773
// ChangeMissionObjectives ( M4a ) ;
13766: LD_STRING M4a
13768: PPUSH
13769: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL 79673 0 1
// end ;
13782: PPOPN 3
13784: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 2
13794: PPUSH
13795: CALL 82007 0 2
// end ;
13799: PPOPN 2
13801: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13802: LD_VAR 0 1
13806: PPUSH
13807: CALL 81075 0 1
// end ;
13811: PPOPN 1
13813: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 22
13821: PUSH
13822: LD_INT 7
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: LD_INT 0
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PPUSH
13843: CALL_OW 69
13847: IN
13848: IFFALSE 13887
// begin SetBName ( building , freedom ) ;
13850: LD_VAR 0 1
13854: PPUSH
13855: LD_STRING freedom
13857: PPUSH
13858: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13862: LD_INT 0
13864: PPUSH
13865: LD_INT 7
13867: PPUSH
13868: LD_INT 0
13870: PPUSH
13871: CALL_OW 324
// freedom := building ;
13875: LD_ADDR_EXP 3
13879: PUSH
13880: LD_VAR 0 1
13884: ST_TO_ADDR
// exit ;
13885: GO 13953
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13887: LD_VAR 0 1
13891: PUSH
13892: LD_INT 22
13894: PUSH
13895: LD_INT 7
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 23
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: PUSH
13912: LD_INT 30
13914: PUSH
13915: LD_INT 6
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: PPUSH
13927: CALL_OW 69
13931: IN
13932: IFFALSE 13944
// begin ru_lab_builded := true ;
13934: LD_ADDR_EXP 5
13938: PUSH
13939: LD_INT 1
13941: ST_TO_ADDR
// exit ;
13942: GO 13953
// end ; MCE_BuildingComplete ( building ) ;
13944: LD_VAR 0 1
13948: PPUSH
13949: CALL 81316 0 1
// end ;
13953: PPOPN 1
13955: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13956: LD_VAR 0 1
13960: PPUSH
13961: LD_VAR 0 2
13965: PPUSH
13966: CALL 79369 0 2
// end ;
13970: PPOPN 2
13972: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13973: LD_VAR 0 1
13977: PPUSH
13978: LD_VAR 0 2
13982: PPUSH
13983: LD_VAR 0 3
13987: PPUSH
13988: LD_VAR 0 4
13992: PPUSH
13993: LD_VAR 0 5
13997: PPUSH
13998: CALL 78989 0 5
// end ;
14002: PPOPN 5
14004: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14005: LD_VAR 0 1
14009: PPUSH
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL 78579 0 2
// end ;
14019: PPOPN 2
14021: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14022: LD_VAR 0 1
14026: PPUSH
14027: CALL_OW 263
14031: PUSH
14032: LD_INT 3
14034: EQUAL
14035: PUSH
14036: LD_VAR 0 2
14040: PPUSH
14041: CALL_OW 263
14045: PUSH
14046: LD_INT 3
14048: EQUAL
14049: OR
14050: IFFALSE 14066
// hack_counter := hack_counter + 1 ;
14052: LD_ADDR_EXP 14
14056: PUSH
14057: LD_EXP 14
14061: PUSH
14062: LD_INT 1
14064: PLUS
14065: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14066: LD_VAR 0 1
14070: PPUSH
14071: LD_VAR 0 2
14075: PPUSH
14076: LD_VAR 0 3
14080: PPUSH
14081: LD_VAR 0 4
14085: PPUSH
14086: CALL 78417 0 4
// end ;
14090: PPOPN 4
14092: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_VAR 0 3
14107: PPUSH
14108: CALL 78192 0 3
// end ;
14112: PPOPN 3
14114: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14115: LD_VAR 0 1
14119: PPUSH
14120: LD_VAR 0 2
14124: PPUSH
14125: CALL 78077 0 2
// end ;
14129: PPOPN 2
14131: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14132: LD_VAR 0 1
14136: PPUSH
14137: LD_VAR 0 2
14141: PPUSH
14142: CALL 82302 0 2
// end ;
14146: PPOPN 2
14148: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14149: LD_VAR 0 1
14153: PPUSH
14154: LD_VAR 0 2
14158: PPUSH
14159: LD_VAR 0 3
14163: PPUSH
14164: LD_VAR 0 4
14168: PPUSH
14169: CALL 82518 0 4
// end ;
14173: PPOPN 4
14175: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_VAR 0 2
14185: PPUSH
14186: CALL 77886 0 2
// end ;
14190: PPOPN 2
14192: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14193: LD_VAR 0 1
14197: PPUSH
14198: CALL 96105 0 1
// end ; end_of_file
14202: PPOPN 1
14204: END
// every 0 0$30 do var cr , time ;
14205: GO 14207
14207: DISABLE
14208: LD_INT 0
14210: PPUSH
14211: PPUSH
// begin time := 0 0$20 ;
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: LD_INT 700
14219: ST_TO_ADDR
// while game do
14220: LD_EXP 2
14224: IFFALSE 14323
// begin wait ( time ) ;
14226: LD_VAR 0 2
14230: PPUSH
14231: CALL_OW 67
// if tick > 2 2$00 then
14235: LD_OWVAR 1
14239: PUSH
14240: LD_INT 4200
14242: GREATER
14243: IFFALSE 14276
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 ] [ Difficulty ] ;
14245: LD_ADDR_VAR 0 2
14249: PUSH
14250: LD_VAR 0 2
14254: PUSH
14255: LD_INT 140
14257: PUSH
14258: LD_INT 140
14260: PUSH
14261: LD_INT 210
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: PUSH
14269: LD_OWVAR 67
14273: ARRAY
14274: PLUS
14275: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 70
14289: PPUSH
14290: LD_INT 49
14292: PPUSH
14293: LD_INT 25
14295: PPUSH
14296: LD_INT 1
14298: PPUSH
14299: CALL_OW 56
// if time > 3 3$00 then
14303: LD_VAR 0 2
14307: PUSH
14308: LD_INT 6300
14310: GREATER
14311: IFFALSE 14321
// time := 0 0$30 ;
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: LD_INT 1050
14320: ST_TO_ADDR
// end ;
14321: GO 14220
// end ;
14323: PPOPN 2
14325: END
// every 0 0$30 do var cr , time ;
14326: GO 14328
14328: DISABLE
14329: LD_INT 0
14331: PPUSH
14332: PPUSH
// begin time := 0 0$20 ;
14333: LD_ADDR_VAR 0 2
14337: PUSH
14338: LD_INT 700
14340: ST_TO_ADDR
// while game do
14341: LD_EXP 2
14345: IFFALSE 14434
// begin wait ( time ) ;
14347: LD_VAR 0 2
14351: PPUSH
14352: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 ] [ Difficulty ] ;
14356: LD_ADDR_VAR 0 2
14360: PUSH
14361: LD_VAR 0 2
14365: PUSH
14366: LD_INT 140
14368: PUSH
14369: LD_INT 175
14371: PUSH
14372: LD_INT 210
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: PUSH
14380: LD_OWVAR 67
14384: ARRAY
14385: PLUS
14386: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14387: LD_INT 3
14389: PPUSH
14390: LD_INT 5
14392: PPUSH
14393: CALL_OW 12
14397: PPUSH
14398: LD_INT 26
14400: PPUSH
14401: LD_INT 9
14403: PPUSH
14404: LD_INT 30
14406: PPUSH
14407: LD_INT 1
14409: PPUSH
14410: CALL_OW 56
// if time > 3 3$00 then
14414: LD_VAR 0 2
14418: PUSH
14419: LD_INT 6300
14421: GREATER
14422: IFFALSE 14432
// time := 0 0$20 ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_INT 700
14431: ST_TO_ADDR
// end ;
14432: GO 14341
// end ;
14434: PPOPN 2
14436: END
// every 0 0$30 do var cr , time ;
14437: GO 14439
14439: DISABLE
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
// begin time := 0 0$20 ;
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: LD_INT 700
14451: ST_TO_ADDR
// while game do
14452: LD_EXP 2
14456: IFFALSE 14581
// begin wait ( time ) ;
14458: LD_VAR 0 2
14462: PPUSH
14463: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: LD_VAR 0 2
14476: PUSH
14477: LD_INT 175
14479: PUSH
14480: LD_INT 210
14482: PUSH
14483: LD_INT 280
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: PUSH
14491: LD_OWVAR 67
14495: ARRAY
14496: PLUS
14497: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14498: LD_INT 1
14500: PPUSH
14501: LD_INT 5
14503: PPUSH
14504: CALL_OW 12
14508: PPUSH
14509: LD_INT 179
14511: PPUSH
14512: LD_INT 101
14514: PPUSH
14515: LD_INT 20
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14525: LD_INT 350
14527: PPUSH
14528: LD_INT 525
14530: PPUSH
14531: CALL_OW 12
14535: PPUSH
14536: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14540: LD_INT 1
14542: PPUSH
14543: LD_INT 5
14545: PPUSH
14546: CALL_OW 12
14550: PPUSH
14551: LD_INT 9
14553: PPUSH
14554: LD_INT 1
14556: PPUSH
14557: CALL_OW 55
// if time > 4 4$00 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_INT 8400
14568: GREATER
14569: IFFALSE 14579
// time := 0 0$30 ;
14571: LD_ADDR_VAR 0 2
14575: PUSH
14576: LD_INT 1050
14578: ST_TO_ADDR
// end ;
14579: GO 14452
// end ;
14581: PPOPN 2
14583: END
// every 0 0$30 do var cr , time ;
14584: GO 14586
14586: DISABLE
14587: LD_INT 0
14589: PPUSH
14590: PPUSH
// begin time := 0 0$10 ;
14591: LD_ADDR_VAR 0 2
14595: PUSH
14596: LD_INT 350
14598: ST_TO_ADDR
// while game do
14599: LD_EXP 2
14603: IFFALSE 14737
// begin wait ( time ) ;
14605: LD_VAR 0 2
14609: PPUSH
14610: CALL_OW 67
// time := time + 0 0$10 ;
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 2
14623: PUSH
14624: LD_INT 350
14626: PLUS
14627: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14628: LD_INT 1
14630: PPUSH
14631: LD_INT 5
14633: PPUSH
14634: CALL_OW 12
14638: PPUSH
14639: LD_INT 11
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14649: LD_ADDR_VAR 0 1
14653: PUSH
14654: LD_INT 1
14656: PPUSH
14657: LD_INT 3
14659: PPUSH
14660: CALL_OW 12
14664: ST_TO_ADDR
// if cr = 1 then
14665: LD_VAR 0 1
14669: PUSH
14670: LD_INT 1
14672: EQUAL
14673: IFFALSE 14717
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14675: LD_INT 700
14677: PPUSH
14678: LD_INT 1575
14680: PPUSH
14681: CALL_OW 12
14685: PPUSH
14686: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14690: LD_INT 1
14692: PPUSH
14693: LD_INT 5
14695: PPUSH
14696: CALL_OW 12
14700: PPUSH
14701: LD_INT 34
14703: PPUSH
14704: LD_INT 50
14706: PPUSH
14707: LD_INT 7
14709: PPUSH
14710: LD_INT 1
14712: PPUSH
14713: CALL_OW 56
// end ; if time > 4 4$00 then
14717: LD_VAR 0 2
14721: PUSH
14722: LD_INT 8400
14724: GREATER
14725: IFFALSE 14735
// time := 0 0$40 ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 1400
14734: ST_TO_ADDR
// end ;
14735: GO 14599
// end ; end_of_file
14737: PPOPN 2
14739: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14740: LD_INT 0
14742: PPUSH
14743: PPUSH
// if exist_mode then
14744: LD_VAR 0 2
14748: IFFALSE 14773
// unit := CreateCharacter ( prefix & ident ) else
14750: LD_ADDR_VAR 0 5
14754: PUSH
14755: LD_VAR 0 3
14759: PUSH
14760: LD_VAR 0 1
14764: STR
14765: PPUSH
14766: CALL_OW 34
14770: ST_TO_ADDR
14771: GO 14788
// unit := NewCharacter ( ident ) ;
14773: LD_ADDR_VAR 0 5
14777: PUSH
14778: LD_VAR 0 1
14782: PPUSH
14783: CALL_OW 25
14787: ST_TO_ADDR
// result := unit ;
14788: LD_ADDR_VAR 0 4
14792: PUSH
14793: LD_VAR 0 5
14797: ST_TO_ADDR
// end ;
14798: LD_VAR 0 4
14802: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14803: LD_INT 0
14805: PPUSH
14806: PPUSH
// if not side or not nation then
14807: LD_VAR 0 1
14811: NOT
14812: PUSH
14813: LD_VAR 0 2
14817: NOT
14818: OR
14819: IFFALSE 14823
// exit ;
14821: GO 15587
// case nation of nation_american :
14823: LD_VAR 0 2
14827: PUSH
14828: LD_INT 1
14830: DOUBLE
14831: EQUAL
14832: IFTRUE 14836
14834: GO 15050
14836: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14837: LD_ADDR_VAR 0 4
14841: PUSH
14842: LD_INT 35
14844: PUSH
14845: LD_INT 45
14847: PUSH
14848: LD_INT 46
14850: PUSH
14851: LD_INT 47
14853: PUSH
14854: LD_INT 82
14856: PUSH
14857: LD_INT 83
14859: PUSH
14860: LD_INT 84
14862: PUSH
14863: LD_INT 85
14865: PUSH
14866: LD_INT 86
14868: PUSH
14869: LD_INT 1
14871: PUSH
14872: LD_INT 2
14874: PUSH
14875: LD_INT 6
14877: PUSH
14878: LD_INT 15
14880: PUSH
14881: LD_INT 16
14883: PUSH
14884: LD_INT 7
14886: PUSH
14887: LD_INT 12
14889: PUSH
14890: LD_INT 13
14892: PUSH
14893: LD_INT 10
14895: PUSH
14896: LD_INT 14
14898: PUSH
14899: LD_INT 20
14901: PUSH
14902: LD_INT 21
14904: PUSH
14905: LD_INT 22
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 32
14913: PUSH
14914: LD_INT 27
14916: PUSH
14917: LD_INT 36
14919: PUSH
14920: LD_INT 69
14922: PUSH
14923: LD_INT 39
14925: PUSH
14926: LD_INT 34
14928: PUSH
14929: LD_INT 40
14931: PUSH
14932: LD_INT 48
14934: PUSH
14935: LD_INT 49
14937: PUSH
14938: LD_INT 50
14940: PUSH
14941: LD_INT 51
14943: PUSH
14944: LD_INT 52
14946: PUSH
14947: LD_INT 53
14949: PUSH
14950: LD_INT 54
14952: PUSH
14953: LD_INT 55
14955: PUSH
14956: LD_INT 56
14958: PUSH
14959: LD_INT 57
14961: PUSH
14962: LD_INT 58
14964: PUSH
14965: LD_INT 59
14967: PUSH
14968: LD_INT 60
14970: PUSH
14971: LD_INT 61
14973: PUSH
14974: LD_INT 62
14976: PUSH
14977: LD_INT 80
14979: PUSH
14980: LD_INT 82
14982: PUSH
14983: LD_INT 83
14985: PUSH
14986: LD_INT 84
14988: PUSH
14989: LD_INT 85
14991: PUSH
14992: LD_INT 86
14994: PUSH
14995: EMPTY
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: ST_TO_ADDR
15048: GO 15511
15050: LD_INT 2
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15280
15058: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
15059: LD_ADDR_VAR 0 4
15063: PUSH
15064: LD_INT 35
15066: PUSH
15067: LD_INT 45
15069: PUSH
15070: LD_INT 46
15072: PUSH
15073: LD_INT 47
15075: PUSH
15076: LD_INT 82
15078: PUSH
15079: LD_INT 83
15081: PUSH
15082: LD_INT 84
15084: PUSH
15085: LD_INT 85
15087: PUSH
15088: LD_INT 87
15090: PUSH
15091: LD_INT 70
15093: PUSH
15094: LD_INT 1
15096: PUSH
15097: LD_INT 11
15099: PUSH
15100: LD_INT 3
15102: PUSH
15103: LD_INT 4
15105: PUSH
15106: LD_INT 5
15108: PUSH
15109: LD_INT 6
15111: PUSH
15112: LD_INT 15
15114: PUSH
15115: LD_INT 18
15117: PUSH
15118: LD_INT 7
15120: PUSH
15121: LD_INT 17
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: LD_INT 20
15129: PUSH
15130: LD_INT 21
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_INT 72
15138: PUSH
15139: LD_INT 26
15141: PUSH
15142: LD_INT 69
15144: PUSH
15145: LD_INT 39
15147: PUSH
15148: LD_INT 40
15150: PUSH
15151: LD_INT 41
15153: PUSH
15154: LD_INT 42
15156: PUSH
15157: LD_INT 43
15159: PUSH
15160: LD_INT 48
15162: PUSH
15163: LD_INT 49
15165: PUSH
15166: LD_INT 50
15168: PUSH
15169: LD_INT 51
15171: PUSH
15172: LD_INT 52
15174: PUSH
15175: LD_INT 53
15177: PUSH
15178: LD_INT 54
15180: PUSH
15181: LD_INT 55
15183: PUSH
15184: LD_INT 56
15186: PUSH
15187: LD_INT 60
15189: PUSH
15190: LD_INT 61
15192: PUSH
15193: LD_INT 62
15195: PUSH
15196: LD_INT 66
15198: PUSH
15199: LD_INT 67
15201: PUSH
15202: LD_INT 68
15204: PUSH
15205: LD_INT 81
15207: PUSH
15208: LD_INT 82
15210: PUSH
15211: LD_INT 83
15213: PUSH
15214: LD_INT 84
15216: PUSH
15217: LD_INT 85
15219: PUSH
15220: LD_INT 87
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: ST_TO_ADDR
15278: GO 15511
15280: LD_INT 3
15282: DOUBLE
15283: EQUAL
15284: IFTRUE 15288
15286: GO 15510
15288: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15289: LD_ADDR_VAR 0 4
15293: PUSH
15294: LD_INT 46
15296: PUSH
15297: LD_INT 47
15299: PUSH
15300: LD_INT 1
15302: PUSH
15303: LD_INT 2
15305: PUSH
15306: LD_INT 82
15308: PUSH
15309: LD_INT 83
15311: PUSH
15312: LD_INT 84
15314: PUSH
15315: LD_INT 85
15317: PUSH
15318: LD_INT 86
15320: PUSH
15321: LD_INT 11
15323: PUSH
15324: LD_INT 9
15326: PUSH
15327: LD_INT 20
15329: PUSH
15330: LD_INT 19
15332: PUSH
15333: LD_INT 21
15335: PUSH
15336: LD_INT 24
15338: PUSH
15339: LD_INT 22
15341: PUSH
15342: LD_INT 25
15344: PUSH
15345: LD_INT 28
15347: PUSH
15348: LD_INT 29
15350: PUSH
15351: LD_INT 30
15353: PUSH
15354: LD_INT 31
15356: PUSH
15357: LD_INT 37
15359: PUSH
15360: LD_INT 38
15362: PUSH
15363: LD_INT 32
15365: PUSH
15366: LD_INT 27
15368: PUSH
15369: LD_INT 33
15371: PUSH
15372: LD_INT 69
15374: PUSH
15375: LD_INT 39
15377: PUSH
15378: LD_INT 34
15380: PUSH
15381: LD_INT 40
15383: PUSH
15384: LD_INT 71
15386: PUSH
15387: LD_INT 23
15389: PUSH
15390: LD_INT 44
15392: PUSH
15393: LD_INT 48
15395: PUSH
15396: LD_INT 49
15398: PUSH
15399: LD_INT 50
15401: PUSH
15402: LD_INT 51
15404: PUSH
15405: LD_INT 52
15407: PUSH
15408: LD_INT 53
15410: PUSH
15411: LD_INT 54
15413: PUSH
15414: LD_INT 55
15416: PUSH
15417: LD_INT 56
15419: PUSH
15420: LD_INT 57
15422: PUSH
15423: LD_INT 58
15425: PUSH
15426: LD_INT 59
15428: PUSH
15429: LD_INT 63
15431: PUSH
15432: LD_INT 64
15434: PUSH
15435: LD_INT 65
15437: PUSH
15438: LD_INT 82
15440: PUSH
15441: LD_INT 83
15443: PUSH
15444: LD_INT 84
15446: PUSH
15447: LD_INT 85
15449: PUSH
15450: LD_INT 86
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: LIST
15493: LIST
15494: LIST
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: LIST
15500: LIST
15501: LIST
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: LIST
15507: ST_TO_ADDR
15508: GO 15511
15510: POP
// if state > - 1 and state < 3 then
15511: LD_VAR 0 3
15515: PUSH
15516: LD_INT 1
15518: NEG
15519: GREATER
15520: PUSH
15521: LD_VAR 0 3
15525: PUSH
15526: LD_INT 3
15528: LESS
15529: AND
15530: IFFALSE 15587
// for i in result do
15532: LD_ADDR_VAR 0 5
15536: PUSH
15537: LD_VAR 0 4
15541: PUSH
15542: FOR_IN
15543: IFFALSE 15585
// if GetTech ( i , side ) <> state then
15545: LD_VAR 0 5
15549: PPUSH
15550: LD_VAR 0 1
15554: PPUSH
15555: CALL_OW 321
15559: PUSH
15560: LD_VAR 0 3
15564: NONEQUAL
15565: IFFALSE 15583
// result := result diff i ;
15567: LD_ADDR_VAR 0 4
15571: PUSH
15572: LD_VAR 0 4
15576: PUSH
15577: LD_VAR 0 5
15581: DIFF
15582: ST_TO_ADDR
15583: GO 15542
15585: POP
15586: POP
// end ;
15587: LD_VAR 0 4
15591: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15592: LD_INT 0
15594: PPUSH
15595: PPUSH
15596: PPUSH
// result := true ;
15597: LD_ADDR_VAR 0 3
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15605: LD_ADDR_VAR 0 5
15609: PUSH
15610: LD_VAR 0 2
15614: PPUSH
15615: CALL_OW 480
15619: ST_TO_ADDR
// if not tmp then
15620: LD_VAR 0 5
15624: NOT
15625: IFFALSE 15629
// exit ;
15627: GO 15678
// for i in tmp do
15629: LD_ADDR_VAR 0 4
15633: PUSH
15634: LD_VAR 0 5
15638: PUSH
15639: FOR_IN
15640: IFFALSE 15676
// if GetTech ( i , side ) <> state_researched then
15642: LD_VAR 0 4
15646: PPUSH
15647: LD_VAR 0 1
15651: PPUSH
15652: CALL_OW 321
15656: PUSH
15657: LD_INT 2
15659: NONEQUAL
15660: IFFALSE 15674
// begin result := false ;
15662: LD_ADDR_VAR 0 3
15666: PUSH
15667: LD_INT 0
15669: ST_TO_ADDR
// exit ;
15670: POP
15671: POP
15672: GO 15678
// end ;
15674: GO 15639
15676: POP
15677: POP
// end ;
15678: LD_VAR 0 3
15682: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15683: LD_INT 0
15685: PPUSH
15686: PPUSH
15687: PPUSH
15688: PPUSH
15689: PPUSH
15690: PPUSH
15691: PPUSH
15692: PPUSH
15693: PPUSH
15694: PPUSH
15695: PPUSH
15696: PPUSH
15697: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15698: LD_VAR 0 1
15702: NOT
15703: PUSH
15704: LD_VAR 0 1
15708: PPUSH
15709: CALL_OW 257
15713: PUSH
15714: LD_INT 9
15716: NONEQUAL
15717: OR
15718: IFFALSE 15722
// exit ;
15720: GO 16295
// side := GetSide ( unit ) ;
15722: LD_ADDR_VAR 0 9
15726: PUSH
15727: LD_VAR 0 1
15731: PPUSH
15732: CALL_OW 255
15736: ST_TO_ADDR
// tech_space := tech_spacanom ;
15737: LD_ADDR_VAR 0 12
15741: PUSH
15742: LD_INT 29
15744: ST_TO_ADDR
// tech_time := tech_taurad ;
15745: LD_ADDR_VAR 0 13
15749: PUSH
15750: LD_INT 28
15752: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15753: LD_ADDR_VAR 0 11
15757: PUSH
15758: LD_VAR 0 1
15762: PPUSH
15763: CALL_OW 310
15767: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15768: LD_VAR 0 11
15772: PPUSH
15773: CALL_OW 247
15777: PUSH
15778: LD_INT 2
15780: EQUAL
15781: IFFALSE 15785
// exit ;
15783: GO 16295
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15785: LD_ADDR_VAR 0 8
15789: PUSH
15790: LD_INT 81
15792: PUSH
15793: LD_VAR 0 9
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 3
15804: PUSH
15805: LD_INT 21
15807: PUSH
15808: LD_INT 3
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PPUSH
15823: CALL_OW 69
15827: ST_TO_ADDR
// if not tmp then
15828: LD_VAR 0 8
15832: NOT
15833: IFFALSE 15837
// exit ;
15835: GO 16295
// if in_unit then
15837: LD_VAR 0 11
15841: IFFALSE 15865
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15843: LD_ADDR_VAR 0 10
15847: PUSH
15848: LD_VAR 0 8
15852: PPUSH
15853: LD_VAR 0 11
15857: PPUSH
15858: CALL_OW 74
15862: ST_TO_ADDR
15863: GO 15885
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15865: LD_ADDR_VAR 0 10
15869: PUSH
15870: LD_VAR 0 8
15874: PPUSH
15875: LD_VAR 0 1
15879: PPUSH
15880: CALL_OW 74
15884: ST_TO_ADDR
// if not enemy then
15885: LD_VAR 0 10
15889: NOT
15890: IFFALSE 15894
// exit ;
15892: GO 16295
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15894: LD_VAR 0 11
15898: PUSH
15899: LD_VAR 0 11
15903: PPUSH
15904: LD_VAR 0 10
15908: PPUSH
15909: CALL_OW 296
15913: PUSH
15914: LD_INT 13
15916: GREATER
15917: AND
15918: PUSH
15919: LD_VAR 0 1
15923: PPUSH
15924: LD_VAR 0 10
15928: PPUSH
15929: CALL_OW 296
15933: PUSH
15934: LD_INT 12
15936: GREATER
15937: OR
15938: IFFALSE 15942
// exit ;
15940: GO 16295
// missile := [ 1 ] ;
15942: LD_ADDR_VAR 0 14
15946: PUSH
15947: LD_INT 1
15949: PUSH
15950: EMPTY
15951: LIST
15952: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15953: LD_VAR 0 9
15957: PPUSH
15958: LD_VAR 0 12
15962: PPUSH
15963: CALL_OW 325
15967: IFFALSE 15996
// missile := Insert ( missile , missile + 1 , 2 ) ;
15969: LD_ADDR_VAR 0 14
15973: PUSH
15974: LD_VAR 0 14
15978: PPUSH
15979: LD_VAR 0 14
15983: PUSH
15984: LD_INT 1
15986: PLUS
15987: PPUSH
15988: LD_INT 2
15990: PPUSH
15991: CALL_OW 2
15995: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15996: LD_VAR 0 9
16000: PPUSH
16001: LD_VAR 0 13
16005: PPUSH
16006: CALL_OW 325
16010: PUSH
16011: LD_VAR 0 10
16015: PPUSH
16016: CALL_OW 255
16020: PPUSH
16021: LD_VAR 0 13
16025: PPUSH
16026: CALL_OW 325
16030: NOT
16031: AND
16032: IFFALSE 16061
// missile := Insert ( missile , missile + 1 , 3 ) ;
16034: LD_ADDR_VAR 0 14
16038: PUSH
16039: LD_VAR 0 14
16043: PPUSH
16044: LD_VAR 0 14
16048: PUSH
16049: LD_INT 1
16051: PLUS
16052: PPUSH
16053: LD_INT 3
16055: PPUSH
16056: CALL_OW 2
16060: ST_TO_ADDR
// if missile < 2 then
16061: LD_VAR 0 14
16065: PUSH
16066: LD_INT 2
16068: LESS
16069: IFFALSE 16073
// exit ;
16071: GO 16295
// x := GetX ( enemy ) ;
16073: LD_ADDR_VAR 0 4
16077: PUSH
16078: LD_VAR 0 10
16082: PPUSH
16083: CALL_OW 250
16087: ST_TO_ADDR
// y := GetY ( enemy ) ;
16088: LD_ADDR_VAR 0 5
16092: PUSH
16093: LD_VAR 0 10
16097: PPUSH
16098: CALL_OW 251
16102: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16103: LD_ADDR_VAR 0 6
16107: PUSH
16108: LD_VAR 0 4
16112: PUSH
16113: LD_INT 1
16115: NEG
16116: PPUSH
16117: LD_INT 1
16119: PPUSH
16120: CALL_OW 12
16124: PLUS
16125: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16126: LD_ADDR_VAR 0 7
16130: PUSH
16131: LD_VAR 0 5
16135: PUSH
16136: LD_INT 1
16138: NEG
16139: PPUSH
16140: LD_INT 1
16142: PPUSH
16143: CALL_OW 12
16147: PLUS
16148: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16149: LD_VAR 0 6
16153: PPUSH
16154: LD_VAR 0 7
16158: PPUSH
16159: CALL_OW 488
16163: NOT
16164: IFFALSE 16186
// begin _x := x ;
16166: LD_ADDR_VAR 0 6
16170: PUSH
16171: LD_VAR 0 4
16175: ST_TO_ADDR
// _y := y ;
16176: LD_ADDR_VAR 0 7
16180: PUSH
16181: LD_VAR 0 5
16185: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16186: LD_ADDR_VAR 0 3
16190: PUSH
16191: LD_INT 1
16193: PPUSH
16194: LD_VAR 0 14
16198: PPUSH
16199: CALL_OW 12
16203: ST_TO_ADDR
// case i of 1 :
16204: LD_VAR 0 3
16208: PUSH
16209: LD_INT 1
16211: DOUBLE
16212: EQUAL
16213: IFTRUE 16217
16215: GO 16234
16217: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16218: LD_VAR 0 1
16222: PPUSH
16223: LD_VAR 0 10
16227: PPUSH
16228: CALL_OW 115
16232: GO 16295
16234: LD_INT 2
16236: DOUBLE
16237: EQUAL
16238: IFTRUE 16242
16240: GO 16264
16242: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16243: LD_VAR 0 1
16247: PPUSH
16248: LD_VAR 0 6
16252: PPUSH
16253: LD_VAR 0 7
16257: PPUSH
16258: CALL_OW 153
16262: GO 16295
16264: LD_INT 3
16266: DOUBLE
16267: EQUAL
16268: IFTRUE 16272
16270: GO 16294
16272: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16273: LD_VAR 0 1
16277: PPUSH
16278: LD_VAR 0 6
16282: PPUSH
16283: LD_VAR 0 7
16287: PPUSH
16288: CALL_OW 154
16292: GO 16295
16294: POP
// end ;
16295: LD_VAR 0 2
16299: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16300: LD_INT 0
16302: PPUSH
16303: PPUSH
16304: PPUSH
16305: PPUSH
16306: PPUSH
16307: PPUSH
// if not unit or not building then
16308: LD_VAR 0 1
16312: NOT
16313: PUSH
16314: LD_VAR 0 2
16318: NOT
16319: OR
16320: IFFALSE 16324
// exit ;
16322: GO 16482
// x := GetX ( building ) ;
16324: LD_ADDR_VAR 0 5
16328: PUSH
16329: LD_VAR 0 2
16333: PPUSH
16334: CALL_OW 250
16338: ST_TO_ADDR
// y := GetY ( building ) ;
16339: LD_ADDR_VAR 0 6
16343: PUSH
16344: LD_VAR 0 2
16348: PPUSH
16349: CALL_OW 251
16353: ST_TO_ADDR
// for i = 0 to 5 do
16354: LD_ADDR_VAR 0 4
16358: PUSH
16359: DOUBLE
16360: LD_INT 0
16362: DEC
16363: ST_TO_ADDR
16364: LD_INT 5
16366: PUSH
16367: FOR_TO
16368: IFFALSE 16480
// begin _x := ShiftX ( x , i , 3 ) ;
16370: LD_ADDR_VAR 0 7
16374: PUSH
16375: LD_VAR 0 5
16379: PPUSH
16380: LD_VAR 0 4
16384: PPUSH
16385: LD_INT 3
16387: PPUSH
16388: CALL_OW 272
16392: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16393: LD_ADDR_VAR 0 8
16397: PUSH
16398: LD_VAR 0 6
16402: PPUSH
16403: LD_VAR 0 4
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 273
16415: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16416: LD_VAR 0 7
16420: PPUSH
16421: LD_VAR 0 8
16425: PPUSH
16426: CALL_OW 488
16430: NOT
16431: IFFALSE 16435
// continue ;
16433: GO 16367
// if HexInfo ( _x , _y ) = 0 then
16435: LD_VAR 0 7
16439: PPUSH
16440: LD_VAR 0 8
16444: PPUSH
16445: CALL_OW 428
16449: PUSH
16450: LD_INT 0
16452: EQUAL
16453: IFFALSE 16478
// begin ComMoveXY ( unit , _x , _y ) ;
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PPUSH
16465: LD_VAR 0 8
16469: PPUSH
16470: CALL_OW 111
// exit ;
16474: POP
16475: POP
16476: GO 16482
// end ; end ;
16478: GO 16367
16480: POP
16481: POP
// end ;
16482: LD_VAR 0 3
16486: RET
// export function ScanBase ( side , base_area ) ; begin
16487: LD_INT 0
16489: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16490: LD_ADDR_VAR 0 3
16494: PUSH
16495: LD_VAR 0 2
16499: PPUSH
16500: LD_INT 81
16502: PUSH
16503: LD_VAR 0 1
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PPUSH
16512: CALL_OW 70
16516: ST_TO_ADDR
// end ;
16517: LD_VAR 0 3
16521: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16522: LD_INT 0
16524: PPUSH
16525: PPUSH
16526: PPUSH
16527: PPUSH
// result := false ;
16528: LD_ADDR_VAR 0 2
16532: PUSH
16533: LD_INT 0
16535: ST_TO_ADDR
// side := GetSide ( unit ) ;
16536: LD_ADDR_VAR 0 3
16540: PUSH
16541: LD_VAR 0 1
16545: PPUSH
16546: CALL_OW 255
16550: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16551: LD_ADDR_VAR 0 4
16555: PUSH
16556: LD_VAR 0 1
16560: PPUSH
16561: CALL_OW 248
16565: ST_TO_ADDR
// case nat of 1 :
16566: LD_VAR 0 4
16570: PUSH
16571: LD_INT 1
16573: DOUBLE
16574: EQUAL
16575: IFTRUE 16579
16577: GO 16590
16579: POP
// tech := tech_lassight ; 2 :
16580: LD_ADDR_VAR 0 5
16584: PUSH
16585: LD_INT 12
16587: ST_TO_ADDR
16588: GO 16629
16590: LD_INT 2
16592: DOUBLE
16593: EQUAL
16594: IFTRUE 16598
16596: GO 16609
16598: POP
// tech := tech_mortar ; 3 :
16599: LD_ADDR_VAR 0 5
16603: PUSH
16604: LD_INT 41
16606: ST_TO_ADDR
16607: GO 16629
16609: LD_INT 3
16611: DOUBLE
16612: EQUAL
16613: IFTRUE 16617
16615: GO 16628
16617: POP
// tech := tech_bazooka ; end ;
16618: LD_ADDR_VAR 0 5
16622: PUSH
16623: LD_INT 44
16625: ST_TO_ADDR
16626: GO 16629
16628: POP
// if Researched ( side , tech ) then
16629: LD_VAR 0 3
16633: PPUSH
16634: LD_VAR 0 5
16638: PPUSH
16639: CALL_OW 325
16643: IFFALSE 16670
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16645: LD_ADDR_VAR 0 2
16649: PUSH
16650: LD_INT 5
16652: PUSH
16653: LD_INT 8
16655: PUSH
16656: LD_INT 9
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: LIST
16663: PUSH
16664: LD_VAR 0 4
16668: ARRAY
16669: ST_TO_ADDR
// end ;
16670: LD_VAR 0 2
16674: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16675: LD_INT 0
16677: PPUSH
16678: PPUSH
16679: PPUSH
// if not mines then
16680: LD_VAR 0 2
16684: NOT
16685: IFFALSE 16689
// exit ;
16687: GO 16833
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16689: LD_ADDR_VAR 0 5
16693: PUSH
16694: LD_INT 81
16696: PUSH
16697: LD_VAR 0 1
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: PUSH
16706: LD_INT 3
16708: PUSH
16709: LD_INT 21
16711: PUSH
16712: LD_INT 3
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PPUSH
16727: CALL_OW 69
16731: ST_TO_ADDR
// for i in mines do
16732: LD_ADDR_VAR 0 4
16736: PUSH
16737: LD_VAR 0 2
16741: PUSH
16742: FOR_IN
16743: IFFALSE 16831
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16745: LD_VAR 0 4
16749: PUSH
16750: LD_INT 1
16752: ARRAY
16753: PPUSH
16754: LD_VAR 0 4
16758: PUSH
16759: LD_INT 2
16761: ARRAY
16762: PPUSH
16763: CALL_OW 458
16767: NOT
16768: IFFALSE 16772
// continue ;
16770: GO 16742
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16772: LD_VAR 0 4
16776: PUSH
16777: LD_INT 1
16779: ARRAY
16780: PPUSH
16781: LD_VAR 0 4
16785: PUSH
16786: LD_INT 2
16788: ARRAY
16789: PPUSH
16790: CALL_OW 428
16794: PUSH
16795: LD_VAR 0 5
16799: IN
16800: IFFALSE 16829
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16802: LD_VAR 0 4
16806: PUSH
16807: LD_INT 1
16809: ARRAY
16810: PPUSH
16811: LD_VAR 0 4
16815: PUSH
16816: LD_INT 2
16818: ARRAY
16819: PPUSH
16820: LD_VAR 0 1
16824: PPUSH
16825: CALL_OW 456
// end ;
16829: GO 16742
16831: POP
16832: POP
// end ;
16833: LD_VAR 0 3
16837: RET
// export function Count ( array ) ; var i ; begin
16838: LD_INT 0
16840: PPUSH
16841: PPUSH
// result := 0 ;
16842: LD_ADDR_VAR 0 2
16846: PUSH
16847: LD_INT 0
16849: ST_TO_ADDR
// for i in array do
16850: LD_ADDR_VAR 0 3
16854: PUSH
16855: LD_VAR 0 1
16859: PUSH
16860: FOR_IN
16861: IFFALSE 16885
// if i then
16863: LD_VAR 0 3
16867: IFFALSE 16883
// result := result + 1 ;
16869: LD_ADDR_VAR 0 2
16873: PUSH
16874: LD_VAR 0 2
16878: PUSH
16879: LD_INT 1
16881: PLUS
16882: ST_TO_ADDR
16883: GO 16860
16885: POP
16886: POP
// end ;
16887: LD_VAR 0 2
16891: RET
// export function IsEmpty ( building ) ; begin
16892: LD_INT 0
16894: PPUSH
// if not building then
16895: LD_VAR 0 1
16899: NOT
16900: IFFALSE 16904
// exit ;
16902: GO 16947
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16904: LD_ADDR_VAR 0 2
16908: PUSH
16909: LD_VAR 0 1
16913: PUSH
16914: LD_INT 22
16916: PUSH
16917: LD_VAR 0 1
16921: PPUSH
16922: CALL_OW 255
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 58
16933: PUSH
16934: EMPTY
16935: LIST
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PPUSH
16941: CALL_OW 69
16945: IN
16946: ST_TO_ADDR
// end ;
16947: LD_VAR 0 2
16951: RET
// export function IsNotFull ( building ) ; begin
16952: LD_INT 0
16954: PPUSH
// if not building then
16955: LD_VAR 0 1
16959: NOT
16960: IFFALSE 16964
// exit ;
16962: GO 16983
// result := UnitsInside ( building ) < 6 ;
16964: LD_ADDR_VAR 0 2
16968: PUSH
16969: LD_VAR 0 1
16973: PPUSH
16974: CALL_OW 313
16978: PUSH
16979: LD_INT 6
16981: LESS
16982: ST_TO_ADDR
// end ;
16983: LD_VAR 0 2
16987: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16988: LD_INT 0
16990: PPUSH
16991: PPUSH
16992: PPUSH
16993: PPUSH
// tmp := [ ] ;
16994: LD_ADDR_VAR 0 3
16998: PUSH
16999: EMPTY
17000: ST_TO_ADDR
// list := [ ] ;
17001: LD_ADDR_VAR 0 5
17005: PUSH
17006: EMPTY
17007: ST_TO_ADDR
// for i = 16 to 25 do
17008: LD_ADDR_VAR 0 4
17012: PUSH
17013: DOUBLE
17014: LD_INT 16
17016: DEC
17017: ST_TO_ADDR
17018: LD_INT 25
17020: PUSH
17021: FOR_TO
17022: IFFALSE 17095
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17024: LD_ADDR_VAR 0 3
17028: PUSH
17029: LD_VAR 0 3
17033: PUSH
17034: LD_INT 22
17036: PUSH
17037: LD_VAR 0 1
17041: PPUSH
17042: CALL_OW 255
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 91
17053: PUSH
17054: LD_VAR 0 1
17058: PUSH
17059: LD_INT 6
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: LIST
17066: PUSH
17067: LD_INT 30
17069: PUSH
17070: LD_VAR 0 4
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: LIST
17083: PUSH
17084: EMPTY
17085: LIST
17086: PPUSH
17087: CALL_OW 69
17091: ADD
17092: ST_TO_ADDR
17093: GO 17021
17095: POP
17096: POP
// for i = 1 to tmp do
17097: LD_ADDR_VAR 0 4
17101: PUSH
17102: DOUBLE
17103: LD_INT 1
17105: DEC
17106: ST_TO_ADDR
17107: LD_VAR 0 3
17111: PUSH
17112: FOR_TO
17113: IFFALSE 17201
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17115: LD_ADDR_VAR 0 5
17119: PUSH
17120: LD_VAR 0 5
17124: PUSH
17125: LD_VAR 0 3
17129: PUSH
17130: LD_VAR 0 4
17134: ARRAY
17135: PPUSH
17136: CALL_OW 266
17140: PUSH
17141: LD_VAR 0 3
17145: PUSH
17146: LD_VAR 0 4
17150: ARRAY
17151: PPUSH
17152: CALL_OW 250
17156: PUSH
17157: LD_VAR 0 3
17161: PUSH
17162: LD_VAR 0 4
17166: ARRAY
17167: PPUSH
17168: CALL_OW 251
17172: PUSH
17173: LD_VAR 0 3
17177: PUSH
17178: LD_VAR 0 4
17182: ARRAY
17183: PPUSH
17184: CALL_OW 254
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: ADD
17198: ST_TO_ADDR
17199: GO 17112
17201: POP
17202: POP
// result := list ;
17203: LD_ADDR_VAR 0 2
17207: PUSH
17208: LD_VAR 0 5
17212: ST_TO_ADDR
// end ;
17213: LD_VAR 0 2
17217: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17218: LD_INT 0
17220: PPUSH
17221: PPUSH
17222: PPUSH
17223: PPUSH
17224: PPUSH
17225: PPUSH
17226: PPUSH
// if not factory then
17227: LD_VAR 0 1
17231: NOT
17232: IFFALSE 17236
// exit ;
17234: GO 17829
// if control = control_apeman then
17236: LD_VAR 0 4
17240: PUSH
17241: LD_INT 5
17243: EQUAL
17244: IFFALSE 17353
// begin tmp := UnitsInside ( factory ) ;
17246: LD_ADDR_VAR 0 8
17250: PUSH
17251: LD_VAR 0 1
17255: PPUSH
17256: CALL_OW 313
17260: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17261: LD_VAR 0 8
17265: PPUSH
17266: LD_INT 25
17268: PUSH
17269: LD_INT 12
17271: PUSH
17272: EMPTY
17273: LIST
17274: LIST
17275: PPUSH
17276: CALL_OW 72
17280: NOT
17281: IFFALSE 17291
// control := control_manual ;
17283: LD_ADDR_VAR 0 4
17287: PUSH
17288: LD_INT 1
17290: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17291: LD_ADDR_VAR 0 8
17295: PUSH
17296: LD_VAR 0 1
17300: PPUSH
17301: CALL 16988 0 1
17305: ST_TO_ADDR
// if tmp then
17306: LD_VAR 0 8
17310: IFFALSE 17353
// begin for i in tmp do
17312: LD_ADDR_VAR 0 7
17316: PUSH
17317: LD_VAR 0 8
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17351
// if i [ 1 ] = b_ext_radio then
17325: LD_VAR 0 7
17329: PUSH
17330: LD_INT 1
17332: ARRAY
17333: PUSH
17334: LD_INT 22
17336: EQUAL
17337: IFFALSE 17349
// begin control := control_remote ;
17339: LD_ADDR_VAR 0 4
17343: PUSH
17344: LD_INT 2
17346: ST_TO_ADDR
// break ;
17347: GO 17351
// end ;
17349: GO 17322
17351: POP
17352: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17353: LD_VAR 0 1
17357: PPUSH
17358: LD_VAR 0 2
17362: PPUSH
17363: LD_VAR 0 3
17367: PPUSH
17368: LD_VAR 0 4
17372: PPUSH
17373: LD_VAR 0 5
17377: PPUSH
17378: CALL_OW 448
17382: IFFALSE 17417
// begin result := [ chassis , engine , control , weapon ] ;
17384: LD_ADDR_VAR 0 6
17388: PUSH
17389: LD_VAR 0 2
17393: PUSH
17394: LD_VAR 0 3
17398: PUSH
17399: LD_VAR 0 4
17403: PUSH
17404: LD_VAR 0 5
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: LIST
17413: LIST
17414: ST_TO_ADDR
// exit ;
17415: GO 17829
// end ; _chassis := AvailableChassisList ( factory ) ;
17417: LD_ADDR_VAR 0 9
17421: PUSH
17422: LD_VAR 0 1
17426: PPUSH
17427: CALL_OW 475
17431: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17432: LD_ADDR_VAR 0 11
17436: PUSH
17437: LD_VAR 0 1
17441: PPUSH
17442: CALL_OW 476
17446: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17447: LD_ADDR_VAR 0 12
17451: PUSH
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 477
17461: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17462: LD_ADDR_VAR 0 10
17466: PUSH
17467: LD_VAR 0 1
17471: PPUSH
17472: CALL_OW 478
17476: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17477: LD_VAR 0 9
17481: NOT
17482: PUSH
17483: LD_VAR 0 11
17487: NOT
17488: OR
17489: PUSH
17490: LD_VAR 0 12
17494: NOT
17495: OR
17496: PUSH
17497: LD_VAR 0 10
17501: NOT
17502: OR
17503: IFFALSE 17538
// begin result := [ chassis , engine , control , weapon ] ;
17505: LD_ADDR_VAR 0 6
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: LD_VAR 0 3
17519: PUSH
17520: LD_VAR 0 4
17524: PUSH
17525: LD_VAR 0 5
17529: PUSH
17530: EMPTY
17531: LIST
17532: LIST
17533: LIST
17534: LIST
17535: ST_TO_ADDR
// exit ;
17536: GO 17829
// end ; if not chassis in _chassis then
17538: LD_VAR 0 2
17542: PUSH
17543: LD_VAR 0 9
17547: IN
17548: NOT
17549: IFFALSE 17575
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17551: LD_ADDR_VAR 0 2
17555: PUSH
17556: LD_VAR 0 9
17560: PUSH
17561: LD_INT 1
17563: PPUSH
17564: LD_VAR 0 9
17568: PPUSH
17569: CALL_OW 12
17573: ARRAY
17574: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17575: LD_VAR 0 2
17579: PPUSH
17580: LD_VAR 0 3
17584: PPUSH
17585: CALL 17834 0 2
17589: NOT
17590: IFFALSE 17649
// repeat engine := _engine [ 1 ] ;
17592: LD_ADDR_VAR 0 3
17596: PUSH
17597: LD_VAR 0 11
17601: PUSH
17602: LD_INT 1
17604: ARRAY
17605: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17606: LD_ADDR_VAR 0 11
17610: PUSH
17611: LD_VAR 0 11
17615: PPUSH
17616: LD_INT 1
17618: PPUSH
17619: CALL_OW 3
17623: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17624: LD_VAR 0 2
17628: PPUSH
17629: LD_VAR 0 3
17633: PPUSH
17634: CALL 17834 0 2
17638: PUSH
17639: LD_VAR 0 11
17643: PUSH
17644: EMPTY
17645: EQUAL
17646: OR
17647: IFFALSE 17592
// if not control in _control then
17649: LD_VAR 0 4
17653: PUSH
17654: LD_VAR 0 12
17658: IN
17659: NOT
17660: IFFALSE 17686
// control := _control [ rand ( 1 , _control ) ] ;
17662: LD_ADDR_VAR 0 4
17666: PUSH
17667: LD_VAR 0 12
17671: PUSH
17672: LD_INT 1
17674: PPUSH
17675: LD_VAR 0 12
17679: PPUSH
17680: CALL_OW 12
17684: ARRAY
17685: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17686: LD_VAR 0 2
17690: PPUSH
17691: LD_VAR 0 5
17695: PPUSH
17696: CALL 18054 0 2
17700: NOT
17701: IFFALSE 17760
// repeat weapon := _weapon [ 1 ] ;
17703: LD_ADDR_VAR 0 5
17707: PUSH
17708: LD_VAR 0 10
17712: PUSH
17713: LD_INT 1
17715: ARRAY
17716: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17717: LD_ADDR_VAR 0 10
17721: PUSH
17722: LD_VAR 0 10
17726: PPUSH
17727: LD_INT 1
17729: PPUSH
17730: CALL_OW 3
17734: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17735: LD_VAR 0 2
17739: PPUSH
17740: LD_VAR 0 5
17744: PPUSH
17745: CALL 18054 0 2
17749: PUSH
17750: LD_VAR 0 10
17754: PUSH
17755: EMPTY
17756: EQUAL
17757: OR
17758: IFFALSE 17703
// result := [ ] ;
17760: LD_ADDR_VAR 0 6
17764: PUSH
17765: EMPTY
17766: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17767: LD_VAR 0 1
17771: PPUSH
17772: LD_VAR 0 2
17776: PPUSH
17777: LD_VAR 0 3
17781: PPUSH
17782: LD_VAR 0 4
17786: PPUSH
17787: LD_VAR 0 5
17791: PPUSH
17792: CALL_OW 448
17796: IFFALSE 17829
// result := [ chassis , engine , control , weapon ] ;
17798: LD_ADDR_VAR 0 6
17802: PUSH
17803: LD_VAR 0 2
17807: PUSH
17808: LD_VAR 0 3
17812: PUSH
17813: LD_VAR 0 4
17817: PUSH
17818: LD_VAR 0 5
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: LIST
17827: LIST
17828: ST_TO_ADDR
// end ;
17829: LD_VAR 0 6
17833: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17834: LD_INT 0
17836: PPUSH
// if not chassis or not engine then
17837: LD_VAR 0 1
17841: NOT
17842: PUSH
17843: LD_VAR 0 2
17847: NOT
17848: OR
17849: IFFALSE 17853
// exit ;
17851: GO 18049
// case engine of engine_solar :
17853: LD_VAR 0 2
17857: PUSH
17858: LD_INT 2
17860: DOUBLE
17861: EQUAL
17862: IFTRUE 17866
17864: GO 17904
17866: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17867: LD_ADDR_VAR 0 3
17871: PUSH
17872: LD_INT 11
17874: PUSH
17875: LD_INT 12
17877: PUSH
17878: LD_INT 13
17880: PUSH
17881: LD_INT 14
17883: PUSH
17884: LD_INT 1
17886: PUSH
17887: LD_INT 2
17889: PUSH
17890: LD_INT 3
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: ST_TO_ADDR
17902: GO 18033
17904: LD_INT 1
17906: DOUBLE
17907: EQUAL
17908: IFTRUE 17912
17910: GO 17974
17912: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17913: LD_ADDR_VAR 0 3
17917: PUSH
17918: LD_INT 11
17920: PUSH
17921: LD_INT 12
17923: PUSH
17924: LD_INT 13
17926: PUSH
17927: LD_INT 14
17929: PUSH
17930: LD_INT 1
17932: PUSH
17933: LD_INT 2
17935: PUSH
17936: LD_INT 3
17938: PUSH
17939: LD_INT 4
17941: PUSH
17942: LD_INT 5
17944: PUSH
17945: LD_INT 21
17947: PUSH
17948: LD_INT 23
17950: PUSH
17951: LD_INT 22
17953: PUSH
17954: LD_INT 24
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: LIST
17964: LIST
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: LIST
17971: ST_TO_ADDR
17972: GO 18033
17974: LD_INT 3
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 18032
17982: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17983: LD_ADDR_VAR 0 3
17987: PUSH
17988: LD_INT 13
17990: PUSH
17991: LD_INT 14
17993: PUSH
17994: LD_INT 2
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 4
18002: PUSH
18003: LD_INT 5
18005: PUSH
18006: LD_INT 21
18008: PUSH
18009: LD_INT 22
18011: PUSH
18012: LD_INT 23
18014: PUSH
18015: LD_INT 24
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: ST_TO_ADDR
18030: GO 18033
18032: POP
// result := ( chassis in result ) ;
18033: LD_ADDR_VAR 0 3
18037: PUSH
18038: LD_VAR 0 1
18042: PUSH
18043: LD_VAR 0 3
18047: IN
18048: ST_TO_ADDR
// end ;
18049: LD_VAR 0 3
18053: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18054: LD_INT 0
18056: PPUSH
// if not chassis or not weapon then
18057: LD_VAR 0 1
18061: NOT
18062: PUSH
18063: LD_VAR 0 2
18067: NOT
18068: OR
18069: IFFALSE 18073
// exit ;
18071: GO 19099
// case weapon of us_machine_gun :
18073: LD_VAR 0 2
18077: PUSH
18078: LD_INT 2
18080: DOUBLE
18081: EQUAL
18082: IFTRUE 18086
18084: GO 18116
18086: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18087: LD_ADDR_VAR 0 3
18091: PUSH
18092: LD_INT 1
18094: PUSH
18095: LD_INT 2
18097: PUSH
18098: LD_INT 3
18100: PUSH
18101: LD_INT 4
18103: PUSH
18104: LD_INT 5
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: ST_TO_ADDR
18114: GO 19083
18116: LD_INT 3
18118: DOUBLE
18119: EQUAL
18120: IFTRUE 18124
18122: GO 18154
18124: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18125: LD_ADDR_VAR 0 3
18129: PUSH
18130: LD_INT 1
18132: PUSH
18133: LD_INT 2
18135: PUSH
18136: LD_INT 3
18138: PUSH
18139: LD_INT 4
18141: PUSH
18142: LD_INT 5
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: LIST
18151: ST_TO_ADDR
18152: GO 19083
18154: LD_INT 11
18156: DOUBLE
18157: EQUAL
18158: IFTRUE 18162
18160: GO 18192
18162: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18163: LD_ADDR_VAR 0 3
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: LD_INT 2
18173: PUSH
18174: LD_INT 3
18176: PUSH
18177: LD_INT 4
18179: PUSH
18180: LD_INT 5
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: LIST
18187: LIST
18188: LIST
18189: ST_TO_ADDR
18190: GO 19083
18192: LD_INT 4
18194: DOUBLE
18195: EQUAL
18196: IFTRUE 18200
18198: GO 18226
18200: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18201: LD_ADDR_VAR 0 3
18205: PUSH
18206: LD_INT 2
18208: PUSH
18209: LD_INT 3
18211: PUSH
18212: LD_INT 4
18214: PUSH
18215: LD_INT 5
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: ST_TO_ADDR
18224: GO 19083
18226: LD_INT 5
18228: DOUBLE
18229: EQUAL
18230: IFTRUE 18234
18232: GO 18260
18234: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 2
18242: PUSH
18243: LD_INT 3
18245: PUSH
18246: LD_INT 4
18248: PUSH
18249: LD_INT 5
18251: PUSH
18252: EMPTY
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: ST_TO_ADDR
18258: GO 19083
18260: LD_INT 9
18262: DOUBLE
18263: EQUAL
18264: IFTRUE 18268
18266: GO 18294
18268: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18269: LD_ADDR_VAR 0 3
18273: PUSH
18274: LD_INT 2
18276: PUSH
18277: LD_INT 3
18279: PUSH
18280: LD_INT 4
18282: PUSH
18283: LD_INT 5
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: ST_TO_ADDR
18292: GO 19083
18294: LD_INT 7
18296: DOUBLE
18297: EQUAL
18298: IFTRUE 18302
18300: GO 18328
18302: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18303: LD_ADDR_VAR 0 3
18307: PUSH
18308: LD_INT 2
18310: PUSH
18311: LD_INT 3
18313: PUSH
18314: LD_INT 4
18316: PUSH
18317: LD_INT 5
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: ST_TO_ADDR
18326: GO 19083
18328: LD_INT 12
18330: DOUBLE
18331: EQUAL
18332: IFTRUE 18336
18334: GO 18362
18336: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 2
18344: PUSH
18345: LD_INT 3
18347: PUSH
18348: LD_INT 4
18350: PUSH
18351: LD_INT 5
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: LIST
18358: LIST
18359: ST_TO_ADDR
18360: GO 19083
18362: LD_INT 13
18364: DOUBLE
18365: EQUAL
18366: IFTRUE 18370
18368: GO 18396
18370: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: LD_INT 4
18384: PUSH
18385: LD_INT 5
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: ST_TO_ADDR
18394: GO 19083
18396: LD_INT 14
18398: DOUBLE
18399: EQUAL
18400: IFTRUE 18404
18402: GO 18422
18404: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18405: LD_ADDR_VAR 0 3
18409: PUSH
18410: LD_INT 4
18412: PUSH
18413: LD_INT 5
18415: PUSH
18416: EMPTY
18417: LIST
18418: LIST
18419: ST_TO_ADDR
18420: GO 19083
18422: LD_INT 6
18424: DOUBLE
18425: EQUAL
18426: IFTRUE 18430
18428: GO 18448
18430: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18431: LD_ADDR_VAR 0 3
18435: PUSH
18436: LD_INT 4
18438: PUSH
18439: LD_INT 5
18441: PUSH
18442: EMPTY
18443: LIST
18444: LIST
18445: ST_TO_ADDR
18446: GO 19083
18448: LD_INT 10
18450: DOUBLE
18451: EQUAL
18452: IFTRUE 18456
18454: GO 18474
18456: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18457: LD_ADDR_VAR 0 3
18461: PUSH
18462: LD_INT 4
18464: PUSH
18465: LD_INT 5
18467: PUSH
18468: EMPTY
18469: LIST
18470: LIST
18471: ST_TO_ADDR
18472: GO 19083
18474: LD_INT 22
18476: DOUBLE
18477: EQUAL
18478: IFTRUE 18482
18480: GO 18508
18482: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18483: LD_ADDR_VAR 0 3
18487: PUSH
18488: LD_INT 11
18490: PUSH
18491: LD_INT 12
18493: PUSH
18494: LD_INT 13
18496: PUSH
18497: LD_INT 14
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: ST_TO_ADDR
18506: GO 19083
18508: LD_INT 23
18510: DOUBLE
18511: EQUAL
18512: IFTRUE 18516
18514: GO 18542
18516: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18517: LD_ADDR_VAR 0 3
18521: PUSH
18522: LD_INT 11
18524: PUSH
18525: LD_INT 12
18527: PUSH
18528: LD_INT 13
18530: PUSH
18531: LD_INT 14
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: ST_TO_ADDR
18540: GO 19083
18542: LD_INT 24
18544: DOUBLE
18545: EQUAL
18546: IFTRUE 18550
18548: GO 18576
18550: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18551: LD_ADDR_VAR 0 3
18555: PUSH
18556: LD_INT 11
18558: PUSH
18559: LD_INT 12
18561: PUSH
18562: LD_INT 13
18564: PUSH
18565: LD_INT 14
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: ST_TO_ADDR
18574: GO 19083
18576: LD_INT 30
18578: DOUBLE
18579: EQUAL
18580: IFTRUE 18584
18582: GO 18610
18584: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_INT 11
18592: PUSH
18593: LD_INT 12
18595: PUSH
18596: LD_INT 13
18598: PUSH
18599: LD_INT 14
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: ST_TO_ADDR
18608: GO 19083
18610: LD_INT 25
18612: DOUBLE
18613: EQUAL
18614: IFTRUE 18618
18616: GO 18636
18618: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_INT 13
18626: PUSH
18627: LD_INT 14
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: ST_TO_ADDR
18634: GO 19083
18636: LD_INT 27
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18662
18644: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18645: LD_ADDR_VAR 0 3
18649: PUSH
18650: LD_INT 13
18652: PUSH
18653: LD_INT 14
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: ST_TO_ADDR
18660: GO 19083
18662: LD_INT 28
18664: DOUBLE
18665: EQUAL
18666: IFTRUE 18670
18668: GO 18688
18670: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: LD_INT 13
18678: PUSH
18679: LD_INT 14
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: ST_TO_ADDR
18686: GO 19083
18688: LD_INT 29
18690: DOUBLE
18691: EQUAL
18692: IFTRUE 18696
18694: GO 18714
18696: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18697: LD_ADDR_VAR 0 3
18701: PUSH
18702: LD_INT 13
18704: PUSH
18705: LD_INT 14
18707: PUSH
18708: EMPTY
18709: LIST
18710: LIST
18711: ST_TO_ADDR
18712: GO 19083
18714: LD_INT 31
18716: DOUBLE
18717: EQUAL
18718: IFTRUE 18722
18720: GO 18740
18722: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18723: LD_ADDR_VAR 0 3
18727: PUSH
18728: LD_INT 13
18730: PUSH
18731: LD_INT 14
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: ST_TO_ADDR
18738: GO 19083
18740: LD_INT 26
18742: DOUBLE
18743: EQUAL
18744: IFTRUE 18748
18746: GO 18766
18748: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18749: LD_ADDR_VAR 0 3
18753: PUSH
18754: LD_INT 13
18756: PUSH
18757: LD_INT 14
18759: PUSH
18760: EMPTY
18761: LIST
18762: LIST
18763: ST_TO_ADDR
18764: GO 19083
18766: LD_INT 42
18768: DOUBLE
18769: EQUAL
18770: IFTRUE 18774
18772: GO 18800
18774: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_INT 21
18782: PUSH
18783: LD_INT 22
18785: PUSH
18786: LD_INT 23
18788: PUSH
18789: LD_INT 24
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: LIST
18796: LIST
18797: ST_TO_ADDR
18798: GO 19083
18800: LD_INT 43
18802: DOUBLE
18803: EQUAL
18804: IFTRUE 18808
18806: GO 18834
18808: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18809: LD_ADDR_VAR 0 3
18813: PUSH
18814: LD_INT 21
18816: PUSH
18817: LD_INT 22
18819: PUSH
18820: LD_INT 23
18822: PUSH
18823: LD_INT 24
18825: PUSH
18826: EMPTY
18827: LIST
18828: LIST
18829: LIST
18830: LIST
18831: ST_TO_ADDR
18832: GO 19083
18834: LD_INT 44
18836: DOUBLE
18837: EQUAL
18838: IFTRUE 18842
18840: GO 18868
18842: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18843: LD_ADDR_VAR 0 3
18847: PUSH
18848: LD_INT 21
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 23
18856: PUSH
18857: LD_INT 24
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: LIST
18864: LIST
18865: ST_TO_ADDR
18866: GO 19083
18868: LD_INT 45
18870: DOUBLE
18871: EQUAL
18872: IFTRUE 18876
18874: GO 18902
18876: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18877: LD_ADDR_VAR 0 3
18881: PUSH
18882: LD_INT 21
18884: PUSH
18885: LD_INT 22
18887: PUSH
18888: LD_INT 23
18890: PUSH
18891: LD_INT 24
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: LIST
18898: LIST
18899: ST_TO_ADDR
18900: GO 19083
18902: LD_INT 49
18904: DOUBLE
18905: EQUAL
18906: IFTRUE 18910
18908: GO 18936
18910: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18911: LD_ADDR_VAR 0 3
18915: PUSH
18916: LD_INT 21
18918: PUSH
18919: LD_INT 22
18921: PUSH
18922: LD_INT 23
18924: PUSH
18925: LD_INT 24
18927: PUSH
18928: EMPTY
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: ST_TO_ADDR
18934: GO 19083
18936: LD_INT 51
18938: DOUBLE
18939: EQUAL
18940: IFTRUE 18944
18942: GO 18970
18944: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18945: LD_ADDR_VAR 0 3
18949: PUSH
18950: LD_INT 21
18952: PUSH
18953: LD_INT 22
18955: PUSH
18956: LD_INT 23
18958: PUSH
18959: LD_INT 24
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: LIST
18966: LIST
18967: ST_TO_ADDR
18968: GO 19083
18970: LD_INT 52
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19004
18978: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18979: LD_ADDR_VAR 0 3
18983: PUSH
18984: LD_INT 21
18986: PUSH
18987: LD_INT 22
18989: PUSH
18990: LD_INT 23
18992: PUSH
18993: LD_INT 24
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: LIST
19000: LIST
19001: ST_TO_ADDR
19002: GO 19083
19004: LD_INT 53
19006: DOUBLE
19007: EQUAL
19008: IFTRUE 19012
19010: GO 19030
19012: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19013: LD_ADDR_VAR 0 3
19017: PUSH
19018: LD_INT 23
19020: PUSH
19021: LD_INT 24
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: ST_TO_ADDR
19028: GO 19083
19030: LD_INT 46
19032: DOUBLE
19033: EQUAL
19034: IFTRUE 19038
19036: GO 19056
19038: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19039: LD_ADDR_VAR 0 3
19043: PUSH
19044: LD_INT 23
19046: PUSH
19047: LD_INT 24
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: ST_TO_ADDR
19054: GO 19083
19056: LD_INT 47
19058: DOUBLE
19059: EQUAL
19060: IFTRUE 19064
19062: GO 19082
19064: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19065: LD_ADDR_VAR 0 3
19069: PUSH
19070: LD_INT 23
19072: PUSH
19073: LD_INT 24
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: ST_TO_ADDR
19080: GO 19083
19082: POP
// result := ( chassis in result ) ;
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_VAR 0 1
19092: PUSH
19093: LD_VAR 0 3
19097: IN
19098: ST_TO_ADDR
// end ;
19099: LD_VAR 0 3
19103: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19104: LD_INT 0
19106: PPUSH
19107: PPUSH
19108: PPUSH
19109: PPUSH
19110: PPUSH
19111: PPUSH
19112: PPUSH
// result := array ;
19113: LD_ADDR_VAR 0 5
19117: PUSH
19118: LD_VAR 0 1
19122: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19123: LD_VAR 0 1
19127: NOT
19128: PUSH
19129: LD_VAR 0 2
19133: NOT
19134: OR
19135: PUSH
19136: LD_VAR 0 3
19140: NOT
19141: OR
19142: PUSH
19143: LD_VAR 0 2
19147: PUSH
19148: LD_VAR 0 1
19152: GREATER
19153: OR
19154: PUSH
19155: LD_VAR 0 3
19159: PUSH
19160: LD_VAR 0 1
19164: GREATER
19165: OR
19166: IFFALSE 19170
// exit ;
19168: GO 19466
// if direction then
19170: LD_VAR 0 4
19174: IFFALSE 19238
// begin d := 1 ;
19176: LD_ADDR_VAR 0 9
19180: PUSH
19181: LD_INT 1
19183: ST_TO_ADDR
// if i_from > i_to then
19184: LD_VAR 0 2
19188: PUSH
19189: LD_VAR 0 3
19193: GREATER
19194: IFFALSE 19220
// length := ( array - i_from ) + i_to else
19196: LD_ADDR_VAR 0 11
19200: PUSH
19201: LD_VAR 0 1
19205: PUSH
19206: LD_VAR 0 2
19210: MINUS
19211: PUSH
19212: LD_VAR 0 3
19216: PLUS
19217: ST_TO_ADDR
19218: GO 19236
// length := i_to - i_from ;
19220: LD_ADDR_VAR 0 11
19224: PUSH
19225: LD_VAR 0 3
19229: PUSH
19230: LD_VAR 0 2
19234: MINUS
19235: ST_TO_ADDR
// end else
19236: GO 19299
// begin d := - 1 ;
19238: LD_ADDR_VAR 0 9
19242: PUSH
19243: LD_INT 1
19245: NEG
19246: ST_TO_ADDR
// if i_from > i_to then
19247: LD_VAR 0 2
19251: PUSH
19252: LD_VAR 0 3
19256: GREATER
19257: IFFALSE 19277
// length := i_from - i_to else
19259: LD_ADDR_VAR 0 11
19263: PUSH
19264: LD_VAR 0 2
19268: PUSH
19269: LD_VAR 0 3
19273: MINUS
19274: ST_TO_ADDR
19275: GO 19299
// length := ( array - i_to ) + i_from ;
19277: LD_ADDR_VAR 0 11
19281: PUSH
19282: LD_VAR 0 1
19286: PUSH
19287: LD_VAR 0 3
19291: MINUS
19292: PUSH
19293: LD_VAR 0 2
19297: PLUS
19298: ST_TO_ADDR
// end ; if not length then
19299: LD_VAR 0 11
19303: NOT
19304: IFFALSE 19308
// exit ;
19306: GO 19466
// tmp := array ;
19308: LD_ADDR_VAR 0 10
19312: PUSH
19313: LD_VAR 0 1
19317: ST_TO_ADDR
// for i = 1 to length do
19318: LD_ADDR_VAR 0 6
19322: PUSH
19323: DOUBLE
19324: LD_INT 1
19326: DEC
19327: ST_TO_ADDR
19328: LD_VAR 0 11
19332: PUSH
19333: FOR_TO
19334: IFFALSE 19454
// begin for j = 1 to array do
19336: LD_ADDR_VAR 0 7
19340: PUSH
19341: DOUBLE
19342: LD_INT 1
19344: DEC
19345: ST_TO_ADDR
19346: LD_VAR 0 1
19350: PUSH
19351: FOR_TO
19352: IFFALSE 19440
// begin k := j + d ;
19354: LD_ADDR_VAR 0 8
19358: PUSH
19359: LD_VAR 0 7
19363: PUSH
19364: LD_VAR 0 9
19368: PLUS
19369: ST_TO_ADDR
// if k > array then
19370: LD_VAR 0 8
19374: PUSH
19375: LD_VAR 0 1
19379: GREATER
19380: IFFALSE 19390
// k := 1 ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_INT 1
19389: ST_TO_ADDR
// if not k then
19390: LD_VAR 0 8
19394: NOT
19395: IFFALSE 19407
// k := array ;
19397: LD_ADDR_VAR 0 8
19401: PUSH
19402: LD_VAR 0 1
19406: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19407: LD_ADDR_VAR 0 10
19411: PUSH
19412: LD_VAR 0 10
19416: PPUSH
19417: LD_VAR 0 8
19421: PPUSH
19422: LD_VAR 0 1
19426: PUSH
19427: LD_VAR 0 7
19431: ARRAY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// end ;
19438: GO 19351
19440: POP
19441: POP
// array := tmp ;
19442: LD_ADDR_VAR 0 1
19446: PUSH
19447: LD_VAR 0 10
19451: ST_TO_ADDR
// end ;
19452: GO 19333
19454: POP
19455: POP
// result := array ;
19456: LD_ADDR_VAR 0 5
19460: PUSH
19461: LD_VAR 0 1
19465: ST_TO_ADDR
// end ;
19466: LD_VAR 0 5
19470: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19471: LD_INT 0
19473: PPUSH
19474: PPUSH
// result := 0 ;
19475: LD_ADDR_VAR 0 3
19479: PUSH
19480: LD_INT 0
19482: ST_TO_ADDR
// if not array or not value in array then
19483: LD_VAR 0 1
19487: NOT
19488: PUSH
19489: LD_VAR 0 2
19493: PUSH
19494: LD_VAR 0 1
19498: IN
19499: NOT
19500: OR
19501: IFFALSE 19505
// exit ;
19503: GO 19559
// for i = 1 to array do
19505: LD_ADDR_VAR 0 4
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_VAR 0 1
19519: PUSH
19520: FOR_TO
19521: IFFALSE 19557
// if value = array [ i ] then
19523: LD_VAR 0 2
19527: PUSH
19528: LD_VAR 0 1
19532: PUSH
19533: LD_VAR 0 4
19537: ARRAY
19538: EQUAL
19539: IFFALSE 19555
// begin result := i ;
19541: LD_ADDR_VAR 0 3
19545: PUSH
19546: LD_VAR 0 4
19550: ST_TO_ADDR
// exit ;
19551: POP
19552: POP
19553: GO 19559
// end ;
19555: GO 19520
19557: POP
19558: POP
// end ;
19559: LD_VAR 0 3
19563: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19564: LD_INT 0
19566: PPUSH
// vc_chassis := chassis ;
19567: LD_ADDR_OWVAR 37
19571: PUSH
19572: LD_VAR 0 1
19576: ST_TO_ADDR
// vc_engine := engine ;
19577: LD_ADDR_OWVAR 39
19581: PUSH
19582: LD_VAR 0 2
19586: ST_TO_ADDR
// vc_control := control ;
19587: LD_ADDR_OWVAR 38
19591: PUSH
19592: LD_VAR 0 3
19596: ST_TO_ADDR
// vc_weapon := weapon ;
19597: LD_ADDR_OWVAR 40
19601: PUSH
19602: LD_VAR 0 4
19606: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19607: LD_ADDR_OWVAR 41
19611: PUSH
19612: LD_VAR 0 5
19616: ST_TO_ADDR
// end ;
19617: LD_VAR 0 6
19621: RET
// export function WantPlant ( unit ) ; var task ; begin
19622: LD_INT 0
19624: PPUSH
19625: PPUSH
// result := false ;
19626: LD_ADDR_VAR 0 2
19630: PUSH
19631: LD_INT 0
19633: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19634: LD_ADDR_VAR 0 3
19638: PUSH
19639: LD_VAR 0 1
19643: PPUSH
19644: CALL_OW 437
19648: ST_TO_ADDR
// if task then
19649: LD_VAR 0 3
19653: IFFALSE 19681
// if task [ 1 ] [ 1 ] = p then
19655: LD_VAR 0 3
19659: PUSH
19660: LD_INT 1
19662: ARRAY
19663: PUSH
19664: LD_INT 1
19666: ARRAY
19667: PUSH
19668: LD_STRING p
19670: EQUAL
19671: IFFALSE 19681
// result := true ;
19673: LD_ADDR_VAR 0 2
19677: PUSH
19678: LD_INT 1
19680: ST_TO_ADDR
// end ;
19681: LD_VAR 0 2
19685: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19686: LD_INT 0
19688: PPUSH
19689: PPUSH
19690: PPUSH
19691: PPUSH
// if pos < 1 then
19692: LD_VAR 0 2
19696: PUSH
19697: LD_INT 1
19699: LESS
19700: IFFALSE 19704
// exit ;
19702: GO 20007
// if pos = 1 then
19704: LD_VAR 0 2
19708: PUSH
19709: LD_INT 1
19711: EQUAL
19712: IFFALSE 19745
// result := Replace ( arr , pos [ 1 ] , value ) else
19714: LD_ADDR_VAR 0 4
19718: PUSH
19719: LD_VAR 0 1
19723: PPUSH
19724: LD_VAR 0 2
19728: PUSH
19729: LD_INT 1
19731: ARRAY
19732: PPUSH
19733: LD_VAR 0 3
19737: PPUSH
19738: CALL_OW 1
19742: ST_TO_ADDR
19743: GO 20007
// begin tmp := arr ;
19745: LD_ADDR_VAR 0 6
19749: PUSH
19750: LD_VAR 0 1
19754: ST_TO_ADDR
// s_arr := [ tmp ] ;
19755: LD_ADDR_VAR 0 7
19759: PUSH
19760: LD_VAR 0 6
19764: PUSH
19765: EMPTY
19766: LIST
19767: ST_TO_ADDR
// for i = 1 to pos - 1 do
19768: LD_ADDR_VAR 0 5
19772: PUSH
19773: DOUBLE
19774: LD_INT 1
19776: DEC
19777: ST_TO_ADDR
19778: LD_VAR 0 2
19782: PUSH
19783: LD_INT 1
19785: MINUS
19786: PUSH
19787: FOR_TO
19788: IFFALSE 19833
// begin tmp := tmp [ pos [ i ] ] ;
19790: LD_ADDR_VAR 0 6
19794: PUSH
19795: LD_VAR 0 6
19799: PUSH
19800: LD_VAR 0 2
19804: PUSH
19805: LD_VAR 0 5
19809: ARRAY
19810: ARRAY
19811: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19812: LD_ADDR_VAR 0 7
19816: PUSH
19817: LD_VAR 0 7
19821: PUSH
19822: LD_VAR 0 6
19826: PUSH
19827: EMPTY
19828: LIST
19829: ADD
19830: ST_TO_ADDR
// end ;
19831: GO 19787
19833: POP
19834: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19835: LD_ADDR_VAR 0 6
19839: PUSH
19840: LD_VAR 0 6
19844: PPUSH
19845: LD_VAR 0 2
19849: PUSH
19850: LD_VAR 0 2
19854: ARRAY
19855: PPUSH
19856: LD_VAR 0 3
19860: PPUSH
19861: CALL_OW 1
19865: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19866: LD_ADDR_VAR 0 7
19870: PUSH
19871: LD_VAR 0 7
19875: PPUSH
19876: LD_VAR 0 7
19880: PPUSH
19881: LD_VAR 0 6
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// for i = s_arr downto 2 do
19891: LD_ADDR_VAR 0 5
19895: PUSH
19896: DOUBLE
19897: LD_VAR 0 7
19901: INC
19902: ST_TO_ADDR
19903: LD_INT 2
19905: PUSH
19906: FOR_DOWNTO
19907: IFFALSE 19991
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19909: LD_ADDR_VAR 0 6
19913: PUSH
19914: LD_VAR 0 7
19918: PUSH
19919: LD_VAR 0 5
19923: PUSH
19924: LD_INT 1
19926: MINUS
19927: ARRAY
19928: PPUSH
19929: LD_VAR 0 2
19933: PUSH
19934: LD_VAR 0 5
19938: PUSH
19939: LD_INT 1
19941: MINUS
19942: ARRAY
19943: PPUSH
19944: LD_VAR 0 7
19948: PUSH
19949: LD_VAR 0 5
19953: ARRAY
19954: PPUSH
19955: CALL_OW 1
19959: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19960: LD_ADDR_VAR 0 7
19964: PUSH
19965: LD_VAR 0 7
19969: PPUSH
19970: LD_VAR 0 5
19974: PUSH
19975: LD_INT 1
19977: MINUS
19978: PPUSH
19979: LD_VAR 0 6
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// end ;
19989: GO 19906
19991: POP
19992: POP
// result := s_arr [ 1 ] ;
19993: LD_ADDR_VAR 0 4
19997: PUSH
19998: LD_VAR 0 7
20002: PUSH
20003: LD_INT 1
20005: ARRAY
20006: ST_TO_ADDR
// end ; end ;
20007: LD_VAR 0 4
20011: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20012: LD_INT 0
20014: PPUSH
20015: PPUSH
// if not list then
20016: LD_VAR 0 1
20020: NOT
20021: IFFALSE 20025
// exit ;
20023: GO 20116
// i := list [ pos1 ] ;
20025: LD_ADDR_VAR 0 5
20029: PUSH
20030: LD_VAR 0 1
20034: PUSH
20035: LD_VAR 0 2
20039: ARRAY
20040: ST_TO_ADDR
// if not i then
20041: LD_VAR 0 5
20045: NOT
20046: IFFALSE 20050
// exit ;
20048: GO 20116
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20050: LD_ADDR_VAR 0 1
20054: PUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: LD_VAR 0 2
20064: PPUSH
20065: LD_VAR 0 1
20069: PUSH
20070: LD_VAR 0 3
20074: ARRAY
20075: PPUSH
20076: CALL_OW 1
20080: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20081: LD_ADDR_VAR 0 1
20085: PUSH
20086: LD_VAR 0 1
20090: PPUSH
20091: LD_VAR 0 3
20095: PPUSH
20096: LD_VAR 0 5
20100: PPUSH
20101: CALL_OW 1
20105: ST_TO_ADDR
// result := list ;
20106: LD_ADDR_VAR 0 4
20110: PUSH
20111: LD_VAR 0 1
20115: ST_TO_ADDR
// end ;
20116: LD_VAR 0 4
20120: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20121: LD_INT 0
20123: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20124: LD_ADDR_VAR 0 5
20128: PUSH
20129: LD_VAR 0 1
20133: PPUSH
20134: CALL_OW 250
20138: PPUSH
20139: LD_VAR 0 1
20143: PPUSH
20144: CALL_OW 251
20148: PPUSH
20149: LD_VAR 0 2
20153: PPUSH
20154: LD_VAR 0 3
20158: PPUSH
20159: LD_VAR 0 4
20163: PPUSH
20164: CALL 20174 0 5
20168: ST_TO_ADDR
// end ;
20169: LD_VAR 0 5
20173: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20174: LD_INT 0
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
// if not list then
20180: LD_VAR 0 3
20184: NOT
20185: IFFALSE 20189
// exit ;
20187: GO 20577
// result := [ ] ;
20189: LD_ADDR_VAR 0 6
20193: PUSH
20194: EMPTY
20195: ST_TO_ADDR
// for i in list do
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: LD_VAR 0 3
20205: PUSH
20206: FOR_IN
20207: IFFALSE 20409
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20209: LD_ADDR_VAR 0 9
20213: PUSH
20214: LD_VAR 0 7
20218: PPUSH
20219: LD_VAR 0 1
20223: PPUSH
20224: LD_VAR 0 2
20228: PPUSH
20229: CALL_OW 297
20233: ST_TO_ADDR
// if not result then
20234: LD_VAR 0 6
20238: NOT
20239: IFFALSE 20265
// result := [ [ i , tmp ] ] else
20241: LD_ADDR_VAR 0 6
20245: PUSH
20246: LD_VAR 0 7
20250: PUSH
20251: LD_VAR 0 9
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PUSH
20260: EMPTY
20261: LIST
20262: ST_TO_ADDR
20263: GO 20407
// begin if result [ result ] [ 2 ] < tmp then
20265: LD_VAR 0 6
20269: PUSH
20270: LD_VAR 0 6
20274: ARRAY
20275: PUSH
20276: LD_INT 2
20278: ARRAY
20279: PUSH
20280: LD_VAR 0 9
20284: LESS
20285: IFFALSE 20327
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20287: LD_ADDR_VAR 0 6
20291: PUSH
20292: LD_VAR 0 6
20296: PPUSH
20297: LD_VAR 0 6
20301: PUSH
20302: LD_INT 1
20304: PLUS
20305: PPUSH
20306: LD_VAR 0 7
20310: PUSH
20311: LD_VAR 0 9
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: PPUSH
20320: CALL_OW 2
20324: ST_TO_ADDR
20325: GO 20407
// for j = 1 to result do
20327: LD_ADDR_VAR 0 8
20331: PUSH
20332: DOUBLE
20333: LD_INT 1
20335: DEC
20336: ST_TO_ADDR
20337: LD_VAR 0 6
20341: PUSH
20342: FOR_TO
20343: IFFALSE 20405
// begin if tmp < result [ j ] [ 2 ] then
20345: LD_VAR 0 9
20349: PUSH
20350: LD_VAR 0 6
20354: PUSH
20355: LD_VAR 0 8
20359: ARRAY
20360: PUSH
20361: LD_INT 2
20363: ARRAY
20364: LESS
20365: IFFALSE 20403
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20367: LD_ADDR_VAR 0 6
20371: PUSH
20372: LD_VAR 0 6
20376: PPUSH
20377: LD_VAR 0 8
20381: PPUSH
20382: LD_VAR 0 7
20386: PUSH
20387: LD_VAR 0 9
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PPUSH
20396: CALL_OW 2
20400: ST_TO_ADDR
// break ;
20401: GO 20405
// end ; end ;
20403: GO 20342
20405: POP
20406: POP
// end ; end ;
20407: GO 20206
20409: POP
20410: POP
// if result and not asc then
20411: LD_VAR 0 6
20415: PUSH
20416: LD_VAR 0 4
20420: NOT
20421: AND
20422: IFFALSE 20497
// begin tmp := result ;
20424: LD_ADDR_VAR 0 9
20428: PUSH
20429: LD_VAR 0 6
20433: ST_TO_ADDR
// for i = tmp downto 1 do
20434: LD_ADDR_VAR 0 7
20438: PUSH
20439: DOUBLE
20440: LD_VAR 0 9
20444: INC
20445: ST_TO_ADDR
20446: LD_INT 1
20448: PUSH
20449: FOR_DOWNTO
20450: IFFALSE 20495
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20452: LD_ADDR_VAR 0 6
20456: PUSH
20457: LD_VAR 0 6
20461: PPUSH
20462: LD_VAR 0 9
20466: PUSH
20467: LD_VAR 0 7
20471: MINUS
20472: PUSH
20473: LD_INT 1
20475: PLUS
20476: PPUSH
20477: LD_VAR 0 9
20481: PUSH
20482: LD_VAR 0 7
20486: ARRAY
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
20493: GO 20449
20495: POP
20496: POP
// end ; tmp := [ ] ;
20497: LD_ADDR_VAR 0 9
20501: PUSH
20502: EMPTY
20503: ST_TO_ADDR
// if mode then
20504: LD_VAR 0 5
20508: IFFALSE 20577
// begin for i = 1 to result do
20510: LD_ADDR_VAR 0 7
20514: PUSH
20515: DOUBLE
20516: LD_INT 1
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 6
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20565
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20528: LD_ADDR_VAR 0 9
20532: PUSH
20533: LD_VAR 0 9
20537: PPUSH
20538: LD_VAR 0 7
20542: PPUSH
20543: LD_VAR 0 6
20547: PUSH
20548: LD_VAR 0 7
20552: ARRAY
20553: PUSH
20554: LD_INT 1
20556: ARRAY
20557: PPUSH
20558: CALL_OW 1
20562: ST_TO_ADDR
20563: GO 20525
20565: POP
20566: POP
// result := tmp ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 9
20576: ST_TO_ADDR
// end ; end ;
20577: LD_VAR 0 6
20581: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20582: LD_INT 0
20584: PPUSH
20585: PPUSH
20586: PPUSH
20587: PPUSH
20588: PPUSH
20589: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: LD_INT 0
20597: PUSH
20598: LD_INT 0
20600: PUSH
20601: LD_INT 0
20603: PUSH
20604: EMPTY
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: ST_TO_ADDR
// if not x or not y then
20612: LD_VAR 0 2
20616: NOT
20617: PUSH
20618: LD_VAR 0 3
20622: NOT
20623: OR
20624: IFFALSE 20628
// exit ;
20626: GO 22274
// if not range then
20628: LD_VAR 0 4
20632: NOT
20633: IFFALSE 20643
// range := 10 ;
20635: LD_ADDR_VAR 0 4
20639: PUSH
20640: LD_INT 10
20642: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20643: LD_ADDR_VAR 0 8
20647: PUSH
20648: LD_INT 81
20650: PUSH
20651: LD_VAR 0 1
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: PUSH
20660: LD_INT 92
20662: PUSH
20663: LD_VAR 0 2
20667: PUSH
20668: LD_VAR 0 3
20672: PUSH
20673: LD_VAR 0 4
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: LIST
20682: LIST
20683: PUSH
20684: LD_INT 3
20686: PUSH
20687: LD_INT 21
20689: PUSH
20690: LD_INT 3
20692: PUSH
20693: EMPTY
20694: LIST
20695: LIST
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: LIST
20705: PPUSH
20706: CALL_OW 69
20710: ST_TO_ADDR
// if not tmp then
20711: LD_VAR 0 8
20715: NOT
20716: IFFALSE 20720
// exit ;
20718: GO 22274
// for i in tmp do
20720: LD_ADDR_VAR 0 6
20724: PUSH
20725: LD_VAR 0 8
20729: PUSH
20730: FOR_IN
20731: IFFALSE 22249
// begin points := [ 0 , 0 , 0 ] ;
20733: LD_ADDR_VAR 0 9
20737: PUSH
20738: LD_INT 0
20740: PUSH
20741: LD_INT 0
20743: PUSH
20744: LD_INT 0
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: ST_TO_ADDR
// bpoints := 1 ;
20752: LD_ADDR_VAR 0 10
20756: PUSH
20757: LD_INT 1
20759: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20760: LD_VAR 0 6
20764: PPUSH
20765: CALL_OW 247
20769: PUSH
20770: LD_INT 1
20772: DOUBLE
20773: EQUAL
20774: IFTRUE 20778
20776: GO 21356
20778: POP
// begin if GetClass ( i ) = 1 then
20779: LD_VAR 0 6
20783: PPUSH
20784: CALL_OW 257
20788: PUSH
20789: LD_INT 1
20791: EQUAL
20792: IFFALSE 20813
// points := [ 10 , 5 , 3 ] ;
20794: LD_ADDR_VAR 0 9
20798: PUSH
20799: LD_INT 10
20801: PUSH
20802: LD_INT 5
20804: PUSH
20805: LD_INT 3
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: LIST
20812: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20813: LD_VAR 0 6
20817: PPUSH
20818: CALL_OW 257
20822: PUSH
20823: LD_INT 2
20825: PUSH
20826: LD_INT 3
20828: PUSH
20829: LD_INT 4
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: LIST
20836: IN
20837: IFFALSE 20858
// points := [ 3 , 2 , 1 ] ;
20839: LD_ADDR_VAR 0 9
20843: PUSH
20844: LD_INT 3
20846: PUSH
20847: LD_INT 2
20849: PUSH
20850: LD_INT 1
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: LIST
20857: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20858: LD_VAR 0 6
20862: PPUSH
20863: CALL_OW 257
20867: PUSH
20868: LD_INT 5
20870: EQUAL
20871: IFFALSE 20892
// points := [ 130 , 5 , 2 ] ;
20873: LD_ADDR_VAR 0 9
20877: PUSH
20878: LD_INT 130
20880: PUSH
20881: LD_INT 5
20883: PUSH
20884: LD_INT 2
20886: PUSH
20887: EMPTY
20888: LIST
20889: LIST
20890: LIST
20891: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20892: LD_VAR 0 6
20896: PPUSH
20897: CALL_OW 257
20901: PUSH
20902: LD_INT 8
20904: EQUAL
20905: IFFALSE 20926
// points := [ 35 , 35 , 30 ] ;
20907: LD_ADDR_VAR 0 9
20911: PUSH
20912: LD_INT 35
20914: PUSH
20915: LD_INT 35
20917: PUSH
20918: LD_INT 30
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: LIST
20925: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20926: LD_VAR 0 6
20930: PPUSH
20931: CALL_OW 257
20935: PUSH
20936: LD_INT 9
20938: EQUAL
20939: IFFALSE 20960
// points := [ 20 , 55 , 40 ] ;
20941: LD_ADDR_VAR 0 9
20945: PUSH
20946: LD_INT 20
20948: PUSH
20949: LD_INT 55
20951: PUSH
20952: LD_INT 40
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: LIST
20959: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20960: LD_VAR 0 6
20964: PPUSH
20965: CALL_OW 257
20969: PUSH
20970: LD_INT 12
20972: PUSH
20973: LD_INT 16
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: IN
20980: IFFALSE 21001
// points := [ 5 , 3 , 2 ] ;
20982: LD_ADDR_VAR 0 9
20986: PUSH
20987: LD_INT 5
20989: PUSH
20990: LD_INT 3
20992: PUSH
20993: LD_INT 2
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: LIST
21000: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21001: LD_VAR 0 6
21005: PPUSH
21006: CALL_OW 257
21010: PUSH
21011: LD_INT 17
21013: EQUAL
21014: IFFALSE 21035
// points := [ 100 , 50 , 75 ] ;
21016: LD_ADDR_VAR 0 9
21020: PUSH
21021: LD_INT 100
21023: PUSH
21024: LD_INT 50
21026: PUSH
21027: LD_INT 75
21029: PUSH
21030: EMPTY
21031: LIST
21032: LIST
21033: LIST
21034: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21035: LD_VAR 0 6
21039: PPUSH
21040: CALL_OW 257
21044: PUSH
21045: LD_INT 15
21047: EQUAL
21048: IFFALSE 21069
// points := [ 10 , 5 , 3 ] ;
21050: LD_ADDR_VAR 0 9
21054: PUSH
21055: LD_INT 10
21057: PUSH
21058: LD_INT 5
21060: PUSH
21061: LD_INT 3
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: LIST
21068: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21069: LD_VAR 0 6
21073: PPUSH
21074: CALL_OW 257
21078: PUSH
21079: LD_INT 14
21081: EQUAL
21082: IFFALSE 21103
// points := [ 10 , 0 , 0 ] ;
21084: LD_ADDR_VAR 0 9
21088: PUSH
21089: LD_INT 10
21091: PUSH
21092: LD_INT 0
21094: PUSH
21095: LD_INT 0
21097: PUSH
21098: EMPTY
21099: LIST
21100: LIST
21101: LIST
21102: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21103: LD_VAR 0 6
21107: PPUSH
21108: CALL_OW 257
21112: PUSH
21113: LD_INT 11
21115: EQUAL
21116: IFFALSE 21137
// points := [ 30 , 10 , 5 ] ;
21118: LD_ADDR_VAR 0 9
21122: PUSH
21123: LD_INT 30
21125: PUSH
21126: LD_INT 10
21128: PUSH
21129: LD_INT 5
21131: PUSH
21132: EMPTY
21133: LIST
21134: LIST
21135: LIST
21136: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21137: LD_VAR 0 1
21141: PPUSH
21142: LD_INT 5
21144: PPUSH
21145: CALL_OW 321
21149: PUSH
21150: LD_INT 2
21152: EQUAL
21153: IFFALSE 21170
// bpoints := bpoints * 1.8 ;
21155: LD_ADDR_VAR 0 10
21159: PUSH
21160: LD_VAR 0 10
21164: PUSH
21165: LD_REAL  1.80000000000000E+0000
21168: MUL
21169: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21170: LD_VAR 0 6
21174: PPUSH
21175: CALL_OW 257
21179: PUSH
21180: LD_INT 1
21182: PUSH
21183: LD_INT 2
21185: PUSH
21186: LD_INT 3
21188: PUSH
21189: LD_INT 4
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: LIST
21196: LIST
21197: IN
21198: PUSH
21199: LD_VAR 0 1
21203: PPUSH
21204: LD_INT 51
21206: PPUSH
21207: CALL_OW 321
21211: PUSH
21212: LD_INT 2
21214: EQUAL
21215: AND
21216: IFFALSE 21233
// bpoints := bpoints * 1.2 ;
21218: LD_ADDR_VAR 0 10
21222: PUSH
21223: LD_VAR 0 10
21227: PUSH
21228: LD_REAL  1.20000000000000E+0000
21231: MUL
21232: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21233: LD_VAR 0 6
21237: PPUSH
21238: CALL_OW 257
21242: PUSH
21243: LD_INT 5
21245: PUSH
21246: LD_INT 7
21248: PUSH
21249: LD_INT 9
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: LIST
21256: IN
21257: PUSH
21258: LD_VAR 0 1
21262: PPUSH
21263: LD_INT 52
21265: PPUSH
21266: CALL_OW 321
21270: PUSH
21271: LD_INT 2
21273: EQUAL
21274: AND
21275: IFFALSE 21292
// bpoints := bpoints * 1.5 ;
21277: LD_ADDR_VAR 0 10
21281: PUSH
21282: LD_VAR 0 10
21286: PUSH
21287: LD_REAL  1.50000000000000E+0000
21290: MUL
21291: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21292: LD_VAR 0 1
21296: PPUSH
21297: LD_INT 66
21299: PPUSH
21300: CALL_OW 321
21304: PUSH
21305: LD_INT 2
21307: EQUAL
21308: IFFALSE 21325
// bpoints := bpoints * 1.1 ;
21310: LD_ADDR_VAR 0 10
21314: PUSH
21315: LD_VAR 0 10
21319: PUSH
21320: LD_REAL  1.10000000000000E+0000
21323: MUL
21324: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21325: LD_ADDR_VAR 0 10
21329: PUSH
21330: LD_VAR 0 10
21334: PUSH
21335: LD_VAR 0 6
21339: PPUSH
21340: LD_INT 1
21342: PPUSH
21343: CALL_OW 259
21347: PUSH
21348: LD_REAL  1.15000000000000E+0000
21351: MUL
21352: MUL
21353: ST_TO_ADDR
// end ; unit_vehicle :
21354: GO 22178
21356: LD_INT 2
21358: DOUBLE
21359: EQUAL
21360: IFTRUE 21364
21362: GO 22166
21364: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21365: LD_VAR 0 6
21369: PPUSH
21370: CALL_OW 264
21374: PUSH
21375: LD_INT 2
21377: PUSH
21378: LD_INT 42
21380: PUSH
21381: LD_INT 24
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: LIST
21388: IN
21389: IFFALSE 21410
// points := [ 25 , 5 , 3 ] ;
21391: LD_ADDR_VAR 0 9
21395: PUSH
21396: LD_INT 25
21398: PUSH
21399: LD_INT 5
21401: PUSH
21402: LD_INT 3
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: LIST
21409: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21410: LD_VAR 0 6
21414: PPUSH
21415: CALL_OW 264
21419: PUSH
21420: LD_INT 4
21422: PUSH
21423: LD_INT 43
21425: PUSH
21426: LD_INT 25
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: LIST
21433: IN
21434: IFFALSE 21455
// points := [ 40 , 15 , 5 ] ;
21436: LD_ADDR_VAR 0 9
21440: PUSH
21441: LD_INT 40
21443: PUSH
21444: LD_INT 15
21446: PUSH
21447: LD_INT 5
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: LIST
21454: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21455: LD_VAR 0 6
21459: PPUSH
21460: CALL_OW 264
21464: PUSH
21465: LD_INT 3
21467: PUSH
21468: LD_INT 23
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: IN
21475: IFFALSE 21496
// points := [ 7 , 25 , 8 ] ;
21477: LD_ADDR_VAR 0 9
21481: PUSH
21482: LD_INT 7
21484: PUSH
21485: LD_INT 25
21487: PUSH
21488: LD_INT 8
21490: PUSH
21491: EMPTY
21492: LIST
21493: LIST
21494: LIST
21495: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21496: LD_VAR 0 6
21500: PPUSH
21501: CALL_OW 264
21505: PUSH
21506: LD_INT 5
21508: PUSH
21509: LD_INT 27
21511: PUSH
21512: LD_INT 44
21514: PUSH
21515: EMPTY
21516: LIST
21517: LIST
21518: LIST
21519: IN
21520: IFFALSE 21541
// points := [ 14 , 50 , 16 ] ;
21522: LD_ADDR_VAR 0 9
21526: PUSH
21527: LD_INT 14
21529: PUSH
21530: LD_INT 50
21532: PUSH
21533: LD_INT 16
21535: PUSH
21536: EMPTY
21537: LIST
21538: LIST
21539: LIST
21540: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21541: LD_VAR 0 6
21545: PPUSH
21546: CALL_OW 264
21550: PUSH
21551: LD_INT 6
21553: PUSH
21554: LD_INT 46
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: IN
21561: IFFALSE 21582
// points := [ 32 , 120 , 70 ] ;
21563: LD_ADDR_VAR 0 9
21567: PUSH
21568: LD_INT 32
21570: PUSH
21571: LD_INT 120
21573: PUSH
21574: LD_INT 70
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: LIST
21581: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21582: LD_VAR 0 6
21586: PPUSH
21587: CALL_OW 264
21591: PUSH
21592: LD_INT 7
21594: PUSH
21595: LD_INT 28
21597: PUSH
21598: LD_INT 45
21600: PUSH
21601: EMPTY
21602: LIST
21603: LIST
21604: LIST
21605: IN
21606: IFFALSE 21627
// points := [ 35 , 20 , 45 ] ;
21608: LD_ADDR_VAR 0 9
21612: PUSH
21613: LD_INT 35
21615: PUSH
21616: LD_INT 20
21618: PUSH
21619: LD_INT 45
21621: PUSH
21622: EMPTY
21623: LIST
21624: LIST
21625: LIST
21626: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21627: LD_VAR 0 6
21631: PPUSH
21632: CALL_OW 264
21636: PUSH
21637: LD_INT 47
21639: PUSH
21640: EMPTY
21641: LIST
21642: IN
21643: IFFALSE 21664
// points := [ 67 , 45 , 75 ] ;
21645: LD_ADDR_VAR 0 9
21649: PUSH
21650: LD_INT 67
21652: PUSH
21653: LD_INT 45
21655: PUSH
21656: LD_INT 75
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21664: LD_VAR 0 6
21668: PPUSH
21669: CALL_OW 264
21673: PUSH
21674: LD_INT 26
21676: PUSH
21677: EMPTY
21678: LIST
21679: IN
21680: IFFALSE 21701
// points := [ 120 , 30 , 80 ] ;
21682: LD_ADDR_VAR 0 9
21686: PUSH
21687: LD_INT 120
21689: PUSH
21690: LD_INT 30
21692: PUSH
21693: LD_INT 80
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: LIST
21700: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21701: LD_VAR 0 6
21705: PPUSH
21706: CALL_OW 264
21710: PUSH
21711: LD_INT 22
21713: PUSH
21714: EMPTY
21715: LIST
21716: IN
21717: IFFALSE 21738
// points := [ 40 , 1 , 1 ] ;
21719: LD_ADDR_VAR 0 9
21723: PUSH
21724: LD_INT 40
21726: PUSH
21727: LD_INT 1
21729: PUSH
21730: LD_INT 1
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: LIST
21737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21738: LD_VAR 0 6
21742: PPUSH
21743: CALL_OW 264
21747: PUSH
21748: LD_INT 29
21750: PUSH
21751: EMPTY
21752: LIST
21753: IN
21754: IFFALSE 21775
// points := [ 70 , 200 , 400 ] ;
21756: LD_ADDR_VAR 0 9
21760: PUSH
21761: LD_INT 70
21763: PUSH
21764: LD_INT 200
21766: PUSH
21767: LD_INT 400
21769: PUSH
21770: EMPTY
21771: LIST
21772: LIST
21773: LIST
21774: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21775: LD_VAR 0 6
21779: PPUSH
21780: CALL_OW 264
21784: PUSH
21785: LD_INT 14
21787: PUSH
21788: LD_INT 53
21790: PUSH
21791: EMPTY
21792: LIST
21793: LIST
21794: IN
21795: IFFALSE 21816
// points := [ 40 , 10 , 20 ] ;
21797: LD_ADDR_VAR 0 9
21801: PUSH
21802: LD_INT 40
21804: PUSH
21805: LD_INT 10
21807: PUSH
21808: LD_INT 20
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21816: LD_VAR 0 6
21820: PPUSH
21821: CALL_OW 264
21825: PUSH
21826: LD_INT 9
21828: PUSH
21829: EMPTY
21830: LIST
21831: IN
21832: IFFALSE 21853
// points := [ 5 , 70 , 20 ] ;
21834: LD_ADDR_VAR 0 9
21838: PUSH
21839: LD_INT 5
21841: PUSH
21842: LD_INT 70
21844: PUSH
21845: LD_INT 20
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: LIST
21852: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21853: LD_VAR 0 6
21857: PPUSH
21858: CALL_OW 264
21862: PUSH
21863: LD_INT 10
21865: PUSH
21866: EMPTY
21867: LIST
21868: IN
21869: IFFALSE 21890
// points := [ 35 , 110 , 70 ] ;
21871: LD_ADDR_VAR 0 9
21875: PUSH
21876: LD_INT 35
21878: PUSH
21879: LD_INT 110
21881: PUSH
21882: LD_INT 70
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: LIST
21889: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21890: LD_VAR 0 6
21894: PPUSH
21895: CALL_OW 265
21899: PUSH
21900: LD_INT 25
21902: EQUAL
21903: IFFALSE 21924
// points := [ 80 , 65 , 100 ] ;
21905: LD_ADDR_VAR 0 9
21909: PUSH
21910: LD_INT 80
21912: PUSH
21913: LD_INT 65
21915: PUSH
21916: LD_INT 100
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: LIST
21923: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21924: LD_VAR 0 6
21928: PPUSH
21929: CALL_OW 263
21933: PUSH
21934: LD_INT 1
21936: EQUAL
21937: IFFALSE 21972
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21939: LD_ADDR_VAR 0 10
21943: PUSH
21944: LD_VAR 0 10
21948: PUSH
21949: LD_VAR 0 6
21953: PPUSH
21954: CALL_OW 311
21958: PPUSH
21959: LD_INT 3
21961: PPUSH
21962: CALL_OW 259
21966: PUSH
21967: LD_INT 4
21969: MUL
21970: MUL
21971: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21972: LD_VAR 0 6
21976: PPUSH
21977: CALL_OW 263
21981: PUSH
21982: LD_INT 2
21984: EQUAL
21985: IFFALSE 22036
// begin j := IsControledBy ( i ) ;
21987: LD_ADDR_VAR 0 7
21991: PUSH
21992: LD_VAR 0 6
21996: PPUSH
21997: CALL_OW 312
22001: ST_TO_ADDR
// if j then
22002: LD_VAR 0 7
22006: IFFALSE 22036
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22008: LD_ADDR_VAR 0 10
22012: PUSH
22013: LD_VAR 0 10
22017: PUSH
22018: LD_VAR 0 7
22022: PPUSH
22023: LD_INT 3
22025: PPUSH
22026: CALL_OW 259
22030: PUSH
22031: LD_INT 3
22033: MUL
22034: MUL
22035: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22036: LD_VAR 0 6
22040: PPUSH
22041: CALL_OW 264
22045: PUSH
22046: LD_INT 5
22048: PUSH
22049: LD_INT 6
22051: PUSH
22052: LD_INT 46
22054: PUSH
22055: LD_INT 44
22057: PUSH
22058: LD_INT 47
22060: PUSH
22061: LD_INT 45
22063: PUSH
22064: LD_INT 28
22066: PUSH
22067: LD_INT 7
22069: PUSH
22070: LD_INT 27
22072: PUSH
22073: LD_INT 29
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: LIST
22080: LIST
22081: LIST
22082: LIST
22083: LIST
22084: LIST
22085: LIST
22086: LIST
22087: IN
22088: PUSH
22089: LD_VAR 0 1
22093: PPUSH
22094: LD_INT 52
22096: PPUSH
22097: CALL_OW 321
22101: PUSH
22102: LD_INT 2
22104: EQUAL
22105: AND
22106: IFFALSE 22123
// bpoints := bpoints * 1.2 ;
22108: LD_ADDR_VAR 0 10
22112: PUSH
22113: LD_VAR 0 10
22117: PUSH
22118: LD_REAL  1.20000000000000E+0000
22121: MUL
22122: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22123: LD_VAR 0 6
22127: PPUSH
22128: CALL_OW 264
22132: PUSH
22133: LD_INT 6
22135: PUSH
22136: LD_INT 46
22138: PUSH
22139: LD_INT 47
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: LIST
22146: IN
22147: IFFALSE 22164
// bpoints := bpoints * 1.2 ;
22149: LD_ADDR_VAR 0 10
22153: PUSH
22154: LD_VAR 0 10
22158: PUSH
22159: LD_REAL  1.20000000000000E+0000
22162: MUL
22163: ST_TO_ADDR
// end ; unit_building :
22164: GO 22178
22166: LD_INT 3
22168: DOUBLE
22169: EQUAL
22170: IFTRUE 22174
22172: GO 22177
22174: POP
// ; end ;
22175: GO 22178
22177: POP
// for j = 1 to 3 do
22178: LD_ADDR_VAR 0 7
22182: PUSH
22183: DOUBLE
22184: LD_INT 1
22186: DEC
22187: ST_TO_ADDR
22188: LD_INT 3
22190: PUSH
22191: FOR_TO
22192: IFFALSE 22245
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22194: LD_ADDR_VAR 0 5
22198: PUSH
22199: LD_VAR 0 5
22203: PPUSH
22204: LD_VAR 0 7
22208: PPUSH
22209: LD_VAR 0 5
22213: PUSH
22214: LD_VAR 0 7
22218: ARRAY
22219: PUSH
22220: LD_VAR 0 9
22224: PUSH
22225: LD_VAR 0 7
22229: ARRAY
22230: PUSH
22231: LD_VAR 0 10
22235: MUL
22236: PLUS
22237: PPUSH
22238: CALL_OW 1
22242: ST_TO_ADDR
22243: GO 22191
22245: POP
22246: POP
// end ;
22247: GO 20730
22249: POP
22250: POP
// result := Replace ( result , 4 , tmp ) ;
22251: LD_ADDR_VAR 0 5
22255: PUSH
22256: LD_VAR 0 5
22260: PPUSH
22261: LD_INT 4
22263: PPUSH
22264: LD_VAR 0 8
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// end ;
22274: LD_VAR 0 5
22278: RET
// export function DangerAtRange ( unit , range ) ; begin
22279: LD_INT 0
22281: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22282: LD_ADDR_VAR 0 3
22286: PUSH
22287: LD_VAR 0 1
22291: PPUSH
22292: CALL_OW 255
22296: PPUSH
22297: LD_VAR 0 1
22301: PPUSH
22302: CALL_OW 250
22306: PPUSH
22307: LD_VAR 0 1
22311: PPUSH
22312: CALL_OW 251
22316: PPUSH
22317: LD_VAR 0 2
22321: PPUSH
22322: CALL 20582 0 4
22326: ST_TO_ADDR
// end ;
22327: LD_VAR 0 3
22331: RET
// export function DangerInArea ( side , area ) ; begin
22332: LD_INT 0
22334: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22335: LD_ADDR_VAR 0 3
22339: PUSH
22340: LD_VAR 0 2
22344: PPUSH
22345: LD_INT 81
22347: PUSH
22348: LD_VAR 0 1
22352: PUSH
22353: EMPTY
22354: LIST
22355: LIST
22356: PPUSH
22357: CALL_OW 70
22361: ST_TO_ADDR
// end ;
22362: LD_VAR 0 3
22366: RET
// export function IsExtension ( b ) ; begin
22367: LD_INT 0
22369: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22370: LD_ADDR_VAR 0 2
22374: PUSH
22375: LD_VAR 0 1
22379: PUSH
22380: LD_INT 23
22382: PUSH
22383: LD_INT 20
22385: PUSH
22386: LD_INT 22
22388: PUSH
22389: LD_INT 17
22391: PUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 21
22397: PUSH
22398: LD_INT 19
22400: PUSH
22401: LD_INT 16
22403: PUSH
22404: LD_INT 25
22406: PUSH
22407: LD_INT 18
22409: PUSH
22410: EMPTY
22411: LIST
22412: LIST
22413: LIST
22414: LIST
22415: LIST
22416: LIST
22417: LIST
22418: LIST
22419: LIST
22420: LIST
22421: IN
22422: ST_TO_ADDR
// end ;
22423: LD_VAR 0 2
22427: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22428: LD_INT 0
22430: PPUSH
22431: PPUSH
22432: PPUSH
// result := [ ] ;
22433: LD_ADDR_VAR 0 4
22437: PUSH
22438: EMPTY
22439: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22440: LD_ADDR_VAR 0 5
22444: PUSH
22445: LD_VAR 0 2
22449: PPUSH
22450: LD_INT 21
22452: PUSH
22453: LD_INT 3
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: PPUSH
22460: CALL_OW 70
22464: ST_TO_ADDR
// if not tmp then
22465: LD_VAR 0 5
22469: NOT
22470: IFFALSE 22474
// exit ;
22472: GO 22538
// if checkLink then
22474: LD_VAR 0 3
22478: IFFALSE 22528
// begin for i in tmp do
22480: LD_ADDR_VAR 0 6
22484: PUSH
22485: LD_VAR 0 5
22489: PUSH
22490: FOR_IN
22491: IFFALSE 22526
// if GetBase ( i ) <> base then
22493: LD_VAR 0 6
22497: PPUSH
22498: CALL_OW 274
22502: PUSH
22503: LD_VAR 0 1
22507: NONEQUAL
22508: IFFALSE 22524
// ComLinkToBase ( base , i ) ;
22510: LD_VAR 0 1
22514: PPUSH
22515: LD_VAR 0 6
22519: PPUSH
22520: CALL_OW 169
22524: GO 22490
22526: POP
22527: POP
// end ; result := tmp ;
22528: LD_ADDR_VAR 0 4
22532: PUSH
22533: LD_VAR 0 5
22537: ST_TO_ADDR
// end ;
22538: LD_VAR 0 4
22542: RET
// export function ComComplete ( units , b ) ; var i ; begin
22543: LD_INT 0
22545: PPUSH
22546: PPUSH
// if not units then
22547: LD_VAR 0 1
22551: NOT
22552: IFFALSE 22556
// exit ;
22554: GO 22646
// for i in units do
22556: LD_ADDR_VAR 0 4
22560: PUSH
22561: LD_VAR 0 1
22565: PUSH
22566: FOR_IN
22567: IFFALSE 22644
// if BuildingStatus ( b ) = bs_build then
22569: LD_VAR 0 2
22573: PPUSH
22574: CALL_OW 461
22578: PUSH
22579: LD_INT 1
22581: EQUAL
22582: IFFALSE 22642
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22584: LD_VAR 0 4
22588: PPUSH
22589: LD_STRING h
22591: PUSH
22592: LD_VAR 0 2
22596: PPUSH
22597: CALL_OW 250
22601: PUSH
22602: LD_VAR 0 2
22606: PPUSH
22607: CALL_OW 251
22611: PUSH
22612: LD_VAR 0 2
22616: PUSH
22617: LD_INT 0
22619: PUSH
22620: LD_INT 0
22622: PUSH
22623: LD_INT 0
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: LIST
22630: LIST
22631: LIST
22632: LIST
22633: LIST
22634: PUSH
22635: EMPTY
22636: LIST
22637: PPUSH
22638: CALL_OW 446
22642: GO 22566
22644: POP
22645: POP
// end ;
22646: LD_VAR 0 3
22650: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22651: LD_INT 0
22653: PPUSH
22654: PPUSH
22655: PPUSH
22656: PPUSH
22657: PPUSH
22658: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22659: LD_VAR 0 1
22663: NOT
22664: PUSH
22665: LD_VAR 0 1
22669: PPUSH
22670: CALL_OW 263
22674: PUSH
22675: LD_INT 2
22677: EQUAL
22678: NOT
22679: OR
22680: IFFALSE 22684
// exit ;
22682: GO 23000
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22684: LD_ADDR_VAR 0 6
22688: PUSH
22689: LD_INT 22
22691: PUSH
22692: LD_VAR 0 1
22696: PPUSH
22697: CALL_OW 255
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: PUSH
22706: LD_INT 2
22708: PUSH
22709: LD_INT 30
22711: PUSH
22712: LD_INT 36
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PUSH
22719: LD_INT 34
22721: PUSH
22722: LD_INT 31
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: EMPTY
22730: LIST
22731: LIST
22732: LIST
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: PPUSH
22738: CALL_OW 69
22742: ST_TO_ADDR
// if not tmp then
22743: LD_VAR 0 6
22747: NOT
22748: IFFALSE 22752
// exit ;
22750: GO 23000
// result := [ ] ;
22752: LD_ADDR_VAR 0 2
22756: PUSH
22757: EMPTY
22758: ST_TO_ADDR
// for i in tmp do
22759: LD_ADDR_VAR 0 3
22763: PUSH
22764: LD_VAR 0 6
22768: PUSH
22769: FOR_IN
22770: IFFALSE 22841
// begin t := UnitsInside ( i ) ;
22772: LD_ADDR_VAR 0 4
22776: PUSH
22777: LD_VAR 0 3
22781: PPUSH
22782: CALL_OW 313
22786: ST_TO_ADDR
// if t then
22787: LD_VAR 0 4
22791: IFFALSE 22839
// for j in t do
22793: LD_ADDR_VAR 0 7
22797: PUSH
22798: LD_VAR 0 4
22802: PUSH
22803: FOR_IN
22804: IFFALSE 22837
// result := Insert ( result , result + 1 , j ) ;
22806: LD_ADDR_VAR 0 2
22810: PUSH
22811: LD_VAR 0 2
22815: PPUSH
22816: LD_VAR 0 2
22820: PUSH
22821: LD_INT 1
22823: PLUS
22824: PPUSH
22825: LD_VAR 0 7
22829: PPUSH
22830: CALL_OW 2
22834: ST_TO_ADDR
22835: GO 22803
22837: POP
22838: POP
// end ;
22839: GO 22769
22841: POP
22842: POP
// if not result then
22843: LD_VAR 0 2
22847: NOT
22848: IFFALSE 22852
// exit ;
22850: GO 23000
// mech := result [ 1 ] ;
22852: LD_ADDR_VAR 0 5
22856: PUSH
22857: LD_VAR 0 2
22861: PUSH
22862: LD_INT 1
22864: ARRAY
22865: ST_TO_ADDR
// if result > 1 then
22866: LD_VAR 0 2
22870: PUSH
22871: LD_INT 1
22873: GREATER
22874: IFFALSE 22986
// for i = 2 to result do
22876: LD_ADDR_VAR 0 3
22880: PUSH
22881: DOUBLE
22882: LD_INT 2
22884: DEC
22885: ST_TO_ADDR
22886: LD_VAR 0 2
22890: PUSH
22891: FOR_TO
22892: IFFALSE 22984
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22894: LD_ADDR_VAR 0 4
22898: PUSH
22899: LD_VAR 0 2
22903: PUSH
22904: LD_VAR 0 3
22908: ARRAY
22909: PPUSH
22910: LD_INT 3
22912: PPUSH
22913: CALL_OW 259
22917: PUSH
22918: LD_VAR 0 2
22922: PUSH
22923: LD_VAR 0 3
22927: ARRAY
22928: PPUSH
22929: CALL_OW 432
22933: MINUS
22934: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22935: LD_VAR 0 4
22939: PUSH
22940: LD_VAR 0 5
22944: PPUSH
22945: LD_INT 3
22947: PPUSH
22948: CALL_OW 259
22952: PUSH
22953: LD_VAR 0 5
22957: PPUSH
22958: CALL_OW 432
22962: MINUS
22963: GREATEREQUAL
22964: IFFALSE 22982
// mech := result [ i ] ;
22966: LD_ADDR_VAR 0 5
22970: PUSH
22971: LD_VAR 0 2
22975: PUSH
22976: LD_VAR 0 3
22980: ARRAY
22981: ST_TO_ADDR
// end ;
22982: GO 22891
22984: POP
22985: POP
// ComLinkTo ( vehicle , mech ) ;
22986: LD_VAR 0 1
22990: PPUSH
22991: LD_VAR 0 5
22995: PPUSH
22996: CALL_OW 135
// end ;
23000: LD_VAR 0 2
23004: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23005: LD_INT 0
23007: PPUSH
23008: PPUSH
23009: PPUSH
23010: PPUSH
23011: PPUSH
23012: PPUSH
23013: PPUSH
23014: PPUSH
23015: PPUSH
23016: PPUSH
23017: PPUSH
23018: PPUSH
23019: PPUSH
// result := [ ] ;
23020: LD_ADDR_VAR 0 7
23024: PUSH
23025: EMPTY
23026: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 266
23036: PUSH
23037: LD_INT 0
23039: PUSH
23040: LD_INT 1
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: IN
23047: NOT
23048: IFFALSE 23052
// exit ;
23050: GO 24686
// if name then
23052: LD_VAR 0 3
23056: IFFALSE 23072
// SetBName ( base_dep , name ) ;
23058: LD_VAR 0 1
23062: PPUSH
23063: LD_VAR 0 3
23067: PPUSH
23068: CALL_OW 500
// base := GetBase ( base_dep ) ;
23072: LD_ADDR_VAR 0 15
23076: PUSH
23077: LD_VAR 0 1
23081: PPUSH
23082: CALL_OW 274
23086: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23087: LD_ADDR_VAR 0 16
23091: PUSH
23092: LD_VAR 0 1
23096: PPUSH
23097: CALL_OW 255
23101: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23102: LD_ADDR_VAR 0 17
23106: PUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: CALL_OW 248
23116: ST_TO_ADDR
// if sources then
23117: LD_VAR 0 5
23121: IFFALSE 23168
// for i = 1 to 3 do
23123: LD_ADDR_VAR 0 8
23127: PUSH
23128: DOUBLE
23129: LD_INT 1
23131: DEC
23132: ST_TO_ADDR
23133: LD_INT 3
23135: PUSH
23136: FOR_TO
23137: IFFALSE 23166
// AddResourceType ( base , i , sources [ i ] ) ;
23139: LD_VAR 0 15
23143: PPUSH
23144: LD_VAR 0 8
23148: PPUSH
23149: LD_VAR 0 5
23153: PUSH
23154: LD_VAR 0 8
23158: ARRAY
23159: PPUSH
23160: CALL_OW 276
23164: GO 23136
23166: POP
23167: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23168: LD_ADDR_VAR 0 18
23172: PUSH
23173: LD_VAR 0 15
23177: PPUSH
23178: LD_VAR 0 2
23182: PPUSH
23183: LD_INT 1
23185: PPUSH
23186: CALL 22428 0 3
23190: ST_TO_ADDR
// InitHc ;
23191: CALL_OW 19
// InitUc ;
23195: CALL_OW 18
// uc_side := side ;
23199: LD_ADDR_OWVAR 20
23203: PUSH
23204: LD_VAR 0 16
23208: ST_TO_ADDR
// uc_nation := nation ;
23209: LD_ADDR_OWVAR 21
23213: PUSH
23214: LD_VAR 0 17
23218: ST_TO_ADDR
// if buildings then
23219: LD_VAR 0 18
23223: IFFALSE 24545
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23225: LD_ADDR_VAR 0 19
23229: PUSH
23230: LD_VAR 0 18
23234: PPUSH
23235: LD_INT 2
23237: PUSH
23238: LD_INT 30
23240: PUSH
23241: LD_INT 29
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 30
23250: PUSH
23251: LD_INT 30
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: PPUSH
23263: CALL_OW 72
23267: ST_TO_ADDR
// if tmp then
23268: LD_VAR 0 19
23272: IFFALSE 23320
// for i in tmp do
23274: LD_ADDR_VAR 0 8
23278: PUSH
23279: LD_VAR 0 19
23283: PUSH
23284: FOR_IN
23285: IFFALSE 23318
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23287: LD_VAR 0 8
23291: PPUSH
23292: CALL_OW 250
23296: PPUSH
23297: LD_VAR 0 8
23301: PPUSH
23302: CALL_OW 251
23306: PPUSH
23307: LD_VAR 0 16
23311: PPUSH
23312: CALL_OW 441
23316: GO 23284
23318: POP
23319: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23320: LD_VAR 0 18
23324: PPUSH
23325: LD_INT 2
23327: PUSH
23328: LD_INT 30
23330: PUSH
23331: LD_INT 32
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: PUSH
23338: LD_INT 30
23340: PUSH
23341: LD_INT 33
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: LIST
23352: PPUSH
23353: CALL_OW 72
23357: IFFALSE 23445
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23359: LD_ADDR_VAR 0 8
23363: PUSH
23364: LD_VAR 0 18
23368: PPUSH
23369: LD_INT 2
23371: PUSH
23372: LD_INT 30
23374: PUSH
23375: LD_INT 32
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: PUSH
23382: LD_INT 30
23384: PUSH
23385: LD_INT 33
23387: PUSH
23388: EMPTY
23389: LIST
23390: LIST
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: LIST
23396: PPUSH
23397: CALL_OW 72
23401: PUSH
23402: FOR_IN
23403: IFFALSE 23443
// begin if not GetBWeapon ( i ) then
23405: LD_VAR 0 8
23409: PPUSH
23410: CALL_OW 269
23414: NOT
23415: IFFALSE 23441
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23417: LD_VAR 0 8
23421: PPUSH
23422: LD_VAR 0 8
23426: PPUSH
23427: LD_VAR 0 2
23431: PPUSH
23432: CALL 24691 0 2
23436: PPUSH
23437: CALL_OW 431
// end ;
23441: GO 23402
23443: POP
23444: POP
// end ; for i = 1 to personel do
23445: LD_ADDR_VAR 0 8
23449: PUSH
23450: DOUBLE
23451: LD_INT 1
23453: DEC
23454: ST_TO_ADDR
23455: LD_VAR 0 6
23459: PUSH
23460: FOR_TO
23461: IFFALSE 24525
// begin if i > 4 then
23463: LD_VAR 0 8
23467: PUSH
23468: LD_INT 4
23470: GREATER
23471: IFFALSE 23475
// break ;
23473: GO 24525
// case i of 1 :
23475: LD_VAR 0 8
23479: PUSH
23480: LD_INT 1
23482: DOUBLE
23483: EQUAL
23484: IFTRUE 23488
23486: GO 23568
23488: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23489: LD_ADDR_VAR 0 12
23493: PUSH
23494: LD_VAR 0 18
23498: PPUSH
23499: LD_INT 22
23501: PUSH
23502: LD_VAR 0 16
23506: PUSH
23507: EMPTY
23508: LIST
23509: LIST
23510: PUSH
23511: LD_INT 58
23513: PUSH
23514: EMPTY
23515: LIST
23516: PUSH
23517: LD_INT 2
23519: PUSH
23520: LD_INT 30
23522: PUSH
23523: LD_INT 32
23525: PUSH
23526: EMPTY
23527: LIST
23528: LIST
23529: PUSH
23530: LD_INT 30
23532: PUSH
23533: LD_INT 4
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: PUSH
23540: LD_INT 30
23542: PUSH
23543: LD_INT 5
23545: PUSH
23546: EMPTY
23547: LIST
23548: LIST
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: LIST
23554: LIST
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: LIST
23560: PPUSH
23561: CALL_OW 72
23565: ST_TO_ADDR
23566: GO 23790
23568: LD_INT 2
23570: DOUBLE
23571: EQUAL
23572: IFTRUE 23576
23574: GO 23638
23576: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23577: LD_ADDR_VAR 0 12
23581: PUSH
23582: LD_VAR 0 18
23586: PPUSH
23587: LD_INT 22
23589: PUSH
23590: LD_VAR 0 16
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: PUSH
23599: LD_INT 2
23601: PUSH
23602: LD_INT 30
23604: PUSH
23605: LD_INT 0
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: PUSH
23612: LD_INT 30
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: LIST
23626: PUSH
23627: EMPTY
23628: LIST
23629: LIST
23630: PPUSH
23631: CALL_OW 72
23635: ST_TO_ADDR
23636: GO 23790
23638: LD_INT 3
23640: DOUBLE
23641: EQUAL
23642: IFTRUE 23646
23644: GO 23708
23646: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23647: LD_ADDR_VAR 0 12
23651: PUSH
23652: LD_VAR 0 18
23656: PPUSH
23657: LD_INT 22
23659: PUSH
23660: LD_VAR 0 16
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: PUSH
23669: LD_INT 2
23671: PUSH
23672: LD_INT 30
23674: PUSH
23675: LD_INT 2
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 30
23684: PUSH
23685: LD_INT 3
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: LIST
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: PPUSH
23701: CALL_OW 72
23705: ST_TO_ADDR
23706: GO 23790
23708: LD_INT 4
23710: DOUBLE
23711: EQUAL
23712: IFTRUE 23716
23714: GO 23789
23716: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23717: LD_ADDR_VAR 0 12
23721: PUSH
23722: LD_VAR 0 18
23726: PPUSH
23727: LD_INT 22
23729: PUSH
23730: LD_VAR 0 16
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: PUSH
23739: LD_INT 2
23741: PUSH
23742: LD_INT 30
23744: PUSH
23745: LD_INT 6
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: PUSH
23752: LD_INT 30
23754: PUSH
23755: LD_INT 7
23757: PUSH
23758: EMPTY
23759: LIST
23760: LIST
23761: PUSH
23762: LD_INT 30
23764: PUSH
23765: LD_INT 8
23767: PUSH
23768: EMPTY
23769: LIST
23770: LIST
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: LIST
23776: LIST
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: PPUSH
23782: CALL_OW 72
23786: ST_TO_ADDR
23787: GO 23790
23789: POP
// if i = 1 then
23790: LD_VAR 0 8
23794: PUSH
23795: LD_INT 1
23797: EQUAL
23798: IFFALSE 23909
// begin tmp := [ ] ;
23800: LD_ADDR_VAR 0 19
23804: PUSH
23805: EMPTY
23806: ST_TO_ADDR
// for j in f do
23807: LD_ADDR_VAR 0 9
23811: PUSH
23812: LD_VAR 0 12
23816: PUSH
23817: FOR_IN
23818: IFFALSE 23891
// if GetBType ( j ) = b_bunker then
23820: LD_VAR 0 9
23824: PPUSH
23825: CALL_OW 266
23829: PUSH
23830: LD_INT 32
23832: EQUAL
23833: IFFALSE 23860
// tmp := Insert ( tmp , 1 , j ) else
23835: LD_ADDR_VAR 0 19
23839: PUSH
23840: LD_VAR 0 19
23844: PPUSH
23845: LD_INT 1
23847: PPUSH
23848: LD_VAR 0 9
23852: PPUSH
23853: CALL_OW 2
23857: ST_TO_ADDR
23858: GO 23889
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23860: LD_ADDR_VAR 0 19
23864: PUSH
23865: LD_VAR 0 19
23869: PPUSH
23870: LD_VAR 0 19
23874: PUSH
23875: LD_INT 1
23877: PLUS
23878: PPUSH
23879: LD_VAR 0 9
23883: PPUSH
23884: CALL_OW 2
23888: ST_TO_ADDR
23889: GO 23817
23891: POP
23892: POP
// if tmp then
23893: LD_VAR 0 19
23897: IFFALSE 23909
// f := tmp ;
23899: LD_ADDR_VAR 0 12
23903: PUSH
23904: LD_VAR 0 19
23908: ST_TO_ADDR
// end ; x := personel [ i ] ;
23909: LD_ADDR_VAR 0 13
23913: PUSH
23914: LD_VAR 0 6
23918: PUSH
23919: LD_VAR 0 8
23923: ARRAY
23924: ST_TO_ADDR
// if x = - 1 then
23925: LD_VAR 0 13
23929: PUSH
23930: LD_INT 1
23932: NEG
23933: EQUAL
23934: IFFALSE 24143
// begin for j in f do
23936: LD_ADDR_VAR 0 9
23940: PUSH
23941: LD_VAR 0 12
23945: PUSH
23946: FOR_IN
23947: IFFALSE 24139
// repeat InitHc ;
23949: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23953: LD_VAR 0 9
23957: PPUSH
23958: CALL_OW 266
23962: PUSH
23963: LD_INT 5
23965: EQUAL
23966: IFFALSE 24036
// begin if UnitsInside ( j ) < 3 then
23968: LD_VAR 0 9
23972: PPUSH
23973: CALL_OW 313
23977: PUSH
23978: LD_INT 3
23980: LESS
23981: IFFALSE 24017
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23983: LD_INT 0
23985: PPUSH
23986: LD_INT 5
23988: PUSH
23989: LD_INT 8
23991: PUSH
23992: LD_INT 9
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: LIST
23999: PUSH
24000: LD_VAR 0 17
24004: ARRAY
24005: PPUSH
24006: LD_VAR 0 4
24010: PPUSH
24011: CALL_OW 380
24015: GO 24034
// PrepareHuman ( false , i , skill ) ;
24017: LD_INT 0
24019: PPUSH
24020: LD_VAR 0 8
24024: PPUSH
24025: LD_VAR 0 4
24029: PPUSH
24030: CALL_OW 380
// end else
24034: GO 24053
// PrepareHuman ( false , i , skill ) ;
24036: LD_INT 0
24038: PPUSH
24039: LD_VAR 0 8
24043: PPUSH
24044: LD_VAR 0 4
24048: PPUSH
24049: CALL_OW 380
// un := CreateHuman ;
24053: LD_ADDR_VAR 0 14
24057: PUSH
24058: CALL_OW 44
24062: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24063: LD_ADDR_VAR 0 7
24067: PUSH
24068: LD_VAR 0 7
24072: PPUSH
24073: LD_INT 1
24075: PPUSH
24076: LD_VAR 0 14
24080: PPUSH
24081: CALL_OW 2
24085: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24086: LD_VAR 0 14
24090: PPUSH
24091: LD_VAR 0 9
24095: PPUSH
24096: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24100: LD_VAR 0 9
24104: PPUSH
24105: CALL_OW 313
24109: PUSH
24110: LD_INT 6
24112: EQUAL
24113: PUSH
24114: LD_VAR 0 9
24118: PPUSH
24119: CALL_OW 266
24123: PUSH
24124: LD_INT 32
24126: PUSH
24127: LD_INT 31
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: IN
24134: OR
24135: IFFALSE 23949
24137: GO 23946
24139: POP
24140: POP
// end else
24141: GO 24523
// for j = 1 to x do
24143: LD_ADDR_VAR 0 9
24147: PUSH
24148: DOUBLE
24149: LD_INT 1
24151: DEC
24152: ST_TO_ADDR
24153: LD_VAR 0 13
24157: PUSH
24158: FOR_TO
24159: IFFALSE 24521
// begin InitHc ;
24161: CALL_OW 19
// if not f then
24165: LD_VAR 0 12
24169: NOT
24170: IFFALSE 24259
// begin PrepareHuman ( false , i , skill ) ;
24172: LD_INT 0
24174: PPUSH
24175: LD_VAR 0 8
24179: PPUSH
24180: LD_VAR 0 4
24184: PPUSH
24185: CALL_OW 380
// un := CreateHuman ;
24189: LD_ADDR_VAR 0 14
24193: PUSH
24194: CALL_OW 44
24198: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24199: LD_ADDR_VAR 0 7
24203: PUSH
24204: LD_VAR 0 7
24208: PPUSH
24209: LD_INT 1
24211: PPUSH
24212: LD_VAR 0 14
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24222: LD_VAR 0 14
24226: PPUSH
24227: LD_VAR 0 1
24231: PPUSH
24232: CALL_OW 250
24236: PPUSH
24237: LD_VAR 0 1
24241: PPUSH
24242: CALL_OW 251
24246: PPUSH
24247: LD_INT 10
24249: PPUSH
24250: LD_INT 0
24252: PPUSH
24253: CALL_OW 50
// continue ;
24257: GO 24158
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24259: LD_VAR 0 12
24263: PUSH
24264: LD_INT 1
24266: ARRAY
24267: PPUSH
24268: CALL_OW 313
24272: PUSH
24273: LD_VAR 0 12
24277: PUSH
24278: LD_INT 1
24280: ARRAY
24281: PPUSH
24282: CALL_OW 266
24286: PUSH
24287: LD_INT 32
24289: PUSH
24290: LD_INT 31
24292: PUSH
24293: EMPTY
24294: LIST
24295: LIST
24296: IN
24297: AND
24298: PUSH
24299: LD_VAR 0 12
24303: PUSH
24304: LD_INT 1
24306: ARRAY
24307: PPUSH
24308: CALL_OW 313
24312: PUSH
24313: LD_INT 6
24315: EQUAL
24316: OR
24317: IFFALSE 24337
// f := Delete ( f , 1 ) ;
24319: LD_ADDR_VAR 0 12
24323: PUSH
24324: LD_VAR 0 12
24328: PPUSH
24329: LD_INT 1
24331: PPUSH
24332: CALL_OW 3
24336: ST_TO_ADDR
// if not f then
24337: LD_VAR 0 12
24341: NOT
24342: IFFALSE 24360
// begin x := x + 2 ;
24344: LD_ADDR_VAR 0 13
24348: PUSH
24349: LD_VAR 0 13
24353: PUSH
24354: LD_INT 2
24356: PLUS
24357: ST_TO_ADDR
// continue ;
24358: GO 24158
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24360: LD_VAR 0 12
24364: PUSH
24365: LD_INT 1
24367: ARRAY
24368: PPUSH
24369: CALL_OW 266
24373: PUSH
24374: LD_INT 5
24376: EQUAL
24377: IFFALSE 24451
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24379: LD_VAR 0 12
24383: PUSH
24384: LD_INT 1
24386: ARRAY
24387: PPUSH
24388: CALL_OW 313
24392: PUSH
24393: LD_INT 3
24395: LESS
24396: IFFALSE 24432
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24398: LD_INT 0
24400: PPUSH
24401: LD_INT 5
24403: PUSH
24404: LD_INT 8
24406: PUSH
24407: LD_INT 9
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: LIST
24414: PUSH
24415: LD_VAR 0 17
24419: ARRAY
24420: PPUSH
24421: LD_VAR 0 4
24425: PPUSH
24426: CALL_OW 380
24430: GO 24449
// PrepareHuman ( false , i , skill ) ;
24432: LD_INT 0
24434: PPUSH
24435: LD_VAR 0 8
24439: PPUSH
24440: LD_VAR 0 4
24444: PPUSH
24445: CALL_OW 380
// end else
24449: GO 24468
// PrepareHuman ( false , i , skill ) ;
24451: LD_INT 0
24453: PPUSH
24454: LD_VAR 0 8
24458: PPUSH
24459: LD_VAR 0 4
24463: PPUSH
24464: CALL_OW 380
// un := CreateHuman ;
24468: LD_ADDR_VAR 0 14
24472: PUSH
24473: CALL_OW 44
24477: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24478: LD_ADDR_VAR 0 7
24482: PUSH
24483: LD_VAR 0 7
24487: PPUSH
24488: LD_INT 1
24490: PPUSH
24491: LD_VAR 0 14
24495: PPUSH
24496: CALL_OW 2
24500: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24501: LD_VAR 0 14
24505: PPUSH
24506: LD_VAR 0 12
24510: PUSH
24511: LD_INT 1
24513: ARRAY
24514: PPUSH
24515: CALL_OW 52
// end ;
24519: GO 24158
24521: POP
24522: POP
// end ;
24523: GO 23460
24525: POP
24526: POP
// result := result ^ buildings ;
24527: LD_ADDR_VAR 0 7
24531: PUSH
24532: LD_VAR 0 7
24536: PUSH
24537: LD_VAR 0 18
24541: ADD
24542: ST_TO_ADDR
// end else
24543: GO 24686
// begin for i = 1 to personel do
24545: LD_ADDR_VAR 0 8
24549: PUSH
24550: DOUBLE
24551: LD_INT 1
24553: DEC
24554: ST_TO_ADDR
24555: LD_VAR 0 6
24559: PUSH
24560: FOR_TO
24561: IFFALSE 24684
// begin if i > 4 then
24563: LD_VAR 0 8
24567: PUSH
24568: LD_INT 4
24570: GREATER
24571: IFFALSE 24575
// break ;
24573: GO 24684
// x := personel [ i ] ;
24575: LD_ADDR_VAR 0 13
24579: PUSH
24580: LD_VAR 0 6
24584: PUSH
24585: LD_VAR 0 8
24589: ARRAY
24590: ST_TO_ADDR
// if x = - 1 then
24591: LD_VAR 0 13
24595: PUSH
24596: LD_INT 1
24598: NEG
24599: EQUAL
24600: IFFALSE 24604
// continue ;
24602: GO 24560
// PrepareHuman ( false , i , skill ) ;
24604: LD_INT 0
24606: PPUSH
24607: LD_VAR 0 8
24611: PPUSH
24612: LD_VAR 0 4
24616: PPUSH
24617: CALL_OW 380
// un := CreateHuman ;
24621: LD_ADDR_VAR 0 14
24625: PUSH
24626: CALL_OW 44
24630: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24631: LD_VAR 0 14
24635: PPUSH
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL_OW 250
24645: PPUSH
24646: LD_VAR 0 1
24650: PPUSH
24651: CALL_OW 251
24655: PPUSH
24656: LD_INT 10
24658: PPUSH
24659: LD_INT 0
24661: PPUSH
24662: CALL_OW 50
// result := result ^ un ;
24666: LD_ADDR_VAR 0 7
24670: PUSH
24671: LD_VAR 0 7
24675: PUSH
24676: LD_VAR 0 14
24680: ADD
24681: ST_TO_ADDR
// end ;
24682: GO 24560
24684: POP
24685: POP
// end ; end ;
24686: LD_VAR 0 7
24690: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24691: LD_INT 0
24693: PPUSH
24694: PPUSH
24695: PPUSH
24696: PPUSH
24697: PPUSH
24698: PPUSH
24699: PPUSH
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
24704: PPUSH
24705: PPUSH
24706: PPUSH
24707: PPUSH
24708: PPUSH
// result := false ;
24709: LD_ADDR_VAR 0 3
24713: PUSH
24714: LD_INT 0
24716: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24717: LD_VAR 0 1
24721: NOT
24722: PUSH
24723: LD_VAR 0 1
24727: PPUSH
24728: CALL_OW 266
24732: PUSH
24733: LD_INT 32
24735: PUSH
24736: LD_INT 33
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: IN
24743: NOT
24744: OR
24745: IFFALSE 24749
// exit ;
24747: GO 25858
// nat := GetNation ( tower ) ;
24749: LD_ADDR_VAR 0 12
24753: PUSH
24754: LD_VAR 0 1
24758: PPUSH
24759: CALL_OW 248
24763: ST_TO_ADDR
// side := GetSide ( tower ) ;
24764: LD_ADDR_VAR 0 16
24768: PUSH
24769: LD_VAR 0 1
24773: PPUSH
24774: CALL_OW 255
24778: ST_TO_ADDR
// x := GetX ( tower ) ;
24779: LD_ADDR_VAR 0 10
24783: PUSH
24784: LD_VAR 0 1
24788: PPUSH
24789: CALL_OW 250
24793: ST_TO_ADDR
// y := GetY ( tower ) ;
24794: LD_ADDR_VAR 0 11
24798: PUSH
24799: LD_VAR 0 1
24803: PPUSH
24804: CALL_OW 251
24808: ST_TO_ADDR
// if not x or not y then
24809: LD_VAR 0 10
24813: NOT
24814: PUSH
24815: LD_VAR 0 11
24819: NOT
24820: OR
24821: IFFALSE 24825
// exit ;
24823: GO 25858
// weapon := 0 ;
24825: LD_ADDR_VAR 0 18
24829: PUSH
24830: LD_INT 0
24832: ST_TO_ADDR
// fac_list := [ ] ;
24833: LD_ADDR_VAR 0 17
24837: PUSH
24838: EMPTY
24839: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24840: LD_ADDR_VAR 0 6
24844: PUSH
24845: LD_VAR 0 1
24849: PPUSH
24850: CALL_OW 274
24854: PPUSH
24855: LD_VAR 0 2
24859: PPUSH
24860: LD_INT 0
24862: PPUSH
24863: CALL 22428 0 3
24867: PPUSH
24868: LD_INT 30
24870: PUSH
24871: LD_INT 3
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PPUSH
24878: CALL_OW 72
24882: ST_TO_ADDR
// if not factories then
24883: LD_VAR 0 6
24887: NOT
24888: IFFALSE 24892
// exit ;
24890: GO 25858
// for i in factories do
24892: LD_ADDR_VAR 0 8
24896: PUSH
24897: LD_VAR 0 6
24901: PUSH
24902: FOR_IN
24903: IFFALSE 24928
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24905: LD_ADDR_VAR 0 17
24909: PUSH
24910: LD_VAR 0 17
24914: PUSH
24915: LD_VAR 0 8
24919: PPUSH
24920: CALL_OW 478
24924: UNION
24925: ST_TO_ADDR
24926: GO 24902
24928: POP
24929: POP
// if not fac_list then
24930: LD_VAR 0 17
24934: NOT
24935: IFFALSE 24939
// exit ;
24937: GO 25858
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24939: LD_ADDR_VAR 0 5
24943: PUSH
24944: LD_INT 4
24946: PUSH
24947: LD_INT 5
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 10
24955: PUSH
24956: LD_INT 6
24958: PUSH
24959: LD_INT 7
24961: PUSH
24962: LD_INT 11
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: LIST
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 27
24976: PUSH
24977: LD_INT 28
24979: PUSH
24980: LD_INT 26
24982: PUSH
24983: LD_INT 30
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: LIST
24990: LIST
24991: PUSH
24992: LD_INT 43
24994: PUSH
24995: LD_INT 44
24997: PUSH
24998: LD_INT 46
25000: PUSH
25001: LD_INT 45
25003: PUSH
25004: LD_INT 47
25006: PUSH
25007: LD_INT 49
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: LIST
25022: PUSH
25023: LD_VAR 0 12
25027: ARRAY
25028: ST_TO_ADDR
// list := list isect fac_list ;
25029: LD_ADDR_VAR 0 5
25033: PUSH
25034: LD_VAR 0 5
25038: PUSH
25039: LD_VAR 0 17
25043: ISECT
25044: ST_TO_ADDR
// if not list then
25045: LD_VAR 0 5
25049: NOT
25050: IFFALSE 25054
// exit ;
25052: GO 25858
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25054: LD_VAR 0 12
25058: PUSH
25059: LD_INT 3
25061: EQUAL
25062: PUSH
25063: LD_INT 49
25065: PUSH
25066: LD_VAR 0 5
25070: IN
25071: AND
25072: PUSH
25073: LD_INT 31
25075: PPUSH
25076: LD_VAR 0 16
25080: PPUSH
25081: CALL_OW 321
25085: PUSH
25086: LD_INT 2
25088: EQUAL
25089: AND
25090: IFFALSE 25150
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25092: LD_INT 22
25094: PUSH
25095: LD_VAR 0 16
25099: PUSH
25100: EMPTY
25101: LIST
25102: LIST
25103: PUSH
25104: LD_INT 35
25106: PUSH
25107: LD_INT 49
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: PUSH
25114: LD_INT 91
25116: PUSH
25117: LD_VAR 0 1
25121: PUSH
25122: LD_INT 10
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: LIST
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: PPUSH
25135: CALL_OW 69
25139: NOT
25140: IFFALSE 25150
// weapon := ru_time_lapser ;
25142: LD_ADDR_VAR 0 18
25146: PUSH
25147: LD_INT 49
25149: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25150: LD_VAR 0 12
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: IN
25165: PUSH
25166: LD_INT 11
25168: PUSH
25169: LD_VAR 0 5
25173: IN
25174: PUSH
25175: LD_INT 30
25177: PUSH
25178: LD_VAR 0 5
25182: IN
25183: OR
25184: AND
25185: PUSH
25186: LD_INT 6
25188: PPUSH
25189: LD_VAR 0 16
25193: PPUSH
25194: CALL_OW 321
25198: PUSH
25199: LD_INT 2
25201: EQUAL
25202: AND
25203: IFFALSE 25368
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25205: LD_INT 22
25207: PUSH
25208: LD_VAR 0 16
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 2
25219: PUSH
25220: LD_INT 35
25222: PUSH
25223: LD_INT 11
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: PUSH
25230: LD_INT 35
25232: PUSH
25233: LD_INT 30
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: EMPTY
25241: LIST
25242: LIST
25243: LIST
25244: PUSH
25245: LD_INT 91
25247: PUSH
25248: LD_VAR 0 1
25252: PUSH
25253: LD_INT 18
25255: PUSH
25256: EMPTY
25257: LIST
25258: LIST
25259: LIST
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: LIST
25265: PPUSH
25266: CALL_OW 69
25270: NOT
25271: PUSH
25272: LD_INT 22
25274: PUSH
25275: LD_VAR 0 16
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: PUSH
25284: LD_INT 2
25286: PUSH
25287: LD_INT 30
25289: PUSH
25290: LD_INT 32
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: PUSH
25297: LD_INT 30
25299: PUSH
25300: LD_INT 33
25302: PUSH
25303: EMPTY
25304: LIST
25305: LIST
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: LIST
25311: PUSH
25312: LD_INT 91
25314: PUSH
25315: LD_VAR 0 1
25319: PUSH
25320: LD_INT 12
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: LIST
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: PUSH
25333: EMPTY
25334: LIST
25335: PPUSH
25336: CALL_OW 69
25340: PUSH
25341: LD_INT 2
25343: GREATER
25344: AND
25345: IFFALSE 25368
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25347: LD_ADDR_VAR 0 18
25351: PUSH
25352: LD_INT 11
25354: PUSH
25355: LD_INT 30
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_VAR 0 12
25366: ARRAY
25367: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25368: LD_VAR 0 18
25372: NOT
25373: PUSH
25374: LD_INT 40
25376: PPUSH
25377: LD_VAR 0 16
25381: PPUSH
25382: CALL_OW 321
25386: PUSH
25387: LD_INT 2
25389: EQUAL
25390: AND
25391: PUSH
25392: LD_INT 7
25394: PUSH
25395: LD_VAR 0 5
25399: IN
25400: PUSH
25401: LD_INT 28
25403: PUSH
25404: LD_VAR 0 5
25408: IN
25409: OR
25410: PUSH
25411: LD_INT 45
25413: PUSH
25414: LD_VAR 0 5
25418: IN
25419: OR
25420: AND
25421: IFFALSE 25675
// begin hex := GetHexInfo ( x , y ) ;
25423: LD_ADDR_VAR 0 4
25427: PUSH
25428: LD_VAR 0 10
25432: PPUSH
25433: LD_VAR 0 11
25437: PPUSH
25438: CALL_OW 546
25442: ST_TO_ADDR
// if hex [ 1 ] then
25443: LD_VAR 0 4
25447: PUSH
25448: LD_INT 1
25450: ARRAY
25451: IFFALSE 25455
// exit ;
25453: GO 25858
// height := hex [ 2 ] ;
25455: LD_ADDR_VAR 0 15
25459: PUSH
25460: LD_VAR 0 4
25464: PUSH
25465: LD_INT 2
25467: ARRAY
25468: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25469: LD_ADDR_VAR 0 14
25473: PUSH
25474: LD_INT 0
25476: PUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 3
25482: PUSH
25483: LD_INT 5
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: LIST
25490: LIST
25491: ST_TO_ADDR
// for i in tmp do
25492: LD_ADDR_VAR 0 8
25496: PUSH
25497: LD_VAR 0 14
25501: PUSH
25502: FOR_IN
25503: IFFALSE 25673
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25505: LD_ADDR_VAR 0 9
25509: PUSH
25510: LD_VAR 0 10
25514: PPUSH
25515: LD_VAR 0 8
25519: PPUSH
25520: LD_INT 5
25522: PPUSH
25523: CALL_OW 272
25527: PUSH
25528: LD_VAR 0 11
25532: PPUSH
25533: LD_VAR 0 8
25537: PPUSH
25538: LD_INT 5
25540: PPUSH
25541: CALL_OW 273
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25550: LD_VAR 0 9
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 9
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: CALL_OW 488
25572: IFFALSE 25671
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25574: LD_ADDR_VAR 0 4
25578: PUSH
25579: LD_VAR 0 9
25583: PUSH
25584: LD_INT 1
25586: ARRAY
25587: PPUSH
25588: LD_VAR 0 9
25592: PUSH
25593: LD_INT 2
25595: ARRAY
25596: PPUSH
25597: CALL_OW 546
25601: ST_TO_ADDR
// if hex [ 1 ] then
25602: LD_VAR 0 4
25606: PUSH
25607: LD_INT 1
25609: ARRAY
25610: IFFALSE 25614
// continue ;
25612: GO 25502
// h := hex [ 2 ] ;
25614: LD_ADDR_VAR 0 13
25618: PUSH
25619: LD_VAR 0 4
25623: PUSH
25624: LD_INT 2
25626: ARRAY
25627: ST_TO_ADDR
// if h + 7 < height then
25628: LD_VAR 0 13
25632: PUSH
25633: LD_INT 7
25635: PLUS
25636: PUSH
25637: LD_VAR 0 15
25641: LESS
25642: IFFALSE 25671
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25644: LD_ADDR_VAR 0 18
25648: PUSH
25649: LD_INT 7
25651: PUSH
25652: LD_INT 28
25654: PUSH
25655: LD_INT 45
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: LIST
25662: PUSH
25663: LD_VAR 0 12
25667: ARRAY
25668: ST_TO_ADDR
// break ;
25669: GO 25673
// end ; end ; end ;
25671: GO 25502
25673: POP
25674: POP
// end ; if not weapon then
25675: LD_VAR 0 18
25679: NOT
25680: IFFALSE 25740
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25682: LD_ADDR_VAR 0 5
25686: PUSH
25687: LD_VAR 0 5
25691: PUSH
25692: LD_INT 11
25694: PUSH
25695: LD_INT 30
25697: PUSH
25698: LD_INT 49
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: LIST
25705: DIFF
25706: ST_TO_ADDR
// if not list then
25707: LD_VAR 0 5
25711: NOT
25712: IFFALSE 25716
// exit ;
25714: GO 25858
// weapon := list [ rand ( 1 , list ) ] ;
25716: LD_ADDR_VAR 0 18
25720: PUSH
25721: LD_VAR 0 5
25725: PUSH
25726: LD_INT 1
25728: PPUSH
25729: LD_VAR 0 5
25733: PPUSH
25734: CALL_OW 12
25738: ARRAY
25739: ST_TO_ADDR
// end ; if weapon then
25740: LD_VAR 0 18
25744: IFFALSE 25858
// begin tmp := CostOfWeapon ( weapon ) ;
25746: LD_ADDR_VAR 0 14
25750: PUSH
25751: LD_VAR 0 18
25755: PPUSH
25756: CALL_OW 451
25760: ST_TO_ADDR
// j := GetBase ( tower ) ;
25761: LD_ADDR_VAR 0 9
25765: PUSH
25766: LD_VAR 0 1
25770: PPUSH
25771: CALL_OW 274
25775: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25776: LD_VAR 0 9
25780: PPUSH
25781: LD_INT 1
25783: PPUSH
25784: CALL_OW 275
25788: PUSH
25789: LD_VAR 0 14
25793: PUSH
25794: LD_INT 1
25796: ARRAY
25797: GREATEREQUAL
25798: PUSH
25799: LD_VAR 0 9
25803: PPUSH
25804: LD_INT 2
25806: PPUSH
25807: CALL_OW 275
25811: PUSH
25812: LD_VAR 0 14
25816: PUSH
25817: LD_INT 2
25819: ARRAY
25820: GREATEREQUAL
25821: AND
25822: PUSH
25823: LD_VAR 0 9
25827: PPUSH
25828: LD_INT 3
25830: PPUSH
25831: CALL_OW 275
25835: PUSH
25836: LD_VAR 0 14
25840: PUSH
25841: LD_INT 3
25843: ARRAY
25844: GREATEREQUAL
25845: AND
25846: IFFALSE 25858
// result := weapon ;
25848: LD_ADDR_VAR 0 3
25852: PUSH
25853: LD_VAR 0 18
25857: ST_TO_ADDR
// end ; end ;
25858: LD_VAR 0 3
25862: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25863: LD_INT 0
25865: PPUSH
25866: PPUSH
// result := true ;
25867: LD_ADDR_VAR 0 3
25871: PUSH
25872: LD_INT 1
25874: ST_TO_ADDR
// if array1 = array2 then
25875: LD_VAR 0 1
25879: PUSH
25880: LD_VAR 0 2
25884: EQUAL
25885: IFFALSE 25945
// begin for i = 1 to array1 do
25887: LD_ADDR_VAR 0 4
25891: PUSH
25892: DOUBLE
25893: LD_INT 1
25895: DEC
25896: ST_TO_ADDR
25897: LD_VAR 0 1
25901: PUSH
25902: FOR_TO
25903: IFFALSE 25941
// if array1 [ i ] <> array2 [ i ] then
25905: LD_VAR 0 1
25909: PUSH
25910: LD_VAR 0 4
25914: ARRAY
25915: PUSH
25916: LD_VAR 0 2
25920: PUSH
25921: LD_VAR 0 4
25925: ARRAY
25926: NONEQUAL
25927: IFFALSE 25939
// begin result := false ;
25929: LD_ADDR_VAR 0 3
25933: PUSH
25934: LD_INT 0
25936: ST_TO_ADDR
// break ;
25937: GO 25941
// end ;
25939: GO 25902
25941: POP
25942: POP
// end else
25943: GO 25953
// result := false ;
25945: LD_ADDR_VAR 0 3
25949: PUSH
25950: LD_INT 0
25952: ST_TO_ADDR
// end ;
25953: LD_VAR 0 3
25957: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25958: LD_INT 0
25960: PPUSH
25961: PPUSH
// if not array1 or not array2 then
25962: LD_VAR 0 1
25966: NOT
25967: PUSH
25968: LD_VAR 0 2
25972: NOT
25973: OR
25974: IFFALSE 25978
// exit ;
25976: GO 26042
// result := true ;
25978: LD_ADDR_VAR 0 3
25982: PUSH
25983: LD_INT 1
25985: ST_TO_ADDR
// for i = 1 to array1 do
25986: LD_ADDR_VAR 0 4
25990: PUSH
25991: DOUBLE
25992: LD_INT 1
25994: DEC
25995: ST_TO_ADDR
25996: LD_VAR 0 1
26000: PUSH
26001: FOR_TO
26002: IFFALSE 26040
// if array1 [ i ] <> array2 [ i ] then
26004: LD_VAR 0 1
26008: PUSH
26009: LD_VAR 0 4
26013: ARRAY
26014: PUSH
26015: LD_VAR 0 2
26019: PUSH
26020: LD_VAR 0 4
26024: ARRAY
26025: NONEQUAL
26026: IFFALSE 26038
// begin result := false ;
26028: LD_ADDR_VAR 0 3
26032: PUSH
26033: LD_INT 0
26035: ST_TO_ADDR
// break ;
26036: GO 26040
// end ;
26038: GO 26001
26040: POP
26041: POP
// end ;
26042: LD_VAR 0 3
26046: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26047: LD_INT 0
26049: PPUSH
26050: PPUSH
26051: PPUSH
// pom := GetBase ( fac ) ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_VAR 0 1
26061: PPUSH
26062: CALL_OW 274
26066: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26067: LD_ADDR_VAR 0 4
26071: PUSH
26072: LD_VAR 0 2
26076: PUSH
26077: LD_INT 1
26079: ARRAY
26080: PPUSH
26081: LD_VAR 0 2
26085: PUSH
26086: LD_INT 2
26088: ARRAY
26089: PPUSH
26090: LD_VAR 0 2
26094: PUSH
26095: LD_INT 3
26097: ARRAY
26098: PPUSH
26099: LD_VAR 0 2
26103: PUSH
26104: LD_INT 4
26106: ARRAY
26107: PPUSH
26108: CALL_OW 449
26112: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26113: LD_ADDR_VAR 0 3
26117: PUSH
26118: LD_VAR 0 5
26122: PPUSH
26123: LD_INT 1
26125: PPUSH
26126: CALL_OW 275
26130: PUSH
26131: LD_VAR 0 4
26135: PUSH
26136: LD_INT 1
26138: ARRAY
26139: GREATEREQUAL
26140: PUSH
26141: LD_VAR 0 5
26145: PPUSH
26146: LD_INT 2
26148: PPUSH
26149: CALL_OW 275
26153: PUSH
26154: LD_VAR 0 4
26158: PUSH
26159: LD_INT 2
26161: ARRAY
26162: GREATEREQUAL
26163: AND
26164: PUSH
26165: LD_VAR 0 5
26169: PPUSH
26170: LD_INT 3
26172: PPUSH
26173: CALL_OW 275
26177: PUSH
26178: LD_VAR 0 4
26182: PUSH
26183: LD_INT 3
26185: ARRAY
26186: GREATEREQUAL
26187: AND
26188: ST_TO_ADDR
// end ;
26189: LD_VAR 0 3
26193: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26194: LD_INT 0
26196: PPUSH
26197: PPUSH
26198: PPUSH
26199: PPUSH
// pom := GetBase ( building ) ;
26200: LD_ADDR_VAR 0 3
26204: PUSH
26205: LD_VAR 0 1
26209: PPUSH
26210: CALL_OW 274
26214: ST_TO_ADDR
// if not pom then
26215: LD_VAR 0 3
26219: NOT
26220: IFFALSE 26224
// exit ;
26222: GO 26394
// btype := GetBType ( building ) ;
26224: LD_ADDR_VAR 0 5
26228: PUSH
26229: LD_VAR 0 1
26233: PPUSH
26234: CALL_OW 266
26238: ST_TO_ADDR
// if btype = b_armoury then
26239: LD_VAR 0 5
26243: PUSH
26244: LD_INT 4
26246: EQUAL
26247: IFFALSE 26257
// btype := b_barracks ;
26249: LD_ADDR_VAR 0 5
26253: PUSH
26254: LD_INT 5
26256: ST_TO_ADDR
// if btype = b_depot then
26257: LD_VAR 0 5
26261: PUSH
26262: LD_INT 0
26264: EQUAL
26265: IFFALSE 26275
// btype := b_warehouse ;
26267: LD_ADDR_VAR 0 5
26271: PUSH
26272: LD_INT 1
26274: ST_TO_ADDR
// if btype = b_workshop then
26275: LD_VAR 0 5
26279: PUSH
26280: LD_INT 2
26282: EQUAL
26283: IFFALSE 26293
// btype := b_factory ;
26285: LD_ADDR_VAR 0 5
26289: PUSH
26290: LD_INT 3
26292: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26293: LD_ADDR_VAR 0 4
26297: PUSH
26298: LD_VAR 0 5
26302: PPUSH
26303: LD_VAR 0 1
26307: PPUSH
26308: CALL_OW 248
26312: PPUSH
26313: CALL_OW 450
26317: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26318: LD_ADDR_VAR 0 2
26322: PUSH
26323: LD_VAR 0 3
26327: PPUSH
26328: LD_INT 1
26330: PPUSH
26331: CALL_OW 275
26335: PUSH
26336: LD_VAR 0 4
26340: PUSH
26341: LD_INT 1
26343: ARRAY
26344: GREATEREQUAL
26345: PUSH
26346: LD_VAR 0 3
26350: PPUSH
26351: LD_INT 2
26353: PPUSH
26354: CALL_OW 275
26358: PUSH
26359: LD_VAR 0 4
26363: PUSH
26364: LD_INT 2
26366: ARRAY
26367: GREATEREQUAL
26368: AND
26369: PUSH
26370: LD_VAR 0 3
26374: PPUSH
26375: LD_INT 3
26377: PPUSH
26378: CALL_OW 275
26382: PUSH
26383: LD_VAR 0 4
26387: PUSH
26388: LD_INT 3
26390: ARRAY
26391: GREATEREQUAL
26392: AND
26393: ST_TO_ADDR
// end ;
26394: LD_VAR 0 2
26398: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26399: LD_INT 0
26401: PPUSH
26402: PPUSH
26403: PPUSH
// pom := GetBase ( building ) ;
26404: LD_ADDR_VAR 0 4
26408: PUSH
26409: LD_VAR 0 1
26413: PPUSH
26414: CALL_OW 274
26418: ST_TO_ADDR
// if not pom then
26419: LD_VAR 0 4
26423: NOT
26424: IFFALSE 26428
// exit ;
26426: GO 26529
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26428: LD_ADDR_VAR 0 5
26432: PUSH
26433: LD_VAR 0 2
26437: PPUSH
26438: LD_VAR 0 1
26442: PPUSH
26443: CALL_OW 248
26447: PPUSH
26448: CALL_OW 450
26452: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26453: LD_ADDR_VAR 0 3
26457: PUSH
26458: LD_VAR 0 4
26462: PPUSH
26463: LD_INT 1
26465: PPUSH
26466: CALL_OW 275
26470: PUSH
26471: LD_VAR 0 5
26475: PUSH
26476: LD_INT 1
26478: ARRAY
26479: GREATEREQUAL
26480: PUSH
26481: LD_VAR 0 4
26485: PPUSH
26486: LD_INT 2
26488: PPUSH
26489: CALL_OW 275
26493: PUSH
26494: LD_VAR 0 5
26498: PUSH
26499: LD_INT 2
26501: ARRAY
26502: GREATEREQUAL
26503: AND
26504: PUSH
26505: LD_VAR 0 4
26509: PPUSH
26510: LD_INT 3
26512: PPUSH
26513: CALL_OW 275
26517: PUSH
26518: LD_VAR 0 5
26522: PUSH
26523: LD_INT 3
26525: ARRAY
26526: GREATEREQUAL
26527: AND
26528: ST_TO_ADDR
// end ;
26529: LD_VAR 0 3
26533: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26534: LD_INT 0
26536: PPUSH
26537: PPUSH
26538: PPUSH
26539: PPUSH
26540: PPUSH
26541: PPUSH
26542: PPUSH
26543: PPUSH
26544: PPUSH
26545: PPUSH
26546: PPUSH
// result := false ;
26547: LD_ADDR_VAR 0 8
26551: PUSH
26552: LD_INT 0
26554: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26555: LD_VAR 0 5
26559: NOT
26560: PUSH
26561: LD_VAR 0 1
26565: NOT
26566: OR
26567: PUSH
26568: LD_VAR 0 2
26572: NOT
26573: OR
26574: PUSH
26575: LD_VAR 0 3
26579: NOT
26580: OR
26581: IFFALSE 26585
// exit ;
26583: GO 27399
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26585: LD_ADDR_VAR 0 14
26589: PUSH
26590: LD_VAR 0 1
26594: PPUSH
26595: LD_VAR 0 2
26599: PPUSH
26600: LD_VAR 0 3
26604: PPUSH
26605: LD_VAR 0 4
26609: PPUSH
26610: LD_VAR 0 5
26614: PUSH
26615: LD_INT 1
26617: ARRAY
26618: PPUSH
26619: CALL_OW 248
26623: PPUSH
26624: LD_INT 0
26626: PPUSH
26627: CALL 28236 0 6
26631: ST_TO_ADDR
// if not hexes then
26632: LD_VAR 0 14
26636: NOT
26637: IFFALSE 26641
// exit ;
26639: GO 27399
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26641: LD_ADDR_VAR 0 17
26645: PUSH
26646: LD_VAR 0 5
26650: PPUSH
26651: LD_INT 22
26653: PUSH
26654: LD_VAR 0 13
26658: PPUSH
26659: CALL_OW 255
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: LD_INT 2
26670: PUSH
26671: LD_INT 30
26673: PUSH
26674: LD_INT 0
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 30
26683: PUSH
26684: LD_INT 1
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: LIST
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PPUSH
26700: CALL_OW 72
26704: ST_TO_ADDR
// for i = 1 to hexes do
26705: LD_ADDR_VAR 0 9
26709: PUSH
26710: DOUBLE
26711: LD_INT 1
26713: DEC
26714: ST_TO_ADDR
26715: LD_VAR 0 14
26719: PUSH
26720: FOR_TO
26721: IFFALSE 27397
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26723: LD_ADDR_VAR 0 13
26727: PUSH
26728: LD_VAR 0 14
26732: PUSH
26733: LD_VAR 0 9
26737: ARRAY
26738: PUSH
26739: LD_INT 1
26741: ARRAY
26742: PPUSH
26743: LD_VAR 0 14
26747: PUSH
26748: LD_VAR 0 9
26752: ARRAY
26753: PUSH
26754: LD_INT 2
26756: ARRAY
26757: PPUSH
26758: CALL_OW 428
26762: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26763: LD_VAR 0 14
26767: PUSH
26768: LD_VAR 0 9
26772: ARRAY
26773: PUSH
26774: LD_INT 1
26776: ARRAY
26777: PPUSH
26778: LD_VAR 0 14
26782: PUSH
26783: LD_VAR 0 9
26787: ARRAY
26788: PUSH
26789: LD_INT 2
26791: ARRAY
26792: PPUSH
26793: CALL_OW 351
26797: PUSH
26798: LD_VAR 0 14
26802: PUSH
26803: LD_VAR 0 9
26807: ARRAY
26808: PUSH
26809: LD_INT 1
26811: ARRAY
26812: PPUSH
26813: LD_VAR 0 14
26817: PUSH
26818: LD_VAR 0 9
26822: ARRAY
26823: PUSH
26824: LD_INT 2
26826: ARRAY
26827: PPUSH
26828: CALL_OW 488
26832: NOT
26833: OR
26834: PUSH
26835: LD_VAR 0 13
26839: PPUSH
26840: CALL_OW 247
26844: PUSH
26845: LD_INT 3
26847: EQUAL
26848: OR
26849: IFFALSE 26855
// exit ;
26851: POP
26852: POP
26853: GO 27399
// if not tmp then
26855: LD_VAR 0 13
26859: NOT
26860: IFFALSE 26864
// continue ;
26862: GO 26720
// result := true ;
26864: LD_ADDR_VAR 0 8
26868: PUSH
26869: LD_INT 1
26871: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26872: LD_VAR 0 6
26876: PUSH
26877: LD_VAR 0 13
26881: PPUSH
26882: CALL_OW 247
26886: PUSH
26887: LD_INT 2
26889: EQUAL
26890: AND
26891: PUSH
26892: LD_VAR 0 13
26896: PPUSH
26897: CALL_OW 263
26901: PUSH
26902: LD_INT 1
26904: EQUAL
26905: AND
26906: IFFALSE 27070
// begin if IsDrivenBy ( tmp ) then
26908: LD_VAR 0 13
26912: PPUSH
26913: CALL_OW 311
26917: IFFALSE 26921
// continue ;
26919: GO 26720
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26921: LD_VAR 0 6
26925: PPUSH
26926: LD_INT 3
26928: PUSH
26929: LD_INT 60
26931: PUSH
26932: EMPTY
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 3
26941: PUSH
26942: LD_INT 55
26944: PUSH
26945: EMPTY
26946: LIST
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PPUSH
26956: CALL_OW 72
26960: IFFALSE 27068
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26962: LD_ADDR_VAR 0 18
26966: PUSH
26967: LD_VAR 0 6
26971: PPUSH
26972: LD_INT 3
26974: PUSH
26975: LD_INT 60
26977: PUSH
26978: EMPTY
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 55
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PPUSH
27002: CALL_OW 72
27006: PUSH
27007: LD_INT 1
27009: ARRAY
27010: ST_TO_ADDR
// if IsInUnit ( driver ) then
27011: LD_VAR 0 18
27015: PPUSH
27016: CALL_OW 310
27020: IFFALSE 27031
// ComExit ( driver ) ;
27022: LD_VAR 0 18
27026: PPUSH
27027: CALL 51420 0 1
// AddComEnterUnit ( driver , tmp ) ;
27031: LD_VAR 0 18
27035: PPUSH
27036: LD_VAR 0 13
27040: PPUSH
27041: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27045: LD_VAR 0 18
27049: PPUSH
27050: LD_VAR 0 7
27054: PPUSH
27055: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27059: LD_VAR 0 18
27063: PPUSH
27064: CALL_OW 181
// end ; continue ;
27068: GO 26720
// end ; if not cleaners or not tmp in cleaners then
27070: LD_VAR 0 6
27074: NOT
27075: PUSH
27076: LD_VAR 0 13
27080: PUSH
27081: LD_VAR 0 6
27085: IN
27086: NOT
27087: OR
27088: IFFALSE 27395
// begin if dep then
27090: LD_VAR 0 17
27094: IFFALSE 27230
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27096: LD_ADDR_VAR 0 16
27100: PUSH
27101: LD_VAR 0 17
27105: PUSH
27106: LD_INT 1
27108: ARRAY
27109: PPUSH
27110: CALL_OW 250
27114: PPUSH
27115: LD_VAR 0 17
27119: PUSH
27120: LD_INT 1
27122: ARRAY
27123: PPUSH
27124: CALL_OW 254
27128: PPUSH
27129: LD_INT 5
27131: PPUSH
27132: CALL_OW 272
27136: PUSH
27137: LD_VAR 0 17
27141: PUSH
27142: LD_INT 1
27144: ARRAY
27145: PPUSH
27146: CALL_OW 251
27150: PPUSH
27151: LD_VAR 0 17
27155: PUSH
27156: LD_INT 1
27158: ARRAY
27159: PPUSH
27160: CALL_OW 254
27164: PPUSH
27165: LD_INT 5
27167: PPUSH
27168: CALL_OW 273
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27177: LD_VAR 0 16
27181: PUSH
27182: LD_INT 1
27184: ARRAY
27185: PPUSH
27186: LD_VAR 0 16
27190: PUSH
27191: LD_INT 2
27193: ARRAY
27194: PPUSH
27195: CALL_OW 488
27199: IFFALSE 27230
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27201: LD_VAR 0 13
27205: PPUSH
27206: LD_VAR 0 16
27210: PUSH
27211: LD_INT 1
27213: ARRAY
27214: PPUSH
27215: LD_VAR 0 16
27219: PUSH
27220: LD_INT 2
27222: ARRAY
27223: PPUSH
27224: CALL_OW 111
// continue ;
27228: GO 26720
// end ; end ; r := GetDir ( tmp ) ;
27230: LD_ADDR_VAR 0 15
27234: PUSH
27235: LD_VAR 0 13
27239: PPUSH
27240: CALL_OW 254
27244: ST_TO_ADDR
// if r = 5 then
27245: LD_VAR 0 15
27249: PUSH
27250: LD_INT 5
27252: EQUAL
27253: IFFALSE 27263
// r := 0 ;
27255: LD_ADDR_VAR 0 15
27259: PUSH
27260: LD_INT 0
27262: ST_TO_ADDR
// for j = r to 5 do
27263: LD_ADDR_VAR 0 10
27267: PUSH
27268: DOUBLE
27269: LD_VAR 0 15
27273: DEC
27274: ST_TO_ADDR
27275: LD_INT 5
27277: PUSH
27278: FOR_TO
27279: IFFALSE 27393
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27281: LD_ADDR_VAR 0 11
27285: PUSH
27286: LD_VAR 0 13
27290: PPUSH
27291: CALL_OW 250
27295: PPUSH
27296: LD_VAR 0 10
27300: PPUSH
27301: LD_INT 2
27303: PPUSH
27304: CALL_OW 272
27308: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27309: LD_ADDR_VAR 0 12
27313: PUSH
27314: LD_VAR 0 13
27318: PPUSH
27319: CALL_OW 251
27323: PPUSH
27324: LD_VAR 0 10
27328: PPUSH
27329: LD_INT 2
27331: PPUSH
27332: CALL_OW 273
27336: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27337: LD_VAR 0 11
27341: PPUSH
27342: LD_VAR 0 12
27346: PPUSH
27347: CALL_OW 488
27351: PUSH
27352: LD_VAR 0 11
27356: PPUSH
27357: LD_VAR 0 12
27361: PPUSH
27362: CALL_OW 428
27366: NOT
27367: AND
27368: IFFALSE 27391
// begin ComMoveXY ( tmp , _x , _y ) ;
27370: LD_VAR 0 13
27374: PPUSH
27375: LD_VAR 0 11
27379: PPUSH
27380: LD_VAR 0 12
27384: PPUSH
27385: CALL_OW 111
// break ;
27389: GO 27393
// end ; end ;
27391: GO 27278
27393: POP
27394: POP
// end ; end ;
27395: GO 26720
27397: POP
27398: POP
// end ;
27399: LD_VAR 0 8
27403: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27404: LD_INT 0
27406: PPUSH
27407: PPUSH
27408: PPUSH
27409: PPUSH
27410: PPUSH
27411: PPUSH
27412: PPUSH
27413: PPUSH
27414: PPUSH
27415: PPUSH
// result := false ;
27416: LD_ADDR_VAR 0 6
27420: PUSH
27421: LD_INT 0
27423: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27424: LD_VAR 0 1
27428: NOT
27429: PUSH
27430: LD_VAR 0 1
27434: PPUSH
27435: CALL_OW 266
27439: PUSH
27440: LD_INT 0
27442: PUSH
27443: LD_INT 1
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: IN
27450: NOT
27451: OR
27452: PUSH
27453: LD_VAR 0 2
27457: NOT
27458: OR
27459: PUSH
27460: LD_VAR 0 5
27464: PUSH
27465: LD_INT 0
27467: PUSH
27468: LD_INT 1
27470: PUSH
27471: LD_INT 2
27473: PUSH
27474: LD_INT 3
27476: PUSH
27477: LD_INT 4
27479: PUSH
27480: LD_INT 5
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: IN
27491: NOT
27492: OR
27493: PUSH
27494: LD_VAR 0 3
27498: PPUSH
27499: LD_VAR 0 4
27503: PPUSH
27504: CALL_OW 488
27508: NOT
27509: OR
27510: IFFALSE 27514
// exit ;
27512: GO 28231
// pom := GetBase ( depot ) ;
27514: LD_ADDR_VAR 0 10
27518: PUSH
27519: LD_VAR 0 1
27523: PPUSH
27524: CALL_OW 274
27528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27529: LD_ADDR_VAR 0 11
27533: PUSH
27534: LD_VAR 0 2
27538: PPUSH
27539: LD_VAR 0 1
27543: PPUSH
27544: CALL_OW 248
27548: PPUSH
27549: CALL_OW 450
27553: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27554: LD_VAR 0 10
27558: PPUSH
27559: LD_INT 1
27561: PPUSH
27562: CALL_OW 275
27566: PUSH
27567: LD_VAR 0 11
27571: PUSH
27572: LD_INT 1
27574: ARRAY
27575: GREATEREQUAL
27576: PUSH
27577: LD_VAR 0 10
27581: PPUSH
27582: LD_INT 2
27584: PPUSH
27585: CALL_OW 275
27589: PUSH
27590: LD_VAR 0 11
27594: PUSH
27595: LD_INT 2
27597: ARRAY
27598: GREATEREQUAL
27599: AND
27600: PUSH
27601: LD_VAR 0 10
27605: PPUSH
27606: LD_INT 3
27608: PPUSH
27609: CALL_OW 275
27613: PUSH
27614: LD_VAR 0 11
27618: PUSH
27619: LD_INT 3
27621: ARRAY
27622: GREATEREQUAL
27623: AND
27624: NOT
27625: IFFALSE 27629
// exit ;
27627: GO 28231
// if GetBType ( depot ) = b_depot then
27629: LD_VAR 0 1
27633: PPUSH
27634: CALL_OW 266
27638: PUSH
27639: LD_INT 0
27641: EQUAL
27642: IFFALSE 27654
// dist := 28 else
27644: LD_ADDR_VAR 0 14
27648: PUSH
27649: LD_INT 28
27651: ST_TO_ADDR
27652: GO 27662
// dist := 36 ;
27654: LD_ADDR_VAR 0 14
27658: PUSH
27659: LD_INT 36
27661: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27662: LD_VAR 0 1
27666: PPUSH
27667: LD_VAR 0 3
27671: PPUSH
27672: LD_VAR 0 4
27676: PPUSH
27677: CALL_OW 297
27681: PUSH
27682: LD_VAR 0 14
27686: GREATER
27687: IFFALSE 27691
// exit ;
27689: GO 28231
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27691: LD_ADDR_VAR 0 12
27695: PUSH
27696: LD_VAR 0 2
27700: PPUSH
27701: LD_VAR 0 3
27705: PPUSH
27706: LD_VAR 0 4
27710: PPUSH
27711: LD_VAR 0 5
27715: PPUSH
27716: LD_VAR 0 1
27720: PPUSH
27721: CALL_OW 248
27725: PPUSH
27726: LD_INT 0
27728: PPUSH
27729: CALL 28236 0 6
27733: ST_TO_ADDR
// if not hexes then
27734: LD_VAR 0 12
27738: NOT
27739: IFFALSE 27743
// exit ;
27741: GO 28231
// hex := GetHexInfo ( x , y ) ;
27743: LD_ADDR_VAR 0 15
27747: PUSH
27748: LD_VAR 0 3
27752: PPUSH
27753: LD_VAR 0 4
27757: PPUSH
27758: CALL_OW 546
27762: ST_TO_ADDR
// if hex [ 1 ] then
27763: LD_VAR 0 15
27767: PUSH
27768: LD_INT 1
27770: ARRAY
27771: IFFALSE 27775
// exit ;
27773: GO 28231
// height := hex [ 2 ] ;
27775: LD_ADDR_VAR 0 13
27779: PUSH
27780: LD_VAR 0 15
27784: PUSH
27785: LD_INT 2
27787: ARRAY
27788: ST_TO_ADDR
// for i = 1 to hexes do
27789: LD_ADDR_VAR 0 7
27793: PUSH
27794: DOUBLE
27795: LD_INT 1
27797: DEC
27798: ST_TO_ADDR
27799: LD_VAR 0 12
27803: PUSH
27804: FOR_TO
27805: IFFALSE 28135
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27807: LD_VAR 0 12
27811: PUSH
27812: LD_VAR 0 7
27816: ARRAY
27817: PUSH
27818: LD_INT 1
27820: ARRAY
27821: PPUSH
27822: LD_VAR 0 12
27826: PUSH
27827: LD_VAR 0 7
27831: ARRAY
27832: PUSH
27833: LD_INT 2
27835: ARRAY
27836: PPUSH
27837: CALL_OW 488
27841: NOT
27842: PUSH
27843: LD_VAR 0 12
27847: PUSH
27848: LD_VAR 0 7
27852: ARRAY
27853: PUSH
27854: LD_INT 1
27856: ARRAY
27857: PPUSH
27858: LD_VAR 0 12
27862: PUSH
27863: LD_VAR 0 7
27867: ARRAY
27868: PUSH
27869: LD_INT 2
27871: ARRAY
27872: PPUSH
27873: CALL_OW 428
27877: PUSH
27878: LD_INT 0
27880: GREATER
27881: OR
27882: PUSH
27883: LD_VAR 0 12
27887: PUSH
27888: LD_VAR 0 7
27892: ARRAY
27893: PUSH
27894: LD_INT 1
27896: ARRAY
27897: PPUSH
27898: LD_VAR 0 12
27902: PUSH
27903: LD_VAR 0 7
27907: ARRAY
27908: PUSH
27909: LD_INT 2
27911: ARRAY
27912: PPUSH
27913: CALL_OW 351
27917: OR
27918: IFFALSE 27924
// exit ;
27920: POP
27921: POP
27922: GO 28231
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27924: LD_ADDR_VAR 0 8
27928: PUSH
27929: LD_VAR 0 12
27933: PUSH
27934: LD_VAR 0 7
27938: ARRAY
27939: PUSH
27940: LD_INT 1
27942: ARRAY
27943: PPUSH
27944: LD_VAR 0 12
27948: PUSH
27949: LD_VAR 0 7
27953: ARRAY
27954: PUSH
27955: LD_INT 2
27957: ARRAY
27958: PPUSH
27959: CALL_OW 546
27963: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27964: LD_VAR 0 8
27968: PUSH
27969: LD_INT 1
27971: ARRAY
27972: PUSH
27973: LD_VAR 0 8
27977: PUSH
27978: LD_INT 2
27980: ARRAY
27981: PUSH
27982: LD_VAR 0 13
27986: PUSH
27987: LD_INT 2
27989: PLUS
27990: GREATER
27991: OR
27992: PUSH
27993: LD_VAR 0 8
27997: PUSH
27998: LD_INT 2
28000: ARRAY
28001: PUSH
28002: LD_VAR 0 13
28006: PUSH
28007: LD_INT 2
28009: MINUS
28010: LESS
28011: OR
28012: PUSH
28013: LD_VAR 0 8
28017: PUSH
28018: LD_INT 3
28020: ARRAY
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: LD_INT 8
28027: PUSH
28028: LD_INT 9
28030: PUSH
28031: LD_INT 10
28033: PUSH
28034: LD_INT 11
28036: PUSH
28037: LD_INT 12
28039: PUSH
28040: LD_INT 13
28042: PUSH
28043: LD_INT 16
28045: PUSH
28046: LD_INT 17
28048: PUSH
28049: LD_INT 18
28051: PUSH
28052: LD_INT 19
28054: PUSH
28055: LD_INT 20
28057: PUSH
28058: LD_INT 21
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: IN
28076: NOT
28077: OR
28078: PUSH
28079: LD_VAR 0 8
28083: PUSH
28084: LD_INT 5
28086: ARRAY
28087: NOT
28088: OR
28089: PUSH
28090: LD_VAR 0 8
28094: PUSH
28095: LD_INT 6
28097: ARRAY
28098: PUSH
28099: LD_INT 1
28101: PUSH
28102: LD_INT 2
28104: PUSH
28105: LD_INT 7
28107: PUSH
28108: LD_INT 9
28110: PUSH
28111: LD_INT 10
28113: PUSH
28114: LD_INT 11
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: LIST
28121: LIST
28122: LIST
28123: LIST
28124: IN
28125: NOT
28126: OR
28127: IFFALSE 28133
// exit ;
28129: POP
28130: POP
28131: GO 28231
// end ;
28133: GO 27804
28135: POP
28136: POP
// side := GetSide ( depot ) ;
28137: LD_ADDR_VAR 0 9
28141: PUSH
28142: LD_VAR 0 1
28146: PPUSH
28147: CALL_OW 255
28151: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28152: LD_VAR 0 9
28156: PPUSH
28157: LD_VAR 0 3
28161: PPUSH
28162: LD_VAR 0 4
28166: PPUSH
28167: LD_INT 20
28169: PPUSH
28170: CALL 20582 0 4
28174: PUSH
28175: LD_INT 4
28177: ARRAY
28178: IFFALSE 28182
// exit ;
28180: GO 28231
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28182: LD_VAR 0 2
28186: PUSH
28187: LD_INT 29
28189: PUSH
28190: LD_INT 30
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: IN
28197: PUSH
28198: LD_VAR 0 3
28202: PPUSH
28203: LD_VAR 0 4
28207: PPUSH
28208: LD_VAR 0 9
28212: PPUSH
28213: CALL_OW 440
28217: NOT
28218: AND
28219: IFFALSE 28223
// exit ;
28221: GO 28231
// result := true ;
28223: LD_ADDR_VAR 0 6
28227: PUSH
28228: LD_INT 1
28230: ST_TO_ADDR
// end ;
28231: LD_VAR 0 6
28235: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28236: LD_INT 0
28238: PPUSH
28239: PPUSH
28240: PPUSH
28241: PPUSH
28242: PPUSH
28243: PPUSH
28244: PPUSH
28245: PPUSH
28246: PPUSH
28247: PPUSH
28248: PPUSH
28249: PPUSH
28250: PPUSH
28251: PPUSH
28252: PPUSH
28253: PPUSH
28254: PPUSH
28255: PPUSH
28256: PPUSH
28257: PPUSH
28258: PPUSH
28259: PPUSH
28260: PPUSH
28261: PPUSH
28262: PPUSH
28263: PPUSH
28264: PPUSH
28265: PPUSH
28266: PPUSH
28267: PPUSH
28268: PPUSH
28269: PPUSH
28270: PPUSH
28271: PPUSH
28272: PPUSH
28273: PPUSH
28274: PPUSH
28275: PPUSH
28276: PPUSH
28277: PPUSH
28278: PPUSH
28279: PPUSH
28280: PPUSH
28281: PPUSH
28282: PPUSH
28283: PPUSH
28284: PPUSH
28285: PPUSH
28286: PPUSH
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
28291: PPUSH
28292: PPUSH
28293: PPUSH
28294: PPUSH
28295: PPUSH
// result = [ ] ;
28296: LD_ADDR_VAR 0 7
28300: PUSH
28301: EMPTY
28302: ST_TO_ADDR
// temp_list = [ ] ;
28303: LD_ADDR_VAR 0 9
28307: PUSH
28308: EMPTY
28309: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28310: LD_VAR 0 4
28314: PUSH
28315: LD_INT 0
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: LD_INT 2
28323: PUSH
28324: LD_INT 3
28326: PUSH
28327: LD_INT 4
28329: PUSH
28330: LD_INT 5
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: IN
28341: NOT
28342: PUSH
28343: LD_VAR 0 1
28347: PUSH
28348: LD_INT 0
28350: PUSH
28351: LD_INT 1
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: IN
28358: PUSH
28359: LD_VAR 0 5
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: LD_INT 3
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: LIST
28377: IN
28378: NOT
28379: AND
28380: OR
28381: IFFALSE 28385
// exit ;
28383: GO 46776
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28385: LD_VAR 0 1
28389: PUSH
28390: LD_INT 6
28392: PUSH
28393: LD_INT 7
28395: PUSH
28396: LD_INT 8
28398: PUSH
28399: LD_INT 13
28401: PUSH
28402: LD_INT 12
28404: PUSH
28405: LD_INT 15
28407: PUSH
28408: LD_INT 11
28410: PUSH
28411: LD_INT 14
28413: PUSH
28414: LD_INT 10
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: IN
28428: IFFALSE 28438
// btype = b_lab ;
28430: LD_ADDR_VAR 0 1
28434: PUSH
28435: LD_INT 6
28437: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28438: LD_VAR 0 6
28442: PUSH
28443: LD_INT 0
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: LD_INT 2
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: LIST
28456: IN
28457: NOT
28458: PUSH
28459: LD_VAR 0 1
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: LD_INT 1
28469: PUSH
28470: LD_INT 2
28472: PUSH
28473: LD_INT 3
28475: PUSH
28476: LD_INT 6
28478: PUSH
28479: LD_INT 36
28481: PUSH
28482: LD_INT 4
28484: PUSH
28485: LD_INT 5
28487: PUSH
28488: LD_INT 31
28490: PUSH
28491: LD_INT 32
28493: PUSH
28494: LD_INT 33
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: LIST
28501: LIST
28502: LIST
28503: LIST
28504: LIST
28505: LIST
28506: LIST
28507: LIST
28508: LIST
28509: IN
28510: NOT
28511: PUSH
28512: LD_VAR 0 6
28516: PUSH
28517: LD_INT 1
28519: EQUAL
28520: AND
28521: OR
28522: PUSH
28523: LD_VAR 0 1
28527: PUSH
28528: LD_INT 2
28530: PUSH
28531: LD_INT 3
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: IN
28538: NOT
28539: PUSH
28540: LD_VAR 0 6
28544: PUSH
28545: LD_INT 2
28547: EQUAL
28548: AND
28549: OR
28550: IFFALSE 28560
// mode = 0 ;
28552: LD_ADDR_VAR 0 6
28556: PUSH
28557: LD_INT 0
28559: ST_TO_ADDR
// case mode of 0 :
28560: LD_VAR 0 6
28564: PUSH
28565: LD_INT 0
28567: DOUBLE
28568: EQUAL
28569: IFTRUE 28573
28571: GO 40026
28573: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28574: LD_ADDR_VAR 0 11
28578: PUSH
28579: LD_INT 0
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 0
28591: PUSH
28592: LD_INT 1
28594: NEG
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 1
28602: PUSH
28603: LD_INT 0
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 1
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: LD_INT 0
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: EMPTY
28627: LIST
28628: LIST
28629: PUSH
28630: LD_INT 1
28632: NEG
28633: PUSH
28634: LD_INT 0
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: LD_INT 1
28643: NEG
28644: PUSH
28645: LD_INT 1
28647: NEG
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 1
28655: NEG
28656: PUSH
28657: LD_INT 2
28659: NEG
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 0
28667: PUSH
28668: LD_INT 2
28670: NEG
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: LD_INT 1
28681: NEG
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PUSH
28687: LD_INT 1
28689: PUSH
28690: LD_INT 2
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 0
28699: PUSH
28700: LD_INT 2
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 1
28709: NEG
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: LD_INT 3
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 0
28730: PUSH
28731: LD_INT 3
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PUSH
28738: LD_INT 1
28740: NEG
28741: PUSH
28742: LD_INT 2
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28767: LD_ADDR_VAR 0 12
28771: PUSH
28772: LD_INT 0
28774: PUSH
28775: LD_INT 0
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: LD_INT 1
28787: NEG
28788: PUSH
28789: EMPTY
28790: LIST
28791: LIST
28792: PUSH
28793: LD_INT 1
28795: PUSH
28796: LD_INT 0
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: PUSH
28813: LD_INT 0
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: LD_INT 1
28825: NEG
28826: PUSH
28827: LD_INT 0
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: LD_INT 1
28840: NEG
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 1
28848: PUSH
28849: LD_INT 1
28851: NEG
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 2
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 2
28869: PUSH
28870: LD_INT 1
28872: PUSH
28873: EMPTY
28874: LIST
28875: LIST
28876: PUSH
28877: LD_INT 1
28879: NEG
28880: PUSH
28881: LD_INT 1
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: LD_INT 2
28890: NEG
28891: PUSH
28892: LD_INT 0
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: PUSH
28899: LD_INT 2
28901: NEG
28902: PUSH
28903: LD_INT 1
28905: NEG
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 2
28913: NEG
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 3
28924: NEG
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 3
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: LIST
28955: LIST
28956: LIST
28957: LIST
28958: LIST
28959: LIST
28960: LIST
28961: LIST
28962: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28963: LD_ADDR_VAR 0 13
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: LD_INT 0
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 0
28980: PUSH
28981: LD_INT 1
28983: NEG
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: PUSH
28989: LD_INT 1
28991: PUSH
28992: LD_INT 0
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: PUSH
28999: LD_INT 1
29001: PUSH
29002: LD_INT 1
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 0
29011: PUSH
29012: LD_INT 1
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: NEG
29022: PUSH
29023: LD_INT 0
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: LD_INT 1
29036: NEG
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: LD_INT 1
29044: NEG
29045: PUSH
29046: LD_INT 2
29048: NEG
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: LD_INT 2
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 2
29066: PUSH
29067: LD_INT 2
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 1
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 2
29086: NEG
29087: PUSH
29088: LD_INT 1
29090: NEG
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 2
29098: NEG
29099: PUSH
29100: LD_INT 2
29102: NEG
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 2
29110: NEG
29111: PUSH
29112: LD_INT 3
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 3
29122: NEG
29123: PUSH
29124: LD_INT 2
29126: NEG
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 3
29134: NEG
29135: PUSH
29136: LD_INT 3
29138: NEG
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: LIST
29148: LIST
29149: LIST
29150: LIST
29151: LIST
29152: LIST
29153: LIST
29154: LIST
29155: LIST
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29162: LD_ADDR_VAR 0 14
29166: PUSH
29167: LD_INT 0
29169: PUSH
29170: LD_INT 0
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 0
29179: PUSH
29180: LD_INT 1
29182: NEG
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: PUSH
29188: LD_INT 1
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 1
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 0
29210: PUSH
29211: LD_INT 1
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: LD_INT 1
29220: NEG
29221: PUSH
29222: LD_INT 0
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 1
29231: NEG
29232: PUSH
29233: LD_INT 1
29235: NEG
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: LD_INT 2
29247: NEG
29248: PUSH
29249: EMPTY
29250: LIST
29251: LIST
29252: PUSH
29253: LD_INT 0
29255: PUSH
29256: LD_INT 2
29258: NEG
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PUSH
29264: LD_INT 1
29266: PUSH
29267: LD_INT 1
29269: NEG
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: LD_INT 2
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 0
29287: PUSH
29288: LD_INT 2
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: NEG
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 1
29308: NEG
29309: PUSH
29310: LD_INT 3
29312: NEG
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: LD_INT 3
29323: NEG
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 1
29331: PUSH
29332: LD_INT 2
29334: NEG
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: LIST
29346: LIST
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29358: LD_ADDR_VAR 0 15
29362: PUSH
29363: LD_INT 0
29365: PUSH
29366: LD_INT 0
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 0
29375: PUSH
29376: LD_INT 1
29378: NEG
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 1
29386: PUSH
29387: LD_INT 0
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 1
29396: PUSH
29397: LD_INT 1
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 0
29406: PUSH
29407: LD_INT 1
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: LD_INT 1
29416: NEG
29417: PUSH
29418: LD_INT 0
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: PUSH
29425: LD_INT 1
29427: NEG
29428: PUSH
29429: LD_INT 1
29431: NEG
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PUSH
29437: LD_INT 1
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 2
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 2
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 1
29470: NEG
29471: PUSH
29472: LD_INT 1
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 2
29481: NEG
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 2
29492: NEG
29493: PUSH
29494: LD_INT 1
29496: NEG
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 2
29504: PUSH
29505: LD_INT 1
29507: NEG
29508: PUSH
29509: EMPTY
29510: LIST
29511: LIST
29512: PUSH
29513: LD_INT 3
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 3
29525: PUSH
29526: LD_INT 1
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29551: LD_ADDR_VAR 0 16
29555: PUSH
29556: LD_INT 0
29558: PUSH
29559: LD_INT 0
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 1
29579: PUSH
29580: LD_INT 0
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: LD_INT 1
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 0
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 1
29609: NEG
29610: PUSH
29611: LD_INT 0
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: LD_INT 1
29620: NEG
29621: PUSH
29622: LD_INT 1
29624: NEG
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 1
29632: NEG
29633: PUSH
29634: LD_INT 2
29636: NEG
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 2
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 2
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 1
29664: PUSH
29665: LD_INT 2
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 2
29674: NEG
29675: PUSH
29676: LD_INT 1
29678: NEG
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: NEG
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 3
29698: PUSH
29699: LD_INT 2
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 3
29708: PUSH
29709: LD_INT 3
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 2
29718: PUSH
29719: LD_INT 3
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29744: LD_ADDR_VAR 0 17
29748: PUSH
29749: LD_INT 0
29751: PUSH
29752: LD_INT 0
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 0
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 1
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 1
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 0
29792: PUSH
29793: LD_INT 1
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 1
29802: NEG
29803: PUSH
29804: LD_INT 0
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 1
29825: NEG
29826: PUSH
29827: LD_INT 2
29829: NEG
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: LD_INT 2
29840: NEG
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: PUSH
29849: LD_INT 1
29851: NEG
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: LD_INT 2
29869: PUSH
29870: LD_INT 1
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: LD_INT 2
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: LD_INT 2
29892: PUSH
29893: EMPTY
29894: LIST
29895: LIST
29896: PUSH
29897: LD_INT 0
29899: PUSH
29900: LD_INT 2
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: PUSH
29907: LD_INT 1
29909: NEG
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 2
29920: NEG
29921: PUSH
29922: LD_INT 0
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 2
29931: NEG
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 2
29943: NEG
29944: PUSH
29945: LD_INT 2
29947: NEG
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29974: LD_ADDR_VAR 0 18
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: LD_INT 0
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 0
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 1
30012: PUSH
30013: LD_INT 1
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 0
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 0
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: LD_INT 1
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 1
30055: NEG
30056: PUSH
30057: LD_INT 2
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: LD_INT 2
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: PUSH
30079: LD_INT 1
30081: NEG
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: PUSH
30090: LD_INT 0
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 2
30099: PUSH
30100: LD_INT 1
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: LD_INT 2
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 1
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 0
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 1
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 2
30161: NEG
30162: PUSH
30163: LD_INT 1
30165: NEG
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 2
30173: NEG
30174: PUSH
30175: LD_INT 2
30177: NEG
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30204: LD_ADDR_VAR 0 19
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: LD_INT 0
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 1
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: LD_INT 1
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 0
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: LD_INT 0
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PUSH
30271: LD_INT 1
30273: NEG
30274: PUSH
30275: LD_INT 1
30277: NEG
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: LD_INT 2
30289: NEG
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: LD_INT 2
30300: NEG
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: PUSH
30309: LD_INT 1
30311: NEG
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: PUSH
30320: LD_INT 0
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 2
30329: PUSH
30330: LD_INT 1
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 2
30339: PUSH
30340: LD_INT 2
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 1
30349: PUSH
30350: LD_INT 2
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 0
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 1
30369: NEG
30370: PUSH
30371: LD_INT 1
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 2
30380: NEG
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: NEG
30392: PUSH
30393: LD_INT 1
30395: NEG
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 2
30403: NEG
30404: PUSH
30405: LD_INT 2
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30434: LD_ADDR_VAR 0 20
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: LD_INT 0
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 1
30462: PUSH
30463: LD_INT 0
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: LD_INT 1
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 0
30482: PUSH
30483: LD_INT 1
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 1
30492: NEG
30493: PUSH
30494: LD_INT 0
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: PUSH
30501: LD_INT 1
30503: NEG
30504: PUSH
30505: LD_INT 1
30507: NEG
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 1
30515: NEG
30516: PUSH
30517: LD_INT 2
30519: NEG
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: LD_INT 2
30530: NEG
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 2
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 2
30559: PUSH
30560: LD_INT 1
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 2
30569: PUSH
30570: LD_INT 2
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 1
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: LD_INT 1
30599: NEG
30600: PUSH
30601: LD_INT 1
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 2
30610: NEG
30611: PUSH
30612: LD_INT 0
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 2
30621: NEG
30622: PUSH
30623: LD_INT 1
30625: NEG
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 2
30633: NEG
30634: PUSH
30635: LD_INT 2
30637: NEG
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: LIST
30659: LIST
30660: LIST
30661: LIST
30662: LIST
30663: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30664: LD_ADDR_VAR 0 21
30668: PUSH
30669: LD_INT 0
30671: PUSH
30672: LD_INT 0
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 0
30681: PUSH
30682: LD_INT 1
30684: NEG
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 1
30702: PUSH
30703: LD_INT 1
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: LD_INT 1
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: LD_INT 1
30737: NEG
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 1
30745: NEG
30746: PUSH
30747: LD_INT 2
30749: NEG
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: LD_INT 2
30760: NEG
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 1
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 2
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 2
30789: PUSH
30790: LD_INT 1
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: LD_INT 2
30799: PUSH
30800: LD_INT 2
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 1
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 0
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 2
30851: NEG
30852: PUSH
30853: LD_INT 1
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 2
30863: NEG
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30894: LD_ADDR_VAR 0 22
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 0
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: LD_INT 1
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 0
30942: PUSH
30943: LD_INT 1
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 1
30952: NEG
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 1
30963: NEG
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 1
30975: NEG
30976: PUSH
30977: LD_INT 2
30979: NEG
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: LD_INT 2
30990: NEG
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: PUSH
30999: LD_INT 1
31001: NEG
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 2
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 2
31019: PUSH
31020: LD_INT 1
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: PUSH
31027: LD_INT 2
31029: PUSH
31030: LD_INT 2
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 1
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 2
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 1
31059: NEG
31060: PUSH
31061: LD_INT 1
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 2
31070: NEG
31071: PUSH
31072: LD_INT 0
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 2
31081: NEG
31082: PUSH
31083: LD_INT 1
31085: NEG
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: LD_INT 2
31093: NEG
31094: PUSH
31095: LD_INT 2
31097: NEG
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31124: LD_ADDR_VAR 0 23
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 0
31141: PUSH
31142: LD_INT 1
31144: NEG
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 1
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: LD_INT 1
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 1
31182: NEG
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 1
31205: NEG
31206: PUSH
31207: LD_INT 2
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 0
31217: PUSH
31218: LD_INT 2
31220: NEG
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 2
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 2
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 2
31259: PUSH
31260: LD_INT 2
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: LD_INT 2
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 1
31289: NEG
31290: PUSH
31291: LD_INT 1
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 2
31300: NEG
31301: PUSH
31302: LD_INT 0
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 2
31311: NEG
31312: PUSH
31313: LD_INT 1
31315: NEG
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 2
31323: NEG
31324: PUSH
31325: LD_INT 2
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: NEG
31336: PUSH
31337: LD_INT 3
31339: NEG
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: LD_INT 3
31351: NEG
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 1
31359: PUSH
31360: LD_INT 2
31362: NEG
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 2
31370: PUSH
31371: LD_INT 1
31373: NEG
31374: PUSH
31375: EMPTY
31376: LIST
31377: LIST
31378: PUSH
31379: EMPTY
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31404: LD_ADDR_VAR 0 24
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 0
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 0
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: NEG
31463: PUSH
31464: LD_INT 0
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 1
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: NEG
31486: PUSH
31487: LD_INT 2
31489: NEG
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: LD_INT 2
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 1
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 2
31519: PUSH
31520: LD_INT 0
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: LD_INT 2
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: PUSH
31550: LD_INT 2
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: NEG
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 2
31580: NEG
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 2
31591: NEG
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 2
31603: NEG
31604: PUSH
31605: LD_INT 2
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: PUSH
31616: LD_INT 2
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: LD_INT 1
31629: NEG
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 3
31637: PUSH
31638: LD_INT 1
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: LD_INT 2
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31680: LD_ADDR_VAR 0 25
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: LD_INT 0
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 0
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: LD_INT 0
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: LD_INT 1
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 0
31728: PUSH
31729: LD_INT 1
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 1
31749: NEG
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: NEG
31762: PUSH
31763: LD_INT 2
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: LD_INT 2
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 1
31787: NEG
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: LD_INT 2
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: LD_INT 2
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 1
31845: NEG
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 2
31856: NEG
31857: PUSH
31858: LD_INT 0
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 2
31867: NEG
31868: PUSH
31869: LD_INT 1
31871: NEG
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 2
31879: NEG
31880: PUSH
31881: LD_INT 2
31883: NEG
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PUSH
31889: LD_INT 3
31891: PUSH
31892: LD_INT 1
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: LD_INT 3
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 2
31911: PUSH
31912: LD_INT 3
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 3
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31954: LD_ADDR_VAR 0 26
31958: PUSH
31959: LD_INT 0
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 0
31971: PUSH
31972: LD_INT 1
31974: NEG
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: PUSH
31983: LD_INT 0
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 1
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 0
32002: PUSH
32003: LD_INT 1
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 1
32023: NEG
32024: PUSH
32025: LD_INT 1
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 1
32035: NEG
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 0
32047: PUSH
32048: LD_INT 2
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 1
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 2
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 2
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: LD_INT 2
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: LD_INT 2
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: LD_INT 1
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: PUSH
32139: LD_INT 2
32141: NEG
32142: PUSH
32143: LD_INT 1
32145: NEG
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: LD_INT 2
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: PUSH
32166: LD_INT 3
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 1
32175: PUSH
32176: LD_INT 3
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 2
32196: NEG
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32230: LD_ADDR_VAR 0 27
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: LD_INT 0
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 0
32247: PUSH
32248: LD_INT 1
32250: NEG
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 0
32278: PUSH
32279: LD_INT 1
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 1
32288: NEG
32289: PUSH
32290: LD_INT 0
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: LD_INT 2
32315: NEG
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PUSH
32321: LD_INT 0
32323: PUSH
32324: LD_INT 2
32326: NEG
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: PUSH
32335: LD_INT 1
32337: NEG
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: LD_INT 2
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 2
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 2
32406: NEG
32407: PUSH
32408: LD_INT 0
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PUSH
32415: LD_INT 2
32417: NEG
32418: PUSH
32419: LD_INT 1
32421: NEG
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 2
32429: NEG
32430: PUSH
32431: LD_INT 2
32433: NEG
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: NEG
32442: PUSH
32443: LD_INT 2
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 2
32452: NEG
32453: PUSH
32454: LD_INT 1
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 3
32463: NEG
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 3
32475: NEG
32476: PUSH
32477: LD_INT 2
32479: NEG
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32510: LD_ADDR_VAR 0 28
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 0
32527: PUSH
32528: LD_INT 1
32530: NEG
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 1
32548: PUSH
32549: LD_INT 1
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 0
32558: PUSH
32559: LD_INT 1
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: LD_INT 0
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: NEG
32580: PUSH
32581: LD_INT 1
32583: NEG
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: LD_INT 2
32595: NEG
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 0
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: LD_INT 1
32617: NEG
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 2
32625: PUSH
32626: LD_INT 0
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 2
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: LD_INT 2
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 1
32655: PUSH
32656: LD_INT 2
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 0
32665: PUSH
32666: LD_INT 2
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 1
32675: NEG
32676: PUSH
32677: LD_INT 1
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 2
32686: NEG
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 2
32697: NEG
32698: PUSH
32699: LD_INT 1
32701: NEG
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 2
32709: NEG
32710: PUSH
32711: LD_INT 2
32713: NEG
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 2
32721: NEG
32722: PUSH
32723: LD_INT 3
32725: NEG
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: LD_INT 3
32737: NEG
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 3
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 3
32757: NEG
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32792: LD_ADDR_VAR 0 29
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: LD_INT 0
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 0
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 0
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 0
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: LD_INT 1
32865: NEG
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: LD_INT 2
32877: NEG
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 1
32896: PUSH
32897: LD_INT 1
32899: NEG
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 2
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: PUSH
32915: LD_INT 2
32917: PUSH
32918: LD_INT 1
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: LD_INT 2
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 0
32937: PUSH
32938: LD_INT 2
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: PUSH
32949: LD_INT 1
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 2
32970: NEG
32971: PUSH
32972: LD_INT 2
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 2
32982: NEG
32983: PUSH
32984: LD_INT 3
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 2
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 3
33005: PUSH
33006: LD_INT 1
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: PUSH
33016: LD_INT 3
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: LD_INT 2
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 3
33036: NEG
33037: PUSH
33038: LD_INT 2
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33071: LD_ADDR_VAR 0 30
33075: PUSH
33076: LD_INT 0
33078: PUSH
33079: LD_INT 0
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 0
33088: PUSH
33089: LD_INT 1
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 1
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 0
33119: PUSH
33120: LD_INT 1
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 1
33129: NEG
33130: PUSH
33131: LD_INT 0
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 1
33140: NEG
33141: PUSH
33142: LD_INT 1
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: LD_INT 1
33152: NEG
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: LD_INT 2
33167: NEG
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 2
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: PUSH
33207: LD_INT 2
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: LD_INT 2
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: NEG
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 2
33248: NEG
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: LD_INT 3
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 2
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 3
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 3
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: LD_INT 1
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 3
33314: NEG
33315: PUSH
33316: LD_INT 1
33318: NEG
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33349: LD_ADDR_VAR 0 31
33353: PUSH
33354: LD_INT 0
33356: PUSH
33357: LD_INT 0
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: LD_INT 1
33369: NEG
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 0
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: PUSH
33388: LD_INT 1
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 0
33397: PUSH
33398: LD_INT 1
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: NEG
33419: PUSH
33420: LD_INT 1
33422: NEG
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: LD_INT 2
33434: NEG
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 2
33453: PUSH
33454: LD_INT 0
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 2
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 2
33473: PUSH
33474: LD_INT 2
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 1
33483: PUSH
33484: LD_INT 2
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: LD_INT 2
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: NEG
33504: PUSH
33505: LD_INT 1
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: NEG
33515: PUSH
33516: LD_INT 1
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: NEG
33527: PUSH
33528: LD_INT 2
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: LD_INT 3
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 2
33550: PUSH
33551: LD_INT 1
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 3
33561: PUSH
33562: LD_INT 1
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: PUSH
33572: LD_INT 3
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: LD_INT 2
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 3
33592: NEG
33593: PUSH
33594: LD_INT 2
33596: NEG
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33627: LD_ADDR_VAR 0 32
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 0
33644: PUSH
33645: LD_INT 1
33647: NEG
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: LD_INT 1
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 1
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: NEG
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: LD_INT 2
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 2
33723: NEG
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 1
33731: PUSH
33732: LD_INT 1
33734: NEG
33735: PUSH
33736: EMPTY
33737: LIST
33738: LIST
33739: PUSH
33740: LD_INT 2
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 2
33752: PUSH
33753: LD_INT 2
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: LD_INT 2
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 0
33772: PUSH
33773: LD_INT 2
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 1
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 0
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 1
33816: NEG
33817: PUSH
33818: LD_INT 3
33820: NEG
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 1
33828: PUSH
33829: LD_INT 2
33831: NEG
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 3
33839: PUSH
33840: LD_INT 2
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 2
33849: PUSH
33850: LD_INT 3
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 3
33870: NEG
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33905: LD_ADDR_VAR 0 33
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: LD_INT 0
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 0
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: LD_INT 0
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 0
33953: PUSH
33954: LD_INT 1
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: LD_INT 1
33978: NEG
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: LD_INT 1
33986: NEG
33987: PUSH
33988: LD_INT 2
33990: NEG
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 1
33998: PUSH
33999: LD_INT 1
34001: NEG
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 2
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: LD_INT 2
34019: PUSH
34020: LD_INT 1
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: LD_INT 2
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: LD_INT 2
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 2
34060: NEG
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 2
34071: NEG
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 2
34083: NEG
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 2
34095: NEG
34096: PUSH
34097: LD_INT 3
34099: NEG
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 2
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 3
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: LD_INT 3
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 1
34138: NEG
34139: PUSH
34140: LD_INT 2
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 3
34149: NEG
34150: PUSH
34151: LD_INT 2
34153: NEG
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34184: LD_ADDR_VAR 0 34
34188: PUSH
34189: LD_INT 0
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: LD_INT 1
34204: NEG
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 0
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 1
34253: NEG
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: LD_INT 2
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 0
34277: PUSH
34278: LD_INT 2
34280: NEG
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: PUSH
34289: LD_INT 1
34291: NEG
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 2
34299: PUSH
34300: LD_INT 1
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 2
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 1
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 1
34329: NEG
34330: PUSH
34331: LD_INT 1
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 2
34340: NEG
34341: PUSH
34342: LD_INT 0
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: LD_INT 1
34355: NEG
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: NEG
34364: PUSH
34365: LD_INT 2
34367: NEG
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 1
34375: NEG
34376: PUSH
34377: LD_INT 3
34379: NEG
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 2
34390: NEG
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 3
34398: PUSH
34399: LD_INT 2
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 2
34408: PUSH
34409: LD_INT 3
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: NEG
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 3
34429: NEG
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34464: LD_ADDR_VAR 0 35
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: LD_INT 1
34484: NEG
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: LD_INT 1
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 0
34512: PUSH
34513: LD_INT 1
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 1
34522: NEG
34523: PUSH
34524: LD_INT 0
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 1
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 2
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: NEG
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: LIST
34569: LIST
34570: LIST
34571: LIST
34572: LIST
34573: LIST
34574: LIST
34575: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34576: LD_ADDR_VAR 0 36
34580: PUSH
34581: LD_INT 0
34583: PUSH
34584: LD_INT 0
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 0
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 1
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 0
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 1
34634: NEG
34635: PUSH
34636: LD_INT 0
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: NEG
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: LD_INT 2
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34688: LD_ADDR_VAR 0 37
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: LD_INT 0
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: LD_INT 1
34772: NEG
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34800: LD_ADDR_VAR 0 38
34804: PUSH
34805: LD_INT 0
34807: PUSH
34808: LD_INT 0
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 0
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 0
34848: PUSH
34849: LD_INT 1
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: LD_INT 1
34873: NEG
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 2
34881: PUSH
34882: LD_INT 1
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 2
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34912: LD_ADDR_VAR 0 39
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: LD_INT 0
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 0
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 1
34981: NEG
34982: PUSH
34983: LD_INT 1
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: LD_INT 2
34997: NEG
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 2
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35024: LD_ADDR_VAR 0 40
35028: PUSH
35029: LD_INT 0
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 0
35041: PUSH
35042: LD_INT 1
35044: NEG
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 1
35052: PUSH
35053: LD_INT 0
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 1
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: LD_INT 1
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 1
35108: NEG
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 1
35116: NEG
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35136: LD_ADDR_VAR 0 41
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: LD_INT 1
35156: NEG
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: LD_INT 0
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: LD_INT 1
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 1
35194: NEG
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 1
35205: NEG
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: LD_INT 2
35221: NEG
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: LD_INT 1
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 2
35240: PUSH
35241: LD_INT 0
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 2
35250: PUSH
35251: LD_INT 1
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: LD_INT 2
35260: PUSH
35261: LD_INT 2
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: LD_INT 2
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: LD_INT 1
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: LD_INT 2
35291: NEG
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 2
35302: NEG
35303: PUSH
35304: LD_INT 1
35306: NEG
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 2
35314: NEG
35315: PUSH
35316: LD_INT 2
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 2
35326: NEG
35327: PUSH
35328: LD_INT 3
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 3
35349: PUSH
35350: LD_INT 0
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 3
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 3
35369: PUSH
35370: LD_INT 2
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 3
35379: PUSH
35380: LD_INT 3
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: LD_INT 3
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 3
35410: NEG
35411: PUSH
35412: LD_INT 0
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 3
35421: NEG
35422: PUSH
35423: LD_INT 1
35425: NEG
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 3
35433: NEG
35434: PUSH
35435: LD_INT 2
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 3
35445: NEG
35446: PUSH
35447: LD_INT 3
35449: NEG
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35486: LD_ADDR_VAR 0 42
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: LD_INT 0
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: LD_INT 1
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 1
35555: NEG
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: NEG
35568: PUSH
35569: LD_INT 2
35571: NEG
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: LD_INT 2
35582: NEG
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: LD_INT 1
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: LD_INT 1
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: PUSH
35612: LD_INT 2
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 2
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: LD_INT 2
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: NEG
35642: PUSH
35643: LD_INT 1
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 2
35652: NEG
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: NEG
35665: PUSH
35666: LD_INT 2
35668: NEG
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 2
35676: NEG
35677: PUSH
35678: LD_INT 3
35680: NEG
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 1
35688: NEG
35689: PUSH
35690: LD_INT 3
35692: NEG
35693: PUSH
35694: EMPTY
35695: LIST
35696: LIST
35697: PUSH
35698: LD_INT 0
35700: PUSH
35701: LD_INT 3
35703: NEG
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 1
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 3
35722: PUSH
35723: LD_INT 2
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 3
35732: PUSH
35733: LD_INT 3
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 2
35742: PUSH
35743: LD_INT 3
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: PUSH
35753: LD_INT 3
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: LD_INT 3
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: NEG
35773: PUSH
35774: LD_INT 2
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 3
35783: NEG
35784: PUSH
35785: LD_INT 2
35787: NEG
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 3
35795: NEG
35796: PUSH
35797: LD_INT 3
35799: NEG
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35836: LD_ADDR_VAR 0 43
35840: PUSH
35841: LD_INT 0
35843: PUSH
35844: LD_INT 0
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: LD_INT 0
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: NEG
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 1
35905: NEG
35906: PUSH
35907: LD_INT 1
35909: NEG
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 1
35940: PUSH
35941: LD_INT 1
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 2
35951: PUSH
35952: LD_INT 0
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: LD_INT 1
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 0
35981: PUSH
35982: LD_INT 2
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 1
35991: NEG
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 2
36002: NEG
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: NEG
36014: PUSH
36015: LD_INT 1
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: LD_INT 3
36029: NEG
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: LD_INT 3
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 1
36048: PUSH
36049: LD_INT 2
36051: NEG
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 3
36070: PUSH
36071: LD_INT 0
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: LD_INT 3
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 0
36100: PUSH
36101: LD_INT 3
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: NEG
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: NEG
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 3
36143: NEG
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36184: LD_ADDR_VAR 0 44
36188: PUSH
36189: LD_INT 0
36191: PUSH
36192: LD_INT 0
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 1
36222: PUSH
36223: LD_INT 1
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 0
36232: PUSH
36233: LD_INT 1
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: NEG
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 1
36253: NEG
36254: PUSH
36255: LD_INT 1
36257: NEG
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 1
36265: NEG
36266: PUSH
36267: LD_INT 2
36269: NEG
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 1
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 2
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 2
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: LD_INT 2
36308: PUSH
36309: LD_INT 2
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 1
36318: PUSH
36319: LD_INT 2
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 1
36328: NEG
36329: PUSH
36330: LD_INT 1
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 2
36339: NEG
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 2
36350: NEG
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 2
36362: NEG
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: LD_INT 3
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 2
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 3
36397: PUSH
36398: LD_INT 0
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 3
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 3
36417: PUSH
36418: LD_INT 2
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 3
36427: PUSH
36428: LD_INT 3
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 2
36437: PUSH
36438: LD_INT 3
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: NEG
36448: PUSH
36449: LD_INT 1
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 3
36458: NEG
36459: PUSH
36460: LD_INT 0
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: LD_INT 3
36469: NEG
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 3
36481: NEG
36482: PUSH
36483: LD_INT 2
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 3
36493: NEG
36494: PUSH
36495: LD_INT 3
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36534: LD_ADDR_VAR 0 45
36538: PUSH
36539: LD_INT 0
36541: PUSH
36542: LD_INT 0
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 1
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: LD_INT 1
36607: NEG
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 2
36619: NEG
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 0
36627: PUSH
36628: LD_INT 2
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: LD_INT 1
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: LD_INT 2
36659: PUSH
36660: LD_INT 2
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: LD_INT 2
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: LD_INT 2
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: NEG
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: NEG
36701: PUSH
36702: LD_INT 1
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 2
36712: NEG
36713: PUSH
36714: LD_INT 2
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: LD_INT 3
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: LD_INT 3
36740: NEG
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 0
36748: PUSH
36749: LD_INT 3
36751: NEG
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: PUSH
36760: LD_INT 2
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 3
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 3
36780: PUSH
36781: LD_INT 3
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 3
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: LD_INT 3
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: LD_INT 3
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: LD_INT 2
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 3
36831: NEG
36832: PUSH
36833: LD_INT 2
36835: NEG
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 3
36843: NEG
36844: PUSH
36845: LD_INT 3
36847: NEG
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36884: LD_ADDR_VAR 0 46
36888: PUSH
36889: LD_INT 0
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 0
36901: PUSH
36902: LD_INT 1
36904: NEG
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 1
36912: PUSH
36913: LD_INT 0
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 1
36922: PUSH
36923: LD_INT 1
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 1
36942: NEG
36943: PUSH
36944: LD_INT 0
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 1
36953: NEG
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: LD_INT 2
36969: NEG
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 0
36977: PUSH
36978: LD_INT 2
36980: NEG
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 1
36988: PUSH
36989: LD_INT 1
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 2
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 2
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 2
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 2
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 2
37050: NEG
37051: PUSH
37052: LD_INT 0
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: LD_INT 1
37065: NEG
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 1
37073: NEG
37074: PUSH
37075: LD_INT 3
37077: NEG
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: LD_INT 3
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 1
37096: PUSH
37097: LD_INT 2
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: LD_INT 1
37110: NEG
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 3
37118: PUSH
37119: LD_INT 0
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 3
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: LD_INT 3
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: LD_INT 3
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: LD_INT 2
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: NEG
37181: PUSH
37182: LD_INT 0
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 3
37191: NEG
37192: PUSH
37193: LD_INT 1
37195: NEG
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: LIST
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37232: LD_ADDR_VAR 0 47
37236: PUSH
37237: LD_INT 0
37239: PUSH
37240: LD_INT 0
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 1
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 0
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 1
37290: NEG
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: LD_INT 2
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 0
37325: PUSH
37326: LD_INT 2
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 2
37347: NEG
37348: PUSH
37349: LD_INT 1
37351: NEG
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 2
37359: NEG
37360: PUSH
37361: LD_INT 2
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37383: LD_ADDR_VAR 0 48
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: LD_INT 0
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 1
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: LD_INT 1
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: NEG
37453: PUSH
37454: LD_INT 1
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: NEG
37465: PUSH
37466: LD_INT 2
37468: NEG
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: LD_INT 2
37479: NEG
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 1
37487: PUSH
37488: LD_INT 1
37490: NEG
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 2
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 2
37508: PUSH
37509: LD_INT 1
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37530: LD_ADDR_VAR 0 49
37534: PUSH
37535: LD_INT 0
37537: PUSH
37538: LD_INT 0
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: LD_INT 1
37550: NEG
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 1
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: PUSH
37569: LD_INT 1
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 0
37578: PUSH
37579: LD_INT 1
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: NEG
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: NEG
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: PUSH
37623: LD_INT 0
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 2
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 2
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: LD_INT 2
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37674: LD_ADDR_VAR 0 50
37678: PUSH
37679: LD_INT 0
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 1
37694: NEG
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PUSH
37700: LD_INT 1
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 1
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 0
37722: PUSH
37723: LD_INT 1
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: NEG
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: LD_INT 1
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 2
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: LD_INT 1
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37818: LD_ADDR_VAR 0 51
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: LD_INT 0
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: LD_INT 1
37838: NEG
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 1
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 1
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 0
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 1
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 1
37899: PUSH
37900: LD_INT 2
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 0
37909: PUSH
37910: LD_INT 2
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 1
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 2
37941: NEG
37942: PUSH
37943: LD_INT 1
37945: NEG
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37965: LD_ADDR_VAR 0 52
37969: PUSH
37970: LD_INT 0
37972: PUSH
37973: LD_INT 0
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 0
37982: PUSH
37983: LD_INT 1
37985: NEG
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 1
37993: PUSH
37994: LD_INT 0
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 1
38003: PUSH
38004: LD_INT 1
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 0
38013: PUSH
38014: LD_INT 1
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 1
38023: NEG
38024: PUSH
38025: LD_INT 0
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 1
38034: NEG
38035: PUSH
38036: LD_INT 1
38038: NEG
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 1
38046: NEG
38047: PUSH
38048: LD_INT 2
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: LD_INT 0
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 2
38080: NEG
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 2
38092: NEG
38093: PUSH
38094: LD_INT 2
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38116: LD_ADDR_VAR 0 53
38120: PUSH
38121: LD_INT 0
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 0
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 1
38144: PUSH
38145: LD_INT 0
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: LD_INT 1
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 0
38164: PUSH
38165: LD_INT 1
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: NEG
38175: PUSH
38176: LD_INT 0
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 1
38185: NEG
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 1
38197: NEG
38198: PUSH
38199: LD_INT 2
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 0
38209: PUSH
38210: LD_INT 2
38212: NEG
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: LD_INT 1
38223: NEG
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 2
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 2
38251: PUSH
38252: LD_INT 2
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 1
38261: PUSH
38262: LD_INT 2
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: LD_INT 2
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 2
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 2
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 2
38315: NEG
38316: PUSH
38317: LD_INT 2
38319: NEG
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38346: LD_ADDR_VAR 0 54
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: LD_INT 0
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 1
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: LD_INT 1
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 0
38394: PUSH
38395: LD_INT 1
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 1
38404: NEG
38405: PUSH
38406: LD_INT 0
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 1
38415: NEG
38416: PUSH
38417: LD_INT 1
38419: NEG
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 1
38427: NEG
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 0
38439: PUSH
38440: LD_INT 2
38442: NEG
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 1
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 0
38501: PUSH
38502: LD_INT 2
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 1
38511: NEG
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: NEG
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 2
38533: NEG
38534: PUSH
38535: LD_INT 1
38537: NEG
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 2
38545: NEG
38546: PUSH
38547: LD_INT 2
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: LIST
38573: LIST
38574: LIST
38575: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38576: LD_ADDR_VAR 0 55
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 1
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: PUSH
38615: LD_INT 1
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 0
38624: PUSH
38625: LD_INT 1
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 1
38634: NEG
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 1
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: NEG
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 1
38657: NEG
38658: PUSH
38659: LD_INT 2
38661: NEG
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: LD_INT 2
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 2
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 2
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 2
38711: PUSH
38712: LD_INT 2
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: PUSH
38722: LD_INT 2
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: LD_INT 2
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: LD_INT 1
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 2
38752: NEG
38753: PUSH
38754: LD_INT 0
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 2
38763: NEG
38764: PUSH
38765: LD_INT 1
38767: NEG
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 2
38775: NEG
38776: PUSH
38777: LD_INT 2
38779: NEG
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38806: LD_ADDR_VAR 0 56
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: LD_INT 0
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 0
38823: PUSH
38824: LD_INT 1
38826: NEG
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 1
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: LD_INT 1
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 0
38854: PUSH
38855: LD_INT 1
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: NEG
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 1
38875: NEG
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: NEG
38888: PUSH
38889: LD_INT 2
38891: NEG
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: LD_INT 2
38902: NEG
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: LD_INT 1
38913: NEG
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 2
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 2
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 2
38941: PUSH
38942: LD_INT 2
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 1
38971: NEG
38972: PUSH
38973: LD_INT 1
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 2
38993: NEG
38994: PUSH
38995: LD_INT 1
38997: NEG
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: LD_INT 2
39005: NEG
39006: PUSH
39007: LD_INT 2
39009: NEG
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39036: LD_ADDR_VAR 0 57
39040: PUSH
39041: LD_INT 0
39043: PUSH
39044: LD_INT 0
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 0
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 1
39064: PUSH
39065: LD_INT 0
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 1
39074: PUSH
39075: LD_INT 1
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: LD_INT 1
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 1
39094: NEG
39095: PUSH
39096: LD_INT 0
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 1
39105: NEG
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: LD_INT 2
39121: NEG
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: LD_INT 2
39132: NEG
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 2
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 2
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 2
39171: PUSH
39172: LD_INT 2
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: LD_INT 2
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: LD_INT 2
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 1
39201: NEG
39202: PUSH
39203: LD_INT 1
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 2
39212: NEG
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 2
39235: NEG
39236: PUSH
39237: LD_INT 2
39239: NEG
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39266: LD_ADDR_VAR 0 58
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: LD_INT 2
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 2
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 0
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 2
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PUSH
39399: LD_INT 2
39401: PUSH
39402: LD_INT 2
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 1
39411: PUSH
39412: LD_INT 2
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: LD_INT 2
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: LD_INT 1
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 2
39442: NEG
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 2
39453: NEG
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 2
39465: NEG
39466: PUSH
39467: LD_INT 2
39469: NEG
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: LIST
39481: LIST
39482: LIST
39483: LIST
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39496: LD_ADDR_VAR 0 59
39500: PUSH
39501: LD_INT 0
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 0
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 1
39524: PUSH
39525: LD_INT 0
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 1
39534: PUSH
39535: LD_INT 1
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PUSH
39542: LD_INT 0
39544: PUSH
39545: LD_INT 1
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 1
39554: NEG
39555: PUSH
39556: LD_INT 0
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 1
39565: NEG
39566: PUSH
39567: LD_INT 1
39569: NEG
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39584: LD_ADDR_VAR 0 60
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 0
39601: PUSH
39602: LD_INT 1
39604: NEG
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 1
39612: PUSH
39613: LD_INT 0
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 1
39622: PUSH
39623: LD_INT 1
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 0
39632: PUSH
39633: LD_INT 1
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 1
39642: NEG
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 1
39653: NEG
39654: PUSH
39655: LD_INT 1
39657: NEG
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39672: LD_ADDR_VAR 0 61
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 1
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: LD_INT 1
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 1
39730: NEG
39731: PUSH
39732: LD_INT 0
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 1
39741: NEG
39742: PUSH
39743: LD_INT 1
39745: NEG
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39760: LD_ADDR_VAR 0 62
39764: PUSH
39765: LD_INT 0
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 1
39780: NEG
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 1
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 1
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 0
39808: PUSH
39809: LD_INT 1
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 1
39818: NEG
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: LD_INT 1
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39848: LD_ADDR_VAR 0 63
39852: PUSH
39853: LD_INT 0
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 0
39865: PUSH
39866: LD_INT 1
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 1
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 1
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: NEG
39907: PUSH
39908: LD_INT 0
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 1
39917: NEG
39918: PUSH
39919: LD_INT 1
39921: NEG
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39936: LD_ADDR_VAR 0 64
39940: PUSH
39941: LD_INT 0
39943: PUSH
39944: LD_INT 0
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: LD_INT 1
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 1
39974: PUSH
39975: LD_INT 1
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: ST_TO_ADDR
// end ; 1 :
40024: GO 45921
40026: LD_INT 1
40028: DOUBLE
40029: EQUAL
40030: IFTRUE 40034
40032: GO 42657
40034: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40035: LD_ADDR_VAR 0 11
40039: PUSH
40040: LD_INT 1
40042: NEG
40043: PUSH
40044: LD_INT 3
40046: NEG
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 3
40057: NEG
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 2
40068: NEG
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: LIST
40078: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40079: LD_ADDR_VAR 0 12
40083: PUSH
40084: LD_INT 2
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 3
40097: PUSH
40098: LD_INT 0
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 3
40107: PUSH
40108: LD_INT 1
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: LIST
40119: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40120: LD_ADDR_VAR 0 13
40124: PUSH
40125: LD_INT 3
40127: PUSH
40128: LD_INT 2
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: PUSH
40138: LD_INT 3
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 2
40147: PUSH
40148: LD_INT 3
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: LIST
40159: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40160: LD_ADDR_VAR 0 14
40164: PUSH
40165: LD_INT 1
40167: PUSH
40168: LD_INT 3
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 0
40177: PUSH
40178: LD_INT 3
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: NEG
40188: PUSH
40189: LD_INT 2
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: LIST
40200: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40201: LD_ADDR_VAR 0 15
40205: PUSH
40206: LD_INT 2
40208: NEG
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 3
40219: NEG
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 3
40230: NEG
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: LIST
40244: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40245: LD_ADDR_VAR 0 16
40249: PUSH
40250: LD_INT 2
40252: NEG
40253: PUSH
40254: LD_INT 3
40256: NEG
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 3
40264: NEG
40265: PUSH
40266: LD_INT 2
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 3
40276: NEG
40277: PUSH
40278: LD_INT 3
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: LIST
40290: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40291: LD_ADDR_VAR 0 17
40295: PUSH
40296: LD_INT 1
40298: NEG
40299: PUSH
40300: LD_INT 3
40302: NEG
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: LD_INT 3
40313: NEG
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: LD_INT 2
40324: NEG
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: LIST
40334: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40335: LD_ADDR_VAR 0 18
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 3
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 3
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: LIST
40375: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40376: LD_ADDR_VAR 0 19
40380: PUSH
40381: LD_INT 3
40383: PUSH
40384: LD_INT 2
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 3
40393: PUSH
40394: LD_INT 3
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: PUSH
40404: LD_INT 3
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40416: LD_ADDR_VAR 0 20
40420: PUSH
40421: LD_INT 1
40423: PUSH
40424: LD_INT 3
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 0
40433: PUSH
40434: LD_INT 3
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: NEG
40444: PUSH
40445: LD_INT 2
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: LIST
40456: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40457: LD_ADDR_VAR 0 21
40461: PUSH
40462: LD_INT 2
40464: NEG
40465: PUSH
40466: LD_INT 1
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 3
40475: NEG
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 3
40486: NEG
40487: PUSH
40488: LD_INT 1
40490: NEG
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: LIST
40500: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40501: LD_ADDR_VAR 0 22
40505: PUSH
40506: LD_INT 2
40508: NEG
40509: PUSH
40510: LD_INT 3
40512: NEG
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 3
40520: NEG
40521: PUSH
40522: LD_INT 2
40524: NEG
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 3
40532: NEG
40533: PUSH
40534: LD_INT 3
40536: NEG
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: LIST
40546: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40547: LD_ADDR_VAR 0 23
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: LD_INT 3
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: NEG
40566: PUSH
40567: LD_INT 4
40569: NEG
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 1
40577: PUSH
40578: LD_INT 3
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: LIST
40590: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40591: LD_ADDR_VAR 0 24
40595: PUSH
40596: LD_INT 3
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 3
40608: PUSH
40609: LD_INT 1
40611: NEG
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 4
40619: PUSH
40620: LD_INT 1
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: LIST
40631: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40632: LD_ADDR_VAR 0 25
40636: PUSH
40637: LD_INT 3
40639: PUSH
40640: LD_INT 3
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 4
40649: PUSH
40650: LD_INT 3
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: LD_INT 4
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: LIST
40671: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40672: LD_ADDR_VAR 0 26
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: LD_INT 3
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 1
40689: PUSH
40690: LD_INT 4
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: LD_INT 3
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: LIST
40712: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40713: LD_ADDR_VAR 0 27
40717: PUSH
40718: LD_INT 3
40720: NEG
40721: PUSH
40722: LD_INT 0
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: NEG
40743: PUSH
40744: LD_INT 1
40746: NEG
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: LIST
40756: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40757: LD_ADDR_VAR 0 28
40761: PUSH
40762: LD_INT 3
40764: NEG
40765: PUSH
40766: LD_INT 3
40768: NEG
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 3
40776: NEG
40777: PUSH
40778: LD_INT 4
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 4
40788: NEG
40789: PUSH
40790: LD_INT 3
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40803: LD_ADDR_VAR 0 29
40807: PUSH
40808: LD_INT 1
40810: NEG
40811: PUSH
40812: LD_INT 3
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: LD_INT 3
40825: NEG
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 1
40833: PUSH
40834: LD_INT 2
40836: NEG
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 1
40844: NEG
40845: PUSH
40846: LD_INT 4
40848: NEG
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 4
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 1
40867: PUSH
40868: LD_INT 3
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 1
40878: NEG
40879: PUSH
40880: LD_INT 5
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 0
40890: PUSH
40891: LD_INT 5
40893: NEG
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 1
40901: PUSH
40902: LD_INT 4
40904: NEG
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 1
40912: NEG
40913: PUSH
40914: LD_INT 6
40916: NEG
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: LD_INT 6
40927: NEG
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 1
40935: PUSH
40936: LD_INT 5
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: LIST
40950: LIST
40951: LIST
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40958: LD_ADDR_VAR 0 30
40962: PUSH
40963: LD_INT 2
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 3
40976: PUSH
40977: LD_INT 0
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 3
40986: PUSH
40987: LD_INT 1
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: LD_INT 3
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 4
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 4
41017: PUSH
41018: LD_INT 1
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 4
41027: PUSH
41028: LD_INT 1
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 5
41038: PUSH
41039: LD_INT 0
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 5
41048: PUSH
41049: LD_INT 1
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 5
41058: PUSH
41059: LD_INT 1
41061: NEG
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 6
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 6
41079: PUSH
41080: LD_INT 1
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41101: LD_ADDR_VAR 0 31
41105: PUSH
41106: LD_INT 3
41108: PUSH
41109: LD_INT 2
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 3
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 2
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 4
41138: PUSH
41139: LD_INT 3
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 4
41148: PUSH
41149: LD_INT 4
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 3
41158: PUSH
41159: LD_INT 4
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 5
41168: PUSH
41169: LD_INT 4
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 5
41178: PUSH
41179: LD_INT 5
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: PUSH
41189: LD_INT 5
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 6
41198: PUSH
41199: LD_INT 5
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 6
41208: PUSH
41209: LD_INT 6
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 5
41218: PUSH
41219: LD_INT 6
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41240: LD_ADDR_VAR 0 32
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 3
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 0
41257: PUSH
41258: LD_INT 3
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PUSH
41265: LD_INT 1
41267: NEG
41268: PUSH
41269: LD_INT 2
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: PUSH
41279: LD_INT 4
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 0
41288: PUSH
41289: LD_INT 4
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: LD_INT 1
41298: NEG
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: LD_INT 5
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 0
41319: PUSH
41320: LD_INT 5
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 1
41329: NEG
41330: PUSH
41331: LD_INT 4
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 1
41340: PUSH
41341: LD_INT 6
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: LD_INT 6
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: NEG
41361: PUSH
41362: LD_INT 5
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41383: LD_ADDR_VAR 0 33
41387: PUSH
41388: LD_INT 2
41390: NEG
41391: PUSH
41392: LD_INT 1
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 3
41401: NEG
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 3
41412: NEG
41413: PUSH
41414: LD_INT 1
41416: NEG
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 4
41435: NEG
41436: PUSH
41437: LD_INT 0
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 1
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 4
41458: NEG
41459: PUSH
41460: LD_INT 1
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 5
41469: NEG
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 5
41480: NEG
41481: PUSH
41482: LD_INT 1
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: NEG
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 6
41503: NEG
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 6
41514: NEG
41515: PUSH
41516: LD_INT 1
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41538: LD_ADDR_VAR 0 34
41542: PUSH
41543: LD_INT 2
41545: NEG
41546: PUSH
41547: LD_INT 3
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 3
41557: NEG
41558: PUSH
41559: LD_INT 2
41561: NEG
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 3
41569: NEG
41570: PUSH
41571: LD_INT 3
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 3
41581: NEG
41582: PUSH
41583: LD_INT 4
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 4
41593: NEG
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 4
41605: NEG
41606: PUSH
41607: LD_INT 4
41609: NEG
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: LD_INT 4
41617: NEG
41618: PUSH
41619: LD_INT 5
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 5
41629: NEG
41630: PUSH
41631: LD_INT 4
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 5
41641: NEG
41642: PUSH
41643: LD_INT 5
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 5
41653: NEG
41654: PUSH
41655: LD_INT 6
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 6
41665: NEG
41666: PUSH
41667: LD_INT 5
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 6
41677: NEG
41678: PUSH
41679: LD_INT 6
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41701: LD_ADDR_VAR 0 41
41705: PUSH
41706: LD_INT 0
41708: PUSH
41709: LD_INT 2
41711: NEG
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: LD_INT 3
41723: NEG
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 1
41731: PUSH
41732: LD_INT 2
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: LIST
41744: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41745: LD_ADDR_VAR 0 42
41749: PUSH
41750: LD_INT 2
41752: PUSH
41753: LD_INT 0
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: PUSH
41763: LD_INT 1
41765: NEG
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 3
41773: PUSH
41774: LD_INT 1
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: LIST
41785: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41786: LD_ADDR_VAR 0 43
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 2
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 3
41803: PUSH
41804: LD_INT 2
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 2
41813: PUSH
41814: LD_INT 3
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: LIST
41825: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41826: LD_ADDR_VAR 0 44
41830: PUSH
41831: LD_INT 0
41833: PUSH
41834: LD_INT 2
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 1
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 2
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: LIST
41866: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41867: LD_ADDR_VAR 0 45
41871: PUSH
41872: LD_INT 2
41874: NEG
41875: PUSH
41876: LD_INT 0
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 2
41885: NEG
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 3
41896: NEG
41897: PUSH
41898: LD_INT 1
41900: NEG
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: LIST
41910: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41911: LD_ADDR_VAR 0 46
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: LD_INT 2
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 2
41930: NEG
41931: PUSH
41932: LD_INT 3
41934: NEG
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 3
41942: NEG
41943: PUSH
41944: LD_INT 2
41946: NEG
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41957: LD_ADDR_VAR 0 47
41961: PUSH
41962: LD_INT 2
41964: NEG
41965: PUSH
41966: LD_INT 3
41968: NEG
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: NEG
41977: PUSH
41978: LD_INT 3
41980: NEG
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: EMPTY
41987: LIST
41988: LIST
41989: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41990: LD_ADDR_VAR 0 48
41994: PUSH
41995: LD_INT 1
41997: PUSH
41998: LD_INT 2
42000: NEG
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: LD_INT 1
42011: NEG
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42021: LD_ADDR_VAR 0 49
42025: PUSH
42026: LD_INT 3
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 3
42038: PUSH
42039: LD_INT 2
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42050: LD_ADDR_VAR 0 50
42054: PUSH
42055: LD_INT 2
42057: PUSH
42058: LD_INT 3
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42079: LD_ADDR_VAR 0 51
42083: PUSH
42084: LD_INT 1
42086: NEG
42087: PUSH
42088: LD_INT 2
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 2
42097: NEG
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42110: LD_ADDR_VAR 0 52
42114: PUSH
42115: LD_INT 3
42117: NEG
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 3
42129: NEG
42130: PUSH
42131: LD_INT 2
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42143: LD_ADDR_VAR 0 53
42147: PUSH
42148: LD_INT 1
42150: NEG
42151: PUSH
42152: LD_INT 3
42154: NEG
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 0
42162: PUSH
42163: LD_INT 3
42165: NEG
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 1
42173: PUSH
42174: LD_INT 2
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42187: LD_ADDR_VAR 0 54
42191: PUSH
42192: LD_INT 2
42194: PUSH
42195: LD_INT 1
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 3
42205: PUSH
42206: LD_INT 0
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: LD_INT 1
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: LIST
42227: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42228: LD_ADDR_VAR 0 55
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: LD_INT 2
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 3
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: LIST
42267: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42268: LD_ADDR_VAR 0 56
42272: PUSH
42273: LD_INT 1
42275: PUSH
42276: LD_INT 3
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 3
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: NEG
42296: PUSH
42297: LD_INT 2
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: LIST
42308: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42309: LD_ADDR_VAR 0 57
42313: PUSH
42314: LD_INT 2
42316: NEG
42317: PUSH
42318: LD_INT 1
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 3
42327: NEG
42328: PUSH
42329: LD_INT 0
42331: PUSH
42332: EMPTY
42333: LIST
42334: LIST
42335: PUSH
42336: LD_INT 3
42338: NEG
42339: PUSH
42340: LD_INT 1
42342: NEG
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: LIST
42352: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42353: LD_ADDR_VAR 0 58
42357: PUSH
42358: LD_INT 2
42360: NEG
42361: PUSH
42362: LD_INT 3
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 3
42372: NEG
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 3
42384: NEG
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: LIST
42398: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42399: LD_ADDR_VAR 0 59
42403: PUSH
42404: LD_INT 1
42406: NEG
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 0
42418: PUSH
42419: LD_INT 2
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 1
42429: PUSH
42430: LD_INT 1
42432: NEG
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: LIST
42442: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42443: LD_ADDR_VAR 0 60
42447: PUSH
42448: LD_INT 1
42450: PUSH
42451: LD_INT 1
42453: NEG
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 2
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: LD_INT 1
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42484: LD_ADDR_VAR 0 61
42488: PUSH
42489: LD_INT 2
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: LD_INT 2
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: PUSH
42512: LD_INT 2
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: LIST
42523: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42524: LD_ADDR_VAR 0 62
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: LD_INT 2
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 0
42541: PUSH
42542: LD_INT 2
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 1
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: LIST
42564: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42565: LD_ADDR_VAR 0 63
42569: PUSH
42570: LD_INT 1
42572: NEG
42573: PUSH
42574: LD_INT 1
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 0
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 2
42594: NEG
42595: PUSH
42596: LD_INT 1
42598: NEG
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: LIST
42608: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42609: LD_ADDR_VAR 0 64
42613: PUSH
42614: LD_INT 1
42616: NEG
42617: PUSH
42618: LD_INT 2
42620: NEG
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 2
42628: NEG
42629: PUSH
42630: LD_INT 1
42632: NEG
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: LD_INT 2
42644: NEG
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: LIST
42654: ST_TO_ADDR
// end ; 2 :
42655: GO 45921
42657: LD_INT 2
42659: DOUBLE
42660: EQUAL
42661: IFTRUE 42665
42663: GO 45920
42665: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42666: LD_ADDR_VAR 0 29
42670: PUSH
42671: LD_INT 4
42673: PUSH
42674: LD_INT 0
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: LD_INT 1
42686: NEG
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 5
42694: PUSH
42695: LD_INT 0
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 5
42704: PUSH
42705: LD_INT 1
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 4
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 3
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 3
42734: PUSH
42735: LD_INT 1
42737: NEG
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 3
42745: PUSH
42746: LD_INT 2
42748: NEG
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 5
42756: PUSH
42757: LD_INT 2
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 3
42766: PUSH
42767: LD_INT 3
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 3
42776: PUSH
42777: LD_INT 2
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: LD_INT 4
42786: PUSH
42787: LD_INT 3
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 4
42796: PUSH
42797: LD_INT 4
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 3
42806: PUSH
42807: LD_INT 4
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 2
42816: PUSH
42817: LD_INT 3
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 2
42826: PUSH
42827: LD_INT 2
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 4
42836: PUSH
42837: LD_INT 2
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 2
42846: PUSH
42847: LD_INT 4
42849: PUSH
42850: EMPTY
42851: LIST
42852: LIST
42853: PUSH
42854: LD_INT 0
42856: PUSH
42857: LD_INT 4
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: LD_INT 3
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: PUSH
42874: LD_INT 1
42876: PUSH
42877: LD_INT 4
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 1
42886: PUSH
42887: LD_INT 5
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PUSH
42894: LD_INT 0
42896: PUSH
42897: LD_INT 5
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: LD_INT 1
42906: NEG
42907: PUSH
42908: LD_INT 4
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 1
42917: NEG
42918: PUSH
42919: LD_INT 3
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PUSH
42926: LD_INT 2
42928: PUSH
42929: LD_INT 5
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 2
42938: NEG
42939: PUSH
42940: LD_INT 3
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 3
42949: NEG
42950: PUSH
42951: LD_INT 0
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 3
42960: NEG
42961: PUSH
42962: LD_INT 1
42964: NEG
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 2
42972: NEG
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 2
42983: NEG
42984: PUSH
42985: LD_INT 1
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 3
42994: NEG
42995: PUSH
42996: LD_INT 1
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 4
43005: NEG
43006: PUSH
43007: LD_INT 0
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: PUSH
43014: LD_INT 4
43016: NEG
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 4
43028: NEG
43029: PUSH
43030: LD_INT 2
43032: NEG
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 2
43040: NEG
43041: PUSH
43042: LD_INT 2
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: LD_INT 4
43051: NEG
43052: PUSH
43053: LD_INT 4
43055: NEG
43056: PUSH
43057: EMPTY
43058: LIST
43059: LIST
43060: PUSH
43061: LD_INT 4
43063: NEG
43064: PUSH
43065: LD_INT 5
43067: NEG
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 3
43075: NEG
43076: PUSH
43077: LD_INT 4
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 3
43087: NEG
43088: PUSH
43089: LD_INT 3
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 4
43099: NEG
43100: PUSH
43101: LD_INT 3
43103: NEG
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 5
43111: NEG
43112: PUSH
43113: LD_INT 4
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 5
43123: NEG
43124: PUSH
43125: LD_INT 5
43127: NEG
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 3
43135: NEG
43136: PUSH
43137: LD_INT 5
43139: NEG
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 5
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43204: LD_ADDR_VAR 0 30
43208: PUSH
43209: LD_INT 4
43211: PUSH
43212: LD_INT 4
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 4
43221: PUSH
43222: LD_INT 3
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 5
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 5
43241: PUSH
43242: LD_INT 5
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 4
43251: PUSH
43252: LD_INT 5
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 3
43261: PUSH
43262: LD_INT 4
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 3
43271: PUSH
43272: LD_INT 3
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 5
43281: PUSH
43282: LD_INT 3
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 3
43291: PUSH
43292: LD_INT 5
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 0
43301: PUSH
43302: LD_INT 3
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: LD_INT 2
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 1
43321: PUSH
43322: LD_INT 3
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 1
43331: PUSH
43332: LD_INT 4
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 0
43341: PUSH
43342: LD_INT 4
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 3
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 1
43362: NEG
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 2
43373: PUSH
43374: LD_INT 4
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 2
43383: NEG
43384: PUSH
43385: LD_INT 2
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 4
43394: NEG
43395: PUSH
43396: LD_INT 0
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 4
43405: NEG
43406: PUSH
43407: LD_INT 1
43409: NEG
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 3
43417: NEG
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 3
43428: NEG
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 4
43439: NEG
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 5
43450: NEG
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 5
43461: NEG
43462: PUSH
43463: LD_INT 1
43465: NEG
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 5
43473: NEG
43474: PUSH
43475: LD_INT 2
43477: NEG
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 3
43485: NEG
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 3
43496: NEG
43497: PUSH
43498: LD_INT 3
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 3
43508: NEG
43509: PUSH
43510: LD_INT 4
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 2
43520: NEG
43521: PUSH
43522: LD_INT 3
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 2
43532: NEG
43533: PUSH
43534: LD_INT 2
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 3
43544: NEG
43545: PUSH
43546: LD_INT 2
43548: NEG
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 4
43556: NEG
43557: PUSH
43558: LD_INT 3
43560: NEG
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 4
43568: NEG
43569: PUSH
43570: LD_INT 4
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 2
43580: NEG
43581: PUSH
43582: LD_INT 4
43584: NEG
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 4
43592: NEG
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: LD_INT 4
43607: NEG
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 0
43615: PUSH
43616: LD_INT 5
43618: NEG
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 1
43626: PUSH
43627: LD_INT 4
43629: NEG
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 1
43637: PUSH
43638: LD_INT 3
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 0
43648: PUSH
43649: LD_INT 3
43651: NEG
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 1
43659: NEG
43660: PUSH
43661: LD_INT 4
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 1
43671: NEG
43672: PUSH
43673: LD_INT 5
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: PUSH
43684: LD_INT 3
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 2
43694: NEG
43695: PUSH
43696: LD_INT 5
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43751: LD_ADDR_VAR 0 31
43755: PUSH
43756: LD_INT 0
43758: PUSH
43759: LD_INT 4
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: LD_INT 3
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 1
43778: PUSH
43779: LD_INT 4
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 1
43788: PUSH
43789: LD_INT 5
43791: PUSH
43792: EMPTY
43793: LIST
43794: LIST
43795: PUSH
43796: LD_INT 0
43798: PUSH
43799: LD_INT 5
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: LD_INT 4
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 1
43819: NEG
43820: PUSH
43821: LD_INT 3
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 2
43830: PUSH
43831: LD_INT 5
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 2
43840: NEG
43841: PUSH
43842: LD_INT 3
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 3
43851: NEG
43852: PUSH
43853: LD_INT 0
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: LD_INT 3
43862: NEG
43863: PUSH
43864: LD_INT 1
43866: NEG
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 2
43874: NEG
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: LD_INT 2
43885: NEG
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 3
43896: NEG
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 4
43907: NEG
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 4
43918: NEG
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 4
43930: NEG
43931: PUSH
43932: LD_INT 2
43934: NEG
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 2
43942: NEG
43943: PUSH
43944: LD_INT 2
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 4
43953: NEG
43954: PUSH
43955: LD_INT 4
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 4
43965: NEG
43966: PUSH
43967: LD_INT 5
43969: NEG
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 3
43977: NEG
43978: PUSH
43979: LD_INT 4
43981: NEG
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: LD_INT 3
43989: NEG
43990: PUSH
43991: LD_INT 3
43993: NEG
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 4
44001: NEG
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 5
44013: NEG
44014: PUSH
44015: LD_INT 4
44017: NEG
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 5
44025: NEG
44026: PUSH
44027: LD_INT 5
44029: NEG
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 3
44037: NEG
44038: PUSH
44039: LD_INT 5
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 5
44049: NEG
44050: PUSH
44051: LD_INT 3
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 0
44072: PUSH
44073: LD_INT 4
44075: NEG
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 1
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 1
44094: PUSH
44095: LD_INT 2
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 0
44105: PUSH
44106: LD_INT 2
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 1
44116: NEG
44117: PUSH
44118: LD_INT 3
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 1
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 2
44140: PUSH
44141: LD_INT 2
44143: NEG
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 2
44151: NEG
44152: PUSH
44153: LD_INT 4
44155: NEG
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 4
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 4
44173: PUSH
44174: LD_INT 1
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 5
44184: PUSH
44185: LD_INT 0
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 5
44194: PUSH
44195: LD_INT 1
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 4
44204: PUSH
44205: LD_INT 1
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 3
44214: PUSH
44215: LD_INT 0
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 3
44224: PUSH
44225: LD_INT 1
44227: NEG
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 3
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 5
44246: PUSH
44247: LD_INT 2
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44301: LD_ADDR_VAR 0 32
44305: PUSH
44306: LD_INT 4
44308: NEG
44309: PUSH
44310: LD_INT 0
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 4
44319: NEG
44320: PUSH
44321: LD_INT 1
44323: NEG
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: LD_INT 3
44331: NEG
44332: PUSH
44333: LD_INT 0
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 3
44342: NEG
44343: PUSH
44344: LD_INT 1
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 4
44353: NEG
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 5
44364: NEG
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 5
44375: NEG
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 5
44387: NEG
44388: PUSH
44389: LD_INT 2
44391: NEG
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 3
44399: NEG
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: LD_INT 3
44410: NEG
44411: PUSH
44412: LD_INT 3
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 3
44422: NEG
44423: PUSH
44424: LD_INT 4
44426: NEG
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 2
44434: NEG
44435: PUSH
44436: LD_INT 3
44438: NEG
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 2
44446: NEG
44447: PUSH
44448: LD_INT 2
44450: NEG
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 3
44458: NEG
44459: PUSH
44460: LD_INT 2
44462: NEG
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 4
44470: NEG
44471: PUSH
44472: LD_INT 3
44474: NEG
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 4
44482: NEG
44483: PUSH
44484: LD_INT 4
44486: NEG
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 2
44494: NEG
44495: PUSH
44496: LD_INT 4
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 4
44506: NEG
44507: PUSH
44508: LD_INT 2
44510: NEG
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PUSH
44516: LD_INT 0
44518: PUSH
44519: LD_INT 4
44521: NEG
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 0
44529: PUSH
44530: LD_INT 5
44532: NEG
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 1
44540: PUSH
44541: LD_INT 4
44543: NEG
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 1
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 3
44565: NEG
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 1
44573: NEG
44574: PUSH
44575: LD_INT 4
44577: NEG
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 1
44585: NEG
44586: PUSH
44587: LD_INT 5
44589: NEG
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: LD_INT 2
44597: PUSH
44598: LD_INT 3
44600: NEG
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 2
44608: NEG
44609: PUSH
44610: LD_INT 5
44612: NEG
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 3
44620: PUSH
44621: LD_INT 0
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 3
44630: PUSH
44631: LD_INT 1
44633: NEG
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 4
44641: PUSH
44642: LD_INT 0
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 4
44651: PUSH
44652: LD_INT 1
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 3
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 2
44671: PUSH
44672: LD_INT 0
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 2
44681: PUSH
44682: LD_INT 1
44684: NEG
44685: PUSH
44686: EMPTY
44687: LIST
44688: LIST
44689: PUSH
44690: LD_INT 2
44692: PUSH
44693: LD_INT 2
44695: NEG
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 4
44703: PUSH
44704: LD_INT 2
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 4
44713: PUSH
44714: LD_INT 4
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 4
44723: PUSH
44724: LD_INT 3
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 5
44733: PUSH
44734: LD_INT 4
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: LD_INT 5
44743: PUSH
44744: LD_INT 5
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 4
44753: PUSH
44754: LD_INT 5
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 3
44763: PUSH
44764: LD_INT 4
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 3
44773: PUSH
44774: LD_INT 3
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 5
44783: PUSH
44784: LD_INT 3
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 3
44793: PUSH
44794: LD_INT 5
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: LIST
44847: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44848: LD_ADDR_VAR 0 33
44852: PUSH
44853: LD_INT 4
44855: NEG
44856: PUSH
44857: LD_INT 4
44859: NEG
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 4
44867: NEG
44868: PUSH
44869: LD_INT 5
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: NEG
44880: PUSH
44881: LD_INT 4
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 3
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 4
44903: NEG
44904: PUSH
44905: LD_INT 3
44907: NEG
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 5
44915: NEG
44916: PUSH
44917: LD_INT 4
44919: NEG
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 5
44927: NEG
44928: PUSH
44929: LD_INT 5
44931: NEG
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 3
44939: NEG
44940: PUSH
44941: LD_INT 5
44943: NEG
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 5
44951: NEG
44952: PUSH
44953: LD_INT 3
44955: NEG
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 0
44963: PUSH
44964: LD_INT 3
44966: NEG
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 0
44974: PUSH
44975: LD_INT 4
44977: NEG
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 1
44985: PUSH
44986: LD_INT 3
44988: NEG
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 1
44996: PUSH
44997: LD_INT 2
44999: NEG
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 2
45010: NEG
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: LD_INT 3
45022: NEG
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: LD_INT 4
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 2
45042: PUSH
45043: LD_INT 2
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 2
45053: NEG
45054: PUSH
45055: LD_INT 4
45057: NEG
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: PUSH
45066: LD_INT 0
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 4
45075: PUSH
45076: LD_INT 1
45078: NEG
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 5
45086: PUSH
45087: LD_INT 0
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 5
45096: PUSH
45097: LD_INT 1
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 4
45106: PUSH
45107: LD_INT 1
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 3
45116: PUSH
45117: LD_INT 0
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 3
45126: PUSH
45127: LD_INT 1
45129: NEG
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 3
45137: PUSH
45138: LD_INT 2
45140: NEG
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 5
45148: PUSH
45149: LD_INT 2
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 3
45158: PUSH
45159: LD_INT 3
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 3
45168: PUSH
45169: LD_INT 2
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 4
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: LD_INT 4
45188: PUSH
45189: LD_INT 4
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 3
45198: PUSH
45199: LD_INT 4
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 2
45208: PUSH
45209: LD_INT 3
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 2
45218: PUSH
45219: LD_INT 2
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: PUSH
45229: LD_INT 2
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 2
45238: PUSH
45239: LD_INT 4
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 0
45248: PUSH
45249: LD_INT 4
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 0
45258: PUSH
45259: LD_INT 3
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 4
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 1
45278: PUSH
45279: LD_INT 5
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 0
45288: PUSH
45289: LD_INT 5
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: PUSH
45296: LD_INT 1
45298: NEG
45299: PUSH
45300: LD_INT 4
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 1
45309: NEG
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: LD_INT 2
45320: PUSH
45321: LD_INT 5
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 2
45330: NEG
45331: PUSH
45332: LD_INT 3
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45386: LD_ADDR_VAR 0 34
45390: PUSH
45391: LD_INT 0
45393: PUSH
45394: LD_INT 4
45396: NEG
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 0
45404: PUSH
45405: LD_INT 5
45407: NEG
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 1
45415: PUSH
45416: LD_INT 4
45418: NEG
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 1
45426: PUSH
45427: LD_INT 3
45429: NEG
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 0
45437: PUSH
45438: LD_INT 3
45440: NEG
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 1
45448: NEG
45449: PUSH
45450: LD_INT 4
45452: NEG
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: LD_INT 1
45460: NEG
45461: PUSH
45462: LD_INT 5
45464: NEG
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PUSH
45470: LD_INT 2
45472: PUSH
45473: LD_INT 3
45475: NEG
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 2
45483: NEG
45484: PUSH
45485: LD_INT 5
45487: NEG
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: PUSH
45493: LD_INT 3
45495: PUSH
45496: LD_INT 0
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 3
45505: PUSH
45506: LD_INT 1
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 4
45516: PUSH
45517: LD_INT 0
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 4
45526: PUSH
45527: LD_INT 1
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 3
45536: PUSH
45537: LD_INT 1
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PUSH
45544: LD_INT 2
45546: PUSH
45547: LD_INT 0
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 2
45556: PUSH
45557: LD_INT 1
45559: NEG
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: PUSH
45565: LD_INT 2
45567: PUSH
45568: LD_INT 2
45570: NEG
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 2
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 4
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 4
45598: PUSH
45599: LD_INT 3
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 5
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 5
45618: PUSH
45619: LD_INT 5
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 4
45628: PUSH
45629: LD_INT 5
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: LD_INT 3
45638: PUSH
45639: LD_INT 4
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 3
45648: PUSH
45649: LD_INT 3
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: PUSH
45656: LD_INT 5
45658: PUSH
45659: LD_INT 3
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 3
45668: PUSH
45669: LD_INT 5
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 0
45678: PUSH
45679: LD_INT 3
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: LD_INT 2
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: LD_INT 3
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 4
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 3
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 2
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 2
45750: PUSH
45751: LD_INT 4
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: LD_INT 2
45760: NEG
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 4
45771: NEG
45772: PUSH
45773: LD_INT 0
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 4
45782: NEG
45783: PUSH
45784: LD_INT 1
45786: NEG
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 3
45794: NEG
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 4
45816: NEG
45817: PUSH
45818: LD_INT 1
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PUSH
45825: LD_INT 5
45827: NEG
45828: PUSH
45829: LD_INT 0
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 5
45838: NEG
45839: PUSH
45840: LD_INT 1
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 5
45850: NEG
45851: PUSH
45852: LD_INT 2
45854: NEG
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 3
45862: NEG
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: EMPTY
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: ST_TO_ADDR
// end ; end ;
45918: GO 45921
45920: POP
// case btype of b_depot , b_warehouse :
45921: LD_VAR 0 1
45925: PUSH
45926: LD_INT 0
45928: DOUBLE
45929: EQUAL
45930: IFTRUE 45940
45932: LD_INT 1
45934: DOUBLE
45935: EQUAL
45936: IFTRUE 45940
45938: GO 46141
45940: POP
// case nation of nation_american :
45941: LD_VAR 0 5
45945: PUSH
45946: LD_INT 1
45948: DOUBLE
45949: EQUAL
45950: IFTRUE 45954
45952: GO 46010
45954: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45955: LD_ADDR_VAR 0 9
45959: PUSH
45960: LD_VAR 0 11
45964: PUSH
45965: LD_VAR 0 12
45969: PUSH
45970: LD_VAR 0 13
45974: PUSH
45975: LD_VAR 0 14
45979: PUSH
45980: LD_VAR 0 15
45984: PUSH
45985: LD_VAR 0 16
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: PUSH
45998: LD_VAR 0 4
46002: PUSH
46003: LD_INT 1
46005: PLUS
46006: ARRAY
46007: ST_TO_ADDR
46008: GO 46139
46010: LD_INT 2
46012: DOUBLE
46013: EQUAL
46014: IFTRUE 46018
46016: GO 46074
46018: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46019: LD_ADDR_VAR 0 9
46023: PUSH
46024: LD_VAR 0 17
46028: PUSH
46029: LD_VAR 0 18
46033: PUSH
46034: LD_VAR 0 19
46038: PUSH
46039: LD_VAR 0 20
46043: PUSH
46044: LD_VAR 0 21
46048: PUSH
46049: LD_VAR 0 22
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: LIST
46061: PUSH
46062: LD_VAR 0 4
46066: PUSH
46067: LD_INT 1
46069: PLUS
46070: ARRAY
46071: ST_TO_ADDR
46072: GO 46139
46074: LD_INT 3
46076: DOUBLE
46077: EQUAL
46078: IFTRUE 46082
46080: GO 46138
46082: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46083: LD_ADDR_VAR 0 9
46087: PUSH
46088: LD_VAR 0 23
46092: PUSH
46093: LD_VAR 0 24
46097: PUSH
46098: LD_VAR 0 25
46102: PUSH
46103: LD_VAR 0 26
46107: PUSH
46108: LD_VAR 0 27
46112: PUSH
46113: LD_VAR 0 28
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: PUSH
46126: LD_VAR 0 4
46130: PUSH
46131: LD_INT 1
46133: PLUS
46134: ARRAY
46135: ST_TO_ADDR
46136: GO 46139
46138: POP
46139: GO 46694
46141: LD_INT 2
46143: DOUBLE
46144: EQUAL
46145: IFTRUE 46155
46147: LD_INT 3
46149: DOUBLE
46150: EQUAL
46151: IFTRUE 46155
46153: GO 46211
46155: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46156: LD_ADDR_VAR 0 9
46160: PUSH
46161: LD_VAR 0 29
46165: PUSH
46166: LD_VAR 0 30
46170: PUSH
46171: LD_VAR 0 31
46175: PUSH
46176: LD_VAR 0 32
46180: PUSH
46181: LD_VAR 0 33
46185: PUSH
46186: LD_VAR 0 34
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: PUSH
46199: LD_VAR 0 4
46203: PUSH
46204: LD_INT 1
46206: PLUS
46207: ARRAY
46208: ST_TO_ADDR
46209: GO 46694
46211: LD_INT 16
46213: DOUBLE
46214: EQUAL
46215: IFTRUE 46273
46217: LD_INT 17
46219: DOUBLE
46220: EQUAL
46221: IFTRUE 46273
46223: LD_INT 18
46225: DOUBLE
46226: EQUAL
46227: IFTRUE 46273
46229: LD_INT 19
46231: DOUBLE
46232: EQUAL
46233: IFTRUE 46273
46235: LD_INT 22
46237: DOUBLE
46238: EQUAL
46239: IFTRUE 46273
46241: LD_INT 20
46243: DOUBLE
46244: EQUAL
46245: IFTRUE 46273
46247: LD_INT 21
46249: DOUBLE
46250: EQUAL
46251: IFTRUE 46273
46253: LD_INT 23
46255: DOUBLE
46256: EQUAL
46257: IFTRUE 46273
46259: LD_INT 24
46261: DOUBLE
46262: EQUAL
46263: IFTRUE 46273
46265: LD_INT 25
46267: DOUBLE
46268: EQUAL
46269: IFTRUE 46273
46271: GO 46329
46273: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46274: LD_ADDR_VAR 0 9
46278: PUSH
46279: LD_VAR 0 35
46283: PUSH
46284: LD_VAR 0 36
46288: PUSH
46289: LD_VAR 0 37
46293: PUSH
46294: LD_VAR 0 38
46298: PUSH
46299: LD_VAR 0 39
46303: PUSH
46304: LD_VAR 0 40
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: PUSH
46317: LD_VAR 0 4
46321: PUSH
46322: LD_INT 1
46324: PLUS
46325: ARRAY
46326: ST_TO_ADDR
46327: GO 46694
46329: LD_INT 6
46331: DOUBLE
46332: EQUAL
46333: IFTRUE 46385
46335: LD_INT 7
46337: DOUBLE
46338: EQUAL
46339: IFTRUE 46385
46341: LD_INT 8
46343: DOUBLE
46344: EQUAL
46345: IFTRUE 46385
46347: LD_INT 13
46349: DOUBLE
46350: EQUAL
46351: IFTRUE 46385
46353: LD_INT 12
46355: DOUBLE
46356: EQUAL
46357: IFTRUE 46385
46359: LD_INT 15
46361: DOUBLE
46362: EQUAL
46363: IFTRUE 46385
46365: LD_INT 11
46367: DOUBLE
46368: EQUAL
46369: IFTRUE 46385
46371: LD_INT 14
46373: DOUBLE
46374: EQUAL
46375: IFTRUE 46385
46377: LD_INT 10
46379: DOUBLE
46380: EQUAL
46381: IFTRUE 46385
46383: GO 46441
46385: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46386: LD_ADDR_VAR 0 9
46390: PUSH
46391: LD_VAR 0 41
46395: PUSH
46396: LD_VAR 0 42
46400: PUSH
46401: LD_VAR 0 43
46405: PUSH
46406: LD_VAR 0 44
46410: PUSH
46411: LD_VAR 0 45
46415: PUSH
46416: LD_VAR 0 46
46420: PUSH
46421: EMPTY
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: PUSH
46429: LD_VAR 0 4
46433: PUSH
46434: LD_INT 1
46436: PLUS
46437: ARRAY
46438: ST_TO_ADDR
46439: GO 46694
46441: LD_INT 36
46443: DOUBLE
46444: EQUAL
46445: IFTRUE 46449
46447: GO 46505
46449: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46450: LD_ADDR_VAR 0 9
46454: PUSH
46455: LD_VAR 0 47
46459: PUSH
46460: LD_VAR 0 48
46464: PUSH
46465: LD_VAR 0 49
46469: PUSH
46470: LD_VAR 0 50
46474: PUSH
46475: LD_VAR 0 51
46479: PUSH
46480: LD_VAR 0 52
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: PUSH
46493: LD_VAR 0 4
46497: PUSH
46498: LD_INT 1
46500: PLUS
46501: ARRAY
46502: ST_TO_ADDR
46503: GO 46694
46505: LD_INT 4
46507: DOUBLE
46508: EQUAL
46509: IFTRUE 46531
46511: LD_INT 5
46513: DOUBLE
46514: EQUAL
46515: IFTRUE 46531
46517: LD_INT 34
46519: DOUBLE
46520: EQUAL
46521: IFTRUE 46531
46523: LD_INT 37
46525: DOUBLE
46526: EQUAL
46527: IFTRUE 46531
46529: GO 46587
46531: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46532: LD_ADDR_VAR 0 9
46536: PUSH
46537: LD_VAR 0 53
46541: PUSH
46542: LD_VAR 0 54
46546: PUSH
46547: LD_VAR 0 55
46551: PUSH
46552: LD_VAR 0 56
46556: PUSH
46557: LD_VAR 0 57
46561: PUSH
46562: LD_VAR 0 58
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: PUSH
46575: LD_VAR 0 4
46579: PUSH
46580: LD_INT 1
46582: PLUS
46583: ARRAY
46584: ST_TO_ADDR
46585: GO 46694
46587: LD_INT 31
46589: DOUBLE
46590: EQUAL
46591: IFTRUE 46637
46593: LD_INT 32
46595: DOUBLE
46596: EQUAL
46597: IFTRUE 46637
46599: LD_INT 33
46601: DOUBLE
46602: EQUAL
46603: IFTRUE 46637
46605: LD_INT 27
46607: DOUBLE
46608: EQUAL
46609: IFTRUE 46637
46611: LD_INT 26
46613: DOUBLE
46614: EQUAL
46615: IFTRUE 46637
46617: LD_INT 28
46619: DOUBLE
46620: EQUAL
46621: IFTRUE 46637
46623: LD_INT 29
46625: DOUBLE
46626: EQUAL
46627: IFTRUE 46637
46629: LD_INT 30
46631: DOUBLE
46632: EQUAL
46633: IFTRUE 46637
46635: GO 46693
46637: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46638: LD_ADDR_VAR 0 9
46642: PUSH
46643: LD_VAR 0 59
46647: PUSH
46648: LD_VAR 0 60
46652: PUSH
46653: LD_VAR 0 61
46657: PUSH
46658: LD_VAR 0 62
46662: PUSH
46663: LD_VAR 0 63
46667: PUSH
46668: LD_VAR 0 64
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: PUSH
46681: LD_VAR 0 4
46685: PUSH
46686: LD_INT 1
46688: PLUS
46689: ARRAY
46690: ST_TO_ADDR
46691: GO 46694
46693: POP
// temp_list2 = [ ] ;
46694: LD_ADDR_VAR 0 10
46698: PUSH
46699: EMPTY
46700: ST_TO_ADDR
// for i in temp_list do
46701: LD_ADDR_VAR 0 8
46705: PUSH
46706: LD_VAR 0 9
46710: PUSH
46711: FOR_IN
46712: IFFALSE 46764
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46714: LD_ADDR_VAR 0 10
46718: PUSH
46719: LD_VAR 0 10
46723: PUSH
46724: LD_VAR 0 8
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PUSH
46733: LD_VAR 0 2
46737: PLUS
46738: PUSH
46739: LD_VAR 0 8
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PUSH
46748: LD_VAR 0 3
46752: PLUS
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: EMPTY
46759: LIST
46760: ADD
46761: ST_TO_ADDR
46762: GO 46711
46764: POP
46765: POP
// result = temp_list2 ;
46766: LD_ADDR_VAR 0 7
46770: PUSH
46771: LD_VAR 0 10
46775: ST_TO_ADDR
// end ;
46776: LD_VAR 0 7
46780: RET
// export function EnemyInRange ( unit , dist ) ; begin
46781: LD_INT 0
46783: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46784: LD_ADDR_VAR 0 3
46788: PUSH
46789: LD_VAR 0 1
46793: PPUSH
46794: CALL_OW 255
46798: PPUSH
46799: LD_VAR 0 1
46803: PPUSH
46804: CALL_OW 250
46808: PPUSH
46809: LD_VAR 0 1
46813: PPUSH
46814: CALL_OW 251
46818: PPUSH
46819: LD_VAR 0 2
46823: PPUSH
46824: CALL 20582 0 4
46828: PUSH
46829: LD_INT 4
46831: ARRAY
46832: ST_TO_ADDR
// end ;
46833: LD_VAR 0 3
46837: RET
// export function PlayerSeeMe ( unit ) ; begin
46838: LD_INT 0
46840: PPUSH
// result := See ( your_side , unit ) ;
46841: LD_ADDR_VAR 0 2
46845: PUSH
46846: LD_OWVAR 2
46850: PPUSH
46851: LD_VAR 0 1
46855: PPUSH
46856: CALL_OW 292
46860: ST_TO_ADDR
// end ;
46861: LD_VAR 0 2
46865: RET
// export function ReverseDir ( unit ) ; begin
46866: LD_INT 0
46868: PPUSH
// if not unit then
46869: LD_VAR 0 1
46873: NOT
46874: IFFALSE 46878
// exit ;
46876: GO 46901
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46878: LD_ADDR_VAR 0 2
46882: PUSH
46883: LD_VAR 0 1
46887: PPUSH
46888: CALL_OW 254
46892: PUSH
46893: LD_INT 3
46895: PLUS
46896: PUSH
46897: LD_INT 6
46899: MOD
46900: ST_TO_ADDR
// end ;
46901: LD_VAR 0 2
46905: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46906: LD_INT 0
46908: PPUSH
46909: PPUSH
46910: PPUSH
46911: PPUSH
46912: PPUSH
// if not hexes then
46913: LD_VAR 0 2
46917: NOT
46918: IFFALSE 46922
// exit ;
46920: GO 47070
// dist := 9999 ;
46922: LD_ADDR_VAR 0 5
46926: PUSH
46927: LD_INT 9999
46929: ST_TO_ADDR
// for i = 1 to hexes do
46930: LD_ADDR_VAR 0 4
46934: PUSH
46935: DOUBLE
46936: LD_INT 1
46938: DEC
46939: ST_TO_ADDR
46940: LD_VAR 0 2
46944: PUSH
46945: FOR_TO
46946: IFFALSE 47058
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46948: LD_VAR 0 1
46952: PPUSH
46953: LD_VAR 0 2
46957: PUSH
46958: LD_VAR 0 4
46962: ARRAY
46963: PUSH
46964: LD_INT 1
46966: ARRAY
46967: PPUSH
46968: LD_VAR 0 2
46972: PUSH
46973: LD_VAR 0 4
46977: ARRAY
46978: PUSH
46979: LD_INT 2
46981: ARRAY
46982: PPUSH
46983: CALL_OW 297
46987: PUSH
46988: LD_VAR 0 5
46992: LESS
46993: IFFALSE 47056
// begin hex := hexes [ i ] ;
46995: LD_ADDR_VAR 0 7
46999: PUSH
47000: LD_VAR 0 2
47004: PUSH
47005: LD_VAR 0 4
47009: ARRAY
47010: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47011: LD_ADDR_VAR 0 5
47015: PUSH
47016: LD_VAR 0 1
47020: PPUSH
47021: LD_VAR 0 2
47025: PUSH
47026: LD_VAR 0 4
47030: ARRAY
47031: PUSH
47032: LD_INT 1
47034: ARRAY
47035: PPUSH
47036: LD_VAR 0 2
47040: PUSH
47041: LD_VAR 0 4
47045: ARRAY
47046: PUSH
47047: LD_INT 2
47049: ARRAY
47050: PPUSH
47051: CALL_OW 297
47055: ST_TO_ADDR
// end ; end ;
47056: GO 46945
47058: POP
47059: POP
// result := hex ;
47060: LD_ADDR_VAR 0 3
47064: PUSH
47065: LD_VAR 0 7
47069: ST_TO_ADDR
// end ;
47070: LD_VAR 0 3
47074: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47075: LD_INT 0
47077: PPUSH
47078: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47079: LD_VAR 0 1
47083: NOT
47084: PUSH
47085: LD_VAR 0 1
47089: PUSH
47090: LD_INT 21
47092: PUSH
47093: LD_INT 2
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 23
47102: PUSH
47103: LD_INT 2
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PPUSH
47114: CALL_OW 69
47118: IN
47119: NOT
47120: OR
47121: IFFALSE 47125
// exit ;
47123: GO 47172
// for i = 1 to 3 do
47125: LD_ADDR_VAR 0 3
47129: PUSH
47130: DOUBLE
47131: LD_INT 1
47133: DEC
47134: ST_TO_ADDR
47135: LD_INT 3
47137: PUSH
47138: FOR_TO
47139: IFFALSE 47170
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47141: LD_VAR 0 1
47145: PPUSH
47146: CALL_OW 250
47150: PPUSH
47151: LD_VAR 0 1
47155: PPUSH
47156: CALL_OW 251
47160: PPUSH
47161: LD_INT 1
47163: PPUSH
47164: CALL_OW 453
47168: GO 47138
47170: POP
47171: POP
// end ;
47172: LD_VAR 0 2
47176: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47177: LD_INT 0
47179: PPUSH
47180: PPUSH
47181: PPUSH
47182: PPUSH
47183: PPUSH
47184: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47185: LD_VAR 0 1
47189: NOT
47190: PUSH
47191: LD_VAR 0 2
47195: NOT
47196: OR
47197: PUSH
47198: LD_VAR 0 1
47202: PPUSH
47203: CALL_OW 314
47207: OR
47208: IFFALSE 47212
// exit ;
47210: GO 47653
// x := GetX ( enemy_unit ) ;
47212: LD_ADDR_VAR 0 7
47216: PUSH
47217: LD_VAR 0 2
47221: PPUSH
47222: CALL_OW 250
47226: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47227: LD_ADDR_VAR 0 8
47231: PUSH
47232: LD_VAR 0 2
47236: PPUSH
47237: CALL_OW 251
47241: ST_TO_ADDR
// if not x or not y then
47242: LD_VAR 0 7
47246: NOT
47247: PUSH
47248: LD_VAR 0 8
47252: NOT
47253: OR
47254: IFFALSE 47258
// exit ;
47256: GO 47653
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47258: LD_ADDR_VAR 0 6
47262: PUSH
47263: LD_VAR 0 7
47267: PPUSH
47268: LD_INT 0
47270: PPUSH
47271: LD_INT 4
47273: PPUSH
47274: CALL_OW 272
47278: PUSH
47279: LD_VAR 0 8
47283: PPUSH
47284: LD_INT 0
47286: PPUSH
47287: LD_INT 4
47289: PPUSH
47290: CALL_OW 273
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_VAR 0 7
47303: PPUSH
47304: LD_INT 1
47306: PPUSH
47307: LD_INT 4
47309: PPUSH
47310: CALL_OW 272
47314: PUSH
47315: LD_VAR 0 8
47319: PPUSH
47320: LD_INT 1
47322: PPUSH
47323: LD_INT 4
47325: PPUSH
47326: CALL_OW 273
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_VAR 0 7
47339: PPUSH
47340: LD_INT 2
47342: PPUSH
47343: LD_INT 4
47345: PPUSH
47346: CALL_OW 272
47350: PUSH
47351: LD_VAR 0 8
47355: PPUSH
47356: LD_INT 2
47358: PPUSH
47359: LD_INT 4
47361: PPUSH
47362: CALL_OW 273
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PUSH
47371: LD_VAR 0 7
47375: PPUSH
47376: LD_INT 3
47378: PPUSH
47379: LD_INT 4
47381: PPUSH
47382: CALL_OW 272
47386: PUSH
47387: LD_VAR 0 8
47391: PPUSH
47392: LD_INT 3
47394: PPUSH
47395: LD_INT 4
47397: PPUSH
47398: CALL_OW 273
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_VAR 0 7
47411: PPUSH
47412: LD_INT 4
47414: PPUSH
47415: LD_INT 4
47417: PPUSH
47418: CALL_OW 272
47422: PUSH
47423: LD_VAR 0 8
47427: PPUSH
47428: LD_INT 4
47430: PPUSH
47431: LD_INT 4
47433: PPUSH
47434: CALL_OW 273
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PUSH
47443: LD_VAR 0 7
47447: PPUSH
47448: LD_INT 5
47450: PPUSH
47451: LD_INT 4
47453: PPUSH
47454: CALL_OW 272
47458: PUSH
47459: LD_VAR 0 8
47463: PPUSH
47464: LD_INT 5
47466: PPUSH
47467: LD_INT 4
47469: PPUSH
47470: CALL_OW 273
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: ST_TO_ADDR
// for i = tmp downto 1 do
47487: LD_ADDR_VAR 0 4
47491: PUSH
47492: DOUBLE
47493: LD_VAR 0 6
47497: INC
47498: ST_TO_ADDR
47499: LD_INT 1
47501: PUSH
47502: FOR_DOWNTO
47503: IFFALSE 47604
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47505: LD_VAR 0 6
47509: PUSH
47510: LD_VAR 0 4
47514: ARRAY
47515: PUSH
47516: LD_INT 1
47518: ARRAY
47519: PPUSH
47520: LD_VAR 0 6
47524: PUSH
47525: LD_VAR 0 4
47529: ARRAY
47530: PUSH
47531: LD_INT 2
47533: ARRAY
47534: PPUSH
47535: CALL_OW 488
47539: NOT
47540: PUSH
47541: LD_VAR 0 6
47545: PUSH
47546: LD_VAR 0 4
47550: ARRAY
47551: PUSH
47552: LD_INT 1
47554: ARRAY
47555: PPUSH
47556: LD_VAR 0 6
47560: PUSH
47561: LD_VAR 0 4
47565: ARRAY
47566: PUSH
47567: LD_INT 2
47569: ARRAY
47570: PPUSH
47571: CALL_OW 428
47575: PUSH
47576: LD_INT 0
47578: NONEQUAL
47579: OR
47580: IFFALSE 47602
// tmp := Delete ( tmp , i ) ;
47582: LD_ADDR_VAR 0 6
47586: PUSH
47587: LD_VAR 0 6
47591: PPUSH
47592: LD_VAR 0 4
47596: PPUSH
47597: CALL_OW 3
47601: ST_TO_ADDR
47602: GO 47502
47604: POP
47605: POP
// j := GetClosestHex ( unit , tmp ) ;
47606: LD_ADDR_VAR 0 5
47610: PUSH
47611: LD_VAR 0 1
47615: PPUSH
47616: LD_VAR 0 6
47620: PPUSH
47621: CALL 46906 0 2
47625: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47626: LD_VAR 0 1
47630: PPUSH
47631: LD_VAR 0 5
47635: PUSH
47636: LD_INT 1
47638: ARRAY
47639: PPUSH
47640: LD_VAR 0 5
47644: PUSH
47645: LD_INT 2
47647: ARRAY
47648: PPUSH
47649: CALL_OW 111
// end ;
47653: LD_VAR 0 3
47657: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47658: LD_INT 0
47660: PPUSH
47661: PPUSH
47662: PPUSH
// uc_side = 0 ;
47663: LD_ADDR_OWVAR 20
47667: PUSH
47668: LD_INT 0
47670: ST_TO_ADDR
// uc_nation = 0 ;
47671: LD_ADDR_OWVAR 21
47675: PUSH
47676: LD_INT 0
47678: ST_TO_ADDR
// InitHc_All ( ) ;
47679: CALL_OW 584
// InitVc ;
47683: CALL_OW 20
// if mastodonts then
47687: LD_VAR 0 6
47691: IFFALSE 47758
// for i = 1 to mastodonts do
47693: LD_ADDR_VAR 0 11
47697: PUSH
47698: DOUBLE
47699: LD_INT 1
47701: DEC
47702: ST_TO_ADDR
47703: LD_VAR 0 6
47707: PUSH
47708: FOR_TO
47709: IFFALSE 47756
// begin vc_chassis := 31 ;
47711: LD_ADDR_OWVAR 37
47715: PUSH
47716: LD_INT 31
47718: ST_TO_ADDR
// vc_control := control_rider ;
47719: LD_ADDR_OWVAR 38
47723: PUSH
47724: LD_INT 4
47726: ST_TO_ADDR
// animal := CreateVehicle ;
47727: LD_ADDR_VAR 0 12
47731: PUSH
47732: CALL_OW 45
47736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47737: LD_VAR 0 12
47741: PPUSH
47742: LD_VAR 0 8
47746: PPUSH
47747: LD_INT 0
47749: PPUSH
47750: CALL 49946 0 3
// end ;
47754: GO 47708
47756: POP
47757: POP
// if horses then
47758: LD_VAR 0 5
47762: IFFALSE 47829
// for i = 1 to horses do
47764: LD_ADDR_VAR 0 11
47768: PUSH
47769: DOUBLE
47770: LD_INT 1
47772: DEC
47773: ST_TO_ADDR
47774: LD_VAR 0 5
47778: PUSH
47779: FOR_TO
47780: IFFALSE 47827
// begin hc_class := 21 ;
47782: LD_ADDR_OWVAR 28
47786: PUSH
47787: LD_INT 21
47789: ST_TO_ADDR
// hc_gallery :=  ;
47790: LD_ADDR_OWVAR 33
47794: PUSH
47795: LD_STRING 
47797: ST_TO_ADDR
// animal := CreateHuman ;
47798: LD_ADDR_VAR 0 12
47802: PUSH
47803: CALL_OW 44
47807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47808: LD_VAR 0 12
47812: PPUSH
47813: LD_VAR 0 8
47817: PPUSH
47818: LD_INT 0
47820: PPUSH
47821: CALL 49946 0 3
// end ;
47825: GO 47779
47827: POP
47828: POP
// if birds then
47829: LD_VAR 0 1
47833: IFFALSE 47900
// for i = 1 to birds do
47835: LD_ADDR_VAR 0 11
47839: PUSH
47840: DOUBLE
47841: LD_INT 1
47843: DEC
47844: ST_TO_ADDR
47845: LD_VAR 0 1
47849: PUSH
47850: FOR_TO
47851: IFFALSE 47898
// begin hc_class = 18 ;
47853: LD_ADDR_OWVAR 28
47857: PUSH
47858: LD_INT 18
47860: ST_TO_ADDR
// hc_gallery =  ;
47861: LD_ADDR_OWVAR 33
47865: PUSH
47866: LD_STRING 
47868: ST_TO_ADDR
// animal := CreateHuman ;
47869: LD_ADDR_VAR 0 12
47873: PUSH
47874: CALL_OW 44
47878: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47879: LD_VAR 0 12
47883: PPUSH
47884: LD_VAR 0 8
47888: PPUSH
47889: LD_INT 0
47891: PPUSH
47892: CALL 49946 0 3
// end ;
47896: GO 47850
47898: POP
47899: POP
// if tigers then
47900: LD_VAR 0 2
47904: IFFALSE 47988
// for i = 1 to tigers do
47906: LD_ADDR_VAR 0 11
47910: PUSH
47911: DOUBLE
47912: LD_INT 1
47914: DEC
47915: ST_TO_ADDR
47916: LD_VAR 0 2
47920: PUSH
47921: FOR_TO
47922: IFFALSE 47986
// begin hc_class = class_tiger ;
47924: LD_ADDR_OWVAR 28
47928: PUSH
47929: LD_INT 14
47931: ST_TO_ADDR
// hc_gallery =  ;
47932: LD_ADDR_OWVAR 33
47936: PUSH
47937: LD_STRING 
47939: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47940: LD_ADDR_OWVAR 35
47944: PUSH
47945: LD_INT 7
47947: NEG
47948: PPUSH
47949: LD_INT 7
47951: PPUSH
47952: CALL_OW 12
47956: ST_TO_ADDR
// animal := CreateHuman ;
47957: LD_ADDR_VAR 0 12
47961: PUSH
47962: CALL_OW 44
47966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47967: LD_VAR 0 12
47971: PPUSH
47972: LD_VAR 0 8
47976: PPUSH
47977: LD_INT 0
47979: PPUSH
47980: CALL 49946 0 3
// end ;
47984: GO 47921
47986: POP
47987: POP
// if apemans then
47988: LD_VAR 0 3
47992: IFFALSE 48115
// for i = 1 to apemans do
47994: LD_ADDR_VAR 0 11
47998: PUSH
47999: DOUBLE
48000: LD_INT 1
48002: DEC
48003: ST_TO_ADDR
48004: LD_VAR 0 3
48008: PUSH
48009: FOR_TO
48010: IFFALSE 48113
// begin hc_class = class_apeman ;
48012: LD_ADDR_OWVAR 28
48016: PUSH
48017: LD_INT 12
48019: ST_TO_ADDR
// hc_gallery =  ;
48020: LD_ADDR_OWVAR 33
48024: PUSH
48025: LD_STRING 
48027: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48028: LD_ADDR_OWVAR 35
48032: PUSH
48033: LD_INT 5
48035: NEG
48036: PPUSH
48037: LD_INT 5
48039: PPUSH
48040: CALL_OW 12
48044: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48045: LD_ADDR_OWVAR 31
48049: PUSH
48050: LD_INT 1
48052: PPUSH
48053: LD_INT 3
48055: PPUSH
48056: CALL_OW 12
48060: PUSH
48061: LD_INT 1
48063: PPUSH
48064: LD_INT 3
48066: PPUSH
48067: CALL_OW 12
48071: PUSH
48072: LD_INT 0
48074: PUSH
48075: LD_INT 0
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: ST_TO_ADDR
// animal := CreateHuman ;
48084: LD_ADDR_VAR 0 12
48088: PUSH
48089: CALL_OW 44
48093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48094: LD_VAR 0 12
48098: PPUSH
48099: LD_VAR 0 8
48103: PPUSH
48104: LD_INT 0
48106: PPUSH
48107: CALL 49946 0 3
// end ;
48111: GO 48009
48113: POP
48114: POP
// if enchidnas then
48115: LD_VAR 0 4
48119: IFFALSE 48186
// for i = 1 to enchidnas do
48121: LD_ADDR_VAR 0 11
48125: PUSH
48126: DOUBLE
48127: LD_INT 1
48129: DEC
48130: ST_TO_ADDR
48131: LD_VAR 0 4
48135: PUSH
48136: FOR_TO
48137: IFFALSE 48184
// begin hc_class = 13 ;
48139: LD_ADDR_OWVAR 28
48143: PUSH
48144: LD_INT 13
48146: ST_TO_ADDR
// hc_gallery =  ;
48147: LD_ADDR_OWVAR 33
48151: PUSH
48152: LD_STRING 
48154: ST_TO_ADDR
// animal := CreateHuman ;
48155: LD_ADDR_VAR 0 12
48159: PUSH
48160: CALL_OW 44
48164: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48165: LD_VAR 0 12
48169: PPUSH
48170: LD_VAR 0 8
48174: PPUSH
48175: LD_INT 0
48177: PPUSH
48178: CALL 49946 0 3
// end ;
48182: GO 48136
48184: POP
48185: POP
// if fishes then
48186: LD_VAR 0 7
48190: IFFALSE 48257
// for i = 1 to fishes do
48192: LD_ADDR_VAR 0 11
48196: PUSH
48197: DOUBLE
48198: LD_INT 1
48200: DEC
48201: ST_TO_ADDR
48202: LD_VAR 0 7
48206: PUSH
48207: FOR_TO
48208: IFFALSE 48255
// begin hc_class = 20 ;
48210: LD_ADDR_OWVAR 28
48214: PUSH
48215: LD_INT 20
48217: ST_TO_ADDR
// hc_gallery =  ;
48218: LD_ADDR_OWVAR 33
48222: PUSH
48223: LD_STRING 
48225: ST_TO_ADDR
// animal := CreateHuman ;
48226: LD_ADDR_VAR 0 12
48230: PUSH
48231: CALL_OW 44
48235: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48236: LD_VAR 0 12
48240: PPUSH
48241: LD_VAR 0 9
48245: PPUSH
48246: LD_INT 0
48248: PPUSH
48249: CALL 49946 0 3
// end ;
48253: GO 48207
48255: POP
48256: POP
// end ;
48257: LD_VAR 0 10
48261: RET
// export function WantHeal ( sci , unit ) ; begin
48262: LD_INT 0
48264: PPUSH
// if GetTaskList ( sci ) > 0 then
48265: LD_VAR 0 1
48269: PPUSH
48270: CALL_OW 437
48274: PUSH
48275: LD_INT 0
48277: GREATER
48278: IFFALSE 48348
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48280: LD_VAR 0 1
48284: PPUSH
48285: CALL_OW 437
48289: PUSH
48290: LD_INT 1
48292: ARRAY
48293: PUSH
48294: LD_INT 1
48296: ARRAY
48297: PUSH
48298: LD_STRING l
48300: EQUAL
48301: PUSH
48302: LD_VAR 0 1
48306: PPUSH
48307: CALL_OW 437
48311: PUSH
48312: LD_INT 1
48314: ARRAY
48315: PUSH
48316: LD_INT 4
48318: ARRAY
48319: PUSH
48320: LD_VAR 0 2
48324: EQUAL
48325: AND
48326: IFFALSE 48338
// result := true else
48328: LD_ADDR_VAR 0 3
48332: PUSH
48333: LD_INT 1
48335: ST_TO_ADDR
48336: GO 48346
// result := false ;
48338: LD_ADDR_VAR 0 3
48342: PUSH
48343: LD_INT 0
48345: ST_TO_ADDR
// end else
48346: GO 48356
// result := false ;
48348: LD_ADDR_VAR 0 3
48352: PUSH
48353: LD_INT 0
48355: ST_TO_ADDR
// end ;
48356: LD_VAR 0 3
48360: RET
// export function HealTarget ( sci ) ; begin
48361: LD_INT 0
48363: PPUSH
// if not sci then
48364: LD_VAR 0 1
48368: NOT
48369: IFFALSE 48373
// exit ;
48371: GO 48438
// result := 0 ;
48373: LD_ADDR_VAR 0 2
48377: PUSH
48378: LD_INT 0
48380: ST_TO_ADDR
// if GetTaskList ( sci ) then
48381: LD_VAR 0 1
48385: PPUSH
48386: CALL_OW 437
48390: IFFALSE 48438
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48392: LD_VAR 0 1
48396: PPUSH
48397: CALL_OW 437
48401: PUSH
48402: LD_INT 1
48404: ARRAY
48405: PUSH
48406: LD_INT 1
48408: ARRAY
48409: PUSH
48410: LD_STRING l
48412: EQUAL
48413: IFFALSE 48438
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48415: LD_ADDR_VAR 0 2
48419: PUSH
48420: LD_VAR 0 1
48424: PPUSH
48425: CALL_OW 437
48429: PUSH
48430: LD_INT 1
48432: ARRAY
48433: PUSH
48434: LD_INT 4
48436: ARRAY
48437: ST_TO_ADDR
// end ;
48438: LD_VAR 0 2
48442: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48443: LD_INT 0
48445: PPUSH
48446: PPUSH
48447: PPUSH
48448: PPUSH
// if not base_units then
48449: LD_VAR 0 1
48453: NOT
48454: IFFALSE 48458
// exit ;
48456: GO 48545
// result := false ;
48458: LD_ADDR_VAR 0 2
48462: PUSH
48463: LD_INT 0
48465: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48466: LD_ADDR_VAR 0 5
48470: PUSH
48471: LD_VAR 0 1
48475: PPUSH
48476: LD_INT 21
48478: PUSH
48479: LD_INT 3
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PPUSH
48486: CALL_OW 72
48490: ST_TO_ADDR
// if not tmp then
48491: LD_VAR 0 5
48495: NOT
48496: IFFALSE 48500
// exit ;
48498: GO 48545
// for i in tmp do
48500: LD_ADDR_VAR 0 3
48504: PUSH
48505: LD_VAR 0 5
48509: PUSH
48510: FOR_IN
48511: IFFALSE 48543
// begin result := EnemyInRange ( i , 22 ) ;
48513: LD_ADDR_VAR 0 2
48517: PUSH
48518: LD_VAR 0 3
48522: PPUSH
48523: LD_INT 22
48525: PPUSH
48526: CALL 46781 0 2
48530: ST_TO_ADDR
// if result then
48531: LD_VAR 0 2
48535: IFFALSE 48541
// exit ;
48537: POP
48538: POP
48539: GO 48545
// end ;
48541: GO 48510
48543: POP
48544: POP
// end ;
48545: LD_VAR 0 2
48549: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48550: LD_INT 0
48552: PPUSH
48553: PPUSH
// if not units then
48554: LD_VAR 0 1
48558: NOT
48559: IFFALSE 48563
// exit ;
48561: GO 48633
// result := [ ] ;
48563: LD_ADDR_VAR 0 3
48567: PUSH
48568: EMPTY
48569: ST_TO_ADDR
// for i in units do
48570: LD_ADDR_VAR 0 4
48574: PUSH
48575: LD_VAR 0 1
48579: PUSH
48580: FOR_IN
48581: IFFALSE 48631
// if GetTag ( i ) = tag then
48583: LD_VAR 0 4
48587: PPUSH
48588: CALL_OW 110
48592: PUSH
48593: LD_VAR 0 2
48597: EQUAL
48598: IFFALSE 48629
// result := Insert ( result , result + 1 , i ) ;
48600: LD_ADDR_VAR 0 3
48604: PUSH
48605: LD_VAR 0 3
48609: PPUSH
48610: LD_VAR 0 3
48614: PUSH
48615: LD_INT 1
48617: PLUS
48618: PPUSH
48619: LD_VAR 0 4
48623: PPUSH
48624: CALL_OW 2
48628: ST_TO_ADDR
48629: GO 48580
48631: POP
48632: POP
// end ;
48633: LD_VAR 0 3
48637: RET
// export function IsDriver ( un ) ; begin
48638: LD_INT 0
48640: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48641: LD_ADDR_VAR 0 2
48645: PUSH
48646: LD_VAR 0 1
48650: PUSH
48651: LD_INT 55
48653: PUSH
48654: EMPTY
48655: LIST
48656: PPUSH
48657: CALL_OW 69
48661: IN
48662: ST_TO_ADDR
// end ;
48663: LD_VAR 0 2
48667: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48668: LD_INT 0
48670: PPUSH
48671: PPUSH
// list := [ ] ;
48672: LD_ADDR_VAR 0 5
48676: PUSH
48677: EMPTY
48678: ST_TO_ADDR
// case d of 0 :
48679: LD_VAR 0 3
48683: PUSH
48684: LD_INT 0
48686: DOUBLE
48687: EQUAL
48688: IFTRUE 48692
48690: GO 48825
48692: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48693: LD_ADDR_VAR 0 5
48697: PUSH
48698: LD_VAR 0 1
48702: PUSH
48703: LD_INT 4
48705: MINUS
48706: PUSH
48707: LD_VAR 0 2
48711: PUSH
48712: LD_INT 4
48714: MINUS
48715: PUSH
48716: LD_INT 2
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: LIST
48723: PUSH
48724: LD_VAR 0 1
48728: PUSH
48729: LD_INT 3
48731: MINUS
48732: PUSH
48733: LD_VAR 0 2
48737: PUSH
48738: LD_INT 1
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: LIST
48745: PUSH
48746: LD_VAR 0 1
48750: PUSH
48751: LD_INT 4
48753: PLUS
48754: PUSH
48755: LD_VAR 0 2
48759: PUSH
48760: LD_INT 4
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: LIST
48767: PUSH
48768: LD_VAR 0 1
48772: PUSH
48773: LD_INT 3
48775: PLUS
48776: PUSH
48777: LD_VAR 0 2
48781: PUSH
48782: LD_INT 3
48784: PLUS
48785: PUSH
48786: LD_INT 5
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: LIST
48793: PUSH
48794: LD_VAR 0 1
48798: PUSH
48799: LD_VAR 0 2
48803: PUSH
48804: LD_INT 4
48806: PLUS
48807: PUSH
48808: LD_INT 0
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: LIST
48815: PUSH
48816: EMPTY
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: ST_TO_ADDR
// end ; 1 :
48823: GO 49523
48825: LD_INT 1
48827: DOUBLE
48828: EQUAL
48829: IFTRUE 48833
48831: GO 48966
48833: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48834: LD_ADDR_VAR 0 5
48838: PUSH
48839: LD_VAR 0 1
48843: PUSH
48844: LD_VAR 0 2
48848: PUSH
48849: LD_INT 4
48851: MINUS
48852: PUSH
48853: LD_INT 3
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: LIST
48860: PUSH
48861: LD_VAR 0 1
48865: PUSH
48866: LD_INT 3
48868: MINUS
48869: PUSH
48870: LD_VAR 0 2
48874: PUSH
48875: LD_INT 3
48877: MINUS
48878: PUSH
48879: LD_INT 2
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: LIST
48886: PUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 4
48894: MINUS
48895: PUSH
48896: LD_VAR 0 2
48900: PUSH
48901: LD_INT 1
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: LIST
48908: PUSH
48909: LD_VAR 0 1
48913: PUSH
48914: LD_VAR 0 2
48918: PUSH
48919: LD_INT 3
48921: PLUS
48922: PUSH
48923: LD_INT 0
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: LIST
48930: PUSH
48931: LD_VAR 0 1
48935: PUSH
48936: LD_INT 4
48938: PLUS
48939: PUSH
48940: LD_VAR 0 2
48944: PUSH
48945: LD_INT 4
48947: PLUS
48948: PUSH
48949: LD_INT 5
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: LIST
48956: PUSH
48957: EMPTY
48958: LIST
48959: LIST
48960: LIST
48961: LIST
48962: LIST
48963: ST_TO_ADDR
// end ; 2 :
48964: GO 49523
48966: LD_INT 2
48968: DOUBLE
48969: EQUAL
48970: IFTRUE 48974
48972: GO 49103
48974: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48975: LD_ADDR_VAR 0 5
48979: PUSH
48980: LD_VAR 0 1
48984: PUSH
48985: LD_VAR 0 2
48989: PUSH
48990: LD_INT 3
48992: MINUS
48993: PUSH
48994: LD_INT 3
48996: PUSH
48997: EMPTY
48998: LIST
48999: LIST
49000: LIST
49001: PUSH
49002: LD_VAR 0 1
49006: PUSH
49007: LD_INT 4
49009: PLUS
49010: PUSH
49011: LD_VAR 0 2
49015: PUSH
49016: LD_INT 4
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: LIST
49023: PUSH
49024: LD_VAR 0 1
49028: PUSH
49029: LD_VAR 0 2
49033: PUSH
49034: LD_INT 4
49036: PLUS
49037: PUSH
49038: LD_INT 0
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: LIST
49045: PUSH
49046: LD_VAR 0 1
49050: PUSH
49051: LD_INT 3
49053: MINUS
49054: PUSH
49055: LD_VAR 0 2
49059: PUSH
49060: LD_INT 1
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: LIST
49067: PUSH
49068: LD_VAR 0 1
49072: PUSH
49073: LD_INT 4
49075: MINUS
49076: PUSH
49077: LD_VAR 0 2
49081: PUSH
49082: LD_INT 4
49084: MINUS
49085: PUSH
49086: LD_INT 2
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: LIST
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: ST_TO_ADDR
// end ; 3 :
49101: GO 49523
49103: LD_INT 3
49105: DOUBLE
49106: EQUAL
49107: IFTRUE 49111
49109: GO 49244
49111: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49112: LD_ADDR_VAR 0 5
49116: PUSH
49117: LD_VAR 0 1
49121: PUSH
49122: LD_INT 3
49124: PLUS
49125: PUSH
49126: LD_VAR 0 2
49130: PUSH
49131: LD_INT 4
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: LIST
49138: PUSH
49139: LD_VAR 0 1
49143: PUSH
49144: LD_INT 4
49146: PLUS
49147: PUSH
49148: LD_VAR 0 2
49152: PUSH
49153: LD_INT 4
49155: PLUS
49156: PUSH
49157: LD_INT 5
49159: PUSH
49160: EMPTY
49161: LIST
49162: LIST
49163: LIST
49164: PUSH
49165: LD_VAR 0 1
49169: PUSH
49170: LD_INT 4
49172: MINUS
49173: PUSH
49174: LD_VAR 0 2
49178: PUSH
49179: LD_INT 1
49181: PUSH
49182: EMPTY
49183: LIST
49184: LIST
49185: LIST
49186: PUSH
49187: LD_VAR 0 1
49191: PUSH
49192: LD_VAR 0 2
49196: PUSH
49197: LD_INT 4
49199: MINUS
49200: PUSH
49201: LD_INT 3
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: LIST
49208: PUSH
49209: LD_VAR 0 1
49213: PUSH
49214: LD_INT 3
49216: MINUS
49217: PUSH
49218: LD_VAR 0 2
49222: PUSH
49223: LD_INT 3
49225: MINUS
49226: PUSH
49227: LD_INT 2
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: LIST
49234: PUSH
49235: EMPTY
49236: LIST
49237: LIST
49238: LIST
49239: LIST
49240: LIST
49241: ST_TO_ADDR
// end ; 4 :
49242: GO 49523
49244: LD_INT 4
49246: DOUBLE
49247: EQUAL
49248: IFTRUE 49252
49250: GO 49385
49252: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49253: LD_ADDR_VAR 0 5
49257: PUSH
49258: LD_VAR 0 1
49262: PUSH
49263: LD_VAR 0 2
49267: PUSH
49268: LD_INT 4
49270: PLUS
49271: PUSH
49272: LD_INT 0
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: LIST
49279: PUSH
49280: LD_VAR 0 1
49284: PUSH
49285: LD_INT 3
49287: PLUS
49288: PUSH
49289: LD_VAR 0 2
49293: PUSH
49294: LD_INT 3
49296: PLUS
49297: PUSH
49298: LD_INT 5
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: LIST
49305: PUSH
49306: LD_VAR 0 1
49310: PUSH
49311: LD_INT 4
49313: PLUS
49314: PUSH
49315: LD_VAR 0 2
49319: PUSH
49320: LD_INT 4
49322: PUSH
49323: EMPTY
49324: LIST
49325: LIST
49326: LIST
49327: PUSH
49328: LD_VAR 0 1
49332: PUSH
49333: LD_VAR 0 2
49337: PUSH
49338: LD_INT 3
49340: MINUS
49341: PUSH
49342: LD_INT 3
49344: PUSH
49345: EMPTY
49346: LIST
49347: LIST
49348: LIST
49349: PUSH
49350: LD_VAR 0 1
49354: PUSH
49355: LD_INT 4
49357: MINUS
49358: PUSH
49359: LD_VAR 0 2
49363: PUSH
49364: LD_INT 4
49366: MINUS
49367: PUSH
49368: LD_INT 2
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: LIST
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: ST_TO_ADDR
// end ; 5 :
49383: GO 49523
49385: LD_INT 5
49387: DOUBLE
49388: EQUAL
49389: IFTRUE 49393
49391: GO 49522
49393: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49394: LD_ADDR_VAR 0 5
49398: PUSH
49399: LD_VAR 0 1
49403: PUSH
49404: LD_INT 4
49406: MINUS
49407: PUSH
49408: LD_VAR 0 2
49412: PUSH
49413: LD_INT 1
49415: PUSH
49416: EMPTY
49417: LIST
49418: LIST
49419: LIST
49420: PUSH
49421: LD_VAR 0 1
49425: PUSH
49426: LD_VAR 0 2
49430: PUSH
49431: LD_INT 4
49433: MINUS
49434: PUSH
49435: LD_INT 3
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: PUSH
49443: LD_VAR 0 1
49447: PUSH
49448: LD_INT 4
49450: PLUS
49451: PUSH
49452: LD_VAR 0 2
49456: PUSH
49457: LD_INT 4
49459: PLUS
49460: PUSH
49461: LD_INT 5
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: LIST
49468: PUSH
49469: LD_VAR 0 1
49473: PUSH
49474: LD_INT 3
49476: PLUS
49477: PUSH
49478: LD_VAR 0 2
49482: PUSH
49483: LD_INT 4
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: LIST
49490: PUSH
49491: LD_VAR 0 1
49495: PUSH
49496: LD_VAR 0 2
49500: PUSH
49501: LD_INT 3
49503: PLUS
49504: PUSH
49505: LD_INT 0
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: LIST
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: ST_TO_ADDR
// end ; end ;
49520: GO 49523
49522: POP
// result := list ;
49523: LD_ADDR_VAR 0 4
49527: PUSH
49528: LD_VAR 0 5
49532: ST_TO_ADDR
// end ;
49533: LD_VAR 0 4
49537: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49538: LD_INT 0
49540: PPUSH
49541: PPUSH
49542: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49543: LD_VAR 0 1
49547: NOT
49548: PUSH
49549: LD_VAR 0 2
49553: PUSH
49554: LD_INT 1
49556: PUSH
49557: LD_INT 2
49559: PUSH
49560: LD_INT 3
49562: PUSH
49563: LD_INT 4
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: LIST
49570: LIST
49571: IN
49572: NOT
49573: OR
49574: IFFALSE 49578
// exit ;
49576: GO 49670
// tmp := [ ] ;
49578: LD_ADDR_VAR 0 5
49582: PUSH
49583: EMPTY
49584: ST_TO_ADDR
// for i in units do
49585: LD_ADDR_VAR 0 4
49589: PUSH
49590: LD_VAR 0 1
49594: PUSH
49595: FOR_IN
49596: IFFALSE 49639
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49598: LD_ADDR_VAR 0 5
49602: PUSH
49603: LD_VAR 0 5
49607: PPUSH
49608: LD_VAR 0 5
49612: PUSH
49613: LD_INT 1
49615: PLUS
49616: PPUSH
49617: LD_VAR 0 4
49621: PPUSH
49622: LD_VAR 0 2
49626: PPUSH
49627: CALL_OW 259
49631: PPUSH
49632: CALL_OW 2
49636: ST_TO_ADDR
49637: GO 49595
49639: POP
49640: POP
// if not tmp then
49641: LD_VAR 0 5
49645: NOT
49646: IFFALSE 49650
// exit ;
49648: GO 49670
// result := SortListByListDesc ( units , tmp ) ;
49650: LD_ADDR_VAR 0 3
49654: PUSH
49655: LD_VAR 0 1
49659: PPUSH
49660: LD_VAR 0 5
49664: PPUSH
49665: CALL_OW 77
49669: ST_TO_ADDR
// end ;
49670: LD_VAR 0 3
49674: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49675: LD_INT 0
49677: PPUSH
49678: PPUSH
49679: PPUSH
// result := false ;
49680: LD_ADDR_VAR 0 3
49684: PUSH
49685: LD_INT 0
49687: ST_TO_ADDR
// x := GetX ( building ) ;
49688: LD_ADDR_VAR 0 4
49692: PUSH
49693: LD_VAR 0 2
49697: PPUSH
49698: CALL_OW 250
49702: ST_TO_ADDR
// y := GetY ( building ) ;
49703: LD_ADDR_VAR 0 5
49707: PUSH
49708: LD_VAR 0 2
49712: PPUSH
49713: CALL_OW 251
49717: ST_TO_ADDR
// if not building or not x or not y then
49718: LD_VAR 0 2
49722: NOT
49723: PUSH
49724: LD_VAR 0 4
49728: NOT
49729: OR
49730: PUSH
49731: LD_VAR 0 5
49735: NOT
49736: OR
49737: IFFALSE 49741
// exit ;
49739: GO 49833
// if GetTaskList ( unit ) then
49741: LD_VAR 0 1
49745: PPUSH
49746: CALL_OW 437
49750: IFFALSE 49833
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49752: LD_STRING e
49754: PUSH
49755: LD_VAR 0 1
49759: PPUSH
49760: CALL_OW 437
49764: PUSH
49765: LD_INT 1
49767: ARRAY
49768: PUSH
49769: LD_INT 1
49771: ARRAY
49772: EQUAL
49773: PUSH
49774: LD_VAR 0 4
49778: PUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL_OW 437
49788: PUSH
49789: LD_INT 1
49791: ARRAY
49792: PUSH
49793: LD_INT 2
49795: ARRAY
49796: EQUAL
49797: AND
49798: PUSH
49799: LD_VAR 0 5
49803: PUSH
49804: LD_VAR 0 1
49808: PPUSH
49809: CALL_OW 437
49813: PUSH
49814: LD_INT 1
49816: ARRAY
49817: PUSH
49818: LD_INT 3
49820: ARRAY
49821: EQUAL
49822: AND
49823: IFFALSE 49833
// result := true end ;
49825: LD_ADDR_VAR 0 3
49829: PUSH
49830: LD_INT 1
49832: ST_TO_ADDR
// end ;
49833: LD_VAR 0 3
49837: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49838: LD_INT 0
49840: PPUSH
// result := false ;
49841: LD_ADDR_VAR 0 4
49845: PUSH
49846: LD_INT 0
49848: ST_TO_ADDR
// if GetTaskList ( unit ) then
49849: LD_VAR 0 1
49853: PPUSH
49854: CALL_OW 437
49858: IFFALSE 49941
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49860: LD_STRING M
49862: PUSH
49863: LD_VAR 0 1
49867: PPUSH
49868: CALL_OW 437
49872: PUSH
49873: LD_INT 1
49875: ARRAY
49876: PUSH
49877: LD_INT 1
49879: ARRAY
49880: EQUAL
49881: PUSH
49882: LD_VAR 0 2
49886: PUSH
49887: LD_VAR 0 1
49891: PPUSH
49892: CALL_OW 437
49896: PUSH
49897: LD_INT 1
49899: ARRAY
49900: PUSH
49901: LD_INT 2
49903: ARRAY
49904: EQUAL
49905: AND
49906: PUSH
49907: LD_VAR 0 3
49911: PUSH
49912: LD_VAR 0 1
49916: PPUSH
49917: CALL_OW 437
49921: PUSH
49922: LD_INT 1
49924: ARRAY
49925: PUSH
49926: LD_INT 3
49928: ARRAY
49929: EQUAL
49930: AND
49931: IFFALSE 49941
// result := true ;
49933: LD_ADDR_VAR 0 4
49937: PUSH
49938: LD_INT 1
49940: ST_TO_ADDR
// end ; end ;
49941: LD_VAR 0 4
49945: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49946: LD_INT 0
49948: PPUSH
49949: PPUSH
49950: PPUSH
49951: PPUSH
// if not unit or not area then
49952: LD_VAR 0 1
49956: NOT
49957: PUSH
49958: LD_VAR 0 2
49962: NOT
49963: OR
49964: IFFALSE 49968
// exit ;
49966: GO 50132
// tmp := AreaToList ( area , i ) ;
49968: LD_ADDR_VAR 0 6
49972: PUSH
49973: LD_VAR 0 2
49977: PPUSH
49978: LD_VAR 0 5
49982: PPUSH
49983: CALL_OW 517
49987: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49988: LD_ADDR_VAR 0 5
49992: PUSH
49993: DOUBLE
49994: LD_INT 1
49996: DEC
49997: ST_TO_ADDR
49998: LD_VAR 0 6
50002: PUSH
50003: LD_INT 1
50005: ARRAY
50006: PUSH
50007: FOR_TO
50008: IFFALSE 50130
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50010: LD_ADDR_VAR 0 7
50014: PUSH
50015: LD_VAR 0 6
50019: PUSH
50020: LD_INT 1
50022: ARRAY
50023: PUSH
50024: LD_VAR 0 5
50028: ARRAY
50029: PUSH
50030: LD_VAR 0 6
50034: PUSH
50035: LD_INT 2
50037: ARRAY
50038: PUSH
50039: LD_VAR 0 5
50043: ARRAY
50044: PUSH
50045: EMPTY
50046: LIST
50047: LIST
50048: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50049: LD_VAR 0 7
50053: PUSH
50054: LD_INT 1
50056: ARRAY
50057: PPUSH
50058: LD_VAR 0 7
50062: PUSH
50063: LD_INT 2
50065: ARRAY
50066: PPUSH
50067: CALL_OW 428
50071: PUSH
50072: LD_INT 0
50074: EQUAL
50075: IFFALSE 50128
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50077: LD_VAR 0 1
50081: PPUSH
50082: LD_VAR 0 7
50086: PUSH
50087: LD_INT 1
50089: ARRAY
50090: PPUSH
50091: LD_VAR 0 7
50095: PUSH
50096: LD_INT 2
50098: ARRAY
50099: PPUSH
50100: LD_VAR 0 3
50104: PPUSH
50105: CALL_OW 48
// result := IsPlaced ( unit ) ;
50109: LD_ADDR_VAR 0 4
50113: PUSH
50114: LD_VAR 0 1
50118: PPUSH
50119: CALL_OW 305
50123: ST_TO_ADDR
// exit ;
50124: POP
50125: POP
50126: GO 50132
// end ; end ;
50128: GO 50007
50130: POP
50131: POP
// end ;
50132: LD_VAR 0 4
50136: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50137: LD_INT 0
50139: PPUSH
50140: PPUSH
50141: PPUSH
// if not side or side > 8 then
50142: LD_VAR 0 1
50146: NOT
50147: PUSH
50148: LD_VAR 0 1
50152: PUSH
50153: LD_INT 8
50155: GREATER
50156: OR
50157: IFFALSE 50161
// exit ;
50159: GO 50348
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50161: LD_ADDR_VAR 0 4
50165: PUSH
50166: LD_INT 22
50168: PUSH
50169: LD_VAR 0 1
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 21
50180: PUSH
50181: LD_INT 3
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PPUSH
50192: CALL_OW 69
50196: ST_TO_ADDR
// if not tmp then
50197: LD_VAR 0 4
50201: NOT
50202: IFFALSE 50206
// exit ;
50204: GO 50348
// enable_addtolog := true ;
50206: LD_ADDR_OWVAR 81
50210: PUSH
50211: LD_INT 1
50213: ST_TO_ADDR
// AddToLog ( [ ) ;
50214: LD_STRING [
50216: PPUSH
50217: CALL_OW 561
// for i in tmp do
50221: LD_ADDR_VAR 0 3
50225: PUSH
50226: LD_VAR 0 4
50230: PUSH
50231: FOR_IN
50232: IFFALSE 50339
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50234: LD_STRING [
50236: PUSH
50237: LD_VAR 0 3
50241: PPUSH
50242: CALL_OW 266
50246: STR
50247: PUSH
50248: LD_STRING , 
50250: STR
50251: PUSH
50252: LD_VAR 0 3
50256: PPUSH
50257: CALL_OW 250
50261: STR
50262: PUSH
50263: LD_STRING , 
50265: STR
50266: PUSH
50267: LD_VAR 0 3
50271: PPUSH
50272: CALL_OW 251
50276: STR
50277: PUSH
50278: LD_STRING , 
50280: STR
50281: PUSH
50282: LD_VAR 0 3
50286: PPUSH
50287: CALL_OW 254
50291: STR
50292: PUSH
50293: LD_STRING , 
50295: STR
50296: PUSH
50297: LD_VAR 0 3
50301: PPUSH
50302: LD_INT 1
50304: PPUSH
50305: CALL_OW 268
50309: STR
50310: PUSH
50311: LD_STRING , 
50313: STR
50314: PUSH
50315: LD_VAR 0 3
50319: PPUSH
50320: LD_INT 2
50322: PPUSH
50323: CALL_OW 268
50327: STR
50328: PUSH
50329: LD_STRING ],
50331: STR
50332: PPUSH
50333: CALL_OW 561
// end ;
50337: GO 50231
50339: POP
50340: POP
// AddToLog ( ]; ) ;
50341: LD_STRING ];
50343: PPUSH
50344: CALL_OW 561
// end ;
50348: LD_VAR 0 2
50352: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50353: LD_INT 0
50355: PPUSH
50356: PPUSH
50357: PPUSH
50358: PPUSH
50359: PPUSH
// if not area or not rate or not max then
50360: LD_VAR 0 1
50364: NOT
50365: PUSH
50366: LD_VAR 0 2
50370: NOT
50371: OR
50372: PUSH
50373: LD_VAR 0 4
50377: NOT
50378: OR
50379: IFFALSE 50383
// exit ;
50381: GO 50575
// while 1 do
50383: LD_INT 1
50385: IFFALSE 50575
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50387: LD_ADDR_VAR 0 9
50391: PUSH
50392: LD_VAR 0 1
50396: PPUSH
50397: LD_INT 1
50399: PPUSH
50400: CALL_OW 287
50404: PUSH
50405: LD_INT 10
50407: MUL
50408: ST_TO_ADDR
// r := rate / 10 ;
50409: LD_ADDR_VAR 0 7
50413: PUSH
50414: LD_VAR 0 2
50418: PUSH
50419: LD_INT 10
50421: DIVREAL
50422: ST_TO_ADDR
// time := 1 1$00 ;
50423: LD_ADDR_VAR 0 8
50427: PUSH
50428: LD_INT 2100
50430: ST_TO_ADDR
// if amount < min then
50431: LD_VAR 0 9
50435: PUSH
50436: LD_VAR 0 3
50440: LESS
50441: IFFALSE 50459
// r := r * 2 else
50443: LD_ADDR_VAR 0 7
50447: PUSH
50448: LD_VAR 0 7
50452: PUSH
50453: LD_INT 2
50455: MUL
50456: ST_TO_ADDR
50457: GO 50485
// if amount > max then
50459: LD_VAR 0 9
50463: PUSH
50464: LD_VAR 0 4
50468: GREATER
50469: IFFALSE 50485
// r := r / 2 ;
50471: LD_ADDR_VAR 0 7
50475: PUSH
50476: LD_VAR 0 7
50480: PUSH
50481: LD_INT 2
50483: DIVREAL
50484: ST_TO_ADDR
// time := time / r ;
50485: LD_ADDR_VAR 0 8
50489: PUSH
50490: LD_VAR 0 8
50494: PUSH
50495: LD_VAR 0 7
50499: DIVREAL
50500: ST_TO_ADDR
// if time < 0 then
50501: LD_VAR 0 8
50505: PUSH
50506: LD_INT 0
50508: LESS
50509: IFFALSE 50526
// time := time * - 1 ;
50511: LD_ADDR_VAR 0 8
50515: PUSH
50516: LD_VAR 0 8
50520: PUSH
50521: LD_INT 1
50523: NEG
50524: MUL
50525: ST_TO_ADDR
// wait ( time ) ;
50526: LD_VAR 0 8
50530: PPUSH
50531: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50535: LD_INT 35
50537: PPUSH
50538: LD_INT 875
50540: PPUSH
50541: CALL_OW 12
50545: PPUSH
50546: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50550: LD_INT 1
50552: PPUSH
50553: LD_INT 5
50555: PPUSH
50556: CALL_OW 12
50560: PPUSH
50561: LD_VAR 0 1
50565: PPUSH
50566: LD_INT 1
50568: PPUSH
50569: CALL_OW 55
// end ;
50573: GO 50383
// end ;
50575: LD_VAR 0 5
50579: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50580: LD_INT 0
50582: PPUSH
50583: PPUSH
50584: PPUSH
50585: PPUSH
50586: PPUSH
50587: PPUSH
50588: PPUSH
50589: PPUSH
// if not turrets or not factories then
50590: LD_VAR 0 1
50594: NOT
50595: PUSH
50596: LD_VAR 0 2
50600: NOT
50601: OR
50602: IFFALSE 50606
// exit ;
50604: GO 50913
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50606: LD_ADDR_VAR 0 10
50610: PUSH
50611: LD_INT 5
50613: PUSH
50614: LD_INT 6
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: PUSH
50621: LD_INT 2
50623: PUSH
50624: LD_INT 4
50626: PUSH
50627: EMPTY
50628: LIST
50629: LIST
50630: PUSH
50631: LD_INT 3
50633: PUSH
50634: LD_INT 5
50636: PUSH
50637: EMPTY
50638: LIST
50639: LIST
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: LIST
50645: PUSH
50646: LD_INT 24
50648: PUSH
50649: LD_INT 25
50651: PUSH
50652: EMPTY
50653: LIST
50654: LIST
50655: PUSH
50656: LD_INT 23
50658: PUSH
50659: LD_INT 27
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 42
50672: PUSH
50673: LD_INT 43
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 44
50682: PUSH
50683: LD_INT 46
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: LD_INT 45
50692: PUSH
50693: LD_INT 47
50695: PUSH
50696: EMPTY
50697: LIST
50698: LIST
50699: PUSH
50700: EMPTY
50701: LIST
50702: LIST
50703: LIST
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: LIST
50709: ST_TO_ADDR
// result := [ ] ;
50710: LD_ADDR_VAR 0 3
50714: PUSH
50715: EMPTY
50716: ST_TO_ADDR
// for i in turrets do
50717: LD_ADDR_VAR 0 4
50721: PUSH
50722: LD_VAR 0 1
50726: PUSH
50727: FOR_IN
50728: IFFALSE 50911
// begin nat := GetNation ( i ) ;
50730: LD_ADDR_VAR 0 7
50734: PUSH
50735: LD_VAR 0 4
50739: PPUSH
50740: CALL_OW 248
50744: ST_TO_ADDR
// weapon := 0 ;
50745: LD_ADDR_VAR 0 8
50749: PUSH
50750: LD_INT 0
50752: ST_TO_ADDR
// if not nat then
50753: LD_VAR 0 7
50757: NOT
50758: IFFALSE 50762
// continue ;
50760: GO 50727
// for j in list [ nat ] do
50762: LD_ADDR_VAR 0 5
50766: PUSH
50767: LD_VAR 0 10
50771: PUSH
50772: LD_VAR 0 7
50776: ARRAY
50777: PUSH
50778: FOR_IN
50779: IFFALSE 50820
// if GetBWeapon ( i ) = j [ 1 ] then
50781: LD_VAR 0 4
50785: PPUSH
50786: CALL_OW 269
50790: PUSH
50791: LD_VAR 0 5
50795: PUSH
50796: LD_INT 1
50798: ARRAY
50799: EQUAL
50800: IFFALSE 50818
// begin weapon := j [ 2 ] ;
50802: LD_ADDR_VAR 0 8
50806: PUSH
50807: LD_VAR 0 5
50811: PUSH
50812: LD_INT 2
50814: ARRAY
50815: ST_TO_ADDR
// break ;
50816: GO 50820
// end ;
50818: GO 50778
50820: POP
50821: POP
// if not weapon then
50822: LD_VAR 0 8
50826: NOT
50827: IFFALSE 50831
// continue ;
50829: GO 50727
// for k in factories do
50831: LD_ADDR_VAR 0 6
50835: PUSH
50836: LD_VAR 0 2
50840: PUSH
50841: FOR_IN
50842: IFFALSE 50907
// begin weapons := AvailableWeaponList ( k ) ;
50844: LD_ADDR_VAR 0 9
50848: PUSH
50849: LD_VAR 0 6
50853: PPUSH
50854: CALL_OW 478
50858: ST_TO_ADDR
// if not weapons then
50859: LD_VAR 0 9
50863: NOT
50864: IFFALSE 50868
// continue ;
50866: GO 50841
// if weapon in weapons then
50868: LD_VAR 0 8
50872: PUSH
50873: LD_VAR 0 9
50877: IN
50878: IFFALSE 50905
// begin result := [ i , weapon ] ;
50880: LD_ADDR_VAR 0 3
50884: PUSH
50885: LD_VAR 0 4
50889: PUSH
50890: LD_VAR 0 8
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: ST_TO_ADDR
// exit ;
50899: POP
50900: POP
50901: POP
50902: POP
50903: GO 50913
// end ; end ;
50905: GO 50841
50907: POP
50908: POP
// end ;
50909: GO 50727
50911: POP
50912: POP
// end ;
50913: LD_VAR 0 3
50917: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50918: LD_INT 0
50920: PPUSH
// if not side or side > 8 then
50921: LD_VAR 0 3
50925: NOT
50926: PUSH
50927: LD_VAR 0 3
50931: PUSH
50932: LD_INT 8
50934: GREATER
50935: OR
50936: IFFALSE 50940
// exit ;
50938: GO 50999
// if not range then
50940: LD_VAR 0 4
50944: NOT
50945: IFFALSE 50956
// range := - 12 ;
50947: LD_ADDR_VAR 0 4
50951: PUSH
50952: LD_INT 12
50954: NEG
50955: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50956: LD_VAR 0 1
50960: PPUSH
50961: LD_VAR 0 2
50965: PPUSH
50966: LD_VAR 0 3
50970: PPUSH
50971: LD_VAR 0 4
50975: PPUSH
50976: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50980: LD_VAR 0 1
50984: PPUSH
50985: LD_VAR 0 2
50989: PPUSH
50990: LD_VAR 0 3
50994: PPUSH
50995: CALL_OW 331
// end ;
50999: LD_VAR 0 5
51003: RET
// export function Video ( mode ) ; begin
51004: LD_INT 0
51006: PPUSH
// ingame_video = mode ;
51007: LD_ADDR_OWVAR 52
51011: PUSH
51012: LD_VAR 0 1
51016: ST_TO_ADDR
// interface_hidden = mode ;
51017: LD_ADDR_OWVAR 54
51021: PUSH
51022: LD_VAR 0 1
51026: ST_TO_ADDR
// end ;
51027: LD_VAR 0 2
51031: RET
// export function Join ( array , element ) ; begin
51032: LD_INT 0
51034: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51035: LD_ADDR_VAR 0 3
51039: PUSH
51040: LD_VAR 0 1
51044: PPUSH
51045: LD_VAR 0 1
51049: PUSH
51050: LD_INT 1
51052: PLUS
51053: PPUSH
51054: LD_VAR 0 2
51058: PPUSH
51059: CALL_OW 1
51063: ST_TO_ADDR
// end ;
51064: LD_VAR 0 3
51068: RET
// export function JoinUnion ( array , element ) ; begin
51069: LD_INT 0
51071: PPUSH
// result := array union element ;
51072: LD_ADDR_VAR 0 3
51076: PUSH
51077: LD_VAR 0 1
51081: PUSH
51082: LD_VAR 0 2
51086: UNION
51087: ST_TO_ADDR
// end ;
51088: LD_VAR 0 3
51092: RET
// export function GetBehemoths ( side ) ; begin
51093: LD_INT 0
51095: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51096: LD_ADDR_VAR 0 2
51100: PUSH
51101: LD_INT 22
51103: PUSH
51104: LD_VAR 0 1
51108: PUSH
51109: EMPTY
51110: LIST
51111: LIST
51112: PUSH
51113: LD_INT 31
51115: PUSH
51116: LD_INT 25
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: PPUSH
51127: CALL_OW 69
51131: ST_TO_ADDR
// end ;
51132: LD_VAR 0 2
51136: RET
// export function Shuffle ( array ) ; var i , index ; begin
51137: LD_INT 0
51139: PPUSH
51140: PPUSH
51141: PPUSH
// result := [ ] ;
51142: LD_ADDR_VAR 0 2
51146: PUSH
51147: EMPTY
51148: ST_TO_ADDR
// if not array then
51149: LD_VAR 0 1
51153: NOT
51154: IFFALSE 51158
// exit ;
51156: GO 51257
// Randomize ;
51158: CALL_OW 10
// for i = array downto 1 do
51162: LD_ADDR_VAR 0 3
51166: PUSH
51167: DOUBLE
51168: LD_VAR 0 1
51172: INC
51173: ST_TO_ADDR
51174: LD_INT 1
51176: PUSH
51177: FOR_DOWNTO
51178: IFFALSE 51255
// begin index := rand ( 1 , array ) ;
51180: LD_ADDR_VAR 0 4
51184: PUSH
51185: LD_INT 1
51187: PPUSH
51188: LD_VAR 0 1
51192: PPUSH
51193: CALL_OW 12
51197: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51198: LD_ADDR_VAR 0 2
51202: PUSH
51203: LD_VAR 0 2
51207: PPUSH
51208: LD_VAR 0 2
51212: PUSH
51213: LD_INT 1
51215: PLUS
51216: PPUSH
51217: LD_VAR 0 1
51221: PUSH
51222: LD_VAR 0 4
51226: ARRAY
51227: PPUSH
51228: CALL_OW 2
51232: ST_TO_ADDR
// array := Delete ( array , index ) ;
51233: LD_ADDR_VAR 0 1
51237: PUSH
51238: LD_VAR 0 1
51242: PPUSH
51243: LD_VAR 0 4
51247: PPUSH
51248: CALL_OW 3
51252: ST_TO_ADDR
// end ;
51253: GO 51177
51255: POP
51256: POP
// end ;
51257: LD_VAR 0 2
51261: RET
// export function GetBaseMaterials ( base ) ; begin
51262: LD_INT 0
51264: PPUSH
// result := [ 0 , 0 , 0 ] ;
51265: LD_ADDR_VAR 0 2
51269: PUSH
51270: LD_INT 0
51272: PUSH
51273: LD_INT 0
51275: PUSH
51276: LD_INT 0
51278: PUSH
51279: EMPTY
51280: LIST
51281: LIST
51282: LIST
51283: ST_TO_ADDR
// if not base then
51284: LD_VAR 0 1
51288: NOT
51289: IFFALSE 51293
// exit ;
51291: GO 51342
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51293: LD_ADDR_VAR 0 2
51297: PUSH
51298: LD_VAR 0 1
51302: PPUSH
51303: LD_INT 1
51305: PPUSH
51306: CALL_OW 275
51310: PUSH
51311: LD_VAR 0 1
51315: PPUSH
51316: LD_INT 2
51318: PPUSH
51319: CALL_OW 275
51323: PUSH
51324: LD_VAR 0 1
51328: PPUSH
51329: LD_INT 3
51331: PPUSH
51332: CALL_OW 275
51336: PUSH
51337: EMPTY
51338: LIST
51339: LIST
51340: LIST
51341: ST_TO_ADDR
// end ;
51342: LD_VAR 0 2
51346: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51347: LD_INT 0
51349: PPUSH
51350: PPUSH
// result := array ;
51351: LD_ADDR_VAR 0 3
51355: PUSH
51356: LD_VAR 0 1
51360: ST_TO_ADDR
// if size > 0 then
51361: LD_VAR 0 2
51365: PUSH
51366: LD_INT 0
51368: GREATER
51369: IFFALSE 51415
// for i := array downto size do
51371: LD_ADDR_VAR 0 4
51375: PUSH
51376: DOUBLE
51377: LD_VAR 0 1
51381: INC
51382: ST_TO_ADDR
51383: LD_VAR 0 2
51387: PUSH
51388: FOR_DOWNTO
51389: IFFALSE 51413
// result := Delete ( result , result ) ;
51391: LD_ADDR_VAR 0 3
51395: PUSH
51396: LD_VAR 0 3
51400: PPUSH
51401: LD_VAR 0 3
51405: PPUSH
51406: CALL_OW 3
51410: ST_TO_ADDR
51411: GO 51388
51413: POP
51414: POP
// end ;
51415: LD_VAR 0 3
51419: RET
// export function ComExit ( unit ) ; var tmp ; begin
51420: LD_INT 0
51422: PPUSH
51423: PPUSH
// if not IsInUnit ( unit ) then
51424: LD_VAR 0 1
51428: PPUSH
51429: CALL_OW 310
51433: NOT
51434: IFFALSE 51438
// exit ;
51436: GO 51498
// tmp := IsInUnit ( unit ) ;
51438: LD_ADDR_VAR 0 3
51442: PUSH
51443: LD_VAR 0 1
51447: PPUSH
51448: CALL_OW 310
51452: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51453: LD_VAR 0 3
51457: PPUSH
51458: CALL_OW 247
51462: PUSH
51463: LD_INT 2
51465: EQUAL
51466: IFFALSE 51479
// ComExitVehicle ( unit ) else
51468: LD_VAR 0 1
51472: PPUSH
51473: CALL_OW 121
51477: GO 51488
// ComExitBuilding ( unit ) ;
51479: LD_VAR 0 1
51483: PPUSH
51484: CALL_OW 122
// result := tmp ;
51488: LD_ADDR_VAR 0 2
51492: PUSH
51493: LD_VAR 0 3
51497: ST_TO_ADDR
// end ;
51498: LD_VAR 0 2
51502: RET
// export function ComExitAll ( units ) ; var i ; begin
51503: LD_INT 0
51505: PPUSH
51506: PPUSH
// if not units then
51507: LD_VAR 0 1
51511: NOT
51512: IFFALSE 51516
// exit ;
51514: GO 51542
// for i in units do
51516: LD_ADDR_VAR 0 3
51520: PUSH
51521: LD_VAR 0 1
51525: PUSH
51526: FOR_IN
51527: IFFALSE 51540
// ComExit ( i ) ;
51529: LD_VAR 0 3
51533: PPUSH
51534: CALL 51420 0 1
51538: GO 51526
51540: POP
51541: POP
// end ;
51542: LD_VAR 0 2
51546: RET
// export function ResetHc ; begin
51547: LD_INT 0
51549: PPUSH
// InitHc ;
51550: CALL_OW 19
// hc_importance := 0 ;
51554: LD_ADDR_OWVAR 32
51558: PUSH
51559: LD_INT 0
51561: ST_TO_ADDR
// end ;
51562: LD_VAR 0 1
51566: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51567: LD_INT 0
51569: PPUSH
51570: PPUSH
51571: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51572: LD_ADDR_VAR 0 6
51576: PUSH
51577: LD_VAR 0 1
51581: PUSH
51582: LD_VAR 0 3
51586: PLUS
51587: PUSH
51588: LD_INT 2
51590: DIV
51591: ST_TO_ADDR
// if _x < 0 then
51592: LD_VAR 0 6
51596: PUSH
51597: LD_INT 0
51599: LESS
51600: IFFALSE 51617
// _x := _x * - 1 ;
51602: LD_ADDR_VAR 0 6
51606: PUSH
51607: LD_VAR 0 6
51611: PUSH
51612: LD_INT 1
51614: NEG
51615: MUL
51616: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51617: LD_ADDR_VAR 0 7
51621: PUSH
51622: LD_VAR 0 2
51626: PUSH
51627: LD_VAR 0 4
51631: PLUS
51632: PUSH
51633: LD_INT 2
51635: DIV
51636: ST_TO_ADDR
// if _y < 0 then
51637: LD_VAR 0 7
51641: PUSH
51642: LD_INT 0
51644: LESS
51645: IFFALSE 51662
// _y := _y * - 1 ;
51647: LD_ADDR_VAR 0 7
51651: PUSH
51652: LD_VAR 0 7
51656: PUSH
51657: LD_INT 1
51659: NEG
51660: MUL
51661: ST_TO_ADDR
// result := [ _x , _y ] ;
51662: LD_ADDR_VAR 0 5
51666: PUSH
51667: LD_VAR 0 6
51671: PUSH
51672: LD_VAR 0 7
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: ST_TO_ADDR
// end ;
51681: LD_VAR 0 5
51685: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51686: LD_INT 0
51688: PPUSH
51689: PPUSH
51690: PPUSH
51691: PPUSH
// task := GetTaskList ( unit ) ;
51692: LD_ADDR_VAR 0 7
51696: PUSH
51697: LD_VAR 0 1
51701: PPUSH
51702: CALL_OW 437
51706: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51707: LD_VAR 0 7
51711: NOT
51712: PUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: LD_VAR 0 2
51722: PPUSH
51723: CALL_OW 308
51727: NOT
51728: AND
51729: IFFALSE 51733
// exit ;
51731: GO 51851
// if IsInArea ( unit , area ) then
51733: LD_VAR 0 1
51737: PPUSH
51738: LD_VAR 0 2
51742: PPUSH
51743: CALL_OW 308
51747: IFFALSE 51765
// begin ComMoveToArea ( unit , goAway ) ;
51749: LD_VAR 0 1
51753: PPUSH
51754: LD_VAR 0 3
51758: PPUSH
51759: CALL_OW 113
// exit ;
51763: GO 51851
// end ; if task [ 1 ] [ 1 ] <> M then
51765: LD_VAR 0 7
51769: PUSH
51770: LD_INT 1
51772: ARRAY
51773: PUSH
51774: LD_INT 1
51776: ARRAY
51777: PUSH
51778: LD_STRING M
51780: NONEQUAL
51781: IFFALSE 51785
// exit ;
51783: GO 51851
// x := task [ 1 ] [ 2 ] ;
51785: LD_ADDR_VAR 0 5
51789: PUSH
51790: LD_VAR 0 7
51794: PUSH
51795: LD_INT 1
51797: ARRAY
51798: PUSH
51799: LD_INT 2
51801: ARRAY
51802: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51803: LD_ADDR_VAR 0 6
51807: PUSH
51808: LD_VAR 0 7
51812: PUSH
51813: LD_INT 1
51815: ARRAY
51816: PUSH
51817: LD_INT 3
51819: ARRAY
51820: ST_TO_ADDR
// if InArea ( x , y , area ) then
51821: LD_VAR 0 5
51825: PPUSH
51826: LD_VAR 0 6
51830: PPUSH
51831: LD_VAR 0 2
51835: PPUSH
51836: CALL_OW 309
51840: IFFALSE 51851
// ComStop ( unit ) ;
51842: LD_VAR 0 1
51846: PPUSH
51847: CALL_OW 141
// end ;
51851: LD_VAR 0 4
51855: RET
// export function Abs ( value ) ; begin
51856: LD_INT 0
51858: PPUSH
// result := value ;
51859: LD_ADDR_VAR 0 2
51863: PUSH
51864: LD_VAR 0 1
51868: ST_TO_ADDR
// if value < 0 then
51869: LD_VAR 0 1
51873: PUSH
51874: LD_INT 0
51876: LESS
51877: IFFALSE 51894
// result := value * - 1 ;
51879: LD_ADDR_VAR 0 2
51883: PUSH
51884: LD_VAR 0 1
51888: PUSH
51889: LD_INT 1
51891: NEG
51892: MUL
51893: ST_TO_ADDR
// end ;
51894: LD_VAR 0 2
51898: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51899: LD_INT 0
51901: PPUSH
51902: PPUSH
51903: PPUSH
51904: PPUSH
51905: PPUSH
51906: PPUSH
51907: PPUSH
51908: PPUSH
// if not unit or not building then
51909: LD_VAR 0 1
51913: NOT
51914: PUSH
51915: LD_VAR 0 2
51919: NOT
51920: OR
51921: IFFALSE 51925
// exit ;
51923: GO 52151
// x := GetX ( building ) ;
51925: LD_ADDR_VAR 0 4
51929: PUSH
51930: LD_VAR 0 2
51934: PPUSH
51935: CALL_OW 250
51939: ST_TO_ADDR
// y := GetY ( building ) ;
51940: LD_ADDR_VAR 0 6
51944: PUSH
51945: LD_VAR 0 2
51949: PPUSH
51950: CALL_OW 251
51954: ST_TO_ADDR
// d := GetDir ( building ) ;
51955: LD_ADDR_VAR 0 8
51959: PUSH
51960: LD_VAR 0 2
51964: PPUSH
51965: CALL_OW 254
51969: ST_TO_ADDR
// r := 4 ;
51970: LD_ADDR_VAR 0 9
51974: PUSH
51975: LD_INT 4
51977: ST_TO_ADDR
// for i := 1 to 5 do
51978: LD_ADDR_VAR 0 10
51982: PUSH
51983: DOUBLE
51984: LD_INT 1
51986: DEC
51987: ST_TO_ADDR
51988: LD_INT 5
51990: PUSH
51991: FOR_TO
51992: IFFALSE 52149
// begin _x := ShiftX ( x , d , r + i ) ;
51994: LD_ADDR_VAR 0 5
51998: PUSH
51999: LD_VAR 0 4
52003: PPUSH
52004: LD_VAR 0 8
52008: PPUSH
52009: LD_VAR 0 9
52013: PUSH
52014: LD_VAR 0 10
52018: PLUS
52019: PPUSH
52020: CALL_OW 272
52024: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52025: LD_ADDR_VAR 0 7
52029: PUSH
52030: LD_VAR 0 6
52034: PPUSH
52035: LD_VAR 0 8
52039: PPUSH
52040: LD_VAR 0 9
52044: PUSH
52045: LD_VAR 0 10
52049: PLUS
52050: PPUSH
52051: CALL_OW 273
52055: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52056: LD_VAR 0 5
52060: PPUSH
52061: LD_VAR 0 7
52065: PPUSH
52066: CALL_OW 488
52070: PUSH
52071: LD_VAR 0 5
52075: PPUSH
52076: LD_VAR 0 7
52080: PPUSH
52081: CALL_OW 428
52085: PPUSH
52086: CALL_OW 247
52090: PUSH
52091: LD_INT 3
52093: PUSH
52094: LD_INT 2
52096: PUSH
52097: EMPTY
52098: LIST
52099: LIST
52100: IN
52101: NOT
52102: AND
52103: IFFALSE 52147
// begin ComMoveXY ( unit , _x , _y ) ;
52105: LD_VAR 0 1
52109: PPUSH
52110: LD_VAR 0 5
52114: PPUSH
52115: LD_VAR 0 7
52119: PPUSH
52120: CALL_OW 111
// result := [ _x , _y ] ;
52124: LD_ADDR_VAR 0 3
52128: PUSH
52129: LD_VAR 0 5
52133: PUSH
52134: LD_VAR 0 7
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: ST_TO_ADDR
// exit ;
52143: POP
52144: POP
52145: GO 52151
// end ; end ;
52147: GO 51991
52149: POP
52150: POP
// end ;
52151: LD_VAR 0 3
52155: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52156: LD_INT 0
52158: PPUSH
52159: PPUSH
52160: PPUSH
// result := 0 ;
52161: LD_ADDR_VAR 0 3
52165: PUSH
52166: LD_INT 0
52168: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52169: LD_VAR 0 1
52173: PUSH
52174: LD_INT 0
52176: LESS
52177: PUSH
52178: LD_VAR 0 1
52182: PUSH
52183: LD_INT 8
52185: GREATER
52186: OR
52187: PUSH
52188: LD_VAR 0 2
52192: PUSH
52193: LD_INT 0
52195: LESS
52196: OR
52197: PUSH
52198: LD_VAR 0 2
52202: PUSH
52203: LD_INT 8
52205: GREATER
52206: OR
52207: IFFALSE 52211
// exit ;
52209: GO 52286
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52211: LD_ADDR_VAR 0 4
52215: PUSH
52216: LD_INT 22
52218: PUSH
52219: LD_VAR 0 2
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PPUSH
52228: CALL_OW 69
52232: PUSH
52233: FOR_IN
52234: IFFALSE 52284
// begin un := UnitShoot ( i ) ;
52236: LD_ADDR_VAR 0 5
52240: PUSH
52241: LD_VAR 0 4
52245: PPUSH
52246: CALL_OW 504
52250: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52251: LD_VAR 0 5
52255: PPUSH
52256: CALL_OW 255
52260: PUSH
52261: LD_VAR 0 1
52265: EQUAL
52266: IFFALSE 52282
// begin result := un ;
52268: LD_ADDR_VAR 0 3
52272: PUSH
52273: LD_VAR 0 5
52277: ST_TO_ADDR
// exit ;
52278: POP
52279: POP
52280: GO 52286
// end ; end ;
52282: GO 52233
52284: POP
52285: POP
// end ;
52286: LD_VAR 0 3
52290: RET
// export function GetCargoBay ( units ) ; begin
52291: LD_INT 0
52293: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52294: LD_ADDR_VAR 0 2
52298: PUSH
52299: LD_VAR 0 1
52303: PPUSH
52304: LD_INT 2
52306: PUSH
52307: LD_INT 34
52309: PUSH
52310: LD_INT 12
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: PUSH
52317: LD_INT 34
52319: PUSH
52320: LD_INT 51
52322: PUSH
52323: EMPTY
52324: LIST
52325: LIST
52326: PUSH
52327: LD_INT 34
52329: PUSH
52330: LD_INT 32
52332: PUSH
52333: EMPTY
52334: LIST
52335: LIST
52336: PUSH
52337: LD_INT 34
52339: PUSH
52340: LD_EXP 104
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: PPUSH
52356: CALL_OW 72
52360: ST_TO_ADDR
// end ; end_of_file
52361: LD_VAR 0 2
52365: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52366: LD_INT 0
52368: PPUSH
52369: PPUSH
// skirmish := false ;
52370: LD_ADDR_EXP 57
52374: PUSH
52375: LD_INT 0
52377: ST_TO_ADDR
// debug_mc := false ;
52378: LD_ADDR_EXP 58
52382: PUSH
52383: LD_INT 0
52385: ST_TO_ADDR
// mc_bases := [ ] ;
52386: LD_ADDR_EXP 59
52390: PUSH
52391: EMPTY
52392: ST_TO_ADDR
// mc_sides := [ ] ;
52393: LD_ADDR_EXP 85
52397: PUSH
52398: EMPTY
52399: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52400: LD_ADDR_EXP 60
52404: PUSH
52405: EMPTY
52406: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52407: LD_ADDR_EXP 61
52411: PUSH
52412: EMPTY
52413: ST_TO_ADDR
// mc_need_heal := [ ] ;
52414: LD_ADDR_EXP 62
52418: PUSH
52419: EMPTY
52420: ST_TO_ADDR
// mc_healers := [ ] ;
52421: LD_ADDR_EXP 63
52425: PUSH
52426: EMPTY
52427: ST_TO_ADDR
// mc_build_list := [ ] ;
52428: LD_ADDR_EXP 64
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52435: LD_ADDR_EXP 91
52439: PUSH
52440: EMPTY
52441: ST_TO_ADDR
// mc_builders := [ ] ;
52442: LD_ADDR_EXP 65
52446: PUSH
52447: EMPTY
52448: ST_TO_ADDR
// mc_construct_list := [ ] ;
52449: LD_ADDR_EXP 66
52453: PUSH
52454: EMPTY
52455: ST_TO_ADDR
// mc_turret_list := [ ] ;
52456: LD_ADDR_EXP 67
52460: PUSH
52461: EMPTY
52462: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52463: LD_ADDR_EXP 68
52467: PUSH
52468: EMPTY
52469: ST_TO_ADDR
// mc_miners := [ ] ;
52470: LD_ADDR_EXP 73
52474: PUSH
52475: EMPTY
52476: ST_TO_ADDR
// mc_mines := [ ] ;
52477: LD_ADDR_EXP 72
52481: PUSH
52482: EMPTY
52483: ST_TO_ADDR
// mc_minefields := [ ] ;
52484: LD_ADDR_EXP 74
52488: PUSH
52489: EMPTY
52490: ST_TO_ADDR
// mc_crates := [ ] ;
52491: LD_ADDR_EXP 75
52495: PUSH
52496: EMPTY
52497: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52498: LD_ADDR_EXP 76
52502: PUSH
52503: EMPTY
52504: ST_TO_ADDR
// mc_crates_area := [ ] ;
52505: LD_ADDR_EXP 77
52509: PUSH
52510: EMPTY
52511: ST_TO_ADDR
// mc_vehicles := [ ] ;
52512: LD_ADDR_EXP 78
52516: PUSH
52517: EMPTY
52518: ST_TO_ADDR
// mc_attack := [ ] ;
52519: LD_ADDR_EXP 79
52523: PUSH
52524: EMPTY
52525: ST_TO_ADDR
// mc_produce := [ ] ;
52526: LD_ADDR_EXP 80
52530: PUSH
52531: EMPTY
52532: ST_TO_ADDR
// mc_defender := [ ] ;
52533: LD_ADDR_EXP 81
52537: PUSH
52538: EMPTY
52539: ST_TO_ADDR
// mc_parking := [ ] ;
52540: LD_ADDR_EXP 83
52544: PUSH
52545: EMPTY
52546: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52547: LD_ADDR_EXP 69
52551: PUSH
52552: EMPTY
52553: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52554: LD_ADDR_EXP 71
52558: PUSH
52559: EMPTY
52560: ST_TO_ADDR
// mc_scan := [ ] ;
52561: LD_ADDR_EXP 82
52565: PUSH
52566: EMPTY
52567: ST_TO_ADDR
// mc_scan_area := [ ] ;
52568: LD_ADDR_EXP 84
52572: PUSH
52573: EMPTY
52574: ST_TO_ADDR
// mc_tech := [ ] ;
52575: LD_ADDR_EXP 86
52579: PUSH
52580: EMPTY
52581: ST_TO_ADDR
// mc_class := [ ] ;
52582: LD_ADDR_EXP 100
52586: PUSH
52587: EMPTY
52588: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52589: LD_ADDR_EXP 101
52593: PUSH
52594: EMPTY
52595: ST_TO_ADDR
// mc_is_defending := [ ] ;
52596: LD_ADDR_EXP 102
52600: PUSH
52601: EMPTY
52602: ST_TO_ADDR
// end ;
52603: LD_VAR 0 1
52607: RET
// export function MC_Kill ( base ) ; begin
52608: LD_INT 0
52610: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52611: LD_ADDR_EXP 59
52615: PUSH
52616: LD_EXP 59
52620: PPUSH
52621: LD_VAR 0 1
52625: PPUSH
52626: EMPTY
52627: PPUSH
52628: CALL_OW 1
52632: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52633: LD_ADDR_EXP 60
52637: PUSH
52638: LD_EXP 60
52642: PPUSH
52643: LD_VAR 0 1
52647: PPUSH
52648: EMPTY
52649: PPUSH
52650: CALL_OW 1
52654: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52655: LD_ADDR_EXP 61
52659: PUSH
52660: LD_EXP 61
52664: PPUSH
52665: LD_VAR 0 1
52669: PPUSH
52670: EMPTY
52671: PPUSH
52672: CALL_OW 1
52676: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52677: LD_ADDR_EXP 62
52681: PUSH
52682: LD_EXP 62
52686: PPUSH
52687: LD_VAR 0 1
52691: PPUSH
52692: EMPTY
52693: PPUSH
52694: CALL_OW 1
52698: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52699: LD_ADDR_EXP 63
52703: PUSH
52704: LD_EXP 63
52708: PPUSH
52709: LD_VAR 0 1
52713: PPUSH
52714: EMPTY
52715: PPUSH
52716: CALL_OW 1
52720: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52721: LD_ADDR_EXP 64
52725: PUSH
52726: LD_EXP 64
52730: PPUSH
52731: LD_VAR 0 1
52735: PPUSH
52736: EMPTY
52737: PPUSH
52738: CALL_OW 1
52742: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52743: LD_ADDR_EXP 65
52747: PUSH
52748: LD_EXP 65
52752: PPUSH
52753: LD_VAR 0 1
52757: PPUSH
52758: EMPTY
52759: PPUSH
52760: CALL_OW 1
52764: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52765: LD_ADDR_EXP 66
52769: PUSH
52770: LD_EXP 66
52774: PPUSH
52775: LD_VAR 0 1
52779: PPUSH
52780: EMPTY
52781: PPUSH
52782: CALL_OW 1
52786: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52787: LD_ADDR_EXP 67
52791: PUSH
52792: LD_EXP 67
52796: PPUSH
52797: LD_VAR 0 1
52801: PPUSH
52802: EMPTY
52803: PPUSH
52804: CALL_OW 1
52808: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52809: LD_ADDR_EXP 68
52813: PUSH
52814: LD_EXP 68
52818: PPUSH
52819: LD_VAR 0 1
52823: PPUSH
52824: EMPTY
52825: PPUSH
52826: CALL_OW 1
52830: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52831: LD_ADDR_EXP 69
52835: PUSH
52836: LD_EXP 69
52840: PPUSH
52841: LD_VAR 0 1
52845: PPUSH
52846: EMPTY
52847: PPUSH
52848: CALL_OW 1
52852: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52853: LD_ADDR_EXP 70
52857: PUSH
52858: LD_EXP 70
52862: PPUSH
52863: LD_VAR 0 1
52867: PPUSH
52868: LD_INT 0
52870: PPUSH
52871: CALL_OW 1
52875: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52876: LD_ADDR_EXP 71
52880: PUSH
52881: LD_EXP 71
52885: PPUSH
52886: LD_VAR 0 1
52890: PPUSH
52891: EMPTY
52892: PPUSH
52893: CALL_OW 1
52897: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52898: LD_ADDR_EXP 72
52902: PUSH
52903: LD_EXP 72
52907: PPUSH
52908: LD_VAR 0 1
52912: PPUSH
52913: EMPTY
52914: PPUSH
52915: CALL_OW 1
52919: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52920: LD_ADDR_EXP 73
52924: PUSH
52925: LD_EXP 73
52929: PPUSH
52930: LD_VAR 0 1
52934: PPUSH
52935: EMPTY
52936: PPUSH
52937: CALL_OW 1
52941: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52942: LD_ADDR_EXP 74
52946: PUSH
52947: LD_EXP 74
52951: PPUSH
52952: LD_VAR 0 1
52956: PPUSH
52957: EMPTY
52958: PPUSH
52959: CALL_OW 1
52963: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52964: LD_ADDR_EXP 75
52968: PUSH
52969: LD_EXP 75
52973: PPUSH
52974: LD_VAR 0 1
52978: PPUSH
52979: EMPTY
52980: PPUSH
52981: CALL_OW 1
52985: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52986: LD_ADDR_EXP 76
52990: PUSH
52991: LD_EXP 76
52995: PPUSH
52996: LD_VAR 0 1
53000: PPUSH
53001: EMPTY
53002: PPUSH
53003: CALL_OW 1
53007: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53008: LD_ADDR_EXP 77
53012: PUSH
53013: LD_EXP 77
53017: PPUSH
53018: LD_VAR 0 1
53022: PPUSH
53023: EMPTY
53024: PPUSH
53025: CALL_OW 1
53029: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53030: LD_ADDR_EXP 78
53034: PUSH
53035: LD_EXP 78
53039: PPUSH
53040: LD_VAR 0 1
53044: PPUSH
53045: EMPTY
53046: PPUSH
53047: CALL_OW 1
53051: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53052: LD_ADDR_EXP 79
53056: PUSH
53057: LD_EXP 79
53061: PPUSH
53062: LD_VAR 0 1
53066: PPUSH
53067: EMPTY
53068: PPUSH
53069: CALL_OW 1
53073: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53074: LD_ADDR_EXP 80
53078: PUSH
53079: LD_EXP 80
53083: PPUSH
53084: LD_VAR 0 1
53088: PPUSH
53089: EMPTY
53090: PPUSH
53091: CALL_OW 1
53095: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53096: LD_ADDR_EXP 81
53100: PUSH
53101: LD_EXP 81
53105: PPUSH
53106: LD_VAR 0 1
53110: PPUSH
53111: EMPTY
53112: PPUSH
53113: CALL_OW 1
53117: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53118: LD_ADDR_EXP 82
53122: PUSH
53123: LD_EXP 82
53127: PPUSH
53128: LD_VAR 0 1
53132: PPUSH
53133: EMPTY
53134: PPUSH
53135: CALL_OW 1
53139: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53140: LD_ADDR_EXP 83
53144: PUSH
53145: LD_EXP 83
53149: PPUSH
53150: LD_VAR 0 1
53154: PPUSH
53155: EMPTY
53156: PPUSH
53157: CALL_OW 1
53161: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53162: LD_ADDR_EXP 84
53166: PUSH
53167: LD_EXP 84
53171: PPUSH
53172: LD_VAR 0 1
53176: PPUSH
53177: EMPTY
53178: PPUSH
53179: CALL_OW 1
53183: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53184: LD_ADDR_EXP 86
53188: PUSH
53189: LD_EXP 86
53193: PPUSH
53194: LD_VAR 0 1
53198: PPUSH
53199: EMPTY
53200: PPUSH
53201: CALL_OW 1
53205: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53206: LD_ADDR_EXP 88
53210: PUSH
53211: LD_EXP 88
53215: PPUSH
53216: LD_VAR 0 1
53220: PPUSH
53221: EMPTY
53222: PPUSH
53223: CALL_OW 1
53227: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53228: LD_ADDR_EXP 89
53232: PUSH
53233: LD_EXP 89
53237: PPUSH
53238: LD_VAR 0 1
53242: PPUSH
53243: EMPTY
53244: PPUSH
53245: CALL_OW 1
53249: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53250: LD_ADDR_EXP 90
53254: PUSH
53255: LD_EXP 90
53259: PPUSH
53260: LD_VAR 0 1
53264: PPUSH
53265: EMPTY
53266: PPUSH
53267: CALL_OW 1
53271: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53272: LD_ADDR_EXP 91
53276: PUSH
53277: LD_EXP 91
53281: PPUSH
53282: LD_VAR 0 1
53286: PPUSH
53287: EMPTY
53288: PPUSH
53289: CALL_OW 1
53293: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53294: LD_ADDR_EXP 92
53298: PUSH
53299: LD_EXP 92
53303: PPUSH
53304: LD_VAR 0 1
53308: PPUSH
53309: EMPTY
53310: PPUSH
53311: CALL_OW 1
53315: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53316: LD_ADDR_EXP 93
53320: PUSH
53321: LD_EXP 93
53325: PPUSH
53326: LD_VAR 0 1
53330: PPUSH
53331: EMPTY
53332: PPUSH
53333: CALL_OW 1
53337: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53338: LD_ADDR_EXP 94
53342: PUSH
53343: LD_EXP 94
53347: PPUSH
53348: LD_VAR 0 1
53352: PPUSH
53353: EMPTY
53354: PPUSH
53355: CALL_OW 1
53359: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53360: LD_ADDR_EXP 95
53364: PUSH
53365: LD_EXP 95
53369: PPUSH
53370: LD_VAR 0 1
53374: PPUSH
53375: EMPTY
53376: PPUSH
53377: CALL_OW 1
53381: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53382: LD_ADDR_EXP 96
53386: PUSH
53387: LD_EXP 96
53391: PPUSH
53392: LD_VAR 0 1
53396: PPUSH
53397: EMPTY
53398: PPUSH
53399: CALL_OW 1
53403: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53404: LD_ADDR_EXP 97
53408: PUSH
53409: LD_EXP 97
53413: PPUSH
53414: LD_VAR 0 1
53418: PPUSH
53419: EMPTY
53420: PPUSH
53421: CALL_OW 1
53425: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53426: LD_ADDR_EXP 98
53430: PUSH
53431: LD_EXP 98
53435: PPUSH
53436: LD_VAR 0 1
53440: PPUSH
53441: EMPTY
53442: PPUSH
53443: CALL_OW 1
53447: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53448: LD_ADDR_EXP 99
53452: PUSH
53453: LD_EXP 99
53457: PPUSH
53458: LD_VAR 0 1
53462: PPUSH
53463: EMPTY
53464: PPUSH
53465: CALL_OW 1
53469: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53470: LD_ADDR_EXP 100
53474: PUSH
53475: LD_EXP 100
53479: PPUSH
53480: LD_VAR 0 1
53484: PPUSH
53485: EMPTY
53486: PPUSH
53487: CALL_OW 1
53491: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53492: LD_ADDR_EXP 101
53496: PUSH
53497: LD_EXP 101
53501: PPUSH
53502: LD_VAR 0 1
53506: PPUSH
53507: LD_INT 0
53509: PPUSH
53510: CALL_OW 1
53514: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53515: LD_ADDR_EXP 102
53519: PUSH
53520: LD_EXP 102
53524: PPUSH
53525: LD_VAR 0 1
53529: PPUSH
53530: LD_INT 0
53532: PPUSH
53533: CALL_OW 1
53537: ST_TO_ADDR
// end ;
53538: LD_VAR 0 2
53542: RET
// export function MC_Add ( side , units ) ; var base ; begin
53543: LD_INT 0
53545: PPUSH
53546: PPUSH
// base := mc_bases + 1 ;
53547: LD_ADDR_VAR 0 4
53551: PUSH
53552: LD_EXP 59
53556: PUSH
53557: LD_INT 1
53559: PLUS
53560: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53561: LD_ADDR_EXP 85
53565: PUSH
53566: LD_EXP 85
53570: PPUSH
53571: LD_VAR 0 4
53575: PPUSH
53576: LD_VAR 0 1
53580: PPUSH
53581: CALL_OW 1
53585: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53586: LD_ADDR_EXP 59
53590: PUSH
53591: LD_EXP 59
53595: PPUSH
53596: LD_VAR 0 4
53600: PPUSH
53601: LD_VAR 0 2
53605: PPUSH
53606: CALL_OW 1
53610: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53611: LD_ADDR_EXP 60
53615: PUSH
53616: LD_EXP 60
53620: PPUSH
53621: LD_VAR 0 4
53625: PPUSH
53626: EMPTY
53627: PPUSH
53628: CALL_OW 1
53632: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53633: LD_ADDR_EXP 61
53637: PUSH
53638: LD_EXP 61
53642: PPUSH
53643: LD_VAR 0 4
53647: PPUSH
53648: EMPTY
53649: PPUSH
53650: CALL_OW 1
53654: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53655: LD_ADDR_EXP 62
53659: PUSH
53660: LD_EXP 62
53664: PPUSH
53665: LD_VAR 0 4
53669: PPUSH
53670: EMPTY
53671: PPUSH
53672: CALL_OW 1
53676: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53677: LD_ADDR_EXP 63
53681: PUSH
53682: LD_EXP 63
53686: PPUSH
53687: LD_VAR 0 4
53691: PPUSH
53692: EMPTY
53693: PPUSH
53694: CALL_OW 1
53698: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53699: LD_ADDR_EXP 64
53703: PUSH
53704: LD_EXP 64
53708: PPUSH
53709: LD_VAR 0 4
53713: PPUSH
53714: EMPTY
53715: PPUSH
53716: CALL_OW 1
53720: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53721: LD_ADDR_EXP 65
53725: PUSH
53726: LD_EXP 65
53730: PPUSH
53731: LD_VAR 0 4
53735: PPUSH
53736: EMPTY
53737: PPUSH
53738: CALL_OW 1
53742: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53743: LD_ADDR_EXP 66
53747: PUSH
53748: LD_EXP 66
53752: PPUSH
53753: LD_VAR 0 4
53757: PPUSH
53758: EMPTY
53759: PPUSH
53760: CALL_OW 1
53764: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53765: LD_ADDR_EXP 67
53769: PUSH
53770: LD_EXP 67
53774: PPUSH
53775: LD_VAR 0 4
53779: PPUSH
53780: EMPTY
53781: PPUSH
53782: CALL_OW 1
53786: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53787: LD_ADDR_EXP 68
53791: PUSH
53792: LD_EXP 68
53796: PPUSH
53797: LD_VAR 0 4
53801: PPUSH
53802: EMPTY
53803: PPUSH
53804: CALL_OW 1
53808: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53809: LD_ADDR_EXP 69
53813: PUSH
53814: LD_EXP 69
53818: PPUSH
53819: LD_VAR 0 4
53823: PPUSH
53824: EMPTY
53825: PPUSH
53826: CALL_OW 1
53830: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53831: LD_ADDR_EXP 70
53835: PUSH
53836: LD_EXP 70
53840: PPUSH
53841: LD_VAR 0 4
53845: PPUSH
53846: LD_INT 0
53848: PPUSH
53849: CALL_OW 1
53853: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53854: LD_ADDR_EXP 71
53858: PUSH
53859: LD_EXP 71
53863: PPUSH
53864: LD_VAR 0 4
53868: PPUSH
53869: EMPTY
53870: PPUSH
53871: CALL_OW 1
53875: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53876: LD_ADDR_EXP 72
53880: PUSH
53881: LD_EXP 72
53885: PPUSH
53886: LD_VAR 0 4
53890: PPUSH
53891: EMPTY
53892: PPUSH
53893: CALL_OW 1
53897: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53898: LD_ADDR_EXP 73
53902: PUSH
53903: LD_EXP 73
53907: PPUSH
53908: LD_VAR 0 4
53912: PPUSH
53913: EMPTY
53914: PPUSH
53915: CALL_OW 1
53919: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53920: LD_ADDR_EXP 74
53924: PUSH
53925: LD_EXP 74
53929: PPUSH
53930: LD_VAR 0 4
53934: PPUSH
53935: EMPTY
53936: PPUSH
53937: CALL_OW 1
53941: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53942: LD_ADDR_EXP 75
53946: PUSH
53947: LD_EXP 75
53951: PPUSH
53952: LD_VAR 0 4
53956: PPUSH
53957: EMPTY
53958: PPUSH
53959: CALL_OW 1
53963: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53964: LD_ADDR_EXP 76
53968: PUSH
53969: LD_EXP 76
53973: PPUSH
53974: LD_VAR 0 4
53978: PPUSH
53979: EMPTY
53980: PPUSH
53981: CALL_OW 1
53985: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53986: LD_ADDR_EXP 77
53990: PUSH
53991: LD_EXP 77
53995: PPUSH
53996: LD_VAR 0 4
54000: PPUSH
54001: EMPTY
54002: PPUSH
54003: CALL_OW 1
54007: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54008: LD_ADDR_EXP 78
54012: PUSH
54013: LD_EXP 78
54017: PPUSH
54018: LD_VAR 0 4
54022: PPUSH
54023: EMPTY
54024: PPUSH
54025: CALL_OW 1
54029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54030: LD_ADDR_EXP 79
54034: PUSH
54035: LD_EXP 79
54039: PPUSH
54040: LD_VAR 0 4
54044: PPUSH
54045: EMPTY
54046: PPUSH
54047: CALL_OW 1
54051: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54052: LD_ADDR_EXP 80
54056: PUSH
54057: LD_EXP 80
54061: PPUSH
54062: LD_VAR 0 4
54066: PPUSH
54067: EMPTY
54068: PPUSH
54069: CALL_OW 1
54073: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54074: LD_ADDR_EXP 81
54078: PUSH
54079: LD_EXP 81
54083: PPUSH
54084: LD_VAR 0 4
54088: PPUSH
54089: EMPTY
54090: PPUSH
54091: CALL_OW 1
54095: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54096: LD_ADDR_EXP 82
54100: PUSH
54101: LD_EXP 82
54105: PPUSH
54106: LD_VAR 0 4
54110: PPUSH
54111: EMPTY
54112: PPUSH
54113: CALL_OW 1
54117: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54118: LD_ADDR_EXP 83
54122: PUSH
54123: LD_EXP 83
54127: PPUSH
54128: LD_VAR 0 4
54132: PPUSH
54133: EMPTY
54134: PPUSH
54135: CALL_OW 1
54139: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54140: LD_ADDR_EXP 84
54144: PUSH
54145: LD_EXP 84
54149: PPUSH
54150: LD_VAR 0 4
54154: PPUSH
54155: EMPTY
54156: PPUSH
54157: CALL_OW 1
54161: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54162: LD_ADDR_EXP 86
54166: PUSH
54167: LD_EXP 86
54171: PPUSH
54172: LD_VAR 0 4
54176: PPUSH
54177: EMPTY
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54184: LD_ADDR_EXP 88
54188: PUSH
54189: LD_EXP 88
54193: PPUSH
54194: LD_VAR 0 4
54198: PPUSH
54199: EMPTY
54200: PPUSH
54201: CALL_OW 1
54205: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54206: LD_ADDR_EXP 89
54210: PUSH
54211: LD_EXP 89
54215: PPUSH
54216: LD_VAR 0 4
54220: PPUSH
54221: EMPTY
54222: PPUSH
54223: CALL_OW 1
54227: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54228: LD_ADDR_EXP 90
54232: PUSH
54233: LD_EXP 90
54237: PPUSH
54238: LD_VAR 0 4
54242: PPUSH
54243: EMPTY
54244: PPUSH
54245: CALL_OW 1
54249: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54250: LD_ADDR_EXP 91
54254: PUSH
54255: LD_EXP 91
54259: PPUSH
54260: LD_VAR 0 4
54264: PPUSH
54265: EMPTY
54266: PPUSH
54267: CALL_OW 1
54271: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54272: LD_ADDR_EXP 92
54276: PUSH
54277: LD_EXP 92
54281: PPUSH
54282: LD_VAR 0 4
54286: PPUSH
54287: EMPTY
54288: PPUSH
54289: CALL_OW 1
54293: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54294: LD_ADDR_EXP 93
54298: PUSH
54299: LD_EXP 93
54303: PPUSH
54304: LD_VAR 0 4
54308: PPUSH
54309: EMPTY
54310: PPUSH
54311: CALL_OW 1
54315: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54316: LD_ADDR_EXP 94
54320: PUSH
54321: LD_EXP 94
54325: PPUSH
54326: LD_VAR 0 4
54330: PPUSH
54331: EMPTY
54332: PPUSH
54333: CALL_OW 1
54337: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54338: LD_ADDR_EXP 95
54342: PUSH
54343: LD_EXP 95
54347: PPUSH
54348: LD_VAR 0 4
54352: PPUSH
54353: EMPTY
54354: PPUSH
54355: CALL_OW 1
54359: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54360: LD_ADDR_EXP 96
54364: PUSH
54365: LD_EXP 96
54369: PPUSH
54370: LD_VAR 0 4
54374: PPUSH
54375: EMPTY
54376: PPUSH
54377: CALL_OW 1
54381: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54382: LD_ADDR_EXP 97
54386: PUSH
54387: LD_EXP 97
54391: PPUSH
54392: LD_VAR 0 4
54396: PPUSH
54397: EMPTY
54398: PPUSH
54399: CALL_OW 1
54403: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54404: LD_ADDR_EXP 98
54408: PUSH
54409: LD_EXP 98
54413: PPUSH
54414: LD_VAR 0 4
54418: PPUSH
54419: EMPTY
54420: PPUSH
54421: CALL_OW 1
54425: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54426: LD_ADDR_EXP 99
54430: PUSH
54431: LD_EXP 99
54435: PPUSH
54436: LD_VAR 0 4
54440: PPUSH
54441: EMPTY
54442: PPUSH
54443: CALL_OW 1
54447: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54448: LD_ADDR_EXP 100
54452: PUSH
54453: LD_EXP 100
54457: PPUSH
54458: LD_VAR 0 4
54462: PPUSH
54463: EMPTY
54464: PPUSH
54465: CALL_OW 1
54469: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54470: LD_ADDR_EXP 101
54474: PUSH
54475: LD_EXP 101
54479: PPUSH
54480: LD_VAR 0 4
54484: PPUSH
54485: LD_INT 0
54487: PPUSH
54488: CALL_OW 1
54492: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54493: LD_ADDR_EXP 102
54497: PUSH
54498: LD_EXP 102
54502: PPUSH
54503: LD_VAR 0 4
54507: PPUSH
54508: LD_INT 0
54510: PPUSH
54511: CALL_OW 1
54515: ST_TO_ADDR
// result := base ;
54516: LD_ADDR_VAR 0 3
54520: PUSH
54521: LD_VAR 0 4
54525: ST_TO_ADDR
// end ;
54526: LD_VAR 0 3
54530: RET
// export function MC_Start ( ) ; var i ; begin
54531: LD_INT 0
54533: PPUSH
54534: PPUSH
// for i = 1 to mc_bases do
54535: LD_ADDR_VAR 0 2
54539: PUSH
54540: DOUBLE
54541: LD_INT 1
54543: DEC
54544: ST_TO_ADDR
54545: LD_EXP 59
54549: PUSH
54550: FOR_TO
54551: IFFALSE 55628
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54553: LD_ADDR_EXP 59
54557: PUSH
54558: LD_EXP 59
54562: PPUSH
54563: LD_VAR 0 2
54567: PPUSH
54568: LD_EXP 59
54572: PUSH
54573: LD_VAR 0 2
54577: ARRAY
54578: PUSH
54579: LD_INT 0
54581: DIFF
54582: PPUSH
54583: CALL_OW 1
54587: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54588: LD_ADDR_EXP 60
54592: PUSH
54593: LD_EXP 60
54597: PPUSH
54598: LD_VAR 0 2
54602: PPUSH
54603: EMPTY
54604: PPUSH
54605: CALL_OW 1
54609: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54610: LD_ADDR_EXP 61
54614: PUSH
54615: LD_EXP 61
54619: PPUSH
54620: LD_VAR 0 2
54624: PPUSH
54625: EMPTY
54626: PPUSH
54627: CALL_OW 1
54631: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54632: LD_ADDR_EXP 62
54636: PUSH
54637: LD_EXP 62
54641: PPUSH
54642: LD_VAR 0 2
54646: PPUSH
54647: EMPTY
54648: PPUSH
54649: CALL_OW 1
54653: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54654: LD_ADDR_EXP 63
54658: PUSH
54659: LD_EXP 63
54663: PPUSH
54664: LD_VAR 0 2
54668: PPUSH
54669: EMPTY
54670: PUSH
54671: EMPTY
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PPUSH
54677: CALL_OW 1
54681: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54682: LD_ADDR_EXP 64
54686: PUSH
54687: LD_EXP 64
54691: PPUSH
54692: LD_VAR 0 2
54696: PPUSH
54697: EMPTY
54698: PPUSH
54699: CALL_OW 1
54703: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54704: LD_ADDR_EXP 91
54708: PUSH
54709: LD_EXP 91
54713: PPUSH
54714: LD_VAR 0 2
54718: PPUSH
54719: EMPTY
54720: PPUSH
54721: CALL_OW 1
54725: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54726: LD_ADDR_EXP 65
54730: PUSH
54731: LD_EXP 65
54735: PPUSH
54736: LD_VAR 0 2
54740: PPUSH
54741: EMPTY
54742: PPUSH
54743: CALL_OW 1
54747: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54748: LD_ADDR_EXP 66
54752: PUSH
54753: LD_EXP 66
54757: PPUSH
54758: LD_VAR 0 2
54762: PPUSH
54763: EMPTY
54764: PPUSH
54765: CALL_OW 1
54769: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54770: LD_ADDR_EXP 67
54774: PUSH
54775: LD_EXP 67
54779: PPUSH
54780: LD_VAR 0 2
54784: PPUSH
54785: LD_EXP 59
54789: PUSH
54790: LD_VAR 0 2
54794: ARRAY
54795: PPUSH
54796: LD_INT 2
54798: PUSH
54799: LD_INT 30
54801: PUSH
54802: LD_INT 32
54804: PUSH
54805: EMPTY
54806: LIST
54807: LIST
54808: PUSH
54809: LD_INT 30
54811: PUSH
54812: LD_INT 33
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: PUSH
54819: EMPTY
54820: LIST
54821: LIST
54822: LIST
54823: PPUSH
54824: CALL_OW 72
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54834: LD_ADDR_EXP 68
54838: PUSH
54839: LD_EXP 68
54843: PPUSH
54844: LD_VAR 0 2
54848: PPUSH
54849: LD_EXP 59
54853: PUSH
54854: LD_VAR 0 2
54858: ARRAY
54859: PPUSH
54860: LD_INT 2
54862: PUSH
54863: LD_INT 30
54865: PUSH
54866: LD_INT 32
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: PUSH
54873: LD_INT 30
54875: PUSH
54876: LD_INT 31
54878: PUSH
54879: EMPTY
54880: LIST
54881: LIST
54882: PUSH
54883: EMPTY
54884: LIST
54885: LIST
54886: LIST
54887: PUSH
54888: LD_INT 58
54890: PUSH
54891: EMPTY
54892: LIST
54893: PUSH
54894: EMPTY
54895: LIST
54896: LIST
54897: PPUSH
54898: CALL_OW 72
54902: PPUSH
54903: CALL_OW 1
54907: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54908: LD_ADDR_EXP 69
54912: PUSH
54913: LD_EXP 69
54917: PPUSH
54918: LD_VAR 0 2
54922: PPUSH
54923: EMPTY
54924: PPUSH
54925: CALL_OW 1
54929: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54930: LD_ADDR_EXP 73
54934: PUSH
54935: LD_EXP 73
54939: PPUSH
54940: LD_VAR 0 2
54944: PPUSH
54945: EMPTY
54946: PPUSH
54947: CALL_OW 1
54951: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54952: LD_ADDR_EXP 72
54956: PUSH
54957: LD_EXP 72
54961: PPUSH
54962: LD_VAR 0 2
54966: PPUSH
54967: EMPTY
54968: PPUSH
54969: CALL_OW 1
54973: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54974: LD_ADDR_EXP 74
54978: PUSH
54979: LD_EXP 74
54983: PPUSH
54984: LD_VAR 0 2
54988: PPUSH
54989: EMPTY
54990: PPUSH
54991: CALL_OW 1
54995: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54996: LD_ADDR_EXP 75
55000: PUSH
55001: LD_EXP 75
55005: PPUSH
55006: LD_VAR 0 2
55010: PPUSH
55011: EMPTY
55012: PPUSH
55013: CALL_OW 1
55017: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55018: LD_ADDR_EXP 76
55022: PUSH
55023: LD_EXP 76
55027: PPUSH
55028: LD_VAR 0 2
55032: PPUSH
55033: EMPTY
55034: PPUSH
55035: CALL_OW 1
55039: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55040: LD_ADDR_EXP 77
55044: PUSH
55045: LD_EXP 77
55049: PPUSH
55050: LD_VAR 0 2
55054: PPUSH
55055: EMPTY
55056: PPUSH
55057: CALL_OW 1
55061: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55062: LD_ADDR_EXP 78
55066: PUSH
55067: LD_EXP 78
55071: PPUSH
55072: LD_VAR 0 2
55076: PPUSH
55077: EMPTY
55078: PPUSH
55079: CALL_OW 1
55083: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55084: LD_ADDR_EXP 79
55088: PUSH
55089: LD_EXP 79
55093: PPUSH
55094: LD_VAR 0 2
55098: PPUSH
55099: EMPTY
55100: PPUSH
55101: CALL_OW 1
55105: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55106: LD_ADDR_EXP 80
55110: PUSH
55111: LD_EXP 80
55115: PPUSH
55116: LD_VAR 0 2
55120: PPUSH
55121: EMPTY
55122: PPUSH
55123: CALL_OW 1
55127: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55128: LD_ADDR_EXP 81
55132: PUSH
55133: LD_EXP 81
55137: PPUSH
55138: LD_VAR 0 2
55142: PPUSH
55143: EMPTY
55144: PPUSH
55145: CALL_OW 1
55149: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55150: LD_ADDR_EXP 70
55154: PUSH
55155: LD_EXP 70
55159: PPUSH
55160: LD_VAR 0 2
55164: PPUSH
55165: LD_INT 0
55167: PPUSH
55168: CALL_OW 1
55172: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55173: LD_ADDR_EXP 83
55177: PUSH
55178: LD_EXP 83
55182: PPUSH
55183: LD_VAR 0 2
55187: PPUSH
55188: LD_INT 0
55190: PPUSH
55191: CALL_OW 1
55195: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55196: LD_ADDR_EXP 71
55200: PUSH
55201: LD_EXP 71
55205: PPUSH
55206: LD_VAR 0 2
55210: PPUSH
55211: EMPTY
55212: PPUSH
55213: CALL_OW 1
55217: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55218: LD_ADDR_EXP 82
55222: PUSH
55223: LD_EXP 82
55227: PPUSH
55228: LD_VAR 0 2
55232: PPUSH
55233: LD_INT 0
55235: PPUSH
55236: CALL_OW 1
55240: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55241: LD_ADDR_EXP 84
55245: PUSH
55246: LD_EXP 84
55250: PPUSH
55251: LD_VAR 0 2
55255: PPUSH
55256: EMPTY
55257: PPUSH
55258: CALL_OW 1
55262: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55263: LD_ADDR_EXP 87
55267: PUSH
55268: LD_EXP 87
55272: PPUSH
55273: LD_VAR 0 2
55277: PPUSH
55278: LD_INT 0
55280: PPUSH
55281: CALL_OW 1
55285: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55286: LD_ADDR_EXP 88
55290: PUSH
55291: LD_EXP 88
55295: PPUSH
55296: LD_VAR 0 2
55300: PPUSH
55301: EMPTY
55302: PPUSH
55303: CALL_OW 1
55307: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55308: LD_ADDR_EXP 89
55312: PUSH
55313: LD_EXP 89
55317: PPUSH
55318: LD_VAR 0 2
55322: PPUSH
55323: EMPTY
55324: PPUSH
55325: CALL_OW 1
55329: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55330: LD_ADDR_EXP 90
55334: PUSH
55335: LD_EXP 90
55339: PPUSH
55340: LD_VAR 0 2
55344: PPUSH
55345: EMPTY
55346: PPUSH
55347: CALL_OW 1
55351: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55352: LD_ADDR_EXP 92
55356: PUSH
55357: LD_EXP 92
55361: PPUSH
55362: LD_VAR 0 2
55366: PPUSH
55367: LD_EXP 59
55371: PUSH
55372: LD_VAR 0 2
55376: ARRAY
55377: PPUSH
55378: LD_INT 2
55380: PUSH
55381: LD_INT 30
55383: PUSH
55384: LD_INT 6
55386: PUSH
55387: EMPTY
55388: LIST
55389: LIST
55390: PUSH
55391: LD_INT 30
55393: PUSH
55394: LD_INT 7
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: PUSH
55401: LD_INT 30
55403: PUSH
55404: LD_INT 8
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: PUSH
55411: EMPTY
55412: LIST
55413: LIST
55414: LIST
55415: LIST
55416: PPUSH
55417: CALL_OW 72
55421: PPUSH
55422: CALL_OW 1
55426: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55427: LD_ADDR_EXP 93
55431: PUSH
55432: LD_EXP 93
55436: PPUSH
55437: LD_VAR 0 2
55441: PPUSH
55442: EMPTY
55443: PPUSH
55444: CALL_OW 1
55448: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55449: LD_ADDR_EXP 94
55453: PUSH
55454: LD_EXP 94
55458: PPUSH
55459: LD_VAR 0 2
55463: PPUSH
55464: EMPTY
55465: PPUSH
55466: CALL_OW 1
55470: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55471: LD_ADDR_EXP 95
55475: PUSH
55476: LD_EXP 95
55480: PPUSH
55481: LD_VAR 0 2
55485: PPUSH
55486: EMPTY
55487: PPUSH
55488: CALL_OW 1
55492: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55493: LD_ADDR_EXP 96
55497: PUSH
55498: LD_EXP 96
55502: PPUSH
55503: LD_VAR 0 2
55507: PPUSH
55508: EMPTY
55509: PPUSH
55510: CALL_OW 1
55514: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55515: LD_ADDR_EXP 97
55519: PUSH
55520: LD_EXP 97
55524: PPUSH
55525: LD_VAR 0 2
55529: PPUSH
55530: EMPTY
55531: PPUSH
55532: CALL_OW 1
55536: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55537: LD_ADDR_EXP 98
55541: PUSH
55542: LD_EXP 98
55546: PPUSH
55547: LD_VAR 0 2
55551: PPUSH
55552: EMPTY
55553: PPUSH
55554: CALL_OW 1
55558: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55559: LD_ADDR_EXP 99
55563: PUSH
55564: LD_EXP 99
55568: PPUSH
55569: LD_VAR 0 2
55573: PPUSH
55574: EMPTY
55575: PPUSH
55576: CALL_OW 1
55580: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55581: LD_ADDR_EXP 100
55585: PUSH
55586: LD_EXP 100
55590: PPUSH
55591: LD_VAR 0 2
55595: PPUSH
55596: EMPTY
55597: PPUSH
55598: CALL_OW 1
55602: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55603: LD_ADDR_EXP 101
55607: PUSH
55608: LD_EXP 101
55612: PPUSH
55613: LD_VAR 0 2
55617: PPUSH
55618: LD_INT 0
55620: PPUSH
55621: CALL_OW 1
55625: ST_TO_ADDR
// end ;
55626: GO 54550
55628: POP
55629: POP
// MC_InitSides ( ) ;
55630: CALL 55916 0 0
// MC_InitResearch ( ) ;
55634: CALL 55655 0 0
// CustomInitMacro ( ) ;
55638: CALL 202 0 0
// skirmish := true ;
55642: LD_ADDR_EXP 57
55646: PUSH
55647: LD_INT 1
55649: ST_TO_ADDR
// end ;
55650: LD_VAR 0 1
55654: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55655: LD_INT 0
55657: PPUSH
55658: PPUSH
55659: PPUSH
55660: PPUSH
55661: PPUSH
55662: PPUSH
// if not mc_bases then
55663: LD_EXP 59
55667: NOT
55668: IFFALSE 55672
// exit ;
55670: GO 55911
// for i = 1 to 8 do
55672: LD_ADDR_VAR 0 2
55676: PUSH
55677: DOUBLE
55678: LD_INT 1
55680: DEC
55681: ST_TO_ADDR
55682: LD_INT 8
55684: PUSH
55685: FOR_TO
55686: IFFALSE 55712
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55688: LD_ADDR_EXP 86
55692: PUSH
55693: LD_EXP 86
55697: PPUSH
55698: LD_VAR 0 2
55702: PPUSH
55703: EMPTY
55704: PPUSH
55705: CALL_OW 1
55709: ST_TO_ADDR
55710: GO 55685
55712: POP
55713: POP
// tmp := [ ] ;
55714: LD_ADDR_VAR 0 5
55718: PUSH
55719: EMPTY
55720: ST_TO_ADDR
// for i = 1 to mc_sides do
55721: LD_ADDR_VAR 0 2
55725: PUSH
55726: DOUBLE
55727: LD_INT 1
55729: DEC
55730: ST_TO_ADDR
55731: LD_EXP 85
55735: PUSH
55736: FOR_TO
55737: IFFALSE 55795
// if not mc_sides [ i ] in tmp then
55739: LD_EXP 85
55743: PUSH
55744: LD_VAR 0 2
55748: ARRAY
55749: PUSH
55750: LD_VAR 0 5
55754: IN
55755: NOT
55756: IFFALSE 55793
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55758: LD_ADDR_VAR 0 5
55762: PUSH
55763: LD_VAR 0 5
55767: PPUSH
55768: LD_VAR 0 5
55772: PUSH
55773: LD_INT 1
55775: PLUS
55776: PPUSH
55777: LD_EXP 85
55781: PUSH
55782: LD_VAR 0 2
55786: ARRAY
55787: PPUSH
55788: CALL_OW 2
55792: ST_TO_ADDR
55793: GO 55736
55795: POP
55796: POP
// if not tmp then
55797: LD_VAR 0 5
55801: NOT
55802: IFFALSE 55806
// exit ;
55804: GO 55911
// for j in tmp do
55806: LD_ADDR_VAR 0 3
55810: PUSH
55811: LD_VAR 0 5
55815: PUSH
55816: FOR_IN
55817: IFFALSE 55909
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55819: LD_ADDR_VAR 0 6
55823: PUSH
55824: LD_INT 22
55826: PUSH
55827: LD_VAR 0 3
55831: PUSH
55832: EMPTY
55833: LIST
55834: LIST
55835: PPUSH
55836: CALL_OW 69
55840: ST_TO_ADDR
// if not un then
55841: LD_VAR 0 6
55845: NOT
55846: IFFALSE 55850
// continue ;
55848: GO 55816
// nation := GetNation ( un [ 1 ] ) ;
55850: LD_ADDR_VAR 0 4
55854: PUSH
55855: LD_VAR 0 6
55859: PUSH
55860: LD_INT 1
55862: ARRAY
55863: PPUSH
55864: CALL_OW 248
55868: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55869: LD_ADDR_EXP 86
55873: PUSH
55874: LD_EXP 86
55878: PPUSH
55879: LD_VAR 0 3
55883: PPUSH
55884: LD_VAR 0 3
55888: PPUSH
55889: LD_VAR 0 4
55893: PPUSH
55894: LD_INT 1
55896: PPUSH
55897: CALL 14803 0 3
55901: PPUSH
55902: CALL_OW 1
55906: ST_TO_ADDR
// end ;
55907: GO 55816
55909: POP
55910: POP
// end ;
55911: LD_VAR 0 1
55915: RET
// export function MC_InitSides ( ) ; var i ; begin
55916: LD_INT 0
55918: PPUSH
55919: PPUSH
// if not mc_bases then
55920: LD_EXP 59
55924: NOT
55925: IFFALSE 55929
// exit ;
55927: GO 56003
// for i = 1 to mc_bases do
55929: LD_ADDR_VAR 0 2
55933: PUSH
55934: DOUBLE
55935: LD_INT 1
55937: DEC
55938: ST_TO_ADDR
55939: LD_EXP 59
55943: PUSH
55944: FOR_TO
55945: IFFALSE 56001
// if mc_bases [ i ] then
55947: LD_EXP 59
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: IFFALSE 55999
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55959: LD_ADDR_EXP 85
55963: PUSH
55964: LD_EXP 85
55968: PPUSH
55969: LD_VAR 0 2
55973: PPUSH
55974: LD_EXP 59
55978: PUSH
55979: LD_VAR 0 2
55983: ARRAY
55984: PUSH
55985: LD_INT 1
55987: ARRAY
55988: PPUSH
55989: CALL_OW 255
55993: PPUSH
55994: CALL_OW 1
55998: ST_TO_ADDR
55999: GO 55944
56001: POP
56002: POP
// end ;
56003: LD_VAR 0 1
56007: RET
// every 0 0$03 trigger skirmish do
56008: LD_EXP 57
56012: IFFALSE 56166
56014: GO 56016
56016: DISABLE
// begin enable ;
56017: ENABLE
// MC_CheckBuildings ( ) ;
56018: CALL 60664 0 0
// MC_CheckPeopleLife ( ) ;
56022: CALL 60789 0 0
// RaiseSailEvent ( 100 ) ;
56026: LD_INT 100
56028: PPUSH
56029: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56033: LD_INT 103
56035: PPUSH
56036: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56040: LD_INT 104
56042: PPUSH
56043: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56047: LD_INT 105
56049: PPUSH
56050: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56054: LD_INT 106
56056: PPUSH
56057: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56061: LD_INT 107
56063: PPUSH
56064: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56068: LD_INT 108
56070: PPUSH
56071: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56075: LD_INT 109
56077: PPUSH
56078: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56082: LD_INT 110
56084: PPUSH
56085: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56089: LD_INT 111
56091: PPUSH
56092: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56096: LD_INT 112
56098: PPUSH
56099: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56103: LD_INT 113
56105: PPUSH
56106: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56110: LD_INT 120
56112: PPUSH
56113: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56117: LD_INT 121
56119: PPUSH
56120: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56124: LD_INT 122
56126: PPUSH
56127: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56131: LD_INT 123
56133: PPUSH
56134: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56138: LD_INT 124
56140: PPUSH
56141: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56145: LD_INT 125
56147: PPUSH
56148: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56152: LD_INT 126
56154: PPUSH
56155: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56159: LD_INT 200
56161: PPUSH
56162: CALL_OW 427
// end ;
56166: END
// on SailEvent ( event ) do begin if event < 100 then
56167: LD_VAR 0 1
56171: PUSH
56172: LD_INT 100
56174: LESS
56175: IFFALSE 56186
// CustomEvent ( event ) ;
56177: LD_VAR 0 1
56181: PPUSH
56182: CALL 13461 0 1
// if event = 100 then
56186: LD_VAR 0 1
56190: PUSH
56191: LD_INT 100
56193: EQUAL
56194: IFFALSE 56200
// MC_ClassManager ( ) ;
56196: CALL 56592 0 0
// if event = 101 then
56200: LD_VAR 0 1
56204: PUSH
56205: LD_INT 101
56207: EQUAL
56208: IFFALSE 56214
// MC_RepairBuildings ( ) ;
56210: CALL 61374 0 0
// if event = 102 then
56214: LD_VAR 0 1
56218: PUSH
56219: LD_INT 102
56221: EQUAL
56222: IFFALSE 56228
// MC_Heal ( ) ;
56224: CALL 62259 0 0
// if event = 103 then
56228: LD_VAR 0 1
56232: PUSH
56233: LD_INT 103
56235: EQUAL
56236: IFFALSE 56242
// MC_Build ( ) ;
56238: CALL 62681 0 0
// if event = 104 then
56242: LD_VAR 0 1
56246: PUSH
56247: LD_INT 104
56249: EQUAL
56250: IFFALSE 56256
// MC_TurretWeapon ( ) ;
56252: CALL 64322 0 0
// if event = 105 then
56256: LD_VAR 0 1
56260: PUSH
56261: LD_INT 105
56263: EQUAL
56264: IFFALSE 56270
// MC_BuildUpgrade ( ) ;
56266: CALL 63873 0 0
// if event = 106 then
56270: LD_VAR 0 1
56274: PUSH
56275: LD_INT 106
56277: EQUAL
56278: IFFALSE 56284
// MC_PlantMines ( ) ;
56280: CALL 64752 0 0
// if event = 107 then
56284: LD_VAR 0 1
56288: PUSH
56289: LD_INT 107
56291: EQUAL
56292: IFFALSE 56298
// MC_CollectCrates ( ) ;
56294: CALL 65543 0 0
// if event = 108 then
56298: LD_VAR 0 1
56302: PUSH
56303: LD_INT 108
56305: EQUAL
56306: IFFALSE 56312
// MC_LinkRemoteControl ( ) ;
56308: CALL 67319 0 0
// if event = 109 then
56312: LD_VAR 0 1
56316: PUSH
56317: LD_INT 109
56319: EQUAL
56320: IFFALSE 56326
// MC_ProduceVehicle ( ) ;
56322: CALL 67500 0 0
// if event = 110 then
56326: LD_VAR 0 1
56330: PUSH
56331: LD_INT 110
56333: EQUAL
56334: IFFALSE 56340
// MC_SendAttack ( ) ;
56336: CALL 67966 0 0
// if event = 111 then
56340: LD_VAR 0 1
56344: PUSH
56345: LD_INT 111
56347: EQUAL
56348: IFFALSE 56354
// MC_Defend ( ) ;
56350: CALL 68074 0 0
// if event = 112 then
56354: LD_VAR 0 1
56358: PUSH
56359: LD_INT 112
56361: EQUAL
56362: IFFALSE 56368
// MC_Research ( ) ;
56364: CALL 68796 0 0
// if event = 113 then
56368: LD_VAR 0 1
56372: PUSH
56373: LD_INT 113
56375: EQUAL
56376: IFFALSE 56382
// MC_MinesTrigger ( ) ;
56378: CALL 69910 0 0
// if event = 120 then
56382: LD_VAR 0 1
56386: PUSH
56387: LD_INT 120
56389: EQUAL
56390: IFFALSE 56396
// MC_RepairVehicle ( ) ;
56392: CALL 70009 0 0
// if event = 121 then
56396: LD_VAR 0 1
56400: PUSH
56401: LD_INT 121
56403: EQUAL
56404: IFFALSE 56410
// MC_TameApe ( ) ;
56406: CALL 70739 0 0
// if event = 122 then
56410: LD_VAR 0 1
56414: PUSH
56415: LD_INT 122
56417: EQUAL
56418: IFFALSE 56424
// MC_ChangeApeClass ( ) ;
56420: CALL 71568 0 0
// if event = 123 then
56424: LD_VAR 0 1
56428: PUSH
56429: LD_INT 123
56431: EQUAL
56432: IFFALSE 56438
// MC_Bazooka ( ) ;
56434: CALL 72218 0 0
// if event = 124 then
56438: LD_VAR 0 1
56442: PUSH
56443: LD_INT 124
56445: EQUAL
56446: IFFALSE 56452
// MC_TeleportExit ( ) ;
56448: CALL 72416 0 0
// if event = 125 then
56452: LD_VAR 0 1
56456: PUSH
56457: LD_INT 125
56459: EQUAL
56460: IFFALSE 56466
// MC_Deposits ( ) ;
56462: CALL 73063 0 0
// if event = 126 then
56466: LD_VAR 0 1
56470: PUSH
56471: LD_INT 126
56473: EQUAL
56474: IFFALSE 56480
// MC_RemoteDriver ( ) ;
56476: CALL 73688 0 0
// if event = 200 then
56480: LD_VAR 0 1
56484: PUSH
56485: LD_INT 200
56487: EQUAL
56488: IFFALSE 56494
// MC_Idle ( ) ;
56490: CALL 75637 0 0
// end ;
56494: PPOPN 1
56496: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56497: LD_INT 0
56499: PPUSH
56500: PPUSH
// if not mc_bases [ base ] or not tag then
56501: LD_EXP 59
56505: PUSH
56506: LD_VAR 0 1
56510: ARRAY
56511: NOT
56512: PUSH
56513: LD_VAR 0 2
56517: NOT
56518: OR
56519: IFFALSE 56523
// exit ;
56521: GO 56587
// for i in mc_bases [ base ] union mc_ape [ base ] do
56523: LD_ADDR_VAR 0 4
56527: PUSH
56528: LD_EXP 59
56532: PUSH
56533: LD_VAR 0 1
56537: ARRAY
56538: PUSH
56539: LD_EXP 88
56543: PUSH
56544: LD_VAR 0 1
56548: ARRAY
56549: UNION
56550: PUSH
56551: FOR_IN
56552: IFFALSE 56585
// if GetTag ( i ) = tag then
56554: LD_VAR 0 4
56558: PPUSH
56559: CALL_OW 110
56563: PUSH
56564: LD_VAR 0 2
56568: EQUAL
56569: IFFALSE 56583
// SetTag ( i , 0 ) ;
56571: LD_VAR 0 4
56575: PPUSH
56576: LD_INT 0
56578: PPUSH
56579: CALL_OW 109
56583: GO 56551
56585: POP
56586: POP
// end ;
56587: LD_VAR 0 3
56591: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56592: LD_INT 0
56594: PPUSH
56595: PPUSH
56596: PPUSH
56597: PPUSH
56598: PPUSH
56599: PPUSH
56600: PPUSH
56601: PPUSH
// if not mc_bases then
56602: LD_EXP 59
56606: NOT
56607: IFFALSE 56611
// exit ;
56609: GO 57069
// for i = 1 to mc_bases do
56611: LD_ADDR_VAR 0 2
56615: PUSH
56616: DOUBLE
56617: LD_INT 1
56619: DEC
56620: ST_TO_ADDR
56621: LD_EXP 59
56625: PUSH
56626: FOR_TO
56627: IFFALSE 57067
// begin tmp := MC_ClassCheckReq ( i ) ;
56629: LD_ADDR_VAR 0 4
56633: PUSH
56634: LD_VAR 0 2
56638: PPUSH
56639: CALL 57074 0 1
56643: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56644: LD_ADDR_EXP 100
56648: PUSH
56649: LD_EXP 100
56653: PPUSH
56654: LD_VAR 0 2
56658: PPUSH
56659: LD_VAR 0 4
56663: PPUSH
56664: CALL_OW 1
56668: ST_TO_ADDR
// if not tmp then
56669: LD_VAR 0 4
56673: NOT
56674: IFFALSE 56678
// continue ;
56676: GO 56626
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56678: LD_ADDR_VAR 0 6
56682: PUSH
56683: LD_EXP 59
56687: PUSH
56688: LD_VAR 0 2
56692: ARRAY
56693: PPUSH
56694: LD_INT 2
56696: PUSH
56697: LD_INT 30
56699: PUSH
56700: LD_INT 4
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PUSH
56707: LD_INT 30
56709: PUSH
56710: LD_INT 5
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: LIST
56721: PPUSH
56722: CALL_OW 72
56726: PUSH
56727: LD_EXP 59
56731: PUSH
56732: LD_VAR 0 2
56736: ARRAY
56737: PPUSH
56738: LD_INT 2
56740: PUSH
56741: LD_INT 30
56743: PUSH
56744: LD_INT 0
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PUSH
56751: LD_INT 30
56753: PUSH
56754: LD_INT 1
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PUSH
56761: EMPTY
56762: LIST
56763: LIST
56764: LIST
56765: PPUSH
56766: CALL_OW 72
56770: PUSH
56771: LD_EXP 59
56775: PUSH
56776: LD_VAR 0 2
56780: ARRAY
56781: PPUSH
56782: LD_INT 30
56784: PUSH
56785: LD_INT 3
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: PPUSH
56792: CALL_OW 72
56796: PUSH
56797: LD_EXP 59
56801: PUSH
56802: LD_VAR 0 2
56806: ARRAY
56807: PPUSH
56808: LD_INT 2
56810: PUSH
56811: LD_INT 30
56813: PUSH
56814: LD_INT 6
56816: PUSH
56817: EMPTY
56818: LIST
56819: LIST
56820: PUSH
56821: LD_INT 30
56823: PUSH
56824: LD_INT 7
56826: PUSH
56827: EMPTY
56828: LIST
56829: LIST
56830: PUSH
56831: LD_INT 30
56833: PUSH
56834: LD_INT 8
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: PUSH
56841: EMPTY
56842: LIST
56843: LIST
56844: LIST
56845: LIST
56846: PPUSH
56847: CALL_OW 72
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: LIST
56856: LIST
56857: ST_TO_ADDR
// for j = 1 to 4 do
56858: LD_ADDR_VAR 0 3
56862: PUSH
56863: DOUBLE
56864: LD_INT 1
56866: DEC
56867: ST_TO_ADDR
56868: LD_INT 4
56870: PUSH
56871: FOR_TO
56872: IFFALSE 57063
// begin if not tmp [ j ] then
56874: LD_VAR 0 4
56878: PUSH
56879: LD_VAR 0 3
56883: ARRAY
56884: NOT
56885: IFFALSE 56889
// continue ;
56887: GO 56871
// for p in tmp [ j ] do
56889: LD_ADDR_VAR 0 5
56893: PUSH
56894: LD_VAR 0 4
56898: PUSH
56899: LD_VAR 0 3
56903: ARRAY
56904: PUSH
56905: FOR_IN
56906: IFFALSE 57059
// begin if not b [ j ] then
56908: LD_VAR 0 6
56912: PUSH
56913: LD_VAR 0 3
56917: ARRAY
56918: NOT
56919: IFFALSE 56923
// break ;
56921: GO 57059
// e := 0 ;
56923: LD_ADDR_VAR 0 7
56927: PUSH
56928: LD_INT 0
56930: ST_TO_ADDR
// for k in b [ j ] do
56931: LD_ADDR_VAR 0 8
56935: PUSH
56936: LD_VAR 0 6
56940: PUSH
56941: LD_VAR 0 3
56945: ARRAY
56946: PUSH
56947: FOR_IN
56948: IFFALSE 56975
// if IsNotFull ( k ) then
56950: LD_VAR 0 8
56954: PPUSH
56955: CALL 16952 0 1
56959: IFFALSE 56973
// begin e := k ;
56961: LD_ADDR_VAR 0 7
56965: PUSH
56966: LD_VAR 0 8
56970: ST_TO_ADDR
// break ;
56971: GO 56975
// end ;
56973: GO 56947
56975: POP
56976: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56977: LD_VAR 0 7
56981: PUSH
56982: LD_VAR 0 5
56986: PPUSH
56987: LD_VAR 0 7
56991: PPUSH
56992: CALL 49675 0 2
56996: NOT
56997: AND
56998: IFFALSE 57057
// begin if IsInUnit ( p ) then
57000: LD_VAR 0 5
57004: PPUSH
57005: CALL_OW 310
57009: IFFALSE 57020
// ComExitBuilding ( p ) ;
57011: LD_VAR 0 5
57015: PPUSH
57016: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57020: LD_VAR 0 5
57024: PPUSH
57025: LD_VAR 0 7
57029: PPUSH
57030: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57034: LD_VAR 0 5
57038: PPUSH
57039: LD_VAR 0 3
57043: PPUSH
57044: CALL_OW 183
// AddComExitBuilding ( p ) ;
57048: LD_VAR 0 5
57052: PPUSH
57053: CALL_OW 182
// end ; end ;
57057: GO 56905
57059: POP
57060: POP
// end ;
57061: GO 56871
57063: POP
57064: POP
// end ;
57065: GO 56626
57067: POP
57068: POP
// end ;
57069: LD_VAR 0 1
57073: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57074: LD_INT 0
57076: PPUSH
57077: PPUSH
57078: PPUSH
57079: PPUSH
57080: PPUSH
57081: PPUSH
57082: PPUSH
57083: PPUSH
57084: PPUSH
57085: PPUSH
57086: PPUSH
57087: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57088: LD_VAR 0 1
57092: NOT
57093: PUSH
57094: LD_EXP 59
57098: PUSH
57099: LD_VAR 0 1
57103: ARRAY
57104: NOT
57105: OR
57106: PUSH
57107: LD_EXP 59
57111: PUSH
57112: LD_VAR 0 1
57116: ARRAY
57117: PPUSH
57118: LD_INT 2
57120: PUSH
57121: LD_INT 30
57123: PUSH
57124: LD_INT 0
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: LD_INT 30
57133: PUSH
57134: LD_INT 1
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: LIST
57145: PPUSH
57146: CALL_OW 72
57150: NOT
57151: OR
57152: IFFALSE 57156
// exit ;
57154: GO 60659
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57156: LD_ADDR_VAR 0 4
57160: PUSH
57161: LD_EXP 59
57165: PUSH
57166: LD_VAR 0 1
57170: ARRAY
57171: PPUSH
57172: LD_INT 2
57174: PUSH
57175: LD_INT 25
57177: PUSH
57178: LD_INT 1
57180: PUSH
57181: EMPTY
57182: LIST
57183: LIST
57184: PUSH
57185: LD_INT 25
57187: PUSH
57188: LD_INT 2
57190: PUSH
57191: EMPTY
57192: LIST
57193: LIST
57194: PUSH
57195: LD_INT 25
57197: PUSH
57198: LD_INT 3
57200: PUSH
57201: EMPTY
57202: LIST
57203: LIST
57204: PUSH
57205: LD_INT 25
57207: PUSH
57208: LD_INT 4
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: PUSH
57215: LD_INT 25
57217: PUSH
57218: LD_INT 5
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: LD_INT 25
57227: PUSH
57228: LD_INT 8
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: PUSH
57235: LD_INT 25
57237: PUSH
57238: LD_INT 9
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PUSH
57245: EMPTY
57246: LIST
57247: LIST
57248: LIST
57249: LIST
57250: LIST
57251: LIST
57252: LIST
57253: LIST
57254: PPUSH
57255: CALL_OW 72
57259: ST_TO_ADDR
// if not tmp then
57260: LD_VAR 0 4
57264: NOT
57265: IFFALSE 57269
// exit ;
57267: GO 60659
// for i in tmp do
57269: LD_ADDR_VAR 0 3
57273: PUSH
57274: LD_VAR 0 4
57278: PUSH
57279: FOR_IN
57280: IFFALSE 57311
// if GetTag ( i ) then
57282: LD_VAR 0 3
57286: PPUSH
57287: CALL_OW 110
57291: IFFALSE 57309
// tmp := tmp diff i ;
57293: LD_ADDR_VAR 0 4
57297: PUSH
57298: LD_VAR 0 4
57302: PUSH
57303: LD_VAR 0 3
57307: DIFF
57308: ST_TO_ADDR
57309: GO 57279
57311: POP
57312: POP
// if not tmp then
57313: LD_VAR 0 4
57317: NOT
57318: IFFALSE 57322
// exit ;
57320: GO 60659
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57322: LD_ADDR_VAR 0 5
57326: PUSH
57327: LD_EXP 59
57331: PUSH
57332: LD_VAR 0 1
57336: ARRAY
57337: PPUSH
57338: LD_INT 2
57340: PUSH
57341: LD_INT 25
57343: PUSH
57344: LD_INT 1
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PUSH
57351: LD_INT 25
57353: PUSH
57354: LD_INT 5
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: PUSH
57361: LD_INT 25
57363: PUSH
57364: LD_INT 8
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: PUSH
57371: LD_INT 25
57373: PUSH
57374: LD_INT 9
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: LIST
57385: LIST
57386: LIST
57387: PPUSH
57388: CALL_OW 72
57392: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57393: LD_ADDR_VAR 0 6
57397: PUSH
57398: LD_EXP 59
57402: PUSH
57403: LD_VAR 0 1
57407: ARRAY
57408: PPUSH
57409: LD_INT 25
57411: PUSH
57412: LD_INT 2
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PPUSH
57419: CALL_OW 72
57423: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57424: LD_ADDR_VAR 0 7
57428: PUSH
57429: LD_EXP 59
57433: PUSH
57434: LD_VAR 0 1
57438: ARRAY
57439: PPUSH
57440: LD_INT 25
57442: PUSH
57443: LD_INT 3
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: PPUSH
57450: CALL_OW 72
57454: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57455: LD_ADDR_VAR 0 8
57459: PUSH
57460: LD_EXP 59
57464: PUSH
57465: LD_VAR 0 1
57469: ARRAY
57470: PPUSH
57471: LD_INT 25
57473: PUSH
57474: LD_INT 4
57476: PUSH
57477: EMPTY
57478: LIST
57479: LIST
57480: PUSH
57481: LD_INT 24
57483: PUSH
57484: LD_INT 251
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PUSH
57491: EMPTY
57492: LIST
57493: LIST
57494: PPUSH
57495: CALL_OW 72
57499: ST_TO_ADDR
// if mc_scan [ base ] then
57500: LD_EXP 82
57504: PUSH
57505: LD_VAR 0 1
57509: ARRAY
57510: IFFALSE 57971
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57512: LD_ADDR_EXP 101
57516: PUSH
57517: LD_EXP 101
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: LD_INT 4
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57535: LD_ADDR_VAR 0 12
57539: PUSH
57540: LD_EXP 59
57544: PUSH
57545: LD_VAR 0 1
57549: ARRAY
57550: PPUSH
57551: LD_INT 2
57553: PUSH
57554: LD_INT 30
57556: PUSH
57557: LD_INT 4
57559: PUSH
57560: EMPTY
57561: LIST
57562: LIST
57563: PUSH
57564: LD_INT 30
57566: PUSH
57567: LD_INT 5
57569: PUSH
57570: EMPTY
57571: LIST
57572: LIST
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: LIST
57578: PPUSH
57579: CALL_OW 72
57583: ST_TO_ADDR
// if not b then
57584: LD_VAR 0 12
57588: NOT
57589: IFFALSE 57593
// exit ;
57591: GO 60659
// p := [ ] ;
57593: LD_ADDR_VAR 0 11
57597: PUSH
57598: EMPTY
57599: ST_TO_ADDR
// if sci >= 2 then
57600: LD_VAR 0 8
57604: PUSH
57605: LD_INT 2
57607: GREATEREQUAL
57608: IFFALSE 57639
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57610: LD_ADDR_VAR 0 8
57614: PUSH
57615: LD_VAR 0 8
57619: PUSH
57620: LD_INT 1
57622: ARRAY
57623: PUSH
57624: LD_VAR 0 8
57628: PUSH
57629: LD_INT 2
57631: ARRAY
57632: PUSH
57633: EMPTY
57634: LIST
57635: LIST
57636: ST_TO_ADDR
57637: GO 57700
// if sci = 1 then
57639: LD_VAR 0 8
57643: PUSH
57644: LD_INT 1
57646: EQUAL
57647: IFFALSE 57668
// sci := [ sci [ 1 ] ] else
57649: LD_ADDR_VAR 0 8
57653: PUSH
57654: LD_VAR 0 8
57658: PUSH
57659: LD_INT 1
57661: ARRAY
57662: PUSH
57663: EMPTY
57664: LIST
57665: ST_TO_ADDR
57666: GO 57700
// if sci = 0 then
57668: LD_VAR 0 8
57672: PUSH
57673: LD_INT 0
57675: EQUAL
57676: IFFALSE 57700
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57678: LD_ADDR_VAR 0 11
57682: PUSH
57683: LD_VAR 0 4
57687: PPUSH
57688: LD_INT 4
57690: PPUSH
57691: CALL 49538 0 2
57695: PUSH
57696: LD_INT 1
57698: ARRAY
57699: ST_TO_ADDR
// if eng > 4 then
57700: LD_VAR 0 6
57704: PUSH
57705: LD_INT 4
57707: GREATER
57708: IFFALSE 57754
// for i = eng downto 4 do
57710: LD_ADDR_VAR 0 3
57714: PUSH
57715: DOUBLE
57716: LD_VAR 0 6
57720: INC
57721: ST_TO_ADDR
57722: LD_INT 4
57724: PUSH
57725: FOR_DOWNTO
57726: IFFALSE 57752
// eng := eng diff eng [ i ] ;
57728: LD_ADDR_VAR 0 6
57732: PUSH
57733: LD_VAR 0 6
57737: PUSH
57738: LD_VAR 0 6
57742: PUSH
57743: LD_VAR 0 3
57747: ARRAY
57748: DIFF
57749: ST_TO_ADDR
57750: GO 57725
57752: POP
57753: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57754: LD_ADDR_VAR 0 4
57758: PUSH
57759: LD_VAR 0 4
57763: PUSH
57764: LD_VAR 0 5
57768: PUSH
57769: LD_VAR 0 6
57773: UNION
57774: PUSH
57775: LD_VAR 0 7
57779: UNION
57780: PUSH
57781: LD_VAR 0 8
57785: UNION
57786: DIFF
57787: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57788: LD_ADDR_VAR 0 13
57792: PUSH
57793: LD_EXP 59
57797: PUSH
57798: LD_VAR 0 1
57802: ARRAY
57803: PPUSH
57804: LD_INT 2
57806: PUSH
57807: LD_INT 30
57809: PUSH
57810: LD_INT 32
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: PUSH
57817: LD_INT 30
57819: PUSH
57820: LD_INT 31
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: LIST
57831: PPUSH
57832: CALL_OW 72
57836: PUSH
57837: LD_EXP 59
57841: PUSH
57842: LD_VAR 0 1
57846: ARRAY
57847: PPUSH
57848: LD_INT 2
57850: PUSH
57851: LD_INT 30
57853: PUSH
57854: LD_INT 4
57856: PUSH
57857: EMPTY
57858: LIST
57859: LIST
57860: PUSH
57861: LD_INT 30
57863: PUSH
57864: LD_INT 5
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: LIST
57875: PPUSH
57876: CALL_OW 72
57880: PUSH
57881: LD_INT 6
57883: MUL
57884: PLUS
57885: ST_TO_ADDR
// if bcount < tmp then
57886: LD_VAR 0 13
57890: PUSH
57891: LD_VAR 0 4
57895: LESS
57896: IFFALSE 57942
// for i = tmp downto bcount do
57898: LD_ADDR_VAR 0 3
57902: PUSH
57903: DOUBLE
57904: LD_VAR 0 4
57908: INC
57909: ST_TO_ADDR
57910: LD_VAR 0 13
57914: PUSH
57915: FOR_DOWNTO
57916: IFFALSE 57940
// tmp := Delete ( tmp , tmp ) ;
57918: LD_ADDR_VAR 0 4
57922: PUSH
57923: LD_VAR 0 4
57927: PPUSH
57928: LD_VAR 0 4
57932: PPUSH
57933: CALL_OW 3
57937: ST_TO_ADDR
57938: GO 57915
57940: POP
57941: POP
// result := [ tmp , 0 , 0 , p ] ;
57942: LD_ADDR_VAR 0 2
57946: PUSH
57947: LD_VAR 0 4
57951: PUSH
57952: LD_INT 0
57954: PUSH
57955: LD_INT 0
57957: PUSH
57958: LD_VAR 0 11
57962: PUSH
57963: EMPTY
57964: LIST
57965: LIST
57966: LIST
57967: LIST
57968: ST_TO_ADDR
// exit ;
57969: GO 60659
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57971: LD_EXP 59
57975: PUSH
57976: LD_VAR 0 1
57980: ARRAY
57981: PPUSH
57982: LD_INT 2
57984: PUSH
57985: LD_INT 30
57987: PUSH
57988: LD_INT 6
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: PUSH
57995: LD_INT 30
57997: PUSH
57998: LD_INT 7
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: LD_INT 30
58007: PUSH
58008: LD_INT 8
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: LIST
58019: LIST
58020: PPUSH
58021: CALL_OW 72
58025: NOT
58026: PUSH
58027: LD_EXP 59
58031: PUSH
58032: LD_VAR 0 1
58036: ARRAY
58037: PPUSH
58038: LD_INT 30
58040: PUSH
58041: LD_INT 3
58043: PUSH
58044: EMPTY
58045: LIST
58046: LIST
58047: PPUSH
58048: CALL_OW 72
58052: NOT
58053: AND
58054: IFFALSE 58126
// begin if eng = tmp then
58056: LD_VAR 0 6
58060: PUSH
58061: LD_VAR 0 4
58065: EQUAL
58066: IFFALSE 58070
// exit ;
58068: GO 60659
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58070: LD_ADDR_EXP 101
58074: PUSH
58075: LD_EXP 101
58079: PPUSH
58080: LD_VAR 0 1
58084: PPUSH
58085: LD_INT 1
58087: PPUSH
58088: CALL_OW 1
58092: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58093: LD_ADDR_VAR 0 2
58097: PUSH
58098: LD_INT 0
58100: PUSH
58101: LD_VAR 0 4
58105: PUSH
58106: LD_VAR 0 6
58110: DIFF
58111: PUSH
58112: LD_INT 0
58114: PUSH
58115: LD_INT 0
58117: PUSH
58118: EMPTY
58119: LIST
58120: LIST
58121: LIST
58122: LIST
58123: ST_TO_ADDR
// exit ;
58124: GO 60659
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58126: LD_EXP 86
58130: PUSH
58131: LD_EXP 85
58135: PUSH
58136: LD_VAR 0 1
58140: ARRAY
58141: ARRAY
58142: PUSH
58143: LD_EXP 59
58147: PUSH
58148: LD_VAR 0 1
58152: ARRAY
58153: PPUSH
58154: LD_INT 2
58156: PUSH
58157: LD_INT 30
58159: PUSH
58160: LD_INT 6
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: LD_INT 30
58169: PUSH
58170: LD_INT 7
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: LD_INT 30
58179: PUSH
58180: LD_INT 8
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: PUSH
58187: EMPTY
58188: LIST
58189: LIST
58190: LIST
58191: LIST
58192: PPUSH
58193: CALL_OW 72
58197: AND
58198: PUSH
58199: LD_EXP 59
58203: PUSH
58204: LD_VAR 0 1
58208: ARRAY
58209: PPUSH
58210: LD_INT 30
58212: PUSH
58213: LD_INT 3
58215: PUSH
58216: EMPTY
58217: LIST
58218: LIST
58219: PPUSH
58220: CALL_OW 72
58224: NOT
58225: AND
58226: IFFALSE 58440
// begin if sci >= 6 then
58228: LD_VAR 0 8
58232: PUSH
58233: LD_INT 6
58235: GREATEREQUAL
58236: IFFALSE 58240
// exit ;
58238: GO 60659
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58240: LD_ADDR_EXP 101
58244: PUSH
58245: LD_EXP 101
58249: PPUSH
58250: LD_VAR 0 1
58254: PPUSH
58255: LD_INT 2
58257: PPUSH
58258: CALL_OW 1
58262: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58263: LD_ADDR_VAR 0 9
58267: PUSH
58268: LD_VAR 0 4
58272: PUSH
58273: LD_VAR 0 8
58277: DIFF
58278: PPUSH
58279: LD_INT 4
58281: PPUSH
58282: CALL 49538 0 2
58286: ST_TO_ADDR
// p := [ ] ;
58287: LD_ADDR_VAR 0 11
58291: PUSH
58292: EMPTY
58293: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58294: LD_VAR 0 8
58298: PUSH
58299: LD_INT 6
58301: LESS
58302: PUSH
58303: LD_VAR 0 9
58307: PUSH
58308: LD_INT 6
58310: GREATER
58311: AND
58312: IFFALSE 58393
// begin for i = 1 to 6 - sci do
58314: LD_ADDR_VAR 0 3
58318: PUSH
58319: DOUBLE
58320: LD_INT 1
58322: DEC
58323: ST_TO_ADDR
58324: LD_INT 6
58326: PUSH
58327: LD_VAR 0 8
58331: MINUS
58332: PUSH
58333: FOR_TO
58334: IFFALSE 58389
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58336: LD_ADDR_VAR 0 11
58340: PUSH
58341: LD_VAR 0 11
58345: PPUSH
58346: LD_VAR 0 11
58350: PUSH
58351: LD_INT 1
58353: PLUS
58354: PPUSH
58355: LD_VAR 0 9
58359: PUSH
58360: LD_INT 1
58362: ARRAY
58363: PPUSH
58364: CALL_OW 2
58368: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58369: LD_ADDR_VAR 0 9
58373: PUSH
58374: LD_VAR 0 9
58378: PPUSH
58379: LD_INT 1
58381: PPUSH
58382: CALL_OW 3
58386: ST_TO_ADDR
// end ;
58387: GO 58333
58389: POP
58390: POP
// end else
58391: GO 58413
// if sort then
58393: LD_VAR 0 9
58397: IFFALSE 58413
// p := sort [ 1 ] ;
58399: LD_ADDR_VAR 0 11
58403: PUSH
58404: LD_VAR 0 9
58408: PUSH
58409: LD_INT 1
58411: ARRAY
58412: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58413: LD_ADDR_VAR 0 2
58417: PUSH
58418: LD_INT 0
58420: PUSH
58421: LD_INT 0
58423: PUSH
58424: LD_INT 0
58426: PUSH
58427: LD_VAR 0 11
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: LIST
58437: ST_TO_ADDR
// exit ;
58438: GO 60659
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58440: LD_EXP 86
58444: PUSH
58445: LD_EXP 85
58449: PUSH
58450: LD_VAR 0 1
58454: ARRAY
58455: ARRAY
58456: PUSH
58457: LD_EXP 59
58461: PUSH
58462: LD_VAR 0 1
58466: ARRAY
58467: PPUSH
58468: LD_INT 2
58470: PUSH
58471: LD_INT 30
58473: PUSH
58474: LD_INT 6
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: PUSH
58481: LD_INT 30
58483: PUSH
58484: LD_INT 7
58486: PUSH
58487: EMPTY
58488: LIST
58489: LIST
58490: PUSH
58491: LD_INT 30
58493: PUSH
58494: LD_INT 8
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: PUSH
58501: EMPTY
58502: LIST
58503: LIST
58504: LIST
58505: LIST
58506: PPUSH
58507: CALL_OW 72
58511: AND
58512: PUSH
58513: LD_EXP 59
58517: PUSH
58518: LD_VAR 0 1
58522: ARRAY
58523: PPUSH
58524: LD_INT 30
58526: PUSH
58527: LD_INT 3
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: PPUSH
58534: CALL_OW 72
58538: AND
58539: IFFALSE 59273
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58541: LD_ADDR_EXP 101
58545: PUSH
58546: LD_EXP 101
58550: PPUSH
58551: LD_VAR 0 1
58555: PPUSH
58556: LD_INT 3
58558: PPUSH
58559: CALL_OW 1
58563: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58564: LD_ADDR_VAR 0 2
58568: PUSH
58569: LD_INT 0
58571: PUSH
58572: LD_INT 0
58574: PUSH
58575: LD_INT 0
58577: PUSH
58578: LD_INT 0
58580: PUSH
58581: EMPTY
58582: LIST
58583: LIST
58584: LIST
58585: LIST
58586: ST_TO_ADDR
// if not eng then
58587: LD_VAR 0 6
58591: NOT
58592: IFFALSE 58655
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58594: LD_ADDR_VAR 0 11
58598: PUSH
58599: LD_VAR 0 4
58603: PPUSH
58604: LD_INT 2
58606: PPUSH
58607: CALL 49538 0 2
58611: PUSH
58612: LD_INT 1
58614: ARRAY
58615: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58616: LD_ADDR_VAR 0 2
58620: PUSH
58621: LD_VAR 0 2
58625: PPUSH
58626: LD_INT 2
58628: PPUSH
58629: LD_VAR 0 11
58633: PPUSH
58634: CALL_OW 1
58638: ST_TO_ADDR
// tmp := tmp diff p ;
58639: LD_ADDR_VAR 0 4
58643: PUSH
58644: LD_VAR 0 4
58648: PUSH
58649: LD_VAR 0 11
58653: DIFF
58654: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58655: LD_VAR 0 4
58659: PUSH
58660: LD_VAR 0 8
58664: PUSH
58665: LD_INT 6
58667: LESS
58668: AND
58669: IFFALSE 58857
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58671: LD_ADDR_VAR 0 9
58675: PUSH
58676: LD_VAR 0 4
58680: PUSH
58681: LD_VAR 0 8
58685: PUSH
58686: LD_VAR 0 7
58690: UNION
58691: DIFF
58692: PPUSH
58693: LD_INT 4
58695: PPUSH
58696: CALL 49538 0 2
58700: ST_TO_ADDR
// p := [ ] ;
58701: LD_ADDR_VAR 0 11
58705: PUSH
58706: EMPTY
58707: ST_TO_ADDR
// if sort then
58708: LD_VAR 0 9
58712: IFFALSE 58828
// for i = 1 to 6 - sci do
58714: LD_ADDR_VAR 0 3
58718: PUSH
58719: DOUBLE
58720: LD_INT 1
58722: DEC
58723: ST_TO_ADDR
58724: LD_INT 6
58726: PUSH
58727: LD_VAR 0 8
58731: MINUS
58732: PUSH
58733: FOR_TO
58734: IFFALSE 58826
// begin if i = sort then
58736: LD_VAR 0 3
58740: PUSH
58741: LD_VAR 0 9
58745: EQUAL
58746: IFFALSE 58750
// break ;
58748: GO 58826
// if GetClass ( i ) = 4 then
58750: LD_VAR 0 3
58754: PPUSH
58755: CALL_OW 257
58759: PUSH
58760: LD_INT 4
58762: EQUAL
58763: IFFALSE 58767
// continue ;
58765: GO 58733
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58767: LD_ADDR_VAR 0 11
58771: PUSH
58772: LD_VAR 0 11
58776: PPUSH
58777: LD_VAR 0 11
58781: PUSH
58782: LD_INT 1
58784: PLUS
58785: PPUSH
58786: LD_VAR 0 9
58790: PUSH
58791: LD_VAR 0 3
58795: ARRAY
58796: PPUSH
58797: CALL_OW 2
58801: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58802: LD_ADDR_VAR 0 4
58806: PUSH
58807: LD_VAR 0 4
58811: PUSH
58812: LD_VAR 0 9
58816: PUSH
58817: LD_VAR 0 3
58821: ARRAY
58822: DIFF
58823: ST_TO_ADDR
// end ;
58824: GO 58733
58826: POP
58827: POP
// if p then
58828: LD_VAR 0 11
58832: IFFALSE 58857
// result := Replace ( result , 4 , p ) ;
58834: LD_ADDR_VAR 0 2
58838: PUSH
58839: LD_VAR 0 2
58843: PPUSH
58844: LD_INT 4
58846: PPUSH
58847: LD_VAR 0 11
58851: PPUSH
58852: CALL_OW 1
58856: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58857: LD_VAR 0 4
58861: PUSH
58862: LD_VAR 0 7
58866: PUSH
58867: LD_INT 6
58869: LESS
58870: AND
58871: IFFALSE 59059
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58873: LD_ADDR_VAR 0 9
58877: PUSH
58878: LD_VAR 0 4
58882: PUSH
58883: LD_VAR 0 8
58887: PUSH
58888: LD_VAR 0 7
58892: UNION
58893: DIFF
58894: PPUSH
58895: LD_INT 3
58897: PPUSH
58898: CALL 49538 0 2
58902: ST_TO_ADDR
// p := [ ] ;
58903: LD_ADDR_VAR 0 11
58907: PUSH
58908: EMPTY
58909: ST_TO_ADDR
// if sort then
58910: LD_VAR 0 9
58914: IFFALSE 59030
// for i = 1 to 6 - mech do
58916: LD_ADDR_VAR 0 3
58920: PUSH
58921: DOUBLE
58922: LD_INT 1
58924: DEC
58925: ST_TO_ADDR
58926: LD_INT 6
58928: PUSH
58929: LD_VAR 0 7
58933: MINUS
58934: PUSH
58935: FOR_TO
58936: IFFALSE 59028
// begin if i = sort then
58938: LD_VAR 0 3
58942: PUSH
58943: LD_VAR 0 9
58947: EQUAL
58948: IFFALSE 58952
// break ;
58950: GO 59028
// if GetClass ( i ) = 3 then
58952: LD_VAR 0 3
58956: PPUSH
58957: CALL_OW 257
58961: PUSH
58962: LD_INT 3
58964: EQUAL
58965: IFFALSE 58969
// continue ;
58967: GO 58935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58969: LD_ADDR_VAR 0 11
58973: PUSH
58974: LD_VAR 0 11
58978: PPUSH
58979: LD_VAR 0 11
58983: PUSH
58984: LD_INT 1
58986: PLUS
58987: PPUSH
58988: LD_VAR 0 9
58992: PUSH
58993: LD_VAR 0 3
58997: ARRAY
58998: PPUSH
58999: CALL_OW 2
59003: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59004: LD_ADDR_VAR 0 4
59008: PUSH
59009: LD_VAR 0 4
59013: PUSH
59014: LD_VAR 0 9
59018: PUSH
59019: LD_VAR 0 3
59023: ARRAY
59024: DIFF
59025: ST_TO_ADDR
// end ;
59026: GO 58935
59028: POP
59029: POP
// if p then
59030: LD_VAR 0 11
59034: IFFALSE 59059
// result := Replace ( result , 3 , p ) ;
59036: LD_ADDR_VAR 0 2
59040: PUSH
59041: LD_VAR 0 2
59045: PPUSH
59046: LD_INT 3
59048: PPUSH
59049: LD_VAR 0 11
59053: PPUSH
59054: CALL_OW 1
59058: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59059: LD_VAR 0 4
59063: PUSH
59064: LD_INT 6
59066: GREATER
59067: PUSH
59068: LD_VAR 0 6
59072: PUSH
59073: LD_INT 6
59075: LESS
59076: AND
59077: IFFALSE 59271
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59079: LD_ADDR_VAR 0 9
59083: PUSH
59084: LD_VAR 0 4
59088: PUSH
59089: LD_VAR 0 8
59093: PUSH
59094: LD_VAR 0 7
59098: UNION
59099: PUSH
59100: LD_VAR 0 6
59104: UNION
59105: DIFF
59106: PPUSH
59107: LD_INT 2
59109: PPUSH
59110: CALL 49538 0 2
59114: ST_TO_ADDR
// p := [ ] ;
59115: LD_ADDR_VAR 0 11
59119: PUSH
59120: EMPTY
59121: ST_TO_ADDR
// if sort then
59122: LD_VAR 0 9
59126: IFFALSE 59242
// for i = 1 to 6 - eng do
59128: LD_ADDR_VAR 0 3
59132: PUSH
59133: DOUBLE
59134: LD_INT 1
59136: DEC
59137: ST_TO_ADDR
59138: LD_INT 6
59140: PUSH
59141: LD_VAR 0 6
59145: MINUS
59146: PUSH
59147: FOR_TO
59148: IFFALSE 59240
// begin if i = sort then
59150: LD_VAR 0 3
59154: PUSH
59155: LD_VAR 0 9
59159: EQUAL
59160: IFFALSE 59164
// break ;
59162: GO 59240
// if GetClass ( i ) = 2 then
59164: LD_VAR 0 3
59168: PPUSH
59169: CALL_OW 257
59173: PUSH
59174: LD_INT 2
59176: EQUAL
59177: IFFALSE 59181
// continue ;
59179: GO 59147
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59181: LD_ADDR_VAR 0 11
59185: PUSH
59186: LD_VAR 0 11
59190: PPUSH
59191: LD_VAR 0 11
59195: PUSH
59196: LD_INT 1
59198: PLUS
59199: PPUSH
59200: LD_VAR 0 9
59204: PUSH
59205: LD_VAR 0 3
59209: ARRAY
59210: PPUSH
59211: CALL_OW 2
59215: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59216: LD_ADDR_VAR 0 4
59220: PUSH
59221: LD_VAR 0 4
59225: PUSH
59226: LD_VAR 0 9
59230: PUSH
59231: LD_VAR 0 3
59235: ARRAY
59236: DIFF
59237: ST_TO_ADDR
// end ;
59238: GO 59147
59240: POP
59241: POP
// if p then
59242: LD_VAR 0 11
59246: IFFALSE 59271
// result := Replace ( result , 2 , p ) ;
59248: LD_ADDR_VAR 0 2
59252: PUSH
59253: LD_VAR 0 2
59257: PPUSH
59258: LD_INT 2
59260: PPUSH
59261: LD_VAR 0 11
59265: PPUSH
59266: CALL_OW 1
59270: ST_TO_ADDR
// end ; exit ;
59271: GO 60659
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59273: LD_EXP 86
59277: PUSH
59278: LD_EXP 85
59282: PUSH
59283: LD_VAR 0 1
59287: ARRAY
59288: ARRAY
59289: NOT
59290: PUSH
59291: LD_EXP 59
59295: PUSH
59296: LD_VAR 0 1
59300: ARRAY
59301: PPUSH
59302: LD_INT 30
59304: PUSH
59305: LD_INT 3
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: PPUSH
59312: CALL_OW 72
59316: AND
59317: PUSH
59318: LD_EXP 64
59322: PUSH
59323: LD_VAR 0 1
59327: ARRAY
59328: AND
59329: IFFALSE 59937
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59331: LD_ADDR_EXP 101
59335: PUSH
59336: LD_EXP 101
59340: PPUSH
59341: LD_VAR 0 1
59345: PPUSH
59346: LD_INT 5
59348: PPUSH
59349: CALL_OW 1
59353: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59354: LD_ADDR_VAR 0 2
59358: PUSH
59359: LD_INT 0
59361: PUSH
59362: LD_INT 0
59364: PUSH
59365: LD_INT 0
59367: PUSH
59368: LD_INT 0
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: LIST
59375: LIST
59376: ST_TO_ADDR
// if sci > 1 then
59377: LD_VAR 0 8
59381: PUSH
59382: LD_INT 1
59384: GREATER
59385: IFFALSE 59413
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59387: LD_ADDR_VAR 0 4
59391: PUSH
59392: LD_VAR 0 4
59396: PUSH
59397: LD_VAR 0 8
59401: PUSH
59402: LD_VAR 0 8
59406: PUSH
59407: LD_INT 1
59409: ARRAY
59410: DIFF
59411: DIFF
59412: ST_TO_ADDR
// if tmp and not sci then
59413: LD_VAR 0 4
59417: PUSH
59418: LD_VAR 0 8
59422: NOT
59423: AND
59424: IFFALSE 59493
// begin sort := SortBySkill ( tmp , 4 ) ;
59426: LD_ADDR_VAR 0 9
59430: PUSH
59431: LD_VAR 0 4
59435: PPUSH
59436: LD_INT 4
59438: PPUSH
59439: CALL 49538 0 2
59443: ST_TO_ADDR
// if sort then
59444: LD_VAR 0 9
59448: IFFALSE 59464
// p := sort [ 1 ] ;
59450: LD_ADDR_VAR 0 11
59454: PUSH
59455: LD_VAR 0 9
59459: PUSH
59460: LD_INT 1
59462: ARRAY
59463: ST_TO_ADDR
// if p then
59464: LD_VAR 0 11
59468: IFFALSE 59493
// result := Replace ( result , 4 , p ) ;
59470: LD_ADDR_VAR 0 2
59474: PUSH
59475: LD_VAR 0 2
59479: PPUSH
59480: LD_INT 4
59482: PPUSH
59483: LD_VAR 0 11
59487: PPUSH
59488: CALL_OW 1
59492: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59493: LD_ADDR_VAR 0 4
59497: PUSH
59498: LD_VAR 0 4
59502: PUSH
59503: LD_VAR 0 7
59507: DIFF
59508: ST_TO_ADDR
// if tmp and mech < 6 then
59509: LD_VAR 0 4
59513: PUSH
59514: LD_VAR 0 7
59518: PUSH
59519: LD_INT 6
59521: LESS
59522: AND
59523: IFFALSE 59711
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59525: LD_ADDR_VAR 0 9
59529: PUSH
59530: LD_VAR 0 4
59534: PUSH
59535: LD_VAR 0 8
59539: PUSH
59540: LD_VAR 0 7
59544: UNION
59545: DIFF
59546: PPUSH
59547: LD_INT 3
59549: PPUSH
59550: CALL 49538 0 2
59554: ST_TO_ADDR
// p := [ ] ;
59555: LD_ADDR_VAR 0 11
59559: PUSH
59560: EMPTY
59561: ST_TO_ADDR
// if sort then
59562: LD_VAR 0 9
59566: IFFALSE 59682
// for i = 1 to 6 - mech do
59568: LD_ADDR_VAR 0 3
59572: PUSH
59573: DOUBLE
59574: LD_INT 1
59576: DEC
59577: ST_TO_ADDR
59578: LD_INT 6
59580: PUSH
59581: LD_VAR 0 7
59585: MINUS
59586: PUSH
59587: FOR_TO
59588: IFFALSE 59680
// begin if i = sort then
59590: LD_VAR 0 3
59594: PUSH
59595: LD_VAR 0 9
59599: EQUAL
59600: IFFALSE 59604
// break ;
59602: GO 59680
// if GetClass ( i ) = 3 then
59604: LD_VAR 0 3
59608: PPUSH
59609: CALL_OW 257
59613: PUSH
59614: LD_INT 3
59616: EQUAL
59617: IFFALSE 59621
// continue ;
59619: GO 59587
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59621: LD_ADDR_VAR 0 11
59625: PUSH
59626: LD_VAR 0 11
59630: PPUSH
59631: LD_VAR 0 11
59635: PUSH
59636: LD_INT 1
59638: PLUS
59639: PPUSH
59640: LD_VAR 0 9
59644: PUSH
59645: LD_VAR 0 3
59649: ARRAY
59650: PPUSH
59651: CALL_OW 2
59655: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59656: LD_ADDR_VAR 0 4
59660: PUSH
59661: LD_VAR 0 4
59665: PUSH
59666: LD_VAR 0 9
59670: PUSH
59671: LD_VAR 0 3
59675: ARRAY
59676: DIFF
59677: ST_TO_ADDR
// end ;
59678: GO 59587
59680: POP
59681: POP
// if p then
59682: LD_VAR 0 11
59686: IFFALSE 59711
// result := Replace ( result , 3 , p ) ;
59688: LD_ADDR_VAR 0 2
59692: PUSH
59693: LD_VAR 0 2
59697: PPUSH
59698: LD_INT 3
59700: PPUSH
59701: LD_VAR 0 11
59705: PPUSH
59706: CALL_OW 1
59710: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59711: LD_ADDR_VAR 0 4
59715: PUSH
59716: LD_VAR 0 4
59720: PUSH
59721: LD_VAR 0 6
59725: DIFF
59726: ST_TO_ADDR
// if tmp and eng < 6 then
59727: LD_VAR 0 4
59731: PUSH
59732: LD_VAR 0 6
59736: PUSH
59737: LD_INT 6
59739: LESS
59740: AND
59741: IFFALSE 59935
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59743: LD_ADDR_VAR 0 9
59747: PUSH
59748: LD_VAR 0 4
59752: PUSH
59753: LD_VAR 0 8
59757: PUSH
59758: LD_VAR 0 7
59762: UNION
59763: PUSH
59764: LD_VAR 0 6
59768: UNION
59769: DIFF
59770: PPUSH
59771: LD_INT 2
59773: PPUSH
59774: CALL 49538 0 2
59778: ST_TO_ADDR
// p := [ ] ;
59779: LD_ADDR_VAR 0 11
59783: PUSH
59784: EMPTY
59785: ST_TO_ADDR
// if sort then
59786: LD_VAR 0 9
59790: IFFALSE 59906
// for i = 1 to 6 - eng do
59792: LD_ADDR_VAR 0 3
59796: PUSH
59797: DOUBLE
59798: LD_INT 1
59800: DEC
59801: ST_TO_ADDR
59802: LD_INT 6
59804: PUSH
59805: LD_VAR 0 6
59809: MINUS
59810: PUSH
59811: FOR_TO
59812: IFFALSE 59904
// begin if i = sort then
59814: LD_VAR 0 3
59818: PUSH
59819: LD_VAR 0 9
59823: EQUAL
59824: IFFALSE 59828
// break ;
59826: GO 59904
// if GetClass ( i ) = 2 then
59828: LD_VAR 0 3
59832: PPUSH
59833: CALL_OW 257
59837: PUSH
59838: LD_INT 2
59840: EQUAL
59841: IFFALSE 59845
// continue ;
59843: GO 59811
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59845: LD_ADDR_VAR 0 11
59849: PUSH
59850: LD_VAR 0 11
59854: PPUSH
59855: LD_VAR 0 11
59859: PUSH
59860: LD_INT 1
59862: PLUS
59863: PPUSH
59864: LD_VAR 0 9
59868: PUSH
59869: LD_VAR 0 3
59873: ARRAY
59874: PPUSH
59875: CALL_OW 2
59879: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59880: LD_ADDR_VAR 0 4
59884: PUSH
59885: LD_VAR 0 4
59889: PUSH
59890: LD_VAR 0 9
59894: PUSH
59895: LD_VAR 0 3
59899: ARRAY
59900: DIFF
59901: ST_TO_ADDR
// end ;
59902: GO 59811
59904: POP
59905: POP
// if p then
59906: LD_VAR 0 11
59910: IFFALSE 59935
// result := Replace ( result , 2 , p ) ;
59912: LD_ADDR_VAR 0 2
59916: PUSH
59917: LD_VAR 0 2
59921: PPUSH
59922: LD_INT 2
59924: PPUSH
59925: LD_VAR 0 11
59929: PPUSH
59930: CALL_OW 1
59934: ST_TO_ADDR
// end ; exit ;
59935: GO 60659
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59937: LD_EXP 86
59941: PUSH
59942: LD_EXP 85
59946: PUSH
59947: LD_VAR 0 1
59951: ARRAY
59952: ARRAY
59953: NOT
59954: PUSH
59955: LD_EXP 59
59959: PUSH
59960: LD_VAR 0 1
59964: ARRAY
59965: PPUSH
59966: LD_INT 30
59968: PUSH
59969: LD_INT 3
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: PPUSH
59976: CALL_OW 72
59980: AND
59981: PUSH
59982: LD_EXP 64
59986: PUSH
59987: LD_VAR 0 1
59991: ARRAY
59992: NOT
59993: AND
59994: IFFALSE 60659
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59996: LD_ADDR_EXP 101
60000: PUSH
60001: LD_EXP 101
60005: PPUSH
60006: LD_VAR 0 1
60010: PPUSH
60011: LD_INT 6
60013: PPUSH
60014: CALL_OW 1
60018: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60019: LD_ADDR_VAR 0 2
60023: PUSH
60024: LD_INT 0
60026: PUSH
60027: LD_INT 0
60029: PUSH
60030: LD_INT 0
60032: PUSH
60033: LD_INT 0
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: ST_TO_ADDR
// if sci >= 1 then
60042: LD_VAR 0 8
60046: PUSH
60047: LD_INT 1
60049: GREATEREQUAL
60050: IFFALSE 60072
// tmp := tmp diff sci [ 1 ] ;
60052: LD_ADDR_VAR 0 4
60056: PUSH
60057: LD_VAR 0 4
60061: PUSH
60062: LD_VAR 0 8
60066: PUSH
60067: LD_INT 1
60069: ARRAY
60070: DIFF
60071: ST_TO_ADDR
// if tmp and not sci then
60072: LD_VAR 0 4
60076: PUSH
60077: LD_VAR 0 8
60081: NOT
60082: AND
60083: IFFALSE 60152
// begin sort := SortBySkill ( tmp , 4 ) ;
60085: LD_ADDR_VAR 0 9
60089: PUSH
60090: LD_VAR 0 4
60094: PPUSH
60095: LD_INT 4
60097: PPUSH
60098: CALL 49538 0 2
60102: ST_TO_ADDR
// if sort then
60103: LD_VAR 0 9
60107: IFFALSE 60123
// p := sort [ 1 ] ;
60109: LD_ADDR_VAR 0 11
60113: PUSH
60114: LD_VAR 0 9
60118: PUSH
60119: LD_INT 1
60121: ARRAY
60122: ST_TO_ADDR
// if p then
60123: LD_VAR 0 11
60127: IFFALSE 60152
// result := Replace ( result , 4 , p ) ;
60129: LD_ADDR_VAR 0 2
60133: PUSH
60134: LD_VAR 0 2
60138: PPUSH
60139: LD_INT 4
60141: PPUSH
60142: LD_VAR 0 11
60146: PPUSH
60147: CALL_OW 1
60151: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60152: LD_ADDR_VAR 0 4
60156: PUSH
60157: LD_VAR 0 4
60161: PUSH
60162: LD_VAR 0 7
60166: DIFF
60167: ST_TO_ADDR
// if tmp and mech < 6 then
60168: LD_VAR 0 4
60172: PUSH
60173: LD_VAR 0 7
60177: PUSH
60178: LD_INT 6
60180: LESS
60181: AND
60182: IFFALSE 60364
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60184: LD_ADDR_VAR 0 9
60188: PUSH
60189: LD_VAR 0 4
60193: PUSH
60194: LD_VAR 0 7
60198: DIFF
60199: PPUSH
60200: LD_INT 3
60202: PPUSH
60203: CALL 49538 0 2
60207: ST_TO_ADDR
// p := [ ] ;
60208: LD_ADDR_VAR 0 11
60212: PUSH
60213: EMPTY
60214: ST_TO_ADDR
// if sort then
60215: LD_VAR 0 9
60219: IFFALSE 60335
// for i = 1 to 6 - mech do
60221: LD_ADDR_VAR 0 3
60225: PUSH
60226: DOUBLE
60227: LD_INT 1
60229: DEC
60230: ST_TO_ADDR
60231: LD_INT 6
60233: PUSH
60234: LD_VAR 0 7
60238: MINUS
60239: PUSH
60240: FOR_TO
60241: IFFALSE 60333
// begin if i = sort then
60243: LD_VAR 0 3
60247: PUSH
60248: LD_VAR 0 9
60252: EQUAL
60253: IFFALSE 60257
// break ;
60255: GO 60333
// if GetClass ( i ) = 3 then
60257: LD_VAR 0 3
60261: PPUSH
60262: CALL_OW 257
60266: PUSH
60267: LD_INT 3
60269: EQUAL
60270: IFFALSE 60274
// continue ;
60272: GO 60240
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60274: LD_ADDR_VAR 0 11
60278: PUSH
60279: LD_VAR 0 11
60283: PPUSH
60284: LD_VAR 0 11
60288: PUSH
60289: LD_INT 1
60291: PLUS
60292: PPUSH
60293: LD_VAR 0 9
60297: PUSH
60298: LD_VAR 0 3
60302: ARRAY
60303: PPUSH
60304: CALL_OW 2
60308: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60309: LD_ADDR_VAR 0 4
60313: PUSH
60314: LD_VAR 0 4
60318: PUSH
60319: LD_VAR 0 9
60323: PUSH
60324: LD_VAR 0 3
60328: ARRAY
60329: DIFF
60330: ST_TO_ADDR
// end ;
60331: GO 60240
60333: POP
60334: POP
// if p then
60335: LD_VAR 0 11
60339: IFFALSE 60364
// result := Replace ( result , 3 , p ) ;
60341: LD_ADDR_VAR 0 2
60345: PUSH
60346: LD_VAR 0 2
60350: PPUSH
60351: LD_INT 3
60353: PPUSH
60354: LD_VAR 0 11
60358: PPUSH
60359: CALL_OW 1
60363: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60364: LD_ADDR_VAR 0 4
60368: PUSH
60369: LD_VAR 0 4
60373: PUSH
60374: LD_VAR 0 6
60378: DIFF
60379: ST_TO_ADDR
// if tmp and eng < 4 then
60380: LD_VAR 0 4
60384: PUSH
60385: LD_VAR 0 6
60389: PUSH
60390: LD_INT 4
60392: LESS
60393: AND
60394: IFFALSE 60584
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60396: LD_ADDR_VAR 0 9
60400: PUSH
60401: LD_VAR 0 4
60405: PUSH
60406: LD_VAR 0 7
60410: PUSH
60411: LD_VAR 0 6
60415: UNION
60416: DIFF
60417: PPUSH
60418: LD_INT 2
60420: PPUSH
60421: CALL 49538 0 2
60425: ST_TO_ADDR
// p := [ ] ;
60426: LD_ADDR_VAR 0 11
60430: PUSH
60431: EMPTY
60432: ST_TO_ADDR
// if sort then
60433: LD_VAR 0 9
60437: IFFALSE 60553
// for i = 1 to 4 - eng do
60439: LD_ADDR_VAR 0 3
60443: PUSH
60444: DOUBLE
60445: LD_INT 1
60447: DEC
60448: ST_TO_ADDR
60449: LD_INT 4
60451: PUSH
60452: LD_VAR 0 6
60456: MINUS
60457: PUSH
60458: FOR_TO
60459: IFFALSE 60551
// begin if i = sort then
60461: LD_VAR 0 3
60465: PUSH
60466: LD_VAR 0 9
60470: EQUAL
60471: IFFALSE 60475
// break ;
60473: GO 60551
// if GetClass ( i ) = 2 then
60475: LD_VAR 0 3
60479: PPUSH
60480: CALL_OW 257
60484: PUSH
60485: LD_INT 2
60487: EQUAL
60488: IFFALSE 60492
// continue ;
60490: GO 60458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60492: LD_ADDR_VAR 0 11
60496: PUSH
60497: LD_VAR 0 11
60501: PPUSH
60502: LD_VAR 0 11
60506: PUSH
60507: LD_INT 1
60509: PLUS
60510: PPUSH
60511: LD_VAR 0 9
60515: PUSH
60516: LD_VAR 0 3
60520: ARRAY
60521: PPUSH
60522: CALL_OW 2
60526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60527: LD_ADDR_VAR 0 4
60531: PUSH
60532: LD_VAR 0 4
60536: PUSH
60537: LD_VAR 0 9
60541: PUSH
60542: LD_VAR 0 3
60546: ARRAY
60547: DIFF
60548: ST_TO_ADDR
// end ;
60549: GO 60458
60551: POP
60552: POP
// if p then
60553: LD_VAR 0 11
60557: IFFALSE 60582
// result := Replace ( result , 2 , p ) ;
60559: LD_ADDR_VAR 0 2
60563: PUSH
60564: LD_VAR 0 2
60568: PPUSH
60569: LD_INT 2
60571: PPUSH
60572: LD_VAR 0 11
60576: PPUSH
60577: CALL_OW 1
60581: ST_TO_ADDR
// end else
60582: GO 60628
// for i = eng downto 5 do
60584: LD_ADDR_VAR 0 3
60588: PUSH
60589: DOUBLE
60590: LD_VAR 0 6
60594: INC
60595: ST_TO_ADDR
60596: LD_INT 5
60598: PUSH
60599: FOR_DOWNTO
60600: IFFALSE 60626
// tmp := tmp union eng [ i ] ;
60602: LD_ADDR_VAR 0 4
60606: PUSH
60607: LD_VAR 0 4
60611: PUSH
60612: LD_VAR 0 6
60616: PUSH
60617: LD_VAR 0 3
60621: ARRAY
60622: UNION
60623: ST_TO_ADDR
60624: GO 60599
60626: POP
60627: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60628: LD_ADDR_VAR 0 2
60632: PUSH
60633: LD_VAR 0 2
60637: PPUSH
60638: LD_INT 1
60640: PPUSH
60641: LD_VAR 0 4
60645: PUSH
60646: LD_VAR 0 5
60650: DIFF
60651: PPUSH
60652: CALL_OW 1
60656: ST_TO_ADDR
// exit ;
60657: GO 60659
// end ; end ;
60659: LD_VAR 0 2
60663: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60664: LD_INT 0
60666: PPUSH
60667: PPUSH
60668: PPUSH
// if not mc_bases then
60669: LD_EXP 59
60673: NOT
60674: IFFALSE 60678
// exit ;
60676: GO 60784
// for i = 1 to mc_bases do
60678: LD_ADDR_VAR 0 2
60682: PUSH
60683: DOUBLE
60684: LD_INT 1
60686: DEC
60687: ST_TO_ADDR
60688: LD_EXP 59
60692: PUSH
60693: FOR_TO
60694: IFFALSE 60775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60696: LD_ADDR_VAR 0 3
60700: PUSH
60701: LD_EXP 59
60705: PUSH
60706: LD_VAR 0 2
60710: ARRAY
60711: PPUSH
60712: LD_INT 21
60714: PUSH
60715: LD_INT 3
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: PUSH
60722: LD_INT 3
60724: PUSH
60725: LD_INT 24
60727: PUSH
60728: LD_INT 1000
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: EMPTY
60740: LIST
60741: LIST
60742: PPUSH
60743: CALL_OW 72
60747: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60748: LD_ADDR_EXP 60
60752: PUSH
60753: LD_EXP 60
60757: PPUSH
60758: LD_VAR 0 2
60762: PPUSH
60763: LD_VAR 0 3
60767: PPUSH
60768: CALL_OW 1
60772: ST_TO_ADDR
// end ;
60773: GO 60693
60775: POP
60776: POP
// RaiseSailEvent ( 101 ) ;
60777: LD_INT 101
60779: PPUSH
60780: CALL_OW 427
// end ;
60784: LD_VAR 0 1
60788: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60789: LD_INT 0
60791: PPUSH
60792: PPUSH
60793: PPUSH
60794: PPUSH
60795: PPUSH
60796: PPUSH
60797: PPUSH
// if not mc_bases then
60798: LD_EXP 59
60802: NOT
60803: IFFALSE 60807
// exit ;
60805: GO 61369
// for i = 1 to mc_bases do
60807: LD_ADDR_VAR 0 2
60811: PUSH
60812: DOUBLE
60813: LD_INT 1
60815: DEC
60816: ST_TO_ADDR
60817: LD_EXP 59
60821: PUSH
60822: FOR_TO
60823: IFFALSE 61360
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60825: LD_ADDR_VAR 0 5
60829: PUSH
60830: LD_EXP 59
60834: PUSH
60835: LD_VAR 0 2
60839: ARRAY
60840: PUSH
60841: LD_EXP 88
60845: PUSH
60846: LD_VAR 0 2
60850: ARRAY
60851: UNION
60852: PPUSH
60853: LD_INT 21
60855: PUSH
60856: LD_INT 1
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PUSH
60863: LD_INT 1
60865: PUSH
60866: LD_INT 3
60868: PUSH
60869: LD_INT 54
60871: PUSH
60872: EMPTY
60873: LIST
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: PUSH
60879: LD_INT 3
60881: PUSH
60882: LD_INT 24
60884: PUSH
60885: LD_INT 1000
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: EMPTY
60897: LIST
60898: LIST
60899: LIST
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PPUSH
60905: CALL_OW 72
60909: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60910: LD_ADDR_VAR 0 6
60914: PUSH
60915: LD_EXP 59
60919: PUSH
60920: LD_VAR 0 2
60924: ARRAY
60925: PPUSH
60926: LD_INT 21
60928: PUSH
60929: LD_INT 1
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PUSH
60936: LD_INT 1
60938: PUSH
60939: LD_INT 3
60941: PUSH
60942: LD_INT 54
60944: PUSH
60945: EMPTY
60946: LIST
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 3
60954: PUSH
60955: LD_INT 24
60957: PUSH
60958: LD_INT 250
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: PUSH
60965: EMPTY
60966: LIST
60967: LIST
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: LIST
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PPUSH
60978: CALL_OW 72
60982: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60983: LD_ADDR_VAR 0 7
60987: PUSH
60988: LD_VAR 0 5
60992: PUSH
60993: LD_VAR 0 6
60997: DIFF
60998: ST_TO_ADDR
// if not need_heal_1 then
60999: LD_VAR 0 6
61003: NOT
61004: IFFALSE 61037
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61006: LD_ADDR_EXP 62
61010: PUSH
61011: LD_EXP 62
61015: PPUSH
61016: LD_VAR 0 2
61020: PUSH
61021: LD_INT 1
61023: PUSH
61024: EMPTY
61025: LIST
61026: LIST
61027: PPUSH
61028: EMPTY
61029: PPUSH
61030: CALL 19686 0 3
61034: ST_TO_ADDR
61035: GO 61107
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61037: LD_ADDR_EXP 62
61041: PUSH
61042: LD_EXP 62
61046: PPUSH
61047: LD_VAR 0 2
61051: PUSH
61052: LD_INT 1
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PPUSH
61059: LD_EXP 62
61063: PUSH
61064: LD_VAR 0 2
61068: ARRAY
61069: PUSH
61070: LD_INT 1
61072: ARRAY
61073: PPUSH
61074: LD_INT 3
61076: PUSH
61077: LD_INT 24
61079: PUSH
61080: LD_INT 1000
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PPUSH
61091: CALL_OW 72
61095: PUSH
61096: LD_VAR 0 6
61100: UNION
61101: PPUSH
61102: CALL 19686 0 3
61106: ST_TO_ADDR
// if not need_heal_2 then
61107: LD_VAR 0 7
61111: NOT
61112: IFFALSE 61145
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61114: LD_ADDR_EXP 62
61118: PUSH
61119: LD_EXP 62
61123: PPUSH
61124: LD_VAR 0 2
61128: PUSH
61129: LD_INT 2
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PPUSH
61136: EMPTY
61137: PPUSH
61138: CALL 19686 0 3
61142: ST_TO_ADDR
61143: GO 61177
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61145: LD_ADDR_EXP 62
61149: PUSH
61150: LD_EXP 62
61154: PPUSH
61155: LD_VAR 0 2
61159: PUSH
61160: LD_INT 2
61162: PUSH
61163: EMPTY
61164: LIST
61165: LIST
61166: PPUSH
61167: LD_VAR 0 7
61171: PPUSH
61172: CALL 19686 0 3
61176: ST_TO_ADDR
// if need_heal_2 then
61177: LD_VAR 0 7
61181: IFFALSE 61342
// for j in need_heal_2 do
61183: LD_ADDR_VAR 0 3
61187: PUSH
61188: LD_VAR 0 7
61192: PUSH
61193: FOR_IN
61194: IFFALSE 61340
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61196: LD_ADDR_VAR 0 5
61200: PUSH
61201: LD_EXP 59
61205: PUSH
61206: LD_VAR 0 2
61210: ARRAY
61211: PPUSH
61212: LD_INT 2
61214: PUSH
61215: LD_INT 30
61217: PUSH
61218: LD_INT 6
61220: PUSH
61221: EMPTY
61222: LIST
61223: LIST
61224: PUSH
61225: LD_INT 30
61227: PUSH
61228: LD_INT 7
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: PUSH
61235: LD_INT 30
61237: PUSH
61238: LD_INT 8
61240: PUSH
61241: EMPTY
61242: LIST
61243: LIST
61244: PUSH
61245: LD_INT 30
61247: PUSH
61248: LD_INT 0
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: LD_INT 30
61257: PUSH
61258: LD_INT 1
61260: PUSH
61261: EMPTY
61262: LIST
61263: LIST
61264: PUSH
61265: EMPTY
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: LIST
61272: PPUSH
61273: CALL_OW 72
61277: ST_TO_ADDR
// if tmp then
61278: LD_VAR 0 5
61282: IFFALSE 61338
// begin k := NearestUnitToUnit ( tmp , j ) ;
61284: LD_ADDR_VAR 0 4
61288: PUSH
61289: LD_VAR 0 5
61293: PPUSH
61294: LD_VAR 0 3
61298: PPUSH
61299: CALL_OW 74
61303: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61304: LD_VAR 0 3
61308: PPUSH
61309: LD_VAR 0 4
61313: PPUSH
61314: CALL_OW 296
61318: PUSH
61319: LD_INT 5
61321: GREATER
61322: IFFALSE 61338
// ComMoveToNearbyEntrance ( j , k ) ;
61324: LD_VAR 0 3
61328: PPUSH
61329: LD_VAR 0 4
61333: PPUSH
61334: CALL 51899 0 2
// end ; end ;
61338: GO 61193
61340: POP
61341: POP
// if not need_heal_1 and not need_heal_2 then
61342: LD_VAR 0 6
61346: NOT
61347: PUSH
61348: LD_VAR 0 7
61352: NOT
61353: AND
61354: IFFALSE 61358
// continue ;
61356: GO 60822
// end ;
61358: GO 60822
61360: POP
61361: POP
// RaiseSailEvent ( 102 ) ;
61362: LD_INT 102
61364: PPUSH
61365: CALL_OW 427
// end ;
61369: LD_VAR 0 1
61373: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61374: LD_INT 0
61376: PPUSH
61377: PPUSH
61378: PPUSH
61379: PPUSH
61380: PPUSH
61381: PPUSH
61382: PPUSH
61383: PPUSH
// if not mc_bases then
61384: LD_EXP 59
61388: NOT
61389: IFFALSE 61393
// exit ;
61391: GO 62254
// for i = 1 to mc_bases do
61393: LD_ADDR_VAR 0 2
61397: PUSH
61398: DOUBLE
61399: LD_INT 1
61401: DEC
61402: ST_TO_ADDR
61403: LD_EXP 59
61407: PUSH
61408: FOR_TO
61409: IFFALSE 62252
// begin if not mc_building_need_repair [ i ] then
61411: LD_EXP 60
61415: PUSH
61416: LD_VAR 0 2
61420: ARRAY
61421: NOT
61422: IFFALSE 61609
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61424: LD_ADDR_VAR 0 6
61428: PUSH
61429: LD_EXP 78
61433: PUSH
61434: LD_VAR 0 2
61438: ARRAY
61439: PPUSH
61440: LD_INT 3
61442: PUSH
61443: LD_INT 24
61445: PUSH
61446: LD_INT 1000
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: EMPTY
61454: LIST
61455: LIST
61456: PUSH
61457: LD_INT 2
61459: PUSH
61460: LD_INT 34
61462: PUSH
61463: LD_INT 13
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: PUSH
61470: LD_INT 34
61472: PUSH
61473: LD_INT 52
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 34
61482: PUSH
61483: LD_EXP 109
61487: PUSH
61488: EMPTY
61489: LIST
61490: LIST
61491: PUSH
61492: EMPTY
61493: LIST
61494: LIST
61495: LIST
61496: LIST
61497: PUSH
61498: EMPTY
61499: LIST
61500: LIST
61501: PPUSH
61502: CALL_OW 72
61506: ST_TO_ADDR
// if cranes then
61507: LD_VAR 0 6
61511: IFFALSE 61573
// for j in cranes do
61513: LD_ADDR_VAR 0 3
61517: PUSH
61518: LD_VAR 0 6
61522: PUSH
61523: FOR_IN
61524: IFFALSE 61571
// if not IsInArea ( j , mc_parking [ i ] ) then
61526: LD_VAR 0 3
61530: PPUSH
61531: LD_EXP 83
61535: PUSH
61536: LD_VAR 0 2
61540: ARRAY
61541: PPUSH
61542: CALL_OW 308
61546: NOT
61547: IFFALSE 61569
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61549: LD_VAR 0 3
61553: PPUSH
61554: LD_EXP 83
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: PPUSH
61565: CALL_OW 113
61569: GO 61523
61571: POP
61572: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61573: LD_ADDR_EXP 61
61577: PUSH
61578: LD_EXP 61
61582: PPUSH
61583: LD_VAR 0 2
61587: PPUSH
61588: EMPTY
61589: PPUSH
61590: CALL_OW 1
61594: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61595: LD_VAR 0 2
61599: PPUSH
61600: LD_INT 101
61602: PPUSH
61603: CALL 56497 0 2
// continue ;
61607: GO 61408
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61609: LD_ADDR_EXP 65
61613: PUSH
61614: LD_EXP 65
61618: PPUSH
61619: LD_VAR 0 2
61623: PPUSH
61624: EMPTY
61625: PPUSH
61626: CALL_OW 1
61630: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61631: LD_VAR 0 2
61635: PPUSH
61636: LD_INT 103
61638: PPUSH
61639: CALL 56497 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61643: LD_ADDR_VAR 0 5
61647: PUSH
61648: LD_EXP 59
61652: PUSH
61653: LD_VAR 0 2
61657: ARRAY
61658: PUSH
61659: LD_EXP 88
61663: PUSH
61664: LD_VAR 0 2
61668: ARRAY
61669: UNION
61670: PPUSH
61671: LD_INT 2
61673: PUSH
61674: LD_INT 25
61676: PUSH
61677: LD_INT 2
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: LD_INT 25
61686: PUSH
61687: LD_INT 16
61689: PUSH
61690: EMPTY
61691: LIST
61692: LIST
61693: PUSH
61694: EMPTY
61695: LIST
61696: LIST
61697: LIST
61698: PUSH
61699: EMPTY
61700: LIST
61701: PPUSH
61702: CALL_OW 72
61706: PUSH
61707: LD_EXP 62
61711: PUSH
61712: LD_VAR 0 2
61716: ARRAY
61717: PUSH
61718: LD_INT 1
61720: ARRAY
61721: PUSH
61722: LD_EXP 62
61726: PUSH
61727: LD_VAR 0 2
61731: ARRAY
61732: PUSH
61733: LD_INT 2
61735: ARRAY
61736: UNION
61737: DIFF
61738: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61739: LD_ADDR_VAR 0 6
61743: PUSH
61744: LD_EXP 78
61748: PUSH
61749: LD_VAR 0 2
61753: ARRAY
61754: PPUSH
61755: LD_INT 2
61757: PUSH
61758: LD_INT 34
61760: PUSH
61761: LD_INT 13
61763: PUSH
61764: EMPTY
61765: LIST
61766: LIST
61767: PUSH
61768: LD_INT 34
61770: PUSH
61771: LD_INT 52
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 34
61780: PUSH
61781: LD_EXP 109
61785: PUSH
61786: EMPTY
61787: LIST
61788: LIST
61789: PUSH
61790: EMPTY
61791: LIST
61792: LIST
61793: LIST
61794: LIST
61795: PPUSH
61796: CALL_OW 72
61800: ST_TO_ADDR
// if cranes then
61801: LD_VAR 0 6
61805: IFFALSE 61941
// begin for j in cranes do
61807: LD_ADDR_VAR 0 3
61811: PUSH
61812: LD_VAR 0 6
61816: PUSH
61817: FOR_IN
61818: IFFALSE 61939
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61820: LD_VAR 0 3
61824: PPUSH
61825: CALL_OW 256
61829: PUSH
61830: LD_INT 1000
61832: EQUAL
61833: PUSH
61834: LD_VAR 0 3
61838: PPUSH
61839: CALL_OW 314
61843: NOT
61844: AND
61845: IFFALSE 61879
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61847: LD_VAR 0 3
61851: PPUSH
61852: LD_EXP 60
61856: PUSH
61857: LD_VAR 0 2
61861: ARRAY
61862: PPUSH
61863: LD_VAR 0 3
61867: PPUSH
61868: CALL_OW 74
61872: PPUSH
61873: CALL_OW 130
61877: GO 61937
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61879: LD_VAR 0 3
61883: PPUSH
61884: CALL_OW 256
61888: PUSH
61889: LD_INT 500
61891: LESS
61892: PUSH
61893: LD_VAR 0 3
61897: PPUSH
61898: LD_EXP 83
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: PPUSH
61909: CALL_OW 308
61913: NOT
61914: AND
61915: IFFALSE 61937
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61917: LD_VAR 0 3
61921: PPUSH
61922: LD_EXP 83
61926: PUSH
61927: LD_VAR 0 2
61931: ARRAY
61932: PPUSH
61933: CALL_OW 113
// end ;
61937: GO 61817
61939: POP
61940: POP
// end ; if tmp > 3 then
61941: LD_VAR 0 5
61945: PUSH
61946: LD_INT 3
61948: GREATER
61949: IFFALSE 61969
// tmp := ShrinkArray ( tmp , 4 ) ;
61951: LD_ADDR_VAR 0 5
61955: PUSH
61956: LD_VAR 0 5
61960: PPUSH
61961: LD_INT 4
61963: PPUSH
61964: CALL 51347 0 2
61968: ST_TO_ADDR
// if not tmp then
61969: LD_VAR 0 5
61973: NOT
61974: IFFALSE 61978
// continue ;
61976: GO 61408
// for j in tmp do
61978: LD_ADDR_VAR 0 3
61982: PUSH
61983: LD_VAR 0 5
61987: PUSH
61988: FOR_IN
61989: IFFALSE 62248
// begin if IsInUnit ( j ) then
61991: LD_VAR 0 3
61995: PPUSH
61996: CALL_OW 310
62000: IFFALSE 62011
// ComExitBuilding ( j ) ;
62002: LD_VAR 0 3
62006: PPUSH
62007: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62011: LD_VAR 0 3
62015: PUSH
62016: LD_EXP 61
62020: PUSH
62021: LD_VAR 0 2
62025: ARRAY
62026: IN
62027: NOT
62028: IFFALSE 62086
// begin SetTag ( j , 101 ) ;
62030: LD_VAR 0 3
62034: PPUSH
62035: LD_INT 101
62037: PPUSH
62038: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62042: LD_ADDR_EXP 61
62046: PUSH
62047: LD_EXP 61
62051: PPUSH
62052: LD_VAR 0 2
62056: PUSH
62057: LD_EXP 61
62061: PUSH
62062: LD_VAR 0 2
62066: ARRAY
62067: PUSH
62068: LD_INT 1
62070: PLUS
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: PPUSH
62076: LD_VAR 0 3
62080: PPUSH
62081: CALL 19686 0 3
62085: ST_TO_ADDR
// end ; wait ( 1 ) ;
62086: LD_INT 1
62088: PPUSH
62089: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62093: LD_ADDR_VAR 0 7
62097: PUSH
62098: LD_EXP 60
62102: PUSH
62103: LD_VAR 0 2
62107: ARRAY
62108: ST_TO_ADDR
// if mc_scan [ i ] then
62109: LD_EXP 82
62113: PUSH
62114: LD_VAR 0 2
62118: ARRAY
62119: IFFALSE 62181
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62121: LD_ADDR_VAR 0 7
62125: PUSH
62126: LD_EXP 60
62130: PUSH
62131: LD_VAR 0 2
62135: ARRAY
62136: PPUSH
62137: LD_INT 3
62139: PUSH
62140: LD_INT 30
62142: PUSH
62143: LD_INT 32
62145: PUSH
62146: EMPTY
62147: LIST
62148: LIST
62149: PUSH
62150: LD_INT 30
62152: PUSH
62153: LD_INT 33
62155: PUSH
62156: EMPTY
62157: LIST
62158: LIST
62159: PUSH
62160: LD_INT 30
62162: PUSH
62163: LD_INT 31
62165: PUSH
62166: EMPTY
62167: LIST
62168: LIST
62169: PUSH
62170: EMPTY
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: PPUSH
62176: CALL_OW 72
62180: ST_TO_ADDR
// if not to_repair_tmp then
62181: LD_VAR 0 7
62185: NOT
62186: IFFALSE 62190
// continue ;
62188: GO 61988
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62190: LD_ADDR_VAR 0 8
62194: PUSH
62195: LD_VAR 0 7
62199: PPUSH
62200: LD_VAR 0 3
62204: PPUSH
62205: CALL_OW 74
62209: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62210: LD_VAR 0 8
62214: PPUSH
62215: LD_INT 16
62217: PPUSH
62218: CALL 22279 0 2
62222: PUSH
62223: LD_INT 4
62225: ARRAY
62226: PUSH
62227: LD_INT 10
62229: LESS
62230: IFFALSE 62246
// ComRepairBuilding ( j , to_repair ) ;
62232: LD_VAR 0 3
62236: PPUSH
62237: LD_VAR 0 8
62241: PPUSH
62242: CALL_OW 130
// end ;
62246: GO 61988
62248: POP
62249: POP
// end ;
62250: GO 61408
62252: POP
62253: POP
// end ;
62254: LD_VAR 0 1
62258: RET
// export function MC_Heal ; var i , j , tmp ; begin
62259: LD_INT 0
62261: PPUSH
62262: PPUSH
62263: PPUSH
62264: PPUSH
// if not mc_bases then
62265: LD_EXP 59
62269: NOT
62270: IFFALSE 62274
// exit ;
62272: GO 62676
// for i = 1 to mc_bases do
62274: LD_ADDR_VAR 0 2
62278: PUSH
62279: DOUBLE
62280: LD_INT 1
62282: DEC
62283: ST_TO_ADDR
62284: LD_EXP 59
62288: PUSH
62289: FOR_TO
62290: IFFALSE 62674
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62292: LD_EXP 62
62296: PUSH
62297: LD_VAR 0 2
62301: ARRAY
62302: PUSH
62303: LD_INT 1
62305: ARRAY
62306: NOT
62307: PUSH
62308: LD_EXP 62
62312: PUSH
62313: LD_VAR 0 2
62317: ARRAY
62318: PUSH
62319: LD_INT 2
62321: ARRAY
62322: NOT
62323: AND
62324: IFFALSE 62362
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62326: LD_ADDR_EXP 63
62330: PUSH
62331: LD_EXP 63
62335: PPUSH
62336: LD_VAR 0 2
62340: PPUSH
62341: EMPTY
62342: PPUSH
62343: CALL_OW 1
62347: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62348: LD_VAR 0 2
62352: PPUSH
62353: LD_INT 102
62355: PPUSH
62356: CALL 56497 0 2
// continue ;
62360: GO 62289
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62362: LD_ADDR_VAR 0 4
62366: PUSH
62367: LD_EXP 59
62371: PUSH
62372: LD_VAR 0 2
62376: ARRAY
62377: PPUSH
62378: LD_INT 25
62380: PUSH
62381: LD_INT 4
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: PPUSH
62388: CALL_OW 72
62392: ST_TO_ADDR
// if not tmp then
62393: LD_VAR 0 4
62397: NOT
62398: IFFALSE 62402
// continue ;
62400: GO 62289
// if mc_taming [ i ] then
62402: LD_EXP 90
62406: PUSH
62407: LD_VAR 0 2
62411: ARRAY
62412: IFFALSE 62436
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62414: LD_ADDR_EXP 90
62418: PUSH
62419: LD_EXP 90
62423: PPUSH
62424: LD_VAR 0 2
62428: PPUSH
62429: EMPTY
62430: PPUSH
62431: CALL_OW 1
62435: ST_TO_ADDR
// for j in tmp do
62436: LD_ADDR_VAR 0 3
62440: PUSH
62441: LD_VAR 0 4
62445: PUSH
62446: FOR_IN
62447: IFFALSE 62670
// begin if IsInUnit ( j ) then
62449: LD_VAR 0 3
62453: PPUSH
62454: CALL_OW 310
62458: IFFALSE 62469
// ComExitBuilding ( j ) ;
62460: LD_VAR 0 3
62464: PPUSH
62465: CALL_OW 122
// if not j in mc_healers [ i ] then
62469: LD_VAR 0 3
62473: PUSH
62474: LD_EXP 63
62478: PUSH
62479: LD_VAR 0 2
62483: ARRAY
62484: IN
62485: NOT
62486: IFFALSE 62532
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62488: LD_ADDR_EXP 63
62492: PUSH
62493: LD_EXP 63
62497: PPUSH
62498: LD_VAR 0 2
62502: PUSH
62503: LD_EXP 63
62507: PUSH
62508: LD_VAR 0 2
62512: ARRAY
62513: PUSH
62514: LD_INT 1
62516: PLUS
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PPUSH
62522: LD_VAR 0 3
62526: PPUSH
62527: CALL 19686 0 3
62531: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62532: LD_VAR 0 3
62536: PPUSH
62537: CALL_OW 110
62541: PUSH
62542: LD_INT 102
62544: NONEQUAL
62545: IFFALSE 62559
// SetTag ( j , 102 ) ;
62547: LD_VAR 0 3
62551: PPUSH
62552: LD_INT 102
62554: PPUSH
62555: CALL_OW 109
// Wait ( 3 ) ;
62559: LD_INT 3
62561: PPUSH
62562: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62566: LD_EXP 62
62570: PUSH
62571: LD_VAR 0 2
62575: ARRAY
62576: PUSH
62577: LD_INT 1
62579: ARRAY
62580: IFFALSE 62612
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62582: LD_VAR 0 3
62586: PPUSH
62587: LD_EXP 62
62591: PUSH
62592: LD_VAR 0 2
62596: ARRAY
62597: PUSH
62598: LD_INT 1
62600: ARRAY
62601: PUSH
62602: LD_INT 1
62604: ARRAY
62605: PPUSH
62606: CALL_OW 128
62610: GO 62668
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62612: LD_VAR 0 3
62616: PPUSH
62617: CALL_OW 314
62621: NOT
62622: PUSH
62623: LD_EXP 62
62627: PUSH
62628: LD_VAR 0 2
62632: ARRAY
62633: PUSH
62634: LD_INT 2
62636: ARRAY
62637: AND
62638: IFFALSE 62668
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62640: LD_VAR 0 3
62644: PPUSH
62645: LD_EXP 62
62649: PUSH
62650: LD_VAR 0 2
62654: ARRAY
62655: PUSH
62656: LD_INT 2
62658: ARRAY
62659: PUSH
62660: LD_INT 1
62662: ARRAY
62663: PPUSH
62664: CALL_OW 128
// end ;
62668: GO 62446
62670: POP
62671: POP
// end ;
62672: GO 62289
62674: POP
62675: POP
// end ;
62676: LD_VAR 0 1
62680: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62681: LD_INT 0
62683: PPUSH
62684: PPUSH
62685: PPUSH
62686: PPUSH
62687: PPUSH
// if not mc_bases then
62688: LD_EXP 59
62692: NOT
62693: IFFALSE 62697
// exit ;
62695: GO 63868
// for i = 1 to mc_bases do
62697: LD_ADDR_VAR 0 2
62701: PUSH
62702: DOUBLE
62703: LD_INT 1
62705: DEC
62706: ST_TO_ADDR
62707: LD_EXP 59
62711: PUSH
62712: FOR_TO
62713: IFFALSE 63866
// begin if mc_scan [ i ] then
62715: LD_EXP 82
62719: PUSH
62720: LD_VAR 0 2
62724: ARRAY
62725: IFFALSE 62729
// continue ;
62727: GO 62712
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62729: LD_EXP 64
62733: PUSH
62734: LD_VAR 0 2
62738: ARRAY
62739: NOT
62740: PUSH
62741: LD_EXP 66
62745: PUSH
62746: LD_VAR 0 2
62750: ARRAY
62751: NOT
62752: AND
62753: PUSH
62754: LD_EXP 65
62758: PUSH
62759: LD_VAR 0 2
62763: ARRAY
62764: AND
62765: IFFALSE 62803
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62767: LD_ADDR_EXP 65
62771: PUSH
62772: LD_EXP 65
62776: PPUSH
62777: LD_VAR 0 2
62781: PPUSH
62782: EMPTY
62783: PPUSH
62784: CALL_OW 1
62788: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62789: LD_VAR 0 2
62793: PPUSH
62794: LD_INT 103
62796: PPUSH
62797: CALL 56497 0 2
// continue ;
62801: GO 62712
// end ; if mc_construct_list [ i ] then
62803: LD_EXP 66
62807: PUSH
62808: LD_VAR 0 2
62812: ARRAY
62813: IFFALSE 63033
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62815: LD_ADDR_VAR 0 4
62819: PUSH
62820: LD_EXP 59
62824: PUSH
62825: LD_VAR 0 2
62829: ARRAY
62830: PPUSH
62831: LD_INT 25
62833: PUSH
62834: LD_INT 2
62836: PUSH
62837: EMPTY
62838: LIST
62839: LIST
62840: PPUSH
62841: CALL_OW 72
62845: PUSH
62846: LD_EXP 61
62850: PUSH
62851: LD_VAR 0 2
62855: ARRAY
62856: DIFF
62857: ST_TO_ADDR
// if not tmp then
62858: LD_VAR 0 4
62862: NOT
62863: IFFALSE 62867
// continue ;
62865: GO 62712
// for j in tmp do
62867: LD_ADDR_VAR 0 3
62871: PUSH
62872: LD_VAR 0 4
62876: PUSH
62877: FOR_IN
62878: IFFALSE 63029
// begin if not mc_builders [ i ] then
62880: LD_EXP 65
62884: PUSH
62885: LD_VAR 0 2
62889: ARRAY
62890: NOT
62891: IFFALSE 62949
// begin SetTag ( j , 103 ) ;
62893: LD_VAR 0 3
62897: PPUSH
62898: LD_INT 103
62900: PPUSH
62901: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62905: LD_ADDR_EXP 65
62909: PUSH
62910: LD_EXP 65
62914: PPUSH
62915: LD_VAR 0 2
62919: PUSH
62920: LD_EXP 65
62924: PUSH
62925: LD_VAR 0 2
62929: ARRAY
62930: PUSH
62931: LD_INT 1
62933: PLUS
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PPUSH
62939: LD_VAR 0 3
62943: PPUSH
62944: CALL 19686 0 3
62948: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62949: LD_VAR 0 3
62953: PPUSH
62954: CALL_OW 310
62958: IFFALSE 62969
// ComExitBuilding ( j ) ;
62960: LD_VAR 0 3
62964: PPUSH
62965: CALL_OW 122
// wait ( 3 ) ;
62969: LD_INT 3
62971: PPUSH
62972: CALL_OW 67
// if not mc_construct_list [ i ] then
62976: LD_EXP 66
62980: PUSH
62981: LD_VAR 0 2
62985: ARRAY
62986: NOT
62987: IFFALSE 62991
// break ;
62989: GO 63029
// if not HasTask ( j ) then
62991: LD_VAR 0 3
62995: PPUSH
62996: CALL_OW 314
63000: NOT
63001: IFFALSE 63027
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63003: LD_VAR 0 3
63007: PPUSH
63008: LD_EXP 66
63012: PUSH
63013: LD_VAR 0 2
63017: ARRAY
63018: PUSH
63019: LD_INT 1
63021: ARRAY
63022: PPUSH
63023: CALL 22543 0 2
// end ;
63027: GO 62877
63029: POP
63030: POP
// end else
63031: GO 63864
// if mc_build_list [ i ] then
63033: LD_EXP 64
63037: PUSH
63038: LD_VAR 0 2
63042: ARRAY
63043: IFFALSE 63864
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63045: LD_ADDR_VAR 0 5
63049: PUSH
63050: LD_EXP 59
63054: PUSH
63055: LD_VAR 0 2
63059: ARRAY
63060: PPUSH
63061: LD_INT 2
63063: PUSH
63064: LD_INT 30
63066: PUSH
63067: LD_INT 0
63069: PUSH
63070: EMPTY
63071: LIST
63072: LIST
63073: PUSH
63074: LD_INT 30
63076: PUSH
63077: LD_INT 1
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: LIST
63088: PPUSH
63089: CALL_OW 72
63093: ST_TO_ADDR
// if depot then
63094: LD_VAR 0 5
63098: IFFALSE 63116
// depot := depot [ 1 ] else
63100: LD_ADDR_VAR 0 5
63104: PUSH
63105: LD_VAR 0 5
63109: PUSH
63110: LD_INT 1
63112: ARRAY
63113: ST_TO_ADDR
63114: GO 63124
// depot := 0 ;
63116: LD_ADDR_VAR 0 5
63120: PUSH
63121: LD_INT 0
63123: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63124: LD_EXP 64
63128: PUSH
63129: LD_VAR 0 2
63133: ARRAY
63134: PUSH
63135: LD_INT 1
63137: ARRAY
63138: PUSH
63139: LD_INT 1
63141: ARRAY
63142: PPUSH
63143: CALL 22367 0 1
63147: PUSH
63148: LD_EXP 59
63152: PUSH
63153: LD_VAR 0 2
63157: ARRAY
63158: PPUSH
63159: LD_INT 2
63161: PUSH
63162: LD_INT 30
63164: PUSH
63165: LD_INT 2
63167: PUSH
63168: EMPTY
63169: LIST
63170: LIST
63171: PUSH
63172: LD_INT 30
63174: PUSH
63175: LD_INT 3
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: PPUSH
63187: CALL_OW 72
63191: NOT
63192: AND
63193: IFFALSE 63298
// begin for j = 1 to mc_build_list [ i ] do
63195: LD_ADDR_VAR 0 3
63199: PUSH
63200: DOUBLE
63201: LD_INT 1
63203: DEC
63204: ST_TO_ADDR
63205: LD_EXP 64
63209: PUSH
63210: LD_VAR 0 2
63214: ARRAY
63215: PUSH
63216: FOR_TO
63217: IFFALSE 63296
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63219: LD_EXP 64
63223: PUSH
63224: LD_VAR 0 2
63228: ARRAY
63229: PUSH
63230: LD_VAR 0 3
63234: ARRAY
63235: PUSH
63236: LD_INT 1
63238: ARRAY
63239: PUSH
63240: LD_INT 2
63242: EQUAL
63243: IFFALSE 63294
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63245: LD_ADDR_EXP 64
63249: PUSH
63250: LD_EXP 64
63254: PPUSH
63255: LD_VAR 0 2
63259: PPUSH
63260: LD_EXP 64
63264: PUSH
63265: LD_VAR 0 2
63269: ARRAY
63270: PPUSH
63271: LD_VAR 0 3
63275: PPUSH
63276: LD_INT 1
63278: PPUSH
63279: LD_INT 0
63281: PPUSH
63282: CALL 19104 0 4
63286: PPUSH
63287: CALL_OW 1
63291: ST_TO_ADDR
// break ;
63292: GO 63296
// end ;
63294: GO 63216
63296: POP
63297: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
63298: LD_EXP 64
63302: PUSH
63303: LD_VAR 0 2
63307: ARRAY
63308: PUSH
63309: LD_INT 1
63311: ARRAY
63312: PUSH
63313: LD_INT 1
63315: ARRAY
63316: PUSH
63317: LD_INT 0
63319: EQUAL
63320: PUSH
63321: LD_VAR 0 5
63325: PUSH
63326: LD_VAR 0 5
63330: PPUSH
63331: LD_EXP 64
63335: PUSH
63336: LD_VAR 0 2
63340: ARRAY
63341: PUSH
63342: LD_INT 1
63344: ARRAY
63345: PUSH
63346: LD_INT 1
63348: ARRAY
63349: PPUSH
63350: LD_EXP 64
63354: PUSH
63355: LD_VAR 0 2
63359: ARRAY
63360: PUSH
63361: LD_INT 1
63363: ARRAY
63364: PUSH
63365: LD_INT 2
63367: ARRAY
63368: PPUSH
63369: LD_EXP 64
63373: PUSH
63374: LD_VAR 0 2
63378: ARRAY
63379: PUSH
63380: LD_INT 1
63382: ARRAY
63383: PUSH
63384: LD_INT 3
63386: ARRAY
63387: PPUSH
63388: LD_EXP 64
63392: PUSH
63393: LD_VAR 0 2
63397: ARRAY
63398: PUSH
63399: LD_INT 1
63401: ARRAY
63402: PUSH
63403: LD_INT 4
63405: ARRAY
63406: PPUSH
63407: CALL 27404 0 5
63411: AND
63412: OR
63413: IFFALSE 63694
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63415: LD_ADDR_VAR 0 4
63419: PUSH
63420: LD_EXP 59
63424: PUSH
63425: LD_VAR 0 2
63429: ARRAY
63430: PPUSH
63431: LD_INT 25
63433: PUSH
63434: LD_INT 2
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PPUSH
63441: CALL_OW 72
63445: PUSH
63446: LD_EXP 61
63450: PUSH
63451: LD_VAR 0 2
63455: ARRAY
63456: DIFF
63457: ST_TO_ADDR
// if not tmp then
63458: LD_VAR 0 4
63462: NOT
63463: IFFALSE 63467
// continue ;
63465: GO 62712
// for j in tmp do
63467: LD_ADDR_VAR 0 3
63471: PUSH
63472: LD_VAR 0 4
63476: PUSH
63477: FOR_IN
63478: IFFALSE 63690
// begin if not mc_builders [ i ] then
63480: LD_EXP 65
63484: PUSH
63485: LD_VAR 0 2
63489: ARRAY
63490: NOT
63491: IFFALSE 63549
// begin SetTag ( j , 103 ) ;
63493: LD_VAR 0 3
63497: PPUSH
63498: LD_INT 103
63500: PPUSH
63501: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63505: LD_ADDR_EXP 65
63509: PUSH
63510: LD_EXP 65
63514: PPUSH
63515: LD_VAR 0 2
63519: PUSH
63520: LD_EXP 65
63524: PUSH
63525: LD_VAR 0 2
63529: ARRAY
63530: PUSH
63531: LD_INT 1
63533: PLUS
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: PPUSH
63539: LD_VAR 0 3
63543: PPUSH
63544: CALL 19686 0 3
63548: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63549: LD_VAR 0 3
63553: PPUSH
63554: CALL_OW 310
63558: IFFALSE 63569
// ComExitBuilding ( j ) ;
63560: LD_VAR 0 3
63564: PPUSH
63565: CALL_OW 122
// wait ( 3 ) ;
63569: LD_INT 3
63571: PPUSH
63572: CALL_OW 67
// if not mc_build_list [ i ] then
63576: LD_EXP 64
63580: PUSH
63581: LD_VAR 0 2
63585: ARRAY
63586: NOT
63587: IFFALSE 63591
// break ;
63589: GO 63690
// if not HasTask ( j ) then
63591: LD_VAR 0 3
63595: PPUSH
63596: CALL_OW 314
63600: NOT
63601: IFFALSE 63688
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63603: LD_VAR 0 3
63607: PPUSH
63608: LD_EXP 64
63612: PUSH
63613: LD_VAR 0 2
63617: ARRAY
63618: PUSH
63619: LD_INT 1
63621: ARRAY
63622: PUSH
63623: LD_INT 1
63625: ARRAY
63626: PPUSH
63627: LD_EXP 64
63631: PUSH
63632: LD_VAR 0 2
63636: ARRAY
63637: PUSH
63638: LD_INT 1
63640: ARRAY
63641: PUSH
63642: LD_INT 2
63644: ARRAY
63645: PPUSH
63646: LD_EXP 64
63650: PUSH
63651: LD_VAR 0 2
63655: ARRAY
63656: PUSH
63657: LD_INT 1
63659: ARRAY
63660: PUSH
63661: LD_INT 3
63663: ARRAY
63664: PPUSH
63665: LD_EXP 64
63669: PUSH
63670: LD_VAR 0 2
63674: ARRAY
63675: PUSH
63676: LD_INT 1
63678: ARRAY
63679: PUSH
63680: LD_INT 4
63682: ARRAY
63683: PPUSH
63684: CALL_OW 145
// end ;
63688: GO 63477
63690: POP
63691: POP
// end else
63692: GO 63864
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63694: LD_EXP 59
63698: PUSH
63699: LD_VAR 0 2
63703: ARRAY
63704: PPUSH
63705: LD_EXP 64
63709: PUSH
63710: LD_VAR 0 2
63714: ARRAY
63715: PUSH
63716: LD_INT 1
63718: ARRAY
63719: PUSH
63720: LD_INT 1
63722: ARRAY
63723: PPUSH
63724: LD_EXP 64
63728: PUSH
63729: LD_VAR 0 2
63733: ARRAY
63734: PUSH
63735: LD_INT 1
63737: ARRAY
63738: PUSH
63739: LD_INT 2
63741: ARRAY
63742: PPUSH
63743: LD_EXP 64
63747: PUSH
63748: LD_VAR 0 2
63752: ARRAY
63753: PUSH
63754: LD_INT 1
63756: ARRAY
63757: PUSH
63758: LD_INT 3
63760: ARRAY
63761: PPUSH
63762: LD_EXP 64
63766: PUSH
63767: LD_VAR 0 2
63771: ARRAY
63772: PUSH
63773: LD_INT 1
63775: ARRAY
63776: PUSH
63777: LD_INT 4
63779: ARRAY
63780: PPUSH
63781: LD_EXP 59
63785: PUSH
63786: LD_VAR 0 2
63790: ARRAY
63791: PPUSH
63792: LD_INT 21
63794: PUSH
63795: LD_INT 3
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PPUSH
63802: CALL_OW 72
63806: PPUSH
63807: EMPTY
63808: PPUSH
63809: CALL 26534 0 7
63813: NOT
63814: IFFALSE 63864
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63816: LD_ADDR_EXP 64
63820: PUSH
63821: LD_EXP 64
63825: PPUSH
63826: LD_VAR 0 2
63830: PPUSH
63831: LD_EXP 64
63835: PUSH
63836: LD_VAR 0 2
63840: ARRAY
63841: PPUSH
63842: LD_INT 1
63844: PPUSH
63845: LD_INT 1
63847: NEG
63848: PPUSH
63849: LD_INT 0
63851: PPUSH
63852: CALL 19104 0 4
63856: PPUSH
63857: CALL_OW 1
63861: ST_TO_ADDR
// continue ;
63862: GO 62712
// end ; end ; end ;
63864: GO 62712
63866: POP
63867: POP
// end ;
63868: LD_VAR 0 1
63872: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63873: LD_INT 0
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
// if not mc_bases then
63881: LD_EXP 59
63885: NOT
63886: IFFALSE 63890
// exit ;
63888: GO 64317
// for i = 1 to mc_bases do
63890: LD_ADDR_VAR 0 2
63894: PUSH
63895: DOUBLE
63896: LD_INT 1
63898: DEC
63899: ST_TO_ADDR
63900: LD_EXP 59
63904: PUSH
63905: FOR_TO
63906: IFFALSE 64315
// begin tmp := mc_build_upgrade [ i ] ;
63908: LD_ADDR_VAR 0 4
63912: PUSH
63913: LD_EXP 91
63917: PUSH
63918: LD_VAR 0 2
63922: ARRAY
63923: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63924: LD_ADDR_VAR 0 6
63928: PUSH
63929: LD_EXP 92
63933: PUSH
63934: LD_VAR 0 2
63938: ARRAY
63939: PPUSH
63940: LD_INT 2
63942: PUSH
63943: LD_INT 30
63945: PUSH
63946: LD_INT 6
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: LD_INT 30
63955: PUSH
63956: LD_INT 7
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: LIST
63967: PPUSH
63968: CALL_OW 72
63972: ST_TO_ADDR
// if not tmp and not lab then
63973: LD_VAR 0 4
63977: NOT
63978: PUSH
63979: LD_VAR 0 6
63983: NOT
63984: AND
63985: IFFALSE 63989
// continue ;
63987: GO 63905
// if tmp then
63989: LD_VAR 0 4
63993: IFFALSE 64113
// for j in tmp do
63995: LD_ADDR_VAR 0 3
63999: PUSH
64000: LD_VAR 0 4
64004: PUSH
64005: FOR_IN
64006: IFFALSE 64111
// begin if UpgradeCost ( j ) then
64008: LD_VAR 0 3
64012: PPUSH
64013: CALL 26194 0 1
64017: IFFALSE 64109
// begin ComUpgrade ( j ) ;
64019: LD_VAR 0 3
64023: PPUSH
64024: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64028: LD_ADDR_EXP 91
64032: PUSH
64033: LD_EXP 91
64037: PPUSH
64038: LD_VAR 0 2
64042: PPUSH
64043: LD_EXP 91
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: PUSH
64054: LD_VAR 0 3
64058: DIFF
64059: PPUSH
64060: CALL_OW 1
64064: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64065: LD_ADDR_EXP 66
64069: PUSH
64070: LD_EXP 66
64074: PPUSH
64075: LD_VAR 0 2
64079: PUSH
64080: LD_EXP 66
64084: PUSH
64085: LD_VAR 0 2
64089: ARRAY
64090: PUSH
64091: LD_INT 1
64093: PLUS
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PPUSH
64099: LD_VAR 0 3
64103: PPUSH
64104: CALL 19686 0 3
64108: ST_TO_ADDR
// end ; end ;
64109: GO 64005
64111: POP
64112: POP
// if not lab or not mc_lab_upgrade [ i ] then
64113: LD_VAR 0 6
64117: NOT
64118: PUSH
64119: LD_EXP 93
64123: PUSH
64124: LD_VAR 0 2
64128: ARRAY
64129: NOT
64130: OR
64131: IFFALSE 64135
// continue ;
64133: GO 63905
// for j in lab do
64135: LD_ADDR_VAR 0 3
64139: PUSH
64140: LD_VAR 0 6
64144: PUSH
64145: FOR_IN
64146: IFFALSE 64311
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64148: LD_VAR 0 3
64152: PPUSH
64153: CALL_OW 266
64157: PUSH
64158: LD_INT 6
64160: PUSH
64161: LD_INT 7
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: IN
64168: PUSH
64169: LD_VAR 0 3
64173: PPUSH
64174: CALL_OW 461
64178: PUSH
64179: LD_INT 1
64181: NONEQUAL
64182: AND
64183: IFFALSE 64309
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64185: LD_VAR 0 3
64189: PPUSH
64190: LD_EXP 93
64194: PUSH
64195: LD_VAR 0 2
64199: ARRAY
64200: PUSH
64201: LD_INT 1
64203: ARRAY
64204: PPUSH
64205: CALL 26399 0 2
64209: IFFALSE 64309
// begin ComCancel ( j ) ;
64211: LD_VAR 0 3
64215: PPUSH
64216: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64220: LD_VAR 0 3
64224: PPUSH
64225: LD_EXP 93
64229: PUSH
64230: LD_VAR 0 2
64234: ARRAY
64235: PUSH
64236: LD_INT 1
64238: ARRAY
64239: PPUSH
64240: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64244: LD_VAR 0 3
64248: PUSH
64249: LD_EXP 66
64253: PUSH
64254: LD_VAR 0 2
64258: ARRAY
64259: IN
64260: NOT
64261: IFFALSE 64307
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64263: LD_ADDR_EXP 66
64267: PUSH
64268: LD_EXP 66
64272: PPUSH
64273: LD_VAR 0 2
64277: PUSH
64278: LD_EXP 66
64282: PUSH
64283: LD_VAR 0 2
64287: ARRAY
64288: PUSH
64289: LD_INT 1
64291: PLUS
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PPUSH
64297: LD_VAR 0 3
64301: PPUSH
64302: CALL 19686 0 3
64306: ST_TO_ADDR
// break ;
64307: GO 64311
// end ; end ; end ;
64309: GO 64145
64311: POP
64312: POP
// end ;
64313: GO 63905
64315: POP
64316: POP
// end ;
64317: LD_VAR 0 1
64321: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64322: LD_INT 0
64324: PPUSH
64325: PPUSH
64326: PPUSH
64327: PPUSH
64328: PPUSH
64329: PPUSH
64330: PPUSH
64331: PPUSH
64332: PPUSH
// if not mc_bases then
64333: LD_EXP 59
64337: NOT
64338: IFFALSE 64342
// exit ;
64340: GO 64747
// for i = 1 to mc_bases do
64342: LD_ADDR_VAR 0 2
64346: PUSH
64347: DOUBLE
64348: LD_INT 1
64350: DEC
64351: ST_TO_ADDR
64352: LD_EXP 59
64356: PUSH
64357: FOR_TO
64358: IFFALSE 64745
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64360: LD_EXP 67
64364: PUSH
64365: LD_VAR 0 2
64369: ARRAY
64370: NOT
64371: PUSH
64372: LD_EXP 59
64376: PUSH
64377: LD_VAR 0 2
64381: ARRAY
64382: PPUSH
64383: LD_INT 30
64385: PUSH
64386: LD_INT 3
64388: PUSH
64389: EMPTY
64390: LIST
64391: LIST
64392: PPUSH
64393: CALL_OW 72
64397: NOT
64398: OR
64399: IFFALSE 64403
// continue ;
64401: GO 64357
// busy := false ;
64403: LD_ADDR_VAR 0 8
64407: PUSH
64408: LD_INT 0
64410: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64411: LD_ADDR_VAR 0 4
64415: PUSH
64416: LD_EXP 59
64420: PUSH
64421: LD_VAR 0 2
64425: ARRAY
64426: PPUSH
64427: LD_INT 30
64429: PUSH
64430: LD_INT 3
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: PPUSH
64437: CALL_OW 72
64441: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64442: LD_ADDR_VAR 0 6
64446: PUSH
64447: LD_EXP 67
64451: PUSH
64452: LD_VAR 0 2
64456: ARRAY
64457: PPUSH
64458: LD_INT 2
64460: PUSH
64461: LD_INT 30
64463: PUSH
64464: LD_INT 32
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 30
64473: PUSH
64474: LD_INT 33
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: LIST
64485: PPUSH
64486: CALL_OW 72
64490: ST_TO_ADDR
// if not t then
64491: LD_VAR 0 6
64495: NOT
64496: IFFALSE 64500
// continue ;
64498: GO 64357
// for j in tmp do
64500: LD_ADDR_VAR 0 3
64504: PUSH
64505: LD_VAR 0 4
64509: PUSH
64510: FOR_IN
64511: IFFALSE 64541
// if not BuildingStatus ( j ) = bs_idle then
64513: LD_VAR 0 3
64517: PPUSH
64518: CALL_OW 461
64522: PUSH
64523: LD_INT 2
64525: EQUAL
64526: NOT
64527: IFFALSE 64539
// begin busy := true ;
64529: LD_ADDR_VAR 0 8
64533: PUSH
64534: LD_INT 1
64536: ST_TO_ADDR
// break ;
64537: GO 64541
// end ;
64539: GO 64510
64541: POP
64542: POP
// if busy then
64543: LD_VAR 0 8
64547: IFFALSE 64551
// continue ;
64549: GO 64357
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64551: LD_ADDR_VAR 0 7
64555: PUSH
64556: LD_VAR 0 6
64560: PPUSH
64561: LD_INT 35
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PPUSH
64571: CALL_OW 72
64575: ST_TO_ADDR
// if tw then
64576: LD_VAR 0 7
64580: IFFALSE 64657
// begin tw := tw [ 1 ] ;
64582: LD_ADDR_VAR 0 7
64586: PUSH
64587: LD_VAR 0 7
64591: PUSH
64592: LD_INT 1
64594: ARRAY
64595: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64596: LD_ADDR_VAR 0 9
64600: PUSH
64601: LD_VAR 0 7
64605: PPUSH
64606: LD_EXP 84
64610: PUSH
64611: LD_VAR 0 2
64615: ARRAY
64616: PPUSH
64617: CALL 24691 0 2
64621: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64622: LD_EXP 98
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: IFFALSE 64655
// if not weapon in mc_allowed_tower_weapons [ i ] then
64634: LD_VAR 0 9
64638: PUSH
64639: LD_EXP 98
64643: PUSH
64644: LD_VAR 0 2
64648: ARRAY
64649: IN
64650: NOT
64651: IFFALSE 64655
// continue ;
64653: GO 64357
// end else
64655: GO 64720
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64657: LD_ADDR_VAR 0 5
64661: PUSH
64662: LD_EXP 67
64666: PUSH
64667: LD_VAR 0 2
64671: ARRAY
64672: PPUSH
64673: LD_VAR 0 4
64677: PPUSH
64678: CALL 50580 0 2
64682: ST_TO_ADDR
// if not tmp2 then
64683: LD_VAR 0 5
64687: NOT
64688: IFFALSE 64692
// continue ;
64690: GO 64357
// tw := tmp2 [ 1 ] ;
64692: LD_ADDR_VAR 0 7
64696: PUSH
64697: LD_VAR 0 5
64701: PUSH
64702: LD_INT 1
64704: ARRAY
64705: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64706: LD_ADDR_VAR 0 9
64710: PUSH
64711: LD_VAR 0 5
64715: PUSH
64716: LD_INT 2
64718: ARRAY
64719: ST_TO_ADDR
// end ; if not weapon then
64720: LD_VAR 0 9
64724: NOT
64725: IFFALSE 64729
// continue ;
64727: GO 64357
// ComPlaceWeapon ( tw , weapon ) ;
64729: LD_VAR 0 7
64733: PPUSH
64734: LD_VAR 0 9
64738: PPUSH
64739: CALL_OW 148
// end ;
64743: GO 64357
64745: POP
64746: POP
// end ;
64747: LD_VAR 0 1
64751: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64752: LD_INT 0
64754: PPUSH
64755: PPUSH
64756: PPUSH
64757: PPUSH
64758: PPUSH
64759: PPUSH
64760: PPUSH
// if not mc_bases then
64761: LD_EXP 59
64765: NOT
64766: IFFALSE 64770
// exit ;
64768: GO 65538
// for i = 1 to mc_bases do
64770: LD_ADDR_VAR 0 2
64774: PUSH
64775: DOUBLE
64776: LD_INT 1
64778: DEC
64779: ST_TO_ADDR
64780: LD_EXP 59
64784: PUSH
64785: FOR_TO
64786: IFFALSE 65536
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64788: LD_EXP 72
64792: PUSH
64793: LD_VAR 0 2
64797: ARRAY
64798: NOT
64799: PUSH
64800: LD_EXP 72
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: PUSH
64811: LD_EXP 73
64815: PUSH
64816: LD_VAR 0 2
64820: ARRAY
64821: EQUAL
64822: OR
64823: PUSH
64824: LD_EXP 82
64828: PUSH
64829: LD_VAR 0 2
64833: ARRAY
64834: OR
64835: IFFALSE 64839
// continue ;
64837: GO 64785
// if mc_miners [ i ] then
64839: LD_EXP 73
64843: PUSH
64844: LD_VAR 0 2
64848: ARRAY
64849: IFFALSE 65223
// begin for j = mc_miners [ i ] downto 1 do
64851: LD_ADDR_VAR 0 3
64855: PUSH
64856: DOUBLE
64857: LD_EXP 73
64861: PUSH
64862: LD_VAR 0 2
64866: ARRAY
64867: INC
64868: ST_TO_ADDR
64869: LD_INT 1
64871: PUSH
64872: FOR_DOWNTO
64873: IFFALSE 65221
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64875: LD_EXP 73
64879: PUSH
64880: LD_VAR 0 2
64884: ARRAY
64885: PUSH
64886: LD_VAR 0 3
64890: ARRAY
64891: PPUSH
64892: CALL_OW 301
64896: PUSH
64897: LD_EXP 73
64901: PUSH
64902: LD_VAR 0 2
64906: ARRAY
64907: PUSH
64908: LD_VAR 0 3
64912: ARRAY
64913: PPUSH
64914: CALL_OW 257
64918: PUSH
64919: LD_INT 1
64921: NONEQUAL
64922: OR
64923: IFFALSE 64986
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64925: LD_ADDR_VAR 0 5
64929: PUSH
64930: LD_EXP 73
64934: PUSH
64935: LD_VAR 0 2
64939: ARRAY
64940: PUSH
64941: LD_EXP 73
64945: PUSH
64946: LD_VAR 0 2
64950: ARRAY
64951: PUSH
64952: LD_VAR 0 3
64956: ARRAY
64957: DIFF
64958: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64959: LD_ADDR_EXP 73
64963: PUSH
64964: LD_EXP 73
64968: PPUSH
64969: LD_VAR 0 2
64973: PPUSH
64974: LD_VAR 0 5
64978: PPUSH
64979: CALL_OW 1
64983: ST_TO_ADDR
// continue ;
64984: GO 64872
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64986: LD_EXP 73
64990: PUSH
64991: LD_VAR 0 2
64995: ARRAY
64996: PUSH
64997: LD_VAR 0 3
65001: ARRAY
65002: PPUSH
65003: CALL_OW 257
65007: PUSH
65008: LD_INT 1
65010: EQUAL
65011: PUSH
65012: LD_EXP 73
65016: PUSH
65017: LD_VAR 0 2
65021: ARRAY
65022: PUSH
65023: LD_VAR 0 3
65027: ARRAY
65028: PPUSH
65029: CALL_OW 459
65033: NOT
65034: AND
65035: PUSH
65036: LD_EXP 73
65040: PUSH
65041: LD_VAR 0 2
65045: ARRAY
65046: PUSH
65047: LD_VAR 0 3
65051: ARRAY
65052: PPUSH
65053: CALL_OW 314
65057: NOT
65058: AND
65059: IFFALSE 65219
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65061: LD_EXP 73
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: PUSH
65072: LD_VAR 0 3
65076: ARRAY
65077: PPUSH
65078: CALL_OW 310
65082: IFFALSE 65105
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65084: LD_EXP 73
65088: PUSH
65089: LD_VAR 0 2
65093: ARRAY
65094: PUSH
65095: LD_VAR 0 3
65099: ARRAY
65100: PPUSH
65101: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65105: LD_EXP 73
65109: PUSH
65110: LD_VAR 0 2
65114: ARRAY
65115: PUSH
65116: LD_VAR 0 3
65120: ARRAY
65121: PPUSH
65122: CALL_OW 314
65126: NOT
65127: IFFALSE 65219
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65129: LD_ADDR_VAR 0 7
65133: PUSH
65134: LD_INT 1
65136: PPUSH
65137: LD_EXP 72
65141: PUSH
65142: LD_VAR 0 2
65146: ARRAY
65147: PPUSH
65148: CALL_OW 12
65152: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65153: LD_EXP 73
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: PUSH
65164: LD_VAR 0 3
65168: ARRAY
65169: PPUSH
65170: LD_EXP 72
65174: PUSH
65175: LD_VAR 0 2
65179: ARRAY
65180: PUSH
65181: LD_VAR 0 7
65185: ARRAY
65186: PUSH
65187: LD_INT 1
65189: ARRAY
65190: PPUSH
65191: LD_EXP 72
65195: PUSH
65196: LD_VAR 0 2
65200: ARRAY
65201: PUSH
65202: LD_VAR 0 7
65206: ARRAY
65207: PUSH
65208: LD_INT 2
65210: ARRAY
65211: PPUSH
65212: LD_INT 0
65214: PPUSH
65215: CALL_OW 193
// end ; end ; end ;
65219: GO 64872
65221: POP
65222: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65223: LD_ADDR_VAR 0 5
65227: PUSH
65228: LD_EXP 59
65232: PUSH
65233: LD_VAR 0 2
65237: ARRAY
65238: PPUSH
65239: LD_INT 2
65241: PUSH
65242: LD_INT 30
65244: PUSH
65245: LD_INT 4
65247: PUSH
65248: EMPTY
65249: LIST
65250: LIST
65251: PUSH
65252: LD_INT 30
65254: PUSH
65255: LD_INT 5
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: PUSH
65262: LD_INT 30
65264: PUSH
65265: LD_INT 32
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: PPUSH
65278: CALL_OW 72
65282: ST_TO_ADDR
// if not tmp then
65283: LD_VAR 0 5
65287: NOT
65288: IFFALSE 65292
// continue ;
65290: GO 64785
// list := [ ] ;
65292: LD_ADDR_VAR 0 6
65296: PUSH
65297: EMPTY
65298: ST_TO_ADDR
// for j in tmp do
65299: LD_ADDR_VAR 0 3
65303: PUSH
65304: LD_VAR 0 5
65308: PUSH
65309: FOR_IN
65310: IFFALSE 65379
// begin for k in UnitsInside ( j ) do
65312: LD_ADDR_VAR 0 4
65316: PUSH
65317: LD_VAR 0 3
65321: PPUSH
65322: CALL_OW 313
65326: PUSH
65327: FOR_IN
65328: IFFALSE 65375
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65330: LD_VAR 0 4
65334: PPUSH
65335: CALL_OW 257
65339: PUSH
65340: LD_INT 1
65342: EQUAL
65343: PUSH
65344: LD_VAR 0 4
65348: PPUSH
65349: CALL_OW 459
65353: NOT
65354: AND
65355: IFFALSE 65373
// list := list ^ k ;
65357: LD_ADDR_VAR 0 6
65361: PUSH
65362: LD_VAR 0 6
65366: PUSH
65367: LD_VAR 0 4
65371: ADD
65372: ST_TO_ADDR
65373: GO 65327
65375: POP
65376: POP
// end ;
65377: GO 65309
65379: POP
65380: POP
// list := list diff mc_miners [ i ] ;
65381: LD_ADDR_VAR 0 6
65385: PUSH
65386: LD_VAR 0 6
65390: PUSH
65391: LD_EXP 73
65395: PUSH
65396: LD_VAR 0 2
65400: ARRAY
65401: DIFF
65402: ST_TO_ADDR
// if not list then
65403: LD_VAR 0 6
65407: NOT
65408: IFFALSE 65412
// continue ;
65410: GO 64785
// k := mc_mines [ i ] - mc_miners [ i ] ;
65412: LD_ADDR_VAR 0 4
65416: PUSH
65417: LD_EXP 72
65421: PUSH
65422: LD_VAR 0 2
65426: ARRAY
65427: PUSH
65428: LD_EXP 73
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: MINUS
65439: ST_TO_ADDR
// if k > list then
65440: LD_VAR 0 4
65444: PUSH
65445: LD_VAR 0 6
65449: GREATER
65450: IFFALSE 65462
// k := list ;
65452: LD_ADDR_VAR 0 4
65456: PUSH
65457: LD_VAR 0 6
65461: ST_TO_ADDR
// for j = 1 to k do
65462: LD_ADDR_VAR 0 3
65466: PUSH
65467: DOUBLE
65468: LD_INT 1
65470: DEC
65471: ST_TO_ADDR
65472: LD_VAR 0 4
65476: PUSH
65477: FOR_TO
65478: IFFALSE 65532
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65480: LD_ADDR_EXP 73
65484: PUSH
65485: LD_EXP 73
65489: PPUSH
65490: LD_VAR 0 2
65494: PUSH
65495: LD_EXP 73
65499: PUSH
65500: LD_VAR 0 2
65504: ARRAY
65505: PUSH
65506: LD_INT 1
65508: PLUS
65509: PUSH
65510: EMPTY
65511: LIST
65512: LIST
65513: PPUSH
65514: LD_VAR 0 6
65518: PUSH
65519: LD_VAR 0 3
65523: ARRAY
65524: PPUSH
65525: CALL 19686 0 3
65529: ST_TO_ADDR
65530: GO 65477
65532: POP
65533: POP
// end ;
65534: GO 64785
65536: POP
65537: POP
// end ;
65538: LD_VAR 0 1
65542: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
65543: LD_INT 0
65545: PPUSH
65546: PPUSH
65547: PPUSH
65548: PPUSH
65549: PPUSH
65550: PPUSH
65551: PPUSH
65552: PPUSH
65553: PPUSH
65554: PPUSH
// if not mc_bases then
65555: LD_EXP 59
65559: NOT
65560: IFFALSE 65564
// exit ;
65562: GO 67314
// for i = 1 to mc_bases do
65564: LD_ADDR_VAR 0 2
65568: PUSH
65569: DOUBLE
65570: LD_INT 1
65572: DEC
65573: ST_TO_ADDR
65574: LD_EXP 59
65578: PUSH
65579: FOR_TO
65580: IFFALSE 67312
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65582: LD_EXP 59
65586: PUSH
65587: LD_VAR 0 2
65591: ARRAY
65592: NOT
65593: PUSH
65594: LD_EXP 66
65598: PUSH
65599: LD_VAR 0 2
65603: ARRAY
65604: OR
65605: IFFALSE 65609
// continue ;
65607: GO 65579
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65609: LD_EXP 75
65613: PUSH
65614: LD_VAR 0 2
65618: ARRAY
65619: NOT
65620: PUSH
65621: LD_EXP 76
65625: PUSH
65626: LD_VAR 0 2
65630: ARRAY
65631: AND
65632: IFFALSE 65670
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65634: LD_ADDR_EXP 76
65638: PUSH
65639: LD_EXP 76
65643: PPUSH
65644: LD_VAR 0 2
65648: PPUSH
65649: EMPTY
65650: PPUSH
65651: CALL_OW 1
65655: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65656: LD_VAR 0 2
65660: PPUSH
65661: LD_INT 107
65663: PPUSH
65664: CALL 56497 0 2
// continue ;
65668: GO 65579
// end ; target := [ ] ;
65670: LD_ADDR_VAR 0 6
65674: PUSH
65675: EMPTY
65676: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65677: LD_ADDR_VAR 0 3
65681: PUSH
65682: DOUBLE
65683: LD_EXP 75
65687: PUSH
65688: LD_VAR 0 2
65692: ARRAY
65693: INC
65694: ST_TO_ADDR
65695: LD_INT 1
65697: PUSH
65698: FOR_DOWNTO
65699: IFFALSE 65959
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65701: LD_EXP 75
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: PUSH
65712: LD_VAR 0 3
65716: ARRAY
65717: PUSH
65718: LD_INT 2
65720: ARRAY
65721: PPUSH
65722: LD_EXP 75
65726: PUSH
65727: LD_VAR 0 2
65731: ARRAY
65732: PUSH
65733: LD_VAR 0 3
65737: ARRAY
65738: PUSH
65739: LD_INT 3
65741: ARRAY
65742: PPUSH
65743: CALL_OW 488
65747: PUSH
65748: LD_EXP 75
65752: PUSH
65753: LD_VAR 0 2
65757: ARRAY
65758: PUSH
65759: LD_VAR 0 3
65763: ARRAY
65764: PUSH
65765: LD_INT 2
65767: ARRAY
65768: PPUSH
65769: LD_EXP 75
65773: PUSH
65774: LD_VAR 0 2
65778: ARRAY
65779: PUSH
65780: LD_VAR 0 3
65784: ARRAY
65785: PUSH
65786: LD_INT 3
65788: ARRAY
65789: PPUSH
65790: CALL_OW 284
65794: PUSH
65795: LD_INT 0
65797: EQUAL
65798: AND
65799: IFFALSE 65854
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65801: LD_ADDR_VAR 0 5
65805: PUSH
65806: LD_EXP 75
65810: PUSH
65811: LD_VAR 0 2
65815: ARRAY
65816: PPUSH
65817: LD_VAR 0 3
65821: PPUSH
65822: CALL_OW 3
65826: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65827: LD_ADDR_EXP 75
65831: PUSH
65832: LD_EXP 75
65836: PPUSH
65837: LD_VAR 0 2
65841: PPUSH
65842: LD_VAR 0 5
65846: PPUSH
65847: CALL_OW 1
65851: ST_TO_ADDR
// continue ;
65852: GO 65698
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65854: LD_EXP 59
65858: PUSH
65859: LD_VAR 0 2
65863: ARRAY
65864: PUSH
65865: LD_INT 1
65867: ARRAY
65868: PPUSH
65869: CALL_OW 255
65873: PPUSH
65874: LD_EXP 75
65878: PUSH
65879: LD_VAR 0 2
65883: ARRAY
65884: PUSH
65885: LD_VAR 0 3
65889: ARRAY
65890: PUSH
65891: LD_INT 2
65893: ARRAY
65894: PPUSH
65895: LD_EXP 75
65899: PUSH
65900: LD_VAR 0 2
65904: ARRAY
65905: PUSH
65906: LD_VAR 0 3
65910: ARRAY
65911: PUSH
65912: LD_INT 3
65914: ARRAY
65915: PPUSH
65916: LD_INT 30
65918: PPUSH
65919: CALL 20582 0 4
65923: PUSH
65924: LD_INT 4
65926: ARRAY
65927: PUSH
65928: LD_INT 0
65930: EQUAL
65931: IFFALSE 65957
// begin target := mc_crates [ i ] [ j ] ;
65933: LD_ADDR_VAR 0 6
65937: PUSH
65938: LD_EXP 75
65942: PUSH
65943: LD_VAR 0 2
65947: ARRAY
65948: PUSH
65949: LD_VAR 0 3
65953: ARRAY
65954: ST_TO_ADDR
// break ;
65955: GO 65959
// end ; end ;
65957: GO 65698
65959: POP
65960: POP
// if not target then
65961: LD_VAR 0 6
65965: NOT
65966: IFFALSE 65970
// continue ;
65968: GO 65579
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65970: LD_ADDR_VAR 0 7
65974: PUSH
65975: LD_EXP 78
65979: PUSH
65980: LD_VAR 0 2
65984: ARRAY
65985: PPUSH
65986: LD_INT 2
65988: PUSH
65989: LD_INT 3
65991: PUSH
65992: LD_INT 58
65994: PUSH
65995: EMPTY
65996: LIST
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 61
66004: PUSH
66005: EMPTY
66006: LIST
66007: PUSH
66008: LD_INT 33
66010: PUSH
66011: LD_INT 5
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 33
66020: PUSH
66021: LD_INT 3
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 2
66037: PUSH
66038: LD_INT 34
66040: PUSH
66041: LD_INT 32
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 34
66050: PUSH
66051: LD_INT 51
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PUSH
66058: LD_INT 34
66060: PUSH
66061: LD_INT 12
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PPUSH
66078: CALL_OW 72
66082: ST_TO_ADDR
// if not cargo then
66083: LD_VAR 0 7
66087: NOT
66088: IFFALSE 66731
// begin if mc_crates_collector [ i ] < 5 then
66090: LD_EXP 76
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: PUSH
66101: LD_INT 5
66103: LESS
66104: IFFALSE 66470
// begin if mc_ape [ i ] then
66106: LD_EXP 88
66110: PUSH
66111: LD_VAR 0 2
66115: ARRAY
66116: IFFALSE 66163
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66118: LD_ADDR_VAR 0 5
66122: PUSH
66123: LD_EXP 88
66127: PUSH
66128: LD_VAR 0 2
66132: ARRAY
66133: PPUSH
66134: LD_INT 25
66136: PUSH
66137: LD_INT 16
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 24
66146: PUSH
66147: LD_INT 750
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PPUSH
66158: CALL_OW 72
66162: ST_TO_ADDR
// if not tmp then
66163: LD_VAR 0 5
66167: NOT
66168: IFFALSE 66215
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66170: LD_ADDR_VAR 0 5
66174: PUSH
66175: LD_EXP 59
66179: PUSH
66180: LD_VAR 0 2
66184: ARRAY
66185: PPUSH
66186: LD_INT 25
66188: PUSH
66189: LD_INT 2
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 24
66198: PUSH
66199: LD_INT 750
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PPUSH
66210: CALL_OW 72
66214: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66215: LD_EXP 88
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: PUSH
66226: LD_EXP 59
66230: PUSH
66231: LD_VAR 0 2
66235: ARRAY
66236: PPUSH
66237: LD_INT 25
66239: PUSH
66240: LD_INT 2
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 24
66249: PUSH
66250: LD_INT 750
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PPUSH
66261: CALL_OW 72
66265: AND
66266: PUSH
66267: LD_VAR 0 5
66271: PUSH
66272: LD_INT 5
66274: LESS
66275: AND
66276: IFFALSE 66358
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66278: LD_ADDR_VAR 0 3
66282: PUSH
66283: LD_EXP 59
66287: PUSH
66288: LD_VAR 0 2
66292: ARRAY
66293: PPUSH
66294: LD_INT 25
66296: PUSH
66297: LD_INT 2
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 24
66306: PUSH
66307: LD_INT 750
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PPUSH
66318: CALL_OW 72
66322: PUSH
66323: FOR_IN
66324: IFFALSE 66356
// begin tmp := tmp union j ;
66326: LD_ADDR_VAR 0 5
66330: PUSH
66331: LD_VAR 0 5
66335: PUSH
66336: LD_VAR 0 3
66340: UNION
66341: ST_TO_ADDR
// if tmp >= 5 then
66342: LD_VAR 0 5
66346: PUSH
66347: LD_INT 5
66349: GREATEREQUAL
66350: IFFALSE 66354
// break ;
66352: GO 66356
// end ;
66354: GO 66323
66356: POP
66357: POP
// end ; if not tmp then
66358: LD_VAR 0 5
66362: NOT
66363: IFFALSE 66367
// continue ;
66365: GO 65579
// for j in tmp do
66367: LD_ADDR_VAR 0 3
66371: PUSH
66372: LD_VAR 0 5
66376: PUSH
66377: FOR_IN
66378: IFFALSE 66468
// if not GetTag ( j ) then
66380: LD_VAR 0 3
66384: PPUSH
66385: CALL_OW 110
66389: NOT
66390: IFFALSE 66466
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66392: LD_ADDR_EXP 76
66396: PUSH
66397: LD_EXP 76
66401: PPUSH
66402: LD_VAR 0 2
66406: PUSH
66407: LD_EXP 76
66411: PUSH
66412: LD_VAR 0 2
66416: ARRAY
66417: PUSH
66418: LD_INT 1
66420: PLUS
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PPUSH
66426: LD_VAR 0 3
66430: PPUSH
66431: CALL 19686 0 3
66435: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66436: LD_VAR 0 3
66440: PPUSH
66441: LD_INT 107
66443: PPUSH
66444: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66448: LD_EXP 76
66452: PUSH
66453: LD_VAR 0 2
66457: ARRAY
66458: PUSH
66459: LD_INT 5
66461: GREATEREQUAL
66462: IFFALSE 66466
// break ;
66464: GO 66468
// end ;
66466: GO 66377
66468: POP
66469: POP
// end ; if mc_crates_collector [ i ] and target then
66470: LD_EXP 76
66474: PUSH
66475: LD_VAR 0 2
66479: ARRAY
66480: PUSH
66481: LD_VAR 0 6
66485: AND
66486: IFFALSE 66729
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66488: LD_EXP 76
66492: PUSH
66493: LD_VAR 0 2
66497: ARRAY
66498: PUSH
66499: LD_VAR 0 6
66503: PUSH
66504: LD_INT 1
66506: ARRAY
66507: LESS
66508: IFFALSE 66528
// tmp := mc_crates_collector [ i ] else
66510: LD_ADDR_VAR 0 5
66514: PUSH
66515: LD_EXP 76
66519: PUSH
66520: LD_VAR 0 2
66524: ARRAY
66525: ST_TO_ADDR
66526: GO 66542
// tmp := target [ 1 ] ;
66528: LD_ADDR_VAR 0 5
66532: PUSH
66533: LD_VAR 0 6
66537: PUSH
66538: LD_INT 1
66540: ARRAY
66541: ST_TO_ADDR
// k := 0 ;
66542: LD_ADDR_VAR 0 4
66546: PUSH
66547: LD_INT 0
66549: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66550: LD_ADDR_VAR 0 3
66554: PUSH
66555: LD_EXP 76
66559: PUSH
66560: LD_VAR 0 2
66564: ARRAY
66565: PUSH
66566: FOR_IN
66567: IFFALSE 66727
// begin k := k + 1 ;
66569: LD_ADDR_VAR 0 4
66573: PUSH
66574: LD_VAR 0 4
66578: PUSH
66579: LD_INT 1
66581: PLUS
66582: ST_TO_ADDR
// if k > tmp then
66583: LD_VAR 0 4
66587: PUSH
66588: LD_VAR 0 5
66592: GREATER
66593: IFFALSE 66597
// break ;
66595: GO 66727
// if not GetClass ( j ) in [ 2 , 16 ] then
66597: LD_VAR 0 3
66601: PPUSH
66602: CALL_OW 257
66606: PUSH
66607: LD_INT 2
66609: PUSH
66610: LD_INT 16
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: IN
66617: NOT
66618: IFFALSE 66671
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66620: LD_ADDR_EXP 76
66624: PUSH
66625: LD_EXP 76
66629: PPUSH
66630: LD_VAR 0 2
66634: PPUSH
66635: LD_EXP 76
66639: PUSH
66640: LD_VAR 0 2
66644: ARRAY
66645: PUSH
66646: LD_VAR 0 3
66650: DIFF
66651: PPUSH
66652: CALL_OW 1
66656: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66657: LD_VAR 0 3
66661: PPUSH
66662: LD_INT 0
66664: PPUSH
66665: CALL_OW 109
// continue ;
66669: GO 66566
// end ; if IsInUnit ( j ) then
66671: LD_VAR 0 3
66675: PPUSH
66676: CALL_OW 310
66680: IFFALSE 66691
// ComExitBuilding ( j ) ;
66682: LD_VAR 0 3
66686: PPUSH
66687: CALL_OW 122
// wait ( 3 ) ;
66691: LD_INT 3
66693: PPUSH
66694: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66698: LD_VAR 0 3
66702: PPUSH
66703: LD_VAR 0 6
66707: PUSH
66708: LD_INT 2
66710: ARRAY
66711: PPUSH
66712: LD_VAR 0 6
66716: PUSH
66717: LD_INT 3
66719: ARRAY
66720: PPUSH
66721: CALL_OW 117
// end ;
66725: GO 66566
66727: POP
66728: POP
// end ; end else
66729: GO 67310
// begin for j in cargo do
66731: LD_ADDR_VAR 0 3
66735: PUSH
66736: LD_VAR 0 7
66740: PUSH
66741: FOR_IN
66742: IFFALSE 67308
// begin if GetTag ( j ) <> 0 then
66744: LD_VAR 0 3
66748: PPUSH
66749: CALL_OW 110
66753: PUSH
66754: LD_INT 0
66756: NONEQUAL
66757: IFFALSE 66761
// continue ;
66759: GO 66741
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66761: LD_VAR 0 3
66765: PPUSH
66766: CALL_OW 256
66770: PUSH
66771: LD_INT 1000
66773: LESS
66774: PUSH
66775: LD_VAR 0 3
66779: PPUSH
66780: LD_EXP 83
66784: PUSH
66785: LD_VAR 0 2
66789: ARRAY
66790: PPUSH
66791: CALL_OW 308
66795: NOT
66796: AND
66797: IFFALSE 66819
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66799: LD_VAR 0 3
66803: PPUSH
66804: LD_EXP 83
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PPUSH
66815: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66819: LD_VAR 0 3
66823: PPUSH
66824: CALL_OW 256
66828: PUSH
66829: LD_INT 1000
66831: LESS
66832: PUSH
66833: LD_VAR 0 3
66837: PPUSH
66838: LD_EXP 83
66842: PUSH
66843: LD_VAR 0 2
66847: ARRAY
66848: PPUSH
66849: CALL_OW 308
66853: AND
66854: IFFALSE 66858
// continue ;
66856: GO 66741
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66858: LD_VAR 0 3
66862: PPUSH
66863: CALL_OW 262
66867: PUSH
66868: LD_INT 2
66870: EQUAL
66871: PUSH
66872: LD_VAR 0 3
66876: PPUSH
66877: CALL_OW 261
66881: PUSH
66882: LD_INT 15
66884: LESS
66885: AND
66886: IFFALSE 66890
// continue ;
66888: GO 66741
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66890: LD_VAR 0 3
66894: PPUSH
66895: CALL_OW 262
66899: PUSH
66900: LD_INT 1
66902: EQUAL
66903: PUSH
66904: LD_VAR 0 3
66908: PPUSH
66909: CALL_OW 261
66913: PUSH
66914: LD_INT 10
66916: LESS
66917: AND
66918: IFFALSE 67247
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66920: LD_ADDR_VAR 0 8
66924: PUSH
66925: LD_EXP 59
66929: PUSH
66930: LD_VAR 0 2
66934: ARRAY
66935: PPUSH
66936: LD_INT 2
66938: PUSH
66939: LD_INT 30
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 30
66951: PUSH
66952: LD_INT 1
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: LIST
66963: PPUSH
66964: CALL_OW 72
66968: ST_TO_ADDR
// if not depot then
66969: LD_VAR 0 8
66973: NOT
66974: IFFALSE 66978
// continue ;
66976: GO 66741
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66978: LD_VAR 0 3
66982: PPUSH
66983: LD_VAR 0 8
66987: PPUSH
66988: LD_VAR 0 3
66992: PPUSH
66993: CALL_OW 74
66997: PPUSH
66998: CALL_OW 296
67002: PUSH
67003: LD_INT 6
67005: LESS
67006: IFFALSE 67022
// SetFuel ( j , 100 ) else
67008: LD_VAR 0 3
67012: PPUSH
67013: LD_INT 100
67015: PPUSH
67016: CALL_OW 240
67020: GO 67247
// if GetFuel ( j ) = 0 then
67022: LD_VAR 0 3
67026: PPUSH
67027: CALL_OW 261
67031: PUSH
67032: LD_INT 0
67034: EQUAL
67035: IFFALSE 67247
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67037: LD_ADDR_EXP 78
67041: PUSH
67042: LD_EXP 78
67046: PPUSH
67047: LD_VAR 0 2
67051: PPUSH
67052: LD_EXP 78
67056: PUSH
67057: LD_VAR 0 2
67061: ARRAY
67062: PUSH
67063: LD_VAR 0 3
67067: DIFF
67068: PPUSH
67069: CALL_OW 1
67073: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67074: LD_VAR 0 3
67078: PPUSH
67079: CALL_OW 263
67083: PUSH
67084: LD_INT 1
67086: EQUAL
67087: IFFALSE 67103
// ComExitVehicle ( IsInUnit ( j ) ) ;
67089: LD_VAR 0 3
67093: PPUSH
67094: CALL_OW 310
67098: PPUSH
67099: CALL_OW 121
// if GetControl ( j ) = control_remote then
67103: LD_VAR 0 3
67107: PPUSH
67108: CALL_OW 263
67112: PUSH
67113: LD_INT 2
67115: EQUAL
67116: IFFALSE 67127
// ComUnlink ( j ) ;
67118: LD_VAR 0 3
67122: PPUSH
67123: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67127: LD_ADDR_VAR 0 9
67131: PUSH
67132: LD_VAR 0 2
67136: PPUSH
67137: LD_INT 3
67139: PPUSH
67140: CALL 76717 0 2
67144: ST_TO_ADDR
// if fac then
67145: LD_VAR 0 9
67149: IFFALSE 67245
// begin for k in fac do
67151: LD_ADDR_VAR 0 4
67155: PUSH
67156: LD_VAR 0 9
67160: PUSH
67161: FOR_IN
67162: IFFALSE 67243
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67164: LD_ADDR_VAR 0 10
67168: PUSH
67169: LD_VAR 0 9
67173: PPUSH
67174: LD_VAR 0 3
67178: PPUSH
67179: CALL_OW 265
67183: PPUSH
67184: LD_VAR 0 3
67188: PPUSH
67189: CALL_OW 262
67193: PPUSH
67194: LD_VAR 0 3
67198: PPUSH
67199: CALL_OW 263
67203: PPUSH
67204: LD_VAR 0 3
67208: PPUSH
67209: CALL_OW 264
67213: PPUSH
67214: CALL 17218 0 5
67218: ST_TO_ADDR
// if components then
67219: LD_VAR 0 10
67223: IFFALSE 67241
// begin MC_InsertProduceList ( i , components ) ;
67225: LD_VAR 0 2
67229: PPUSH
67230: LD_VAR 0 10
67234: PPUSH
67235: CALL 76262 0 2
// break ;
67239: GO 67243
// end ; end ;
67241: GO 67161
67243: POP
67244: POP
// end ; continue ;
67245: GO 66741
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67247: LD_VAR 0 3
67251: PPUSH
67252: LD_INT 1
67254: PPUSH
67255: CALL_OW 289
67259: PUSH
67260: LD_INT 100
67262: LESS
67263: PUSH
67264: LD_VAR 0 3
67268: PPUSH
67269: CALL_OW 314
67273: NOT
67274: AND
67275: IFFALSE 67304
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67277: LD_VAR 0 3
67281: PPUSH
67282: LD_VAR 0 6
67286: PUSH
67287: LD_INT 2
67289: ARRAY
67290: PPUSH
67291: LD_VAR 0 6
67295: PUSH
67296: LD_INT 3
67298: ARRAY
67299: PPUSH
67300: CALL_OW 117
// break ;
67304: GO 67308
// end ;
67306: GO 66741
67308: POP
67309: POP
// end ; end ;
67310: GO 65579
67312: POP
67313: POP
// end ;
67314: LD_VAR 0 1
67318: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67319: LD_INT 0
67321: PPUSH
67322: PPUSH
67323: PPUSH
67324: PPUSH
// if not mc_bases then
67325: LD_EXP 59
67329: NOT
67330: IFFALSE 67334
// exit ;
67332: GO 67495
// for i = 1 to mc_bases do
67334: LD_ADDR_VAR 0 2
67338: PUSH
67339: DOUBLE
67340: LD_INT 1
67342: DEC
67343: ST_TO_ADDR
67344: LD_EXP 59
67348: PUSH
67349: FOR_TO
67350: IFFALSE 67493
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67352: LD_ADDR_VAR 0 4
67356: PUSH
67357: LD_EXP 78
67361: PUSH
67362: LD_VAR 0 2
67366: ARRAY
67367: PUSH
67368: LD_EXP 81
67372: PUSH
67373: LD_VAR 0 2
67377: ARRAY
67378: UNION
67379: PPUSH
67380: LD_INT 33
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PPUSH
67390: CALL_OW 72
67394: ST_TO_ADDR
// if tmp then
67395: LD_VAR 0 4
67399: IFFALSE 67491
// for j in tmp do
67401: LD_ADDR_VAR 0 3
67405: PUSH
67406: LD_VAR 0 4
67410: PUSH
67411: FOR_IN
67412: IFFALSE 67489
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67414: LD_VAR 0 3
67418: PPUSH
67419: CALL_OW 312
67423: NOT
67424: PUSH
67425: LD_VAR 0 3
67429: PPUSH
67430: CALL_OW 256
67434: PUSH
67435: LD_INT 250
67437: GREATEREQUAL
67438: AND
67439: IFFALSE 67452
// Connect ( j ) else
67441: LD_VAR 0 3
67445: PPUSH
67446: CALL 22651 0 1
67450: GO 67487
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67452: LD_VAR 0 3
67456: PPUSH
67457: CALL_OW 256
67461: PUSH
67462: LD_INT 250
67464: LESS
67465: PUSH
67466: LD_VAR 0 3
67470: PPUSH
67471: CALL_OW 312
67475: AND
67476: IFFALSE 67487
// ComUnlink ( j ) ;
67478: LD_VAR 0 3
67482: PPUSH
67483: CALL_OW 136
67487: GO 67411
67489: POP
67490: POP
// end ;
67491: GO 67349
67493: POP
67494: POP
// end ;
67495: LD_VAR 0 1
67499: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67500: LD_INT 0
67502: PPUSH
67503: PPUSH
67504: PPUSH
67505: PPUSH
67506: PPUSH
// if not mc_bases then
67507: LD_EXP 59
67511: NOT
67512: IFFALSE 67516
// exit ;
67514: GO 67961
// for i = 1 to mc_bases do
67516: LD_ADDR_VAR 0 2
67520: PUSH
67521: DOUBLE
67522: LD_INT 1
67524: DEC
67525: ST_TO_ADDR
67526: LD_EXP 59
67530: PUSH
67531: FOR_TO
67532: IFFALSE 67959
// begin if not mc_produce [ i ] then
67534: LD_EXP 80
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: NOT
67545: IFFALSE 67549
// continue ;
67547: GO 67531
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67549: LD_ADDR_VAR 0 5
67553: PUSH
67554: LD_EXP 59
67558: PUSH
67559: LD_VAR 0 2
67563: ARRAY
67564: PPUSH
67565: LD_INT 30
67567: PUSH
67568: LD_INT 3
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PPUSH
67575: CALL_OW 72
67579: ST_TO_ADDR
// if not fac then
67580: LD_VAR 0 5
67584: NOT
67585: IFFALSE 67589
// continue ;
67587: GO 67531
// for j in fac do
67589: LD_ADDR_VAR 0 3
67593: PUSH
67594: LD_VAR 0 5
67598: PUSH
67599: FOR_IN
67600: IFFALSE 67955
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67602: LD_VAR 0 3
67606: PPUSH
67607: CALL_OW 461
67611: PUSH
67612: LD_INT 2
67614: NONEQUAL
67615: PUSH
67616: LD_VAR 0 3
67620: PPUSH
67621: LD_INT 15
67623: PPUSH
67624: CALL 22279 0 2
67628: PUSH
67629: LD_INT 4
67631: ARRAY
67632: OR
67633: IFFALSE 67637
// continue ;
67635: GO 67599
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67637: LD_VAR 0 3
67641: PPUSH
67642: LD_EXP 80
67646: PUSH
67647: LD_VAR 0 2
67651: ARRAY
67652: PUSH
67653: LD_INT 1
67655: ARRAY
67656: PUSH
67657: LD_INT 1
67659: ARRAY
67660: PPUSH
67661: LD_EXP 80
67665: PUSH
67666: LD_VAR 0 2
67670: ARRAY
67671: PUSH
67672: LD_INT 1
67674: ARRAY
67675: PUSH
67676: LD_INT 2
67678: ARRAY
67679: PPUSH
67680: LD_EXP 80
67684: PUSH
67685: LD_VAR 0 2
67689: ARRAY
67690: PUSH
67691: LD_INT 1
67693: ARRAY
67694: PUSH
67695: LD_INT 3
67697: ARRAY
67698: PPUSH
67699: LD_EXP 80
67703: PUSH
67704: LD_VAR 0 2
67708: ARRAY
67709: PUSH
67710: LD_INT 1
67712: ARRAY
67713: PUSH
67714: LD_INT 4
67716: ARRAY
67717: PPUSH
67718: CALL_OW 448
67722: PUSH
67723: LD_VAR 0 3
67727: PPUSH
67728: LD_EXP 80
67732: PUSH
67733: LD_VAR 0 2
67737: ARRAY
67738: PUSH
67739: LD_INT 1
67741: ARRAY
67742: PUSH
67743: LD_INT 1
67745: ARRAY
67746: PUSH
67747: LD_EXP 80
67751: PUSH
67752: LD_VAR 0 2
67756: ARRAY
67757: PUSH
67758: LD_INT 1
67760: ARRAY
67761: PUSH
67762: LD_INT 2
67764: ARRAY
67765: PUSH
67766: LD_EXP 80
67770: PUSH
67771: LD_VAR 0 2
67775: ARRAY
67776: PUSH
67777: LD_INT 1
67779: ARRAY
67780: PUSH
67781: LD_INT 3
67783: ARRAY
67784: PUSH
67785: LD_EXP 80
67789: PUSH
67790: LD_VAR 0 2
67794: ARRAY
67795: PUSH
67796: LD_INT 1
67798: ARRAY
67799: PUSH
67800: LD_INT 4
67802: ARRAY
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: PPUSH
67810: CALL 26047 0 2
67814: AND
67815: IFFALSE 67953
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67817: LD_VAR 0 3
67821: PPUSH
67822: LD_EXP 80
67826: PUSH
67827: LD_VAR 0 2
67831: ARRAY
67832: PUSH
67833: LD_INT 1
67835: ARRAY
67836: PUSH
67837: LD_INT 1
67839: ARRAY
67840: PPUSH
67841: LD_EXP 80
67845: PUSH
67846: LD_VAR 0 2
67850: ARRAY
67851: PUSH
67852: LD_INT 1
67854: ARRAY
67855: PUSH
67856: LD_INT 2
67858: ARRAY
67859: PPUSH
67860: LD_EXP 80
67864: PUSH
67865: LD_VAR 0 2
67869: ARRAY
67870: PUSH
67871: LD_INT 1
67873: ARRAY
67874: PUSH
67875: LD_INT 3
67877: ARRAY
67878: PPUSH
67879: LD_EXP 80
67883: PUSH
67884: LD_VAR 0 2
67888: ARRAY
67889: PUSH
67890: LD_INT 1
67892: ARRAY
67893: PUSH
67894: LD_INT 4
67896: ARRAY
67897: PPUSH
67898: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67902: LD_ADDR_VAR 0 4
67906: PUSH
67907: LD_EXP 80
67911: PUSH
67912: LD_VAR 0 2
67916: ARRAY
67917: PPUSH
67918: LD_INT 1
67920: PPUSH
67921: CALL_OW 3
67925: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67926: LD_ADDR_EXP 80
67930: PUSH
67931: LD_EXP 80
67935: PPUSH
67936: LD_VAR 0 2
67940: PPUSH
67941: LD_VAR 0 4
67945: PPUSH
67946: CALL_OW 1
67950: ST_TO_ADDR
// break ;
67951: GO 67955
// end ; end ;
67953: GO 67599
67955: POP
67956: POP
// end ;
67957: GO 67531
67959: POP
67960: POP
// end ;
67961: LD_VAR 0 1
67965: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67966: LD_INT 0
67968: PPUSH
67969: PPUSH
67970: PPUSH
// if not mc_bases then
67971: LD_EXP 59
67975: NOT
67976: IFFALSE 67980
// exit ;
67978: GO 68069
// for i = 1 to mc_bases do
67980: LD_ADDR_VAR 0 2
67984: PUSH
67985: DOUBLE
67986: LD_INT 1
67988: DEC
67989: ST_TO_ADDR
67990: LD_EXP 59
67994: PUSH
67995: FOR_TO
67996: IFFALSE 68067
// begin if mc_attack [ i ] then
67998: LD_EXP 79
68002: PUSH
68003: LD_VAR 0 2
68007: ARRAY
68008: IFFALSE 68065
// begin tmp := mc_attack [ i ] [ 1 ] ;
68010: LD_ADDR_VAR 0 3
68014: PUSH
68015: LD_EXP 79
68019: PUSH
68020: LD_VAR 0 2
68024: ARRAY
68025: PUSH
68026: LD_INT 1
68028: ARRAY
68029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68030: LD_ADDR_EXP 79
68034: PUSH
68035: LD_EXP 79
68039: PPUSH
68040: LD_VAR 0 2
68044: PPUSH
68045: EMPTY
68046: PPUSH
68047: CALL_OW 1
68051: ST_TO_ADDR
// Attack ( tmp ) ;
68052: LD_VAR 0 3
68056: PPUSH
68057: CALL 100014 0 1
// exit ;
68061: POP
68062: POP
68063: GO 68069
// end ; end ;
68065: GO 67995
68067: POP
68068: POP
// end ;
68069: LD_VAR 0 1
68073: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68074: LD_INT 0
68076: PPUSH
68077: PPUSH
68078: PPUSH
68079: PPUSH
68080: PPUSH
68081: PPUSH
68082: PPUSH
// if not mc_bases then
68083: LD_EXP 59
68087: NOT
68088: IFFALSE 68092
// exit ;
68090: GO 68791
// for i = 1 to mc_bases do
68092: LD_ADDR_VAR 0 2
68096: PUSH
68097: DOUBLE
68098: LD_INT 1
68100: DEC
68101: ST_TO_ADDR
68102: LD_EXP 59
68106: PUSH
68107: FOR_TO
68108: IFFALSE 68789
// begin if not mc_bases [ i ] then
68110: LD_EXP 59
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: NOT
68121: IFFALSE 68125
// continue ;
68123: GO 68107
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68125: LD_ADDR_VAR 0 7
68129: PUSH
68130: LD_EXP 59
68134: PUSH
68135: LD_VAR 0 2
68139: ARRAY
68140: PUSH
68141: LD_INT 1
68143: ARRAY
68144: PPUSH
68145: CALL 16522 0 1
68149: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68150: LD_ADDR_EXP 82
68154: PUSH
68155: LD_EXP 82
68159: PPUSH
68160: LD_VAR 0 2
68164: PPUSH
68165: LD_EXP 59
68169: PUSH
68170: LD_VAR 0 2
68174: ARRAY
68175: PUSH
68176: LD_INT 1
68178: ARRAY
68179: PPUSH
68180: CALL_OW 255
68184: PPUSH
68185: LD_EXP 84
68189: PUSH
68190: LD_VAR 0 2
68194: ARRAY
68195: PPUSH
68196: CALL 16487 0 2
68200: PPUSH
68201: CALL_OW 1
68205: ST_TO_ADDR
// if not mc_scan [ i ] then
68206: LD_EXP 82
68210: PUSH
68211: LD_VAR 0 2
68215: ARRAY
68216: NOT
68217: IFFALSE 68395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68219: LD_ADDR_VAR 0 4
68223: PUSH
68224: LD_EXP 59
68228: PUSH
68229: LD_VAR 0 2
68233: ARRAY
68234: PPUSH
68235: LD_INT 2
68237: PUSH
68238: LD_INT 25
68240: PUSH
68241: LD_INT 5
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 25
68250: PUSH
68251: LD_INT 8
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 25
68260: PUSH
68261: LD_INT 9
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: PPUSH
68274: CALL_OW 72
68278: ST_TO_ADDR
// if not tmp then
68279: LD_VAR 0 4
68283: NOT
68284: IFFALSE 68288
// continue ;
68286: GO 68107
// for j in tmp do
68288: LD_ADDR_VAR 0 3
68292: PUSH
68293: LD_VAR 0 4
68297: PUSH
68298: FOR_IN
68299: IFFALSE 68370
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68301: LD_VAR 0 3
68305: PPUSH
68306: CALL_OW 310
68310: PPUSH
68311: CALL_OW 266
68315: PUSH
68316: LD_INT 5
68318: EQUAL
68319: PUSH
68320: LD_VAR 0 3
68324: PPUSH
68325: CALL_OW 257
68329: PUSH
68330: LD_INT 1
68332: EQUAL
68333: AND
68334: PUSH
68335: LD_VAR 0 3
68339: PPUSH
68340: CALL_OW 459
68344: NOT
68345: AND
68346: PUSH
68347: LD_VAR 0 7
68351: AND
68352: IFFALSE 68368
// ComChangeProfession ( j , class ) ;
68354: LD_VAR 0 3
68358: PPUSH
68359: LD_VAR 0 7
68363: PPUSH
68364: CALL_OW 123
68368: GO 68298
68370: POP
68371: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68372: LD_ADDR_EXP 102
68376: PUSH
68377: LD_EXP 102
68381: PPUSH
68382: LD_VAR 0 2
68386: PPUSH
68387: LD_INT 0
68389: PPUSH
68390: CALL_OW 1
68394: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68395: LD_EXP 82
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: PUSH
68406: LD_EXP 102
68410: PUSH
68411: LD_VAR 0 2
68415: ARRAY
68416: NOT
68417: AND
68418: PUSH
68419: LD_EXP 81
68423: PUSH
68424: LD_VAR 0 2
68428: ARRAY
68429: NOT
68430: AND
68431: PUSH
68432: LD_EXP 59
68436: PUSH
68437: LD_VAR 0 2
68441: ARRAY
68442: PPUSH
68443: LD_INT 30
68445: PUSH
68446: LD_INT 32
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PPUSH
68453: CALL_OW 72
68457: NOT
68458: AND
68459: PUSH
68460: LD_EXP 59
68464: PUSH
68465: LD_VAR 0 2
68469: ARRAY
68470: PPUSH
68471: LD_INT 2
68473: PUSH
68474: LD_INT 30
68476: PUSH
68477: LD_INT 4
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 30
68486: PUSH
68487: LD_INT 5
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: LIST
68498: PPUSH
68499: CALL_OW 72
68503: NOT
68504: AND
68505: IFFALSE 68660
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68507: LD_ADDR_VAR 0 4
68511: PUSH
68512: LD_EXP 59
68516: PUSH
68517: LD_VAR 0 2
68521: ARRAY
68522: PPUSH
68523: LD_INT 2
68525: PUSH
68526: LD_INT 25
68528: PUSH
68529: LD_INT 1
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: LD_INT 25
68538: PUSH
68539: LD_INT 5
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 25
68548: PUSH
68549: LD_INT 8
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 25
68558: PUSH
68559: LD_INT 9
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: PPUSH
68573: CALL_OW 72
68577: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68578: LD_ADDR_VAR 0 4
68582: PUSH
68583: LD_VAR 0 4
68587: PUSH
68588: LD_VAR 0 4
68592: PPUSH
68593: LD_INT 18
68595: PPUSH
68596: CALL 48550 0 2
68600: DIFF
68601: ST_TO_ADDR
// if tmp then
68602: LD_VAR 0 4
68606: IFFALSE 68660
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68608: LD_ADDR_EXP 102
68612: PUSH
68613: LD_EXP 102
68617: PPUSH
68618: LD_VAR 0 2
68622: PPUSH
68623: LD_INT 1
68625: PPUSH
68626: CALL_OW 1
68630: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
68631: LD_VAR 0 2
68635: PPUSH
68636: LD_VAR 0 4
68640: PPUSH
68641: LD_EXP 84
68645: PUSH
68646: LD_VAR 0 2
68650: ARRAY
68651: PPUSH
68652: CALL 104723 0 3
// exit ;
68656: POP
68657: POP
68658: GO 68791
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68660: LD_EXP 82
68664: PUSH
68665: LD_VAR 0 2
68669: ARRAY
68670: PUSH
68671: LD_EXP 102
68675: PUSH
68676: LD_VAR 0 2
68680: ARRAY
68681: NOT
68682: AND
68683: PUSH
68684: LD_EXP 81
68688: PUSH
68689: LD_VAR 0 2
68693: ARRAY
68694: AND
68695: IFFALSE 68787
// begin tmp := mc_defender [ i ] ;
68697: LD_ADDR_VAR 0 4
68701: PUSH
68702: LD_EXP 81
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68713: LD_ADDR_EXP 81
68717: PUSH
68718: LD_EXP 81
68722: PPUSH
68723: LD_VAR 0 2
68727: PPUSH
68728: EMPTY
68729: PPUSH
68730: CALL_OW 1
68734: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68735: LD_ADDR_EXP 102
68739: PUSH
68740: LD_EXP 102
68744: PPUSH
68745: LD_VAR 0 2
68749: PPUSH
68750: LD_INT 1
68752: PPUSH
68753: CALL_OW 1
68757: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
68758: LD_VAR 0 2
68762: PPUSH
68763: LD_VAR 0 4
68767: PPUSH
68768: LD_EXP 82
68772: PUSH
68773: LD_VAR 0 2
68777: ARRAY
68778: PPUSH
68779: CALL 105284 0 3
// exit ;
68783: POP
68784: POP
68785: GO 68791
// end ; end ;
68787: GO 68107
68789: POP
68790: POP
// end ;
68791: LD_VAR 0 1
68795: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68796: LD_INT 0
68798: PPUSH
68799: PPUSH
68800: PPUSH
68801: PPUSH
68802: PPUSH
68803: PPUSH
68804: PPUSH
68805: PPUSH
68806: PPUSH
68807: PPUSH
68808: PPUSH
// if not mc_bases then
68809: LD_EXP 59
68813: NOT
68814: IFFALSE 68818
// exit ;
68816: GO 69905
// for i = 1 to mc_bases do
68818: LD_ADDR_VAR 0 2
68822: PUSH
68823: DOUBLE
68824: LD_INT 1
68826: DEC
68827: ST_TO_ADDR
68828: LD_EXP 59
68832: PUSH
68833: FOR_TO
68834: IFFALSE 69903
// begin tmp := mc_lab [ i ] ;
68836: LD_ADDR_VAR 0 6
68840: PUSH
68841: LD_EXP 92
68845: PUSH
68846: LD_VAR 0 2
68850: ARRAY
68851: ST_TO_ADDR
// if not tmp then
68852: LD_VAR 0 6
68856: NOT
68857: IFFALSE 68861
// continue ;
68859: GO 68833
// idle_lab := 0 ;
68861: LD_ADDR_VAR 0 11
68865: PUSH
68866: LD_INT 0
68868: ST_TO_ADDR
// for j in tmp do
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: LD_VAR 0 6
68878: PUSH
68879: FOR_IN
68880: IFFALSE 69899
// begin researching := false ;
68882: LD_ADDR_VAR 0 10
68886: PUSH
68887: LD_INT 0
68889: ST_TO_ADDR
// side := GetSide ( j ) ;
68890: LD_ADDR_VAR 0 4
68894: PUSH
68895: LD_VAR 0 3
68899: PPUSH
68900: CALL_OW 255
68904: ST_TO_ADDR
// if not mc_tech [ side ] then
68905: LD_EXP 86
68909: PUSH
68910: LD_VAR 0 4
68914: ARRAY
68915: NOT
68916: IFFALSE 68920
// continue ;
68918: GO 68879
// if BuildingStatus ( j ) = bs_idle then
68920: LD_VAR 0 3
68924: PPUSH
68925: CALL_OW 461
68929: PUSH
68930: LD_INT 2
68932: EQUAL
68933: IFFALSE 69121
// begin if idle_lab and UnitsInside ( j ) < 6 then
68935: LD_VAR 0 11
68939: PUSH
68940: LD_VAR 0 3
68944: PPUSH
68945: CALL_OW 313
68949: PUSH
68950: LD_INT 6
68952: LESS
68953: AND
68954: IFFALSE 69025
// begin tmp2 := UnitsInside ( idle_lab ) ;
68956: LD_ADDR_VAR 0 9
68960: PUSH
68961: LD_VAR 0 11
68965: PPUSH
68966: CALL_OW 313
68970: ST_TO_ADDR
// if tmp2 then
68971: LD_VAR 0 9
68975: IFFALSE 69017
// for x in tmp2 do
68977: LD_ADDR_VAR 0 7
68981: PUSH
68982: LD_VAR 0 9
68986: PUSH
68987: FOR_IN
68988: IFFALSE 69015
// begin ComExitBuilding ( x ) ;
68990: LD_VAR 0 7
68994: PPUSH
68995: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68999: LD_VAR 0 7
69003: PPUSH
69004: LD_VAR 0 3
69008: PPUSH
69009: CALL_OW 180
// end ;
69013: GO 68987
69015: POP
69016: POP
// idle_lab := 0 ;
69017: LD_ADDR_VAR 0 11
69021: PUSH
69022: LD_INT 0
69024: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69025: LD_ADDR_VAR 0 5
69029: PUSH
69030: LD_EXP 86
69034: PUSH
69035: LD_VAR 0 4
69039: ARRAY
69040: PUSH
69041: FOR_IN
69042: IFFALSE 69102
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69044: LD_VAR 0 3
69048: PPUSH
69049: LD_VAR 0 5
69053: PPUSH
69054: CALL_OW 430
69058: PUSH
69059: LD_VAR 0 4
69063: PPUSH
69064: LD_VAR 0 5
69068: PPUSH
69069: CALL 15592 0 2
69073: AND
69074: IFFALSE 69100
// begin researching := true ;
69076: LD_ADDR_VAR 0 10
69080: PUSH
69081: LD_INT 1
69083: ST_TO_ADDR
// ComResearch ( j , t ) ;
69084: LD_VAR 0 3
69088: PPUSH
69089: LD_VAR 0 5
69093: PPUSH
69094: CALL_OW 124
// break ;
69098: GO 69102
// end ;
69100: GO 69041
69102: POP
69103: POP
// if not researching then
69104: LD_VAR 0 10
69108: NOT
69109: IFFALSE 69121
// idle_lab := j ;
69111: LD_ADDR_VAR 0 11
69115: PUSH
69116: LD_VAR 0 3
69120: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69121: LD_VAR 0 3
69125: PPUSH
69126: CALL_OW 461
69130: PUSH
69131: LD_INT 10
69133: EQUAL
69134: IFFALSE 69722
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69136: LD_EXP 88
69140: PUSH
69141: LD_VAR 0 2
69145: ARRAY
69146: NOT
69147: PUSH
69148: LD_EXP 89
69152: PUSH
69153: LD_VAR 0 2
69157: ARRAY
69158: NOT
69159: AND
69160: PUSH
69161: LD_EXP 86
69165: PUSH
69166: LD_VAR 0 4
69170: ARRAY
69171: PUSH
69172: LD_INT 1
69174: GREATER
69175: AND
69176: IFFALSE 69307
// begin ComCancel ( j ) ;
69178: LD_VAR 0 3
69182: PPUSH
69183: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69187: LD_ADDR_EXP 86
69191: PUSH
69192: LD_EXP 86
69196: PPUSH
69197: LD_VAR 0 4
69201: PPUSH
69202: LD_EXP 86
69206: PUSH
69207: LD_VAR 0 4
69211: ARRAY
69212: PPUSH
69213: LD_EXP 86
69217: PUSH
69218: LD_VAR 0 4
69222: ARRAY
69223: PUSH
69224: LD_INT 1
69226: MINUS
69227: PPUSH
69228: LD_EXP 86
69232: PUSH
69233: LD_VAR 0 4
69237: ARRAY
69238: PPUSH
69239: LD_INT 0
69241: PPUSH
69242: CALL 19104 0 4
69246: PPUSH
69247: CALL_OW 1
69251: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69252: LD_ADDR_EXP 86
69256: PUSH
69257: LD_EXP 86
69261: PPUSH
69262: LD_VAR 0 4
69266: PPUSH
69267: LD_EXP 86
69271: PUSH
69272: LD_VAR 0 4
69276: ARRAY
69277: PPUSH
69278: LD_EXP 86
69282: PUSH
69283: LD_VAR 0 4
69287: ARRAY
69288: PPUSH
69289: LD_INT 1
69291: PPUSH
69292: LD_INT 0
69294: PPUSH
69295: CALL 19104 0 4
69299: PPUSH
69300: CALL_OW 1
69304: ST_TO_ADDR
// continue ;
69305: GO 68879
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69307: LD_EXP 88
69311: PUSH
69312: LD_VAR 0 2
69316: ARRAY
69317: PUSH
69318: LD_EXP 89
69322: PUSH
69323: LD_VAR 0 2
69327: ARRAY
69328: NOT
69329: AND
69330: IFFALSE 69457
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69332: LD_ADDR_EXP 89
69336: PUSH
69337: LD_EXP 89
69341: PPUSH
69342: LD_VAR 0 2
69346: PUSH
69347: LD_EXP 89
69351: PUSH
69352: LD_VAR 0 2
69356: ARRAY
69357: PUSH
69358: LD_INT 1
69360: PLUS
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PPUSH
69366: LD_EXP 88
69370: PUSH
69371: LD_VAR 0 2
69375: ARRAY
69376: PUSH
69377: LD_INT 1
69379: ARRAY
69380: PPUSH
69381: CALL 19686 0 3
69385: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69386: LD_EXP 88
69390: PUSH
69391: LD_VAR 0 2
69395: ARRAY
69396: PUSH
69397: LD_INT 1
69399: ARRAY
69400: PPUSH
69401: LD_INT 112
69403: PPUSH
69404: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69408: LD_ADDR_VAR 0 9
69412: PUSH
69413: LD_EXP 88
69417: PUSH
69418: LD_VAR 0 2
69422: ARRAY
69423: PPUSH
69424: LD_INT 1
69426: PPUSH
69427: CALL_OW 3
69431: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69432: LD_ADDR_EXP 88
69436: PUSH
69437: LD_EXP 88
69441: PPUSH
69442: LD_VAR 0 2
69446: PPUSH
69447: LD_VAR 0 9
69451: PPUSH
69452: CALL_OW 1
69456: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69457: LD_EXP 88
69461: PUSH
69462: LD_VAR 0 2
69466: ARRAY
69467: PUSH
69468: LD_EXP 89
69472: PUSH
69473: LD_VAR 0 2
69477: ARRAY
69478: AND
69479: PUSH
69480: LD_EXP 89
69484: PUSH
69485: LD_VAR 0 2
69489: ARRAY
69490: PUSH
69491: LD_INT 1
69493: ARRAY
69494: PPUSH
69495: CALL_OW 310
69499: NOT
69500: AND
69501: PUSH
69502: LD_VAR 0 3
69506: PPUSH
69507: CALL_OW 313
69511: PUSH
69512: LD_INT 6
69514: EQUAL
69515: AND
69516: IFFALSE 69572
// begin tmp2 := UnitsInside ( j ) ;
69518: LD_ADDR_VAR 0 9
69522: PUSH
69523: LD_VAR 0 3
69527: PPUSH
69528: CALL_OW 313
69532: ST_TO_ADDR
// if tmp2 = 6 then
69533: LD_VAR 0 9
69537: PUSH
69538: LD_INT 6
69540: EQUAL
69541: IFFALSE 69572
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69543: LD_VAR 0 9
69547: PUSH
69548: LD_INT 1
69550: ARRAY
69551: PPUSH
69552: LD_INT 112
69554: PPUSH
69555: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69559: LD_VAR 0 9
69563: PUSH
69564: LD_INT 1
69566: ARRAY
69567: PPUSH
69568: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69572: LD_EXP 89
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: PUSH
69583: LD_EXP 89
69587: PUSH
69588: LD_VAR 0 2
69592: ARRAY
69593: PUSH
69594: LD_INT 1
69596: ARRAY
69597: PPUSH
69598: CALL_OW 314
69602: NOT
69603: AND
69604: PUSH
69605: LD_EXP 89
69609: PUSH
69610: LD_VAR 0 2
69614: ARRAY
69615: PUSH
69616: LD_INT 1
69618: ARRAY
69619: PPUSH
69620: CALL_OW 310
69624: NOT
69625: AND
69626: IFFALSE 69652
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69628: LD_EXP 89
69632: PUSH
69633: LD_VAR 0 2
69637: ARRAY
69638: PUSH
69639: LD_INT 1
69641: ARRAY
69642: PPUSH
69643: LD_VAR 0 3
69647: PPUSH
69648: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69652: LD_EXP 89
69656: PUSH
69657: LD_VAR 0 2
69661: ARRAY
69662: PUSH
69663: LD_INT 1
69665: ARRAY
69666: PPUSH
69667: CALL_OW 310
69671: PUSH
69672: LD_EXP 89
69676: PUSH
69677: LD_VAR 0 2
69681: ARRAY
69682: PUSH
69683: LD_INT 1
69685: ARRAY
69686: PPUSH
69687: CALL_OW 310
69691: PPUSH
69692: CALL_OW 461
69696: PUSH
69697: LD_INT 3
69699: NONEQUAL
69700: AND
69701: IFFALSE 69722
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69703: LD_EXP 89
69707: PUSH
69708: LD_VAR 0 2
69712: ARRAY
69713: PUSH
69714: LD_INT 1
69716: ARRAY
69717: PPUSH
69718: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69722: LD_VAR 0 3
69726: PPUSH
69727: CALL_OW 461
69731: PUSH
69732: LD_INT 6
69734: EQUAL
69735: PUSH
69736: LD_VAR 0 6
69740: PUSH
69741: LD_INT 1
69743: GREATER
69744: AND
69745: IFFALSE 69897
// begin sci := [ ] ;
69747: LD_ADDR_VAR 0 8
69751: PUSH
69752: EMPTY
69753: ST_TO_ADDR
// for x in ( tmp diff j ) do
69754: LD_ADDR_VAR 0 7
69758: PUSH
69759: LD_VAR 0 6
69763: PUSH
69764: LD_VAR 0 3
69768: DIFF
69769: PUSH
69770: FOR_IN
69771: IFFALSE 69823
// begin if sci = 6 then
69773: LD_VAR 0 8
69777: PUSH
69778: LD_INT 6
69780: EQUAL
69781: IFFALSE 69785
// break ;
69783: GO 69823
// if BuildingStatus ( x ) = bs_idle then
69785: LD_VAR 0 7
69789: PPUSH
69790: CALL_OW 461
69794: PUSH
69795: LD_INT 2
69797: EQUAL
69798: IFFALSE 69821
// sci := sci ^ UnitsInside ( x ) ;
69800: LD_ADDR_VAR 0 8
69804: PUSH
69805: LD_VAR 0 8
69809: PUSH
69810: LD_VAR 0 7
69814: PPUSH
69815: CALL_OW 313
69819: ADD
69820: ST_TO_ADDR
// end ;
69821: GO 69770
69823: POP
69824: POP
// if not sci then
69825: LD_VAR 0 8
69829: NOT
69830: IFFALSE 69834
// continue ;
69832: GO 68879
// for x in sci do
69834: LD_ADDR_VAR 0 7
69838: PUSH
69839: LD_VAR 0 8
69843: PUSH
69844: FOR_IN
69845: IFFALSE 69895
// if IsInUnit ( x ) and not HasTask ( x ) then
69847: LD_VAR 0 7
69851: PPUSH
69852: CALL_OW 310
69856: PUSH
69857: LD_VAR 0 7
69861: PPUSH
69862: CALL_OW 314
69866: NOT
69867: AND
69868: IFFALSE 69893
// begin ComExitBuilding ( x ) ;
69870: LD_VAR 0 7
69874: PPUSH
69875: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69879: LD_VAR 0 7
69883: PPUSH
69884: LD_VAR 0 3
69888: PPUSH
69889: CALL_OW 180
// end ;
69893: GO 69844
69895: POP
69896: POP
// end ; end ;
69897: GO 68879
69899: POP
69900: POP
// end ;
69901: GO 68833
69903: POP
69904: POP
// end ;
69905: LD_VAR 0 1
69909: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69910: LD_INT 0
69912: PPUSH
69913: PPUSH
// if not mc_bases then
69914: LD_EXP 59
69918: NOT
69919: IFFALSE 69923
// exit ;
69921: GO 70004
// for i = 1 to mc_bases do
69923: LD_ADDR_VAR 0 2
69927: PUSH
69928: DOUBLE
69929: LD_INT 1
69931: DEC
69932: ST_TO_ADDR
69933: LD_EXP 59
69937: PUSH
69938: FOR_TO
69939: IFFALSE 70002
// if mc_mines [ i ] and mc_miners [ i ] then
69941: LD_EXP 72
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_EXP 73
69956: PUSH
69957: LD_VAR 0 2
69961: ARRAY
69962: AND
69963: IFFALSE 70000
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69965: LD_EXP 73
69969: PUSH
69970: LD_VAR 0 2
69974: ARRAY
69975: PUSH
69976: LD_INT 1
69978: ARRAY
69979: PPUSH
69980: CALL_OW 255
69984: PPUSH
69985: LD_EXP 72
69989: PUSH
69990: LD_VAR 0 2
69994: ARRAY
69995: PPUSH
69996: CALL 16675 0 2
70000: GO 69938
70002: POP
70003: POP
// end ;
70004: LD_VAR 0 1
70008: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70009: LD_INT 0
70011: PPUSH
70012: PPUSH
70013: PPUSH
70014: PPUSH
70015: PPUSH
70016: PPUSH
70017: PPUSH
70018: PPUSH
// if not mc_bases or not mc_parking then
70019: LD_EXP 59
70023: NOT
70024: PUSH
70025: LD_EXP 83
70029: NOT
70030: OR
70031: IFFALSE 70035
// exit ;
70033: GO 70734
// for i = 1 to mc_bases do
70035: LD_ADDR_VAR 0 2
70039: PUSH
70040: DOUBLE
70041: LD_INT 1
70043: DEC
70044: ST_TO_ADDR
70045: LD_EXP 59
70049: PUSH
70050: FOR_TO
70051: IFFALSE 70732
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70053: LD_EXP 59
70057: PUSH
70058: LD_VAR 0 2
70062: ARRAY
70063: NOT
70064: PUSH
70065: LD_EXP 83
70069: PUSH
70070: LD_VAR 0 2
70074: ARRAY
70075: NOT
70076: OR
70077: IFFALSE 70081
// continue ;
70079: GO 70050
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70081: LD_ADDR_VAR 0 5
70085: PUSH
70086: LD_EXP 59
70090: PUSH
70091: LD_VAR 0 2
70095: ARRAY
70096: PUSH
70097: LD_INT 1
70099: ARRAY
70100: PPUSH
70101: CALL_OW 255
70105: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70106: LD_ADDR_VAR 0 6
70110: PUSH
70111: LD_EXP 59
70115: PUSH
70116: LD_VAR 0 2
70120: ARRAY
70121: PPUSH
70122: LD_INT 30
70124: PUSH
70125: LD_INT 3
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PPUSH
70132: CALL_OW 72
70136: ST_TO_ADDR
// if not fac then
70137: LD_VAR 0 6
70141: NOT
70142: IFFALSE 70193
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70144: LD_ADDR_VAR 0 6
70148: PUSH
70149: LD_EXP 59
70153: PUSH
70154: LD_VAR 0 2
70158: ARRAY
70159: PPUSH
70160: LD_INT 2
70162: PUSH
70163: LD_INT 30
70165: PUSH
70166: LD_INT 0
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 30
70175: PUSH
70176: LD_INT 1
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: LIST
70187: PPUSH
70188: CALL_OW 72
70192: ST_TO_ADDR
// if not fac then
70193: LD_VAR 0 6
70197: NOT
70198: IFFALSE 70202
// continue ;
70200: GO 70050
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70202: LD_ADDR_VAR 0 7
70206: PUSH
70207: LD_EXP 83
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: PPUSH
70218: LD_INT 22
70220: PUSH
70221: LD_VAR 0 5
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 21
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 3
70242: PUSH
70243: LD_INT 24
70245: PUSH
70246: LD_INT 1000
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: LIST
70261: PPUSH
70262: CALL_OW 70
70266: ST_TO_ADDR
// for j in fac do
70267: LD_ADDR_VAR 0 3
70271: PUSH
70272: LD_VAR 0 6
70276: PUSH
70277: FOR_IN
70278: IFFALSE 70359
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70280: LD_ADDR_VAR 0 7
70284: PUSH
70285: LD_VAR 0 7
70289: PUSH
70290: LD_INT 22
70292: PUSH
70293: LD_VAR 0 5
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 91
70304: PUSH
70305: LD_VAR 0 3
70309: PUSH
70310: LD_INT 15
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 21
70320: PUSH
70321: LD_INT 2
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 3
70330: PUSH
70331: LD_INT 24
70333: PUSH
70334: LD_INT 1000
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: LIST
70349: LIST
70350: PPUSH
70351: CALL_OW 69
70355: UNION
70356: ST_TO_ADDR
70357: GO 70277
70359: POP
70360: POP
// if not vehs then
70361: LD_VAR 0 7
70365: NOT
70366: IFFALSE 70392
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70368: LD_ADDR_EXP 71
70372: PUSH
70373: LD_EXP 71
70377: PPUSH
70378: LD_VAR 0 2
70382: PPUSH
70383: EMPTY
70384: PPUSH
70385: CALL_OW 1
70389: ST_TO_ADDR
// continue ;
70390: GO 70050
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70392: LD_ADDR_VAR 0 8
70396: PUSH
70397: LD_EXP 59
70401: PUSH
70402: LD_VAR 0 2
70406: ARRAY
70407: PPUSH
70408: LD_INT 30
70410: PUSH
70411: LD_INT 3
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PPUSH
70418: CALL_OW 72
70422: ST_TO_ADDR
// if tmp then
70423: LD_VAR 0 8
70427: IFFALSE 70530
// begin for j in tmp do
70429: LD_ADDR_VAR 0 3
70433: PUSH
70434: LD_VAR 0 8
70438: PUSH
70439: FOR_IN
70440: IFFALSE 70528
// for k in UnitsInside ( j ) do
70442: LD_ADDR_VAR 0 4
70446: PUSH
70447: LD_VAR 0 3
70451: PPUSH
70452: CALL_OW 313
70456: PUSH
70457: FOR_IN
70458: IFFALSE 70524
// if k then
70460: LD_VAR 0 4
70464: IFFALSE 70522
// if not k in mc_repair_vehicle [ i ] then
70466: LD_VAR 0 4
70470: PUSH
70471: LD_EXP 71
70475: PUSH
70476: LD_VAR 0 2
70480: ARRAY
70481: IN
70482: NOT
70483: IFFALSE 70522
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70485: LD_ADDR_EXP 71
70489: PUSH
70490: LD_EXP 71
70494: PPUSH
70495: LD_VAR 0 2
70499: PPUSH
70500: LD_EXP 71
70504: PUSH
70505: LD_VAR 0 2
70509: ARRAY
70510: PUSH
70511: LD_VAR 0 4
70515: UNION
70516: PPUSH
70517: CALL_OW 1
70521: ST_TO_ADDR
70522: GO 70457
70524: POP
70525: POP
70526: GO 70439
70528: POP
70529: POP
// end ; if not mc_repair_vehicle [ i ] then
70530: LD_EXP 71
70534: PUSH
70535: LD_VAR 0 2
70539: ARRAY
70540: NOT
70541: IFFALSE 70545
// continue ;
70543: GO 70050
// for j in mc_repair_vehicle [ i ] do
70545: LD_ADDR_VAR 0 3
70549: PUSH
70550: LD_EXP 71
70554: PUSH
70555: LD_VAR 0 2
70559: ARRAY
70560: PUSH
70561: FOR_IN
70562: IFFALSE 70728
// begin if GetClass ( j ) <> 3 then
70564: LD_VAR 0 3
70568: PPUSH
70569: CALL_OW 257
70573: PUSH
70574: LD_INT 3
70576: NONEQUAL
70577: IFFALSE 70618
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70579: LD_ADDR_EXP 71
70583: PUSH
70584: LD_EXP 71
70588: PPUSH
70589: LD_VAR 0 2
70593: PPUSH
70594: LD_EXP 71
70598: PUSH
70599: LD_VAR 0 2
70603: ARRAY
70604: PUSH
70605: LD_VAR 0 3
70609: DIFF
70610: PPUSH
70611: CALL_OW 1
70615: ST_TO_ADDR
// continue ;
70616: GO 70561
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70618: LD_VAR 0 3
70622: PPUSH
70623: CALL_OW 311
70627: NOT
70628: PUSH
70629: LD_VAR 0 3
70633: PUSH
70634: LD_EXP 62
70638: PUSH
70639: LD_VAR 0 2
70643: ARRAY
70644: PUSH
70645: LD_INT 1
70647: ARRAY
70648: IN
70649: NOT
70650: AND
70651: PUSH
70652: LD_VAR 0 3
70656: PUSH
70657: LD_EXP 62
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: PUSH
70668: LD_INT 2
70670: ARRAY
70671: IN
70672: NOT
70673: AND
70674: IFFALSE 70726
// begin if IsInUnit ( j ) then
70676: LD_VAR 0 3
70680: PPUSH
70681: CALL_OW 310
70685: IFFALSE 70696
// ComExitBuilding ( j ) ;
70687: LD_VAR 0 3
70691: PPUSH
70692: CALL_OW 122
// if not HasTask ( j ) then
70696: LD_VAR 0 3
70700: PPUSH
70701: CALL_OW 314
70705: NOT
70706: IFFALSE 70726
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
70708: LD_VAR 0 3
70712: PPUSH
70713: LD_VAR 0 7
70717: PUSH
70718: LD_INT 1
70720: ARRAY
70721: PPUSH
70722: CALL_OW 189
// end ; end ;
70726: GO 70561
70728: POP
70729: POP
// end ;
70730: GO 70050
70732: POP
70733: POP
// end ;
70734: LD_VAR 0 1
70738: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70739: LD_INT 0
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
70745: PPUSH
70746: PPUSH
70747: PPUSH
70748: PPUSH
70749: PPUSH
70750: PPUSH
70751: PPUSH
// if not mc_bases then
70752: LD_EXP 59
70756: NOT
70757: IFFALSE 70761
// exit ;
70759: GO 71563
// for i = 1 to mc_bases do
70761: LD_ADDR_VAR 0 2
70765: PUSH
70766: DOUBLE
70767: LD_INT 1
70769: DEC
70770: ST_TO_ADDR
70771: LD_EXP 59
70775: PUSH
70776: FOR_TO
70777: IFFALSE 71561
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70779: LD_EXP 87
70783: PUSH
70784: LD_VAR 0 2
70788: ARRAY
70789: NOT
70790: PUSH
70791: LD_EXP 62
70795: PUSH
70796: LD_VAR 0 2
70800: ARRAY
70801: PUSH
70802: LD_INT 1
70804: ARRAY
70805: OR
70806: PUSH
70807: LD_EXP 62
70811: PUSH
70812: LD_VAR 0 2
70816: ARRAY
70817: PUSH
70818: LD_INT 2
70820: ARRAY
70821: OR
70822: PUSH
70823: LD_EXP 85
70827: PUSH
70828: LD_VAR 0 2
70832: ARRAY
70833: PPUSH
70834: LD_INT 1
70836: PPUSH
70837: CALL_OW 325
70841: NOT
70842: OR
70843: PUSH
70844: LD_EXP 82
70848: PUSH
70849: LD_VAR 0 2
70853: ARRAY
70854: OR
70855: IFFALSE 70859
// continue ;
70857: GO 70776
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70859: LD_ADDR_VAR 0 8
70863: PUSH
70864: LD_EXP 59
70868: PUSH
70869: LD_VAR 0 2
70873: ARRAY
70874: PPUSH
70875: LD_INT 25
70877: PUSH
70878: LD_INT 4
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 50
70887: PUSH
70888: EMPTY
70889: LIST
70890: PUSH
70891: LD_INT 3
70893: PUSH
70894: LD_INT 60
70896: PUSH
70897: EMPTY
70898: LIST
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: LIST
70908: PPUSH
70909: CALL_OW 72
70913: PUSH
70914: LD_EXP 63
70918: PUSH
70919: LD_VAR 0 2
70923: ARRAY
70924: DIFF
70925: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70926: LD_ADDR_VAR 0 9
70930: PUSH
70931: LD_EXP 59
70935: PUSH
70936: LD_VAR 0 2
70940: ARRAY
70941: PPUSH
70942: LD_INT 2
70944: PUSH
70945: LD_INT 30
70947: PUSH
70948: LD_INT 0
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 30
70957: PUSH
70958: LD_INT 1
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: LIST
70969: PPUSH
70970: CALL_OW 72
70974: ST_TO_ADDR
// if not tmp or not dep then
70975: LD_VAR 0 8
70979: NOT
70980: PUSH
70981: LD_VAR 0 9
70985: NOT
70986: OR
70987: IFFALSE 70991
// continue ;
70989: GO 70776
// side := GetSide ( tmp [ 1 ] ) ;
70991: LD_ADDR_VAR 0 11
70995: PUSH
70996: LD_VAR 0 8
71000: PUSH
71001: LD_INT 1
71003: ARRAY
71004: PPUSH
71005: CALL_OW 255
71009: ST_TO_ADDR
// dep := dep [ 1 ] ;
71010: LD_ADDR_VAR 0 9
71014: PUSH
71015: LD_VAR 0 9
71019: PUSH
71020: LD_INT 1
71022: ARRAY
71023: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71024: LD_ADDR_VAR 0 7
71028: PUSH
71029: LD_EXP 87
71033: PUSH
71034: LD_VAR 0 2
71038: ARRAY
71039: PPUSH
71040: LD_INT 22
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 25
71052: PUSH
71053: LD_INT 12
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PPUSH
71064: CALL_OW 70
71068: PUSH
71069: LD_INT 22
71071: PUSH
71072: LD_INT 0
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 25
71081: PUSH
71082: LD_INT 12
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 91
71091: PUSH
71092: LD_VAR 0 9
71096: PUSH
71097: LD_INT 20
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: LIST
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: LIST
71109: PPUSH
71110: CALL_OW 69
71114: UNION
71115: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71116: LD_ADDR_VAR 0 10
71120: PUSH
71121: LD_EXP 87
71125: PUSH
71126: LD_VAR 0 2
71130: ARRAY
71131: PPUSH
71132: LD_INT 81
71134: PUSH
71135: LD_VAR 0 11
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PPUSH
71144: CALL_OW 70
71148: ST_TO_ADDR
// if not apes or danger_at_area then
71149: LD_VAR 0 7
71153: NOT
71154: PUSH
71155: LD_VAR 0 10
71159: OR
71160: IFFALSE 71210
// begin if mc_taming [ i ] then
71162: LD_EXP 90
71166: PUSH
71167: LD_VAR 0 2
71171: ARRAY
71172: IFFALSE 71208
// begin MC_Reset ( i , 121 ) ;
71174: LD_VAR 0 2
71178: PPUSH
71179: LD_INT 121
71181: PPUSH
71182: CALL 56497 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71186: LD_ADDR_EXP 90
71190: PUSH
71191: LD_EXP 90
71195: PPUSH
71196: LD_VAR 0 2
71200: PPUSH
71201: EMPTY
71202: PPUSH
71203: CALL_OW 1
71207: ST_TO_ADDR
// end ; continue ;
71208: GO 70776
// end ; for j in tmp do
71210: LD_ADDR_VAR 0 3
71214: PUSH
71215: LD_VAR 0 8
71219: PUSH
71220: FOR_IN
71221: IFFALSE 71557
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71223: LD_VAR 0 3
71227: PUSH
71228: LD_EXP 90
71232: PUSH
71233: LD_VAR 0 2
71237: ARRAY
71238: IN
71239: NOT
71240: PUSH
71241: LD_EXP 90
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: PUSH
71252: LD_INT 3
71254: LESS
71255: AND
71256: IFFALSE 71314
// begin SetTag ( j , 121 ) ;
71258: LD_VAR 0 3
71262: PPUSH
71263: LD_INT 121
71265: PPUSH
71266: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71270: LD_ADDR_EXP 90
71274: PUSH
71275: LD_EXP 90
71279: PPUSH
71280: LD_VAR 0 2
71284: PUSH
71285: LD_EXP 90
71289: PUSH
71290: LD_VAR 0 2
71294: ARRAY
71295: PUSH
71296: LD_INT 1
71298: PLUS
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: PPUSH
71304: LD_VAR 0 3
71308: PPUSH
71309: CALL 19686 0 3
71313: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71314: LD_VAR 0 3
71318: PUSH
71319: LD_EXP 90
71323: PUSH
71324: LD_VAR 0 2
71328: ARRAY
71329: IN
71330: IFFALSE 71555
// begin if GetClass ( j ) <> 4 then
71332: LD_VAR 0 3
71336: PPUSH
71337: CALL_OW 257
71341: PUSH
71342: LD_INT 4
71344: NONEQUAL
71345: IFFALSE 71398
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71347: LD_ADDR_EXP 90
71351: PUSH
71352: LD_EXP 90
71356: PPUSH
71357: LD_VAR 0 2
71361: PPUSH
71362: LD_EXP 90
71366: PUSH
71367: LD_VAR 0 2
71371: ARRAY
71372: PUSH
71373: LD_VAR 0 3
71377: DIFF
71378: PPUSH
71379: CALL_OW 1
71383: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71384: LD_VAR 0 3
71388: PPUSH
71389: LD_INT 0
71391: PPUSH
71392: CALL_OW 109
// continue ;
71396: GO 71220
// end ; if IsInUnit ( j ) then
71398: LD_VAR 0 3
71402: PPUSH
71403: CALL_OW 310
71407: IFFALSE 71418
// ComExitBuilding ( j ) ;
71409: LD_VAR 0 3
71413: PPUSH
71414: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71418: LD_ADDR_VAR 0 6
71422: PUSH
71423: LD_VAR 0 7
71427: PPUSH
71428: LD_VAR 0 3
71432: PPUSH
71433: CALL_OW 74
71437: ST_TO_ADDR
// if not ape then
71438: LD_VAR 0 6
71442: NOT
71443: IFFALSE 71447
// break ;
71445: GO 71557
// x := GetX ( ape ) ;
71447: LD_ADDR_VAR 0 4
71451: PUSH
71452: LD_VAR 0 6
71456: PPUSH
71457: CALL_OW 250
71461: ST_TO_ADDR
// y := GetY ( ape ) ;
71462: LD_ADDR_VAR 0 5
71466: PUSH
71467: LD_VAR 0 6
71471: PPUSH
71472: CALL_OW 251
71476: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71477: LD_VAR 0 4
71481: PPUSH
71482: LD_VAR 0 5
71486: PPUSH
71487: CALL_OW 488
71491: NOT
71492: PUSH
71493: LD_VAR 0 11
71497: PPUSH
71498: LD_VAR 0 4
71502: PPUSH
71503: LD_VAR 0 5
71507: PPUSH
71508: LD_INT 20
71510: PPUSH
71511: CALL 20582 0 4
71515: PUSH
71516: LD_INT 4
71518: ARRAY
71519: OR
71520: IFFALSE 71524
// break ;
71522: GO 71557
// if not HasTask ( j ) then
71524: LD_VAR 0 3
71528: PPUSH
71529: CALL_OW 314
71533: NOT
71534: IFFALSE 71555
// ComTameXY ( j , x , y ) ;
71536: LD_VAR 0 3
71540: PPUSH
71541: LD_VAR 0 4
71545: PPUSH
71546: LD_VAR 0 5
71550: PPUSH
71551: CALL_OW 131
// end ; end ;
71555: GO 71220
71557: POP
71558: POP
// end ;
71559: GO 70776
71561: POP
71562: POP
// end ;
71563: LD_VAR 0 1
71567: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71568: LD_INT 0
71570: PPUSH
71571: PPUSH
71572: PPUSH
71573: PPUSH
71574: PPUSH
71575: PPUSH
71576: PPUSH
71577: PPUSH
// if not mc_bases then
71578: LD_EXP 59
71582: NOT
71583: IFFALSE 71587
// exit ;
71585: GO 72213
// for i = 1 to mc_bases do
71587: LD_ADDR_VAR 0 2
71591: PUSH
71592: DOUBLE
71593: LD_INT 1
71595: DEC
71596: ST_TO_ADDR
71597: LD_EXP 59
71601: PUSH
71602: FOR_TO
71603: IFFALSE 72211
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71605: LD_EXP 88
71609: PUSH
71610: LD_VAR 0 2
71614: ARRAY
71615: NOT
71616: PUSH
71617: LD_EXP 88
71621: PUSH
71622: LD_VAR 0 2
71626: ARRAY
71627: PPUSH
71628: LD_INT 25
71630: PUSH
71631: LD_INT 12
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PPUSH
71638: CALL_OW 72
71642: NOT
71643: OR
71644: IFFALSE 71648
// continue ;
71646: GO 71602
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71648: LD_ADDR_VAR 0 5
71652: PUSH
71653: LD_EXP 88
71657: PUSH
71658: LD_VAR 0 2
71662: ARRAY
71663: PUSH
71664: LD_INT 1
71666: ARRAY
71667: PPUSH
71668: CALL_OW 255
71672: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71673: LD_VAR 0 5
71677: PPUSH
71678: LD_INT 2
71680: PPUSH
71681: CALL_OW 325
71685: IFFALSE 71938
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71687: LD_ADDR_VAR 0 4
71691: PUSH
71692: LD_EXP 88
71696: PUSH
71697: LD_VAR 0 2
71701: ARRAY
71702: PPUSH
71703: LD_INT 25
71705: PUSH
71706: LD_INT 16
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PPUSH
71713: CALL_OW 72
71717: ST_TO_ADDR
// if tmp < 6 then
71718: LD_VAR 0 4
71722: PUSH
71723: LD_INT 6
71725: LESS
71726: IFFALSE 71938
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71728: LD_ADDR_VAR 0 6
71732: PUSH
71733: LD_EXP 59
71737: PUSH
71738: LD_VAR 0 2
71742: ARRAY
71743: PPUSH
71744: LD_INT 2
71746: PUSH
71747: LD_INT 30
71749: PUSH
71750: LD_INT 0
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 30
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: PPUSH
71772: CALL_OW 72
71776: ST_TO_ADDR
// if depot then
71777: LD_VAR 0 6
71781: IFFALSE 71938
// begin selected := 0 ;
71783: LD_ADDR_VAR 0 7
71787: PUSH
71788: LD_INT 0
71790: ST_TO_ADDR
// for j in depot do
71791: LD_ADDR_VAR 0 3
71795: PUSH
71796: LD_VAR 0 6
71800: PUSH
71801: FOR_IN
71802: IFFALSE 71833
// begin if UnitsInside ( j ) < 6 then
71804: LD_VAR 0 3
71808: PPUSH
71809: CALL_OW 313
71813: PUSH
71814: LD_INT 6
71816: LESS
71817: IFFALSE 71831
// begin selected := j ;
71819: LD_ADDR_VAR 0 7
71823: PUSH
71824: LD_VAR 0 3
71828: ST_TO_ADDR
// break ;
71829: GO 71833
// end ; end ;
71831: GO 71801
71833: POP
71834: POP
// if selected then
71835: LD_VAR 0 7
71839: IFFALSE 71938
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71841: LD_ADDR_VAR 0 3
71845: PUSH
71846: LD_EXP 88
71850: PUSH
71851: LD_VAR 0 2
71855: ARRAY
71856: PPUSH
71857: LD_INT 25
71859: PUSH
71860: LD_INT 12
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PPUSH
71867: CALL_OW 72
71871: PUSH
71872: FOR_IN
71873: IFFALSE 71936
// if not HasTask ( j ) then
71875: LD_VAR 0 3
71879: PPUSH
71880: CALL_OW 314
71884: NOT
71885: IFFALSE 71934
// begin if not IsInUnit ( j ) then
71887: LD_VAR 0 3
71891: PPUSH
71892: CALL_OW 310
71896: NOT
71897: IFFALSE 71913
// ComEnterUnit ( j , selected ) ;
71899: LD_VAR 0 3
71903: PPUSH
71904: LD_VAR 0 7
71908: PPUSH
71909: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71913: LD_VAR 0 3
71917: PPUSH
71918: LD_INT 16
71920: PPUSH
71921: CALL_OW 183
// AddComExitBuilding ( j ) ;
71925: LD_VAR 0 3
71929: PPUSH
71930: CALL_OW 182
// end ;
71934: GO 71872
71936: POP
71937: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71938: LD_VAR 0 5
71942: PPUSH
71943: LD_INT 11
71945: PPUSH
71946: CALL_OW 325
71950: IFFALSE 72209
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71952: LD_ADDR_VAR 0 4
71956: PUSH
71957: LD_EXP 88
71961: PUSH
71962: LD_VAR 0 2
71966: ARRAY
71967: PPUSH
71968: LD_INT 25
71970: PUSH
71971: LD_INT 16
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PPUSH
71978: CALL_OW 72
71982: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71983: LD_VAR 0 4
71987: PUSH
71988: LD_INT 6
71990: GREATEREQUAL
71991: PUSH
71992: LD_VAR 0 5
71996: PPUSH
71997: LD_INT 2
71999: PPUSH
72000: CALL_OW 325
72004: NOT
72005: OR
72006: IFFALSE 72209
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72008: LD_ADDR_VAR 0 8
72012: PUSH
72013: LD_EXP 59
72017: PUSH
72018: LD_VAR 0 2
72022: ARRAY
72023: PPUSH
72024: LD_INT 2
72026: PUSH
72027: LD_INT 30
72029: PUSH
72030: LD_INT 4
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 30
72039: PUSH
72040: LD_INT 5
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: LIST
72051: PPUSH
72052: CALL_OW 72
72056: ST_TO_ADDR
// if barracks then
72057: LD_VAR 0 8
72061: IFFALSE 72209
// begin selected := 0 ;
72063: LD_ADDR_VAR 0 7
72067: PUSH
72068: LD_INT 0
72070: ST_TO_ADDR
// for j in barracks do
72071: LD_ADDR_VAR 0 3
72075: PUSH
72076: LD_VAR 0 8
72080: PUSH
72081: FOR_IN
72082: IFFALSE 72113
// begin if UnitsInside ( j ) < 6 then
72084: LD_VAR 0 3
72088: PPUSH
72089: CALL_OW 313
72093: PUSH
72094: LD_INT 6
72096: LESS
72097: IFFALSE 72111
// begin selected := j ;
72099: LD_ADDR_VAR 0 7
72103: PUSH
72104: LD_VAR 0 3
72108: ST_TO_ADDR
// break ;
72109: GO 72113
// end ; end ;
72111: GO 72081
72113: POP
72114: POP
// if selected then
72115: LD_VAR 0 7
72119: IFFALSE 72209
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72121: LD_ADDR_VAR 0 3
72125: PUSH
72126: LD_EXP 88
72130: PUSH
72131: LD_VAR 0 2
72135: ARRAY
72136: PPUSH
72137: LD_INT 25
72139: PUSH
72140: LD_INT 12
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PPUSH
72147: CALL_OW 72
72151: PUSH
72152: FOR_IN
72153: IFFALSE 72207
// if not IsInUnit ( j ) and not HasTask ( j ) then
72155: LD_VAR 0 3
72159: PPUSH
72160: CALL_OW 310
72164: NOT
72165: PUSH
72166: LD_VAR 0 3
72170: PPUSH
72171: CALL_OW 314
72175: NOT
72176: AND
72177: IFFALSE 72205
// begin ComEnterUnit ( j , selected ) ;
72179: LD_VAR 0 3
72183: PPUSH
72184: LD_VAR 0 7
72188: PPUSH
72189: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72193: LD_VAR 0 3
72197: PPUSH
72198: LD_INT 15
72200: PPUSH
72201: CALL_OW 183
// end ;
72205: GO 72152
72207: POP
72208: POP
// end ; end ; end ; end ; end ;
72209: GO 71602
72211: POP
72212: POP
// end ;
72213: LD_VAR 0 1
72217: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72218: LD_INT 0
72220: PPUSH
72221: PPUSH
72222: PPUSH
72223: PPUSH
// if not mc_bases then
72224: LD_EXP 59
72228: NOT
72229: IFFALSE 72233
// exit ;
72231: GO 72411
// for i = 1 to mc_bases do
72233: LD_ADDR_VAR 0 2
72237: PUSH
72238: DOUBLE
72239: LD_INT 1
72241: DEC
72242: ST_TO_ADDR
72243: LD_EXP 59
72247: PUSH
72248: FOR_TO
72249: IFFALSE 72409
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72251: LD_ADDR_VAR 0 4
72255: PUSH
72256: LD_EXP 59
72260: PUSH
72261: LD_VAR 0 2
72265: ARRAY
72266: PPUSH
72267: LD_INT 25
72269: PUSH
72270: LD_INT 9
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PPUSH
72277: CALL_OW 72
72281: ST_TO_ADDR
// if not tmp then
72282: LD_VAR 0 4
72286: NOT
72287: IFFALSE 72291
// continue ;
72289: GO 72248
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72291: LD_EXP 85
72295: PUSH
72296: LD_VAR 0 2
72300: ARRAY
72301: PPUSH
72302: LD_INT 29
72304: PPUSH
72305: CALL_OW 325
72309: NOT
72310: PUSH
72311: LD_EXP 85
72315: PUSH
72316: LD_VAR 0 2
72320: ARRAY
72321: PPUSH
72322: LD_INT 28
72324: PPUSH
72325: CALL_OW 325
72329: NOT
72330: AND
72331: IFFALSE 72335
// continue ;
72333: GO 72248
// for j in tmp do
72335: LD_ADDR_VAR 0 3
72339: PUSH
72340: LD_VAR 0 4
72344: PUSH
72345: FOR_IN
72346: IFFALSE 72405
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72348: LD_VAR 0 3
72352: PUSH
72353: LD_EXP 62
72357: PUSH
72358: LD_VAR 0 2
72362: ARRAY
72363: PUSH
72364: LD_INT 1
72366: ARRAY
72367: IN
72368: NOT
72369: PUSH
72370: LD_VAR 0 3
72374: PUSH
72375: LD_EXP 62
72379: PUSH
72380: LD_VAR 0 2
72384: ARRAY
72385: PUSH
72386: LD_INT 2
72388: ARRAY
72389: IN
72390: NOT
72391: AND
72392: IFFALSE 72403
// ComSpaceTimeShoot ( j ) ;
72394: LD_VAR 0 3
72398: PPUSH
72399: CALL 15683 0 1
72403: GO 72345
72405: POP
72406: POP
// end ;
72407: GO 72248
72409: POP
72410: POP
// end ;
72411: LD_VAR 0 1
72415: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72416: LD_INT 0
72418: PPUSH
72419: PPUSH
72420: PPUSH
72421: PPUSH
72422: PPUSH
72423: PPUSH
72424: PPUSH
72425: PPUSH
72426: PPUSH
// if not mc_bases then
72427: LD_EXP 59
72431: NOT
72432: IFFALSE 72436
// exit ;
72434: GO 73058
// for i = 1 to mc_bases do
72436: LD_ADDR_VAR 0 2
72440: PUSH
72441: DOUBLE
72442: LD_INT 1
72444: DEC
72445: ST_TO_ADDR
72446: LD_EXP 59
72450: PUSH
72451: FOR_TO
72452: IFFALSE 73056
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72454: LD_EXP 94
72458: PUSH
72459: LD_VAR 0 2
72463: ARRAY
72464: NOT
72465: PUSH
72466: LD_INT 38
72468: PPUSH
72469: LD_EXP 85
72473: PUSH
72474: LD_VAR 0 2
72478: ARRAY
72479: PPUSH
72480: CALL_OW 321
72484: PUSH
72485: LD_INT 2
72487: NONEQUAL
72488: OR
72489: IFFALSE 72493
// continue ;
72491: GO 72451
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72493: LD_ADDR_VAR 0 8
72497: PUSH
72498: LD_EXP 59
72502: PUSH
72503: LD_VAR 0 2
72507: ARRAY
72508: PPUSH
72509: LD_INT 30
72511: PUSH
72512: LD_INT 34
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PPUSH
72519: CALL_OW 72
72523: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72524: LD_ADDR_VAR 0 9
72528: PUSH
72529: LD_EXP 59
72533: PUSH
72534: LD_VAR 0 2
72538: ARRAY
72539: PPUSH
72540: LD_INT 25
72542: PUSH
72543: LD_INT 4
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PPUSH
72550: CALL_OW 72
72554: PPUSH
72555: LD_INT 0
72557: PPUSH
72558: CALL 48550 0 2
72562: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72563: LD_VAR 0 9
72567: NOT
72568: PUSH
72569: LD_VAR 0 8
72573: NOT
72574: OR
72575: PUSH
72576: LD_EXP 59
72580: PUSH
72581: LD_VAR 0 2
72585: ARRAY
72586: PPUSH
72587: LD_INT 124
72589: PPUSH
72590: CALL 48550 0 2
72594: OR
72595: IFFALSE 72599
// continue ;
72597: GO 72451
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72599: LD_EXP 95
72603: PUSH
72604: LD_VAR 0 2
72608: ARRAY
72609: PUSH
72610: LD_EXP 94
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: LESS
72621: PUSH
72622: LD_EXP 95
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PUSH
72633: LD_VAR 0 8
72637: LESS
72638: AND
72639: IFFALSE 73054
// begin tmp := sci [ 1 ] ;
72641: LD_ADDR_VAR 0 7
72645: PUSH
72646: LD_VAR 0 9
72650: PUSH
72651: LD_INT 1
72653: ARRAY
72654: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72655: LD_VAR 0 7
72659: PPUSH
72660: LD_INT 124
72662: PPUSH
72663: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72667: LD_ADDR_VAR 0 3
72671: PUSH
72672: DOUBLE
72673: LD_EXP 94
72677: PUSH
72678: LD_VAR 0 2
72682: ARRAY
72683: INC
72684: ST_TO_ADDR
72685: LD_EXP 94
72689: PUSH
72690: LD_VAR 0 2
72694: ARRAY
72695: PUSH
72696: FOR_DOWNTO
72697: IFFALSE 73040
// begin if IsInUnit ( tmp ) then
72699: LD_VAR 0 7
72703: PPUSH
72704: CALL_OW 310
72708: IFFALSE 72719
// ComExitBuilding ( tmp ) ;
72710: LD_VAR 0 7
72714: PPUSH
72715: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72719: LD_INT 35
72721: PPUSH
72722: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72726: LD_VAR 0 7
72730: PPUSH
72731: CALL_OW 310
72735: NOT
72736: PUSH
72737: LD_VAR 0 7
72741: PPUSH
72742: CALL_OW 314
72746: NOT
72747: AND
72748: IFFALSE 72719
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72750: LD_ADDR_VAR 0 6
72754: PUSH
72755: LD_VAR 0 7
72759: PPUSH
72760: CALL_OW 250
72764: PUSH
72765: LD_VAR 0 7
72769: PPUSH
72770: CALL_OW 251
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72779: LD_INT 35
72781: PPUSH
72782: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72786: LD_ADDR_VAR 0 4
72790: PUSH
72791: LD_EXP 94
72795: PUSH
72796: LD_VAR 0 2
72800: ARRAY
72801: PUSH
72802: LD_VAR 0 3
72806: ARRAY
72807: PUSH
72808: LD_INT 1
72810: ARRAY
72811: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72812: LD_ADDR_VAR 0 5
72816: PUSH
72817: LD_EXP 94
72821: PUSH
72822: LD_VAR 0 2
72826: ARRAY
72827: PUSH
72828: LD_VAR 0 3
72832: ARRAY
72833: PUSH
72834: LD_INT 2
72836: ARRAY
72837: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72838: LD_VAR 0 7
72842: PPUSH
72843: LD_INT 10
72845: PPUSH
72846: CALL 22279 0 2
72850: PUSH
72851: LD_INT 4
72853: ARRAY
72854: IFFALSE 72892
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72856: LD_VAR 0 7
72860: PPUSH
72861: LD_VAR 0 6
72865: PUSH
72866: LD_INT 1
72868: ARRAY
72869: PPUSH
72870: LD_VAR 0 6
72874: PUSH
72875: LD_INT 2
72877: ARRAY
72878: PPUSH
72879: CALL_OW 111
// wait ( 0 0$10 ) ;
72883: LD_INT 350
72885: PPUSH
72886: CALL_OW 67
// end else
72890: GO 72918
// begin ComMoveXY ( tmp , x , y ) ;
72892: LD_VAR 0 7
72896: PPUSH
72897: LD_VAR 0 4
72901: PPUSH
72902: LD_VAR 0 5
72906: PPUSH
72907: CALL_OW 111
// wait ( 0 0$3 ) ;
72911: LD_INT 105
72913: PPUSH
72914: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72918: LD_VAR 0 7
72922: PPUSH
72923: LD_VAR 0 4
72927: PPUSH
72928: LD_VAR 0 5
72932: PPUSH
72933: CALL_OW 307
72937: IFFALSE 72779
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72939: LD_VAR 0 7
72943: PPUSH
72944: LD_VAR 0 4
72948: PPUSH
72949: LD_VAR 0 5
72953: PPUSH
72954: LD_VAR 0 8
72958: PUSH
72959: LD_VAR 0 3
72963: ARRAY
72964: PPUSH
72965: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72969: LD_INT 35
72971: PPUSH
72972: CALL_OW 67
// until not HasTask ( tmp ) ;
72976: LD_VAR 0 7
72980: PPUSH
72981: CALL_OW 314
72985: NOT
72986: IFFALSE 72969
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72988: LD_ADDR_EXP 95
72992: PUSH
72993: LD_EXP 95
72997: PPUSH
72998: LD_VAR 0 2
73002: PUSH
73003: LD_EXP 95
73007: PUSH
73008: LD_VAR 0 2
73012: ARRAY
73013: PUSH
73014: LD_INT 1
73016: PLUS
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PPUSH
73022: LD_VAR 0 8
73026: PUSH
73027: LD_VAR 0 3
73031: ARRAY
73032: PPUSH
73033: CALL 19686 0 3
73037: ST_TO_ADDR
// end ;
73038: GO 72696
73040: POP
73041: POP
// MC_Reset ( i , 124 ) ;
73042: LD_VAR 0 2
73046: PPUSH
73047: LD_INT 124
73049: PPUSH
73050: CALL 56497 0 2
// end ; end ;
73054: GO 72451
73056: POP
73057: POP
// end ;
73058: LD_VAR 0 1
73062: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73063: LD_INT 0
73065: PPUSH
73066: PPUSH
73067: PPUSH
// if not mc_bases then
73068: LD_EXP 59
73072: NOT
73073: IFFALSE 73077
// exit ;
73075: GO 73683
// for i = 1 to mc_bases do
73077: LD_ADDR_VAR 0 2
73081: PUSH
73082: DOUBLE
73083: LD_INT 1
73085: DEC
73086: ST_TO_ADDR
73087: LD_EXP 59
73091: PUSH
73092: FOR_TO
73093: IFFALSE 73681
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73095: LD_ADDR_VAR 0 3
73099: PUSH
73100: LD_EXP 59
73104: PUSH
73105: LD_VAR 0 2
73109: ARRAY
73110: PPUSH
73111: LD_INT 25
73113: PUSH
73114: LD_INT 4
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PPUSH
73121: CALL_OW 72
73125: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73126: LD_VAR 0 3
73130: NOT
73131: PUSH
73132: LD_EXP 96
73136: PUSH
73137: LD_VAR 0 2
73141: ARRAY
73142: NOT
73143: OR
73144: PUSH
73145: LD_EXP 59
73149: PUSH
73150: LD_VAR 0 2
73154: ARRAY
73155: PPUSH
73156: LD_INT 2
73158: PUSH
73159: LD_INT 30
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 30
73171: PUSH
73172: LD_INT 1
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: LIST
73183: PPUSH
73184: CALL_OW 72
73188: NOT
73189: OR
73190: IFFALSE 73240
// begin if mc_deposits_finder [ i ] then
73192: LD_EXP 97
73196: PUSH
73197: LD_VAR 0 2
73201: ARRAY
73202: IFFALSE 73238
// begin MC_Reset ( i , 125 ) ;
73204: LD_VAR 0 2
73208: PPUSH
73209: LD_INT 125
73211: PPUSH
73212: CALL 56497 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73216: LD_ADDR_EXP 97
73220: PUSH
73221: LD_EXP 97
73225: PPUSH
73226: LD_VAR 0 2
73230: PPUSH
73231: EMPTY
73232: PPUSH
73233: CALL_OW 1
73237: ST_TO_ADDR
// end ; continue ;
73238: GO 73092
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73240: LD_EXP 96
73244: PUSH
73245: LD_VAR 0 2
73249: ARRAY
73250: PUSH
73251: LD_INT 1
73253: ARRAY
73254: PUSH
73255: LD_INT 3
73257: ARRAY
73258: PUSH
73259: LD_INT 1
73261: EQUAL
73262: PUSH
73263: LD_INT 20
73265: PPUSH
73266: LD_EXP 85
73270: PUSH
73271: LD_VAR 0 2
73275: ARRAY
73276: PPUSH
73277: CALL_OW 321
73281: PUSH
73282: LD_INT 2
73284: NONEQUAL
73285: AND
73286: IFFALSE 73336
// begin if mc_deposits_finder [ i ] then
73288: LD_EXP 97
73292: PUSH
73293: LD_VAR 0 2
73297: ARRAY
73298: IFFALSE 73334
// begin MC_Reset ( i , 125 ) ;
73300: LD_VAR 0 2
73304: PPUSH
73305: LD_INT 125
73307: PPUSH
73308: CALL 56497 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73312: LD_ADDR_EXP 97
73316: PUSH
73317: LD_EXP 97
73321: PPUSH
73322: LD_VAR 0 2
73326: PPUSH
73327: EMPTY
73328: PPUSH
73329: CALL_OW 1
73333: ST_TO_ADDR
// end ; continue ;
73334: GO 73092
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73336: LD_EXP 96
73340: PUSH
73341: LD_VAR 0 2
73345: ARRAY
73346: PUSH
73347: LD_INT 1
73349: ARRAY
73350: PUSH
73351: LD_INT 1
73353: ARRAY
73354: PPUSH
73355: LD_EXP 96
73359: PUSH
73360: LD_VAR 0 2
73364: ARRAY
73365: PUSH
73366: LD_INT 1
73368: ARRAY
73369: PUSH
73370: LD_INT 2
73372: ARRAY
73373: PPUSH
73374: LD_EXP 85
73378: PUSH
73379: LD_VAR 0 2
73383: ARRAY
73384: PPUSH
73385: CALL_OW 440
73389: IFFALSE 73432
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73391: LD_ADDR_EXP 96
73395: PUSH
73396: LD_EXP 96
73400: PPUSH
73401: LD_VAR 0 2
73405: PPUSH
73406: LD_EXP 96
73410: PUSH
73411: LD_VAR 0 2
73415: ARRAY
73416: PPUSH
73417: LD_INT 1
73419: PPUSH
73420: CALL_OW 3
73424: PPUSH
73425: CALL_OW 1
73429: ST_TO_ADDR
73430: GO 73679
// begin if not mc_deposits_finder [ i ] then
73432: LD_EXP 97
73436: PUSH
73437: LD_VAR 0 2
73441: ARRAY
73442: NOT
73443: IFFALSE 73495
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73445: LD_ADDR_EXP 97
73449: PUSH
73450: LD_EXP 97
73454: PPUSH
73455: LD_VAR 0 2
73459: PPUSH
73460: LD_VAR 0 3
73464: PUSH
73465: LD_INT 1
73467: ARRAY
73468: PUSH
73469: EMPTY
73470: LIST
73471: PPUSH
73472: CALL_OW 1
73476: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73477: LD_VAR 0 3
73481: PUSH
73482: LD_INT 1
73484: ARRAY
73485: PPUSH
73486: LD_INT 125
73488: PPUSH
73489: CALL_OW 109
// end else
73493: GO 73679
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73495: LD_EXP 97
73499: PUSH
73500: LD_VAR 0 2
73504: ARRAY
73505: PUSH
73506: LD_INT 1
73508: ARRAY
73509: PPUSH
73510: CALL_OW 310
73514: IFFALSE 73537
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73516: LD_EXP 97
73520: PUSH
73521: LD_VAR 0 2
73525: ARRAY
73526: PUSH
73527: LD_INT 1
73529: ARRAY
73530: PPUSH
73531: CALL_OW 122
73535: GO 73679
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73537: LD_EXP 97
73541: PUSH
73542: LD_VAR 0 2
73546: ARRAY
73547: PUSH
73548: LD_INT 1
73550: ARRAY
73551: PPUSH
73552: CALL_OW 314
73556: NOT
73557: PUSH
73558: LD_EXP 97
73562: PUSH
73563: LD_VAR 0 2
73567: ARRAY
73568: PUSH
73569: LD_INT 1
73571: ARRAY
73572: PPUSH
73573: LD_EXP 96
73577: PUSH
73578: LD_VAR 0 2
73582: ARRAY
73583: PUSH
73584: LD_INT 1
73586: ARRAY
73587: PUSH
73588: LD_INT 1
73590: ARRAY
73591: PPUSH
73592: LD_EXP 96
73596: PUSH
73597: LD_VAR 0 2
73601: ARRAY
73602: PUSH
73603: LD_INT 1
73605: ARRAY
73606: PUSH
73607: LD_INT 2
73609: ARRAY
73610: PPUSH
73611: CALL_OW 297
73615: PUSH
73616: LD_INT 6
73618: GREATER
73619: AND
73620: IFFALSE 73679
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73622: LD_EXP 97
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: PUSH
73633: LD_INT 1
73635: ARRAY
73636: PPUSH
73637: LD_EXP 96
73641: PUSH
73642: LD_VAR 0 2
73646: ARRAY
73647: PUSH
73648: LD_INT 1
73650: ARRAY
73651: PUSH
73652: LD_INT 1
73654: ARRAY
73655: PPUSH
73656: LD_EXP 96
73660: PUSH
73661: LD_VAR 0 2
73665: ARRAY
73666: PUSH
73667: LD_INT 1
73669: ARRAY
73670: PUSH
73671: LD_INT 2
73673: ARRAY
73674: PPUSH
73675: CALL_OW 111
// end ; end ; end ;
73679: GO 73092
73681: POP
73682: POP
// end ;
73683: LD_VAR 0 1
73687: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73688: LD_INT 0
73690: PPUSH
73691: PPUSH
73692: PPUSH
73693: PPUSH
73694: PPUSH
73695: PPUSH
73696: PPUSH
73697: PPUSH
73698: PPUSH
73699: PPUSH
73700: PPUSH
// if not mc_bases then
73701: LD_EXP 59
73705: NOT
73706: IFFALSE 73710
// exit ;
73708: GO 74650
// for i = 1 to mc_bases do
73710: LD_ADDR_VAR 0 2
73714: PUSH
73715: DOUBLE
73716: LD_INT 1
73718: DEC
73719: ST_TO_ADDR
73720: LD_EXP 59
73724: PUSH
73725: FOR_TO
73726: IFFALSE 74648
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73728: LD_EXP 59
73732: PUSH
73733: LD_VAR 0 2
73737: ARRAY
73738: NOT
73739: PUSH
73740: LD_EXP 82
73744: PUSH
73745: LD_VAR 0 2
73749: ARRAY
73750: OR
73751: IFFALSE 73755
// continue ;
73753: GO 73725
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73755: LD_ADDR_VAR 0 7
73759: PUSH
73760: LD_EXP 59
73764: PUSH
73765: LD_VAR 0 2
73769: ARRAY
73770: PUSH
73771: LD_INT 1
73773: ARRAY
73774: PPUSH
73775: CALL_OW 248
73779: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73780: LD_VAR 0 7
73784: PUSH
73785: LD_INT 3
73787: EQUAL
73788: PUSH
73789: LD_EXP 78
73793: PUSH
73794: LD_VAR 0 2
73798: ARRAY
73799: PUSH
73800: LD_EXP 81
73804: PUSH
73805: LD_VAR 0 2
73809: ARRAY
73810: UNION
73811: PPUSH
73812: LD_INT 33
73814: PUSH
73815: LD_INT 2
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PPUSH
73822: CALL_OW 72
73826: NOT
73827: OR
73828: IFFALSE 73832
// continue ;
73830: GO 73725
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73832: LD_ADDR_VAR 0 9
73836: PUSH
73837: LD_EXP 59
73841: PUSH
73842: LD_VAR 0 2
73846: ARRAY
73847: PPUSH
73848: LD_INT 30
73850: PUSH
73851: LD_INT 36
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PPUSH
73858: CALL_OW 72
73862: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73863: LD_ADDR_VAR 0 10
73867: PUSH
73868: LD_EXP 78
73872: PUSH
73873: LD_VAR 0 2
73877: ARRAY
73878: PPUSH
73879: LD_INT 34
73881: PUSH
73882: LD_INT 31
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PPUSH
73889: CALL_OW 72
73893: ST_TO_ADDR
// if not cts and not mcts then
73894: LD_VAR 0 9
73898: NOT
73899: PUSH
73900: LD_VAR 0 10
73904: NOT
73905: AND
73906: IFFALSE 73910
// continue ;
73908: GO 73725
// x := cts ;
73910: LD_ADDR_VAR 0 11
73914: PUSH
73915: LD_VAR 0 9
73919: ST_TO_ADDR
// if not x then
73920: LD_VAR 0 11
73924: NOT
73925: IFFALSE 73937
// x := mcts ;
73927: LD_ADDR_VAR 0 11
73931: PUSH
73932: LD_VAR 0 10
73936: ST_TO_ADDR
// if not x then
73937: LD_VAR 0 11
73941: NOT
73942: IFFALSE 73946
// continue ;
73944: GO 73725
// if mc_remote_driver [ i ] then
73946: LD_EXP 99
73950: PUSH
73951: LD_VAR 0 2
73955: ARRAY
73956: IFFALSE 74343
// for j in mc_remote_driver [ i ] do
73958: LD_ADDR_VAR 0 3
73962: PUSH
73963: LD_EXP 99
73967: PUSH
73968: LD_VAR 0 2
73972: ARRAY
73973: PUSH
73974: FOR_IN
73975: IFFALSE 74341
// begin if GetClass ( j ) <> 3 then
73977: LD_VAR 0 3
73981: PPUSH
73982: CALL_OW 257
73986: PUSH
73987: LD_INT 3
73989: NONEQUAL
73990: IFFALSE 74043
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73992: LD_ADDR_EXP 99
73996: PUSH
73997: LD_EXP 99
74001: PPUSH
74002: LD_VAR 0 2
74006: PPUSH
74007: LD_EXP 99
74011: PUSH
74012: LD_VAR 0 2
74016: ARRAY
74017: PUSH
74018: LD_VAR 0 3
74022: DIFF
74023: PPUSH
74024: CALL_OW 1
74028: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74029: LD_VAR 0 3
74033: PPUSH
74034: LD_INT 0
74036: PPUSH
74037: CALL_OW 109
// continue ;
74041: GO 73974
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74043: LD_EXP 78
74047: PUSH
74048: LD_VAR 0 2
74052: ARRAY
74053: PPUSH
74054: LD_INT 34
74056: PUSH
74057: LD_INT 31
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 58
74066: PUSH
74067: EMPTY
74068: LIST
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PPUSH
74074: CALL_OW 72
74078: PUSH
74079: LD_VAR 0 3
74083: PPUSH
74084: CALL 48638 0 1
74088: NOT
74089: AND
74090: IFFALSE 74161
// begin if IsInUnit ( j ) then
74092: LD_VAR 0 3
74096: PPUSH
74097: CALL_OW 310
74101: IFFALSE 74112
// ComExitBuilding ( j ) ;
74103: LD_VAR 0 3
74107: PPUSH
74108: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74112: LD_VAR 0 3
74116: PPUSH
74117: LD_EXP 78
74121: PUSH
74122: LD_VAR 0 2
74126: ARRAY
74127: PPUSH
74128: LD_INT 34
74130: PUSH
74131: LD_INT 31
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 58
74140: PUSH
74141: EMPTY
74142: LIST
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PPUSH
74148: CALL_OW 72
74152: PUSH
74153: LD_INT 1
74155: ARRAY
74156: PPUSH
74157: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74161: LD_VAR 0 3
74165: PPUSH
74166: CALL_OW 310
74170: NOT
74171: PUSH
74172: LD_VAR 0 3
74176: PPUSH
74177: CALL_OW 310
74181: PPUSH
74182: CALL_OW 266
74186: PUSH
74187: LD_INT 36
74189: NONEQUAL
74190: PUSH
74191: LD_VAR 0 3
74195: PPUSH
74196: CALL 48638 0 1
74200: NOT
74201: AND
74202: OR
74203: IFFALSE 74339
// begin if IsInUnit ( j ) then
74205: LD_VAR 0 3
74209: PPUSH
74210: CALL_OW 310
74214: IFFALSE 74225
// ComExitBuilding ( j ) ;
74216: LD_VAR 0 3
74220: PPUSH
74221: CALL_OW 122
// ct := 0 ;
74225: LD_ADDR_VAR 0 8
74229: PUSH
74230: LD_INT 0
74232: ST_TO_ADDR
// for k in x do
74233: LD_ADDR_VAR 0 4
74237: PUSH
74238: LD_VAR 0 11
74242: PUSH
74243: FOR_IN
74244: IFFALSE 74317
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74246: LD_VAR 0 4
74250: PPUSH
74251: CALL_OW 264
74255: PUSH
74256: LD_INT 31
74258: EQUAL
74259: PUSH
74260: LD_VAR 0 4
74264: PPUSH
74265: CALL_OW 311
74269: NOT
74270: AND
74271: PUSH
74272: LD_VAR 0 4
74276: PPUSH
74277: CALL_OW 266
74281: PUSH
74282: LD_INT 36
74284: EQUAL
74285: PUSH
74286: LD_VAR 0 4
74290: PPUSH
74291: CALL_OW 313
74295: PUSH
74296: LD_INT 3
74298: LESS
74299: AND
74300: OR
74301: IFFALSE 74315
// begin ct := k ;
74303: LD_ADDR_VAR 0 8
74307: PUSH
74308: LD_VAR 0 4
74312: ST_TO_ADDR
// break ;
74313: GO 74317
// end ;
74315: GO 74243
74317: POP
74318: POP
// if ct then
74319: LD_VAR 0 8
74323: IFFALSE 74339
// ComEnterUnit ( j , ct ) ;
74325: LD_VAR 0 3
74329: PPUSH
74330: LD_VAR 0 8
74334: PPUSH
74335: CALL_OW 120
// end ; end ;
74339: GO 73974
74341: POP
74342: POP
// places := 0 ;
74343: LD_ADDR_VAR 0 5
74347: PUSH
74348: LD_INT 0
74350: ST_TO_ADDR
// for j = 1 to x do
74351: LD_ADDR_VAR 0 3
74355: PUSH
74356: DOUBLE
74357: LD_INT 1
74359: DEC
74360: ST_TO_ADDR
74361: LD_VAR 0 11
74365: PUSH
74366: FOR_TO
74367: IFFALSE 74443
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74369: LD_VAR 0 11
74373: PUSH
74374: LD_VAR 0 3
74378: ARRAY
74379: PPUSH
74380: CALL_OW 264
74384: PUSH
74385: LD_INT 31
74387: EQUAL
74388: IFFALSE 74406
// places := places + 1 else
74390: LD_ADDR_VAR 0 5
74394: PUSH
74395: LD_VAR 0 5
74399: PUSH
74400: LD_INT 1
74402: PLUS
74403: ST_TO_ADDR
74404: GO 74441
// if GetBType ( x [ j ] ) = b_control_tower then
74406: LD_VAR 0 11
74410: PUSH
74411: LD_VAR 0 3
74415: ARRAY
74416: PPUSH
74417: CALL_OW 266
74421: PUSH
74422: LD_INT 36
74424: EQUAL
74425: IFFALSE 74441
// places := places + 3 ;
74427: LD_ADDR_VAR 0 5
74431: PUSH
74432: LD_VAR 0 5
74436: PUSH
74437: LD_INT 3
74439: PLUS
74440: ST_TO_ADDR
74441: GO 74366
74443: POP
74444: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74445: LD_VAR 0 5
74449: PUSH
74450: LD_INT 0
74452: EQUAL
74453: PUSH
74454: LD_VAR 0 5
74458: PUSH
74459: LD_EXP 99
74463: PUSH
74464: LD_VAR 0 2
74468: ARRAY
74469: LESSEQUAL
74470: OR
74471: IFFALSE 74475
// continue ;
74473: GO 73725
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74475: LD_ADDR_VAR 0 6
74479: PUSH
74480: LD_EXP 59
74484: PUSH
74485: LD_VAR 0 2
74489: ARRAY
74490: PPUSH
74491: LD_INT 25
74493: PUSH
74494: LD_INT 3
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PPUSH
74501: CALL_OW 72
74505: PUSH
74506: LD_EXP 99
74510: PUSH
74511: LD_VAR 0 2
74515: ARRAY
74516: DIFF
74517: PPUSH
74518: LD_INT 3
74520: PPUSH
74521: CALL 49538 0 2
74525: ST_TO_ADDR
// for j in tmp do
74526: LD_ADDR_VAR 0 3
74530: PUSH
74531: LD_VAR 0 6
74535: PUSH
74536: FOR_IN
74537: IFFALSE 74572
// if GetTag ( j ) > 0 then
74539: LD_VAR 0 3
74543: PPUSH
74544: CALL_OW 110
74548: PUSH
74549: LD_INT 0
74551: GREATER
74552: IFFALSE 74570
// tmp := tmp diff j ;
74554: LD_ADDR_VAR 0 6
74558: PUSH
74559: LD_VAR 0 6
74563: PUSH
74564: LD_VAR 0 3
74568: DIFF
74569: ST_TO_ADDR
74570: GO 74536
74572: POP
74573: POP
// if not tmp then
74574: LD_VAR 0 6
74578: NOT
74579: IFFALSE 74583
// continue ;
74581: GO 73725
// if places then
74583: LD_VAR 0 5
74587: IFFALSE 74646
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74589: LD_ADDR_EXP 99
74593: PUSH
74594: LD_EXP 99
74598: PPUSH
74599: LD_VAR 0 2
74603: PPUSH
74604: LD_EXP 99
74608: PUSH
74609: LD_VAR 0 2
74613: ARRAY
74614: PUSH
74615: LD_VAR 0 6
74619: PUSH
74620: LD_INT 1
74622: ARRAY
74623: UNION
74624: PPUSH
74625: CALL_OW 1
74629: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74630: LD_VAR 0 6
74634: PUSH
74635: LD_INT 1
74637: ARRAY
74638: PPUSH
74639: LD_INT 126
74641: PPUSH
74642: CALL_OW 109
// end ; end ;
74646: GO 73725
74648: POP
74649: POP
// end ;
74650: LD_VAR 0 1
74654: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74655: LD_INT 0
74657: PPUSH
74658: PPUSH
74659: PPUSH
74660: PPUSH
74661: PPUSH
74662: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74663: LD_VAR 0 1
74667: NOT
74668: PUSH
74669: LD_VAR 0 2
74673: NOT
74674: OR
74675: PUSH
74676: LD_VAR 0 3
74680: NOT
74681: OR
74682: PUSH
74683: LD_VAR 0 4
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: LD_INT 2
74693: PUSH
74694: LD_INT 3
74696: PUSH
74697: LD_INT 4
74699: PUSH
74700: LD_INT 5
74702: PUSH
74703: LD_INT 8
74705: PUSH
74706: LD_INT 9
74708: PUSH
74709: LD_INT 15
74711: PUSH
74712: LD_INT 16
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: LIST
74722: LIST
74723: LIST
74724: LIST
74725: IN
74726: NOT
74727: OR
74728: IFFALSE 74732
// exit ;
74730: GO 75632
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74732: LD_ADDR_VAR 0 2
74736: PUSH
74737: LD_VAR 0 2
74741: PPUSH
74742: LD_INT 21
74744: PUSH
74745: LD_INT 3
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 24
74754: PUSH
74755: LD_INT 250
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PPUSH
74766: CALL_OW 72
74770: ST_TO_ADDR
// case class of 1 , 15 :
74771: LD_VAR 0 4
74775: PUSH
74776: LD_INT 1
74778: DOUBLE
74779: EQUAL
74780: IFTRUE 74790
74782: LD_INT 15
74784: DOUBLE
74785: EQUAL
74786: IFTRUE 74790
74788: GO 74875
74790: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74791: LD_ADDR_VAR 0 8
74795: PUSH
74796: LD_VAR 0 2
74800: PPUSH
74801: LD_INT 2
74803: PUSH
74804: LD_INT 30
74806: PUSH
74807: LD_INT 32
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 30
74816: PUSH
74817: LD_INT 31
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: LIST
74828: PPUSH
74829: CALL_OW 72
74833: PUSH
74834: LD_VAR 0 2
74838: PPUSH
74839: LD_INT 2
74841: PUSH
74842: LD_INT 30
74844: PUSH
74845: LD_INT 4
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 30
74854: PUSH
74855: LD_INT 5
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: LIST
74866: PPUSH
74867: CALL_OW 72
74871: ADD
74872: ST_TO_ADDR
74873: GO 75121
74875: LD_INT 2
74877: DOUBLE
74878: EQUAL
74879: IFTRUE 74889
74881: LD_INT 16
74883: DOUBLE
74884: EQUAL
74885: IFTRUE 74889
74887: GO 74935
74889: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74890: LD_ADDR_VAR 0 8
74894: PUSH
74895: LD_VAR 0 2
74899: PPUSH
74900: LD_INT 2
74902: PUSH
74903: LD_INT 30
74905: PUSH
74906: LD_INT 0
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 30
74915: PUSH
74916: LD_INT 1
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: LIST
74927: PPUSH
74928: CALL_OW 72
74932: ST_TO_ADDR
74933: GO 75121
74935: LD_INT 3
74937: DOUBLE
74938: EQUAL
74939: IFTRUE 74943
74941: GO 74989
74943: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74944: LD_ADDR_VAR 0 8
74948: PUSH
74949: LD_VAR 0 2
74953: PPUSH
74954: LD_INT 2
74956: PUSH
74957: LD_INT 30
74959: PUSH
74960: LD_INT 2
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 30
74969: PUSH
74970: LD_INT 3
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: PPUSH
74982: CALL_OW 72
74986: ST_TO_ADDR
74987: GO 75121
74989: LD_INT 4
74991: DOUBLE
74992: EQUAL
74993: IFTRUE 74997
74995: GO 75054
74997: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74998: LD_ADDR_VAR 0 8
75002: PUSH
75003: LD_VAR 0 2
75007: PPUSH
75008: LD_INT 2
75010: PUSH
75011: LD_INT 30
75013: PUSH
75014: LD_INT 6
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 30
75023: PUSH
75024: LD_INT 7
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 30
75033: PUSH
75034: LD_INT 8
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: PPUSH
75047: CALL_OW 72
75051: ST_TO_ADDR
75052: GO 75121
75054: LD_INT 5
75056: DOUBLE
75057: EQUAL
75058: IFTRUE 75074
75060: LD_INT 8
75062: DOUBLE
75063: EQUAL
75064: IFTRUE 75074
75066: LD_INT 9
75068: DOUBLE
75069: EQUAL
75070: IFTRUE 75074
75072: GO 75120
75074: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75075: LD_ADDR_VAR 0 8
75079: PUSH
75080: LD_VAR 0 2
75084: PPUSH
75085: LD_INT 2
75087: PUSH
75088: LD_INT 30
75090: PUSH
75091: LD_INT 4
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 30
75100: PUSH
75101: LD_INT 5
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: LIST
75112: PPUSH
75113: CALL_OW 72
75117: ST_TO_ADDR
75118: GO 75121
75120: POP
// if not tmp then
75121: LD_VAR 0 8
75125: NOT
75126: IFFALSE 75130
// exit ;
75128: GO 75632
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75130: LD_VAR 0 4
75134: PUSH
75135: LD_INT 1
75137: PUSH
75138: LD_INT 15
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: IN
75145: PUSH
75146: LD_EXP 68
75150: PUSH
75151: LD_VAR 0 1
75155: ARRAY
75156: AND
75157: IFFALSE 75313
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75159: LD_ADDR_VAR 0 9
75163: PUSH
75164: LD_EXP 68
75168: PUSH
75169: LD_VAR 0 1
75173: ARRAY
75174: PUSH
75175: LD_INT 1
75177: ARRAY
75178: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75179: LD_VAR 0 9
75183: PUSH
75184: LD_EXP 69
75188: PUSH
75189: LD_VAR 0 1
75193: ARRAY
75194: IN
75195: NOT
75196: IFFALSE 75311
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75198: LD_ADDR_EXP 69
75202: PUSH
75203: LD_EXP 69
75207: PPUSH
75208: LD_VAR 0 1
75212: PUSH
75213: LD_EXP 69
75217: PUSH
75218: LD_VAR 0 1
75222: ARRAY
75223: PUSH
75224: LD_INT 1
75226: PLUS
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PPUSH
75232: LD_VAR 0 9
75236: PPUSH
75237: CALL 19686 0 3
75241: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75242: LD_ADDR_EXP 68
75246: PUSH
75247: LD_EXP 68
75251: PPUSH
75252: LD_VAR 0 1
75256: PPUSH
75257: LD_EXP 68
75261: PUSH
75262: LD_VAR 0 1
75266: ARRAY
75267: PUSH
75268: LD_VAR 0 9
75272: DIFF
75273: PPUSH
75274: CALL_OW 1
75278: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75279: LD_VAR 0 3
75283: PPUSH
75284: LD_EXP 69
75288: PUSH
75289: LD_VAR 0 1
75293: ARRAY
75294: PUSH
75295: LD_EXP 69
75299: PUSH
75300: LD_VAR 0 1
75304: ARRAY
75305: ARRAY
75306: PPUSH
75307: CALL_OW 120
// end ; exit ;
75311: GO 75632
// end ; if tmp > 1 then
75313: LD_VAR 0 8
75317: PUSH
75318: LD_INT 1
75320: GREATER
75321: IFFALSE 75425
// for i = 2 to tmp do
75323: LD_ADDR_VAR 0 6
75327: PUSH
75328: DOUBLE
75329: LD_INT 2
75331: DEC
75332: ST_TO_ADDR
75333: LD_VAR 0 8
75337: PUSH
75338: FOR_TO
75339: IFFALSE 75423
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75341: LD_VAR 0 8
75345: PUSH
75346: LD_VAR 0 6
75350: ARRAY
75351: PPUSH
75352: CALL_OW 461
75356: PUSH
75357: LD_INT 6
75359: EQUAL
75360: IFFALSE 75421
// begin x := tmp [ i ] ;
75362: LD_ADDR_VAR 0 9
75366: PUSH
75367: LD_VAR 0 8
75371: PUSH
75372: LD_VAR 0 6
75376: ARRAY
75377: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75378: LD_ADDR_VAR 0 8
75382: PUSH
75383: LD_VAR 0 8
75387: PPUSH
75388: LD_VAR 0 6
75392: PPUSH
75393: CALL_OW 3
75397: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75398: LD_ADDR_VAR 0 8
75402: PUSH
75403: LD_VAR 0 8
75407: PPUSH
75408: LD_INT 1
75410: PPUSH
75411: LD_VAR 0 9
75415: PPUSH
75416: CALL_OW 2
75420: ST_TO_ADDR
// end ;
75421: GO 75338
75423: POP
75424: POP
// for i in tmp do
75425: LD_ADDR_VAR 0 6
75429: PUSH
75430: LD_VAR 0 8
75434: PUSH
75435: FOR_IN
75436: IFFALSE 75505
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75438: LD_VAR 0 6
75442: PPUSH
75443: CALL_OW 313
75447: PUSH
75448: LD_INT 6
75450: LESS
75451: PUSH
75452: LD_VAR 0 6
75456: PPUSH
75457: CALL_OW 266
75461: PUSH
75462: LD_INT 31
75464: PUSH
75465: LD_INT 32
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: IN
75472: NOT
75473: AND
75474: PUSH
75475: LD_VAR 0 6
75479: PPUSH
75480: CALL_OW 313
75484: PUSH
75485: LD_INT 0
75487: EQUAL
75488: OR
75489: IFFALSE 75503
// begin j := i ;
75491: LD_ADDR_VAR 0 7
75495: PUSH
75496: LD_VAR 0 6
75500: ST_TO_ADDR
// break ;
75501: GO 75505
// end ; end ;
75503: GO 75435
75505: POP
75506: POP
// if j then
75507: LD_VAR 0 7
75511: IFFALSE 75529
// ComEnterUnit ( unit , j ) else
75513: LD_VAR 0 3
75517: PPUSH
75518: LD_VAR 0 7
75522: PPUSH
75523: CALL_OW 120
75527: GO 75632
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75529: LD_ADDR_VAR 0 10
75533: PUSH
75534: LD_VAR 0 2
75538: PPUSH
75539: LD_INT 2
75541: PUSH
75542: LD_INT 30
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 30
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: LIST
75566: PPUSH
75567: CALL_OW 72
75571: ST_TO_ADDR
// if depot then
75572: LD_VAR 0 10
75576: IFFALSE 75632
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75578: LD_ADDR_VAR 0 10
75582: PUSH
75583: LD_VAR 0 10
75587: PPUSH
75588: LD_VAR 0 3
75592: PPUSH
75593: CALL_OW 74
75597: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75598: LD_VAR 0 3
75602: PPUSH
75603: LD_VAR 0 10
75607: PPUSH
75608: CALL_OW 296
75612: PUSH
75613: LD_INT 10
75615: GREATER
75616: IFFALSE 75632
// ComStandNearbyBuilding ( unit , depot ) ;
75618: LD_VAR 0 3
75622: PPUSH
75623: LD_VAR 0 10
75627: PPUSH
75628: CALL 16300 0 2
// end ; end ; end ;
75632: LD_VAR 0 5
75636: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75637: LD_INT 0
75639: PPUSH
75640: PPUSH
75641: PPUSH
75642: PPUSH
// if not mc_bases then
75643: LD_EXP 59
75647: NOT
75648: IFFALSE 75652
// exit ;
75650: GO 75891
// for i = 1 to mc_bases do
75652: LD_ADDR_VAR 0 2
75656: PUSH
75657: DOUBLE
75658: LD_INT 1
75660: DEC
75661: ST_TO_ADDR
75662: LD_EXP 59
75666: PUSH
75667: FOR_TO
75668: IFFALSE 75889
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75670: LD_ADDR_VAR 0 4
75674: PUSH
75675: LD_EXP 59
75679: PUSH
75680: LD_VAR 0 2
75684: ARRAY
75685: PPUSH
75686: LD_INT 21
75688: PUSH
75689: LD_INT 1
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PPUSH
75696: CALL_OW 72
75700: PUSH
75701: LD_EXP 88
75705: PUSH
75706: LD_VAR 0 2
75710: ARRAY
75711: UNION
75712: ST_TO_ADDR
// if not tmp then
75713: LD_VAR 0 4
75717: NOT
75718: IFFALSE 75722
// continue ;
75720: GO 75667
// for j in tmp do
75722: LD_ADDR_VAR 0 3
75726: PUSH
75727: LD_VAR 0 4
75731: PUSH
75732: FOR_IN
75733: IFFALSE 75885
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75735: LD_VAR 0 3
75739: PPUSH
75740: CALL_OW 110
75744: NOT
75745: PUSH
75746: LD_VAR 0 3
75750: PPUSH
75751: CALL_OW 314
75755: NOT
75756: AND
75757: PUSH
75758: LD_VAR 0 3
75762: PPUSH
75763: CALL_OW 311
75767: NOT
75768: AND
75769: PUSH
75770: LD_VAR 0 3
75774: PPUSH
75775: CALL_OW 310
75779: NOT
75780: AND
75781: PUSH
75782: LD_VAR 0 3
75786: PUSH
75787: LD_EXP 62
75791: PUSH
75792: LD_VAR 0 2
75796: ARRAY
75797: PUSH
75798: LD_INT 1
75800: ARRAY
75801: IN
75802: NOT
75803: AND
75804: PUSH
75805: LD_VAR 0 3
75809: PUSH
75810: LD_EXP 62
75814: PUSH
75815: LD_VAR 0 2
75819: ARRAY
75820: PUSH
75821: LD_INT 2
75823: ARRAY
75824: IN
75825: NOT
75826: AND
75827: PUSH
75828: LD_VAR 0 3
75832: PUSH
75833: LD_EXP 71
75837: PUSH
75838: LD_VAR 0 2
75842: ARRAY
75843: IN
75844: NOT
75845: AND
75846: IFFALSE 75883
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75848: LD_VAR 0 2
75852: PPUSH
75853: LD_EXP 59
75857: PUSH
75858: LD_VAR 0 2
75862: ARRAY
75863: PPUSH
75864: LD_VAR 0 3
75868: PPUSH
75869: LD_VAR 0 3
75873: PPUSH
75874: CALL_OW 257
75878: PPUSH
75879: CALL 74655 0 4
// end ;
75883: GO 75732
75885: POP
75886: POP
// end ;
75887: GO 75667
75889: POP
75890: POP
// end ;
75891: LD_VAR 0 1
75895: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75896: LD_INT 0
75898: PPUSH
75899: PPUSH
75900: PPUSH
75901: PPUSH
75902: PPUSH
75903: PPUSH
// if not mc_bases [ base ] then
75904: LD_EXP 59
75908: PUSH
75909: LD_VAR 0 1
75913: ARRAY
75914: NOT
75915: IFFALSE 75919
// exit ;
75917: GO 76101
// tmp := [ ] ;
75919: LD_ADDR_VAR 0 6
75923: PUSH
75924: EMPTY
75925: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75926: LD_ADDR_VAR 0 7
75930: PUSH
75931: LD_VAR 0 3
75935: PPUSH
75936: LD_INT 0
75938: PPUSH
75939: CALL_OW 517
75943: ST_TO_ADDR
// if not list then
75944: LD_VAR 0 7
75948: NOT
75949: IFFALSE 75953
// exit ;
75951: GO 76101
// for i = 1 to amount do
75953: LD_ADDR_VAR 0 5
75957: PUSH
75958: DOUBLE
75959: LD_INT 1
75961: DEC
75962: ST_TO_ADDR
75963: LD_VAR 0 2
75967: PUSH
75968: FOR_TO
75969: IFFALSE 76049
// begin x := rand ( 1 , list [ 1 ] ) ;
75971: LD_ADDR_VAR 0 8
75975: PUSH
75976: LD_INT 1
75978: PPUSH
75979: LD_VAR 0 7
75983: PUSH
75984: LD_INT 1
75986: ARRAY
75987: PPUSH
75988: CALL_OW 12
75992: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75993: LD_ADDR_VAR 0 6
75997: PUSH
75998: LD_VAR 0 6
76002: PPUSH
76003: LD_VAR 0 5
76007: PPUSH
76008: LD_VAR 0 7
76012: PUSH
76013: LD_INT 1
76015: ARRAY
76016: PUSH
76017: LD_VAR 0 8
76021: ARRAY
76022: PUSH
76023: LD_VAR 0 7
76027: PUSH
76028: LD_INT 2
76030: ARRAY
76031: PUSH
76032: LD_VAR 0 8
76036: ARRAY
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PPUSH
76042: CALL_OW 1
76046: ST_TO_ADDR
// end ;
76047: GO 75968
76049: POP
76050: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76051: LD_ADDR_EXP 72
76055: PUSH
76056: LD_EXP 72
76060: PPUSH
76061: LD_VAR 0 1
76065: PPUSH
76066: LD_VAR 0 6
76070: PPUSH
76071: CALL_OW 1
76075: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76076: LD_ADDR_EXP 74
76080: PUSH
76081: LD_EXP 74
76085: PPUSH
76086: LD_VAR 0 1
76090: PPUSH
76091: LD_VAR 0 3
76095: PPUSH
76096: CALL_OW 1
76100: ST_TO_ADDR
// end ;
76101: LD_VAR 0 4
76105: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76106: LD_INT 0
76108: PPUSH
// if not mc_bases [ base ] then
76109: LD_EXP 59
76113: PUSH
76114: LD_VAR 0 1
76118: ARRAY
76119: NOT
76120: IFFALSE 76124
// exit ;
76122: GO 76149
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76124: LD_ADDR_EXP 64
76128: PUSH
76129: LD_EXP 64
76133: PPUSH
76134: LD_VAR 0 1
76138: PPUSH
76139: LD_VAR 0 2
76143: PPUSH
76144: CALL_OW 1
76148: ST_TO_ADDR
// end ;
76149: LD_VAR 0 3
76153: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76154: LD_INT 0
76156: PPUSH
// if not mc_bases [ base ] then
76157: LD_EXP 59
76161: PUSH
76162: LD_VAR 0 1
76166: ARRAY
76167: NOT
76168: IFFALSE 76172
// exit ;
76170: GO 76209
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76172: LD_ADDR_EXP 64
76176: PUSH
76177: LD_EXP 64
76181: PPUSH
76182: LD_VAR 0 1
76186: PPUSH
76187: LD_EXP 64
76191: PUSH
76192: LD_VAR 0 1
76196: ARRAY
76197: PUSH
76198: LD_VAR 0 2
76202: UNION
76203: PPUSH
76204: CALL_OW 1
76208: ST_TO_ADDR
// end ;
76209: LD_VAR 0 3
76213: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76214: LD_INT 0
76216: PPUSH
// if not mc_bases [ base ] then
76217: LD_EXP 59
76221: PUSH
76222: LD_VAR 0 1
76226: ARRAY
76227: NOT
76228: IFFALSE 76232
// exit ;
76230: GO 76257
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76232: LD_ADDR_EXP 80
76236: PUSH
76237: LD_EXP 80
76241: PPUSH
76242: LD_VAR 0 1
76246: PPUSH
76247: LD_VAR 0 2
76251: PPUSH
76252: CALL_OW 1
76256: ST_TO_ADDR
// end ;
76257: LD_VAR 0 3
76261: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76262: LD_INT 0
76264: PPUSH
// if not mc_bases [ base ] then
76265: LD_EXP 59
76269: PUSH
76270: LD_VAR 0 1
76274: ARRAY
76275: NOT
76276: IFFALSE 76280
// exit ;
76278: GO 76317
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76280: LD_ADDR_EXP 80
76284: PUSH
76285: LD_EXP 80
76289: PPUSH
76290: LD_VAR 0 1
76294: PPUSH
76295: LD_EXP 80
76299: PUSH
76300: LD_VAR 0 1
76304: ARRAY
76305: PUSH
76306: LD_VAR 0 2
76310: ADD
76311: PPUSH
76312: CALL_OW 1
76316: ST_TO_ADDR
// end ;
76317: LD_VAR 0 3
76321: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76322: LD_INT 0
76324: PPUSH
// if not mc_bases [ base ] then
76325: LD_EXP 59
76329: PUSH
76330: LD_VAR 0 1
76334: ARRAY
76335: NOT
76336: IFFALSE 76340
// exit ;
76338: GO 76394
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76340: LD_ADDR_EXP 81
76344: PUSH
76345: LD_EXP 81
76349: PPUSH
76350: LD_VAR 0 1
76354: PPUSH
76355: LD_VAR 0 2
76359: PPUSH
76360: CALL_OW 1
76364: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76365: LD_ADDR_EXP 70
76369: PUSH
76370: LD_EXP 70
76374: PPUSH
76375: LD_VAR 0 1
76379: PPUSH
76380: LD_VAR 0 2
76384: PUSH
76385: LD_INT 0
76387: PLUS
76388: PPUSH
76389: CALL_OW 1
76393: ST_TO_ADDR
// end ;
76394: LD_VAR 0 3
76398: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76399: LD_INT 0
76401: PPUSH
// if not mc_bases [ base ] then
76402: LD_EXP 59
76406: PUSH
76407: LD_VAR 0 1
76411: ARRAY
76412: NOT
76413: IFFALSE 76417
// exit ;
76415: GO 76442
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76417: LD_ADDR_EXP 70
76421: PUSH
76422: LD_EXP 70
76426: PPUSH
76427: LD_VAR 0 1
76431: PPUSH
76432: LD_VAR 0 2
76436: PPUSH
76437: CALL_OW 1
76441: ST_TO_ADDR
// end ;
76442: LD_VAR 0 3
76446: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76447: LD_INT 0
76449: PPUSH
76450: PPUSH
76451: PPUSH
76452: PPUSH
// if not mc_bases [ base ] then
76453: LD_EXP 59
76457: PUSH
76458: LD_VAR 0 1
76462: ARRAY
76463: NOT
76464: IFFALSE 76468
// exit ;
76466: GO 76533
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76468: LD_ADDR_EXP 79
76472: PUSH
76473: LD_EXP 79
76477: PPUSH
76478: LD_VAR 0 1
76482: PUSH
76483: LD_EXP 79
76487: PUSH
76488: LD_VAR 0 1
76492: ARRAY
76493: PUSH
76494: LD_INT 1
76496: PLUS
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PPUSH
76502: LD_VAR 0 1
76506: PUSH
76507: LD_VAR 0 2
76511: PUSH
76512: LD_VAR 0 3
76516: PUSH
76517: LD_VAR 0 4
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: PPUSH
76528: CALL 19686 0 3
76532: ST_TO_ADDR
// end ;
76533: LD_VAR 0 5
76537: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76538: LD_INT 0
76540: PPUSH
// if not mc_bases [ base ] then
76541: LD_EXP 59
76545: PUSH
76546: LD_VAR 0 1
76550: ARRAY
76551: NOT
76552: IFFALSE 76556
// exit ;
76554: GO 76581
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76556: LD_ADDR_EXP 96
76560: PUSH
76561: LD_EXP 96
76565: PPUSH
76566: LD_VAR 0 1
76570: PPUSH
76571: LD_VAR 0 2
76575: PPUSH
76576: CALL_OW 1
76580: ST_TO_ADDR
// end ;
76581: LD_VAR 0 3
76585: RET
// export function MC_GetMinesField ( base ) ; begin
76586: LD_INT 0
76588: PPUSH
// result := mc_mines [ base ] ;
76589: LD_ADDR_VAR 0 2
76593: PUSH
76594: LD_EXP 72
76598: PUSH
76599: LD_VAR 0 1
76603: ARRAY
76604: ST_TO_ADDR
// end ;
76605: LD_VAR 0 2
76609: RET
// export function MC_GetProduceList ( base ) ; begin
76610: LD_INT 0
76612: PPUSH
// result := mc_produce [ base ] ;
76613: LD_ADDR_VAR 0 2
76617: PUSH
76618: LD_EXP 80
76622: PUSH
76623: LD_VAR 0 1
76627: ARRAY
76628: ST_TO_ADDR
// end ;
76629: LD_VAR 0 2
76633: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76634: LD_INT 0
76636: PPUSH
76637: PPUSH
// if not mc_bases then
76638: LD_EXP 59
76642: NOT
76643: IFFALSE 76647
// exit ;
76645: GO 76712
// if mc_bases [ base ] then
76647: LD_EXP 59
76651: PUSH
76652: LD_VAR 0 1
76656: ARRAY
76657: IFFALSE 76712
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76659: LD_ADDR_VAR 0 3
76663: PUSH
76664: LD_EXP 59
76668: PUSH
76669: LD_VAR 0 1
76673: ARRAY
76674: PPUSH
76675: LD_INT 30
76677: PUSH
76678: LD_VAR 0 2
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PPUSH
76687: CALL_OW 72
76691: ST_TO_ADDR
// if result then
76692: LD_VAR 0 3
76696: IFFALSE 76712
// result := result [ 1 ] ;
76698: LD_ADDR_VAR 0 3
76702: PUSH
76703: LD_VAR 0 3
76707: PUSH
76708: LD_INT 1
76710: ARRAY
76711: ST_TO_ADDR
// end ; end ;
76712: LD_VAR 0 3
76716: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76717: LD_INT 0
76719: PPUSH
76720: PPUSH
// if not mc_bases then
76721: LD_EXP 59
76725: NOT
76726: IFFALSE 76730
// exit ;
76728: GO 76775
// if mc_bases [ base ] then
76730: LD_EXP 59
76734: PUSH
76735: LD_VAR 0 1
76739: ARRAY
76740: IFFALSE 76775
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76742: LD_ADDR_VAR 0 3
76746: PUSH
76747: LD_EXP 59
76751: PUSH
76752: LD_VAR 0 1
76756: ARRAY
76757: PPUSH
76758: LD_INT 30
76760: PUSH
76761: LD_VAR 0 2
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PPUSH
76770: CALL_OW 72
76774: ST_TO_ADDR
// end ;
76775: LD_VAR 0 3
76779: RET
// export function MC_SetTame ( base , area ) ; begin
76780: LD_INT 0
76782: PPUSH
// if not mc_bases or not base then
76783: LD_EXP 59
76787: NOT
76788: PUSH
76789: LD_VAR 0 1
76793: NOT
76794: OR
76795: IFFALSE 76799
// exit ;
76797: GO 76824
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76799: LD_ADDR_EXP 87
76803: PUSH
76804: LD_EXP 87
76808: PPUSH
76809: LD_VAR 0 1
76813: PPUSH
76814: LD_VAR 0 2
76818: PPUSH
76819: CALL_OW 1
76823: ST_TO_ADDR
// end ;
76824: LD_VAR 0 3
76828: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76829: LD_INT 0
76831: PPUSH
76832: PPUSH
// if not mc_bases or not base then
76833: LD_EXP 59
76837: NOT
76838: PUSH
76839: LD_VAR 0 1
76843: NOT
76844: OR
76845: IFFALSE 76849
// exit ;
76847: GO 76951
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76849: LD_ADDR_VAR 0 4
76853: PUSH
76854: LD_EXP 59
76858: PUSH
76859: LD_VAR 0 1
76863: ARRAY
76864: PPUSH
76865: LD_INT 30
76867: PUSH
76868: LD_VAR 0 2
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PPUSH
76877: CALL_OW 72
76881: ST_TO_ADDR
// if not tmp then
76882: LD_VAR 0 4
76886: NOT
76887: IFFALSE 76891
// exit ;
76889: GO 76951
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76891: LD_ADDR_EXP 91
76895: PUSH
76896: LD_EXP 91
76900: PPUSH
76901: LD_VAR 0 1
76905: PPUSH
76906: LD_EXP 91
76910: PUSH
76911: LD_VAR 0 1
76915: ARRAY
76916: PPUSH
76917: LD_EXP 91
76921: PUSH
76922: LD_VAR 0 1
76926: ARRAY
76927: PUSH
76928: LD_INT 1
76930: PLUS
76931: PPUSH
76932: LD_VAR 0 4
76936: PUSH
76937: LD_INT 1
76939: ARRAY
76940: PPUSH
76941: CALL_OW 2
76945: PPUSH
76946: CALL_OW 1
76950: ST_TO_ADDR
// end ;
76951: LD_VAR 0 3
76955: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76956: LD_INT 0
76958: PPUSH
76959: PPUSH
// if not mc_bases or not base or not kinds then
76960: LD_EXP 59
76964: NOT
76965: PUSH
76966: LD_VAR 0 1
76970: NOT
76971: OR
76972: PUSH
76973: LD_VAR 0 2
76977: NOT
76978: OR
76979: IFFALSE 76983
// exit ;
76981: GO 77044
// for i in kinds do
76983: LD_ADDR_VAR 0 4
76987: PUSH
76988: LD_VAR 0 2
76992: PUSH
76993: FOR_IN
76994: IFFALSE 77042
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76996: LD_ADDR_EXP 93
77000: PUSH
77001: LD_EXP 93
77005: PPUSH
77006: LD_VAR 0 1
77010: PUSH
77011: LD_EXP 93
77015: PUSH
77016: LD_VAR 0 1
77020: ARRAY
77021: PUSH
77022: LD_INT 1
77024: PLUS
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PPUSH
77030: LD_VAR 0 4
77034: PPUSH
77035: CALL 19686 0 3
77039: ST_TO_ADDR
77040: GO 76993
77042: POP
77043: POP
// end ;
77044: LD_VAR 0 3
77048: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77049: LD_INT 0
77051: PPUSH
// if not mc_bases or not base or not areas then
77052: LD_EXP 59
77056: NOT
77057: PUSH
77058: LD_VAR 0 1
77062: NOT
77063: OR
77064: PUSH
77065: LD_VAR 0 2
77069: NOT
77070: OR
77071: IFFALSE 77075
// exit ;
77073: GO 77100
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77075: LD_ADDR_EXP 77
77079: PUSH
77080: LD_EXP 77
77084: PPUSH
77085: LD_VAR 0 1
77089: PPUSH
77090: LD_VAR 0 2
77094: PPUSH
77095: CALL_OW 1
77099: ST_TO_ADDR
// end ;
77100: LD_VAR 0 3
77104: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77105: LD_INT 0
77107: PPUSH
// if not mc_bases or not base or not teleports_exit then
77108: LD_EXP 59
77112: NOT
77113: PUSH
77114: LD_VAR 0 1
77118: NOT
77119: OR
77120: PUSH
77121: LD_VAR 0 2
77125: NOT
77126: OR
77127: IFFALSE 77131
// exit ;
77129: GO 77156
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77131: LD_ADDR_EXP 94
77135: PUSH
77136: LD_EXP 94
77140: PPUSH
77141: LD_VAR 0 1
77145: PPUSH
77146: LD_VAR 0 2
77150: PPUSH
77151: CALL_OW 1
77155: ST_TO_ADDR
// end ;
77156: LD_VAR 0 3
77160: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77161: LD_INT 0
77163: PPUSH
77164: PPUSH
77165: PPUSH
// if not mc_bases or not base or not ext_list then
77166: LD_EXP 59
77170: NOT
77171: PUSH
77172: LD_VAR 0 1
77176: NOT
77177: OR
77178: PUSH
77179: LD_VAR 0 5
77183: NOT
77184: OR
77185: IFFALSE 77189
// exit ;
77187: GO 77362
// tmp := GetFacExtXYD ( x , y , d ) ;
77189: LD_ADDR_VAR 0 8
77193: PUSH
77194: LD_VAR 0 2
77198: PPUSH
77199: LD_VAR 0 3
77203: PPUSH
77204: LD_VAR 0 4
77208: PPUSH
77209: CALL 48668 0 3
77213: ST_TO_ADDR
// if not tmp then
77214: LD_VAR 0 8
77218: NOT
77219: IFFALSE 77223
// exit ;
77221: GO 77362
// for i in tmp do
77223: LD_ADDR_VAR 0 7
77227: PUSH
77228: LD_VAR 0 8
77232: PUSH
77233: FOR_IN
77234: IFFALSE 77360
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77236: LD_ADDR_EXP 64
77240: PUSH
77241: LD_EXP 64
77245: PPUSH
77246: LD_VAR 0 1
77250: PPUSH
77251: LD_EXP 64
77255: PUSH
77256: LD_VAR 0 1
77260: ARRAY
77261: PPUSH
77262: LD_EXP 64
77266: PUSH
77267: LD_VAR 0 1
77271: ARRAY
77272: PUSH
77273: LD_INT 1
77275: PLUS
77276: PPUSH
77277: LD_VAR 0 5
77281: PUSH
77282: LD_INT 1
77284: ARRAY
77285: PUSH
77286: LD_VAR 0 7
77290: PUSH
77291: LD_INT 1
77293: ARRAY
77294: PUSH
77295: LD_VAR 0 7
77299: PUSH
77300: LD_INT 2
77302: ARRAY
77303: PUSH
77304: LD_VAR 0 7
77308: PUSH
77309: LD_INT 3
77311: ARRAY
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: PPUSH
77319: CALL_OW 2
77323: PPUSH
77324: CALL_OW 1
77328: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77329: LD_ADDR_VAR 0 5
77333: PUSH
77334: LD_VAR 0 5
77338: PPUSH
77339: LD_INT 1
77341: PPUSH
77342: CALL_OW 3
77346: ST_TO_ADDR
// if not ext_list then
77347: LD_VAR 0 5
77351: NOT
77352: IFFALSE 77358
// exit ;
77354: POP
77355: POP
77356: GO 77362
// end ;
77358: GO 77233
77360: POP
77361: POP
// end ;
77362: LD_VAR 0 6
77366: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77367: LD_INT 0
77369: PPUSH
// if not mc_bases or not base or not weapon_list then
77370: LD_EXP 59
77374: NOT
77375: PUSH
77376: LD_VAR 0 1
77380: NOT
77381: OR
77382: PUSH
77383: LD_VAR 0 2
77387: NOT
77388: OR
77389: IFFALSE 77393
// exit ;
77391: GO 77418
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77393: LD_ADDR_EXP 98
77397: PUSH
77398: LD_EXP 98
77402: PPUSH
77403: LD_VAR 0 1
77407: PPUSH
77408: LD_VAR 0 2
77412: PPUSH
77413: CALL_OW 1
77417: ST_TO_ADDR
// end ;
77418: LD_VAR 0 3
77422: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77423: LD_INT 0
77425: PPUSH
// if not mc_bases or not base or not tech_list then
77426: LD_EXP 59
77430: NOT
77431: PUSH
77432: LD_VAR 0 1
77436: NOT
77437: OR
77438: PUSH
77439: LD_VAR 0 2
77443: NOT
77444: OR
77445: IFFALSE 77449
// exit ;
77447: GO 77474
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77449: LD_ADDR_EXP 86
77453: PUSH
77454: LD_EXP 86
77458: PPUSH
77459: LD_VAR 0 1
77463: PPUSH
77464: LD_VAR 0 2
77468: PPUSH
77469: CALL_OW 1
77473: ST_TO_ADDR
// end ;
77474: LD_VAR 0 3
77478: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77479: LD_INT 0
77481: PPUSH
// if not mc_bases or not parking_area or not base then
77482: LD_EXP 59
77486: NOT
77487: PUSH
77488: LD_VAR 0 2
77492: NOT
77493: OR
77494: PUSH
77495: LD_VAR 0 1
77499: NOT
77500: OR
77501: IFFALSE 77505
// exit ;
77503: GO 77530
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77505: LD_ADDR_EXP 83
77509: PUSH
77510: LD_EXP 83
77514: PPUSH
77515: LD_VAR 0 1
77519: PPUSH
77520: LD_VAR 0 2
77524: PPUSH
77525: CALL_OW 1
77529: ST_TO_ADDR
// end ;
77530: LD_VAR 0 3
77534: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77535: LD_INT 0
77537: PPUSH
// if not mc_bases or not base or not scan_area then
77538: LD_EXP 59
77542: NOT
77543: PUSH
77544: LD_VAR 0 1
77548: NOT
77549: OR
77550: PUSH
77551: LD_VAR 0 2
77555: NOT
77556: OR
77557: IFFALSE 77561
// exit ;
77559: GO 77586
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77561: LD_ADDR_EXP 84
77565: PUSH
77566: LD_EXP 84
77570: PPUSH
77571: LD_VAR 0 1
77575: PPUSH
77576: LD_VAR 0 2
77580: PPUSH
77581: CALL_OW 1
77585: ST_TO_ADDR
// end ;
77586: LD_VAR 0 3
77590: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77591: LD_INT 0
77593: PPUSH
77594: PPUSH
// if not mc_bases or not base then
77595: LD_EXP 59
77599: NOT
77600: PUSH
77601: LD_VAR 0 1
77605: NOT
77606: OR
77607: IFFALSE 77611
// exit ;
77609: GO 77675
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77611: LD_ADDR_VAR 0 3
77615: PUSH
77616: LD_INT 1
77618: PUSH
77619: LD_INT 2
77621: PUSH
77622: LD_INT 3
77624: PUSH
77625: LD_INT 4
77627: PUSH
77628: LD_INT 11
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: LIST
77635: LIST
77636: LIST
77637: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77638: LD_ADDR_EXP 86
77642: PUSH
77643: LD_EXP 86
77647: PPUSH
77648: LD_VAR 0 1
77652: PPUSH
77653: LD_EXP 86
77657: PUSH
77658: LD_VAR 0 1
77662: ARRAY
77663: PUSH
77664: LD_VAR 0 3
77668: DIFF
77669: PPUSH
77670: CALL_OW 1
77674: ST_TO_ADDR
// end ;
77675: LD_VAR 0 2
77679: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77680: LD_INT 0
77682: PPUSH
// result := mc_vehicles [ base ] ;
77683: LD_ADDR_VAR 0 3
77687: PUSH
77688: LD_EXP 78
77692: PUSH
77693: LD_VAR 0 1
77697: ARRAY
77698: ST_TO_ADDR
// if onlyCombat then
77699: LD_VAR 0 2
77703: IFFALSE 77881
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77705: LD_ADDR_VAR 0 3
77709: PUSH
77710: LD_VAR 0 3
77714: PUSH
77715: LD_VAR 0 3
77719: PPUSH
77720: LD_INT 2
77722: PUSH
77723: LD_INT 34
77725: PUSH
77726: LD_INT 12
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 34
77735: PUSH
77736: LD_INT 51
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 34
77745: PUSH
77746: LD_EXP 104
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 34
77757: PUSH
77758: LD_INT 32
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 34
77767: PUSH
77768: LD_INT 13
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 34
77777: PUSH
77778: LD_INT 52
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 34
77787: PUSH
77788: LD_EXP 109
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 34
77799: PUSH
77800: LD_INT 14
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 34
77809: PUSH
77810: LD_INT 53
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 34
77819: PUSH
77820: LD_EXP 103
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 34
77831: PUSH
77832: LD_INT 31
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 34
77841: PUSH
77842: LD_INT 48
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 34
77851: PUSH
77852: LD_INT 8
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: LIST
77863: LIST
77864: LIST
77865: LIST
77866: LIST
77867: LIST
77868: LIST
77869: LIST
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: PPUSH
77875: CALL_OW 72
77879: DIFF
77880: ST_TO_ADDR
// end ; end_of_file
77881: LD_VAR 0 3
77885: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77886: LD_INT 0
77888: PPUSH
77889: PPUSH
77890: PPUSH
// if not mc_bases or not skirmish then
77891: LD_EXP 59
77895: NOT
77896: PUSH
77897: LD_EXP 57
77901: NOT
77902: OR
77903: IFFALSE 77907
// exit ;
77905: GO 78072
// for i = 1 to mc_bases do
77907: LD_ADDR_VAR 0 4
77911: PUSH
77912: DOUBLE
77913: LD_INT 1
77915: DEC
77916: ST_TO_ADDR
77917: LD_EXP 59
77921: PUSH
77922: FOR_TO
77923: IFFALSE 78070
// begin if sci in mc_bases [ i ] then
77925: LD_VAR 0 2
77929: PUSH
77930: LD_EXP 59
77934: PUSH
77935: LD_VAR 0 4
77939: ARRAY
77940: IN
77941: IFFALSE 78068
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77943: LD_ADDR_EXP 88
77947: PUSH
77948: LD_EXP 88
77952: PPUSH
77953: LD_VAR 0 4
77957: PUSH
77958: LD_EXP 88
77962: PUSH
77963: LD_VAR 0 4
77967: ARRAY
77968: PUSH
77969: LD_INT 1
77971: PLUS
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PPUSH
77977: LD_VAR 0 1
77981: PPUSH
77982: CALL 19686 0 3
77986: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77987: LD_ADDR_VAR 0 5
77991: PUSH
77992: LD_EXP 59
77996: PUSH
77997: LD_VAR 0 4
78001: ARRAY
78002: PPUSH
78003: LD_INT 2
78005: PUSH
78006: LD_INT 30
78008: PUSH
78009: LD_INT 0
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 30
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: PPUSH
78031: CALL_OW 72
78035: PPUSH
78036: LD_VAR 0 1
78040: PPUSH
78041: CALL_OW 74
78045: ST_TO_ADDR
// if tmp then
78046: LD_VAR 0 5
78050: IFFALSE 78066
// ComStandNearbyBuilding ( ape , tmp ) ;
78052: LD_VAR 0 1
78056: PPUSH
78057: LD_VAR 0 5
78061: PPUSH
78062: CALL 16300 0 2
// break ;
78066: GO 78070
// end ; end ;
78068: GO 77922
78070: POP
78071: POP
// end ;
78072: LD_VAR 0 3
78076: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78077: LD_INT 0
78079: PPUSH
78080: PPUSH
78081: PPUSH
// if not mc_bases or not skirmish then
78082: LD_EXP 59
78086: NOT
78087: PUSH
78088: LD_EXP 57
78092: NOT
78093: OR
78094: IFFALSE 78098
// exit ;
78096: GO 78187
// for i = 1 to mc_bases do
78098: LD_ADDR_VAR 0 4
78102: PUSH
78103: DOUBLE
78104: LD_INT 1
78106: DEC
78107: ST_TO_ADDR
78108: LD_EXP 59
78112: PUSH
78113: FOR_TO
78114: IFFALSE 78185
// begin if building in mc_busy_turret_list [ i ] then
78116: LD_VAR 0 1
78120: PUSH
78121: LD_EXP 69
78125: PUSH
78126: LD_VAR 0 4
78130: ARRAY
78131: IN
78132: IFFALSE 78183
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78134: LD_ADDR_VAR 0 5
78138: PUSH
78139: LD_EXP 69
78143: PUSH
78144: LD_VAR 0 4
78148: ARRAY
78149: PUSH
78150: LD_VAR 0 1
78154: DIFF
78155: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78156: LD_ADDR_EXP 69
78160: PUSH
78161: LD_EXP 69
78165: PPUSH
78166: LD_VAR 0 4
78170: PPUSH
78171: LD_VAR 0 5
78175: PPUSH
78176: CALL_OW 1
78180: ST_TO_ADDR
// break ;
78181: GO 78185
// end ; end ;
78183: GO 78113
78185: POP
78186: POP
// end ;
78187: LD_VAR 0 3
78191: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78192: LD_INT 0
78194: PPUSH
78195: PPUSH
78196: PPUSH
// if not mc_bases or not skirmish then
78197: LD_EXP 59
78201: NOT
78202: PUSH
78203: LD_EXP 57
78207: NOT
78208: OR
78209: IFFALSE 78213
// exit ;
78211: GO 78412
// for i = 1 to mc_bases do
78213: LD_ADDR_VAR 0 5
78217: PUSH
78218: DOUBLE
78219: LD_INT 1
78221: DEC
78222: ST_TO_ADDR
78223: LD_EXP 59
78227: PUSH
78228: FOR_TO
78229: IFFALSE 78410
// if building in mc_bases [ i ] then
78231: LD_VAR 0 1
78235: PUSH
78236: LD_EXP 59
78240: PUSH
78241: LD_VAR 0 5
78245: ARRAY
78246: IN
78247: IFFALSE 78408
// begin tmp := mc_bases [ i ] diff building ;
78249: LD_ADDR_VAR 0 6
78253: PUSH
78254: LD_EXP 59
78258: PUSH
78259: LD_VAR 0 5
78263: ARRAY
78264: PUSH
78265: LD_VAR 0 1
78269: DIFF
78270: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78271: LD_ADDR_EXP 59
78275: PUSH
78276: LD_EXP 59
78280: PPUSH
78281: LD_VAR 0 5
78285: PPUSH
78286: LD_VAR 0 6
78290: PPUSH
78291: CALL_OW 1
78295: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78296: LD_VAR 0 1
78300: PUSH
78301: LD_EXP 67
78305: PUSH
78306: LD_VAR 0 5
78310: ARRAY
78311: IN
78312: IFFALSE 78351
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78314: LD_ADDR_EXP 67
78318: PUSH
78319: LD_EXP 67
78323: PPUSH
78324: LD_VAR 0 5
78328: PPUSH
78329: LD_EXP 67
78333: PUSH
78334: LD_VAR 0 5
78338: ARRAY
78339: PUSH
78340: LD_VAR 0 1
78344: DIFF
78345: PPUSH
78346: CALL_OW 1
78350: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78351: LD_VAR 0 1
78355: PUSH
78356: LD_EXP 68
78360: PUSH
78361: LD_VAR 0 5
78365: ARRAY
78366: IN
78367: IFFALSE 78406
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78369: LD_ADDR_EXP 68
78373: PUSH
78374: LD_EXP 68
78378: PPUSH
78379: LD_VAR 0 5
78383: PPUSH
78384: LD_EXP 68
78388: PUSH
78389: LD_VAR 0 5
78393: ARRAY
78394: PUSH
78395: LD_VAR 0 1
78399: DIFF
78400: PPUSH
78401: CALL_OW 1
78405: ST_TO_ADDR
// break ;
78406: GO 78410
// end ;
78408: GO 78228
78410: POP
78411: POP
// end ;
78412: LD_VAR 0 4
78416: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78417: LD_INT 0
78419: PPUSH
78420: PPUSH
78421: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78422: LD_EXP 59
78426: NOT
78427: PUSH
78428: LD_EXP 57
78432: NOT
78433: OR
78434: PUSH
78435: LD_VAR 0 3
78439: PUSH
78440: LD_EXP 85
78444: IN
78445: NOT
78446: OR
78447: IFFALSE 78451
// exit ;
78449: GO 78574
// for i = 1 to mc_vehicles do
78451: LD_ADDR_VAR 0 6
78455: PUSH
78456: DOUBLE
78457: LD_INT 1
78459: DEC
78460: ST_TO_ADDR
78461: LD_EXP 78
78465: PUSH
78466: FOR_TO
78467: IFFALSE 78572
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78469: LD_VAR 0 2
78473: PUSH
78474: LD_EXP 78
78478: PUSH
78479: LD_VAR 0 6
78483: ARRAY
78484: IN
78485: PUSH
78486: LD_VAR 0 1
78490: PUSH
78491: LD_EXP 78
78495: PUSH
78496: LD_VAR 0 6
78500: ARRAY
78501: IN
78502: OR
78503: IFFALSE 78570
// begin tmp := mc_vehicles [ i ] diff old ;
78505: LD_ADDR_VAR 0 7
78509: PUSH
78510: LD_EXP 78
78514: PUSH
78515: LD_VAR 0 6
78519: ARRAY
78520: PUSH
78521: LD_VAR 0 2
78525: DIFF
78526: ST_TO_ADDR
// tmp := tmp diff new ;
78527: LD_ADDR_VAR 0 7
78531: PUSH
78532: LD_VAR 0 7
78536: PUSH
78537: LD_VAR 0 1
78541: DIFF
78542: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78543: LD_ADDR_EXP 78
78547: PUSH
78548: LD_EXP 78
78552: PPUSH
78553: LD_VAR 0 6
78557: PPUSH
78558: LD_VAR 0 7
78562: PPUSH
78563: CALL_OW 1
78567: ST_TO_ADDR
// break ;
78568: GO 78572
// end ;
78570: GO 78466
78572: POP
78573: POP
// end ;
78574: LD_VAR 0 5
78578: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78579: LD_INT 0
78581: PPUSH
78582: PPUSH
78583: PPUSH
78584: PPUSH
// if not mc_bases or not skirmish then
78585: LD_EXP 59
78589: NOT
78590: PUSH
78591: LD_EXP 57
78595: NOT
78596: OR
78597: IFFALSE 78601
// exit ;
78599: GO 78984
// side := GetSide ( vehicle ) ;
78601: LD_ADDR_VAR 0 5
78605: PUSH
78606: LD_VAR 0 1
78610: PPUSH
78611: CALL_OW 255
78615: ST_TO_ADDR
// for i = 1 to mc_bases do
78616: LD_ADDR_VAR 0 4
78620: PUSH
78621: DOUBLE
78622: LD_INT 1
78624: DEC
78625: ST_TO_ADDR
78626: LD_EXP 59
78630: PUSH
78631: FOR_TO
78632: IFFALSE 78982
// begin if factory in mc_bases [ i ] then
78634: LD_VAR 0 2
78638: PUSH
78639: LD_EXP 59
78643: PUSH
78644: LD_VAR 0 4
78648: ARRAY
78649: IN
78650: IFFALSE 78980
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78652: LD_EXP 81
78656: PUSH
78657: LD_VAR 0 4
78661: ARRAY
78662: PUSH
78663: LD_EXP 70
78667: PUSH
78668: LD_VAR 0 4
78672: ARRAY
78673: LESS
78674: PUSH
78675: LD_VAR 0 1
78679: PPUSH
78680: CALL_OW 264
78684: PUSH
78685: LD_INT 31
78687: PUSH
78688: LD_INT 32
78690: PUSH
78691: LD_INT 51
78693: PUSH
78694: LD_EXP 104
78698: PUSH
78699: LD_INT 12
78701: PUSH
78702: LD_INT 30
78704: PUSH
78705: LD_EXP 103
78709: PUSH
78710: LD_INT 11
78712: PUSH
78713: LD_INT 53
78715: PUSH
78716: LD_INT 14
78718: PUSH
78719: LD_EXP 107
78723: PUSH
78724: LD_INT 29
78726: PUSH
78727: LD_EXP 105
78731: PUSH
78732: LD_INT 13
78734: PUSH
78735: LD_INT 52
78737: PUSH
78738: LD_EXP 109
78742: PUSH
78743: LD_INT 48
78745: PUSH
78746: LD_INT 8
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: IN
78769: NOT
78770: AND
78771: IFFALSE 78819
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78773: LD_ADDR_EXP 81
78777: PUSH
78778: LD_EXP 81
78782: PPUSH
78783: LD_VAR 0 4
78787: PUSH
78788: LD_EXP 81
78792: PUSH
78793: LD_VAR 0 4
78797: ARRAY
78798: PUSH
78799: LD_INT 1
78801: PLUS
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PPUSH
78807: LD_VAR 0 1
78811: PPUSH
78812: CALL 19686 0 3
78816: ST_TO_ADDR
78817: GO 78863
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78819: LD_ADDR_EXP 78
78823: PUSH
78824: LD_EXP 78
78828: PPUSH
78829: LD_VAR 0 4
78833: PUSH
78834: LD_EXP 78
78838: PUSH
78839: LD_VAR 0 4
78843: ARRAY
78844: PUSH
78845: LD_INT 1
78847: PLUS
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PPUSH
78853: LD_VAR 0 1
78857: PPUSH
78858: CALL 19686 0 3
78862: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78863: LD_VAR 0 1
78867: PPUSH
78868: CALL_OW 263
78872: PUSH
78873: LD_INT 2
78875: EQUAL
78876: IFFALSE 78896
// begin repeat wait ( 0 0$1 ) ;
78878: LD_INT 35
78880: PPUSH
78881: CALL_OW 67
// until IsControledBy ( vehicle ) ;
78885: LD_VAR 0 1
78889: PPUSH
78890: CALL_OW 312
78894: IFFALSE 78878
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78896: LD_VAR 0 1
78900: PPUSH
78901: LD_EXP 83
78905: PUSH
78906: LD_VAR 0 4
78910: ARRAY
78911: PPUSH
78912: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78916: LD_VAR 0 1
78920: PPUSH
78921: CALL_OW 263
78925: PUSH
78926: LD_INT 1
78928: NONEQUAL
78929: IFFALSE 78933
// break ;
78931: GO 78982
// repeat wait ( 0 0$1 ) ;
78933: LD_INT 35
78935: PPUSH
78936: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78940: LD_VAR 0 1
78944: PPUSH
78945: LD_EXP 83
78949: PUSH
78950: LD_VAR 0 4
78954: ARRAY
78955: PPUSH
78956: CALL_OW 308
78960: IFFALSE 78933
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78962: LD_VAR 0 1
78966: PPUSH
78967: CALL_OW 311
78971: PPUSH
78972: CALL_OW 121
// exit ;
78976: POP
78977: POP
78978: GO 78984
// end ; end ;
78980: GO 78631
78982: POP
78983: POP
// end ;
78984: LD_VAR 0 3
78988: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78989: LD_INT 0
78991: PPUSH
78992: PPUSH
78993: PPUSH
78994: PPUSH
// if not mc_bases or not skirmish then
78995: LD_EXP 59
78999: NOT
79000: PUSH
79001: LD_EXP 57
79005: NOT
79006: OR
79007: IFFALSE 79011
// exit ;
79009: GO 79364
// repeat wait ( 0 0$1 ) ;
79011: LD_INT 35
79013: PPUSH
79014: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79018: LD_VAR 0 2
79022: PPUSH
79023: LD_VAR 0 3
79027: PPUSH
79028: CALL_OW 284
79032: IFFALSE 79011
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79034: LD_VAR 0 2
79038: PPUSH
79039: LD_VAR 0 3
79043: PPUSH
79044: CALL_OW 283
79048: PUSH
79049: LD_INT 4
79051: EQUAL
79052: IFFALSE 79056
// exit ;
79054: GO 79364
// for i = 1 to mc_bases do
79056: LD_ADDR_VAR 0 7
79060: PUSH
79061: DOUBLE
79062: LD_INT 1
79064: DEC
79065: ST_TO_ADDR
79066: LD_EXP 59
79070: PUSH
79071: FOR_TO
79072: IFFALSE 79362
// begin if mc_crates_area [ i ] then
79074: LD_EXP 77
79078: PUSH
79079: LD_VAR 0 7
79083: ARRAY
79084: IFFALSE 79195
// for j in mc_crates_area [ i ] do
79086: LD_ADDR_VAR 0 8
79090: PUSH
79091: LD_EXP 77
79095: PUSH
79096: LD_VAR 0 7
79100: ARRAY
79101: PUSH
79102: FOR_IN
79103: IFFALSE 79193
// if InArea ( x , y , j ) then
79105: LD_VAR 0 2
79109: PPUSH
79110: LD_VAR 0 3
79114: PPUSH
79115: LD_VAR 0 8
79119: PPUSH
79120: CALL_OW 309
79124: IFFALSE 79191
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79126: LD_ADDR_EXP 75
79130: PUSH
79131: LD_EXP 75
79135: PPUSH
79136: LD_VAR 0 7
79140: PUSH
79141: LD_EXP 75
79145: PUSH
79146: LD_VAR 0 7
79150: ARRAY
79151: PUSH
79152: LD_INT 1
79154: PLUS
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PPUSH
79160: LD_VAR 0 4
79164: PUSH
79165: LD_VAR 0 2
79169: PUSH
79170: LD_VAR 0 3
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: LIST
79179: PPUSH
79180: CALL 19686 0 3
79184: ST_TO_ADDR
// exit ;
79185: POP
79186: POP
79187: POP
79188: POP
79189: GO 79364
// end ;
79191: GO 79102
79193: POP
79194: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79195: LD_ADDR_VAR 0 9
79199: PUSH
79200: LD_EXP 59
79204: PUSH
79205: LD_VAR 0 7
79209: ARRAY
79210: PPUSH
79211: LD_INT 2
79213: PUSH
79214: LD_INT 30
79216: PUSH
79217: LD_INT 0
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 30
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: LIST
79238: PPUSH
79239: CALL_OW 72
79243: ST_TO_ADDR
// if not depot then
79244: LD_VAR 0 9
79248: NOT
79249: IFFALSE 79253
// continue ;
79251: GO 79071
// for j in depot do
79253: LD_ADDR_VAR 0 8
79257: PUSH
79258: LD_VAR 0 9
79262: PUSH
79263: FOR_IN
79264: IFFALSE 79358
// if GetDistUnitXY ( j , x , y ) < 30 then
79266: LD_VAR 0 8
79270: PPUSH
79271: LD_VAR 0 2
79275: PPUSH
79276: LD_VAR 0 3
79280: PPUSH
79281: CALL_OW 297
79285: PUSH
79286: LD_INT 30
79288: LESS
79289: IFFALSE 79356
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79291: LD_ADDR_EXP 75
79295: PUSH
79296: LD_EXP 75
79300: PPUSH
79301: LD_VAR 0 7
79305: PUSH
79306: LD_EXP 75
79310: PUSH
79311: LD_VAR 0 7
79315: ARRAY
79316: PUSH
79317: LD_INT 1
79319: PLUS
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PPUSH
79325: LD_VAR 0 4
79329: PUSH
79330: LD_VAR 0 2
79334: PUSH
79335: LD_VAR 0 3
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: LIST
79344: PPUSH
79345: CALL 19686 0 3
79349: ST_TO_ADDR
// exit ;
79350: POP
79351: POP
79352: POP
79353: POP
79354: GO 79364
// end ;
79356: GO 79263
79358: POP
79359: POP
// end ;
79360: GO 79071
79362: POP
79363: POP
// end ;
79364: LD_VAR 0 6
79368: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79369: LD_INT 0
79371: PPUSH
79372: PPUSH
79373: PPUSH
79374: PPUSH
// if not mc_bases or not skirmish then
79375: LD_EXP 59
79379: NOT
79380: PUSH
79381: LD_EXP 57
79385: NOT
79386: OR
79387: IFFALSE 79391
// exit ;
79389: GO 79668
// side := GetSide ( lab ) ;
79391: LD_ADDR_VAR 0 4
79395: PUSH
79396: LD_VAR 0 2
79400: PPUSH
79401: CALL_OW 255
79405: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79406: LD_VAR 0 4
79410: PUSH
79411: LD_EXP 85
79415: IN
79416: NOT
79417: PUSH
79418: LD_EXP 86
79422: NOT
79423: OR
79424: PUSH
79425: LD_EXP 59
79429: NOT
79430: OR
79431: IFFALSE 79435
// exit ;
79433: GO 79668
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79435: LD_ADDR_EXP 86
79439: PUSH
79440: LD_EXP 86
79444: PPUSH
79445: LD_VAR 0 4
79449: PPUSH
79450: LD_EXP 86
79454: PUSH
79455: LD_VAR 0 4
79459: ARRAY
79460: PUSH
79461: LD_VAR 0 1
79465: DIFF
79466: PPUSH
79467: CALL_OW 1
79471: ST_TO_ADDR
// for i = 1 to mc_bases do
79472: LD_ADDR_VAR 0 5
79476: PUSH
79477: DOUBLE
79478: LD_INT 1
79480: DEC
79481: ST_TO_ADDR
79482: LD_EXP 59
79486: PUSH
79487: FOR_TO
79488: IFFALSE 79666
// begin if lab in mc_bases [ i ] then
79490: LD_VAR 0 2
79494: PUSH
79495: LD_EXP 59
79499: PUSH
79500: LD_VAR 0 5
79504: ARRAY
79505: IN
79506: IFFALSE 79664
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79508: LD_VAR 0 1
79512: PUSH
79513: LD_INT 11
79515: PUSH
79516: LD_INT 4
79518: PUSH
79519: LD_INT 3
79521: PUSH
79522: LD_INT 2
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: IN
79531: PUSH
79532: LD_EXP 89
79536: PUSH
79537: LD_VAR 0 5
79541: ARRAY
79542: AND
79543: IFFALSE 79664
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79545: LD_ADDR_VAR 0 6
79549: PUSH
79550: LD_EXP 89
79554: PUSH
79555: LD_VAR 0 5
79559: ARRAY
79560: PUSH
79561: LD_INT 1
79563: ARRAY
79564: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79565: LD_ADDR_EXP 89
79569: PUSH
79570: LD_EXP 89
79574: PPUSH
79575: LD_VAR 0 5
79579: PPUSH
79580: EMPTY
79581: PPUSH
79582: CALL_OW 1
79586: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79587: LD_VAR 0 6
79591: PPUSH
79592: LD_INT 0
79594: PPUSH
79595: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79599: LD_VAR 0 6
79603: PPUSH
79604: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79608: LD_ADDR_EXP 88
79612: PUSH
79613: LD_EXP 88
79617: PPUSH
79618: LD_VAR 0 5
79622: PPUSH
79623: LD_EXP 88
79627: PUSH
79628: LD_VAR 0 5
79632: ARRAY
79633: PPUSH
79634: LD_INT 1
79636: PPUSH
79637: LD_VAR 0 6
79641: PPUSH
79642: CALL_OW 2
79646: PPUSH
79647: CALL_OW 1
79651: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79652: LD_VAR 0 5
79656: PPUSH
79657: LD_INT 112
79659: PPUSH
79660: CALL 56497 0 2
// end ; end ; end ;
79664: GO 79487
79666: POP
79667: POP
// end ;
79668: LD_VAR 0 3
79672: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79673: LD_INT 0
79675: PPUSH
79676: PPUSH
79677: PPUSH
79678: PPUSH
79679: PPUSH
79680: PPUSH
79681: PPUSH
79682: PPUSH
// if not mc_bases or not skirmish then
79683: LD_EXP 59
79687: NOT
79688: PUSH
79689: LD_EXP 57
79693: NOT
79694: OR
79695: IFFALSE 79699
// exit ;
79697: GO 81070
// for i = 1 to mc_bases do
79699: LD_ADDR_VAR 0 3
79703: PUSH
79704: DOUBLE
79705: LD_INT 1
79707: DEC
79708: ST_TO_ADDR
79709: LD_EXP 59
79713: PUSH
79714: FOR_TO
79715: IFFALSE 81068
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79717: LD_VAR 0 1
79721: PUSH
79722: LD_EXP 59
79726: PUSH
79727: LD_VAR 0 3
79731: ARRAY
79732: IN
79733: PUSH
79734: LD_VAR 0 1
79738: PUSH
79739: LD_EXP 66
79743: PUSH
79744: LD_VAR 0 3
79748: ARRAY
79749: IN
79750: OR
79751: PUSH
79752: LD_VAR 0 1
79756: PUSH
79757: LD_EXP 81
79761: PUSH
79762: LD_VAR 0 3
79766: ARRAY
79767: IN
79768: OR
79769: PUSH
79770: LD_VAR 0 1
79774: PUSH
79775: LD_EXP 78
79779: PUSH
79780: LD_VAR 0 3
79784: ARRAY
79785: IN
79786: OR
79787: PUSH
79788: LD_VAR 0 1
79792: PUSH
79793: LD_EXP 88
79797: PUSH
79798: LD_VAR 0 3
79802: ARRAY
79803: IN
79804: OR
79805: PUSH
79806: LD_VAR 0 1
79810: PUSH
79811: LD_EXP 89
79815: PUSH
79816: LD_VAR 0 3
79820: ARRAY
79821: IN
79822: OR
79823: IFFALSE 81066
// begin if un in mc_ape [ i ] then
79825: LD_VAR 0 1
79829: PUSH
79830: LD_EXP 88
79834: PUSH
79835: LD_VAR 0 3
79839: ARRAY
79840: IN
79841: IFFALSE 79880
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79843: LD_ADDR_EXP 88
79847: PUSH
79848: LD_EXP 88
79852: PPUSH
79853: LD_VAR 0 3
79857: PPUSH
79858: LD_EXP 88
79862: PUSH
79863: LD_VAR 0 3
79867: ARRAY
79868: PUSH
79869: LD_VAR 0 1
79873: DIFF
79874: PPUSH
79875: CALL_OW 1
79879: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79880: LD_VAR 0 1
79884: PUSH
79885: LD_EXP 89
79889: PUSH
79890: LD_VAR 0 3
79894: ARRAY
79895: IN
79896: IFFALSE 79920
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79898: LD_ADDR_EXP 89
79902: PUSH
79903: LD_EXP 89
79907: PPUSH
79908: LD_VAR 0 3
79912: PPUSH
79913: EMPTY
79914: PPUSH
79915: CALL_OW 1
79919: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79920: LD_VAR 0 1
79924: PPUSH
79925: CALL_OW 247
79929: PUSH
79930: LD_INT 2
79932: EQUAL
79933: PUSH
79934: LD_VAR 0 1
79938: PPUSH
79939: CALL_OW 110
79943: PUSH
79944: LD_INT 20
79946: EQUAL
79947: PUSH
79948: LD_VAR 0 1
79952: PUSH
79953: LD_EXP 81
79957: PUSH
79958: LD_VAR 0 3
79962: ARRAY
79963: IN
79964: OR
79965: PUSH
79966: LD_VAR 0 1
79970: PPUSH
79971: CALL_OW 264
79975: PUSH
79976: LD_INT 12
79978: PUSH
79979: LD_INT 51
79981: PUSH
79982: LD_EXP 104
79986: PUSH
79987: LD_INT 32
79989: PUSH
79990: LD_INT 13
79992: PUSH
79993: LD_INT 52
79995: PUSH
79996: LD_INT 31
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: IN
80008: OR
80009: AND
80010: IFFALSE 80318
// begin if un in mc_defender [ i ] then
80012: LD_VAR 0 1
80016: PUSH
80017: LD_EXP 81
80021: PUSH
80022: LD_VAR 0 3
80026: ARRAY
80027: IN
80028: IFFALSE 80067
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80030: LD_ADDR_EXP 81
80034: PUSH
80035: LD_EXP 81
80039: PPUSH
80040: LD_VAR 0 3
80044: PPUSH
80045: LD_EXP 81
80049: PUSH
80050: LD_VAR 0 3
80054: ARRAY
80055: PUSH
80056: LD_VAR 0 1
80060: DIFF
80061: PPUSH
80062: CALL_OW 1
80066: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80067: LD_ADDR_VAR 0 8
80071: PUSH
80072: LD_VAR 0 3
80076: PPUSH
80077: LD_INT 3
80079: PPUSH
80080: CALL 76717 0 2
80084: ST_TO_ADDR
// if fac then
80085: LD_VAR 0 8
80089: IFFALSE 80318
// begin for j in fac do
80091: LD_ADDR_VAR 0 4
80095: PUSH
80096: LD_VAR 0 8
80100: PUSH
80101: FOR_IN
80102: IFFALSE 80316
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80104: LD_ADDR_VAR 0 9
80108: PUSH
80109: LD_VAR 0 8
80113: PPUSH
80114: LD_VAR 0 1
80118: PPUSH
80119: CALL_OW 265
80123: PPUSH
80124: LD_VAR 0 1
80128: PPUSH
80129: CALL_OW 262
80133: PPUSH
80134: LD_VAR 0 1
80138: PPUSH
80139: CALL_OW 263
80143: PPUSH
80144: LD_VAR 0 1
80148: PPUSH
80149: CALL_OW 264
80153: PPUSH
80154: CALL 17218 0 5
80158: ST_TO_ADDR
// if components then
80159: LD_VAR 0 9
80163: IFFALSE 80314
// begin if GetWeapon ( un ) = ar_control_tower then
80165: LD_VAR 0 1
80169: PPUSH
80170: CALL_OW 264
80174: PUSH
80175: LD_INT 31
80177: EQUAL
80178: IFFALSE 80295
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80180: LD_VAR 0 1
80184: PPUSH
80185: CALL_OW 311
80189: PPUSH
80190: LD_INT 0
80192: PPUSH
80193: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80197: LD_ADDR_EXP 99
80201: PUSH
80202: LD_EXP 99
80206: PPUSH
80207: LD_VAR 0 3
80211: PPUSH
80212: LD_EXP 99
80216: PUSH
80217: LD_VAR 0 3
80221: ARRAY
80222: PUSH
80223: LD_VAR 0 1
80227: PPUSH
80228: CALL_OW 311
80232: DIFF
80233: PPUSH
80234: CALL_OW 1
80238: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80239: LD_ADDR_VAR 0 7
80243: PUSH
80244: LD_EXP 80
80248: PUSH
80249: LD_VAR 0 3
80253: ARRAY
80254: PPUSH
80255: LD_INT 1
80257: PPUSH
80258: LD_VAR 0 9
80262: PPUSH
80263: CALL_OW 2
80267: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80268: LD_ADDR_EXP 80
80272: PUSH
80273: LD_EXP 80
80277: PPUSH
80278: LD_VAR 0 3
80282: PPUSH
80283: LD_VAR 0 7
80287: PPUSH
80288: CALL_OW 1
80292: ST_TO_ADDR
// end else
80293: GO 80312
// MC_InsertProduceList ( i , [ components ] ) ;
80295: LD_VAR 0 3
80299: PPUSH
80300: LD_VAR 0 9
80304: PUSH
80305: EMPTY
80306: LIST
80307: PPUSH
80308: CALL 76262 0 2
// break ;
80312: GO 80316
// end ; end ;
80314: GO 80101
80316: POP
80317: POP
// end ; end ; if GetType ( un ) = unit_building then
80318: LD_VAR 0 1
80322: PPUSH
80323: CALL_OW 247
80327: PUSH
80328: LD_INT 3
80330: EQUAL
80331: IFFALSE 80734
// begin btype := GetBType ( un ) ;
80333: LD_ADDR_VAR 0 5
80337: PUSH
80338: LD_VAR 0 1
80342: PPUSH
80343: CALL_OW 266
80347: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80348: LD_VAR 0 5
80352: PUSH
80353: LD_INT 29
80355: PUSH
80356: LD_INT 30
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: IN
80363: IFFALSE 80436
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80365: LD_VAR 0 1
80369: PPUSH
80370: CALL_OW 250
80374: PPUSH
80375: LD_VAR 0 1
80379: PPUSH
80380: CALL_OW 251
80384: PPUSH
80385: LD_VAR 0 1
80389: PPUSH
80390: CALL_OW 255
80394: PPUSH
80395: CALL_OW 440
80399: NOT
80400: IFFALSE 80436
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80402: LD_VAR 0 1
80406: PPUSH
80407: CALL_OW 250
80411: PPUSH
80412: LD_VAR 0 1
80416: PPUSH
80417: CALL_OW 251
80421: PPUSH
80422: LD_VAR 0 1
80426: PPUSH
80427: CALL_OW 255
80431: PPUSH
80432: CALL_OW 441
// end ; if btype = b_warehouse then
80436: LD_VAR 0 5
80440: PUSH
80441: LD_INT 1
80443: EQUAL
80444: IFFALSE 80462
// begin btype := b_depot ;
80446: LD_ADDR_VAR 0 5
80450: PUSH
80451: LD_INT 0
80453: ST_TO_ADDR
// pos := 1 ;
80454: LD_ADDR_VAR 0 6
80458: PUSH
80459: LD_INT 1
80461: ST_TO_ADDR
// end ; if btype = b_factory then
80462: LD_VAR 0 5
80466: PUSH
80467: LD_INT 3
80469: EQUAL
80470: IFFALSE 80488
// begin btype := b_workshop ;
80472: LD_ADDR_VAR 0 5
80476: PUSH
80477: LD_INT 2
80479: ST_TO_ADDR
// pos := 1 ;
80480: LD_ADDR_VAR 0 6
80484: PUSH
80485: LD_INT 1
80487: ST_TO_ADDR
// end ; if btype = b_barracks then
80488: LD_VAR 0 5
80492: PUSH
80493: LD_INT 5
80495: EQUAL
80496: IFFALSE 80506
// btype := b_armoury ;
80498: LD_ADDR_VAR 0 5
80502: PUSH
80503: LD_INT 4
80505: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80506: LD_VAR 0 5
80510: PUSH
80511: LD_INT 7
80513: PUSH
80514: LD_INT 8
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: IN
80521: IFFALSE 80531
// btype := b_lab ;
80523: LD_ADDR_VAR 0 5
80527: PUSH
80528: LD_INT 6
80530: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80531: LD_ADDR_EXP 64
80535: PUSH
80536: LD_EXP 64
80540: PPUSH
80541: LD_VAR 0 3
80545: PUSH
80546: LD_EXP 64
80550: PUSH
80551: LD_VAR 0 3
80555: ARRAY
80556: PUSH
80557: LD_INT 1
80559: PLUS
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PPUSH
80565: LD_VAR 0 5
80569: PUSH
80570: LD_VAR 0 1
80574: PPUSH
80575: CALL_OW 250
80579: PUSH
80580: LD_VAR 0 1
80584: PPUSH
80585: CALL_OW 251
80589: PUSH
80590: LD_VAR 0 1
80594: PPUSH
80595: CALL_OW 254
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: PPUSH
80606: CALL 19686 0 3
80610: ST_TO_ADDR
// if pos = 1 then
80611: LD_VAR 0 6
80615: PUSH
80616: LD_INT 1
80618: EQUAL
80619: IFFALSE 80734
// begin tmp := mc_build_list [ i ] ;
80621: LD_ADDR_VAR 0 7
80625: PUSH
80626: LD_EXP 64
80630: PUSH
80631: LD_VAR 0 3
80635: ARRAY
80636: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80637: LD_VAR 0 7
80641: PPUSH
80642: LD_INT 2
80644: PUSH
80645: LD_INT 30
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 30
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: LIST
80669: PPUSH
80670: CALL_OW 72
80674: IFFALSE 80684
// pos := 2 ;
80676: LD_ADDR_VAR 0 6
80680: PUSH
80681: LD_INT 2
80683: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80684: LD_ADDR_VAR 0 7
80688: PUSH
80689: LD_VAR 0 7
80693: PPUSH
80694: LD_VAR 0 6
80698: PPUSH
80699: LD_VAR 0 7
80703: PPUSH
80704: CALL 20012 0 3
80708: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80709: LD_ADDR_EXP 64
80713: PUSH
80714: LD_EXP 64
80718: PPUSH
80719: LD_VAR 0 3
80723: PPUSH
80724: LD_VAR 0 7
80728: PPUSH
80729: CALL_OW 1
80733: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80734: LD_VAR 0 1
80738: PUSH
80739: LD_EXP 59
80743: PUSH
80744: LD_VAR 0 3
80748: ARRAY
80749: IN
80750: IFFALSE 80789
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80752: LD_ADDR_EXP 59
80756: PUSH
80757: LD_EXP 59
80761: PPUSH
80762: LD_VAR 0 3
80766: PPUSH
80767: LD_EXP 59
80771: PUSH
80772: LD_VAR 0 3
80776: ARRAY
80777: PUSH
80778: LD_VAR 0 1
80782: DIFF
80783: PPUSH
80784: CALL_OW 1
80788: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80789: LD_VAR 0 1
80793: PUSH
80794: LD_EXP 66
80798: PUSH
80799: LD_VAR 0 3
80803: ARRAY
80804: IN
80805: IFFALSE 80844
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80807: LD_ADDR_EXP 66
80811: PUSH
80812: LD_EXP 66
80816: PPUSH
80817: LD_VAR 0 3
80821: PPUSH
80822: LD_EXP 66
80826: PUSH
80827: LD_VAR 0 3
80831: ARRAY
80832: PUSH
80833: LD_VAR 0 1
80837: DIFF
80838: PPUSH
80839: CALL_OW 1
80843: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80844: LD_VAR 0 1
80848: PUSH
80849: LD_EXP 78
80853: PUSH
80854: LD_VAR 0 3
80858: ARRAY
80859: IN
80860: IFFALSE 80899
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80862: LD_ADDR_EXP 78
80866: PUSH
80867: LD_EXP 78
80871: PPUSH
80872: LD_VAR 0 3
80876: PPUSH
80877: LD_EXP 78
80881: PUSH
80882: LD_VAR 0 3
80886: ARRAY
80887: PUSH
80888: LD_VAR 0 1
80892: DIFF
80893: PPUSH
80894: CALL_OW 1
80898: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80899: LD_VAR 0 1
80903: PUSH
80904: LD_EXP 81
80908: PUSH
80909: LD_VAR 0 3
80913: ARRAY
80914: IN
80915: IFFALSE 80954
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80917: LD_ADDR_EXP 81
80921: PUSH
80922: LD_EXP 81
80926: PPUSH
80927: LD_VAR 0 3
80931: PPUSH
80932: LD_EXP 81
80936: PUSH
80937: LD_VAR 0 3
80941: ARRAY
80942: PUSH
80943: LD_VAR 0 1
80947: DIFF
80948: PPUSH
80949: CALL_OW 1
80953: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80954: LD_VAR 0 1
80958: PUSH
80959: LD_EXP 68
80963: PUSH
80964: LD_VAR 0 3
80968: ARRAY
80969: IN
80970: IFFALSE 81009
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80972: LD_ADDR_EXP 68
80976: PUSH
80977: LD_EXP 68
80981: PPUSH
80982: LD_VAR 0 3
80986: PPUSH
80987: LD_EXP 68
80991: PUSH
80992: LD_VAR 0 3
80996: ARRAY
80997: PUSH
80998: LD_VAR 0 1
81002: DIFF
81003: PPUSH
81004: CALL_OW 1
81008: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81009: LD_VAR 0 1
81013: PUSH
81014: LD_EXP 67
81018: PUSH
81019: LD_VAR 0 3
81023: ARRAY
81024: IN
81025: IFFALSE 81064
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81027: LD_ADDR_EXP 67
81031: PUSH
81032: LD_EXP 67
81036: PPUSH
81037: LD_VAR 0 3
81041: PPUSH
81042: LD_EXP 67
81046: PUSH
81047: LD_VAR 0 3
81051: ARRAY
81052: PUSH
81053: LD_VAR 0 1
81057: DIFF
81058: PPUSH
81059: CALL_OW 1
81063: ST_TO_ADDR
// end ; break ;
81064: GO 81068
// end ;
81066: GO 79714
81068: POP
81069: POP
// end ;
81070: LD_VAR 0 2
81074: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81075: LD_INT 0
81077: PPUSH
81078: PPUSH
81079: PPUSH
// if not mc_bases or not skirmish then
81080: LD_EXP 59
81084: NOT
81085: PUSH
81086: LD_EXP 57
81090: NOT
81091: OR
81092: IFFALSE 81096
// exit ;
81094: GO 81311
// for i = 1 to mc_bases do
81096: LD_ADDR_VAR 0 3
81100: PUSH
81101: DOUBLE
81102: LD_INT 1
81104: DEC
81105: ST_TO_ADDR
81106: LD_EXP 59
81110: PUSH
81111: FOR_TO
81112: IFFALSE 81309
// begin if building in mc_construct_list [ i ] then
81114: LD_VAR 0 1
81118: PUSH
81119: LD_EXP 66
81123: PUSH
81124: LD_VAR 0 3
81128: ARRAY
81129: IN
81130: IFFALSE 81307
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81132: LD_ADDR_EXP 66
81136: PUSH
81137: LD_EXP 66
81141: PPUSH
81142: LD_VAR 0 3
81146: PPUSH
81147: LD_EXP 66
81151: PUSH
81152: LD_VAR 0 3
81156: ARRAY
81157: PUSH
81158: LD_VAR 0 1
81162: DIFF
81163: PPUSH
81164: CALL_OW 1
81168: ST_TO_ADDR
// if building in mc_lab [ i ] then
81169: LD_VAR 0 1
81173: PUSH
81174: LD_EXP 92
81178: PUSH
81179: LD_VAR 0 3
81183: ARRAY
81184: IN
81185: IFFALSE 81240
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81187: LD_ADDR_EXP 93
81191: PUSH
81192: LD_EXP 93
81196: PPUSH
81197: LD_VAR 0 3
81201: PPUSH
81202: LD_EXP 93
81206: PUSH
81207: LD_VAR 0 3
81211: ARRAY
81212: PPUSH
81213: LD_INT 1
81215: PPUSH
81216: LD_EXP 93
81220: PUSH
81221: LD_VAR 0 3
81225: ARRAY
81226: PPUSH
81227: LD_INT 0
81229: PPUSH
81230: CALL 19104 0 4
81234: PPUSH
81235: CALL_OW 1
81239: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81240: LD_VAR 0 1
81244: PUSH
81245: LD_EXP 59
81249: PUSH
81250: LD_VAR 0 3
81254: ARRAY
81255: IN
81256: NOT
81257: IFFALSE 81303
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81259: LD_ADDR_EXP 59
81263: PUSH
81264: LD_EXP 59
81268: PPUSH
81269: LD_VAR 0 3
81273: PUSH
81274: LD_EXP 59
81278: PUSH
81279: LD_VAR 0 3
81283: ARRAY
81284: PUSH
81285: LD_INT 1
81287: PLUS
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PPUSH
81293: LD_VAR 0 1
81297: PPUSH
81298: CALL 19686 0 3
81302: ST_TO_ADDR
// exit ;
81303: POP
81304: POP
81305: GO 81311
// end ; end ;
81307: GO 81111
81309: POP
81310: POP
// end ;
81311: LD_VAR 0 2
81315: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81316: LD_INT 0
81318: PPUSH
81319: PPUSH
81320: PPUSH
81321: PPUSH
81322: PPUSH
81323: PPUSH
81324: PPUSH
// if not mc_bases or not skirmish then
81325: LD_EXP 59
81329: NOT
81330: PUSH
81331: LD_EXP 57
81335: NOT
81336: OR
81337: IFFALSE 81341
// exit ;
81339: GO 82002
// for i = 1 to mc_bases do
81341: LD_ADDR_VAR 0 3
81345: PUSH
81346: DOUBLE
81347: LD_INT 1
81349: DEC
81350: ST_TO_ADDR
81351: LD_EXP 59
81355: PUSH
81356: FOR_TO
81357: IFFALSE 82000
// begin if building in mc_construct_list [ i ] then
81359: LD_VAR 0 1
81363: PUSH
81364: LD_EXP 66
81368: PUSH
81369: LD_VAR 0 3
81373: ARRAY
81374: IN
81375: IFFALSE 81998
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81377: LD_ADDR_EXP 66
81381: PUSH
81382: LD_EXP 66
81386: PPUSH
81387: LD_VAR 0 3
81391: PPUSH
81392: LD_EXP 66
81396: PUSH
81397: LD_VAR 0 3
81401: ARRAY
81402: PUSH
81403: LD_VAR 0 1
81407: DIFF
81408: PPUSH
81409: CALL_OW 1
81413: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81414: LD_ADDR_EXP 59
81418: PUSH
81419: LD_EXP 59
81423: PPUSH
81424: LD_VAR 0 3
81428: PUSH
81429: LD_EXP 59
81433: PUSH
81434: LD_VAR 0 3
81438: ARRAY
81439: PUSH
81440: LD_INT 1
81442: PLUS
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PPUSH
81448: LD_VAR 0 1
81452: PPUSH
81453: CALL 19686 0 3
81457: ST_TO_ADDR
// btype := GetBType ( building ) ;
81458: LD_ADDR_VAR 0 5
81462: PUSH
81463: LD_VAR 0 1
81467: PPUSH
81468: CALL_OW 266
81472: ST_TO_ADDR
// side := GetSide ( building ) ;
81473: LD_ADDR_VAR 0 8
81477: PUSH
81478: LD_VAR 0 1
81482: PPUSH
81483: CALL_OW 255
81487: ST_TO_ADDR
// if btype = b_lab then
81488: LD_VAR 0 5
81492: PUSH
81493: LD_INT 6
81495: EQUAL
81496: IFFALSE 81546
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81498: LD_ADDR_EXP 92
81502: PUSH
81503: LD_EXP 92
81507: PPUSH
81508: LD_VAR 0 3
81512: PUSH
81513: LD_EXP 92
81517: PUSH
81518: LD_VAR 0 3
81522: ARRAY
81523: PUSH
81524: LD_INT 1
81526: PLUS
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PPUSH
81532: LD_VAR 0 1
81536: PPUSH
81537: CALL 19686 0 3
81541: ST_TO_ADDR
// exit ;
81542: POP
81543: POP
81544: GO 82002
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81546: LD_VAR 0 5
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: LD_INT 2
81556: PUSH
81557: LD_INT 4
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: LIST
81564: IN
81565: IFFALSE 81689
// begin if btype = b_armoury then
81567: LD_VAR 0 5
81571: PUSH
81572: LD_INT 4
81574: EQUAL
81575: IFFALSE 81585
// btype := b_barracks ;
81577: LD_ADDR_VAR 0 5
81581: PUSH
81582: LD_INT 5
81584: ST_TO_ADDR
// if btype = b_depot then
81585: LD_VAR 0 5
81589: PUSH
81590: LD_INT 0
81592: EQUAL
81593: IFFALSE 81603
// btype := b_warehouse ;
81595: LD_ADDR_VAR 0 5
81599: PUSH
81600: LD_INT 1
81602: ST_TO_ADDR
// if btype = b_workshop then
81603: LD_VAR 0 5
81607: PUSH
81608: LD_INT 2
81610: EQUAL
81611: IFFALSE 81621
// btype := b_factory ;
81613: LD_ADDR_VAR 0 5
81617: PUSH
81618: LD_INT 3
81620: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81621: LD_VAR 0 5
81625: PPUSH
81626: LD_VAR 0 8
81630: PPUSH
81631: CALL_OW 323
81635: PUSH
81636: LD_INT 1
81638: EQUAL
81639: IFFALSE 81685
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81641: LD_ADDR_EXP 91
81645: PUSH
81646: LD_EXP 91
81650: PPUSH
81651: LD_VAR 0 3
81655: PUSH
81656: LD_EXP 91
81660: PUSH
81661: LD_VAR 0 3
81665: ARRAY
81666: PUSH
81667: LD_INT 1
81669: PLUS
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PPUSH
81675: LD_VAR 0 1
81679: PPUSH
81680: CALL 19686 0 3
81684: ST_TO_ADDR
// exit ;
81685: POP
81686: POP
81687: GO 82002
// end ; if btype in [ b_bunker , b_turret ] then
81689: LD_VAR 0 5
81693: PUSH
81694: LD_INT 32
81696: PUSH
81697: LD_INT 33
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: IN
81704: IFFALSE 81994
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81706: LD_ADDR_EXP 67
81710: PUSH
81711: LD_EXP 67
81715: PPUSH
81716: LD_VAR 0 3
81720: PUSH
81721: LD_EXP 67
81725: PUSH
81726: LD_VAR 0 3
81730: ARRAY
81731: PUSH
81732: LD_INT 1
81734: PLUS
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PPUSH
81740: LD_VAR 0 1
81744: PPUSH
81745: CALL 19686 0 3
81749: ST_TO_ADDR
// if btype = b_bunker then
81750: LD_VAR 0 5
81754: PUSH
81755: LD_INT 32
81757: EQUAL
81758: IFFALSE 81994
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81760: LD_ADDR_EXP 68
81764: PUSH
81765: LD_EXP 68
81769: PPUSH
81770: LD_VAR 0 3
81774: PUSH
81775: LD_EXP 68
81779: PUSH
81780: LD_VAR 0 3
81784: ARRAY
81785: PUSH
81786: LD_INT 1
81788: PLUS
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PPUSH
81794: LD_VAR 0 1
81798: PPUSH
81799: CALL 19686 0 3
81803: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81804: LD_ADDR_VAR 0 6
81808: PUSH
81809: LD_EXP 59
81813: PUSH
81814: LD_VAR 0 3
81818: ARRAY
81819: PPUSH
81820: LD_INT 25
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 3
81832: PUSH
81833: LD_INT 54
81835: PUSH
81836: EMPTY
81837: LIST
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PPUSH
81847: CALL_OW 72
81851: ST_TO_ADDR
// if tmp then
81852: LD_VAR 0 6
81856: IFFALSE 81862
// exit ;
81858: POP
81859: POP
81860: GO 82002
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81862: LD_ADDR_VAR 0 6
81866: PUSH
81867: LD_EXP 59
81871: PUSH
81872: LD_VAR 0 3
81876: ARRAY
81877: PPUSH
81878: LD_INT 2
81880: PUSH
81881: LD_INT 30
81883: PUSH
81884: LD_INT 4
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 30
81893: PUSH
81894: LD_INT 5
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: LIST
81905: PPUSH
81906: CALL_OW 72
81910: ST_TO_ADDR
// if not tmp then
81911: LD_VAR 0 6
81915: NOT
81916: IFFALSE 81922
// exit ;
81918: POP
81919: POP
81920: GO 82002
// for j in tmp do
81922: LD_ADDR_VAR 0 4
81926: PUSH
81927: LD_VAR 0 6
81931: PUSH
81932: FOR_IN
81933: IFFALSE 81992
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81935: LD_ADDR_VAR 0 7
81939: PUSH
81940: LD_VAR 0 4
81944: PPUSH
81945: CALL_OW 313
81949: PPUSH
81950: LD_INT 25
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PPUSH
81960: CALL_OW 72
81964: ST_TO_ADDR
// if units then
81965: LD_VAR 0 7
81969: IFFALSE 81990
// begin ComExitBuilding ( units [ 1 ] ) ;
81971: LD_VAR 0 7
81975: PUSH
81976: LD_INT 1
81978: ARRAY
81979: PPUSH
81980: CALL_OW 122
// exit ;
81984: POP
81985: POP
81986: POP
81987: POP
81988: GO 82002
// end ; end ;
81990: GO 81932
81992: POP
81993: POP
// end ; end ; exit ;
81994: POP
81995: POP
81996: GO 82002
// end ; end ;
81998: GO 81356
82000: POP
82001: POP
// end ;
82002: LD_VAR 0 2
82006: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82007: LD_INT 0
82009: PPUSH
82010: PPUSH
82011: PPUSH
82012: PPUSH
82013: PPUSH
82014: PPUSH
82015: PPUSH
// if not mc_bases or not skirmish then
82016: LD_EXP 59
82020: NOT
82021: PUSH
82022: LD_EXP 57
82026: NOT
82027: OR
82028: IFFALSE 82032
// exit ;
82030: GO 82297
// btype := GetBType ( building ) ;
82032: LD_ADDR_VAR 0 6
82036: PUSH
82037: LD_VAR 0 1
82041: PPUSH
82042: CALL_OW 266
82046: ST_TO_ADDR
// x := GetX ( building ) ;
82047: LD_ADDR_VAR 0 7
82051: PUSH
82052: LD_VAR 0 1
82056: PPUSH
82057: CALL_OW 250
82061: ST_TO_ADDR
// y := GetY ( building ) ;
82062: LD_ADDR_VAR 0 8
82066: PUSH
82067: LD_VAR 0 1
82071: PPUSH
82072: CALL_OW 251
82076: ST_TO_ADDR
// d := GetDir ( building ) ;
82077: LD_ADDR_VAR 0 9
82081: PUSH
82082: LD_VAR 0 1
82086: PPUSH
82087: CALL_OW 254
82091: ST_TO_ADDR
// for i = 1 to mc_bases do
82092: LD_ADDR_VAR 0 4
82096: PUSH
82097: DOUBLE
82098: LD_INT 1
82100: DEC
82101: ST_TO_ADDR
82102: LD_EXP 59
82106: PUSH
82107: FOR_TO
82108: IFFALSE 82295
// begin if not mc_build_list [ i ] then
82110: LD_EXP 64
82114: PUSH
82115: LD_VAR 0 4
82119: ARRAY
82120: NOT
82121: IFFALSE 82125
// continue ;
82123: GO 82107
// for j := 1 to mc_build_list [ i ] do
82125: LD_ADDR_VAR 0 5
82129: PUSH
82130: DOUBLE
82131: LD_INT 1
82133: DEC
82134: ST_TO_ADDR
82135: LD_EXP 64
82139: PUSH
82140: LD_VAR 0 4
82144: ARRAY
82145: PUSH
82146: FOR_TO
82147: IFFALSE 82291
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82149: LD_VAR 0 6
82153: PUSH
82154: LD_VAR 0 7
82158: PUSH
82159: LD_VAR 0 8
82163: PUSH
82164: LD_VAR 0 9
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: PPUSH
82175: LD_EXP 64
82179: PUSH
82180: LD_VAR 0 4
82184: ARRAY
82185: PUSH
82186: LD_VAR 0 5
82190: ARRAY
82191: PPUSH
82192: CALL 25863 0 2
82196: IFFALSE 82289
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82198: LD_ADDR_EXP 64
82202: PUSH
82203: LD_EXP 64
82207: PPUSH
82208: LD_VAR 0 4
82212: PPUSH
82213: LD_EXP 64
82217: PUSH
82218: LD_VAR 0 4
82222: ARRAY
82223: PPUSH
82224: LD_VAR 0 5
82228: PPUSH
82229: CALL_OW 3
82233: PPUSH
82234: CALL_OW 1
82238: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82239: LD_ADDR_EXP 66
82243: PUSH
82244: LD_EXP 66
82248: PPUSH
82249: LD_VAR 0 4
82253: PUSH
82254: LD_EXP 66
82258: PUSH
82259: LD_VAR 0 4
82263: ARRAY
82264: PUSH
82265: LD_INT 1
82267: PLUS
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PPUSH
82273: LD_VAR 0 1
82277: PPUSH
82278: CALL 19686 0 3
82282: ST_TO_ADDR
// exit ;
82283: POP
82284: POP
82285: POP
82286: POP
82287: GO 82297
// end ;
82289: GO 82146
82291: POP
82292: POP
// end ;
82293: GO 82107
82295: POP
82296: POP
// end ;
82297: LD_VAR 0 3
82301: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82302: LD_INT 0
82304: PPUSH
82305: PPUSH
82306: PPUSH
// if not mc_bases or not skirmish then
82307: LD_EXP 59
82311: NOT
82312: PUSH
82313: LD_EXP 57
82317: NOT
82318: OR
82319: IFFALSE 82323
// exit ;
82321: GO 82513
// for i = 1 to mc_bases do
82323: LD_ADDR_VAR 0 4
82327: PUSH
82328: DOUBLE
82329: LD_INT 1
82331: DEC
82332: ST_TO_ADDR
82333: LD_EXP 59
82337: PUSH
82338: FOR_TO
82339: IFFALSE 82426
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82341: LD_VAR 0 1
82345: PUSH
82346: LD_EXP 67
82350: PUSH
82351: LD_VAR 0 4
82355: ARRAY
82356: IN
82357: PUSH
82358: LD_VAR 0 1
82362: PUSH
82363: LD_EXP 68
82367: PUSH
82368: LD_VAR 0 4
82372: ARRAY
82373: IN
82374: NOT
82375: AND
82376: IFFALSE 82424
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82378: LD_ADDR_EXP 68
82382: PUSH
82383: LD_EXP 68
82387: PPUSH
82388: LD_VAR 0 4
82392: PUSH
82393: LD_EXP 68
82397: PUSH
82398: LD_VAR 0 4
82402: ARRAY
82403: PUSH
82404: LD_INT 1
82406: PLUS
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PPUSH
82412: LD_VAR 0 1
82416: PPUSH
82417: CALL 19686 0 3
82421: ST_TO_ADDR
// break ;
82422: GO 82426
// end ; end ;
82424: GO 82338
82426: POP
82427: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82428: LD_VAR 0 1
82432: PPUSH
82433: CALL_OW 257
82437: PUSH
82438: LD_EXP 85
82442: IN
82443: PUSH
82444: LD_VAR 0 1
82448: PPUSH
82449: CALL_OW 266
82453: PUSH
82454: LD_INT 5
82456: EQUAL
82457: AND
82458: PUSH
82459: LD_VAR 0 2
82463: PPUSH
82464: CALL_OW 110
82468: PUSH
82469: LD_INT 18
82471: NONEQUAL
82472: AND
82473: IFFALSE 82513
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82475: LD_VAR 0 2
82479: PPUSH
82480: CALL_OW 257
82484: PUSH
82485: LD_INT 5
82487: PUSH
82488: LD_INT 8
82490: PUSH
82491: LD_INT 9
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: LIST
82498: IN
82499: IFFALSE 82513
// SetClass ( unit , 1 ) ;
82501: LD_VAR 0 2
82505: PPUSH
82506: LD_INT 1
82508: PPUSH
82509: CALL_OW 336
// end ;
82513: LD_VAR 0 3
82517: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82518: LD_INT 0
82520: PPUSH
82521: PPUSH
// if not mc_bases or not skirmish then
82522: LD_EXP 59
82526: NOT
82527: PUSH
82528: LD_EXP 57
82532: NOT
82533: OR
82534: IFFALSE 82538
// exit ;
82536: GO 82654
// if GetLives ( abandoned_vehicle ) > 250 then
82538: LD_VAR 0 2
82542: PPUSH
82543: CALL_OW 256
82547: PUSH
82548: LD_INT 250
82550: GREATER
82551: IFFALSE 82555
// exit ;
82553: GO 82654
// for i = 1 to mc_bases do
82555: LD_ADDR_VAR 0 6
82559: PUSH
82560: DOUBLE
82561: LD_INT 1
82563: DEC
82564: ST_TO_ADDR
82565: LD_EXP 59
82569: PUSH
82570: FOR_TO
82571: IFFALSE 82652
// begin if driver in mc_bases [ i ] then
82573: LD_VAR 0 1
82577: PUSH
82578: LD_EXP 59
82582: PUSH
82583: LD_VAR 0 6
82587: ARRAY
82588: IN
82589: IFFALSE 82650
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82591: LD_VAR 0 1
82595: PPUSH
82596: LD_EXP 59
82600: PUSH
82601: LD_VAR 0 6
82605: ARRAY
82606: PPUSH
82607: LD_INT 2
82609: PUSH
82610: LD_INT 30
82612: PUSH
82613: LD_INT 0
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 30
82622: PUSH
82623: LD_INT 1
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: LIST
82634: PPUSH
82635: CALL_OW 72
82639: PUSH
82640: LD_INT 1
82642: ARRAY
82643: PPUSH
82644: CALL 51899 0 2
// break ;
82648: GO 82652
// end ; end ;
82650: GO 82570
82652: POP
82653: POP
// end ; end_of_file
82654: LD_VAR 0 5
82658: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
82659: LD_INT 0
82661: PPUSH
// ar_miner := 81 ;
82662: LD_ADDR_EXP 110
82666: PUSH
82667: LD_INT 81
82669: ST_TO_ADDR
// ar_crane := 88 ;
82670: LD_ADDR_EXP 109
82674: PUSH
82675: LD_INT 88
82677: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
82678: LD_ADDR_EXP 104
82682: PUSH
82683: LD_INT 89
82685: ST_TO_ADDR
// us_hack := 99 ;
82686: LD_ADDR_EXP 105
82690: PUSH
82691: LD_INT 99
82693: ST_TO_ADDR
// us_artillery := 97 ;
82694: LD_ADDR_EXP 106
82698: PUSH
82699: LD_INT 97
82701: ST_TO_ADDR
// ar_bio_bomb := 91 ;
82702: LD_ADDR_EXP 107
82706: PUSH
82707: LD_INT 91
82709: ST_TO_ADDR
// ar_mortar := 92 ;
82710: LD_ADDR_EXP 108
82714: PUSH
82715: LD_INT 92
82717: ST_TO_ADDR
// ru_radar := 98 ;
82718: LD_ADDR_EXP 103
82722: PUSH
82723: LD_INT 98
82725: ST_TO_ADDR
// tech_Artillery := 80 ;
82726: LD_ADDR_EXP 111
82730: PUSH
82731: LD_INT 80
82733: ST_TO_ADDR
// tech_RadMat := 81 ;
82734: LD_ADDR_EXP 112
82738: PUSH
82739: LD_INT 81
82741: ST_TO_ADDR
// tech_BasicTools := 82 ;
82742: LD_ADDR_EXP 113
82746: PUSH
82747: LD_INT 82
82749: ST_TO_ADDR
// tech_Cargo := 83 ;
82750: LD_ADDR_EXP 114
82754: PUSH
82755: LD_INT 83
82757: ST_TO_ADDR
// tech_Track := 84 ;
82758: LD_ADDR_EXP 115
82762: PUSH
82763: LD_INT 84
82765: ST_TO_ADDR
// tech_Crane := 85 ;
82766: LD_ADDR_EXP 116
82770: PUSH
82771: LD_INT 85
82773: ST_TO_ADDR
// tech_Bulldozer := 86 ;
82774: LD_ADDR_EXP 117
82778: PUSH
82779: LD_INT 86
82781: ST_TO_ADDR
// tech_Hovercraft := 87 ;
82782: LD_ADDR_EXP 118
82786: PUSH
82787: LD_INT 87
82789: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
82790: LD_ADDR_EXP 119
82794: PUSH
82795: LD_INT 88
82797: ST_TO_ADDR
// class_mastodont := 31 ;
82798: LD_ADDR_EXP 120
82802: PUSH
82803: LD_INT 31
82805: ST_TO_ADDR
// class_horse := 21 ;
82806: LD_ADDR_EXP 121
82810: PUSH
82811: LD_INT 21
82813: ST_TO_ADDR
// end ;
82814: LD_VAR 0 1
82818: RET
// every 1 do
82819: GO 82821
82821: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
82822: CALL 82659 0 0
82826: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
82827: LD_INT 0
82829: PPUSH
// if p2 = 100 then
82830: LD_VAR 0 2
82834: PUSH
82835: LD_INT 100
82837: EQUAL
82838: IFFALSE 83787
// begin if not StreamModeActive then
82840: LD_EXP 122
82844: NOT
82845: IFFALSE 82855
// StreamModeActive := true ;
82847: LD_ADDR_EXP 122
82851: PUSH
82852: LD_INT 1
82854: ST_TO_ADDR
// if p3 = 0 then
82855: LD_VAR 0 3
82859: PUSH
82860: LD_INT 0
82862: EQUAL
82863: IFFALSE 82869
// InitStreamMode ;
82865: CALL 83947 0 0
// if p3 = 1 then
82869: LD_VAR 0 3
82873: PUSH
82874: LD_INT 1
82876: EQUAL
82877: IFFALSE 82887
// sRocket := true ;
82879: LD_ADDR_EXP 127
82883: PUSH
82884: LD_INT 1
82886: ST_TO_ADDR
// if p3 = 2 then
82887: LD_VAR 0 3
82891: PUSH
82892: LD_INT 2
82894: EQUAL
82895: IFFALSE 82905
// sSpeed := true ;
82897: LD_ADDR_EXP 126
82901: PUSH
82902: LD_INT 1
82904: ST_TO_ADDR
// if p3 = 3 then
82905: LD_VAR 0 3
82909: PUSH
82910: LD_INT 3
82912: EQUAL
82913: IFFALSE 82923
// sEngine := true ;
82915: LD_ADDR_EXP 128
82919: PUSH
82920: LD_INT 1
82922: ST_TO_ADDR
// if p3 = 4 then
82923: LD_VAR 0 3
82927: PUSH
82928: LD_INT 4
82930: EQUAL
82931: IFFALSE 82941
// sSpec := true ;
82933: LD_ADDR_EXP 125
82937: PUSH
82938: LD_INT 1
82940: ST_TO_ADDR
// if p3 = 5 then
82941: LD_VAR 0 3
82945: PUSH
82946: LD_INT 5
82948: EQUAL
82949: IFFALSE 82959
// sLevel := true ;
82951: LD_ADDR_EXP 129
82955: PUSH
82956: LD_INT 1
82958: ST_TO_ADDR
// if p3 = 6 then
82959: LD_VAR 0 3
82963: PUSH
82964: LD_INT 6
82966: EQUAL
82967: IFFALSE 82977
// sArmoury := true ;
82969: LD_ADDR_EXP 130
82973: PUSH
82974: LD_INT 1
82976: ST_TO_ADDR
// if p3 = 7 then
82977: LD_VAR 0 3
82981: PUSH
82982: LD_INT 7
82984: EQUAL
82985: IFFALSE 82995
// sRadar := true ;
82987: LD_ADDR_EXP 131
82991: PUSH
82992: LD_INT 1
82994: ST_TO_ADDR
// if p3 = 8 then
82995: LD_VAR 0 3
82999: PUSH
83000: LD_INT 8
83002: EQUAL
83003: IFFALSE 83013
// sBunker := true ;
83005: LD_ADDR_EXP 132
83009: PUSH
83010: LD_INT 1
83012: ST_TO_ADDR
// if p3 = 9 then
83013: LD_VAR 0 3
83017: PUSH
83018: LD_INT 9
83020: EQUAL
83021: IFFALSE 83031
// sHack := true ;
83023: LD_ADDR_EXP 133
83027: PUSH
83028: LD_INT 1
83030: ST_TO_ADDR
// if p3 = 10 then
83031: LD_VAR 0 3
83035: PUSH
83036: LD_INT 10
83038: EQUAL
83039: IFFALSE 83049
// sFire := true ;
83041: LD_ADDR_EXP 134
83045: PUSH
83046: LD_INT 1
83048: ST_TO_ADDR
// if p3 = 11 then
83049: LD_VAR 0 3
83053: PUSH
83054: LD_INT 11
83056: EQUAL
83057: IFFALSE 83067
// sRefresh := true ;
83059: LD_ADDR_EXP 135
83063: PUSH
83064: LD_INT 1
83066: ST_TO_ADDR
// if p3 = 12 then
83067: LD_VAR 0 3
83071: PUSH
83072: LD_INT 12
83074: EQUAL
83075: IFFALSE 83085
// sExp := true ;
83077: LD_ADDR_EXP 136
83081: PUSH
83082: LD_INT 1
83084: ST_TO_ADDR
// if p3 = 13 then
83085: LD_VAR 0 3
83089: PUSH
83090: LD_INT 13
83092: EQUAL
83093: IFFALSE 83103
// sDepot := true ;
83095: LD_ADDR_EXP 137
83099: PUSH
83100: LD_INT 1
83102: ST_TO_ADDR
// if p3 = 14 then
83103: LD_VAR 0 3
83107: PUSH
83108: LD_INT 14
83110: EQUAL
83111: IFFALSE 83121
// sFlag := true ;
83113: LD_ADDR_EXP 138
83117: PUSH
83118: LD_INT 1
83120: ST_TO_ADDR
// if p3 = 15 then
83121: LD_VAR 0 3
83125: PUSH
83126: LD_INT 15
83128: EQUAL
83129: IFFALSE 83139
// sKamikadze := true ;
83131: LD_ADDR_EXP 146
83135: PUSH
83136: LD_INT 1
83138: ST_TO_ADDR
// if p3 = 16 then
83139: LD_VAR 0 3
83143: PUSH
83144: LD_INT 16
83146: EQUAL
83147: IFFALSE 83157
// sTroll := true ;
83149: LD_ADDR_EXP 147
83153: PUSH
83154: LD_INT 1
83156: ST_TO_ADDR
// if p3 = 17 then
83157: LD_VAR 0 3
83161: PUSH
83162: LD_INT 17
83164: EQUAL
83165: IFFALSE 83175
// sSlow := true ;
83167: LD_ADDR_EXP 148
83171: PUSH
83172: LD_INT 1
83174: ST_TO_ADDR
// if p3 = 18 then
83175: LD_VAR 0 3
83179: PUSH
83180: LD_INT 18
83182: EQUAL
83183: IFFALSE 83193
// sLack := true ;
83185: LD_ADDR_EXP 149
83189: PUSH
83190: LD_INT 1
83192: ST_TO_ADDR
// if p3 = 19 then
83193: LD_VAR 0 3
83197: PUSH
83198: LD_INT 19
83200: EQUAL
83201: IFFALSE 83211
// sTank := true ;
83203: LD_ADDR_EXP 151
83207: PUSH
83208: LD_INT 1
83210: ST_TO_ADDR
// if p3 = 20 then
83211: LD_VAR 0 3
83215: PUSH
83216: LD_INT 20
83218: EQUAL
83219: IFFALSE 83229
// sRemote := true ;
83221: LD_ADDR_EXP 152
83225: PUSH
83226: LD_INT 1
83228: ST_TO_ADDR
// if p3 = 21 then
83229: LD_VAR 0 3
83233: PUSH
83234: LD_INT 21
83236: EQUAL
83237: IFFALSE 83247
// sPowell := true ;
83239: LD_ADDR_EXP 153
83243: PUSH
83244: LD_INT 1
83246: ST_TO_ADDR
// if p3 = 22 then
83247: LD_VAR 0 3
83251: PUSH
83252: LD_INT 22
83254: EQUAL
83255: IFFALSE 83265
// sTeleport := true ;
83257: LD_ADDR_EXP 156
83261: PUSH
83262: LD_INT 1
83264: ST_TO_ADDR
// if p3 = 23 then
83265: LD_VAR 0 3
83269: PUSH
83270: LD_INT 23
83272: EQUAL
83273: IFFALSE 83283
// sOilTower := true ;
83275: LD_ADDR_EXP 158
83279: PUSH
83280: LD_INT 1
83282: ST_TO_ADDR
// if p3 = 24 then
83283: LD_VAR 0 3
83287: PUSH
83288: LD_INT 24
83290: EQUAL
83291: IFFALSE 83301
// sShovel := true ;
83293: LD_ADDR_EXP 159
83297: PUSH
83298: LD_INT 1
83300: ST_TO_ADDR
// if p3 = 25 then
83301: LD_VAR 0 3
83305: PUSH
83306: LD_INT 25
83308: EQUAL
83309: IFFALSE 83319
// sSheik := true ;
83311: LD_ADDR_EXP 160
83315: PUSH
83316: LD_INT 1
83318: ST_TO_ADDR
// if p3 = 26 then
83319: LD_VAR 0 3
83323: PUSH
83324: LD_INT 26
83326: EQUAL
83327: IFFALSE 83337
// sEarthquake := true ;
83329: LD_ADDR_EXP 162
83333: PUSH
83334: LD_INT 1
83336: ST_TO_ADDR
// if p3 = 27 then
83337: LD_VAR 0 3
83341: PUSH
83342: LD_INT 27
83344: EQUAL
83345: IFFALSE 83355
// sAI := true ;
83347: LD_ADDR_EXP 163
83351: PUSH
83352: LD_INT 1
83354: ST_TO_ADDR
// if p3 = 28 then
83355: LD_VAR 0 3
83359: PUSH
83360: LD_INT 28
83362: EQUAL
83363: IFFALSE 83373
// sCargo := true ;
83365: LD_ADDR_EXP 166
83369: PUSH
83370: LD_INT 1
83372: ST_TO_ADDR
// if p3 = 29 then
83373: LD_VAR 0 3
83377: PUSH
83378: LD_INT 29
83380: EQUAL
83381: IFFALSE 83391
// sDLaser := true ;
83383: LD_ADDR_EXP 167
83387: PUSH
83388: LD_INT 1
83390: ST_TO_ADDR
// if p3 = 30 then
83391: LD_VAR 0 3
83395: PUSH
83396: LD_INT 30
83398: EQUAL
83399: IFFALSE 83409
// sExchange := true ;
83401: LD_ADDR_EXP 168
83405: PUSH
83406: LD_INT 1
83408: ST_TO_ADDR
// if p3 = 31 then
83409: LD_VAR 0 3
83413: PUSH
83414: LD_INT 31
83416: EQUAL
83417: IFFALSE 83427
// sFac := true ;
83419: LD_ADDR_EXP 169
83423: PUSH
83424: LD_INT 1
83426: ST_TO_ADDR
// if p3 = 32 then
83427: LD_VAR 0 3
83431: PUSH
83432: LD_INT 32
83434: EQUAL
83435: IFFALSE 83445
// sPower := true ;
83437: LD_ADDR_EXP 170
83441: PUSH
83442: LD_INT 1
83444: ST_TO_ADDR
// if p3 = 33 then
83445: LD_VAR 0 3
83449: PUSH
83450: LD_INT 33
83452: EQUAL
83453: IFFALSE 83463
// sRandom := true ;
83455: LD_ADDR_EXP 171
83459: PUSH
83460: LD_INT 1
83462: ST_TO_ADDR
// if p3 = 34 then
83463: LD_VAR 0 3
83467: PUSH
83468: LD_INT 34
83470: EQUAL
83471: IFFALSE 83481
// sShield := true ;
83473: LD_ADDR_EXP 172
83477: PUSH
83478: LD_INT 1
83480: ST_TO_ADDR
// if p3 = 35 then
83481: LD_VAR 0 3
83485: PUSH
83486: LD_INT 35
83488: EQUAL
83489: IFFALSE 83499
// sTime := true ;
83491: LD_ADDR_EXP 173
83495: PUSH
83496: LD_INT 1
83498: ST_TO_ADDR
// if p3 = 36 then
83499: LD_VAR 0 3
83503: PUSH
83504: LD_INT 36
83506: EQUAL
83507: IFFALSE 83517
// sTools := true ;
83509: LD_ADDR_EXP 174
83513: PUSH
83514: LD_INT 1
83516: ST_TO_ADDR
// if p3 = 101 then
83517: LD_VAR 0 3
83521: PUSH
83522: LD_INT 101
83524: EQUAL
83525: IFFALSE 83535
// sSold := true ;
83527: LD_ADDR_EXP 139
83531: PUSH
83532: LD_INT 1
83534: ST_TO_ADDR
// if p3 = 102 then
83535: LD_VAR 0 3
83539: PUSH
83540: LD_INT 102
83542: EQUAL
83543: IFFALSE 83553
// sDiff := true ;
83545: LD_ADDR_EXP 140
83549: PUSH
83550: LD_INT 1
83552: ST_TO_ADDR
// if p3 = 103 then
83553: LD_VAR 0 3
83557: PUSH
83558: LD_INT 103
83560: EQUAL
83561: IFFALSE 83571
// sFog := true ;
83563: LD_ADDR_EXP 143
83567: PUSH
83568: LD_INT 1
83570: ST_TO_ADDR
// if p3 = 104 then
83571: LD_VAR 0 3
83575: PUSH
83576: LD_INT 104
83578: EQUAL
83579: IFFALSE 83589
// sReset := true ;
83581: LD_ADDR_EXP 144
83585: PUSH
83586: LD_INT 1
83588: ST_TO_ADDR
// if p3 = 105 then
83589: LD_VAR 0 3
83593: PUSH
83594: LD_INT 105
83596: EQUAL
83597: IFFALSE 83607
// sSun := true ;
83599: LD_ADDR_EXP 145
83603: PUSH
83604: LD_INT 1
83606: ST_TO_ADDR
// if p3 = 106 then
83607: LD_VAR 0 3
83611: PUSH
83612: LD_INT 106
83614: EQUAL
83615: IFFALSE 83625
// sTiger := true ;
83617: LD_ADDR_EXP 141
83621: PUSH
83622: LD_INT 1
83624: ST_TO_ADDR
// if p3 = 107 then
83625: LD_VAR 0 3
83629: PUSH
83630: LD_INT 107
83632: EQUAL
83633: IFFALSE 83643
// sBomb := true ;
83635: LD_ADDR_EXP 142
83639: PUSH
83640: LD_INT 1
83642: ST_TO_ADDR
// if p3 = 108 then
83643: LD_VAR 0 3
83647: PUSH
83648: LD_INT 108
83650: EQUAL
83651: IFFALSE 83661
// sWound := true ;
83653: LD_ADDR_EXP 150
83657: PUSH
83658: LD_INT 1
83660: ST_TO_ADDR
// if p3 = 109 then
83661: LD_VAR 0 3
83665: PUSH
83666: LD_INT 109
83668: EQUAL
83669: IFFALSE 83679
// sBetray := true ;
83671: LD_ADDR_EXP 154
83675: PUSH
83676: LD_INT 1
83678: ST_TO_ADDR
// if p3 = 110 then
83679: LD_VAR 0 3
83683: PUSH
83684: LD_INT 110
83686: EQUAL
83687: IFFALSE 83697
// sContamin := true ;
83689: LD_ADDR_EXP 155
83693: PUSH
83694: LD_INT 1
83696: ST_TO_ADDR
// if p3 = 111 then
83697: LD_VAR 0 3
83701: PUSH
83702: LD_INT 111
83704: EQUAL
83705: IFFALSE 83715
// sOil := true ;
83707: LD_ADDR_EXP 157
83711: PUSH
83712: LD_INT 1
83714: ST_TO_ADDR
// if p3 = 112 then
83715: LD_VAR 0 3
83719: PUSH
83720: LD_INT 112
83722: EQUAL
83723: IFFALSE 83733
// sStu := true ;
83725: LD_ADDR_EXP 161
83729: PUSH
83730: LD_INT 1
83732: ST_TO_ADDR
// if p3 = 113 then
83733: LD_VAR 0 3
83737: PUSH
83738: LD_INT 113
83740: EQUAL
83741: IFFALSE 83751
// sBazooka := true ;
83743: LD_ADDR_EXP 164
83747: PUSH
83748: LD_INT 1
83750: ST_TO_ADDR
// if p3 = 114 then
83751: LD_VAR 0 3
83755: PUSH
83756: LD_INT 114
83758: EQUAL
83759: IFFALSE 83769
// sMortar := true ;
83761: LD_ADDR_EXP 165
83765: PUSH
83766: LD_INT 1
83768: ST_TO_ADDR
// if p3 = 115 then
83769: LD_VAR 0 3
83773: PUSH
83774: LD_INT 115
83776: EQUAL
83777: IFFALSE 83787
// sRanger := true ;
83779: LD_ADDR_EXP 175
83783: PUSH
83784: LD_INT 1
83786: ST_TO_ADDR
// end ; if p2 = 101 then
83787: LD_VAR 0 2
83791: PUSH
83792: LD_INT 101
83794: EQUAL
83795: IFFALSE 83923
// begin case p3 of 1 :
83797: LD_VAR 0 3
83801: PUSH
83802: LD_INT 1
83804: DOUBLE
83805: EQUAL
83806: IFTRUE 83810
83808: GO 83817
83810: POP
// hHackUnlimitedResources ; 2 :
83811: CALL 94960 0 0
83815: GO 83923
83817: LD_INT 2
83819: DOUBLE
83820: EQUAL
83821: IFTRUE 83825
83823: GO 83832
83825: POP
// hHackSetLevel10 ; 3 :
83826: CALL 95093 0 0
83830: GO 83923
83832: LD_INT 3
83834: DOUBLE
83835: EQUAL
83836: IFTRUE 83840
83838: GO 83847
83840: POP
// hHackSetLevel10YourUnits ; 4 :
83841: CALL 95178 0 0
83845: GO 83923
83847: LD_INT 4
83849: DOUBLE
83850: EQUAL
83851: IFTRUE 83855
83853: GO 83862
83855: POP
// hHackInvincible ; 5 :
83856: CALL 95626 0 0
83860: GO 83923
83862: LD_INT 5
83864: DOUBLE
83865: EQUAL
83866: IFTRUE 83870
83868: GO 83877
83870: POP
// hHackInvisible ; 6 :
83871: CALL 95737 0 0
83875: GO 83923
83877: LD_INT 6
83879: DOUBLE
83880: EQUAL
83881: IFTRUE 83885
83883: GO 83892
83885: POP
// hHackChangeYourSide ; 7 :
83886: CALL 95794 0 0
83890: GO 83923
83892: LD_INT 7
83894: DOUBLE
83895: EQUAL
83896: IFTRUE 83900
83898: GO 83907
83900: POP
// hHackChangeUnitSide ; 8 :
83901: CALL 95836 0 0
83905: GO 83923
83907: LD_INT 8
83909: DOUBLE
83910: EQUAL
83911: IFTRUE 83915
83913: GO 83922
83915: POP
// hHackFog ; end ;
83916: CALL 95937 0 0
83920: GO 83923
83922: POP
// end ; end ;
83923: LD_VAR 0 7
83927: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83928: GO 83930
83930: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83931: LD_STRING initStreamRollete();
83933: PPUSH
83934: CALL_OW 559
// InitStreamMode ;
83938: CALL 83947 0 0
// DefineStreamItems ( ) ;
83942: CALL 84387 0 0
// end ;
83946: END
// function InitStreamMode ; begin
83947: LD_INT 0
83949: PPUSH
// streamModeActive := false ;
83950: LD_ADDR_EXP 122
83954: PUSH
83955: LD_INT 0
83957: ST_TO_ADDR
// normalCounter := 36 ;
83958: LD_ADDR_EXP 123
83962: PUSH
83963: LD_INT 36
83965: ST_TO_ADDR
// hardcoreCounter := 16 ;
83966: LD_ADDR_EXP 124
83970: PUSH
83971: LD_INT 16
83973: ST_TO_ADDR
// sRocket := false ;
83974: LD_ADDR_EXP 127
83978: PUSH
83979: LD_INT 0
83981: ST_TO_ADDR
// sSpeed := false ;
83982: LD_ADDR_EXP 126
83986: PUSH
83987: LD_INT 0
83989: ST_TO_ADDR
// sEngine := false ;
83990: LD_ADDR_EXP 128
83994: PUSH
83995: LD_INT 0
83997: ST_TO_ADDR
// sSpec := false ;
83998: LD_ADDR_EXP 125
84002: PUSH
84003: LD_INT 0
84005: ST_TO_ADDR
// sLevel := false ;
84006: LD_ADDR_EXP 129
84010: PUSH
84011: LD_INT 0
84013: ST_TO_ADDR
// sArmoury := false ;
84014: LD_ADDR_EXP 130
84018: PUSH
84019: LD_INT 0
84021: ST_TO_ADDR
// sRadar := false ;
84022: LD_ADDR_EXP 131
84026: PUSH
84027: LD_INT 0
84029: ST_TO_ADDR
// sBunker := false ;
84030: LD_ADDR_EXP 132
84034: PUSH
84035: LD_INT 0
84037: ST_TO_ADDR
// sHack := false ;
84038: LD_ADDR_EXP 133
84042: PUSH
84043: LD_INT 0
84045: ST_TO_ADDR
// sFire := false ;
84046: LD_ADDR_EXP 134
84050: PUSH
84051: LD_INT 0
84053: ST_TO_ADDR
// sRefresh := false ;
84054: LD_ADDR_EXP 135
84058: PUSH
84059: LD_INT 0
84061: ST_TO_ADDR
// sExp := false ;
84062: LD_ADDR_EXP 136
84066: PUSH
84067: LD_INT 0
84069: ST_TO_ADDR
// sDepot := false ;
84070: LD_ADDR_EXP 137
84074: PUSH
84075: LD_INT 0
84077: ST_TO_ADDR
// sFlag := false ;
84078: LD_ADDR_EXP 138
84082: PUSH
84083: LD_INT 0
84085: ST_TO_ADDR
// sKamikadze := false ;
84086: LD_ADDR_EXP 146
84090: PUSH
84091: LD_INT 0
84093: ST_TO_ADDR
// sTroll := false ;
84094: LD_ADDR_EXP 147
84098: PUSH
84099: LD_INT 0
84101: ST_TO_ADDR
// sSlow := false ;
84102: LD_ADDR_EXP 148
84106: PUSH
84107: LD_INT 0
84109: ST_TO_ADDR
// sLack := false ;
84110: LD_ADDR_EXP 149
84114: PUSH
84115: LD_INT 0
84117: ST_TO_ADDR
// sTank := false ;
84118: LD_ADDR_EXP 151
84122: PUSH
84123: LD_INT 0
84125: ST_TO_ADDR
// sRemote := false ;
84126: LD_ADDR_EXP 152
84130: PUSH
84131: LD_INT 0
84133: ST_TO_ADDR
// sPowell := false ;
84134: LD_ADDR_EXP 153
84138: PUSH
84139: LD_INT 0
84141: ST_TO_ADDR
// sTeleport := false ;
84142: LD_ADDR_EXP 156
84146: PUSH
84147: LD_INT 0
84149: ST_TO_ADDR
// sOilTower := false ;
84150: LD_ADDR_EXP 158
84154: PUSH
84155: LD_INT 0
84157: ST_TO_ADDR
// sShovel := false ;
84158: LD_ADDR_EXP 159
84162: PUSH
84163: LD_INT 0
84165: ST_TO_ADDR
// sSheik := false ;
84166: LD_ADDR_EXP 160
84170: PUSH
84171: LD_INT 0
84173: ST_TO_ADDR
// sEarthquake := false ;
84174: LD_ADDR_EXP 162
84178: PUSH
84179: LD_INT 0
84181: ST_TO_ADDR
// sAI := false ;
84182: LD_ADDR_EXP 163
84186: PUSH
84187: LD_INT 0
84189: ST_TO_ADDR
// sCargo := false ;
84190: LD_ADDR_EXP 166
84194: PUSH
84195: LD_INT 0
84197: ST_TO_ADDR
// sDLaser := false ;
84198: LD_ADDR_EXP 167
84202: PUSH
84203: LD_INT 0
84205: ST_TO_ADDR
// sExchange := false ;
84206: LD_ADDR_EXP 168
84210: PUSH
84211: LD_INT 0
84213: ST_TO_ADDR
// sFac := false ;
84214: LD_ADDR_EXP 169
84218: PUSH
84219: LD_INT 0
84221: ST_TO_ADDR
// sPower := false ;
84222: LD_ADDR_EXP 170
84226: PUSH
84227: LD_INT 0
84229: ST_TO_ADDR
// sRandom := false ;
84230: LD_ADDR_EXP 171
84234: PUSH
84235: LD_INT 0
84237: ST_TO_ADDR
// sShield := false ;
84238: LD_ADDR_EXP 172
84242: PUSH
84243: LD_INT 0
84245: ST_TO_ADDR
// sTime := false ;
84246: LD_ADDR_EXP 173
84250: PUSH
84251: LD_INT 0
84253: ST_TO_ADDR
// sTools := false ;
84254: LD_ADDR_EXP 174
84258: PUSH
84259: LD_INT 0
84261: ST_TO_ADDR
// sSold := false ;
84262: LD_ADDR_EXP 139
84266: PUSH
84267: LD_INT 0
84269: ST_TO_ADDR
// sDiff := false ;
84270: LD_ADDR_EXP 140
84274: PUSH
84275: LD_INT 0
84277: ST_TO_ADDR
// sFog := false ;
84278: LD_ADDR_EXP 143
84282: PUSH
84283: LD_INT 0
84285: ST_TO_ADDR
// sReset := false ;
84286: LD_ADDR_EXP 144
84290: PUSH
84291: LD_INT 0
84293: ST_TO_ADDR
// sSun := false ;
84294: LD_ADDR_EXP 145
84298: PUSH
84299: LD_INT 0
84301: ST_TO_ADDR
// sTiger := false ;
84302: LD_ADDR_EXP 141
84306: PUSH
84307: LD_INT 0
84309: ST_TO_ADDR
// sBomb := false ;
84310: LD_ADDR_EXP 142
84314: PUSH
84315: LD_INT 0
84317: ST_TO_ADDR
// sWound := false ;
84318: LD_ADDR_EXP 150
84322: PUSH
84323: LD_INT 0
84325: ST_TO_ADDR
// sBetray := false ;
84326: LD_ADDR_EXP 154
84330: PUSH
84331: LD_INT 0
84333: ST_TO_ADDR
// sContamin := false ;
84334: LD_ADDR_EXP 155
84338: PUSH
84339: LD_INT 0
84341: ST_TO_ADDR
// sOil := false ;
84342: LD_ADDR_EXP 157
84346: PUSH
84347: LD_INT 0
84349: ST_TO_ADDR
// sStu := false ;
84350: LD_ADDR_EXP 161
84354: PUSH
84355: LD_INT 0
84357: ST_TO_ADDR
// sBazooka := false ;
84358: LD_ADDR_EXP 164
84362: PUSH
84363: LD_INT 0
84365: ST_TO_ADDR
// sMortar := false ;
84366: LD_ADDR_EXP 165
84370: PUSH
84371: LD_INT 0
84373: ST_TO_ADDR
// sRanger := false ;
84374: LD_ADDR_EXP 175
84378: PUSH
84379: LD_INT 0
84381: ST_TO_ADDR
// end ;
84382: LD_VAR 0 1
84386: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84387: LD_INT 0
84389: PPUSH
84390: PPUSH
84391: PPUSH
84392: PPUSH
84393: PPUSH
// result := [ ] ;
84394: LD_ADDR_VAR 0 1
84398: PUSH
84399: EMPTY
84400: ST_TO_ADDR
// if campaign_id = 1 then
84401: LD_OWVAR 69
84405: PUSH
84406: LD_INT 1
84408: EQUAL
84409: IFFALSE 87347
// begin case mission_number of 1 :
84411: LD_OWVAR 70
84415: PUSH
84416: LD_INT 1
84418: DOUBLE
84419: EQUAL
84420: IFTRUE 84424
84422: GO 84488
84424: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84425: LD_ADDR_VAR 0 1
84429: PUSH
84430: LD_INT 2
84432: PUSH
84433: LD_INT 4
84435: PUSH
84436: LD_INT 11
84438: PUSH
84439: LD_INT 12
84441: PUSH
84442: LD_INT 15
84444: PUSH
84445: LD_INT 16
84447: PUSH
84448: LD_INT 22
84450: PUSH
84451: LD_INT 23
84453: PUSH
84454: LD_INT 26
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 101
84470: PUSH
84471: LD_INT 102
84473: PUSH
84474: LD_INT 106
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: LIST
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: ST_TO_ADDR
84486: GO 87345
84488: LD_INT 2
84490: DOUBLE
84491: EQUAL
84492: IFTRUE 84496
84494: GO 84568
84496: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84497: LD_ADDR_VAR 0 1
84501: PUSH
84502: LD_INT 2
84504: PUSH
84505: LD_INT 4
84507: PUSH
84508: LD_INT 11
84510: PUSH
84511: LD_INT 12
84513: PUSH
84514: LD_INT 15
84516: PUSH
84517: LD_INT 16
84519: PUSH
84520: LD_INT 22
84522: PUSH
84523: LD_INT 23
84525: PUSH
84526: LD_INT 26
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 101
84542: PUSH
84543: LD_INT 102
84545: PUSH
84546: LD_INT 105
84548: PUSH
84549: LD_INT 106
84551: PUSH
84552: LD_INT 108
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: ST_TO_ADDR
84566: GO 87345
84568: LD_INT 3
84570: DOUBLE
84571: EQUAL
84572: IFTRUE 84576
84574: GO 84652
84576: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84577: LD_ADDR_VAR 0 1
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: LD_INT 4
84587: PUSH
84588: LD_INT 5
84590: PUSH
84591: LD_INT 11
84593: PUSH
84594: LD_INT 12
84596: PUSH
84597: LD_INT 15
84599: PUSH
84600: LD_INT 16
84602: PUSH
84603: LD_INT 22
84605: PUSH
84606: LD_INT 26
84608: PUSH
84609: LD_INT 36
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 101
84626: PUSH
84627: LD_INT 102
84629: PUSH
84630: LD_INT 105
84632: PUSH
84633: LD_INT 106
84635: PUSH
84636: LD_INT 108
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: ST_TO_ADDR
84650: GO 87345
84652: LD_INT 4
84654: DOUBLE
84655: EQUAL
84656: IFTRUE 84660
84658: GO 84744
84660: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84661: LD_ADDR_VAR 0 1
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: LD_INT 4
84671: PUSH
84672: LD_INT 5
84674: PUSH
84675: LD_INT 8
84677: PUSH
84678: LD_INT 11
84680: PUSH
84681: LD_INT 12
84683: PUSH
84684: LD_INT 15
84686: PUSH
84687: LD_INT 16
84689: PUSH
84690: LD_INT 22
84692: PUSH
84693: LD_INT 23
84695: PUSH
84696: LD_INT 26
84698: PUSH
84699: LD_INT 36
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 101
84718: PUSH
84719: LD_INT 102
84721: PUSH
84722: LD_INT 105
84724: PUSH
84725: LD_INT 106
84727: PUSH
84728: LD_INT 108
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: ST_TO_ADDR
84742: GO 87345
84744: LD_INT 5
84746: DOUBLE
84747: EQUAL
84748: IFTRUE 84752
84750: GO 84852
84752: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84753: LD_ADDR_VAR 0 1
84757: PUSH
84758: LD_INT 2
84760: PUSH
84761: LD_INT 4
84763: PUSH
84764: LD_INT 5
84766: PUSH
84767: LD_INT 6
84769: PUSH
84770: LD_INT 8
84772: PUSH
84773: LD_INT 11
84775: PUSH
84776: LD_INT 12
84778: PUSH
84779: LD_INT 15
84781: PUSH
84782: LD_INT 16
84784: PUSH
84785: LD_INT 22
84787: PUSH
84788: LD_INT 23
84790: PUSH
84791: LD_INT 25
84793: PUSH
84794: LD_INT 26
84796: PUSH
84797: LD_INT 36
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 101
84818: PUSH
84819: LD_INT 102
84821: PUSH
84822: LD_INT 105
84824: PUSH
84825: LD_INT 106
84827: PUSH
84828: LD_INT 108
84830: PUSH
84831: LD_INT 109
84833: PUSH
84834: LD_INT 112
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: ST_TO_ADDR
84850: GO 87345
84852: LD_INT 6
84854: DOUBLE
84855: EQUAL
84856: IFTRUE 84860
84858: GO 84980
84860: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84861: LD_ADDR_VAR 0 1
84865: PUSH
84866: LD_INT 2
84868: PUSH
84869: LD_INT 4
84871: PUSH
84872: LD_INT 5
84874: PUSH
84875: LD_INT 6
84877: PUSH
84878: LD_INT 8
84880: PUSH
84881: LD_INT 11
84883: PUSH
84884: LD_INT 12
84886: PUSH
84887: LD_INT 15
84889: PUSH
84890: LD_INT 16
84892: PUSH
84893: LD_INT 20
84895: PUSH
84896: LD_INT 21
84898: PUSH
84899: LD_INT 22
84901: PUSH
84902: LD_INT 23
84904: PUSH
84905: LD_INT 25
84907: PUSH
84908: LD_INT 26
84910: PUSH
84911: LD_INT 30
84913: PUSH
84914: LD_INT 31
84916: PUSH
84917: LD_INT 32
84919: PUSH
84920: LD_INT 36
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 101
84946: PUSH
84947: LD_INT 102
84949: PUSH
84950: LD_INT 105
84952: PUSH
84953: LD_INT 106
84955: PUSH
84956: LD_INT 108
84958: PUSH
84959: LD_INT 109
84961: PUSH
84962: LD_INT 112
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: ST_TO_ADDR
84978: GO 87345
84980: LD_INT 7
84982: DOUBLE
84983: EQUAL
84984: IFTRUE 84988
84986: GO 85088
84988: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84989: LD_ADDR_VAR 0 1
84993: PUSH
84994: LD_INT 2
84996: PUSH
84997: LD_INT 4
84999: PUSH
85000: LD_INT 5
85002: PUSH
85003: LD_INT 7
85005: PUSH
85006: LD_INT 11
85008: PUSH
85009: LD_INT 12
85011: PUSH
85012: LD_INT 15
85014: PUSH
85015: LD_INT 16
85017: PUSH
85018: LD_INT 20
85020: PUSH
85021: LD_INT 21
85023: PUSH
85024: LD_INT 22
85026: PUSH
85027: LD_INT 23
85029: PUSH
85030: LD_INT 25
85032: PUSH
85033: LD_INT 26
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 101
85054: PUSH
85055: LD_INT 102
85057: PUSH
85058: LD_INT 103
85060: PUSH
85061: LD_INT 105
85063: PUSH
85064: LD_INT 106
85066: PUSH
85067: LD_INT 108
85069: PUSH
85070: LD_INT 112
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: ST_TO_ADDR
85086: GO 87345
85088: LD_INT 8
85090: DOUBLE
85091: EQUAL
85092: IFTRUE 85096
85094: GO 85224
85096: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
85097: LD_ADDR_VAR 0 1
85101: PUSH
85102: LD_INT 2
85104: PUSH
85105: LD_INT 4
85107: PUSH
85108: LD_INT 5
85110: PUSH
85111: LD_INT 6
85113: PUSH
85114: LD_INT 7
85116: PUSH
85117: LD_INT 8
85119: PUSH
85120: LD_INT 11
85122: PUSH
85123: LD_INT 12
85125: PUSH
85126: LD_INT 15
85128: PUSH
85129: LD_INT 16
85131: PUSH
85132: LD_INT 20
85134: PUSH
85135: LD_INT 21
85137: PUSH
85138: LD_INT 22
85140: PUSH
85141: LD_INT 23
85143: PUSH
85144: LD_INT 25
85146: PUSH
85147: LD_INT 26
85149: PUSH
85150: LD_INT 30
85152: PUSH
85153: LD_INT 31
85155: PUSH
85156: LD_INT 32
85158: PUSH
85159: LD_INT 36
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 101
85186: PUSH
85187: LD_INT 102
85189: PUSH
85190: LD_INT 103
85192: PUSH
85193: LD_INT 105
85195: PUSH
85196: LD_INT 106
85198: PUSH
85199: LD_INT 108
85201: PUSH
85202: LD_INT 109
85204: PUSH
85205: LD_INT 112
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: ST_TO_ADDR
85222: GO 87345
85224: LD_INT 9
85226: DOUBLE
85227: EQUAL
85228: IFTRUE 85232
85230: GO 85368
85232: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85233: LD_ADDR_VAR 0 1
85237: PUSH
85238: LD_INT 2
85240: PUSH
85241: LD_INT 4
85243: PUSH
85244: LD_INT 5
85246: PUSH
85247: LD_INT 6
85249: PUSH
85250: LD_INT 7
85252: PUSH
85253: LD_INT 8
85255: PUSH
85256: LD_INT 11
85258: PUSH
85259: LD_INT 12
85261: PUSH
85262: LD_INT 15
85264: PUSH
85265: LD_INT 16
85267: PUSH
85268: LD_INT 20
85270: PUSH
85271: LD_INT 21
85273: PUSH
85274: LD_INT 22
85276: PUSH
85277: LD_INT 23
85279: PUSH
85280: LD_INT 25
85282: PUSH
85283: LD_INT 26
85285: PUSH
85286: LD_INT 28
85288: PUSH
85289: LD_INT 30
85291: PUSH
85292: LD_INT 31
85294: PUSH
85295: LD_INT 32
85297: PUSH
85298: LD_INT 36
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: PUSH
85324: LD_INT 101
85326: PUSH
85327: LD_INT 102
85329: PUSH
85330: LD_INT 103
85332: PUSH
85333: LD_INT 105
85335: PUSH
85336: LD_INT 106
85338: PUSH
85339: LD_INT 108
85341: PUSH
85342: LD_INT 109
85344: PUSH
85345: LD_INT 112
85347: PUSH
85348: LD_INT 114
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: ST_TO_ADDR
85366: GO 87345
85368: LD_INT 10
85370: DOUBLE
85371: EQUAL
85372: IFTRUE 85376
85374: GO 85560
85376: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85377: LD_ADDR_VAR 0 1
85381: PUSH
85382: LD_INT 2
85384: PUSH
85385: LD_INT 4
85387: PUSH
85388: LD_INT 5
85390: PUSH
85391: LD_INT 6
85393: PUSH
85394: LD_INT 7
85396: PUSH
85397: LD_INT 8
85399: PUSH
85400: LD_INT 9
85402: PUSH
85403: LD_INT 10
85405: PUSH
85406: LD_INT 11
85408: PUSH
85409: LD_INT 12
85411: PUSH
85412: LD_INT 13
85414: PUSH
85415: LD_INT 14
85417: PUSH
85418: LD_INT 15
85420: PUSH
85421: LD_INT 16
85423: PUSH
85424: LD_INT 17
85426: PUSH
85427: LD_INT 18
85429: PUSH
85430: LD_INT 19
85432: PUSH
85433: LD_INT 20
85435: PUSH
85436: LD_INT 21
85438: PUSH
85439: LD_INT 22
85441: PUSH
85442: LD_INT 23
85444: PUSH
85445: LD_INT 24
85447: PUSH
85448: LD_INT 25
85450: PUSH
85451: LD_INT 26
85453: PUSH
85454: LD_INT 28
85456: PUSH
85457: LD_INT 30
85459: PUSH
85460: LD_INT 31
85462: PUSH
85463: LD_INT 32
85465: PUSH
85466: LD_INT 36
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 101
85502: PUSH
85503: LD_INT 102
85505: PUSH
85506: LD_INT 103
85508: PUSH
85509: LD_INT 104
85511: PUSH
85512: LD_INT 105
85514: PUSH
85515: LD_INT 106
85517: PUSH
85518: LD_INT 107
85520: PUSH
85521: LD_INT 108
85523: PUSH
85524: LD_INT 109
85526: PUSH
85527: LD_INT 110
85529: PUSH
85530: LD_INT 111
85532: PUSH
85533: LD_INT 112
85535: PUSH
85536: LD_INT 114
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: ST_TO_ADDR
85558: GO 87345
85560: LD_INT 11
85562: DOUBLE
85563: EQUAL
85564: IFTRUE 85568
85566: GO 85760
85568: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85569: LD_ADDR_VAR 0 1
85573: PUSH
85574: LD_INT 2
85576: PUSH
85577: LD_INT 3
85579: PUSH
85580: LD_INT 4
85582: PUSH
85583: LD_INT 5
85585: PUSH
85586: LD_INT 6
85588: PUSH
85589: LD_INT 7
85591: PUSH
85592: LD_INT 8
85594: PUSH
85595: LD_INT 9
85597: PUSH
85598: LD_INT 10
85600: PUSH
85601: LD_INT 11
85603: PUSH
85604: LD_INT 12
85606: PUSH
85607: LD_INT 13
85609: PUSH
85610: LD_INT 14
85612: PUSH
85613: LD_INT 15
85615: PUSH
85616: LD_INT 16
85618: PUSH
85619: LD_INT 17
85621: PUSH
85622: LD_INT 18
85624: PUSH
85625: LD_INT 19
85627: PUSH
85628: LD_INT 20
85630: PUSH
85631: LD_INT 21
85633: PUSH
85634: LD_INT 22
85636: PUSH
85637: LD_INT 23
85639: PUSH
85640: LD_INT 24
85642: PUSH
85643: LD_INT 25
85645: PUSH
85646: LD_INT 26
85648: PUSH
85649: LD_INT 28
85651: PUSH
85652: LD_INT 30
85654: PUSH
85655: LD_INT 31
85657: PUSH
85658: LD_INT 32
85660: PUSH
85661: LD_INT 34
85663: PUSH
85664: LD_INT 36
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 101
85702: PUSH
85703: LD_INT 102
85705: PUSH
85706: LD_INT 103
85708: PUSH
85709: LD_INT 104
85711: PUSH
85712: LD_INT 105
85714: PUSH
85715: LD_INT 106
85717: PUSH
85718: LD_INT 107
85720: PUSH
85721: LD_INT 108
85723: PUSH
85724: LD_INT 109
85726: PUSH
85727: LD_INT 110
85729: PUSH
85730: LD_INT 111
85732: PUSH
85733: LD_INT 112
85735: PUSH
85736: LD_INT 114
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: ST_TO_ADDR
85758: GO 87345
85760: LD_INT 12
85762: DOUBLE
85763: EQUAL
85764: IFTRUE 85768
85766: GO 85976
85768: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85769: LD_ADDR_VAR 0 1
85773: PUSH
85774: LD_INT 1
85776: PUSH
85777: LD_INT 2
85779: PUSH
85780: LD_INT 3
85782: PUSH
85783: LD_INT 4
85785: PUSH
85786: LD_INT 5
85788: PUSH
85789: LD_INT 6
85791: PUSH
85792: LD_INT 7
85794: PUSH
85795: LD_INT 8
85797: PUSH
85798: LD_INT 9
85800: PUSH
85801: LD_INT 10
85803: PUSH
85804: LD_INT 11
85806: PUSH
85807: LD_INT 12
85809: PUSH
85810: LD_INT 13
85812: PUSH
85813: LD_INT 14
85815: PUSH
85816: LD_INT 15
85818: PUSH
85819: LD_INT 16
85821: PUSH
85822: LD_INT 17
85824: PUSH
85825: LD_INT 18
85827: PUSH
85828: LD_INT 19
85830: PUSH
85831: LD_INT 20
85833: PUSH
85834: LD_INT 21
85836: PUSH
85837: LD_INT 22
85839: PUSH
85840: LD_INT 23
85842: PUSH
85843: LD_INT 24
85845: PUSH
85846: LD_INT 25
85848: PUSH
85849: LD_INT 26
85851: PUSH
85852: LD_INT 27
85854: PUSH
85855: LD_INT 28
85857: PUSH
85858: LD_INT 30
85860: PUSH
85861: LD_INT 31
85863: PUSH
85864: LD_INT 32
85866: PUSH
85867: LD_INT 33
85869: PUSH
85870: LD_INT 34
85872: PUSH
85873: LD_INT 36
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 101
85914: PUSH
85915: LD_INT 102
85917: PUSH
85918: LD_INT 103
85920: PUSH
85921: LD_INT 104
85923: PUSH
85924: LD_INT 105
85926: PUSH
85927: LD_INT 106
85929: PUSH
85930: LD_INT 107
85932: PUSH
85933: LD_INT 108
85935: PUSH
85936: LD_INT 109
85938: PUSH
85939: LD_INT 110
85941: PUSH
85942: LD_INT 111
85944: PUSH
85945: LD_INT 112
85947: PUSH
85948: LD_INT 113
85950: PUSH
85951: LD_INT 114
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: ST_TO_ADDR
85974: GO 87345
85976: LD_INT 13
85978: DOUBLE
85979: EQUAL
85980: IFTRUE 85984
85982: GO 86180
85984: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85985: LD_ADDR_VAR 0 1
85989: PUSH
85990: LD_INT 1
85992: PUSH
85993: LD_INT 2
85995: PUSH
85996: LD_INT 3
85998: PUSH
85999: LD_INT 4
86001: PUSH
86002: LD_INT 5
86004: PUSH
86005: LD_INT 8
86007: PUSH
86008: LD_INT 9
86010: PUSH
86011: LD_INT 10
86013: PUSH
86014: LD_INT 11
86016: PUSH
86017: LD_INT 12
86019: PUSH
86020: LD_INT 14
86022: PUSH
86023: LD_INT 15
86025: PUSH
86026: LD_INT 16
86028: PUSH
86029: LD_INT 17
86031: PUSH
86032: LD_INT 18
86034: PUSH
86035: LD_INT 19
86037: PUSH
86038: LD_INT 20
86040: PUSH
86041: LD_INT 21
86043: PUSH
86044: LD_INT 22
86046: PUSH
86047: LD_INT 23
86049: PUSH
86050: LD_INT 24
86052: PUSH
86053: LD_INT 25
86055: PUSH
86056: LD_INT 26
86058: PUSH
86059: LD_INT 27
86061: PUSH
86062: LD_INT 28
86064: PUSH
86065: LD_INT 30
86067: PUSH
86068: LD_INT 31
86070: PUSH
86071: LD_INT 32
86073: PUSH
86074: LD_INT 33
86076: PUSH
86077: LD_INT 34
86079: PUSH
86080: LD_INT 36
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 101
86118: PUSH
86119: LD_INT 102
86121: PUSH
86122: LD_INT 103
86124: PUSH
86125: LD_INT 104
86127: PUSH
86128: LD_INT 105
86130: PUSH
86131: LD_INT 106
86133: PUSH
86134: LD_INT 107
86136: PUSH
86137: LD_INT 108
86139: PUSH
86140: LD_INT 109
86142: PUSH
86143: LD_INT 110
86145: PUSH
86146: LD_INT 111
86148: PUSH
86149: LD_INT 112
86151: PUSH
86152: LD_INT 113
86154: PUSH
86155: LD_INT 114
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: ST_TO_ADDR
86178: GO 87345
86180: LD_INT 14
86182: DOUBLE
86183: EQUAL
86184: IFTRUE 86188
86186: GO 86400
86188: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
86189: LD_ADDR_VAR 0 1
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: LD_INT 2
86199: PUSH
86200: LD_INT 3
86202: PUSH
86203: LD_INT 4
86205: PUSH
86206: LD_INT 5
86208: PUSH
86209: LD_INT 6
86211: PUSH
86212: LD_INT 7
86214: PUSH
86215: LD_INT 8
86217: PUSH
86218: LD_INT 9
86220: PUSH
86221: LD_INT 10
86223: PUSH
86224: LD_INT 11
86226: PUSH
86227: LD_INT 12
86229: PUSH
86230: LD_INT 13
86232: PUSH
86233: LD_INT 14
86235: PUSH
86236: LD_INT 15
86238: PUSH
86239: LD_INT 16
86241: PUSH
86242: LD_INT 17
86244: PUSH
86245: LD_INT 18
86247: PUSH
86248: LD_INT 19
86250: PUSH
86251: LD_INT 20
86253: PUSH
86254: LD_INT 21
86256: PUSH
86257: LD_INT 22
86259: PUSH
86260: LD_INT 23
86262: PUSH
86263: LD_INT 24
86265: PUSH
86266: LD_INT 25
86268: PUSH
86269: LD_INT 26
86271: PUSH
86272: LD_INT 27
86274: PUSH
86275: LD_INT 28
86277: PUSH
86278: LD_INT 29
86280: PUSH
86281: LD_INT 30
86283: PUSH
86284: LD_INT 31
86286: PUSH
86287: LD_INT 32
86289: PUSH
86290: LD_INT 33
86292: PUSH
86293: LD_INT 34
86295: PUSH
86296: LD_INT 36
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 101
86338: PUSH
86339: LD_INT 102
86341: PUSH
86342: LD_INT 103
86344: PUSH
86345: LD_INT 104
86347: PUSH
86348: LD_INT 105
86350: PUSH
86351: LD_INT 106
86353: PUSH
86354: LD_INT 107
86356: PUSH
86357: LD_INT 108
86359: PUSH
86360: LD_INT 109
86362: PUSH
86363: LD_INT 110
86365: PUSH
86366: LD_INT 111
86368: PUSH
86369: LD_INT 112
86371: PUSH
86372: LD_INT 113
86374: PUSH
86375: LD_INT 114
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: ST_TO_ADDR
86398: GO 87345
86400: LD_INT 15
86402: DOUBLE
86403: EQUAL
86404: IFTRUE 86408
86406: GO 86620
86408: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86409: LD_ADDR_VAR 0 1
86413: PUSH
86414: LD_INT 1
86416: PUSH
86417: LD_INT 2
86419: PUSH
86420: LD_INT 3
86422: PUSH
86423: LD_INT 4
86425: PUSH
86426: LD_INT 5
86428: PUSH
86429: LD_INT 6
86431: PUSH
86432: LD_INT 7
86434: PUSH
86435: LD_INT 8
86437: PUSH
86438: LD_INT 9
86440: PUSH
86441: LD_INT 10
86443: PUSH
86444: LD_INT 11
86446: PUSH
86447: LD_INT 12
86449: PUSH
86450: LD_INT 13
86452: PUSH
86453: LD_INT 14
86455: PUSH
86456: LD_INT 15
86458: PUSH
86459: LD_INT 16
86461: PUSH
86462: LD_INT 17
86464: PUSH
86465: LD_INT 18
86467: PUSH
86468: LD_INT 19
86470: PUSH
86471: LD_INT 20
86473: PUSH
86474: LD_INT 21
86476: PUSH
86477: LD_INT 22
86479: PUSH
86480: LD_INT 23
86482: PUSH
86483: LD_INT 24
86485: PUSH
86486: LD_INT 25
86488: PUSH
86489: LD_INT 26
86491: PUSH
86492: LD_INT 27
86494: PUSH
86495: LD_INT 28
86497: PUSH
86498: LD_INT 29
86500: PUSH
86501: LD_INT 30
86503: PUSH
86504: LD_INT 31
86506: PUSH
86507: LD_INT 32
86509: PUSH
86510: LD_INT 33
86512: PUSH
86513: LD_INT 34
86515: PUSH
86516: LD_INT 36
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 101
86558: PUSH
86559: LD_INT 102
86561: PUSH
86562: LD_INT 103
86564: PUSH
86565: LD_INT 104
86567: PUSH
86568: LD_INT 105
86570: PUSH
86571: LD_INT 106
86573: PUSH
86574: LD_INT 107
86576: PUSH
86577: LD_INT 108
86579: PUSH
86580: LD_INT 109
86582: PUSH
86583: LD_INT 110
86585: PUSH
86586: LD_INT 111
86588: PUSH
86589: LD_INT 112
86591: PUSH
86592: LD_INT 113
86594: PUSH
86595: LD_INT 114
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: ST_TO_ADDR
86618: GO 87345
86620: LD_INT 16
86622: DOUBLE
86623: EQUAL
86624: IFTRUE 86628
86626: GO 86752
86628: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86629: LD_ADDR_VAR 0 1
86633: PUSH
86634: LD_INT 2
86636: PUSH
86637: LD_INT 4
86639: PUSH
86640: LD_INT 5
86642: PUSH
86643: LD_INT 7
86645: PUSH
86646: LD_INT 11
86648: PUSH
86649: LD_INT 12
86651: PUSH
86652: LD_INT 15
86654: PUSH
86655: LD_INT 16
86657: PUSH
86658: LD_INT 20
86660: PUSH
86661: LD_INT 21
86663: PUSH
86664: LD_INT 22
86666: PUSH
86667: LD_INT 23
86669: PUSH
86670: LD_INT 25
86672: PUSH
86673: LD_INT 26
86675: PUSH
86676: LD_INT 30
86678: PUSH
86679: LD_INT 31
86681: PUSH
86682: LD_INT 32
86684: PUSH
86685: LD_INT 33
86687: PUSH
86688: LD_INT 34
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 101
86714: PUSH
86715: LD_INT 102
86717: PUSH
86718: LD_INT 103
86720: PUSH
86721: LD_INT 106
86723: PUSH
86724: LD_INT 108
86726: PUSH
86727: LD_INT 112
86729: PUSH
86730: LD_INT 113
86732: PUSH
86733: LD_INT 114
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: ST_TO_ADDR
86750: GO 87345
86752: LD_INT 17
86754: DOUBLE
86755: EQUAL
86756: IFTRUE 86760
86758: GO 86972
86760: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86761: LD_ADDR_VAR 0 1
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: LD_INT 2
86771: PUSH
86772: LD_INT 3
86774: PUSH
86775: LD_INT 4
86777: PUSH
86778: LD_INT 5
86780: PUSH
86781: LD_INT 6
86783: PUSH
86784: LD_INT 7
86786: PUSH
86787: LD_INT 8
86789: PUSH
86790: LD_INT 9
86792: PUSH
86793: LD_INT 10
86795: PUSH
86796: LD_INT 11
86798: PUSH
86799: LD_INT 12
86801: PUSH
86802: LD_INT 13
86804: PUSH
86805: LD_INT 14
86807: PUSH
86808: LD_INT 15
86810: PUSH
86811: LD_INT 16
86813: PUSH
86814: LD_INT 17
86816: PUSH
86817: LD_INT 18
86819: PUSH
86820: LD_INT 19
86822: PUSH
86823: LD_INT 20
86825: PUSH
86826: LD_INT 21
86828: PUSH
86829: LD_INT 22
86831: PUSH
86832: LD_INT 23
86834: PUSH
86835: LD_INT 24
86837: PUSH
86838: LD_INT 25
86840: PUSH
86841: LD_INT 26
86843: PUSH
86844: LD_INT 27
86846: PUSH
86847: LD_INT 28
86849: PUSH
86850: LD_INT 29
86852: PUSH
86853: LD_INT 30
86855: PUSH
86856: LD_INT 31
86858: PUSH
86859: LD_INT 32
86861: PUSH
86862: LD_INT 33
86864: PUSH
86865: LD_INT 34
86867: PUSH
86868: LD_INT 36
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 101
86910: PUSH
86911: LD_INT 102
86913: PUSH
86914: LD_INT 103
86916: PUSH
86917: LD_INT 104
86919: PUSH
86920: LD_INT 105
86922: PUSH
86923: LD_INT 106
86925: PUSH
86926: LD_INT 107
86928: PUSH
86929: LD_INT 108
86931: PUSH
86932: LD_INT 109
86934: PUSH
86935: LD_INT 110
86937: PUSH
86938: LD_INT 111
86940: PUSH
86941: LD_INT 112
86943: PUSH
86944: LD_INT 113
86946: PUSH
86947: LD_INT 114
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: ST_TO_ADDR
86970: GO 87345
86972: LD_INT 18
86974: DOUBLE
86975: EQUAL
86976: IFTRUE 86980
86978: GO 87116
86980: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86981: LD_ADDR_VAR 0 1
86985: PUSH
86986: LD_INT 2
86988: PUSH
86989: LD_INT 4
86991: PUSH
86992: LD_INT 5
86994: PUSH
86995: LD_INT 7
86997: PUSH
86998: LD_INT 11
87000: PUSH
87001: LD_INT 12
87003: PUSH
87004: LD_INT 15
87006: PUSH
87007: LD_INT 16
87009: PUSH
87010: LD_INT 20
87012: PUSH
87013: LD_INT 21
87015: PUSH
87016: LD_INT 22
87018: PUSH
87019: LD_INT 23
87021: PUSH
87022: LD_INT 25
87024: PUSH
87025: LD_INT 26
87027: PUSH
87028: LD_INT 30
87030: PUSH
87031: LD_INT 31
87033: PUSH
87034: LD_INT 32
87036: PUSH
87037: LD_INT 33
87039: PUSH
87040: LD_INT 34
87042: PUSH
87043: LD_INT 35
87045: PUSH
87046: LD_INT 36
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 101
87074: PUSH
87075: LD_INT 102
87077: PUSH
87078: LD_INT 103
87080: PUSH
87081: LD_INT 106
87083: PUSH
87084: LD_INT 108
87086: PUSH
87087: LD_INT 112
87089: PUSH
87090: LD_INT 113
87092: PUSH
87093: LD_INT 114
87095: PUSH
87096: LD_INT 115
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: ST_TO_ADDR
87114: GO 87345
87116: LD_INT 19
87118: DOUBLE
87119: EQUAL
87120: IFTRUE 87124
87122: GO 87344
87124: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87125: LD_ADDR_VAR 0 1
87129: PUSH
87130: LD_INT 1
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: LD_INT 3
87138: PUSH
87139: LD_INT 4
87141: PUSH
87142: LD_INT 5
87144: PUSH
87145: LD_INT 6
87147: PUSH
87148: LD_INT 7
87150: PUSH
87151: LD_INT 8
87153: PUSH
87154: LD_INT 9
87156: PUSH
87157: LD_INT 10
87159: PUSH
87160: LD_INT 11
87162: PUSH
87163: LD_INT 12
87165: PUSH
87166: LD_INT 13
87168: PUSH
87169: LD_INT 14
87171: PUSH
87172: LD_INT 15
87174: PUSH
87175: LD_INT 16
87177: PUSH
87178: LD_INT 17
87180: PUSH
87181: LD_INT 18
87183: PUSH
87184: LD_INT 19
87186: PUSH
87187: LD_INT 20
87189: PUSH
87190: LD_INT 21
87192: PUSH
87193: LD_INT 22
87195: PUSH
87196: LD_INT 23
87198: PUSH
87199: LD_INT 24
87201: PUSH
87202: LD_INT 25
87204: PUSH
87205: LD_INT 26
87207: PUSH
87208: LD_INT 27
87210: PUSH
87211: LD_INT 28
87213: PUSH
87214: LD_INT 29
87216: PUSH
87217: LD_INT 30
87219: PUSH
87220: LD_INT 31
87222: PUSH
87223: LD_INT 32
87225: PUSH
87226: LD_INT 33
87228: PUSH
87229: LD_INT 34
87231: PUSH
87232: LD_INT 35
87234: PUSH
87235: LD_INT 36
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 101
87278: PUSH
87279: LD_INT 102
87281: PUSH
87282: LD_INT 103
87284: PUSH
87285: LD_INT 104
87287: PUSH
87288: LD_INT 105
87290: PUSH
87291: LD_INT 106
87293: PUSH
87294: LD_INT 107
87296: PUSH
87297: LD_INT 108
87299: PUSH
87300: LD_INT 109
87302: PUSH
87303: LD_INT 110
87305: PUSH
87306: LD_INT 111
87308: PUSH
87309: LD_INT 112
87311: PUSH
87312: LD_INT 113
87314: PUSH
87315: LD_INT 114
87317: PUSH
87318: LD_INT 115
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: ST_TO_ADDR
87342: GO 87345
87344: POP
// end else
87345: GO 87564
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87347: LD_ADDR_VAR 0 1
87351: PUSH
87352: LD_INT 1
87354: PUSH
87355: LD_INT 2
87357: PUSH
87358: LD_INT 3
87360: PUSH
87361: LD_INT 4
87363: PUSH
87364: LD_INT 5
87366: PUSH
87367: LD_INT 6
87369: PUSH
87370: LD_INT 7
87372: PUSH
87373: LD_INT 8
87375: PUSH
87376: LD_INT 9
87378: PUSH
87379: LD_INT 10
87381: PUSH
87382: LD_INT 11
87384: PUSH
87385: LD_INT 12
87387: PUSH
87388: LD_INT 13
87390: PUSH
87391: LD_INT 14
87393: PUSH
87394: LD_INT 15
87396: PUSH
87397: LD_INT 16
87399: PUSH
87400: LD_INT 17
87402: PUSH
87403: LD_INT 18
87405: PUSH
87406: LD_INT 19
87408: PUSH
87409: LD_INT 20
87411: PUSH
87412: LD_INT 21
87414: PUSH
87415: LD_INT 22
87417: PUSH
87418: LD_INT 23
87420: PUSH
87421: LD_INT 24
87423: PUSH
87424: LD_INT 25
87426: PUSH
87427: LD_INT 26
87429: PUSH
87430: LD_INT 27
87432: PUSH
87433: LD_INT 28
87435: PUSH
87436: LD_INT 29
87438: PUSH
87439: LD_INT 30
87441: PUSH
87442: LD_INT 31
87444: PUSH
87445: LD_INT 32
87447: PUSH
87448: LD_INT 33
87450: PUSH
87451: LD_INT 34
87453: PUSH
87454: LD_INT 35
87456: PUSH
87457: LD_INT 36
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 101
87500: PUSH
87501: LD_INT 102
87503: PUSH
87504: LD_INT 103
87506: PUSH
87507: LD_INT 104
87509: PUSH
87510: LD_INT 105
87512: PUSH
87513: LD_INT 106
87515: PUSH
87516: LD_INT 107
87518: PUSH
87519: LD_INT 108
87521: PUSH
87522: LD_INT 109
87524: PUSH
87525: LD_INT 110
87527: PUSH
87528: LD_INT 111
87530: PUSH
87531: LD_INT 112
87533: PUSH
87534: LD_INT 113
87536: PUSH
87537: LD_INT 114
87539: PUSH
87540: LD_INT 115
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: ST_TO_ADDR
// if result then
87564: LD_VAR 0 1
87568: IFFALSE 87857
// begin normal :=  ;
87570: LD_ADDR_VAR 0 3
87574: PUSH
87575: LD_STRING 
87577: ST_TO_ADDR
// hardcore :=  ;
87578: LD_ADDR_VAR 0 4
87582: PUSH
87583: LD_STRING 
87585: ST_TO_ADDR
// for i = 1 to normalCounter do
87586: LD_ADDR_VAR 0 5
87590: PUSH
87591: DOUBLE
87592: LD_INT 1
87594: DEC
87595: ST_TO_ADDR
87596: LD_EXP 123
87600: PUSH
87601: FOR_TO
87602: IFFALSE 87703
// begin tmp := 0 ;
87604: LD_ADDR_VAR 0 2
87608: PUSH
87609: LD_STRING 0
87611: ST_TO_ADDR
// if result [ 1 ] then
87612: LD_VAR 0 1
87616: PUSH
87617: LD_INT 1
87619: ARRAY
87620: IFFALSE 87685
// if result [ 1 ] [ 1 ] = i then
87622: LD_VAR 0 1
87626: PUSH
87627: LD_INT 1
87629: ARRAY
87630: PUSH
87631: LD_INT 1
87633: ARRAY
87634: PUSH
87635: LD_VAR 0 5
87639: EQUAL
87640: IFFALSE 87685
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87642: LD_ADDR_VAR 0 1
87646: PUSH
87647: LD_VAR 0 1
87651: PPUSH
87652: LD_INT 1
87654: PPUSH
87655: LD_VAR 0 1
87659: PUSH
87660: LD_INT 1
87662: ARRAY
87663: PPUSH
87664: LD_INT 1
87666: PPUSH
87667: CALL_OW 3
87671: PPUSH
87672: CALL_OW 1
87676: ST_TO_ADDR
// tmp := 1 ;
87677: LD_ADDR_VAR 0 2
87681: PUSH
87682: LD_STRING 1
87684: ST_TO_ADDR
// end ; normal := normal & tmp ;
87685: LD_ADDR_VAR 0 3
87689: PUSH
87690: LD_VAR 0 3
87694: PUSH
87695: LD_VAR 0 2
87699: STR
87700: ST_TO_ADDR
// end ;
87701: GO 87601
87703: POP
87704: POP
// for i = 1 to hardcoreCounter do
87705: LD_ADDR_VAR 0 5
87709: PUSH
87710: DOUBLE
87711: LD_INT 1
87713: DEC
87714: ST_TO_ADDR
87715: LD_EXP 124
87719: PUSH
87720: FOR_TO
87721: IFFALSE 87826
// begin tmp := 0 ;
87723: LD_ADDR_VAR 0 2
87727: PUSH
87728: LD_STRING 0
87730: ST_TO_ADDR
// if result [ 2 ] then
87731: LD_VAR 0 1
87735: PUSH
87736: LD_INT 2
87738: ARRAY
87739: IFFALSE 87808
// if result [ 2 ] [ 1 ] = 100 + i then
87741: LD_VAR 0 1
87745: PUSH
87746: LD_INT 2
87748: ARRAY
87749: PUSH
87750: LD_INT 1
87752: ARRAY
87753: PUSH
87754: LD_INT 100
87756: PUSH
87757: LD_VAR 0 5
87761: PLUS
87762: EQUAL
87763: IFFALSE 87808
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87765: LD_ADDR_VAR 0 1
87769: PUSH
87770: LD_VAR 0 1
87774: PPUSH
87775: LD_INT 2
87777: PPUSH
87778: LD_VAR 0 1
87782: PUSH
87783: LD_INT 2
87785: ARRAY
87786: PPUSH
87787: LD_INT 1
87789: PPUSH
87790: CALL_OW 3
87794: PPUSH
87795: CALL_OW 1
87799: ST_TO_ADDR
// tmp := 1 ;
87800: LD_ADDR_VAR 0 2
87804: PUSH
87805: LD_STRING 1
87807: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87808: LD_ADDR_VAR 0 4
87812: PUSH
87813: LD_VAR 0 4
87817: PUSH
87818: LD_VAR 0 2
87822: STR
87823: ST_TO_ADDR
// end ;
87824: GO 87720
87826: POP
87827: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87828: LD_STRING getStreamItemsFromMission("
87830: PUSH
87831: LD_VAR 0 3
87835: STR
87836: PUSH
87837: LD_STRING ","
87839: STR
87840: PUSH
87841: LD_VAR 0 4
87845: STR
87846: PUSH
87847: LD_STRING ")
87849: STR
87850: PPUSH
87851: CALL_OW 559
// end else
87855: GO 87864
// ToLua ( getStreamItemsFromMission("","") ) ;
87857: LD_STRING getStreamItemsFromMission("","")
87859: PPUSH
87860: CALL_OW 559
// end ;
87864: LD_VAR 0 1
87868: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87869: LD_EXP 122
87873: PUSH
87874: LD_EXP 127
87878: AND
87879: IFFALSE 88003
87881: GO 87883
87883: DISABLE
87884: LD_INT 0
87886: PPUSH
87887: PPUSH
// begin enable ;
87888: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87889: LD_ADDR_VAR 0 2
87893: PUSH
87894: LD_INT 22
87896: PUSH
87897: LD_OWVAR 2
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 2
87908: PUSH
87909: LD_INT 34
87911: PUSH
87912: LD_INT 7
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 34
87921: PUSH
87922: LD_INT 45
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 34
87931: PUSH
87932: LD_INT 28
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 34
87941: PUSH
87942: LD_INT 47
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PPUSH
87960: CALL_OW 69
87964: ST_TO_ADDR
// if not tmp then
87965: LD_VAR 0 2
87969: NOT
87970: IFFALSE 87974
// exit ;
87972: GO 88003
// for i in tmp do
87974: LD_ADDR_VAR 0 1
87978: PUSH
87979: LD_VAR 0 2
87983: PUSH
87984: FOR_IN
87985: IFFALSE 88001
// begin SetLives ( i , 0 ) ;
87987: LD_VAR 0 1
87991: PPUSH
87992: LD_INT 0
87994: PPUSH
87995: CALL_OW 234
// end ;
87999: GO 87984
88001: POP
88002: POP
// end ;
88003: PPOPN 2
88005: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
88006: LD_EXP 122
88010: PUSH
88011: LD_EXP 128
88015: AND
88016: IFFALSE 88100
88018: GO 88020
88020: DISABLE
88021: LD_INT 0
88023: PPUSH
88024: PPUSH
// begin enable ;
88025: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88026: LD_ADDR_VAR 0 2
88030: PUSH
88031: LD_INT 22
88033: PUSH
88034: LD_OWVAR 2
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PUSH
88043: LD_INT 32
88045: PUSH
88046: LD_INT 3
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PPUSH
88057: CALL_OW 69
88061: ST_TO_ADDR
// if not tmp then
88062: LD_VAR 0 2
88066: NOT
88067: IFFALSE 88071
// exit ;
88069: GO 88100
// for i in tmp do
88071: LD_ADDR_VAR 0 1
88075: PUSH
88076: LD_VAR 0 2
88080: PUSH
88081: FOR_IN
88082: IFFALSE 88098
// begin SetLives ( i , 0 ) ;
88084: LD_VAR 0 1
88088: PPUSH
88089: LD_INT 0
88091: PPUSH
88092: CALL_OW 234
// end ;
88096: GO 88081
88098: POP
88099: POP
// end ;
88100: PPOPN 2
88102: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88103: LD_EXP 122
88107: PUSH
88108: LD_EXP 125
88112: AND
88113: IFFALSE 88206
88115: GO 88117
88117: DISABLE
88118: LD_INT 0
88120: PPUSH
// begin enable ;
88121: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88122: LD_ADDR_VAR 0 1
88126: PUSH
88127: LD_INT 22
88129: PUSH
88130: LD_OWVAR 2
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: PUSH
88142: LD_INT 25
88144: PUSH
88145: LD_INT 5
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 25
88154: PUSH
88155: LD_INT 9
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 25
88164: PUSH
88165: LD_INT 8
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PPUSH
88182: CALL_OW 69
88186: PUSH
88187: FOR_IN
88188: IFFALSE 88204
// begin SetClass ( i , 1 ) ;
88190: LD_VAR 0 1
88194: PPUSH
88195: LD_INT 1
88197: PPUSH
88198: CALL_OW 336
// end ;
88202: GO 88187
88204: POP
88205: POP
// end ;
88206: PPOPN 1
88208: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88209: LD_EXP 122
88213: PUSH
88214: LD_EXP 126
88218: AND
88219: PUSH
88220: LD_OWVAR 65
88224: PUSH
88225: LD_INT 7
88227: LESS
88228: AND
88229: IFFALSE 88243
88231: GO 88233
88233: DISABLE
// begin enable ;
88234: ENABLE
// game_speed := 7 ;
88235: LD_ADDR_OWVAR 65
88239: PUSH
88240: LD_INT 7
88242: ST_TO_ADDR
// end ;
88243: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88244: LD_EXP 122
88248: PUSH
88249: LD_EXP 129
88253: AND
88254: IFFALSE 88456
88256: GO 88258
88258: DISABLE
88259: LD_INT 0
88261: PPUSH
88262: PPUSH
88263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88264: LD_ADDR_VAR 0 3
88268: PUSH
88269: LD_INT 81
88271: PUSH
88272: LD_OWVAR 2
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 21
88283: PUSH
88284: LD_INT 1
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PPUSH
88295: CALL_OW 69
88299: ST_TO_ADDR
// if not tmp then
88300: LD_VAR 0 3
88304: NOT
88305: IFFALSE 88309
// exit ;
88307: GO 88456
// if tmp > 5 then
88309: LD_VAR 0 3
88313: PUSH
88314: LD_INT 5
88316: GREATER
88317: IFFALSE 88329
// k := 5 else
88319: LD_ADDR_VAR 0 2
88323: PUSH
88324: LD_INT 5
88326: ST_TO_ADDR
88327: GO 88339
// k := tmp ;
88329: LD_ADDR_VAR 0 2
88333: PUSH
88334: LD_VAR 0 3
88338: ST_TO_ADDR
// for i := 1 to k do
88339: LD_ADDR_VAR 0 1
88343: PUSH
88344: DOUBLE
88345: LD_INT 1
88347: DEC
88348: ST_TO_ADDR
88349: LD_VAR 0 2
88353: PUSH
88354: FOR_TO
88355: IFFALSE 88454
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
88357: LD_VAR 0 3
88361: PUSH
88362: LD_VAR 0 1
88366: ARRAY
88367: PPUSH
88368: LD_VAR 0 1
88372: PUSH
88373: LD_INT 4
88375: MOD
88376: PUSH
88377: LD_INT 1
88379: PLUS
88380: PPUSH
88381: CALL_OW 259
88385: PUSH
88386: LD_INT 10
88388: LESS
88389: IFFALSE 88452
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88391: LD_VAR 0 3
88395: PUSH
88396: LD_VAR 0 1
88400: ARRAY
88401: PPUSH
88402: LD_VAR 0 1
88406: PUSH
88407: LD_INT 4
88409: MOD
88410: PUSH
88411: LD_INT 1
88413: PLUS
88414: PPUSH
88415: LD_VAR 0 3
88419: PUSH
88420: LD_VAR 0 1
88424: ARRAY
88425: PPUSH
88426: LD_VAR 0 1
88430: PUSH
88431: LD_INT 4
88433: MOD
88434: PUSH
88435: LD_INT 1
88437: PLUS
88438: PPUSH
88439: CALL_OW 259
88443: PUSH
88444: LD_INT 1
88446: PLUS
88447: PPUSH
88448: CALL_OW 237
88452: GO 88354
88454: POP
88455: POP
// end ;
88456: PPOPN 3
88458: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88459: LD_EXP 122
88463: PUSH
88464: LD_EXP 130
88468: AND
88469: IFFALSE 88489
88471: GO 88473
88473: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88474: LD_INT 4
88476: PPUSH
88477: LD_OWVAR 2
88481: PPUSH
88482: LD_INT 0
88484: PPUSH
88485: CALL_OW 324
88489: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88490: LD_EXP 122
88494: PUSH
88495: LD_EXP 159
88499: AND
88500: IFFALSE 88520
88502: GO 88504
88504: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88505: LD_INT 19
88507: PPUSH
88508: LD_OWVAR 2
88512: PPUSH
88513: LD_INT 0
88515: PPUSH
88516: CALL_OW 324
88520: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88521: LD_EXP 122
88525: PUSH
88526: LD_EXP 131
88530: AND
88531: IFFALSE 88633
88533: GO 88535
88535: DISABLE
88536: LD_INT 0
88538: PPUSH
88539: PPUSH
// begin enable ;
88540: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88541: LD_ADDR_VAR 0 2
88545: PUSH
88546: LD_INT 22
88548: PUSH
88549: LD_OWVAR 2
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 2
88560: PUSH
88561: LD_INT 34
88563: PUSH
88564: LD_INT 11
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 34
88573: PUSH
88574: LD_INT 30
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: LIST
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PPUSH
88590: CALL_OW 69
88594: ST_TO_ADDR
// if not tmp then
88595: LD_VAR 0 2
88599: NOT
88600: IFFALSE 88604
// exit ;
88602: GO 88633
// for i in tmp do
88604: LD_ADDR_VAR 0 1
88608: PUSH
88609: LD_VAR 0 2
88613: PUSH
88614: FOR_IN
88615: IFFALSE 88631
// begin SetLives ( i , 0 ) ;
88617: LD_VAR 0 1
88621: PPUSH
88622: LD_INT 0
88624: PPUSH
88625: CALL_OW 234
// end ;
88629: GO 88614
88631: POP
88632: POP
// end ;
88633: PPOPN 2
88635: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88636: LD_EXP 122
88640: PUSH
88641: LD_EXP 132
88645: AND
88646: IFFALSE 88666
88648: GO 88650
88650: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88651: LD_INT 32
88653: PPUSH
88654: LD_OWVAR 2
88658: PPUSH
88659: LD_INT 0
88661: PPUSH
88662: CALL_OW 324
88666: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88667: LD_EXP 122
88671: PUSH
88672: LD_EXP 133
88676: AND
88677: IFFALSE 88858
88679: GO 88681
88681: DISABLE
88682: LD_INT 0
88684: PPUSH
88685: PPUSH
88686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88687: LD_ADDR_VAR 0 2
88691: PUSH
88692: LD_INT 22
88694: PUSH
88695: LD_OWVAR 2
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 33
88706: PUSH
88707: LD_INT 3
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PPUSH
88718: CALL_OW 69
88722: ST_TO_ADDR
// if not tmp then
88723: LD_VAR 0 2
88727: NOT
88728: IFFALSE 88732
// exit ;
88730: GO 88858
// side := 0 ;
88732: LD_ADDR_VAR 0 3
88736: PUSH
88737: LD_INT 0
88739: ST_TO_ADDR
// for i := 1 to 8 do
88740: LD_ADDR_VAR 0 1
88744: PUSH
88745: DOUBLE
88746: LD_INT 1
88748: DEC
88749: ST_TO_ADDR
88750: LD_INT 8
88752: PUSH
88753: FOR_TO
88754: IFFALSE 88802
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88756: LD_OWVAR 2
88760: PUSH
88761: LD_VAR 0 1
88765: NONEQUAL
88766: PUSH
88767: LD_OWVAR 2
88771: PPUSH
88772: LD_VAR 0 1
88776: PPUSH
88777: CALL_OW 81
88781: PUSH
88782: LD_INT 2
88784: EQUAL
88785: AND
88786: IFFALSE 88800
// begin side := i ;
88788: LD_ADDR_VAR 0 3
88792: PUSH
88793: LD_VAR 0 1
88797: ST_TO_ADDR
// break ;
88798: GO 88802
// end ;
88800: GO 88753
88802: POP
88803: POP
// if not side then
88804: LD_VAR 0 3
88808: NOT
88809: IFFALSE 88813
// exit ;
88811: GO 88858
// for i := 1 to tmp do
88813: LD_ADDR_VAR 0 1
88817: PUSH
88818: DOUBLE
88819: LD_INT 1
88821: DEC
88822: ST_TO_ADDR
88823: LD_VAR 0 2
88827: PUSH
88828: FOR_TO
88829: IFFALSE 88856
// if Prob ( 60 ) then
88831: LD_INT 60
88833: PPUSH
88834: CALL_OW 13
88838: IFFALSE 88854
// SetSide ( i , side ) ;
88840: LD_VAR 0 1
88844: PPUSH
88845: LD_VAR 0 3
88849: PPUSH
88850: CALL_OW 235
88854: GO 88828
88856: POP
88857: POP
// end ;
88858: PPOPN 3
88860: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88861: LD_EXP 122
88865: PUSH
88866: LD_EXP 135
88870: AND
88871: IFFALSE 88990
88873: GO 88875
88875: DISABLE
88876: LD_INT 0
88878: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88879: LD_ADDR_VAR 0 1
88883: PUSH
88884: LD_INT 22
88886: PUSH
88887: LD_OWVAR 2
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: PUSH
88896: LD_INT 21
88898: PUSH
88899: LD_INT 1
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: LD_INT 3
88908: PUSH
88909: LD_INT 23
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: LIST
88927: PPUSH
88928: CALL_OW 69
88932: PUSH
88933: FOR_IN
88934: IFFALSE 88988
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88936: LD_VAR 0 1
88940: PPUSH
88941: CALL_OW 257
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: LD_INT 2
88951: PUSH
88952: LD_INT 3
88954: PUSH
88955: LD_INT 4
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: IN
88964: IFFALSE 88986
// SetClass ( un , rand ( 1 , 4 ) ) ;
88966: LD_VAR 0 1
88970: PPUSH
88971: LD_INT 1
88973: PPUSH
88974: LD_INT 4
88976: PPUSH
88977: CALL_OW 12
88981: PPUSH
88982: CALL_OW 336
88986: GO 88933
88988: POP
88989: POP
// end ;
88990: PPOPN 1
88992: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88993: LD_EXP 122
88997: PUSH
88998: LD_EXP 134
89002: AND
89003: IFFALSE 89082
89005: GO 89007
89007: DISABLE
89008: LD_INT 0
89010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89011: LD_ADDR_VAR 0 1
89015: PUSH
89016: LD_INT 22
89018: PUSH
89019: LD_OWVAR 2
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 21
89030: PUSH
89031: LD_INT 3
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PPUSH
89042: CALL_OW 69
89046: ST_TO_ADDR
// if not tmp then
89047: LD_VAR 0 1
89051: NOT
89052: IFFALSE 89056
// exit ;
89054: GO 89082
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89056: LD_VAR 0 1
89060: PUSH
89061: LD_INT 1
89063: PPUSH
89064: LD_VAR 0 1
89068: PPUSH
89069: CALL_OW 12
89073: ARRAY
89074: PPUSH
89075: LD_INT 100
89077: PPUSH
89078: CALL_OW 234
// end ;
89082: PPOPN 1
89084: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89085: LD_EXP 122
89089: PUSH
89090: LD_EXP 136
89094: AND
89095: IFFALSE 89193
89097: GO 89099
89099: DISABLE
89100: LD_INT 0
89102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89103: LD_ADDR_VAR 0 1
89107: PUSH
89108: LD_INT 22
89110: PUSH
89111: LD_OWVAR 2
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 21
89122: PUSH
89123: LD_INT 1
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PPUSH
89134: CALL_OW 69
89138: ST_TO_ADDR
// if not tmp then
89139: LD_VAR 0 1
89143: NOT
89144: IFFALSE 89148
// exit ;
89146: GO 89193
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89148: LD_VAR 0 1
89152: PUSH
89153: LD_INT 1
89155: PPUSH
89156: LD_VAR 0 1
89160: PPUSH
89161: CALL_OW 12
89165: ARRAY
89166: PPUSH
89167: LD_INT 1
89169: PPUSH
89170: LD_INT 4
89172: PPUSH
89173: CALL_OW 12
89177: PPUSH
89178: LD_INT 3000
89180: PPUSH
89181: LD_INT 9000
89183: PPUSH
89184: CALL_OW 12
89188: PPUSH
89189: CALL_OW 492
// end ;
89193: PPOPN 1
89195: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89196: LD_EXP 122
89200: PUSH
89201: LD_EXP 137
89205: AND
89206: IFFALSE 89226
89208: GO 89210
89210: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89211: LD_INT 1
89213: PPUSH
89214: LD_OWVAR 2
89218: PPUSH
89219: LD_INT 0
89221: PPUSH
89222: CALL_OW 324
89226: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89227: LD_EXP 122
89231: PUSH
89232: LD_EXP 138
89236: AND
89237: IFFALSE 89320
89239: GO 89241
89241: DISABLE
89242: LD_INT 0
89244: PPUSH
89245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89246: LD_ADDR_VAR 0 2
89250: PUSH
89251: LD_INT 22
89253: PUSH
89254: LD_OWVAR 2
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 21
89265: PUSH
89266: LD_INT 3
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PPUSH
89277: CALL_OW 69
89281: ST_TO_ADDR
// if not tmp then
89282: LD_VAR 0 2
89286: NOT
89287: IFFALSE 89291
// exit ;
89289: GO 89320
// for i in tmp do
89291: LD_ADDR_VAR 0 1
89295: PUSH
89296: LD_VAR 0 2
89300: PUSH
89301: FOR_IN
89302: IFFALSE 89318
// SetBLevel ( i , 10 ) ;
89304: LD_VAR 0 1
89308: PPUSH
89309: LD_INT 10
89311: PPUSH
89312: CALL_OW 241
89316: GO 89301
89318: POP
89319: POP
// end ;
89320: PPOPN 2
89322: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
89323: LD_EXP 122
89327: PUSH
89328: LD_EXP 139
89332: AND
89333: IFFALSE 89444
89335: GO 89337
89337: DISABLE
89338: LD_INT 0
89340: PPUSH
89341: PPUSH
89342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89343: LD_ADDR_VAR 0 3
89347: PUSH
89348: LD_INT 22
89350: PUSH
89351: LD_OWVAR 2
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 25
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: PPUSH
89374: CALL_OW 69
89378: ST_TO_ADDR
// if not tmp then
89379: LD_VAR 0 3
89383: NOT
89384: IFFALSE 89388
// exit ;
89386: GO 89444
// un := tmp [ rand ( 1 , tmp ) ] ;
89388: LD_ADDR_VAR 0 2
89392: PUSH
89393: LD_VAR 0 3
89397: PUSH
89398: LD_INT 1
89400: PPUSH
89401: LD_VAR 0 3
89405: PPUSH
89406: CALL_OW 12
89410: ARRAY
89411: ST_TO_ADDR
// if Crawls ( un ) then
89412: LD_VAR 0 2
89416: PPUSH
89417: CALL_OW 318
89421: IFFALSE 89432
// ComWalk ( un ) ;
89423: LD_VAR 0 2
89427: PPUSH
89428: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89432: LD_VAR 0 2
89436: PPUSH
89437: LD_INT 5
89439: PPUSH
89440: CALL_OW 336
// end ;
89444: PPOPN 3
89446: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89447: LD_EXP 122
89451: PUSH
89452: LD_EXP 140
89456: AND
89457: PUSH
89458: LD_OWVAR 67
89462: PUSH
89463: LD_INT 3
89465: LESS
89466: AND
89467: IFFALSE 89486
89469: GO 89471
89471: DISABLE
// Difficulty := Difficulty + 1 ;
89472: LD_ADDR_OWVAR 67
89476: PUSH
89477: LD_OWVAR 67
89481: PUSH
89482: LD_INT 1
89484: PLUS
89485: ST_TO_ADDR
89486: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89487: LD_EXP 122
89491: PUSH
89492: LD_EXP 141
89496: AND
89497: IFFALSE 89600
89499: GO 89501
89501: DISABLE
89502: LD_INT 0
89504: PPUSH
// begin for i := 1 to 5 do
89505: LD_ADDR_VAR 0 1
89509: PUSH
89510: DOUBLE
89511: LD_INT 1
89513: DEC
89514: ST_TO_ADDR
89515: LD_INT 5
89517: PUSH
89518: FOR_TO
89519: IFFALSE 89598
// begin uc_nation := nation_nature ;
89521: LD_ADDR_OWVAR 21
89525: PUSH
89526: LD_INT 0
89528: ST_TO_ADDR
// uc_side := 0 ;
89529: LD_ADDR_OWVAR 20
89533: PUSH
89534: LD_INT 0
89536: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89537: LD_ADDR_OWVAR 29
89541: PUSH
89542: LD_INT 12
89544: PUSH
89545: LD_INT 12
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: ST_TO_ADDR
// hc_agressivity := 20 ;
89552: LD_ADDR_OWVAR 35
89556: PUSH
89557: LD_INT 20
89559: ST_TO_ADDR
// hc_class := class_tiger ;
89560: LD_ADDR_OWVAR 28
89564: PUSH
89565: LD_INT 14
89567: ST_TO_ADDR
// hc_gallery :=  ;
89568: LD_ADDR_OWVAR 33
89572: PUSH
89573: LD_STRING 
89575: ST_TO_ADDR
// hc_name :=  ;
89576: LD_ADDR_OWVAR 26
89580: PUSH
89581: LD_STRING 
89583: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89584: CALL_OW 44
89588: PPUSH
89589: LD_INT 0
89591: PPUSH
89592: CALL_OW 51
// end ;
89596: GO 89518
89598: POP
89599: POP
// end ;
89600: PPOPN 1
89602: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89603: LD_EXP 122
89607: PUSH
89608: LD_EXP 142
89612: AND
89613: IFFALSE 89622
89615: GO 89617
89617: DISABLE
// StreamSibBomb ;
89618: CALL 89623 0 0
89622: END
// export function StreamSibBomb ; var i , x , y ; begin
89623: LD_INT 0
89625: PPUSH
89626: PPUSH
89627: PPUSH
89628: PPUSH
// result := false ;
89629: LD_ADDR_VAR 0 1
89633: PUSH
89634: LD_INT 0
89636: ST_TO_ADDR
// for i := 1 to 16 do
89637: LD_ADDR_VAR 0 2
89641: PUSH
89642: DOUBLE
89643: LD_INT 1
89645: DEC
89646: ST_TO_ADDR
89647: LD_INT 16
89649: PUSH
89650: FOR_TO
89651: IFFALSE 89850
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89653: LD_ADDR_VAR 0 3
89657: PUSH
89658: LD_INT 10
89660: PUSH
89661: LD_INT 20
89663: PUSH
89664: LD_INT 30
89666: PUSH
89667: LD_INT 40
89669: PUSH
89670: LD_INT 50
89672: PUSH
89673: LD_INT 60
89675: PUSH
89676: LD_INT 70
89678: PUSH
89679: LD_INT 80
89681: PUSH
89682: LD_INT 90
89684: PUSH
89685: LD_INT 100
89687: PUSH
89688: LD_INT 110
89690: PUSH
89691: LD_INT 120
89693: PUSH
89694: LD_INT 130
89696: PUSH
89697: LD_INT 140
89699: PUSH
89700: LD_INT 150
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: PPUSH
89723: LD_INT 15
89725: PPUSH
89726: CALL_OW 12
89730: ARRAY
89731: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89732: LD_ADDR_VAR 0 4
89736: PUSH
89737: LD_INT 10
89739: PUSH
89740: LD_INT 20
89742: PUSH
89743: LD_INT 30
89745: PUSH
89746: LD_INT 40
89748: PUSH
89749: LD_INT 50
89751: PUSH
89752: LD_INT 60
89754: PUSH
89755: LD_INT 70
89757: PUSH
89758: LD_INT 80
89760: PUSH
89761: LD_INT 90
89763: PUSH
89764: LD_INT 100
89766: PUSH
89767: LD_INT 110
89769: PUSH
89770: LD_INT 120
89772: PUSH
89773: LD_INT 130
89775: PUSH
89776: LD_INT 140
89778: PUSH
89779: LD_INT 150
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 1
89801: PPUSH
89802: LD_INT 15
89804: PPUSH
89805: CALL_OW 12
89809: ARRAY
89810: ST_TO_ADDR
// if ValidHex ( x , y ) then
89811: LD_VAR 0 3
89815: PPUSH
89816: LD_VAR 0 4
89820: PPUSH
89821: CALL_OW 488
89825: IFFALSE 89848
// begin result := [ x , y ] ;
89827: LD_ADDR_VAR 0 1
89831: PUSH
89832: LD_VAR 0 3
89836: PUSH
89837: LD_VAR 0 4
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: ST_TO_ADDR
// break ;
89846: GO 89850
// end ; end ;
89848: GO 89650
89850: POP
89851: POP
// if result then
89852: LD_VAR 0 1
89856: IFFALSE 89916
// begin ToLua ( playSibBomb() ) ;
89858: LD_STRING playSibBomb()
89860: PPUSH
89861: CALL_OW 559
// wait ( 0 0$14 ) ;
89865: LD_INT 490
89867: PPUSH
89868: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89872: LD_VAR 0 1
89876: PUSH
89877: LD_INT 1
89879: ARRAY
89880: PPUSH
89881: LD_VAR 0 1
89885: PUSH
89886: LD_INT 2
89888: ARRAY
89889: PPUSH
89890: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89894: LD_VAR 0 1
89898: PUSH
89899: LD_INT 1
89901: ARRAY
89902: PPUSH
89903: LD_VAR 0 1
89907: PUSH
89908: LD_INT 2
89910: ARRAY
89911: PPUSH
89912: CALL_OW 429
// end ; end ;
89916: LD_VAR 0 1
89920: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89921: LD_EXP 122
89925: PUSH
89926: LD_EXP 144
89930: AND
89931: IFFALSE 89943
89933: GO 89935
89935: DISABLE
// YouLost (  ) ;
89936: LD_STRING 
89938: PPUSH
89939: CALL_OW 104
89943: END
// every 0 0$1 trigger StreamModeActive and sFog do
89944: LD_EXP 122
89948: PUSH
89949: LD_EXP 143
89953: AND
89954: IFFALSE 89968
89956: GO 89958
89958: DISABLE
// FogOff ( your_side ) ;
89959: LD_OWVAR 2
89963: PPUSH
89964: CALL_OW 344
89968: END
// every 0 0$1 trigger StreamModeActive and sSun do
89969: LD_EXP 122
89973: PUSH
89974: LD_EXP 145
89978: AND
89979: IFFALSE 90007
89981: GO 89983
89983: DISABLE
// begin solar_recharge_percent := 0 ;
89984: LD_ADDR_OWVAR 79
89988: PUSH
89989: LD_INT 0
89991: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89992: LD_INT 10500
89994: PPUSH
89995: CALL_OW 67
// solar_recharge_percent := 100 ;
89999: LD_ADDR_OWVAR 79
90003: PUSH
90004: LD_INT 100
90006: ST_TO_ADDR
// end ;
90007: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
90008: LD_EXP 122
90012: PUSH
90013: LD_EXP 146
90017: AND
90018: IFFALSE 90257
90020: GO 90022
90022: DISABLE
90023: LD_INT 0
90025: PPUSH
90026: PPUSH
90027: PPUSH
// begin tmp := [ ] ;
90028: LD_ADDR_VAR 0 3
90032: PUSH
90033: EMPTY
90034: ST_TO_ADDR
// for i := 1 to 6 do
90035: LD_ADDR_VAR 0 1
90039: PUSH
90040: DOUBLE
90041: LD_INT 1
90043: DEC
90044: ST_TO_ADDR
90045: LD_INT 6
90047: PUSH
90048: FOR_TO
90049: IFFALSE 90154
// begin uc_nation := nation_nature ;
90051: LD_ADDR_OWVAR 21
90055: PUSH
90056: LD_INT 0
90058: ST_TO_ADDR
// uc_side := 0 ;
90059: LD_ADDR_OWVAR 20
90063: PUSH
90064: LD_INT 0
90066: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90067: LD_ADDR_OWVAR 29
90071: PUSH
90072: LD_INT 12
90074: PUSH
90075: LD_INT 12
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: ST_TO_ADDR
// hc_agressivity := 20 ;
90082: LD_ADDR_OWVAR 35
90086: PUSH
90087: LD_INT 20
90089: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90090: LD_ADDR_OWVAR 28
90094: PUSH
90095: LD_INT 17
90097: ST_TO_ADDR
// hc_gallery :=  ;
90098: LD_ADDR_OWVAR 33
90102: PUSH
90103: LD_STRING 
90105: ST_TO_ADDR
// hc_name :=  ;
90106: LD_ADDR_OWVAR 26
90110: PUSH
90111: LD_STRING 
90113: ST_TO_ADDR
// un := CreateHuman ;
90114: LD_ADDR_VAR 0 2
90118: PUSH
90119: CALL_OW 44
90123: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90124: LD_VAR 0 2
90128: PPUSH
90129: LD_INT 1
90131: PPUSH
90132: CALL_OW 51
// tmp := tmp ^ un ;
90136: LD_ADDR_VAR 0 3
90140: PUSH
90141: LD_VAR 0 3
90145: PUSH
90146: LD_VAR 0 2
90150: ADD
90151: ST_TO_ADDR
// end ;
90152: GO 90048
90154: POP
90155: POP
// repeat wait ( 0 0$1 ) ;
90156: LD_INT 35
90158: PPUSH
90159: CALL_OW 67
// for un in tmp do
90163: LD_ADDR_VAR 0 2
90167: PUSH
90168: LD_VAR 0 3
90172: PUSH
90173: FOR_IN
90174: IFFALSE 90248
// begin if IsDead ( un ) then
90176: LD_VAR 0 2
90180: PPUSH
90181: CALL_OW 301
90185: IFFALSE 90205
// begin tmp := tmp diff un ;
90187: LD_ADDR_VAR 0 3
90191: PUSH
90192: LD_VAR 0 3
90196: PUSH
90197: LD_VAR 0 2
90201: DIFF
90202: ST_TO_ADDR
// continue ;
90203: GO 90173
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90205: LD_VAR 0 2
90209: PPUSH
90210: LD_INT 3
90212: PUSH
90213: LD_INT 22
90215: PUSH
90216: LD_INT 0
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PPUSH
90227: CALL_OW 69
90231: PPUSH
90232: LD_VAR 0 2
90236: PPUSH
90237: CALL_OW 74
90241: PPUSH
90242: CALL_OW 115
// end ;
90246: GO 90173
90248: POP
90249: POP
// until not tmp ;
90250: LD_VAR 0 3
90254: NOT
90255: IFFALSE 90156
// end ;
90257: PPOPN 3
90259: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90260: LD_EXP 122
90264: PUSH
90265: LD_EXP 147
90269: AND
90270: IFFALSE 90324
90272: GO 90274
90274: DISABLE
// begin ToLua ( displayTroll(); ) ;
90275: LD_STRING displayTroll();
90277: PPUSH
90278: CALL_OW 559
// wait ( 3 3$00 ) ;
90282: LD_INT 6300
90284: PPUSH
90285: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90289: LD_STRING hideTroll();
90291: PPUSH
90292: CALL_OW 559
// wait ( 1 1$00 ) ;
90296: LD_INT 2100
90298: PPUSH
90299: CALL_OW 67
// ToLua ( displayTroll(); ) ;
90303: LD_STRING displayTroll();
90305: PPUSH
90306: CALL_OW 559
// wait ( 1 1$00 ) ;
90310: LD_INT 2100
90312: PPUSH
90313: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90317: LD_STRING hideTroll();
90319: PPUSH
90320: CALL_OW 559
// end ;
90324: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
90325: LD_EXP 122
90329: PUSH
90330: LD_EXP 148
90334: AND
90335: IFFALSE 90398
90337: GO 90339
90339: DISABLE
90340: LD_INT 0
90342: PPUSH
// begin p := 0 ;
90343: LD_ADDR_VAR 0 1
90347: PUSH
90348: LD_INT 0
90350: ST_TO_ADDR
// repeat game_speed := 1 ;
90351: LD_ADDR_OWVAR 65
90355: PUSH
90356: LD_INT 1
90358: ST_TO_ADDR
// wait ( 0 0$1 ) ;
90359: LD_INT 35
90361: PPUSH
90362: CALL_OW 67
// p := p + 1 ;
90366: LD_ADDR_VAR 0 1
90370: PUSH
90371: LD_VAR 0 1
90375: PUSH
90376: LD_INT 1
90378: PLUS
90379: ST_TO_ADDR
// until p >= 60 ;
90380: LD_VAR 0 1
90384: PUSH
90385: LD_INT 60
90387: GREATEREQUAL
90388: IFFALSE 90351
// game_speed := 4 ;
90390: LD_ADDR_OWVAR 65
90394: PUSH
90395: LD_INT 4
90397: ST_TO_ADDR
// end ;
90398: PPOPN 1
90400: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90401: LD_EXP 122
90405: PUSH
90406: LD_EXP 149
90410: AND
90411: IFFALSE 90557
90413: GO 90415
90415: DISABLE
90416: LD_INT 0
90418: PPUSH
90419: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90420: LD_ADDR_VAR 0 1
90424: PUSH
90425: LD_INT 22
90427: PUSH
90428: LD_OWVAR 2
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 2
90439: PUSH
90440: LD_INT 30
90442: PUSH
90443: LD_INT 0
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: PUSH
90450: LD_INT 30
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: LIST
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PPUSH
90469: CALL_OW 69
90473: ST_TO_ADDR
// if not depot then
90474: LD_VAR 0 1
90478: NOT
90479: IFFALSE 90483
// exit ;
90481: GO 90557
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90483: LD_ADDR_VAR 0 2
90487: PUSH
90488: LD_VAR 0 1
90492: PUSH
90493: LD_INT 1
90495: PPUSH
90496: LD_VAR 0 1
90500: PPUSH
90501: CALL_OW 12
90505: ARRAY
90506: PPUSH
90507: CALL_OW 274
90511: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90512: LD_VAR 0 2
90516: PPUSH
90517: LD_INT 1
90519: PPUSH
90520: LD_INT 0
90522: PPUSH
90523: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90527: LD_VAR 0 2
90531: PPUSH
90532: LD_INT 2
90534: PPUSH
90535: LD_INT 0
90537: PPUSH
90538: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90542: LD_VAR 0 2
90546: PPUSH
90547: LD_INT 3
90549: PPUSH
90550: LD_INT 0
90552: PPUSH
90553: CALL_OW 277
// end ;
90557: PPOPN 2
90559: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90560: LD_EXP 122
90564: PUSH
90565: LD_EXP 150
90569: AND
90570: IFFALSE 90667
90572: GO 90574
90574: DISABLE
90575: LD_INT 0
90577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90578: LD_ADDR_VAR 0 1
90582: PUSH
90583: LD_INT 22
90585: PUSH
90586: LD_OWVAR 2
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 21
90597: PUSH
90598: LD_INT 1
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 3
90607: PUSH
90608: LD_INT 23
90610: PUSH
90611: LD_INT 0
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: LIST
90626: PPUSH
90627: CALL_OW 69
90631: ST_TO_ADDR
// if not tmp then
90632: LD_VAR 0 1
90636: NOT
90637: IFFALSE 90641
// exit ;
90639: GO 90667
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90641: LD_VAR 0 1
90645: PUSH
90646: LD_INT 1
90648: PPUSH
90649: LD_VAR 0 1
90653: PPUSH
90654: CALL_OW 12
90658: ARRAY
90659: PPUSH
90660: LD_INT 200
90662: PPUSH
90663: CALL_OW 234
// end ;
90667: PPOPN 1
90669: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90670: LD_EXP 122
90674: PUSH
90675: LD_EXP 151
90679: AND
90680: IFFALSE 90759
90682: GO 90684
90684: DISABLE
90685: LD_INT 0
90687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90688: LD_ADDR_VAR 0 1
90692: PUSH
90693: LD_INT 22
90695: PUSH
90696: LD_OWVAR 2
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 21
90707: PUSH
90708: LD_INT 2
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PPUSH
90719: CALL_OW 69
90723: ST_TO_ADDR
// if not tmp then
90724: LD_VAR 0 1
90728: NOT
90729: IFFALSE 90733
// exit ;
90731: GO 90759
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90733: LD_VAR 0 1
90737: PUSH
90738: LD_INT 1
90740: PPUSH
90741: LD_VAR 0 1
90745: PPUSH
90746: CALL_OW 12
90750: ARRAY
90751: PPUSH
90752: LD_INT 60
90754: PPUSH
90755: CALL_OW 234
// end ;
90759: PPOPN 1
90761: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90762: LD_EXP 122
90766: PUSH
90767: LD_EXP 152
90771: AND
90772: IFFALSE 90871
90774: GO 90776
90776: DISABLE
90777: LD_INT 0
90779: PPUSH
90780: PPUSH
// begin enable ;
90781: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90782: LD_ADDR_VAR 0 1
90786: PUSH
90787: LD_INT 22
90789: PUSH
90790: LD_OWVAR 2
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 61
90801: PUSH
90802: EMPTY
90803: LIST
90804: PUSH
90805: LD_INT 33
90807: PUSH
90808: LD_INT 2
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: LIST
90819: PPUSH
90820: CALL_OW 69
90824: ST_TO_ADDR
// if not tmp then
90825: LD_VAR 0 1
90829: NOT
90830: IFFALSE 90834
// exit ;
90832: GO 90871
// for i in tmp do
90834: LD_ADDR_VAR 0 2
90838: PUSH
90839: LD_VAR 0 1
90843: PUSH
90844: FOR_IN
90845: IFFALSE 90869
// if IsControledBy ( i ) then
90847: LD_VAR 0 2
90851: PPUSH
90852: CALL_OW 312
90856: IFFALSE 90867
// ComUnlink ( i ) ;
90858: LD_VAR 0 2
90862: PPUSH
90863: CALL_OW 136
90867: GO 90844
90869: POP
90870: POP
// end ;
90871: PPOPN 2
90873: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90874: LD_EXP 122
90878: PUSH
90879: LD_EXP 153
90883: AND
90884: IFFALSE 91024
90886: GO 90888
90888: DISABLE
90889: LD_INT 0
90891: PPUSH
90892: PPUSH
// begin ToLua ( displayPowell(); ) ;
90893: LD_STRING displayPowell();
90895: PPUSH
90896: CALL_OW 559
// uc_side := 0 ;
90900: LD_ADDR_OWVAR 20
90904: PUSH
90905: LD_INT 0
90907: ST_TO_ADDR
// uc_nation := 2 ;
90908: LD_ADDR_OWVAR 21
90912: PUSH
90913: LD_INT 2
90915: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90916: LD_ADDR_OWVAR 37
90920: PUSH
90921: LD_INT 14
90923: ST_TO_ADDR
// vc_engine := engine_siberite ;
90924: LD_ADDR_OWVAR 39
90928: PUSH
90929: LD_INT 3
90931: ST_TO_ADDR
// vc_control := control_apeman ;
90932: LD_ADDR_OWVAR 38
90936: PUSH
90937: LD_INT 5
90939: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90940: LD_ADDR_OWVAR 40
90944: PUSH
90945: LD_INT 29
90947: ST_TO_ADDR
// un := CreateVehicle ;
90948: LD_ADDR_VAR 0 2
90952: PUSH
90953: CALL_OW 45
90957: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90958: LD_VAR 0 2
90962: PPUSH
90963: LD_INT 1
90965: PPUSH
90966: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90970: LD_INT 35
90972: PPUSH
90973: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90977: LD_VAR 0 2
90981: PPUSH
90982: LD_INT 22
90984: PUSH
90985: LD_OWVAR 2
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PPUSH
90994: CALL_OW 69
90998: PPUSH
90999: LD_VAR 0 2
91003: PPUSH
91004: CALL_OW 74
91008: PPUSH
91009: CALL_OW 115
// until IsDead ( un ) ;
91013: LD_VAR 0 2
91017: PPUSH
91018: CALL_OW 301
91022: IFFALSE 90970
// end ;
91024: PPOPN 2
91026: END
// every 0 0$1 trigger StreamModeActive and sStu do
91027: LD_EXP 122
91031: PUSH
91032: LD_EXP 161
91036: AND
91037: IFFALSE 91053
91039: GO 91041
91041: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91042: LD_STRING displayStucuk();
91044: PPUSH
91045: CALL_OW 559
// ResetFog ;
91049: CALL_OW 335
// end ;
91053: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91054: LD_EXP 122
91058: PUSH
91059: LD_EXP 154
91063: AND
91064: IFFALSE 91205
91066: GO 91068
91068: DISABLE
91069: LD_INT 0
91071: PPUSH
91072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91073: LD_ADDR_VAR 0 2
91077: PUSH
91078: LD_INT 22
91080: PUSH
91081: LD_OWVAR 2
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 21
91092: PUSH
91093: LD_INT 1
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PPUSH
91104: CALL_OW 69
91108: ST_TO_ADDR
// if not tmp then
91109: LD_VAR 0 2
91113: NOT
91114: IFFALSE 91118
// exit ;
91116: GO 91205
// un := tmp [ rand ( 1 , tmp ) ] ;
91118: LD_ADDR_VAR 0 1
91122: PUSH
91123: LD_VAR 0 2
91127: PUSH
91128: LD_INT 1
91130: PPUSH
91131: LD_VAR 0 2
91135: PPUSH
91136: CALL_OW 12
91140: ARRAY
91141: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91142: LD_VAR 0 1
91146: PPUSH
91147: LD_INT 0
91149: PPUSH
91150: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91154: LD_VAR 0 1
91158: PPUSH
91159: LD_OWVAR 3
91163: PUSH
91164: LD_VAR 0 1
91168: DIFF
91169: PPUSH
91170: LD_VAR 0 1
91174: PPUSH
91175: CALL_OW 74
91179: PPUSH
91180: CALL_OW 115
// wait ( 0 0$20 ) ;
91184: LD_INT 700
91186: PPUSH
91187: CALL_OW 67
// SetSide ( un , your_side ) ;
91191: LD_VAR 0 1
91195: PPUSH
91196: LD_OWVAR 2
91200: PPUSH
91201: CALL_OW 235
// end ;
91205: PPOPN 2
91207: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91208: LD_EXP 122
91212: PUSH
91213: LD_EXP 155
91217: AND
91218: IFFALSE 91324
91220: GO 91222
91222: DISABLE
91223: LD_INT 0
91225: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91226: LD_ADDR_VAR 0 1
91230: PUSH
91231: LD_INT 22
91233: PUSH
91234: LD_OWVAR 2
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 2
91245: PUSH
91246: LD_INT 30
91248: PUSH
91249: LD_INT 0
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 30
91258: PUSH
91259: LD_INT 1
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: LIST
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PPUSH
91275: CALL_OW 69
91279: ST_TO_ADDR
// if not depot then
91280: LD_VAR 0 1
91284: NOT
91285: IFFALSE 91289
// exit ;
91287: GO 91324
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
91289: LD_VAR 0 1
91293: PUSH
91294: LD_INT 1
91296: ARRAY
91297: PPUSH
91298: CALL_OW 250
91302: PPUSH
91303: LD_VAR 0 1
91307: PUSH
91308: LD_INT 1
91310: ARRAY
91311: PPUSH
91312: CALL_OW 251
91316: PPUSH
91317: LD_INT 70
91319: PPUSH
91320: CALL_OW 495
// end ;
91324: PPOPN 1
91326: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
91327: LD_EXP 122
91331: PUSH
91332: LD_EXP 156
91336: AND
91337: IFFALSE 91548
91339: GO 91341
91341: DISABLE
91342: LD_INT 0
91344: PPUSH
91345: PPUSH
91346: PPUSH
91347: PPUSH
91348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91349: LD_ADDR_VAR 0 5
91353: PUSH
91354: LD_INT 22
91356: PUSH
91357: LD_OWVAR 2
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 21
91368: PUSH
91369: LD_INT 1
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: PPUSH
91380: CALL_OW 69
91384: ST_TO_ADDR
// if not tmp then
91385: LD_VAR 0 5
91389: NOT
91390: IFFALSE 91394
// exit ;
91392: GO 91548
// for i in tmp do
91394: LD_ADDR_VAR 0 1
91398: PUSH
91399: LD_VAR 0 5
91403: PUSH
91404: FOR_IN
91405: IFFALSE 91546
// begin d := rand ( 0 , 5 ) ;
91407: LD_ADDR_VAR 0 4
91411: PUSH
91412: LD_INT 0
91414: PPUSH
91415: LD_INT 5
91417: PPUSH
91418: CALL_OW 12
91422: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91423: LD_ADDR_VAR 0 2
91427: PUSH
91428: LD_VAR 0 1
91432: PPUSH
91433: CALL_OW 250
91437: PPUSH
91438: LD_VAR 0 4
91442: PPUSH
91443: LD_INT 3
91445: PPUSH
91446: LD_INT 12
91448: PPUSH
91449: CALL_OW 12
91453: PPUSH
91454: CALL_OW 272
91458: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91459: LD_ADDR_VAR 0 3
91463: PUSH
91464: LD_VAR 0 1
91468: PPUSH
91469: CALL_OW 251
91473: PPUSH
91474: LD_VAR 0 4
91478: PPUSH
91479: LD_INT 3
91481: PPUSH
91482: LD_INT 12
91484: PPUSH
91485: CALL_OW 12
91489: PPUSH
91490: CALL_OW 273
91494: ST_TO_ADDR
// if ValidHex ( x , y ) then
91495: LD_VAR 0 2
91499: PPUSH
91500: LD_VAR 0 3
91504: PPUSH
91505: CALL_OW 488
91509: IFFALSE 91544
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91511: LD_VAR 0 1
91515: PPUSH
91516: LD_VAR 0 2
91520: PPUSH
91521: LD_VAR 0 3
91525: PPUSH
91526: LD_INT 3
91528: PPUSH
91529: LD_INT 6
91531: PPUSH
91532: CALL_OW 12
91536: PPUSH
91537: LD_INT 1
91539: PPUSH
91540: CALL_OW 483
// end ;
91544: GO 91404
91546: POP
91547: POP
// end ;
91548: PPOPN 5
91550: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91551: LD_EXP 122
91555: PUSH
91556: LD_EXP 157
91560: AND
91561: IFFALSE 91655
91563: GO 91565
91565: DISABLE
91566: LD_INT 0
91568: PPUSH
91569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91570: LD_ADDR_VAR 0 2
91574: PUSH
91575: LD_INT 22
91577: PUSH
91578: LD_OWVAR 2
91582: PUSH
91583: EMPTY
91584: LIST
91585: LIST
91586: PUSH
91587: LD_INT 32
91589: PUSH
91590: LD_INT 1
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PUSH
91597: LD_INT 21
91599: PUSH
91600: LD_INT 2
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: LIST
91611: PPUSH
91612: CALL_OW 69
91616: ST_TO_ADDR
// if not tmp then
91617: LD_VAR 0 2
91621: NOT
91622: IFFALSE 91626
// exit ;
91624: GO 91655
// for i in tmp do
91626: LD_ADDR_VAR 0 1
91630: PUSH
91631: LD_VAR 0 2
91635: PUSH
91636: FOR_IN
91637: IFFALSE 91653
// SetFuel ( i , 0 ) ;
91639: LD_VAR 0 1
91643: PPUSH
91644: LD_INT 0
91646: PPUSH
91647: CALL_OW 240
91651: GO 91636
91653: POP
91654: POP
// end ;
91655: PPOPN 2
91657: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91658: LD_EXP 122
91662: PUSH
91663: LD_EXP 158
91667: AND
91668: IFFALSE 91734
91670: GO 91672
91672: DISABLE
91673: LD_INT 0
91675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91676: LD_ADDR_VAR 0 1
91680: PUSH
91681: LD_INT 22
91683: PUSH
91684: LD_OWVAR 2
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 30
91695: PUSH
91696: LD_INT 29
91698: PUSH
91699: EMPTY
91700: LIST
91701: LIST
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: PPUSH
91707: CALL_OW 69
91711: ST_TO_ADDR
// if not tmp then
91712: LD_VAR 0 1
91716: NOT
91717: IFFALSE 91721
// exit ;
91719: GO 91734
// DestroyUnit ( tmp [ 1 ] ) ;
91721: LD_VAR 0 1
91725: PUSH
91726: LD_INT 1
91728: ARRAY
91729: PPUSH
91730: CALL_OW 65
// end ;
91734: PPOPN 1
91736: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91737: LD_EXP 122
91741: PUSH
91742: LD_EXP 160
91746: AND
91747: IFFALSE 91876
91749: GO 91751
91751: DISABLE
91752: LD_INT 0
91754: PPUSH
// begin uc_side := 0 ;
91755: LD_ADDR_OWVAR 20
91759: PUSH
91760: LD_INT 0
91762: ST_TO_ADDR
// uc_nation := nation_arabian ;
91763: LD_ADDR_OWVAR 21
91767: PUSH
91768: LD_INT 2
91770: ST_TO_ADDR
// hc_gallery :=  ;
91771: LD_ADDR_OWVAR 33
91775: PUSH
91776: LD_STRING 
91778: ST_TO_ADDR
// hc_name :=  ;
91779: LD_ADDR_OWVAR 26
91783: PUSH
91784: LD_STRING 
91786: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91787: LD_INT 1
91789: PPUSH
91790: LD_INT 11
91792: PPUSH
91793: LD_INT 10
91795: PPUSH
91796: CALL_OW 380
// un := CreateHuman ;
91800: LD_ADDR_VAR 0 1
91804: PUSH
91805: CALL_OW 44
91809: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91810: LD_VAR 0 1
91814: PPUSH
91815: LD_INT 1
91817: PPUSH
91818: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91822: LD_INT 35
91824: PPUSH
91825: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91829: LD_VAR 0 1
91833: PPUSH
91834: LD_INT 22
91836: PUSH
91837: LD_OWVAR 2
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PPUSH
91846: CALL_OW 69
91850: PPUSH
91851: LD_VAR 0 1
91855: PPUSH
91856: CALL_OW 74
91860: PPUSH
91861: CALL_OW 115
// until IsDead ( un ) ;
91865: LD_VAR 0 1
91869: PPUSH
91870: CALL_OW 301
91874: IFFALSE 91822
// end ;
91876: PPOPN 1
91878: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91879: LD_EXP 122
91883: PUSH
91884: LD_EXP 162
91888: AND
91889: IFFALSE 91901
91891: GO 91893
91893: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91894: LD_STRING earthquake(getX(game), 0, 32)
91896: PPUSH
91897: CALL_OW 559
91901: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91902: LD_EXP 122
91906: PUSH
91907: LD_EXP 163
91911: AND
91912: IFFALSE 92003
91914: GO 91916
91916: DISABLE
91917: LD_INT 0
91919: PPUSH
// begin enable ;
91920: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91921: LD_ADDR_VAR 0 1
91925: PUSH
91926: LD_INT 22
91928: PUSH
91929: LD_OWVAR 2
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 21
91940: PUSH
91941: LD_INT 2
91943: PUSH
91944: EMPTY
91945: LIST
91946: LIST
91947: PUSH
91948: LD_INT 33
91950: PUSH
91951: LD_INT 3
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: LIST
91962: PPUSH
91963: CALL_OW 69
91967: ST_TO_ADDR
// if not tmp then
91968: LD_VAR 0 1
91972: NOT
91973: IFFALSE 91977
// exit ;
91975: GO 92003
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91977: LD_VAR 0 1
91981: PUSH
91982: LD_INT 1
91984: PPUSH
91985: LD_VAR 0 1
91989: PPUSH
91990: CALL_OW 12
91994: ARRAY
91995: PPUSH
91996: LD_INT 1
91998: PPUSH
91999: CALL_OW 234
// end ;
92003: PPOPN 1
92005: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
92006: LD_EXP 122
92010: PUSH
92011: LD_EXP 164
92015: AND
92016: IFFALSE 92157
92018: GO 92020
92020: DISABLE
92021: LD_INT 0
92023: PPUSH
92024: PPUSH
92025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92026: LD_ADDR_VAR 0 3
92030: PUSH
92031: LD_INT 22
92033: PUSH
92034: LD_OWVAR 2
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 25
92045: PUSH
92046: LD_INT 1
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PPUSH
92057: CALL_OW 69
92061: ST_TO_ADDR
// if not tmp then
92062: LD_VAR 0 3
92066: NOT
92067: IFFALSE 92071
// exit ;
92069: GO 92157
// un := tmp [ rand ( 1 , tmp ) ] ;
92071: LD_ADDR_VAR 0 2
92075: PUSH
92076: LD_VAR 0 3
92080: PUSH
92081: LD_INT 1
92083: PPUSH
92084: LD_VAR 0 3
92088: PPUSH
92089: CALL_OW 12
92093: ARRAY
92094: ST_TO_ADDR
// if Crawls ( un ) then
92095: LD_VAR 0 2
92099: PPUSH
92100: CALL_OW 318
92104: IFFALSE 92115
// ComWalk ( un ) ;
92106: LD_VAR 0 2
92110: PPUSH
92111: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92115: LD_VAR 0 2
92119: PPUSH
92120: LD_INT 9
92122: PPUSH
92123: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92127: LD_INT 28
92129: PPUSH
92130: LD_OWVAR 2
92134: PPUSH
92135: LD_INT 2
92137: PPUSH
92138: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92142: LD_INT 29
92144: PPUSH
92145: LD_OWVAR 2
92149: PPUSH
92150: LD_INT 2
92152: PPUSH
92153: CALL_OW 322
// end ;
92157: PPOPN 3
92159: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92160: LD_EXP 122
92164: PUSH
92165: LD_EXP 165
92169: AND
92170: IFFALSE 92281
92172: GO 92174
92174: DISABLE
92175: LD_INT 0
92177: PPUSH
92178: PPUSH
92179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92180: LD_ADDR_VAR 0 3
92184: PUSH
92185: LD_INT 22
92187: PUSH
92188: LD_OWVAR 2
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 25
92199: PUSH
92200: LD_INT 1
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PPUSH
92211: CALL_OW 69
92215: ST_TO_ADDR
// if not tmp then
92216: LD_VAR 0 3
92220: NOT
92221: IFFALSE 92225
// exit ;
92223: GO 92281
// un := tmp [ rand ( 1 , tmp ) ] ;
92225: LD_ADDR_VAR 0 2
92229: PUSH
92230: LD_VAR 0 3
92234: PUSH
92235: LD_INT 1
92237: PPUSH
92238: LD_VAR 0 3
92242: PPUSH
92243: CALL_OW 12
92247: ARRAY
92248: ST_TO_ADDR
// if Crawls ( un ) then
92249: LD_VAR 0 2
92253: PPUSH
92254: CALL_OW 318
92258: IFFALSE 92269
// ComWalk ( un ) ;
92260: LD_VAR 0 2
92264: PPUSH
92265: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92269: LD_VAR 0 2
92273: PPUSH
92274: LD_INT 8
92276: PPUSH
92277: CALL_OW 336
// end ;
92281: PPOPN 3
92283: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
92284: LD_EXP 122
92288: PUSH
92289: LD_EXP 166
92293: AND
92294: IFFALSE 92438
92296: GO 92298
92298: DISABLE
92299: LD_INT 0
92301: PPUSH
92302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
92303: LD_ADDR_VAR 0 2
92307: PUSH
92308: LD_INT 22
92310: PUSH
92311: LD_OWVAR 2
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 21
92322: PUSH
92323: LD_INT 2
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 2
92332: PUSH
92333: LD_INT 34
92335: PUSH
92336: LD_INT 12
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: LD_INT 34
92345: PUSH
92346: LD_INT 51
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 34
92355: PUSH
92356: LD_INT 32
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: LIST
92373: PPUSH
92374: CALL_OW 69
92378: ST_TO_ADDR
// if not tmp then
92379: LD_VAR 0 2
92383: NOT
92384: IFFALSE 92388
// exit ;
92386: GO 92438
// for i in tmp do
92388: LD_ADDR_VAR 0 1
92392: PUSH
92393: LD_VAR 0 2
92397: PUSH
92398: FOR_IN
92399: IFFALSE 92436
// if GetCargo ( i , mat_artifact ) = 0 then
92401: LD_VAR 0 1
92405: PPUSH
92406: LD_INT 4
92408: PPUSH
92409: CALL_OW 289
92413: PUSH
92414: LD_INT 0
92416: EQUAL
92417: IFFALSE 92434
// SetCargo ( i , mat_siberit , 100 ) ;
92419: LD_VAR 0 1
92423: PPUSH
92424: LD_INT 3
92426: PPUSH
92427: LD_INT 100
92429: PPUSH
92430: CALL_OW 290
92434: GO 92398
92436: POP
92437: POP
// end ;
92438: PPOPN 2
92440: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92441: LD_EXP 122
92445: PUSH
92446: LD_EXP 167
92450: AND
92451: IFFALSE 92634
92453: GO 92455
92455: DISABLE
92456: LD_INT 0
92458: PPUSH
92459: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92460: LD_ADDR_VAR 0 2
92464: PUSH
92465: LD_INT 22
92467: PUSH
92468: LD_OWVAR 2
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PPUSH
92477: CALL_OW 69
92481: ST_TO_ADDR
// if not tmp then
92482: LD_VAR 0 2
92486: NOT
92487: IFFALSE 92491
// exit ;
92489: GO 92634
// for i := 1 to 2 do
92491: LD_ADDR_VAR 0 1
92495: PUSH
92496: DOUBLE
92497: LD_INT 1
92499: DEC
92500: ST_TO_ADDR
92501: LD_INT 2
92503: PUSH
92504: FOR_TO
92505: IFFALSE 92632
// begin uc_side := your_side ;
92507: LD_ADDR_OWVAR 20
92511: PUSH
92512: LD_OWVAR 2
92516: ST_TO_ADDR
// uc_nation := nation_american ;
92517: LD_ADDR_OWVAR 21
92521: PUSH
92522: LD_INT 1
92524: ST_TO_ADDR
// vc_chassis := us_morphling ;
92525: LD_ADDR_OWVAR 37
92529: PUSH
92530: LD_INT 5
92532: ST_TO_ADDR
// vc_engine := engine_siberite ;
92533: LD_ADDR_OWVAR 39
92537: PUSH
92538: LD_INT 3
92540: ST_TO_ADDR
// vc_control := control_computer ;
92541: LD_ADDR_OWVAR 38
92545: PUSH
92546: LD_INT 3
92548: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92549: LD_ADDR_OWVAR 40
92553: PUSH
92554: LD_INT 10
92556: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92557: LD_VAR 0 2
92561: PUSH
92562: LD_INT 1
92564: ARRAY
92565: PPUSH
92566: CALL_OW 310
92570: NOT
92571: IFFALSE 92618
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92573: CALL_OW 45
92577: PPUSH
92578: LD_VAR 0 2
92582: PUSH
92583: LD_INT 1
92585: ARRAY
92586: PPUSH
92587: CALL_OW 250
92591: PPUSH
92592: LD_VAR 0 2
92596: PUSH
92597: LD_INT 1
92599: ARRAY
92600: PPUSH
92601: CALL_OW 251
92605: PPUSH
92606: LD_INT 12
92608: PPUSH
92609: LD_INT 1
92611: PPUSH
92612: CALL_OW 50
92616: GO 92630
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92618: CALL_OW 45
92622: PPUSH
92623: LD_INT 1
92625: PPUSH
92626: CALL_OW 51
// end ;
92630: GO 92504
92632: POP
92633: POP
// end ;
92634: PPOPN 2
92636: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92637: LD_EXP 122
92641: PUSH
92642: LD_EXP 168
92646: AND
92647: IFFALSE 92869
92649: GO 92651
92651: DISABLE
92652: LD_INT 0
92654: PPUSH
92655: PPUSH
92656: PPUSH
92657: PPUSH
92658: PPUSH
92659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92660: LD_ADDR_VAR 0 6
92664: PUSH
92665: LD_INT 22
92667: PUSH
92668: LD_OWVAR 2
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 21
92679: PUSH
92680: LD_INT 1
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 3
92689: PUSH
92690: LD_INT 23
92692: PUSH
92693: LD_INT 0
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: LIST
92708: PPUSH
92709: CALL_OW 69
92713: ST_TO_ADDR
// if not tmp then
92714: LD_VAR 0 6
92718: NOT
92719: IFFALSE 92723
// exit ;
92721: GO 92869
// s1 := rand ( 1 , 4 ) ;
92723: LD_ADDR_VAR 0 2
92727: PUSH
92728: LD_INT 1
92730: PPUSH
92731: LD_INT 4
92733: PPUSH
92734: CALL_OW 12
92738: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92739: LD_ADDR_VAR 0 4
92743: PUSH
92744: LD_VAR 0 6
92748: PUSH
92749: LD_INT 1
92751: ARRAY
92752: PPUSH
92753: LD_VAR 0 2
92757: PPUSH
92758: CALL_OW 259
92762: ST_TO_ADDR
// if s1 = 1 then
92763: LD_VAR 0 2
92767: PUSH
92768: LD_INT 1
92770: EQUAL
92771: IFFALSE 92791
// s2 := rand ( 2 , 4 ) else
92773: LD_ADDR_VAR 0 3
92777: PUSH
92778: LD_INT 2
92780: PPUSH
92781: LD_INT 4
92783: PPUSH
92784: CALL_OW 12
92788: ST_TO_ADDR
92789: GO 92799
// s2 := 1 ;
92791: LD_ADDR_VAR 0 3
92795: PUSH
92796: LD_INT 1
92798: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92799: LD_ADDR_VAR 0 5
92803: PUSH
92804: LD_VAR 0 6
92808: PUSH
92809: LD_INT 1
92811: ARRAY
92812: PPUSH
92813: LD_VAR 0 3
92817: PPUSH
92818: CALL_OW 259
92822: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92823: LD_VAR 0 6
92827: PUSH
92828: LD_INT 1
92830: ARRAY
92831: PPUSH
92832: LD_VAR 0 2
92836: PPUSH
92837: LD_VAR 0 5
92841: PPUSH
92842: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92846: LD_VAR 0 6
92850: PUSH
92851: LD_INT 1
92853: ARRAY
92854: PPUSH
92855: LD_VAR 0 3
92859: PPUSH
92860: LD_VAR 0 4
92864: PPUSH
92865: CALL_OW 237
// end ;
92869: PPOPN 6
92871: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92872: LD_EXP 122
92876: PUSH
92877: LD_EXP 169
92881: AND
92882: IFFALSE 92961
92884: GO 92886
92886: DISABLE
92887: LD_INT 0
92889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92890: LD_ADDR_VAR 0 1
92894: PUSH
92895: LD_INT 22
92897: PUSH
92898: LD_OWVAR 2
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 30
92909: PUSH
92910: LD_INT 3
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PPUSH
92921: CALL_OW 69
92925: ST_TO_ADDR
// if not tmp then
92926: LD_VAR 0 1
92930: NOT
92931: IFFALSE 92935
// exit ;
92933: GO 92961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92935: LD_VAR 0 1
92939: PUSH
92940: LD_INT 1
92942: PPUSH
92943: LD_VAR 0 1
92947: PPUSH
92948: CALL_OW 12
92952: ARRAY
92953: PPUSH
92954: LD_INT 1
92956: PPUSH
92957: CALL_OW 234
// end ;
92961: PPOPN 1
92963: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92964: LD_EXP 122
92968: PUSH
92969: LD_EXP 170
92973: AND
92974: IFFALSE 93086
92976: GO 92978
92978: DISABLE
92979: LD_INT 0
92981: PPUSH
92982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92983: LD_ADDR_VAR 0 2
92987: PUSH
92988: LD_INT 22
92990: PUSH
92991: LD_OWVAR 2
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 2
93002: PUSH
93003: LD_INT 30
93005: PUSH
93006: LD_INT 27
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 30
93015: PUSH
93016: LD_INT 26
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 30
93025: PUSH
93026: LD_INT 28
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PPUSH
93043: CALL_OW 69
93047: ST_TO_ADDR
// if not tmp then
93048: LD_VAR 0 2
93052: NOT
93053: IFFALSE 93057
// exit ;
93055: GO 93086
// for i in tmp do
93057: LD_ADDR_VAR 0 1
93061: PUSH
93062: LD_VAR 0 2
93066: PUSH
93067: FOR_IN
93068: IFFALSE 93084
// SetLives ( i , 1 ) ;
93070: LD_VAR 0 1
93074: PPUSH
93075: LD_INT 1
93077: PPUSH
93078: CALL_OW 234
93082: GO 93067
93084: POP
93085: POP
// end ;
93086: PPOPN 2
93088: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93089: LD_EXP 122
93093: PUSH
93094: LD_EXP 171
93098: AND
93099: IFFALSE 93373
93101: GO 93103
93103: DISABLE
93104: LD_INT 0
93106: PPUSH
93107: PPUSH
93108: PPUSH
// begin i := rand ( 1 , 7 ) ;
93109: LD_ADDR_VAR 0 1
93113: PUSH
93114: LD_INT 1
93116: PPUSH
93117: LD_INT 7
93119: PPUSH
93120: CALL_OW 12
93124: ST_TO_ADDR
// case i of 1 :
93125: LD_VAR 0 1
93129: PUSH
93130: LD_INT 1
93132: DOUBLE
93133: EQUAL
93134: IFTRUE 93138
93136: GO 93148
93138: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93139: LD_STRING earthquake(getX(game), 0, 32)
93141: PPUSH
93142: CALL_OW 559
93146: GO 93373
93148: LD_INT 2
93150: DOUBLE
93151: EQUAL
93152: IFTRUE 93156
93154: GO 93170
93156: POP
// begin ToLua ( displayStucuk(); ) ;
93157: LD_STRING displayStucuk();
93159: PPUSH
93160: CALL_OW 559
// ResetFog ;
93164: CALL_OW 335
// end ; 3 :
93168: GO 93373
93170: LD_INT 3
93172: DOUBLE
93173: EQUAL
93174: IFTRUE 93178
93176: GO 93282
93178: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93179: LD_ADDR_VAR 0 2
93183: PUSH
93184: LD_INT 22
93186: PUSH
93187: LD_OWVAR 2
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 25
93198: PUSH
93199: LD_INT 1
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PPUSH
93210: CALL_OW 69
93214: ST_TO_ADDR
// if not tmp then
93215: LD_VAR 0 2
93219: NOT
93220: IFFALSE 93224
// exit ;
93222: GO 93373
// un := tmp [ rand ( 1 , tmp ) ] ;
93224: LD_ADDR_VAR 0 3
93228: PUSH
93229: LD_VAR 0 2
93233: PUSH
93234: LD_INT 1
93236: PPUSH
93237: LD_VAR 0 2
93241: PPUSH
93242: CALL_OW 12
93246: ARRAY
93247: ST_TO_ADDR
// if Crawls ( un ) then
93248: LD_VAR 0 3
93252: PPUSH
93253: CALL_OW 318
93257: IFFALSE 93268
// ComWalk ( un ) ;
93259: LD_VAR 0 3
93263: PPUSH
93264: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93268: LD_VAR 0 3
93272: PPUSH
93273: LD_INT 8
93275: PPUSH
93276: CALL_OW 336
// end ; 4 :
93280: GO 93373
93282: LD_INT 4
93284: DOUBLE
93285: EQUAL
93286: IFTRUE 93290
93288: GO 93351
93290: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93291: LD_ADDR_VAR 0 2
93295: PUSH
93296: LD_INT 22
93298: PUSH
93299: LD_OWVAR 2
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 30
93310: PUSH
93311: LD_INT 29
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PPUSH
93322: CALL_OW 69
93326: ST_TO_ADDR
// if not tmp then
93327: LD_VAR 0 2
93331: NOT
93332: IFFALSE 93336
// exit ;
93334: GO 93373
// DestroyUnit ( tmp [ 1 ] ) ;
93336: LD_VAR 0 2
93340: PUSH
93341: LD_INT 1
93343: ARRAY
93344: PPUSH
93345: CALL_OW 65
// end ; 5 .. 7 :
93349: GO 93373
93351: LD_INT 5
93353: DOUBLE
93354: GREATEREQUAL
93355: IFFALSE 93363
93357: LD_INT 7
93359: DOUBLE
93360: LESSEQUAL
93361: IFTRUE 93365
93363: GO 93372
93365: POP
// StreamSibBomb ; end ;
93366: CALL 89623 0 0
93370: GO 93373
93372: POP
// end ;
93373: PPOPN 3
93375: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
93376: LD_EXP 122
93380: PUSH
93381: LD_EXP 172
93385: AND
93386: IFFALSE 93542
93388: GO 93390
93390: DISABLE
93391: LD_INT 0
93393: PPUSH
93394: PPUSH
93395: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93396: LD_ADDR_VAR 0 2
93400: PUSH
93401: LD_INT 81
93403: PUSH
93404: LD_OWVAR 2
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 2
93415: PUSH
93416: LD_INT 21
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 21
93428: PUSH
93429: LD_INT 2
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: LIST
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PPUSH
93445: CALL_OW 69
93449: ST_TO_ADDR
// if not tmp then
93450: LD_VAR 0 2
93454: NOT
93455: IFFALSE 93459
// exit ;
93457: GO 93542
// p := 0 ;
93459: LD_ADDR_VAR 0 3
93463: PUSH
93464: LD_INT 0
93466: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93467: LD_INT 35
93469: PPUSH
93470: CALL_OW 67
// p := p + 1 ;
93474: LD_ADDR_VAR 0 3
93478: PUSH
93479: LD_VAR 0 3
93483: PUSH
93484: LD_INT 1
93486: PLUS
93487: ST_TO_ADDR
// for i in tmp do
93488: LD_ADDR_VAR 0 1
93492: PUSH
93493: LD_VAR 0 2
93497: PUSH
93498: FOR_IN
93499: IFFALSE 93530
// if GetLives ( i ) < 1000 then
93501: LD_VAR 0 1
93505: PPUSH
93506: CALL_OW 256
93510: PUSH
93511: LD_INT 1000
93513: LESS
93514: IFFALSE 93528
// SetLives ( i , 1000 ) ;
93516: LD_VAR 0 1
93520: PPUSH
93521: LD_INT 1000
93523: PPUSH
93524: CALL_OW 234
93528: GO 93498
93530: POP
93531: POP
// until p > 20 ;
93532: LD_VAR 0 3
93536: PUSH
93537: LD_INT 20
93539: GREATER
93540: IFFALSE 93467
// end ;
93542: PPOPN 3
93544: END
// every 0 0$1 trigger StreamModeActive and sTime do
93545: LD_EXP 122
93549: PUSH
93550: LD_EXP 173
93554: AND
93555: IFFALSE 93590
93557: GO 93559
93559: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93560: LD_INT 28
93562: PPUSH
93563: LD_OWVAR 2
93567: PPUSH
93568: LD_INT 2
93570: PPUSH
93571: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93575: LD_INT 30
93577: PPUSH
93578: LD_OWVAR 2
93582: PPUSH
93583: LD_INT 2
93585: PPUSH
93586: CALL_OW 322
// end ;
93590: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93591: LD_EXP 122
93595: PUSH
93596: LD_EXP 174
93600: AND
93601: IFFALSE 93722
93603: GO 93605
93605: DISABLE
93606: LD_INT 0
93608: PPUSH
93609: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93610: LD_ADDR_VAR 0 2
93614: PUSH
93615: LD_INT 22
93617: PUSH
93618: LD_OWVAR 2
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 21
93629: PUSH
93630: LD_INT 1
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: LD_INT 3
93639: PUSH
93640: LD_INT 23
93642: PUSH
93643: LD_INT 0
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: LIST
93658: PPUSH
93659: CALL_OW 69
93663: ST_TO_ADDR
// if not tmp then
93664: LD_VAR 0 2
93668: NOT
93669: IFFALSE 93673
// exit ;
93671: GO 93722
// for i in tmp do
93673: LD_ADDR_VAR 0 1
93677: PUSH
93678: LD_VAR 0 2
93682: PUSH
93683: FOR_IN
93684: IFFALSE 93720
// begin if Crawls ( i ) then
93686: LD_VAR 0 1
93690: PPUSH
93691: CALL_OW 318
93695: IFFALSE 93706
// ComWalk ( i ) ;
93697: LD_VAR 0 1
93701: PPUSH
93702: CALL_OW 138
// SetClass ( i , 2 ) ;
93706: LD_VAR 0 1
93710: PPUSH
93711: LD_INT 2
93713: PPUSH
93714: CALL_OW 336
// end ;
93718: GO 93683
93720: POP
93721: POP
// end ;
93722: PPOPN 2
93724: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93725: LD_EXP 122
93729: PUSH
93730: LD_EXP 175
93734: AND
93735: IFFALSE 94016
93737: GO 93739
93739: DISABLE
93740: LD_INT 0
93742: PPUSH
93743: PPUSH
93744: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93745: LD_OWVAR 2
93749: PPUSH
93750: LD_INT 9
93752: PPUSH
93753: LD_INT 1
93755: PPUSH
93756: LD_INT 1
93758: PPUSH
93759: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93763: LD_INT 9
93765: PPUSH
93766: LD_OWVAR 2
93770: PPUSH
93771: CALL_OW 343
// uc_side := 9 ;
93775: LD_ADDR_OWVAR 20
93779: PUSH
93780: LD_INT 9
93782: ST_TO_ADDR
// uc_nation := 2 ;
93783: LD_ADDR_OWVAR 21
93787: PUSH
93788: LD_INT 2
93790: ST_TO_ADDR
// hc_name := Dark Warrior ;
93791: LD_ADDR_OWVAR 26
93795: PUSH
93796: LD_STRING Dark Warrior
93798: ST_TO_ADDR
// hc_gallery :=  ;
93799: LD_ADDR_OWVAR 33
93803: PUSH
93804: LD_STRING 
93806: ST_TO_ADDR
// hc_noskilllimit := true ;
93807: LD_ADDR_OWVAR 76
93811: PUSH
93812: LD_INT 1
93814: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93815: LD_ADDR_OWVAR 31
93819: PUSH
93820: LD_INT 30
93822: PUSH
93823: LD_INT 30
93825: PUSH
93826: LD_INT 30
93828: PUSH
93829: LD_INT 30
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: ST_TO_ADDR
// un := CreateHuman ;
93838: LD_ADDR_VAR 0 3
93842: PUSH
93843: CALL_OW 44
93847: ST_TO_ADDR
// hc_noskilllimit := false ;
93848: LD_ADDR_OWVAR 76
93852: PUSH
93853: LD_INT 0
93855: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93856: LD_VAR 0 3
93860: PPUSH
93861: LD_INT 1
93863: PPUSH
93864: CALL_OW 51
// p := 0 ;
93868: LD_ADDR_VAR 0 2
93872: PUSH
93873: LD_INT 0
93875: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93876: LD_INT 35
93878: PPUSH
93879: CALL_OW 67
// p := p + 1 ;
93883: LD_ADDR_VAR 0 2
93887: PUSH
93888: LD_VAR 0 2
93892: PUSH
93893: LD_INT 1
93895: PLUS
93896: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93897: LD_VAR 0 3
93901: PPUSH
93902: CALL_OW 256
93906: PUSH
93907: LD_INT 1000
93909: LESS
93910: IFFALSE 93924
// SetLives ( un , 1000 ) ;
93912: LD_VAR 0 3
93916: PPUSH
93917: LD_INT 1000
93919: PPUSH
93920: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93924: LD_VAR 0 3
93928: PPUSH
93929: LD_INT 81
93931: PUSH
93932: LD_OWVAR 2
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 91
93943: PUSH
93944: LD_VAR 0 3
93948: PUSH
93949: LD_INT 30
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: LIST
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PPUSH
93961: CALL_OW 69
93965: PPUSH
93966: LD_VAR 0 3
93970: PPUSH
93971: CALL_OW 74
93975: PPUSH
93976: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93980: LD_VAR 0 2
93984: PUSH
93985: LD_INT 60
93987: GREATER
93988: PUSH
93989: LD_VAR 0 3
93993: PPUSH
93994: CALL_OW 301
93998: OR
93999: IFFALSE 93876
// if un then
94001: LD_VAR 0 3
94005: IFFALSE 94016
// RemoveUnit ( un ) ;
94007: LD_VAR 0 3
94011: PPUSH
94012: CALL_OW 64
// end ;
94016: PPOPN 3
94018: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94019: LD_INT 0
94021: PPUSH
// case cmd of 301 :
94022: LD_VAR 0 1
94026: PUSH
94027: LD_INT 301
94029: DOUBLE
94030: EQUAL
94031: IFTRUE 94035
94033: GO 94067
94035: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
94036: LD_VAR 0 6
94040: PPUSH
94041: LD_VAR 0 7
94045: PPUSH
94046: LD_VAR 0 8
94050: PPUSH
94051: LD_VAR 0 4
94055: PPUSH
94056: LD_VAR 0 5
94060: PPUSH
94061: CALL 95268 0 5
94065: GO 94188
94067: LD_INT 302
94069: DOUBLE
94070: EQUAL
94071: IFTRUE 94075
94073: GO 94112
94075: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
94076: LD_VAR 0 6
94080: PPUSH
94081: LD_VAR 0 7
94085: PPUSH
94086: LD_VAR 0 8
94090: PPUSH
94091: LD_VAR 0 9
94095: PPUSH
94096: LD_VAR 0 4
94100: PPUSH
94101: LD_VAR 0 5
94105: PPUSH
94106: CALL 95359 0 6
94110: GO 94188
94112: LD_INT 303
94114: DOUBLE
94115: EQUAL
94116: IFTRUE 94120
94118: GO 94157
94120: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
94121: LD_VAR 0 6
94125: PPUSH
94126: LD_VAR 0 7
94130: PPUSH
94131: LD_VAR 0 8
94135: PPUSH
94136: LD_VAR 0 9
94140: PPUSH
94141: LD_VAR 0 4
94145: PPUSH
94146: LD_VAR 0 5
94150: PPUSH
94151: CALL 94193 0 6
94155: GO 94188
94157: LD_INT 304
94159: DOUBLE
94160: EQUAL
94161: IFTRUE 94165
94163: GO 94187
94165: POP
// hHackTeleport ( unit , x , y ) ; end ;
94166: LD_VAR 0 2
94170: PPUSH
94171: LD_VAR 0 4
94175: PPUSH
94176: LD_VAR 0 5
94180: PPUSH
94181: CALL 95952 0 3
94185: GO 94188
94187: POP
// end ;
94188: LD_VAR 0 12
94192: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
94193: LD_INT 0
94195: PPUSH
94196: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
94197: LD_VAR 0 1
94201: PUSH
94202: LD_INT 1
94204: LESS
94205: PUSH
94206: LD_VAR 0 1
94210: PUSH
94211: LD_INT 3
94213: GREATER
94214: OR
94215: PUSH
94216: LD_VAR 0 5
94220: PPUSH
94221: LD_VAR 0 6
94225: PPUSH
94226: CALL_OW 428
94230: OR
94231: IFFALSE 94235
// exit ;
94233: GO 94955
// uc_side := your_side ;
94235: LD_ADDR_OWVAR 20
94239: PUSH
94240: LD_OWVAR 2
94244: ST_TO_ADDR
// uc_nation := nation ;
94245: LD_ADDR_OWVAR 21
94249: PUSH
94250: LD_VAR 0 1
94254: ST_TO_ADDR
// bc_level = 1 ;
94255: LD_ADDR_OWVAR 43
94259: PUSH
94260: LD_INT 1
94262: ST_TO_ADDR
// case btype of 1 :
94263: LD_VAR 0 2
94267: PUSH
94268: LD_INT 1
94270: DOUBLE
94271: EQUAL
94272: IFTRUE 94276
94274: GO 94287
94276: POP
// bc_type := b_depot ; 2 :
94277: LD_ADDR_OWVAR 42
94281: PUSH
94282: LD_INT 0
94284: ST_TO_ADDR
94285: GO 94899
94287: LD_INT 2
94289: DOUBLE
94290: EQUAL
94291: IFTRUE 94295
94293: GO 94306
94295: POP
// bc_type := b_warehouse ; 3 :
94296: LD_ADDR_OWVAR 42
94300: PUSH
94301: LD_INT 1
94303: ST_TO_ADDR
94304: GO 94899
94306: LD_INT 3
94308: DOUBLE
94309: EQUAL
94310: IFTRUE 94314
94312: GO 94325
94314: POP
// bc_type := b_lab ; 4 .. 9 :
94315: LD_ADDR_OWVAR 42
94319: PUSH
94320: LD_INT 6
94322: ST_TO_ADDR
94323: GO 94899
94325: LD_INT 4
94327: DOUBLE
94328: GREATEREQUAL
94329: IFFALSE 94337
94331: LD_INT 9
94333: DOUBLE
94334: LESSEQUAL
94335: IFTRUE 94339
94337: GO 94391
94339: POP
// begin bc_type := b_lab_half ;
94340: LD_ADDR_OWVAR 42
94344: PUSH
94345: LD_INT 7
94347: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
94348: LD_ADDR_OWVAR 44
94352: PUSH
94353: LD_INT 10
94355: PUSH
94356: LD_INT 11
94358: PUSH
94359: LD_INT 12
94361: PUSH
94362: LD_INT 15
94364: PUSH
94365: LD_INT 14
94367: PUSH
94368: LD_INT 13
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: PUSH
94379: LD_VAR 0 2
94383: PUSH
94384: LD_INT 3
94386: MINUS
94387: ARRAY
94388: ST_TO_ADDR
// end ; 10 .. 13 :
94389: GO 94899
94391: LD_INT 10
94393: DOUBLE
94394: GREATEREQUAL
94395: IFFALSE 94403
94397: LD_INT 13
94399: DOUBLE
94400: LESSEQUAL
94401: IFTRUE 94405
94403: GO 94482
94405: POP
// begin bc_type := b_lab_full ;
94406: LD_ADDR_OWVAR 42
94410: PUSH
94411: LD_INT 8
94413: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94414: LD_ADDR_OWVAR 44
94418: PUSH
94419: LD_INT 10
94421: PUSH
94422: LD_INT 12
94424: PUSH
94425: LD_INT 14
94427: PUSH
94428: LD_INT 13
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: PUSH
94437: LD_VAR 0 2
94441: PUSH
94442: LD_INT 9
94444: MINUS
94445: ARRAY
94446: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94447: LD_ADDR_OWVAR 45
94451: PUSH
94452: LD_INT 11
94454: PUSH
94455: LD_INT 15
94457: PUSH
94458: LD_INT 12
94460: PUSH
94461: LD_INT 15
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: PUSH
94470: LD_VAR 0 2
94474: PUSH
94475: LD_INT 9
94477: MINUS
94478: ARRAY
94479: ST_TO_ADDR
// end ; 14 :
94480: GO 94899
94482: LD_INT 14
94484: DOUBLE
94485: EQUAL
94486: IFTRUE 94490
94488: GO 94501
94490: POP
// bc_type := b_workshop ; 15 :
94491: LD_ADDR_OWVAR 42
94495: PUSH
94496: LD_INT 2
94498: ST_TO_ADDR
94499: GO 94899
94501: LD_INT 15
94503: DOUBLE
94504: EQUAL
94505: IFTRUE 94509
94507: GO 94520
94509: POP
// bc_type := b_factory ; 16 :
94510: LD_ADDR_OWVAR 42
94514: PUSH
94515: LD_INT 3
94517: ST_TO_ADDR
94518: GO 94899
94520: LD_INT 16
94522: DOUBLE
94523: EQUAL
94524: IFTRUE 94528
94526: GO 94539
94528: POP
// bc_type := b_ext_gun ; 17 :
94529: LD_ADDR_OWVAR 42
94533: PUSH
94534: LD_INT 17
94536: ST_TO_ADDR
94537: GO 94899
94539: LD_INT 17
94541: DOUBLE
94542: EQUAL
94543: IFTRUE 94547
94545: GO 94575
94547: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94548: LD_ADDR_OWVAR 42
94552: PUSH
94553: LD_INT 19
94555: PUSH
94556: LD_INT 23
94558: PUSH
94559: LD_INT 19
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: LIST
94566: PUSH
94567: LD_VAR 0 1
94571: ARRAY
94572: ST_TO_ADDR
94573: GO 94899
94575: LD_INT 18
94577: DOUBLE
94578: EQUAL
94579: IFTRUE 94583
94581: GO 94594
94583: POP
// bc_type := b_ext_radar ; 19 :
94584: LD_ADDR_OWVAR 42
94588: PUSH
94589: LD_INT 20
94591: ST_TO_ADDR
94592: GO 94899
94594: LD_INT 19
94596: DOUBLE
94597: EQUAL
94598: IFTRUE 94602
94600: GO 94613
94602: POP
// bc_type := b_ext_radio ; 20 :
94603: LD_ADDR_OWVAR 42
94607: PUSH
94608: LD_INT 22
94610: ST_TO_ADDR
94611: GO 94899
94613: LD_INT 20
94615: DOUBLE
94616: EQUAL
94617: IFTRUE 94621
94619: GO 94632
94621: POP
// bc_type := b_ext_siberium ; 21 :
94622: LD_ADDR_OWVAR 42
94626: PUSH
94627: LD_INT 21
94629: ST_TO_ADDR
94630: GO 94899
94632: LD_INT 21
94634: DOUBLE
94635: EQUAL
94636: IFTRUE 94640
94638: GO 94651
94640: POP
// bc_type := b_ext_computer ; 22 :
94641: LD_ADDR_OWVAR 42
94645: PUSH
94646: LD_INT 24
94648: ST_TO_ADDR
94649: GO 94899
94651: LD_INT 22
94653: DOUBLE
94654: EQUAL
94655: IFTRUE 94659
94657: GO 94670
94659: POP
// bc_type := b_ext_track ; 23 :
94660: LD_ADDR_OWVAR 42
94664: PUSH
94665: LD_INT 16
94667: ST_TO_ADDR
94668: GO 94899
94670: LD_INT 23
94672: DOUBLE
94673: EQUAL
94674: IFTRUE 94678
94676: GO 94689
94678: POP
// bc_type := b_ext_laser ; 24 :
94679: LD_ADDR_OWVAR 42
94683: PUSH
94684: LD_INT 25
94686: ST_TO_ADDR
94687: GO 94899
94689: LD_INT 24
94691: DOUBLE
94692: EQUAL
94693: IFTRUE 94697
94695: GO 94708
94697: POP
// bc_type := b_control_tower ; 25 :
94698: LD_ADDR_OWVAR 42
94702: PUSH
94703: LD_INT 36
94705: ST_TO_ADDR
94706: GO 94899
94708: LD_INT 25
94710: DOUBLE
94711: EQUAL
94712: IFTRUE 94716
94714: GO 94727
94716: POP
// bc_type := b_breastwork ; 26 :
94717: LD_ADDR_OWVAR 42
94721: PUSH
94722: LD_INT 31
94724: ST_TO_ADDR
94725: GO 94899
94727: LD_INT 26
94729: DOUBLE
94730: EQUAL
94731: IFTRUE 94735
94733: GO 94746
94735: POP
// bc_type := b_bunker ; 27 :
94736: LD_ADDR_OWVAR 42
94740: PUSH
94741: LD_INT 32
94743: ST_TO_ADDR
94744: GO 94899
94746: LD_INT 27
94748: DOUBLE
94749: EQUAL
94750: IFTRUE 94754
94752: GO 94765
94754: POP
// bc_type := b_turret ; 28 :
94755: LD_ADDR_OWVAR 42
94759: PUSH
94760: LD_INT 33
94762: ST_TO_ADDR
94763: GO 94899
94765: LD_INT 28
94767: DOUBLE
94768: EQUAL
94769: IFTRUE 94773
94771: GO 94784
94773: POP
// bc_type := b_armoury ; 29 :
94774: LD_ADDR_OWVAR 42
94778: PUSH
94779: LD_INT 4
94781: ST_TO_ADDR
94782: GO 94899
94784: LD_INT 29
94786: DOUBLE
94787: EQUAL
94788: IFTRUE 94792
94790: GO 94803
94792: POP
// bc_type := b_barracks ; 30 :
94793: LD_ADDR_OWVAR 42
94797: PUSH
94798: LD_INT 5
94800: ST_TO_ADDR
94801: GO 94899
94803: LD_INT 30
94805: DOUBLE
94806: EQUAL
94807: IFTRUE 94811
94809: GO 94822
94811: POP
// bc_type := b_solar_power ; 31 :
94812: LD_ADDR_OWVAR 42
94816: PUSH
94817: LD_INT 27
94819: ST_TO_ADDR
94820: GO 94899
94822: LD_INT 31
94824: DOUBLE
94825: EQUAL
94826: IFTRUE 94830
94828: GO 94841
94830: POP
// bc_type := b_oil_power ; 32 :
94831: LD_ADDR_OWVAR 42
94835: PUSH
94836: LD_INT 26
94838: ST_TO_ADDR
94839: GO 94899
94841: LD_INT 32
94843: DOUBLE
94844: EQUAL
94845: IFTRUE 94849
94847: GO 94860
94849: POP
// bc_type := b_siberite_power ; 33 :
94850: LD_ADDR_OWVAR 42
94854: PUSH
94855: LD_INT 28
94857: ST_TO_ADDR
94858: GO 94899
94860: LD_INT 33
94862: DOUBLE
94863: EQUAL
94864: IFTRUE 94868
94866: GO 94879
94868: POP
// bc_type := b_oil_mine ; 34 :
94869: LD_ADDR_OWVAR 42
94873: PUSH
94874: LD_INT 29
94876: ST_TO_ADDR
94877: GO 94899
94879: LD_INT 34
94881: DOUBLE
94882: EQUAL
94883: IFTRUE 94887
94885: GO 94898
94887: POP
// bc_type := b_siberite_mine ; end ;
94888: LD_ADDR_OWVAR 42
94892: PUSH
94893: LD_INT 30
94895: ST_TO_ADDR
94896: GO 94899
94898: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94899: LD_ADDR_VAR 0 8
94903: PUSH
94904: LD_VAR 0 5
94908: PPUSH
94909: LD_VAR 0 6
94913: PPUSH
94914: LD_VAR 0 3
94918: PPUSH
94919: CALL_OW 47
94923: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94924: LD_OWVAR 42
94928: PUSH
94929: LD_INT 32
94931: PUSH
94932: LD_INT 33
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: IN
94939: IFFALSE 94955
// PlaceWeaponTurret ( b , weapon ) ;
94941: LD_VAR 0 8
94945: PPUSH
94946: LD_VAR 0 4
94950: PPUSH
94951: CALL_OW 431
// end ;
94955: LD_VAR 0 7
94959: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94960: LD_INT 0
94962: PPUSH
94963: PPUSH
94964: PPUSH
94965: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94966: LD_ADDR_VAR 0 4
94970: PUSH
94971: LD_INT 22
94973: PUSH
94974: LD_OWVAR 2
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PUSH
94983: LD_INT 2
94985: PUSH
94986: LD_INT 30
94988: PUSH
94989: LD_INT 0
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 30
94998: PUSH
94999: LD_INT 1
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: LIST
95010: PUSH
95011: EMPTY
95012: LIST
95013: LIST
95014: PPUSH
95015: CALL_OW 69
95019: ST_TO_ADDR
// if not tmp then
95020: LD_VAR 0 4
95024: NOT
95025: IFFALSE 95029
// exit ;
95027: GO 95088
// for i in tmp do
95029: LD_ADDR_VAR 0 2
95033: PUSH
95034: LD_VAR 0 4
95038: PUSH
95039: FOR_IN
95040: IFFALSE 95086
// for j = 1 to 3 do
95042: LD_ADDR_VAR 0 3
95046: PUSH
95047: DOUBLE
95048: LD_INT 1
95050: DEC
95051: ST_TO_ADDR
95052: LD_INT 3
95054: PUSH
95055: FOR_TO
95056: IFFALSE 95082
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95058: LD_VAR 0 2
95062: PPUSH
95063: CALL_OW 274
95067: PPUSH
95068: LD_VAR 0 3
95072: PPUSH
95073: LD_INT 99999
95075: PPUSH
95076: CALL_OW 277
95080: GO 95055
95082: POP
95083: POP
95084: GO 95039
95086: POP
95087: POP
// end ;
95088: LD_VAR 0 1
95092: RET
// export function hHackSetLevel10 ; var i , j ; begin
95093: LD_INT 0
95095: PPUSH
95096: PPUSH
95097: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95098: LD_ADDR_VAR 0 2
95102: PUSH
95103: LD_INT 21
95105: PUSH
95106: LD_INT 1
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PPUSH
95113: CALL_OW 69
95117: PUSH
95118: FOR_IN
95119: IFFALSE 95171
// if IsSelected ( i ) then
95121: LD_VAR 0 2
95125: PPUSH
95126: CALL_OW 306
95130: IFFALSE 95169
// begin for j := 1 to 4 do
95132: LD_ADDR_VAR 0 3
95136: PUSH
95137: DOUBLE
95138: LD_INT 1
95140: DEC
95141: ST_TO_ADDR
95142: LD_INT 4
95144: PUSH
95145: FOR_TO
95146: IFFALSE 95167
// SetSkill ( i , j , 10 ) ;
95148: LD_VAR 0 2
95152: PPUSH
95153: LD_VAR 0 3
95157: PPUSH
95158: LD_INT 10
95160: PPUSH
95161: CALL_OW 237
95165: GO 95145
95167: POP
95168: POP
// end ;
95169: GO 95118
95171: POP
95172: POP
// end ;
95173: LD_VAR 0 1
95177: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95178: LD_INT 0
95180: PPUSH
95181: PPUSH
95182: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95183: LD_ADDR_VAR 0 2
95187: PUSH
95188: LD_INT 22
95190: PUSH
95191: LD_OWVAR 2
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: PUSH
95200: LD_INT 21
95202: PUSH
95203: LD_INT 1
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PPUSH
95214: CALL_OW 69
95218: PUSH
95219: FOR_IN
95220: IFFALSE 95261
// begin for j := 1 to 4 do
95222: LD_ADDR_VAR 0 3
95226: PUSH
95227: DOUBLE
95228: LD_INT 1
95230: DEC
95231: ST_TO_ADDR
95232: LD_INT 4
95234: PUSH
95235: FOR_TO
95236: IFFALSE 95257
// SetSkill ( i , j , 10 ) ;
95238: LD_VAR 0 2
95242: PPUSH
95243: LD_VAR 0 3
95247: PPUSH
95248: LD_INT 10
95250: PPUSH
95251: CALL_OW 237
95255: GO 95235
95257: POP
95258: POP
// end ;
95259: GO 95219
95261: POP
95262: POP
// end ;
95263: LD_VAR 0 1
95267: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
95268: LD_INT 0
95270: PPUSH
// uc_side := your_side ;
95271: LD_ADDR_OWVAR 20
95275: PUSH
95276: LD_OWVAR 2
95280: ST_TO_ADDR
// uc_nation := nation ;
95281: LD_ADDR_OWVAR 21
95285: PUSH
95286: LD_VAR 0 1
95290: ST_TO_ADDR
// InitHc ;
95291: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95295: LD_INT 0
95297: PPUSH
95298: LD_VAR 0 2
95302: PPUSH
95303: LD_VAR 0 3
95307: PPUSH
95308: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
95312: LD_VAR 0 4
95316: PPUSH
95317: LD_VAR 0 5
95321: PPUSH
95322: CALL_OW 428
95326: PUSH
95327: LD_INT 0
95329: EQUAL
95330: IFFALSE 95354
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
95332: CALL_OW 44
95336: PPUSH
95337: LD_VAR 0 4
95341: PPUSH
95342: LD_VAR 0 5
95346: PPUSH
95347: LD_INT 1
95349: PPUSH
95350: CALL_OW 48
// end ;
95354: LD_VAR 0 6
95358: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
95359: LD_INT 0
95361: PPUSH
95362: PPUSH
// uc_side := your_side ;
95363: LD_ADDR_OWVAR 20
95367: PUSH
95368: LD_OWVAR 2
95372: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
95373: LD_VAR 0 1
95377: PUSH
95378: LD_INT 1
95380: PUSH
95381: LD_INT 2
95383: PUSH
95384: LD_INT 3
95386: PUSH
95387: LD_INT 4
95389: PUSH
95390: LD_INT 5
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: IN
95400: IFFALSE 95412
// uc_nation := nation_american else
95402: LD_ADDR_OWVAR 21
95406: PUSH
95407: LD_INT 1
95409: ST_TO_ADDR
95410: GO 95455
// if chassis in [ 11 , 12 , 13 , 14 ] then
95412: LD_VAR 0 1
95416: PUSH
95417: LD_INT 11
95419: PUSH
95420: LD_INT 12
95422: PUSH
95423: LD_INT 13
95425: PUSH
95426: LD_INT 14
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: IN
95435: IFFALSE 95447
// uc_nation := nation_arabian else
95437: LD_ADDR_OWVAR 21
95441: PUSH
95442: LD_INT 2
95444: ST_TO_ADDR
95445: GO 95455
// uc_nation := nation_russian ;
95447: LD_ADDR_OWVAR 21
95451: PUSH
95452: LD_INT 3
95454: ST_TO_ADDR
// vc_chassis := chassis ;
95455: LD_ADDR_OWVAR 37
95459: PUSH
95460: LD_VAR 0 1
95464: ST_TO_ADDR
// vc_engine := engine ;
95465: LD_ADDR_OWVAR 39
95469: PUSH
95470: LD_VAR 0 2
95474: ST_TO_ADDR
// vc_control := control ;
95475: LD_ADDR_OWVAR 38
95479: PUSH
95480: LD_VAR 0 3
95484: ST_TO_ADDR
// vc_weapon := weapon ;
95485: LD_ADDR_OWVAR 40
95489: PUSH
95490: LD_VAR 0 4
95494: ST_TO_ADDR
// un := CreateVehicle ;
95495: LD_ADDR_VAR 0 8
95499: PUSH
95500: CALL_OW 45
95504: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95505: LD_VAR 0 8
95509: PPUSH
95510: LD_INT 0
95512: PPUSH
95513: LD_INT 5
95515: PPUSH
95516: CALL_OW 12
95520: PPUSH
95521: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95525: LD_VAR 0 8
95529: PPUSH
95530: LD_VAR 0 5
95534: PPUSH
95535: LD_VAR 0 6
95539: PPUSH
95540: LD_INT 1
95542: PPUSH
95543: CALL_OW 48
// end ;
95547: LD_VAR 0 7
95551: RET
// export hInvincible ; every 1 do
95552: GO 95554
95554: DISABLE
// hInvincible := [ ] ;
95555: LD_ADDR_EXP 176
95559: PUSH
95560: EMPTY
95561: ST_TO_ADDR
95562: END
// every 10 do var i ;
95563: GO 95565
95565: DISABLE
95566: LD_INT 0
95568: PPUSH
// begin enable ;
95569: ENABLE
// if not hInvincible then
95570: LD_EXP 176
95574: NOT
95575: IFFALSE 95579
// exit ;
95577: GO 95623
// for i in hInvincible do
95579: LD_ADDR_VAR 0 1
95583: PUSH
95584: LD_EXP 176
95588: PUSH
95589: FOR_IN
95590: IFFALSE 95621
// if GetLives ( i ) < 1000 then
95592: LD_VAR 0 1
95596: PPUSH
95597: CALL_OW 256
95601: PUSH
95602: LD_INT 1000
95604: LESS
95605: IFFALSE 95619
// SetLives ( i , 1000 ) ;
95607: LD_VAR 0 1
95611: PPUSH
95612: LD_INT 1000
95614: PPUSH
95615: CALL_OW 234
95619: GO 95589
95621: POP
95622: POP
// end ;
95623: PPOPN 1
95625: END
// export function hHackInvincible ; var i ; begin
95626: LD_INT 0
95628: PPUSH
95629: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95630: LD_ADDR_VAR 0 2
95634: PUSH
95635: LD_INT 2
95637: PUSH
95638: LD_INT 21
95640: PUSH
95641: LD_INT 1
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 21
95650: PUSH
95651: LD_INT 2
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: LIST
95662: PPUSH
95663: CALL_OW 69
95667: PUSH
95668: FOR_IN
95669: IFFALSE 95730
// if IsSelected ( i ) then
95671: LD_VAR 0 2
95675: PPUSH
95676: CALL_OW 306
95680: IFFALSE 95728
// begin if i in hInvincible then
95682: LD_VAR 0 2
95686: PUSH
95687: LD_EXP 176
95691: IN
95692: IFFALSE 95712
// hInvincible := hInvincible diff i else
95694: LD_ADDR_EXP 176
95698: PUSH
95699: LD_EXP 176
95703: PUSH
95704: LD_VAR 0 2
95708: DIFF
95709: ST_TO_ADDR
95710: GO 95728
// hInvincible := hInvincible union i ;
95712: LD_ADDR_EXP 176
95716: PUSH
95717: LD_EXP 176
95721: PUSH
95722: LD_VAR 0 2
95726: UNION
95727: ST_TO_ADDR
// end ;
95728: GO 95668
95730: POP
95731: POP
// end ;
95732: LD_VAR 0 1
95736: RET
// export function hHackInvisible ; var i , j ; begin
95737: LD_INT 0
95739: PPUSH
95740: PPUSH
95741: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95742: LD_ADDR_VAR 0 2
95746: PUSH
95747: LD_INT 21
95749: PUSH
95750: LD_INT 1
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PPUSH
95757: CALL_OW 69
95761: PUSH
95762: FOR_IN
95763: IFFALSE 95787
// if IsSelected ( i ) then
95765: LD_VAR 0 2
95769: PPUSH
95770: CALL_OW 306
95774: IFFALSE 95785
// ComForceInvisible ( i ) ;
95776: LD_VAR 0 2
95780: PPUSH
95781: CALL_OW 496
95785: GO 95762
95787: POP
95788: POP
// end ;
95789: LD_VAR 0 1
95793: RET
// export function hHackChangeYourSide ; begin
95794: LD_INT 0
95796: PPUSH
// if your_side = 8 then
95797: LD_OWVAR 2
95801: PUSH
95802: LD_INT 8
95804: EQUAL
95805: IFFALSE 95817
// your_side := 0 else
95807: LD_ADDR_OWVAR 2
95811: PUSH
95812: LD_INT 0
95814: ST_TO_ADDR
95815: GO 95831
// your_side := your_side + 1 ;
95817: LD_ADDR_OWVAR 2
95821: PUSH
95822: LD_OWVAR 2
95826: PUSH
95827: LD_INT 1
95829: PLUS
95830: ST_TO_ADDR
// end ;
95831: LD_VAR 0 1
95835: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95836: LD_INT 0
95838: PPUSH
95839: PPUSH
95840: PPUSH
// for i in all_units do
95841: LD_ADDR_VAR 0 2
95845: PUSH
95846: LD_OWVAR 3
95850: PUSH
95851: FOR_IN
95852: IFFALSE 95930
// if IsSelected ( i ) then
95854: LD_VAR 0 2
95858: PPUSH
95859: CALL_OW 306
95863: IFFALSE 95928
// begin j := GetSide ( i ) ;
95865: LD_ADDR_VAR 0 3
95869: PUSH
95870: LD_VAR 0 2
95874: PPUSH
95875: CALL_OW 255
95879: ST_TO_ADDR
// if j = 8 then
95880: LD_VAR 0 3
95884: PUSH
95885: LD_INT 8
95887: EQUAL
95888: IFFALSE 95900
// j := 0 else
95890: LD_ADDR_VAR 0 3
95894: PUSH
95895: LD_INT 0
95897: ST_TO_ADDR
95898: GO 95914
// j := j + 1 ;
95900: LD_ADDR_VAR 0 3
95904: PUSH
95905: LD_VAR 0 3
95909: PUSH
95910: LD_INT 1
95912: PLUS
95913: ST_TO_ADDR
// SetSide ( i , j ) ;
95914: LD_VAR 0 2
95918: PPUSH
95919: LD_VAR 0 3
95923: PPUSH
95924: CALL_OW 235
// end ;
95928: GO 95851
95930: POP
95931: POP
// end ;
95932: LD_VAR 0 1
95936: RET
// export function hHackFog ; begin
95937: LD_INT 0
95939: PPUSH
// FogOff ( true ) ;
95940: LD_INT 1
95942: PPUSH
95943: CALL_OW 344
// end ;
95947: LD_VAR 0 1
95951: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95952: LD_INT 0
95954: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95955: LD_VAR 0 1
95959: PPUSH
95960: LD_VAR 0 2
95964: PPUSH
95965: LD_VAR 0 3
95969: PPUSH
95970: LD_INT 1
95972: PPUSH
95973: LD_INT 1
95975: PPUSH
95976: CALL_OW 483
// CenterOnXY ( x , y ) ;
95980: LD_VAR 0 2
95984: PPUSH
95985: LD_VAR 0 3
95989: PPUSH
95990: CALL_OW 84
// end ; end_of_file
95994: LD_VAR 0 4
95998: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
95999: LD_INT 0
96001: PPUSH
96002: PPUSH
96003: PPUSH
96004: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
96005: LD_VAR 0 1
96009: PPUSH
96010: CALL_OW 264
96014: PUSH
96015: LD_EXP 107
96019: EQUAL
96020: IFFALSE 96092
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
96022: LD_INT 68
96024: PPUSH
96025: LD_VAR 0 1
96029: PPUSH
96030: CALL_OW 255
96034: PPUSH
96035: CALL_OW 321
96039: PUSH
96040: LD_INT 2
96042: EQUAL
96043: IFFALSE 96055
// eff := 70 else
96045: LD_ADDR_VAR 0 4
96049: PUSH
96050: LD_INT 70
96052: ST_TO_ADDR
96053: GO 96063
// eff := 30 ;
96055: LD_ADDR_VAR 0 4
96059: PUSH
96060: LD_INT 30
96062: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
96063: LD_VAR 0 1
96067: PPUSH
96068: CALL_OW 250
96072: PPUSH
96073: LD_VAR 0 1
96077: PPUSH
96078: CALL_OW 251
96082: PPUSH
96083: LD_VAR 0 4
96087: PPUSH
96088: CALL_OW 495
// end ; end ;
96092: LD_VAR 0 2
96096: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
96097: LD_INT 0
96099: PPUSH
// end ;
96100: LD_VAR 0 4
96104: RET
// export function SOS_Command ( cmd ) ; begin
96105: LD_INT 0
96107: PPUSH
// end ;
96108: LD_VAR 0 2
96112: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
96113: LD_INT 0
96115: PPUSH
// if cmd = 121 then
96116: LD_VAR 0 1
96120: PUSH
96121: LD_INT 121
96123: EQUAL
96124: IFFALSE 96126
// end ;
96126: LD_VAR 0 6
96130: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
96131: LD_INT 0
96133: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
96134: LD_VAR 0 1
96138: PUSH
96139: LD_INT 250
96141: EQUAL
96142: PUSH
96143: LD_VAR 0 2
96147: PPUSH
96148: CALL_OW 264
96152: PUSH
96153: LD_EXP 110
96157: EQUAL
96158: AND
96159: IFFALSE 96180
// MinerPlaceMine ( unit , x , y ) ;
96161: LD_VAR 0 2
96165: PPUSH
96166: LD_VAR 0 4
96170: PPUSH
96171: LD_VAR 0 5
96175: PPUSH
96176: CALL 98529 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
96180: LD_VAR 0 1
96184: PUSH
96185: LD_INT 251
96187: EQUAL
96188: PUSH
96189: LD_VAR 0 2
96193: PPUSH
96194: CALL_OW 264
96198: PUSH
96199: LD_EXP 110
96203: EQUAL
96204: AND
96205: IFFALSE 96226
// MinerDetonateMine ( unit , x , y ) ;
96207: LD_VAR 0 2
96211: PPUSH
96212: LD_VAR 0 4
96216: PPUSH
96217: LD_VAR 0 5
96221: PPUSH
96222: CALL 98806 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
96226: LD_VAR 0 1
96230: PUSH
96231: LD_INT 252
96233: EQUAL
96234: PUSH
96235: LD_VAR 0 2
96239: PPUSH
96240: CALL_OW 264
96244: PUSH
96245: LD_EXP 110
96249: EQUAL
96250: AND
96251: IFFALSE 96272
// MinerCreateMinefield ( unit , x , y ) ;
96253: LD_VAR 0 2
96257: PPUSH
96258: LD_VAR 0 4
96262: PPUSH
96263: LD_VAR 0 5
96267: PPUSH
96268: CALL 99223 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
96272: LD_VAR 0 1
96276: PUSH
96277: LD_INT 253
96279: EQUAL
96280: PUSH
96281: LD_VAR 0 2
96285: PPUSH
96286: CALL_OW 257
96290: PUSH
96291: LD_INT 5
96293: EQUAL
96294: AND
96295: IFFALSE 96316
// ComBinocular ( unit , x , y ) ;
96297: LD_VAR 0 2
96301: PPUSH
96302: LD_VAR 0 4
96306: PPUSH
96307: LD_VAR 0 5
96311: PPUSH
96312: CALL 99594 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
96316: LD_VAR 0 1
96320: PUSH
96321: LD_INT 254
96323: EQUAL
96324: PUSH
96325: LD_VAR 0 2
96329: PPUSH
96330: CALL_OW 264
96334: PUSH
96335: LD_EXP 105
96339: EQUAL
96340: AND
96341: PUSH
96342: LD_VAR 0 3
96346: PPUSH
96347: CALL_OW 263
96351: PUSH
96352: LD_INT 3
96354: EQUAL
96355: AND
96356: IFFALSE 96372
// HackDestroyVehicle ( unit , selectedUnit ) ;
96358: LD_VAR 0 2
96362: PPUSH
96363: LD_VAR 0 3
96367: PPUSH
96368: CALL 97889 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
96372: LD_VAR 0 1
96376: PUSH
96377: LD_INT 255
96379: EQUAL
96380: PUSH
96381: LD_VAR 0 2
96385: PPUSH
96386: CALL_OW 264
96390: PUSH
96391: LD_INT 14
96393: PUSH
96394: LD_INT 53
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: IN
96401: AND
96402: PUSH
96403: LD_VAR 0 4
96407: PPUSH
96408: LD_VAR 0 5
96412: PPUSH
96413: CALL_OW 488
96417: AND
96418: IFFALSE 96442
// CutTreeXYR ( unit , x , y , 12 ) ;
96420: LD_VAR 0 2
96424: PPUSH
96425: LD_VAR 0 4
96429: PPUSH
96430: LD_VAR 0 5
96434: PPUSH
96435: LD_INT 12
96437: PPUSH
96438: CALL 96455 0 4
// end ;
96442: LD_VAR 0 6
96446: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
96447: LD_INT 0
96449: PPUSH
// end ;
96450: LD_VAR 0 4
96454: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
96455: LD_INT 0
96457: PPUSH
96458: PPUSH
96459: PPUSH
96460: PPUSH
96461: PPUSH
96462: PPUSH
96463: PPUSH
96464: PPUSH
96465: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
96466: LD_VAR 0 1
96470: NOT
96471: PUSH
96472: LD_VAR 0 2
96476: PPUSH
96477: LD_VAR 0 3
96481: PPUSH
96482: CALL_OW 488
96486: NOT
96487: OR
96488: PUSH
96489: LD_VAR 0 4
96493: NOT
96494: OR
96495: IFFALSE 96499
// exit ;
96497: GO 96839
// list := [ ] ;
96499: LD_ADDR_VAR 0 13
96503: PUSH
96504: EMPTY
96505: ST_TO_ADDR
// if x - r < 0 then
96506: LD_VAR 0 2
96510: PUSH
96511: LD_VAR 0 4
96515: MINUS
96516: PUSH
96517: LD_INT 0
96519: LESS
96520: IFFALSE 96532
// min_x := 0 else
96522: LD_ADDR_VAR 0 7
96526: PUSH
96527: LD_INT 0
96529: ST_TO_ADDR
96530: GO 96548
// min_x := x - r ;
96532: LD_ADDR_VAR 0 7
96536: PUSH
96537: LD_VAR 0 2
96541: PUSH
96542: LD_VAR 0 4
96546: MINUS
96547: ST_TO_ADDR
// if y - r < 0 then
96548: LD_VAR 0 3
96552: PUSH
96553: LD_VAR 0 4
96557: MINUS
96558: PUSH
96559: LD_INT 0
96561: LESS
96562: IFFALSE 96574
// min_y := 0 else
96564: LD_ADDR_VAR 0 8
96568: PUSH
96569: LD_INT 0
96571: ST_TO_ADDR
96572: GO 96590
// min_y := y - r ;
96574: LD_ADDR_VAR 0 8
96578: PUSH
96579: LD_VAR 0 3
96583: PUSH
96584: LD_VAR 0 4
96588: MINUS
96589: ST_TO_ADDR
// max_x := x + r ;
96590: LD_ADDR_VAR 0 9
96594: PUSH
96595: LD_VAR 0 2
96599: PUSH
96600: LD_VAR 0 4
96604: PLUS
96605: ST_TO_ADDR
// max_y := y + r ;
96606: LD_ADDR_VAR 0 10
96610: PUSH
96611: LD_VAR 0 3
96615: PUSH
96616: LD_VAR 0 4
96620: PLUS
96621: ST_TO_ADDR
// for _x = min_x to max_x do
96622: LD_ADDR_VAR 0 11
96626: PUSH
96627: DOUBLE
96628: LD_VAR 0 7
96632: DEC
96633: ST_TO_ADDR
96634: LD_VAR 0 9
96638: PUSH
96639: FOR_TO
96640: IFFALSE 96757
// for _y = min_y to max_y do
96642: LD_ADDR_VAR 0 12
96646: PUSH
96647: DOUBLE
96648: LD_VAR 0 8
96652: DEC
96653: ST_TO_ADDR
96654: LD_VAR 0 10
96658: PUSH
96659: FOR_TO
96660: IFFALSE 96753
// begin if not ValidHex ( _x , _y ) then
96662: LD_VAR 0 11
96666: PPUSH
96667: LD_VAR 0 12
96671: PPUSH
96672: CALL_OW 488
96676: NOT
96677: IFFALSE 96681
// continue ;
96679: GO 96659
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
96681: LD_VAR 0 11
96685: PPUSH
96686: LD_VAR 0 12
96690: PPUSH
96691: CALL_OW 351
96695: PUSH
96696: LD_VAR 0 11
96700: PPUSH
96701: LD_VAR 0 12
96705: PPUSH
96706: CALL_OW 554
96710: AND
96711: IFFALSE 96751
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
96713: LD_ADDR_VAR 0 13
96717: PUSH
96718: LD_VAR 0 13
96722: PPUSH
96723: LD_VAR 0 13
96727: PUSH
96728: LD_INT 1
96730: PLUS
96731: PPUSH
96732: LD_VAR 0 11
96736: PUSH
96737: LD_VAR 0 12
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PPUSH
96746: CALL_OW 2
96750: ST_TO_ADDR
// end ;
96751: GO 96659
96753: POP
96754: POP
96755: GO 96639
96757: POP
96758: POP
// if not list then
96759: LD_VAR 0 13
96763: NOT
96764: IFFALSE 96768
// exit ;
96766: GO 96839
// for i in list do
96768: LD_ADDR_VAR 0 6
96772: PUSH
96773: LD_VAR 0 13
96777: PUSH
96778: FOR_IN
96779: IFFALSE 96837
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
96781: LD_VAR 0 1
96785: PPUSH
96786: LD_STRING M
96788: PUSH
96789: LD_VAR 0 6
96793: PUSH
96794: LD_INT 1
96796: ARRAY
96797: PUSH
96798: LD_VAR 0 6
96802: PUSH
96803: LD_INT 2
96805: ARRAY
96806: PUSH
96807: LD_INT 0
96809: PUSH
96810: LD_INT 0
96812: PUSH
96813: LD_INT 0
96815: PUSH
96816: LD_INT 0
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: PUSH
96828: EMPTY
96829: LIST
96830: PPUSH
96831: CALL_OW 447
96835: GO 96778
96837: POP
96838: POP
// end ;
96839: LD_VAR 0 5
96843: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
96844: LD_EXP 179
96848: NOT
96849: IFFALSE 96899
96851: GO 96853
96853: DISABLE
// begin initHack := true ;
96854: LD_ADDR_EXP 179
96858: PUSH
96859: LD_INT 1
96861: ST_TO_ADDR
// hackTanks := [ ] ;
96862: LD_ADDR_EXP 180
96866: PUSH
96867: EMPTY
96868: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
96869: LD_ADDR_EXP 181
96873: PUSH
96874: EMPTY
96875: ST_TO_ADDR
// hackLimit := 3 ;
96876: LD_ADDR_EXP 182
96880: PUSH
96881: LD_INT 3
96883: ST_TO_ADDR
// hackDist := 12 ;
96884: LD_ADDR_EXP 183
96888: PUSH
96889: LD_INT 12
96891: ST_TO_ADDR
// hackCounter := [ ] ;
96892: LD_ADDR_EXP 184
96896: PUSH
96897: EMPTY
96898: ST_TO_ADDR
// end ;
96899: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
96900: LD_EXP 179
96904: PUSH
96905: LD_INT 34
96907: PUSH
96908: LD_EXP 105
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PPUSH
96917: CALL_OW 69
96921: AND
96922: IFFALSE 97177
96924: GO 96926
96926: DISABLE
96927: LD_INT 0
96929: PPUSH
96930: PPUSH
// begin enable ;
96931: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
96932: LD_ADDR_VAR 0 1
96936: PUSH
96937: LD_INT 34
96939: PUSH
96940: LD_EXP 105
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PPUSH
96949: CALL_OW 69
96953: PUSH
96954: FOR_IN
96955: IFFALSE 97175
// begin if not i in hackTanks then
96957: LD_VAR 0 1
96961: PUSH
96962: LD_EXP 180
96966: IN
96967: NOT
96968: IFFALSE 97051
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
96970: LD_ADDR_EXP 180
96974: PUSH
96975: LD_EXP 180
96979: PPUSH
96980: LD_EXP 180
96984: PUSH
96985: LD_INT 1
96987: PLUS
96988: PPUSH
96989: LD_VAR 0 1
96993: PPUSH
96994: CALL_OW 1
96998: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
96999: LD_ADDR_EXP 181
97003: PUSH
97004: LD_EXP 181
97008: PPUSH
97009: LD_EXP 181
97013: PUSH
97014: LD_INT 1
97016: PLUS
97017: PPUSH
97018: EMPTY
97019: PPUSH
97020: CALL_OW 1
97024: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
97025: LD_ADDR_EXP 184
97029: PUSH
97030: LD_EXP 184
97034: PPUSH
97035: LD_EXP 184
97039: PUSH
97040: LD_INT 1
97042: PLUS
97043: PPUSH
97044: EMPTY
97045: PPUSH
97046: CALL_OW 1
97050: ST_TO_ADDR
// end ; if not IsOk ( i ) then
97051: LD_VAR 0 1
97055: PPUSH
97056: CALL_OW 302
97060: NOT
97061: IFFALSE 97074
// begin HackUnlinkAll ( i ) ;
97063: LD_VAR 0 1
97067: PPUSH
97068: CALL 97180 0 1
// continue ;
97072: GO 96954
// end ; HackCheckCapturedStatus ( i ) ;
97074: LD_VAR 0 1
97078: PPUSH
97079: CALL 97623 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
97083: LD_ADDR_VAR 0 2
97087: PUSH
97088: LD_INT 81
97090: PUSH
97091: LD_VAR 0 1
97095: PPUSH
97096: CALL_OW 255
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 33
97107: PUSH
97108: LD_INT 3
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 91
97117: PUSH
97118: LD_VAR 0 1
97122: PUSH
97123: LD_EXP 183
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: LIST
97132: PUSH
97133: LD_INT 50
97135: PUSH
97136: EMPTY
97137: LIST
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: PPUSH
97145: CALL_OW 69
97149: ST_TO_ADDR
// if not tmp then
97150: LD_VAR 0 2
97154: NOT
97155: IFFALSE 97159
// continue ;
97157: GO 96954
// HackLink ( i , tmp ) ;
97159: LD_VAR 0 1
97163: PPUSH
97164: LD_VAR 0 2
97168: PPUSH
97169: CALL 97316 0 2
// end ;
97173: GO 96954
97175: POP
97176: POP
// end ;
97177: PPOPN 2
97179: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
97180: LD_INT 0
97182: PPUSH
97183: PPUSH
97184: PPUSH
// if not hack in hackTanks then
97185: LD_VAR 0 1
97189: PUSH
97190: LD_EXP 180
97194: IN
97195: NOT
97196: IFFALSE 97200
// exit ;
97198: GO 97311
// index := GetElementIndex ( hackTanks , hack ) ;
97200: LD_ADDR_VAR 0 4
97204: PUSH
97205: LD_EXP 180
97209: PPUSH
97210: LD_VAR 0 1
97214: PPUSH
97215: CALL 19471 0 2
97219: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
97220: LD_EXP 181
97224: PUSH
97225: LD_VAR 0 4
97229: ARRAY
97230: IFFALSE 97311
// begin for i in hackTanksCaptured [ index ] do
97232: LD_ADDR_VAR 0 3
97236: PUSH
97237: LD_EXP 181
97241: PUSH
97242: LD_VAR 0 4
97246: ARRAY
97247: PUSH
97248: FOR_IN
97249: IFFALSE 97275
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
97251: LD_VAR 0 3
97255: PUSH
97256: LD_INT 1
97258: ARRAY
97259: PPUSH
97260: LD_VAR 0 3
97264: PUSH
97265: LD_INT 2
97267: ARRAY
97268: PPUSH
97269: CALL_OW 235
97273: GO 97248
97275: POP
97276: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
97277: LD_ADDR_EXP 181
97281: PUSH
97282: LD_EXP 181
97286: PPUSH
97287: LD_VAR 0 4
97291: PPUSH
97292: EMPTY
97293: PPUSH
97294: CALL_OW 1
97298: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
97299: LD_VAR 0 1
97303: PPUSH
97304: LD_INT 0
97306: PPUSH
97307: CALL_OW 505
// end ; end ;
97311: LD_VAR 0 2
97315: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
97316: LD_INT 0
97318: PPUSH
97319: PPUSH
97320: PPUSH
// if not hack in hackTanks or not vehicles then
97321: LD_VAR 0 1
97325: PUSH
97326: LD_EXP 180
97330: IN
97331: NOT
97332: PUSH
97333: LD_VAR 0 2
97337: NOT
97338: OR
97339: IFFALSE 97343
// exit ;
97341: GO 97618
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
97343: LD_ADDR_VAR 0 2
97347: PUSH
97348: LD_VAR 0 1
97352: PPUSH
97353: LD_VAR 0 2
97357: PPUSH
97358: LD_INT 1
97360: PPUSH
97361: LD_INT 1
97363: PPUSH
97364: CALL 20121 0 4
97368: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
97369: LD_ADDR_VAR 0 5
97373: PUSH
97374: LD_EXP 180
97378: PPUSH
97379: LD_VAR 0 1
97383: PPUSH
97384: CALL 19471 0 2
97388: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
97389: LD_EXP 181
97393: PUSH
97394: LD_VAR 0 5
97398: ARRAY
97399: PUSH
97400: LD_EXP 182
97404: LESS
97405: IFFALSE 97594
// begin for i := 1 to vehicles do
97407: LD_ADDR_VAR 0 4
97411: PUSH
97412: DOUBLE
97413: LD_INT 1
97415: DEC
97416: ST_TO_ADDR
97417: LD_VAR 0 2
97421: PUSH
97422: FOR_TO
97423: IFFALSE 97592
// begin if hackTanksCaptured [ index ] = hackLimit then
97425: LD_EXP 181
97429: PUSH
97430: LD_VAR 0 5
97434: ARRAY
97435: PUSH
97436: LD_EXP 182
97440: EQUAL
97441: IFFALSE 97445
// break ;
97443: GO 97592
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
97445: LD_ADDR_EXP 184
97449: PUSH
97450: LD_EXP 184
97454: PPUSH
97455: LD_VAR 0 5
97459: PPUSH
97460: LD_EXP 184
97464: PUSH
97465: LD_VAR 0 5
97469: ARRAY
97470: PUSH
97471: LD_INT 1
97473: PLUS
97474: PPUSH
97475: CALL_OW 1
97479: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
97480: LD_ADDR_EXP 181
97484: PUSH
97485: LD_EXP 181
97489: PPUSH
97490: LD_VAR 0 5
97494: PUSH
97495: LD_EXP 181
97499: PUSH
97500: LD_VAR 0 5
97504: ARRAY
97505: PUSH
97506: LD_INT 1
97508: PLUS
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PPUSH
97514: LD_VAR 0 2
97518: PUSH
97519: LD_VAR 0 4
97523: ARRAY
97524: PUSH
97525: LD_VAR 0 2
97529: PUSH
97530: LD_VAR 0 4
97534: ARRAY
97535: PPUSH
97536: CALL_OW 255
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: PPUSH
97545: CALL 19686 0 3
97549: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
97550: LD_VAR 0 2
97554: PUSH
97555: LD_VAR 0 4
97559: ARRAY
97560: PPUSH
97561: LD_VAR 0 1
97565: PPUSH
97566: CALL_OW 255
97570: PPUSH
97571: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
97575: LD_VAR 0 2
97579: PUSH
97580: LD_VAR 0 4
97584: ARRAY
97585: PPUSH
97586: CALL_OW 141
// end ;
97590: GO 97422
97592: POP
97593: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97594: LD_VAR 0 1
97598: PPUSH
97599: LD_EXP 181
97603: PUSH
97604: LD_VAR 0 5
97608: ARRAY
97609: PUSH
97610: LD_INT 0
97612: PLUS
97613: PPUSH
97614: CALL_OW 505
// end ;
97618: LD_VAR 0 3
97622: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
97623: LD_INT 0
97625: PPUSH
97626: PPUSH
97627: PPUSH
97628: PPUSH
// if not hack in hackTanks then
97629: LD_VAR 0 1
97633: PUSH
97634: LD_EXP 180
97638: IN
97639: NOT
97640: IFFALSE 97644
// exit ;
97642: GO 97884
// index := GetElementIndex ( hackTanks , hack ) ;
97644: LD_ADDR_VAR 0 4
97648: PUSH
97649: LD_EXP 180
97653: PPUSH
97654: LD_VAR 0 1
97658: PPUSH
97659: CALL 19471 0 2
97663: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
97664: LD_ADDR_VAR 0 3
97668: PUSH
97669: DOUBLE
97670: LD_EXP 181
97674: PUSH
97675: LD_VAR 0 4
97679: ARRAY
97680: INC
97681: ST_TO_ADDR
97682: LD_INT 1
97684: PUSH
97685: FOR_DOWNTO
97686: IFFALSE 97858
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
97688: LD_ADDR_VAR 0 5
97692: PUSH
97693: LD_EXP 181
97697: PUSH
97698: LD_VAR 0 4
97702: ARRAY
97703: PUSH
97704: LD_VAR 0 3
97708: ARRAY
97709: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
97710: LD_VAR 0 5
97714: PUSH
97715: LD_INT 1
97717: ARRAY
97718: PPUSH
97719: CALL_OW 302
97723: NOT
97724: PUSH
97725: LD_VAR 0 5
97729: PUSH
97730: LD_INT 1
97732: ARRAY
97733: PPUSH
97734: CALL_OW 255
97738: PUSH
97739: LD_VAR 0 1
97743: PPUSH
97744: CALL_OW 255
97748: NONEQUAL
97749: OR
97750: IFFALSE 97856
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
97752: LD_VAR 0 5
97756: PUSH
97757: LD_INT 1
97759: ARRAY
97760: PPUSH
97761: CALL_OW 305
97765: PUSH
97766: LD_VAR 0 5
97770: PUSH
97771: LD_INT 1
97773: ARRAY
97774: PPUSH
97775: CALL_OW 255
97779: PUSH
97780: LD_VAR 0 1
97784: PPUSH
97785: CALL_OW 255
97789: EQUAL
97790: AND
97791: IFFALSE 97815
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
97793: LD_VAR 0 5
97797: PUSH
97798: LD_INT 1
97800: ARRAY
97801: PPUSH
97802: LD_VAR 0 5
97806: PUSH
97807: LD_INT 2
97809: ARRAY
97810: PPUSH
97811: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
97815: LD_ADDR_EXP 181
97819: PUSH
97820: LD_EXP 181
97824: PPUSH
97825: LD_VAR 0 4
97829: PPUSH
97830: LD_EXP 181
97834: PUSH
97835: LD_VAR 0 4
97839: ARRAY
97840: PPUSH
97841: LD_VAR 0 3
97845: PPUSH
97846: CALL_OW 3
97850: PPUSH
97851: CALL_OW 1
97855: ST_TO_ADDR
// end ; end ;
97856: GO 97685
97858: POP
97859: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97860: LD_VAR 0 1
97864: PPUSH
97865: LD_EXP 181
97869: PUSH
97870: LD_VAR 0 4
97874: ARRAY
97875: PUSH
97876: LD_INT 0
97878: PLUS
97879: PPUSH
97880: CALL_OW 505
// end ;
97884: LD_VAR 0 2
97888: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
97889: LD_INT 0
97891: PPUSH
97892: PPUSH
97893: PPUSH
97894: PPUSH
// if not hack in hackTanks then
97895: LD_VAR 0 1
97899: PUSH
97900: LD_EXP 180
97904: IN
97905: NOT
97906: IFFALSE 97910
// exit ;
97908: GO 97995
// index := GetElementIndex ( hackTanks , hack ) ;
97910: LD_ADDR_VAR 0 5
97914: PUSH
97915: LD_EXP 180
97919: PPUSH
97920: LD_VAR 0 1
97924: PPUSH
97925: CALL 19471 0 2
97929: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
97930: LD_ADDR_VAR 0 4
97934: PUSH
97935: DOUBLE
97936: LD_INT 1
97938: DEC
97939: ST_TO_ADDR
97940: LD_EXP 181
97944: PUSH
97945: LD_VAR 0 5
97949: ARRAY
97950: PUSH
97951: FOR_TO
97952: IFFALSE 97993
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
97954: LD_EXP 181
97958: PUSH
97959: LD_VAR 0 5
97963: ARRAY
97964: PUSH
97965: LD_VAR 0 4
97969: ARRAY
97970: PUSH
97971: LD_INT 1
97973: ARRAY
97974: PUSH
97975: LD_VAR 0 2
97979: EQUAL
97980: IFFALSE 97991
// KillUnit ( vehicle ) ;
97982: LD_VAR 0 2
97986: PPUSH
97987: CALL_OW 66
97991: GO 97951
97993: POP
97994: POP
// end ;
97995: LD_VAR 0 3
97999: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
98000: LD_EXP 185
98004: NOT
98005: IFFALSE 98040
98007: GO 98009
98009: DISABLE
// begin initMiner := true ;
98010: LD_ADDR_EXP 185
98014: PUSH
98015: LD_INT 1
98017: ST_TO_ADDR
// minersList := [ ] ;
98018: LD_ADDR_EXP 186
98022: PUSH
98023: EMPTY
98024: ST_TO_ADDR
// minerMinesList := [ ] ;
98025: LD_ADDR_EXP 187
98029: PUSH
98030: EMPTY
98031: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
98032: LD_ADDR_EXP 188
98036: PUSH
98037: LD_INT 5
98039: ST_TO_ADDR
// end ;
98040: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
98041: LD_EXP 185
98045: PUSH
98046: LD_INT 34
98048: PUSH
98049: LD_EXP 110
98053: PUSH
98054: EMPTY
98055: LIST
98056: LIST
98057: PPUSH
98058: CALL_OW 69
98062: AND
98063: IFFALSE 98526
98065: GO 98067
98067: DISABLE
98068: LD_INT 0
98070: PPUSH
98071: PPUSH
98072: PPUSH
98073: PPUSH
// begin enable ;
98074: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
98075: LD_ADDR_VAR 0 1
98079: PUSH
98080: LD_INT 34
98082: PUSH
98083: LD_EXP 110
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PPUSH
98092: CALL_OW 69
98096: PUSH
98097: FOR_IN
98098: IFFALSE 98170
// begin if not i in minersList then
98100: LD_VAR 0 1
98104: PUSH
98105: LD_EXP 186
98109: IN
98110: NOT
98111: IFFALSE 98168
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
98113: LD_ADDR_EXP 186
98117: PUSH
98118: LD_EXP 186
98122: PPUSH
98123: LD_EXP 186
98127: PUSH
98128: LD_INT 1
98130: PLUS
98131: PPUSH
98132: LD_VAR 0 1
98136: PPUSH
98137: CALL_OW 1
98141: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
98142: LD_ADDR_EXP 187
98146: PUSH
98147: LD_EXP 187
98151: PPUSH
98152: LD_EXP 187
98156: PUSH
98157: LD_INT 1
98159: PLUS
98160: PPUSH
98161: EMPTY
98162: PPUSH
98163: CALL_OW 1
98167: ST_TO_ADDR
// end end ;
98168: GO 98097
98170: POP
98171: POP
// for i := minerMinesList downto 1 do
98172: LD_ADDR_VAR 0 1
98176: PUSH
98177: DOUBLE
98178: LD_EXP 187
98182: INC
98183: ST_TO_ADDR
98184: LD_INT 1
98186: PUSH
98187: FOR_DOWNTO
98188: IFFALSE 98524
// begin if IsLive ( minersList [ i ] ) then
98190: LD_EXP 186
98194: PUSH
98195: LD_VAR 0 1
98199: ARRAY
98200: PPUSH
98201: CALL_OW 300
98205: IFFALSE 98233
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
98207: LD_EXP 186
98211: PUSH
98212: LD_VAR 0 1
98216: ARRAY
98217: PPUSH
98218: LD_EXP 187
98222: PUSH
98223: LD_VAR 0 1
98227: ARRAY
98228: PPUSH
98229: CALL_OW 505
// if not minerMinesList [ i ] then
98233: LD_EXP 187
98237: PUSH
98238: LD_VAR 0 1
98242: ARRAY
98243: NOT
98244: IFFALSE 98248
// continue ;
98246: GO 98187
// for j := minerMinesList [ i ] downto 1 do
98248: LD_ADDR_VAR 0 2
98252: PUSH
98253: DOUBLE
98254: LD_EXP 187
98258: PUSH
98259: LD_VAR 0 1
98263: ARRAY
98264: INC
98265: ST_TO_ADDR
98266: LD_INT 1
98268: PUSH
98269: FOR_DOWNTO
98270: IFFALSE 98520
// begin side := GetSide ( minersList [ i ] ) ;
98272: LD_ADDR_VAR 0 3
98276: PUSH
98277: LD_EXP 186
98281: PUSH
98282: LD_VAR 0 1
98286: ARRAY
98287: PPUSH
98288: CALL_OW 255
98292: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
98293: LD_ADDR_VAR 0 4
98297: PUSH
98298: LD_EXP 187
98302: PUSH
98303: LD_VAR 0 1
98307: ARRAY
98308: PUSH
98309: LD_VAR 0 2
98313: ARRAY
98314: PUSH
98315: LD_INT 1
98317: ARRAY
98318: PPUSH
98319: LD_EXP 187
98323: PUSH
98324: LD_VAR 0 1
98328: ARRAY
98329: PUSH
98330: LD_VAR 0 2
98334: ARRAY
98335: PUSH
98336: LD_INT 2
98338: ARRAY
98339: PPUSH
98340: CALL_OW 428
98344: ST_TO_ADDR
// if not tmp then
98345: LD_VAR 0 4
98349: NOT
98350: IFFALSE 98354
// continue ;
98352: GO 98269
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
98354: LD_VAR 0 4
98358: PUSH
98359: LD_INT 81
98361: PUSH
98362: LD_VAR 0 3
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PPUSH
98371: CALL_OW 69
98375: IN
98376: PUSH
98377: LD_EXP 187
98381: PUSH
98382: LD_VAR 0 1
98386: ARRAY
98387: PUSH
98388: LD_VAR 0 2
98392: ARRAY
98393: PUSH
98394: LD_INT 1
98396: ARRAY
98397: PPUSH
98398: LD_EXP 187
98402: PUSH
98403: LD_VAR 0 1
98407: ARRAY
98408: PUSH
98409: LD_VAR 0 2
98413: ARRAY
98414: PUSH
98415: LD_INT 2
98417: ARRAY
98418: PPUSH
98419: CALL_OW 458
98423: AND
98424: IFFALSE 98518
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
98426: LD_EXP 187
98430: PUSH
98431: LD_VAR 0 1
98435: ARRAY
98436: PUSH
98437: LD_VAR 0 2
98441: ARRAY
98442: PUSH
98443: LD_INT 1
98445: ARRAY
98446: PPUSH
98447: LD_EXP 187
98451: PUSH
98452: LD_VAR 0 1
98456: ARRAY
98457: PUSH
98458: LD_VAR 0 2
98462: ARRAY
98463: PUSH
98464: LD_INT 2
98466: ARRAY
98467: PPUSH
98468: LD_VAR 0 3
98472: PPUSH
98473: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
98477: LD_ADDR_EXP 187
98481: PUSH
98482: LD_EXP 187
98486: PPUSH
98487: LD_VAR 0 1
98491: PPUSH
98492: LD_EXP 187
98496: PUSH
98497: LD_VAR 0 1
98501: ARRAY
98502: PPUSH
98503: LD_VAR 0 2
98507: PPUSH
98508: CALL_OW 3
98512: PPUSH
98513: CALL_OW 1
98517: ST_TO_ADDR
// end ; end ;
98518: GO 98269
98520: POP
98521: POP
// end ;
98522: GO 98187
98524: POP
98525: POP
// end ;
98526: PPOPN 4
98528: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
98529: LD_INT 0
98531: PPUSH
98532: PPUSH
// result := false ;
98533: LD_ADDR_VAR 0 4
98537: PUSH
98538: LD_INT 0
98540: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
98541: LD_VAR 0 1
98545: PPUSH
98546: CALL_OW 264
98550: PUSH
98551: LD_EXP 110
98555: EQUAL
98556: NOT
98557: IFFALSE 98561
// exit ;
98559: GO 98801
// index := GetElementIndex ( minersList , unit ) ;
98561: LD_ADDR_VAR 0 5
98565: PUSH
98566: LD_EXP 186
98570: PPUSH
98571: LD_VAR 0 1
98575: PPUSH
98576: CALL 19471 0 2
98580: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
98581: LD_EXP 187
98585: PUSH
98586: LD_VAR 0 5
98590: ARRAY
98591: PUSH
98592: LD_EXP 188
98596: GREATEREQUAL
98597: IFFALSE 98601
// exit ;
98599: GO 98801
// ComMoveXY ( unit , x , y ) ;
98601: LD_VAR 0 1
98605: PPUSH
98606: LD_VAR 0 2
98610: PPUSH
98611: LD_VAR 0 3
98615: PPUSH
98616: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98620: LD_INT 35
98622: PPUSH
98623: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
98627: LD_VAR 0 1
98631: PPUSH
98632: LD_VAR 0 2
98636: PPUSH
98637: LD_VAR 0 3
98641: PPUSH
98642: CALL 49838 0 3
98646: NOT
98647: PUSH
98648: LD_VAR 0 1
98652: PPUSH
98653: CALL_OW 314
98657: AND
98658: IFFALSE 98662
// exit ;
98660: GO 98801
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
98662: LD_VAR 0 2
98666: PPUSH
98667: LD_VAR 0 3
98671: PPUSH
98672: CALL_OW 428
98676: PUSH
98677: LD_VAR 0 1
98681: EQUAL
98682: PUSH
98683: LD_VAR 0 1
98687: PPUSH
98688: CALL_OW 314
98692: NOT
98693: AND
98694: IFFALSE 98620
// PlaySoundXY ( x , y , PlantMine ) ;
98696: LD_VAR 0 2
98700: PPUSH
98701: LD_VAR 0 3
98705: PPUSH
98706: LD_STRING PlantMine
98708: PPUSH
98709: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
98713: LD_VAR 0 2
98717: PPUSH
98718: LD_VAR 0 3
98722: PPUSH
98723: LD_VAR 0 1
98727: PPUSH
98728: CALL_OW 255
98732: PPUSH
98733: LD_INT 0
98735: PPUSH
98736: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
98740: LD_ADDR_EXP 187
98744: PUSH
98745: LD_EXP 187
98749: PPUSH
98750: LD_VAR 0 5
98754: PUSH
98755: LD_EXP 187
98759: PUSH
98760: LD_VAR 0 5
98764: ARRAY
98765: PUSH
98766: LD_INT 1
98768: PLUS
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PPUSH
98774: LD_VAR 0 2
98778: PUSH
98779: LD_VAR 0 3
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PPUSH
98788: CALL 19686 0 3
98792: ST_TO_ADDR
// result := true ;
98793: LD_ADDR_VAR 0 4
98797: PUSH
98798: LD_INT 1
98800: ST_TO_ADDR
// end ;
98801: LD_VAR 0 4
98805: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
98806: LD_INT 0
98808: PPUSH
98809: PPUSH
98810: PPUSH
// if not unit in minersList then
98811: LD_VAR 0 1
98815: PUSH
98816: LD_EXP 186
98820: IN
98821: NOT
98822: IFFALSE 98826
// exit ;
98824: GO 99218
// index := GetElementIndex ( minersList , unit ) ;
98826: LD_ADDR_VAR 0 6
98830: PUSH
98831: LD_EXP 186
98835: PPUSH
98836: LD_VAR 0 1
98840: PPUSH
98841: CALL 19471 0 2
98845: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
98846: LD_ADDR_VAR 0 5
98850: PUSH
98851: DOUBLE
98852: LD_EXP 187
98856: PUSH
98857: LD_VAR 0 6
98861: ARRAY
98862: INC
98863: ST_TO_ADDR
98864: LD_INT 1
98866: PUSH
98867: FOR_DOWNTO
98868: IFFALSE 99029
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
98870: LD_EXP 187
98874: PUSH
98875: LD_VAR 0 6
98879: ARRAY
98880: PUSH
98881: LD_VAR 0 5
98885: ARRAY
98886: PUSH
98887: LD_INT 1
98889: ARRAY
98890: PUSH
98891: LD_VAR 0 2
98895: EQUAL
98896: PUSH
98897: LD_EXP 187
98901: PUSH
98902: LD_VAR 0 6
98906: ARRAY
98907: PUSH
98908: LD_VAR 0 5
98912: ARRAY
98913: PUSH
98914: LD_INT 2
98916: ARRAY
98917: PUSH
98918: LD_VAR 0 3
98922: EQUAL
98923: AND
98924: IFFALSE 99027
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98926: LD_EXP 187
98930: PUSH
98931: LD_VAR 0 6
98935: ARRAY
98936: PUSH
98937: LD_VAR 0 5
98941: ARRAY
98942: PUSH
98943: LD_INT 1
98945: ARRAY
98946: PPUSH
98947: LD_EXP 187
98951: PUSH
98952: LD_VAR 0 6
98956: ARRAY
98957: PUSH
98958: LD_VAR 0 5
98962: ARRAY
98963: PUSH
98964: LD_INT 2
98966: ARRAY
98967: PPUSH
98968: LD_VAR 0 1
98972: PPUSH
98973: CALL_OW 255
98977: PPUSH
98978: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98982: LD_ADDR_EXP 187
98986: PUSH
98987: LD_EXP 187
98991: PPUSH
98992: LD_VAR 0 6
98996: PPUSH
98997: LD_EXP 187
99001: PUSH
99002: LD_VAR 0 6
99006: ARRAY
99007: PPUSH
99008: LD_VAR 0 5
99012: PPUSH
99013: CALL_OW 3
99017: PPUSH
99018: CALL_OW 1
99022: ST_TO_ADDR
// exit ;
99023: POP
99024: POP
99025: GO 99218
// end ; end ;
99027: GO 98867
99029: POP
99030: POP
// for i := minerMinesList [ index ] downto 1 do
99031: LD_ADDR_VAR 0 5
99035: PUSH
99036: DOUBLE
99037: LD_EXP 187
99041: PUSH
99042: LD_VAR 0 6
99046: ARRAY
99047: INC
99048: ST_TO_ADDR
99049: LD_INT 1
99051: PUSH
99052: FOR_DOWNTO
99053: IFFALSE 99216
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
99055: LD_EXP 187
99059: PUSH
99060: LD_VAR 0 6
99064: ARRAY
99065: PUSH
99066: LD_VAR 0 5
99070: ARRAY
99071: PUSH
99072: LD_INT 1
99074: ARRAY
99075: PPUSH
99076: LD_EXP 187
99080: PUSH
99081: LD_VAR 0 6
99085: ARRAY
99086: PUSH
99087: LD_VAR 0 5
99091: ARRAY
99092: PUSH
99093: LD_INT 2
99095: ARRAY
99096: PPUSH
99097: LD_VAR 0 2
99101: PPUSH
99102: LD_VAR 0 3
99106: PPUSH
99107: CALL_OW 298
99111: PUSH
99112: LD_INT 6
99114: LESS
99115: IFFALSE 99214
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
99117: LD_EXP 187
99121: PUSH
99122: LD_VAR 0 6
99126: ARRAY
99127: PUSH
99128: LD_VAR 0 5
99132: ARRAY
99133: PUSH
99134: LD_INT 1
99136: ARRAY
99137: PPUSH
99138: LD_EXP 187
99142: PUSH
99143: LD_VAR 0 6
99147: ARRAY
99148: PUSH
99149: LD_VAR 0 5
99153: ARRAY
99154: PUSH
99155: LD_INT 2
99157: ARRAY
99158: PPUSH
99159: LD_VAR 0 1
99163: PPUSH
99164: CALL_OW 255
99168: PPUSH
99169: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
99173: LD_ADDR_EXP 187
99177: PUSH
99178: LD_EXP 187
99182: PPUSH
99183: LD_VAR 0 6
99187: PPUSH
99188: LD_EXP 187
99192: PUSH
99193: LD_VAR 0 6
99197: ARRAY
99198: PPUSH
99199: LD_VAR 0 5
99203: PPUSH
99204: CALL_OW 3
99208: PPUSH
99209: CALL_OW 1
99213: ST_TO_ADDR
// end ; end ;
99214: GO 99052
99216: POP
99217: POP
// end ;
99218: LD_VAR 0 4
99222: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
99223: LD_INT 0
99225: PPUSH
99226: PPUSH
99227: PPUSH
99228: PPUSH
99229: PPUSH
99230: PPUSH
99231: PPUSH
99232: PPUSH
99233: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
99234: LD_VAR 0 1
99238: PPUSH
99239: CALL_OW 264
99243: PUSH
99244: LD_EXP 110
99248: EQUAL
99249: NOT
99250: PUSH
99251: LD_VAR 0 1
99255: PUSH
99256: LD_EXP 186
99260: IN
99261: NOT
99262: OR
99263: IFFALSE 99267
// exit ;
99265: GO 99589
// index := GetElementIndex ( minersList , unit ) ;
99267: LD_ADDR_VAR 0 6
99271: PUSH
99272: LD_EXP 186
99276: PPUSH
99277: LD_VAR 0 1
99281: PPUSH
99282: CALL 19471 0 2
99286: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
99287: LD_ADDR_VAR 0 8
99291: PUSH
99292: LD_EXP 188
99296: PUSH
99297: LD_EXP 187
99301: PUSH
99302: LD_VAR 0 6
99306: ARRAY
99307: MINUS
99308: ST_TO_ADDR
// if not minesFreeAmount then
99309: LD_VAR 0 8
99313: NOT
99314: IFFALSE 99318
// exit ;
99316: GO 99589
// tmp := [ ] ;
99318: LD_ADDR_VAR 0 7
99322: PUSH
99323: EMPTY
99324: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
99325: LD_ADDR_VAR 0 5
99329: PUSH
99330: DOUBLE
99331: LD_INT 1
99333: DEC
99334: ST_TO_ADDR
99335: LD_VAR 0 8
99339: PUSH
99340: FOR_TO
99341: IFFALSE 99536
// begin _d := rand ( 0 , 5 ) ;
99343: LD_ADDR_VAR 0 11
99347: PUSH
99348: LD_INT 0
99350: PPUSH
99351: LD_INT 5
99353: PPUSH
99354: CALL_OW 12
99358: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
99359: LD_ADDR_VAR 0 12
99363: PUSH
99364: LD_INT 2
99366: PPUSH
99367: LD_INT 6
99369: PPUSH
99370: CALL_OW 12
99374: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
99375: LD_ADDR_VAR 0 9
99379: PUSH
99380: LD_VAR 0 2
99384: PPUSH
99385: LD_VAR 0 11
99389: PPUSH
99390: LD_VAR 0 12
99394: PPUSH
99395: CALL_OW 272
99399: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
99400: LD_ADDR_VAR 0 10
99404: PUSH
99405: LD_VAR 0 3
99409: PPUSH
99410: LD_VAR 0 11
99414: PPUSH
99415: LD_VAR 0 12
99419: PPUSH
99420: CALL_OW 273
99424: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
99425: LD_VAR 0 9
99429: PPUSH
99430: LD_VAR 0 10
99434: PPUSH
99435: CALL_OW 488
99439: PUSH
99440: LD_VAR 0 9
99444: PUSH
99445: LD_VAR 0 10
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: PUSH
99454: LD_VAR 0 7
99458: IN
99459: NOT
99460: AND
99461: PUSH
99462: LD_VAR 0 9
99466: PPUSH
99467: LD_VAR 0 10
99471: PPUSH
99472: CALL_OW 458
99476: NOT
99477: AND
99478: IFFALSE 99520
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
99480: LD_ADDR_VAR 0 7
99484: PUSH
99485: LD_VAR 0 7
99489: PPUSH
99490: LD_VAR 0 7
99494: PUSH
99495: LD_INT 1
99497: PLUS
99498: PPUSH
99499: LD_VAR 0 9
99503: PUSH
99504: LD_VAR 0 10
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PPUSH
99513: CALL_OW 1
99517: ST_TO_ADDR
99518: GO 99534
// i := i - 1 ;
99520: LD_ADDR_VAR 0 5
99524: PUSH
99525: LD_VAR 0 5
99529: PUSH
99530: LD_INT 1
99532: MINUS
99533: ST_TO_ADDR
// end ;
99534: GO 99340
99536: POP
99537: POP
// for i in tmp do
99538: LD_ADDR_VAR 0 5
99542: PUSH
99543: LD_VAR 0 7
99547: PUSH
99548: FOR_IN
99549: IFFALSE 99587
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
99551: LD_VAR 0 1
99555: PPUSH
99556: LD_VAR 0 5
99560: PUSH
99561: LD_INT 1
99563: ARRAY
99564: PPUSH
99565: LD_VAR 0 5
99569: PUSH
99570: LD_INT 2
99572: ARRAY
99573: PPUSH
99574: CALL 98529 0 3
99578: NOT
99579: IFFALSE 99585
// exit ;
99581: POP
99582: POP
99583: GO 99589
99585: GO 99548
99587: POP
99588: POP
// end ;
99589: LD_VAR 0 4
99593: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
99594: LD_INT 0
99596: PPUSH
99597: PPUSH
99598: PPUSH
99599: PPUSH
99600: PPUSH
99601: PPUSH
99602: PPUSH
// if not GetClass ( unit ) = class_sniper then
99603: LD_VAR 0 1
99607: PPUSH
99608: CALL_OW 257
99612: PUSH
99613: LD_INT 5
99615: EQUAL
99616: NOT
99617: IFFALSE 99621
// exit ;
99619: GO 100009
// dist := 8 ;
99621: LD_ADDR_VAR 0 5
99625: PUSH
99626: LD_INT 8
99628: ST_TO_ADDR
// viewRange := 12 ;
99629: LD_ADDR_VAR 0 7
99633: PUSH
99634: LD_INT 12
99636: ST_TO_ADDR
// side := GetSide ( unit ) ;
99637: LD_ADDR_VAR 0 6
99641: PUSH
99642: LD_VAR 0 1
99646: PPUSH
99647: CALL_OW 255
99651: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
99652: LD_INT 61
99654: PPUSH
99655: LD_VAR 0 6
99659: PPUSH
99660: CALL_OW 321
99664: PUSH
99665: LD_INT 2
99667: EQUAL
99668: IFFALSE 99678
// viewRange := 16 ;
99670: LD_ADDR_VAR 0 7
99674: PUSH
99675: LD_INT 16
99677: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
99678: LD_VAR 0 1
99682: PPUSH
99683: LD_VAR 0 2
99687: PPUSH
99688: LD_VAR 0 3
99692: PPUSH
99693: CALL_OW 297
99697: PUSH
99698: LD_VAR 0 5
99702: GREATER
99703: IFFALSE 99782
// begin ComMoveXY ( unit , x , y ) ;
99705: LD_VAR 0 1
99709: PPUSH
99710: LD_VAR 0 2
99714: PPUSH
99715: LD_VAR 0 3
99719: PPUSH
99720: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
99724: LD_INT 35
99726: PPUSH
99727: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
99731: LD_VAR 0 1
99735: PPUSH
99736: LD_VAR 0 2
99740: PPUSH
99741: LD_VAR 0 3
99745: PPUSH
99746: CALL 49838 0 3
99750: NOT
99751: IFFALSE 99755
// exit ;
99753: GO 100009
// until GetDistUnitXY ( unit , x , y ) < dist ;
99755: LD_VAR 0 1
99759: PPUSH
99760: LD_VAR 0 2
99764: PPUSH
99765: LD_VAR 0 3
99769: PPUSH
99770: CALL_OW 297
99774: PUSH
99775: LD_VAR 0 5
99779: LESS
99780: IFFALSE 99724
// end ; ComTurnXY ( unit , x , y ) ;
99782: LD_VAR 0 1
99786: PPUSH
99787: LD_VAR 0 2
99791: PPUSH
99792: LD_VAR 0 3
99796: PPUSH
99797: CALL_OW 118
// wait ( 5 ) ;
99801: LD_INT 5
99803: PPUSH
99804: CALL_OW 67
// _d := GetDir ( unit ) ;
99808: LD_ADDR_VAR 0 10
99812: PUSH
99813: LD_VAR 0 1
99817: PPUSH
99818: CALL_OW 254
99822: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
99823: LD_ADDR_VAR 0 8
99827: PUSH
99828: LD_VAR 0 1
99832: PPUSH
99833: CALL_OW 250
99837: PPUSH
99838: LD_VAR 0 10
99842: PPUSH
99843: LD_VAR 0 5
99847: PPUSH
99848: CALL_OW 272
99852: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
99853: LD_ADDR_VAR 0 9
99857: PUSH
99858: LD_VAR 0 1
99862: PPUSH
99863: CALL_OW 251
99867: PPUSH
99868: LD_VAR 0 10
99872: PPUSH
99873: LD_VAR 0 5
99877: PPUSH
99878: CALL_OW 273
99882: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
99883: LD_VAR 0 8
99887: PPUSH
99888: LD_VAR 0 9
99892: PPUSH
99893: CALL_OW 488
99897: NOT
99898: IFFALSE 99902
// exit ;
99900: GO 100009
// ComAnimCustom ( unit , 1 ) ;
99902: LD_VAR 0 1
99906: PPUSH
99907: LD_INT 1
99909: PPUSH
99910: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
99914: LD_VAR 0 8
99918: PPUSH
99919: LD_VAR 0 9
99923: PPUSH
99924: LD_VAR 0 6
99928: PPUSH
99929: LD_VAR 0 7
99933: PPUSH
99934: CALL_OW 330
// repeat wait ( 1 ) ;
99938: LD_INT 1
99940: PPUSH
99941: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
99945: LD_VAR 0 1
99949: PPUSH
99950: CALL_OW 316
99954: PUSH
99955: LD_VAR 0 1
99959: PPUSH
99960: CALL_OW 314
99964: OR
99965: PUSH
99966: LD_VAR 0 1
99970: PPUSH
99971: CALL_OW 302
99975: NOT
99976: OR
99977: PUSH
99978: LD_VAR 0 1
99982: PPUSH
99983: CALL_OW 301
99987: OR
99988: IFFALSE 99938
// RemoveSeeing ( _x , _y , side ) ;
99990: LD_VAR 0 8
99994: PPUSH
99995: LD_VAR 0 9
99999: PPUSH
100000: LD_VAR 0 6
100004: PPUSH
100005: CALL_OW 331
// end ; end_of_file
100009: LD_VAR 0 4
100013: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100014: LD_INT 0
100016: PPUSH
100017: PPUSH
100018: PPUSH
100019: PPUSH
100020: PPUSH
100021: PPUSH
100022: PPUSH
100023: PPUSH
100024: PPUSH
100025: PPUSH
100026: PPUSH
100027: PPUSH
100028: PPUSH
100029: PPUSH
100030: PPUSH
100031: PPUSH
100032: PPUSH
100033: PPUSH
100034: PPUSH
100035: PPUSH
100036: PPUSH
100037: PPUSH
100038: PPUSH
100039: PPUSH
100040: PPUSH
100041: PPUSH
100042: PPUSH
100043: PPUSH
100044: PPUSH
100045: PPUSH
100046: PPUSH
100047: PPUSH
100048: PPUSH
100049: PPUSH
// if not list then
100050: LD_VAR 0 1
100054: NOT
100055: IFFALSE 100059
// exit ;
100057: GO 104718
// base := list [ 1 ] ;
100059: LD_ADDR_VAR 0 3
100063: PUSH
100064: LD_VAR 0 1
100068: PUSH
100069: LD_INT 1
100071: ARRAY
100072: ST_TO_ADDR
// group := list [ 2 ] ;
100073: LD_ADDR_VAR 0 4
100077: PUSH
100078: LD_VAR 0 1
100082: PUSH
100083: LD_INT 2
100085: ARRAY
100086: ST_TO_ADDR
// path := list [ 3 ] ;
100087: LD_ADDR_VAR 0 5
100091: PUSH
100092: LD_VAR 0 1
100096: PUSH
100097: LD_INT 3
100099: ARRAY
100100: ST_TO_ADDR
// flags := list [ 4 ] ;
100101: LD_ADDR_VAR 0 6
100105: PUSH
100106: LD_VAR 0 1
100110: PUSH
100111: LD_INT 4
100113: ARRAY
100114: ST_TO_ADDR
// mined := [ ] ;
100115: LD_ADDR_VAR 0 27
100119: PUSH
100120: EMPTY
100121: ST_TO_ADDR
// bombed := [ ] ;
100122: LD_ADDR_VAR 0 28
100126: PUSH
100127: EMPTY
100128: ST_TO_ADDR
// healers := [ ] ;
100129: LD_ADDR_VAR 0 31
100133: PUSH
100134: EMPTY
100135: ST_TO_ADDR
// to_heal := [ ] ;
100136: LD_ADDR_VAR 0 30
100140: PUSH
100141: EMPTY
100142: ST_TO_ADDR
// repairs := [ ] ;
100143: LD_ADDR_VAR 0 33
100147: PUSH
100148: EMPTY
100149: ST_TO_ADDR
// to_repair := [ ] ;
100150: LD_ADDR_VAR 0 32
100154: PUSH
100155: EMPTY
100156: ST_TO_ADDR
// if not group or not path then
100157: LD_VAR 0 4
100161: NOT
100162: PUSH
100163: LD_VAR 0 5
100167: NOT
100168: OR
100169: IFFALSE 100173
// exit ;
100171: GO 104718
// side := GetSide ( group [ 1 ] ) ;
100173: LD_ADDR_VAR 0 35
100177: PUSH
100178: LD_VAR 0 4
100182: PUSH
100183: LD_INT 1
100185: ARRAY
100186: PPUSH
100187: CALL_OW 255
100191: ST_TO_ADDR
// if flags then
100192: LD_VAR 0 6
100196: IFFALSE 100340
// begin f_ignore_area := flags [ 1 ] ;
100198: LD_ADDR_VAR 0 17
100202: PUSH
100203: LD_VAR 0 6
100207: PUSH
100208: LD_INT 1
100210: ARRAY
100211: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100212: LD_ADDR_VAR 0 18
100216: PUSH
100217: LD_VAR 0 6
100221: PUSH
100222: LD_INT 2
100224: ARRAY
100225: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100226: LD_ADDR_VAR 0 19
100230: PUSH
100231: LD_VAR 0 6
100235: PUSH
100236: LD_INT 3
100238: ARRAY
100239: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100240: LD_ADDR_VAR 0 20
100244: PUSH
100245: LD_VAR 0 6
100249: PUSH
100250: LD_INT 4
100252: ARRAY
100253: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100254: LD_ADDR_VAR 0 21
100258: PUSH
100259: LD_VAR 0 6
100263: PUSH
100264: LD_INT 5
100266: ARRAY
100267: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100268: LD_ADDR_VAR 0 22
100272: PUSH
100273: LD_VAR 0 6
100277: PUSH
100278: LD_INT 6
100280: ARRAY
100281: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100282: LD_ADDR_VAR 0 23
100286: PUSH
100287: LD_VAR 0 6
100291: PUSH
100292: LD_INT 7
100294: ARRAY
100295: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100296: LD_ADDR_VAR 0 24
100300: PUSH
100301: LD_VAR 0 6
100305: PUSH
100306: LD_INT 8
100308: ARRAY
100309: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100310: LD_ADDR_VAR 0 25
100314: PUSH
100315: LD_VAR 0 6
100319: PUSH
100320: LD_INT 9
100322: ARRAY
100323: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100324: LD_ADDR_VAR 0 26
100328: PUSH
100329: LD_VAR 0 6
100333: PUSH
100334: LD_INT 10
100336: ARRAY
100337: ST_TO_ADDR
// end else
100338: GO 100420
// begin f_ignore_area := false ;
100340: LD_ADDR_VAR 0 17
100344: PUSH
100345: LD_INT 0
100347: ST_TO_ADDR
// f_capture := false ;
100348: LD_ADDR_VAR 0 18
100352: PUSH
100353: LD_INT 0
100355: ST_TO_ADDR
// f_ignore_civ := false ;
100356: LD_ADDR_VAR 0 19
100360: PUSH
100361: LD_INT 0
100363: ST_TO_ADDR
// f_murder := false ;
100364: LD_ADDR_VAR 0 20
100368: PUSH
100369: LD_INT 0
100371: ST_TO_ADDR
// f_mines := false ;
100372: LD_ADDR_VAR 0 21
100376: PUSH
100377: LD_INT 0
100379: ST_TO_ADDR
// f_repair := false ;
100380: LD_ADDR_VAR 0 22
100384: PUSH
100385: LD_INT 0
100387: ST_TO_ADDR
// f_heal := false ;
100388: LD_ADDR_VAR 0 23
100392: PUSH
100393: LD_INT 0
100395: ST_TO_ADDR
// f_spacetime := false ;
100396: LD_ADDR_VAR 0 24
100400: PUSH
100401: LD_INT 0
100403: ST_TO_ADDR
// f_attack_depot := false ;
100404: LD_ADDR_VAR 0 25
100408: PUSH
100409: LD_INT 0
100411: ST_TO_ADDR
// f_crawl := false ;
100412: LD_ADDR_VAR 0 26
100416: PUSH
100417: LD_INT 0
100419: ST_TO_ADDR
// end ; if f_heal then
100420: LD_VAR 0 23
100424: IFFALSE 100451
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100426: LD_ADDR_VAR 0 31
100430: PUSH
100431: LD_VAR 0 4
100435: PPUSH
100436: LD_INT 25
100438: PUSH
100439: LD_INT 4
100441: PUSH
100442: EMPTY
100443: LIST
100444: LIST
100445: PPUSH
100446: CALL_OW 72
100450: ST_TO_ADDR
// if f_repair then
100451: LD_VAR 0 22
100455: IFFALSE 100482
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100457: LD_ADDR_VAR 0 33
100461: PUSH
100462: LD_VAR 0 4
100466: PPUSH
100467: LD_INT 25
100469: PUSH
100470: LD_INT 3
100472: PUSH
100473: EMPTY
100474: LIST
100475: LIST
100476: PPUSH
100477: CALL_OW 72
100481: ST_TO_ADDR
// units_path := [ ] ;
100482: LD_ADDR_VAR 0 16
100486: PUSH
100487: EMPTY
100488: ST_TO_ADDR
// for i = 1 to group do
100489: LD_ADDR_VAR 0 7
100493: PUSH
100494: DOUBLE
100495: LD_INT 1
100497: DEC
100498: ST_TO_ADDR
100499: LD_VAR 0 4
100503: PUSH
100504: FOR_TO
100505: IFFALSE 100534
// units_path := Replace ( units_path , i , path ) ;
100507: LD_ADDR_VAR 0 16
100511: PUSH
100512: LD_VAR 0 16
100516: PPUSH
100517: LD_VAR 0 7
100521: PPUSH
100522: LD_VAR 0 5
100526: PPUSH
100527: CALL_OW 1
100531: ST_TO_ADDR
100532: GO 100504
100534: POP
100535: POP
// repeat for i = group downto 1 do
100536: LD_ADDR_VAR 0 7
100540: PUSH
100541: DOUBLE
100542: LD_VAR 0 4
100546: INC
100547: ST_TO_ADDR
100548: LD_INT 1
100550: PUSH
100551: FOR_DOWNTO
100552: IFFALSE 104674
// begin wait ( 5 ) ;
100554: LD_INT 5
100556: PPUSH
100557: CALL_OW 67
// tmp := [ ] ;
100561: LD_ADDR_VAR 0 14
100565: PUSH
100566: EMPTY
100567: ST_TO_ADDR
// attacking := false ;
100568: LD_ADDR_VAR 0 29
100572: PUSH
100573: LD_INT 0
100575: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100576: LD_VAR 0 4
100580: PUSH
100581: LD_VAR 0 7
100585: ARRAY
100586: PPUSH
100587: CALL_OW 301
100591: PUSH
100592: LD_VAR 0 4
100596: PUSH
100597: LD_VAR 0 7
100601: ARRAY
100602: NOT
100603: OR
100604: IFFALSE 100713
// begin if GetType ( group [ i ] ) = unit_human then
100606: LD_VAR 0 4
100610: PUSH
100611: LD_VAR 0 7
100615: ARRAY
100616: PPUSH
100617: CALL_OW 247
100621: PUSH
100622: LD_INT 1
100624: EQUAL
100625: IFFALSE 100671
// begin to_heal := to_heal diff group [ i ] ;
100627: LD_ADDR_VAR 0 30
100631: PUSH
100632: LD_VAR 0 30
100636: PUSH
100637: LD_VAR 0 4
100641: PUSH
100642: LD_VAR 0 7
100646: ARRAY
100647: DIFF
100648: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100649: LD_ADDR_VAR 0 31
100653: PUSH
100654: LD_VAR 0 31
100658: PUSH
100659: LD_VAR 0 4
100663: PUSH
100664: LD_VAR 0 7
100668: ARRAY
100669: DIFF
100670: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100671: LD_ADDR_VAR 0 4
100675: PUSH
100676: LD_VAR 0 4
100680: PPUSH
100681: LD_VAR 0 7
100685: PPUSH
100686: CALL_OW 3
100690: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100691: LD_ADDR_VAR 0 16
100695: PUSH
100696: LD_VAR 0 16
100700: PPUSH
100701: LD_VAR 0 7
100705: PPUSH
100706: CALL_OW 3
100710: ST_TO_ADDR
// continue ;
100711: GO 100551
// end ; if f_repair then
100713: LD_VAR 0 22
100717: IFFALSE 101206
// begin if GetType ( group [ i ] ) = unit_vehicle then
100719: LD_VAR 0 4
100723: PUSH
100724: LD_VAR 0 7
100728: ARRAY
100729: PPUSH
100730: CALL_OW 247
100734: PUSH
100735: LD_INT 2
100737: EQUAL
100738: IFFALSE 100928
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100740: LD_VAR 0 4
100744: PUSH
100745: LD_VAR 0 7
100749: ARRAY
100750: PPUSH
100751: CALL_OW 256
100755: PUSH
100756: LD_INT 700
100758: LESS
100759: PUSH
100760: LD_VAR 0 4
100764: PUSH
100765: LD_VAR 0 7
100769: ARRAY
100770: PUSH
100771: LD_VAR 0 32
100775: IN
100776: NOT
100777: AND
100778: IFFALSE 100802
// to_repair := to_repair union group [ i ] ;
100780: LD_ADDR_VAR 0 32
100784: PUSH
100785: LD_VAR 0 32
100789: PUSH
100790: LD_VAR 0 4
100794: PUSH
100795: LD_VAR 0 7
100799: ARRAY
100800: UNION
100801: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100802: LD_VAR 0 4
100806: PUSH
100807: LD_VAR 0 7
100811: ARRAY
100812: PPUSH
100813: CALL_OW 256
100817: PUSH
100818: LD_INT 1000
100820: EQUAL
100821: PUSH
100822: LD_VAR 0 4
100826: PUSH
100827: LD_VAR 0 7
100831: ARRAY
100832: PUSH
100833: LD_VAR 0 32
100837: IN
100838: AND
100839: IFFALSE 100863
// to_repair := to_repair diff group [ i ] ;
100841: LD_ADDR_VAR 0 32
100845: PUSH
100846: LD_VAR 0 32
100850: PUSH
100851: LD_VAR 0 4
100855: PUSH
100856: LD_VAR 0 7
100860: ARRAY
100861: DIFF
100862: ST_TO_ADDR
// if group [ i ] in to_repair then
100863: LD_VAR 0 4
100867: PUSH
100868: LD_VAR 0 7
100872: ARRAY
100873: PUSH
100874: LD_VAR 0 32
100878: IN
100879: IFFALSE 100926
// begin if not IsInArea ( group [ i ] , f_repair ) then
100881: LD_VAR 0 4
100885: PUSH
100886: LD_VAR 0 7
100890: ARRAY
100891: PPUSH
100892: LD_VAR 0 22
100896: PPUSH
100897: CALL_OW 308
100901: NOT
100902: IFFALSE 100924
// ComMoveToArea ( group [ i ] , f_repair ) ;
100904: LD_VAR 0 4
100908: PUSH
100909: LD_VAR 0 7
100913: ARRAY
100914: PPUSH
100915: LD_VAR 0 22
100919: PPUSH
100920: CALL_OW 113
// continue ;
100924: GO 100551
// end ; end else
100926: GO 101206
// if group [ i ] in repairs then
100928: LD_VAR 0 4
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PUSH
100939: LD_VAR 0 33
100943: IN
100944: IFFALSE 101206
// begin if IsInUnit ( group [ i ] ) then
100946: LD_VAR 0 4
100950: PUSH
100951: LD_VAR 0 7
100955: ARRAY
100956: PPUSH
100957: CALL_OW 310
100961: IFFALSE 101029
// begin z := IsInUnit ( group [ i ] ) ;
100963: LD_ADDR_VAR 0 13
100967: PUSH
100968: LD_VAR 0 4
100972: PUSH
100973: LD_VAR 0 7
100977: ARRAY
100978: PPUSH
100979: CALL_OW 310
100983: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100984: LD_VAR 0 13
100988: PUSH
100989: LD_VAR 0 32
100993: IN
100994: PUSH
100995: LD_VAR 0 13
100999: PPUSH
101000: LD_VAR 0 22
101004: PPUSH
101005: CALL_OW 308
101009: AND
101010: IFFALSE 101027
// ComExitVehicle ( group [ i ] ) ;
101012: LD_VAR 0 4
101016: PUSH
101017: LD_VAR 0 7
101021: ARRAY
101022: PPUSH
101023: CALL_OW 121
// end else
101027: GO 101206
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101029: LD_ADDR_VAR 0 13
101033: PUSH
101034: LD_VAR 0 4
101038: PPUSH
101039: LD_INT 95
101041: PUSH
101042: LD_VAR 0 22
101046: PUSH
101047: EMPTY
101048: LIST
101049: LIST
101050: PUSH
101051: LD_INT 58
101053: PUSH
101054: EMPTY
101055: LIST
101056: PUSH
101057: EMPTY
101058: LIST
101059: LIST
101060: PPUSH
101061: CALL_OW 72
101065: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101066: LD_VAR 0 4
101070: PUSH
101071: LD_VAR 0 7
101075: ARRAY
101076: PPUSH
101077: CALL_OW 314
101081: NOT
101082: IFFALSE 101204
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101084: LD_ADDR_VAR 0 10
101088: PUSH
101089: LD_VAR 0 13
101093: PPUSH
101094: LD_VAR 0 4
101098: PUSH
101099: LD_VAR 0 7
101103: ARRAY
101104: PPUSH
101105: CALL_OW 74
101109: ST_TO_ADDR
// if not x then
101110: LD_VAR 0 10
101114: NOT
101115: IFFALSE 101119
// continue ;
101117: GO 100551
// if GetLives ( x ) < 1000 then
101119: LD_VAR 0 10
101123: PPUSH
101124: CALL_OW 256
101128: PUSH
101129: LD_INT 1000
101131: LESS
101132: IFFALSE 101156
// ComRepairVehicle ( group [ i ] , x ) else
101134: LD_VAR 0 4
101138: PUSH
101139: LD_VAR 0 7
101143: ARRAY
101144: PPUSH
101145: LD_VAR 0 10
101149: PPUSH
101150: CALL_OW 129
101154: GO 101204
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101156: LD_VAR 0 23
101160: PUSH
101161: LD_VAR 0 4
101165: PUSH
101166: LD_VAR 0 7
101170: ARRAY
101171: PPUSH
101172: CALL_OW 256
101176: PUSH
101177: LD_INT 1000
101179: LESS
101180: AND
101181: NOT
101182: IFFALSE 101204
// ComEnterUnit ( group [ i ] , x ) ;
101184: LD_VAR 0 4
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PPUSH
101195: LD_VAR 0 10
101199: PPUSH
101200: CALL_OW 120
// end ; continue ;
101204: GO 100551
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101206: LD_VAR 0 23
101210: PUSH
101211: LD_VAR 0 4
101215: PUSH
101216: LD_VAR 0 7
101220: ARRAY
101221: PPUSH
101222: CALL_OW 247
101226: PUSH
101227: LD_INT 1
101229: EQUAL
101230: AND
101231: IFFALSE 101709
// begin if group [ i ] in healers then
101233: LD_VAR 0 4
101237: PUSH
101238: LD_VAR 0 7
101242: ARRAY
101243: PUSH
101244: LD_VAR 0 31
101248: IN
101249: IFFALSE 101522
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101251: LD_VAR 0 4
101255: PUSH
101256: LD_VAR 0 7
101260: ARRAY
101261: PPUSH
101262: LD_VAR 0 23
101266: PPUSH
101267: CALL_OW 308
101271: NOT
101272: PUSH
101273: LD_VAR 0 4
101277: PUSH
101278: LD_VAR 0 7
101282: ARRAY
101283: PPUSH
101284: CALL_OW 314
101288: NOT
101289: AND
101290: IFFALSE 101314
// ComMoveToArea ( group [ i ] , f_heal ) else
101292: LD_VAR 0 4
101296: PUSH
101297: LD_VAR 0 7
101301: ARRAY
101302: PPUSH
101303: LD_VAR 0 23
101307: PPUSH
101308: CALL_OW 113
101312: GO 101520
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101314: LD_VAR 0 4
101318: PUSH
101319: LD_VAR 0 7
101323: ARRAY
101324: PPUSH
101325: CALL 48361 0 1
101329: PPUSH
101330: CALL_OW 256
101334: PUSH
101335: LD_INT 1000
101337: EQUAL
101338: IFFALSE 101357
// ComStop ( group [ i ] ) else
101340: LD_VAR 0 4
101344: PUSH
101345: LD_VAR 0 7
101349: ARRAY
101350: PPUSH
101351: CALL_OW 141
101355: GO 101520
// if not HasTask ( group [ i ] ) and to_heal then
101357: LD_VAR 0 4
101361: PUSH
101362: LD_VAR 0 7
101366: ARRAY
101367: PPUSH
101368: CALL_OW 314
101372: NOT
101373: PUSH
101374: LD_VAR 0 30
101378: AND
101379: IFFALSE 101520
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101381: LD_ADDR_VAR 0 13
101385: PUSH
101386: LD_VAR 0 30
101390: PPUSH
101391: LD_INT 3
101393: PUSH
101394: LD_INT 54
101396: PUSH
101397: EMPTY
101398: LIST
101399: PUSH
101400: EMPTY
101401: LIST
101402: LIST
101403: PPUSH
101404: CALL_OW 72
101408: PPUSH
101409: LD_VAR 0 4
101413: PUSH
101414: LD_VAR 0 7
101418: ARRAY
101419: PPUSH
101420: CALL_OW 74
101424: ST_TO_ADDR
// if z then
101425: LD_VAR 0 13
101429: IFFALSE 101520
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101431: LD_INT 91
101433: PUSH
101434: LD_VAR 0 13
101438: PUSH
101439: LD_INT 10
101441: PUSH
101442: EMPTY
101443: LIST
101444: LIST
101445: LIST
101446: PUSH
101447: LD_INT 81
101449: PUSH
101450: LD_VAR 0 13
101454: PPUSH
101455: CALL_OW 255
101459: PUSH
101460: EMPTY
101461: LIST
101462: LIST
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PPUSH
101468: CALL_OW 69
101472: PUSH
101473: LD_INT 0
101475: EQUAL
101476: IFFALSE 101500
// ComHeal ( group [ i ] , z ) else
101478: LD_VAR 0 4
101482: PUSH
101483: LD_VAR 0 7
101487: ARRAY
101488: PPUSH
101489: LD_VAR 0 13
101493: PPUSH
101494: CALL_OW 128
101498: GO 101520
// ComMoveToArea ( group [ i ] , f_heal ) ;
101500: LD_VAR 0 4
101504: PUSH
101505: LD_VAR 0 7
101509: ARRAY
101510: PPUSH
101511: LD_VAR 0 23
101515: PPUSH
101516: CALL_OW 113
// end ; continue ;
101520: GO 100551
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101522: LD_VAR 0 4
101526: PUSH
101527: LD_VAR 0 7
101531: ARRAY
101532: PPUSH
101533: CALL_OW 256
101537: PUSH
101538: LD_INT 700
101540: LESS
101541: PUSH
101542: LD_VAR 0 4
101546: PUSH
101547: LD_VAR 0 7
101551: ARRAY
101552: PUSH
101553: LD_VAR 0 30
101557: IN
101558: NOT
101559: AND
101560: IFFALSE 101584
// to_heal := to_heal union group [ i ] ;
101562: LD_ADDR_VAR 0 30
101566: PUSH
101567: LD_VAR 0 30
101571: PUSH
101572: LD_VAR 0 4
101576: PUSH
101577: LD_VAR 0 7
101581: ARRAY
101582: UNION
101583: ST_TO_ADDR
// if group [ i ] in to_heal then
101584: LD_VAR 0 4
101588: PUSH
101589: LD_VAR 0 7
101593: ARRAY
101594: PUSH
101595: LD_VAR 0 30
101599: IN
101600: IFFALSE 101709
// begin if GetLives ( group [ i ] ) = 1000 then
101602: LD_VAR 0 4
101606: PUSH
101607: LD_VAR 0 7
101611: ARRAY
101612: PPUSH
101613: CALL_OW 256
101617: PUSH
101618: LD_INT 1000
101620: EQUAL
101621: IFFALSE 101647
// to_heal := to_heal diff group [ i ] else
101623: LD_ADDR_VAR 0 30
101627: PUSH
101628: LD_VAR 0 30
101632: PUSH
101633: LD_VAR 0 4
101637: PUSH
101638: LD_VAR 0 7
101642: ARRAY
101643: DIFF
101644: ST_TO_ADDR
101645: GO 101709
// begin if not IsInArea ( group [ i ] , to_heal ) then
101647: LD_VAR 0 4
101651: PUSH
101652: LD_VAR 0 7
101656: ARRAY
101657: PPUSH
101658: LD_VAR 0 30
101662: PPUSH
101663: CALL_OW 308
101667: NOT
101668: IFFALSE 101692
// ComMoveToArea ( group [ i ] , f_heal ) else
101670: LD_VAR 0 4
101674: PUSH
101675: LD_VAR 0 7
101679: ARRAY
101680: PPUSH
101681: LD_VAR 0 23
101685: PPUSH
101686: CALL_OW 113
101690: GO 101707
// ComHold ( group [ i ] ) ;
101692: LD_VAR 0 4
101696: PUSH
101697: LD_VAR 0 7
101701: ARRAY
101702: PPUSH
101703: CALL_OW 140
// continue ;
101707: GO 100551
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101709: LD_VAR 0 4
101713: PUSH
101714: LD_VAR 0 7
101718: ARRAY
101719: PPUSH
101720: LD_INT 10
101722: PPUSH
101723: CALL 46781 0 2
101727: NOT
101728: PUSH
101729: LD_VAR 0 16
101733: PUSH
101734: LD_VAR 0 7
101738: ARRAY
101739: PUSH
101740: EMPTY
101741: EQUAL
101742: NOT
101743: AND
101744: IFFALSE 102010
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101746: LD_VAR 0 4
101750: PUSH
101751: LD_VAR 0 7
101755: ARRAY
101756: PPUSH
101757: CALL_OW 262
101761: PUSH
101762: LD_INT 1
101764: PUSH
101765: LD_INT 2
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: IN
101772: IFFALSE 101813
// if GetFuel ( group [ i ] ) < 10 then
101774: LD_VAR 0 4
101778: PUSH
101779: LD_VAR 0 7
101783: ARRAY
101784: PPUSH
101785: CALL_OW 261
101789: PUSH
101790: LD_INT 10
101792: LESS
101793: IFFALSE 101813
// SetFuel ( group [ i ] , 12 ) ;
101795: LD_VAR 0 4
101799: PUSH
101800: LD_VAR 0 7
101804: ARRAY
101805: PPUSH
101806: LD_INT 12
101808: PPUSH
101809: CALL_OW 240
// if units_path [ i ] then
101813: LD_VAR 0 16
101817: PUSH
101818: LD_VAR 0 7
101822: ARRAY
101823: IFFALSE 102008
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101825: LD_VAR 0 4
101829: PUSH
101830: LD_VAR 0 7
101834: ARRAY
101835: PPUSH
101836: LD_VAR 0 16
101840: PUSH
101841: LD_VAR 0 7
101845: ARRAY
101846: PUSH
101847: LD_INT 1
101849: ARRAY
101850: PUSH
101851: LD_INT 1
101853: ARRAY
101854: PPUSH
101855: LD_VAR 0 16
101859: PUSH
101860: LD_VAR 0 7
101864: ARRAY
101865: PUSH
101866: LD_INT 1
101868: ARRAY
101869: PUSH
101870: LD_INT 2
101872: ARRAY
101873: PPUSH
101874: CALL_OW 297
101878: PUSH
101879: LD_INT 6
101881: GREATER
101882: IFFALSE 101957
// begin if not HasTask ( group [ i ] ) then
101884: LD_VAR 0 4
101888: PUSH
101889: LD_VAR 0 7
101893: ARRAY
101894: PPUSH
101895: CALL_OW 314
101899: NOT
101900: IFFALSE 101955
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101902: LD_VAR 0 4
101906: PUSH
101907: LD_VAR 0 7
101911: ARRAY
101912: PPUSH
101913: LD_VAR 0 16
101917: PUSH
101918: LD_VAR 0 7
101922: ARRAY
101923: PUSH
101924: LD_INT 1
101926: ARRAY
101927: PUSH
101928: LD_INT 1
101930: ARRAY
101931: PPUSH
101932: LD_VAR 0 16
101936: PUSH
101937: LD_VAR 0 7
101941: ARRAY
101942: PUSH
101943: LD_INT 1
101945: ARRAY
101946: PUSH
101947: LD_INT 2
101949: ARRAY
101950: PPUSH
101951: CALL_OW 114
// end else
101955: GO 102008
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101957: LD_ADDR_VAR 0 15
101961: PUSH
101962: LD_VAR 0 16
101966: PUSH
101967: LD_VAR 0 7
101971: ARRAY
101972: PPUSH
101973: LD_INT 1
101975: PPUSH
101976: CALL_OW 3
101980: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101981: LD_ADDR_VAR 0 16
101985: PUSH
101986: LD_VAR 0 16
101990: PPUSH
101991: LD_VAR 0 7
101995: PPUSH
101996: LD_VAR 0 15
102000: PPUSH
102001: CALL_OW 1
102005: ST_TO_ADDR
// continue ;
102006: GO 100551
// end ; end ; end else
102008: GO 104672
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102010: LD_ADDR_VAR 0 14
102014: PUSH
102015: LD_INT 81
102017: PUSH
102018: LD_VAR 0 4
102022: PUSH
102023: LD_VAR 0 7
102027: ARRAY
102028: PPUSH
102029: CALL_OW 255
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: PPUSH
102038: CALL_OW 69
102042: ST_TO_ADDR
// if not tmp then
102043: LD_VAR 0 14
102047: NOT
102048: IFFALSE 102052
// continue ;
102050: GO 100551
// if f_ignore_area then
102052: LD_VAR 0 17
102056: IFFALSE 102144
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102058: LD_ADDR_VAR 0 15
102062: PUSH
102063: LD_VAR 0 14
102067: PPUSH
102068: LD_INT 3
102070: PUSH
102071: LD_INT 92
102073: PUSH
102074: LD_VAR 0 17
102078: PUSH
102079: LD_INT 1
102081: ARRAY
102082: PUSH
102083: LD_VAR 0 17
102087: PUSH
102088: LD_INT 2
102090: ARRAY
102091: PUSH
102092: LD_VAR 0 17
102096: PUSH
102097: LD_INT 3
102099: ARRAY
102100: PUSH
102101: EMPTY
102102: LIST
102103: LIST
102104: LIST
102105: LIST
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PPUSH
102111: CALL_OW 72
102115: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102116: LD_VAR 0 14
102120: PUSH
102121: LD_VAR 0 15
102125: DIFF
102126: IFFALSE 102144
// tmp := tmp diff tmp2 ;
102128: LD_ADDR_VAR 0 14
102132: PUSH
102133: LD_VAR 0 14
102137: PUSH
102138: LD_VAR 0 15
102142: DIFF
102143: ST_TO_ADDR
// end ; if not f_murder then
102144: LD_VAR 0 20
102148: NOT
102149: IFFALSE 102207
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102151: LD_ADDR_VAR 0 15
102155: PUSH
102156: LD_VAR 0 14
102160: PPUSH
102161: LD_INT 3
102163: PUSH
102164: LD_INT 50
102166: PUSH
102167: EMPTY
102168: LIST
102169: PUSH
102170: EMPTY
102171: LIST
102172: LIST
102173: PPUSH
102174: CALL_OW 72
102178: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102179: LD_VAR 0 14
102183: PUSH
102184: LD_VAR 0 15
102188: DIFF
102189: IFFALSE 102207
// tmp := tmp diff tmp2 ;
102191: LD_ADDR_VAR 0 14
102195: PUSH
102196: LD_VAR 0 14
102200: PUSH
102201: LD_VAR 0 15
102205: DIFF
102206: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102207: LD_ADDR_VAR 0 14
102211: PUSH
102212: LD_VAR 0 4
102216: PUSH
102217: LD_VAR 0 7
102221: ARRAY
102222: PPUSH
102223: LD_VAR 0 14
102227: PPUSH
102228: LD_INT 1
102230: PPUSH
102231: LD_INT 1
102233: PPUSH
102234: CALL 20121 0 4
102238: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102239: LD_VAR 0 4
102243: PUSH
102244: LD_VAR 0 7
102248: ARRAY
102249: PPUSH
102250: CALL_OW 257
102254: PUSH
102255: LD_INT 1
102257: EQUAL
102258: IFFALSE 102706
// begin if WantPlant ( group [ i ] ) then
102260: LD_VAR 0 4
102264: PUSH
102265: LD_VAR 0 7
102269: ARRAY
102270: PPUSH
102271: CALL 19622 0 1
102275: IFFALSE 102279
// continue ;
102277: GO 100551
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102279: LD_VAR 0 18
102283: PUSH
102284: LD_VAR 0 4
102288: PUSH
102289: LD_VAR 0 7
102293: ARRAY
102294: PPUSH
102295: CALL_OW 310
102299: NOT
102300: AND
102301: PUSH
102302: LD_VAR 0 14
102306: PUSH
102307: LD_INT 1
102309: ARRAY
102310: PUSH
102311: LD_VAR 0 14
102315: PPUSH
102316: LD_INT 21
102318: PUSH
102319: LD_INT 2
102321: PUSH
102322: EMPTY
102323: LIST
102324: LIST
102325: PUSH
102326: LD_INT 58
102328: PUSH
102329: EMPTY
102330: LIST
102331: PUSH
102332: EMPTY
102333: LIST
102334: LIST
102335: PPUSH
102336: CALL_OW 72
102340: IN
102341: AND
102342: IFFALSE 102378
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102344: LD_VAR 0 4
102348: PUSH
102349: LD_VAR 0 7
102353: ARRAY
102354: PPUSH
102355: LD_VAR 0 14
102359: PUSH
102360: LD_INT 1
102362: ARRAY
102363: PPUSH
102364: CALL_OW 120
// attacking := true ;
102368: LD_ADDR_VAR 0 29
102372: PUSH
102373: LD_INT 1
102375: ST_TO_ADDR
// continue ;
102376: GO 100551
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102378: LD_VAR 0 26
102382: PUSH
102383: LD_VAR 0 4
102387: PUSH
102388: LD_VAR 0 7
102392: ARRAY
102393: PPUSH
102394: CALL_OW 257
102398: PUSH
102399: LD_INT 1
102401: EQUAL
102402: AND
102403: PUSH
102404: LD_VAR 0 4
102408: PUSH
102409: LD_VAR 0 7
102413: ARRAY
102414: PPUSH
102415: CALL_OW 256
102419: PUSH
102420: LD_INT 800
102422: LESS
102423: AND
102424: PUSH
102425: LD_VAR 0 4
102429: PUSH
102430: LD_VAR 0 7
102434: ARRAY
102435: PPUSH
102436: CALL_OW 318
102440: NOT
102441: AND
102442: IFFALSE 102459
// ComCrawl ( group [ i ] ) ;
102444: LD_VAR 0 4
102448: PUSH
102449: LD_VAR 0 7
102453: ARRAY
102454: PPUSH
102455: CALL_OW 137
// if f_mines then
102459: LD_VAR 0 21
102463: IFFALSE 102706
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102465: LD_VAR 0 14
102469: PUSH
102470: LD_INT 1
102472: ARRAY
102473: PPUSH
102474: CALL_OW 247
102478: PUSH
102479: LD_INT 3
102481: EQUAL
102482: PUSH
102483: LD_VAR 0 14
102487: PUSH
102488: LD_INT 1
102490: ARRAY
102491: PUSH
102492: LD_VAR 0 27
102496: IN
102497: NOT
102498: AND
102499: IFFALSE 102706
// begin x := GetX ( tmp [ 1 ] ) ;
102501: LD_ADDR_VAR 0 10
102505: PUSH
102506: LD_VAR 0 14
102510: PUSH
102511: LD_INT 1
102513: ARRAY
102514: PPUSH
102515: CALL_OW 250
102519: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102520: LD_ADDR_VAR 0 11
102524: PUSH
102525: LD_VAR 0 14
102529: PUSH
102530: LD_INT 1
102532: ARRAY
102533: PPUSH
102534: CALL_OW 251
102538: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102539: LD_ADDR_VAR 0 12
102543: PUSH
102544: LD_VAR 0 4
102548: PUSH
102549: LD_VAR 0 7
102553: ARRAY
102554: PPUSH
102555: CALL 46866 0 1
102559: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102560: LD_VAR 0 4
102564: PUSH
102565: LD_VAR 0 7
102569: ARRAY
102570: PPUSH
102571: LD_VAR 0 10
102575: PPUSH
102576: LD_VAR 0 11
102580: PPUSH
102581: LD_VAR 0 14
102585: PUSH
102586: LD_INT 1
102588: ARRAY
102589: PPUSH
102590: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102594: LD_VAR 0 4
102598: PUSH
102599: LD_VAR 0 7
102603: ARRAY
102604: PPUSH
102605: LD_VAR 0 10
102609: PPUSH
102610: LD_VAR 0 12
102614: PPUSH
102615: LD_INT 7
102617: PPUSH
102618: CALL_OW 272
102622: PPUSH
102623: LD_VAR 0 11
102627: PPUSH
102628: LD_VAR 0 12
102632: PPUSH
102633: LD_INT 7
102635: PPUSH
102636: CALL_OW 273
102640: PPUSH
102641: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102645: LD_VAR 0 4
102649: PUSH
102650: LD_VAR 0 7
102654: ARRAY
102655: PPUSH
102656: LD_INT 71
102658: PPUSH
102659: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102663: LD_ADDR_VAR 0 27
102667: PUSH
102668: LD_VAR 0 27
102672: PPUSH
102673: LD_VAR 0 27
102677: PUSH
102678: LD_INT 1
102680: PLUS
102681: PPUSH
102682: LD_VAR 0 14
102686: PUSH
102687: LD_INT 1
102689: ARRAY
102690: PPUSH
102691: CALL_OW 1
102695: ST_TO_ADDR
// attacking := true ;
102696: LD_ADDR_VAR 0 29
102700: PUSH
102701: LD_INT 1
102703: ST_TO_ADDR
// continue ;
102704: GO 100551
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102706: LD_VAR 0 4
102710: PUSH
102711: LD_VAR 0 7
102715: ARRAY
102716: PPUSH
102717: CALL_OW 257
102721: PUSH
102722: LD_INT 17
102724: EQUAL
102725: PUSH
102726: LD_VAR 0 4
102730: PUSH
102731: LD_VAR 0 7
102735: ARRAY
102736: PPUSH
102737: CALL_OW 110
102741: PUSH
102742: LD_INT 71
102744: EQUAL
102745: NOT
102746: AND
102747: IFFALSE 102893
// begin attacking := false ;
102749: LD_ADDR_VAR 0 29
102753: PUSH
102754: LD_INT 0
102756: ST_TO_ADDR
// k := 5 ;
102757: LD_ADDR_VAR 0 9
102761: PUSH
102762: LD_INT 5
102764: ST_TO_ADDR
// if tmp < k then
102765: LD_VAR 0 14
102769: PUSH
102770: LD_VAR 0 9
102774: LESS
102775: IFFALSE 102787
// k := tmp ;
102777: LD_ADDR_VAR 0 9
102781: PUSH
102782: LD_VAR 0 14
102786: ST_TO_ADDR
// for j = 1 to k do
102787: LD_ADDR_VAR 0 8
102791: PUSH
102792: DOUBLE
102793: LD_INT 1
102795: DEC
102796: ST_TO_ADDR
102797: LD_VAR 0 9
102801: PUSH
102802: FOR_TO
102803: IFFALSE 102891
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102805: LD_VAR 0 14
102809: PUSH
102810: LD_VAR 0 8
102814: ARRAY
102815: PUSH
102816: LD_VAR 0 14
102820: PPUSH
102821: LD_INT 58
102823: PUSH
102824: EMPTY
102825: LIST
102826: PPUSH
102827: CALL_OW 72
102831: IN
102832: NOT
102833: IFFALSE 102889
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102835: LD_VAR 0 4
102839: PUSH
102840: LD_VAR 0 7
102844: ARRAY
102845: PPUSH
102846: LD_VAR 0 14
102850: PUSH
102851: LD_VAR 0 8
102855: ARRAY
102856: PPUSH
102857: CALL_OW 115
// attacking := true ;
102861: LD_ADDR_VAR 0 29
102865: PUSH
102866: LD_INT 1
102868: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102869: LD_VAR 0 4
102873: PUSH
102874: LD_VAR 0 7
102878: ARRAY
102879: PPUSH
102880: LD_INT 71
102882: PPUSH
102883: CALL_OW 109
// continue ;
102887: GO 102802
// end ; end ;
102889: GO 102802
102891: POP
102892: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102893: LD_VAR 0 4
102897: PUSH
102898: LD_VAR 0 7
102902: ARRAY
102903: PPUSH
102904: CALL_OW 257
102908: PUSH
102909: LD_INT 8
102911: EQUAL
102912: PUSH
102913: LD_VAR 0 4
102917: PUSH
102918: LD_VAR 0 7
102922: ARRAY
102923: PPUSH
102924: CALL_OW 264
102928: PUSH
102929: LD_INT 28
102931: PUSH
102932: LD_INT 45
102934: PUSH
102935: LD_INT 7
102937: PUSH
102938: LD_INT 47
102940: PUSH
102941: EMPTY
102942: LIST
102943: LIST
102944: LIST
102945: LIST
102946: IN
102947: OR
102948: IFFALSE 103204
// begin attacking := false ;
102950: LD_ADDR_VAR 0 29
102954: PUSH
102955: LD_INT 0
102957: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102958: LD_VAR 0 14
102962: PUSH
102963: LD_INT 1
102965: ARRAY
102966: PPUSH
102967: CALL_OW 266
102971: PUSH
102972: LD_INT 32
102974: PUSH
102975: LD_INT 31
102977: PUSH
102978: LD_INT 33
102980: PUSH
102981: LD_INT 4
102983: PUSH
102984: LD_INT 5
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: LIST
102991: LIST
102992: LIST
102993: IN
102994: IFFALSE 103180
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102996: LD_ADDR_VAR 0 9
103000: PUSH
103001: LD_VAR 0 14
103005: PUSH
103006: LD_INT 1
103008: ARRAY
103009: PPUSH
103010: CALL_OW 266
103014: PPUSH
103015: LD_VAR 0 14
103019: PUSH
103020: LD_INT 1
103022: ARRAY
103023: PPUSH
103024: CALL_OW 250
103028: PPUSH
103029: LD_VAR 0 14
103033: PUSH
103034: LD_INT 1
103036: ARRAY
103037: PPUSH
103038: CALL_OW 251
103042: PPUSH
103043: LD_VAR 0 14
103047: PUSH
103048: LD_INT 1
103050: ARRAY
103051: PPUSH
103052: CALL_OW 254
103056: PPUSH
103057: LD_VAR 0 14
103061: PUSH
103062: LD_INT 1
103064: ARRAY
103065: PPUSH
103066: CALL_OW 248
103070: PPUSH
103071: LD_INT 0
103073: PPUSH
103074: CALL 28236 0 6
103078: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103079: LD_ADDR_VAR 0 8
103083: PUSH
103084: LD_VAR 0 4
103088: PUSH
103089: LD_VAR 0 7
103093: ARRAY
103094: PPUSH
103095: LD_VAR 0 9
103099: PPUSH
103100: CALL 46906 0 2
103104: ST_TO_ADDR
// if j then
103105: LD_VAR 0 8
103109: IFFALSE 103178
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103111: LD_VAR 0 8
103115: PUSH
103116: LD_INT 1
103118: ARRAY
103119: PPUSH
103120: LD_VAR 0 8
103124: PUSH
103125: LD_INT 2
103127: ARRAY
103128: PPUSH
103129: CALL_OW 488
103133: IFFALSE 103178
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103135: LD_VAR 0 4
103139: PUSH
103140: LD_VAR 0 7
103144: ARRAY
103145: PPUSH
103146: LD_VAR 0 8
103150: PUSH
103151: LD_INT 1
103153: ARRAY
103154: PPUSH
103155: LD_VAR 0 8
103159: PUSH
103160: LD_INT 2
103162: ARRAY
103163: PPUSH
103164: CALL_OW 116
// attacking := true ;
103168: LD_ADDR_VAR 0 29
103172: PUSH
103173: LD_INT 1
103175: ST_TO_ADDR
// continue ;
103176: GO 100551
// end ; end else
103178: GO 103204
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103180: LD_VAR 0 4
103184: PUSH
103185: LD_VAR 0 7
103189: ARRAY
103190: PPUSH
103191: LD_VAR 0 14
103195: PUSH
103196: LD_INT 1
103198: ARRAY
103199: PPUSH
103200: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103204: LD_VAR 0 4
103208: PUSH
103209: LD_VAR 0 7
103213: ARRAY
103214: PPUSH
103215: CALL_OW 265
103219: PUSH
103220: LD_INT 11
103222: EQUAL
103223: IFFALSE 103501
// begin k := 10 ;
103225: LD_ADDR_VAR 0 9
103229: PUSH
103230: LD_INT 10
103232: ST_TO_ADDR
// x := 0 ;
103233: LD_ADDR_VAR 0 10
103237: PUSH
103238: LD_INT 0
103240: ST_TO_ADDR
// if tmp < k then
103241: LD_VAR 0 14
103245: PUSH
103246: LD_VAR 0 9
103250: LESS
103251: IFFALSE 103263
// k := tmp ;
103253: LD_ADDR_VAR 0 9
103257: PUSH
103258: LD_VAR 0 14
103262: ST_TO_ADDR
// for j = k downto 1 do
103263: LD_ADDR_VAR 0 8
103267: PUSH
103268: DOUBLE
103269: LD_VAR 0 9
103273: INC
103274: ST_TO_ADDR
103275: LD_INT 1
103277: PUSH
103278: FOR_DOWNTO
103279: IFFALSE 103354
// begin if GetType ( tmp [ j ] ) = unit_human then
103281: LD_VAR 0 14
103285: PUSH
103286: LD_VAR 0 8
103290: ARRAY
103291: PPUSH
103292: CALL_OW 247
103296: PUSH
103297: LD_INT 1
103299: EQUAL
103300: IFFALSE 103352
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103302: LD_VAR 0 4
103306: PUSH
103307: LD_VAR 0 7
103311: ARRAY
103312: PPUSH
103313: LD_VAR 0 14
103317: PUSH
103318: LD_VAR 0 8
103322: ARRAY
103323: PPUSH
103324: CALL 47177 0 2
// x := tmp [ j ] ;
103328: LD_ADDR_VAR 0 10
103332: PUSH
103333: LD_VAR 0 14
103337: PUSH
103338: LD_VAR 0 8
103342: ARRAY
103343: ST_TO_ADDR
// attacking := true ;
103344: LD_ADDR_VAR 0 29
103348: PUSH
103349: LD_INT 1
103351: ST_TO_ADDR
// end ; end ;
103352: GO 103278
103354: POP
103355: POP
// if not x then
103356: LD_VAR 0 10
103360: NOT
103361: IFFALSE 103501
// begin attacking := true ;
103363: LD_ADDR_VAR 0 29
103367: PUSH
103368: LD_INT 1
103370: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103371: LD_VAR 0 4
103375: PUSH
103376: LD_VAR 0 7
103380: ARRAY
103381: PPUSH
103382: CALL_OW 250
103386: PPUSH
103387: LD_VAR 0 4
103391: PUSH
103392: LD_VAR 0 7
103396: ARRAY
103397: PPUSH
103398: CALL_OW 251
103402: PPUSH
103403: CALL_OW 546
103407: PUSH
103408: LD_INT 2
103410: ARRAY
103411: PUSH
103412: LD_VAR 0 14
103416: PUSH
103417: LD_INT 1
103419: ARRAY
103420: PPUSH
103421: CALL_OW 250
103425: PPUSH
103426: LD_VAR 0 14
103430: PUSH
103431: LD_INT 1
103433: ARRAY
103434: PPUSH
103435: CALL_OW 251
103439: PPUSH
103440: CALL_OW 546
103444: PUSH
103445: LD_INT 2
103447: ARRAY
103448: EQUAL
103449: IFFALSE 103477
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103451: LD_VAR 0 4
103455: PUSH
103456: LD_VAR 0 7
103460: ARRAY
103461: PPUSH
103462: LD_VAR 0 14
103466: PUSH
103467: LD_INT 1
103469: ARRAY
103470: PPUSH
103471: CALL 47177 0 2
103475: GO 103501
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103477: LD_VAR 0 4
103481: PUSH
103482: LD_VAR 0 7
103486: ARRAY
103487: PPUSH
103488: LD_VAR 0 14
103492: PUSH
103493: LD_INT 1
103495: ARRAY
103496: PPUSH
103497: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103501: LD_VAR 0 4
103505: PUSH
103506: LD_VAR 0 7
103510: ARRAY
103511: PPUSH
103512: CALL_OW 264
103516: PUSH
103517: LD_INT 29
103519: EQUAL
103520: IFFALSE 103886
// begin if WantsToAttack ( group [ i ] ) in bombed then
103522: LD_VAR 0 4
103526: PUSH
103527: LD_VAR 0 7
103531: ARRAY
103532: PPUSH
103533: CALL_OW 319
103537: PUSH
103538: LD_VAR 0 28
103542: IN
103543: IFFALSE 103547
// continue ;
103545: GO 100551
// k := 8 ;
103547: LD_ADDR_VAR 0 9
103551: PUSH
103552: LD_INT 8
103554: ST_TO_ADDR
// x := 0 ;
103555: LD_ADDR_VAR 0 10
103559: PUSH
103560: LD_INT 0
103562: ST_TO_ADDR
// if tmp < k then
103563: LD_VAR 0 14
103567: PUSH
103568: LD_VAR 0 9
103572: LESS
103573: IFFALSE 103585
// k := tmp ;
103575: LD_ADDR_VAR 0 9
103579: PUSH
103580: LD_VAR 0 14
103584: ST_TO_ADDR
// for j = 1 to k do
103585: LD_ADDR_VAR 0 8
103589: PUSH
103590: DOUBLE
103591: LD_INT 1
103593: DEC
103594: ST_TO_ADDR
103595: LD_VAR 0 9
103599: PUSH
103600: FOR_TO
103601: IFFALSE 103733
// begin if GetType ( tmp [ j ] ) = unit_building then
103603: LD_VAR 0 14
103607: PUSH
103608: LD_VAR 0 8
103612: ARRAY
103613: PPUSH
103614: CALL_OW 247
103618: PUSH
103619: LD_INT 3
103621: EQUAL
103622: IFFALSE 103731
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103624: LD_VAR 0 14
103628: PUSH
103629: LD_VAR 0 8
103633: ARRAY
103634: PUSH
103635: LD_VAR 0 28
103639: IN
103640: NOT
103641: PUSH
103642: LD_VAR 0 14
103646: PUSH
103647: LD_VAR 0 8
103651: ARRAY
103652: PPUSH
103653: CALL_OW 313
103657: AND
103658: IFFALSE 103731
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103660: LD_VAR 0 4
103664: PUSH
103665: LD_VAR 0 7
103669: ARRAY
103670: PPUSH
103671: LD_VAR 0 14
103675: PUSH
103676: LD_VAR 0 8
103680: ARRAY
103681: PPUSH
103682: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103686: LD_ADDR_VAR 0 28
103690: PUSH
103691: LD_VAR 0 28
103695: PPUSH
103696: LD_VAR 0 28
103700: PUSH
103701: LD_INT 1
103703: PLUS
103704: PPUSH
103705: LD_VAR 0 14
103709: PUSH
103710: LD_VAR 0 8
103714: ARRAY
103715: PPUSH
103716: CALL_OW 1
103720: ST_TO_ADDR
// attacking := true ;
103721: LD_ADDR_VAR 0 29
103725: PUSH
103726: LD_INT 1
103728: ST_TO_ADDR
// break ;
103729: GO 103733
// end ; end ;
103731: GO 103600
103733: POP
103734: POP
// if not attacking and f_attack_depot then
103735: LD_VAR 0 29
103739: NOT
103740: PUSH
103741: LD_VAR 0 25
103745: AND
103746: IFFALSE 103841
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103748: LD_ADDR_VAR 0 13
103752: PUSH
103753: LD_VAR 0 14
103757: PPUSH
103758: LD_INT 2
103760: PUSH
103761: LD_INT 30
103763: PUSH
103764: LD_INT 0
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PUSH
103771: LD_INT 30
103773: PUSH
103774: LD_INT 1
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PUSH
103781: EMPTY
103782: LIST
103783: LIST
103784: LIST
103785: PPUSH
103786: CALL_OW 72
103790: ST_TO_ADDR
// if z then
103791: LD_VAR 0 13
103795: IFFALSE 103841
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103797: LD_VAR 0 4
103801: PUSH
103802: LD_VAR 0 7
103806: ARRAY
103807: PPUSH
103808: LD_VAR 0 13
103812: PPUSH
103813: LD_VAR 0 4
103817: PUSH
103818: LD_VAR 0 7
103822: ARRAY
103823: PPUSH
103824: CALL_OW 74
103828: PPUSH
103829: CALL_OW 115
// attacking := true ;
103833: LD_ADDR_VAR 0 29
103837: PUSH
103838: LD_INT 1
103840: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103841: LD_VAR 0 4
103845: PUSH
103846: LD_VAR 0 7
103850: ARRAY
103851: PPUSH
103852: CALL_OW 256
103856: PUSH
103857: LD_INT 500
103859: LESS
103860: IFFALSE 103886
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103862: LD_VAR 0 4
103866: PUSH
103867: LD_VAR 0 7
103871: ARRAY
103872: PPUSH
103873: LD_VAR 0 14
103877: PUSH
103878: LD_INT 1
103880: ARRAY
103881: PPUSH
103882: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103886: LD_VAR 0 4
103890: PUSH
103891: LD_VAR 0 7
103895: ARRAY
103896: PPUSH
103897: CALL_OW 264
103901: PUSH
103902: LD_INT 49
103904: EQUAL
103905: IFFALSE 104026
// begin if not HasTask ( group [ i ] ) then
103907: LD_VAR 0 4
103911: PUSH
103912: LD_VAR 0 7
103916: ARRAY
103917: PPUSH
103918: CALL_OW 314
103922: NOT
103923: IFFALSE 104026
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103925: LD_ADDR_VAR 0 9
103929: PUSH
103930: LD_INT 81
103932: PUSH
103933: LD_VAR 0 4
103937: PUSH
103938: LD_VAR 0 7
103942: ARRAY
103943: PPUSH
103944: CALL_OW 255
103948: PUSH
103949: EMPTY
103950: LIST
103951: LIST
103952: PPUSH
103953: CALL_OW 69
103957: PPUSH
103958: LD_VAR 0 4
103962: PUSH
103963: LD_VAR 0 7
103967: ARRAY
103968: PPUSH
103969: CALL_OW 74
103973: ST_TO_ADDR
// if k then
103974: LD_VAR 0 9
103978: IFFALSE 104026
// if GetDistUnits ( group [ i ] , k ) > 10 then
103980: LD_VAR 0 4
103984: PUSH
103985: LD_VAR 0 7
103989: ARRAY
103990: PPUSH
103991: LD_VAR 0 9
103995: PPUSH
103996: CALL_OW 296
104000: PUSH
104001: LD_INT 10
104003: GREATER
104004: IFFALSE 104026
// ComMoveUnit ( group [ i ] , k ) ;
104006: LD_VAR 0 4
104010: PUSH
104011: LD_VAR 0 7
104015: ARRAY
104016: PPUSH
104017: LD_VAR 0 9
104021: PPUSH
104022: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104026: LD_VAR 0 4
104030: PUSH
104031: LD_VAR 0 7
104035: ARRAY
104036: PPUSH
104037: CALL_OW 256
104041: PUSH
104042: LD_INT 250
104044: LESS
104045: PUSH
104046: LD_VAR 0 4
104050: PUSH
104051: LD_VAR 0 7
104055: ARRAY
104056: PUSH
104057: LD_INT 21
104059: PUSH
104060: LD_INT 2
104062: PUSH
104063: EMPTY
104064: LIST
104065: LIST
104066: PUSH
104067: LD_INT 23
104069: PUSH
104070: LD_INT 2
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PPUSH
104081: CALL_OW 69
104085: IN
104086: AND
104087: IFFALSE 104212
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104089: LD_ADDR_VAR 0 9
104093: PUSH
104094: LD_OWVAR 3
104098: PUSH
104099: LD_VAR 0 4
104103: PUSH
104104: LD_VAR 0 7
104108: ARRAY
104109: DIFF
104110: PPUSH
104111: LD_VAR 0 4
104115: PUSH
104116: LD_VAR 0 7
104120: ARRAY
104121: PPUSH
104122: CALL_OW 74
104126: ST_TO_ADDR
// if not k then
104127: LD_VAR 0 9
104131: NOT
104132: IFFALSE 104136
// continue ;
104134: GO 100551
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104136: LD_VAR 0 9
104140: PUSH
104141: LD_INT 81
104143: PUSH
104144: LD_VAR 0 4
104148: PUSH
104149: LD_VAR 0 7
104153: ARRAY
104154: PPUSH
104155: CALL_OW 255
104159: PUSH
104160: EMPTY
104161: LIST
104162: LIST
104163: PPUSH
104164: CALL_OW 69
104168: IN
104169: PUSH
104170: LD_VAR 0 9
104174: PPUSH
104175: LD_VAR 0 4
104179: PUSH
104180: LD_VAR 0 7
104184: ARRAY
104185: PPUSH
104186: CALL_OW 296
104190: PUSH
104191: LD_INT 5
104193: LESS
104194: AND
104195: IFFALSE 104212
// ComAutodestruct ( group [ i ] ) ;
104197: LD_VAR 0 4
104201: PUSH
104202: LD_VAR 0 7
104206: ARRAY
104207: PPUSH
104208: CALL 47075 0 1
// end ; if f_attack_depot then
104212: LD_VAR 0 25
104216: IFFALSE 104328
// begin k := 6 ;
104218: LD_ADDR_VAR 0 9
104222: PUSH
104223: LD_INT 6
104225: ST_TO_ADDR
// if tmp < k then
104226: LD_VAR 0 14
104230: PUSH
104231: LD_VAR 0 9
104235: LESS
104236: IFFALSE 104248
// k := tmp ;
104238: LD_ADDR_VAR 0 9
104242: PUSH
104243: LD_VAR 0 14
104247: ST_TO_ADDR
// for j = 1 to k do
104248: LD_ADDR_VAR 0 8
104252: PUSH
104253: DOUBLE
104254: LD_INT 1
104256: DEC
104257: ST_TO_ADDR
104258: LD_VAR 0 9
104262: PUSH
104263: FOR_TO
104264: IFFALSE 104326
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104266: LD_VAR 0 8
104270: PPUSH
104271: CALL_OW 266
104275: PUSH
104276: LD_INT 0
104278: PUSH
104279: LD_INT 1
104281: PUSH
104282: EMPTY
104283: LIST
104284: LIST
104285: IN
104286: IFFALSE 104324
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104288: LD_VAR 0 4
104292: PUSH
104293: LD_VAR 0 7
104297: ARRAY
104298: PPUSH
104299: LD_VAR 0 14
104303: PUSH
104304: LD_VAR 0 8
104308: ARRAY
104309: PPUSH
104310: CALL_OW 115
// attacking := true ;
104314: LD_ADDR_VAR 0 29
104318: PUSH
104319: LD_INT 1
104321: ST_TO_ADDR
// break ;
104322: GO 104326
// end ;
104324: GO 104263
104326: POP
104327: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104328: LD_VAR 0 4
104332: PUSH
104333: LD_VAR 0 7
104337: ARRAY
104338: PPUSH
104339: CALL_OW 302
104343: PUSH
104344: LD_VAR 0 29
104348: NOT
104349: AND
104350: IFFALSE 104672
// begin if GetTag ( group [ i ] ) = 71 then
104352: LD_VAR 0 4
104356: PUSH
104357: LD_VAR 0 7
104361: ARRAY
104362: PPUSH
104363: CALL_OW 110
104367: PUSH
104368: LD_INT 71
104370: EQUAL
104371: IFFALSE 104412
// begin if HasTask ( group [ i ] ) then
104373: LD_VAR 0 4
104377: PUSH
104378: LD_VAR 0 7
104382: ARRAY
104383: PPUSH
104384: CALL_OW 314
104388: IFFALSE 104394
// continue else
104390: GO 100551
104392: GO 104412
// SetTag ( group [ i ] , 0 ) ;
104394: LD_VAR 0 4
104398: PUSH
104399: LD_VAR 0 7
104403: ARRAY
104404: PPUSH
104405: LD_INT 0
104407: PPUSH
104408: CALL_OW 109
// end ; k := 8 ;
104412: LD_ADDR_VAR 0 9
104416: PUSH
104417: LD_INT 8
104419: ST_TO_ADDR
// x := 0 ;
104420: LD_ADDR_VAR 0 10
104424: PUSH
104425: LD_INT 0
104427: ST_TO_ADDR
// if tmp < k then
104428: LD_VAR 0 14
104432: PUSH
104433: LD_VAR 0 9
104437: LESS
104438: IFFALSE 104450
// k := tmp ;
104440: LD_ADDR_VAR 0 9
104444: PUSH
104445: LD_VAR 0 14
104449: ST_TO_ADDR
// for j = 1 to k do
104450: LD_ADDR_VAR 0 8
104454: PUSH
104455: DOUBLE
104456: LD_INT 1
104458: DEC
104459: ST_TO_ADDR
104460: LD_VAR 0 9
104464: PUSH
104465: FOR_TO
104466: IFFALSE 104564
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104468: LD_VAR 0 14
104472: PUSH
104473: LD_VAR 0 8
104477: ARRAY
104478: PPUSH
104479: CALL_OW 247
104483: PUSH
104484: LD_INT 1
104486: EQUAL
104487: PUSH
104488: LD_VAR 0 14
104492: PUSH
104493: LD_VAR 0 8
104497: ARRAY
104498: PPUSH
104499: CALL_OW 256
104503: PUSH
104504: LD_INT 250
104506: LESS
104507: PUSH
104508: LD_VAR 0 20
104512: AND
104513: PUSH
104514: LD_VAR 0 20
104518: NOT
104519: PUSH
104520: LD_VAR 0 14
104524: PUSH
104525: LD_VAR 0 8
104529: ARRAY
104530: PPUSH
104531: CALL_OW 256
104535: PUSH
104536: LD_INT 250
104538: GREATEREQUAL
104539: AND
104540: OR
104541: AND
104542: IFFALSE 104562
// begin x := tmp [ j ] ;
104544: LD_ADDR_VAR 0 10
104548: PUSH
104549: LD_VAR 0 14
104553: PUSH
104554: LD_VAR 0 8
104558: ARRAY
104559: ST_TO_ADDR
// break ;
104560: GO 104564
// end ;
104562: GO 104465
104564: POP
104565: POP
// if x then
104566: LD_VAR 0 10
104570: IFFALSE 104594
// ComAttackUnit ( group [ i ] , x ) else
104572: LD_VAR 0 4
104576: PUSH
104577: LD_VAR 0 7
104581: ARRAY
104582: PPUSH
104583: LD_VAR 0 10
104587: PPUSH
104588: CALL_OW 115
104592: GO 104618
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104594: LD_VAR 0 4
104598: PUSH
104599: LD_VAR 0 7
104603: ARRAY
104604: PPUSH
104605: LD_VAR 0 14
104609: PUSH
104610: LD_INT 1
104612: ARRAY
104613: PPUSH
104614: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104618: LD_VAR 0 4
104622: PUSH
104623: LD_VAR 0 7
104627: ARRAY
104628: PPUSH
104629: CALL_OW 314
104633: NOT
104634: IFFALSE 104672
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104636: LD_VAR 0 4
104640: PUSH
104641: LD_VAR 0 7
104645: ARRAY
104646: PPUSH
104647: LD_VAR 0 14
104651: PPUSH
104652: LD_VAR 0 4
104656: PUSH
104657: LD_VAR 0 7
104661: ARRAY
104662: PPUSH
104663: CALL_OW 74
104667: PPUSH
104668: CALL_OW 115
// end ; end ; end ;
104672: GO 100551
104674: POP
104675: POP
// wait ( 0 0$2 ) ;
104676: LD_INT 70
104678: PPUSH
104679: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104683: LD_VAR 0 4
104687: NOT
104688: PUSH
104689: LD_VAR 0 4
104693: PUSH
104694: EMPTY
104695: EQUAL
104696: OR
104697: PUSH
104698: LD_INT 81
104700: PUSH
104701: LD_VAR 0 35
104705: PUSH
104706: EMPTY
104707: LIST
104708: LIST
104709: PPUSH
104710: CALL_OW 69
104714: NOT
104715: OR
104716: IFFALSE 100536
// end ;
104718: LD_VAR 0 2
104722: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
104723: LD_INT 0
104725: PPUSH
104726: PPUSH
104727: PPUSH
104728: PPUSH
104729: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
104730: LD_VAR 0 1
104734: NOT
104735: PUSH
104736: LD_EXP 59
104740: PUSH
104741: LD_VAR 0 1
104745: ARRAY
104746: NOT
104747: OR
104748: PUSH
104749: LD_VAR 0 2
104753: NOT
104754: OR
104755: PUSH
104756: LD_VAR 0 3
104760: NOT
104761: OR
104762: IFFALSE 104766
// exit ;
104764: GO 105279
// side := mc_sides [ base ] ;
104766: LD_ADDR_VAR 0 6
104770: PUSH
104771: LD_EXP 85
104775: PUSH
104776: LD_VAR 0 1
104780: ARRAY
104781: ST_TO_ADDR
// if not side then
104782: LD_VAR 0 6
104786: NOT
104787: IFFALSE 104791
// exit ;
104789: GO 105279
// for i in solds do
104791: LD_ADDR_VAR 0 7
104795: PUSH
104796: LD_VAR 0 2
104800: PUSH
104801: FOR_IN
104802: IFFALSE 104863
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
104804: LD_VAR 0 7
104808: PPUSH
104809: CALL_OW 310
104813: PPUSH
104814: CALL_OW 266
104818: PUSH
104819: LD_INT 32
104821: PUSH
104822: LD_INT 31
104824: PUSH
104825: EMPTY
104826: LIST
104827: LIST
104828: IN
104829: IFFALSE 104849
// solds := solds diff i else
104831: LD_ADDR_VAR 0 2
104835: PUSH
104836: LD_VAR 0 2
104840: PUSH
104841: LD_VAR 0 7
104845: DIFF
104846: ST_TO_ADDR
104847: GO 104861
// SetTag ( i , 18 ) ;
104849: LD_VAR 0 7
104853: PPUSH
104854: LD_INT 18
104856: PPUSH
104857: CALL_OW 109
104861: GO 104801
104863: POP
104864: POP
// if not solds then
104865: LD_VAR 0 2
104869: NOT
104870: IFFALSE 104874
// exit ;
104872: GO 105279
// repeat wait ( 0 0$2 ) ;
104874: LD_INT 70
104876: PPUSH
104877: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
104881: LD_ADDR_VAR 0 5
104885: PUSH
104886: LD_VAR 0 6
104890: PPUSH
104891: LD_VAR 0 3
104895: PPUSH
104896: CALL 16487 0 2
104900: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104901: LD_EXP 59
104905: PUSH
104906: LD_VAR 0 1
104910: ARRAY
104911: NOT
104912: PUSH
104913: LD_EXP 59
104917: PUSH
104918: LD_VAR 0 1
104922: ARRAY
104923: PUSH
104924: EMPTY
104925: EQUAL
104926: OR
104927: IFFALSE 104964
// begin for i in solds do
104929: LD_ADDR_VAR 0 7
104933: PUSH
104934: LD_VAR 0 2
104938: PUSH
104939: FOR_IN
104940: IFFALSE 104953
// ComStop ( i ) ;
104942: LD_VAR 0 7
104946: PPUSH
104947: CALL_OW 141
104951: GO 104939
104953: POP
104954: POP
// solds := [ ] ;
104955: LD_ADDR_VAR 0 2
104959: PUSH
104960: EMPTY
104961: ST_TO_ADDR
// exit ;
104962: GO 105279
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
104964: LD_VAR 0 5
104968: NOT
104969: PUSH
104970: LD_VAR 0 5
104974: PUSH
104975: LD_INT 3
104977: GREATER
104978: OR
104979: PUSH
104980: LD_EXP 81
104984: PUSH
104985: LD_VAR 0 1
104989: ARRAY
104990: OR
104991: IFFALSE 105032
// begin for i in solds do
104993: LD_ADDR_VAR 0 7
104997: PUSH
104998: LD_VAR 0 2
105002: PUSH
105003: FOR_IN
105004: IFFALSE 105028
// if HasTask ( i ) then
105006: LD_VAR 0 7
105010: PPUSH
105011: CALL_OW 314
105015: IFFALSE 105026
// ComStop ( i ) ;
105017: LD_VAR 0 7
105021: PPUSH
105022: CALL_OW 141
105026: GO 105003
105028: POP
105029: POP
// break ;
105030: GO 105267
// end ; for i in solds do
105032: LD_ADDR_VAR 0 7
105036: PUSH
105037: LD_VAR 0 2
105041: PUSH
105042: FOR_IN
105043: IFFALSE 105259
// begin if IsInUnit ( i ) then
105045: LD_VAR 0 7
105049: PPUSH
105050: CALL_OW 310
105054: IFFALSE 105065
// ComExitBuilding ( i ) ;
105056: LD_VAR 0 7
105060: PPUSH
105061: CALL_OW 122
// if GetLives ( i ) > 333 then
105065: LD_VAR 0 7
105069: PPUSH
105070: CALL_OW 256
105074: PUSH
105075: LD_INT 333
105077: GREATER
105078: IFFALSE 105106
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105080: LD_VAR 0 7
105084: PPUSH
105085: LD_VAR 0 5
105089: PPUSH
105090: LD_VAR 0 7
105094: PPUSH
105095: CALL_OW 74
105099: PPUSH
105100: CALL_OW 115
105104: GO 105257
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
105106: LD_ADDR_VAR 0 8
105110: PUSH
105111: LD_EXP 59
105115: PUSH
105116: LD_VAR 0 1
105120: ARRAY
105121: PPUSH
105122: LD_INT 2
105124: PUSH
105125: LD_INT 30
105127: PUSH
105128: LD_INT 0
105130: PUSH
105131: EMPTY
105132: LIST
105133: LIST
105134: PUSH
105135: LD_INT 30
105137: PUSH
105138: LD_INT 1
105140: PUSH
105141: EMPTY
105142: LIST
105143: LIST
105144: PUSH
105145: LD_INT 30
105147: PUSH
105148: LD_INT 6
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: PUSH
105155: EMPTY
105156: LIST
105157: LIST
105158: LIST
105159: LIST
105160: PPUSH
105161: CALL_OW 72
105165: PPUSH
105166: LD_VAR 0 7
105170: PPUSH
105171: CALL_OW 74
105175: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
105176: LD_VAR 0 7
105180: PPUSH
105181: LD_VAR 0 8
105185: PPUSH
105186: CALL_OW 250
105190: PPUSH
105191: LD_INT 3
105193: PPUSH
105194: LD_INT 5
105196: PPUSH
105197: CALL_OW 272
105201: PPUSH
105202: LD_VAR 0 8
105206: PPUSH
105207: CALL_OW 251
105211: PPUSH
105212: LD_INT 3
105214: PPUSH
105215: LD_INT 5
105217: PPUSH
105218: CALL_OW 273
105222: PPUSH
105223: CALL_OW 111
// SetTag ( i , 0 ) ;
105227: LD_VAR 0 7
105231: PPUSH
105232: LD_INT 0
105234: PPUSH
105235: CALL_OW 109
// solds := solds diff i ;
105239: LD_ADDR_VAR 0 2
105243: PUSH
105244: LD_VAR 0 2
105248: PUSH
105249: LD_VAR 0 7
105253: DIFF
105254: ST_TO_ADDR
// continue ;
105255: GO 105042
// end ; end ;
105257: GO 105042
105259: POP
105260: POP
// until solds ;
105261: LD_VAR 0 2
105265: IFFALSE 104874
// MC_Reset ( base , 18 ) ;
105267: LD_VAR 0 1
105271: PPUSH
105272: LD_INT 18
105274: PPUSH
105275: CALL 56497 0 2
// end ;
105279: LD_VAR 0 4
105283: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
105284: LD_INT 0
105286: PPUSH
105287: PPUSH
105288: PPUSH
105289: PPUSH
105290: PPUSH
105291: PPUSH
105292: PPUSH
105293: PPUSH
105294: PPUSH
105295: PPUSH
105296: PPUSH
105297: PPUSH
105298: PPUSH
105299: PPUSH
105300: PPUSH
105301: PPUSH
105302: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
105303: LD_ADDR_VAR 0 13
105307: PUSH
105308: LD_EXP 59
105312: PUSH
105313: LD_VAR 0 1
105317: ARRAY
105318: PPUSH
105319: LD_INT 25
105321: PUSH
105322: LD_INT 3
105324: PUSH
105325: EMPTY
105326: LIST
105327: LIST
105328: PPUSH
105329: CALL_OW 72
105333: ST_TO_ADDR
// if mc_remote_driver [ base ] then
105334: LD_EXP 99
105338: PUSH
105339: LD_VAR 0 1
105343: ARRAY
105344: IFFALSE 105368
// mechs := mechs diff mc_remote_driver [ base ] ;
105346: LD_ADDR_VAR 0 13
105350: PUSH
105351: LD_VAR 0 13
105355: PUSH
105356: LD_EXP 99
105360: PUSH
105361: LD_VAR 0 1
105365: ARRAY
105366: DIFF
105367: ST_TO_ADDR
// for i in mechs do
105368: LD_ADDR_VAR 0 5
105372: PUSH
105373: LD_VAR 0 13
105377: PUSH
105378: FOR_IN
105379: IFFALSE 105414
// if GetTag ( i ) > 0 then
105381: LD_VAR 0 5
105385: PPUSH
105386: CALL_OW 110
105390: PUSH
105391: LD_INT 0
105393: GREATER
105394: IFFALSE 105412
// mechs := mechs diff i ;
105396: LD_ADDR_VAR 0 13
105400: PUSH
105401: LD_VAR 0 13
105405: PUSH
105406: LD_VAR 0 5
105410: DIFF
105411: ST_TO_ADDR
105412: GO 105378
105414: POP
105415: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105416: LD_ADDR_VAR 0 9
105420: PUSH
105421: LD_EXP 59
105425: PUSH
105426: LD_VAR 0 1
105430: ARRAY
105431: PPUSH
105432: LD_INT 2
105434: PUSH
105435: LD_INT 25
105437: PUSH
105438: LD_INT 1
105440: PUSH
105441: EMPTY
105442: LIST
105443: LIST
105444: PUSH
105445: LD_INT 25
105447: PUSH
105448: LD_INT 5
105450: PUSH
105451: EMPTY
105452: LIST
105453: LIST
105454: PUSH
105455: LD_INT 25
105457: PUSH
105458: LD_INT 8
105460: PUSH
105461: EMPTY
105462: LIST
105463: LIST
105464: PUSH
105465: LD_INT 25
105467: PUSH
105468: LD_INT 9
105470: PUSH
105471: EMPTY
105472: LIST
105473: LIST
105474: PUSH
105475: EMPTY
105476: LIST
105477: LIST
105478: LIST
105479: LIST
105480: LIST
105481: PPUSH
105482: CALL_OW 72
105486: ST_TO_ADDR
// if not defenders and not solds then
105487: LD_VAR 0 2
105491: NOT
105492: PUSH
105493: LD_VAR 0 9
105497: NOT
105498: AND
105499: IFFALSE 105503
// exit ;
105501: GO 107193
// depot_under_attack := false ;
105503: LD_ADDR_VAR 0 17
105507: PUSH
105508: LD_INT 0
105510: ST_TO_ADDR
// sold_defenders := [ ] ;
105511: LD_ADDR_VAR 0 18
105515: PUSH
105516: EMPTY
105517: ST_TO_ADDR
// if mechs then
105518: LD_VAR 0 13
105522: IFFALSE 105675
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
105524: LD_ADDR_VAR 0 5
105528: PUSH
105529: LD_VAR 0 2
105533: PPUSH
105534: LD_INT 21
105536: PUSH
105537: LD_INT 2
105539: PUSH
105540: EMPTY
105541: LIST
105542: LIST
105543: PPUSH
105544: CALL_OW 72
105548: PUSH
105549: FOR_IN
105550: IFFALSE 105673
// begin if GetTag ( i ) <> 20 then
105552: LD_VAR 0 5
105556: PPUSH
105557: CALL_OW 110
105561: PUSH
105562: LD_INT 20
105564: NONEQUAL
105565: IFFALSE 105579
// SetTag ( i , 20 ) ;
105567: LD_VAR 0 5
105571: PPUSH
105572: LD_INT 20
105574: PPUSH
105575: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
105579: LD_VAR 0 5
105583: PPUSH
105584: CALL_OW 263
105588: PUSH
105589: LD_INT 1
105591: EQUAL
105592: PUSH
105593: LD_VAR 0 5
105597: PPUSH
105598: CALL_OW 311
105602: NOT
105603: AND
105604: IFFALSE 105671
// begin un := mechs [ 1 ] ;
105606: LD_ADDR_VAR 0 11
105610: PUSH
105611: LD_VAR 0 13
105615: PUSH
105616: LD_INT 1
105618: ARRAY
105619: ST_TO_ADDR
// ComExit ( un ) ;
105620: LD_VAR 0 11
105624: PPUSH
105625: CALL 51420 0 1
// AddComEnterUnit ( un , i ) ;
105629: LD_VAR 0 11
105633: PPUSH
105634: LD_VAR 0 5
105638: PPUSH
105639: CALL_OW 180
// SetTag ( un , 19 ) ;
105643: LD_VAR 0 11
105647: PPUSH
105648: LD_INT 19
105650: PPUSH
105651: CALL_OW 109
// mechs := mechs diff un ;
105655: LD_ADDR_VAR 0 13
105659: PUSH
105660: LD_VAR 0 13
105664: PUSH
105665: LD_VAR 0 11
105669: DIFF
105670: ST_TO_ADDR
// end ; end ;
105671: GO 105549
105673: POP
105674: POP
// if solds then
105675: LD_VAR 0 9
105679: IFFALSE 105738
// for i in solds do
105681: LD_ADDR_VAR 0 5
105685: PUSH
105686: LD_VAR 0 9
105690: PUSH
105691: FOR_IN
105692: IFFALSE 105736
// if not GetTag ( i ) then
105694: LD_VAR 0 5
105698: PPUSH
105699: CALL_OW 110
105703: NOT
105704: IFFALSE 105734
// begin defenders := defenders union i ;
105706: LD_ADDR_VAR 0 2
105710: PUSH
105711: LD_VAR 0 2
105715: PUSH
105716: LD_VAR 0 5
105720: UNION
105721: ST_TO_ADDR
// SetTag ( i , 18 ) ;
105722: LD_VAR 0 5
105726: PPUSH
105727: LD_INT 18
105729: PPUSH
105730: CALL_OW 109
// end ;
105734: GO 105691
105736: POP
105737: POP
// repeat wait ( 0 0$2 ) ;
105738: LD_INT 70
105740: PPUSH
105741: CALL_OW 67
// enemy := mc_scan [ base ] ;
105745: LD_ADDR_VAR 0 3
105749: PUSH
105750: LD_EXP 82
105754: PUSH
105755: LD_VAR 0 1
105759: ARRAY
105760: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105761: LD_EXP 59
105765: PUSH
105766: LD_VAR 0 1
105770: ARRAY
105771: NOT
105772: PUSH
105773: LD_EXP 59
105777: PUSH
105778: LD_VAR 0 1
105782: ARRAY
105783: PUSH
105784: EMPTY
105785: EQUAL
105786: OR
105787: IFFALSE 105824
// begin for i in defenders do
105789: LD_ADDR_VAR 0 5
105793: PUSH
105794: LD_VAR 0 2
105798: PUSH
105799: FOR_IN
105800: IFFALSE 105813
// ComStop ( i ) ;
105802: LD_VAR 0 5
105806: PPUSH
105807: CALL_OW 141
105811: GO 105799
105813: POP
105814: POP
// defenders := [ ] ;
105815: LD_ADDR_VAR 0 2
105819: PUSH
105820: EMPTY
105821: ST_TO_ADDR
// exit ;
105822: GO 107193
// end ; for i in defenders do
105824: LD_ADDR_VAR 0 5
105828: PUSH
105829: LD_VAR 0 2
105833: PUSH
105834: FOR_IN
105835: IFFALSE 106653
// begin e := NearestUnitToUnit ( enemy , i ) ;
105837: LD_ADDR_VAR 0 14
105841: PUSH
105842: LD_VAR 0 3
105846: PPUSH
105847: LD_VAR 0 5
105851: PPUSH
105852: CALL_OW 74
105856: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105857: LD_ADDR_VAR 0 8
105861: PUSH
105862: LD_EXP 59
105866: PUSH
105867: LD_VAR 0 1
105871: ARRAY
105872: PPUSH
105873: LD_INT 2
105875: PUSH
105876: LD_INT 30
105878: PUSH
105879: LD_INT 0
105881: PUSH
105882: EMPTY
105883: LIST
105884: LIST
105885: PUSH
105886: LD_INT 30
105888: PUSH
105889: LD_INT 1
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: PUSH
105896: EMPTY
105897: LIST
105898: LIST
105899: LIST
105900: PPUSH
105901: CALL_OW 72
105905: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
105906: LD_ADDR_VAR 0 17
105910: PUSH
105911: LD_VAR 0 8
105915: NOT
105916: PUSH
105917: LD_VAR 0 8
105921: PPUSH
105922: LD_INT 3
105924: PUSH
105925: LD_INT 24
105927: PUSH
105928: LD_INT 600
105930: PUSH
105931: EMPTY
105932: LIST
105933: LIST
105934: PUSH
105935: EMPTY
105936: LIST
105937: LIST
105938: PPUSH
105939: CALL_OW 72
105943: OR
105944: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
105945: LD_VAR 0 5
105949: PPUSH
105950: CALL_OW 247
105954: PUSH
105955: LD_INT 2
105957: DOUBLE
105958: EQUAL
105959: IFTRUE 105963
105961: GO 106359
105963: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
105964: LD_VAR 0 5
105968: PPUSH
105969: CALL_OW 256
105973: PUSH
105974: LD_INT 1000
105976: EQUAL
105977: PUSH
105978: LD_VAR 0 5
105982: PPUSH
105983: LD_VAR 0 14
105987: PPUSH
105988: CALL_OW 296
105992: PUSH
105993: LD_INT 40
105995: LESS
105996: PUSH
105997: LD_VAR 0 14
106001: PPUSH
106002: LD_EXP 84
106006: PUSH
106007: LD_VAR 0 1
106011: ARRAY
106012: PPUSH
106013: CALL_OW 308
106017: OR
106018: AND
106019: IFFALSE 106141
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
106021: LD_VAR 0 5
106025: PPUSH
106026: CALL_OW 262
106030: PUSH
106031: LD_INT 1
106033: EQUAL
106034: PUSH
106035: LD_VAR 0 5
106039: PPUSH
106040: CALL_OW 261
106044: PUSH
106045: LD_INT 30
106047: LESS
106048: AND
106049: PUSH
106050: LD_VAR 0 8
106054: AND
106055: IFFALSE 106125
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
106057: LD_VAR 0 5
106061: PPUSH
106062: LD_VAR 0 8
106066: PPUSH
106067: LD_VAR 0 5
106071: PPUSH
106072: CALL_OW 74
106076: PPUSH
106077: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
106081: LD_VAR 0 5
106085: PPUSH
106086: LD_VAR 0 8
106090: PPUSH
106091: LD_VAR 0 5
106095: PPUSH
106096: CALL_OW 74
106100: PPUSH
106101: CALL_OW 296
106105: PUSH
106106: LD_INT 6
106108: LESS
106109: IFFALSE 106123
// SetFuel ( i , 100 ) ;
106111: LD_VAR 0 5
106115: PPUSH
106116: LD_INT 100
106118: PPUSH
106119: CALL_OW 240
// end else
106123: GO 106139
// ComAttackUnit ( i , e ) ;
106125: LD_VAR 0 5
106129: PPUSH
106130: LD_VAR 0 14
106134: PPUSH
106135: CALL_OW 115
// end else
106139: GO 106242
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
106141: LD_VAR 0 14
106145: PPUSH
106146: LD_EXP 84
106150: PUSH
106151: LD_VAR 0 1
106155: ARRAY
106156: PPUSH
106157: CALL_OW 308
106161: NOT
106162: PUSH
106163: LD_VAR 0 5
106167: PPUSH
106168: LD_VAR 0 14
106172: PPUSH
106173: CALL_OW 296
106177: PUSH
106178: LD_INT 40
106180: GREATEREQUAL
106181: AND
106182: PUSH
106183: LD_VAR 0 5
106187: PPUSH
106188: CALL_OW 256
106192: PUSH
106193: LD_INT 650
106195: LESSEQUAL
106196: OR
106197: PUSH
106198: LD_VAR 0 5
106202: PPUSH
106203: LD_EXP 83
106207: PUSH
106208: LD_VAR 0 1
106212: ARRAY
106213: PPUSH
106214: CALL_OW 308
106218: NOT
106219: AND
106220: IFFALSE 106242
// ComMoveToArea ( i , mc_parking [ base ] ) ;
106222: LD_VAR 0 5
106226: PPUSH
106227: LD_EXP 83
106231: PUSH
106232: LD_VAR 0 1
106236: ARRAY
106237: PPUSH
106238: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
106242: LD_VAR 0 5
106246: PPUSH
106247: CALL_OW 256
106251: PUSH
106252: LD_INT 1000
106254: LESS
106255: PUSH
106256: LD_VAR 0 5
106260: PPUSH
106261: CALL_OW 263
106265: PUSH
106266: LD_INT 1
106268: EQUAL
106269: AND
106270: PUSH
106271: LD_VAR 0 5
106275: PPUSH
106276: CALL_OW 311
106280: AND
106281: PUSH
106282: LD_VAR 0 5
106286: PPUSH
106287: LD_EXP 83
106291: PUSH
106292: LD_VAR 0 1
106296: ARRAY
106297: PPUSH
106298: CALL_OW 308
106302: AND
106303: IFFALSE 106357
// begin mech := IsDrivenBy ( i ) ;
106305: LD_ADDR_VAR 0 10
106309: PUSH
106310: LD_VAR 0 5
106314: PPUSH
106315: CALL_OW 311
106319: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
106320: LD_VAR 0 10
106324: PPUSH
106325: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
106329: LD_VAR 0 10
106333: PPUSH
106334: LD_VAR 0 5
106338: PPUSH
106339: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
106343: LD_VAR 0 10
106347: PPUSH
106348: LD_VAR 0 5
106352: PPUSH
106353: CALL_OW 180
// end ; end ; unit_human :
106357: GO 106624
106359: LD_INT 1
106361: DOUBLE
106362: EQUAL
106363: IFTRUE 106367
106365: GO 106623
106367: POP
// begin b := IsInUnit ( i ) ;
106368: LD_ADDR_VAR 0 19
106372: PUSH
106373: LD_VAR 0 5
106377: PPUSH
106378: CALL_OW 310
106382: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
106383: LD_ADDR_VAR 0 20
106387: PUSH
106388: LD_VAR 0 19
106392: NOT
106393: PUSH
106394: LD_VAR 0 19
106398: PPUSH
106399: CALL_OW 266
106403: PUSH
106404: LD_INT 32
106406: PUSH
106407: LD_INT 31
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: IN
106414: OR
106415: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
106416: LD_VAR 0 17
106420: PUSH
106421: LD_VAR 0 2
106425: PPUSH
106426: LD_INT 21
106428: PUSH
106429: LD_INT 2
106431: PUSH
106432: EMPTY
106433: LIST
106434: LIST
106435: PPUSH
106436: CALL_OW 72
106440: PUSH
106441: LD_INT 1
106443: LESSEQUAL
106444: OR
106445: PUSH
106446: LD_VAR 0 20
106450: AND
106451: PUSH
106452: LD_VAR 0 5
106456: PUSH
106457: LD_VAR 0 18
106461: IN
106462: NOT
106463: AND
106464: IFFALSE 106557
// begin if b then
106466: LD_VAR 0 19
106470: IFFALSE 106519
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
106472: LD_VAR 0 19
106476: PPUSH
106477: LD_VAR 0 3
106481: PPUSH
106482: LD_VAR 0 19
106486: PPUSH
106487: CALL_OW 74
106491: PPUSH
106492: CALL_OW 296
106496: PUSH
106497: LD_INT 10
106499: LESS
106500: PUSH
106501: LD_VAR 0 19
106505: PPUSH
106506: CALL_OW 461
106510: PUSH
106511: LD_INT 7
106513: NONEQUAL
106514: AND
106515: IFFALSE 106519
// continue ;
106517: GO 105834
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
106519: LD_ADDR_VAR 0 18
106523: PUSH
106524: LD_VAR 0 18
106528: PPUSH
106529: LD_VAR 0 18
106533: PUSH
106534: LD_INT 1
106536: PLUS
106537: PPUSH
106538: LD_VAR 0 5
106542: PPUSH
106543: CALL_OW 1
106547: ST_TO_ADDR
// ComExitBuilding ( i ) ;
106548: LD_VAR 0 5
106552: PPUSH
106553: CALL_OW 122
// end ; if sold_defenders then
106557: LD_VAR 0 18
106561: IFFALSE 106621
// if i in sold_defenders then
106563: LD_VAR 0 5
106567: PUSH
106568: LD_VAR 0 18
106572: IN
106573: IFFALSE 106621
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
106575: LD_VAR 0 5
106579: PPUSH
106580: CALL_OW 314
106584: NOT
106585: PUSH
106586: LD_VAR 0 5
106590: PPUSH
106591: LD_VAR 0 14
106595: PPUSH
106596: CALL_OW 296
106600: PUSH
106601: LD_INT 30
106603: LESS
106604: AND
106605: IFFALSE 106621
// ComAttackUnit ( i , e ) ;
106607: LD_VAR 0 5
106611: PPUSH
106612: LD_VAR 0 14
106616: PPUSH
106617: CALL_OW 115
// end ; end ; end ;
106621: GO 106624
106623: POP
// if IsDead ( i ) then
106624: LD_VAR 0 5
106628: PPUSH
106629: CALL_OW 301
106633: IFFALSE 106651
// defenders := defenders diff i ;
106635: LD_ADDR_VAR 0 2
106639: PUSH
106640: LD_VAR 0 2
106644: PUSH
106645: LD_VAR 0 5
106649: DIFF
106650: ST_TO_ADDR
// end ;
106651: GO 105834
106653: POP
106654: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
106655: LD_VAR 0 3
106659: NOT
106660: PUSH
106661: LD_VAR 0 2
106665: NOT
106666: OR
106667: PUSH
106668: LD_EXP 59
106672: PUSH
106673: LD_VAR 0 1
106677: ARRAY
106678: NOT
106679: OR
106680: IFFALSE 105738
// MC_Reset ( base , 18 ) ;
106682: LD_VAR 0 1
106686: PPUSH
106687: LD_INT 18
106689: PPUSH
106690: CALL 56497 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106694: LD_ADDR_VAR 0 2
106698: PUSH
106699: LD_VAR 0 2
106703: PUSH
106704: LD_VAR 0 2
106708: PPUSH
106709: LD_INT 2
106711: PUSH
106712: LD_INT 25
106714: PUSH
106715: LD_INT 1
106717: PUSH
106718: EMPTY
106719: LIST
106720: LIST
106721: PUSH
106722: LD_INT 25
106724: PUSH
106725: LD_INT 5
106727: PUSH
106728: EMPTY
106729: LIST
106730: LIST
106731: PUSH
106732: LD_INT 25
106734: PUSH
106735: LD_INT 8
106737: PUSH
106738: EMPTY
106739: LIST
106740: LIST
106741: PUSH
106742: LD_INT 25
106744: PUSH
106745: LD_INT 9
106747: PUSH
106748: EMPTY
106749: LIST
106750: LIST
106751: PUSH
106752: EMPTY
106753: LIST
106754: LIST
106755: LIST
106756: LIST
106757: LIST
106758: PPUSH
106759: CALL_OW 72
106763: DIFF
106764: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
106765: LD_VAR 0 3
106769: NOT
106770: PUSH
106771: LD_VAR 0 2
106775: PPUSH
106776: LD_INT 21
106778: PUSH
106779: LD_INT 2
106781: PUSH
106782: EMPTY
106783: LIST
106784: LIST
106785: PPUSH
106786: CALL_OW 72
106790: AND
106791: IFFALSE 107129
// begin tmp := FilterByTag ( defenders , 19 ) ;
106793: LD_ADDR_VAR 0 12
106797: PUSH
106798: LD_VAR 0 2
106802: PPUSH
106803: LD_INT 19
106805: PPUSH
106806: CALL 48550 0 2
106810: ST_TO_ADDR
// if tmp then
106811: LD_VAR 0 12
106815: IFFALSE 106885
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
106817: LD_ADDR_VAR 0 12
106821: PUSH
106822: LD_VAR 0 12
106826: PPUSH
106827: LD_INT 25
106829: PUSH
106830: LD_INT 3
106832: PUSH
106833: EMPTY
106834: LIST
106835: LIST
106836: PPUSH
106837: CALL_OW 72
106841: ST_TO_ADDR
// if tmp then
106842: LD_VAR 0 12
106846: IFFALSE 106885
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
106848: LD_ADDR_EXP 71
106852: PUSH
106853: LD_EXP 71
106857: PPUSH
106858: LD_VAR 0 1
106862: PPUSH
106863: LD_EXP 71
106867: PUSH
106868: LD_VAR 0 1
106872: ARRAY
106873: PUSH
106874: LD_VAR 0 12
106878: UNION
106879: PPUSH
106880: CALL_OW 1
106884: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
106885: LD_VAR 0 1
106889: PPUSH
106890: LD_INT 19
106892: PPUSH
106893: CALL 56497 0 2
// repeat wait ( 0 0$1 ) ;
106897: LD_INT 35
106899: PPUSH
106900: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106904: LD_EXP 59
106908: PUSH
106909: LD_VAR 0 1
106913: ARRAY
106914: NOT
106915: PUSH
106916: LD_EXP 59
106920: PUSH
106921: LD_VAR 0 1
106925: ARRAY
106926: PUSH
106927: EMPTY
106928: EQUAL
106929: OR
106930: IFFALSE 106967
// begin for i in defenders do
106932: LD_ADDR_VAR 0 5
106936: PUSH
106937: LD_VAR 0 2
106941: PUSH
106942: FOR_IN
106943: IFFALSE 106956
// ComStop ( i ) ;
106945: LD_VAR 0 5
106949: PPUSH
106950: CALL_OW 141
106954: GO 106942
106956: POP
106957: POP
// defenders := [ ] ;
106958: LD_ADDR_VAR 0 2
106962: PUSH
106963: EMPTY
106964: ST_TO_ADDR
// exit ;
106965: GO 107193
// end ; for i in defenders do
106967: LD_ADDR_VAR 0 5
106971: PUSH
106972: LD_VAR 0 2
106976: PUSH
106977: FOR_IN
106978: IFFALSE 107067
// begin if not IsInArea ( i , mc_parking [ base ] ) then
106980: LD_VAR 0 5
106984: PPUSH
106985: LD_EXP 83
106989: PUSH
106990: LD_VAR 0 1
106994: ARRAY
106995: PPUSH
106996: CALL_OW 308
107000: NOT
107001: IFFALSE 107025
// ComMoveToArea ( i , mc_parking [ base ] ) else
107003: LD_VAR 0 5
107007: PPUSH
107008: LD_EXP 83
107012: PUSH
107013: LD_VAR 0 1
107017: ARRAY
107018: PPUSH
107019: CALL_OW 113
107023: GO 107065
// if GetControl ( i ) = control_manual then
107025: LD_VAR 0 5
107029: PPUSH
107030: CALL_OW 263
107034: PUSH
107035: LD_INT 1
107037: EQUAL
107038: IFFALSE 107065
// if IsDrivenBy ( i ) then
107040: LD_VAR 0 5
107044: PPUSH
107045: CALL_OW 311
107049: IFFALSE 107065
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
107051: LD_VAR 0 5
107055: PPUSH
107056: CALL_OW 311
107060: PPUSH
107061: CALL_OW 121
// end ;
107065: GO 106977
107067: POP
107068: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
107069: LD_VAR 0 2
107073: PPUSH
107074: LD_INT 95
107076: PUSH
107077: LD_EXP 83
107081: PUSH
107082: LD_VAR 0 1
107086: ARRAY
107087: PUSH
107088: EMPTY
107089: LIST
107090: LIST
107091: PPUSH
107092: CALL_OW 72
107096: PUSH
107097: LD_VAR 0 2
107101: EQUAL
107102: PUSH
107103: LD_EXP 82
107107: PUSH
107108: LD_VAR 0 1
107112: ARRAY
107113: OR
107114: PUSH
107115: LD_EXP 59
107119: PUSH
107120: LD_VAR 0 1
107124: ARRAY
107125: NOT
107126: OR
107127: IFFALSE 106897
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
107129: LD_ADDR_EXP 81
107133: PUSH
107134: LD_EXP 81
107138: PPUSH
107139: LD_VAR 0 1
107143: PPUSH
107144: LD_VAR 0 2
107148: PPUSH
107149: LD_INT 21
107151: PUSH
107152: LD_INT 2
107154: PUSH
107155: EMPTY
107156: LIST
107157: LIST
107158: PPUSH
107159: CALL_OW 72
107163: PPUSH
107164: CALL_OW 1
107168: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
107169: LD_VAR 0 1
107173: PPUSH
107174: LD_INT 19
107176: PPUSH
107177: CALL 56497 0 2
// MC_Reset ( base , 20 ) ;
107181: LD_VAR 0 1
107185: PPUSH
107186: LD_INT 20
107188: PPUSH
107189: CALL 56497 0 2
// end ; end_of_file
107193: LD_VAR 0 4
107197: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
107198: LD_VAR 0 1
107202: PUSH
107203: LD_INT 200
107205: DOUBLE
107206: GREATEREQUAL
107207: IFFALSE 107215
107209: LD_INT 299
107211: DOUBLE
107212: LESSEQUAL
107213: IFTRUE 107217
107215: GO 107249
107217: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
107218: LD_VAR 0 1
107222: PPUSH
107223: LD_VAR 0 2
107227: PPUSH
107228: LD_VAR 0 3
107232: PPUSH
107233: LD_VAR 0 4
107237: PPUSH
107238: LD_VAR 0 5
107242: PPUSH
107243: CALL 96131 0 5
107247: GO 107326
107249: LD_INT 300
107251: DOUBLE
107252: GREATEREQUAL
107253: IFFALSE 107261
107255: LD_INT 399
107257: DOUBLE
107258: LESSEQUAL
107259: IFTRUE 107263
107261: GO 107325
107263: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
107264: LD_VAR 0 1
107268: PPUSH
107269: LD_VAR 0 2
107273: PPUSH
107274: LD_VAR 0 3
107278: PPUSH
107279: LD_VAR 0 4
107283: PPUSH
107284: LD_VAR 0 5
107288: PPUSH
107289: LD_VAR 0 6
107293: PPUSH
107294: LD_VAR 0 7
107298: PPUSH
107299: LD_VAR 0 8
107303: PPUSH
107304: LD_VAR 0 9
107308: PPUSH
107309: LD_VAR 0 10
107313: PPUSH
107314: LD_VAR 0 11
107318: PPUSH
107319: CALL 94019 0 11
107323: GO 107326
107325: POP
// end ;
107326: PPOPN 11
107328: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
107329: LD_VAR 0 1
107333: PPUSH
107334: LD_VAR 0 2
107338: PPUSH
107339: LD_VAR 0 3
107343: PPUSH
107344: LD_VAR 0 4
107348: PPUSH
107349: LD_VAR 0 5
107353: PPUSH
107354: CALL 96113 0 5
// end ; end_of_file
107358: PPOPN 5
107360: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
107361: LD_VAR 0 1
107365: PPUSH
107366: LD_VAR 0 2
107370: PPUSH
107371: LD_VAR 0 3
107375: PPUSH
107376: LD_VAR 0 4
107380: PPUSH
107381: LD_VAR 0 5
107385: PPUSH
107386: LD_VAR 0 6
107390: PPUSH
107391: CALL 82827 0 6
// end ;
107395: PPOPN 6
107397: END
