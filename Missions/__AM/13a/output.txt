// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 59206 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50803 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50803 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50803 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50803 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4551 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 61386 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8507 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 83103 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 83548 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84006 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 84275 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 83488 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 84182 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 83548 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84006 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 84275 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 83332 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 84593 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 83488 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 16435 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 16435 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 16435 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 16435 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 16435 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 16435 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 16435 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 16435 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 16435 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 16435 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 16435 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 16435 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 16435 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 16435 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 16435 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 16435 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 16435 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 16435 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 21275 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 21275 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 21275 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 25096 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 21275 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4073
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 3
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 22
3356: PUSH
3357: LD_INT 1
3359: PUSH
3360: LD_INT 3
3362: PUSH
3363: LD_INT 45
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 21
3374: PUSH
3375: LD_INT 1
3377: PUSH
3378: LD_INT 3
3380: PUSH
3381: LD_INT 45
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: PUSH
3390: LD_INT 22
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: LD_INT 3
3398: PUSH
3399: LD_INT 45
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 23
3410: PUSH
3411: LD_INT 1
3413: PUSH
3414: LD_INT 3
3416: PUSH
3417: LD_INT 46
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: ST_TO_ADDR
// amount := Difficulty ;
3432: LD_ADDR_VAR 0 7
3436: PUSH
3437: LD_OWVAR 67
3441: ST_TO_ADDR
// if tick > 30 30$00 then
3442: LD_OWVAR 1
3446: PUSH
3447: LD_INT 63000
3449: GREATER
3450: IFFALSE 3487
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_VAR 0 7
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: LD_INT 3
3467: PUSH
3468: LD_INT 4
3470: PUSH
3471: LD_INT 4
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: PUSH
3480: LD_OWVAR 67
3484: ARRAY
3485: PLUS
3486: ST_TO_ADDR
// for i = 1 to amount do
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_VAR 0 7
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3591
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3505: LD_ADDR_VAR 0 4
3509: PUSH
3510: LD_VAR 0 4
3514: PPUSH
3515: LD_VAR 0 4
3519: PUSH
3520: LD_INT 1
3522: PLUS
3523: PPUSH
3524: LD_INT 23
3526: PUSH
3527: LD_INT 24
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 1
3536: PPUSH
3537: LD_INT 2
3539: PPUSH
3540: CALL_OW 12
3544: ARRAY
3545: PUSH
3546: LD_INT 1
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 46
3554: PUSH
3555: LD_INT 47
3557: PUSH
3558: LD_INT 45
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 1
3568: PPUSH
3569: LD_INT 3
3571: PPUSH
3572: CALL_OW 12
3576: ARRAY
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: PPUSH
3584: CALL_OW 2
3588: ST_TO_ADDR
3589: GO 3502
3591: POP
3592: POP
// p := 1 ;
3593: LD_ADDR_VAR 0 2
3597: PUSH
3598: LD_INT 1
3600: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3601: LD_VAR 0 3
3605: PPUSH
3606: LD_VAR 0 4
3610: PPUSH
3611: CALL 83488 0 2
// repeat wait ( 0 0$1 ) ;
3615: LD_INT 35
3617: PPUSH
3618: CALL_OW 67
// p := Inc ( p ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_VAR 0 2
3631: PPUSH
3632: CALL 55487 0 1
3636: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3637: LD_VAR 0 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL 84906 0 2
3649: PUSH
3650: LD_VAR 0 7
3654: GREATEREQUAL
3655: PUSH
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 60
3663: GREATEREQUAL
3664: OR
3665: IFFALSE 3615
// wait ( 0 0$30 ) ;
3667: LD_INT 1050
3669: PPUSH
3670: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_INT 71
3681: PUSH
3682: LD_INT 19
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 91
3691: PUSH
3692: LD_INT 67
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 52
3701: PUSH
3702: LD_INT 44
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 68
3711: PUSH
3712: LD_INT 48
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ) diff mc_defender [ base ] ;
3725: LD_ADDR_VAR 0 6
3729: PUSH
3730: LD_INT 22
3732: PUSH
3733: LD_INT 3
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 21
3742: PUSH
3743: LD_INT 2
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 3
3752: PUSH
3753: LD_INT 34
3755: PUSH
3756: LD_INT 52
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 34
3765: PUSH
3766: LD_INT 51
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: PPUSH
3783: CALL_OW 69
3787: PUSH
3788: LD_EXP 83
3792: PUSH
3793: LD_VAR 0 3
3797: ARRAY
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4073
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 3
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// p := 0 ;
3951: LD_ADDR_VAR 0 2
3955: PUSH
3956: LD_INT 0
3958: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3959: LD_INT 35
3961: PPUSH
3962: CALL_OW 67
// p := Inc ( p ) ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL 55487 0 1
3980: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_INT 60
3988: PUSH
3989: EMPTY
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: NOT
3997: PUSH
3998: LD_VAR 0 2
4002: PUSH
4003: LD_INT 30
4005: GREATER
4006: OR
4007: IFFALSE 3959
// if not first_attack then
4009: LD_EXP 7
4013: NOT
4014: IFFALSE 4024
// first_attack := true ;
4016: LD_ADDR_EXP 7
4020: PUSH
4021: LD_INT 1
4023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4024: LD_INT 35
4026: PPUSH
4027: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4031: LD_ADDR_VAR 0 6
4035: PUSH
4036: LD_VAR 0 6
4040: PPUSH
4041: LD_INT 50
4043: PUSH
4044: EMPTY
4045: LIST
4046: PPUSH
4047: CALL_OW 72
4051: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PPUSH
4062: CALL 56730 0 2
// until not attackers ;
4066: LD_VAR 0 6
4070: NOT
4071: IFFALSE 4024
// end ;
4073: PPOPN 7
4075: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// uc_side := 6 ;
4084: LD_ADDR_OWVAR 20
4088: PUSH
4089: LD_INT 6
4091: ST_TO_ADDR
// uc_nation := 3 ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// InitHc ;
4100: CALL_OW 19
// InitVc ;
4104: CALL_OW 20
// tmp := [ ] ;
4108: LD_ADDR_VAR 0 3
4112: PUSH
4113: EMPTY
4114: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4115: LD_ADDR_VAR 0 2
4119: PUSH
4120: DOUBLE
4121: LD_INT 1
4123: DEC
4124: ST_TO_ADDR
4125: LD_INT 4
4127: PUSH
4128: LD_INT 5
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PUSH
4149: FOR_TO
4150: IFFALSE 4404
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_INT 21
4159: PUSH
4160: LD_INT 22
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 1
4173: PPUSH
4174: LD_INT 3
4176: PPUSH
4177: CALL_OW 12
4181: ARRAY
4182: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4183: LD_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: DOUBLE
4191: EQUAL
4192: IFTRUE 4202
4194: LD_INT 22
4196: DOUBLE
4197: EQUAL
4198: IFTRUE 4202
4200: GO 4236
4202: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4203: LD_ADDR_VAR 0 6
4207: PUSH
4208: LD_INT 45
4210: PUSH
4211: LD_INT 44
4213: PUSH
4214: LD_INT 43
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 3
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: ST_TO_ADDR
4234: GO 4283
4236: LD_INT 24
4238: DOUBLE
4239: EQUAL
4240: IFTRUE 4244
4242: GO 4282
4244: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4245: LD_ADDR_VAR 0 6
4249: PUSH
4250: LD_INT 46
4252: PUSH
4253: LD_INT 47
4255: PUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 46
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_INT 1
4270: PPUSH
4271: LD_INT 4
4273: PPUSH
4274: CALL_OW 12
4278: ARRAY
4279: ST_TO_ADDR
4280: GO 4283
4282: POP
// uc_side := 6 ;
4283: LD_ADDR_OWVAR 20
4287: PUSH
4288: LD_INT 6
4290: ST_TO_ADDR
// uc_nation := 3 ;
4291: LD_ADDR_OWVAR 21
4295: PUSH
4296: LD_INT 3
4298: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4299: LD_VAR 0 5
4303: PPUSH
4304: LD_INT 1
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 12
4324: ARRAY
4325: PPUSH
4326: LD_INT 3
4328: PPUSH
4329: LD_VAR 0 6
4333: PPUSH
4334: LD_INT 70
4336: PPUSH
4337: LD_INT 90
4339: PPUSH
4340: CALL_OW 12
4344: PPUSH
4345: CALL 21275 0 5
// veh := CreateVehicle ;
4349: LD_ADDR_VAR 0 4
4353: PUSH
4354: CALL_OW 45
4358: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4359: LD_VAR 0 4
4363: PPUSH
4364: LD_INT 5
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4371: LD_VAR 0 4
4375: PPUSH
4376: LD_INT 16
4378: PPUSH
4379: LD_INT 0
4381: PPUSH
4382: CALL_OW 49
// tmp := tmp ^ veh ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_VAR 0 4
4400: ADD
4401: ST_TO_ADDR
// end ;
4402: GO 4149
4404: POP
4405: POP
// if not tmp then
4406: LD_VAR 0 3
4410: NOT
4411: IFFALSE 4415
// exit ;
4413: GO 4509
// repeat wait ( 0 0$2 ) ;
4415: LD_INT 70
4417: PPUSH
4418: CALL_OW 67
// for i in tmp do
4422: LD_ADDR_VAR 0 2
4426: PUSH
4427: LD_VAR 0 3
4431: PUSH
4432: FOR_IN
4433: IFFALSE 4500
// if IsOk ( i ) then
4435: LD_VAR 0 2
4439: PPUSH
4440: CALL_OW 302
4444: IFFALSE 4482
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_INT 22
4453: PUSH
4454: LD_INT 7
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 69
4465: PPUSH
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 74
4475: PPUSH
4476: CALL_OW 115
4480: GO 4498
// tmp := tmp diff i ;
4482: LD_ADDR_VAR 0 3
4486: PUSH
4487: LD_VAR 0 3
4491: PUSH
4492: LD_VAR 0 2
4496: DIFF
4497: ST_TO_ADDR
4498: GO 4432
4500: POP
4501: POP
// until not tmp ;
4502: LD_VAR 0 3
4506: NOT
4507: IFFALSE 4415
// end ;
4509: LD_VAR 0 1
4513: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 do
4514: LD_EXP 7
4518: PUSH
4519: LD_INT 47
4521: PPUSH
4522: CALL_OW 302
4526: AND
4527: PUSH
4528: LD_INT 47
4530: PPUSH
4531: CALL_OW 255
4535: PUSH
4536: LD_INT 3
4538: EQUAL
4539: AND
4540: IFFALSE 4550
4542: GO 4544
4544: DISABLE
// begin enable ;
4545: ENABLE
// PrepareRussianAttack ;
4546: CALL 4076 0 0
// end ; end_of_file
4550: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
4559: PPUSH
// uc_side := 2 ;
4560: LD_ADDR_OWVAR 20
4564: PUSH
4565: LD_INT 2
4567: ST_TO_ADDR
// uc_nation := 2 ;
4568: LD_ADDR_OWVAR 21
4572: PUSH
4573: LD_INT 2
4575: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4576: LD_ADDR_EXP 57
4580: PUSH
4581: LD_STRING Abdul
4583: PPUSH
4584: CALL_OW 25
4588: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4589: LD_EXP 57
4593: PPUSH
4594: LD_INT 11
4596: PPUSH
4597: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4601: LD_EXP 57
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: CALL_OW 52
// vc_chassis := 31 ;
4613: LD_ADDR_OWVAR 37
4617: PUSH
4618: LD_INT 31
4620: ST_TO_ADDR
// vc_control := control_rider ;
4621: LD_ADDR_OWVAR 38
4625: PUSH
4626: LD_INT 4
4628: ST_TO_ADDR
// mastodont := CreateVehicle ;
4629: LD_ADDR_EXP 58
4633: PUSH
4634: CALL_OW 45
4638: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4639: LD_EXP 58
4643: PPUSH
4644: LD_INT 153
4646: PPUSH
4647: LD_INT 71
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// InitVc ;
4657: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4661: LD_ADDR_EXP 55
4665: PUSH
4666: LD_INT 1
4668: PPUSH
4669: LD_INT 3
4671: PPUSH
4672: LD_STRING kaba
4674: PPUSH
4675: LD_INT 7
4677: PUSH
4678: LD_INT 8
4680: PUSH
4681: LD_INT 9
4683: PUSH
4684: LD_INT 10
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 5000
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: LD_INT 300
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 11
4715: PUSH
4716: LD_INT 5
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 7
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 25096 0 6
4735: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4736: LD_ADDR_EXP 61
4740: PUSH
4741: LD_EXP 61
4745: PPUSH
4746: LD_INT 1
4748: PPUSH
4749: LD_EXP 55
4753: PPUSH
4754: CALL_OW 1
4758: ST_TO_ADDR
// tmp := [ ] ;
4759: LD_ADDR_VAR 0 4
4763: PUSH
4764: EMPTY
4765: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4766: LD_ADDR_OWVAR 37
4770: PUSH
4771: LD_INT 13
4773: ST_TO_ADDR
// vc_engine := engine_siberite ;
4774: LD_ADDR_OWVAR 39
4778: PUSH
4779: LD_INT 3
4781: ST_TO_ADDR
// vc_control := control_manual ;
4782: LD_ADDR_OWVAR 38
4786: PUSH
4787: LD_INT 1
4789: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4790: LD_ADDR_OWVAR 40
4794: PUSH
4795: LD_INT 31
4797: ST_TO_ADDR
// for i = 1 to 3 do
4798: LD_ADDR_VAR 0 2
4802: PUSH
4803: DOUBLE
4804: LD_INT 1
4806: DEC
4807: ST_TO_ADDR
4808: LD_INT 3
4810: PUSH
4811: FOR_TO
4812: IFFALSE 5060
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4814: LD_ADDR_VAR 0 5
4818: PUSH
4819: LD_INT 153
4821: PUSH
4822: LD_INT 71
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: LD_INT 155
4831: PUSH
4832: LD_INT 81
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_VAR 0 2
4847: PUSH
4848: LD_INT 2
4850: MOD
4851: PUSH
4852: LD_INT 1
4854: PLUS
4855: ARRAY
4856: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4857: LD_INT 0
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: LD_INT 7
4865: PUSH
4866: LD_INT 8
4868: PUSH
4869: LD_INT 10
4871: PUSH
4872: LD_INT 10
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PUSH
4881: LD_OWVAR 67
4885: ARRAY
4886: PPUSH
4887: CALL_OW 380
// un := CreateVehicle ;
4891: LD_ADDR_VAR 0 6
4895: PUSH
4896: CALL_OW 45
4900: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4901: LD_VAR 0 6
4905: PPUSH
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 12
4916: PPUSH
4917: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4921: LD_VAR 0 6
4925: PPUSH
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_VAR 0 5
4939: PUSH
4940: LD_INT 2
4942: ARRAY
4943: PPUSH
4944: LD_INT 6
4946: PPUSH
4947: LD_INT 0
4949: PPUSH
4950: CALL_OW 50
// un2 := CreateHuman ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: CALL_OW 44
4963: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4964: LD_VAR 0 7
4968: PPUSH
4969: LD_VAR 0 6
4973: PPUSH
4974: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4978: LD_ADDR_EXP 61
4982: PUSH
4983: LD_EXP 61
4987: PPUSH
4988: LD_INT 1
4990: PUSH
4991: LD_EXP 61
4995: PUSH
4996: LD_INT 1
4998: ARRAY
4999: PUSH
5000: LD_INT 1
5002: PLUS
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_VAR 0 6
5012: PPUSH
5013: CALL 21397 0 3
5017: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5018: LD_ADDR_EXP 61
5022: PUSH
5023: LD_EXP 61
5027: PPUSH
5028: LD_INT 1
5030: PUSH
5031: LD_EXP 61
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PUSH
5040: LD_INT 1
5042: PLUS
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PPUSH
5048: LD_VAR 0 7
5052: PPUSH
5053: CALL 21397 0 3
5057: ST_TO_ADDR
// end ;
5058: GO 4811
5060: POP
5061: POP
// for i = 1 to 5 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 5
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5169
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5078: LD_INT 13
5080: PPUSH
5081: LD_INT 3
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 25
5089: PUSH
5090: LD_INT 28
5092: PUSH
5093: LD_INT 28
5095: PUSH
5096: LD_INT 26
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_VAR 0 2
5109: PUSH
5110: LD_INT 4
5112: MOD
5113: PUSH
5114: LD_INT 1
5116: PLUS
5117: ARRAY
5118: PPUSH
5119: LD_INT 100
5121: PPUSH
5122: CALL 21275 0 5
// veh := CreateVehicle ;
5126: LD_ADDR_VAR 0 3
5130: PUSH
5131: CALL_OW 45
5135: ST_TO_ADDR
// tmp := tmp ^ veh ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 3
5150: ADD
5151: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5152: LD_VAR 0 3
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 49
// end ;
5167: GO 5075
5169: POP
5170: POP
// arabian_guard := tmp ;
5171: LD_ADDR_EXP 56
5175: PUSH
5176: LD_VAR 0 4
5180: ST_TO_ADDR
// end ;
5181: LD_VAR 0 1
5185: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5186: LD_INT 22
5188: PUSH
5189: LD_INT 7
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 91
5198: PUSH
5199: LD_INT 1
5201: PUSH
5202: LD_INT 12
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: PPUSH
5214: CALL_OW 69
5218: PUSH
5219: LD_EXP 58
5223: PPUSH
5224: CALL_OW 256
5228: PUSH
5229: LD_INT 990
5231: LESS
5232: OR
5233: PUSH
5234: LD_EXP 57
5238: PPUSH
5239: CALL_OW 256
5243: PUSH
5244: LD_INT 990
5246: LESS
5247: OR
5248: IFFALSE 5391
5250: GO 5252
5252: DISABLE
// begin if IsInUnit ( Abdul ) then
5253: LD_EXP 57
5257: PPUSH
5258: CALL_OW 310
5262: IFFALSE 5273
// ComExitBuilding ( Abdul ) ;
5264: LD_EXP 57
5268: PPUSH
5269: CALL_OW 122
// if Mastodont then
5273: LD_EXP 58
5277: IFFALSE 5294
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5279: LD_EXP 58
5283: PPUSH
5284: LD_INT 205
5286: PPUSH
5287: LD_INT 132
5289: PPUSH
5290: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5294: LD_EXP 57
5298: PPUSH
5299: LD_INT 205
5301: PPUSH
5302: LD_INT 132
5304: PPUSH
5305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5309: LD_INT 35
5311: PPUSH
5312: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5316: LD_EXP 57
5320: PPUSH
5321: LD_INT 21
5323: PPUSH
5324: CALL_OW 308
5328: IFFALSE 5309
// RemoveUnit ( Abdul ) ;
5330: LD_EXP 57
5334: PPUSH
5335: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5339: LD_INT 35
5341: PPUSH
5342: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5346: LD_EXP 58
5350: PPUSH
5351: LD_INT 21
5353: PPUSH
5354: CALL_OW 308
5358: PUSH
5359: LD_EXP 58
5363: PPUSH
5364: CALL_OW 301
5368: OR
5369: IFFALSE 5339
// if IsOk ( Mastodont ) then
5371: LD_EXP 58
5375: PPUSH
5376: CALL_OW 302
5380: IFFALSE 5391
// RemoveUnit ( Mastodont ) ;
5382: LD_EXP 58
5386: PPUSH
5387: CALL_OW 64
// end ;
5391: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5392: LD_EXP 57
5396: PPUSH
5397: CALL_OW 301
5401: PUSH
5402: LD_INT 22
5404: PUSH
5405: LD_INT 2
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 2
5414: PUSH
5415: LD_INT 25
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 25
5427: PUSH
5428: LD_INT 2
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 25
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PUSH
5445: LD_INT 25
5447: PUSH
5448: LD_INT 4
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 25
5457: PUSH
5458: LD_INT 8
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PPUSH
5477: CALL_OW 69
5481: PUSH
5482: LD_INT 16
5484: PUSH
5485: LD_INT 19
5487: PUSH
5488: LD_INT 22
5490: PUSH
5491: LD_INT 22
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: LESS
5506: OR
5507: IFFALSE 6180
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin MC_Kill ( 1 ) ;
5520: LD_INT 1
5522: PPUSH
5523: CALL 59463 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5527: LD_ADDR_VAR 0 2
5531: PUSH
5532: LD_INT 22
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 25
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 25
5557: PUSH
5558: LD_INT 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 25
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 25
5577: PUSH
5578: LD_INT 4
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 25
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// for i in tmp do
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_VAR 0 2
5621: PUSH
5622: FOR_IN
5623: IFFALSE 5639
// SetTag ( i , 10 ) ;
5625: LD_VAR 0 5
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 109
5637: GO 5622
5639: POP
5640: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 22
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 21
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 69
5674: PUSH
5675: LD_VAR 0 2
5679: DIFF
5680: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5681: LD_ADDR_VAR 0 1
5685: PUSH
5686: LD_INT 22
5688: PUSH
5689: LD_INT 2
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 21
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PUSH
5706: LD_INT 24
5708: PUSH
5709: LD_INT 300
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 69
5725: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5726: LD_ADDR_VAR 0 4
5730: PUSH
5731: LD_VAR 0 1
5735: PPUSH
5736: LD_INT 33
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: LD_INT 58
5748: PUSH
5749: EMPTY
5750: LIST
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PPUSH
5756: CALL_OW 72
5760: ST_TO_ADDR
// for i in tmp do
5761: LD_ADDR_VAR 0 5
5765: PUSH
5766: LD_VAR 0 2
5770: PUSH
5771: FOR_IN
5772: IFFALSE 5956
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 55
5781: PUSH
5782: EMPTY
5783: LIST
5784: PPUSH
5785: CALL_OW 69
5789: IN
5790: IFFALSE 5809
// begin AddComMoveXY ( i , 209 , 132 ) ;
5792: LD_VAR 0 5
5796: PPUSH
5797: LD_INT 209
5799: PPUSH
5800: LD_INT 132
5802: PPUSH
5803: CALL_OW 171
// continue ;
5807: GO 5771
// end ; if IsInUnit ( i ) then
5809: LD_VAR 0 5
5813: PPUSH
5814: CALL_OW 310
5818: IFFALSE 5836
// begin ComExitBuilding ( i ) ;
5820: LD_VAR 0 5
5824: PPUSH
5825: CALL_OW 122
// wait ( 3 ) ;
5829: LD_INT 3
5831: PPUSH
5832: CALL_OW 67
// end ; if tmp_empty then
5836: LD_VAR 0 4
5840: IFFALSE 5939
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5842: LD_VAR 0 5
5846: PPUSH
5847: LD_VAR 0 4
5851: PPUSH
5852: LD_VAR 0 5
5856: PPUSH
5857: CALL_OW 74
5861: PPUSH
5862: CALL_OW 296
5866: PUSH
5867: LD_INT 25
5869: LESS
5870: IFFALSE 5939
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_VAR 0 4
5881: PPUSH
5882: LD_VAR 0 5
5886: PPUSH
5887: CALL_OW 74
5891: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5892: LD_VAR 0 5
5896: PPUSH
5897: LD_VAR 0 6
5901: PPUSH
5902: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5906: LD_VAR 0 5
5910: PPUSH
5911: LD_INT 209
5913: PPUSH
5914: LD_INT 132
5916: PPUSH
5917: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5921: LD_ADDR_VAR 0 4
5925: PUSH
5926: LD_VAR 0 4
5930: PUSH
5931: LD_VAR 0 6
5935: DIFF
5936: ST_TO_ADDR
// continue ;
5937: GO 5771
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5939: LD_VAR 0 5
5943: PPUSH
5944: LD_INT 201
5946: PPUSH
5947: LD_INT 132
5949: PPUSH
5950: CALL_OW 171
// end ;
5954: GO 5771
5956: POP
5957: POP
// for i in tmp_ape do
5958: LD_ADDR_VAR 0 5
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: FOR_IN
5969: IFFALSE 6008
// begin if IsInUnit ( i ) then
5971: LD_VAR 0 5
5975: PPUSH
5976: CALL_OW 310
5980: IFFALSE 5991
// ComExitBuilding ( i ) ;
5982: LD_VAR 0 5
5986: PPUSH
5987: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5991: LD_VAR 0 5
5995: PPUSH
5996: LD_INT 201
5998: PPUSH
5999: LD_INT 132
6001: PPUSH
6002: CALL_OW 171
// end ;
6006: GO 5968
6008: POP
6009: POP
// repeat wait ( 0 0$1 ) ;
6010: LD_INT 35
6012: PPUSH
6013: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_VAR 0 3
6031: UNION
6032: PUSH
6033: LD_VAR 0 1
6037: UNION
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6071
// if not HasTask ( i ) then
6042: LD_VAR 0 5
6046: PPUSH
6047: CALL_OW 314
6051: NOT
6052: IFFALSE 6069
// ComMoveXY ( i , 201 , 132 ) ;
6054: LD_VAR 0 5
6058: PPUSH
6059: LD_INT 201
6061: PPUSH
6062: LD_INT 132
6064: PPUSH
6065: CALL_OW 111
6069: GO 6039
6071: POP
6072: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6073: LD_INT 21
6075: PPUSH
6076: LD_INT 22
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 70
6090: IFFALSE 6131
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6092: LD_ADDR_VAR 0 5
6096: PUSH
6097: LD_INT 21
6099: PPUSH
6100: LD_INT 22
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 70
6114: PUSH
6115: FOR_IN
6116: IFFALSE 6129
// RemoveUnit ( i ) ;
6118: LD_VAR 0 5
6122: PPUSH
6123: CALL_OW 64
6127: GO 6115
6129: POP
6130: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6131: LD_INT 22
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: LD_INT 21
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 21
6156: PUSH
6157: LD_INT 2
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PPUSH
6173: CALL_OW 69
6177: NOT
6178: IFFALSE 6010
// end ;
6180: PPOPN 6
6182: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6183: LD_EXP 9
6187: PUSH
6188: LD_INT 92
6190: PPUSH
6191: LD_INT 40
6193: PPUSH
6194: CALL_OW 428
6198: PPUSH
6199: CALL_OW 266
6203: PUSH
6204: LD_INT 30
6206: EQUAL
6207: AND
6208: IFFALSE 6404
6210: GO 6212
6212: DISABLE
6213: LD_INT 0
6215: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6216: LD_ADDR_VAR 0 1
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_INT 1
6228: ARRAY
6229: PPUSH
6230: LD_INT 25
6232: PUSH
6233: LD_INT 4
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PPUSH
6240: CALL_OW 72
6244: ST_TO_ADDR
// if not sci then
6245: LD_VAR 0 1
6249: NOT
6250: IFFALSE 6254
// exit ;
6252: GO 6404
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6254: LD_ADDR_EXP 61
6258: PUSH
6259: LD_EXP 61
6263: PPUSH
6264: LD_INT 1
6266: PPUSH
6267: LD_EXP 61
6271: PUSH
6272: LD_INT 1
6274: ARRAY
6275: PUSH
6276: LD_VAR 0 1
6280: PUSH
6281: LD_INT 1
6283: ARRAY
6284: DIFF
6285: PPUSH
6286: CALL_OW 1
6290: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6291: LD_VAR 0 1
6295: PUSH
6296: LD_INT 1
6298: ARRAY
6299: PPUSH
6300: CALL_OW 310
6304: IFFALSE 6319
// ComExitBuilding ( sci [ 1 ] ) ;
6306: LD_VAR 0 1
6310: PUSH
6311: LD_INT 1
6313: ARRAY
6314: PPUSH
6315: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6319: LD_INT 2
6321: PPUSH
6322: LD_INT 105
6324: PPUSH
6325: LD_INT 14
6327: PPUSH
6328: LD_INT 20
6330: PPUSH
6331: CALL 22661 0 4
6335: PUSH
6336: LD_INT 4
6338: ARRAY
6339: PUSH
6340: LD_INT 10
6342: LESS
6343: IFFALSE 6366
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6345: LD_VAR 0 1
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_INT 105
6356: PPUSH
6357: LD_INT 14
6359: PPUSH
6360: CALL_OW 171
6364: GO 6385
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 1
6373: ARRAY
6374: PPUSH
6375: LD_INT 118
6377: PPUSH
6378: LD_INT 77
6380: PPUSH
6381: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6385: LD_VAR 0 1
6389: PUSH
6390: LD_INT 1
6392: ARRAY
6393: PPUSH
6394: LD_INT 92
6396: PPUSH
6397: LD_INT 40
6399: PPUSH
6400: CALL_OW 218
// end ;
6404: PPOPN 1
6406: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6407: LD_INT 1
6409: PPUSH
6410: CALL_OW 302
6414: PUSH
6415: LD_EXP 9
6419: AND
6420: IFFALSE 7291
6422: GO 6424
6424: DISABLE
6425: LD_INT 0
6427: PPUSH
6428: PPUSH
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// begin enable ;
6435: ENABLE
// base := 1 ;
6436: LD_ADDR_VAR 0 3
6440: PUSH
6441: LD_INT 1
6443: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6444: LD_ADDR_VAR 0 5
6448: PUSH
6449: LD_INT 0
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: LD_INT 0
6466: PUSH
6467: LD_INT 0
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 1
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 13
6498: PUSH
6499: LD_INT 1
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 13
6516: PUSH
6517: LD_INT 1
6519: PUSH
6520: LD_INT 2
6522: PUSH
6523: LD_INT 28
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 13
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: LD_INT 2
6540: PUSH
6541: LD_INT 29
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6555: LD_ADDR_VAR 0 1
6559: PUSH
6560: DOUBLE
6561: LD_INT 1
6563: DEC
6564: ST_TO_ADDR
6565: LD_OWVAR 67
6569: PUSH
6570: LD_OWVAR 1
6574: PUSH
6575: LD_INT 21000
6577: DIV
6578: PLUS
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6654
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6583: LD_ADDR_VAR 0 4
6587: PUSH
6588: LD_VAR 0 4
6592: PPUSH
6593: LD_VAR 0 4
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: PPUSH
6602: LD_INT 13
6604: PUSH
6605: LD_INT 1
6607: PUSH
6608: LD_INT 2
6610: PUSH
6611: LD_INT 28
6613: PUSH
6614: LD_INT 29
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 26
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 4
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL_OW 2
6651: ST_TO_ADDR
6652: GO 6580
6654: POP
6655: POP
// MC_InsertProduceList ( base , tmp ) ;
6656: LD_VAR 0 3
6660: PPUSH
6661: LD_VAR 0 4
6665: PPUSH
6666: CALL 83488 0 2
// wait ( 3 3$20 ) ;
6670: LD_INT 7000
6672: PPUSH
6673: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6677: LD_ADDR_VAR 0 6
6681: PUSH
6682: LD_INT 124
6684: PUSH
6685: LD_INT 85
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: LD_INT 90
6694: PUSH
6695: LD_INT 61
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: LD_INT 69
6704: PUSH
6705: LD_INT 48
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 68
6714: PUSH
6715: LD_INT 48
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6728: LD_ADDR_VAR 0 7
6732: PUSH
6733: LD_INT 22
6735: PUSH
6736: LD_INT 2
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: LD_INT 21
6745: PUSH
6746: LD_INT 2
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 34
6758: PUSH
6759: LD_INT 31
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 34
6768: PUSH
6769: LD_INT 88
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 34
6778: PUSH
6779: LD_INT 32
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: LIST
6796: PPUSH
6797: CALL_OW 69
6801: PUSH
6802: LD_EXP 80
6806: PUSH
6807: LD_VAR 0 3
6811: ARRAY
6812: PPUSH
6813: LD_INT 2
6815: PUSH
6816: LD_INT 34
6818: PUSH
6819: LD_INT 32
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 34
6828: PUSH
6829: LD_INT 88
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: LIST
6840: PPUSH
6841: CALL_OW 72
6845: DIFF
6846: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6847: LD_INT 0
6849: PPUSH
6850: LD_INT 1
6852: PPUSH
6853: CALL_OW 12
6857: IFFALSE 7007
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6859: LD_ADDR_VAR 0 1
6863: PUSH
6864: DOUBLE
6865: LD_INT 1
6867: DEC
6868: ST_TO_ADDR
6869: LD_INT 3
6871: PUSH
6872: LD_INT 4
6874: PUSH
6875: LD_INT 5
6877: PUSH
6878: LD_INT 6
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: LIST
6885: LIST
6886: PUSH
6887: LD_OWVAR 67
6891: ARRAY
6892: PUSH
6893: FOR_TO
6894: IFFALSE 7003
// begin uc_side := 2 ;
6896: LD_ADDR_OWVAR 20
6900: PUSH
6901: LD_INT 2
6903: ST_TO_ADDR
// uc_nation := 2 ;
6904: LD_ADDR_OWVAR 21
6908: PUSH
6909: LD_INT 2
6911: ST_TO_ADDR
// InitHc ;
6912: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6916: LD_INT 0
6918: PPUSH
6919: LD_INT 15
6921: PUSH
6922: LD_INT 17
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 1
6931: PPUSH
6932: LD_INT 2
6934: PPUSH
6935: CALL_OW 12
6939: ARRAY
6940: PPUSH
6941: LD_INT 8
6943: PPUSH
6944: CALL_OW 380
// un := CreateHuman ;
6948: LD_ADDR_VAR 0 2
6952: PUSH
6953: CALL_OW 44
6957: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_INT 4
6965: PPUSH
6966: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 23
6977: PPUSH
6978: LD_INT 0
6980: PPUSH
6981: CALL_OW 49
// attackers := attackers union un ;
6985: LD_ADDR_VAR 0 7
6989: PUSH
6990: LD_VAR 0 7
6994: PUSH
6995: LD_VAR 0 2
6999: UNION
7000: ST_TO_ADDR
// end ;
7001: GO 6893
7003: POP
7004: POP
// end else
7005: GO 7165
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 2
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: LD_INT 5
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_OWVAR 67
7039: ARRAY
7040: PUSH
7041: FOR_TO
7042: IFFALSE 7163
// begin uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7064: LD_INT 14
7066: PPUSH
7067: LD_INT 3
7069: PPUSH
7070: LD_INT 5
7072: PPUSH
7073: LD_INT 29
7075: PUSH
7076: LD_INT 29
7078: PUSH
7079: LD_INT 26
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_VAR 0 1
7091: PUSH
7092: LD_INT 3
7094: MOD
7095: PUSH
7096: LD_INT 1
7098: PLUS
7099: ARRAY
7100: PPUSH
7101: LD_INT 100
7103: PPUSH
7104: CALL 21275 0 5
// un := CreateVehicle ;
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: CALL_OW 45
7117: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7118: LD_VAR 0 2
7122: PPUSH
7123: LD_INT 4
7125: PPUSH
7126: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7130: LD_VAR 0 2
7134: PPUSH
7135: LD_INT 23
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 49
// attackers := attackers union un ;
7145: LD_ADDR_VAR 0 7
7149: PUSH
7150: LD_VAR 0 7
7154: PUSH
7155: LD_VAR 0 2
7159: UNION
7160: ST_TO_ADDR
// end ;
7161: GO 7041
7163: POP
7164: POP
// end ; if not attackers then
7165: LD_VAR 0 7
7169: NOT
7170: IFFALSE 7174
// exit ;
7172: GO 7291
// ar_attackers := attackers ;
7174: LD_ADDR_EXP 11
7178: PUSH
7179: LD_VAR 0 7
7183: ST_TO_ADDR
// p := 0 ;
7184: LD_ADDR_VAR 0 8
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7192: LD_INT 35
7194: PPUSH
7195: CALL_OW 67
// p := Inc ( p ) ;
7199: LD_ADDR_VAR 0 8
7203: PUSH
7204: LD_VAR 0 8
7208: PPUSH
7209: CALL 55487 0 1
7213: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7214: LD_VAR 0 7
7218: PPUSH
7219: LD_INT 60
7221: PUSH
7222: EMPTY
7223: LIST
7224: PPUSH
7225: CALL_OW 72
7229: NOT
7230: PUSH
7231: LD_VAR 0 8
7235: PUSH
7236: LD_INT 30
7238: GREATER
7239: OR
7240: IFFALSE 7192
// repeat wait ( 0 0$1 ) ;
7242: LD_INT 35
7244: PPUSH
7245: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7249: LD_ADDR_VAR 0 7
7253: PUSH
7254: LD_VAR 0 7
7258: PPUSH
7259: LD_INT 50
7261: PUSH
7262: EMPTY
7263: LIST
7264: PPUSH
7265: CALL_OW 72
7269: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7270: LD_VAR 0 7
7274: PPUSH
7275: LD_VAR 0 6
7279: PPUSH
7280: CALL 56730 0 2
// until not attackers ;
7284: LD_VAR 0 7
7288: NOT
7289: IFFALSE 7242
// end ;
7291: PPOPN 8
7293: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7294: LD_INT 1
7296: PPUSH
7297: CALL_OW 302
7301: PUSH
7302: LD_EXP 9
7306: AND
7307: PUSH
7308: LD_EXP 51
7312: PPUSH
7313: LD_INT 22
7315: PPUSH
7316: CALL_OW 308
7320: AND
7321: IFFALSE 7809
7323: GO 7325
7325: DISABLE
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
7332: PPUSH
7333: PPUSH
7334: PPUSH
7335: PPUSH
// begin base := 1 ;
7336: LD_ADDR_VAR 0 2
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7344: LD_ADDR_VAR 0 4
7348: PUSH
7349: LD_INT 0
7351: PUSH
7352: LD_INT 0
7354: PUSH
7355: LD_INT 0
7357: PUSH
7358: LD_INT 0
7360: PUSH
7361: LD_INT 0
7363: PUSH
7364: LD_INT 0
7366: PUSH
7367: LD_INT 0
7369: PUSH
7370: LD_INT 0
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 0
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7391: LD_ADDR_VAR 0 3
7395: PUSH
7396: LD_INT 13
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: LD_INT 28
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PUSH
7414: LD_INT 13
7416: PUSH
7417: LD_INT 1
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: LD_INT 27
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: PUSH
7432: LD_INT 13
7434: PUSH
7435: LD_INT 1
7437: PUSH
7438: LD_INT 2
7440: PUSH
7441: LD_INT 25
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 11
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: LD_INT 24
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: LD_INT 11
7470: PUSH
7471: LD_INT 2
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 24
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7493: LD_VAR 0 2
7497: PPUSH
7498: LD_VAR 0 3
7502: PPUSH
7503: CALL 83488 0 2
// wait ( 4 4$20 ) ;
7507: LD_INT 9100
7509: PPUSH
7510: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7514: LD_ADDR_VAR 0 5
7518: PUSH
7519: LD_INT 119
7521: PUSH
7522: LD_INT 9
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7532: LD_ADDR_VAR 0 6
7536: PUSH
7537: LD_EXP 80
7541: PUSH
7542: LD_VAR 0 2
7546: ARRAY
7547: PUSH
7548: LD_EXP 80
7552: PUSH
7553: LD_VAR 0 2
7557: ARRAY
7558: PPUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 34
7564: PUSH
7565: LD_INT 32
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 34
7574: PUSH
7575: LD_INT 88
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 72
7591: DIFF
7592: ST_TO_ADDR
// uc_side := 2 ;
7593: LD_ADDR_OWVAR 20
7597: PUSH
7598: LD_INT 2
7600: ST_TO_ADDR
// uc_nation := 2 ;
7601: LD_ADDR_OWVAR 21
7605: PUSH
7606: LD_INT 2
7608: ST_TO_ADDR
// InitHc ;
7609: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7613: LD_ADDR_VAR 0 1
7617: PUSH
7618: DOUBLE
7619: LD_INT 1
7621: DEC
7622: ST_TO_ADDR
7623: LD_INT 4
7625: PUSH
7626: LD_INT 5
7628: PUSH
7629: LD_INT 6
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: PUSH
7641: LD_OWVAR 67
7645: ARRAY
7646: PUSH
7647: FOR_TO
7648: IFFALSE 7725
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7650: LD_INT 0
7652: PPUSH
7653: LD_INT 15
7655: PUSH
7656: LD_INT 17
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 1
7665: PPUSH
7666: LD_INT 2
7668: PPUSH
7669: CALL_OW 12
7673: ARRAY
7674: PPUSH
7675: LD_INT 8
7677: PPUSH
7678: CALL_OW 380
// un := CreateHuman ;
7682: LD_ADDR_VAR 0 7
7686: PUSH
7687: CALL_OW 44
7691: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7692: LD_VAR 0 7
7696: PPUSH
7697: LD_INT 23
7699: PPUSH
7700: LD_INT 0
7702: PPUSH
7703: CALL_OW 49
// attackers := attackers union un ;
7707: LD_ADDR_VAR 0 6
7711: PUSH
7712: LD_VAR 0 6
7716: PUSH
7717: LD_VAR 0 7
7721: UNION
7722: ST_TO_ADDR
// end ;
7723: GO 7647
7725: POP
7726: POP
// p := 0 ;
7727: LD_ADDR_VAR 0 8
7731: PUSH
7732: LD_INT 0
7734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7735: LD_INT 35
7737: PPUSH
7738: CALL_OW 67
// p := Inc ( p ) ;
7742: LD_ADDR_VAR 0 8
7746: PUSH
7747: LD_VAR 0 8
7751: PPUSH
7752: CALL 55487 0 1
7756: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7757: LD_VAR 0 6
7761: PPUSH
7762: LD_INT 60
7764: PUSH
7765: EMPTY
7766: LIST
7767: PPUSH
7768: CALL_OW 72
7772: NOT
7773: PUSH
7774: LD_VAR 0 8
7778: PUSH
7779: LD_INT 30
7781: GREATER
7782: OR
7783: IFFALSE 7735
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7785: LD_VAR 0 2
7789: PPUSH
7790: LD_VAR 0 6
7794: PPUSH
7795: LD_VAR 0 5
7799: PPUSH
7800: LD_VAR 0 4
7804: PPUSH
7805: CALL 83673 0 4
// end ; end_of_file
7809: PPOPN 8
7811: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7812: LD_INT 0
7814: PPUSH
7815: PPUSH
7816: PPUSH
7817: PPUSH
7818: PPUSH
7819: PPUSH
// uc_side := 1 ;
7820: LD_ADDR_OWVAR 20
7824: PUSH
7825: LD_INT 1
7827: ST_TO_ADDR
// uc_nation := 1 ;
7828: LD_ADDR_OWVAR 21
7832: PUSH
7833: LD_INT 1
7835: ST_TO_ADDR
// InitHc ;
7836: CALL_OW 19
// InitVc ;
7840: CALL_OW 20
// tmp := [ ] ;
7844: LD_ADDR_VAR 0 3
7848: PUSH
7849: EMPTY
7850: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7851: LD_ADDR_VAR 0 2
7855: PUSH
7856: DOUBLE
7857: LD_INT 1
7859: DEC
7860: ST_TO_ADDR
7861: LD_INT 6
7863: PUSH
7864: LD_INT 8
7866: PUSH
7867: LD_INT 10
7869: PUSH
7870: LD_INT 10
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: LIST
7878: PUSH
7879: LD_OWVAR 67
7883: ARRAY
7884: PUSH
7885: FOR_TO
7886: IFFALSE 8176
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7888: LD_ADDR_VAR 0 5
7892: PUSH
7893: LD_INT 2
7895: PUSH
7896: LD_INT 4
7898: PUSH
7899: LD_INT 5
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 1
7909: PPUSH
7910: LD_INT 3
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7919: LD_VAR 0 5
7923: PUSH
7924: LD_INT 2
7926: DOUBLE
7927: EQUAL
7928: IFTRUE 7932
7930: GO 7966
7932: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7933: LD_ADDR_VAR 0 6
7937: PUSH
7938: LD_INT 9
7940: PUSH
7941: LD_INT 5
7943: PUSH
7944: LD_INT 7
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 1
7954: PPUSH
7955: LD_INT 3
7957: PPUSH
7958: CALL_OW 12
7962: ARRAY
7963: ST_TO_ADDR
7964: GO 8055
7966: LD_INT 4
7968: DOUBLE
7969: EQUAL
7970: IFTRUE 7974
7972: GO 8012
7974: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7975: LD_ADDR_VAR 0 6
7979: PUSH
7980: LD_INT 9
7982: PUSH
7983: LD_INT 6
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: LD_INT 7
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 1
8000: PPUSH
8001: LD_INT 4
8003: PPUSH
8004: CALL_OW 12
8008: ARRAY
8009: ST_TO_ADDR
8010: GO 8055
8012: LD_INT 5
8014: DOUBLE
8015: EQUAL
8016: IFTRUE 8020
8018: GO 8054
8020: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8021: LD_ADDR_VAR 0 6
8025: PUSH
8026: LD_INT 9
8028: PUSH
8029: LD_INT 6
8031: PUSH
8032: LD_INT 7
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 1
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: CALL_OW 12
8050: ARRAY
8051: ST_TO_ADDR
8052: GO 8055
8054: POP
// uc_side := 1 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 1
8062: ST_TO_ADDR
// uc_nation := 1 ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 1
8070: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8071: LD_VAR 0 5
8075: PPUSH
8076: LD_INT 1
8078: PUSH
8079: LD_INT 3
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 1
8088: PPUSH
8089: LD_INT 2
8091: PPUSH
8092: CALL_OW 12
8096: ARRAY
8097: PPUSH
8098: LD_INT 3
8100: PPUSH
8101: LD_VAR 0 6
8105: PPUSH
8106: LD_INT 70
8108: PPUSH
8109: LD_INT 90
8111: PPUSH
8112: CALL_OW 12
8116: PPUSH
8117: CALL 21275 0 5
// veh := CreateVehicle ;
8121: LD_ADDR_VAR 0 4
8125: PUSH
8126: CALL_OW 45
8130: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8131: LD_VAR 0 4
8135: PPUSH
8136: LD_INT 2
8138: PPUSH
8139: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8143: LD_VAR 0 4
8147: PPUSH
8148: LD_INT 17
8150: PPUSH
8151: LD_INT 0
8153: PPUSH
8154: CALL_OW 49
// tmp := tmp ^ veh ;
8158: LD_ADDR_VAR 0 3
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_VAR 0 4
8172: ADD
8173: ST_TO_ADDR
// end ;
8174: GO 7885
8176: POP
8177: POP
// if not tmp then
8178: LD_VAR 0 3
8182: NOT
8183: IFFALSE 8187
// exit ;
8185: GO 8296
// if not first_powell_attack then
8187: LD_EXP 12
8191: NOT
8192: IFFALSE 8202
// first_powell_attack := true ;
8194: LD_ADDR_EXP 12
8198: PUSH
8199: LD_INT 1
8201: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8202: LD_INT 70
8204: PPUSH
8205: CALL_OW 67
// for i in tmp do
8209: LD_ADDR_VAR 0 2
8213: PUSH
8214: LD_VAR 0 3
8218: PUSH
8219: FOR_IN
8220: IFFALSE 8287
// if IsOk ( i ) then
8222: LD_VAR 0 2
8226: PPUSH
8227: CALL_OW 302
8231: IFFALSE 8269
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8233: LD_VAR 0 2
8237: PPUSH
8238: LD_INT 81
8240: PUSH
8241: LD_INT 1
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PPUSH
8248: CALL_OW 69
8252: PPUSH
8253: LD_VAR 0 2
8257: PPUSH
8258: CALL_OW 74
8262: PPUSH
8263: CALL_OW 115
8267: GO 8285
// tmp := tmp diff i ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_VAR 0 3
8278: PUSH
8279: LD_VAR 0 2
8283: DIFF
8284: ST_TO_ADDR
8285: GO 8219
8287: POP
8288: POP
// until not tmp ;
8289: LD_VAR 0 3
8293: NOT
8294: IFFALSE 8202
// end ;
8296: LD_VAR 0 1
8300: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
8301: LD_INT 0
8303: PPUSH
8304: PPUSH
// uc_side := 1 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 1
8312: ST_TO_ADDR
// uc_nation := 1 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 1
8320: ST_TO_ADDR
// InitHc ;
8321: CALL_OW 19
// InitVc ;
8325: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
8329: LD_INT 5
8331: PPUSH
8332: LD_INT 3
8334: PPUSH
8335: LD_INT 3
8337: PPUSH
8338: LD_INT 12
8340: PPUSH
8341: LD_INT 100
8343: PPUSH
8344: CALL 21275 0 5
// veh := CreateVehicle ;
8348: LD_ADDR_VAR 0 3
8352: PUSH
8353: CALL_OW 45
8357: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8358: LD_VAR 0 3
8362: PPUSH
8363: LD_INT 2
8365: PPUSH
8366: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8370: LD_VAR 0 3
8374: PPUSH
8375: LD_INT 17
8377: PPUSH
8378: LD_INT 0
8380: PPUSH
8381: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_VAR 0 1
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: PPUSH
8399: LD_VAR 0 1
8403: PUSH
8404: LD_INT 2
8406: ARRAY
8407: PPUSH
8408: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
8412: LD_VAR 0 3
8416: PPUSH
8417: LD_INT 59
8419: PPUSH
8420: LD_INT 2
8422: PPUSH
8423: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8427: LD_INT 35
8429: PPUSH
8430: CALL_OW 67
// if not IsOk ( veh ) then
8434: LD_VAR 0 3
8438: PPUSH
8439: CALL_OW 302
8443: NOT
8444: IFFALSE 8448
// exit ;
8446: GO 8502
// until IsAt ( veh , 59 , 2 ) ;
8448: LD_VAR 0 3
8452: PPUSH
8453: LD_INT 59
8455: PPUSH
8456: LD_INT 2
8458: PPUSH
8459: CALL_OW 307
8463: IFFALSE 8427
// RemoveUnit ( veh ) ;
8465: LD_VAR 0 3
8469: PPUSH
8470: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
8474: LD_VAR 0 3
8478: PPUSH
8479: LD_INT 4
8481: PPUSH
8482: CALL_OW 289
8486: IFFALSE 8502
// begin wait ( 0 0$2 ) ;
8488: LD_INT 70
8490: PPUSH
8491: CALL_OW 67
// YouLost ( Artifact ) ;
8495: LD_STRING Artifact
8497: PPUSH
8498: CALL_OW 104
// end ; end ; end_of_file
8502: LD_VAR 0 2
8506: RET
// export function Action ; var tmp , i , un ; begin
8507: LD_INT 0
8509: PPUSH
8510: PPUSH
8511: PPUSH
8512: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8513: LD_INT 68
8515: PPUSH
8516: LD_INT 39
8518: PPUSH
8519: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8523: LD_ADDR_VAR 0 2
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PPUSH
8538: CALL_OW 69
8542: ST_TO_ADDR
// InGameOn ;
8543: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8547: LD_VAR 0 2
8551: PPUSH
8552: LD_INT 71
8554: PPUSH
8555: LD_INT 49
8557: PPUSH
8558: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8562: LD_INT 35
8564: PPUSH
8565: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8569: LD_INT 7
8571: PPUSH
8572: LD_INT 71
8574: PPUSH
8575: LD_INT 51
8577: PPUSH
8578: CALL_OW 293
8582: IFFALSE 8562
// DialogueOn ;
8584: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8588: LD_EXP 16
8592: PPUSH
8593: LD_STRING D1-JMM-1
8595: PPUSH
8596: CALL_OW 88
// if Joan then
8600: LD_EXP 31
8604: IFFALSE 8618
// Say ( Joan , D1-Joan-1 ) ;
8606: LD_EXP 31
8610: PPUSH
8611: LD_STRING D1-Joan-1
8613: PPUSH
8614: CALL_OW 88
// if Lisa then
8618: LD_EXP 18
8622: IFFALSE 8636
// Say ( Lisa , D1-Lisa-1 ) ;
8624: LD_EXP 18
8628: PPUSH
8629: LD_STRING D1-Lisa-1
8631: PPUSH
8632: CALL_OW 88
// if Joan or Lisa then
8636: LD_EXP 31
8640: PUSH
8641: LD_EXP 18
8645: OR
8646: IFFALSE 8660
// Say ( JMM , D1-JMM-2 ) ;
8648: LD_EXP 16
8652: PPUSH
8653: LD_STRING D1-JMM-2
8655: PPUSH
8656: CALL_OW 88
// DialogueOff ;
8660: CALL_OW 7
// InGameOff ;
8664: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8668: LD_INT 71
8670: PPUSH
8671: LD_INT 50
8673: PPUSH
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 30
8679: NEG
8680: PPUSH
8681: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8685: LD_INT 71
8687: PPUSH
8688: LD_INT 50
8690: PPUSH
8691: LD_INT 7
8693: PPUSH
8694: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8698: LD_STRING M1
8700: PPUSH
8701: CALL_OW 337
// SaveForQuickRestart ;
8705: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8716: LD_EXP 3
8720: PUSH
8721: LD_OWVAR 1
8725: PUSH
8726: LD_INT 2100
8728: GREATER
8729: OR
8730: IFFALSE 8709
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8732: LD_INT 350
8734: PPUSH
8735: LD_INT 700
8737: PPUSH
8738: CALL_OW 12
8742: PPUSH
8743: CALL_OW 67
// PrepareGossudarov ;
8747: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
8751: LD_INT 35
8753: PPUSH
8754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8758: LD_INT 22
8760: PUSH
8761: LD_INT 6
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 3
8770: PUSH
8771: LD_INT 24
8773: PUSH
8774: LD_INT 1000
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PPUSH
8789: CALL_OW 69
8793: PUSH
8794: LD_INT 7
8796: PPUSH
8797: LD_EXP 34
8801: PPUSH
8802: CALL_OW 292
8806: OR
8807: IFFALSE 8751
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8809: LD_ADDR_VAR 0 2
8813: PUSH
8814: LD_INT 22
8816: PUSH
8817: LD_INT 6
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PPUSH
8824: CALL_OW 69
8828: ST_TO_ADDR
// for i in tmp do
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_VAR 0 2
8838: PUSH
8839: FOR_IN
8840: IFFALSE 8856
// SetSide ( i , 7 ) ;
8842: LD_VAR 0 3
8846: PPUSH
8847: LD_INT 7
8849: PPUSH
8850: CALL_OW 235
8854: GO 8839
8856: POP
8857: POP
// DialogueOn ;
8858: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8862: LD_EXP 16
8866: PUSH
8867: LD_EXP 17
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PPUSH
8876: LD_EXP 34
8880: PPUSH
8881: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8885: LD_EXP 34
8889: PPUSH
8890: CALL_OW 87
// if not Roth then
8894: LD_EXP 17
8898: NOT
8899: IFFALSE 8991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 3
8908: PUSH
8909: LD_INT 24
8911: PUSH
8912: LD_INT 1000
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PPUSH
8923: CALL_OW 72
8927: IFFALSE 8941
// Say ( JMM , D2-JMM-1 ) ;
8929: LD_EXP 16
8933: PPUSH
8934: LD_STRING D2-JMM-1
8936: PPUSH
8937: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8941: LD_EXP 16
8945: PPUSH
8946: LD_STRING D2-JMM-1b
8948: PPUSH
8949: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8953: LD_EXP 34
8957: PPUSH
8958: LD_STRING D2-Gos-1
8960: PPUSH
8961: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8965: LD_EXP 16
8969: PPUSH
8970: LD_STRING D2-JMM-2
8972: PPUSH
8973: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8977: LD_EXP 34
8981: PPUSH
8982: LD_STRING D2-Gos-2
8984: PPUSH
8985: CALL_OW 88
// end else
8989: GO 9143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8991: LD_VAR 0 2
8995: PPUSH
8996: LD_INT 3
8998: PUSH
8999: LD_INT 24
9001: PUSH
9002: LD_INT 1000
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PPUSH
9013: CALL_OW 72
9017: IFFALSE 9043
// begin Say ( Roth , D2-Roth-2 ) ;
9019: LD_EXP 17
9023: PPUSH
9024: LD_STRING D2-Roth-2
9026: PPUSH
9027: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9031: LD_EXP 16
9035: PPUSH
9036: LD_STRING D2-JMM-1a
9038: PPUSH
9039: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9043: LD_EXP 17
9047: PPUSH
9048: LD_STRING D2-Roth-2a
9050: PPUSH
9051: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9055: LD_EXP 17
9059: PPUSH
9060: LD_STRING D2-Roth-2b
9062: PPUSH
9063: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9067: LD_EXP 16
9071: PPUSH
9072: LD_STRING D2-JMM-3
9074: PPUSH
9075: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9079: LD_VAR 0 2
9083: PPUSH
9084: LD_INT 3
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 1000
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL_OW 72
9105: IFFALSE 9143
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9107: LD_EXP 34
9111: PPUSH
9112: LD_STRING D2-Gos-3
9114: PPUSH
9115: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9119: LD_EXP 16
9123: PPUSH
9124: LD_STRING D2-JMM-4
9126: PPUSH
9127: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9131: LD_EXP 34
9135: PPUSH
9136: LD_STRING D2-Gos-4
9138: PPUSH
9139: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9143: LD_EXP 16
9147: PPUSH
9148: LD_STRING D2-JMM-5
9150: PPUSH
9151: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9155: LD_EXP 34
9159: PPUSH
9160: LD_STRING D2-Gos-5
9162: PPUSH
9163: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9167: LD_EXP 16
9171: PPUSH
9172: LD_STRING D2-JMM-6
9174: PPUSH
9175: CALL_OW 88
// DialogueOff ;
9179: CALL_OW 7
// wait ( 0 0$2 ) ;
9183: LD_INT 70
9185: PPUSH
9186: CALL_OW 67
// if Kirilenkova then
9190: LD_EXP 35
9194: IFFALSE 9208
// Say ( Kirilenkova , D3-Kir-1 ) ;
9196: LD_EXP 35
9200: PPUSH
9201: LD_STRING D3-Kir-1
9203: PPUSH
9204: CALL_OW 88
// gossudarov_arrive := true ;
9208: LD_ADDR_EXP 4
9212: PUSH
9213: LD_INT 1
9215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9216: LD_INT 35
9218: PPUSH
9219: CALL_OW 67
// until ru_lab_builded ;
9223: LD_EXP 5
9227: IFFALSE 9216
// DialogueOn ;
9229: CALL_OW 6
// if Kirilenkova then
9233: LD_EXP 35
9237: IFFALSE 9253
// Say ( Kirilenkova , D3a-Kir-1 ) else
9239: LD_EXP 35
9243: PPUSH
9244: LD_STRING D3a-Kir-1
9246: PPUSH
9247: CALL_OW 88
9251: GO 9275
// begin un := SciRu ;
9253: LD_ADDR_VAR 0 4
9257: PUSH
9258: CALL 14789 0 0
9262: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
9263: LD_VAR 0 4
9267: PPUSH
9268: LD_STRING D3a-Sci1-1
9270: PPUSH
9271: CALL_OW 88
// end ; if Kirilenkova or un then
9275: LD_EXP 35
9279: PUSH
9280: LD_VAR 0 4
9284: OR
9285: IFFALSE 9299
// Say ( JMM , D3a-JMM-1 ) ;
9287: LD_EXP 16
9291: PPUSH
9292: LD_STRING D3a-JMM-1
9294: PPUSH
9295: CALL_OW 88
// DialogueOff ;
9299: CALL_OW 7
// end ;
9303: LD_VAR 0 1
9307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9308: LD_EXP 4
9312: PUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 7
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PUSH
9323: LD_INT 2
9325: PUSH
9326: LD_INT 25
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 25
9338: PUSH
9339: LD_INT 2
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 25
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: LD_INT 25
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: LD_INT 25
9368: PUSH
9369: LD_INT 5
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: PUSH
9376: LD_INT 25
9378: PUSH
9379: LD_INT 8
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 25
9388: PUSH
9389: LD_INT 9
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: PUSH
9415: LD_INT 7
9417: LESS
9418: AND
9419: IFFALSE 9431
9421: GO 9423
9423: DISABLE
// YouLost ( TooMany ) ;
9424: LD_STRING TooMany
9426: PPUSH
9427: CALL_OW 104
9431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9432: LD_EXP 34
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 7
9444: EQUAL
9445: IFFALSE 9662
9447: GO 9449
9449: DISABLE
9450: LD_INT 0
9452: PPUSH
9453: PPUSH
9454: PPUSH
// begin uc_side := 3 ;
9455: LD_ADDR_OWVAR 20
9459: PUSH
9460: LD_INT 3
9462: ST_TO_ADDR
// uc_nation := 3 ;
9463: LD_ADDR_OWVAR 21
9467: PUSH
9468: LD_INT 3
9470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9471: LD_INT 21
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: LD_INT 3
9479: PPUSH
9480: LD_INT 42
9482: PPUSH
9483: LD_INT 100
9485: PPUSH
9486: CALL 21275 0 5
// un := CreateVehicle ;
9490: LD_ADDR_VAR 0 3
9494: PUSH
9495: CALL_OW 45
9499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9500: LD_VAR 0 3
9504: PPUSH
9505: LD_INT 15
9507: PPUSH
9508: LD_INT 0
9510: PPUSH
9511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9515: LD_VAR 0 3
9519: PPUSH
9520: LD_INT 67
9522: PPUSH
9523: LD_INT 45
9525: PPUSH
9526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9530: LD_VAR 0 3
9534: PPUSH
9535: LD_INT 70
9537: PPUSH
9538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9542: LD_VAR 0 3
9546: PPUSH
9547: LD_INT 69
9549: PPUSH
9550: LD_INT 18
9552: PPUSH
9553: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9557: LD_VAR 0 3
9561: PPUSH
9562: LD_INT 60
9564: PPUSH
9565: LD_INT 3
9567: PPUSH
9568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9572: LD_INT 35
9574: PPUSH
9575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9579: LD_VAR 0 3
9583: PPUSH
9584: CALL_OW 302
9588: NOT
9589: PUSH
9590: LD_VAR 0 3
9594: PPUSH
9595: LD_INT 17
9597: PPUSH
9598: CALL_OW 308
9602: OR
9603: PUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: LD_INT 60
9611: PPUSH
9612: LD_INT 3
9614: PPUSH
9615: CALL_OW 307
9619: OR
9620: IFFALSE 9572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9622: LD_VAR 0 3
9626: PPUSH
9627: LD_INT 17
9629: PPUSH
9630: CALL_OW 308
9634: PUSH
9635: LD_VAR 0 3
9639: PPUSH
9640: LD_INT 60
9642: PPUSH
9643: LD_INT 3
9645: PPUSH
9646: CALL_OW 307
9650: OR
9651: IFFALSE 9662
// RemoveUnit ( un ) ;
9653: LD_VAR 0 3
9657: PPUSH
9658: CALL_OW 64
// end ;
9662: PPOPN 3
9664: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9665: LD_EXP 4
9669: IFFALSE 9911
9671: GO 9673
9673: DISABLE
9674: LD_INT 0
9676: PPUSH
9677: PPUSH
9678: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9679: LD_INT 70
9681: PPUSH
9682: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9686: LD_ADDR_VAR 0 3
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 7
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 3
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PPUSH
9715: CALL_OW 69
9719: ST_TO_ADDR
// until tmp ;
9720: LD_VAR 0 3
9724: IFFALSE 9679
// un := NearestUnitToUnit ( tmp , JMM ) ;
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_VAR 0 3
9735: PPUSH
9736: LD_EXP 16
9740: PPUSH
9741: CALL_OW 74
9745: ST_TO_ADDR
// player_spotted := true ;
9746: LD_ADDR_EXP 6
9750: PUSH
9751: LD_INT 1
9753: ST_TO_ADDR
// tmp := SciRu ;
9754: LD_ADDR_VAR 0 3
9758: PUSH
9759: CALL 14789 0 0
9763: ST_TO_ADDR
// if not tmp then
9764: LD_VAR 0 3
9768: NOT
9769: IFFALSE 9781
// tmp := SolRu ;
9771: LD_ADDR_VAR 0 3
9775: PUSH
9776: CALL 14936 0 0
9780: ST_TO_ADDR
// DialogueOn ;
9781: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9785: LD_VAR 0 2
9789: PPUSH
9790: CALL_OW 250
9794: PPUSH
9795: LD_VAR 0 2
9799: PPUSH
9800: CALL_OW 251
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: LD_INT 8
9810: NEG
9811: PPUSH
9812: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9816: LD_VAR 0 2
9820: PPUSH
9821: CALL_OW 87
// if tmp then
9825: LD_VAR 0 3
9829: IFFALSE 9843
// Say ( tmp , D4-RSci1-1 ) ;
9831: LD_VAR 0 3
9835: PPUSH
9836: LD_STRING D4-RSci1-1
9838: PPUSH
9839: CALL_OW 88
// if Gossudarov then
9843: LD_EXP 34
9847: IFFALSE 9873
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9849: LD_EXP 34
9853: PPUSH
9854: LD_STRING D4-Gos-1
9856: PPUSH
9857: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9861: LD_EXP 16
9865: PPUSH
9866: LD_STRING D4-JMM-1
9868: PPUSH
9869: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9873: LD_VAR 0 2
9877: PPUSH
9878: CALL_OW 250
9882: PPUSH
9883: LD_VAR 0 2
9887: PPUSH
9888: CALL_OW 251
9892: PPUSH
9893: LD_INT 7
9895: PPUSH
9896: CALL_OW 331
// DialogueOff ;
9900: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9904: LD_STRING M5
9906: PPUSH
9907: CALL_OW 337
// end ;
9911: PPOPN 3
9913: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9914: LD_EXP 6
9918: IFFALSE 10511
9920: GO 9922
9922: DISABLE
9923: LD_INT 0
9925: PPUSH
9926: PPUSH
9927: PPUSH
// begin PrepareBelkov ;
9928: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9932: LD_EXP 49
9936: PPUSH
9937: LD_INT 118
9939: PPUSH
9940: LD_INT 106
9942: PPUSH
9943: CALL_OW 111
// AddComHold ( Belkov ) ;
9947: LD_EXP 49
9951: PPUSH
9952: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9956: LD_INT 35
9958: PPUSH
9959: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9963: LD_EXP 49
9967: PPUSH
9968: LD_INT 118
9970: PPUSH
9971: LD_INT 106
9973: PPUSH
9974: CALL_OW 307
9978: IFFALSE 9956
// ChangeSideFog ( 4 , 7 ) ;
9980: LD_INT 4
9982: PPUSH
9983: LD_INT 7
9985: PPUSH
9986: CALL_OW 343
// if IsOk ( Belkov ) then
9990: LD_EXP 49
9994: PPUSH
9995: CALL_OW 302
9999: IFFALSE 10083
// begin InGameOn ;
10001: CALL_OW 8
// DialogueOn ;
10005: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10009: LD_EXP 49
10013: PPUSH
10014: LD_STRING D5-Bel-1
10016: PPUSH
10017: CALL_OW 94
// if Gossudarov then
10021: LD_EXP 34
10025: IFFALSE 10075
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10027: LD_EXP 34
10031: PPUSH
10032: LD_STRING D5-Gos-1
10034: PPUSH
10035: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10039: LD_EXP 16
10043: PPUSH
10044: LD_STRING D5-JMM-1
10046: PPUSH
10047: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10051: LD_EXP 34
10055: PPUSH
10056: LD_STRING D5-Gos-2
10058: PPUSH
10059: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10063: LD_EXP 16
10067: PPUSH
10068: LD_STRING D5-JMM-2
10070: PPUSH
10071: CALL_OW 88
// end ; DialogueOff ;
10075: CALL_OW 7
// InGameOff ;
10079: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10083: LD_STRING QSaveBelkov
10085: PPUSH
10086: CALL_OW 97
10090: PUSH
10091: LD_INT 1
10093: DOUBLE
10094: EQUAL
10095: IFTRUE 10099
10097: GO 10149
10099: POP
// begin DialogueOn ;
10100: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10104: LD_EXP 16
10108: PPUSH
10109: LD_STRING D5a-JMM-1
10111: PPUSH
10112: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10116: LD_EXP 49
10120: PPUSH
10121: LD_STRING D5a-Bel-1
10123: PPUSH
10124: CALL_OW 94
// DialogueOff ;
10128: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10132: LD_EXP 49
10136: PPUSH
10137: LD_INT 83
10139: PPUSH
10140: LD_INT 49
10142: PPUSH
10143: CALL_OW 111
// end ; 2 :
10147: GO 10182
10149: LD_INT 2
10151: DOUBLE
10152: EQUAL
10153: IFTRUE 10157
10155: GO 10181
10157: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10158: LD_EXP 16
10162: PPUSH
10163: LD_STRING D5a-JMM-2
10165: PPUSH
10166: CALL_OW 88
// ComHold ( Belkov ) ;
10170: LD_EXP 49
10174: PPUSH
10175: CALL_OW 140
// end ; end ;
10179: GO 10182
10181: POP
// time := 0 0$00 ;
10182: LD_ADDR_VAR 0 1
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
// vehSpawned := false ;
10190: LD_ADDR_VAR 0 3
10194: PUSH
10195: LD_INT 0
10197: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10198: LD_INT 35
10200: PPUSH
10201: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 350
10212: PUSH
10213: LD_INT 175
10215: PUSH
10216: LD_INT 105
10218: PUSH
10219: LD_INT 70
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_OWVAR 67
10232: ARRAY
10233: GREATEREQUAL
10234: PUSH
10235: LD_VAR 0 3
10239: NOT
10240: AND
10241: IFFALSE 10331
// begin vehSpawned := true ;
10243: LD_ADDR_VAR 0 3
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// uc_side := 3 ;
10251: LD_ADDR_OWVAR 20
10255: PUSH
10256: LD_INT 3
10258: ST_TO_ADDR
// uc_nation := 3 ;
10259: LD_ADDR_OWVAR 21
10263: PUSH
10264: LD_INT 3
10266: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
10267: LD_INT 22
10269: PPUSH
10270: LD_INT 3
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: LD_INT 43
10278: PPUSH
10279: LD_INT 100
10281: PPUSH
10282: CALL 21275 0 5
// veh := CreateVehicle ;
10286: LD_ADDR_VAR 0 2
10290: PUSH
10291: CALL_OW 45
10295: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10296: LD_VAR 0 2
10300: PPUSH
10301: LD_INT 130
10303: PPUSH
10304: LD_INT 131
10306: PPUSH
10307: LD_INT 0
10309: PPUSH
10310: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10314: LD_VAR 0 2
10318: PPUSH
10319: LD_INT 100
10321: PPUSH
10322: LD_INT 82
10324: PPUSH
10325: CALL_OW 114
// end else
10329: GO 10345
// time := time + 0 0$1 ;
10331: LD_ADDR_VAR 0 1
10335: PUSH
10336: LD_VAR 0 1
10340: PUSH
10341: LD_INT 35
10343: PLUS
10344: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10345: LD_EXP 49
10349: PPUSH
10350: CALL_OW 301
10354: PUSH
10355: LD_EXP 49
10359: PPUSH
10360: CALL_OW 255
10364: PUSH
10365: LD_INT 4
10367: EQUAL
10368: AND
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 69
10384: PPUSH
10385: LD_EXP 49
10389: PPUSH
10390: CALL_OW 74
10394: PPUSH
10395: LD_EXP 49
10399: PPUSH
10400: CALL_OW 296
10404: PUSH
10405: LD_INT 10
10407: LESS
10408: OR
10409: IFFALSE 10198
// if IsDead ( Belkov ) then
10411: LD_EXP 49
10415: PPUSH
10416: CALL_OW 301
10420: IFFALSE 10445
// begin CenterNowOnUnits ( Belkov ) ;
10422: LD_EXP 49
10426: PPUSH
10427: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10431: LD_EXP 16
10435: PPUSH
10436: LD_STRING D5a-JMM-2a
10438: PPUSH
10439: CALL_OW 88
// exit ;
10443: GO 10511
// end ; if See ( 7 , Belkov ) then
10445: LD_INT 7
10447: PPUSH
10448: LD_EXP 49
10452: PPUSH
10453: CALL_OW 292
10457: IFFALSE 10471
// SetSide ( Belkov , 7 ) ;
10459: LD_EXP 49
10463: PPUSH
10464: LD_INT 7
10466: PPUSH
10467: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10478: LD_EXP 49
10482: PPUSH
10483: LD_INT 66
10485: PPUSH
10486: LD_INT 45
10488: PPUSH
10489: CALL_OW 297
10493: PUSH
10494: LD_INT 30
10496: LESS
10497: IFFALSE 10471
// Say ( Belkov , D6-Bel-1 ) ;
10499: LD_EXP 49
10503: PPUSH
10504: LD_STRING D6-Bel-1
10506: PPUSH
10507: CALL_OW 88
// end ;
10511: PPOPN 3
10513: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10514: LD_EXP 49
10518: PPUSH
10519: CALL_OW 302
10523: PUSH
10524: LD_EXP 49
10528: PPUSH
10529: CALL_OW 504
10533: PUSH
10534: LD_INT 2
10536: PUSH
10537: LD_INT 34
10539: PUSH
10540: LD_INT 47
10542: PUSH
10543: EMPTY
10544: LIST
10545: LIST
10546: PUSH
10547: LD_INT 34
10549: PUSH
10550: LD_INT 45
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 69
10566: IN
10567: AND
10568: IFFALSE 10585
10570: GO 10572
10572: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10573: LD_EXP 49
10577: PPUSH
10578: LD_STRING D7-Bel-1
10580: PPUSH
10581: CALL_OW 88
10585: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10586: LD_INT 22
10588: PUSH
10589: LD_INT 7
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 101
10598: PUSH
10599: LD_INT 2
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 69
10614: PUSH
10615: LD_EXP 8
10619: NOT
10620: AND
10621: PUSH
10622: LD_EXP 48
10626: PPUSH
10627: CALL_OW 305
10631: NOT
10632: AND
10633: IFFALSE 11118
10635: GO 10637
10637: DISABLE
10638: LD_INT 0
10640: PPUSH
// begin ar_base_spotted := true ;
10641: LD_ADDR_EXP 8
10645: PUSH
10646: LD_INT 1
10648: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10649: LD_ADDR_VAR 0 1
10653: PUSH
10654: LD_INT 22
10656: PUSH
10657: LD_INT 2
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 21
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PPUSH
10678: CALL_OW 69
10682: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 1
10692: PPUSH
10693: LD_EXP 16
10697: PPUSH
10698: CALL_OW 74
10702: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10703: LD_INT 7
10705: PPUSH
10706: LD_INT 3
10708: PPUSH
10709: CALL_OW 332
// DialogueOn ;
10713: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 250
10726: PPUSH
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 251
10736: PPUSH
10737: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10741: LD_ADDR_VAR 0 1
10745: PUSH
10746: LD_INT 22
10748: PUSH
10749: LD_INT 7
10751: PUSH
10752: EMPTY
10753: LIST
10754: LIST
10755: PUSH
10756: LD_INT 23
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 26
10768: PUSH
10769: LD_INT 1
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PUSH
10786: LD_EXP 16
10790: PUSH
10791: LD_EXP 20
10795: PUSH
10796: LD_EXP 21
10800: PUSH
10801: LD_EXP 28
10805: PUSH
10806: LD_EXP 17
10810: PUSH
10811: LD_EXP 26
10815: PUSH
10816: LD_EXP 22
10820: PUSH
10821: LD_EXP 24
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: DIFF
10836: ST_TO_ADDR
// if not tmp then
10837: LD_VAR 0 1
10841: NOT
10842: IFFALSE 10916
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10844: LD_ADDR_VAR 0 1
10848: PUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 7
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 23
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PUSH
10889: LD_EXP 31
10893: PUSH
10894: LD_EXP 18
10898: PUSH
10899: LD_EXP 29
10903: PUSH
10904: LD_EXP 30
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: DIFF
10915: ST_TO_ADDR
// if tmp then
10916: LD_VAR 0 1
10920: IFFALSE 10991
// case GetSex ( tmp [ 1 ] ) of sex_male :
10922: LD_VAR 0 1
10926: PUSH
10927: LD_INT 1
10929: ARRAY
10930: PPUSH
10931: CALL_OW 258
10935: PUSH
10936: LD_INT 1
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 10963
10944: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_STRING D9-Sol1-1
10956: PPUSH
10957: CALL_OW 88
10961: GO 10991
10963: LD_INT 2
10965: DOUBLE
10966: EQUAL
10967: IFTRUE 10971
10969: GO 10990
10971: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10972: LD_VAR 0 1
10976: PUSH
10977: LD_INT 1
10979: ARRAY
10980: PPUSH
10981: LD_STRING D9-FSol1-1
10983: PPUSH
10984: CALL_OW 88
10988: GO 10991
10990: POP
// if Frank then
10991: LD_EXP 28
10995: IFFALSE 11099
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10997: LD_EXP 58
11001: PPUSH
11002: CALL_OW 250
11006: PPUSH
11007: LD_EXP 58
11011: PPUSH
11012: CALL_OW 251
11016: PPUSH
11017: LD_INT 7
11019: PPUSH
11020: LD_INT 8
11022: PPUSH
11023: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11027: LD_EXP 58
11031: PPUSH
11032: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11036: LD_EXP 28
11040: PPUSH
11041: LD_STRING D9-Frank-1
11043: PPUSH
11044: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11048: LD_EXP 16
11052: PPUSH
11053: LD_STRING D9-JMM-1
11055: PPUSH
11056: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11060: LD_EXP 28
11064: PPUSH
11065: LD_STRING D9-Frank-2
11067: PPUSH
11068: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11072: LD_EXP 58
11076: PPUSH
11077: CALL_OW 250
11081: PPUSH
11082: LD_EXP 58
11086: PPUSH
11087: CALL_OW 251
11091: PPUSH
11092: LD_INT 7
11094: PPUSH
11095: CALL_OW 331
// end ; DialogueOff ;
11099: CALL_OW 7
// wait ( 1 1$00 ) ;
11103: LD_INT 2100
11105: PPUSH
11106: CALL_OW 67
// ar_active_attack := true ;
11110: LD_ADDR_EXP 9
11114: PUSH
11115: LD_INT 1
11117: ST_TO_ADDR
// end ;
11118: PPOPN 1
11120: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11121: LD_EXP 7
11125: PUSH
11126: LD_OWVAR 1
11130: PUSH
11131: LD_INT 42000
11133: GREATEREQUAL
11134: OR
11135: IFFALSE 12187
11137: GO 11139
11139: DISABLE
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
// begin selected_option := 1 ;
11144: LD_ADDR_VAR 0 2
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11152: LD_INT 10500
11154: PPUSH
11155: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until not ru_attackers ;
11166: LD_EXP 54
11170: NOT
11171: IFFALSE 11159
// PrepareBurlak ;
11173: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
11177: LD_INT 70
11179: PPUSH
11180: CALL_OW 67
// until not HasTask ( Burlak ) ;
11184: LD_EXP 48
11188: PPUSH
11189: CALL_OW 314
11193: NOT
11194: IFFALSE 11177
// InGameOn ;
11196: CALL_OW 8
// DialogueOn ;
11200: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
11204: LD_EXP 51
11208: PPUSH
11209: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
11213: LD_EXP 48
11217: PPUSH
11218: LD_STRING D10-Bur-1
11220: PPUSH
11221: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
11225: LD_EXP 49
11229: PUSH
11230: LD_EXP 49
11234: PPUSH
11235: CALL_OW 255
11239: PUSH
11240: LD_INT 7
11242: EQUAL
11243: AND
11244: IFFALSE 11258
// Say ( Belkov , D10-Bel-1 ) ;
11246: LD_EXP 49
11250: PPUSH
11251: LD_STRING D10-Bel-1
11253: PPUSH
11254: CALL_OW 88
// if Gossudarov then
11258: LD_EXP 34
11262: IFFALSE 11276
// Say ( Gossudarov , D10-Gos-1 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_STRING D10-Gos-1
11271: PPUSH
11272: CALL_OW 88
// if Kirilenkova then
11276: LD_EXP 35
11280: IFFALSE 11294
// Say ( Kirilenkova , D10-Kir-1 ) ;
11282: LD_EXP 35
11286: PPUSH
11287: LD_STRING D10-Kir-1
11289: PPUSH
11290: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
11294: CALL 14936 0 0
11298: PPUSH
11299: LD_STRING D10-RSol1-1
11301: PPUSH
11302: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11306: LD_EXP 48
11310: PPUSH
11311: LD_STRING D10-Bur-2
11313: PPUSH
11314: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11318: LD_EXP 16
11322: PPUSH
11323: LD_STRING D10-JMM-2
11325: PPUSH
11326: CALL_OW 88
// if Kirilenkova then
11330: LD_EXP 35
11334: IFFALSE 11350
// Say ( Kirilenkova , D10-Kir-2 ) else
11336: LD_EXP 35
11340: PPUSH
11341: LD_STRING D10-Kir-2
11343: PPUSH
11344: CALL_OW 88
11348: GO 11362
// Say ( SolRu , D10-RSol1-2 ) ;
11350: CALL 14936 0 0
11354: PPUSH
11355: LD_STRING D10-RSol1-2
11357: PPUSH
11358: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11362: LD_EXP 16
11366: PPUSH
11367: LD_STRING D10-JMM-3
11369: PPUSH
11370: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11374: LD_EXP 48
11378: PPUSH
11379: LD_STRING D10-Bur-3
11381: PPUSH
11382: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11386: LD_EXP 16
11390: PPUSH
11391: LD_STRING D10-JMM-4
11393: PPUSH
11394: CALL_OW 88
// DialogueOff ;
11398: CALL_OW 7
// InGameOff ;
11402: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11406: LD_STRING M2
11408: PPUSH
11409: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11413: LD_INT 35
11415: PPUSH
11416: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 91
11432: PUSH
11433: LD_EXP 48
11437: PUSH
11438: LD_INT 8
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: LIST
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: IFFALSE 11413
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11456: LD_ADDR_VAR 0 1
11460: PUSH
11461: LD_INT 22
11463: PUSH
11464: LD_INT 4
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PPUSH
11471: CALL_OW 69
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11493
// SetSide ( i , 7 ) ;
11479: LD_VAR 0 1
11483: PPUSH
11484: LD_INT 7
11486: PPUSH
11487: CALL_OW 235
11491: GO 11476
11493: POP
11494: POP
// ChangeMissionObjectives ( M3 ) ;
11495: LD_STRING M3
11497: PPUSH
11498: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11502: LD_INT 35
11504: PPUSH
11505: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11509: LD_EXP 16
11513: PPUSH
11514: LD_EXP 48
11518: PPUSH
11519: CALL_OW 296
11523: PUSH
11524: LD_INT 8
11526: LESS
11527: IFFALSE 11502
// ComTurnUnit ( JMM , Burlak ) ;
11529: LD_EXP 16
11533: PPUSH
11534: LD_EXP 48
11538: PPUSH
11539: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11543: LD_EXP 48
11547: PPUSH
11548: LD_EXP 16
11552: PPUSH
11553: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11557: LD_INT 10
11559: PPUSH
11560: CALL_OW 67
// DialogueOn ;
11564: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11568: LD_EXP 16
11572: PPUSH
11573: LD_STRING D11-JMM-1
11575: PPUSH
11576: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11580: LD_EXP 48
11584: PPUSH
11585: LD_STRING D11-Bur-1
11587: PPUSH
11588: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11592: LD_EXP 16
11596: PPUSH
11597: LD_STRING D11-JMM-2
11599: PPUSH
11600: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11604: LD_EXP 48
11608: PPUSH
11609: LD_STRING D11-Bur-2
11611: PPUSH
11612: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11616: LD_EXP 16
11620: PPUSH
11621: LD_STRING D11-JMM-3
11623: PPUSH
11624: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11628: LD_EXP 48
11632: PPUSH
11633: LD_STRING D11-Bur-3
11635: PPUSH
11636: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11640: LD_EXP 16
11644: PPUSH
11645: LD_STRING D11-JMM-4
11647: PPUSH
11648: CALL_OW 88
// if ar_base_spotted then
11652: LD_EXP 8
11656: IFFALSE 11672
// Say ( Burlak , D12-Bur-1 ) else
11658: LD_EXP 48
11662: PPUSH
11663: LD_STRING D12-Bur-1
11665: PPUSH
11666: CALL_OW 88
11670: GO 11711
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11672: LD_INT 7
11674: PPUSH
11675: LD_INT 3
11677: PPUSH
11678: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11682: LD_INT 127
11684: PPUSH
11685: LD_INT 45
11687: PPUSH
11688: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11692: LD_EXP 48
11696: PPUSH
11697: LD_STRING D12-Bur-1a
11699: PPUSH
11700: CALL_OW 88
// dwait ( 0 0$2 ) ;
11704: LD_INT 70
11706: PPUSH
11707: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
11711: LD_EXP 57
11715: PPUSH
11716: CALL_OW 302
11720: NOT
11721: IFFALSE 11729
// begin DialogueOff ;
11723: CALL_OW 7
// exit ;
11727: GO 12187
// end ; Say ( Burlak , D12-Bur-1b ) ;
11729: LD_EXP 48
11733: PPUSH
11734: LD_STRING D12-Bur-1b
11736: PPUSH
11737: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11741: LD_EXP 16
11745: PPUSH
11746: LD_STRING D12-JMM-1
11748: PPUSH
11749: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11753: LD_EXP 48
11757: PPUSH
11758: LD_STRING D12-Bur-2
11760: PPUSH
11761: CALL_OW 88
// if Roth then
11765: LD_EXP 17
11769: IFFALSE 11785
// Say ( Roth , D12-Roth-2 ) else
11771: LD_EXP 17
11775: PPUSH
11776: LD_STRING D12-Roth-2
11778: PPUSH
11779: CALL_OW 88
11783: GO 11797
// Say ( SciRu , D12-RSci1-2 ) ;
11785: CALL 14789 0 0
11789: PPUSH
11790: LD_STRING D12-RSci1-2
11792: PPUSH
11793: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11797: LD_EXP 16
11801: PPUSH
11802: LD_STRING D12-JMM-2
11804: PPUSH
11805: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11809: LD_EXP 48
11813: PPUSH
11814: LD_STRING D12-Bur-3
11816: PPUSH
11817: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11821: LD_EXP 16
11825: PPUSH
11826: LD_STRING D12-JMM-3
11828: PPUSH
11829: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11833: LD_EXP 48
11837: PPUSH
11838: LD_STRING D12-Bur-4
11840: PPUSH
11841: CALL_OW 88
// case Query ( QBase ) of 1 :
11845: LD_STRING QBase
11847: PPUSH
11848: CALL_OW 97
11852: PUSH
11853: LD_INT 1
11855: DOUBLE
11856: EQUAL
11857: IFTRUE 11861
11859: GO 11979
11861: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11862: LD_EXP 16
11866: PPUSH
11867: LD_STRING D13a-JMM-1
11869: PPUSH
11870: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11874: LD_EXP 48
11878: PPUSH
11879: LD_STRING D13a-Bur-1
11881: PPUSH
11882: CALL_OW 88
// if Roth then
11886: LD_EXP 17
11890: IFFALSE 11906
// Say ( Roth , D13a-Roth-1 ) else
11892: LD_EXP 17
11896: PPUSH
11897: LD_STRING D13a-Roth-1
11899: PPUSH
11900: CALL_OW 88
11904: GO 11918
// Say ( SciRu , D13a-RSci1-1 ) ;
11906: CALL 14789 0 0
11910: PPUSH
11911: LD_STRING D13a-RSci1-1
11913: PPUSH
11914: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11918: LD_EXP 16
11922: PPUSH
11923: LD_STRING D13a-JMM-2
11925: PPUSH
11926: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11930: LD_STRING QBaseAgain
11932: PPUSH
11933: CALL_OW 97
11937: PUSH
11938: LD_INT 1
11940: DOUBLE
11941: EQUAL
11942: IFTRUE 11946
11944: GO 11957
11946: POP
// selected_option := 2 ; 2 :
11947: LD_ADDR_VAR 0 2
11951: PUSH
11952: LD_INT 2
11954: ST_TO_ADDR
11955: GO 11977
11957: LD_INT 2
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// selected_option := 3 ; end ;
11966: LD_ADDR_VAR 0 2
11970: PUSH
11971: LD_INT 3
11973: ST_TO_ADDR
11974: GO 11977
11976: POP
// end ; 2 :
11977: GO 12018
11979: LD_INT 2
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// selected_option := 2 ; 3 :
11988: LD_ADDR_VAR 0 2
11992: PUSH
11993: LD_INT 2
11995: ST_TO_ADDR
11996: GO 12018
11998: LD_INT 3
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// selected_option := 3 ; end ;
12007: LD_ADDR_VAR 0 2
12011: PUSH
12012: LD_INT 3
12014: ST_TO_ADDR
12015: GO 12018
12017: POP
// if selected_option = 2 then
12018: LD_VAR 0 2
12022: PUSH
12023: LD_INT 2
12025: EQUAL
12026: IFFALSE 12120
// begin Say ( JMM , D13b-JMM-1 ) ;
12028: LD_EXP 16
12032: PPUSH
12033: LD_STRING D13b-JMM-1
12035: PPUSH
12036: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12040: LD_EXP 48
12044: PPUSH
12045: LD_STRING D13b-Bur-1
12047: PPUSH
12048: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12052: LD_EXP 16
12056: PPUSH
12057: LD_STRING D13b-JMM-2
12059: PPUSH
12060: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12064: LD_EXP 57
12068: PPUSH
12069: LD_STRING D13b-Abd-2
12071: PPUSH
12072: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12076: LD_EXP 16
12080: PPUSH
12081: LD_STRING D13b-JMM-3
12083: PPUSH
12084: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12088: LD_EXP 57
12092: PPUSH
12093: LD_STRING D13b-Abd-3
12095: PPUSH
12096: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12100: LD_EXP 16
12104: PPUSH
12105: LD_STRING D13b-JMM-4
12107: PPUSH
12108: CALL_OW 88
// ar_active_attack := true ;
12112: LD_ADDR_EXP 9
12116: PUSH
12117: LD_INT 1
12119: ST_TO_ADDR
// end ; if selected_option = 3 then
12120: LD_VAR 0 2
12124: PUSH
12125: LD_INT 3
12127: EQUAL
12128: IFFALSE 12154
// begin Say ( JMM , D13c-JMM-1 ) ;
12130: LD_EXP 16
12134: PPUSH
12135: LD_STRING D13c-JMM-1
12137: PPUSH
12138: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12142: LD_EXP 48
12146: PPUSH
12147: LD_STRING D13c-Bur-1
12149: PPUSH
12150: CALL_OW 88
// end ; DialogueOff ;
12154: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12158: LD_STRING M4
12160: PPUSH
12161: CALL_OW 337
// if not ar_active_attack then
12165: LD_EXP 9
12169: NOT
12170: IFFALSE 12187
// begin wait ( 6 6$00 ) ;
12172: LD_INT 12600
12174: PPUSH
12175: CALL_OW 67
// ar_active_attack := true ;
12179: LD_ADDR_EXP 9
12183: PUSH
12184: LD_INT 1
12186: ST_TO_ADDR
// end ; end ;
12187: PPOPN 2
12189: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
12190: LD_EXP 48
12194: PPUSH
12195: CALL_OW 305
12199: PUSH
12200: LD_EXP 48
12204: PPUSH
12205: CALL_OW 255
12209: PUSH
12210: LD_INT 7
12212: EQUAL
12213: AND
12214: IFFALSE 12437
12216: GO 12218
12218: DISABLE
12219: LD_INT 0
12221: PPUSH
// begin wait ( 4 4$40 ) ;
12222: LD_INT 9800
12224: PPUSH
12225: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12229: LD_INT 35
12231: PPUSH
12232: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
12236: LD_EXP 54
12240: NOT
12241: PUSH
12242: LD_INT 22
12244: PUSH
12245: LD_INT 6
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: LD_INT 50
12254: PUSH
12255: EMPTY
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PPUSH
12262: CALL_OW 69
12266: NOT
12267: AND
12268: IFFALSE 12229
// PrepareGnyevko ;
12270: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
12274: LD_EXP 50
12278: PPUSH
12279: LD_INT 124
12281: PPUSH
12282: LD_INT 118
12284: PPUSH
12285: CALL_OW 111
// AddComHold ( Gnyevko ) ;
12289: LD_EXP 50
12293: PPUSH
12294: CALL_OW 200
// time := 0 0$00 ;
12298: LD_ADDR_VAR 0 1
12302: PUSH
12303: LD_INT 0
12305: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12306: LD_INT 35
12308: PPUSH
12309: CALL_OW 67
// time := time + 0 0$1 ;
12313: LD_ADDR_VAR 0 1
12317: PUSH
12318: LD_VAR 0 1
12322: PUSH
12323: LD_INT 35
12325: PLUS
12326: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12327: LD_EXP 50
12331: PPUSH
12332: LD_INT 124
12334: PPUSH
12335: LD_INT 118
12337: PPUSH
12338: CALL_OW 307
12342: PUSH
12343: LD_VAR 0 1
12347: PUSH
12348: LD_INT 1050
12350: GREATEREQUAL
12351: OR
12352: IFFALSE 12306
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12354: LD_EXP 50
12358: PPUSH
12359: LD_STRING DBelkov-Gny-1
12361: PPUSH
12362: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12366: LD_EXP 48
12370: PPUSH
12371: LD_STRING DBelkov-Bur-1a
12373: PPUSH
12374: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12378: LD_INT 35
12380: PPUSH
12381: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12385: LD_EXP 50
12389: PPUSH
12390: LD_INT 22
12392: PUSH
12393: LD_INT 7
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PPUSH
12400: CALL_OW 69
12404: PPUSH
12405: LD_EXP 50
12409: PPUSH
12410: CALL_OW 74
12414: PPUSH
12415: CALL_OW 296
12419: PUSH
12420: LD_INT 8
12422: LESS
12423: IFFALSE 12378
// SetSide ( Gnyevko , 7 ) ;
12425: LD_EXP 50
12429: PPUSH
12430: LD_INT 7
12432: PPUSH
12433: CALL_OW 235
// end ;
12437: PPOPN 1
12439: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12440: LD_EXP 48
12444: PPUSH
12445: CALL_OW 255
12449: PUSH
12450: LD_INT 7
12452: EQUAL
12453: IFFALSE 12463
12455: GO 12457
12457: DISABLE
// begin enable ;
12458: ENABLE
// PrepareAmericanAttack ;
12459: CALL 7812 0 0
// end ;
12463: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12464: LD_INT 22
12466: PUSH
12467: LD_INT 1
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: PPUSH
12474: CALL_OW 69
12478: IFFALSE 12662
12480: GO 12482
12482: DISABLE
12483: LD_INT 0
12485: PPUSH
12486: PPUSH
// begin while true do
12487: LD_INT 1
12489: IFFALSE 12546
// begin wait ( 0 0$1 ) ;
12491: LD_INT 35
12493: PPUSH
12494: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12498: LD_ADDR_VAR 0 2
12502: PUSH
12503: LD_INT 22
12505: PUSH
12506: LD_INT 1
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 69
12517: PPUSH
12518: LD_EXP 16
12522: PPUSH
12523: CALL_OW 74
12527: ST_TO_ADDR
// if See ( 7 , tmp ) then
12528: LD_INT 7
12530: PPUSH
12531: LD_VAR 0 2
12535: PPUSH
12536: CALL_OW 292
12540: IFFALSE 12544
// break ;
12542: GO 12546
// end ;
12544: GO 12487
// DialogueOn ;
12546: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12550: LD_VAR 0 2
12554: PPUSH
12555: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: CALL_OW 250
12568: PPUSH
12569: LD_VAR 0 2
12573: PPUSH
12574: CALL_OW 251
12578: PPUSH
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 8
12584: PPUSH
12585: CALL_OW 330
// if Denis then
12589: LD_EXP 22
12593: IFFALSE 12607
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12595: LD_EXP 22
12599: PPUSH
12600: LD_STRING DAmerAttack-Pet-1
12602: PPUSH
12603: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12607: LD_EXP 16
12611: PPUSH
12612: LD_STRING DAmerAttack-JMM-1
12614: PPUSH
12615: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12619: LD_EXP 48
12623: PPUSH
12624: LD_STRING DStop-Bur-1
12626: PPUSH
12627: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12631: LD_VAR 0 2
12635: PPUSH
12636: CALL_OW 250
12640: PPUSH
12641: LD_VAR 0 2
12645: PPUSH
12646: CALL_OW 251
12650: PPUSH
12651: LD_INT 7
12653: PPUSH
12654: CALL_OW 331
// DialogueOff ;
12658: CALL_OW 7
// end ;
12662: PPOPN 2
12664: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12665: LD_INT 22
12667: PUSH
12668: LD_INT 3
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 21
12677: PUSH
12678: LD_INT 1
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL_OW 69
12693: PUSH
12694: LD_INT 0
12696: EQUAL
12697: IFFALSE 12739
12699: GO 12701
12701: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
12702: LD_STRING M5a
12704: PPUSH
12705: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12709: LD_EXP 16
12713: PPUSH
12714: LD_STRING D8-JMM-1
12716: PPUSH
12717: CALL_OW 88
// if Gossudarov then
12721: LD_EXP 34
12725: IFFALSE 12739
// Say ( Gossudarov , D8-Gos-1 ) ;
12727: LD_EXP 34
12731: PPUSH
12732: LD_STRING D8-Gos-1
12734: PPUSH
12735: CALL_OW 88
// end ;
12739: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12740: LD_INT 22
12742: PUSH
12743: LD_INT 2
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 21
12752: PUSH
12753: LD_INT 1
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_INT 0
12771: EQUAL
12772: IFFALSE 12822
12774: GO 12776
12776: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
12777: LD_STRING M4c
12779: PPUSH
12780: CALL_OW 337
// if Roth then
12784: LD_EXP 17
12788: IFFALSE 12804
// Say ( Roth , DStop-Roth-1 ) else
12790: LD_EXP 17
12794: PPUSH
12795: LD_STRING DStop-Roth-1
12797: PPUSH
12798: CALL_OW 88
12802: GO 12822
// if Gossudarov then
12804: LD_EXP 34
12808: IFFALSE 12822
// Say ( Gossudarov , D8-Gos-1a ) ;
12810: LD_EXP 34
12814: PPUSH
12815: LD_STRING D8-Gos-1a
12817: PPUSH
12818: CALL_OW 88
// end ;
12822: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
12823: LD_INT 3
12825: PPUSH
12826: CALL_OW 469
12830: PUSH
12831: LD_EXP 12
12835: AND
12836: IFFALSE 12891
12838: GO 12840
12840: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12841: LD_INT 3
12843: PPUSH
12844: CALL_OW 469
12848: PPUSH
12849: CALL 8301 0 1
// if Difficulty > 2 then
12853: LD_OWVAR 67
12857: PUSH
12858: LD_INT 2
12860: GREATER
12861: IFFALSE 12891
// begin wait ( 5 5$00 ) ;
12863: LD_INT 10500
12865: PPUSH
12866: CALL_OW 67
// if FindArtifact ( 3 ) then
12870: LD_INT 3
12872: PPUSH
12873: CALL_OW 469
12877: IFFALSE 12891
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12879: LD_INT 3
12881: PPUSH
12882: CALL_OW 469
12886: PPUSH
12887: CALL 8301 0 1
// end ; end ;
12891: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12892: LD_INT 7
12894: PPUSH
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 1
12900: PPUSH
12901: CALL 16498 0 3
12905: PUSH
12906: LD_INT 0
12908: EQUAL
12909: PUSH
12910: LD_INT 7
12912: PPUSH
12913: LD_INT 3
12915: PPUSH
12916: LD_INT 1
12918: PPUSH
12919: CALL 16498 0 3
12923: PUSH
12924: LD_INT 0
12926: EQUAL
12927: AND
12928: IFFALSE 12940
12930: GO 12932
12932: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12933: LD_STRING M1a
12935: PPUSH
12936: CALL_OW 337
// end ;
12940: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12941: LD_INT 22
12943: PUSH
12944: LD_INT 2
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 23
12953: PUSH
12954: LD_INT 2
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 21
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: PPUSH
12976: CALL_OW 69
12980: PUSH
12981: LD_INT 0
12983: EQUAL
12984: PUSH
12985: LD_INT 22
12987: PUSH
12988: LD_INT 3
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 23
12997: PUSH
12998: LD_INT 3
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: LD_INT 21
13007: PUSH
13008: LD_INT 1
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: PUSH
13025: LD_INT 0
13027: EQUAL
13028: AND
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 1
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 69
13044: PUSH
13045: LD_INT 0
13047: EQUAL
13048: AND
13049: PUSH
13050: LD_INT 7
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: CALL 16498 0 3
13063: PUSH
13064: LD_INT 0
13066: EQUAL
13067: AND
13068: PUSH
13069: LD_INT 7
13071: PPUSH
13072: LD_INT 3
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: CALL 16498 0 3
13082: PUSH
13083: LD_INT 0
13085: EQUAL
13086: AND
13087: PUSH
13088: LD_EXP 48
13092: PPUSH
13093: CALL_OW 255
13097: PUSH
13098: LD_INT 7
13100: EQUAL
13101: AND
13102: PUSH
13103: LD_EXP 48
13107: PPUSH
13108: CALL_OW 302
13112: AND
13113: IFFALSE 14786
13115: GO 13117
13117: DISABLE
13118: LD_INT 0
13120: PPUSH
13121: PPUSH
13122: PPUSH
13123: PPUSH
13124: PPUSH
13125: PPUSH
// begin m1 := false ;
13126: LD_ADDR_VAR 0 4
13130: PUSH
13131: LD_INT 0
13133: ST_TO_ADDR
// m2 := false ;
13134: LD_ADDR_VAR 0 5
13138: PUSH
13139: LD_INT 0
13141: ST_TO_ADDR
// m3 := false ;
13142: LD_ADDR_VAR 0 6
13146: PUSH
13147: LD_INT 0
13149: ST_TO_ADDR
// if tick < 40 40$00 then
13150: LD_OWVAR 1
13154: PUSH
13155: LD_INT 84000
13157: LESS
13158: IFFALSE 13167
// SetAchievement ( ACH_ASPEED_17 ) ;
13160: LD_STRING ACH_ASPEED_17
13162: PPUSH
13163: CALL_OW 543
// wait ( 0 0$5 ) ;
13167: LD_INT 175
13169: PPUSH
13170: CALL_OW 67
// if not masha_killed then
13174: LD_EXP 10
13178: NOT
13179: IFFALSE 13201
// begin m1 := true ;
13181: LD_ADDR_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
13189: LD_STRING Masha
13191: PPUSH
13192: LD_INT 1
13194: PPUSH
13195: CALL_OW 101
// end else
13199: GO 13212
// AddMedal ( Masha , - 1 ) ;
13201: LD_STRING Masha
13203: PPUSH
13204: LD_INT 1
13206: NEG
13207: PPUSH
13208: CALL_OW 101
// if abdul_escaped then
13212: LD_EXP 13
13216: IFFALSE 13231
// AddMedal ( Abdul , - 1 ) else
13218: LD_STRING Abdul
13220: PPUSH
13221: LD_INT 1
13223: NEG
13224: PPUSH
13225: CALL_OW 101
13229: GO 13249
// begin m2 := true ;
13231: LD_ADDR_VAR 0 5
13235: PUSH
13236: LD_INT 1
13238: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
13239: LD_STRING Abdul
13241: PPUSH
13242: LD_INT 1
13244: PPUSH
13245: CALL_OW 101
// end ; if loss_counter = 0 then
13249: LD_EXP 14
13253: PUSH
13254: LD_INT 0
13256: EQUAL
13257: IFFALSE 13279
// begin m3 := true ;
13259: LD_ADDR_VAR 0 6
13263: PUSH
13264: LD_INT 1
13266: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
13267: LD_STRING People
13269: PPUSH
13270: LD_INT 2
13272: PPUSH
13273: CALL_OW 101
// end else
13277: GO 13341
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
13279: LD_EXP 14
13283: PUSH
13284: LD_INT 3
13286: PUSH
13287: LD_INT 2
13289: PUSH
13290: LD_INT 2
13292: PUSH
13293: LD_INT 1
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: PUSH
13302: LD_OWVAR 67
13306: ARRAY
13307: LESSEQUAL
13308: IFFALSE 13330
// begin AddMedal ( People , 1 ) ;
13310: LD_STRING People
13312: PPUSH
13313: LD_INT 1
13315: PPUSH
13316: CALL_OW 101
// m3 := true ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: LD_INT 1
13327: ST_TO_ADDR
// end else
13328: GO 13341
// AddMedal ( People , - 1 ) ;
13330: LD_STRING People
13332: PPUSH
13333: LD_INT 1
13335: NEG
13336: PPUSH
13337: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
13341: LD_OWVAR 67
13345: PUSH
13346: LD_INT 3
13348: GREATEREQUAL
13349: PUSH
13350: LD_VAR 0 4
13354: AND
13355: PUSH
13356: LD_VAR 0 5
13360: AND
13361: PUSH
13362: LD_VAR 0 6
13366: AND
13367: IFFALSE 13379
// SetAchievementEX ( ACH_AMER , 17 ) ;
13369: LD_STRING ACH_AMER
13371: PPUSH
13372: LD_INT 17
13374: PPUSH
13375: CALL_OW 564
// GiveMedals ( MAIN ) ;
13379: LD_STRING MAIN
13381: PPUSH
13382: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_INT 7
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 50
13403: PUSH
13404: EMPTY
13405: LIST
13406: PUSH
13407: LD_INT 2
13409: PUSH
13410: LD_INT 25
13412: PUSH
13413: LD_INT 1
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: LD_INT 25
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PUSH
13430: LD_INT 25
13432: PUSH
13433: LD_INT 3
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PUSH
13440: LD_INT 25
13442: PUSH
13443: LD_INT 4
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 25
13452: PUSH
13453: LD_INT 5
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 25
13462: PUSH
13463: LD_INT 8
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 25
13472: PUSH
13473: LD_INT 9
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PPUSH
13495: CALL_OW 69
13499: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13500: LD_VAR 0 2
13504: PPUSH
13505: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13509: LD_ADDR_VAR 0 3
13513: PUSH
13514: LD_EXP 16
13518: PUSH
13519: LD_EXP 17
13523: PUSH
13524: LD_EXP 18
13528: PUSH
13529: LD_EXP 19
13533: PUSH
13534: LD_EXP 20
13538: PUSH
13539: LD_EXP 21
13543: PUSH
13544: LD_EXP 22
13548: PUSH
13549: LD_EXP 23
13553: PUSH
13554: LD_EXP 24
13558: PUSH
13559: LD_EXP 25
13563: PUSH
13564: LD_EXP 26
13568: PUSH
13569: LD_EXP 27
13573: PUSH
13574: LD_EXP 28
13578: PUSH
13579: LD_EXP 29
13583: PUSH
13584: LD_EXP 30
13588: PUSH
13589: LD_EXP 31
13593: PUSH
13594: LD_EXP 32
13598: PUSH
13599: LD_EXP 34
13603: PUSH
13604: LD_EXP 35
13608: PUSH
13609: LD_EXP 36
13613: PUSH
13614: LD_EXP 38
13618: PUSH
13619: LD_EXP 39
13623: PUSH
13624: LD_EXP 40
13628: PUSH
13629: LD_EXP 41
13633: PUSH
13634: LD_EXP 42
13638: PUSH
13639: LD_EXP 43
13643: PUSH
13644: LD_EXP 44
13648: PUSH
13649: LD_EXP 45
13653: PUSH
13654: LD_EXP 46
13658: PUSH
13659: LD_EXP 47
13663: PUSH
13664: LD_EXP 48
13668: PUSH
13669: LD_EXP 49
13673: PUSH
13674: LD_EXP 50
13678: PUSH
13679: LD_EXP 33
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: LIST
13719: ST_TO_ADDR
// if tmp diff tmp2 then
13720: LD_VAR 0 2
13724: PUSH
13725: LD_VAR 0 3
13729: DIFF
13730: IFFALSE 13750
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13732: LD_VAR 0 2
13736: PUSH
13737: LD_VAR 0 3
13741: DIFF
13742: PPUSH
13743: LD_STRING 13a_others
13745: PPUSH
13746: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13750: LD_EXP 16
13754: PPUSH
13755: LD_STRING 13a_JMM
13757: PPUSH
13758: CALL_OW 38
// if IsOk ( Mike ) then
13762: LD_EXP 33
13766: PPUSH
13767: CALL_OW 302
13771: IFFALSE 13785
// SaveCharacters ( Mike , 13a_Mike ) ;
13773: LD_EXP 33
13777: PPUSH
13778: LD_STRING 13a_Mike
13780: PPUSH
13781: CALL_OW 38
// if IsOk ( Titov ) then
13785: LD_EXP 36
13789: PPUSH
13790: CALL_OW 302
13794: IFFALSE 13808
// SaveCharacters ( Titov , 13a_Titov ) ;
13796: LD_EXP 36
13800: PPUSH
13801: LD_STRING 13a_Titov
13803: PPUSH
13804: CALL_OW 38
// if IsOk ( Dolgov ) then
13808: LD_EXP 38
13812: PPUSH
13813: CALL_OW 302
13817: IFFALSE 13831
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13819: LD_EXP 38
13823: PPUSH
13824: LD_STRING 13a_Dolgov
13826: PPUSH
13827: CALL_OW 38
// if IsOk ( Petrosyan ) then
13831: LD_EXP 39
13835: PPUSH
13836: CALL_OW 302
13840: IFFALSE 13854
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13842: LD_EXP 39
13846: PPUSH
13847: LD_STRING 13a_Petrosyan
13849: PPUSH
13850: CALL_OW 38
// if IsOk ( Scholtze ) then
13854: LD_EXP 40
13858: PPUSH
13859: CALL_OW 302
13863: IFFALSE 13877
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13865: LD_EXP 40
13869: PPUSH
13870: LD_STRING 13a_Scholtze
13872: PPUSH
13873: CALL_OW 38
// if IsOk ( Oblukov ) then
13877: LD_EXP 41
13881: PPUSH
13882: CALL_OW 302
13886: IFFALSE 13900
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13888: LD_EXP 41
13892: PPUSH
13893: LD_STRING 13a_Oblukov
13895: PPUSH
13896: CALL_OW 38
// if IsOk ( Kapitsova ) then
13900: LD_EXP 42
13904: PPUSH
13905: CALL_OW 302
13909: IFFALSE 13923
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13911: LD_EXP 42
13915: PPUSH
13916: LD_STRING 13a_Kapitsova
13918: PPUSH
13919: CALL_OW 38
// if IsOk ( Lipshchin ) then
13923: LD_EXP 43
13927: PPUSH
13928: CALL_OW 302
13932: IFFALSE 13946
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13934: LD_EXP 43
13938: PPUSH
13939: LD_STRING 13a_Lipshchin
13941: PPUSH
13942: CALL_OW 38
// if IsOk ( Petrovova ) then
13946: LD_EXP 44
13950: PPUSH
13951: CALL_OW 302
13955: IFFALSE 13969
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13957: LD_EXP 44
13961: PPUSH
13962: LD_STRING 13a_Petrovova
13964: PPUSH
13965: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13969: LD_EXP 45
13973: PPUSH
13974: CALL_OW 302
13978: IFFALSE 13992
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13980: LD_EXP 45
13984: PPUSH
13985: LD_STRING 13a_Kovalyuk
13987: PPUSH
13988: CALL_OW 38
// if IsOk ( Kuzmov ) then
13992: LD_EXP 46
13996: PPUSH
13997: CALL_OW 302
14001: IFFALSE 14015
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14003: LD_EXP 46
14007: PPUSH
14008: LD_STRING 13a_Kuzmov
14010: PPUSH
14011: CALL_OW 38
// if IsOk ( Karamazov ) then
14015: LD_EXP 47
14019: PPUSH
14020: CALL_OW 302
14024: IFFALSE 14038
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14026: LD_EXP 47
14030: PPUSH
14031: LD_STRING 13a_Karamazov
14033: PPUSH
14034: CALL_OW 38
// if Burlak then
14038: LD_EXP 48
14042: IFFALSE 14063
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14044: LD_STRING enableBioCharacter(BIO_GORKI)
14046: PPUSH
14047: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14051: LD_EXP 48
14055: PPUSH
14056: LD_STRING 13a_Burlak
14058: PPUSH
14059: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14063: LD_EXP 49
14067: PPUSH
14068: CALL_OW 302
14072: IFFALSE 14086
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14074: LD_EXP 49
14078: PPUSH
14079: LD_STRING 13a_Belkov
14081: PPUSH
14082: CALL_OW 38
// if IsOk ( Gnyevko ) then
14086: LD_EXP 50
14090: PPUSH
14091: CALL_OW 302
14095: IFFALSE 14109
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14097: LD_EXP 50
14101: PPUSH
14102: LD_STRING 13a_Gnyevko
14104: PPUSH
14105: CALL_OW 38
// if IsOk ( Lisa ) then
14109: LD_EXP 18
14113: PPUSH
14114: CALL_OW 302
14118: IFFALSE 14132
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14120: LD_EXP 18
14124: PPUSH
14125: LD_STRING 13a_Lisa
14127: PPUSH
14128: CALL_OW 38
// if IsOk ( Donaldson ) then
14132: LD_EXP 19
14136: PPUSH
14137: CALL_OW 302
14141: IFFALSE 14155
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14143: LD_EXP 19
14147: PPUSH
14148: LD_STRING 13a_Donaldson
14150: PPUSH
14151: CALL_OW 38
// if IsOk ( Bobby ) then
14155: LD_EXP 20
14159: PPUSH
14160: CALL_OW 302
14164: IFFALSE 14178
// SaveCharacters ( Bobby , 13a_Bobby ) ;
14166: LD_EXP 20
14170: PPUSH
14171: LD_STRING 13a_Bobby
14173: PPUSH
14174: CALL_OW 38
// if IsOk ( Cyrus ) then
14178: LD_EXP 21
14182: PPUSH
14183: CALL_OW 302
14187: IFFALSE 14201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
14189: LD_EXP 21
14193: PPUSH
14194: LD_STRING 13a_Cyrus
14196: PPUSH
14197: CALL_OW 38
// if IsOk ( Denis ) then
14201: LD_EXP 22
14205: PPUSH
14206: CALL_OW 302
14210: IFFALSE 14224
// SaveCharacters ( Denis , 13a_Denis ) ;
14212: LD_EXP 22
14216: PPUSH
14217: LD_STRING 13a_Denis
14219: PPUSH
14220: CALL_OW 38
// if IsOk ( Brown ) then
14224: LD_EXP 23
14228: PPUSH
14229: CALL_OW 302
14233: IFFALSE 14247
// SaveCharacters ( Brown , 13a_Brown ) ;
14235: LD_EXP 23
14239: PPUSH
14240: LD_STRING 13a_Brown
14242: PPUSH
14243: CALL_OW 38
// if IsOk ( Gladstone ) then
14247: LD_EXP 24
14251: PPUSH
14252: CALL_OW 302
14256: IFFALSE 14270
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
14258: LD_EXP 24
14262: PPUSH
14263: LD_STRING 13a_Gladstone
14265: PPUSH
14266: CALL_OW 38
// if IsOk ( Houten ) then
14270: LD_EXP 25
14274: PPUSH
14275: CALL_OW 302
14279: IFFALSE 14293
// SaveCharacters ( Houten , 13a_Houten ) ;
14281: LD_EXP 25
14285: PPUSH
14286: LD_STRING 13a_Houten
14288: PPUSH
14289: CALL_OW 38
// if IsOk ( Cornel ) then
14293: LD_EXP 26
14297: PPUSH
14298: CALL_OW 302
14302: IFFALSE 14316
// SaveCharacters ( Cornel , 13a_Cornel ) ;
14304: LD_EXP 26
14308: PPUSH
14309: LD_STRING 13a_Cornel
14311: PPUSH
14312: CALL_OW 38
// if IsOk ( Gary ) then
14316: LD_EXP 27
14320: PPUSH
14321: CALL_OW 302
14325: IFFALSE 14339
// SaveCharacters ( Gary , 13a_Gary ) ;
14327: LD_EXP 27
14331: PPUSH
14332: LD_STRING 13a_Gary
14334: PPUSH
14335: CALL_OW 38
// if IsOk ( Frank ) then
14339: LD_EXP 28
14343: PPUSH
14344: CALL_OW 302
14348: IFFALSE 14362
// SaveCharacters ( Frank , 13a_Frank ) ;
14350: LD_EXP 28
14354: PPUSH
14355: LD_STRING 13a_Frank
14357: PPUSH
14358: CALL_OW 38
// if IsOk ( Kikuchi ) then
14362: LD_EXP 29
14366: PPUSH
14367: CALL_OW 302
14371: IFFALSE 14385
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
14373: LD_EXP 29
14377: PPUSH
14378: LD_STRING 13a_Kikuchi
14380: PPUSH
14381: CALL_OW 38
// if IsOk ( Simms ) then
14385: LD_EXP 30
14389: PPUSH
14390: CALL_OW 302
14394: IFFALSE 14408
// SaveCharacters ( Simms , 13a_Simms ) ;
14396: LD_EXP 30
14400: PPUSH
14401: LD_STRING 13a_Simms
14403: PPUSH
14404: CALL_OW 38
// if IsOk ( Joan ) then
14408: LD_EXP 31
14412: PPUSH
14413: CALL_OW 302
14417: IFFALSE 14431
// SaveCharacters ( Joan , 13a_Joan ) ;
14419: LD_EXP 31
14423: PPUSH
14424: LD_STRING 13a_Joan
14426: PPUSH
14427: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14431: LD_EXP 32
14435: PPUSH
14436: CALL_OW 302
14440: IFFALSE 14454
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14442: LD_EXP 32
14446: PPUSH
14447: LD_STRING 13a_DeltaDoctor
14449: PPUSH
14450: CALL_OW 38
// if IsOk ( Gossudarov ) then
14454: LD_EXP 34
14458: PPUSH
14459: CALL_OW 302
14463: IFFALSE 14477
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14465: LD_EXP 34
14469: PPUSH
14470: LD_STRING 13a_Gossudarov
14472: PPUSH
14473: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14477: LD_EXP 35
14481: PPUSH
14482: CALL_OW 302
14486: IFFALSE 14500
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14488: LD_EXP 35
14492: PPUSH
14493: LD_STRING 13a_Kirilenkova
14495: PPUSH
14496: CALL_OW 38
// if IsOk ( Roth ) then
14500: LD_EXP 17
14504: PPUSH
14505: CALL_OW 302
14509: IFFALSE 14523
// SaveCharacters ( Roth , 13a_Roth ) ;
14511: LD_EXP 17
14515: PPUSH
14516: LD_STRING 13a_Roth
14518: PPUSH
14519: CALL_OW 38
// if Masha then
14523: LD_EXP 51
14527: IFFALSE 14582
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14529: LD_EXP 51
14533: PPUSH
14534: CALL_OW 265
14538: PUSH
14539: LD_EXP 51
14543: PPUSH
14544: CALL_OW 262
14548: PUSH
14549: LD_EXP 51
14553: PPUSH
14554: CALL_OW 263
14558: PUSH
14559: LD_EXP 51
14563: PPUSH
14564: CALL_OW 264
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: PPUSH
14575: LD_STRING 13a_Masha
14577: PPUSH
14578: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14582: LD_ADDR_VAR 0 2
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 3
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PPUSH
14597: CALL_OW 69
14601: ST_TO_ADDR
// tmp2 := [ ] ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: EMPTY
14608: ST_TO_ADDR
// if tmp then
14609: LD_VAR 0 2
14613: IFFALSE 14764
// for i in tmp do
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_VAR 0 2
14624: PUSH
14625: FOR_IN
14626: IFFALSE 14762
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: LD_VAR 0 3
14637: PUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 255
14647: PUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 248
14657: PUSH
14658: LD_VAR 0 1
14662: PPUSH
14663: CALL_OW 266
14667: PUSH
14668: LD_VAR 0 1
14672: PPUSH
14673: CALL_OW 250
14677: PUSH
14678: LD_VAR 0 1
14682: PPUSH
14683: CALL_OW 251
14687: PUSH
14688: LD_VAR 0 1
14692: PPUSH
14693: CALL_OW 254
14697: PUSH
14698: LD_VAR 0 1
14702: PPUSH
14703: CALL_OW 267
14707: PUSH
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_INT 1
14715: PPUSH
14716: CALL_OW 268
14720: PUSH
14721: LD_VAR 0 1
14725: PPUSH
14726: LD_INT 2
14728: PPUSH
14729: CALL_OW 268
14733: PUSH
14734: LD_VAR 0 1
14738: PPUSH
14739: CALL_OW 269
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: ADD
14759: ST_TO_ADDR
14760: GO 14625
14762: POP
14763: POP
// if tmp2 then
14764: LD_VAR 0 3
14768: IFFALSE 14782
// SaveVariable ( tmp2 , 13a_buildings ) ;
14770: LD_VAR 0 3
14774: PPUSH
14775: LD_STRING 13a_buildings
14777: PPUSH
14778: CALL_OW 39
// YouWin ;
14782: CALL_OW 103
// end ;
14786: PPOPN 6
14788: END
// export function SciRu ; var tmp , t ; begin
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_EXP 34
14803: PUSH
14804: LD_EXP 48
14808: PUSH
14809: LD_EXP 36
14813: PUSH
14814: LD_EXP 49
14818: PUSH
14819: LD_EXP 50
14823: PUSH
14824: LD_EXP 39
14828: PUSH
14829: LD_EXP 40
14833: PUSH
14834: LD_EXP 38
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14849: LD_ADDR_VAR 0 2
14853: PUSH
14854: LD_INT 22
14856: PUSH
14857: LD_INT 7
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: LD_INT 23
14866: PUSH
14867: LD_INT 3
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 25
14876: PUSH
14877: LD_INT 4
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 26
14886: PUSH
14887: LD_INT 1
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: PPUSH
14900: CALL_OW 69
14904: PUSH
14905: LD_VAR 0 3
14909: DIFF
14910: ST_TO_ADDR
// if tmp then
14911: LD_VAR 0 2
14915: IFFALSE 14931
// result := tmp [ 1 ] ;
14917: LD_ADDR_VAR 0 1
14921: PUSH
14922: LD_VAR 0 2
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: ST_TO_ADDR
// end ;
14931: LD_VAR 0 1
14935: RET
// export function SolRu ; var tmp , t ; begin
14936: LD_INT 0
14938: PPUSH
14939: PPUSH
14940: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_EXP 34
14950: PUSH
14951: LD_EXP 48
14955: PUSH
14956: LD_EXP 36
14960: PUSH
14961: LD_EXP 49
14965: PUSH
14966: LD_EXP 50
14970: PUSH
14971: LD_EXP 39
14975: PUSH
14976: LD_EXP 40
14980: PUSH
14981: LD_EXP 38
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14996: LD_ADDR_VAR 0 2
15000: PUSH
15001: LD_INT 22
15003: PUSH
15004: LD_INT 7
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: LD_INT 23
15013: PUSH
15014: LD_INT 3
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: PUSH
15021: LD_INT 25
15023: PUSH
15024: LD_INT 1
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 26
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: PPUSH
15047: CALL_OW 69
15051: PUSH
15052: LD_VAR 0 3
15056: DIFF
15057: ST_TO_ADDR
// if tmp then
15058: LD_VAR 0 2
15062: IFFALSE 15078
// result := tmp [ 1 ] ;
15064: LD_ADDR_VAR 0 1
15068: PUSH
15069: LD_VAR 0 2
15073: PUSH
15074: LD_INT 1
15076: ARRAY
15077: ST_TO_ADDR
// end ; end_of_file
15078: LD_VAR 0 1
15082: RET
// export function CustomEvent ( event ) ; begin
15083: LD_INT 0
15085: PPUSH
// end ;
15086: LD_VAR 0 2
15090: RET
// on UnitDestroyed ( un ) do var i , side ;
15091: LD_INT 0
15093: PPUSH
15094: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15095: LD_VAR 0 1
15099: PPUSH
15100: CALL 105733 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15104: LD_VAR 0 1
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 7
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 2
15121: PUSH
15122: LD_INT 25
15124: PUSH
15125: LD_INT 1
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PUSH
15132: LD_INT 25
15134: PUSH
15135: LD_INT 2
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 25
15144: PUSH
15145: LD_INT 3
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: LD_INT 25
15154: PUSH
15155: LD_INT 4
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 25
15164: PUSH
15165: LD_INT 5
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 25
15174: PUSH
15175: LD_INT 8
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 25
15184: PUSH
15185: LD_INT 9
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: IN
15211: IFFALSE 15227
// loss_counter := loss_counter + 1 ;
15213: LD_ADDR_EXP 14
15217: PUSH
15218: LD_EXP 14
15222: PUSH
15223: LD_INT 1
15225: PLUS
15226: ST_TO_ADDR
// if un = Abdul then
15227: LD_VAR 0 1
15231: PUSH
15232: LD_EXP 57
15236: EQUAL
15237: IFFALSE 15247
// abdul_escaped := false ;
15239: LD_ADDR_EXP 13
15243: PUSH
15244: LD_INT 0
15246: ST_TO_ADDR
// if un in ru_attackers then
15247: LD_VAR 0 1
15251: PUSH
15252: LD_EXP 54
15256: IN
15257: IFFALSE 15275
// ru_attackers := ru_attackers diff un ;
15259: LD_ADDR_EXP 54
15263: PUSH
15264: LD_EXP 54
15268: PUSH
15269: LD_VAR 0 1
15273: DIFF
15274: ST_TO_ADDR
// if un in ar_attackers then
15275: LD_VAR 0 1
15279: PUSH
15280: LD_EXP 11
15284: IN
15285: IFFALSE 15303
// ar_attackers := ar_attackers diff un ;
15287: LD_ADDR_EXP 11
15291: PUSH
15292: LD_EXP 11
15296: PUSH
15297: LD_VAR 0 1
15301: DIFF
15302: ST_TO_ADDR
// if un = JMM then
15303: LD_VAR 0 1
15307: PUSH
15308: LD_EXP 16
15312: EQUAL
15313: IFFALSE 15324
// begin YouLost ( JMM ) ;
15315: LD_STRING JMM
15317: PPUSH
15318: CALL_OW 104
// exit ;
15322: GO 15421
// end ; if un = Burlak then
15324: LD_VAR 0 1
15328: PUSH
15329: LD_EXP 48
15333: EQUAL
15334: IFFALSE 15345
// begin YouLost ( Burlak ) ;
15336: LD_STRING Burlak
15338: PPUSH
15339: CALL_OW 104
// exit ;
15343: GO 15421
// end ; if un = freedom then
15345: LD_VAR 0 1
15349: PUSH
15350: LD_EXP 3
15354: EQUAL
15355: IFFALSE 15366
// begin YouLost ( Destroyed ) ;
15357: LD_STRING Destroyed
15359: PPUSH
15360: CALL_OW 104
// exit ;
15364: GO 15421
// end ; if un = Masha then
15366: LD_VAR 0 1
15370: PUSH
15371: LD_EXP 51
15375: EQUAL
15376: IFFALSE 15393
// begin ChangeMissionObjectives ( M4b ) ;
15378: LD_STRING M4b
15380: PPUSH
15381: CALL_OW 337
// masha_killed := true ;
15385: LD_ADDR_EXP 10
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// end ; if un = Mastodont then
15393: LD_VAR 0 1
15397: PUSH
15398: LD_EXP 58
15402: EQUAL
15403: IFFALSE 15412
// ChangeMissionObjectives ( M4a ) ;
15405: LD_STRING M4a
15407: PPUSH
15408: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15412: LD_VAR 0 1
15416: PPUSH
15417: CALL 86930 0 1
// end ;
15421: PPOPN 3
15423: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15424: LD_VAR 0 1
15428: PPUSH
15429: LD_VAR 0 2
15433: PPUSH
15434: CALL 89262 0 2
// end ;
15438: PPOPN 2
15440: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL 88330 0 1
// end ;
15450: PPOPN 1
15452: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15453: LD_VAR 0 1
15457: PUSH
15458: LD_INT 22
15460: PUSH
15461: LD_INT 7
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PUSH
15468: LD_INT 30
15470: PUSH
15471: LD_INT 0
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 69
15486: IN
15487: IFFALSE 15526
// begin SetBName ( building , freedom ) ;
15489: LD_VAR 0 1
15493: PPUSH
15494: LD_STRING freedom
15496: PPUSH
15497: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15501: LD_INT 0
15503: PPUSH
15504: LD_INT 7
15506: PPUSH
15507: LD_INT 0
15509: PPUSH
15510: CALL_OW 324
// freedom := building ;
15514: LD_ADDR_EXP 3
15518: PUSH
15519: LD_VAR 0 1
15523: ST_TO_ADDR
// exit ;
15524: GO 15592
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15526: LD_VAR 0 1
15530: PUSH
15531: LD_INT 22
15533: PUSH
15534: LD_INT 7
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 23
15543: PUSH
15544: LD_INT 3
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: LD_INT 30
15553: PUSH
15554: LD_INT 6
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: EMPTY
15562: LIST
15563: LIST
15564: LIST
15565: PPUSH
15566: CALL_OW 69
15570: IN
15571: IFFALSE 15583
// begin ru_lab_builded := true ;
15573: LD_ADDR_EXP 5
15577: PUSH
15578: LD_INT 1
15580: ST_TO_ADDR
// exit ;
15581: GO 15592
// end ; MCE_BuildingComplete ( building ) ;
15583: LD_VAR 0 1
15587: PPUSH
15588: CALL 88571 0 1
// end ;
15592: PPOPN 1
15594: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15595: LD_VAR 0 1
15599: PPUSH
15600: LD_VAR 0 2
15604: PPUSH
15605: CALL 86626 0 2
// end ;
15609: PPOPN 2
15611: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_VAR 0 2
15621: PPUSH
15622: LD_VAR 0 3
15626: PPUSH
15627: LD_VAR 0 4
15631: PPUSH
15632: LD_VAR 0 5
15636: PPUSH
15637: CALL 86246 0 5
// end ;
15641: PPOPN 5
15643: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15644: LD_VAR 0 1
15648: PPUSH
15649: LD_VAR 0 2
15653: PPUSH
15654: CALL 105853 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15658: LD_VAR 0 1
15662: PPUSH
15663: LD_VAR 0 2
15667: PPUSH
15668: CALL 85799 0 2
// end ;
15672: PPOPN 2
15674: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15675: LD_VAR 0 1
15679: PPUSH
15680: CALL_OW 263
15684: PUSH
15685: LD_INT 3
15687: EQUAL
15688: PUSH
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 263
15698: PUSH
15699: LD_INT 3
15701: EQUAL
15702: OR
15703: IFFALSE 15719
// hack_counter := hack_counter + 1 ;
15705: LD_ADDR_EXP 15
15709: PUSH
15710: LD_EXP 15
15714: PUSH
15715: LD_INT 1
15717: PLUS
15718: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15719: LD_VAR 0 1
15723: PPUSH
15724: LD_VAR 0 2
15728: PPUSH
15729: LD_VAR 0 3
15733: PPUSH
15734: LD_VAR 0 4
15738: PPUSH
15739: CALL 85637 0 4
// end ;
15743: PPOPN 4
15745: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
15746: LD_VAR 0 1
15750: PUSH
15751: LD_INT 47
15753: EQUAL
15754: IFFALSE 15776
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
15756: LD_VAR 0 1
15760: PPUSH
15761: CALL_OW 274
15765: PPUSH
15766: LD_INT 1
15768: PPUSH
15769: LD_INT 600
15771: PPUSH
15772: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15776: LD_VAR 0 1
15780: PPUSH
15781: LD_VAR 0 2
15785: PPUSH
15786: LD_VAR 0 3
15790: PPUSH
15791: CALL 85412 0 3
// end ;
15795: PPOPN 3
15797: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15798: LD_VAR 0 1
15802: PPUSH
15803: LD_VAR 0 2
15807: PPUSH
15808: CALL 85297 0 2
// end ;
15812: PPOPN 2
15814: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_VAR 0 2
15824: PPUSH
15825: CALL 89557 0 2
// end ;
15829: PPOPN 2
15831: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15832: LD_VAR 0 1
15836: PPUSH
15837: LD_VAR 0 2
15841: PPUSH
15842: LD_VAR 0 3
15846: PPUSH
15847: LD_VAR 0 4
15851: PPUSH
15852: CALL 89773 0 4
// end ;
15856: PPOPN 4
15858: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15859: LD_VAR 0 1
15863: PPUSH
15864: LD_VAR 0 2
15868: PPUSH
15869: CALL 85106 0 2
// end ;
15873: PPOPN 2
15875: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15876: LD_VAR 0 1
15880: PPUSH
15881: CALL 105837 0 1
// end ; end_of_file
15885: PPOPN 1
15887: END
// every 0 0$30 do var cr , time ;
15888: GO 15890
15890: DISABLE
15891: LD_INT 0
15893: PPUSH
15894: PPUSH
// begin time := 0 0$20 ;
15895: LD_ADDR_VAR 0 2
15899: PUSH
15900: LD_INT 700
15902: ST_TO_ADDR
// while game do
15903: LD_EXP 2
15907: IFFALSE 16010
// begin wait ( time ) ;
15909: LD_VAR 0 2
15913: PPUSH
15914: CALL_OW 67
// if tick > 2 2$00 then
15918: LD_OWVAR 1
15922: PUSH
15923: LD_INT 4200
15925: GREATER
15926: IFFALSE 15963
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15928: LD_ADDR_VAR 0 2
15932: PUSH
15933: LD_VAR 0 2
15937: PUSH
15938: LD_INT 140
15940: PUSH
15941: LD_INT 140
15943: PUSH
15944: LD_INT 210
15946: PUSH
15947: LD_INT 280
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: PUSH
15956: LD_OWVAR 67
15960: ARRAY
15961: PLUS
15962: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15963: LD_INT 1
15965: PPUSH
15966: LD_INT 5
15968: PPUSH
15969: CALL_OW 12
15973: PPUSH
15974: LD_INT 70
15976: PPUSH
15977: LD_INT 49
15979: PPUSH
15980: LD_INT 25
15982: PPUSH
15983: LD_INT 1
15985: PPUSH
15986: CALL_OW 56
// if time > 3 3$00 then
15990: LD_VAR 0 2
15994: PUSH
15995: LD_INT 6300
15997: GREATER
15998: IFFALSE 16008
// time := 0 0$30 ;
16000: LD_ADDR_VAR 0 2
16004: PUSH
16005: LD_INT 1050
16007: ST_TO_ADDR
// end ;
16008: GO 15903
// end ;
16010: PPOPN 2
16012: END
// every 0 0$30 do var cr , time ;
16013: GO 16015
16015: DISABLE
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
// begin time := 0 0$20 ;
16020: LD_ADDR_VAR 0 2
16024: PUSH
16025: LD_INT 700
16027: ST_TO_ADDR
// while game do
16028: LD_EXP 2
16032: IFFALSE 16125
// begin wait ( time ) ;
16034: LD_VAR 0 2
16038: PPUSH
16039: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16043: LD_ADDR_VAR 0 2
16047: PUSH
16048: LD_VAR 0 2
16052: PUSH
16053: LD_INT 140
16055: PUSH
16056: LD_INT 175
16058: PUSH
16059: LD_INT 210
16061: PUSH
16062: LD_INT 280
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: LIST
16069: LIST
16070: PUSH
16071: LD_OWVAR 67
16075: ARRAY
16076: PLUS
16077: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16078: LD_INT 3
16080: PPUSH
16081: LD_INT 5
16083: PPUSH
16084: CALL_OW 12
16088: PPUSH
16089: LD_INT 26
16091: PPUSH
16092: LD_INT 9
16094: PPUSH
16095: LD_INT 30
16097: PPUSH
16098: LD_INT 1
16100: PPUSH
16101: CALL_OW 56
// if time > 3 3$00 then
16105: LD_VAR 0 2
16109: PUSH
16110: LD_INT 6300
16112: GREATER
16113: IFFALSE 16123
// time := 0 0$20 ;
16115: LD_ADDR_VAR 0 2
16119: PUSH
16120: LD_INT 700
16122: ST_TO_ADDR
// end ;
16123: GO 16028
// end ;
16125: PPOPN 2
16127: END
// every 0 0$30 do var cr , time ;
16128: GO 16130
16130: DISABLE
16131: LD_INT 0
16133: PPUSH
16134: PPUSH
// begin time := 0 0$20 ;
16135: LD_ADDR_VAR 0 2
16139: PUSH
16140: LD_INT 700
16142: ST_TO_ADDR
// while game do
16143: LD_EXP 2
16147: IFFALSE 16276
// begin wait ( time ) ;
16149: LD_VAR 0 2
16153: PPUSH
16154: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16158: LD_ADDR_VAR 0 2
16162: PUSH
16163: LD_VAR 0 2
16167: PUSH
16168: LD_INT 175
16170: PUSH
16171: LD_INT 210
16173: PUSH
16174: LD_INT 280
16176: PUSH
16177: LD_INT 350
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: PUSH
16186: LD_OWVAR 67
16190: ARRAY
16191: PLUS
16192: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
16193: LD_INT 1
16195: PPUSH
16196: LD_INT 5
16198: PPUSH
16199: CALL_OW 12
16203: PPUSH
16204: LD_INT 179
16206: PPUSH
16207: LD_INT 101
16209: PPUSH
16210: LD_INT 20
16212: PPUSH
16213: LD_INT 1
16215: PPUSH
16216: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16220: LD_INT 350
16222: PPUSH
16223: LD_INT 525
16225: PPUSH
16226: CALL_OW 12
16230: PPUSH
16231: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
16235: LD_INT 1
16237: PPUSH
16238: LD_INT 5
16240: PPUSH
16241: CALL_OW 12
16245: PPUSH
16246: LD_INT 9
16248: PPUSH
16249: LD_INT 1
16251: PPUSH
16252: CALL_OW 55
// if time > 4 4$00 then
16256: LD_VAR 0 2
16260: PUSH
16261: LD_INT 8400
16263: GREATER
16264: IFFALSE 16274
// time := 0 0$30 ;
16266: LD_ADDR_VAR 0 2
16270: PUSH
16271: LD_INT 1050
16273: ST_TO_ADDR
// end ;
16274: GO 16143
// end ;
16276: PPOPN 2
16278: END
// every 0 0$30 do var cr , time ;
16279: GO 16281
16281: DISABLE
16282: LD_INT 0
16284: PPUSH
16285: PPUSH
// begin time := 0 0$10 ;
16286: LD_ADDR_VAR 0 2
16290: PUSH
16291: LD_INT 350
16293: ST_TO_ADDR
// while game do
16294: LD_EXP 2
16298: IFFALSE 16432
// begin wait ( time ) ;
16300: LD_VAR 0 2
16304: PPUSH
16305: CALL_OW 67
// time := time + 0 0$10 ;
16309: LD_ADDR_VAR 0 2
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: LD_INT 350
16321: PLUS
16322: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
16323: LD_INT 1
16325: PPUSH
16326: LD_INT 5
16328: PPUSH
16329: CALL_OW 12
16333: PPUSH
16334: LD_INT 11
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
16344: LD_ADDR_VAR 0 1
16348: PUSH
16349: LD_INT 1
16351: PPUSH
16352: LD_INT 3
16354: PPUSH
16355: CALL_OW 12
16359: ST_TO_ADDR
// if cr = 1 then
16360: LD_VAR 0 1
16364: PUSH
16365: LD_INT 1
16367: EQUAL
16368: IFFALSE 16412
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
16370: LD_INT 700
16372: PPUSH
16373: LD_INT 1575
16375: PPUSH
16376: CALL_OW 12
16380: PPUSH
16381: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
16385: LD_INT 1
16387: PPUSH
16388: LD_INT 5
16390: PPUSH
16391: CALL_OW 12
16395: PPUSH
16396: LD_INT 34
16398: PPUSH
16399: LD_INT 50
16401: PPUSH
16402: LD_INT 7
16404: PPUSH
16405: LD_INT 1
16407: PPUSH
16408: CALL_OW 56
// end ; if time > 4 4$00 then
16412: LD_VAR 0 2
16416: PUSH
16417: LD_INT 8400
16419: GREATER
16420: IFFALSE 16430
// time := 0 0$40 ;
16422: LD_ADDR_VAR 0 2
16426: PUSH
16427: LD_INT 1400
16429: ST_TO_ADDR
// end ;
16430: GO 16294
// end ; end_of_file
16432: PPOPN 2
16434: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16435: LD_INT 0
16437: PPUSH
16438: PPUSH
// if exist_mode then
16439: LD_VAR 0 2
16443: IFFALSE 16468
// unit := CreateCharacter ( prefix & ident ) else
16445: LD_ADDR_VAR 0 5
16449: PUSH
16450: LD_VAR 0 3
16454: PUSH
16455: LD_VAR 0 1
16459: STR
16460: PPUSH
16461: CALL_OW 34
16465: ST_TO_ADDR
16466: GO 16483
// unit := NewCharacter ( ident ) ;
16468: LD_ADDR_VAR 0 5
16472: PUSH
16473: LD_VAR 0 1
16477: PPUSH
16478: CALL_OW 25
16482: ST_TO_ADDR
// result := unit ;
16483: LD_ADDR_VAR 0 4
16487: PUSH
16488: LD_VAR 0 5
16492: ST_TO_ADDR
// end ;
16493: LD_VAR 0 4
16497: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// if not side or not nation then
16502: LD_VAR 0 1
16506: NOT
16507: PUSH
16508: LD_VAR 0 2
16512: NOT
16513: OR
16514: IFFALSE 16518
// exit ;
16516: GO 17286
// case nation of nation_american :
16518: LD_VAR 0 2
16522: PUSH
16523: LD_INT 1
16525: DOUBLE
16526: EQUAL
16527: IFTRUE 16531
16529: GO 16745
16531: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16532: LD_ADDR_VAR 0 4
16536: PUSH
16537: LD_INT 35
16539: PUSH
16540: LD_INT 45
16542: PUSH
16543: LD_INT 46
16545: PUSH
16546: LD_INT 47
16548: PUSH
16549: LD_INT 82
16551: PUSH
16552: LD_INT 83
16554: PUSH
16555: LD_INT 84
16557: PUSH
16558: LD_INT 85
16560: PUSH
16561: LD_INT 86
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: LD_INT 6
16572: PUSH
16573: LD_INT 15
16575: PUSH
16576: LD_INT 16
16578: PUSH
16579: LD_INT 7
16581: PUSH
16582: LD_INT 12
16584: PUSH
16585: LD_INT 13
16587: PUSH
16588: LD_INT 10
16590: PUSH
16591: LD_INT 14
16593: PUSH
16594: LD_INT 20
16596: PUSH
16597: LD_INT 21
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 25
16605: PUSH
16606: LD_INT 32
16608: PUSH
16609: LD_INT 27
16611: PUSH
16612: LD_INT 36
16614: PUSH
16615: LD_INT 69
16617: PUSH
16618: LD_INT 39
16620: PUSH
16621: LD_INT 34
16623: PUSH
16624: LD_INT 40
16626: PUSH
16627: LD_INT 48
16629: PUSH
16630: LD_INT 49
16632: PUSH
16633: LD_INT 50
16635: PUSH
16636: LD_INT 51
16638: PUSH
16639: LD_INT 52
16641: PUSH
16642: LD_INT 53
16644: PUSH
16645: LD_INT 54
16647: PUSH
16648: LD_INT 55
16650: PUSH
16651: LD_INT 56
16653: PUSH
16654: LD_INT 57
16656: PUSH
16657: LD_INT 58
16659: PUSH
16660: LD_INT 59
16662: PUSH
16663: LD_INT 60
16665: PUSH
16666: LD_INT 61
16668: PUSH
16669: LD_INT 62
16671: PUSH
16672: LD_INT 80
16674: PUSH
16675: LD_INT 82
16677: PUSH
16678: LD_INT 83
16680: PUSH
16681: LD_INT 84
16683: PUSH
16684: LD_INT 85
16686: PUSH
16687: LD_INT 86
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: LIST
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: LIST
16735: LIST
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: LIST
16742: ST_TO_ADDR
16743: GO 17210
16745: LD_INT 2
16747: DOUBLE
16748: EQUAL
16749: IFTRUE 16753
16751: GO 16979
16753: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16754: LD_ADDR_VAR 0 4
16758: PUSH
16759: LD_INT 35
16761: PUSH
16762: LD_INT 45
16764: PUSH
16765: LD_INT 46
16767: PUSH
16768: LD_INT 47
16770: PUSH
16771: LD_INT 82
16773: PUSH
16774: LD_INT 83
16776: PUSH
16777: LD_INT 84
16779: PUSH
16780: LD_INT 85
16782: PUSH
16783: LD_INT 87
16785: PUSH
16786: LD_INT 70
16788: PUSH
16789: LD_INT 1
16791: PUSH
16792: LD_INT 11
16794: PUSH
16795: LD_INT 3
16797: PUSH
16798: LD_INT 4
16800: PUSH
16801: LD_INT 5
16803: PUSH
16804: LD_INT 6
16806: PUSH
16807: LD_INT 15
16809: PUSH
16810: LD_INT 18
16812: PUSH
16813: LD_INT 7
16815: PUSH
16816: LD_INT 17
16818: PUSH
16819: LD_INT 8
16821: PUSH
16822: LD_INT 20
16824: PUSH
16825: LD_INT 21
16827: PUSH
16828: LD_INT 22
16830: PUSH
16831: LD_INT 72
16833: PUSH
16834: LD_INT 26
16836: PUSH
16837: LD_INT 69
16839: PUSH
16840: LD_INT 39
16842: PUSH
16843: LD_INT 40
16845: PUSH
16846: LD_INT 41
16848: PUSH
16849: LD_INT 42
16851: PUSH
16852: LD_INT 43
16854: PUSH
16855: LD_INT 48
16857: PUSH
16858: LD_INT 49
16860: PUSH
16861: LD_INT 50
16863: PUSH
16864: LD_INT 51
16866: PUSH
16867: LD_INT 52
16869: PUSH
16870: LD_INT 53
16872: PUSH
16873: LD_INT 54
16875: PUSH
16876: LD_INT 55
16878: PUSH
16879: LD_INT 56
16881: PUSH
16882: LD_INT 60
16884: PUSH
16885: LD_INT 61
16887: PUSH
16888: LD_INT 62
16890: PUSH
16891: LD_INT 66
16893: PUSH
16894: LD_INT 67
16896: PUSH
16897: LD_INT 68
16899: PUSH
16900: LD_INT 81
16902: PUSH
16903: LD_INT 82
16905: PUSH
16906: LD_INT 83
16908: PUSH
16909: LD_INT 84
16911: PUSH
16912: LD_INT 85
16914: PUSH
16915: LD_INT 87
16917: PUSH
16918: LD_INT 88
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: ST_TO_ADDR
16977: GO 17210
16979: LD_INT 3
16981: DOUBLE
16982: EQUAL
16983: IFTRUE 16987
16985: GO 17209
16987: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16988: LD_ADDR_VAR 0 4
16992: PUSH
16993: LD_INT 46
16995: PUSH
16996: LD_INT 47
16998: PUSH
16999: LD_INT 1
17001: PUSH
17002: LD_INT 2
17004: PUSH
17005: LD_INT 82
17007: PUSH
17008: LD_INT 83
17010: PUSH
17011: LD_INT 84
17013: PUSH
17014: LD_INT 85
17016: PUSH
17017: LD_INT 86
17019: PUSH
17020: LD_INT 11
17022: PUSH
17023: LD_INT 9
17025: PUSH
17026: LD_INT 20
17028: PUSH
17029: LD_INT 19
17031: PUSH
17032: LD_INT 21
17034: PUSH
17035: LD_INT 24
17037: PUSH
17038: LD_INT 22
17040: PUSH
17041: LD_INT 25
17043: PUSH
17044: LD_INT 28
17046: PUSH
17047: LD_INT 29
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_INT 31
17055: PUSH
17056: LD_INT 37
17058: PUSH
17059: LD_INT 38
17061: PUSH
17062: LD_INT 32
17064: PUSH
17065: LD_INT 27
17067: PUSH
17068: LD_INT 33
17070: PUSH
17071: LD_INT 69
17073: PUSH
17074: LD_INT 39
17076: PUSH
17077: LD_INT 34
17079: PUSH
17080: LD_INT 40
17082: PUSH
17083: LD_INT 71
17085: PUSH
17086: LD_INT 23
17088: PUSH
17089: LD_INT 44
17091: PUSH
17092: LD_INT 48
17094: PUSH
17095: LD_INT 49
17097: PUSH
17098: LD_INT 50
17100: PUSH
17101: LD_INT 51
17103: PUSH
17104: LD_INT 52
17106: PUSH
17107: LD_INT 53
17109: PUSH
17110: LD_INT 54
17112: PUSH
17113: LD_INT 55
17115: PUSH
17116: LD_INT 56
17118: PUSH
17119: LD_INT 57
17121: PUSH
17122: LD_INT 58
17124: PUSH
17125: LD_INT 59
17127: PUSH
17128: LD_INT 63
17130: PUSH
17131: LD_INT 64
17133: PUSH
17134: LD_INT 65
17136: PUSH
17137: LD_INT 82
17139: PUSH
17140: LD_INT 83
17142: PUSH
17143: LD_INT 84
17145: PUSH
17146: LD_INT 85
17148: PUSH
17149: LD_INT 86
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: LIST
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: ST_TO_ADDR
17207: GO 17210
17209: POP
// if state > - 1 and state < 3 then
17210: LD_VAR 0 3
17214: PUSH
17215: LD_INT 1
17217: NEG
17218: GREATER
17219: PUSH
17220: LD_VAR 0 3
17224: PUSH
17225: LD_INT 3
17227: LESS
17228: AND
17229: IFFALSE 17286
// for i in result do
17231: LD_ADDR_VAR 0 5
17235: PUSH
17236: LD_VAR 0 4
17240: PUSH
17241: FOR_IN
17242: IFFALSE 17284
// if GetTech ( i , side ) <> state then
17244: LD_VAR 0 5
17248: PPUSH
17249: LD_VAR 0 1
17253: PPUSH
17254: CALL_OW 321
17258: PUSH
17259: LD_VAR 0 3
17263: NONEQUAL
17264: IFFALSE 17282
// result := result diff i ;
17266: LD_ADDR_VAR 0 4
17270: PUSH
17271: LD_VAR 0 4
17275: PUSH
17276: LD_VAR 0 5
17280: DIFF
17281: ST_TO_ADDR
17282: GO 17241
17284: POP
17285: POP
// end ;
17286: LD_VAR 0 4
17290: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
17291: LD_INT 0
17293: PPUSH
17294: PPUSH
17295: PPUSH
// result := true ;
17296: LD_ADDR_VAR 0 3
17300: PUSH
17301: LD_INT 1
17303: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
17304: LD_ADDR_VAR 0 5
17308: PUSH
17309: LD_VAR 0 2
17313: PPUSH
17314: CALL_OW 480
17318: ST_TO_ADDR
// if not tmp then
17319: LD_VAR 0 5
17323: NOT
17324: IFFALSE 17328
// exit ;
17326: GO 17377
// for i in tmp do
17328: LD_ADDR_VAR 0 4
17332: PUSH
17333: LD_VAR 0 5
17337: PUSH
17338: FOR_IN
17339: IFFALSE 17375
// if GetTech ( i , side ) <> state_researched then
17341: LD_VAR 0 4
17345: PPUSH
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 321
17355: PUSH
17356: LD_INT 2
17358: NONEQUAL
17359: IFFALSE 17373
// begin result := false ;
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: LD_INT 0
17368: ST_TO_ADDR
// exit ;
17369: POP
17370: POP
17371: GO 17377
// end ;
17373: GO 17338
17375: POP
17376: POP
// end ;
17377: LD_VAR 0 3
17381: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
17382: LD_INT 0
17384: PPUSH
17385: PPUSH
17386: PPUSH
17387: PPUSH
17388: PPUSH
17389: PPUSH
17390: PPUSH
17391: PPUSH
17392: PPUSH
17393: PPUSH
17394: PPUSH
17395: PPUSH
17396: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
17397: LD_VAR 0 1
17401: NOT
17402: PUSH
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 257
17412: PUSH
17413: LD_INT 9
17415: NONEQUAL
17416: OR
17417: IFFALSE 17421
// exit ;
17419: GO 17994
// side := GetSide ( unit ) ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_VAR 0 1
17430: PPUSH
17431: CALL_OW 255
17435: ST_TO_ADDR
// tech_space := tech_spacanom ;
17436: LD_ADDR_VAR 0 12
17440: PUSH
17441: LD_INT 29
17443: ST_TO_ADDR
// tech_time := tech_taurad ;
17444: LD_ADDR_VAR 0 13
17448: PUSH
17449: LD_INT 28
17451: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17452: LD_ADDR_VAR 0 11
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17467: LD_VAR 0 11
17471: PPUSH
17472: CALL_OW 247
17476: PUSH
17477: LD_INT 2
17479: EQUAL
17480: IFFALSE 17484
// exit ;
17482: GO 17994
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17484: LD_ADDR_VAR 0 8
17488: PUSH
17489: LD_INT 81
17491: PUSH
17492: LD_VAR 0 9
17496: PUSH
17497: EMPTY
17498: LIST
17499: LIST
17500: PUSH
17501: LD_INT 3
17503: PUSH
17504: LD_INT 21
17506: PUSH
17507: LD_INT 3
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: PPUSH
17522: CALL_OW 69
17526: ST_TO_ADDR
// if not tmp then
17527: LD_VAR 0 8
17531: NOT
17532: IFFALSE 17536
// exit ;
17534: GO 17994
// if in_unit then
17536: LD_VAR 0 11
17540: IFFALSE 17564
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17542: LD_ADDR_VAR 0 10
17546: PUSH
17547: LD_VAR 0 8
17551: PPUSH
17552: LD_VAR 0 11
17556: PPUSH
17557: CALL_OW 74
17561: ST_TO_ADDR
17562: GO 17584
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17564: LD_ADDR_VAR 0 10
17568: PUSH
17569: LD_VAR 0 8
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 74
17583: ST_TO_ADDR
// if not enemy then
17584: LD_VAR 0 10
17588: NOT
17589: IFFALSE 17593
// exit ;
17591: GO 17994
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17593: LD_VAR 0 11
17597: PUSH
17598: LD_VAR 0 11
17602: PPUSH
17603: LD_VAR 0 10
17607: PPUSH
17608: CALL_OW 296
17612: PUSH
17613: LD_INT 13
17615: GREATER
17616: AND
17617: PUSH
17618: LD_VAR 0 1
17622: PPUSH
17623: LD_VAR 0 10
17627: PPUSH
17628: CALL_OW 296
17632: PUSH
17633: LD_INT 12
17635: GREATER
17636: OR
17637: IFFALSE 17641
// exit ;
17639: GO 17994
// missile := [ 1 ] ;
17641: LD_ADDR_VAR 0 14
17645: PUSH
17646: LD_INT 1
17648: PUSH
17649: EMPTY
17650: LIST
17651: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17652: LD_VAR 0 9
17656: PPUSH
17657: LD_VAR 0 12
17661: PPUSH
17662: CALL_OW 325
17666: IFFALSE 17695
// missile := Replace ( missile , missile + 1 , 2 ) ;
17668: LD_ADDR_VAR 0 14
17672: PUSH
17673: LD_VAR 0 14
17677: PPUSH
17678: LD_VAR 0 14
17682: PUSH
17683: LD_INT 1
17685: PLUS
17686: PPUSH
17687: LD_INT 2
17689: PPUSH
17690: CALL_OW 1
17694: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17695: LD_VAR 0 9
17699: PPUSH
17700: LD_VAR 0 13
17704: PPUSH
17705: CALL_OW 325
17709: PUSH
17710: LD_VAR 0 10
17714: PPUSH
17715: CALL_OW 255
17719: PPUSH
17720: LD_VAR 0 13
17724: PPUSH
17725: CALL_OW 325
17729: NOT
17730: AND
17731: IFFALSE 17760
// missile := Replace ( missile , missile + 1 , 3 ) ;
17733: LD_ADDR_VAR 0 14
17737: PUSH
17738: LD_VAR 0 14
17742: PPUSH
17743: LD_VAR 0 14
17747: PUSH
17748: LD_INT 1
17750: PLUS
17751: PPUSH
17752: LD_INT 3
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// if missile < 2 then
17760: LD_VAR 0 14
17764: PUSH
17765: LD_INT 2
17767: LESS
17768: IFFALSE 17772
// exit ;
17770: GO 17994
// x := GetX ( enemy ) ;
17772: LD_ADDR_VAR 0 4
17776: PUSH
17777: LD_VAR 0 10
17781: PPUSH
17782: CALL_OW 250
17786: ST_TO_ADDR
// y := GetY ( enemy ) ;
17787: LD_ADDR_VAR 0 5
17791: PUSH
17792: LD_VAR 0 10
17796: PPUSH
17797: CALL_OW 251
17801: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17802: LD_ADDR_VAR 0 6
17806: PUSH
17807: LD_VAR 0 4
17811: PUSH
17812: LD_INT 1
17814: NEG
17815: PPUSH
17816: LD_INT 1
17818: PPUSH
17819: CALL_OW 12
17823: PLUS
17824: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17825: LD_ADDR_VAR 0 7
17829: PUSH
17830: LD_VAR 0 5
17834: PUSH
17835: LD_INT 1
17837: NEG
17838: PPUSH
17839: LD_INT 1
17841: PPUSH
17842: CALL_OW 12
17846: PLUS
17847: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17848: LD_VAR 0 6
17852: PPUSH
17853: LD_VAR 0 7
17857: PPUSH
17858: CALL_OW 488
17862: NOT
17863: IFFALSE 17885
// begin _x := x ;
17865: LD_ADDR_VAR 0 6
17869: PUSH
17870: LD_VAR 0 4
17874: ST_TO_ADDR
// _y := y ;
17875: LD_ADDR_VAR 0 7
17879: PUSH
17880: LD_VAR 0 5
17884: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17885: LD_ADDR_VAR 0 3
17889: PUSH
17890: LD_INT 1
17892: PPUSH
17893: LD_VAR 0 14
17897: PPUSH
17898: CALL_OW 12
17902: ST_TO_ADDR
// case i of 1 :
17903: LD_VAR 0 3
17907: PUSH
17908: LD_INT 1
17910: DOUBLE
17911: EQUAL
17912: IFTRUE 17916
17914: GO 17933
17916: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17917: LD_VAR 0 1
17921: PPUSH
17922: LD_VAR 0 10
17926: PPUSH
17927: CALL_OW 115
17931: GO 17994
17933: LD_INT 2
17935: DOUBLE
17936: EQUAL
17937: IFTRUE 17941
17939: GO 17963
17941: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 6
17951: PPUSH
17952: LD_VAR 0 7
17956: PPUSH
17957: CALL_OW 153
17961: GO 17994
17963: LD_INT 3
17965: DOUBLE
17966: EQUAL
17967: IFTRUE 17971
17969: GO 17993
17971: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17972: LD_VAR 0 1
17976: PPUSH
17977: LD_VAR 0 6
17981: PPUSH
17982: LD_VAR 0 7
17986: PPUSH
17987: CALL_OW 154
17991: GO 17994
17993: POP
// end ;
17994: LD_VAR 0 2
17998: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17999: LD_INT 0
18001: PPUSH
18002: PPUSH
18003: PPUSH
18004: PPUSH
18005: PPUSH
18006: PPUSH
// if not unit or not building then
18007: LD_VAR 0 1
18011: NOT
18012: PUSH
18013: LD_VAR 0 2
18017: NOT
18018: OR
18019: IFFALSE 18023
// exit ;
18021: GO 18181
// x := GetX ( building ) ;
18023: LD_ADDR_VAR 0 5
18027: PUSH
18028: LD_VAR 0 2
18032: PPUSH
18033: CALL_OW 250
18037: ST_TO_ADDR
// y := GetY ( building ) ;
18038: LD_ADDR_VAR 0 6
18042: PUSH
18043: LD_VAR 0 2
18047: PPUSH
18048: CALL_OW 251
18052: ST_TO_ADDR
// for i = 0 to 5 do
18053: LD_ADDR_VAR 0 4
18057: PUSH
18058: DOUBLE
18059: LD_INT 0
18061: DEC
18062: ST_TO_ADDR
18063: LD_INT 5
18065: PUSH
18066: FOR_TO
18067: IFFALSE 18179
// begin _x := ShiftX ( x , i , 3 ) ;
18069: LD_ADDR_VAR 0 7
18073: PUSH
18074: LD_VAR 0 5
18078: PPUSH
18079: LD_VAR 0 4
18083: PPUSH
18084: LD_INT 3
18086: PPUSH
18087: CALL_OW 272
18091: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18092: LD_ADDR_VAR 0 8
18096: PUSH
18097: LD_VAR 0 6
18101: PPUSH
18102: LD_VAR 0 4
18106: PPUSH
18107: LD_INT 3
18109: PPUSH
18110: CALL_OW 273
18114: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18115: LD_VAR 0 7
18119: PPUSH
18120: LD_VAR 0 8
18124: PPUSH
18125: CALL_OW 488
18129: NOT
18130: IFFALSE 18134
// continue ;
18132: GO 18066
// if HexInfo ( _x , _y ) = 0 then
18134: LD_VAR 0 7
18138: PPUSH
18139: LD_VAR 0 8
18143: PPUSH
18144: CALL_OW 428
18148: PUSH
18149: LD_INT 0
18151: EQUAL
18152: IFFALSE 18177
// begin ComMoveXY ( unit , _x , _y ) ;
18154: LD_VAR 0 1
18158: PPUSH
18159: LD_VAR 0 7
18163: PPUSH
18164: LD_VAR 0 8
18168: PPUSH
18169: CALL_OW 111
// exit ;
18173: POP
18174: POP
18175: GO 18181
// end ; end ;
18177: GO 18066
18179: POP
18180: POP
// end ;
18181: LD_VAR 0 3
18185: RET
// export function ScanBase ( side , base_area ) ; begin
18186: LD_INT 0
18188: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: LD_VAR 0 2
18198: PPUSH
18199: LD_INT 81
18201: PUSH
18202: LD_VAR 0 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: ST_TO_ADDR
// end ;
18216: LD_VAR 0 3
18220: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18221: LD_INT 0
18223: PPUSH
18224: PPUSH
18225: PPUSH
18226: PPUSH
// result := false ;
18227: LD_ADDR_VAR 0 2
18231: PUSH
18232: LD_INT 0
18234: ST_TO_ADDR
// side := GetSide ( unit ) ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: CALL_OW 255
18249: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18250: LD_ADDR_VAR 0 4
18254: PUSH
18255: LD_VAR 0 1
18259: PPUSH
18260: CALL_OW 248
18264: ST_TO_ADDR
// case nat of 1 :
18265: LD_VAR 0 4
18269: PUSH
18270: LD_INT 1
18272: DOUBLE
18273: EQUAL
18274: IFTRUE 18278
18276: GO 18289
18278: POP
// tech := tech_lassight ; 2 :
18279: LD_ADDR_VAR 0 5
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
18287: GO 18328
18289: LD_INT 2
18291: DOUBLE
18292: EQUAL
18293: IFTRUE 18297
18295: GO 18308
18297: POP
// tech := tech_mortar ; 3 :
18298: LD_ADDR_VAR 0 5
18302: PUSH
18303: LD_INT 41
18305: ST_TO_ADDR
18306: GO 18328
18308: LD_INT 3
18310: DOUBLE
18311: EQUAL
18312: IFTRUE 18316
18314: GO 18327
18316: POP
// tech := tech_bazooka ; end ;
18317: LD_ADDR_VAR 0 5
18321: PUSH
18322: LD_INT 44
18324: ST_TO_ADDR
18325: GO 18328
18327: POP
// if Researched ( side , tech ) then
18328: LD_VAR 0 3
18332: PPUSH
18333: LD_VAR 0 5
18337: PPUSH
18338: CALL_OW 325
18342: IFFALSE 18369
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_INT 5
18351: PUSH
18352: LD_INT 8
18354: PUSH
18355: LD_INT 9
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_VAR 0 4
18367: ARRAY
18368: ST_TO_ADDR
// end ;
18369: LD_VAR 0 2
18373: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18374: LD_INT 0
18376: PPUSH
18377: PPUSH
18378: PPUSH
// if not mines then
18379: LD_VAR 0 2
18383: NOT
18384: IFFALSE 18388
// exit ;
18386: GO 18532
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18388: LD_ADDR_VAR 0 5
18392: PUSH
18393: LD_INT 81
18395: PUSH
18396: LD_VAR 0 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PUSH
18405: LD_INT 3
18407: PUSH
18408: LD_INT 21
18410: PUSH
18411: LD_INT 3
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: PPUSH
18426: CALL_OW 69
18430: ST_TO_ADDR
// for i in mines do
18431: LD_ADDR_VAR 0 4
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: FOR_IN
18442: IFFALSE 18530
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18444: LD_VAR 0 4
18448: PUSH
18449: LD_INT 1
18451: ARRAY
18452: PPUSH
18453: LD_VAR 0 4
18457: PUSH
18458: LD_INT 2
18460: ARRAY
18461: PPUSH
18462: CALL_OW 458
18466: NOT
18467: IFFALSE 18471
// continue ;
18469: GO 18441
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18471: LD_VAR 0 4
18475: PUSH
18476: LD_INT 1
18478: ARRAY
18479: PPUSH
18480: LD_VAR 0 4
18484: PUSH
18485: LD_INT 2
18487: ARRAY
18488: PPUSH
18489: CALL_OW 428
18493: PUSH
18494: LD_VAR 0 5
18498: IN
18499: IFFALSE 18528
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18501: LD_VAR 0 4
18505: PUSH
18506: LD_INT 1
18508: ARRAY
18509: PPUSH
18510: LD_VAR 0 4
18514: PUSH
18515: LD_INT 2
18517: ARRAY
18518: PPUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: CALL_OW 456
// end ;
18528: GO 18441
18530: POP
18531: POP
// end ;
18532: LD_VAR 0 3
18536: RET
// export function Count ( array ) ; begin
18537: LD_INT 0
18539: PPUSH
// result := array + 0 ;
18540: LD_ADDR_VAR 0 2
18544: PUSH
18545: LD_VAR 0 1
18549: PUSH
18550: LD_INT 0
18552: PLUS
18553: ST_TO_ADDR
// end ;
18554: LD_VAR 0 2
18558: RET
// export function IsEmpty ( building ) ; begin
18559: LD_INT 0
18561: PPUSH
// if not building then
18562: LD_VAR 0 1
18566: NOT
18567: IFFALSE 18571
// exit ;
18569: GO 18614
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18571: LD_ADDR_VAR 0 2
18575: PUSH
18576: LD_VAR 0 1
18580: PUSH
18581: LD_INT 22
18583: PUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 255
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: PUSH
18598: LD_INT 58
18600: PUSH
18601: EMPTY
18602: LIST
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PPUSH
18608: CALL_OW 69
18612: IN
18613: ST_TO_ADDR
// end ;
18614: LD_VAR 0 2
18618: RET
// export function IsNotFull ( building ) ; var places ; begin
18619: LD_INT 0
18621: PPUSH
18622: PPUSH
// if not building then
18623: LD_VAR 0 1
18627: NOT
18628: IFFALSE 18632
// exit ;
18630: GO 18660
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18632: LD_ADDR_VAR 0 2
18636: PUSH
18637: LD_VAR 0 1
18641: PPUSH
18642: LD_INT 3
18644: PUSH
18645: LD_INT 62
18647: PUSH
18648: EMPTY
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PPUSH
18655: CALL_OW 72
18659: ST_TO_ADDR
// end ;
18660: LD_VAR 0 2
18664: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18665: LD_INT 0
18667: PPUSH
18668: PPUSH
18669: PPUSH
18670: PPUSH
// tmp := [ ] ;
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: EMPTY
18677: ST_TO_ADDR
// list := [ ] ;
18678: LD_ADDR_VAR 0 5
18682: PUSH
18683: EMPTY
18684: ST_TO_ADDR
// for i = 16 to 25 do
18685: LD_ADDR_VAR 0 4
18689: PUSH
18690: DOUBLE
18691: LD_INT 16
18693: DEC
18694: ST_TO_ADDR
18695: LD_INT 25
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18772
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18701: LD_ADDR_VAR 0 3
18705: PUSH
18706: LD_VAR 0 3
18710: PUSH
18711: LD_INT 22
18713: PUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: CALL_OW 255
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: PUSH
18728: LD_INT 91
18730: PUSH
18731: LD_VAR 0 1
18735: PUSH
18736: LD_INT 6
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 30
18746: PUSH
18747: LD_VAR 0 4
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: PPUSH
18764: CALL_OW 69
18768: ADD
18769: ST_TO_ADDR
18770: GO 18698
18772: POP
18773: POP
// for i = 1 to tmp do
18774: LD_ADDR_VAR 0 4
18778: PUSH
18779: DOUBLE
18780: LD_INT 1
18782: DEC
18783: ST_TO_ADDR
18784: LD_VAR 0 3
18788: PUSH
18789: FOR_TO
18790: IFFALSE 18878
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18792: LD_ADDR_VAR 0 5
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: LD_VAR 0 3
18806: PUSH
18807: LD_VAR 0 4
18811: ARRAY
18812: PPUSH
18813: CALL_OW 266
18817: PUSH
18818: LD_VAR 0 3
18822: PUSH
18823: LD_VAR 0 4
18827: ARRAY
18828: PPUSH
18829: CALL_OW 250
18833: PUSH
18834: LD_VAR 0 3
18838: PUSH
18839: LD_VAR 0 4
18843: ARRAY
18844: PPUSH
18845: CALL_OW 251
18849: PUSH
18850: LD_VAR 0 3
18854: PUSH
18855: LD_VAR 0 4
18859: ARRAY
18860: PPUSH
18861: CALL_OW 254
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: PUSH
18872: EMPTY
18873: LIST
18874: ADD
18875: ST_TO_ADDR
18876: GO 18789
18878: POP
18879: POP
// result := list ;
18880: LD_ADDR_VAR 0 2
18884: PUSH
18885: LD_VAR 0 5
18889: ST_TO_ADDR
// end ;
18890: LD_VAR 0 2
18894: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18895: LD_INT 0
18897: PPUSH
18898: PPUSH
18899: PPUSH
18900: PPUSH
18901: PPUSH
18902: PPUSH
18903: PPUSH
// if not factory then
18904: LD_VAR 0 1
18908: NOT
18909: IFFALSE 18913
// exit ;
18911: GO 19506
// if control = control_apeman then
18913: LD_VAR 0 4
18917: PUSH
18918: LD_INT 5
18920: EQUAL
18921: IFFALSE 19030
// begin tmp := UnitsInside ( factory ) ;
18923: LD_ADDR_VAR 0 8
18927: PUSH
18928: LD_VAR 0 1
18932: PPUSH
18933: CALL_OW 313
18937: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18938: LD_VAR 0 8
18942: PPUSH
18943: LD_INT 25
18945: PUSH
18946: LD_INT 12
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PPUSH
18953: CALL_OW 72
18957: NOT
18958: IFFALSE 18968
// control := control_manual ;
18960: LD_ADDR_VAR 0 4
18964: PUSH
18965: LD_INT 1
18967: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18968: LD_ADDR_VAR 0 8
18972: PUSH
18973: LD_VAR 0 1
18977: PPUSH
18978: CALL 18665 0 1
18982: ST_TO_ADDR
// if tmp then
18983: LD_VAR 0 8
18987: IFFALSE 19030
// begin for i in tmp do
18989: LD_ADDR_VAR 0 7
18993: PUSH
18994: LD_VAR 0 8
18998: PUSH
18999: FOR_IN
19000: IFFALSE 19028
// if i [ 1 ] = b_ext_radio then
19002: LD_VAR 0 7
19006: PUSH
19007: LD_INT 1
19009: ARRAY
19010: PUSH
19011: LD_INT 22
19013: EQUAL
19014: IFFALSE 19026
// begin control := control_remote ;
19016: LD_ADDR_VAR 0 4
19020: PUSH
19021: LD_INT 2
19023: ST_TO_ADDR
// break ;
19024: GO 19028
// end ;
19026: GO 18999
19028: POP
19029: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_VAR 0 3
19044: PPUSH
19045: LD_VAR 0 4
19049: PPUSH
19050: LD_VAR 0 5
19054: PPUSH
19055: CALL_OW 448
19059: IFFALSE 19094
// begin result := [ chassis , engine , control , weapon ] ;
19061: LD_ADDR_VAR 0 6
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 3
19075: PUSH
19076: LD_VAR 0 4
19080: PUSH
19081: LD_VAR 0 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: ST_TO_ADDR
// exit ;
19092: GO 19506
// end ; _chassis := AvailableChassisList ( factory ) ;
19094: LD_ADDR_VAR 0 9
19098: PUSH
19099: LD_VAR 0 1
19103: PPUSH
19104: CALL_OW 475
19108: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19109: LD_ADDR_VAR 0 11
19113: PUSH
19114: LD_VAR 0 1
19118: PPUSH
19119: CALL_OW 476
19123: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19124: LD_ADDR_VAR 0 12
19128: PUSH
19129: LD_VAR 0 1
19133: PPUSH
19134: CALL_OW 477
19138: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19139: LD_ADDR_VAR 0 10
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: CALL_OW 478
19153: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19154: LD_VAR 0 9
19158: NOT
19159: PUSH
19160: LD_VAR 0 11
19164: NOT
19165: OR
19166: PUSH
19167: LD_VAR 0 12
19171: NOT
19172: OR
19173: PUSH
19174: LD_VAR 0 10
19178: NOT
19179: OR
19180: IFFALSE 19215
// begin result := [ chassis , engine , control , weapon ] ;
19182: LD_ADDR_VAR 0 6
19186: PUSH
19187: LD_VAR 0 2
19191: PUSH
19192: LD_VAR 0 3
19196: PUSH
19197: LD_VAR 0 4
19201: PUSH
19202: LD_VAR 0 5
19206: PUSH
19207: EMPTY
19208: LIST
19209: LIST
19210: LIST
19211: LIST
19212: ST_TO_ADDR
// exit ;
19213: GO 19506
// end ; if not chassis in _chassis then
19215: LD_VAR 0 2
19219: PUSH
19220: LD_VAR 0 9
19224: IN
19225: NOT
19226: IFFALSE 19252
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19228: LD_ADDR_VAR 0 2
19232: PUSH
19233: LD_VAR 0 9
19237: PUSH
19238: LD_INT 1
19240: PPUSH
19241: LD_VAR 0 9
19245: PPUSH
19246: CALL_OW 12
19250: ARRAY
19251: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19252: LD_VAR 0 2
19256: PPUSH
19257: LD_VAR 0 3
19261: PPUSH
19262: CALL 19511 0 2
19266: NOT
19267: IFFALSE 19326
// repeat engine := _engine [ 1 ] ;
19269: LD_ADDR_VAR 0 3
19273: PUSH
19274: LD_VAR 0 11
19278: PUSH
19279: LD_INT 1
19281: ARRAY
19282: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19283: LD_ADDR_VAR 0 11
19287: PUSH
19288: LD_VAR 0 11
19292: PPUSH
19293: LD_INT 1
19295: PPUSH
19296: CALL_OW 3
19300: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19301: LD_VAR 0 2
19305: PPUSH
19306: LD_VAR 0 3
19310: PPUSH
19311: CALL 19511 0 2
19315: PUSH
19316: LD_VAR 0 11
19320: PUSH
19321: EMPTY
19322: EQUAL
19323: OR
19324: IFFALSE 19269
// if not control in _control then
19326: LD_VAR 0 4
19330: PUSH
19331: LD_VAR 0 12
19335: IN
19336: NOT
19337: IFFALSE 19363
// control := _control [ rand ( 1 , _control ) ] ;
19339: LD_ADDR_VAR 0 4
19343: PUSH
19344: LD_VAR 0 12
19348: PUSH
19349: LD_INT 1
19351: PPUSH
19352: LD_VAR 0 12
19356: PPUSH
19357: CALL_OW 12
19361: ARRAY
19362: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19363: LD_VAR 0 2
19367: PPUSH
19368: LD_VAR 0 5
19372: PPUSH
19373: CALL 19731 0 2
19377: NOT
19378: IFFALSE 19437
// repeat weapon := _weapon [ 1 ] ;
19380: LD_ADDR_VAR 0 5
19384: PUSH
19385: LD_VAR 0 10
19389: PUSH
19390: LD_INT 1
19392: ARRAY
19393: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19394: LD_ADDR_VAR 0 10
19398: PUSH
19399: LD_VAR 0 10
19403: PPUSH
19404: LD_INT 1
19406: PPUSH
19407: CALL_OW 3
19411: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19412: LD_VAR 0 2
19416: PPUSH
19417: LD_VAR 0 5
19421: PPUSH
19422: CALL 19731 0 2
19426: PUSH
19427: LD_VAR 0 10
19431: PUSH
19432: EMPTY
19433: EQUAL
19434: OR
19435: IFFALSE 19380
// result := [ ] ;
19437: LD_ADDR_VAR 0 6
19441: PUSH
19442: EMPTY
19443: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19444: LD_VAR 0 1
19448: PPUSH
19449: LD_VAR 0 2
19453: PPUSH
19454: LD_VAR 0 3
19458: PPUSH
19459: LD_VAR 0 4
19463: PPUSH
19464: LD_VAR 0 5
19468: PPUSH
19469: CALL_OW 448
19473: IFFALSE 19506
// result := [ chassis , engine , control , weapon ] ;
19475: LD_ADDR_VAR 0 6
19479: PUSH
19480: LD_VAR 0 2
19484: PUSH
19485: LD_VAR 0 3
19489: PUSH
19490: LD_VAR 0 4
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: ST_TO_ADDR
// end ;
19506: LD_VAR 0 6
19510: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19511: LD_INT 0
19513: PPUSH
// if not chassis or not engine then
19514: LD_VAR 0 1
19518: NOT
19519: PUSH
19520: LD_VAR 0 2
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 19726
// case engine of engine_solar :
19530: LD_VAR 0 2
19534: PUSH
19535: LD_INT 2
19537: DOUBLE
19538: EQUAL
19539: IFTRUE 19543
19541: GO 19581
19543: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19544: LD_ADDR_VAR 0 3
19548: PUSH
19549: LD_INT 11
19551: PUSH
19552: LD_INT 12
19554: PUSH
19555: LD_INT 13
19557: PUSH
19558: LD_INT 14
19560: PUSH
19561: LD_INT 1
19563: PUSH
19564: LD_INT 2
19566: PUSH
19567: LD_INT 3
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 19710
19581: LD_INT 1
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19651
19589: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 11
19597: PUSH
19598: LD_INT 12
19600: PUSH
19601: LD_INT 13
19603: PUSH
19604: LD_INT 14
19606: PUSH
19607: LD_INT 1
19609: PUSH
19610: LD_INT 2
19612: PUSH
19613: LD_INT 3
19615: PUSH
19616: LD_INT 4
19618: PUSH
19619: LD_INT 5
19621: PUSH
19622: LD_INT 21
19624: PUSH
19625: LD_INT 23
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: ST_TO_ADDR
19649: GO 19710
19651: LD_INT 3
19653: DOUBLE
19654: EQUAL
19655: IFTRUE 19659
19657: GO 19709
19659: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19660: LD_ADDR_VAR 0 3
19664: PUSH
19665: LD_INT 13
19667: PUSH
19668: LD_INT 14
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: LD_INT 3
19676: PUSH
19677: LD_INT 4
19679: PUSH
19680: LD_INT 5
19682: PUSH
19683: LD_INT 21
19685: PUSH
19686: LD_INT 22
19688: PUSH
19689: LD_INT 23
19691: PUSH
19692: LD_INT 24
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: ST_TO_ADDR
19707: GO 19710
19709: POP
// result := ( chassis in result ) ;
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_VAR 0 1
19719: PUSH
19720: LD_VAR 0 3
19724: IN
19725: ST_TO_ADDR
// end ;
19726: LD_VAR 0 3
19730: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19731: LD_INT 0
19733: PPUSH
// if not chassis or not weapon then
19734: LD_VAR 0 1
19738: NOT
19739: PUSH
19740: LD_VAR 0 2
19744: NOT
19745: OR
19746: IFFALSE 19750
// exit ;
19748: GO 20810
// case weapon of us_machine_gun :
19750: LD_VAR 0 2
19754: PUSH
19755: LD_INT 2
19757: DOUBLE
19758: EQUAL
19759: IFTRUE 19763
19761: GO 19793
19763: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19764: LD_ADDR_VAR 0 3
19768: PUSH
19769: LD_INT 1
19771: PUSH
19772: LD_INT 2
19774: PUSH
19775: LD_INT 3
19777: PUSH
19778: LD_INT 4
19780: PUSH
19781: LD_INT 5
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: ST_TO_ADDR
19791: GO 20794
19793: LD_INT 3
19795: DOUBLE
19796: EQUAL
19797: IFTRUE 19801
19799: GO 19831
19801: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19802: LD_ADDR_VAR 0 3
19806: PUSH
19807: LD_INT 1
19809: PUSH
19810: LD_INT 2
19812: PUSH
19813: LD_INT 3
19815: PUSH
19816: LD_INT 4
19818: PUSH
19819: LD_INT 5
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: LIST
19826: LIST
19827: LIST
19828: ST_TO_ADDR
19829: GO 20794
19831: LD_INT 11
19833: DOUBLE
19834: EQUAL
19835: IFTRUE 19839
19837: GO 19869
19839: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19840: LD_ADDR_VAR 0 3
19844: PUSH
19845: LD_INT 1
19847: PUSH
19848: LD_INT 2
19850: PUSH
19851: LD_INT 3
19853: PUSH
19854: LD_INT 4
19856: PUSH
19857: LD_INT 5
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: ST_TO_ADDR
19867: GO 20794
19869: LD_INT 4
19871: DOUBLE
19872: EQUAL
19873: IFTRUE 19877
19875: GO 19903
19877: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19878: LD_ADDR_VAR 0 3
19882: PUSH
19883: LD_INT 2
19885: PUSH
19886: LD_INT 3
19888: PUSH
19889: LD_INT 4
19891: PUSH
19892: LD_INT 5
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: ST_TO_ADDR
19901: GO 20794
19903: LD_INT 5
19905: DOUBLE
19906: EQUAL
19907: IFTRUE 19911
19909: GO 19937
19911: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19912: LD_ADDR_VAR 0 3
19916: PUSH
19917: LD_INT 2
19919: PUSH
19920: LD_INT 3
19922: PUSH
19923: LD_INT 4
19925: PUSH
19926: LD_INT 5
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: LIST
19933: LIST
19934: ST_TO_ADDR
19935: GO 20794
19937: LD_INT 9
19939: DOUBLE
19940: EQUAL
19941: IFTRUE 19945
19943: GO 19971
19945: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19946: LD_ADDR_VAR 0 3
19950: PUSH
19951: LD_INT 2
19953: PUSH
19954: LD_INT 3
19956: PUSH
19957: LD_INT 4
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: ST_TO_ADDR
19969: GO 20794
19971: LD_INT 7
19973: DOUBLE
19974: EQUAL
19975: IFTRUE 19979
19977: GO 20005
19979: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19980: LD_ADDR_VAR 0 3
19984: PUSH
19985: LD_INT 2
19987: PUSH
19988: LD_INT 3
19990: PUSH
19991: LD_INT 4
19993: PUSH
19994: LD_INT 5
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: ST_TO_ADDR
20003: GO 20794
20005: LD_INT 12
20007: DOUBLE
20008: EQUAL
20009: IFTRUE 20013
20011: GO 20039
20013: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20014: LD_ADDR_VAR 0 3
20018: PUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 3
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: LD_INT 5
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: LIST
20035: LIST
20036: ST_TO_ADDR
20037: GO 20794
20039: LD_INT 13
20041: DOUBLE
20042: EQUAL
20043: IFTRUE 20047
20045: GO 20073
20047: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20048: LD_ADDR_VAR 0 3
20052: PUSH
20053: LD_INT 2
20055: PUSH
20056: LD_INT 3
20058: PUSH
20059: LD_INT 4
20061: PUSH
20062: LD_INT 5
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: ST_TO_ADDR
20071: GO 20794
20073: LD_INT 14
20075: DOUBLE
20076: EQUAL
20077: IFTRUE 20081
20079: GO 20099
20081: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20082: LD_ADDR_VAR 0 3
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: EMPTY
20094: LIST
20095: LIST
20096: ST_TO_ADDR
20097: GO 20794
20099: LD_INT 6
20101: DOUBLE
20102: EQUAL
20103: IFTRUE 20107
20105: GO 20125
20107: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_INT 4
20115: PUSH
20116: LD_INT 5
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: ST_TO_ADDR
20123: GO 20794
20125: LD_INT 10
20127: DOUBLE
20128: EQUAL
20129: IFTRUE 20133
20131: GO 20151
20133: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20134: LD_ADDR_VAR 0 3
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 5
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: ST_TO_ADDR
20149: GO 20794
20151: LD_INT 22
20153: DOUBLE
20154: EQUAL
20155: IFTRUE 20159
20157: GO 20185
20159: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20160: LD_ADDR_VAR 0 3
20164: PUSH
20165: LD_INT 11
20167: PUSH
20168: LD_INT 12
20170: PUSH
20171: LD_INT 13
20173: PUSH
20174: LD_INT 14
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: ST_TO_ADDR
20183: GO 20794
20185: LD_INT 23
20187: DOUBLE
20188: EQUAL
20189: IFTRUE 20193
20191: GO 20219
20193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20194: LD_ADDR_VAR 0 3
20198: PUSH
20199: LD_INT 11
20201: PUSH
20202: LD_INT 12
20204: PUSH
20205: LD_INT 13
20207: PUSH
20208: LD_INT 14
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: ST_TO_ADDR
20217: GO 20794
20219: LD_INT 24
20221: DOUBLE
20222: EQUAL
20223: IFTRUE 20227
20225: GO 20253
20227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20228: LD_ADDR_VAR 0 3
20232: PUSH
20233: LD_INT 11
20235: PUSH
20236: LD_INT 12
20238: PUSH
20239: LD_INT 13
20241: PUSH
20242: LD_INT 14
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 20794
20253: LD_INT 30
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20287
20261: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20262: LD_ADDR_VAR 0 3
20266: PUSH
20267: LD_INT 11
20269: PUSH
20270: LD_INT 12
20272: PUSH
20273: LD_INT 13
20275: PUSH
20276: LD_INT 14
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: ST_TO_ADDR
20285: GO 20794
20287: LD_INT 25
20289: DOUBLE
20290: EQUAL
20291: IFTRUE 20295
20293: GO 20313
20295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_INT 13
20303: PUSH
20304: LD_INT 14
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: ST_TO_ADDR
20311: GO 20794
20313: LD_INT 27
20315: DOUBLE
20316: EQUAL
20317: IFTRUE 20321
20319: GO 20339
20321: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_INT 13
20329: PUSH
20330: LD_INT 14
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: ST_TO_ADDR
20337: GO 20794
20339: LD_INT 92
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20373
20347: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20348: LD_ADDR_VAR 0 3
20352: PUSH
20353: LD_INT 11
20355: PUSH
20356: LD_INT 12
20358: PUSH
20359: LD_INT 13
20361: PUSH
20362: LD_INT 14
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: ST_TO_ADDR
20371: GO 20794
20373: LD_INT 28
20375: DOUBLE
20376: EQUAL
20377: IFTRUE 20381
20379: GO 20399
20381: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20382: LD_ADDR_VAR 0 3
20386: PUSH
20387: LD_INT 13
20389: PUSH
20390: LD_INT 14
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: ST_TO_ADDR
20397: GO 20794
20399: LD_INT 29
20401: DOUBLE
20402: EQUAL
20403: IFTRUE 20407
20405: GO 20425
20407: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20408: LD_ADDR_VAR 0 3
20412: PUSH
20413: LD_INT 13
20415: PUSH
20416: LD_INT 14
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: ST_TO_ADDR
20423: GO 20794
20425: LD_INT 31
20427: DOUBLE
20428: EQUAL
20429: IFTRUE 20433
20431: GO 20451
20433: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20434: LD_ADDR_VAR 0 3
20438: PUSH
20439: LD_INT 13
20441: PUSH
20442: LD_INT 14
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: ST_TO_ADDR
20449: GO 20794
20451: LD_INT 26
20453: DOUBLE
20454: EQUAL
20455: IFTRUE 20459
20457: GO 20477
20459: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 13
20467: PUSH
20468: LD_INT 14
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: ST_TO_ADDR
20475: GO 20794
20477: LD_INT 42
20479: DOUBLE
20480: EQUAL
20481: IFTRUE 20485
20483: GO 20511
20485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20486: LD_ADDR_VAR 0 3
20490: PUSH
20491: LD_INT 21
20493: PUSH
20494: LD_INT 22
20496: PUSH
20497: LD_INT 23
20499: PUSH
20500: LD_INT 24
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: ST_TO_ADDR
20509: GO 20794
20511: LD_INT 43
20513: DOUBLE
20514: EQUAL
20515: IFTRUE 20519
20517: GO 20545
20519: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_INT 21
20527: PUSH
20528: LD_INT 22
20530: PUSH
20531: LD_INT 23
20533: PUSH
20534: LD_INT 24
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: LIST
20541: LIST
20542: ST_TO_ADDR
20543: GO 20794
20545: LD_INT 44
20547: DOUBLE
20548: EQUAL
20549: IFTRUE 20553
20551: GO 20579
20553: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20554: LD_ADDR_VAR 0 3
20558: PUSH
20559: LD_INT 21
20561: PUSH
20562: LD_INT 22
20564: PUSH
20565: LD_INT 23
20567: PUSH
20568: LD_INT 24
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: ST_TO_ADDR
20577: GO 20794
20579: LD_INT 45
20581: DOUBLE
20582: EQUAL
20583: IFTRUE 20587
20585: GO 20613
20587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20588: LD_ADDR_VAR 0 3
20592: PUSH
20593: LD_INT 21
20595: PUSH
20596: LD_INT 22
20598: PUSH
20599: LD_INT 23
20601: PUSH
20602: LD_INT 24
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: ST_TO_ADDR
20611: GO 20794
20613: LD_INT 49
20615: DOUBLE
20616: EQUAL
20617: IFTRUE 20621
20619: GO 20647
20621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20622: LD_ADDR_VAR 0 3
20626: PUSH
20627: LD_INT 21
20629: PUSH
20630: LD_INT 22
20632: PUSH
20633: LD_INT 23
20635: PUSH
20636: LD_INT 24
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: ST_TO_ADDR
20645: GO 20794
20647: LD_INT 51
20649: DOUBLE
20650: EQUAL
20651: IFTRUE 20655
20653: GO 20681
20655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20656: LD_ADDR_VAR 0 3
20660: PUSH
20661: LD_INT 21
20663: PUSH
20664: LD_INT 22
20666: PUSH
20667: LD_INT 23
20669: PUSH
20670: LD_INT 24
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: ST_TO_ADDR
20679: GO 20794
20681: LD_INT 52
20683: DOUBLE
20684: EQUAL
20685: IFTRUE 20689
20687: GO 20715
20689: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_INT 21
20697: PUSH
20698: LD_INT 22
20700: PUSH
20701: LD_INT 23
20703: PUSH
20704: LD_INT 24
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: ST_TO_ADDR
20713: GO 20794
20715: LD_INT 53
20717: DOUBLE
20718: EQUAL
20719: IFTRUE 20723
20721: GO 20741
20723: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20724: LD_ADDR_VAR 0 3
20728: PUSH
20729: LD_INT 23
20731: PUSH
20732: LD_INT 24
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: ST_TO_ADDR
20739: GO 20794
20741: LD_INT 46
20743: DOUBLE
20744: EQUAL
20745: IFTRUE 20749
20747: GO 20767
20749: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20750: LD_ADDR_VAR 0 3
20754: PUSH
20755: LD_INT 23
20757: PUSH
20758: LD_INT 24
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: ST_TO_ADDR
20765: GO 20794
20767: LD_INT 47
20769: DOUBLE
20770: EQUAL
20771: IFTRUE 20775
20773: GO 20793
20775: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20776: LD_ADDR_VAR 0 3
20780: PUSH
20781: LD_INT 23
20783: PUSH
20784: LD_INT 24
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: ST_TO_ADDR
20791: GO 20794
20793: POP
// result := ( chassis in result ) ;
20794: LD_ADDR_VAR 0 3
20798: PUSH
20799: LD_VAR 0 1
20803: PUSH
20804: LD_VAR 0 3
20808: IN
20809: ST_TO_ADDR
// end ;
20810: LD_VAR 0 3
20814: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20815: LD_INT 0
20817: PPUSH
20818: PPUSH
20819: PPUSH
20820: PPUSH
20821: PPUSH
20822: PPUSH
20823: PPUSH
// result := array ;
20824: LD_ADDR_VAR 0 5
20828: PUSH
20829: LD_VAR 0 1
20833: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20834: LD_VAR 0 1
20838: NOT
20839: PUSH
20840: LD_VAR 0 2
20844: NOT
20845: OR
20846: PUSH
20847: LD_VAR 0 3
20851: NOT
20852: OR
20853: PUSH
20854: LD_VAR 0 2
20858: PUSH
20859: LD_VAR 0 1
20863: GREATER
20864: OR
20865: PUSH
20866: LD_VAR 0 3
20870: PUSH
20871: LD_VAR 0 1
20875: GREATER
20876: OR
20877: IFFALSE 20881
// exit ;
20879: GO 21177
// if direction then
20881: LD_VAR 0 4
20885: IFFALSE 20949
// begin d := 1 ;
20887: LD_ADDR_VAR 0 9
20891: PUSH
20892: LD_INT 1
20894: ST_TO_ADDR
// if i_from > i_to then
20895: LD_VAR 0 2
20899: PUSH
20900: LD_VAR 0 3
20904: GREATER
20905: IFFALSE 20931
// length := ( array - i_from ) + i_to else
20907: LD_ADDR_VAR 0 11
20911: PUSH
20912: LD_VAR 0 1
20916: PUSH
20917: LD_VAR 0 2
20921: MINUS
20922: PUSH
20923: LD_VAR 0 3
20927: PLUS
20928: ST_TO_ADDR
20929: GO 20947
// length := i_to - i_from ;
20931: LD_ADDR_VAR 0 11
20935: PUSH
20936: LD_VAR 0 3
20940: PUSH
20941: LD_VAR 0 2
20945: MINUS
20946: ST_TO_ADDR
// end else
20947: GO 21010
// begin d := - 1 ;
20949: LD_ADDR_VAR 0 9
20953: PUSH
20954: LD_INT 1
20956: NEG
20957: ST_TO_ADDR
// if i_from > i_to then
20958: LD_VAR 0 2
20962: PUSH
20963: LD_VAR 0 3
20967: GREATER
20968: IFFALSE 20988
// length := i_from - i_to else
20970: LD_ADDR_VAR 0 11
20974: PUSH
20975: LD_VAR 0 2
20979: PUSH
20980: LD_VAR 0 3
20984: MINUS
20985: ST_TO_ADDR
20986: GO 21010
// length := ( array - i_to ) + i_from ;
20988: LD_ADDR_VAR 0 11
20992: PUSH
20993: LD_VAR 0 1
20997: PUSH
20998: LD_VAR 0 3
21002: MINUS
21003: PUSH
21004: LD_VAR 0 2
21008: PLUS
21009: ST_TO_ADDR
// end ; if not length then
21010: LD_VAR 0 11
21014: NOT
21015: IFFALSE 21019
// exit ;
21017: GO 21177
// tmp := array ;
21019: LD_ADDR_VAR 0 10
21023: PUSH
21024: LD_VAR 0 1
21028: ST_TO_ADDR
// for i = 1 to length do
21029: LD_ADDR_VAR 0 6
21033: PUSH
21034: DOUBLE
21035: LD_INT 1
21037: DEC
21038: ST_TO_ADDR
21039: LD_VAR 0 11
21043: PUSH
21044: FOR_TO
21045: IFFALSE 21165
// begin for j = 1 to array do
21047: LD_ADDR_VAR 0 7
21051: PUSH
21052: DOUBLE
21053: LD_INT 1
21055: DEC
21056: ST_TO_ADDR
21057: LD_VAR 0 1
21061: PUSH
21062: FOR_TO
21063: IFFALSE 21151
// begin k := j + d ;
21065: LD_ADDR_VAR 0 8
21069: PUSH
21070: LD_VAR 0 7
21074: PUSH
21075: LD_VAR 0 9
21079: PLUS
21080: ST_TO_ADDR
// if k > array then
21081: LD_VAR 0 8
21085: PUSH
21086: LD_VAR 0 1
21090: GREATER
21091: IFFALSE 21101
// k := 1 ;
21093: LD_ADDR_VAR 0 8
21097: PUSH
21098: LD_INT 1
21100: ST_TO_ADDR
// if not k then
21101: LD_VAR 0 8
21105: NOT
21106: IFFALSE 21118
// k := array ;
21108: LD_ADDR_VAR 0 8
21112: PUSH
21113: LD_VAR 0 1
21117: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21118: LD_ADDR_VAR 0 10
21122: PUSH
21123: LD_VAR 0 10
21127: PPUSH
21128: LD_VAR 0 8
21132: PPUSH
21133: LD_VAR 0 1
21137: PUSH
21138: LD_VAR 0 7
21142: ARRAY
21143: PPUSH
21144: CALL_OW 1
21148: ST_TO_ADDR
// end ;
21149: GO 21062
21151: POP
21152: POP
// array := tmp ;
21153: LD_ADDR_VAR 0 1
21157: PUSH
21158: LD_VAR 0 10
21162: ST_TO_ADDR
// end ;
21163: GO 21044
21165: POP
21166: POP
// result := array ;
21167: LD_ADDR_VAR 0 5
21171: PUSH
21172: LD_VAR 0 1
21176: ST_TO_ADDR
// end ;
21177: LD_VAR 0 5
21181: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21182: LD_INT 0
21184: PPUSH
21185: PPUSH
// result := 0 ;
21186: LD_ADDR_VAR 0 3
21190: PUSH
21191: LD_INT 0
21193: ST_TO_ADDR
// if not array or not value in array then
21194: LD_VAR 0 1
21198: NOT
21199: PUSH
21200: LD_VAR 0 2
21204: PUSH
21205: LD_VAR 0 1
21209: IN
21210: NOT
21211: OR
21212: IFFALSE 21216
// exit ;
21214: GO 21270
// for i = 1 to array do
21216: LD_ADDR_VAR 0 4
21220: PUSH
21221: DOUBLE
21222: LD_INT 1
21224: DEC
21225: ST_TO_ADDR
21226: LD_VAR 0 1
21230: PUSH
21231: FOR_TO
21232: IFFALSE 21268
// if value = array [ i ] then
21234: LD_VAR 0 2
21238: PUSH
21239: LD_VAR 0 1
21243: PUSH
21244: LD_VAR 0 4
21248: ARRAY
21249: EQUAL
21250: IFFALSE 21266
// begin result := i ;
21252: LD_ADDR_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: ST_TO_ADDR
// exit ;
21262: POP
21263: POP
21264: GO 21270
// end ;
21266: GO 21231
21268: POP
21269: POP
// end ;
21270: LD_VAR 0 3
21274: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21275: LD_INT 0
21277: PPUSH
// vc_chassis := chassis ;
21278: LD_ADDR_OWVAR 37
21282: PUSH
21283: LD_VAR 0 1
21287: ST_TO_ADDR
// vc_engine := engine ;
21288: LD_ADDR_OWVAR 39
21292: PUSH
21293: LD_VAR 0 2
21297: ST_TO_ADDR
// vc_control := control ;
21298: LD_ADDR_OWVAR 38
21302: PUSH
21303: LD_VAR 0 3
21307: ST_TO_ADDR
// vc_weapon := weapon ;
21308: LD_ADDR_OWVAR 40
21312: PUSH
21313: LD_VAR 0 4
21317: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21318: LD_ADDR_OWVAR 41
21322: PUSH
21323: LD_VAR 0 5
21327: ST_TO_ADDR
// end ;
21328: LD_VAR 0 6
21332: RET
// export function WantPlant ( unit ) ; var task ; begin
21333: LD_INT 0
21335: PPUSH
21336: PPUSH
// result := false ;
21337: LD_ADDR_VAR 0 2
21341: PUSH
21342: LD_INT 0
21344: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21345: LD_ADDR_VAR 0 3
21349: PUSH
21350: LD_VAR 0 1
21354: PPUSH
21355: CALL_OW 437
21359: ST_TO_ADDR
// if task then
21360: LD_VAR 0 3
21364: IFFALSE 21392
// if task [ 1 ] [ 1 ] = p then
21366: LD_VAR 0 3
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: PUSH
21375: LD_INT 1
21377: ARRAY
21378: PUSH
21379: LD_STRING p
21381: EQUAL
21382: IFFALSE 21392
// result := true ;
21384: LD_ADDR_VAR 0 2
21388: PUSH
21389: LD_INT 1
21391: ST_TO_ADDR
// end ;
21392: LD_VAR 0 2
21396: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21397: LD_INT 0
21399: PPUSH
21400: PPUSH
21401: PPUSH
21402: PPUSH
// if pos < 1 then
21403: LD_VAR 0 2
21407: PUSH
21408: LD_INT 1
21410: LESS
21411: IFFALSE 21415
// exit ;
21413: GO 21718
// if pos = 1 then
21415: LD_VAR 0 2
21419: PUSH
21420: LD_INT 1
21422: EQUAL
21423: IFFALSE 21456
// result := Replace ( arr , pos [ 1 ] , value ) else
21425: LD_ADDR_VAR 0 4
21429: PUSH
21430: LD_VAR 0 1
21434: PPUSH
21435: LD_VAR 0 2
21439: PUSH
21440: LD_INT 1
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 3
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
21454: GO 21718
// begin tmp := arr ;
21456: LD_ADDR_VAR 0 6
21460: PUSH
21461: LD_VAR 0 1
21465: ST_TO_ADDR
// s_arr := [ tmp ] ;
21466: LD_ADDR_VAR 0 7
21470: PUSH
21471: LD_VAR 0 6
21475: PUSH
21476: EMPTY
21477: LIST
21478: ST_TO_ADDR
// for i = 1 to pos - 1 do
21479: LD_ADDR_VAR 0 5
21483: PUSH
21484: DOUBLE
21485: LD_INT 1
21487: DEC
21488: ST_TO_ADDR
21489: LD_VAR 0 2
21493: PUSH
21494: LD_INT 1
21496: MINUS
21497: PUSH
21498: FOR_TO
21499: IFFALSE 21544
// begin tmp := tmp [ pos [ i ] ] ;
21501: LD_ADDR_VAR 0 6
21505: PUSH
21506: LD_VAR 0 6
21510: PUSH
21511: LD_VAR 0 2
21515: PUSH
21516: LD_VAR 0 5
21520: ARRAY
21521: ARRAY
21522: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21523: LD_ADDR_VAR 0 7
21527: PUSH
21528: LD_VAR 0 7
21532: PUSH
21533: LD_VAR 0 6
21537: PUSH
21538: EMPTY
21539: LIST
21540: ADD
21541: ST_TO_ADDR
// end ;
21542: GO 21498
21544: POP
21545: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 6
21555: PPUSH
21556: LD_VAR 0 2
21560: PUSH
21561: LD_VAR 0 2
21565: ARRAY
21566: PPUSH
21567: LD_VAR 0 3
21571: PPUSH
21572: CALL_OW 1
21576: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21577: LD_ADDR_VAR 0 7
21581: PUSH
21582: LD_VAR 0 7
21586: PPUSH
21587: LD_VAR 0 7
21591: PPUSH
21592: LD_VAR 0 6
21596: PPUSH
21597: CALL_OW 1
21601: ST_TO_ADDR
// for i = s_arr downto 2 do
21602: LD_ADDR_VAR 0 5
21606: PUSH
21607: DOUBLE
21608: LD_VAR 0 7
21612: INC
21613: ST_TO_ADDR
21614: LD_INT 2
21616: PUSH
21617: FOR_DOWNTO
21618: IFFALSE 21702
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21620: LD_ADDR_VAR 0 6
21624: PUSH
21625: LD_VAR 0 7
21629: PUSH
21630: LD_VAR 0 5
21634: PUSH
21635: LD_INT 1
21637: MINUS
21638: ARRAY
21639: PPUSH
21640: LD_VAR 0 2
21644: PUSH
21645: LD_VAR 0 5
21649: PUSH
21650: LD_INT 1
21652: MINUS
21653: ARRAY
21654: PPUSH
21655: LD_VAR 0 7
21659: PUSH
21660: LD_VAR 0 5
21664: ARRAY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21671: LD_ADDR_VAR 0 7
21675: PUSH
21676: LD_VAR 0 7
21680: PPUSH
21681: LD_VAR 0 5
21685: PUSH
21686: LD_INT 1
21688: MINUS
21689: PPUSH
21690: LD_VAR 0 6
21694: PPUSH
21695: CALL_OW 1
21699: ST_TO_ADDR
// end ;
21700: GO 21617
21702: POP
21703: POP
// result := s_arr [ 1 ] ;
21704: LD_ADDR_VAR 0 4
21708: PUSH
21709: LD_VAR 0 7
21713: PUSH
21714: LD_INT 1
21716: ARRAY
21717: ST_TO_ADDR
// end ; end ;
21718: LD_VAR 0 4
21722: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
// if not list then
21727: LD_VAR 0 1
21731: NOT
21732: IFFALSE 21736
// exit ;
21734: GO 21827
// i := list [ pos1 ] ;
21736: LD_ADDR_VAR 0 5
21740: PUSH
21741: LD_VAR 0 1
21745: PUSH
21746: LD_VAR 0 2
21750: ARRAY
21751: ST_TO_ADDR
// if not i then
21752: LD_VAR 0 5
21756: NOT
21757: IFFALSE 21761
// exit ;
21759: GO 21827
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21761: LD_ADDR_VAR 0 1
21765: PUSH
21766: LD_VAR 0 1
21770: PPUSH
21771: LD_VAR 0 2
21775: PPUSH
21776: LD_VAR 0 1
21780: PUSH
21781: LD_VAR 0 3
21785: ARRAY
21786: PPUSH
21787: CALL_OW 1
21791: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21792: LD_ADDR_VAR 0 1
21796: PUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: LD_VAR 0 3
21806: PPUSH
21807: LD_VAR 0 5
21811: PPUSH
21812: CALL_OW 1
21816: ST_TO_ADDR
// result := list ;
21817: LD_ADDR_VAR 0 4
21821: PUSH
21822: LD_VAR 0 1
21826: ST_TO_ADDR
// end ;
21827: LD_VAR 0 4
21831: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21832: LD_INT 0
21834: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21835: LD_ADDR_VAR 0 5
21839: PUSH
21840: LD_VAR 0 1
21844: PPUSH
21845: CALL_OW 250
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: CALL_OW 251
21859: PPUSH
21860: LD_VAR 0 2
21864: PPUSH
21865: LD_VAR 0 3
21869: PPUSH
21870: LD_VAR 0 4
21874: PPUSH
21875: CALL 22253 0 5
21879: ST_TO_ADDR
// end ;
21880: LD_VAR 0 5
21884: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21885: LD_INT 0
21887: PPUSH
21888: PPUSH
21889: PPUSH
21890: PPUSH
// if not list or not unit then
21891: LD_VAR 0 2
21895: NOT
21896: PUSH
21897: LD_VAR 0 1
21901: NOT
21902: OR
21903: IFFALSE 21907
// exit ;
21905: GO 22248
// result := [ ] ;
21907: LD_ADDR_VAR 0 5
21911: PUSH
21912: EMPTY
21913: ST_TO_ADDR
// for i in list do
21914: LD_ADDR_VAR 0 6
21918: PUSH
21919: LD_VAR 0 2
21923: PUSH
21924: FOR_IN
21925: IFFALSE 22143
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21927: LD_ADDR_VAR 0 8
21931: PUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: LD_VAR 0 6
21941: PUSH
21942: LD_INT 1
21944: ARRAY
21945: PPUSH
21946: LD_VAR 0 6
21950: PUSH
21951: LD_INT 2
21953: ARRAY
21954: PPUSH
21955: CALL_OW 297
21959: ST_TO_ADDR
// if not Count ( result ) then
21960: LD_VAR 0 5
21964: PPUSH
21965: CALL 18537 0 1
21969: NOT
21970: IFFALSE 22003
// begin result := Join ( result , [ i , tmp ] ) ;
21972: LD_ADDR_VAR 0 5
21976: PUSH
21977: LD_VAR 0 5
21981: PPUSH
21982: LD_VAR 0 6
21986: PUSH
21987: LD_VAR 0 8
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PPUSH
21996: CALL 54126 0 2
22000: ST_TO_ADDR
// continue ;
22001: GO 21924
// end ; if result [ result ] [ 2 ] <= tmp then
22003: LD_VAR 0 5
22007: PUSH
22008: LD_VAR 0 5
22012: ARRAY
22013: PUSH
22014: LD_INT 2
22016: ARRAY
22017: PUSH
22018: LD_VAR 0 8
22022: LESSEQUAL
22023: IFFALSE 22056
// result := Join ( result , [ i , tmp ] ) else
22025: LD_ADDR_VAR 0 5
22029: PUSH
22030: LD_VAR 0 5
22034: PPUSH
22035: LD_VAR 0 6
22039: PUSH
22040: LD_VAR 0 8
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PPUSH
22049: CALL 54126 0 2
22053: ST_TO_ADDR
22054: GO 22141
// begin for j := 1 to Count ( result ) do
22056: LD_ADDR_VAR 0 7
22060: PUSH
22061: DOUBLE
22062: LD_INT 1
22064: DEC
22065: ST_TO_ADDR
22066: LD_VAR 0 5
22070: PPUSH
22071: CALL 18537 0 1
22075: PUSH
22076: FOR_TO
22077: IFFALSE 22139
// begin if tmp < result [ j ] [ 2 ] then
22079: LD_VAR 0 8
22083: PUSH
22084: LD_VAR 0 5
22088: PUSH
22089: LD_VAR 0 7
22093: ARRAY
22094: PUSH
22095: LD_INT 2
22097: ARRAY
22098: LESS
22099: IFFALSE 22137
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22101: LD_ADDR_VAR 0 5
22105: PUSH
22106: LD_VAR 0 5
22110: PPUSH
22111: LD_VAR 0 7
22115: PPUSH
22116: LD_VAR 0 6
22120: PUSH
22121: LD_VAR 0 8
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PPUSH
22130: CALL_OW 2
22134: ST_TO_ADDR
// break ;
22135: GO 22139
// end ; end ;
22137: GO 22076
22139: POP
22140: POP
// end ; end ;
22141: GO 21924
22143: POP
22144: POP
// if result and not asc then
22145: LD_VAR 0 5
22149: PUSH
22150: LD_VAR 0 3
22154: NOT
22155: AND
22156: IFFALSE 22173
// result := ReverseArray ( result ) ;
22158: LD_ADDR_VAR 0 5
22162: PUSH
22163: LD_VAR 0 5
22167: PPUSH
22168: CALL 49413 0 1
22172: ST_TO_ADDR
// tmp := [ ] ;
22173: LD_ADDR_VAR 0 8
22177: PUSH
22178: EMPTY
22179: ST_TO_ADDR
// if mode then
22180: LD_VAR 0 4
22184: IFFALSE 22248
// begin for i := 1 to result do
22186: LD_ADDR_VAR 0 6
22190: PUSH
22191: DOUBLE
22192: LD_INT 1
22194: DEC
22195: ST_TO_ADDR
22196: LD_VAR 0 5
22200: PUSH
22201: FOR_TO
22202: IFFALSE 22236
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
22204: LD_ADDR_VAR 0 8
22208: PUSH
22209: LD_VAR 0 8
22213: PPUSH
22214: LD_VAR 0 5
22218: PUSH
22219: LD_VAR 0 6
22223: ARRAY
22224: PUSH
22225: LD_INT 1
22227: ARRAY
22228: PPUSH
22229: CALL 54126 0 2
22233: ST_TO_ADDR
22234: GO 22201
22236: POP
22237: POP
// result := tmp ;
22238: LD_ADDR_VAR 0 5
22242: PUSH
22243: LD_VAR 0 8
22247: ST_TO_ADDR
// end ; end ;
22248: LD_VAR 0 5
22252: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22253: LD_INT 0
22255: PPUSH
22256: PPUSH
22257: PPUSH
22258: PPUSH
// if not list then
22259: LD_VAR 0 3
22263: NOT
22264: IFFALSE 22268
// exit ;
22266: GO 22656
// result := [ ] ;
22268: LD_ADDR_VAR 0 6
22272: PUSH
22273: EMPTY
22274: ST_TO_ADDR
// for i in list do
22275: LD_ADDR_VAR 0 7
22279: PUSH
22280: LD_VAR 0 3
22284: PUSH
22285: FOR_IN
22286: IFFALSE 22488
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22288: LD_ADDR_VAR 0 9
22292: PUSH
22293: LD_VAR 0 7
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_VAR 0 2
22307: PPUSH
22308: CALL_OW 297
22312: ST_TO_ADDR
// if not result then
22313: LD_VAR 0 6
22317: NOT
22318: IFFALSE 22344
// result := [ [ i , tmp ] ] else
22320: LD_ADDR_VAR 0 6
22324: PUSH
22325: LD_VAR 0 7
22329: PUSH
22330: LD_VAR 0 9
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PUSH
22339: EMPTY
22340: LIST
22341: ST_TO_ADDR
22342: GO 22486
// begin if result [ result ] [ 2 ] < tmp then
22344: LD_VAR 0 6
22348: PUSH
22349: LD_VAR 0 6
22353: ARRAY
22354: PUSH
22355: LD_INT 2
22357: ARRAY
22358: PUSH
22359: LD_VAR 0 9
22363: LESS
22364: IFFALSE 22406
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22366: LD_ADDR_VAR 0 6
22370: PUSH
22371: LD_VAR 0 6
22375: PPUSH
22376: LD_VAR 0 6
22380: PUSH
22381: LD_INT 1
22383: PLUS
22384: PPUSH
22385: LD_VAR 0 7
22389: PUSH
22390: LD_VAR 0 9
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PPUSH
22399: CALL_OW 2
22403: ST_TO_ADDR
22404: GO 22486
// for j = 1 to result do
22406: LD_ADDR_VAR 0 8
22410: PUSH
22411: DOUBLE
22412: LD_INT 1
22414: DEC
22415: ST_TO_ADDR
22416: LD_VAR 0 6
22420: PUSH
22421: FOR_TO
22422: IFFALSE 22484
// begin if tmp < result [ j ] [ 2 ] then
22424: LD_VAR 0 9
22428: PUSH
22429: LD_VAR 0 6
22433: PUSH
22434: LD_VAR 0 8
22438: ARRAY
22439: PUSH
22440: LD_INT 2
22442: ARRAY
22443: LESS
22444: IFFALSE 22482
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22446: LD_ADDR_VAR 0 6
22450: PUSH
22451: LD_VAR 0 6
22455: PPUSH
22456: LD_VAR 0 8
22460: PPUSH
22461: LD_VAR 0 7
22465: PUSH
22466: LD_VAR 0 9
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 2
22479: ST_TO_ADDR
// break ;
22480: GO 22484
// end ; end ;
22482: GO 22421
22484: POP
22485: POP
// end ; end ;
22486: GO 22285
22488: POP
22489: POP
// if result and not asc then
22490: LD_VAR 0 6
22494: PUSH
22495: LD_VAR 0 4
22499: NOT
22500: AND
22501: IFFALSE 22576
// begin tmp := result ;
22503: LD_ADDR_VAR 0 9
22507: PUSH
22508: LD_VAR 0 6
22512: ST_TO_ADDR
// for i = tmp downto 1 do
22513: LD_ADDR_VAR 0 7
22517: PUSH
22518: DOUBLE
22519: LD_VAR 0 9
22523: INC
22524: ST_TO_ADDR
22525: LD_INT 1
22527: PUSH
22528: FOR_DOWNTO
22529: IFFALSE 22574
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22531: LD_ADDR_VAR 0 6
22535: PUSH
22536: LD_VAR 0 6
22540: PPUSH
22541: LD_VAR 0 9
22545: PUSH
22546: LD_VAR 0 7
22550: MINUS
22551: PUSH
22552: LD_INT 1
22554: PLUS
22555: PPUSH
22556: LD_VAR 0 9
22560: PUSH
22561: LD_VAR 0 7
22565: ARRAY
22566: PPUSH
22567: CALL_OW 1
22571: ST_TO_ADDR
22572: GO 22528
22574: POP
22575: POP
// end ; tmp := [ ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: EMPTY
22582: ST_TO_ADDR
// if mode then
22583: LD_VAR 0 5
22587: IFFALSE 22656
// begin for i = 1 to result do
22589: LD_ADDR_VAR 0 7
22593: PUSH
22594: DOUBLE
22595: LD_INT 1
22597: DEC
22598: ST_TO_ADDR
22599: LD_VAR 0 6
22603: PUSH
22604: FOR_TO
22605: IFFALSE 22644
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22607: LD_ADDR_VAR 0 9
22611: PUSH
22612: LD_VAR 0 9
22616: PPUSH
22617: LD_VAR 0 7
22621: PPUSH
22622: LD_VAR 0 6
22626: PUSH
22627: LD_VAR 0 7
22631: ARRAY
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
22642: GO 22604
22644: POP
22645: POP
// result := tmp ;
22646: LD_ADDR_VAR 0 6
22650: PUSH
22651: LD_VAR 0 9
22655: ST_TO_ADDR
// end ; end ;
22656: LD_VAR 0 6
22660: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22669: LD_ADDR_VAR 0 5
22673: PUSH
22674: LD_INT 0
22676: PUSH
22677: LD_INT 0
22679: PUSH
22680: LD_INT 0
22682: PUSH
22683: EMPTY
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: ST_TO_ADDR
// if not x or not y then
22691: LD_VAR 0 2
22695: NOT
22696: PUSH
22697: LD_VAR 0 3
22701: NOT
22702: OR
22703: IFFALSE 22707
// exit ;
22705: GO 24357
// if not range then
22707: LD_VAR 0 4
22711: NOT
22712: IFFALSE 22722
// range := 10 ;
22714: LD_ADDR_VAR 0 4
22718: PUSH
22719: LD_INT 10
22721: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22722: LD_ADDR_VAR 0 8
22726: PUSH
22727: LD_INT 81
22729: PUSH
22730: LD_VAR 0 1
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 92
22741: PUSH
22742: LD_VAR 0 2
22746: PUSH
22747: LD_VAR 0 3
22751: PUSH
22752: LD_VAR 0 4
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: LIST
22762: PUSH
22763: LD_INT 3
22765: PUSH
22766: LD_INT 21
22768: PUSH
22769: LD_INT 3
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: LIST
22784: PPUSH
22785: CALL_OW 69
22789: ST_TO_ADDR
// if not tmp then
22790: LD_VAR 0 8
22794: NOT
22795: IFFALSE 22799
// exit ;
22797: GO 24357
// for i in tmp do
22799: LD_ADDR_VAR 0 6
22803: PUSH
22804: LD_VAR 0 8
22808: PUSH
22809: FOR_IN
22810: IFFALSE 24332
// begin points := [ 0 , 0 , 0 ] ;
22812: LD_ADDR_VAR 0 9
22816: PUSH
22817: LD_INT 0
22819: PUSH
22820: LD_INT 0
22822: PUSH
22823: LD_INT 0
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
// bpoints := 1 ;
22831: LD_ADDR_VAR 0 10
22835: PUSH
22836: LD_INT 1
22838: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22839: LD_VAR 0 6
22843: PPUSH
22844: CALL_OW 247
22848: PUSH
22849: LD_INT 1
22851: DOUBLE
22852: EQUAL
22853: IFTRUE 22857
22855: GO 23435
22857: POP
// begin if GetClass ( i ) = 1 then
22858: LD_VAR 0 6
22862: PPUSH
22863: CALL_OW 257
22867: PUSH
22868: LD_INT 1
22870: EQUAL
22871: IFFALSE 22892
// points := [ 10 , 5 , 3 ] ;
22873: LD_ADDR_VAR 0 9
22877: PUSH
22878: LD_INT 10
22880: PUSH
22881: LD_INT 5
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22892: LD_VAR 0 6
22896: PPUSH
22897: CALL_OW 257
22901: PUSH
22902: LD_INT 2
22904: PUSH
22905: LD_INT 3
22907: PUSH
22908: LD_INT 4
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: LIST
22915: IN
22916: IFFALSE 22937
// points := [ 3 , 2 , 1 ] ;
22918: LD_ADDR_VAR 0 9
22922: PUSH
22923: LD_INT 3
22925: PUSH
22926: LD_INT 2
22928: PUSH
22929: LD_INT 1
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22937: LD_VAR 0 6
22941: PPUSH
22942: CALL_OW 257
22946: PUSH
22947: LD_INT 5
22949: EQUAL
22950: IFFALSE 22971
// points := [ 130 , 5 , 2 ] ;
22952: LD_ADDR_VAR 0 9
22956: PUSH
22957: LD_INT 130
22959: PUSH
22960: LD_INT 5
22962: PUSH
22963: LD_INT 2
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: LIST
22970: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 257
22980: PUSH
22981: LD_INT 8
22983: EQUAL
22984: IFFALSE 23005
// points := [ 35 , 35 , 30 ] ;
22986: LD_ADDR_VAR 0 9
22990: PUSH
22991: LD_INT 35
22993: PUSH
22994: LD_INT 35
22996: PUSH
22997: LD_INT 30
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23005: LD_VAR 0 6
23009: PPUSH
23010: CALL_OW 257
23014: PUSH
23015: LD_INT 9
23017: EQUAL
23018: IFFALSE 23039
// points := [ 20 , 55 , 40 ] ;
23020: LD_ADDR_VAR 0 9
23024: PUSH
23025: LD_INT 20
23027: PUSH
23028: LD_INT 55
23030: PUSH
23031: LD_INT 40
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23039: LD_VAR 0 6
23043: PPUSH
23044: CALL_OW 257
23048: PUSH
23049: LD_INT 12
23051: PUSH
23052: LD_INT 16
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: IN
23059: IFFALSE 23080
// points := [ 5 , 3 , 2 ] ;
23061: LD_ADDR_VAR 0 9
23065: PUSH
23066: LD_INT 5
23068: PUSH
23069: LD_INT 3
23071: PUSH
23072: LD_INT 2
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: LIST
23079: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23080: LD_VAR 0 6
23084: PPUSH
23085: CALL_OW 257
23089: PUSH
23090: LD_INT 17
23092: EQUAL
23093: IFFALSE 23114
// points := [ 100 , 50 , 75 ] ;
23095: LD_ADDR_VAR 0 9
23099: PUSH
23100: LD_INT 100
23102: PUSH
23103: LD_INT 50
23105: PUSH
23106: LD_INT 75
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23114: LD_VAR 0 6
23118: PPUSH
23119: CALL_OW 257
23123: PUSH
23124: LD_INT 15
23126: EQUAL
23127: IFFALSE 23148
// points := [ 10 , 5 , 3 ] ;
23129: LD_ADDR_VAR 0 9
23133: PUSH
23134: LD_INT 10
23136: PUSH
23137: LD_INT 5
23139: PUSH
23140: LD_INT 3
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: LIST
23147: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23148: LD_VAR 0 6
23152: PPUSH
23153: CALL_OW 257
23157: PUSH
23158: LD_INT 14
23160: EQUAL
23161: IFFALSE 23182
// points := [ 10 , 0 , 0 ] ;
23163: LD_ADDR_VAR 0 9
23167: PUSH
23168: LD_INT 10
23170: PUSH
23171: LD_INT 0
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: LIST
23181: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23182: LD_VAR 0 6
23186: PPUSH
23187: CALL_OW 257
23191: PUSH
23192: LD_INT 11
23194: EQUAL
23195: IFFALSE 23216
// points := [ 30 , 10 , 5 ] ;
23197: LD_ADDR_VAR 0 9
23201: PUSH
23202: LD_INT 30
23204: PUSH
23205: LD_INT 10
23207: PUSH
23208: LD_INT 5
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23216: LD_VAR 0 1
23220: PPUSH
23221: LD_INT 5
23223: PPUSH
23224: CALL_OW 321
23228: PUSH
23229: LD_INT 2
23231: EQUAL
23232: IFFALSE 23249
// bpoints := bpoints * 1.8 ;
23234: LD_ADDR_VAR 0 10
23238: PUSH
23239: LD_VAR 0 10
23243: PUSH
23244: LD_REAL  1.80000000000000E+0000
23247: MUL
23248: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23249: LD_VAR 0 6
23253: PPUSH
23254: CALL_OW 257
23258: PUSH
23259: LD_INT 1
23261: PUSH
23262: LD_INT 2
23264: PUSH
23265: LD_INT 3
23267: PUSH
23268: LD_INT 4
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: PUSH
23278: LD_VAR 0 1
23282: PPUSH
23283: LD_INT 51
23285: PPUSH
23286: CALL_OW 321
23290: PUSH
23291: LD_INT 2
23293: EQUAL
23294: AND
23295: IFFALSE 23312
// bpoints := bpoints * 1.2 ;
23297: LD_ADDR_VAR 0 10
23301: PUSH
23302: LD_VAR 0 10
23306: PUSH
23307: LD_REAL  1.20000000000000E+0000
23310: MUL
23311: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23312: LD_VAR 0 6
23316: PPUSH
23317: CALL_OW 257
23321: PUSH
23322: LD_INT 5
23324: PUSH
23325: LD_INT 7
23327: PUSH
23328: LD_INT 9
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: IN
23336: PUSH
23337: LD_VAR 0 1
23341: PPUSH
23342: LD_INT 52
23344: PPUSH
23345: CALL_OW 321
23349: PUSH
23350: LD_INT 2
23352: EQUAL
23353: AND
23354: IFFALSE 23371
// bpoints := bpoints * 1.5 ;
23356: LD_ADDR_VAR 0 10
23360: PUSH
23361: LD_VAR 0 10
23365: PUSH
23366: LD_REAL  1.50000000000000E+0000
23369: MUL
23370: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23371: LD_VAR 0 1
23375: PPUSH
23376: LD_INT 66
23378: PPUSH
23379: CALL_OW 321
23383: PUSH
23384: LD_INT 2
23386: EQUAL
23387: IFFALSE 23404
// bpoints := bpoints * 1.1 ;
23389: LD_ADDR_VAR 0 10
23393: PUSH
23394: LD_VAR 0 10
23398: PUSH
23399: LD_REAL  1.10000000000000E+0000
23402: MUL
23403: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23404: LD_ADDR_VAR 0 10
23408: PUSH
23409: LD_VAR 0 10
23413: PUSH
23414: LD_VAR 0 6
23418: PPUSH
23419: LD_INT 1
23421: PPUSH
23422: CALL_OW 259
23426: PUSH
23427: LD_REAL  1.15000000000000E+0000
23430: MUL
23431: MUL
23432: ST_TO_ADDR
// end ; unit_vehicle :
23433: GO 24261
23435: LD_INT 2
23437: DOUBLE
23438: EQUAL
23439: IFTRUE 23443
23441: GO 24249
23443: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23444: LD_VAR 0 6
23448: PPUSH
23449: CALL_OW 264
23453: PUSH
23454: LD_INT 2
23456: PUSH
23457: LD_INT 42
23459: PUSH
23460: LD_INT 24
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: LIST
23467: IN
23468: IFFALSE 23489
// points := [ 25 , 5 , 3 ] ;
23470: LD_ADDR_VAR 0 9
23474: PUSH
23475: LD_INT 25
23477: PUSH
23478: LD_INT 5
23480: PUSH
23481: LD_INT 3
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23489: LD_VAR 0 6
23493: PPUSH
23494: CALL_OW 264
23498: PUSH
23499: LD_INT 4
23501: PUSH
23502: LD_INT 43
23504: PUSH
23505: LD_INT 25
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: LIST
23512: IN
23513: IFFALSE 23534
// points := [ 40 , 15 , 5 ] ;
23515: LD_ADDR_VAR 0 9
23519: PUSH
23520: LD_INT 40
23522: PUSH
23523: LD_INT 15
23525: PUSH
23526: LD_INT 5
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: LIST
23533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23534: LD_VAR 0 6
23538: PPUSH
23539: CALL_OW 264
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 23
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: IN
23554: IFFALSE 23575
// points := [ 7 , 25 , 8 ] ;
23556: LD_ADDR_VAR 0 9
23560: PUSH
23561: LD_INT 7
23563: PUSH
23564: LD_INT 25
23566: PUSH
23567: LD_INT 8
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23575: LD_VAR 0 6
23579: PPUSH
23580: CALL_OW 264
23584: PUSH
23585: LD_INT 5
23587: PUSH
23588: LD_INT 27
23590: PUSH
23591: LD_INT 44
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: LIST
23598: IN
23599: IFFALSE 23620
// points := [ 14 , 50 , 16 ] ;
23601: LD_ADDR_VAR 0 9
23605: PUSH
23606: LD_INT 14
23608: PUSH
23609: LD_INT 50
23611: PUSH
23612: LD_INT 16
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23620: LD_VAR 0 6
23624: PPUSH
23625: CALL_OW 264
23629: PUSH
23630: LD_INT 6
23632: PUSH
23633: LD_INT 46
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: IN
23640: IFFALSE 23661
// points := [ 32 , 120 , 70 ] ;
23642: LD_ADDR_VAR 0 9
23646: PUSH
23647: LD_INT 32
23649: PUSH
23650: LD_INT 120
23652: PUSH
23653: LD_INT 70
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23661: LD_VAR 0 6
23665: PPUSH
23666: CALL_OW 264
23670: PUSH
23671: LD_INT 7
23673: PUSH
23674: LD_INT 28
23676: PUSH
23677: LD_INT 45
23679: PUSH
23680: LD_INT 92
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: IN
23689: IFFALSE 23710
// points := [ 35 , 20 , 45 ] ;
23691: LD_ADDR_VAR 0 9
23695: PUSH
23696: LD_INT 35
23698: PUSH
23699: LD_INT 20
23701: PUSH
23702: LD_INT 45
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23710: LD_VAR 0 6
23714: PPUSH
23715: CALL_OW 264
23719: PUSH
23720: LD_INT 47
23722: PUSH
23723: EMPTY
23724: LIST
23725: IN
23726: IFFALSE 23747
// points := [ 67 , 45 , 75 ] ;
23728: LD_ADDR_VAR 0 9
23732: PUSH
23733: LD_INT 67
23735: PUSH
23736: LD_INT 45
23738: PUSH
23739: LD_INT 75
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: LIST
23746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23747: LD_VAR 0 6
23751: PPUSH
23752: CALL_OW 264
23756: PUSH
23757: LD_INT 26
23759: PUSH
23760: EMPTY
23761: LIST
23762: IN
23763: IFFALSE 23784
// points := [ 120 , 30 , 80 ] ;
23765: LD_ADDR_VAR 0 9
23769: PUSH
23770: LD_INT 120
23772: PUSH
23773: LD_INT 30
23775: PUSH
23776: LD_INT 80
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23784: LD_VAR 0 6
23788: PPUSH
23789: CALL_OW 264
23793: PUSH
23794: LD_INT 22
23796: PUSH
23797: EMPTY
23798: LIST
23799: IN
23800: IFFALSE 23821
// points := [ 40 , 1 , 1 ] ;
23802: LD_ADDR_VAR 0 9
23806: PUSH
23807: LD_INT 40
23809: PUSH
23810: LD_INT 1
23812: PUSH
23813: LD_INT 1
23815: PUSH
23816: EMPTY
23817: LIST
23818: LIST
23819: LIST
23820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23821: LD_VAR 0 6
23825: PPUSH
23826: CALL_OW 264
23830: PUSH
23831: LD_INT 29
23833: PUSH
23834: EMPTY
23835: LIST
23836: IN
23837: IFFALSE 23858
// points := [ 70 , 200 , 400 ] ;
23839: LD_ADDR_VAR 0 9
23843: PUSH
23844: LD_INT 70
23846: PUSH
23847: LD_INT 200
23849: PUSH
23850: LD_INT 400
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: LIST
23857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23858: LD_VAR 0 6
23862: PPUSH
23863: CALL_OW 264
23867: PUSH
23868: LD_INT 14
23870: PUSH
23871: LD_INT 53
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: IN
23878: IFFALSE 23899
// points := [ 40 , 10 , 20 ] ;
23880: LD_ADDR_VAR 0 9
23884: PUSH
23885: LD_INT 40
23887: PUSH
23888: LD_INT 10
23890: PUSH
23891: LD_INT 20
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: LIST
23898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23899: LD_VAR 0 6
23903: PPUSH
23904: CALL_OW 264
23908: PUSH
23909: LD_INT 9
23911: PUSH
23912: EMPTY
23913: LIST
23914: IN
23915: IFFALSE 23936
// points := [ 5 , 70 , 20 ] ;
23917: LD_ADDR_VAR 0 9
23921: PUSH
23922: LD_INT 5
23924: PUSH
23925: LD_INT 70
23927: PUSH
23928: LD_INT 20
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23936: LD_VAR 0 6
23940: PPUSH
23941: CALL_OW 264
23945: PUSH
23946: LD_INT 10
23948: PUSH
23949: EMPTY
23950: LIST
23951: IN
23952: IFFALSE 23973
// points := [ 35 , 110 , 70 ] ;
23954: LD_ADDR_VAR 0 9
23958: PUSH
23959: LD_INT 35
23961: PUSH
23962: LD_INT 110
23964: PUSH
23965: LD_INT 70
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23973: LD_VAR 0 6
23977: PPUSH
23978: CALL_OW 265
23982: PUSH
23983: LD_INT 25
23985: EQUAL
23986: IFFALSE 24007
// points := [ 80 , 65 , 100 ] ;
23988: LD_ADDR_VAR 0 9
23992: PUSH
23993: LD_INT 80
23995: PUSH
23996: LD_INT 65
23998: PUSH
23999: LD_INT 100
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: LIST
24006: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24007: LD_VAR 0 6
24011: PPUSH
24012: CALL_OW 263
24016: PUSH
24017: LD_INT 1
24019: EQUAL
24020: IFFALSE 24055
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24022: LD_ADDR_VAR 0 10
24026: PUSH
24027: LD_VAR 0 10
24031: PUSH
24032: LD_VAR 0 6
24036: PPUSH
24037: CALL_OW 311
24041: PPUSH
24042: LD_INT 3
24044: PPUSH
24045: CALL_OW 259
24049: PUSH
24050: LD_INT 4
24052: MUL
24053: MUL
24054: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24055: LD_VAR 0 6
24059: PPUSH
24060: CALL_OW 263
24064: PUSH
24065: LD_INT 2
24067: EQUAL
24068: IFFALSE 24119
// begin j := IsControledBy ( i ) ;
24070: LD_ADDR_VAR 0 7
24074: PUSH
24075: LD_VAR 0 6
24079: PPUSH
24080: CALL_OW 312
24084: ST_TO_ADDR
// if j then
24085: LD_VAR 0 7
24089: IFFALSE 24119
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24091: LD_ADDR_VAR 0 10
24095: PUSH
24096: LD_VAR 0 10
24100: PUSH
24101: LD_VAR 0 7
24105: PPUSH
24106: LD_INT 3
24108: PPUSH
24109: CALL_OW 259
24113: PUSH
24114: LD_INT 3
24116: MUL
24117: MUL
24118: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24119: LD_VAR 0 6
24123: PPUSH
24124: CALL_OW 264
24128: PUSH
24129: LD_INT 5
24131: PUSH
24132: LD_INT 6
24134: PUSH
24135: LD_INT 46
24137: PUSH
24138: LD_INT 44
24140: PUSH
24141: LD_INT 47
24143: PUSH
24144: LD_INT 45
24146: PUSH
24147: LD_INT 28
24149: PUSH
24150: LD_INT 7
24152: PUSH
24153: LD_INT 27
24155: PUSH
24156: LD_INT 29
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: IN
24171: PUSH
24172: LD_VAR 0 1
24176: PPUSH
24177: LD_INT 52
24179: PPUSH
24180: CALL_OW 321
24184: PUSH
24185: LD_INT 2
24187: EQUAL
24188: AND
24189: IFFALSE 24206
// bpoints := bpoints * 1.2 ;
24191: LD_ADDR_VAR 0 10
24195: PUSH
24196: LD_VAR 0 10
24200: PUSH
24201: LD_REAL  1.20000000000000E+0000
24204: MUL
24205: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24206: LD_VAR 0 6
24210: PPUSH
24211: CALL_OW 264
24215: PUSH
24216: LD_INT 6
24218: PUSH
24219: LD_INT 46
24221: PUSH
24222: LD_INT 47
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: LIST
24229: IN
24230: IFFALSE 24247
// bpoints := bpoints * 1.2 ;
24232: LD_ADDR_VAR 0 10
24236: PUSH
24237: LD_VAR 0 10
24241: PUSH
24242: LD_REAL  1.20000000000000E+0000
24245: MUL
24246: ST_TO_ADDR
// end ; unit_building :
24247: GO 24261
24249: LD_INT 3
24251: DOUBLE
24252: EQUAL
24253: IFTRUE 24257
24255: GO 24260
24257: POP
// ; end ;
24258: GO 24261
24260: POP
// for j = 1 to 3 do
24261: LD_ADDR_VAR 0 7
24265: PUSH
24266: DOUBLE
24267: LD_INT 1
24269: DEC
24270: ST_TO_ADDR
24271: LD_INT 3
24273: PUSH
24274: FOR_TO
24275: IFFALSE 24328
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 7
24291: PPUSH
24292: LD_VAR 0 5
24296: PUSH
24297: LD_VAR 0 7
24301: ARRAY
24302: PUSH
24303: LD_VAR 0 9
24307: PUSH
24308: LD_VAR 0 7
24312: ARRAY
24313: PUSH
24314: LD_VAR 0 10
24318: MUL
24319: PLUS
24320: PPUSH
24321: CALL_OW 1
24325: ST_TO_ADDR
24326: GO 24274
24328: POP
24329: POP
// end ;
24330: GO 22809
24332: POP
24333: POP
// result := Replace ( result , 4 , tmp ) ;
24334: LD_ADDR_VAR 0 5
24338: PUSH
24339: LD_VAR 0 5
24343: PPUSH
24344: LD_INT 4
24346: PPUSH
24347: LD_VAR 0 8
24351: PPUSH
24352: CALL_OW 1
24356: ST_TO_ADDR
// end ;
24357: LD_VAR 0 5
24361: RET
// export function DangerAtRange ( unit , range ) ; begin
24362: LD_INT 0
24364: PPUSH
// if not unit then
24365: LD_VAR 0 1
24369: NOT
24370: IFFALSE 24374
// exit ;
24372: GO 24419
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_VAR 0 1
24383: PPUSH
24384: CALL_OW 255
24388: PPUSH
24389: LD_VAR 0 1
24393: PPUSH
24394: CALL_OW 250
24398: PPUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 251
24408: PPUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: CALL 22661 0 4
24418: ST_TO_ADDR
// end ;
24419: LD_VAR 0 3
24423: RET
// export function DangerInArea ( side , area ) ; begin
24424: LD_INT 0
24426: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24427: LD_ADDR_VAR 0 3
24431: PUSH
24432: LD_VAR 0 2
24436: PPUSH
24437: LD_INT 81
24439: PUSH
24440: LD_VAR 0 1
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PPUSH
24449: CALL_OW 70
24453: ST_TO_ADDR
// end ;
24454: LD_VAR 0 3
24458: RET
// export function IsExtension ( b ) ; begin
24459: LD_INT 0
24461: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24462: LD_ADDR_VAR 0 2
24466: PUSH
24467: LD_VAR 0 1
24471: PUSH
24472: LD_INT 23
24474: PUSH
24475: LD_INT 20
24477: PUSH
24478: LD_INT 22
24480: PUSH
24481: LD_INT 17
24483: PUSH
24484: LD_INT 24
24486: PUSH
24487: LD_INT 21
24489: PUSH
24490: LD_INT 19
24492: PUSH
24493: LD_INT 16
24495: PUSH
24496: LD_INT 25
24498: PUSH
24499: LD_INT 18
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: IN
24514: ST_TO_ADDR
// end ;
24515: LD_VAR 0 2
24519: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24520: LD_INT 0
24522: PPUSH
24523: PPUSH
24524: PPUSH
// result := [ ] ;
24525: LD_ADDR_VAR 0 4
24529: PUSH
24530: EMPTY
24531: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24532: LD_ADDR_VAR 0 5
24536: PUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: LD_INT 21
24544: PUSH
24545: LD_INT 3
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PPUSH
24552: CALL_OW 70
24556: ST_TO_ADDR
// if not tmp then
24557: LD_VAR 0 5
24561: NOT
24562: IFFALSE 24566
// exit ;
24564: GO 24630
// if checkLink then
24566: LD_VAR 0 3
24570: IFFALSE 24620
// begin for i in tmp do
24572: LD_ADDR_VAR 0 6
24576: PUSH
24577: LD_VAR 0 5
24581: PUSH
24582: FOR_IN
24583: IFFALSE 24618
// if GetBase ( i ) <> base then
24585: LD_VAR 0 6
24589: PPUSH
24590: CALL_OW 274
24594: PUSH
24595: LD_VAR 0 1
24599: NONEQUAL
24600: IFFALSE 24616
// ComLinkToBase ( base , i ) ;
24602: LD_VAR 0 1
24606: PPUSH
24607: LD_VAR 0 6
24611: PPUSH
24612: CALL_OW 169
24616: GO 24582
24618: POP
24619: POP
// end ; result := tmp ;
24620: LD_ADDR_VAR 0 4
24624: PUSH
24625: LD_VAR 0 5
24629: ST_TO_ADDR
// end ;
24630: LD_VAR 0 4
24634: RET
// export function ComComplete ( units , b ) ; var i ; begin
24635: LD_INT 0
24637: PPUSH
24638: PPUSH
// if not units then
24639: LD_VAR 0 1
24643: NOT
24644: IFFALSE 24648
// exit ;
24646: GO 24738
// for i in units do
24648: LD_ADDR_VAR 0 4
24652: PUSH
24653: LD_VAR 0 1
24657: PUSH
24658: FOR_IN
24659: IFFALSE 24736
// if BuildingStatus ( b ) = bs_build then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 461
24670: PUSH
24671: LD_INT 1
24673: EQUAL
24674: IFFALSE 24734
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24676: LD_VAR 0 4
24680: PPUSH
24681: LD_STRING h
24683: PUSH
24684: LD_VAR 0 2
24688: PPUSH
24689: CALL_OW 250
24693: PUSH
24694: LD_VAR 0 2
24698: PPUSH
24699: CALL_OW 251
24703: PUSH
24704: LD_VAR 0 2
24708: PUSH
24709: LD_INT 0
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 0
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: LIST
24723: LIST
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: PPUSH
24730: CALL_OW 446
24734: GO 24658
24736: POP
24737: POP
// end ;
24738: LD_VAR 0 3
24742: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24743: LD_INT 0
24745: PPUSH
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24751: LD_VAR 0 1
24755: NOT
24756: PUSH
24757: LD_VAR 0 1
24761: PPUSH
24762: CALL_OW 263
24766: PUSH
24767: LD_INT 2
24769: NONEQUAL
24770: OR
24771: IFFALSE 24775
// exit ;
24773: GO 25091
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24775: LD_ADDR_VAR 0 6
24779: PUSH
24780: LD_INT 22
24782: PUSH
24783: LD_VAR 0 1
24787: PPUSH
24788: CALL_OW 255
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 2
24799: PUSH
24800: LD_INT 30
24802: PUSH
24803: LD_INT 36
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 34
24812: PUSH
24813: LD_INT 31
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PPUSH
24829: CALL_OW 69
24833: ST_TO_ADDR
// if not tmp then
24834: LD_VAR 0 6
24838: NOT
24839: IFFALSE 24843
// exit ;
24841: GO 25091
// result := [ ] ;
24843: LD_ADDR_VAR 0 2
24847: PUSH
24848: EMPTY
24849: ST_TO_ADDR
// for i in tmp do
24850: LD_ADDR_VAR 0 3
24854: PUSH
24855: LD_VAR 0 6
24859: PUSH
24860: FOR_IN
24861: IFFALSE 24932
// begin t := UnitsInside ( i ) ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 3
24872: PPUSH
24873: CALL_OW 313
24877: ST_TO_ADDR
// if t then
24878: LD_VAR 0 4
24882: IFFALSE 24930
// for j in t do
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: LD_VAR 0 4
24893: PUSH
24894: FOR_IN
24895: IFFALSE 24928
// result := Replace ( result , result + 1 , j ) ;
24897: LD_ADDR_VAR 0 2
24901: PUSH
24902: LD_VAR 0 2
24906: PPUSH
24907: LD_VAR 0 2
24911: PUSH
24912: LD_INT 1
24914: PLUS
24915: PPUSH
24916: LD_VAR 0 7
24920: PPUSH
24921: CALL_OW 1
24925: ST_TO_ADDR
24926: GO 24894
24928: POP
24929: POP
// end ;
24930: GO 24860
24932: POP
24933: POP
// if not result then
24934: LD_VAR 0 2
24938: NOT
24939: IFFALSE 24943
// exit ;
24941: GO 25091
// mech := result [ 1 ] ;
24943: LD_ADDR_VAR 0 5
24947: PUSH
24948: LD_VAR 0 2
24952: PUSH
24953: LD_INT 1
24955: ARRAY
24956: ST_TO_ADDR
// if result > 1 then
24957: LD_VAR 0 2
24961: PUSH
24962: LD_INT 1
24964: GREATER
24965: IFFALSE 25077
// begin for i = 2 to result do
24967: LD_ADDR_VAR 0 3
24971: PUSH
24972: DOUBLE
24973: LD_INT 2
24975: DEC
24976: ST_TO_ADDR
24977: LD_VAR 0 2
24981: PUSH
24982: FOR_TO
24983: IFFALSE 25075
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24985: LD_ADDR_VAR 0 4
24989: PUSH
24990: LD_VAR 0 2
24994: PUSH
24995: LD_VAR 0 3
24999: ARRAY
25000: PPUSH
25001: LD_INT 3
25003: PPUSH
25004: CALL_OW 259
25008: PUSH
25009: LD_VAR 0 2
25013: PUSH
25014: LD_VAR 0 3
25018: ARRAY
25019: PPUSH
25020: CALL_OW 432
25024: MINUS
25025: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25026: LD_VAR 0 4
25030: PUSH
25031: LD_VAR 0 5
25035: PPUSH
25036: LD_INT 3
25038: PPUSH
25039: CALL_OW 259
25043: PUSH
25044: LD_VAR 0 5
25048: PPUSH
25049: CALL_OW 432
25053: MINUS
25054: GREATEREQUAL
25055: IFFALSE 25073
// mech := result [ i ] ;
25057: LD_ADDR_VAR 0 5
25061: PUSH
25062: LD_VAR 0 2
25066: PUSH
25067: LD_VAR 0 3
25071: ARRAY
25072: ST_TO_ADDR
// end ;
25073: GO 24982
25075: POP
25076: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25077: LD_VAR 0 1
25081: PPUSH
25082: LD_VAR 0 5
25086: PPUSH
25087: CALL_OW 135
// end ;
25091: LD_VAR 0 2
25095: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25096: LD_INT 0
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
// result := [ ] ;
25111: LD_ADDR_VAR 0 7
25115: PUSH
25116: EMPTY
25117: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25118: LD_VAR 0 1
25122: PPUSH
25123: CALL_OW 266
25127: PUSH
25128: LD_INT 0
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: IN
25138: NOT
25139: IFFALSE 25143
// exit ;
25141: GO 26777
// if name then
25143: LD_VAR 0 3
25147: IFFALSE 25163
// SetBName ( base_dep , name ) ;
25149: LD_VAR 0 1
25153: PPUSH
25154: LD_VAR 0 3
25158: PPUSH
25159: CALL_OW 500
// base := GetBase ( base_dep ) ;
25163: LD_ADDR_VAR 0 15
25167: PUSH
25168: LD_VAR 0 1
25172: PPUSH
25173: CALL_OW 274
25177: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25178: LD_ADDR_VAR 0 16
25182: PUSH
25183: LD_VAR 0 1
25187: PPUSH
25188: CALL_OW 255
25192: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25193: LD_ADDR_VAR 0 17
25197: PUSH
25198: LD_VAR 0 1
25202: PPUSH
25203: CALL_OW 248
25207: ST_TO_ADDR
// if sources then
25208: LD_VAR 0 5
25212: IFFALSE 25259
// for i = 1 to 3 do
25214: LD_ADDR_VAR 0 8
25218: PUSH
25219: DOUBLE
25220: LD_INT 1
25222: DEC
25223: ST_TO_ADDR
25224: LD_INT 3
25226: PUSH
25227: FOR_TO
25228: IFFALSE 25257
// AddResourceType ( base , i , sources [ i ] ) ;
25230: LD_VAR 0 15
25234: PPUSH
25235: LD_VAR 0 8
25239: PPUSH
25240: LD_VAR 0 5
25244: PUSH
25245: LD_VAR 0 8
25249: ARRAY
25250: PPUSH
25251: CALL_OW 276
25255: GO 25227
25257: POP
25258: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25259: LD_ADDR_VAR 0 18
25263: PUSH
25264: LD_VAR 0 15
25268: PPUSH
25269: LD_VAR 0 2
25273: PPUSH
25274: LD_INT 1
25276: PPUSH
25277: CALL 24520 0 3
25281: ST_TO_ADDR
// InitHc ;
25282: CALL_OW 19
// InitUc ;
25286: CALL_OW 18
// uc_side := side ;
25290: LD_ADDR_OWVAR 20
25294: PUSH
25295: LD_VAR 0 16
25299: ST_TO_ADDR
// uc_nation := nation ;
25300: LD_ADDR_OWVAR 21
25304: PUSH
25305: LD_VAR 0 17
25309: ST_TO_ADDR
// if buildings then
25310: LD_VAR 0 18
25314: IFFALSE 26636
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25316: LD_ADDR_VAR 0 19
25320: PUSH
25321: LD_VAR 0 18
25325: PPUSH
25326: LD_INT 2
25328: PUSH
25329: LD_INT 30
25331: PUSH
25332: LD_INT 29
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: LIST
25353: PPUSH
25354: CALL_OW 72
25358: ST_TO_ADDR
// if tmp then
25359: LD_VAR 0 19
25363: IFFALSE 25411
// for i in tmp do
25365: LD_ADDR_VAR 0 8
25369: PUSH
25370: LD_VAR 0 19
25374: PUSH
25375: FOR_IN
25376: IFFALSE 25409
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25378: LD_VAR 0 8
25382: PPUSH
25383: CALL_OW 250
25387: PPUSH
25388: LD_VAR 0 8
25392: PPUSH
25393: CALL_OW 251
25397: PPUSH
25398: LD_VAR 0 16
25402: PPUSH
25403: CALL_OW 441
25407: GO 25375
25409: POP
25410: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25411: LD_VAR 0 18
25415: PPUSH
25416: LD_INT 2
25418: PUSH
25419: LD_INT 30
25421: PUSH
25422: LD_INT 32
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 30
25431: PUSH
25432: LD_INT 33
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: LIST
25443: PPUSH
25444: CALL_OW 72
25448: IFFALSE 25536
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 18
25459: PPUSH
25460: LD_INT 2
25462: PUSH
25463: LD_INT 30
25465: PUSH
25466: LD_INT 32
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 30
25475: PUSH
25476: LD_INT 33
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: PUSH
25493: FOR_IN
25494: IFFALSE 25534
// begin if not GetBWeapon ( i ) then
25496: LD_VAR 0 8
25500: PPUSH
25501: CALL_OW 269
25505: NOT
25506: IFFALSE 25532
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25508: LD_VAR 0 8
25512: PPUSH
25513: LD_VAR 0 8
25517: PPUSH
25518: LD_VAR 0 2
25522: PPUSH
25523: CALL 26782 0 2
25527: PPUSH
25528: CALL_OW 431
// end ;
25532: GO 25493
25534: POP
25535: POP
// end ; for i = 1 to personel do
25536: LD_ADDR_VAR 0 8
25540: PUSH
25541: DOUBLE
25542: LD_INT 1
25544: DEC
25545: ST_TO_ADDR
25546: LD_VAR 0 6
25550: PUSH
25551: FOR_TO
25552: IFFALSE 26616
// begin if i > 4 then
25554: LD_VAR 0 8
25558: PUSH
25559: LD_INT 4
25561: GREATER
25562: IFFALSE 25566
// break ;
25564: GO 26616
// case i of 1 :
25566: LD_VAR 0 8
25570: PUSH
25571: LD_INT 1
25573: DOUBLE
25574: EQUAL
25575: IFTRUE 25579
25577: GO 25659
25579: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25580: LD_ADDR_VAR 0 12
25584: PUSH
25585: LD_VAR 0 18
25589: PPUSH
25590: LD_INT 22
25592: PUSH
25593: LD_VAR 0 16
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PUSH
25602: LD_INT 58
25604: PUSH
25605: EMPTY
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: PUSH
25611: LD_INT 30
25613: PUSH
25614: LD_INT 32
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 4
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 30
25633: PUSH
25634: LD_INT 5
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: LIST
25651: PPUSH
25652: CALL_OW 72
25656: ST_TO_ADDR
25657: GO 25881
25659: LD_INT 2
25661: DOUBLE
25662: EQUAL
25663: IFTRUE 25667
25665: GO 25729
25667: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25668: LD_ADDR_VAR 0 12
25672: PUSH
25673: LD_VAR 0 18
25677: PPUSH
25678: LD_INT 22
25680: PUSH
25681: LD_VAR 0 16
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 2
25692: PUSH
25693: LD_INT 30
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 30
25705: PUSH
25706: LD_INT 1
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: LIST
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PPUSH
25722: CALL_OW 72
25726: ST_TO_ADDR
25727: GO 25881
25729: LD_INT 3
25731: DOUBLE
25732: EQUAL
25733: IFTRUE 25737
25735: GO 25799
25737: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25738: LD_ADDR_VAR 0 12
25742: PUSH
25743: LD_VAR 0 18
25747: PPUSH
25748: LD_INT 22
25750: PUSH
25751: LD_VAR 0 16
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 2
25762: PUSH
25763: LD_INT 30
25765: PUSH
25766: LD_INT 2
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 30
25775: PUSH
25776: LD_INT 3
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: LIST
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: PPUSH
25792: CALL_OW 72
25796: ST_TO_ADDR
25797: GO 25881
25799: LD_INT 4
25801: DOUBLE
25802: EQUAL
25803: IFTRUE 25807
25805: GO 25880
25807: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25808: LD_ADDR_VAR 0 12
25812: PUSH
25813: LD_VAR 0 18
25817: PPUSH
25818: LD_INT 22
25820: PUSH
25821: LD_VAR 0 16
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 2
25832: PUSH
25833: LD_INT 30
25835: PUSH
25836: LD_INT 6
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 30
25845: PUSH
25846: LD_INT 7
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 30
25855: PUSH
25856: LD_INT 8
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PPUSH
25873: CALL_OW 72
25877: ST_TO_ADDR
25878: GO 25881
25880: POP
// if i = 1 then
25881: LD_VAR 0 8
25885: PUSH
25886: LD_INT 1
25888: EQUAL
25889: IFFALSE 26000
// begin tmp := [ ] ;
25891: LD_ADDR_VAR 0 19
25895: PUSH
25896: EMPTY
25897: ST_TO_ADDR
// for j in f do
25898: LD_ADDR_VAR 0 9
25902: PUSH
25903: LD_VAR 0 12
25907: PUSH
25908: FOR_IN
25909: IFFALSE 25982
// if GetBType ( j ) = b_bunker then
25911: LD_VAR 0 9
25915: PPUSH
25916: CALL_OW 266
25920: PUSH
25921: LD_INT 32
25923: EQUAL
25924: IFFALSE 25951
// tmp := Insert ( tmp , 1 , j ) else
25926: LD_ADDR_VAR 0 19
25930: PUSH
25931: LD_VAR 0 19
25935: PPUSH
25936: LD_INT 1
25938: PPUSH
25939: LD_VAR 0 9
25943: PPUSH
25944: CALL_OW 2
25948: ST_TO_ADDR
25949: GO 25980
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25951: LD_ADDR_VAR 0 19
25955: PUSH
25956: LD_VAR 0 19
25960: PPUSH
25961: LD_VAR 0 19
25965: PUSH
25966: LD_INT 1
25968: PLUS
25969: PPUSH
25970: LD_VAR 0 9
25974: PPUSH
25975: CALL_OW 2
25979: ST_TO_ADDR
25980: GO 25908
25982: POP
25983: POP
// if tmp then
25984: LD_VAR 0 19
25988: IFFALSE 26000
// f := tmp ;
25990: LD_ADDR_VAR 0 12
25994: PUSH
25995: LD_VAR 0 19
25999: ST_TO_ADDR
// end ; x := personel [ i ] ;
26000: LD_ADDR_VAR 0 13
26004: PUSH
26005: LD_VAR 0 6
26009: PUSH
26010: LD_VAR 0 8
26014: ARRAY
26015: ST_TO_ADDR
// if x = - 1 then
26016: LD_VAR 0 13
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: EQUAL
26025: IFFALSE 26234
// begin for j in f do
26027: LD_ADDR_VAR 0 9
26031: PUSH
26032: LD_VAR 0 12
26036: PUSH
26037: FOR_IN
26038: IFFALSE 26230
// repeat InitHc ;
26040: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26044: LD_VAR 0 9
26048: PPUSH
26049: CALL_OW 266
26053: PUSH
26054: LD_INT 5
26056: EQUAL
26057: IFFALSE 26127
// begin if UnitsInside ( j ) < 3 then
26059: LD_VAR 0 9
26063: PPUSH
26064: CALL_OW 313
26068: PUSH
26069: LD_INT 3
26071: LESS
26072: IFFALSE 26108
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26074: LD_INT 0
26076: PPUSH
26077: LD_INT 5
26079: PUSH
26080: LD_INT 8
26082: PUSH
26083: LD_INT 9
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: PUSH
26091: LD_VAR 0 17
26095: ARRAY
26096: PPUSH
26097: LD_VAR 0 4
26101: PPUSH
26102: CALL_OW 380
26106: GO 26125
// PrepareHuman ( false , i , skill ) ;
26108: LD_INT 0
26110: PPUSH
26111: LD_VAR 0 8
26115: PPUSH
26116: LD_VAR 0 4
26120: PPUSH
26121: CALL_OW 380
// end else
26125: GO 26144
// PrepareHuman ( false , i , skill ) ;
26127: LD_INT 0
26129: PPUSH
26130: LD_VAR 0 8
26134: PPUSH
26135: LD_VAR 0 4
26139: PPUSH
26140: CALL_OW 380
// un := CreateHuman ;
26144: LD_ADDR_VAR 0 14
26148: PUSH
26149: CALL_OW 44
26153: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26154: LD_ADDR_VAR 0 7
26158: PUSH
26159: LD_VAR 0 7
26163: PPUSH
26164: LD_INT 1
26166: PPUSH
26167: LD_VAR 0 14
26171: PPUSH
26172: CALL_OW 2
26176: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26177: LD_VAR 0 14
26181: PPUSH
26182: LD_VAR 0 9
26186: PPUSH
26187: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26191: LD_VAR 0 9
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_INT 6
26203: EQUAL
26204: PUSH
26205: LD_VAR 0 9
26209: PPUSH
26210: CALL_OW 266
26214: PUSH
26215: LD_INT 32
26217: PUSH
26218: LD_INT 31
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: IN
26225: OR
26226: IFFALSE 26040
26228: GO 26037
26230: POP
26231: POP
// end else
26232: GO 26614
// for j = 1 to x do
26234: LD_ADDR_VAR 0 9
26238: PUSH
26239: DOUBLE
26240: LD_INT 1
26242: DEC
26243: ST_TO_ADDR
26244: LD_VAR 0 13
26248: PUSH
26249: FOR_TO
26250: IFFALSE 26612
// begin InitHc ;
26252: CALL_OW 19
// if not f then
26256: LD_VAR 0 12
26260: NOT
26261: IFFALSE 26350
// begin PrepareHuman ( false , i , skill ) ;
26263: LD_INT 0
26265: PPUSH
26266: LD_VAR 0 8
26270: PPUSH
26271: LD_VAR 0 4
26275: PPUSH
26276: CALL_OW 380
// un := CreateHuman ;
26280: LD_ADDR_VAR 0 14
26284: PUSH
26285: CALL_OW 44
26289: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26290: LD_ADDR_VAR 0 7
26294: PUSH
26295: LD_VAR 0 7
26299: PPUSH
26300: LD_INT 1
26302: PPUSH
26303: LD_VAR 0 14
26307: PPUSH
26308: CALL_OW 2
26312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26313: LD_VAR 0 14
26317: PPUSH
26318: LD_VAR 0 1
26322: PPUSH
26323: CALL_OW 250
26327: PPUSH
26328: LD_VAR 0 1
26332: PPUSH
26333: CALL_OW 251
26337: PPUSH
26338: LD_INT 10
26340: PPUSH
26341: LD_INT 0
26343: PPUSH
26344: CALL_OW 50
// continue ;
26348: GO 26249
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26350: LD_VAR 0 12
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 313
26363: PUSH
26364: LD_VAR 0 12
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 266
26377: PUSH
26378: LD_INT 32
26380: PUSH
26381: LD_INT 31
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: IN
26388: AND
26389: PUSH
26390: LD_VAR 0 12
26394: PUSH
26395: LD_INT 1
26397: ARRAY
26398: PPUSH
26399: CALL_OW 313
26403: PUSH
26404: LD_INT 6
26406: EQUAL
26407: OR
26408: IFFALSE 26428
// f := Delete ( f , 1 ) ;
26410: LD_ADDR_VAR 0 12
26414: PUSH
26415: LD_VAR 0 12
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: CALL_OW 3
26427: ST_TO_ADDR
// if not f then
26428: LD_VAR 0 12
26432: NOT
26433: IFFALSE 26451
// begin x := x + 2 ;
26435: LD_ADDR_VAR 0 13
26439: PUSH
26440: LD_VAR 0 13
26444: PUSH
26445: LD_INT 2
26447: PLUS
26448: ST_TO_ADDR
// continue ;
26449: GO 26249
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26451: LD_VAR 0 12
26455: PUSH
26456: LD_INT 1
26458: ARRAY
26459: PPUSH
26460: CALL_OW 266
26464: PUSH
26465: LD_INT 5
26467: EQUAL
26468: IFFALSE 26542
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26470: LD_VAR 0 12
26474: PUSH
26475: LD_INT 1
26477: ARRAY
26478: PPUSH
26479: CALL_OW 313
26483: PUSH
26484: LD_INT 3
26486: LESS
26487: IFFALSE 26523
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26489: LD_INT 0
26491: PPUSH
26492: LD_INT 5
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: LD_INT 9
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: LIST
26505: PUSH
26506: LD_VAR 0 17
26510: ARRAY
26511: PPUSH
26512: LD_VAR 0 4
26516: PPUSH
26517: CALL_OW 380
26521: GO 26540
// PrepareHuman ( false , i , skill ) ;
26523: LD_INT 0
26525: PPUSH
26526: LD_VAR 0 8
26530: PPUSH
26531: LD_VAR 0 4
26535: PPUSH
26536: CALL_OW 380
// end else
26540: GO 26559
// PrepareHuman ( false , i , skill ) ;
26542: LD_INT 0
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_VAR 0 4
26554: PPUSH
26555: CALL_OW 380
// un := CreateHuman ;
26559: LD_ADDR_VAR 0 14
26563: PUSH
26564: CALL_OW 44
26568: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26569: LD_ADDR_VAR 0 7
26573: PUSH
26574: LD_VAR 0 7
26578: PPUSH
26579: LD_INT 1
26581: PPUSH
26582: LD_VAR 0 14
26586: PPUSH
26587: CALL_OW 2
26591: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26592: LD_VAR 0 14
26596: PPUSH
26597: LD_VAR 0 12
26601: PUSH
26602: LD_INT 1
26604: ARRAY
26605: PPUSH
26606: CALL_OW 52
// end ;
26610: GO 26249
26612: POP
26613: POP
// end ;
26614: GO 25551
26616: POP
26617: POP
// result := result ^ buildings ;
26618: LD_ADDR_VAR 0 7
26622: PUSH
26623: LD_VAR 0 7
26627: PUSH
26628: LD_VAR 0 18
26632: ADD
26633: ST_TO_ADDR
// end else
26634: GO 26777
// begin for i = 1 to personel do
26636: LD_ADDR_VAR 0 8
26640: PUSH
26641: DOUBLE
26642: LD_INT 1
26644: DEC
26645: ST_TO_ADDR
26646: LD_VAR 0 6
26650: PUSH
26651: FOR_TO
26652: IFFALSE 26775
// begin if i > 4 then
26654: LD_VAR 0 8
26658: PUSH
26659: LD_INT 4
26661: GREATER
26662: IFFALSE 26666
// break ;
26664: GO 26775
// x := personel [ i ] ;
26666: LD_ADDR_VAR 0 13
26670: PUSH
26671: LD_VAR 0 6
26675: PUSH
26676: LD_VAR 0 8
26680: ARRAY
26681: ST_TO_ADDR
// if x = - 1 then
26682: LD_VAR 0 13
26686: PUSH
26687: LD_INT 1
26689: NEG
26690: EQUAL
26691: IFFALSE 26695
// continue ;
26693: GO 26651
// PrepareHuman ( false , i , skill ) ;
26695: LD_INT 0
26697: PPUSH
26698: LD_VAR 0 8
26702: PPUSH
26703: LD_VAR 0 4
26707: PPUSH
26708: CALL_OW 380
// un := CreateHuman ;
26712: LD_ADDR_VAR 0 14
26716: PUSH
26717: CALL_OW 44
26721: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26722: LD_VAR 0 14
26726: PPUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: CALL_OW 250
26736: PPUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 251
26746: PPUSH
26747: LD_INT 10
26749: PPUSH
26750: LD_INT 0
26752: PPUSH
26753: CALL_OW 50
// result := result ^ un ;
26757: LD_ADDR_VAR 0 7
26761: PUSH
26762: LD_VAR 0 7
26766: PUSH
26767: LD_VAR 0 14
26771: ADD
26772: ST_TO_ADDR
// end ;
26773: GO 26651
26775: POP
26776: POP
// end ; end ;
26777: LD_VAR 0 7
26781: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26782: LD_INT 0
26784: PPUSH
26785: PPUSH
26786: PPUSH
26787: PPUSH
26788: PPUSH
26789: PPUSH
26790: PPUSH
26791: PPUSH
26792: PPUSH
26793: PPUSH
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
// result := false ;
26800: LD_ADDR_VAR 0 3
26804: PUSH
26805: LD_INT 0
26807: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26808: LD_VAR 0 1
26812: NOT
26813: PUSH
26814: LD_VAR 0 1
26818: PPUSH
26819: CALL_OW 266
26823: PUSH
26824: LD_INT 32
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: IN
26834: NOT
26835: OR
26836: IFFALSE 26840
// exit ;
26838: GO 27949
// nat := GetNation ( tower ) ;
26840: LD_ADDR_VAR 0 12
26844: PUSH
26845: LD_VAR 0 1
26849: PPUSH
26850: CALL_OW 248
26854: ST_TO_ADDR
// side := GetSide ( tower ) ;
26855: LD_ADDR_VAR 0 16
26859: PUSH
26860: LD_VAR 0 1
26864: PPUSH
26865: CALL_OW 255
26869: ST_TO_ADDR
// x := GetX ( tower ) ;
26870: LD_ADDR_VAR 0 10
26874: PUSH
26875: LD_VAR 0 1
26879: PPUSH
26880: CALL_OW 250
26884: ST_TO_ADDR
// y := GetY ( tower ) ;
26885: LD_ADDR_VAR 0 11
26889: PUSH
26890: LD_VAR 0 1
26894: PPUSH
26895: CALL_OW 251
26899: ST_TO_ADDR
// if not x or not y then
26900: LD_VAR 0 10
26904: NOT
26905: PUSH
26906: LD_VAR 0 11
26910: NOT
26911: OR
26912: IFFALSE 26916
// exit ;
26914: GO 27949
// weapon := 0 ;
26916: LD_ADDR_VAR 0 18
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// fac_list := [ ] ;
26924: LD_ADDR_VAR 0 17
26928: PUSH
26929: EMPTY
26930: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26931: LD_ADDR_VAR 0 6
26935: PUSH
26936: LD_VAR 0 1
26940: PPUSH
26941: CALL_OW 274
26945: PPUSH
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 0
26953: PPUSH
26954: CALL 24520 0 3
26958: PPUSH
26959: LD_INT 30
26961: PUSH
26962: LD_INT 3
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PPUSH
26969: CALL_OW 72
26973: ST_TO_ADDR
// if not factories then
26974: LD_VAR 0 6
26978: NOT
26979: IFFALSE 26983
// exit ;
26981: GO 27949
// for i in factories do
26983: LD_ADDR_VAR 0 8
26987: PUSH
26988: LD_VAR 0 6
26992: PUSH
26993: FOR_IN
26994: IFFALSE 27019
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26996: LD_ADDR_VAR 0 17
27000: PUSH
27001: LD_VAR 0 17
27005: PUSH
27006: LD_VAR 0 8
27010: PPUSH
27011: CALL_OW 478
27015: UNION
27016: ST_TO_ADDR
27017: GO 26993
27019: POP
27020: POP
// if not fac_list then
27021: LD_VAR 0 17
27025: NOT
27026: IFFALSE 27030
// exit ;
27028: GO 27949
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27030: LD_ADDR_VAR 0 5
27034: PUSH
27035: LD_INT 4
27037: PUSH
27038: LD_INT 5
27040: PUSH
27041: LD_INT 9
27043: PUSH
27044: LD_INT 10
27046: PUSH
27047: LD_INT 6
27049: PUSH
27050: LD_INT 7
27052: PUSH
27053: LD_INT 11
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 27
27067: PUSH
27068: LD_INT 28
27070: PUSH
27071: LD_INT 26
27073: PUSH
27074: LD_INT 30
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 43
27085: PUSH
27086: LD_INT 44
27088: PUSH
27089: LD_INT 46
27091: PUSH
27092: LD_INT 45
27094: PUSH
27095: LD_INT 47
27097: PUSH
27098: LD_INT 49
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: PUSH
27114: LD_VAR 0 12
27118: ARRAY
27119: ST_TO_ADDR
// list := list isect fac_list ;
27120: LD_ADDR_VAR 0 5
27124: PUSH
27125: LD_VAR 0 5
27129: PUSH
27130: LD_VAR 0 17
27134: ISECT
27135: ST_TO_ADDR
// if not list then
27136: LD_VAR 0 5
27140: NOT
27141: IFFALSE 27145
// exit ;
27143: GO 27949
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27145: LD_VAR 0 12
27149: PUSH
27150: LD_INT 3
27152: EQUAL
27153: PUSH
27154: LD_INT 49
27156: PUSH
27157: LD_VAR 0 5
27161: IN
27162: AND
27163: PUSH
27164: LD_INT 31
27166: PPUSH
27167: LD_VAR 0 16
27171: PPUSH
27172: CALL_OW 321
27176: PUSH
27177: LD_INT 2
27179: EQUAL
27180: AND
27181: IFFALSE 27241
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27183: LD_INT 22
27185: PUSH
27186: LD_VAR 0 16
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 35
27197: PUSH
27198: LD_INT 49
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 91
27207: PUSH
27208: LD_VAR 0 1
27212: PUSH
27213: LD_INT 10
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: PPUSH
27226: CALL_OW 69
27230: NOT
27231: IFFALSE 27241
// weapon := ru_time_lapser ;
27233: LD_ADDR_VAR 0 18
27237: PUSH
27238: LD_INT 49
27240: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27241: LD_VAR 0 12
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: IN
27256: PUSH
27257: LD_INT 11
27259: PUSH
27260: LD_VAR 0 5
27264: IN
27265: PUSH
27266: LD_INT 30
27268: PUSH
27269: LD_VAR 0 5
27273: IN
27274: OR
27275: AND
27276: PUSH
27277: LD_INT 6
27279: PPUSH
27280: LD_VAR 0 16
27284: PPUSH
27285: CALL_OW 321
27289: PUSH
27290: LD_INT 2
27292: EQUAL
27293: AND
27294: IFFALSE 27459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27296: LD_INT 22
27298: PUSH
27299: LD_VAR 0 16
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 2
27310: PUSH
27311: LD_INT 35
27313: PUSH
27314: LD_INT 11
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 35
27323: PUSH
27324: LD_INT 30
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 91
27338: PUSH
27339: LD_VAR 0 1
27343: PUSH
27344: LD_INT 18
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PPUSH
27357: CALL_OW 69
27361: NOT
27362: PUSH
27363: LD_INT 22
27365: PUSH
27366: LD_VAR 0 16
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: LD_INT 2
27377: PUSH
27378: LD_INT 30
27380: PUSH
27381: LD_INT 32
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 30
27390: PUSH
27391: LD_INT 33
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 91
27405: PUSH
27406: LD_VAR 0 1
27410: PUSH
27411: LD_INT 12
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: LIST
27423: PUSH
27424: EMPTY
27425: LIST
27426: PPUSH
27427: CALL_OW 69
27431: PUSH
27432: LD_INT 2
27434: GREATER
27435: AND
27436: IFFALSE 27459
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27438: LD_ADDR_VAR 0 18
27442: PUSH
27443: LD_INT 11
27445: PUSH
27446: LD_INT 30
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_VAR 0 12
27457: ARRAY
27458: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27459: LD_VAR 0 18
27463: NOT
27464: PUSH
27465: LD_INT 40
27467: PPUSH
27468: LD_VAR 0 16
27472: PPUSH
27473: CALL_OW 321
27477: PUSH
27478: LD_INT 2
27480: EQUAL
27481: AND
27482: PUSH
27483: LD_INT 7
27485: PUSH
27486: LD_VAR 0 5
27490: IN
27491: PUSH
27492: LD_INT 28
27494: PUSH
27495: LD_VAR 0 5
27499: IN
27500: OR
27501: PUSH
27502: LD_INT 45
27504: PUSH
27505: LD_VAR 0 5
27509: IN
27510: OR
27511: AND
27512: IFFALSE 27766
// begin hex := GetHexInfo ( x , y ) ;
27514: LD_ADDR_VAR 0 4
27518: PUSH
27519: LD_VAR 0 10
27523: PPUSH
27524: LD_VAR 0 11
27528: PPUSH
27529: CALL_OW 546
27533: ST_TO_ADDR
// if hex [ 1 ] then
27534: LD_VAR 0 4
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: IFFALSE 27546
// exit ;
27544: GO 27949
// height := hex [ 2 ] ;
27546: LD_ADDR_VAR 0 15
27550: PUSH
27551: LD_VAR 0 4
27555: PUSH
27556: LD_INT 2
27558: ARRAY
27559: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27560: LD_ADDR_VAR 0 14
27564: PUSH
27565: LD_INT 0
27567: PUSH
27568: LD_INT 2
27570: PUSH
27571: LD_INT 3
27573: PUSH
27574: LD_INT 5
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: ST_TO_ADDR
// for i in tmp do
27583: LD_ADDR_VAR 0 8
27587: PUSH
27588: LD_VAR 0 14
27592: PUSH
27593: FOR_IN
27594: IFFALSE 27764
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27596: LD_ADDR_VAR 0 9
27600: PUSH
27601: LD_VAR 0 10
27605: PPUSH
27606: LD_VAR 0 8
27610: PPUSH
27611: LD_INT 5
27613: PPUSH
27614: CALL_OW 272
27618: PUSH
27619: LD_VAR 0 11
27623: PPUSH
27624: LD_VAR 0 8
27628: PPUSH
27629: LD_INT 5
27631: PPUSH
27632: CALL_OW 273
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27641: LD_VAR 0 9
27645: PUSH
27646: LD_INT 1
27648: ARRAY
27649: PPUSH
27650: LD_VAR 0 9
27654: PUSH
27655: LD_INT 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 488
27663: IFFALSE 27762
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27665: LD_ADDR_VAR 0 4
27669: PUSH
27670: LD_VAR 0 9
27674: PUSH
27675: LD_INT 1
27677: ARRAY
27678: PPUSH
27679: LD_VAR 0 9
27683: PUSH
27684: LD_INT 2
27686: ARRAY
27687: PPUSH
27688: CALL_OW 546
27692: ST_TO_ADDR
// if hex [ 1 ] then
27693: LD_VAR 0 4
27697: PUSH
27698: LD_INT 1
27700: ARRAY
27701: IFFALSE 27705
// continue ;
27703: GO 27593
// h := hex [ 2 ] ;
27705: LD_ADDR_VAR 0 13
27709: PUSH
27710: LD_VAR 0 4
27714: PUSH
27715: LD_INT 2
27717: ARRAY
27718: ST_TO_ADDR
// if h + 7 < height then
27719: LD_VAR 0 13
27723: PUSH
27724: LD_INT 7
27726: PLUS
27727: PUSH
27728: LD_VAR 0 15
27732: LESS
27733: IFFALSE 27762
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27735: LD_ADDR_VAR 0 18
27739: PUSH
27740: LD_INT 7
27742: PUSH
27743: LD_INT 28
27745: PUSH
27746: LD_INT 45
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: PUSH
27754: LD_VAR 0 12
27758: ARRAY
27759: ST_TO_ADDR
// break ;
27760: GO 27764
// end ; end ; end ;
27762: GO 27593
27764: POP
27765: POP
// end ; if not weapon then
27766: LD_VAR 0 18
27770: NOT
27771: IFFALSE 27831
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27773: LD_ADDR_VAR 0 5
27777: PUSH
27778: LD_VAR 0 5
27782: PUSH
27783: LD_INT 11
27785: PUSH
27786: LD_INT 30
27788: PUSH
27789: LD_INT 49
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: LIST
27796: DIFF
27797: ST_TO_ADDR
// if not list then
27798: LD_VAR 0 5
27802: NOT
27803: IFFALSE 27807
// exit ;
27805: GO 27949
// weapon := list [ rand ( 1 , list ) ] ;
27807: LD_ADDR_VAR 0 18
27811: PUSH
27812: LD_VAR 0 5
27816: PUSH
27817: LD_INT 1
27819: PPUSH
27820: LD_VAR 0 5
27824: PPUSH
27825: CALL_OW 12
27829: ARRAY
27830: ST_TO_ADDR
// end ; if weapon then
27831: LD_VAR 0 18
27835: IFFALSE 27949
// begin tmp := CostOfWeapon ( weapon ) ;
27837: LD_ADDR_VAR 0 14
27841: PUSH
27842: LD_VAR 0 18
27846: PPUSH
27847: CALL_OW 451
27851: ST_TO_ADDR
// j := GetBase ( tower ) ;
27852: LD_ADDR_VAR 0 9
27856: PUSH
27857: LD_VAR 0 1
27861: PPUSH
27862: CALL_OW 274
27866: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27867: LD_VAR 0 9
27871: PPUSH
27872: LD_INT 1
27874: PPUSH
27875: CALL_OW 275
27879: PUSH
27880: LD_VAR 0 14
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: GREATEREQUAL
27889: PUSH
27890: LD_VAR 0 9
27894: PPUSH
27895: LD_INT 2
27897: PPUSH
27898: CALL_OW 275
27902: PUSH
27903: LD_VAR 0 14
27907: PUSH
27908: LD_INT 2
27910: ARRAY
27911: GREATEREQUAL
27912: AND
27913: PUSH
27914: LD_VAR 0 9
27918: PPUSH
27919: LD_INT 3
27921: PPUSH
27922: CALL_OW 275
27926: PUSH
27927: LD_VAR 0 14
27931: PUSH
27932: LD_INT 3
27934: ARRAY
27935: GREATEREQUAL
27936: AND
27937: IFFALSE 27949
// result := weapon ;
27939: LD_ADDR_VAR 0 3
27943: PUSH
27944: LD_VAR 0 18
27948: ST_TO_ADDR
// end ; end ;
27949: LD_VAR 0 3
27953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27954: LD_INT 0
27956: PPUSH
27957: PPUSH
// result := true ;
27958: LD_ADDR_VAR 0 3
27962: PUSH
27963: LD_INT 1
27965: ST_TO_ADDR
// if array1 = array2 then
27966: LD_VAR 0 1
27970: PUSH
27971: LD_VAR 0 2
27975: EQUAL
27976: IFFALSE 28036
// begin for i = 1 to array1 do
27978: LD_ADDR_VAR 0 4
27982: PUSH
27983: DOUBLE
27984: LD_INT 1
27986: DEC
27987: ST_TO_ADDR
27988: LD_VAR 0 1
27992: PUSH
27993: FOR_TO
27994: IFFALSE 28032
// if array1 [ i ] <> array2 [ i ] then
27996: LD_VAR 0 1
28000: PUSH
28001: LD_VAR 0 4
28005: ARRAY
28006: PUSH
28007: LD_VAR 0 2
28011: PUSH
28012: LD_VAR 0 4
28016: ARRAY
28017: NONEQUAL
28018: IFFALSE 28030
// begin result := false ;
28020: LD_ADDR_VAR 0 3
28024: PUSH
28025: LD_INT 0
28027: ST_TO_ADDR
// break ;
28028: GO 28032
// end ;
28030: GO 27993
28032: POP
28033: POP
// end else
28034: GO 28044
// result := false ;
28036: LD_ADDR_VAR 0 3
28040: PUSH
28041: LD_INT 0
28043: ST_TO_ADDR
// end ;
28044: LD_VAR 0 3
28048: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28049: LD_INT 0
28051: PPUSH
28052: PPUSH
// if not array1 or not array2 then
28053: LD_VAR 0 1
28057: NOT
28058: PUSH
28059: LD_VAR 0 2
28063: NOT
28064: OR
28065: IFFALSE 28069
// exit ;
28067: GO 28133
// result := true ;
28069: LD_ADDR_VAR 0 3
28073: PUSH
28074: LD_INT 1
28076: ST_TO_ADDR
// for i = 1 to array1 do
28077: LD_ADDR_VAR 0 4
28081: PUSH
28082: DOUBLE
28083: LD_INT 1
28085: DEC
28086: ST_TO_ADDR
28087: LD_VAR 0 1
28091: PUSH
28092: FOR_TO
28093: IFFALSE 28131
// if array1 [ i ] <> array2 [ i ] then
28095: LD_VAR 0 1
28099: PUSH
28100: LD_VAR 0 4
28104: ARRAY
28105: PUSH
28106: LD_VAR 0 2
28110: PUSH
28111: LD_VAR 0 4
28115: ARRAY
28116: NONEQUAL
28117: IFFALSE 28129
// begin result := false ;
28119: LD_ADDR_VAR 0 3
28123: PUSH
28124: LD_INT 0
28126: ST_TO_ADDR
// break ;
28127: GO 28131
// end ;
28129: GO 28092
28131: POP
28132: POP
// end ;
28133: LD_VAR 0 3
28137: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28138: LD_INT 0
28140: PPUSH
28141: PPUSH
28142: PPUSH
// pom := GetBase ( fac ) ;
28143: LD_ADDR_VAR 0 5
28147: PUSH
28148: LD_VAR 0 1
28152: PPUSH
28153: CALL_OW 274
28157: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28158: LD_ADDR_VAR 0 4
28162: PUSH
28163: LD_VAR 0 2
28167: PUSH
28168: LD_INT 1
28170: ARRAY
28171: PPUSH
28172: LD_VAR 0 2
28176: PUSH
28177: LD_INT 2
28179: ARRAY
28180: PPUSH
28181: LD_VAR 0 2
28185: PUSH
28186: LD_INT 3
28188: ARRAY
28189: PPUSH
28190: LD_VAR 0 2
28194: PUSH
28195: LD_INT 4
28197: ARRAY
28198: PPUSH
28199: CALL_OW 449
28203: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28204: LD_ADDR_VAR 0 3
28208: PUSH
28209: LD_VAR 0 5
28213: PPUSH
28214: LD_INT 1
28216: PPUSH
28217: CALL_OW 275
28221: PUSH
28222: LD_VAR 0 4
28226: PUSH
28227: LD_INT 1
28229: ARRAY
28230: GREATEREQUAL
28231: PUSH
28232: LD_VAR 0 5
28236: PPUSH
28237: LD_INT 2
28239: PPUSH
28240: CALL_OW 275
28244: PUSH
28245: LD_VAR 0 4
28249: PUSH
28250: LD_INT 2
28252: ARRAY
28253: GREATEREQUAL
28254: AND
28255: PUSH
28256: LD_VAR 0 5
28260: PPUSH
28261: LD_INT 3
28263: PPUSH
28264: CALL_OW 275
28268: PUSH
28269: LD_VAR 0 4
28273: PUSH
28274: LD_INT 3
28276: ARRAY
28277: GREATEREQUAL
28278: AND
28279: ST_TO_ADDR
// end ;
28280: LD_VAR 0 3
28284: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28285: LD_INT 0
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
// pom := GetBase ( building ) ;
28291: LD_ADDR_VAR 0 3
28295: PUSH
28296: LD_VAR 0 1
28300: PPUSH
28301: CALL_OW 274
28305: ST_TO_ADDR
// if not pom then
28306: LD_VAR 0 3
28310: NOT
28311: IFFALSE 28315
// exit ;
28313: GO 28485
// btype := GetBType ( building ) ;
28315: LD_ADDR_VAR 0 5
28319: PUSH
28320: LD_VAR 0 1
28324: PPUSH
28325: CALL_OW 266
28329: ST_TO_ADDR
// if btype = b_armoury then
28330: LD_VAR 0 5
28334: PUSH
28335: LD_INT 4
28337: EQUAL
28338: IFFALSE 28348
// btype := b_barracks ;
28340: LD_ADDR_VAR 0 5
28344: PUSH
28345: LD_INT 5
28347: ST_TO_ADDR
// if btype = b_depot then
28348: LD_VAR 0 5
28352: PUSH
28353: LD_INT 0
28355: EQUAL
28356: IFFALSE 28366
// btype := b_warehouse ;
28358: LD_ADDR_VAR 0 5
28362: PUSH
28363: LD_INT 1
28365: ST_TO_ADDR
// if btype = b_workshop then
28366: LD_VAR 0 5
28370: PUSH
28371: LD_INT 2
28373: EQUAL
28374: IFFALSE 28384
// btype := b_factory ;
28376: LD_ADDR_VAR 0 5
28380: PUSH
28381: LD_INT 3
28383: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28384: LD_ADDR_VAR 0 4
28388: PUSH
28389: LD_VAR 0 5
28393: PPUSH
28394: LD_VAR 0 1
28398: PPUSH
28399: CALL_OW 248
28403: PPUSH
28404: CALL_OW 450
28408: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28409: LD_ADDR_VAR 0 2
28413: PUSH
28414: LD_VAR 0 3
28418: PPUSH
28419: LD_INT 1
28421: PPUSH
28422: CALL_OW 275
28426: PUSH
28427: LD_VAR 0 4
28431: PUSH
28432: LD_INT 1
28434: ARRAY
28435: GREATEREQUAL
28436: PUSH
28437: LD_VAR 0 3
28441: PPUSH
28442: LD_INT 2
28444: PPUSH
28445: CALL_OW 275
28449: PUSH
28450: LD_VAR 0 4
28454: PUSH
28455: LD_INT 2
28457: ARRAY
28458: GREATEREQUAL
28459: AND
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_INT 3
28468: PPUSH
28469: CALL_OW 275
28473: PUSH
28474: LD_VAR 0 4
28478: PUSH
28479: LD_INT 3
28481: ARRAY
28482: GREATEREQUAL
28483: AND
28484: ST_TO_ADDR
// end ;
28485: LD_VAR 0 2
28489: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28490: LD_INT 0
28492: PPUSH
28493: PPUSH
28494: PPUSH
// pom := GetBase ( building ) ;
28495: LD_ADDR_VAR 0 4
28499: PUSH
28500: LD_VAR 0 1
28504: PPUSH
28505: CALL_OW 274
28509: ST_TO_ADDR
// if not pom then
28510: LD_VAR 0 4
28514: NOT
28515: IFFALSE 28519
// exit ;
28517: GO 28620
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28519: LD_ADDR_VAR 0 5
28523: PUSH
28524: LD_VAR 0 2
28528: PPUSH
28529: LD_VAR 0 1
28533: PPUSH
28534: CALL_OW 248
28538: PPUSH
28539: CALL_OW 450
28543: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28544: LD_ADDR_VAR 0 3
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 1
28556: PPUSH
28557: CALL_OW 275
28561: PUSH
28562: LD_VAR 0 5
28566: PUSH
28567: LD_INT 1
28569: ARRAY
28570: GREATEREQUAL
28571: PUSH
28572: LD_VAR 0 4
28576: PPUSH
28577: LD_INT 2
28579: PPUSH
28580: CALL_OW 275
28584: PUSH
28585: LD_VAR 0 5
28589: PUSH
28590: LD_INT 2
28592: ARRAY
28593: GREATEREQUAL
28594: AND
28595: PUSH
28596: LD_VAR 0 4
28600: PPUSH
28601: LD_INT 3
28603: PPUSH
28604: CALL_OW 275
28608: PUSH
28609: LD_VAR 0 5
28613: PUSH
28614: LD_INT 3
28616: ARRAY
28617: GREATEREQUAL
28618: AND
28619: ST_TO_ADDR
// end ;
28620: LD_VAR 0 3
28624: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28625: LD_INT 0
28627: PPUSH
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
// result := false ;
28638: LD_ADDR_VAR 0 8
28642: PUSH
28643: LD_INT 0
28645: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28646: LD_VAR 0 5
28650: NOT
28651: PUSH
28652: LD_VAR 0 1
28656: NOT
28657: OR
28658: PUSH
28659: LD_VAR 0 2
28663: NOT
28664: OR
28665: PUSH
28666: LD_VAR 0 3
28670: NOT
28671: OR
28672: IFFALSE 28676
// exit ;
28674: GO 29490
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28676: LD_ADDR_VAR 0 14
28680: PUSH
28681: LD_VAR 0 1
28685: PPUSH
28686: LD_VAR 0 2
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: LD_VAR 0 4
28700: PPUSH
28701: LD_VAR 0 5
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PPUSH
28710: CALL_OW 248
28714: PPUSH
28715: LD_INT 0
28717: PPUSH
28718: CALL 30743 0 6
28722: ST_TO_ADDR
// if not hexes then
28723: LD_VAR 0 14
28727: NOT
28728: IFFALSE 28732
// exit ;
28730: GO 29490
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28732: LD_ADDR_VAR 0 17
28736: PUSH
28737: LD_VAR 0 5
28741: PPUSH
28742: LD_INT 22
28744: PUSH
28745: LD_VAR 0 13
28749: PPUSH
28750: CALL_OW 255
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 30
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 30
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PPUSH
28791: CALL_OW 72
28795: ST_TO_ADDR
// for i = 1 to hexes do
28796: LD_ADDR_VAR 0 9
28800: PUSH
28801: DOUBLE
28802: LD_INT 1
28804: DEC
28805: ST_TO_ADDR
28806: LD_VAR 0 14
28810: PUSH
28811: FOR_TO
28812: IFFALSE 29488
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28814: LD_ADDR_VAR 0 13
28818: PUSH
28819: LD_VAR 0 14
28823: PUSH
28824: LD_VAR 0 9
28828: ARRAY
28829: PUSH
28830: LD_INT 1
28832: ARRAY
28833: PPUSH
28834: LD_VAR 0 14
28838: PUSH
28839: LD_VAR 0 9
28843: ARRAY
28844: PUSH
28845: LD_INT 2
28847: ARRAY
28848: PPUSH
28849: CALL_OW 428
28853: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28854: LD_VAR 0 14
28858: PUSH
28859: LD_VAR 0 9
28863: ARRAY
28864: PUSH
28865: LD_INT 1
28867: ARRAY
28868: PPUSH
28869: LD_VAR 0 14
28873: PUSH
28874: LD_VAR 0 9
28878: ARRAY
28879: PUSH
28880: LD_INT 2
28882: ARRAY
28883: PPUSH
28884: CALL_OW 351
28888: PUSH
28889: LD_VAR 0 14
28893: PUSH
28894: LD_VAR 0 9
28898: ARRAY
28899: PUSH
28900: LD_INT 1
28902: ARRAY
28903: PPUSH
28904: LD_VAR 0 14
28908: PUSH
28909: LD_VAR 0 9
28913: ARRAY
28914: PUSH
28915: LD_INT 2
28917: ARRAY
28918: PPUSH
28919: CALL_OW 488
28923: NOT
28924: OR
28925: PUSH
28926: LD_VAR 0 13
28930: PPUSH
28931: CALL_OW 247
28935: PUSH
28936: LD_INT 3
28938: EQUAL
28939: OR
28940: IFFALSE 28946
// exit ;
28942: POP
28943: POP
28944: GO 29490
// if not tmp then
28946: LD_VAR 0 13
28950: NOT
28951: IFFALSE 28955
// continue ;
28953: GO 28811
// result := true ;
28955: LD_ADDR_VAR 0 8
28959: PUSH
28960: LD_INT 1
28962: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28963: LD_VAR 0 6
28967: PUSH
28968: LD_VAR 0 13
28972: PPUSH
28973: CALL_OW 247
28977: PUSH
28978: LD_INT 2
28980: EQUAL
28981: AND
28982: PUSH
28983: LD_VAR 0 13
28987: PPUSH
28988: CALL_OW 263
28992: PUSH
28993: LD_INT 1
28995: EQUAL
28996: AND
28997: IFFALSE 29161
// begin if IsDrivenBy ( tmp ) then
28999: LD_VAR 0 13
29003: PPUSH
29004: CALL_OW 311
29008: IFFALSE 29012
// continue ;
29010: GO 28811
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29012: LD_VAR 0 6
29016: PPUSH
29017: LD_INT 3
29019: PUSH
29020: LD_INT 60
29022: PUSH
29023: EMPTY
29024: LIST
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 3
29032: PUSH
29033: LD_INT 55
29035: PUSH
29036: EMPTY
29037: LIST
29038: PUSH
29039: EMPTY
29040: LIST
29041: LIST
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PPUSH
29047: CALL_OW 72
29051: IFFALSE 29159
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29053: LD_ADDR_VAR 0 18
29057: PUSH
29058: LD_VAR 0 6
29062: PPUSH
29063: LD_INT 3
29065: PUSH
29066: LD_INT 60
29068: PUSH
29069: EMPTY
29070: LIST
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 55
29081: PUSH
29082: EMPTY
29083: LIST
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PPUSH
29093: CALL_OW 72
29097: PUSH
29098: LD_INT 1
29100: ARRAY
29101: ST_TO_ADDR
// if IsInUnit ( driver ) then
29102: LD_VAR 0 18
29106: PPUSH
29107: CALL_OW 310
29111: IFFALSE 29122
// ComExit ( driver ) ;
29113: LD_VAR 0 18
29117: PPUSH
29118: CALL 54524 0 1
// AddComEnterUnit ( driver , tmp ) ;
29122: LD_VAR 0 18
29126: PPUSH
29127: LD_VAR 0 13
29131: PPUSH
29132: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29136: LD_VAR 0 18
29140: PPUSH
29141: LD_VAR 0 7
29145: PPUSH
29146: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29150: LD_VAR 0 18
29154: PPUSH
29155: CALL_OW 181
// end ; continue ;
29159: GO 28811
// end ; if not cleaners or not tmp in cleaners then
29161: LD_VAR 0 6
29165: NOT
29166: PUSH
29167: LD_VAR 0 13
29171: PUSH
29172: LD_VAR 0 6
29176: IN
29177: NOT
29178: OR
29179: IFFALSE 29486
// begin if dep then
29181: LD_VAR 0 17
29185: IFFALSE 29321
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29187: LD_ADDR_VAR 0 16
29191: PUSH
29192: LD_VAR 0 17
29196: PUSH
29197: LD_INT 1
29199: ARRAY
29200: PPUSH
29201: CALL_OW 250
29205: PPUSH
29206: LD_VAR 0 17
29210: PUSH
29211: LD_INT 1
29213: ARRAY
29214: PPUSH
29215: CALL_OW 254
29219: PPUSH
29220: LD_INT 5
29222: PPUSH
29223: CALL_OW 272
29227: PUSH
29228: LD_VAR 0 17
29232: PUSH
29233: LD_INT 1
29235: ARRAY
29236: PPUSH
29237: CALL_OW 251
29241: PPUSH
29242: LD_VAR 0 17
29246: PUSH
29247: LD_INT 1
29249: ARRAY
29250: PPUSH
29251: CALL_OW 254
29255: PPUSH
29256: LD_INT 5
29258: PPUSH
29259: CALL_OW 273
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29268: LD_VAR 0 16
29272: PUSH
29273: LD_INT 1
29275: ARRAY
29276: PPUSH
29277: LD_VAR 0 16
29281: PUSH
29282: LD_INT 2
29284: ARRAY
29285: PPUSH
29286: CALL_OW 488
29290: IFFALSE 29321
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29292: LD_VAR 0 13
29296: PPUSH
29297: LD_VAR 0 16
29301: PUSH
29302: LD_INT 1
29304: ARRAY
29305: PPUSH
29306: LD_VAR 0 16
29310: PUSH
29311: LD_INT 2
29313: ARRAY
29314: PPUSH
29315: CALL_OW 111
// continue ;
29319: GO 28811
// end ; end ; r := GetDir ( tmp ) ;
29321: LD_ADDR_VAR 0 15
29325: PUSH
29326: LD_VAR 0 13
29330: PPUSH
29331: CALL_OW 254
29335: ST_TO_ADDR
// if r = 5 then
29336: LD_VAR 0 15
29340: PUSH
29341: LD_INT 5
29343: EQUAL
29344: IFFALSE 29354
// r := 0 ;
29346: LD_ADDR_VAR 0 15
29350: PUSH
29351: LD_INT 0
29353: ST_TO_ADDR
// for j = r to 5 do
29354: LD_ADDR_VAR 0 10
29358: PUSH
29359: DOUBLE
29360: LD_VAR 0 15
29364: DEC
29365: ST_TO_ADDR
29366: LD_INT 5
29368: PUSH
29369: FOR_TO
29370: IFFALSE 29484
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29372: LD_ADDR_VAR 0 11
29376: PUSH
29377: LD_VAR 0 13
29381: PPUSH
29382: CALL_OW 250
29386: PPUSH
29387: LD_VAR 0 10
29391: PPUSH
29392: LD_INT 2
29394: PPUSH
29395: CALL_OW 272
29399: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29400: LD_ADDR_VAR 0 12
29404: PUSH
29405: LD_VAR 0 13
29409: PPUSH
29410: CALL_OW 251
29414: PPUSH
29415: LD_VAR 0 10
29419: PPUSH
29420: LD_INT 2
29422: PPUSH
29423: CALL_OW 273
29427: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29428: LD_VAR 0 11
29432: PPUSH
29433: LD_VAR 0 12
29437: PPUSH
29438: CALL_OW 488
29442: PUSH
29443: LD_VAR 0 11
29447: PPUSH
29448: LD_VAR 0 12
29452: PPUSH
29453: CALL_OW 428
29457: NOT
29458: AND
29459: IFFALSE 29482
// begin ComMoveXY ( tmp , _x , _y ) ;
29461: LD_VAR 0 13
29465: PPUSH
29466: LD_VAR 0 11
29470: PPUSH
29471: LD_VAR 0 12
29475: PPUSH
29476: CALL_OW 111
// break ;
29480: GO 29484
// end ; end ;
29482: GO 29369
29484: POP
29485: POP
// end ; end ;
29486: GO 28811
29488: POP
29489: POP
// end ;
29490: LD_VAR 0 8
29494: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29495: LD_INT 0
29497: PPUSH
// result := true ;
29498: LD_ADDR_VAR 0 3
29502: PUSH
29503: LD_INT 1
29505: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29506: LD_VAR 0 2
29510: PUSH
29511: LD_INT 24
29513: DOUBLE
29514: EQUAL
29515: IFTRUE 29525
29517: LD_INT 33
29519: DOUBLE
29520: EQUAL
29521: IFTRUE 29525
29523: GO 29550
29525: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29526: LD_ADDR_VAR 0 3
29530: PUSH
29531: LD_INT 32
29533: PPUSH
29534: LD_VAR 0 1
29538: PPUSH
29539: CALL_OW 321
29543: PUSH
29544: LD_INT 2
29546: EQUAL
29547: ST_TO_ADDR
29548: GO 29866
29550: LD_INT 20
29552: DOUBLE
29553: EQUAL
29554: IFTRUE 29558
29556: GO 29583
29558: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29559: LD_ADDR_VAR 0 3
29563: PUSH
29564: LD_INT 6
29566: PPUSH
29567: LD_VAR 0 1
29571: PPUSH
29572: CALL_OW 321
29576: PUSH
29577: LD_INT 2
29579: EQUAL
29580: ST_TO_ADDR
29581: GO 29866
29583: LD_INT 22
29585: DOUBLE
29586: EQUAL
29587: IFTRUE 29597
29589: LD_INT 36
29591: DOUBLE
29592: EQUAL
29593: IFTRUE 29597
29595: GO 29622
29597: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29598: LD_ADDR_VAR 0 3
29602: PUSH
29603: LD_INT 15
29605: PPUSH
29606: LD_VAR 0 1
29610: PPUSH
29611: CALL_OW 321
29615: PUSH
29616: LD_INT 2
29618: EQUAL
29619: ST_TO_ADDR
29620: GO 29866
29622: LD_INT 30
29624: DOUBLE
29625: EQUAL
29626: IFTRUE 29630
29628: GO 29655
29630: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29631: LD_ADDR_VAR 0 3
29635: PUSH
29636: LD_INT 20
29638: PPUSH
29639: LD_VAR 0 1
29643: PPUSH
29644: CALL_OW 321
29648: PUSH
29649: LD_INT 2
29651: EQUAL
29652: ST_TO_ADDR
29653: GO 29866
29655: LD_INT 28
29657: DOUBLE
29658: EQUAL
29659: IFTRUE 29669
29661: LD_INT 21
29663: DOUBLE
29664: EQUAL
29665: IFTRUE 29669
29667: GO 29694
29669: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29670: LD_ADDR_VAR 0 3
29674: PUSH
29675: LD_INT 21
29677: PPUSH
29678: LD_VAR 0 1
29682: PPUSH
29683: CALL_OW 321
29687: PUSH
29688: LD_INT 2
29690: EQUAL
29691: ST_TO_ADDR
29692: GO 29866
29694: LD_INT 16
29696: DOUBLE
29697: EQUAL
29698: IFTRUE 29702
29700: GO 29727
29702: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29703: LD_ADDR_VAR 0 3
29707: PUSH
29708: LD_INT 84
29710: PPUSH
29711: LD_VAR 0 1
29715: PPUSH
29716: CALL_OW 321
29720: PUSH
29721: LD_INT 2
29723: EQUAL
29724: ST_TO_ADDR
29725: GO 29866
29727: LD_INT 19
29729: DOUBLE
29730: EQUAL
29731: IFTRUE 29741
29733: LD_INT 23
29735: DOUBLE
29736: EQUAL
29737: IFTRUE 29741
29739: GO 29766
29741: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29742: LD_ADDR_VAR 0 3
29746: PUSH
29747: LD_INT 83
29749: PPUSH
29750: LD_VAR 0 1
29754: PPUSH
29755: CALL_OW 321
29759: PUSH
29760: LD_INT 2
29762: EQUAL
29763: ST_TO_ADDR
29764: GO 29866
29766: LD_INT 17
29768: DOUBLE
29769: EQUAL
29770: IFTRUE 29774
29772: GO 29799
29774: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29775: LD_ADDR_VAR 0 3
29779: PUSH
29780: LD_INT 39
29782: PPUSH
29783: LD_VAR 0 1
29787: PPUSH
29788: CALL_OW 321
29792: PUSH
29793: LD_INT 2
29795: EQUAL
29796: ST_TO_ADDR
29797: GO 29866
29799: LD_INT 18
29801: DOUBLE
29802: EQUAL
29803: IFTRUE 29807
29805: GO 29832
29807: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29808: LD_ADDR_VAR 0 3
29812: PUSH
29813: LD_INT 40
29815: PPUSH
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 321
29825: PUSH
29826: LD_INT 2
29828: EQUAL
29829: ST_TO_ADDR
29830: GO 29866
29832: LD_INT 27
29834: DOUBLE
29835: EQUAL
29836: IFTRUE 29840
29838: GO 29865
29840: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29841: LD_ADDR_VAR 0 3
29845: PUSH
29846: LD_INT 35
29848: PPUSH
29849: LD_VAR 0 1
29853: PPUSH
29854: CALL_OW 321
29858: PUSH
29859: LD_INT 2
29861: EQUAL
29862: ST_TO_ADDR
29863: GO 29866
29865: POP
// end ;
29866: LD_VAR 0 3
29870: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29871: LD_INT 0
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
// result := false ;
29884: LD_ADDR_VAR 0 6
29888: PUSH
29889: LD_INT 0
29891: ST_TO_ADDR
// if btype = b_depot then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 0
29899: EQUAL
29900: IFFALSE 29912
// begin result := true ;
29902: LD_ADDR_VAR 0 6
29906: PUSH
29907: LD_INT 1
29909: ST_TO_ADDR
// exit ;
29910: GO 30738
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29912: LD_VAR 0 1
29916: NOT
29917: PUSH
29918: LD_VAR 0 1
29922: PPUSH
29923: CALL_OW 266
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: IN
29938: NOT
29939: OR
29940: PUSH
29941: LD_VAR 0 2
29945: NOT
29946: OR
29947: PUSH
29948: LD_VAR 0 5
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 2
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: LD_INT 4
29967: PUSH
29968: LD_INT 5
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: IN
29979: NOT
29980: OR
29981: PUSH
29982: LD_VAR 0 3
29986: PPUSH
29987: LD_VAR 0 4
29991: PPUSH
29992: CALL_OW 488
29996: NOT
29997: OR
29998: IFFALSE 30002
// exit ;
30000: GO 30738
// side := GetSide ( depot ) ;
30002: LD_ADDR_VAR 0 9
30006: PUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 255
30016: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30017: LD_VAR 0 9
30021: PPUSH
30022: LD_VAR 0 2
30026: PPUSH
30027: CALL 29495 0 2
30031: NOT
30032: IFFALSE 30036
// exit ;
30034: GO 30738
// pom := GetBase ( depot ) ;
30036: LD_ADDR_VAR 0 10
30040: PUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 274
30050: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30051: LD_ADDR_VAR 0 11
30055: PUSH
30056: LD_VAR 0 2
30060: PPUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 248
30070: PPUSH
30071: CALL_OW 450
30075: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30076: LD_VAR 0 10
30080: PPUSH
30081: LD_INT 1
30083: PPUSH
30084: CALL_OW 275
30088: PUSH
30089: LD_VAR 0 11
30093: PUSH
30094: LD_INT 1
30096: ARRAY
30097: GREATEREQUAL
30098: PUSH
30099: LD_VAR 0 10
30103: PPUSH
30104: LD_INT 2
30106: PPUSH
30107: CALL_OW 275
30111: PUSH
30112: LD_VAR 0 11
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: GREATEREQUAL
30121: AND
30122: PUSH
30123: LD_VAR 0 10
30127: PPUSH
30128: LD_INT 3
30130: PPUSH
30131: CALL_OW 275
30135: PUSH
30136: LD_VAR 0 11
30140: PUSH
30141: LD_INT 3
30143: ARRAY
30144: GREATEREQUAL
30145: AND
30146: NOT
30147: IFFALSE 30151
// exit ;
30149: GO 30738
// if GetBType ( depot ) = b_depot then
30151: LD_VAR 0 1
30155: PPUSH
30156: CALL_OW 266
30160: PUSH
30161: LD_INT 0
30163: EQUAL
30164: IFFALSE 30176
// dist := 28 else
30166: LD_ADDR_VAR 0 14
30170: PUSH
30171: LD_INT 28
30173: ST_TO_ADDR
30174: GO 30184
// dist := 36 ;
30176: LD_ADDR_VAR 0 14
30180: PUSH
30181: LD_INT 36
30183: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30184: LD_VAR 0 1
30188: PPUSH
30189: LD_VAR 0 3
30193: PPUSH
30194: LD_VAR 0 4
30198: PPUSH
30199: CALL_OW 297
30203: PUSH
30204: LD_VAR 0 14
30208: GREATER
30209: IFFALSE 30213
// exit ;
30211: GO 30738
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30213: LD_ADDR_VAR 0 12
30217: PUSH
30218: LD_VAR 0 2
30222: PPUSH
30223: LD_VAR 0 3
30227: PPUSH
30228: LD_VAR 0 4
30232: PPUSH
30233: LD_VAR 0 5
30237: PPUSH
30238: LD_VAR 0 1
30242: PPUSH
30243: CALL_OW 248
30247: PPUSH
30248: LD_INT 0
30250: PPUSH
30251: CALL 30743 0 6
30255: ST_TO_ADDR
// if not hexes then
30256: LD_VAR 0 12
30260: NOT
30261: IFFALSE 30265
// exit ;
30263: GO 30738
// hex := GetHexInfo ( x , y ) ;
30265: LD_ADDR_VAR 0 15
30269: PUSH
30270: LD_VAR 0 3
30274: PPUSH
30275: LD_VAR 0 4
30279: PPUSH
30280: CALL_OW 546
30284: ST_TO_ADDR
// if hex [ 1 ] then
30285: LD_VAR 0 15
30289: PUSH
30290: LD_INT 1
30292: ARRAY
30293: IFFALSE 30297
// exit ;
30295: GO 30738
// height := hex [ 2 ] ;
30297: LD_ADDR_VAR 0 13
30301: PUSH
30302: LD_VAR 0 15
30306: PUSH
30307: LD_INT 2
30309: ARRAY
30310: ST_TO_ADDR
// for i = 1 to hexes do
30311: LD_ADDR_VAR 0 7
30315: PUSH
30316: DOUBLE
30317: LD_INT 1
30319: DEC
30320: ST_TO_ADDR
30321: LD_VAR 0 12
30325: PUSH
30326: FOR_TO
30327: IFFALSE 30657
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30329: LD_VAR 0 12
30333: PUSH
30334: LD_VAR 0 7
30338: ARRAY
30339: PUSH
30340: LD_INT 1
30342: ARRAY
30343: PPUSH
30344: LD_VAR 0 12
30348: PUSH
30349: LD_VAR 0 7
30353: ARRAY
30354: PUSH
30355: LD_INT 2
30357: ARRAY
30358: PPUSH
30359: CALL_OW 488
30363: NOT
30364: PUSH
30365: LD_VAR 0 12
30369: PUSH
30370: LD_VAR 0 7
30374: ARRAY
30375: PUSH
30376: LD_INT 1
30378: ARRAY
30379: PPUSH
30380: LD_VAR 0 12
30384: PUSH
30385: LD_VAR 0 7
30389: ARRAY
30390: PUSH
30391: LD_INT 2
30393: ARRAY
30394: PPUSH
30395: CALL_OW 428
30399: PUSH
30400: LD_INT 0
30402: GREATER
30403: OR
30404: PUSH
30405: LD_VAR 0 12
30409: PUSH
30410: LD_VAR 0 7
30414: ARRAY
30415: PUSH
30416: LD_INT 1
30418: ARRAY
30419: PPUSH
30420: LD_VAR 0 12
30424: PUSH
30425: LD_VAR 0 7
30429: ARRAY
30430: PUSH
30431: LD_INT 2
30433: ARRAY
30434: PPUSH
30435: CALL_OW 351
30439: OR
30440: IFFALSE 30446
// exit ;
30442: POP
30443: POP
30444: GO 30738
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30446: LD_ADDR_VAR 0 8
30450: PUSH
30451: LD_VAR 0 12
30455: PUSH
30456: LD_VAR 0 7
30460: ARRAY
30461: PUSH
30462: LD_INT 1
30464: ARRAY
30465: PPUSH
30466: LD_VAR 0 12
30470: PUSH
30471: LD_VAR 0 7
30475: ARRAY
30476: PUSH
30477: LD_INT 2
30479: ARRAY
30480: PPUSH
30481: CALL_OW 546
30485: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30486: LD_VAR 0 8
30490: PUSH
30491: LD_INT 1
30493: ARRAY
30494: PUSH
30495: LD_VAR 0 8
30499: PUSH
30500: LD_INT 2
30502: ARRAY
30503: PUSH
30504: LD_VAR 0 13
30508: PUSH
30509: LD_INT 2
30511: PLUS
30512: GREATER
30513: OR
30514: PUSH
30515: LD_VAR 0 8
30519: PUSH
30520: LD_INT 2
30522: ARRAY
30523: PUSH
30524: LD_VAR 0 13
30528: PUSH
30529: LD_INT 2
30531: MINUS
30532: LESS
30533: OR
30534: PUSH
30535: LD_VAR 0 8
30539: PUSH
30540: LD_INT 3
30542: ARRAY
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: LD_INT 8
30549: PUSH
30550: LD_INT 9
30552: PUSH
30553: LD_INT 10
30555: PUSH
30556: LD_INT 11
30558: PUSH
30559: LD_INT 12
30561: PUSH
30562: LD_INT 13
30564: PUSH
30565: LD_INT 16
30567: PUSH
30568: LD_INT 17
30570: PUSH
30571: LD_INT 18
30573: PUSH
30574: LD_INT 19
30576: PUSH
30577: LD_INT 20
30579: PUSH
30580: LD_INT 21
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: IN
30598: NOT
30599: OR
30600: PUSH
30601: LD_VAR 0 8
30605: PUSH
30606: LD_INT 5
30608: ARRAY
30609: NOT
30610: OR
30611: PUSH
30612: LD_VAR 0 8
30616: PUSH
30617: LD_INT 6
30619: ARRAY
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: LD_INT 2
30626: PUSH
30627: LD_INT 7
30629: PUSH
30630: LD_INT 9
30632: PUSH
30633: LD_INT 10
30635: PUSH
30636: LD_INT 11
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: IN
30647: NOT
30648: OR
30649: IFFALSE 30655
// exit ;
30651: POP
30652: POP
30653: GO 30738
// end ;
30655: GO 30326
30657: POP
30658: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30659: LD_VAR 0 9
30663: PPUSH
30664: LD_VAR 0 3
30668: PPUSH
30669: LD_VAR 0 4
30673: PPUSH
30674: LD_INT 20
30676: PPUSH
30677: CALL 22661 0 4
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: IFFALSE 30689
// exit ;
30687: GO 30738
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_INT 29
30696: PUSH
30697: LD_INT 30
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: IN
30704: PUSH
30705: LD_VAR 0 3
30709: PPUSH
30710: LD_VAR 0 4
30714: PPUSH
30715: LD_VAR 0 9
30719: PPUSH
30720: CALL_OW 440
30724: NOT
30725: AND
30726: IFFALSE 30730
// exit ;
30728: GO 30738
// result := true ;
30730: LD_ADDR_VAR 0 6
30734: PUSH
30735: LD_INT 1
30737: ST_TO_ADDR
// end ;
30738: LD_VAR 0 6
30742: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30743: LD_INT 0
30745: PPUSH
30746: PPUSH
30747: PPUSH
30748: PPUSH
30749: PPUSH
30750: PPUSH
30751: PPUSH
30752: PPUSH
30753: PPUSH
30754: PPUSH
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
30766: PPUSH
30767: PPUSH
30768: PPUSH
30769: PPUSH
30770: PPUSH
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
30783: PPUSH
30784: PPUSH
30785: PPUSH
30786: PPUSH
30787: PPUSH
30788: PPUSH
30789: PPUSH
30790: PPUSH
30791: PPUSH
30792: PPUSH
30793: PPUSH
30794: PPUSH
30795: PPUSH
30796: PPUSH
30797: PPUSH
30798: PPUSH
30799: PPUSH
30800: PPUSH
30801: PPUSH
30802: PPUSH
// result = [ ] ;
30803: LD_ADDR_VAR 0 7
30807: PUSH
30808: EMPTY
30809: ST_TO_ADDR
// temp_list = [ ] ;
30810: LD_ADDR_VAR 0 9
30814: PUSH
30815: EMPTY
30816: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30817: LD_VAR 0 4
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: LD_INT 2
30830: PUSH
30831: LD_INT 3
30833: PUSH
30834: LD_INT 4
30836: PUSH
30837: LD_INT 5
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: IN
30848: NOT
30849: PUSH
30850: LD_VAR 0 1
30854: PUSH
30855: LD_INT 0
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: IN
30865: PUSH
30866: LD_VAR 0 5
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: LD_INT 2
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: IN
30885: NOT
30886: AND
30887: OR
30888: IFFALSE 30892
// exit ;
30890: GO 49283
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30892: LD_VAR 0 1
30896: PUSH
30897: LD_INT 6
30899: PUSH
30900: LD_INT 7
30902: PUSH
30903: LD_INT 8
30905: PUSH
30906: LD_INT 13
30908: PUSH
30909: LD_INT 12
30911: PUSH
30912: LD_INT 15
30914: PUSH
30915: LD_INT 11
30917: PUSH
30918: LD_INT 14
30920: PUSH
30921: LD_INT 10
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: IN
30935: IFFALSE 30945
// btype = b_lab ;
30937: LD_ADDR_VAR 0 1
30941: PUSH
30942: LD_INT 6
30944: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30945: LD_VAR 0 6
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 2
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: LIST
30963: IN
30964: NOT
30965: PUSH
30966: LD_VAR 0 1
30970: PUSH
30971: LD_INT 0
30973: PUSH
30974: LD_INT 1
30976: PUSH
30977: LD_INT 2
30979: PUSH
30980: LD_INT 3
30982: PUSH
30983: LD_INT 6
30985: PUSH
30986: LD_INT 36
30988: PUSH
30989: LD_INT 4
30991: PUSH
30992: LD_INT 5
30994: PUSH
30995: LD_INT 31
30997: PUSH
30998: LD_INT 32
31000: PUSH
31001: LD_INT 33
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: IN
31017: NOT
31018: PUSH
31019: LD_VAR 0 6
31023: PUSH
31024: LD_INT 1
31026: EQUAL
31027: AND
31028: OR
31029: PUSH
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 2
31037: PUSH
31038: LD_INT 3
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: IN
31045: NOT
31046: PUSH
31047: LD_VAR 0 6
31051: PUSH
31052: LD_INT 2
31054: EQUAL
31055: AND
31056: OR
31057: IFFALSE 31067
// mode = 0 ;
31059: LD_ADDR_VAR 0 6
31063: PUSH
31064: LD_INT 0
31066: ST_TO_ADDR
// case mode of 0 :
31067: LD_VAR 0 6
31071: PUSH
31072: LD_INT 0
31074: DOUBLE
31075: EQUAL
31076: IFTRUE 31080
31078: GO 42533
31080: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31081: LD_ADDR_VAR 0 11
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: LD_INT 0
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 1
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: LD_INT 0
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 1
31139: NEG
31140: PUSH
31141: LD_INT 0
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 1
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 1
31162: NEG
31163: PUSH
31164: LD_INT 2
31166: NEG
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: LD_INT 2
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 0
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 1
31247: NEG
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31274: LD_ADDR_VAR 0 12
31278: PUSH
31279: LD_INT 0
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 0
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 0
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 1
31332: NEG
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 2
31397: NEG
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 2
31408: NEG
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 3
31431: NEG
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 3
31442: NEG
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31470: LD_ADDR_VAR 0 13
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: LD_INT 0
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 1
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: NEG
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: LD_INT 1
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 2
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: PUSH
31564: LD_INT 1
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: LD_INT 2
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 2
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 2
31593: NEG
31594: PUSH
31595: LD_INT 1
31597: NEG
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: LD_INT 2
31609: NEG
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 2
31617: NEG
31618: PUSH
31619: LD_INT 3
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 3
31629: NEG
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 3
31641: NEG
31642: PUSH
31643: LD_INT 3
31645: NEG
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31669: LD_ADDR_VAR 0 14
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 0
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: NEG
31728: PUSH
31729: LD_INT 0
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: LD_INT 2
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 1
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 2
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: NEG
31816: PUSH
31817: LD_INT 3
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: LD_INT 3
31830: NEG
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31865: LD_ADDR_VAR 0 15
31869: PUSH
31870: LD_INT 0
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 0
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 1
31923: NEG
31924: PUSH
31925: LD_INT 0
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 1
31934: NEG
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 2
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 2
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: NEG
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 3
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 3
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32058: LD_ADDR_VAR 0 16
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: NEG
32117: PUSH
32118: LD_INT 0
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 2
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 2
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: NEG
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 2
32193: NEG
32194: PUSH
32195: LD_INT 2
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 3
32205: PUSH
32206: LD_INT 2
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: LD_INT 3
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 2
32225: PUSH
32226: LD_INT 3
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32251: LD_ADDR_VAR 0 17
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 1
32309: NEG
32310: PUSH
32311: LD_INT 0
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 2
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 2
32438: NEG
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 2
32450: NEG
32451: PUSH
32452: LD_INT 2
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32481: LD_ADDR_VAR 0 18
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: LD_INT 1
32554: NEG
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 2
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 0
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 1
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 2
32616: PUSH
32617: LD_INT 2
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 2
32657: NEG
32658: PUSH
32659: LD_INT 0
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 2
32668: NEG
32669: PUSH
32670: LD_INT 1
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 2
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32711: LD_ADDR_VAR 0 19
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: NEG
32770: PUSH
32771: LD_INT 0
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: LD_INT 2
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 2
32807: NEG
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 1
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 2
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: NEG
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: NEG
32911: PUSH
32912: LD_INT 2
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32941: LD_ADDR_VAR 0 20
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 2
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: PUSH
33057: LD_INT 0
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 1
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: LD_INT 2
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: NEG
33118: PUSH
33119: LD_INT 0
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33171: LD_ADDR_VAR 0 21
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 0
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 0
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: PUSH
33297: LD_INT 1
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: LD_INT 2
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: NEG
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: NEG
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 2
33370: NEG
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33401: LD_ADDR_VAR 0 22
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: LD_INT 1
33421: NEG
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 0
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 1
33459: NEG
33460: PUSH
33461: LD_INT 0
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: LD_INT 1
33474: NEG
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: LD_INT 2
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: NEG
33578: PUSH
33579: LD_INT 0
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 2
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33631: LD_ADDR_VAR 0 23
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 1
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: LD_INT 1
33704: NEG
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: LD_INT 2
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: LD_INT 1
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: LD_INT 2
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: NEG
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 2
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 2
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 3
33846: NEG
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: NEG
33855: PUSH
33856: LD_INT 3
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: LD_INT 2
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33911: LD_ADDR_VAR 0 24
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 0
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 1
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: NEG
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: LD_INT 2
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 2
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 2
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: PUSH
34047: LD_INT 2
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 2
34110: NEG
34111: PUSH
34112: LD_INT 2
34114: NEG
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: LD_INT 2
34125: NEG
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 3
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 3
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34187: LD_ADDR_VAR 0 25
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 2
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 1
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: NEG
34364: PUSH
34365: LD_INT 0
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: NEG
34375: PUSH
34376: LD_INT 1
34378: NEG
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 2
34386: NEG
34387: PUSH
34388: LD_INT 2
34390: NEG
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 3
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 3
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: LD_INT 3
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: LD_INT 3
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34461: LD_ADDR_VAR 0 26
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: NEG
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 1
34542: NEG
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: LD_INT 2
34557: NEG
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: NEG
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 0
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: LD_INT 2
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 2
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 1
34626: NEG
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 2
34660: NEG
34661: PUSH
34662: LD_INT 2
34664: NEG
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: LD_INT 3
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PUSH
34701: LD_INT 2
34703: NEG
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 27
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 2
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: NEG
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 3
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 3
34982: NEG
34983: PUSH
34984: LD_INT 2
34986: NEG
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35017: LD_ADDR_VAR 0 28
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 0
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: LD_INT 1
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 2
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 2
35152: PUSH
35153: LD_INT 2
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: PUSH
35163: LD_INT 2
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: LD_INT 2
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 2
35193: NEG
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 2
35216: NEG
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: LD_INT 3
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 3
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35299: LD_ADDR_VAR 0 29
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: LD_INT 1
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: LD_INT 1
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 1
35357: NEG
35358: PUSH
35359: LD_INT 0
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: NEG
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 2
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 0
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 2
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 2
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 0
35444: PUSH
35445: LD_INT 2
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: LD_INT 1
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: NEG
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: LD_INT 3
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: LD_INT 1
35504: NEG
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 3
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: LD_INT 3
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 3
35543: NEG
35544: PUSH
35545: LD_INT 2
35547: NEG
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35578: LD_ADDR_VAR 0 30
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 1
35647: NEG
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 2
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 1
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: NEG
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: NEG
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 2
35755: NEG
35756: PUSH
35757: LD_INT 1
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 1
35767: NEG
35768: PUSH
35769: LD_INT 3
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 2
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 3
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: PUSH
35801: LD_INT 3
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: NEG
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 3
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35856: LD_ADDR_VAR 0 31
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: LD_INT 2
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 1
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: LD_INT 2
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 2
36021: NEG
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: LD_INT 2
36037: NEG
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: NEG
36046: PUSH
36047: LD_INT 3
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 1
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: LD_INT 1
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 1
36088: NEG
36089: PUSH
36090: LD_INT 2
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 3
36099: NEG
36100: PUSH
36101: LD_INT 2
36103: NEG
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36134: LD_ADDR_VAR 0 32
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 0
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: NEG
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: NEG
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 0
36227: PUSH
36228: LD_INT 2
36230: NEG
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 2
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 2
36300: NEG
36301: PUSH
36302: LD_INT 0
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 2
36311: NEG
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 1
36323: NEG
36324: PUSH
36325: LD_INT 3
36327: NEG
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 2
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 3
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 3
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36412: LD_ADDR_VAR 0 33
36416: PUSH
36417: LD_INT 0
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 1
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 0
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: LD_INT 1
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 2
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 2
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 1
36556: NEG
36557: PUSH
36558: LD_INT 1
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: NEG
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: LD_INT 2
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 3
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 3
36625: PUSH
36626: LD_INT 1
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: LD_INT 3
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: NEG
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36691: LD_ADDR_VAR 0 34
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 1
36760: NEG
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: LD_INT 2
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: LD_INT 2
36787: NEG
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 2
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 1
36836: NEG
36837: PUSH
36838: LD_INT 1
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 2
36847: NEG
36848: PUSH
36849: LD_INT 0
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: LD_INT 3
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: LD_INT 2
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 3
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 2
36915: PUSH
36916: LD_INT 3
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 2
36925: NEG
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 3
36936: NEG
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36971: LD_ADDR_VAR 0 35
36975: PUSH
36976: LD_INT 0
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 1
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 1
37029: NEG
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: LD_INT 1
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: NEG
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37083: LD_ADDR_VAR 0 36
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: LD_INT 0
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 1
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 0
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 1
37156: NEG
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37195: LD_ADDR_VAR 0 37
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 0
37212: PUSH
37213: LD_INT 1
37215: NEG
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 1
37223: PUSH
37224: LD_INT 0
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 1
37253: NEG
37254: PUSH
37255: LD_INT 0
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37307: LD_ADDR_VAR 0 38
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 1
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 1
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 1
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 0
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 1
37376: NEG
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37419: LD_ADDR_VAR 0 39
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 0
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: LD_INT 0
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 0
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37531: LD_ADDR_VAR 0 40
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: LD_INT 1
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: NEG
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 1
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37643: LD_ADDR_VAR 0 41
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 1
37663: NEG
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: NEG
37725: PUSH
37726: LD_INT 2
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 2
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 2
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: PUSH
37768: LD_INT 2
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: PUSH
37778: LD_INT 2
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: LD_INT 2
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 3
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: PUSH
37857: LD_INT 0
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 3
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 3
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 3
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 2
37896: PUSH
37897: LD_INT 3
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 3
37917: NEG
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 2
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 3
37952: NEG
37953: PUSH
37954: LD_INT 3
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37993: LD_ADDR_VAR 0 42
37997: PUSH
37998: LD_INT 0
38000: PUSH
38001: LD_INT 0
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: LD_INT 1
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: LD_INT 0
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: LD_INT 1
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 0
38041: PUSH
38042: LD_INT 1
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 1
38062: NEG
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: LD_INT 2
38078: NEG
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 2
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 1
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 2
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 2
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 2
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 2
38171: NEG
38172: PUSH
38173: LD_INT 2
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: LD_INT 3
38187: NEG
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 1
38195: NEG
38196: PUSH
38197: LD_INT 3
38199: NEG
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: LD_INT 3
38210: NEG
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 1
38218: PUSH
38219: LD_INT 2
38221: NEG
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 3
38229: PUSH
38230: LD_INT 2
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 3
38239: PUSH
38240: LD_INT 3
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 2
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: LD_INT 3
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 3
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38343: LD_ADDR_VAR 0 43
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 1
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 1
38498: NEG
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 3
38536: NEG
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 0
38544: PUSH
38545: LD_INT 3
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: LD_INT 2
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: LD_INT 1
38569: NEG
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 3
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 3
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 3
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 3
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 2
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 3
38639: NEG
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38691: LD_ADDR_VAR 0 44
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: PUSH
38720: LD_INT 0
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 1
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: LD_INT 1
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 2
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 2
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: PUSH
38816: LD_INT 2
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: LD_INT 2
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 2
38846: NEG
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 2
38857: NEG
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: LD_INT 2
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: NEG
38882: PUSH
38883: LD_INT 3
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: LD_INT 3
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 2
38944: PUSH
38945: LD_INT 3
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: NEG
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 3
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 3
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 3
38988: NEG
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: NEG
39001: PUSH
39002: LD_INT 3
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39041: LD_ADDR_VAR 0 45
39045: PUSH
39046: LD_INT 0
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: LD_INT 1
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 1
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 1
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 1
39099: NEG
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 1
39110: NEG
39111: PUSH
39112: LD_INT 1
39114: NEG
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 1
39122: NEG
39123: PUSH
39124: LD_INT 2
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 0
39134: PUSH
39135: LD_INT 2
39137: NEG
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 1
39145: PUSH
39146: LD_INT 1
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 2
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 2
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 1
39196: NEG
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 2
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 3
39247: NEG
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 0
39255: PUSH
39256: LD_INT 3
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 1
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 3
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 3
39287: PUSH
39288: LD_INT 3
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: PUSH
39298: LD_INT 3
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: LD_INT 3
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 3
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 2
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 3
39338: NEG
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 3
39350: NEG
39351: PUSH
39352: LD_INT 3
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39391: LD_ADDR_VAR 0 46
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: LD_INT 1
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 1
39472: NEG
39473: PUSH
39474: LD_INT 2
39476: NEG
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 2
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: LD_INT 1
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 2
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 2
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: LD_INT 2
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 1
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 2
39557: NEG
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 2
39568: NEG
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 1
39580: NEG
39581: PUSH
39582: LD_INT 3
39584: NEG
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: LD_INT 3
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: LD_INT 2
39606: NEG
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 2
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 3
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 3
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 1
39665: NEG
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 2
39676: NEG
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: LD_INT 0
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 3
39698: NEG
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39739: LD_ADDR_VAR 0 47
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 1
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 1
39808: NEG
39809: PUSH
39810: LD_INT 1
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: NEG
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: NEG
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 2
39866: NEG
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39890: LD_ADDR_VAR 0 48
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: LD_INT 0
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 0
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 1
39918: PUSH
39919: LD_INT 0
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 1
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 1
39971: NEG
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 2
39986: NEG
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 2
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 2
40015: PUSH
40016: LD_INT 1
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40037: LD_ADDR_VAR 0 49
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 1
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 2
40129: PUSH
40130: LD_INT 0
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 2
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: LD_INT 2
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: LD_INT 2
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40181: LD_ADDR_VAR 0 50
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 1
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: LD_INT 1
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 1
40239: NEG
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: LD_INT 1
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 2
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: LD_INT 2
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 0
40292: PUSH
40293: LD_INT 2
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: NEG
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40325: LD_ADDR_VAR 0 51
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 1
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 2
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 2
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 2
40448: NEG
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40472: LD_ADDR_VAR 0 52
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 1
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 1
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 1
40553: NEG
40554: PUSH
40555: LD_INT 2
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: NEG
40566: PUSH
40567: LD_INT 1
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: NEG
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: LD_INT 1
40591: NEG
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 2
40599: NEG
40600: PUSH
40601: LD_INT 2
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40623: LD_ADDR_VAR 0 53
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: LD_INT 0
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 1
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 1
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: NEG
40682: PUSH
40683: LD_INT 0
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 1
40692: NEG
40693: PUSH
40694: LD_INT 1
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: PUSH
40739: LD_INT 0
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: PUSH
40749: LD_INT 1
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 2
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: LD_INT 2
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 0
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 1
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 2
40822: NEG
40823: PUSH
40824: LD_INT 2
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40853: LD_ADDR_VAR 0 54
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 1
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 1
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: LD_INT 1
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 1
40911: NEG
40912: PUSH
40913: LD_INT 0
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 1
40922: NEG
40923: PUSH
40924: LD_INT 1
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 1
40934: NEG
40935: PUSH
40936: LD_INT 2
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 0
40946: PUSH
40947: LD_INT 2
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 1
40957: PUSH
40958: LD_INT 1
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 2
40968: PUSH
40969: LD_INT 0
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 2
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 2
41029: NEG
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 2
41040: NEG
41041: PUSH
41042: LD_INT 1
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: LD_INT 2
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41083: LD_ADDR_VAR 0 55
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 1
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 1
41111: PUSH
41112: LD_INT 0
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 0
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: NEG
41153: PUSH
41154: LD_INT 1
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 2
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 2
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 2
41208: PUSH
41209: LD_INT 1
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: LD_INT 2
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 1
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 2
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: NEG
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 2
41259: NEG
41260: PUSH
41261: LD_INT 0
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 2
41270: NEG
41271: PUSH
41272: LD_INT 1
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: NEG
41283: PUSH
41284: LD_INT 2
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41313: LD_ADDR_VAR 0 56
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 0
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 1
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: LD_INT 2
41409: NEG
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: LD_INT 1
41420: NEG
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: LD_INT 1
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 0
41468: PUSH
41469: LD_INT 2
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 2
41489: NEG
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 2
41500: NEG
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: LD_INT 2
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41543: LD_ADDR_VAR 0 57
41547: PUSH
41548: LD_INT 0
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 0
41560: PUSH
41561: LD_INT 1
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: LD_INT 1
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 0
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 1
41601: NEG
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 1
41612: NEG
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 1
41624: NEG
41625: PUSH
41626: LD_INT 2
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 0
41636: PUSH
41637: LD_INT 2
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: LD_INT 1
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 2
41658: PUSH
41659: LD_INT 0
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 2
41668: PUSH
41669: LD_INT 1
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 2
41678: PUSH
41679: LD_INT 2
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 0
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 1
41708: NEG
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: LD_INT 0
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 2
41730: NEG
41731: PUSH
41732: LD_INT 1
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 2
41742: NEG
41743: PUSH
41744: LD_INT 2
41746: NEG
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41773: LD_ADDR_VAR 0 58
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: LD_INT 0
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 1
41793: NEG
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: LD_INT 0
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 1
41811: PUSH
41812: LD_INT 1
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 0
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 1
41831: NEG
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 1
41842: NEG
41843: PUSH
41844: LD_INT 1
41846: NEG
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: LD_INT 2
41858: NEG
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 0
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 1
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 2
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: LD_INT 1
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 2
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 1
41918: PUSH
41919: LD_INT 2
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: LD_INT 2
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: LD_INT 1
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 2
41949: NEG
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 2
41960: NEG
41961: PUSH
41962: LD_INT 1
41964: NEG
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 2
41972: NEG
41973: PUSH
41974: LD_INT 2
41976: NEG
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: LIST
41986: LIST
41987: LIST
41988: LIST
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42003: LD_ADDR_VAR 0 59
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: LD_INT 1
42023: NEG
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 1
42041: PUSH
42042: LD_INT 1
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 0
42051: PUSH
42052: LD_INT 1
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: NEG
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: LD_INT 1
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42091: LD_ADDR_VAR 0 60
42095: PUSH
42096: LD_INT 0
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: LD_INT 1
42111: NEG
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: LD_INT 0
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: LD_INT 1
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 1
42149: NEG
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: LD_INT 1
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42179: LD_ADDR_VAR 0 61
42183: PUSH
42184: LD_INT 0
42186: PUSH
42187: LD_INT 0
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 1
42207: PUSH
42208: LD_INT 0
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: PUSH
42218: LD_INT 1
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 1
42237: NEG
42238: PUSH
42239: LD_INT 0
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: LD_INT 1
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42267: LD_ADDR_VAR 0 62
42271: PUSH
42272: LD_INT 0
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 0
42284: PUSH
42285: LD_INT 1
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: LD_INT 1
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 0
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: LD_INT 1
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42355: LD_ADDR_VAR 0 63
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 0
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: LD_INT 0
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 0
42403: PUSH
42404: LD_INT 1
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 0
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: LD_INT 1
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42443: LD_ADDR_VAR 0 64
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 1
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: NEG
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: LD_INT 1
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// end ; 1 :
42531: GO 48428
42533: LD_INT 1
42535: DOUBLE
42536: EQUAL
42537: IFTRUE 42541
42539: GO 45164
42541: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42542: LD_ADDR_VAR 0 11
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: LD_INT 3
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: LIST
42585: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42586: LD_ADDR_VAR 0 12
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 1
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 3
42614: PUSH
42615: LD_INT 1
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42627: LD_ADDR_VAR 0 13
42631: PUSH
42632: LD_INT 3
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 3
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 2
42654: PUSH
42655: LD_INT 3
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42667: LD_ADDR_VAR 0 14
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: LD_INT 3
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 1
42694: NEG
42695: PUSH
42696: LD_INT 2
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42708: LD_ADDR_VAR 0 15
42712: PUSH
42713: LD_INT 2
42715: NEG
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: NEG
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 3
42737: NEG
42738: PUSH
42739: LD_INT 1
42741: NEG
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42752: LD_ADDR_VAR 0 16
42756: PUSH
42757: LD_INT 2
42759: NEG
42760: PUSH
42761: LD_INT 3
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 3
42771: NEG
42772: PUSH
42773: LD_INT 2
42775: NEG
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: NEG
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: LIST
42797: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42798: LD_ADDR_VAR 0 17
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: LD_INT 3
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: LIST
42841: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42842: LD_ADDR_VAR 0 18
42846: PUSH
42847: LD_INT 2
42849: PUSH
42850: LD_INT 1
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: LIST
42882: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42883: LD_ADDR_VAR 0 19
42887: PUSH
42888: LD_INT 3
42890: PUSH
42891: LD_INT 2
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 2
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42923: LD_ADDR_VAR 0 20
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 3
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 2
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42964: LD_ADDR_VAR 0 21
42968: PUSH
42969: LD_INT 2
42971: NEG
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 3
42982: NEG
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43008: LD_ADDR_VAR 0 22
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: LD_INT 3
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 3
43027: NEG
43028: PUSH
43029: LD_INT 2
43031: NEG
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: NEG
43040: PUSH
43041: LD_INT 3
43043: NEG
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: LIST
43053: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43054: LD_ADDR_VAR 0 23
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 3
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 1
43072: NEG
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: LD_INT 3
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: LIST
43097: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43098: LD_ADDR_VAR 0 24
43102: PUSH
43103: LD_INT 3
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 3
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 4
43126: PUSH
43127: LD_INT 1
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: LIST
43138: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43139: LD_ADDR_VAR 0 25
43143: PUSH
43144: LD_INT 3
43146: PUSH
43147: LD_INT 3
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 3
43166: PUSH
43167: LD_INT 4
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43179: LD_ADDR_VAR 0 26
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: LD_INT 4
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: LD_INT 3
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: LIST
43219: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43220: LD_ADDR_VAR 0 27
43224: PUSH
43225: LD_INT 3
43227: NEG
43228: PUSH
43229: LD_INT 0
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 1
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 4
43249: NEG
43250: PUSH
43251: LD_INT 1
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43264: LD_ADDR_VAR 0 28
43268: PUSH
43269: LD_INT 3
43271: NEG
43272: PUSH
43273: LD_INT 3
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 3
43283: NEG
43284: PUSH
43285: LD_INT 4
43287: NEG
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: LD_INT 4
43295: NEG
43296: PUSH
43297: LD_INT 3
43299: NEG
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43310: LD_ADDR_VAR 0 29
43314: PUSH
43315: LD_INT 1
43317: NEG
43318: PUSH
43319: LD_INT 3
43321: NEG
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: LD_INT 3
43332: NEG
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PUSH
43338: LD_INT 1
43340: PUSH
43341: LD_INT 2
43343: NEG
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 4
43355: NEG
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 0
43363: PUSH
43364: LD_INT 4
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 3
43377: NEG
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: NEG
43386: PUSH
43387: LD_INT 5
43389: NEG
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 0
43397: PUSH
43398: LD_INT 5
43400: NEG
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: LD_INT 4
43411: NEG
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 1
43419: NEG
43420: PUSH
43421: LD_INT 6
43423: NEG
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 0
43431: PUSH
43432: LD_INT 6
43434: NEG
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 1
43442: PUSH
43443: LD_INT 5
43445: NEG
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43465: LD_ADDR_VAR 0 30
43469: PUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 1
43475: NEG
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 3
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: LD_INT 1
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: PUSH
43504: LD_INT 1
43506: NEG
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 0
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 4
43534: PUSH
43535: LD_INT 1
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 5
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 5
43555: PUSH
43556: LD_INT 1
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 5
43565: PUSH
43566: LD_INT 1
43568: NEG
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 6
43576: PUSH
43577: LD_INT 0
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 6
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43608: LD_ADDR_VAR 0 31
43612: PUSH
43613: LD_INT 3
43615: PUSH
43616: LD_INT 2
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: LD_INT 3
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 2
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: PUSH
43646: LD_INT 3
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 4
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: LD_INT 4
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 5
43675: PUSH
43676: LD_INT 4
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 5
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 4
43695: PUSH
43696: LD_INT 5
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 6
43705: PUSH
43706: LD_INT 5
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 6
43715: PUSH
43716: LD_INT 6
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 5
43725: PUSH
43726: LD_INT 6
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43747: LD_ADDR_VAR 0 32
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 0
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 1
43774: NEG
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 1
43785: PUSH
43786: LD_INT 4
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 0
43795: PUSH
43796: LD_INT 4
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 1
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: PUSH
43817: LD_INT 5
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 0
43826: PUSH
43827: LD_INT 5
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 1
43836: NEG
43837: PUSH
43838: LD_INT 4
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 6
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 6
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 1
43867: NEG
43868: PUSH
43869: LD_INT 5
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43890: LD_ADDR_VAR 0 33
43894: PUSH
43895: LD_INT 2
43897: NEG
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 3
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 3
43931: NEG
43932: PUSH
43933: LD_INT 1
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 4
43942: NEG
43943: PUSH
43944: LD_INT 0
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 4
43953: NEG
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 4
43965: NEG
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 5
43976: NEG
43977: PUSH
43978: LD_INT 0
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 5
43987: NEG
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 5
43999: NEG
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 6
44010: NEG
44011: PUSH
44012: LD_INT 0
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 6
44021: NEG
44022: PUSH
44023: LD_INT 1
44025: NEG
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: LIST
44035: LIST
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: LIST
44043: LIST
44044: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44045: LD_ADDR_VAR 0 34
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: LD_INT 3
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: LD_INT 2
44068: NEG
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: LD_INT 3
44076: NEG
44077: PUSH
44078: LD_INT 3
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 3
44088: NEG
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 4
44100: NEG
44101: PUSH
44102: LD_INT 3
44104: NEG
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: NEG
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 4
44124: NEG
44125: PUSH
44126: LD_INT 5
44128: NEG
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 5
44136: NEG
44137: PUSH
44138: LD_INT 4
44140: NEG
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 5
44148: NEG
44149: PUSH
44150: LD_INT 5
44152: NEG
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 5
44160: NEG
44161: PUSH
44162: LD_INT 6
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 6
44172: NEG
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 6
44184: NEG
44185: PUSH
44186: LD_INT 6
44188: NEG
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: LIST
44203: LIST
44204: LIST
44205: LIST
44206: LIST
44207: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44208: LD_ADDR_VAR 0 41
44212: PUSH
44213: LD_INT 0
44215: PUSH
44216: LD_INT 2
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: LD_INT 3
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: LD_INT 2
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44252: LD_ADDR_VAR 0 42
44256: PUSH
44257: LD_INT 2
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 2
44269: PUSH
44270: LD_INT 1
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 3
44280: PUSH
44281: LD_INT 1
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: LIST
44292: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44293: LD_ADDR_VAR 0 43
44297: PUSH
44298: LD_INT 2
44300: PUSH
44301: LD_INT 2
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 3
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 3
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44333: LD_ADDR_VAR 0 44
44337: PUSH
44338: LD_INT 0
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 1
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 2
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44374: LD_ADDR_VAR 0 45
44378: PUSH
44379: LD_INT 2
44381: NEG
44382: PUSH
44383: LD_INT 0
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 2
44392: NEG
44393: PUSH
44394: LD_INT 1
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 3
44403: NEG
44404: PUSH
44405: LD_INT 1
44407: NEG
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: LIST
44417: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44418: LD_ADDR_VAR 0 46
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: LD_INT 2
44429: NEG
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 2
44437: NEG
44438: PUSH
44439: LD_INT 3
44441: NEG
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 3
44449: NEG
44450: PUSH
44451: LD_INT 2
44453: NEG
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: LIST
44463: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44464: LD_ADDR_VAR 0 47
44468: PUSH
44469: LD_INT 2
44471: NEG
44472: PUSH
44473: LD_INT 3
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 3
44487: NEG
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44497: LD_ADDR_VAR 0 48
44501: PUSH
44502: LD_INT 1
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 1
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44528: LD_ADDR_VAR 0 49
44532: PUSH
44533: LD_INT 3
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: LD_INT 2
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44557: LD_ADDR_VAR 0 50
44561: PUSH
44562: LD_INT 2
44564: PUSH
44565: LD_INT 3
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 1
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44586: LD_ADDR_VAR 0 51
44590: PUSH
44591: LD_INT 1
44593: NEG
44594: PUSH
44595: LD_INT 2
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 2
44604: NEG
44605: PUSH
44606: LD_INT 1
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44617: LD_ADDR_VAR 0 52
44621: PUSH
44622: LD_INT 3
44624: NEG
44625: PUSH
44626: LD_INT 1
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 3
44636: NEG
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44650: LD_ADDR_VAR 0 53
44654: PUSH
44655: LD_INT 1
44657: NEG
44658: PUSH
44659: LD_INT 3
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: LD_INT 3
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 1
44680: PUSH
44681: LD_INT 2
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: LIST
44693: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44694: LD_ADDR_VAR 0 54
44698: PUSH
44699: LD_INT 2
44701: PUSH
44702: LD_INT 1
44704: NEG
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 3
44712: PUSH
44713: LD_INT 0
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: LD_INT 1
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: LIST
44734: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44735: LD_ADDR_VAR 0 55
44739: PUSH
44740: LD_INT 3
44742: PUSH
44743: LD_INT 2
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 3
44752: PUSH
44753: LD_INT 3
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 2
44762: PUSH
44763: LD_INT 3
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: LIST
44774: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44775: LD_ADDR_VAR 0 56
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 1
44802: NEG
44803: PUSH
44804: LD_INT 2
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44816: LD_ADDR_VAR 0 57
44820: PUSH
44821: LD_INT 2
44823: NEG
44824: PUSH
44825: LD_INT 1
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 3
44834: NEG
44835: PUSH
44836: LD_INT 0
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 3
44845: NEG
44846: PUSH
44847: LD_INT 1
44849: NEG
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: LIST
44859: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44860: LD_ADDR_VAR 0 58
44864: PUSH
44865: LD_INT 2
44867: NEG
44868: PUSH
44869: LD_INT 3
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: NEG
44880: PUSH
44881: LD_INT 2
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 3
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44906: LD_ADDR_VAR 0 59
44910: PUSH
44911: LD_INT 1
44913: NEG
44914: PUSH
44915: LD_INT 2
44917: NEG
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 1
44936: PUSH
44937: LD_INT 1
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: LIST
44949: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44950: LD_ADDR_VAR 0 60
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 2
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 2
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: LIST
44990: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44991: LD_ADDR_VAR 0 61
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: LD_INT 1
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 2
45008: PUSH
45009: LD_INT 2
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 1
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45031: LD_ADDR_VAR 0 62
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 2
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 2
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: LIST
45071: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45072: LD_ADDR_VAR 0 63
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 2
45090: NEG
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 2
45101: NEG
45102: PUSH
45103: LD_INT 1
45105: NEG
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: LIST
45115: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45116: LD_ADDR_VAR 0 64
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: NEG
45136: PUSH
45137: LD_INT 1
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 2
45147: NEG
45148: PUSH
45149: LD_INT 2
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: LIST
45161: ST_TO_ADDR
// end ; 2 :
45162: GO 48428
45164: LD_INT 2
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45172
45170: GO 48427
45172: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45173: LD_ADDR_VAR 0 29
45177: PUSH
45178: LD_INT 4
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 5
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 5
45211: PUSH
45212: LD_INT 1
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 4
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 3
45231: PUSH
45232: LD_INT 0
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: PUSH
45242: LD_INT 1
45244: NEG
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: LD_INT 2
45255: NEG
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 5
45263: PUSH
45264: LD_INT 2
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 3
45273: PUSH
45274: LD_INT 3
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 2
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 4
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 4
45303: PUSH
45304: LD_INT 4
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 2
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: PUSH
45331: LD_INT 2
45333: PUSH
45334: LD_INT 2
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 4
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: PUSH
45351: LD_INT 2
45353: PUSH
45354: LD_INT 4
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 0
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 0
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 1
45383: PUSH
45384: LD_INT 4
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: LD_INT 5
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 0
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 1
45413: NEG
45414: PUSH
45415: LD_INT 4
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 1
45424: NEG
45425: PUSH
45426: LD_INT 3
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 2
45435: PUSH
45436: LD_INT 5
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 2
45445: NEG
45446: PUSH
45447: LD_INT 3
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 3
45456: NEG
45457: PUSH
45458: LD_INT 0
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: NEG
45468: PUSH
45469: LD_INT 1
45471: NEG
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PUSH
45477: LD_INT 2
45479: NEG
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 2
45490: NEG
45491: PUSH
45492: LD_INT 1
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 3
45501: NEG
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 4
45512: NEG
45513: PUSH
45514: LD_INT 0
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 4
45523: NEG
45524: PUSH
45525: LD_INT 1
45527: NEG
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: PUSH
45533: LD_INT 4
45535: NEG
45536: PUSH
45537: LD_INT 2
45539: NEG
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 2
45547: NEG
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 4
45558: NEG
45559: PUSH
45560: LD_INT 4
45562: NEG
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: PUSH
45568: LD_INT 4
45570: NEG
45571: PUSH
45572: LD_INT 5
45574: NEG
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 3
45582: NEG
45583: PUSH
45584: LD_INT 4
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: LD_INT 3
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 4
45606: NEG
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 5
45618: NEG
45619: PUSH
45620: LD_INT 4
45622: NEG
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 5
45630: NEG
45631: PUSH
45632: LD_INT 5
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 3
45642: NEG
45643: PUSH
45644: LD_INT 5
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: LD_INT 3
45658: NEG
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45711: LD_ADDR_VAR 0 30
45715: PUSH
45716: LD_INT 4
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 4
45728: PUSH
45729: LD_INT 3
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 5
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 5
45748: PUSH
45749: LD_INT 5
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 4
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 3
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 5
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 3
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 3
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 0
45818: PUSH
45819: LD_INT 2
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 0
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 1
45858: NEG
45859: PUSH
45860: LD_INT 3
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 1
45869: NEG
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 2
45880: PUSH
45881: LD_INT 4
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 2
45890: NEG
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 4
45901: NEG
45902: PUSH
45903: LD_INT 0
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 4
45912: NEG
45913: PUSH
45914: LD_INT 1
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 3
45924: NEG
45925: PUSH
45926: LD_INT 0
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 3
45935: NEG
45936: PUSH
45937: LD_INT 1
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: NEG
45947: PUSH
45948: LD_INT 1
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 5
45957: NEG
45958: PUSH
45959: LD_INT 0
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 5
45968: NEG
45969: PUSH
45970: LD_INT 1
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 5
45980: NEG
45981: PUSH
45982: LD_INT 2
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 3
45992: NEG
45993: PUSH
45994: LD_INT 2
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 3
46003: NEG
46004: PUSH
46005: LD_INT 3
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: NEG
46016: PUSH
46017: LD_INT 4
46019: NEG
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: LD_INT 2
46027: NEG
46028: PUSH
46029: LD_INT 3
46031: NEG
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 2
46039: NEG
46040: PUSH
46041: LD_INT 2
46043: NEG
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 3
46051: NEG
46052: PUSH
46053: LD_INT 2
46055: NEG
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 4
46063: NEG
46064: PUSH
46065: LD_INT 3
46067: NEG
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 2
46087: NEG
46088: PUSH
46089: LD_INT 4
46091: NEG
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 4
46099: NEG
46100: PUSH
46101: LD_INT 2
46103: NEG
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: PUSH
46109: LD_INT 0
46111: PUSH
46112: LD_INT 4
46114: NEG
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 0
46122: PUSH
46123: LD_INT 5
46125: NEG
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: LD_INT 4
46136: NEG
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 1
46144: PUSH
46145: LD_INT 3
46147: NEG
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 0
46155: PUSH
46156: LD_INT 3
46158: NEG
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: LD_INT 4
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 1
46178: NEG
46179: PUSH
46180: LD_INT 5
46182: NEG
46183: PUSH
46184: EMPTY
46185: LIST
46186: LIST
46187: PUSH
46188: LD_INT 2
46190: PUSH
46191: LD_INT 3
46193: NEG
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 2
46201: NEG
46202: PUSH
46203: LD_INT 5
46205: NEG
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46258: LD_ADDR_VAR 0 31
46262: PUSH
46263: LD_INT 0
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 1
46285: PUSH
46286: LD_INT 4
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 1
46295: PUSH
46296: LD_INT 5
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 0
46305: PUSH
46306: LD_INT 5
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 1
46315: NEG
46316: PUSH
46317: LD_INT 4
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 1
46326: NEG
46327: PUSH
46328: LD_INT 3
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 2
46337: PUSH
46338: LD_INT 5
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 2
46347: NEG
46348: PUSH
46349: LD_INT 3
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 3
46358: NEG
46359: PUSH
46360: LD_INT 0
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: PUSH
46367: LD_INT 3
46369: NEG
46370: PUSH
46371: LD_INT 1
46373: NEG
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 2
46381: NEG
46382: PUSH
46383: LD_INT 0
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 2
46392: NEG
46393: PUSH
46394: LD_INT 1
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 3
46403: NEG
46404: PUSH
46405: LD_INT 1
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 4
46414: NEG
46415: PUSH
46416: LD_INT 0
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 4
46425: NEG
46426: PUSH
46427: LD_INT 1
46429: NEG
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 4
46437: NEG
46438: PUSH
46439: LD_INT 2
46441: NEG
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: LD_INT 2
46449: NEG
46450: PUSH
46451: LD_INT 2
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 4
46460: NEG
46461: PUSH
46462: LD_INT 4
46464: NEG
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 4
46472: NEG
46473: PUSH
46474: LD_INT 5
46476: NEG
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 3
46484: NEG
46485: PUSH
46486: LD_INT 4
46488: NEG
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 3
46496: NEG
46497: PUSH
46498: LD_INT 3
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 4
46508: NEG
46509: PUSH
46510: LD_INT 3
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 5
46520: NEG
46521: PUSH
46522: LD_INT 4
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 5
46532: NEG
46533: PUSH
46534: LD_INT 5
46536: NEG
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: LD_INT 3
46544: NEG
46545: PUSH
46546: LD_INT 5
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 5
46556: NEG
46557: PUSH
46558: LD_INT 3
46560: NEG
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PUSH
46566: LD_INT 0
46568: PUSH
46569: LD_INT 3
46571: NEG
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 0
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 1
46590: PUSH
46591: LD_INT 3
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 2
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 0
46612: PUSH
46613: LD_INT 2
46615: NEG
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: PUSH
46621: LD_INT 1
46623: NEG
46624: PUSH
46625: LD_INT 3
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: NEG
46636: PUSH
46637: LD_INT 4
46639: NEG
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_INT 2
46647: PUSH
46648: LD_INT 2
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 2
46658: NEG
46659: PUSH
46660: LD_INT 4
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 4
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 4
46680: PUSH
46681: LD_INT 1
46683: NEG
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 5
46691: PUSH
46692: LD_INT 0
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 5
46701: PUSH
46702: LD_INT 1
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 4
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 0
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 1
46734: NEG
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 3
46742: PUSH
46743: LD_INT 2
46745: NEG
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 5
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46808: LD_ADDR_VAR 0 32
46812: PUSH
46813: LD_INT 4
46815: NEG
46816: PUSH
46817: LD_INT 0
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 4
46826: NEG
46827: PUSH
46828: LD_INT 1
46830: NEG
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 3
46838: NEG
46839: PUSH
46840: LD_INT 0
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 1
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 4
46860: NEG
46861: PUSH
46862: LD_INT 1
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 5
46871: NEG
46872: PUSH
46873: LD_INT 0
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 5
46882: NEG
46883: PUSH
46884: LD_INT 1
46886: NEG
46887: PUSH
46888: EMPTY
46889: LIST
46890: LIST
46891: PUSH
46892: LD_INT 5
46894: NEG
46895: PUSH
46896: LD_INT 2
46898: NEG
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 3
46906: NEG
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 3
46917: NEG
46918: PUSH
46919: LD_INT 3
46921: NEG
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 3
46929: NEG
46930: PUSH
46931: LD_INT 4
46933: NEG
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 2
46941: NEG
46942: PUSH
46943: LD_INT 3
46945: NEG
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 2
46953: NEG
46954: PUSH
46955: LD_INT 2
46957: NEG
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 3
46965: NEG
46966: PUSH
46967: LD_INT 2
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 4
46977: NEG
46978: PUSH
46979: LD_INT 3
46981: NEG
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 4
46989: NEG
46990: PUSH
46991: LD_INT 4
46993: NEG
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 2
47001: NEG
47002: PUSH
47003: LD_INT 4
47005: NEG
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 4
47013: NEG
47014: PUSH
47015: LD_INT 2
47017: NEG
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 0
47025: PUSH
47026: LD_INT 4
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 5
47039: NEG
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 1
47047: PUSH
47048: LD_INT 4
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: PUSH
47059: LD_INT 3
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 0
47069: PUSH
47070: LD_INT 3
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 1
47080: NEG
47081: PUSH
47082: LD_INT 4
47084: NEG
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: LD_INT 1
47092: NEG
47093: PUSH
47094: LD_INT 5
47096: NEG
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 2
47104: PUSH
47105: LD_INT 3
47107: NEG
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 2
47115: NEG
47116: PUSH
47117: LD_INT 5
47119: NEG
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 3
47127: PUSH
47128: LD_INT 0
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: LD_INT 1
47140: NEG
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 4
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 4
47158: PUSH
47159: LD_INT 1
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 3
47168: PUSH
47169: LD_INT 1
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 2
47178: PUSH
47179: LD_INT 0
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 2
47188: PUSH
47189: LD_INT 1
47191: NEG
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: LD_INT 2
47202: NEG
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 4
47210: PUSH
47211: LD_INT 2
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 4
47220: PUSH
47221: LD_INT 4
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 4
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 5
47240: PUSH
47241: LD_INT 4
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 5
47250: PUSH
47251: LD_INT 5
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 4
47260: PUSH
47261: LD_INT 5
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 3
47270: PUSH
47271: LD_INT 4
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: LD_INT 3
47280: PUSH
47281: LD_INT 3
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 5
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 3
47300: PUSH
47301: LD_INT 5
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: LIST
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47355: LD_ADDR_VAR 0 33
47359: PUSH
47360: LD_INT 4
47362: NEG
47363: PUSH
47364: LD_INT 4
47366: NEG
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 4
47374: NEG
47375: PUSH
47376: LD_INT 5
47378: NEG
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 3
47386: NEG
47387: PUSH
47388: LD_INT 4
47390: NEG
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 3
47398: NEG
47399: PUSH
47400: LD_INT 3
47402: NEG
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 4
47410: NEG
47411: PUSH
47412: LD_INT 3
47414: NEG
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: PUSH
47420: LD_INT 5
47422: NEG
47423: PUSH
47424: LD_INT 4
47426: NEG
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 5
47434: NEG
47435: PUSH
47436: LD_INT 5
47438: NEG
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: LD_INT 5
47450: NEG
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 5
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 3
47473: NEG
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: PUSH
47479: LD_INT 0
47481: PUSH
47482: LD_INT 4
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 1
47492: PUSH
47493: LD_INT 3
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 1
47503: PUSH
47504: LD_INT 2
47506: NEG
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: LD_INT 0
47514: PUSH
47515: LD_INT 2
47517: NEG
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: LD_INT 1
47525: NEG
47526: PUSH
47527: LD_INT 3
47529: NEG
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 1
47537: NEG
47538: PUSH
47539: LD_INT 4
47541: NEG
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 2
47552: NEG
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 2
47560: NEG
47561: PUSH
47562: LD_INT 4
47564: NEG
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 4
47572: PUSH
47573: LD_INT 0
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 4
47582: PUSH
47583: LD_INT 1
47585: NEG
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 5
47593: PUSH
47594: LD_INT 0
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 5
47603: PUSH
47604: LD_INT 1
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: LD_INT 4
47613: PUSH
47614: LD_INT 1
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 3
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 3
47633: PUSH
47634: LD_INT 1
47636: NEG
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 3
47644: PUSH
47645: LD_INT 2
47647: NEG
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: LD_INT 5
47655: PUSH
47656: LD_INT 2
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 3
47665: PUSH
47666: LD_INT 3
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 3
47675: PUSH
47676: LD_INT 2
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 3
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 4
47695: PUSH
47696: LD_INT 4
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 4
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 2
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 2
47725: PUSH
47726: LD_INT 2
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 4
47735: PUSH
47736: LD_INT 2
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 4
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 0
47755: PUSH
47756: LD_INT 4
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 0
47765: PUSH
47766: LD_INT 3
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 1
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 1
47785: PUSH
47786: LD_INT 5
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 5
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: NEG
47806: PUSH
47807: LD_INT 4
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 1
47816: NEG
47817: PUSH
47818: LD_INT 3
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: LD_INT 5
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: LD_INT 2
47837: NEG
47838: PUSH
47839: LD_INT 3
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47893: LD_ADDR_VAR 0 34
47897: PUSH
47898: LD_INT 0
47900: PUSH
47901: LD_INT 4
47903: NEG
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 0
47911: PUSH
47912: LD_INT 5
47914: NEG
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 1
47922: PUSH
47923: LD_INT 4
47925: NEG
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 1
47933: PUSH
47934: LD_INT 3
47936: NEG
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: LD_INT 0
47944: PUSH
47945: LD_INT 3
47947: NEG
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: LD_INT 1
47955: NEG
47956: PUSH
47957: LD_INT 4
47959: NEG
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: PUSH
47965: LD_INT 1
47967: NEG
47968: PUSH
47969: LD_INT 5
47971: NEG
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 2
47979: PUSH
47980: LD_INT 3
47982: NEG
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 2
47990: NEG
47991: PUSH
47992: LD_INT 5
47994: NEG
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: PUSH
48000: LD_INT 3
48002: PUSH
48003: LD_INT 0
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: LD_INT 1
48015: NEG
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 4
48023: PUSH
48024: LD_INT 0
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 4
48033: PUSH
48034: LD_INT 1
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: LD_INT 3
48043: PUSH
48044: LD_INT 1
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 2
48053: PUSH
48054: LD_INT 0
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 2
48063: PUSH
48064: LD_INT 1
48066: NEG
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PUSH
48072: LD_INT 2
48074: PUSH
48075: LD_INT 2
48077: NEG
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: LD_INT 2
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_INT 4
48095: PUSH
48096: LD_INT 4
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 5
48115: PUSH
48116: LD_INT 4
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 5
48125: PUSH
48126: LD_INT 5
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 4
48135: PUSH
48136: LD_INT 5
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 3
48145: PUSH
48146: LD_INT 4
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: LD_INT 3
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: LD_INT 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 3
48175: PUSH
48176: LD_INT 5
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 0
48185: PUSH
48186: LD_INT 3
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 0
48195: PUSH
48196: LD_INT 2
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 1
48205: PUSH
48206: LD_INT 3
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 1
48215: PUSH
48216: LD_INT 4
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 0
48225: PUSH
48226: LD_INT 4
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 1
48235: NEG
48236: PUSH
48237: LD_INT 3
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: PUSH
48244: LD_INT 1
48246: NEG
48247: PUSH
48248: LD_INT 2
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: PUSH
48255: LD_INT 2
48257: PUSH
48258: LD_INT 4
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 2
48267: NEG
48268: PUSH
48269: LD_INT 2
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 4
48278: NEG
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 4
48289: NEG
48290: PUSH
48291: LD_INT 1
48293: NEG
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 3
48301: NEG
48302: PUSH
48303: LD_INT 0
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 3
48312: NEG
48313: PUSH
48314: LD_INT 1
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 1
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 5
48334: NEG
48335: PUSH
48336: LD_INT 0
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 5
48345: NEG
48346: PUSH
48347: LD_INT 1
48349: NEG
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 5
48357: NEG
48358: PUSH
48359: LD_INT 2
48361: NEG
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: LD_INT 3
48369: NEG
48370: PUSH
48371: LD_INT 2
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: ST_TO_ADDR
// end ; end ;
48425: GO 48428
48427: POP
// case btype of b_depot , b_warehouse :
48428: LD_VAR 0 1
48432: PUSH
48433: LD_INT 0
48435: DOUBLE
48436: EQUAL
48437: IFTRUE 48447
48439: LD_INT 1
48441: DOUBLE
48442: EQUAL
48443: IFTRUE 48447
48445: GO 48648
48447: POP
// case nation of nation_american :
48448: LD_VAR 0 5
48452: PUSH
48453: LD_INT 1
48455: DOUBLE
48456: EQUAL
48457: IFTRUE 48461
48459: GO 48517
48461: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48462: LD_ADDR_VAR 0 9
48466: PUSH
48467: LD_VAR 0 11
48471: PUSH
48472: LD_VAR 0 12
48476: PUSH
48477: LD_VAR 0 13
48481: PUSH
48482: LD_VAR 0 14
48486: PUSH
48487: LD_VAR 0 15
48491: PUSH
48492: LD_VAR 0 16
48496: PUSH
48497: EMPTY
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: PUSH
48505: LD_VAR 0 4
48509: PUSH
48510: LD_INT 1
48512: PLUS
48513: ARRAY
48514: ST_TO_ADDR
48515: GO 48646
48517: LD_INT 2
48519: DOUBLE
48520: EQUAL
48521: IFTRUE 48525
48523: GO 48581
48525: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48526: LD_ADDR_VAR 0 9
48530: PUSH
48531: LD_VAR 0 17
48535: PUSH
48536: LD_VAR 0 18
48540: PUSH
48541: LD_VAR 0 19
48545: PUSH
48546: LD_VAR 0 20
48550: PUSH
48551: LD_VAR 0 21
48555: PUSH
48556: LD_VAR 0 22
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PUSH
48569: LD_VAR 0 4
48573: PUSH
48574: LD_INT 1
48576: PLUS
48577: ARRAY
48578: ST_TO_ADDR
48579: GO 48646
48581: LD_INT 3
48583: DOUBLE
48584: EQUAL
48585: IFTRUE 48589
48587: GO 48645
48589: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48590: LD_ADDR_VAR 0 9
48594: PUSH
48595: LD_VAR 0 23
48599: PUSH
48600: LD_VAR 0 24
48604: PUSH
48605: LD_VAR 0 25
48609: PUSH
48610: LD_VAR 0 26
48614: PUSH
48615: LD_VAR 0 27
48619: PUSH
48620: LD_VAR 0 28
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: PUSH
48633: LD_VAR 0 4
48637: PUSH
48638: LD_INT 1
48640: PLUS
48641: ARRAY
48642: ST_TO_ADDR
48643: GO 48646
48645: POP
48646: GO 49201
48648: LD_INT 2
48650: DOUBLE
48651: EQUAL
48652: IFTRUE 48662
48654: LD_INT 3
48656: DOUBLE
48657: EQUAL
48658: IFTRUE 48662
48660: GO 48718
48662: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48663: LD_ADDR_VAR 0 9
48667: PUSH
48668: LD_VAR 0 29
48672: PUSH
48673: LD_VAR 0 30
48677: PUSH
48678: LD_VAR 0 31
48682: PUSH
48683: LD_VAR 0 32
48687: PUSH
48688: LD_VAR 0 33
48692: PUSH
48693: LD_VAR 0 34
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: PUSH
48706: LD_VAR 0 4
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: ARRAY
48715: ST_TO_ADDR
48716: GO 49201
48718: LD_INT 16
48720: DOUBLE
48721: EQUAL
48722: IFTRUE 48780
48724: LD_INT 17
48726: DOUBLE
48727: EQUAL
48728: IFTRUE 48780
48730: LD_INT 18
48732: DOUBLE
48733: EQUAL
48734: IFTRUE 48780
48736: LD_INT 19
48738: DOUBLE
48739: EQUAL
48740: IFTRUE 48780
48742: LD_INT 22
48744: DOUBLE
48745: EQUAL
48746: IFTRUE 48780
48748: LD_INT 20
48750: DOUBLE
48751: EQUAL
48752: IFTRUE 48780
48754: LD_INT 21
48756: DOUBLE
48757: EQUAL
48758: IFTRUE 48780
48760: LD_INT 23
48762: DOUBLE
48763: EQUAL
48764: IFTRUE 48780
48766: LD_INT 24
48768: DOUBLE
48769: EQUAL
48770: IFTRUE 48780
48772: LD_INT 25
48774: DOUBLE
48775: EQUAL
48776: IFTRUE 48780
48778: GO 48836
48780: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48781: LD_ADDR_VAR 0 9
48785: PUSH
48786: LD_VAR 0 35
48790: PUSH
48791: LD_VAR 0 36
48795: PUSH
48796: LD_VAR 0 37
48800: PUSH
48801: LD_VAR 0 38
48805: PUSH
48806: LD_VAR 0 39
48810: PUSH
48811: LD_VAR 0 40
48815: PUSH
48816: EMPTY
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: PUSH
48824: LD_VAR 0 4
48828: PUSH
48829: LD_INT 1
48831: PLUS
48832: ARRAY
48833: ST_TO_ADDR
48834: GO 49201
48836: LD_INT 6
48838: DOUBLE
48839: EQUAL
48840: IFTRUE 48892
48842: LD_INT 7
48844: DOUBLE
48845: EQUAL
48846: IFTRUE 48892
48848: LD_INT 8
48850: DOUBLE
48851: EQUAL
48852: IFTRUE 48892
48854: LD_INT 13
48856: DOUBLE
48857: EQUAL
48858: IFTRUE 48892
48860: LD_INT 12
48862: DOUBLE
48863: EQUAL
48864: IFTRUE 48892
48866: LD_INT 15
48868: DOUBLE
48869: EQUAL
48870: IFTRUE 48892
48872: LD_INT 11
48874: DOUBLE
48875: EQUAL
48876: IFTRUE 48892
48878: LD_INT 14
48880: DOUBLE
48881: EQUAL
48882: IFTRUE 48892
48884: LD_INT 10
48886: DOUBLE
48887: EQUAL
48888: IFTRUE 48892
48890: GO 48948
48892: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48893: LD_ADDR_VAR 0 9
48897: PUSH
48898: LD_VAR 0 41
48902: PUSH
48903: LD_VAR 0 42
48907: PUSH
48908: LD_VAR 0 43
48912: PUSH
48913: LD_VAR 0 44
48917: PUSH
48918: LD_VAR 0 45
48922: PUSH
48923: LD_VAR 0 46
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: PUSH
48936: LD_VAR 0 4
48940: PUSH
48941: LD_INT 1
48943: PLUS
48944: ARRAY
48945: ST_TO_ADDR
48946: GO 49201
48948: LD_INT 36
48950: DOUBLE
48951: EQUAL
48952: IFTRUE 48956
48954: GO 49012
48956: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48957: LD_ADDR_VAR 0 9
48961: PUSH
48962: LD_VAR 0 47
48966: PUSH
48967: LD_VAR 0 48
48971: PUSH
48972: LD_VAR 0 49
48976: PUSH
48977: LD_VAR 0 50
48981: PUSH
48982: LD_VAR 0 51
48986: PUSH
48987: LD_VAR 0 52
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: PUSH
49000: LD_VAR 0 4
49004: PUSH
49005: LD_INT 1
49007: PLUS
49008: ARRAY
49009: ST_TO_ADDR
49010: GO 49201
49012: LD_INT 4
49014: DOUBLE
49015: EQUAL
49016: IFTRUE 49038
49018: LD_INT 5
49020: DOUBLE
49021: EQUAL
49022: IFTRUE 49038
49024: LD_INT 34
49026: DOUBLE
49027: EQUAL
49028: IFTRUE 49038
49030: LD_INT 37
49032: DOUBLE
49033: EQUAL
49034: IFTRUE 49038
49036: GO 49094
49038: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49039: LD_ADDR_VAR 0 9
49043: PUSH
49044: LD_VAR 0 53
49048: PUSH
49049: LD_VAR 0 54
49053: PUSH
49054: LD_VAR 0 55
49058: PUSH
49059: LD_VAR 0 56
49063: PUSH
49064: LD_VAR 0 57
49068: PUSH
49069: LD_VAR 0 58
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: PUSH
49082: LD_VAR 0 4
49086: PUSH
49087: LD_INT 1
49089: PLUS
49090: ARRAY
49091: ST_TO_ADDR
49092: GO 49201
49094: LD_INT 31
49096: DOUBLE
49097: EQUAL
49098: IFTRUE 49144
49100: LD_INT 32
49102: DOUBLE
49103: EQUAL
49104: IFTRUE 49144
49106: LD_INT 33
49108: DOUBLE
49109: EQUAL
49110: IFTRUE 49144
49112: LD_INT 27
49114: DOUBLE
49115: EQUAL
49116: IFTRUE 49144
49118: LD_INT 26
49120: DOUBLE
49121: EQUAL
49122: IFTRUE 49144
49124: LD_INT 28
49126: DOUBLE
49127: EQUAL
49128: IFTRUE 49144
49130: LD_INT 29
49132: DOUBLE
49133: EQUAL
49134: IFTRUE 49144
49136: LD_INT 30
49138: DOUBLE
49139: EQUAL
49140: IFTRUE 49144
49142: GO 49200
49144: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49145: LD_ADDR_VAR 0 9
49149: PUSH
49150: LD_VAR 0 59
49154: PUSH
49155: LD_VAR 0 60
49159: PUSH
49160: LD_VAR 0 61
49164: PUSH
49165: LD_VAR 0 62
49169: PUSH
49170: LD_VAR 0 63
49174: PUSH
49175: LD_VAR 0 64
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: PUSH
49188: LD_VAR 0 4
49192: PUSH
49193: LD_INT 1
49195: PLUS
49196: ARRAY
49197: ST_TO_ADDR
49198: GO 49201
49200: POP
// temp_list2 = [ ] ;
49201: LD_ADDR_VAR 0 10
49205: PUSH
49206: EMPTY
49207: ST_TO_ADDR
// for i in temp_list do
49208: LD_ADDR_VAR 0 8
49212: PUSH
49213: LD_VAR 0 9
49217: PUSH
49218: FOR_IN
49219: IFFALSE 49271
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49221: LD_ADDR_VAR 0 10
49225: PUSH
49226: LD_VAR 0 10
49230: PUSH
49231: LD_VAR 0 8
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PUSH
49240: LD_VAR 0 2
49244: PLUS
49245: PUSH
49246: LD_VAR 0 8
49250: PUSH
49251: LD_INT 2
49253: ARRAY
49254: PUSH
49255: LD_VAR 0 3
49259: PLUS
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: EMPTY
49266: LIST
49267: ADD
49268: ST_TO_ADDR
49269: GO 49218
49271: POP
49272: POP
// result = temp_list2 ;
49273: LD_ADDR_VAR 0 7
49277: PUSH
49278: LD_VAR 0 10
49282: ST_TO_ADDR
// end ;
49283: LD_VAR 0 7
49287: RET
// export function EnemyInRange ( unit , dist ) ; begin
49288: LD_INT 0
49290: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49291: LD_ADDR_VAR 0 3
49295: PUSH
49296: LD_VAR 0 1
49300: PPUSH
49301: CALL_OW 255
49305: PPUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL_OW 250
49315: PPUSH
49316: LD_VAR 0 1
49320: PPUSH
49321: CALL_OW 251
49325: PPUSH
49326: LD_VAR 0 2
49330: PPUSH
49331: CALL 22661 0 4
49335: PUSH
49336: LD_INT 4
49338: ARRAY
49339: ST_TO_ADDR
// end ;
49340: LD_VAR 0 3
49344: RET
// export function PlayerSeeMe ( unit ) ; begin
49345: LD_INT 0
49347: PPUSH
// result := See ( your_side , unit ) ;
49348: LD_ADDR_VAR 0 2
49352: PUSH
49353: LD_OWVAR 2
49357: PPUSH
49358: LD_VAR 0 1
49362: PPUSH
49363: CALL_OW 292
49367: ST_TO_ADDR
// end ;
49368: LD_VAR 0 2
49372: RET
// export function ReverseDir ( unit ) ; begin
49373: LD_INT 0
49375: PPUSH
// if not unit then
49376: LD_VAR 0 1
49380: NOT
49381: IFFALSE 49385
// exit ;
49383: GO 49408
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49385: LD_ADDR_VAR 0 2
49389: PUSH
49390: LD_VAR 0 1
49394: PPUSH
49395: CALL_OW 254
49399: PUSH
49400: LD_INT 3
49402: PLUS
49403: PUSH
49404: LD_INT 6
49406: MOD
49407: ST_TO_ADDR
// end ;
49408: LD_VAR 0 2
49412: RET
// export function ReverseArray ( array ) ; var i ; begin
49413: LD_INT 0
49415: PPUSH
49416: PPUSH
// if not array then
49417: LD_VAR 0 1
49421: NOT
49422: IFFALSE 49426
// exit ;
49424: GO 49481
// result := [ ] ;
49426: LD_ADDR_VAR 0 2
49430: PUSH
49431: EMPTY
49432: ST_TO_ADDR
// for i := array downto 1 do
49433: LD_ADDR_VAR 0 3
49437: PUSH
49438: DOUBLE
49439: LD_VAR 0 1
49443: INC
49444: ST_TO_ADDR
49445: LD_INT 1
49447: PUSH
49448: FOR_DOWNTO
49449: IFFALSE 49479
// result := Join ( result , array [ i ] ) ;
49451: LD_ADDR_VAR 0 2
49455: PUSH
49456: LD_VAR 0 2
49460: PPUSH
49461: LD_VAR 0 1
49465: PUSH
49466: LD_VAR 0 3
49470: ARRAY
49471: PPUSH
49472: CALL 54126 0 2
49476: ST_TO_ADDR
49477: GO 49448
49479: POP
49480: POP
// end ;
49481: LD_VAR 0 2
49485: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49486: LD_INT 0
49488: PPUSH
49489: PPUSH
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
// if not unit or not hexes then
49494: LD_VAR 0 1
49498: NOT
49499: PUSH
49500: LD_VAR 0 2
49504: NOT
49505: OR
49506: IFFALSE 49510
// exit ;
49508: GO 49633
// dist := 9999 ;
49510: LD_ADDR_VAR 0 5
49514: PUSH
49515: LD_INT 9999
49517: ST_TO_ADDR
// for i = 1 to hexes do
49518: LD_ADDR_VAR 0 4
49522: PUSH
49523: DOUBLE
49524: LD_INT 1
49526: DEC
49527: ST_TO_ADDR
49528: LD_VAR 0 2
49532: PUSH
49533: FOR_TO
49534: IFFALSE 49621
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49536: LD_ADDR_VAR 0 6
49540: PUSH
49541: LD_VAR 0 1
49545: PPUSH
49546: LD_VAR 0 2
49550: PUSH
49551: LD_VAR 0 4
49555: ARRAY
49556: PUSH
49557: LD_INT 1
49559: ARRAY
49560: PPUSH
49561: LD_VAR 0 2
49565: PUSH
49566: LD_VAR 0 4
49570: ARRAY
49571: PUSH
49572: LD_INT 2
49574: ARRAY
49575: PPUSH
49576: CALL_OW 297
49580: ST_TO_ADDR
// if tdist < dist then
49581: LD_VAR 0 6
49585: PUSH
49586: LD_VAR 0 5
49590: LESS
49591: IFFALSE 49619
// begin hex := hexes [ i ] ;
49593: LD_ADDR_VAR 0 8
49597: PUSH
49598: LD_VAR 0 2
49602: PUSH
49603: LD_VAR 0 4
49607: ARRAY
49608: ST_TO_ADDR
// dist := tdist ;
49609: LD_ADDR_VAR 0 5
49613: PUSH
49614: LD_VAR 0 6
49618: ST_TO_ADDR
// end ; end ;
49619: GO 49533
49621: POP
49622: POP
// result := hex ;
49623: LD_ADDR_VAR 0 3
49627: PUSH
49628: LD_VAR 0 8
49632: ST_TO_ADDR
// end ;
49633: LD_VAR 0 3
49637: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49638: LD_INT 0
49640: PPUSH
49641: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49642: LD_VAR 0 1
49646: NOT
49647: PUSH
49648: LD_VAR 0 1
49652: PUSH
49653: LD_INT 21
49655: PUSH
49656: LD_INT 2
49658: PUSH
49659: EMPTY
49660: LIST
49661: LIST
49662: PUSH
49663: LD_INT 23
49665: PUSH
49666: LD_INT 2
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PPUSH
49677: CALL_OW 69
49681: IN
49682: NOT
49683: OR
49684: IFFALSE 49688
// exit ;
49686: GO 49735
// for i = 1 to 3 do
49688: LD_ADDR_VAR 0 3
49692: PUSH
49693: DOUBLE
49694: LD_INT 1
49696: DEC
49697: ST_TO_ADDR
49698: LD_INT 3
49700: PUSH
49701: FOR_TO
49702: IFFALSE 49733
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49704: LD_VAR 0 1
49708: PPUSH
49709: CALL_OW 250
49713: PPUSH
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 251
49723: PPUSH
49724: LD_INT 1
49726: PPUSH
49727: CALL_OW 453
49731: GO 49701
49733: POP
49734: POP
// end ;
49735: LD_VAR 0 2
49739: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
49744: PPUSH
49745: PPUSH
49746: PPUSH
49747: PPUSH
// if not unit or not enemy_unit then
49748: LD_VAR 0 1
49752: NOT
49753: PUSH
49754: LD_VAR 0 2
49758: NOT
49759: OR
49760: IFFALSE 49764
// exit ;
49762: GO 50231
// if GetLives ( i ) < 250 then
49764: LD_VAR 0 4
49768: PPUSH
49769: CALL_OW 256
49773: PUSH
49774: LD_INT 250
49776: LESS
49777: IFFALSE 49790
// begin ComAutodestruct ( i ) ;
49779: LD_VAR 0 4
49783: PPUSH
49784: CALL 49638 0 1
// exit ;
49788: GO 50231
// end ; x := GetX ( enemy_unit ) ;
49790: LD_ADDR_VAR 0 7
49794: PUSH
49795: LD_VAR 0 2
49799: PPUSH
49800: CALL_OW 250
49804: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49805: LD_ADDR_VAR 0 8
49809: PUSH
49810: LD_VAR 0 2
49814: PPUSH
49815: CALL_OW 251
49819: ST_TO_ADDR
// if not x or not y then
49820: LD_VAR 0 7
49824: NOT
49825: PUSH
49826: LD_VAR 0 8
49830: NOT
49831: OR
49832: IFFALSE 49836
// exit ;
49834: GO 50231
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49836: LD_ADDR_VAR 0 6
49840: PUSH
49841: LD_VAR 0 7
49845: PPUSH
49846: LD_INT 0
49848: PPUSH
49849: LD_INT 4
49851: PPUSH
49852: CALL_OW 272
49856: PUSH
49857: LD_VAR 0 8
49861: PPUSH
49862: LD_INT 0
49864: PPUSH
49865: LD_INT 4
49867: PPUSH
49868: CALL_OW 273
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: LD_VAR 0 7
49881: PPUSH
49882: LD_INT 1
49884: PPUSH
49885: LD_INT 4
49887: PPUSH
49888: CALL_OW 272
49892: PUSH
49893: LD_VAR 0 8
49897: PPUSH
49898: LD_INT 1
49900: PPUSH
49901: LD_INT 4
49903: PPUSH
49904: CALL_OW 273
49908: PUSH
49909: EMPTY
49910: LIST
49911: LIST
49912: PUSH
49913: LD_VAR 0 7
49917: PPUSH
49918: LD_INT 2
49920: PPUSH
49921: LD_INT 4
49923: PPUSH
49924: CALL_OW 272
49928: PUSH
49929: LD_VAR 0 8
49933: PPUSH
49934: LD_INT 2
49936: PPUSH
49937: LD_INT 4
49939: PPUSH
49940: CALL_OW 273
49944: PUSH
49945: EMPTY
49946: LIST
49947: LIST
49948: PUSH
49949: LD_VAR 0 7
49953: PPUSH
49954: LD_INT 3
49956: PPUSH
49957: LD_INT 4
49959: PPUSH
49960: CALL_OW 272
49964: PUSH
49965: LD_VAR 0 8
49969: PPUSH
49970: LD_INT 3
49972: PPUSH
49973: LD_INT 4
49975: PPUSH
49976: CALL_OW 273
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_VAR 0 7
49989: PPUSH
49990: LD_INT 4
49992: PPUSH
49993: LD_INT 4
49995: PPUSH
49996: CALL_OW 272
50000: PUSH
50001: LD_VAR 0 8
50005: PPUSH
50006: LD_INT 4
50008: PPUSH
50009: LD_INT 4
50011: PPUSH
50012: CALL_OW 273
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_VAR 0 7
50025: PPUSH
50026: LD_INT 5
50028: PPUSH
50029: LD_INT 4
50031: PPUSH
50032: CALL_OW 272
50036: PUSH
50037: LD_VAR 0 8
50041: PPUSH
50042: LD_INT 5
50044: PPUSH
50045: LD_INT 4
50047: PPUSH
50048: CALL_OW 273
50052: PUSH
50053: EMPTY
50054: LIST
50055: LIST
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: LIST
50061: LIST
50062: LIST
50063: LIST
50064: ST_TO_ADDR
// for i = tmp downto 1 do
50065: LD_ADDR_VAR 0 4
50069: PUSH
50070: DOUBLE
50071: LD_VAR 0 6
50075: INC
50076: ST_TO_ADDR
50077: LD_INT 1
50079: PUSH
50080: FOR_DOWNTO
50081: IFFALSE 50182
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50083: LD_VAR 0 6
50087: PUSH
50088: LD_VAR 0 4
50092: ARRAY
50093: PUSH
50094: LD_INT 1
50096: ARRAY
50097: PPUSH
50098: LD_VAR 0 6
50102: PUSH
50103: LD_VAR 0 4
50107: ARRAY
50108: PUSH
50109: LD_INT 2
50111: ARRAY
50112: PPUSH
50113: CALL_OW 488
50117: NOT
50118: PUSH
50119: LD_VAR 0 6
50123: PUSH
50124: LD_VAR 0 4
50128: ARRAY
50129: PUSH
50130: LD_INT 1
50132: ARRAY
50133: PPUSH
50134: LD_VAR 0 6
50138: PUSH
50139: LD_VAR 0 4
50143: ARRAY
50144: PUSH
50145: LD_INT 2
50147: ARRAY
50148: PPUSH
50149: CALL_OW 428
50153: PUSH
50154: LD_INT 0
50156: NONEQUAL
50157: OR
50158: IFFALSE 50180
// tmp := Delete ( tmp , i ) ;
50160: LD_ADDR_VAR 0 6
50164: PUSH
50165: LD_VAR 0 6
50169: PPUSH
50170: LD_VAR 0 4
50174: PPUSH
50175: CALL_OW 3
50179: ST_TO_ADDR
50180: GO 50080
50182: POP
50183: POP
// j := GetClosestHex ( unit , tmp ) ;
50184: LD_ADDR_VAR 0 5
50188: PUSH
50189: LD_VAR 0 1
50193: PPUSH
50194: LD_VAR 0 6
50198: PPUSH
50199: CALL 49486 0 2
50203: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50204: LD_VAR 0 1
50208: PPUSH
50209: LD_VAR 0 5
50213: PUSH
50214: LD_INT 1
50216: ARRAY
50217: PPUSH
50218: LD_VAR 0 5
50222: PUSH
50223: LD_INT 2
50225: ARRAY
50226: PPUSH
50227: CALL_OW 111
// end ;
50231: LD_VAR 0 3
50235: RET
// export function PrepareApemanSoldier ( ) ; begin
50236: LD_INT 0
50238: PPUSH
// uc_nation := 0 ;
50239: LD_ADDR_OWVAR 21
50243: PUSH
50244: LD_INT 0
50246: ST_TO_ADDR
// hc_sex := sex_male ;
50247: LD_ADDR_OWVAR 27
50251: PUSH
50252: LD_INT 1
50254: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
50255: LD_ADDR_OWVAR 28
50259: PUSH
50260: LD_INT 15
50262: ST_TO_ADDR
// hc_gallery :=  ;
50263: LD_ADDR_OWVAR 33
50267: PUSH
50268: LD_STRING 
50270: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50271: LD_ADDR_OWVAR 31
50275: PUSH
50276: LD_INT 0
50278: PPUSH
50279: LD_INT 3
50281: PPUSH
50282: CALL_OW 12
50286: PUSH
50287: LD_INT 0
50289: PPUSH
50290: LD_INT 3
50292: PPUSH
50293: CALL_OW 12
50297: PUSH
50298: LD_INT 0
50300: PUSH
50301: LD_INT 0
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: ST_TO_ADDR
// end ;
50310: LD_VAR 0 1
50314: RET
// export function PrepareApemanEngineer ( ) ; begin
50315: LD_INT 0
50317: PPUSH
// uc_nation := 0 ;
50318: LD_ADDR_OWVAR 21
50322: PUSH
50323: LD_INT 0
50325: ST_TO_ADDR
// hc_sex := sex_male ;
50326: LD_ADDR_OWVAR 27
50330: PUSH
50331: LD_INT 1
50333: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
50334: LD_ADDR_OWVAR 28
50338: PUSH
50339: LD_INT 16
50341: ST_TO_ADDR
// hc_gallery :=  ;
50342: LD_ADDR_OWVAR 33
50346: PUSH
50347: LD_STRING 
50349: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50350: LD_ADDR_OWVAR 31
50354: PUSH
50355: LD_INT 0
50357: PPUSH
50358: LD_INT 3
50360: PPUSH
50361: CALL_OW 12
50365: PUSH
50366: LD_INT 0
50368: PPUSH
50369: LD_INT 3
50371: PPUSH
50372: CALL_OW 12
50376: PUSH
50377: LD_INT 0
50379: PUSH
50380: LD_INT 0
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: ST_TO_ADDR
// end ;
50389: LD_VAR 0 1
50393: RET
// export function PrepareApeman ( agressivity ) ; begin
50394: LD_INT 0
50396: PPUSH
// uc_side := 0 ;
50397: LD_ADDR_OWVAR 20
50401: PUSH
50402: LD_INT 0
50404: ST_TO_ADDR
// uc_nation := 0 ;
50405: LD_ADDR_OWVAR 21
50409: PUSH
50410: LD_INT 0
50412: ST_TO_ADDR
// hc_sex := sex_male ;
50413: LD_ADDR_OWVAR 27
50417: PUSH
50418: LD_INT 1
50420: ST_TO_ADDR
// hc_class := class_apeman ;
50421: LD_ADDR_OWVAR 28
50425: PUSH
50426: LD_INT 12
50428: ST_TO_ADDR
// hc_gallery :=  ;
50429: LD_ADDR_OWVAR 33
50433: PUSH
50434: LD_STRING 
50436: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50437: LD_ADDR_OWVAR 35
50441: PUSH
50442: LD_VAR 0 1
50446: NEG
50447: PPUSH
50448: LD_VAR 0 1
50452: PPUSH
50453: CALL_OW 12
50457: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50458: LD_ADDR_OWVAR 31
50462: PUSH
50463: LD_INT 0
50465: PPUSH
50466: LD_INT 3
50468: PPUSH
50469: CALL_OW 12
50473: PUSH
50474: LD_INT 0
50476: PPUSH
50477: LD_INT 3
50479: PPUSH
50480: CALL_OW 12
50484: PUSH
50485: LD_INT 0
50487: PUSH
50488: LD_INT 0
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: ST_TO_ADDR
// end ;
50497: LD_VAR 0 2
50501: RET
// export function PrepareTiger ( agressivity ) ; begin
50502: LD_INT 0
50504: PPUSH
// uc_side := 0 ;
50505: LD_ADDR_OWVAR 20
50509: PUSH
50510: LD_INT 0
50512: ST_TO_ADDR
// uc_nation := 0 ;
50513: LD_ADDR_OWVAR 21
50517: PUSH
50518: LD_INT 0
50520: ST_TO_ADDR
// hc_class := class_tiger ;
50521: LD_ADDR_OWVAR 28
50525: PUSH
50526: LD_INT 14
50528: ST_TO_ADDR
// hc_gallery :=  ;
50529: LD_ADDR_OWVAR 33
50533: PUSH
50534: LD_STRING 
50536: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50537: LD_ADDR_OWVAR 35
50541: PUSH
50542: LD_VAR 0 1
50546: NEG
50547: PPUSH
50548: LD_VAR 0 1
50552: PPUSH
50553: CALL_OW 12
50557: ST_TO_ADDR
// end ;
50558: LD_VAR 0 2
50562: RET
// export function PrepareEnchidna ( ) ; begin
50563: LD_INT 0
50565: PPUSH
// uc_side := 0 ;
50566: LD_ADDR_OWVAR 20
50570: PUSH
50571: LD_INT 0
50573: ST_TO_ADDR
// uc_nation := 0 ;
50574: LD_ADDR_OWVAR 21
50578: PUSH
50579: LD_INT 0
50581: ST_TO_ADDR
// hc_class := class_baggie ;
50582: LD_ADDR_OWVAR 28
50586: PUSH
50587: LD_INT 13
50589: ST_TO_ADDR
// hc_gallery :=  ;
50590: LD_ADDR_OWVAR 33
50594: PUSH
50595: LD_STRING 
50597: ST_TO_ADDR
// end ;
50598: LD_VAR 0 1
50602: RET
// export function PrepareFrog ( ) ; begin
50603: LD_INT 0
50605: PPUSH
// uc_side := 0 ;
50606: LD_ADDR_OWVAR 20
50610: PUSH
50611: LD_INT 0
50613: ST_TO_ADDR
// uc_nation := 0 ;
50614: LD_ADDR_OWVAR 21
50618: PUSH
50619: LD_INT 0
50621: ST_TO_ADDR
// hc_class := class_frog ;
50622: LD_ADDR_OWVAR 28
50626: PUSH
50627: LD_INT 19
50629: ST_TO_ADDR
// hc_gallery :=  ;
50630: LD_ADDR_OWVAR 33
50634: PUSH
50635: LD_STRING 
50637: ST_TO_ADDR
// end ;
50638: LD_VAR 0 1
50642: RET
// export function PrepareFish ( ) ; begin
50643: LD_INT 0
50645: PPUSH
// uc_side := 0 ;
50646: LD_ADDR_OWVAR 20
50650: PUSH
50651: LD_INT 0
50653: ST_TO_ADDR
// uc_nation := 0 ;
50654: LD_ADDR_OWVAR 21
50658: PUSH
50659: LD_INT 0
50661: ST_TO_ADDR
// hc_class := class_fish ;
50662: LD_ADDR_OWVAR 28
50666: PUSH
50667: LD_INT 20
50669: ST_TO_ADDR
// hc_gallery :=  ;
50670: LD_ADDR_OWVAR 33
50674: PUSH
50675: LD_STRING 
50677: ST_TO_ADDR
// end ;
50678: LD_VAR 0 1
50682: RET
// export function PrepareBird ( ) ; begin
50683: LD_INT 0
50685: PPUSH
// uc_side := 0 ;
50686: LD_ADDR_OWVAR 20
50690: PUSH
50691: LD_INT 0
50693: ST_TO_ADDR
// uc_nation := 0 ;
50694: LD_ADDR_OWVAR 21
50698: PUSH
50699: LD_INT 0
50701: ST_TO_ADDR
// hc_class := class_phororhacos ;
50702: LD_ADDR_OWVAR 28
50706: PUSH
50707: LD_INT 18
50709: ST_TO_ADDR
// hc_gallery :=  ;
50710: LD_ADDR_OWVAR 33
50714: PUSH
50715: LD_STRING 
50717: ST_TO_ADDR
// end ;
50718: LD_VAR 0 1
50722: RET
// export function PrepareHorse ( ) ; begin
50723: LD_INT 0
50725: PPUSH
// uc_side := 0 ;
50726: LD_ADDR_OWVAR 20
50730: PUSH
50731: LD_INT 0
50733: ST_TO_ADDR
// uc_nation := 0 ;
50734: LD_ADDR_OWVAR 21
50738: PUSH
50739: LD_INT 0
50741: ST_TO_ADDR
// hc_class := class_horse ;
50742: LD_ADDR_OWVAR 28
50746: PUSH
50747: LD_INT 21
50749: ST_TO_ADDR
// hc_gallery :=  ;
50750: LD_ADDR_OWVAR 33
50754: PUSH
50755: LD_STRING 
50757: ST_TO_ADDR
// end ;
50758: LD_VAR 0 1
50762: RET
// export function PrepareMastodont ( ) ; begin
50763: LD_INT 0
50765: PPUSH
// uc_side := 0 ;
50766: LD_ADDR_OWVAR 20
50770: PUSH
50771: LD_INT 0
50773: ST_TO_ADDR
// uc_nation := 0 ;
50774: LD_ADDR_OWVAR 21
50778: PUSH
50779: LD_INT 0
50781: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50782: LD_ADDR_OWVAR 37
50786: PUSH
50787: LD_INT 31
50789: ST_TO_ADDR
// vc_control := control_rider ;
50790: LD_ADDR_OWVAR 38
50794: PUSH
50795: LD_INT 4
50797: ST_TO_ADDR
// end ;
50798: LD_VAR 0 1
50802: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50803: LD_INT 0
50805: PPUSH
50806: PPUSH
50807: PPUSH
// uc_side = 0 ;
50808: LD_ADDR_OWVAR 20
50812: PUSH
50813: LD_INT 0
50815: ST_TO_ADDR
// uc_nation = 0 ;
50816: LD_ADDR_OWVAR 21
50820: PUSH
50821: LD_INT 0
50823: ST_TO_ADDR
// InitHc_All ( ) ;
50824: CALL_OW 584
// InitVc ;
50828: CALL_OW 20
// if mastodonts then
50832: LD_VAR 0 6
50836: IFFALSE 50903
// for i = 1 to mastodonts do
50838: LD_ADDR_VAR 0 11
50842: PUSH
50843: DOUBLE
50844: LD_INT 1
50846: DEC
50847: ST_TO_ADDR
50848: LD_VAR 0 6
50852: PUSH
50853: FOR_TO
50854: IFFALSE 50901
// begin vc_chassis := 31 ;
50856: LD_ADDR_OWVAR 37
50860: PUSH
50861: LD_INT 31
50863: ST_TO_ADDR
// vc_control := control_rider ;
50864: LD_ADDR_OWVAR 38
50868: PUSH
50869: LD_INT 4
50871: ST_TO_ADDR
// animal := CreateVehicle ;
50872: LD_ADDR_VAR 0 12
50876: PUSH
50877: CALL_OW 45
50881: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50882: LD_VAR 0 12
50886: PPUSH
50887: LD_VAR 0 8
50891: PPUSH
50892: LD_INT 0
50894: PPUSH
50895: CALL 53031 0 3
// end ;
50899: GO 50853
50901: POP
50902: POP
// if horses then
50903: LD_VAR 0 5
50907: IFFALSE 50974
// for i = 1 to horses do
50909: LD_ADDR_VAR 0 11
50913: PUSH
50914: DOUBLE
50915: LD_INT 1
50917: DEC
50918: ST_TO_ADDR
50919: LD_VAR 0 5
50923: PUSH
50924: FOR_TO
50925: IFFALSE 50972
// begin hc_class := 21 ;
50927: LD_ADDR_OWVAR 28
50931: PUSH
50932: LD_INT 21
50934: ST_TO_ADDR
// hc_gallery :=  ;
50935: LD_ADDR_OWVAR 33
50939: PUSH
50940: LD_STRING 
50942: ST_TO_ADDR
// animal := CreateHuman ;
50943: LD_ADDR_VAR 0 12
50947: PUSH
50948: CALL_OW 44
50952: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50953: LD_VAR 0 12
50957: PPUSH
50958: LD_VAR 0 8
50962: PPUSH
50963: LD_INT 0
50965: PPUSH
50966: CALL 53031 0 3
// end ;
50970: GO 50924
50972: POP
50973: POP
// if birds then
50974: LD_VAR 0 1
50978: IFFALSE 51045
// for i = 1 to birds do
50980: LD_ADDR_VAR 0 11
50984: PUSH
50985: DOUBLE
50986: LD_INT 1
50988: DEC
50989: ST_TO_ADDR
50990: LD_VAR 0 1
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51043
// begin hc_class := 18 ;
50998: LD_ADDR_OWVAR 28
51002: PUSH
51003: LD_INT 18
51005: ST_TO_ADDR
// hc_gallery =  ;
51006: LD_ADDR_OWVAR 33
51010: PUSH
51011: LD_STRING 
51013: ST_TO_ADDR
// animal := CreateHuman ;
51014: LD_ADDR_VAR 0 12
51018: PUSH
51019: CALL_OW 44
51023: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51024: LD_VAR 0 12
51028: PPUSH
51029: LD_VAR 0 8
51033: PPUSH
51034: LD_INT 0
51036: PPUSH
51037: CALL 53031 0 3
// end ;
51041: GO 50995
51043: POP
51044: POP
// if tigers then
51045: LD_VAR 0 2
51049: IFFALSE 51133
// for i = 1 to tigers do
51051: LD_ADDR_VAR 0 11
51055: PUSH
51056: DOUBLE
51057: LD_INT 1
51059: DEC
51060: ST_TO_ADDR
51061: LD_VAR 0 2
51065: PUSH
51066: FOR_TO
51067: IFFALSE 51131
// begin hc_class = class_tiger ;
51069: LD_ADDR_OWVAR 28
51073: PUSH
51074: LD_INT 14
51076: ST_TO_ADDR
// hc_gallery =  ;
51077: LD_ADDR_OWVAR 33
51081: PUSH
51082: LD_STRING 
51084: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51085: LD_ADDR_OWVAR 35
51089: PUSH
51090: LD_INT 7
51092: NEG
51093: PPUSH
51094: LD_INT 7
51096: PPUSH
51097: CALL_OW 12
51101: ST_TO_ADDR
// animal := CreateHuman ;
51102: LD_ADDR_VAR 0 12
51106: PUSH
51107: CALL_OW 44
51111: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51112: LD_VAR 0 12
51116: PPUSH
51117: LD_VAR 0 8
51121: PPUSH
51122: LD_INT 0
51124: PPUSH
51125: CALL 53031 0 3
// end ;
51129: GO 51066
51131: POP
51132: POP
// if apemans then
51133: LD_VAR 0 3
51137: IFFALSE 51260
// for i = 1 to apemans do
51139: LD_ADDR_VAR 0 11
51143: PUSH
51144: DOUBLE
51145: LD_INT 1
51147: DEC
51148: ST_TO_ADDR
51149: LD_VAR 0 3
51153: PUSH
51154: FOR_TO
51155: IFFALSE 51258
// begin hc_class = class_apeman ;
51157: LD_ADDR_OWVAR 28
51161: PUSH
51162: LD_INT 12
51164: ST_TO_ADDR
// hc_gallery =  ;
51165: LD_ADDR_OWVAR 33
51169: PUSH
51170: LD_STRING 
51172: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
51173: LD_ADDR_OWVAR 35
51177: PUSH
51178: LD_INT 2
51180: NEG
51181: PPUSH
51182: LD_INT 2
51184: PPUSH
51185: CALL_OW 12
51189: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
51190: LD_ADDR_OWVAR 31
51194: PUSH
51195: LD_INT 1
51197: PPUSH
51198: LD_INT 3
51200: PPUSH
51201: CALL_OW 12
51205: PUSH
51206: LD_INT 1
51208: PPUSH
51209: LD_INT 3
51211: PPUSH
51212: CALL_OW 12
51216: PUSH
51217: LD_INT 0
51219: PUSH
51220: LD_INT 0
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: LIST
51227: LIST
51228: ST_TO_ADDR
// animal := CreateHuman ;
51229: LD_ADDR_VAR 0 12
51233: PUSH
51234: CALL_OW 44
51238: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51239: LD_VAR 0 12
51243: PPUSH
51244: LD_VAR 0 8
51248: PPUSH
51249: LD_INT 0
51251: PPUSH
51252: CALL 53031 0 3
// end ;
51256: GO 51154
51258: POP
51259: POP
// if enchidnas then
51260: LD_VAR 0 4
51264: IFFALSE 51331
// for i = 1 to enchidnas do
51266: LD_ADDR_VAR 0 11
51270: PUSH
51271: DOUBLE
51272: LD_INT 1
51274: DEC
51275: ST_TO_ADDR
51276: LD_VAR 0 4
51280: PUSH
51281: FOR_TO
51282: IFFALSE 51329
// begin hc_class = 13 ;
51284: LD_ADDR_OWVAR 28
51288: PUSH
51289: LD_INT 13
51291: ST_TO_ADDR
// hc_gallery =  ;
51292: LD_ADDR_OWVAR 33
51296: PUSH
51297: LD_STRING 
51299: ST_TO_ADDR
// animal := CreateHuman ;
51300: LD_ADDR_VAR 0 12
51304: PUSH
51305: CALL_OW 44
51309: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51310: LD_VAR 0 12
51314: PPUSH
51315: LD_VAR 0 8
51319: PPUSH
51320: LD_INT 0
51322: PPUSH
51323: CALL 53031 0 3
// end ;
51327: GO 51281
51329: POP
51330: POP
// if fishes then
51331: LD_VAR 0 7
51335: IFFALSE 51402
// for i = 1 to fishes do
51337: LD_ADDR_VAR 0 11
51341: PUSH
51342: DOUBLE
51343: LD_INT 1
51345: DEC
51346: ST_TO_ADDR
51347: LD_VAR 0 7
51351: PUSH
51352: FOR_TO
51353: IFFALSE 51400
// begin hc_class = 20 ;
51355: LD_ADDR_OWVAR 28
51359: PUSH
51360: LD_INT 20
51362: ST_TO_ADDR
// hc_gallery =  ;
51363: LD_ADDR_OWVAR 33
51367: PUSH
51368: LD_STRING 
51370: ST_TO_ADDR
// animal := CreateHuman ;
51371: LD_ADDR_VAR 0 12
51375: PUSH
51376: CALL_OW 44
51380: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51381: LD_VAR 0 12
51385: PPUSH
51386: LD_VAR 0 9
51390: PPUSH
51391: LD_INT 0
51393: PPUSH
51394: CALL 53031 0 3
// end ;
51398: GO 51352
51400: POP
51401: POP
// end ;
51402: LD_VAR 0 10
51406: RET
// export function WantHeal ( sci , unit ) ; begin
51407: LD_INT 0
51409: PPUSH
// if GetTaskList ( sci ) > 0 then
51410: LD_VAR 0 1
51414: PPUSH
51415: CALL_OW 437
51419: PUSH
51420: LD_INT 0
51422: GREATER
51423: IFFALSE 51493
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51425: LD_VAR 0 1
51429: PPUSH
51430: CALL_OW 437
51434: PUSH
51435: LD_INT 1
51437: ARRAY
51438: PUSH
51439: LD_INT 1
51441: ARRAY
51442: PUSH
51443: LD_STRING l
51445: EQUAL
51446: PUSH
51447: LD_VAR 0 1
51451: PPUSH
51452: CALL_OW 437
51456: PUSH
51457: LD_INT 1
51459: ARRAY
51460: PUSH
51461: LD_INT 4
51463: ARRAY
51464: PUSH
51465: LD_VAR 0 2
51469: EQUAL
51470: AND
51471: IFFALSE 51483
// result := true else
51473: LD_ADDR_VAR 0 3
51477: PUSH
51478: LD_INT 1
51480: ST_TO_ADDR
51481: GO 51491
// result := false ;
51483: LD_ADDR_VAR 0 3
51487: PUSH
51488: LD_INT 0
51490: ST_TO_ADDR
// end else
51491: GO 51501
// result := false ;
51493: LD_ADDR_VAR 0 3
51497: PUSH
51498: LD_INT 0
51500: ST_TO_ADDR
// end ;
51501: LD_VAR 0 3
51505: RET
// export function HealTarget ( sci ) ; begin
51506: LD_INT 0
51508: PPUSH
// if not sci then
51509: LD_VAR 0 1
51513: NOT
51514: IFFALSE 51518
// exit ;
51516: GO 51583
// result := 0 ;
51518: LD_ADDR_VAR 0 2
51522: PUSH
51523: LD_INT 0
51525: ST_TO_ADDR
// if GetTaskList ( sci ) then
51526: LD_VAR 0 1
51530: PPUSH
51531: CALL_OW 437
51535: IFFALSE 51583
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51537: LD_VAR 0 1
51541: PPUSH
51542: CALL_OW 437
51546: PUSH
51547: LD_INT 1
51549: ARRAY
51550: PUSH
51551: LD_INT 1
51553: ARRAY
51554: PUSH
51555: LD_STRING l
51557: EQUAL
51558: IFFALSE 51583
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51560: LD_ADDR_VAR 0 2
51564: PUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL_OW 437
51574: PUSH
51575: LD_INT 1
51577: ARRAY
51578: PUSH
51579: LD_INT 4
51581: ARRAY
51582: ST_TO_ADDR
// end ;
51583: LD_VAR 0 2
51587: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51588: LD_INT 0
51590: PPUSH
51591: PPUSH
51592: PPUSH
51593: PPUSH
// if not base_units then
51594: LD_VAR 0 1
51598: NOT
51599: IFFALSE 51603
// exit ;
51601: GO 51690
// result := false ;
51603: LD_ADDR_VAR 0 2
51607: PUSH
51608: LD_INT 0
51610: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51611: LD_ADDR_VAR 0 5
51615: PUSH
51616: LD_VAR 0 1
51620: PPUSH
51621: LD_INT 21
51623: PUSH
51624: LD_INT 3
51626: PUSH
51627: EMPTY
51628: LIST
51629: LIST
51630: PPUSH
51631: CALL_OW 72
51635: ST_TO_ADDR
// if not tmp then
51636: LD_VAR 0 5
51640: NOT
51641: IFFALSE 51645
// exit ;
51643: GO 51690
// for i in tmp do
51645: LD_ADDR_VAR 0 3
51649: PUSH
51650: LD_VAR 0 5
51654: PUSH
51655: FOR_IN
51656: IFFALSE 51688
// begin result := EnemyInRange ( i , 22 ) ;
51658: LD_ADDR_VAR 0 2
51662: PUSH
51663: LD_VAR 0 3
51667: PPUSH
51668: LD_INT 22
51670: PPUSH
51671: CALL 49288 0 2
51675: ST_TO_ADDR
// if result then
51676: LD_VAR 0 2
51680: IFFALSE 51686
// exit ;
51682: POP
51683: POP
51684: GO 51690
// end ;
51686: GO 51655
51688: POP
51689: POP
// end ;
51690: LD_VAR 0 2
51694: RET
// export function FilterByTag ( units , tag ) ; begin
51695: LD_INT 0
51697: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51698: LD_ADDR_VAR 0 3
51702: PUSH
51703: LD_VAR 0 1
51707: PPUSH
51708: LD_INT 120
51710: PUSH
51711: LD_VAR 0 2
51715: PUSH
51716: EMPTY
51717: LIST
51718: LIST
51719: PPUSH
51720: CALL_OW 72
51724: ST_TO_ADDR
// end ;
51725: LD_VAR 0 3
51729: RET
// export function IsDriver ( un ) ; begin
51730: LD_INT 0
51732: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51733: LD_ADDR_VAR 0 2
51737: PUSH
51738: LD_VAR 0 1
51742: PUSH
51743: LD_INT 55
51745: PUSH
51746: EMPTY
51747: LIST
51748: PPUSH
51749: CALL_OW 69
51753: IN
51754: ST_TO_ADDR
// end ;
51755: LD_VAR 0 2
51759: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51760: LD_INT 0
51762: PPUSH
51763: PPUSH
// list := [ ] ;
51764: LD_ADDR_VAR 0 5
51768: PUSH
51769: EMPTY
51770: ST_TO_ADDR
// case d of 0 :
51771: LD_VAR 0 3
51775: PUSH
51776: LD_INT 0
51778: DOUBLE
51779: EQUAL
51780: IFTRUE 51784
51782: GO 51917
51784: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51785: LD_ADDR_VAR 0 5
51789: PUSH
51790: LD_VAR 0 1
51794: PUSH
51795: LD_INT 4
51797: MINUS
51798: PUSH
51799: LD_VAR 0 2
51803: PUSH
51804: LD_INT 4
51806: MINUS
51807: PUSH
51808: LD_INT 2
51810: PUSH
51811: EMPTY
51812: LIST
51813: LIST
51814: LIST
51815: PUSH
51816: LD_VAR 0 1
51820: PUSH
51821: LD_INT 3
51823: MINUS
51824: PUSH
51825: LD_VAR 0 2
51829: PUSH
51830: LD_INT 1
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: LIST
51837: PUSH
51838: LD_VAR 0 1
51842: PUSH
51843: LD_INT 4
51845: PLUS
51846: PUSH
51847: LD_VAR 0 2
51851: PUSH
51852: LD_INT 4
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 1
51864: PUSH
51865: LD_INT 3
51867: PLUS
51868: PUSH
51869: LD_VAR 0 2
51873: PUSH
51874: LD_INT 3
51876: PLUS
51877: PUSH
51878: LD_INT 5
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: LIST
51885: PUSH
51886: LD_VAR 0 1
51890: PUSH
51891: LD_VAR 0 2
51895: PUSH
51896: LD_INT 4
51898: PLUS
51899: PUSH
51900: LD_INT 0
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: LIST
51907: PUSH
51908: EMPTY
51909: LIST
51910: LIST
51911: LIST
51912: LIST
51913: LIST
51914: ST_TO_ADDR
// end ; 1 :
51915: GO 52615
51917: LD_INT 1
51919: DOUBLE
51920: EQUAL
51921: IFTRUE 51925
51923: GO 52058
51925: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51926: LD_ADDR_VAR 0 5
51930: PUSH
51931: LD_VAR 0 1
51935: PUSH
51936: LD_VAR 0 2
51940: PUSH
51941: LD_INT 4
51943: MINUS
51944: PUSH
51945: LD_INT 3
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: LIST
51952: PUSH
51953: LD_VAR 0 1
51957: PUSH
51958: LD_INT 3
51960: MINUS
51961: PUSH
51962: LD_VAR 0 2
51966: PUSH
51967: LD_INT 3
51969: MINUS
51970: PUSH
51971: LD_INT 2
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: LIST
51978: PUSH
51979: LD_VAR 0 1
51983: PUSH
51984: LD_INT 4
51986: MINUS
51987: PUSH
51988: LD_VAR 0 2
51992: PUSH
51993: LD_INT 1
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: LIST
52000: PUSH
52001: LD_VAR 0 1
52005: PUSH
52006: LD_VAR 0 2
52010: PUSH
52011: LD_INT 3
52013: PLUS
52014: PUSH
52015: LD_INT 0
52017: PUSH
52018: EMPTY
52019: LIST
52020: LIST
52021: LIST
52022: PUSH
52023: LD_VAR 0 1
52027: PUSH
52028: LD_INT 4
52030: PLUS
52031: PUSH
52032: LD_VAR 0 2
52036: PUSH
52037: LD_INT 4
52039: PLUS
52040: PUSH
52041: LD_INT 5
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: LIST
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: ST_TO_ADDR
// end ; 2 :
52056: GO 52615
52058: LD_INT 2
52060: DOUBLE
52061: EQUAL
52062: IFTRUE 52066
52064: GO 52195
52066: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52067: LD_ADDR_VAR 0 5
52071: PUSH
52072: LD_VAR 0 1
52076: PUSH
52077: LD_VAR 0 2
52081: PUSH
52082: LD_INT 3
52084: MINUS
52085: PUSH
52086: LD_INT 3
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: LIST
52093: PUSH
52094: LD_VAR 0 1
52098: PUSH
52099: LD_INT 4
52101: PLUS
52102: PUSH
52103: LD_VAR 0 2
52107: PUSH
52108: LD_INT 4
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: LIST
52115: PUSH
52116: LD_VAR 0 1
52120: PUSH
52121: LD_VAR 0 2
52125: PUSH
52126: LD_INT 4
52128: PLUS
52129: PUSH
52130: LD_INT 0
52132: PUSH
52133: EMPTY
52134: LIST
52135: LIST
52136: LIST
52137: PUSH
52138: LD_VAR 0 1
52142: PUSH
52143: LD_INT 3
52145: MINUS
52146: PUSH
52147: LD_VAR 0 2
52151: PUSH
52152: LD_INT 1
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: PUSH
52160: LD_VAR 0 1
52164: PUSH
52165: LD_INT 4
52167: MINUS
52168: PUSH
52169: LD_VAR 0 2
52173: PUSH
52174: LD_INT 4
52176: MINUS
52177: PUSH
52178: LD_INT 2
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: LIST
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: LIST
52192: ST_TO_ADDR
// end ; 3 :
52193: GO 52615
52195: LD_INT 3
52197: DOUBLE
52198: EQUAL
52199: IFTRUE 52203
52201: GO 52336
52203: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52204: LD_ADDR_VAR 0 5
52208: PUSH
52209: LD_VAR 0 1
52213: PUSH
52214: LD_INT 3
52216: PLUS
52217: PUSH
52218: LD_VAR 0 2
52222: PUSH
52223: LD_INT 4
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: LIST
52230: PUSH
52231: LD_VAR 0 1
52235: PUSH
52236: LD_INT 4
52238: PLUS
52239: PUSH
52240: LD_VAR 0 2
52244: PUSH
52245: LD_INT 4
52247: PLUS
52248: PUSH
52249: LD_INT 5
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: LIST
52256: PUSH
52257: LD_VAR 0 1
52261: PUSH
52262: LD_INT 4
52264: MINUS
52265: PUSH
52266: LD_VAR 0 2
52270: PUSH
52271: LD_INT 1
52273: PUSH
52274: EMPTY
52275: LIST
52276: LIST
52277: LIST
52278: PUSH
52279: LD_VAR 0 1
52283: PUSH
52284: LD_VAR 0 2
52288: PUSH
52289: LD_INT 4
52291: MINUS
52292: PUSH
52293: LD_INT 3
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: LIST
52300: PUSH
52301: LD_VAR 0 1
52305: PUSH
52306: LD_INT 3
52308: MINUS
52309: PUSH
52310: LD_VAR 0 2
52314: PUSH
52315: LD_INT 3
52317: MINUS
52318: PUSH
52319: LD_INT 2
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: LIST
52326: PUSH
52327: EMPTY
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: ST_TO_ADDR
// end ; 4 :
52334: GO 52615
52336: LD_INT 4
52338: DOUBLE
52339: EQUAL
52340: IFTRUE 52344
52342: GO 52477
52344: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52345: LD_ADDR_VAR 0 5
52349: PUSH
52350: LD_VAR 0 1
52354: PUSH
52355: LD_VAR 0 2
52359: PUSH
52360: LD_INT 4
52362: PLUS
52363: PUSH
52364: LD_INT 0
52366: PUSH
52367: EMPTY
52368: LIST
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 1
52376: PUSH
52377: LD_INT 3
52379: PLUS
52380: PUSH
52381: LD_VAR 0 2
52385: PUSH
52386: LD_INT 3
52388: PLUS
52389: PUSH
52390: LD_INT 5
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: LIST
52397: PUSH
52398: LD_VAR 0 1
52402: PUSH
52403: LD_INT 4
52405: PLUS
52406: PUSH
52407: LD_VAR 0 2
52411: PUSH
52412: LD_INT 4
52414: PUSH
52415: EMPTY
52416: LIST
52417: LIST
52418: LIST
52419: PUSH
52420: LD_VAR 0 1
52424: PUSH
52425: LD_VAR 0 2
52429: PUSH
52430: LD_INT 3
52432: MINUS
52433: PUSH
52434: LD_INT 3
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: LIST
52441: PUSH
52442: LD_VAR 0 1
52446: PUSH
52447: LD_INT 4
52449: MINUS
52450: PUSH
52451: LD_VAR 0 2
52455: PUSH
52456: LD_INT 4
52458: MINUS
52459: PUSH
52460: LD_INT 2
52462: PUSH
52463: EMPTY
52464: LIST
52465: LIST
52466: LIST
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: ST_TO_ADDR
// end ; 5 :
52475: GO 52615
52477: LD_INT 5
52479: DOUBLE
52480: EQUAL
52481: IFTRUE 52485
52483: GO 52614
52485: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52486: LD_ADDR_VAR 0 5
52490: PUSH
52491: LD_VAR 0 1
52495: PUSH
52496: LD_INT 4
52498: MINUS
52499: PUSH
52500: LD_VAR 0 2
52504: PUSH
52505: LD_INT 1
52507: PUSH
52508: EMPTY
52509: LIST
52510: LIST
52511: LIST
52512: PUSH
52513: LD_VAR 0 1
52517: PUSH
52518: LD_VAR 0 2
52522: PUSH
52523: LD_INT 4
52525: MINUS
52526: PUSH
52527: LD_INT 3
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: PUSH
52535: LD_VAR 0 1
52539: PUSH
52540: LD_INT 4
52542: PLUS
52543: PUSH
52544: LD_VAR 0 2
52548: PUSH
52549: LD_INT 4
52551: PLUS
52552: PUSH
52553: LD_INT 5
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: LIST
52560: PUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_INT 3
52568: PLUS
52569: PUSH
52570: LD_VAR 0 2
52574: PUSH
52575: LD_INT 4
52577: PUSH
52578: EMPTY
52579: LIST
52580: LIST
52581: LIST
52582: PUSH
52583: LD_VAR 0 1
52587: PUSH
52588: LD_VAR 0 2
52592: PUSH
52593: LD_INT 3
52595: PLUS
52596: PUSH
52597: LD_INT 0
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: LIST
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: ST_TO_ADDR
// end ; end ;
52612: GO 52615
52614: POP
// result := list ;
52615: LD_ADDR_VAR 0 4
52619: PUSH
52620: LD_VAR 0 5
52624: ST_TO_ADDR
// end ;
52625: LD_VAR 0 4
52629: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52630: LD_INT 0
52632: PPUSH
52633: PPUSH
52634: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52635: LD_VAR 0 1
52639: NOT
52640: PUSH
52641: LD_VAR 0 2
52645: PUSH
52646: LD_INT 1
52648: PUSH
52649: LD_INT 2
52651: PUSH
52652: LD_INT 3
52654: PUSH
52655: LD_INT 4
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: LIST
52662: LIST
52663: IN
52664: NOT
52665: OR
52666: IFFALSE 52670
// exit ;
52668: GO 52753
// tmp := [ ] ;
52670: LD_ADDR_VAR 0 5
52674: PUSH
52675: EMPTY
52676: ST_TO_ADDR
// for i in units do
52677: LD_ADDR_VAR 0 4
52681: PUSH
52682: LD_VAR 0 1
52686: PUSH
52687: FOR_IN
52688: IFFALSE 52722
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52690: LD_ADDR_VAR 0 5
52694: PUSH
52695: LD_VAR 0 5
52699: PPUSH
52700: LD_VAR 0 4
52704: PPUSH
52705: LD_VAR 0 2
52709: PPUSH
52710: CALL_OW 259
52714: PPUSH
52715: CALL 54126 0 2
52719: ST_TO_ADDR
52720: GO 52687
52722: POP
52723: POP
// if not tmp then
52724: LD_VAR 0 5
52728: NOT
52729: IFFALSE 52733
// exit ;
52731: GO 52753
// result := SortListByListDesc ( units , tmp ) ;
52733: LD_ADDR_VAR 0 3
52737: PUSH
52738: LD_VAR 0 1
52742: PPUSH
52743: LD_VAR 0 5
52747: PPUSH
52748: CALL_OW 77
52752: ST_TO_ADDR
// end ;
52753: LD_VAR 0 3
52757: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52758: LD_INT 0
52760: PPUSH
52761: PPUSH
52762: PPUSH
// result := false ;
52763: LD_ADDR_VAR 0 3
52767: PUSH
52768: LD_INT 0
52770: ST_TO_ADDR
// if not building then
52771: LD_VAR 0 2
52775: NOT
52776: IFFALSE 52780
// exit ;
52778: GO 52918
// x := GetX ( building ) ;
52780: LD_ADDR_VAR 0 4
52784: PUSH
52785: LD_VAR 0 2
52789: PPUSH
52790: CALL_OW 250
52794: ST_TO_ADDR
// y := GetY ( building ) ;
52795: LD_ADDR_VAR 0 5
52799: PUSH
52800: LD_VAR 0 2
52804: PPUSH
52805: CALL_OW 251
52809: ST_TO_ADDR
// if not x or not y then
52810: LD_VAR 0 4
52814: NOT
52815: PUSH
52816: LD_VAR 0 5
52820: NOT
52821: OR
52822: IFFALSE 52826
// exit ;
52824: GO 52918
// if GetTaskList ( unit ) then
52826: LD_VAR 0 1
52830: PPUSH
52831: CALL_OW 437
52835: IFFALSE 52918
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52837: LD_STRING e
52839: PUSH
52840: LD_VAR 0 1
52844: PPUSH
52845: CALL_OW 437
52849: PUSH
52850: LD_INT 1
52852: ARRAY
52853: PUSH
52854: LD_INT 1
52856: ARRAY
52857: EQUAL
52858: PUSH
52859: LD_VAR 0 4
52863: PUSH
52864: LD_VAR 0 1
52868: PPUSH
52869: CALL_OW 437
52873: PUSH
52874: LD_INT 1
52876: ARRAY
52877: PUSH
52878: LD_INT 2
52880: ARRAY
52881: EQUAL
52882: AND
52883: PUSH
52884: LD_VAR 0 5
52888: PUSH
52889: LD_VAR 0 1
52893: PPUSH
52894: CALL_OW 437
52898: PUSH
52899: LD_INT 1
52901: ARRAY
52902: PUSH
52903: LD_INT 3
52905: ARRAY
52906: EQUAL
52907: AND
52908: IFFALSE 52918
// result := true end ;
52910: LD_ADDR_VAR 0 3
52914: PUSH
52915: LD_INT 1
52917: ST_TO_ADDR
// end ;
52918: LD_VAR 0 3
52922: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52923: LD_INT 0
52925: PPUSH
// result := false ;
52926: LD_ADDR_VAR 0 4
52930: PUSH
52931: LD_INT 0
52933: ST_TO_ADDR
// if GetTaskList ( unit ) then
52934: LD_VAR 0 1
52938: PPUSH
52939: CALL_OW 437
52943: IFFALSE 53026
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52945: LD_STRING M
52947: PUSH
52948: LD_VAR 0 1
52952: PPUSH
52953: CALL_OW 437
52957: PUSH
52958: LD_INT 1
52960: ARRAY
52961: PUSH
52962: LD_INT 1
52964: ARRAY
52965: EQUAL
52966: PUSH
52967: LD_VAR 0 2
52971: PUSH
52972: LD_VAR 0 1
52976: PPUSH
52977: CALL_OW 437
52981: PUSH
52982: LD_INT 1
52984: ARRAY
52985: PUSH
52986: LD_INT 2
52988: ARRAY
52989: EQUAL
52990: AND
52991: PUSH
52992: LD_VAR 0 3
52996: PUSH
52997: LD_VAR 0 1
53001: PPUSH
53002: CALL_OW 437
53006: PUSH
53007: LD_INT 1
53009: ARRAY
53010: PUSH
53011: LD_INT 3
53013: ARRAY
53014: EQUAL
53015: AND
53016: IFFALSE 53026
// result := true ;
53018: LD_ADDR_VAR 0 4
53022: PUSH
53023: LD_INT 1
53025: ST_TO_ADDR
// end ; end ;
53026: LD_VAR 0 4
53030: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53031: LD_INT 0
53033: PPUSH
53034: PPUSH
53035: PPUSH
53036: PPUSH
// if not unit or not area then
53037: LD_VAR 0 1
53041: NOT
53042: PUSH
53043: LD_VAR 0 2
53047: NOT
53048: OR
53049: IFFALSE 53053
// exit ;
53051: GO 53229
// tmp := AreaToList ( area , i ) ;
53053: LD_ADDR_VAR 0 6
53057: PUSH
53058: LD_VAR 0 2
53062: PPUSH
53063: LD_VAR 0 5
53067: PPUSH
53068: CALL_OW 517
53072: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53073: LD_ADDR_VAR 0 5
53077: PUSH
53078: DOUBLE
53079: LD_INT 1
53081: DEC
53082: ST_TO_ADDR
53083: LD_VAR 0 6
53087: PUSH
53088: LD_INT 1
53090: ARRAY
53091: PUSH
53092: FOR_TO
53093: IFFALSE 53227
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53095: LD_ADDR_VAR 0 7
53099: PUSH
53100: LD_VAR 0 6
53104: PUSH
53105: LD_INT 1
53107: ARRAY
53108: PUSH
53109: LD_VAR 0 5
53113: ARRAY
53114: PUSH
53115: LD_VAR 0 6
53119: PUSH
53120: LD_INT 2
53122: ARRAY
53123: PUSH
53124: LD_VAR 0 5
53128: ARRAY
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53134: LD_INT 92
53136: PUSH
53137: LD_VAR 0 7
53141: PUSH
53142: LD_INT 1
53144: ARRAY
53145: PUSH
53146: LD_VAR 0 7
53150: PUSH
53151: LD_INT 2
53153: ARRAY
53154: PUSH
53155: LD_INT 2
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: PPUSH
53164: CALL_OW 69
53168: PUSH
53169: LD_INT 0
53171: EQUAL
53172: IFFALSE 53225
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53174: LD_VAR 0 1
53178: PPUSH
53179: LD_VAR 0 7
53183: PUSH
53184: LD_INT 1
53186: ARRAY
53187: PPUSH
53188: LD_VAR 0 7
53192: PUSH
53193: LD_INT 2
53195: ARRAY
53196: PPUSH
53197: LD_VAR 0 3
53201: PPUSH
53202: CALL_OW 48
// result := IsPlaced ( unit ) ;
53206: LD_ADDR_VAR 0 4
53210: PUSH
53211: LD_VAR 0 1
53215: PPUSH
53216: CALL_OW 305
53220: ST_TO_ADDR
// exit ;
53221: POP
53222: POP
53223: GO 53229
// end ; end ;
53225: GO 53092
53227: POP
53228: POP
// end ;
53229: LD_VAR 0 4
53233: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53234: LD_INT 0
53236: PPUSH
53237: PPUSH
53238: PPUSH
// if not side or side > 8 then
53239: LD_VAR 0 1
53243: NOT
53244: PUSH
53245: LD_VAR 0 1
53249: PUSH
53250: LD_INT 8
53252: GREATER
53253: OR
53254: IFFALSE 53258
// exit ;
53256: GO 53445
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53258: LD_ADDR_VAR 0 4
53262: PUSH
53263: LD_INT 22
53265: PUSH
53266: LD_VAR 0 1
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: LD_INT 21
53277: PUSH
53278: LD_INT 3
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: PPUSH
53289: CALL_OW 69
53293: ST_TO_ADDR
// if not tmp then
53294: LD_VAR 0 4
53298: NOT
53299: IFFALSE 53303
// exit ;
53301: GO 53445
// enable_addtolog := true ;
53303: LD_ADDR_OWVAR 81
53307: PUSH
53308: LD_INT 1
53310: ST_TO_ADDR
// AddToLog ( [ ) ;
53311: LD_STRING [
53313: PPUSH
53314: CALL_OW 561
// for i in tmp do
53318: LD_ADDR_VAR 0 3
53322: PUSH
53323: LD_VAR 0 4
53327: PUSH
53328: FOR_IN
53329: IFFALSE 53436
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53331: LD_STRING [
53333: PUSH
53334: LD_VAR 0 3
53338: PPUSH
53339: CALL_OW 266
53343: STR
53344: PUSH
53345: LD_STRING , 
53347: STR
53348: PUSH
53349: LD_VAR 0 3
53353: PPUSH
53354: CALL_OW 250
53358: STR
53359: PUSH
53360: LD_STRING , 
53362: STR
53363: PUSH
53364: LD_VAR 0 3
53368: PPUSH
53369: CALL_OW 251
53373: STR
53374: PUSH
53375: LD_STRING , 
53377: STR
53378: PUSH
53379: LD_VAR 0 3
53383: PPUSH
53384: CALL_OW 254
53388: STR
53389: PUSH
53390: LD_STRING , 
53392: STR
53393: PUSH
53394: LD_VAR 0 3
53398: PPUSH
53399: LD_INT 1
53401: PPUSH
53402: CALL_OW 268
53406: STR
53407: PUSH
53408: LD_STRING , 
53410: STR
53411: PUSH
53412: LD_VAR 0 3
53416: PPUSH
53417: LD_INT 2
53419: PPUSH
53420: CALL_OW 268
53424: STR
53425: PUSH
53426: LD_STRING ],
53428: STR
53429: PPUSH
53430: CALL_OW 561
// end ;
53434: GO 53328
53436: POP
53437: POP
// AddToLog ( ]; ) ;
53438: LD_STRING ];
53440: PPUSH
53441: CALL_OW 561
// end ;
53445: LD_VAR 0 2
53449: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53450: LD_INT 0
53452: PPUSH
53453: PPUSH
53454: PPUSH
53455: PPUSH
53456: PPUSH
// if not area or not rate or not max then
53457: LD_VAR 0 1
53461: NOT
53462: PUSH
53463: LD_VAR 0 2
53467: NOT
53468: OR
53469: PUSH
53470: LD_VAR 0 4
53474: NOT
53475: OR
53476: IFFALSE 53480
// exit ;
53478: GO 53669
// while 1 do
53480: LD_INT 1
53482: IFFALSE 53669
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53484: LD_ADDR_VAR 0 9
53488: PUSH
53489: LD_VAR 0 1
53493: PPUSH
53494: LD_INT 1
53496: PPUSH
53497: CALL_OW 287
53501: PUSH
53502: LD_INT 10
53504: MUL
53505: ST_TO_ADDR
// r := rate / 10 ;
53506: LD_ADDR_VAR 0 7
53510: PUSH
53511: LD_VAR 0 2
53515: PUSH
53516: LD_INT 10
53518: DIVREAL
53519: ST_TO_ADDR
// time := 1 1$00 ;
53520: LD_ADDR_VAR 0 8
53524: PUSH
53525: LD_INT 2100
53527: ST_TO_ADDR
// if amount < min then
53528: LD_VAR 0 9
53532: PUSH
53533: LD_VAR 0 3
53537: LESS
53538: IFFALSE 53556
// r := r * 2 else
53540: LD_ADDR_VAR 0 7
53544: PUSH
53545: LD_VAR 0 7
53549: PUSH
53550: LD_INT 2
53552: MUL
53553: ST_TO_ADDR
53554: GO 53582
// if amount > max then
53556: LD_VAR 0 9
53560: PUSH
53561: LD_VAR 0 4
53565: GREATER
53566: IFFALSE 53582
// r := r / 2 ;
53568: LD_ADDR_VAR 0 7
53572: PUSH
53573: LD_VAR 0 7
53577: PUSH
53578: LD_INT 2
53580: DIVREAL
53581: ST_TO_ADDR
// time := time / r ;
53582: LD_ADDR_VAR 0 8
53586: PUSH
53587: LD_VAR 0 8
53591: PUSH
53592: LD_VAR 0 7
53596: DIVREAL
53597: ST_TO_ADDR
// if time < 0 then
53598: LD_VAR 0 8
53602: PUSH
53603: LD_INT 0
53605: LESS
53606: IFFALSE 53623
// time := time * - 1 ;
53608: LD_ADDR_VAR 0 8
53612: PUSH
53613: LD_VAR 0 8
53617: PUSH
53618: LD_INT 1
53620: NEG
53621: MUL
53622: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53623: LD_VAR 0 8
53627: PUSH
53628: LD_INT 35
53630: PPUSH
53631: LD_INT 875
53633: PPUSH
53634: CALL_OW 12
53638: PLUS
53639: PPUSH
53640: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53644: LD_INT 1
53646: PPUSH
53647: LD_INT 5
53649: PPUSH
53650: CALL_OW 12
53654: PPUSH
53655: LD_VAR 0 1
53659: PPUSH
53660: LD_INT 1
53662: PPUSH
53663: CALL_OW 55
// end ;
53667: GO 53480
// end ;
53669: LD_VAR 0 5
53673: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53674: LD_INT 0
53676: PPUSH
53677: PPUSH
53678: PPUSH
53679: PPUSH
53680: PPUSH
53681: PPUSH
53682: PPUSH
53683: PPUSH
// if not turrets or not factories then
53684: LD_VAR 0 1
53688: NOT
53689: PUSH
53690: LD_VAR 0 2
53694: NOT
53695: OR
53696: IFFALSE 53700
// exit ;
53698: GO 54007
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53700: LD_ADDR_VAR 0 10
53704: PUSH
53705: LD_INT 5
53707: PUSH
53708: LD_INT 6
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: PUSH
53715: LD_INT 2
53717: PUSH
53718: LD_INT 4
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: LD_INT 3
53727: PUSH
53728: LD_INT 5
53730: PUSH
53731: EMPTY
53732: LIST
53733: LIST
53734: PUSH
53735: EMPTY
53736: LIST
53737: LIST
53738: LIST
53739: PUSH
53740: LD_INT 24
53742: PUSH
53743: LD_INT 25
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: LD_INT 23
53752: PUSH
53753: LD_INT 27
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: PUSH
53760: EMPTY
53761: LIST
53762: LIST
53763: PUSH
53764: LD_INT 42
53766: PUSH
53767: LD_INT 43
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: PUSH
53774: LD_INT 44
53776: PUSH
53777: LD_INT 46
53779: PUSH
53780: EMPTY
53781: LIST
53782: LIST
53783: PUSH
53784: LD_INT 45
53786: PUSH
53787: LD_INT 47
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: LIST
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: LIST
53803: ST_TO_ADDR
// result := [ ] ;
53804: LD_ADDR_VAR 0 3
53808: PUSH
53809: EMPTY
53810: ST_TO_ADDR
// for i in turrets do
53811: LD_ADDR_VAR 0 4
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: FOR_IN
53822: IFFALSE 54005
// begin nat := GetNation ( i ) ;
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: CALL_OW 248
53838: ST_TO_ADDR
// weapon := 0 ;
53839: LD_ADDR_VAR 0 8
53843: PUSH
53844: LD_INT 0
53846: ST_TO_ADDR
// if not nat then
53847: LD_VAR 0 7
53851: NOT
53852: IFFALSE 53856
// continue ;
53854: GO 53821
// for j in list [ nat ] do
53856: LD_ADDR_VAR 0 5
53860: PUSH
53861: LD_VAR 0 10
53865: PUSH
53866: LD_VAR 0 7
53870: ARRAY
53871: PUSH
53872: FOR_IN
53873: IFFALSE 53914
// if GetBWeapon ( i ) = j [ 1 ] then
53875: LD_VAR 0 4
53879: PPUSH
53880: CALL_OW 269
53884: PUSH
53885: LD_VAR 0 5
53889: PUSH
53890: LD_INT 1
53892: ARRAY
53893: EQUAL
53894: IFFALSE 53912
// begin weapon := j [ 2 ] ;
53896: LD_ADDR_VAR 0 8
53900: PUSH
53901: LD_VAR 0 5
53905: PUSH
53906: LD_INT 2
53908: ARRAY
53909: ST_TO_ADDR
// break ;
53910: GO 53914
// end ;
53912: GO 53872
53914: POP
53915: POP
// if not weapon then
53916: LD_VAR 0 8
53920: NOT
53921: IFFALSE 53925
// continue ;
53923: GO 53821
// for k in factories do
53925: LD_ADDR_VAR 0 6
53929: PUSH
53930: LD_VAR 0 2
53934: PUSH
53935: FOR_IN
53936: IFFALSE 54001
// begin weapons := AvailableWeaponList ( k ) ;
53938: LD_ADDR_VAR 0 9
53942: PUSH
53943: LD_VAR 0 6
53947: PPUSH
53948: CALL_OW 478
53952: ST_TO_ADDR
// if not weapons then
53953: LD_VAR 0 9
53957: NOT
53958: IFFALSE 53962
// continue ;
53960: GO 53935
// if weapon in weapons then
53962: LD_VAR 0 8
53966: PUSH
53967: LD_VAR 0 9
53971: IN
53972: IFFALSE 53999
// begin result := [ i , weapon ] ;
53974: LD_ADDR_VAR 0 3
53978: PUSH
53979: LD_VAR 0 4
53983: PUSH
53984: LD_VAR 0 8
53988: PUSH
53989: EMPTY
53990: LIST
53991: LIST
53992: ST_TO_ADDR
// exit ;
53993: POP
53994: POP
53995: POP
53996: POP
53997: GO 54007
// end ; end ;
53999: GO 53935
54001: POP
54002: POP
// end ;
54003: GO 53821
54005: POP
54006: POP
// end ;
54007: LD_VAR 0 3
54011: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54012: LD_INT 0
54014: PPUSH
// if not side or side > 8 then
54015: LD_VAR 0 3
54019: NOT
54020: PUSH
54021: LD_VAR 0 3
54025: PUSH
54026: LD_INT 8
54028: GREATER
54029: OR
54030: IFFALSE 54034
// exit ;
54032: GO 54093
// if not range then
54034: LD_VAR 0 4
54038: NOT
54039: IFFALSE 54050
// range := - 12 ;
54041: LD_ADDR_VAR 0 4
54045: PUSH
54046: LD_INT 12
54048: NEG
54049: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54050: LD_VAR 0 1
54054: PPUSH
54055: LD_VAR 0 2
54059: PPUSH
54060: LD_VAR 0 3
54064: PPUSH
54065: LD_VAR 0 4
54069: PPUSH
54070: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54074: LD_VAR 0 1
54078: PPUSH
54079: LD_VAR 0 2
54083: PPUSH
54084: LD_VAR 0 3
54088: PPUSH
54089: CALL_OW 331
// end ;
54093: LD_VAR 0 5
54097: RET
// export function Video ( mode ) ; begin
54098: LD_INT 0
54100: PPUSH
// ingame_video = mode ;
54101: LD_ADDR_OWVAR 52
54105: PUSH
54106: LD_VAR 0 1
54110: ST_TO_ADDR
// interface_hidden = mode ;
54111: LD_ADDR_OWVAR 54
54115: PUSH
54116: LD_VAR 0 1
54120: ST_TO_ADDR
// end ;
54121: LD_VAR 0 2
54125: RET
// export function Join ( array , element ) ; begin
54126: LD_INT 0
54128: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54129: LD_ADDR_VAR 0 3
54133: PUSH
54134: LD_VAR 0 1
54138: PPUSH
54139: LD_VAR 0 1
54143: PUSH
54144: LD_INT 1
54146: PLUS
54147: PPUSH
54148: LD_VAR 0 2
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// end ;
54158: LD_VAR 0 3
54162: RET
// export function JoinUnion ( array , element ) ; begin
54163: LD_INT 0
54165: PPUSH
// result := array union element ;
54166: LD_ADDR_VAR 0 3
54170: PUSH
54171: LD_VAR 0 1
54175: PUSH
54176: LD_VAR 0 2
54180: UNION
54181: ST_TO_ADDR
// end ;
54182: LD_VAR 0 3
54186: RET
// export function GetBehemoths ( side ) ; begin
54187: LD_INT 0
54189: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
54190: LD_ADDR_VAR 0 2
54194: PUSH
54195: LD_INT 22
54197: PUSH
54198: LD_VAR 0 1
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PUSH
54207: LD_INT 31
54209: PUSH
54210: LD_INT 25
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PPUSH
54221: CALL_OW 69
54225: ST_TO_ADDR
// end ;
54226: LD_VAR 0 2
54230: RET
// export function Shuffle ( array ) ; var i , index ; begin
54231: LD_INT 0
54233: PPUSH
54234: PPUSH
54235: PPUSH
// result := [ ] ;
54236: LD_ADDR_VAR 0 2
54240: PUSH
54241: EMPTY
54242: ST_TO_ADDR
// if not array then
54243: LD_VAR 0 1
54247: NOT
54248: IFFALSE 54252
// exit ;
54250: GO 54351
// Randomize ;
54252: CALL_OW 10
// for i = array downto 1 do
54256: LD_ADDR_VAR 0 3
54260: PUSH
54261: DOUBLE
54262: LD_VAR 0 1
54266: INC
54267: ST_TO_ADDR
54268: LD_INT 1
54270: PUSH
54271: FOR_DOWNTO
54272: IFFALSE 54349
// begin index := rand ( 1 , array ) ;
54274: LD_ADDR_VAR 0 4
54278: PUSH
54279: LD_INT 1
54281: PPUSH
54282: LD_VAR 0 1
54286: PPUSH
54287: CALL_OW 12
54291: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54292: LD_ADDR_VAR 0 2
54296: PUSH
54297: LD_VAR 0 2
54301: PPUSH
54302: LD_VAR 0 2
54306: PUSH
54307: LD_INT 1
54309: PLUS
54310: PPUSH
54311: LD_VAR 0 1
54315: PUSH
54316: LD_VAR 0 4
54320: ARRAY
54321: PPUSH
54322: CALL_OW 2
54326: ST_TO_ADDR
// array := Delete ( array , index ) ;
54327: LD_ADDR_VAR 0 1
54331: PUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: LD_VAR 0 4
54341: PPUSH
54342: CALL_OW 3
54346: ST_TO_ADDR
// end ;
54347: GO 54271
54349: POP
54350: POP
// end ;
54351: LD_VAR 0 2
54355: RET
// export function GetBaseMaterials ( base ) ; begin
54356: LD_INT 0
54358: PPUSH
// result := [ 0 , 0 , 0 ] ;
54359: LD_ADDR_VAR 0 2
54363: PUSH
54364: LD_INT 0
54366: PUSH
54367: LD_INT 0
54369: PUSH
54370: LD_INT 0
54372: PUSH
54373: EMPTY
54374: LIST
54375: LIST
54376: LIST
54377: ST_TO_ADDR
// if not base then
54378: LD_VAR 0 1
54382: NOT
54383: IFFALSE 54387
// exit ;
54385: GO 54436
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54387: LD_ADDR_VAR 0 2
54391: PUSH
54392: LD_VAR 0 1
54396: PPUSH
54397: LD_INT 1
54399: PPUSH
54400: CALL_OW 275
54404: PUSH
54405: LD_VAR 0 1
54409: PPUSH
54410: LD_INT 2
54412: PPUSH
54413: CALL_OW 275
54417: PUSH
54418: LD_VAR 0 1
54422: PPUSH
54423: LD_INT 3
54425: PPUSH
54426: CALL_OW 275
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: LIST
54435: ST_TO_ADDR
// end ;
54436: LD_VAR 0 2
54440: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54441: LD_INT 0
54443: PPUSH
54444: PPUSH
// result := array ;
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: LD_VAR 0 1
54454: ST_TO_ADDR
// if size >= result then
54455: LD_VAR 0 2
54459: PUSH
54460: LD_VAR 0 3
54464: GREATEREQUAL
54465: IFFALSE 54469
// exit ;
54467: GO 54519
// if size then
54469: LD_VAR 0 2
54473: IFFALSE 54519
// for i := array downto size do
54475: LD_ADDR_VAR 0 4
54479: PUSH
54480: DOUBLE
54481: LD_VAR 0 1
54485: INC
54486: ST_TO_ADDR
54487: LD_VAR 0 2
54491: PUSH
54492: FOR_DOWNTO
54493: IFFALSE 54517
// result := Delete ( result , result ) ;
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: LD_VAR 0 3
54504: PPUSH
54505: LD_VAR 0 3
54509: PPUSH
54510: CALL_OW 3
54514: ST_TO_ADDR
54515: GO 54492
54517: POP
54518: POP
// end ;
54519: LD_VAR 0 3
54523: RET
// export function ComExit ( unit ) ; var tmp ; begin
54524: LD_INT 0
54526: PPUSH
54527: PPUSH
// if not IsInUnit ( unit ) then
54528: LD_VAR 0 1
54532: PPUSH
54533: CALL_OW 310
54537: NOT
54538: IFFALSE 54542
// exit ;
54540: GO 54602
// tmp := IsInUnit ( unit ) ;
54542: LD_ADDR_VAR 0 3
54546: PUSH
54547: LD_VAR 0 1
54551: PPUSH
54552: CALL_OW 310
54556: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54557: LD_VAR 0 3
54561: PPUSH
54562: CALL_OW 247
54566: PUSH
54567: LD_INT 2
54569: EQUAL
54570: IFFALSE 54583
// ComExitVehicle ( unit ) else
54572: LD_VAR 0 1
54576: PPUSH
54577: CALL_OW 121
54581: GO 54592
// ComExitBuilding ( unit ) ;
54583: LD_VAR 0 1
54587: PPUSH
54588: CALL_OW 122
// result := tmp ;
54592: LD_ADDR_VAR 0 2
54596: PUSH
54597: LD_VAR 0 3
54601: ST_TO_ADDR
// end ;
54602: LD_VAR 0 2
54606: RET
// export function ComExitAll ( units ) ; var i ; begin
54607: LD_INT 0
54609: PPUSH
54610: PPUSH
// if not units then
54611: LD_VAR 0 1
54615: NOT
54616: IFFALSE 54620
// exit ;
54618: GO 54646
// for i in units do
54620: LD_ADDR_VAR 0 3
54624: PUSH
54625: LD_VAR 0 1
54629: PUSH
54630: FOR_IN
54631: IFFALSE 54644
// ComExit ( i ) ;
54633: LD_VAR 0 3
54637: PPUSH
54638: CALL 54524 0 1
54642: GO 54630
54644: POP
54645: POP
// end ;
54646: LD_VAR 0 2
54650: RET
// export function ResetHc ; begin
54651: LD_INT 0
54653: PPUSH
// InitHc ;
54654: CALL_OW 19
// hc_importance := 0 ;
54658: LD_ADDR_OWVAR 32
54662: PUSH
54663: LD_INT 0
54665: ST_TO_ADDR
// end ;
54666: LD_VAR 0 1
54670: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54671: LD_INT 0
54673: PPUSH
54674: PPUSH
54675: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54676: LD_ADDR_VAR 0 6
54680: PUSH
54681: LD_VAR 0 1
54685: PUSH
54686: LD_VAR 0 3
54690: PLUS
54691: PUSH
54692: LD_INT 2
54694: DIV
54695: ST_TO_ADDR
// if _x < 0 then
54696: LD_VAR 0 6
54700: PUSH
54701: LD_INT 0
54703: LESS
54704: IFFALSE 54721
// _x := _x * - 1 ;
54706: LD_ADDR_VAR 0 6
54710: PUSH
54711: LD_VAR 0 6
54715: PUSH
54716: LD_INT 1
54718: NEG
54719: MUL
54720: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54721: LD_ADDR_VAR 0 7
54725: PUSH
54726: LD_VAR 0 2
54730: PUSH
54731: LD_VAR 0 4
54735: PLUS
54736: PUSH
54737: LD_INT 2
54739: DIV
54740: ST_TO_ADDR
// if _y < 0 then
54741: LD_VAR 0 7
54745: PUSH
54746: LD_INT 0
54748: LESS
54749: IFFALSE 54766
// _y := _y * - 1 ;
54751: LD_ADDR_VAR 0 7
54755: PUSH
54756: LD_VAR 0 7
54760: PUSH
54761: LD_INT 1
54763: NEG
54764: MUL
54765: ST_TO_ADDR
// result := [ _x , _y ] ;
54766: LD_ADDR_VAR 0 5
54770: PUSH
54771: LD_VAR 0 6
54775: PUSH
54776: LD_VAR 0 7
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: ST_TO_ADDR
// end ;
54785: LD_VAR 0 5
54789: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54790: LD_INT 0
54792: PPUSH
54793: PPUSH
54794: PPUSH
54795: PPUSH
// task := GetTaskList ( unit ) ;
54796: LD_ADDR_VAR 0 7
54800: PUSH
54801: LD_VAR 0 1
54805: PPUSH
54806: CALL_OW 437
54810: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54811: LD_VAR 0 7
54815: NOT
54816: PUSH
54817: LD_VAR 0 1
54821: PPUSH
54822: LD_VAR 0 2
54826: PPUSH
54827: CALL_OW 308
54831: NOT
54832: AND
54833: IFFALSE 54837
// exit ;
54835: GO 54955
// if IsInArea ( unit , area ) then
54837: LD_VAR 0 1
54841: PPUSH
54842: LD_VAR 0 2
54846: PPUSH
54847: CALL_OW 308
54851: IFFALSE 54869
// begin ComMoveToArea ( unit , goAway ) ;
54853: LD_VAR 0 1
54857: PPUSH
54858: LD_VAR 0 3
54862: PPUSH
54863: CALL_OW 113
// exit ;
54867: GO 54955
// end ; if task [ 1 ] [ 1 ] <> M then
54869: LD_VAR 0 7
54873: PUSH
54874: LD_INT 1
54876: ARRAY
54877: PUSH
54878: LD_INT 1
54880: ARRAY
54881: PUSH
54882: LD_STRING M
54884: NONEQUAL
54885: IFFALSE 54889
// exit ;
54887: GO 54955
// x := task [ 1 ] [ 2 ] ;
54889: LD_ADDR_VAR 0 5
54893: PUSH
54894: LD_VAR 0 7
54898: PUSH
54899: LD_INT 1
54901: ARRAY
54902: PUSH
54903: LD_INT 2
54905: ARRAY
54906: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54907: LD_ADDR_VAR 0 6
54911: PUSH
54912: LD_VAR 0 7
54916: PUSH
54917: LD_INT 1
54919: ARRAY
54920: PUSH
54921: LD_INT 3
54923: ARRAY
54924: ST_TO_ADDR
// if InArea ( x , y , area ) then
54925: LD_VAR 0 5
54929: PPUSH
54930: LD_VAR 0 6
54934: PPUSH
54935: LD_VAR 0 2
54939: PPUSH
54940: CALL_OW 309
54944: IFFALSE 54955
// ComStop ( unit ) ;
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 141
// end ;
54955: LD_VAR 0 4
54959: RET
// export function Abs ( value ) ; begin
54960: LD_INT 0
54962: PPUSH
// result := value ;
54963: LD_ADDR_VAR 0 2
54967: PUSH
54968: LD_VAR 0 1
54972: ST_TO_ADDR
// if value < 0 then
54973: LD_VAR 0 1
54977: PUSH
54978: LD_INT 0
54980: LESS
54981: IFFALSE 54998
// result := value * - 1 ;
54983: LD_ADDR_VAR 0 2
54987: PUSH
54988: LD_VAR 0 1
54992: PUSH
54993: LD_INT 1
54995: NEG
54996: MUL
54997: ST_TO_ADDR
// end ;
54998: LD_VAR 0 2
55002: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55003: LD_INT 0
55005: PPUSH
55006: PPUSH
55007: PPUSH
55008: PPUSH
55009: PPUSH
55010: PPUSH
55011: PPUSH
55012: PPUSH
// if not unit or not building then
55013: LD_VAR 0 1
55017: NOT
55018: PUSH
55019: LD_VAR 0 2
55023: NOT
55024: OR
55025: IFFALSE 55029
// exit ;
55027: GO 55255
// x := GetX ( building ) ;
55029: LD_ADDR_VAR 0 4
55033: PUSH
55034: LD_VAR 0 2
55038: PPUSH
55039: CALL_OW 250
55043: ST_TO_ADDR
// y := GetY ( building ) ;
55044: LD_ADDR_VAR 0 6
55048: PUSH
55049: LD_VAR 0 2
55053: PPUSH
55054: CALL_OW 251
55058: ST_TO_ADDR
// d := GetDir ( building ) ;
55059: LD_ADDR_VAR 0 8
55063: PUSH
55064: LD_VAR 0 2
55068: PPUSH
55069: CALL_OW 254
55073: ST_TO_ADDR
// r := 4 ;
55074: LD_ADDR_VAR 0 9
55078: PUSH
55079: LD_INT 4
55081: ST_TO_ADDR
// for i := 1 to 5 do
55082: LD_ADDR_VAR 0 10
55086: PUSH
55087: DOUBLE
55088: LD_INT 1
55090: DEC
55091: ST_TO_ADDR
55092: LD_INT 5
55094: PUSH
55095: FOR_TO
55096: IFFALSE 55253
// begin _x := ShiftX ( x , d , r + i ) ;
55098: LD_ADDR_VAR 0 5
55102: PUSH
55103: LD_VAR 0 4
55107: PPUSH
55108: LD_VAR 0 8
55112: PPUSH
55113: LD_VAR 0 9
55117: PUSH
55118: LD_VAR 0 10
55122: PLUS
55123: PPUSH
55124: CALL_OW 272
55128: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55129: LD_ADDR_VAR 0 7
55133: PUSH
55134: LD_VAR 0 6
55138: PPUSH
55139: LD_VAR 0 8
55143: PPUSH
55144: LD_VAR 0 9
55148: PUSH
55149: LD_VAR 0 10
55153: PLUS
55154: PPUSH
55155: CALL_OW 273
55159: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
55160: LD_VAR 0 5
55164: PPUSH
55165: LD_VAR 0 7
55169: PPUSH
55170: CALL_OW 488
55174: PUSH
55175: LD_VAR 0 5
55179: PPUSH
55180: LD_VAR 0 7
55184: PPUSH
55185: CALL_OW 428
55189: PPUSH
55190: CALL_OW 247
55194: PUSH
55195: LD_INT 3
55197: PUSH
55198: LD_INT 2
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: IN
55205: NOT
55206: AND
55207: IFFALSE 55251
// begin ComMoveXY ( unit , _x , _y ) ;
55209: LD_VAR 0 1
55213: PPUSH
55214: LD_VAR 0 5
55218: PPUSH
55219: LD_VAR 0 7
55223: PPUSH
55224: CALL_OW 111
// result := [ _x , _y ] ;
55228: LD_ADDR_VAR 0 3
55232: PUSH
55233: LD_VAR 0 5
55237: PUSH
55238: LD_VAR 0 7
55242: PUSH
55243: EMPTY
55244: LIST
55245: LIST
55246: ST_TO_ADDR
// exit ;
55247: POP
55248: POP
55249: GO 55255
// end ; end ;
55251: GO 55095
55253: POP
55254: POP
// end ;
55255: LD_VAR 0 3
55259: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
55260: LD_INT 0
55262: PPUSH
55263: PPUSH
55264: PPUSH
// result := 0 ;
55265: LD_ADDR_VAR 0 3
55269: PUSH
55270: LD_INT 0
55272: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
55273: LD_VAR 0 1
55277: PUSH
55278: LD_INT 0
55280: LESS
55281: PUSH
55282: LD_VAR 0 1
55286: PUSH
55287: LD_INT 8
55289: GREATER
55290: OR
55291: PUSH
55292: LD_VAR 0 2
55296: PUSH
55297: LD_INT 0
55299: LESS
55300: OR
55301: PUSH
55302: LD_VAR 0 2
55306: PUSH
55307: LD_INT 8
55309: GREATER
55310: OR
55311: IFFALSE 55315
// exit ;
55313: GO 55390
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55315: LD_ADDR_VAR 0 4
55319: PUSH
55320: LD_INT 22
55322: PUSH
55323: LD_VAR 0 2
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: CALL_OW 69
55336: PUSH
55337: FOR_IN
55338: IFFALSE 55388
// begin un := UnitShoot ( i ) ;
55340: LD_ADDR_VAR 0 5
55344: PUSH
55345: LD_VAR 0 4
55349: PPUSH
55350: CALL_OW 504
55354: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55355: LD_VAR 0 5
55359: PPUSH
55360: CALL_OW 255
55364: PUSH
55365: LD_VAR 0 1
55369: EQUAL
55370: IFFALSE 55386
// begin result := un ;
55372: LD_ADDR_VAR 0 3
55376: PUSH
55377: LD_VAR 0 5
55381: ST_TO_ADDR
// exit ;
55382: POP
55383: POP
55384: GO 55390
// end ; end ;
55386: GO 55337
55388: POP
55389: POP
// end ;
55390: LD_VAR 0 3
55394: RET
// export function GetCargoBay ( units ) ; begin
55395: LD_INT 0
55397: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55398: LD_ADDR_VAR 0 2
55402: PUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: LD_INT 2
55410: PUSH
55411: LD_INT 34
55413: PUSH
55414: LD_INT 12
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: LD_INT 34
55423: PUSH
55424: LD_INT 51
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 34
55433: PUSH
55434: LD_INT 32
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: LD_INT 34
55443: PUSH
55444: LD_INT 89
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: PPUSH
55458: CALL_OW 72
55462: ST_TO_ADDR
// end ;
55463: LD_VAR 0 2
55467: RET
// export function Negate ( value ) ; begin
55468: LD_INT 0
55470: PPUSH
// result := not value ;
55471: LD_ADDR_VAR 0 2
55475: PUSH
55476: LD_VAR 0 1
55480: NOT
55481: ST_TO_ADDR
// end ;
55482: LD_VAR 0 2
55486: RET
// export function Inc ( value ) ; begin
55487: LD_INT 0
55489: PPUSH
// result := value + 1 ;
55490: LD_ADDR_VAR 0 2
55494: PUSH
55495: LD_VAR 0 1
55499: PUSH
55500: LD_INT 1
55502: PLUS
55503: ST_TO_ADDR
// end ;
55504: LD_VAR 0 2
55508: RET
// export function Dec ( value ) ; begin
55509: LD_INT 0
55511: PPUSH
// result := value - 1 ;
55512: LD_ADDR_VAR 0 2
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_INT 1
55524: MINUS
55525: ST_TO_ADDR
// end ;
55526: LD_VAR 0 2
55530: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55531: LD_INT 0
55533: PPUSH
55534: PPUSH
55535: PPUSH
55536: PPUSH
55537: PPUSH
55538: PPUSH
55539: PPUSH
55540: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55541: LD_VAR 0 1
55545: PPUSH
55546: LD_VAR 0 2
55550: PPUSH
55551: CALL_OW 488
55555: NOT
55556: PUSH
55557: LD_VAR 0 3
55561: PPUSH
55562: LD_VAR 0 4
55566: PPUSH
55567: CALL_OW 488
55571: NOT
55572: OR
55573: IFFALSE 55586
// begin result := - 1 ;
55575: LD_ADDR_VAR 0 5
55579: PUSH
55580: LD_INT 1
55582: NEG
55583: ST_TO_ADDR
// exit ;
55584: GO 55821
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55586: LD_ADDR_VAR 0 12
55590: PUSH
55591: LD_VAR 0 1
55595: PPUSH
55596: LD_VAR 0 2
55600: PPUSH
55601: LD_VAR 0 3
55605: PPUSH
55606: LD_VAR 0 4
55610: PPUSH
55611: CALL 54671 0 4
55615: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55616: LD_ADDR_VAR 0 11
55620: PUSH
55621: LD_VAR 0 1
55625: PPUSH
55626: LD_VAR 0 2
55630: PPUSH
55631: LD_VAR 0 12
55635: PUSH
55636: LD_INT 1
55638: ARRAY
55639: PPUSH
55640: LD_VAR 0 12
55644: PUSH
55645: LD_INT 2
55647: ARRAY
55648: PPUSH
55649: CALL_OW 298
55653: ST_TO_ADDR
// distance := 9999 ;
55654: LD_ADDR_VAR 0 10
55658: PUSH
55659: LD_INT 9999
55661: ST_TO_ADDR
// for i := 0 to 5 do
55662: LD_ADDR_VAR 0 6
55666: PUSH
55667: DOUBLE
55668: LD_INT 0
55670: DEC
55671: ST_TO_ADDR
55672: LD_INT 5
55674: PUSH
55675: FOR_TO
55676: IFFALSE 55819
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55678: LD_ADDR_VAR 0 7
55682: PUSH
55683: LD_VAR 0 1
55687: PPUSH
55688: LD_VAR 0 6
55692: PPUSH
55693: LD_VAR 0 11
55697: PPUSH
55698: CALL_OW 272
55702: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55703: LD_ADDR_VAR 0 8
55707: PUSH
55708: LD_VAR 0 2
55712: PPUSH
55713: LD_VAR 0 6
55717: PPUSH
55718: LD_VAR 0 11
55722: PPUSH
55723: CALL_OW 273
55727: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55728: LD_VAR 0 7
55732: PPUSH
55733: LD_VAR 0 8
55737: PPUSH
55738: CALL_OW 488
55742: NOT
55743: IFFALSE 55747
// continue ;
55745: GO 55675
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55747: LD_ADDR_VAR 0 9
55751: PUSH
55752: LD_VAR 0 12
55756: PUSH
55757: LD_INT 1
55759: ARRAY
55760: PPUSH
55761: LD_VAR 0 12
55765: PUSH
55766: LD_INT 2
55768: ARRAY
55769: PPUSH
55770: LD_VAR 0 7
55774: PPUSH
55775: LD_VAR 0 8
55779: PPUSH
55780: CALL_OW 298
55784: ST_TO_ADDR
// if tmp < distance then
55785: LD_VAR 0 9
55789: PUSH
55790: LD_VAR 0 10
55794: LESS
55795: IFFALSE 55817
// begin result := i ;
55797: LD_ADDR_VAR 0 5
55801: PUSH
55802: LD_VAR 0 6
55806: ST_TO_ADDR
// distance := tmp ;
55807: LD_ADDR_VAR 0 10
55811: PUSH
55812: LD_VAR 0 9
55816: ST_TO_ADDR
// end ; end ;
55817: GO 55675
55819: POP
55820: POP
// end ;
55821: LD_VAR 0 5
55825: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55826: LD_INT 0
55828: PPUSH
55829: PPUSH
// if not driver or not IsInUnit ( driver ) then
55830: LD_VAR 0 1
55834: NOT
55835: PUSH
55836: LD_VAR 0 1
55840: PPUSH
55841: CALL_OW 310
55845: NOT
55846: OR
55847: IFFALSE 55851
// exit ;
55849: GO 55941
// vehicle := IsInUnit ( driver ) ;
55851: LD_ADDR_VAR 0 3
55855: PUSH
55856: LD_VAR 0 1
55860: PPUSH
55861: CALL_OW 310
55865: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55866: LD_VAR 0 1
55870: PPUSH
55871: LD_STRING \
55873: PUSH
55874: LD_INT 0
55876: PUSH
55877: LD_INT 0
55879: PUSH
55880: LD_INT 0
55882: PUSH
55883: LD_INT 0
55885: PUSH
55886: LD_INT 0
55888: PUSH
55889: LD_INT 0
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: LIST
55898: LIST
55899: LIST
55900: PUSH
55901: LD_STRING E
55903: PUSH
55904: LD_INT 0
55906: PUSH
55907: LD_INT 0
55909: PUSH
55910: LD_VAR 0 3
55914: PUSH
55915: LD_INT 0
55917: PUSH
55918: LD_INT 0
55920: PUSH
55921: LD_INT 0
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: LIST
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: PPUSH
55937: CALL_OW 446
// end ;
55941: LD_VAR 0 2
55945: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55946: LD_INT 0
55948: PPUSH
55949: PPUSH
// if not driver or not IsInUnit ( driver ) then
55950: LD_VAR 0 1
55954: NOT
55955: PUSH
55956: LD_VAR 0 1
55960: PPUSH
55961: CALL_OW 310
55965: NOT
55966: OR
55967: IFFALSE 55971
// exit ;
55969: GO 56061
// vehicle := IsInUnit ( driver ) ;
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: CALL_OW 310
55985: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55986: LD_VAR 0 1
55990: PPUSH
55991: LD_STRING \
55993: PUSH
55994: LD_INT 0
55996: PUSH
55997: LD_INT 0
55999: PUSH
56000: LD_INT 0
56002: PUSH
56003: LD_INT 0
56005: PUSH
56006: LD_INT 0
56008: PUSH
56009: LD_INT 0
56011: PUSH
56012: EMPTY
56013: LIST
56014: LIST
56015: LIST
56016: LIST
56017: LIST
56018: LIST
56019: LIST
56020: PUSH
56021: LD_STRING E
56023: PUSH
56024: LD_INT 0
56026: PUSH
56027: LD_INT 0
56029: PUSH
56030: LD_VAR 0 3
56034: PUSH
56035: LD_INT 0
56037: PUSH
56038: LD_INT 0
56040: PUSH
56041: LD_INT 0
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: PPUSH
56057: CALL_OW 447
// end ;
56061: LD_VAR 0 2
56065: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// tmp := [ ] ;
56071: LD_ADDR_VAR 0 5
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// for i in units do
56078: LD_ADDR_VAR 0 4
56082: PUSH
56083: LD_VAR 0 1
56087: PUSH
56088: FOR_IN
56089: IFFALSE 56127
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56091: LD_ADDR_VAR 0 5
56095: PUSH
56096: LD_VAR 0 5
56100: PPUSH
56101: LD_VAR 0 5
56105: PUSH
56106: LD_INT 1
56108: PLUS
56109: PPUSH
56110: LD_VAR 0 4
56114: PPUSH
56115: CALL_OW 256
56119: PPUSH
56120: CALL_OW 2
56124: ST_TO_ADDR
56125: GO 56088
56127: POP
56128: POP
// if not tmp then
56129: LD_VAR 0 5
56133: NOT
56134: IFFALSE 56138
// exit ;
56136: GO 56186
// if asc then
56138: LD_VAR 0 2
56142: IFFALSE 56166
// result := SortListByListAsc ( units , tmp ) else
56144: LD_ADDR_VAR 0 3
56148: PUSH
56149: LD_VAR 0 1
56153: PPUSH
56154: LD_VAR 0 5
56158: PPUSH
56159: CALL_OW 76
56163: ST_TO_ADDR
56164: GO 56186
// result := SortListByListDesc ( units , tmp ) ;
56166: LD_ADDR_VAR 0 3
56170: PUSH
56171: LD_VAR 0 1
56175: PPUSH
56176: LD_VAR 0 5
56180: PPUSH
56181: CALL_OW 77
56185: ST_TO_ADDR
// end ;
56186: LD_VAR 0 3
56190: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
56191: LD_INT 0
56193: PPUSH
56194: PPUSH
// task := GetTaskList ( mech ) ;
56195: LD_ADDR_VAR 0 4
56199: PUSH
56200: LD_VAR 0 1
56204: PPUSH
56205: CALL_OW 437
56209: ST_TO_ADDR
// if not task then
56210: LD_VAR 0 4
56214: NOT
56215: IFFALSE 56219
// exit ;
56217: GO 56261
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
56219: LD_ADDR_VAR 0 3
56223: PUSH
56224: LD_VAR 0 4
56228: PUSH
56229: LD_INT 1
56231: ARRAY
56232: PUSH
56233: LD_INT 1
56235: ARRAY
56236: PUSH
56237: LD_STRING r
56239: EQUAL
56240: PUSH
56241: LD_VAR 0 4
56245: PUSH
56246: LD_INT 1
56248: ARRAY
56249: PUSH
56250: LD_INT 4
56252: ARRAY
56253: PUSH
56254: LD_VAR 0 2
56258: EQUAL
56259: AND
56260: ST_TO_ADDR
// end ;
56261: LD_VAR 0 3
56265: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
56266: LD_INT 0
56268: PPUSH
// SetDir ( unit , d ) ;
56269: LD_VAR 0 1
56273: PPUSH
56274: LD_VAR 0 4
56278: PPUSH
56279: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
56283: LD_VAR 0 1
56287: PPUSH
56288: LD_VAR 0 2
56292: PPUSH
56293: LD_VAR 0 3
56297: PPUSH
56298: LD_VAR 0 5
56302: PPUSH
56303: CALL_OW 48
// end ;
56307: LD_VAR 0 6
56311: RET
// export function ToNaturalNumber ( number ) ; begin
56312: LD_INT 0
56314: PPUSH
// result := number div 1 ;
56315: LD_ADDR_VAR 0 2
56319: PUSH
56320: LD_VAR 0 1
56324: PUSH
56325: LD_INT 1
56327: DIV
56328: ST_TO_ADDR
// if number < 0 then
56329: LD_VAR 0 1
56333: PUSH
56334: LD_INT 0
56336: LESS
56337: IFFALSE 56347
// result := 0 ;
56339: LD_ADDR_VAR 0 2
56343: PUSH
56344: LD_INT 0
56346: ST_TO_ADDR
// end ;
56347: LD_VAR 0 2
56351: RET
// export function SortByClass ( units , class ) ; var un ; begin
56352: LD_INT 0
56354: PPUSH
56355: PPUSH
// if not units or not class then
56356: LD_VAR 0 1
56360: NOT
56361: PUSH
56362: LD_VAR 0 2
56366: NOT
56367: OR
56368: IFFALSE 56372
// exit ;
56370: GO 56467
// result := [ ] ;
56372: LD_ADDR_VAR 0 3
56376: PUSH
56377: EMPTY
56378: ST_TO_ADDR
// for un in units do
56379: LD_ADDR_VAR 0 4
56383: PUSH
56384: LD_VAR 0 1
56388: PUSH
56389: FOR_IN
56390: IFFALSE 56465
// if GetClass ( un ) = class then
56392: LD_VAR 0 4
56396: PPUSH
56397: CALL_OW 257
56401: PUSH
56402: LD_VAR 0 2
56406: EQUAL
56407: IFFALSE 56434
// result := Insert ( result , 1 , un ) else
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_VAR 0 3
56418: PPUSH
56419: LD_INT 1
56421: PPUSH
56422: LD_VAR 0 4
56426: PPUSH
56427: CALL_OW 2
56431: ST_TO_ADDR
56432: GO 56463
// result := Replace ( result , result + 1 , un ) ;
56434: LD_ADDR_VAR 0 3
56438: PUSH
56439: LD_VAR 0 3
56443: PPUSH
56444: LD_VAR 0 3
56448: PUSH
56449: LD_INT 1
56451: PLUS
56452: PPUSH
56453: LD_VAR 0 4
56457: PPUSH
56458: CALL_OW 1
56462: ST_TO_ADDR
56463: GO 56389
56465: POP
56466: POP
// end ;
56467: LD_VAR 0 3
56471: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56472: LD_INT 0
56474: PPUSH
56475: PPUSH
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
56480: PPUSH
// result := [ ] ;
56481: LD_ADDR_VAR 0 4
56485: PUSH
56486: EMPTY
56487: ST_TO_ADDR
// if x - r < 0 then
56488: LD_VAR 0 1
56492: PUSH
56493: LD_VAR 0 3
56497: MINUS
56498: PUSH
56499: LD_INT 0
56501: LESS
56502: IFFALSE 56514
// min_x := 0 else
56504: LD_ADDR_VAR 0 8
56508: PUSH
56509: LD_INT 0
56511: ST_TO_ADDR
56512: GO 56530
// min_x := x - r ;
56514: LD_ADDR_VAR 0 8
56518: PUSH
56519: LD_VAR 0 1
56523: PUSH
56524: LD_VAR 0 3
56528: MINUS
56529: ST_TO_ADDR
// if y - r < 0 then
56530: LD_VAR 0 2
56534: PUSH
56535: LD_VAR 0 3
56539: MINUS
56540: PUSH
56541: LD_INT 0
56543: LESS
56544: IFFALSE 56556
// min_y := 0 else
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_INT 0
56553: ST_TO_ADDR
56554: GO 56572
// min_y := y - r ;
56556: LD_ADDR_VAR 0 7
56560: PUSH
56561: LD_VAR 0 2
56565: PUSH
56566: LD_VAR 0 3
56570: MINUS
56571: ST_TO_ADDR
// max_x := x + r ;
56572: LD_ADDR_VAR 0 9
56576: PUSH
56577: LD_VAR 0 1
56581: PUSH
56582: LD_VAR 0 3
56586: PLUS
56587: ST_TO_ADDR
// max_y := y + r ;
56588: LD_ADDR_VAR 0 10
56592: PUSH
56593: LD_VAR 0 2
56597: PUSH
56598: LD_VAR 0 3
56602: PLUS
56603: ST_TO_ADDR
// for _x = min_x to max_x do
56604: LD_ADDR_VAR 0 5
56608: PUSH
56609: DOUBLE
56610: LD_VAR 0 8
56614: DEC
56615: ST_TO_ADDR
56616: LD_VAR 0 9
56620: PUSH
56621: FOR_TO
56622: IFFALSE 56723
// for _y = min_y to max_y do
56624: LD_ADDR_VAR 0 6
56628: PUSH
56629: DOUBLE
56630: LD_VAR 0 7
56634: DEC
56635: ST_TO_ADDR
56636: LD_VAR 0 10
56640: PUSH
56641: FOR_TO
56642: IFFALSE 56719
// begin if not ValidHex ( _x , _y ) then
56644: LD_VAR 0 5
56648: PPUSH
56649: LD_VAR 0 6
56653: PPUSH
56654: CALL_OW 488
56658: NOT
56659: IFFALSE 56663
// continue ;
56661: GO 56641
// if GetResourceTypeXY ( _x , _y ) then
56663: LD_VAR 0 5
56667: PPUSH
56668: LD_VAR 0 6
56672: PPUSH
56673: CALL_OW 283
56677: IFFALSE 56717
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56679: LD_ADDR_VAR 0 4
56683: PUSH
56684: LD_VAR 0 4
56688: PPUSH
56689: LD_VAR 0 4
56693: PUSH
56694: LD_INT 1
56696: PLUS
56697: PPUSH
56698: LD_VAR 0 5
56702: PUSH
56703: LD_VAR 0 6
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PPUSH
56712: CALL_OW 1
56716: ST_TO_ADDR
// end ;
56717: GO 56641
56719: POP
56720: POP
56721: GO 56621
56723: POP
56724: POP
// end ;
56725: LD_VAR 0 4
56729: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56730: LD_INT 0
56732: PPUSH
56733: PPUSH
56734: PPUSH
56735: PPUSH
56736: PPUSH
56737: PPUSH
56738: PPUSH
56739: PPUSH
// if not units then
56740: LD_VAR 0 1
56744: NOT
56745: IFFALSE 56749
// exit ;
56747: GO 57273
// result := UnitFilter ( units , [ f_ok ] ) ;
56749: LD_ADDR_VAR 0 3
56753: PUSH
56754: LD_VAR 0 1
56758: PPUSH
56759: LD_INT 50
56761: PUSH
56762: EMPTY
56763: LIST
56764: PPUSH
56765: CALL_OW 72
56769: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56770: LD_ADDR_VAR 0 8
56774: PUSH
56775: LD_VAR 0 1
56779: PUSH
56780: LD_INT 1
56782: ARRAY
56783: PPUSH
56784: CALL_OW 255
56788: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56789: LD_ADDR_VAR 0 10
56793: PUSH
56794: LD_INT 29
56796: PUSH
56797: LD_INT 91
56799: PUSH
56800: LD_INT 49
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: LIST
56807: ST_TO_ADDR
// if not result then
56808: LD_VAR 0 3
56812: NOT
56813: IFFALSE 56817
// exit ;
56815: GO 57273
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56817: LD_ADDR_VAR 0 5
56821: PUSH
56822: LD_INT 81
56824: PUSH
56825: LD_VAR 0 8
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: PPUSH
56834: CALL_OW 69
56838: ST_TO_ADDR
// for i in result do
56839: LD_ADDR_VAR 0 4
56843: PUSH
56844: LD_VAR 0 3
56848: PUSH
56849: FOR_IN
56850: IFFALSE 57271
// begin tag := GetTag ( i ) + 1 ;
56852: LD_ADDR_VAR 0 9
56856: PUSH
56857: LD_VAR 0 4
56861: PPUSH
56862: CALL_OW 110
56866: PUSH
56867: LD_INT 1
56869: PLUS
56870: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
56871: LD_ADDR_VAR 0 7
56875: PUSH
56876: LD_VAR 0 4
56880: PPUSH
56881: CALL_OW 250
56885: PPUSH
56886: LD_VAR 0 4
56890: PPUSH
56891: CALL_OW 251
56895: PPUSH
56896: LD_INT 6
56898: PPUSH
56899: CALL 56472 0 3
56903: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
56904: LD_VAR 0 4
56908: PPUSH
56909: CALL_OW 247
56913: PUSH
56914: LD_INT 2
56916: EQUAL
56917: PUSH
56918: LD_VAR 0 7
56922: AND
56923: PUSH
56924: LD_VAR 0 4
56928: PPUSH
56929: CALL_OW 264
56933: PUSH
56934: LD_VAR 0 10
56938: IN
56939: NOT
56940: AND
56941: IFFALSE 56980
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56943: LD_VAR 0 4
56947: PPUSH
56948: LD_VAR 0 7
56952: PUSH
56953: LD_INT 1
56955: ARRAY
56956: PUSH
56957: LD_INT 1
56959: ARRAY
56960: PPUSH
56961: LD_VAR 0 7
56965: PUSH
56966: LD_INT 1
56968: ARRAY
56969: PUSH
56970: LD_INT 2
56972: ARRAY
56973: PPUSH
56974: CALL_OW 116
56978: GO 57269
// if path > tag then
56980: LD_VAR 0 2
56984: PUSH
56985: LD_VAR 0 9
56989: GREATER
56990: IFFALSE 57198
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
56992: LD_ADDR_VAR 0 6
56996: PUSH
56997: LD_VAR 0 5
57001: PPUSH
57002: LD_INT 91
57004: PUSH
57005: LD_VAR 0 4
57009: PUSH
57010: LD_INT 8
57012: PUSH
57013: EMPTY
57014: LIST
57015: LIST
57016: LIST
57017: PPUSH
57018: CALL_OW 72
57022: ST_TO_ADDR
// if nearEnemy then
57023: LD_VAR 0 6
57027: IFFALSE 57096
// begin if GetWeapon ( i ) = ru_time_lapser then
57029: LD_VAR 0 4
57033: PPUSH
57034: CALL_OW 264
57038: PUSH
57039: LD_INT 49
57041: EQUAL
57042: IFFALSE 57070
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57044: LD_VAR 0 4
57048: PPUSH
57049: LD_VAR 0 6
57053: PPUSH
57054: LD_VAR 0 4
57058: PPUSH
57059: CALL_OW 74
57063: PPUSH
57064: CALL_OW 112
57068: GO 57094
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57070: LD_VAR 0 4
57074: PPUSH
57075: LD_VAR 0 6
57079: PPUSH
57080: LD_VAR 0 4
57084: PPUSH
57085: CALL_OW 74
57089: PPUSH
57090: CALL 58198 0 2
// end else
57094: GO 57196
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57096: LD_VAR 0 4
57100: PPUSH
57101: LD_VAR 0 2
57105: PUSH
57106: LD_VAR 0 9
57110: ARRAY
57111: PUSH
57112: LD_INT 1
57114: ARRAY
57115: PPUSH
57116: LD_VAR 0 2
57120: PUSH
57121: LD_VAR 0 9
57125: ARRAY
57126: PUSH
57127: LD_INT 2
57129: ARRAY
57130: PPUSH
57131: CALL_OW 297
57135: PUSH
57136: LD_INT 6
57138: GREATER
57139: IFFALSE 57182
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57141: LD_VAR 0 4
57145: PPUSH
57146: LD_VAR 0 2
57150: PUSH
57151: LD_VAR 0 9
57155: ARRAY
57156: PUSH
57157: LD_INT 1
57159: ARRAY
57160: PPUSH
57161: LD_VAR 0 2
57165: PUSH
57166: LD_VAR 0 9
57170: ARRAY
57171: PUSH
57172: LD_INT 2
57174: ARRAY
57175: PPUSH
57176: CALL_OW 114
57180: GO 57196
// SetTag ( i , tag ) ;
57182: LD_VAR 0 4
57186: PPUSH
57187: LD_VAR 0 9
57191: PPUSH
57192: CALL_OW 109
// end else
57196: GO 57269
// if enemy then
57198: LD_VAR 0 5
57202: IFFALSE 57269
// begin if GetWeapon ( i ) = ru_time_lapser then
57204: LD_VAR 0 4
57208: PPUSH
57209: CALL_OW 264
57213: PUSH
57214: LD_INT 49
57216: EQUAL
57217: IFFALSE 57245
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
57219: LD_VAR 0 4
57223: PPUSH
57224: LD_VAR 0 5
57228: PPUSH
57229: LD_VAR 0 4
57233: PPUSH
57234: CALL_OW 74
57238: PPUSH
57239: CALL_OW 112
57243: GO 57269
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
57245: LD_VAR 0 4
57249: PPUSH
57250: LD_VAR 0 5
57254: PPUSH
57255: LD_VAR 0 4
57259: PPUSH
57260: CALL_OW 74
57264: PPUSH
57265: CALL 58198 0 2
// end ; end ;
57269: GO 56849
57271: POP
57272: POP
// end ;
57273: LD_VAR 0 3
57277: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
57278: LD_INT 0
57280: PPUSH
57281: PPUSH
57282: PPUSH
// if not unit or IsInUnit ( unit ) then
57283: LD_VAR 0 1
57287: NOT
57288: PUSH
57289: LD_VAR 0 1
57293: PPUSH
57294: CALL_OW 310
57298: OR
57299: IFFALSE 57303
// exit ;
57301: GO 57394
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
57303: LD_ADDR_VAR 0 4
57307: PUSH
57308: LD_VAR 0 1
57312: PPUSH
57313: CALL_OW 250
57317: PPUSH
57318: LD_VAR 0 2
57322: PPUSH
57323: LD_INT 1
57325: PPUSH
57326: CALL_OW 272
57330: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
57331: LD_ADDR_VAR 0 5
57335: PUSH
57336: LD_VAR 0 1
57340: PPUSH
57341: CALL_OW 251
57345: PPUSH
57346: LD_VAR 0 2
57350: PPUSH
57351: LD_INT 1
57353: PPUSH
57354: CALL_OW 273
57358: ST_TO_ADDR
// if ValidHex ( x , y ) then
57359: LD_VAR 0 4
57363: PPUSH
57364: LD_VAR 0 5
57368: PPUSH
57369: CALL_OW 488
57373: IFFALSE 57394
// ComTurnXY ( unit , x , y ) ;
57375: LD_VAR 0 1
57379: PPUSH
57380: LD_VAR 0 4
57384: PPUSH
57385: LD_VAR 0 5
57389: PPUSH
57390: CALL_OW 118
// end ;
57394: LD_VAR 0 3
57398: RET
// export function SeeUnits ( side , units ) ; var i ; begin
57399: LD_INT 0
57401: PPUSH
57402: PPUSH
// result := false ;
57403: LD_ADDR_VAR 0 3
57407: PUSH
57408: LD_INT 0
57410: ST_TO_ADDR
// if not units then
57411: LD_VAR 0 2
57415: NOT
57416: IFFALSE 57420
// exit ;
57418: GO 57465
// for i in units do
57420: LD_ADDR_VAR 0 4
57424: PUSH
57425: LD_VAR 0 2
57429: PUSH
57430: FOR_IN
57431: IFFALSE 57463
// if See ( side , i ) then
57433: LD_VAR 0 1
57437: PPUSH
57438: LD_VAR 0 4
57442: PPUSH
57443: CALL_OW 292
57447: IFFALSE 57461
// begin result := true ;
57449: LD_ADDR_VAR 0 3
57453: PUSH
57454: LD_INT 1
57456: ST_TO_ADDR
// exit ;
57457: POP
57458: POP
57459: GO 57465
// end ;
57461: GO 57430
57463: POP
57464: POP
// end ;
57465: LD_VAR 0 3
57469: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57470: LD_INT 0
57472: PPUSH
57473: PPUSH
57474: PPUSH
57475: PPUSH
// if not unit or not points then
57476: LD_VAR 0 1
57480: NOT
57481: PUSH
57482: LD_VAR 0 2
57486: NOT
57487: OR
57488: IFFALSE 57492
// exit ;
57490: GO 57582
// dist := 99999 ;
57492: LD_ADDR_VAR 0 5
57496: PUSH
57497: LD_INT 99999
57499: ST_TO_ADDR
// for i in points do
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_VAR 0 2
57509: PUSH
57510: FOR_IN
57511: IFFALSE 57580
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57513: LD_ADDR_VAR 0 6
57517: PUSH
57518: LD_VAR 0 1
57522: PPUSH
57523: LD_VAR 0 4
57527: PUSH
57528: LD_INT 1
57530: ARRAY
57531: PPUSH
57532: LD_VAR 0 4
57536: PUSH
57537: LD_INT 2
57539: ARRAY
57540: PPUSH
57541: CALL_OW 297
57545: ST_TO_ADDR
// if tmpDist < dist then
57546: LD_VAR 0 6
57550: PUSH
57551: LD_VAR 0 5
57555: LESS
57556: IFFALSE 57578
// begin result := i ;
57558: LD_ADDR_VAR 0 3
57562: PUSH
57563: LD_VAR 0 4
57567: ST_TO_ADDR
// dist := tmpDist ;
57568: LD_ADDR_VAR 0 5
57572: PUSH
57573: LD_VAR 0 6
57577: ST_TO_ADDR
// end ; end ;
57578: GO 57510
57580: POP
57581: POP
// end ;
57582: LD_VAR 0 3
57586: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57587: LD_INT 0
57589: PPUSH
// uc_side := side ;
57590: LD_ADDR_OWVAR 20
57594: PUSH
57595: LD_VAR 0 1
57599: ST_TO_ADDR
// uc_nation := 3 ;
57600: LD_ADDR_OWVAR 21
57604: PUSH
57605: LD_INT 3
57607: ST_TO_ADDR
// vc_chassis := 25 ;
57608: LD_ADDR_OWVAR 37
57612: PUSH
57613: LD_INT 25
57615: ST_TO_ADDR
// vc_engine := engine_siberite ;
57616: LD_ADDR_OWVAR 39
57620: PUSH
57621: LD_INT 3
57623: ST_TO_ADDR
// vc_control := control_computer ;
57624: LD_ADDR_OWVAR 38
57628: PUSH
57629: LD_INT 3
57631: ST_TO_ADDR
// vc_weapon := 59 ;
57632: LD_ADDR_OWVAR 40
57636: PUSH
57637: LD_INT 59
57639: ST_TO_ADDR
// result := CreateVehicle ;
57640: LD_ADDR_VAR 0 5
57644: PUSH
57645: CALL_OW 45
57649: ST_TO_ADDR
// SetDir ( result , d ) ;
57650: LD_VAR 0 5
57654: PPUSH
57655: LD_VAR 0 4
57659: PPUSH
57660: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57664: LD_VAR 0 5
57668: PPUSH
57669: LD_VAR 0 2
57673: PPUSH
57674: LD_VAR 0 3
57678: PPUSH
57679: LD_INT 0
57681: PPUSH
57682: CALL_OW 48
// end ;
57686: LD_VAR 0 5
57690: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57691: LD_INT 0
57693: PPUSH
57694: PPUSH
57695: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57696: LD_ADDR_VAR 0 2
57700: PUSH
57701: LD_INT 0
57703: PUSH
57704: LD_INT 0
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: LIST
57717: LIST
57718: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57719: LD_VAR 0 1
57723: NOT
57724: PUSH
57725: LD_VAR 0 1
57729: PPUSH
57730: CALL_OW 264
57734: PUSH
57735: LD_INT 12
57737: PUSH
57738: LD_INT 51
57740: PUSH
57741: LD_INT 32
57743: PUSH
57744: LD_INT 89
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: LIST
57751: LIST
57752: IN
57753: NOT
57754: OR
57755: IFFALSE 57759
// exit ;
57757: GO 57857
// for i := 1 to 3 do
57759: LD_ADDR_VAR 0 3
57763: PUSH
57764: DOUBLE
57765: LD_INT 1
57767: DEC
57768: ST_TO_ADDR
57769: LD_INT 3
57771: PUSH
57772: FOR_TO
57773: IFFALSE 57855
// begin tmp := GetCargo ( cargo , i ) ;
57775: LD_ADDR_VAR 0 4
57779: PUSH
57780: LD_VAR 0 1
57784: PPUSH
57785: LD_VAR 0 3
57789: PPUSH
57790: CALL_OW 289
57794: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57795: LD_ADDR_VAR 0 2
57799: PUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: LD_VAR 0 3
57809: PPUSH
57810: LD_VAR 0 4
57814: PPUSH
57815: CALL_OW 1
57819: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57820: LD_ADDR_VAR 0 2
57824: PUSH
57825: LD_VAR 0 2
57829: PPUSH
57830: LD_INT 4
57832: PPUSH
57833: LD_VAR 0 2
57837: PUSH
57838: LD_INT 4
57840: ARRAY
57841: PUSH
57842: LD_VAR 0 4
57846: PLUS
57847: PPUSH
57848: CALL_OW 1
57852: ST_TO_ADDR
// end ;
57853: GO 57772
57855: POP
57856: POP
// end ;
57857: LD_VAR 0 2
57861: RET
// export function Length ( array ) ; begin
57862: LD_INT 0
57864: PPUSH
// result := array + 0 ;
57865: LD_ADDR_VAR 0 2
57869: PUSH
57870: LD_VAR 0 1
57874: PUSH
57875: LD_INT 0
57877: PLUS
57878: ST_TO_ADDR
// end ;
57879: LD_VAR 0 2
57883: RET
// export function PrepareArray ( array ) ; begin
57884: LD_INT 0
57886: PPUSH
// result := array diff 0 ;
57887: LD_ADDR_VAR 0 2
57891: PUSH
57892: LD_VAR 0 1
57896: PUSH
57897: LD_INT 0
57899: DIFF
57900: ST_TO_ADDR
// if not result [ 1 ] then
57901: LD_VAR 0 2
57905: PUSH
57906: LD_INT 1
57908: ARRAY
57909: NOT
57910: IFFALSE 57930
// result := Delete ( result , 1 ) ;
57912: LD_ADDR_VAR 0 2
57916: PUSH
57917: LD_VAR 0 2
57921: PPUSH
57922: LD_INT 1
57924: PPUSH
57925: CALL_OW 3
57929: ST_TO_ADDR
// end ;
57930: LD_VAR 0 2
57934: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57935: LD_INT 0
57937: PPUSH
57938: PPUSH
57939: PPUSH
57940: PPUSH
// sibRocketRange := 25 ;
57941: LD_ADDR_VAR 0 6
57945: PUSH
57946: LD_INT 25
57948: ST_TO_ADDR
// result := false ;
57949: LD_ADDR_VAR 0 4
57953: PUSH
57954: LD_INT 0
57956: ST_TO_ADDR
// for i := 0 to 5 do
57957: LD_ADDR_VAR 0 5
57961: PUSH
57962: DOUBLE
57963: LD_INT 0
57965: DEC
57966: ST_TO_ADDR
57967: LD_INT 5
57969: PUSH
57970: FOR_TO
57971: IFFALSE 58038
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57973: LD_VAR 0 1
57977: PPUSH
57978: LD_VAR 0 5
57982: PPUSH
57983: LD_VAR 0 6
57987: PPUSH
57988: CALL_OW 272
57992: PPUSH
57993: LD_VAR 0 2
57997: PPUSH
57998: LD_VAR 0 5
58002: PPUSH
58003: LD_VAR 0 6
58007: PPUSH
58008: CALL_OW 273
58012: PPUSH
58013: LD_VAR 0 3
58017: PPUSH
58018: CALL_OW 309
58022: IFFALSE 58036
// begin result := true ;
58024: LD_ADDR_VAR 0 4
58028: PUSH
58029: LD_INT 1
58031: ST_TO_ADDR
// exit ;
58032: POP
58033: POP
58034: GO 58040
// end ;
58036: GO 57970
58038: POP
58039: POP
// end ;
58040: LD_VAR 0 4
58044: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
58045: LD_INT 0
58047: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
58048: LD_VAR 0 1
58052: PPUSH
58053: LD_VAR 0 2
58057: PPUSH
58058: LD_INT 0
58060: PPUSH
58061: LD_INT 0
58063: PPUSH
58064: LD_INT 1
58066: PPUSH
58067: LD_INT 0
58069: PPUSH
58070: CALL_OW 587
// end ;
58074: LD_VAR 0 3
58078: RET
// export function CenterOnNow ( unit ) ; begin
58079: LD_INT 0
58081: PPUSH
// result := IsInUnit ( unit ) ;
58082: LD_ADDR_VAR 0 2
58086: PUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: CALL_OW 310
58096: ST_TO_ADDR
// if not result then
58097: LD_VAR 0 2
58101: NOT
58102: IFFALSE 58114
// result := unit ;
58104: LD_ADDR_VAR 0 2
58108: PUSH
58109: LD_VAR 0 1
58113: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
58114: LD_VAR 0 1
58118: PPUSH
58119: CALL_OW 87
// end ;
58123: LD_VAR 0 2
58127: RET
// export function ComMoveHex ( unit , hex ) ; begin
58128: LD_INT 0
58130: PPUSH
// if not hex then
58131: LD_VAR 0 2
58135: NOT
58136: IFFALSE 58140
// exit ;
58138: GO 58193
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
58140: LD_VAR 0 2
58144: PUSH
58145: LD_INT 1
58147: ARRAY
58148: PPUSH
58149: LD_VAR 0 2
58153: PUSH
58154: LD_INT 2
58156: ARRAY
58157: PPUSH
58158: CALL_OW 428
58162: IFFALSE 58166
// exit ;
58164: GO 58193
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
58166: LD_VAR 0 1
58170: PPUSH
58171: LD_VAR 0 2
58175: PUSH
58176: LD_INT 1
58178: ARRAY
58179: PPUSH
58180: LD_VAR 0 2
58184: PUSH
58185: LD_INT 2
58187: ARRAY
58188: PPUSH
58189: CALL_OW 111
// end ;
58193: LD_VAR 0 3
58197: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
58198: LD_INT 0
58200: PPUSH
58201: PPUSH
58202: PPUSH
// if not unit or not enemy then
58203: LD_VAR 0 1
58207: NOT
58208: PUSH
58209: LD_VAR 0 2
58213: NOT
58214: OR
58215: IFFALSE 58219
// exit ;
58217: GO 58343
// x := GetX ( enemy ) ;
58219: LD_ADDR_VAR 0 4
58223: PUSH
58224: LD_VAR 0 2
58228: PPUSH
58229: CALL_OW 250
58233: ST_TO_ADDR
// y := GetY ( enemy ) ;
58234: LD_ADDR_VAR 0 5
58238: PUSH
58239: LD_VAR 0 2
58243: PPUSH
58244: CALL_OW 251
58248: ST_TO_ADDR
// if ValidHex ( x , y ) then
58249: LD_VAR 0 4
58253: PPUSH
58254: LD_VAR 0 5
58258: PPUSH
58259: CALL_OW 488
58263: IFFALSE 58343
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
58265: LD_VAR 0 2
58269: PPUSH
58270: CALL_OW 247
58274: PUSH
58275: LD_INT 3
58277: PUSH
58278: LD_INT 2
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: IN
58285: PUSH
58286: LD_VAR 0 1
58290: PPUSH
58291: CALL_OW 255
58295: PPUSH
58296: LD_VAR 0 2
58300: PPUSH
58301: CALL_OW 292
58305: OR
58306: IFFALSE 58324
// ComAttackUnit ( unit , enemy ) else
58308: LD_VAR 0 1
58312: PPUSH
58313: LD_VAR 0 2
58317: PPUSH
58318: CALL_OW 115
58322: GO 58343
// ComAgressiveMove ( unit , x , y ) ;
58324: LD_VAR 0 1
58328: PPUSH
58329: LD_VAR 0 4
58333: PPUSH
58334: LD_VAR 0 5
58338: PPUSH
58339: CALL_OW 114
// end ;
58343: LD_VAR 0 3
58347: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
58348: LD_INT 0
58350: PPUSH
58351: PPUSH
58352: PPUSH
// list := AreaToList ( area , 0 ) ;
58353: LD_ADDR_VAR 0 5
58357: PUSH
58358: LD_VAR 0 1
58362: PPUSH
58363: LD_INT 0
58365: PPUSH
58366: CALL_OW 517
58370: ST_TO_ADDR
// if not list then
58371: LD_VAR 0 5
58375: NOT
58376: IFFALSE 58380
// exit ;
58378: GO 58510
// if all then
58380: LD_VAR 0 2
58384: IFFALSE 58472
// begin for i := 1 to list [ 1 ] do
58386: LD_ADDR_VAR 0 4
58390: PUSH
58391: DOUBLE
58392: LD_INT 1
58394: DEC
58395: ST_TO_ADDR
58396: LD_VAR 0 5
58400: PUSH
58401: LD_INT 1
58403: ARRAY
58404: PUSH
58405: FOR_TO
58406: IFFALSE 58468
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58408: LD_ADDR_VAR 0 3
58412: PUSH
58413: LD_VAR 0 3
58417: PPUSH
58418: LD_VAR 0 3
58422: PUSH
58423: LD_INT 1
58425: PLUS
58426: PPUSH
58427: LD_VAR 0 5
58431: PUSH
58432: LD_INT 1
58434: ARRAY
58435: PUSH
58436: LD_VAR 0 4
58440: ARRAY
58441: PUSH
58442: LD_VAR 0 5
58446: PUSH
58447: LD_INT 2
58449: ARRAY
58450: PUSH
58451: LD_VAR 0 4
58455: ARRAY
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PPUSH
58461: CALL_OW 1
58465: ST_TO_ADDR
58466: GO 58405
58468: POP
58469: POP
// exit ;
58470: GO 58510
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
58472: LD_ADDR_VAR 0 3
58476: PUSH
58477: LD_VAR 0 5
58481: PUSH
58482: LD_INT 1
58484: ARRAY
58485: PUSH
58486: LD_INT 1
58488: ARRAY
58489: PUSH
58490: LD_VAR 0 5
58494: PUSH
58495: LD_INT 2
58497: ARRAY
58498: PUSH
58499: LD_INT 1
58501: ARRAY
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: PUSH
58507: EMPTY
58508: LIST
58509: ST_TO_ADDR
// end ;
58510: LD_VAR 0 3
58514: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
58515: LD_INT 0
58517: PPUSH
58518: PPUSH
// list := AreaToList ( area , 0 ) ;
58519: LD_ADDR_VAR 0 4
58523: PUSH
58524: LD_VAR 0 1
58528: PPUSH
58529: LD_INT 0
58531: PPUSH
58532: CALL_OW 517
58536: ST_TO_ADDR
// if not list then
58537: LD_VAR 0 4
58541: NOT
58542: IFFALSE 58546
// exit ;
58544: GO 58587
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58546: LD_ADDR_VAR 0 3
58550: PUSH
58551: LD_VAR 0 4
58555: PUSH
58556: LD_INT 1
58558: ARRAY
58559: PUSH
58560: LD_INT 1
58562: ARRAY
58563: PUSH
58564: LD_VAR 0 4
58568: PUSH
58569: LD_INT 2
58571: ARRAY
58572: PUSH
58573: LD_INT 1
58575: ARRAY
58576: PUSH
58577: LD_VAR 0 2
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: LIST
58586: ST_TO_ADDR
// end ;
58587: LD_VAR 0 3
58591: RET
// export function First ( array ) ; begin
58592: LD_INT 0
58594: PPUSH
// if not array then
58595: LD_VAR 0 1
58599: NOT
58600: IFFALSE 58604
// exit ;
58602: GO 58618
// result := array [ 1 ] ;
58604: LD_ADDR_VAR 0 2
58608: PUSH
58609: LD_VAR 0 1
58613: PUSH
58614: LD_INT 1
58616: ARRAY
58617: ST_TO_ADDR
// end ;
58618: LD_VAR 0 2
58622: RET
// export function Last ( array ) ; begin
58623: LD_INT 0
58625: PPUSH
// if not array then
58626: LD_VAR 0 1
58630: NOT
58631: IFFALSE 58635
// exit ;
58633: GO 58651
// result := array [ array ] ;
58635: LD_ADDR_VAR 0 2
58639: PUSH
58640: LD_VAR 0 1
58644: PUSH
58645: LD_VAR 0 1
58649: ARRAY
58650: ST_TO_ADDR
// end ;
58651: LD_VAR 0 2
58655: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
58656: LD_INT 0
58658: PPUSH
58659: PPUSH
// result := [ ] ;
58660: LD_ADDR_VAR 0 5
58664: PUSH
58665: EMPTY
58666: ST_TO_ADDR
// if not array then
58667: LD_VAR 0 1
58671: NOT
58672: IFFALSE 58676
// exit ;
58674: GO 58788
// for i := 1 to array do
58676: LD_ADDR_VAR 0 6
58680: PUSH
58681: DOUBLE
58682: LD_INT 1
58684: DEC
58685: ST_TO_ADDR
58686: LD_VAR 0 1
58690: PUSH
58691: FOR_TO
58692: IFFALSE 58786
// if array [ i ] [ index ] = value then
58694: LD_VAR 0 1
58698: PUSH
58699: LD_VAR 0 6
58703: ARRAY
58704: PUSH
58705: LD_VAR 0 2
58709: ARRAY
58710: PUSH
58711: LD_VAR 0 3
58715: EQUAL
58716: IFFALSE 58784
// begin if indexColumn then
58718: LD_VAR 0 4
58722: IFFALSE 58758
// result := Join ( result , array [ i ] [ indexColumn ] ) else
58724: LD_ADDR_VAR 0 5
58728: PUSH
58729: LD_VAR 0 5
58733: PPUSH
58734: LD_VAR 0 1
58738: PUSH
58739: LD_VAR 0 6
58743: ARRAY
58744: PUSH
58745: LD_VAR 0 4
58749: ARRAY
58750: PPUSH
58751: CALL 54126 0 2
58755: ST_TO_ADDR
58756: GO 58784
// result := Join ( result , array [ i ] ) ;
58758: LD_ADDR_VAR 0 5
58762: PUSH
58763: LD_VAR 0 5
58767: PPUSH
58768: LD_VAR 0 1
58772: PUSH
58773: LD_VAR 0 6
58777: ARRAY
58778: PPUSH
58779: CALL 54126 0 2
58783: ST_TO_ADDR
// end ;
58784: GO 58691
58786: POP
58787: POP
// end ;
58788: LD_VAR 0 5
58792: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58793: LD_INT 0
58795: PPUSH
58796: PPUSH
58797: PPUSH
// if btype = b_depot then
58798: LD_VAR 0 2
58802: PUSH
58803: LD_INT 0
58805: EQUAL
58806: IFFALSE 58818
// begin result := true ;
58808: LD_ADDR_VAR 0 3
58812: PUSH
58813: LD_INT 1
58815: ST_TO_ADDR
// exit ;
58816: GO 58934
// end ; pom := GetBase ( depot ) ;
58818: LD_ADDR_VAR 0 4
58822: PUSH
58823: LD_VAR 0 1
58827: PPUSH
58828: CALL_OW 274
58832: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58833: LD_ADDR_VAR 0 5
58837: PUSH
58838: LD_VAR 0 2
58842: PPUSH
58843: LD_VAR 0 1
58847: PPUSH
58848: CALL_OW 248
58852: PPUSH
58853: CALL_OW 450
58857: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58858: LD_ADDR_VAR 0 3
58862: PUSH
58863: LD_VAR 0 4
58867: PPUSH
58868: LD_INT 1
58870: PPUSH
58871: CALL_OW 275
58875: PUSH
58876: LD_VAR 0 5
58880: PUSH
58881: LD_INT 1
58883: ARRAY
58884: GREATEREQUAL
58885: PUSH
58886: LD_VAR 0 4
58890: PPUSH
58891: LD_INT 2
58893: PPUSH
58894: CALL_OW 275
58898: PUSH
58899: LD_VAR 0 5
58903: PUSH
58904: LD_INT 2
58906: ARRAY
58907: GREATEREQUAL
58908: AND
58909: PUSH
58910: LD_VAR 0 4
58914: PPUSH
58915: LD_INT 3
58917: PPUSH
58918: CALL_OW 275
58922: PUSH
58923: LD_VAR 0 5
58927: PUSH
58928: LD_INT 3
58930: ARRAY
58931: GREATEREQUAL
58932: AND
58933: ST_TO_ADDR
// end ;
58934: LD_VAR 0 3
58938: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
58939: LD_INT 0
58941: PPUSH
// if not vehicles or not parkingPoint then
58942: LD_VAR 0 1
58946: NOT
58947: PUSH
58948: LD_VAR 0 2
58952: NOT
58953: OR
58954: IFFALSE 58958
// exit ;
58956: GO 59056
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
58958: LD_ADDR_VAR 0 1
58962: PUSH
58963: LD_VAR 0 1
58967: PPUSH
58968: LD_INT 50
58970: PUSH
58971: EMPTY
58972: LIST
58973: PUSH
58974: LD_INT 3
58976: PUSH
58977: LD_INT 92
58979: PUSH
58980: LD_VAR 0 2
58984: PUSH
58985: LD_INT 1
58987: ARRAY
58988: PUSH
58989: LD_VAR 0 2
58993: PUSH
58994: LD_INT 2
58996: ARRAY
58997: PUSH
58998: LD_INT 8
59000: PUSH
59001: EMPTY
59002: LIST
59003: LIST
59004: LIST
59005: LIST
59006: PUSH
59007: EMPTY
59008: LIST
59009: LIST
59010: PUSH
59011: EMPTY
59012: LIST
59013: LIST
59014: PPUSH
59015: CALL_OW 72
59019: ST_TO_ADDR
// if not vehicles then
59020: LD_VAR 0 1
59024: NOT
59025: IFFALSE 59029
// exit ;
59027: GO 59056
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59029: LD_VAR 0 1
59033: PPUSH
59034: LD_VAR 0 2
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: LD_VAR 0 2
59047: PUSH
59048: LD_INT 2
59050: ARRAY
59051: PPUSH
59052: CALL_OW 111
// end ;
59056: LD_VAR 0 3
59060: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
59061: LD_INT 0
59063: PPUSH
59064: PPUSH
59065: PPUSH
// if not side or not area then
59066: LD_VAR 0 1
59070: NOT
59071: PUSH
59072: LD_VAR 0 2
59076: NOT
59077: OR
59078: IFFALSE 59082
// exit ;
59080: GO 59201
// tmp := AreaToList ( area , 0 ) ;
59082: LD_ADDR_VAR 0 5
59086: PUSH
59087: LD_VAR 0 2
59091: PPUSH
59092: LD_INT 0
59094: PPUSH
59095: CALL_OW 517
59099: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
59100: LD_ADDR_VAR 0 4
59104: PUSH
59105: DOUBLE
59106: LD_INT 1
59108: DEC
59109: ST_TO_ADDR
59110: LD_VAR 0 5
59114: PUSH
59115: LD_INT 1
59117: ARRAY
59118: PUSH
59119: FOR_TO
59120: IFFALSE 59199
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
59122: LD_VAR 0 5
59126: PUSH
59127: LD_INT 1
59129: ARRAY
59130: PUSH
59131: LD_VAR 0 4
59135: ARRAY
59136: PPUSH
59137: LD_VAR 0 5
59141: PUSH
59142: LD_INT 2
59144: ARRAY
59145: PUSH
59146: LD_VAR 0 4
59150: ARRAY
59151: PPUSH
59152: CALL_OW 351
59156: IFFALSE 59197
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
59158: LD_VAR 0 5
59162: PUSH
59163: LD_INT 1
59165: ARRAY
59166: PUSH
59167: LD_VAR 0 4
59171: ARRAY
59172: PPUSH
59173: LD_VAR 0 5
59177: PUSH
59178: LD_INT 2
59180: ARRAY
59181: PUSH
59182: LD_VAR 0 4
59186: ARRAY
59187: PPUSH
59188: LD_VAR 0 1
59192: PPUSH
59193: CALL_OW 244
// end ;
59197: GO 59119
59199: POP
59200: POP
// end ; end_of_file
59201: LD_VAR 0 3
59205: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
59206: LD_INT 0
59208: PPUSH
59209: PPUSH
// skirmish := false ;
59210: LD_ADDR_EXP 59
59214: PUSH
59215: LD_INT 0
59217: ST_TO_ADDR
// debug_mc := false ;
59218: LD_ADDR_EXP 60
59222: PUSH
59223: LD_INT 0
59225: ST_TO_ADDR
// mc_bases := [ ] ;
59226: LD_ADDR_EXP 61
59230: PUSH
59231: EMPTY
59232: ST_TO_ADDR
// mc_sides := [ ] ;
59233: LD_ADDR_EXP 87
59237: PUSH
59238: EMPTY
59239: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
59240: LD_ADDR_EXP 62
59244: PUSH
59245: EMPTY
59246: ST_TO_ADDR
// mc_building_repairs := [ ] ;
59247: LD_ADDR_EXP 63
59251: PUSH
59252: EMPTY
59253: ST_TO_ADDR
// mc_need_heal := [ ] ;
59254: LD_ADDR_EXP 64
59258: PUSH
59259: EMPTY
59260: ST_TO_ADDR
// mc_healers := [ ] ;
59261: LD_ADDR_EXP 65
59265: PUSH
59266: EMPTY
59267: ST_TO_ADDR
// mc_build_list := [ ] ;
59268: LD_ADDR_EXP 66
59272: PUSH
59273: EMPTY
59274: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
59275: LD_ADDR_EXP 93
59279: PUSH
59280: EMPTY
59281: ST_TO_ADDR
// mc_builders := [ ] ;
59282: LD_ADDR_EXP 67
59286: PUSH
59287: EMPTY
59288: ST_TO_ADDR
// mc_construct_list := [ ] ;
59289: LD_ADDR_EXP 68
59293: PUSH
59294: EMPTY
59295: ST_TO_ADDR
// mc_turret_list := [ ] ;
59296: LD_ADDR_EXP 69
59300: PUSH
59301: EMPTY
59302: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
59303: LD_ADDR_EXP 70
59307: PUSH
59308: EMPTY
59309: ST_TO_ADDR
// mc_miners := [ ] ;
59310: LD_ADDR_EXP 75
59314: PUSH
59315: EMPTY
59316: ST_TO_ADDR
// mc_mines := [ ] ;
59317: LD_ADDR_EXP 74
59321: PUSH
59322: EMPTY
59323: ST_TO_ADDR
// mc_minefields := [ ] ;
59324: LD_ADDR_EXP 76
59328: PUSH
59329: EMPTY
59330: ST_TO_ADDR
// mc_crates := [ ] ;
59331: LD_ADDR_EXP 77
59335: PUSH
59336: EMPTY
59337: ST_TO_ADDR
// mc_crates_collector := [ ] ;
59338: LD_ADDR_EXP 78
59342: PUSH
59343: EMPTY
59344: ST_TO_ADDR
// mc_crates_area := [ ] ;
59345: LD_ADDR_EXP 79
59349: PUSH
59350: EMPTY
59351: ST_TO_ADDR
// mc_vehicles := [ ] ;
59352: LD_ADDR_EXP 80
59356: PUSH
59357: EMPTY
59358: ST_TO_ADDR
// mc_attack := [ ] ;
59359: LD_ADDR_EXP 81
59363: PUSH
59364: EMPTY
59365: ST_TO_ADDR
// mc_produce := [ ] ;
59366: LD_ADDR_EXP 82
59370: PUSH
59371: EMPTY
59372: ST_TO_ADDR
// mc_defender := [ ] ;
59373: LD_ADDR_EXP 83
59377: PUSH
59378: EMPTY
59379: ST_TO_ADDR
// mc_parking := [ ] ;
59380: LD_ADDR_EXP 85
59384: PUSH
59385: EMPTY
59386: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
59387: LD_ADDR_EXP 71
59391: PUSH
59392: EMPTY
59393: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
59394: LD_ADDR_EXP 73
59398: PUSH
59399: EMPTY
59400: ST_TO_ADDR
// mc_scan := [ ] ;
59401: LD_ADDR_EXP 84
59405: PUSH
59406: EMPTY
59407: ST_TO_ADDR
// mc_scan_area := [ ] ;
59408: LD_ADDR_EXP 86
59412: PUSH
59413: EMPTY
59414: ST_TO_ADDR
// mc_tech := [ ] ;
59415: LD_ADDR_EXP 88
59419: PUSH
59420: EMPTY
59421: ST_TO_ADDR
// mc_class := [ ] ;
59422: LD_ADDR_EXP 102
59426: PUSH
59427: EMPTY
59428: ST_TO_ADDR
// mc_class_case_use := [ ] ;
59429: LD_ADDR_EXP 103
59433: PUSH
59434: EMPTY
59435: ST_TO_ADDR
// mc_is_defending := [ ] ;
59436: LD_ADDR_EXP 104
59440: PUSH
59441: EMPTY
59442: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
59443: LD_ADDR_EXP 95
59447: PUSH
59448: EMPTY
59449: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
59450: LD_ADDR_EXP 105
59454: PUSH
59455: LD_INT 0
59457: ST_TO_ADDR
// end ;
59458: LD_VAR 0 1
59462: RET
// export function MC_Kill ( base ) ; begin
59463: LD_INT 0
59465: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
59466: LD_ADDR_EXP 61
59470: PUSH
59471: LD_EXP 61
59475: PPUSH
59476: LD_VAR 0 1
59480: PPUSH
59481: EMPTY
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59488: LD_ADDR_EXP 62
59492: PUSH
59493: LD_EXP 62
59497: PPUSH
59498: LD_VAR 0 1
59502: PPUSH
59503: EMPTY
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59510: LD_ADDR_EXP 63
59514: PUSH
59515: LD_EXP 63
59519: PPUSH
59520: LD_VAR 0 1
59524: PPUSH
59525: EMPTY
59526: PPUSH
59527: CALL_OW 1
59531: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59532: LD_ADDR_EXP 64
59536: PUSH
59537: LD_EXP 64
59541: PPUSH
59542: LD_VAR 0 1
59546: PPUSH
59547: EMPTY
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59554: LD_ADDR_EXP 65
59558: PUSH
59559: LD_EXP 65
59563: PPUSH
59564: LD_VAR 0 1
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59576: LD_ADDR_EXP 66
59580: PUSH
59581: LD_EXP 66
59585: PPUSH
59586: LD_VAR 0 1
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59598: LD_ADDR_EXP 67
59602: PUSH
59603: LD_EXP 67
59607: PPUSH
59608: LD_VAR 0 1
59612: PPUSH
59613: EMPTY
59614: PPUSH
59615: CALL_OW 1
59619: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59620: LD_ADDR_EXP 68
59624: PUSH
59625: LD_EXP 68
59629: PPUSH
59630: LD_VAR 0 1
59634: PPUSH
59635: EMPTY
59636: PPUSH
59637: CALL_OW 1
59641: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59642: LD_ADDR_EXP 69
59646: PUSH
59647: LD_EXP 69
59651: PPUSH
59652: LD_VAR 0 1
59656: PPUSH
59657: EMPTY
59658: PPUSH
59659: CALL_OW 1
59663: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59664: LD_ADDR_EXP 70
59668: PUSH
59669: LD_EXP 70
59673: PPUSH
59674: LD_VAR 0 1
59678: PPUSH
59679: EMPTY
59680: PPUSH
59681: CALL_OW 1
59685: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59686: LD_ADDR_EXP 71
59690: PUSH
59691: LD_EXP 71
59695: PPUSH
59696: LD_VAR 0 1
59700: PPUSH
59701: EMPTY
59702: PPUSH
59703: CALL_OW 1
59707: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59708: LD_ADDR_EXP 72
59712: PUSH
59713: LD_EXP 72
59717: PPUSH
59718: LD_VAR 0 1
59722: PPUSH
59723: LD_INT 0
59725: PPUSH
59726: CALL_OW 1
59730: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59731: LD_ADDR_EXP 73
59735: PUSH
59736: LD_EXP 73
59740: PPUSH
59741: LD_VAR 0 1
59745: PPUSH
59746: EMPTY
59747: PPUSH
59748: CALL_OW 1
59752: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59753: LD_ADDR_EXP 74
59757: PUSH
59758: LD_EXP 74
59762: PPUSH
59763: LD_VAR 0 1
59767: PPUSH
59768: EMPTY
59769: PPUSH
59770: CALL_OW 1
59774: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59775: LD_ADDR_EXP 75
59779: PUSH
59780: LD_EXP 75
59784: PPUSH
59785: LD_VAR 0 1
59789: PPUSH
59790: EMPTY
59791: PPUSH
59792: CALL_OW 1
59796: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59797: LD_ADDR_EXP 76
59801: PUSH
59802: LD_EXP 76
59806: PPUSH
59807: LD_VAR 0 1
59811: PPUSH
59812: EMPTY
59813: PPUSH
59814: CALL_OW 1
59818: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59819: LD_ADDR_EXP 77
59823: PUSH
59824: LD_EXP 77
59828: PPUSH
59829: LD_VAR 0 1
59833: PPUSH
59834: EMPTY
59835: PPUSH
59836: CALL_OW 1
59840: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59841: LD_ADDR_EXP 78
59845: PUSH
59846: LD_EXP 78
59850: PPUSH
59851: LD_VAR 0 1
59855: PPUSH
59856: EMPTY
59857: PPUSH
59858: CALL_OW 1
59862: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59863: LD_ADDR_EXP 79
59867: PUSH
59868: LD_EXP 79
59872: PPUSH
59873: LD_VAR 0 1
59877: PPUSH
59878: EMPTY
59879: PPUSH
59880: CALL_OW 1
59884: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59885: LD_ADDR_EXP 80
59889: PUSH
59890: LD_EXP 80
59894: PPUSH
59895: LD_VAR 0 1
59899: PPUSH
59900: EMPTY
59901: PPUSH
59902: CALL_OW 1
59906: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59907: LD_ADDR_EXP 81
59911: PUSH
59912: LD_EXP 81
59916: PPUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: EMPTY
59923: PPUSH
59924: CALL_OW 1
59928: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59929: LD_ADDR_EXP 82
59933: PUSH
59934: LD_EXP 82
59938: PPUSH
59939: LD_VAR 0 1
59943: PPUSH
59944: EMPTY
59945: PPUSH
59946: CALL_OW 1
59950: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59951: LD_ADDR_EXP 83
59955: PUSH
59956: LD_EXP 83
59960: PPUSH
59961: LD_VAR 0 1
59965: PPUSH
59966: EMPTY
59967: PPUSH
59968: CALL_OW 1
59972: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59973: LD_ADDR_EXP 84
59977: PUSH
59978: LD_EXP 84
59982: PPUSH
59983: LD_VAR 0 1
59987: PPUSH
59988: EMPTY
59989: PPUSH
59990: CALL_OW 1
59994: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59995: LD_ADDR_EXP 85
59999: PUSH
60000: LD_EXP 85
60004: PPUSH
60005: LD_VAR 0 1
60009: PPUSH
60010: EMPTY
60011: PPUSH
60012: CALL_OW 1
60016: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60017: LD_ADDR_EXP 86
60021: PUSH
60022: LD_EXP 86
60026: PPUSH
60027: LD_VAR 0 1
60031: PPUSH
60032: EMPTY
60033: PPUSH
60034: CALL_OW 1
60038: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60039: LD_ADDR_EXP 88
60043: PUSH
60044: LD_EXP 88
60048: PPUSH
60049: LD_VAR 0 1
60053: PPUSH
60054: EMPTY
60055: PPUSH
60056: CALL_OW 1
60060: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60061: LD_ADDR_EXP 90
60065: PUSH
60066: LD_EXP 90
60070: PPUSH
60071: LD_VAR 0 1
60075: PPUSH
60076: EMPTY
60077: PPUSH
60078: CALL_OW 1
60082: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60083: LD_ADDR_EXP 91
60087: PUSH
60088: LD_EXP 91
60092: PPUSH
60093: LD_VAR 0 1
60097: PPUSH
60098: EMPTY
60099: PPUSH
60100: CALL_OW 1
60104: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60105: LD_ADDR_EXP 92
60109: PUSH
60110: LD_EXP 92
60114: PPUSH
60115: LD_VAR 0 1
60119: PPUSH
60120: EMPTY
60121: PPUSH
60122: CALL_OW 1
60126: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60127: LD_ADDR_EXP 93
60131: PUSH
60132: LD_EXP 93
60136: PPUSH
60137: LD_VAR 0 1
60141: PPUSH
60142: EMPTY
60143: PPUSH
60144: CALL_OW 1
60148: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60149: LD_ADDR_EXP 94
60153: PUSH
60154: LD_EXP 94
60158: PPUSH
60159: LD_VAR 0 1
60163: PPUSH
60164: EMPTY
60165: PPUSH
60166: CALL_OW 1
60170: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60171: LD_ADDR_EXP 95
60175: PUSH
60176: LD_EXP 95
60180: PPUSH
60181: LD_VAR 0 1
60185: PPUSH
60186: EMPTY
60187: PPUSH
60188: CALL_OW 1
60192: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60193: LD_ADDR_EXP 96
60197: PUSH
60198: LD_EXP 96
60202: PPUSH
60203: LD_VAR 0 1
60207: PPUSH
60208: EMPTY
60209: PPUSH
60210: CALL_OW 1
60214: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60215: LD_ADDR_EXP 97
60219: PUSH
60220: LD_EXP 97
60224: PPUSH
60225: LD_VAR 0 1
60229: PPUSH
60230: EMPTY
60231: PPUSH
60232: CALL_OW 1
60236: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60237: LD_ADDR_EXP 98
60241: PUSH
60242: LD_EXP 98
60246: PPUSH
60247: LD_VAR 0 1
60251: PPUSH
60252: EMPTY
60253: PPUSH
60254: CALL_OW 1
60258: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60259: LD_ADDR_EXP 99
60263: PUSH
60264: LD_EXP 99
60268: PPUSH
60269: LD_VAR 0 1
60273: PPUSH
60274: EMPTY
60275: PPUSH
60276: CALL_OW 1
60280: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60281: LD_ADDR_EXP 100
60285: PUSH
60286: LD_EXP 100
60290: PPUSH
60291: LD_VAR 0 1
60295: PPUSH
60296: EMPTY
60297: PPUSH
60298: CALL_OW 1
60302: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60303: LD_ADDR_EXP 101
60307: PUSH
60308: LD_EXP 101
60312: PPUSH
60313: LD_VAR 0 1
60317: PPUSH
60318: EMPTY
60319: PPUSH
60320: CALL_OW 1
60324: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60325: LD_ADDR_EXP 102
60329: PUSH
60330: LD_EXP 102
60334: PPUSH
60335: LD_VAR 0 1
60339: PPUSH
60340: EMPTY
60341: PPUSH
60342: CALL_OW 1
60346: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60347: LD_ADDR_EXP 103
60351: PUSH
60352: LD_EXP 103
60356: PPUSH
60357: LD_VAR 0 1
60361: PPUSH
60362: LD_INT 0
60364: PPUSH
60365: CALL_OW 1
60369: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60370: LD_ADDR_EXP 104
60374: PUSH
60375: LD_EXP 104
60379: PPUSH
60380: LD_VAR 0 1
60384: PPUSH
60385: LD_INT 0
60387: PPUSH
60388: CALL_OW 1
60392: ST_TO_ADDR
// end ;
60393: LD_VAR 0 2
60397: RET
// export function MC_Add ( side , units ) ; var base ; begin
60398: LD_INT 0
60400: PPUSH
60401: PPUSH
// base := mc_bases + 1 ;
60402: LD_ADDR_VAR 0 4
60406: PUSH
60407: LD_EXP 61
60411: PUSH
60412: LD_INT 1
60414: PLUS
60415: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
60416: LD_ADDR_EXP 87
60420: PUSH
60421: LD_EXP 87
60425: PPUSH
60426: LD_VAR 0 4
60430: PPUSH
60431: LD_VAR 0 1
60435: PPUSH
60436: CALL_OW 1
60440: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
60441: LD_ADDR_EXP 61
60445: PUSH
60446: LD_EXP 61
60450: PPUSH
60451: LD_VAR 0 4
60455: PPUSH
60456: LD_VAR 0 2
60460: PPUSH
60461: CALL_OW 1
60465: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60466: LD_ADDR_EXP 62
60470: PUSH
60471: LD_EXP 62
60475: PPUSH
60476: LD_VAR 0 4
60480: PPUSH
60481: EMPTY
60482: PPUSH
60483: CALL_OW 1
60487: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60488: LD_ADDR_EXP 63
60492: PUSH
60493: LD_EXP 63
60497: PPUSH
60498: LD_VAR 0 4
60502: PPUSH
60503: EMPTY
60504: PPUSH
60505: CALL_OW 1
60509: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60510: LD_ADDR_EXP 64
60514: PUSH
60515: LD_EXP 64
60519: PPUSH
60520: LD_VAR 0 4
60524: PPUSH
60525: EMPTY
60526: PPUSH
60527: CALL_OW 1
60531: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60532: LD_ADDR_EXP 65
60536: PUSH
60537: LD_EXP 65
60541: PPUSH
60542: LD_VAR 0 4
60546: PPUSH
60547: EMPTY
60548: PPUSH
60549: CALL_OW 1
60553: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60554: LD_ADDR_EXP 66
60558: PUSH
60559: LD_EXP 66
60563: PPUSH
60564: LD_VAR 0 4
60568: PPUSH
60569: EMPTY
60570: PPUSH
60571: CALL_OW 1
60575: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60576: LD_ADDR_EXP 67
60580: PUSH
60581: LD_EXP 67
60585: PPUSH
60586: LD_VAR 0 4
60590: PPUSH
60591: EMPTY
60592: PPUSH
60593: CALL_OW 1
60597: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60598: LD_ADDR_EXP 68
60602: PUSH
60603: LD_EXP 68
60607: PPUSH
60608: LD_VAR 0 4
60612: PPUSH
60613: EMPTY
60614: PPUSH
60615: CALL_OW 1
60619: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60620: LD_ADDR_EXP 69
60624: PUSH
60625: LD_EXP 69
60629: PPUSH
60630: LD_VAR 0 4
60634: PPUSH
60635: EMPTY
60636: PPUSH
60637: CALL_OW 1
60641: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60642: LD_ADDR_EXP 70
60646: PUSH
60647: LD_EXP 70
60651: PPUSH
60652: LD_VAR 0 4
60656: PPUSH
60657: EMPTY
60658: PPUSH
60659: CALL_OW 1
60663: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60664: LD_ADDR_EXP 71
60668: PUSH
60669: LD_EXP 71
60673: PPUSH
60674: LD_VAR 0 4
60678: PPUSH
60679: EMPTY
60680: PPUSH
60681: CALL_OW 1
60685: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60686: LD_ADDR_EXP 72
60690: PUSH
60691: LD_EXP 72
60695: PPUSH
60696: LD_VAR 0 4
60700: PPUSH
60701: LD_INT 0
60703: PPUSH
60704: CALL_OW 1
60708: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60709: LD_ADDR_EXP 73
60713: PUSH
60714: LD_EXP 73
60718: PPUSH
60719: LD_VAR 0 4
60723: PPUSH
60724: EMPTY
60725: PPUSH
60726: CALL_OW 1
60730: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60731: LD_ADDR_EXP 74
60735: PUSH
60736: LD_EXP 74
60740: PPUSH
60741: LD_VAR 0 4
60745: PPUSH
60746: EMPTY
60747: PPUSH
60748: CALL_OW 1
60752: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60753: LD_ADDR_EXP 75
60757: PUSH
60758: LD_EXP 75
60762: PPUSH
60763: LD_VAR 0 4
60767: PPUSH
60768: EMPTY
60769: PPUSH
60770: CALL_OW 1
60774: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60775: LD_ADDR_EXP 76
60779: PUSH
60780: LD_EXP 76
60784: PPUSH
60785: LD_VAR 0 4
60789: PPUSH
60790: EMPTY
60791: PPUSH
60792: CALL_OW 1
60796: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60797: LD_ADDR_EXP 77
60801: PUSH
60802: LD_EXP 77
60806: PPUSH
60807: LD_VAR 0 4
60811: PPUSH
60812: EMPTY
60813: PPUSH
60814: CALL_OW 1
60818: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60819: LD_ADDR_EXP 78
60823: PUSH
60824: LD_EXP 78
60828: PPUSH
60829: LD_VAR 0 4
60833: PPUSH
60834: EMPTY
60835: PPUSH
60836: CALL_OW 1
60840: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60841: LD_ADDR_EXP 79
60845: PUSH
60846: LD_EXP 79
60850: PPUSH
60851: LD_VAR 0 4
60855: PPUSH
60856: EMPTY
60857: PPUSH
60858: CALL_OW 1
60862: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60863: LD_ADDR_EXP 80
60867: PUSH
60868: LD_EXP 80
60872: PPUSH
60873: LD_VAR 0 4
60877: PPUSH
60878: EMPTY
60879: PPUSH
60880: CALL_OW 1
60884: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60885: LD_ADDR_EXP 81
60889: PUSH
60890: LD_EXP 81
60894: PPUSH
60895: LD_VAR 0 4
60899: PPUSH
60900: EMPTY
60901: PPUSH
60902: CALL_OW 1
60906: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60907: LD_ADDR_EXP 82
60911: PUSH
60912: LD_EXP 82
60916: PPUSH
60917: LD_VAR 0 4
60921: PPUSH
60922: EMPTY
60923: PPUSH
60924: CALL_OW 1
60928: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60929: LD_ADDR_EXP 83
60933: PUSH
60934: LD_EXP 83
60938: PPUSH
60939: LD_VAR 0 4
60943: PPUSH
60944: EMPTY
60945: PPUSH
60946: CALL_OW 1
60950: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60951: LD_ADDR_EXP 84
60955: PUSH
60956: LD_EXP 84
60960: PPUSH
60961: LD_VAR 0 4
60965: PPUSH
60966: EMPTY
60967: PPUSH
60968: CALL_OW 1
60972: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60973: LD_ADDR_EXP 85
60977: PUSH
60978: LD_EXP 85
60982: PPUSH
60983: LD_VAR 0 4
60987: PPUSH
60988: EMPTY
60989: PPUSH
60990: CALL_OW 1
60994: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60995: LD_ADDR_EXP 86
60999: PUSH
61000: LD_EXP 86
61004: PPUSH
61005: LD_VAR 0 4
61009: PPUSH
61010: EMPTY
61011: PPUSH
61012: CALL_OW 1
61016: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61017: LD_ADDR_EXP 88
61021: PUSH
61022: LD_EXP 88
61026: PPUSH
61027: LD_VAR 0 4
61031: PPUSH
61032: EMPTY
61033: PPUSH
61034: CALL_OW 1
61038: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61039: LD_ADDR_EXP 90
61043: PUSH
61044: LD_EXP 90
61048: PPUSH
61049: LD_VAR 0 4
61053: PPUSH
61054: EMPTY
61055: PPUSH
61056: CALL_OW 1
61060: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61061: LD_ADDR_EXP 91
61065: PUSH
61066: LD_EXP 91
61070: PPUSH
61071: LD_VAR 0 4
61075: PPUSH
61076: EMPTY
61077: PPUSH
61078: CALL_OW 1
61082: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61083: LD_ADDR_EXP 92
61087: PUSH
61088: LD_EXP 92
61092: PPUSH
61093: LD_VAR 0 4
61097: PPUSH
61098: EMPTY
61099: PPUSH
61100: CALL_OW 1
61104: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61105: LD_ADDR_EXP 93
61109: PUSH
61110: LD_EXP 93
61114: PPUSH
61115: LD_VAR 0 4
61119: PPUSH
61120: EMPTY
61121: PPUSH
61122: CALL_OW 1
61126: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61127: LD_ADDR_EXP 94
61131: PUSH
61132: LD_EXP 94
61136: PPUSH
61137: LD_VAR 0 4
61141: PPUSH
61142: EMPTY
61143: PPUSH
61144: CALL_OW 1
61148: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61149: LD_ADDR_EXP 95
61153: PUSH
61154: LD_EXP 95
61158: PPUSH
61159: LD_VAR 0 4
61163: PPUSH
61164: EMPTY
61165: PPUSH
61166: CALL_OW 1
61170: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61171: LD_ADDR_EXP 96
61175: PUSH
61176: LD_EXP 96
61180: PPUSH
61181: LD_VAR 0 4
61185: PPUSH
61186: EMPTY
61187: PPUSH
61188: CALL_OW 1
61192: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61193: LD_ADDR_EXP 97
61197: PUSH
61198: LD_EXP 97
61202: PPUSH
61203: LD_VAR 0 4
61207: PPUSH
61208: EMPTY
61209: PPUSH
61210: CALL_OW 1
61214: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61215: LD_ADDR_EXP 98
61219: PUSH
61220: LD_EXP 98
61224: PPUSH
61225: LD_VAR 0 4
61229: PPUSH
61230: EMPTY
61231: PPUSH
61232: CALL_OW 1
61236: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61237: LD_ADDR_EXP 99
61241: PUSH
61242: LD_EXP 99
61246: PPUSH
61247: LD_VAR 0 4
61251: PPUSH
61252: EMPTY
61253: PPUSH
61254: CALL_OW 1
61258: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61259: LD_ADDR_EXP 100
61263: PUSH
61264: LD_EXP 100
61268: PPUSH
61269: LD_VAR 0 4
61273: PPUSH
61274: EMPTY
61275: PPUSH
61276: CALL_OW 1
61280: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61281: LD_ADDR_EXP 101
61285: PUSH
61286: LD_EXP 101
61290: PPUSH
61291: LD_VAR 0 4
61295: PPUSH
61296: EMPTY
61297: PPUSH
61298: CALL_OW 1
61302: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61303: LD_ADDR_EXP 102
61307: PUSH
61308: LD_EXP 102
61312: PPUSH
61313: LD_VAR 0 4
61317: PPUSH
61318: EMPTY
61319: PPUSH
61320: CALL_OW 1
61324: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61325: LD_ADDR_EXP 103
61329: PUSH
61330: LD_EXP 103
61334: PPUSH
61335: LD_VAR 0 4
61339: PPUSH
61340: LD_INT 0
61342: PPUSH
61343: CALL_OW 1
61347: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61348: LD_ADDR_EXP 104
61352: PUSH
61353: LD_EXP 104
61357: PPUSH
61358: LD_VAR 0 4
61362: PPUSH
61363: LD_INT 0
61365: PPUSH
61366: CALL_OW 1
61370: ST_TO_ADDR
// result := base ;
61371: LD_ADDR_VAR 0 3
61375: PUSH
61376: LD_VAR 0 4
61380: ST_TO_ADDR
// end ;
61381: LD_VAR 0 3
61385: RET
// export function MC_Start ( ) ; var i ; begin
61386: LD_INT 0
61388: PPUSH
61389: PPUSH
// for i = 1 to mc_bases do
61390: LD_ADDR_VAR 0 2
61394: PUSH
61395: DOUBLE
61396: LD_INT 1
61398: DEC
61399: ST_TO_ADDR
61400: LD_EXP 61
61404: PUSH
61405: FOR_TO
61406: IFFALSE 62506
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
61408: LD_ADDR_EXP 61
61412: PUSH
61413: LD_EXP 61
61417: PPUSH
61418: LD_VAR 0 2
61422: PPUSH
61423: LD_EXP 61
61427: PUSH
61428: LD_VAR 0 2
61432: ARRAY
61433: PUSH
61434: LD_INT 0
61436: DIFF
61437: PPUSH
61438: CALL_OW 1
61442: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
61443: LD_ADDR_EXP 62
61447: PUSH
61448: LD_EXP 62
61452: PPUSH
61453: LD_VAR 0 2
61457: PPUSH
61458: EMPTY
61459: PPUSH
61460: CALL_OW 1
61464: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61465: LD_ADDR_EXP 63
61469: PUSH
61470: LD_EXP 63
61474: PPUSH
61475: LD_VAR 0 2
61479: PPUSH
61480: EMPTY
61481: PPUSH
61482: CALL_OW 1
61486: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
61487: LD_ADDR_EXP 64
61491: PUSH
61492: LD_EXP 64
61496: PPUSH
61497: LD_VAR 0 2
61501: PPUSH
61502: EMPTY
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
61509: LD_ADDR_EXP 65
61513: PUSH
61514: LD_EXP 65
61518: PPUSH
61519: LD_VAR 0 2
61523: PPUSH
61524: EMPTY
61525: PUSH
61526: EMPTY
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: PPUSH
61532: CALL_OW 1
61536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
61537: LD_ADDR_EXP 66
61541: PUSH
61542: LD_EXP 66
61546: PPUSH
61547: LD_VAR 0 2
61551: PPUSH
61552: EMPTY
61553: PPUSH
61554: CALL_OW 1
61558: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
61559: LD_ADDR_EXP 93
61563: PUSH
61564: LD_EXP 93
61568: PPUSH
61569: LD_VAR 0 2
61573: PPUSH
61574: EMPTY
61575: PPUSH
61576: CALL_OW 1
61580: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
61581: LD_ADDR_EXP 67
61585: PUSH
61586: LD_EXP 67
61590: PPUSH
61591: LD_VAR 0 2
61595: PPUSH
61596: EMPTY
61597: PPUSH
61598: CALL_OW 1
61602: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
61603: LD_ADDR_EXP 68
61607: PUSH
61608: LD_EXP 68
61612: PPUSH
61613: LD_VAR 0 2
61617: PPUSH
61618: EMPTY
61619: PPUSH
61620: CALL_OW 1
61624: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
61625: LD_ADDR_EXP 69
61629: PUSH
61630: LD_EXP 69
61634: PPUSH
61635: LD_VAR 0 2
61639: PPUSH
61640: LD_EXP 61
61644: PUSH
61645: LD_VAR 0 2
61649: ARRAY
61650: PPUSH
61651: LD_INT 2
61653: PUSH
61654: LD_INT 30
61656: PUSH
61657: LD_INT 32
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PUSH
61664: LD_INT 30
61666: PUSH
61667: LD_INT 33
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: LIST
61678: PPUSH
61679: CALL_OW 72
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
61689: LD_ADDR_EXP 70
61693: PUSH
61694: LD_EXP 70
61698: PPUSH
61699: LD_VAR 0 2
61703: PPUSH
61704: LD_EXP 61
61708: PUSH
61709: LD_VAR 0 2
61713: ARRAY
61714: PPUSH
61715: LD_INT 2
61717: PUSH
61718: LD_INT 30
61720: PUSH
61721: LD_INT 32
61723: PUSH
61724: EMPTY
61725: LIST
61726: LIST
61727: PUSH
61728: LD_INT 30
61730: PUSH
61731: LD_INT 31
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: PUSH
61738: EMPTY
61739: LIST
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 58
61745: PUSH
61746: EMPTY
61747: LIST
61748: PUSH
61749: EMPTY
61750: LIST
61751: LIST
61752: PPUSH
61753: CALL_OW 72
61757: PPUSH
61758: CALL_OW 1
61762: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
61763: LD_ADDR_EXP 71
61767: PUSH
61768: LD_EXP 71
61772: PPUSH
61773: LD_VAR 0 2
61777: PPUSH
61778: EMPTY
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
61785: LD_ADDR_EXP 75
61789: PUSH
61790: LD_EXP 75
61794: PPUSH
61795: LD_VAR 0 2
61799: PPUSH
61800: EMPTY
61801: PPUSH
61802: CALL_OW 1
61806: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
61807: LD_ADDR_EXP 74
61811: PUSH
61812: LD_EXP 74
61816: PPUSH
61817: LD_VAR 0 2
61821: PPUSH
61822: EMPTY
61823: PPUSH
61824: CALL_OW 1
61828: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
61829: LD_ADDR_EXP 76
61833: PUSH
61834: LD_EXP 76
61838: PPUSH
61839: LD_VAR 0 2
61843: PPUSH
61844: EMPTY
61845: PPUSH
61846: CALL_OW 1
61850: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
61851: LD_ADDR_EXP 77
61855: PUSH
61856: LD_EXP 77
61860: PPUSH
61861: LD_VAR 0 2
61865: PPUSH
61866: EMPTY
61867: PPUSH
61868: CALL_OW 1
61872: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61873: LD_ADDR_EXP 78
61877: PUSH
61878: LD_EXP 78
61882: PPUSH
61883: LD_VAR 0 2
61887: PPUSH
61888: EMPTY
61889: PPUSH
61890: CALL_OW 1
61894: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
61895: LD_ADDR_EXP 79
61899: PUSH
61900: LD_EXP 79
61904: PPUSH
61905: LD_VAR 0 2
61909: PPUSH
61910: EMPTY
61911: PPUSH
61912: CALL_OW 1
61916: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
61917: LD_ADDR_EXP 80
61921: PUSH
61922: LD_EXP 80
61926: PPUSH
61927: LD_VAR 0 2
61931: PPUSH
61932: EMPTY
61933: PPUSH
61934: CALL_OW 1
61938: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
61939: LD_ADDR_EXP 81
61943: PUSH
61944: LD_EXP 81
61948: PPUSH
61949: LD_VAR 0 2
61953: PPUSH
61954: EMPTY
61955: PPUSH
61956: CALL_OW 1
61960: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
61961: LD_ADDR_EXP 82
61965: PUSH
61966: LD_EXP 82
61970: PPUSH
61971: LD_VAR 0 2
61975: PPUSH
61976: EMPTY
61977: PPUSH
61978: CALL_OW 1
61982: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
61983: LD_ADDR_EXP 83
61987: PUSH
61988: LD_EXP 83
61992: PPUSH
61993: LD_VAR 0 2
61997: PPUSH
61998: EMPTY
61999: PPUSH
62000: CALL_OW 1
62004: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62005: LD_ADDR_EXP 72
62009: PUSH
62010: LD_EXP 72
62014: PPUSH
62015: LD_VAR 0 2
62019: PPUSH
62020: LD_INT 0
62022: PPUSH
62023: CALL_OW 1
62027: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62028: LD_ADDR_EXP 85
62032: PUSH
62033: LD_EXP 85
62037: PPUSH
62038: LD_VAR 0 2
62042: PPUSH
62043: LD_INT 0
62045: PPUSH
62046: CALL_OW 1
62050: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62051: LD_ADDR_EXP 73
62055: PUSH
62056: LD_EXP 73
62060: PPUSH
62061: LD_VAR 0 2
62065: PPUSH
62066: EMPTY
62067: PPUSH
62068: CALL_OW 1
62072: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62073: LD_ADDR_EXP 84
62077: PUSH
62078: LD_EXP 84
62082: PPUSH
62083: LD_VAR 0 2
62087: PPUSH
62088: LD_INT 0
62090: PPUSH
62091: CALL_OW 1
62095: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
62096: LD_ADDR_EXP 86
62100: PUSH
62101: LD_EXP 86
62105: PPUSH
62106: LD_VAR 0 2
62110: PPUSH
62111: EMPTY
62112: PPUSH
62113: CALL_OW 1
62117: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
62118: LD_ADDR_EXP 89
62122: PUSH
62123: LD_EXP 89
62127: PPUSH
62128: LD_VAR 0 2
62132: PPUSH
62133: LD_INT 0
62135: PPUSH
62136: CALL_OW 1
62140: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
62141: LD_ADDR_EXP 90
62145: PUSH
62146: LD_EXP 90
62150: PPUSH
62151: LD_VAR 0 2
62155: PPUSH
62156: EMPTY
62157: PPUSH
62158: CALL_OW 1
62162: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62163: LD_ADDR_EXP 91
62167: PUSH
62168: LD_EXP 91
62172: PPUSH
62173: LD_VAR 0 2
62177: PPUSH
62178: EMPTY
62179: PPUSH
62180: CALL_OW 1
62184: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62185: LD_ADDR_EXP 92
62189: PUSH
62190: LD_EXP 92
62194: PPUSH
62195: LD_VAR 0 2
62199: PPUSH
62200: EMPTY
62201: PPUSH
62202: CALL_OW 1
62206: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
62207: LD_ADDR_EXP 94
62211: PUSH
62212: LD_EXP 94
62216: PPUSH
62217: LD_VAR 0 2
62221: PPUSH
62222: LD_EXP 61
62226: PUSH
62227: LD_VAR 0 2
62231: ARRAY
62232: PPUSH
62233: LD_INT 2
62235: PUSH
62236: LD_INT 30
62238: PUSH
62239: LD_INT 6
62241: PUSH
62242: EMPTY
62243: LIST
62244: LIST
62245: PUSH
62246: LD_INT 30
62248: PUSH
62249: LD_INT 7
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 8
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: LIST
62270: LIST
62271: PPUSH
62272: CALL_OW 72
62276: PPUSH
62277: CALL_OW 1
62281: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
62282: LD_ADDR_EXP 95
62286: PUSH
62287: LD_EXP 95
62291: PPUSH
62292: LD_VAR 0 2
62296: PPUSH
62297: EMPTY
62298: PPUSH
62299: CALL_OW 1
62303: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
62304: LD_ADDR_EXP 96
62308: PUSH
62309: LD_EXP 96
62313: PPUSH
62314: LD_VAR 0 2
62318: PPUSH
62319: EMPTY
62320: PPUSH
62321: CALL_OW 1
62325: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
62326: LD_ADDR_EXP 97
62330: PUSH
62331: LD_EXP 97
62335: PPUSH
62336: LD_VAR 0 2
62340: PPUSH
62341: EMPTY
62342: PPUSH
62343: CALL_OW 1
62347: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
62348: LD_ADDR_EXP 98
62352: PUSH
62353: LD_EXP 98
62357: PPUSH
62358: LD_VAR 0 2
62362: PPUSH
62363: EMPTY
62364: PPUSH
62365: CALL_OW 1
62369: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62370: LD_ADDR_EXP 99
62374: PUSH
62375: LD_EXP 99
62379: PPUSH
62380: LD_VAR 0 2
62384: PPUSH
62385: EMPTY
62386: PPUSH
62387: CALL_OW 1
62391: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
62392: LD_ADDR_EXP 100
62396: PUSH
62397: LD_EXP 100
62401: PPUSH
62402: LD_VAR 0 2
62406: PPUSH
62407: EMPTY
62408: PPUSH
62409: CALL_OW 1
62413: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
62414: LD_ADDR_EXP 101
62418: PUSH
62419: LD_EXP 101
62423: PPUSH
62424: LD_VAR 0 2
62428: PPUSH
62429: EMPTY
62430: PPUSH
62431: CALL_OW 1
62435: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
62436: LD_ADDR_EXP 102
62440: PUSH
62441: LD_EXP 102
62445: PPUSH
62446: LD_VAR 0 2
62450: PPUSH
62451: EMPTY
62452: PPUSH
62453: CALL_OW 1
62457: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
62458: LD_ADDR_EXP 103
62462: PUSH
62463: LD_EXP 103
62467: PPUSH
62468: LD_VAR 0 2
62472: PPUSH
62473: LD_INT 0
62475: PPUSH
62476: CALL_OW 1
62480: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
62481: LD_ADDR_EXP 104
62485: PUSH
62486: LD_EXP 104
62490: PPUSH
62491: LD_VAR 0 2
62495: PPUSH
62496: LD_INT 0
62498: PPUSH
62499: CALL_OW 1
62503: ST_TO_ADDR
// end ;
62504: GO 61405
62506: POP
62507: POP
// MC_InitSides ( ) ;
62508: CALL 62794 0 0
// MC_InitResearch ( ) ;
62512: CALL 62533 0 0
// CustomInitMacro ( ) ;
62516: CALL 219 0 0
// skirmish := true ;
62520: LD_ADDR_EXP 59
62524: PUSH
62525: LD_INT 1
62527: ST_TO_ADDR
// end ;
62528: LD_VAR 0 1
62532: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
62533: LD_INT 0
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
62540: PPUSH
// if not mc_bases then
62541: LD_EXP 61
62545: NOT
62546: IFFALSE 62550
// exit ;
62548: GO 62789
// for i = 1 to 8 do
62550: LD_ADDR_VAR 0 2
62554: PUSH
62555: DOUBLE
62556: LD_INT 1
62558: DEC
62559: ST_TO_ADDR
62560: LD_INT 8
62562: PUSH
62563: FOR_TO
62564: IFFALSE 62590
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
62566: LD_ADDR_EXP 88
62570: PUSH
62571: LD_EXP 88
62575: PPUSH
62576: LD_VAR 0 2
62580: PPUSH
62581: EMPTY
62582: PPUSH
62583: CALL_OW 1
62587: ST_TO_ADDR
62588: GO 62563
62590: POP
62591: POP
// tmp := [ ] ;
62592: LD_ADDR_VAR 0 5
62596: PUSH
62597: EMPTY
62598: ST_TO_ADDR
// for i = 1 to mc_sides do
62599: LD_ADDR_VAR 0 2
62603: PUSH
62604: DOUBLE
62605: LD_INT 1
62607: DEC
62608: ST_TO_ADDR
62609: LD_EXP 87
62613: PUSH
62614: FOR_TO
62615: IFFALSE 62673
// if not mc_sides [ i ] in tmp then
62617: LD_EXP 87
62621: PUSH
62622: LD_VAR 0 2
62626: ARRAY
62627: PUSH
62628: LD_VAR 0 5
62632: IN
62633: NOT
62634: IFFALSE 62671
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
62636: LD_ADDR_VAR 0 5
62640: PUSH
62641: LD_VAR 0 5
62645: PPUSH
62646: LD_VAR 0 5
62650: PUSH
62651: LD_INT 1
62653: PLUS
62654: PPUSH
62655: LD_EXP 87
62659: PUSH
62660: LD_VAR 0 2
62664: ARRAY
62665: PPUSH
62666: CALL_OW 2
62670: ST_TO_ADDR
62671: GO 62614
62673: POP
62674: POP
// if not tmp then
62675: LD_VAR 0 5
62679: NOT
62680: IFFALSE 62684
// exit ;
62682: GO 62789
// for j in tmp do
62684: LD_ADDR_VAR 0 3
62688: PUSH
62689: LD_VAR 0 5
62693: PUSH
62694: FOR_IN
62695: IFFALSE 62787
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
62697: LD_ADDR_VAR 0 6
62701: PUSH
62702: LD_INT 22
62704: PUSH
62705: LD_VAR 0 3
62709: PUSH
62710: EMPTY
62711: LIST
62712: LIST
62713: PPUSH
62714: CALL_OW 69
62718: ST_TO_ADDR
// if not un then
62719: LD_VAR 0 6
62723: NOT
62724: IFFALSE 62728
// continue ;
62726: GO 62694
// nation := GetNation ( un [ 1 ] ) ;
62728: LD_ADDR_VAR 0 4
62732: PUSH
62733: LD_VAR 0 6
62737: PUSH
62738: LD_INT 1
62740: ARRAY
62741: PPUSH
62742: CALL_OW 248
62746: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
62747: LD_ADDR_EXP 88
62751: PUSH
62752: LD_EXP 88
62756: PPUSH
62757: LD_VAR 0 3
62761: PPUSH
62762: LD_VAR 0 3
62766: PPUSH
62767: LD_VAR 0 4
62771: PPUSH
62772: LD_INT 1
62774: PPUSH
62775: CALL 16498 0 3
62779: PPUSH
62780: CALL_OW 1
62784: ST_TO_ADDR
// end ;
62785: GO 62694
62787: POP
62788: POP
// end ;
62789: LD_VAR 0 1
62793: RET
// export function MC_InitSides ( ) ; var i ; begin
62794: LD_INT 0
62796: PPUSH
62797: PPUSH
// if not mc_bases then
62798: LD_EXP 61
62802: NOT
62803: IFFALSE 62807
// exit ;
62805: GO 62881
// for i = 1 to mc_bases do
62807: LD_ADDR_VAR 0 2
62811: PUSH
62812: DOUBLE
62813: LD_INT 1
62815: DEC
62816: ST_TO_ADDR
62817: LD_EXP 61
62821: PUSH
62822: FOR_TO
62823: IFFALSE 62879
// if mc_bases [ i ] then
62825: LD_EXP 61
62829: PUSH
62830: LD_VAR 0 2
62834: ARRAY
62835: IFFALSE 62877
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
62837: LD_ADDR_EXP 87
62841: PUSH
62842: LD_EXP 87
62846: PPUSH
62847: LD_VAR 0 2
62851: PPUSH
62852: LD_EXP 61
62856: PUSH
62857: LD_VAR 0 2
62861: ARRAY
62862: PUSH
62863: LD_INT 1
62865: ARRAY
62866: PPUSH
62867: CALL_OW 255
62871: PPUSH
62872: CALL_OW 1
62876: ST_TO_ADDR
62877: GO 62822
62879: POP
62880: POP
// end ;
62881: LD_VAR 0 1
62885: RET
// every 0 0$03 trigger skirmish do
62886: LD_EXP 59
62890: IFFALSE 63044
62892: GO 62894
62894: DISABLE
// begin enable ;
62895: ENABLE
// MC_CheckBuildings ( ) ;
62896: CALL 67556 0 0
// MC_CheckPeopleLife ( ) ;
62900: CALL 67717 0 0
// RaiseSailEvent ( 100 ) ;
62904: LD_INT 100
62906: PPUSH
62907: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
62911: LD_INT 103
62913: PPUSH
62914: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
62918: LD_INT 104
62920: PPUSH
62921: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
62925: LD_INT 105
62927: PPUSH
62928: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
62932: LD_INT 106
62934: PPUSH
62935: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
62939: LD_INT 107
62941: PPUSH
62942: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
62946: LD_INT 108
62948: PPUSH
62949: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
62953: LD_INT 109
62955: PPUSH
62956: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
62960: LD_INT 110
62962: PPUSH
62963: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
62967: LD_INT 111
62969: PPUSH
62970: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
62974: LD_INT 112
62976: PPUSH
62977: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
62981: LD_INT 113
62983: PPUSH
62984: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
62988: LD_INT 120
62990: PPUSH
62991: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
62995: LD_INT 121
62997: PPUSH
62998: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63002: LD_INT 122
63004: PPUSH
63005: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63009: LD_INT 123
63011: PPUSH
63012: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63016: LD_INT 124
63018: PPUSH
63019: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63023: LD_INT 125
63025: PPUSH
63026: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63030: LD_INT 126
63032: PPUSH
63033: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63037: LD_INT 200
63039: PPUSH
63040: CALL_OW 427
// end ;
63044: END
// on SailEvent ( event ) do begin if event < 100 then
63045: LD_VAR 0 1
63049: PUSH
63050: LD_INT 100
63052: LESS
63053: IFFALSE 63064
// CustomEvent ( event ) ;
63055: LD_VAR 0 1
63059: PPUSH
63060: CALL 15083 0 1
// if event = 100 then
63064: LD_VAR 0 1
63068: PUSH
63069: LD_INT 100
63071: EQUAL
63072: IFFALSE 63078
// MC_ClassManager ( ) ;
63074: CALL 63470 0 0
// if event = 101 then
63078: LD_VAR 0 1
63082: PUSH
63083: LD_INT 101
63085: EQUAL
63086: IFFALSE 63092
// MC_RepairBuildings ( ) ;
63088: CALL 68302 0 0
// if event = 102 then
63092: LD_VAR 0 1
63096: PUSH
63097: LD_INT 102
63099: EQUAL
63100: IFFALSE 63106
// MC_Heal ( ) ;
63102: CALL 69237 0 0
// if event = 103 then
63106: LD_VAR 0 1
63110: PUSH
63111: LD_INT 103
63113: EQUAL
63114: IFFALSE 63120
// MC_Build ( ) ;
63116: CALL 69659 0 0
// if event = 104 then
63120: LD_VAR 0 1
63124: PUSH
63125: LD_INT 104
63127: EQUAL
63128: IFFALSE 63134
// MC_TurretWeapon ( ) ;
63130: CALL 71293 0 0
// if event = 105 then
63134: LD_VAR 0 1
63138: PUSH
63139: LD_INT 105
63141: EQUAL
63142: IFFALSE 63148
// MC_BuildUpgrade ( ) ;
63144: CALL 70844 0 0
// if event = 106 then
63148: LD_VAR 0 1
63152: PUSH
63153: LD_INT 106
63155: EQUAL
63156: IFFALSE 63162
// MC_PlantMines ( ) ;
63158: CALL 71723 0 0
// if event = 107 then
63162: LD_VAR 0 1
63166: PUSH
63167: LD_INT 107
63169: EQUAL
63170: IFFALSE 63176
// MC_CollectCrates ( ) ;
63172: CALL 72521 0 0
// if event = 108 then
63176: LD_VAR 0 1
63180: PUSH
63181: LD_INT 108
63183: EQUAL
63184: IFFALSE 63190
// MC_LinkRemoteControl ( ) ;
63186: CALL 74371 0 0
// if event = 109 then
63190: LD_VAR 0 1
63194: PUSH
63195: LD_INT 109
63197: EQUAL
63198: IFFALSE 63204
// MC_ProduceVehicle ( ) ;
63200: CALL 74552 0 0
// if event = 110 then
63204: LD_VAR 0 1
63208: PUSH
63209: LD_INT 110
63211: EQUAL
63212: IFFALSE 63218
// MC_SendAttack ( ) ;
63214: CALL 75018 0 0
// if event = 111 then
63218: LD_VAR 0 1
63222: PUSH
63223: LD_INT 111
63225: EQUAL
63226: IFFALSE 63232
// MC_Defend ( ) ;
63228: CALL 75126 0 0
// if event = 112 then
63232: LD_VAR 0 1
63236: PUSH
63237: LD_INT 112
63239: EQUAL
63240: IFFALSE 63246
// MC_Research ( ) ;
63242: CALL 76006 0 0
// if event = 113 then
63246: LD_VAR 0 1
63250: PUSH
63251: LD_INT 113
63253: EQUAL
63254: IFFALSE 63260
// MC_MinesTrigger ( ) ;
63256: CALL 77120 0 0
// if event = 120 then
63260: LD_VAR 0 1
63264: PUSH
63265: LD_INT 120
63267: EQUAL
63268: IFFALSE 63274
// MC_RepairVehicle ( ) ;
63270: CALL 77219 0 0
// if event = 121 then
63274: LD_VAR 0 1
63278: PUSH
63279: LD_INT 121
63281: EQUAL
63282: IFFALSE 63288
// MC_TameApe ( ) ;
63284: CALL 77988 0 0
// if event = 122 then
63288: LD_VAR 0 1
63292: PUSH
63293: LD_INT 122
63295: EQUAL
63296: IFFALSE 63302
// MC_ChangeApeClass ( ) ;
63298: CALL 78817 0 0
// if event = 123 then
63302: LD_VAR 0 1
63306: PUSH
63307: LD_INT 123
63309: EQUAL
63310: IFFALSE 63316
// MC_Bazooka ( ) ;
63312: CALL 79467 0 0
// if event = 124 then
63316: LD_VAR 0 1
63320: PUSH
63321: LD_INT 124
63323: EQUAL
63324: IFFALSE 63330
// MC_TeleportExit ( ) ;
63326: CALL 79665 0 0
// if event = 125 then
63330: LD_VAR 0 1
63334: PUSH
63335: LD_INT 125
63337: EQUAL
63338: IFFALSE 63344
// MC_Deposits ( ) ;
63340: CALL 80312 0 0
// if event = 126 then
63344: LD_VAR 0 1
63348: PUSH
63349: LD_INT 126
63351: EQUAL
63352: IFFALSE 63358
// MC_RemoteDriver ( ) ;
63354: CALL 80937 0 0
// if event = 200 then
63358: LD_VAR 0 1
63362: PUSH
63363: LD_INT 200
63365: EQUAL
63366: IFFALSE 63372
// MC_Idle ( ) ;
63368: CALL 82844 0 0
// end ;
63372: PPOPN 1
63374: END
// export function MC_Reset ( base , tag ) ; var i ; begin
63375: LD_INT 0
63377: PPUSH
63378: PPUSH
// if not mc_bases [ base ] or not tag then
63379: LD_EXP 61
63383: PUSH
63384: LD_VAR 0 1
63388: ARRAY
63389: NOT
63390: PUSH
63391: LD_VAR 0 2
63395: NOT
63396: OR
63397: IFFALSE 63401
// exit ;
63399: GO 63465
// for i in mc_bases [ base ] union mc_ape [ base ] do
63401: LD_ADDR_VAR 0 4
63405: PUSH
63406: LD_EXP 61
63410: PUSH
63411: LD_VAR 0 1
63415: ARRAY
63416: PUSH
63417: LD_EXP 90
63421: PUSH
63422: LD_VAR 0 1
63426: ARRAY
63427: UNION
63428: PUSH
63429: FOR_IN
63430: IFFALSE 63463
// if GetTag ( i ) = tag then
63432: LD_VAR 0 4
63436: PPUSH
63437: CALL_OW 110
63441: PUSH
63442: LD_VAR 0 2
63446: EQUAL
63447: IFFALSE 63461
// SetTag ( i , 0 ) ;
63449: LD_VAR 0 4
63453: PPUSH
63454: LD_INT 0
63456: PPUSH
63457: CALL_OW 109
63461: GO 63429
63463: POP
63464: POP
// end ;
63465: LD_VAR 0 3
63469: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
63470: LD_INT 0
63472: PPUSH
63473: PPUSH
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
63478: PPUSH
63479: PPUSH
// if not mc_bases then
63480: LD_EXP 61
63484: NOT
63485: IFFALSE 63489
// exit ;
63487: GO 63938
// for i = 1 to mc_bases do
63489: LD_ADDR_VAR 0 2
63493: PUSH
63494: DOUBLE
63495: LD_INT 1
63497: DEC
63498: ST_TO_ADDR
63499: LD_EXP 61
63503: PUSH
63504: FOR_TO
63505: IFFALSE 63936
// begin tmp := MC_ClassCheckReq ( i ) ;
63507: LD_ADDR_VAR 0 4
63511: PUSH
63512: LD_VAR 0 2
63516: PPUSH
63517: CALL 63943 0 1
63521: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
63522: LD_ADDR_EXP 102
63526: PUSH
63527: LD_EXP 102
63531: PPUSH
63532: LD_VAR 0 2
63536: PPUSH
63537: LD_VAR 0 4
63541: PPUSH
63542: CALL_OW 1
63546: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
63547: LD_ADDR_VAR 0 6
63551: PUSH
63552: LD_EXP 61
63556: PUSH
63557: LD_VAR 0 2
63561: ARRAY
63562: PPUSH
63563: LD_INT 2
63565: PUSH
63566: LD_INT 30
63568: PUSH
63569: LD_INT 4
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 30
63578: PUSH
63579: LD_INT 5
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: LIST
63590: PPUSH
63591: CALL_OW 72
63595: PUSH
63596: LD_EXP 61
63600: PUSH
63601: LD_VAR 0 2
63605: ARRAY
63606: PPUSH
63607: LD_INT 2
63609: PUSH
63610: LD_INT 30
63612: PUSH
63613: LD_INT 0
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 30
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: LIST
63634: PPUSH
63635: CALL_OW 72
63639: PUSH
63640: LD_EXP 61
63644: PUSH
63645: LD_VAR 0 2
63649: ARRAY
63650: PPUSH
63651: LD_INT 30
63653: PUSH
63654: LD_INT 3
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: PPUSH
63661: CALL_OW 72
63665: PUSH
63666: LD_EXP 61
63670: PUSH
63671: LD_VAR 0 2
63675: ARRAY
63676: PPUSH
63677: LD_INT 2
63679: PUSH
63680: LD_INT 30
63682: PUSH
63683: LD_INT 6
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 30
63692: PUSH
63693: LD_INT 7
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 30
63702: PUSH
63703: LD_INT 8
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: PPUSH
63716: CALL_OW 72
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: ST_TO_ADDR
// for j := 1 to 4 do
63727: LD_ADDR_VAR 0 3
63731: PUSH
63732: DOUBLE
63733: LD_INT 1
63735: DEC
63736: ST_TO_ADDR
63737: LD_INT 4
63739: PUSH
63740: FOR_TO
63741: IFFALSE 63932
// begin if not tmp [ j ] then
63743: LD_VAR 0 4
63747: PUSH
63748: LD_VAR 0 3
63752: ARRAY
63753: NOT
63754: IFFALSE 63758
// continue ;
63756: GO 63740
// for p in tmp [ j ] do
63758: LD_ADDR_VAR 0 5
63762: PUSH
63763: LD_VAR 0 4
63767: PUSH
63768: LD_VAR 0 3
63772: ARRAY
63773: PUSH
63774: FOR_IN
63775: IFFALSE 63928
// begin if not b [ j ] then
63777: LD_VAR 0 6
63781: PUSH
63782: LD_VAR 0 3
63786: ARRAY
63787: NOT
63788: IFFALSE 63792
// break ;
63790: GO 63928
// e := 0 ;
63792: LD_ADDR_VAR 0 7
63796: PUSH
63797: LD_INT 0
63799: ST_TO_ADDR
// for k in b [ j ] do
63800: LD_ADDR_VAR 0 8
63804: PUSH
63805: LD_VAR 0 6
63809: PUSH
63810: LD_VAR 0 3
63814: ARRAY
63815: PUSH
63816: FOR_IN
63817: IFFALSE 63844
// if IsNotFull ( k ) then
63819: LD_VAR 0 8
63823: PPUSH
63824: CALL 18619 0 1
63828: IFFALSE 63842
// begin e := k ;
63830: LD_ADDR_VAR 0 7
63834: PUSH
63835: LD_VAR 0 8
63839: ST_TO_ADDR
// break ;
63840: GO 63844
// end ;
63842: GO 63816
63844: POP
63845: POP
// if e and not UnitGoingToBuilding ( p , e ) then
63846: LD_VAR 0 7
63850: PUSH
63851: LD_VAR 0 5
63855: PPUSH
63856: LD_VAR 0 7
63860: PPUSH
63861: CALL 52758 0 2
63865: NOT
63866: AND
63867: IFFALSE 63926
// begin if IsInUnit ( p ) then
63869: LD_VAR 0 5
63873: PPUSH
63874: CALL_OW 310
63878: IFFALSE 63889
// ComExitBuilding ( p ) ;
63880: LD_VAR 0 5
63884: PPUSH
63885: CALL_OW 122
// ComEnterUnit ( p , e ) ;
63889: LD_VAR 0 5
63893: PPUSH
63894: LD_VAR 0 7
63898: PPUSH
63899: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
63903: LD_VAR 0 5
63907: PPUSH
63908: LD_VAR 0 3
63912: PPUSH
63913: CALL_OW 183
// AddComExitBuilding ( p ) ;
63917: LD_VAR 0 5
63921: PPUSH
63922: CALL_OW 182
// end ; end ;
63926: GO 63774
63928: POP
63929: POP
// end ;
63930: GO 63740
63932: POP
63933: POP
// end ;
63934: GO 63504
63936: POP
63937: POP
// end ;
63938: LD_VAR 0 1
63942: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
63943: LD_INT 0
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
63952: PPUSH
63953: PPUSH
63954: PPUSH
63955: PPUSH
63956: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
63957: LD_ADDR_VAR 0 2
63961: PUSH
63962: LD_INT 0
63964: PUSH
63965: LD_INT 0
63967: PUSH
63968: LD_INT 0
63970: PUSH
63971: LD_INT 0
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: LIST
63978: LIST
63979: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63980: LD_VAR 0 1
63984: NOT
63985: PUSH
63986: LD_EXP 61
63990: PUSH
63991: LD_VAR 0 1
63995: ARRAY
63996: NOT
63997: OR
63998: PUSH
63999: LD_EXP 61
64003: PUSH
64004: LD_VAR 0 1
64008: ARRAY
64009: PPUSH
64010: LD_INT 2
64012: PUSH
64013: LD_INT 30
64015: PUSH
64016: LD_INT 0
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 30
64025: PUSH
64026: LD_INT 1
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: LIST
64037: PPUSH
64038: CALL_OW 72
64042: NOT
64043: OR
64044: IFFALSE 64048
// exit ;
64046: GO 67551
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64048: LD_ADDR_VAR 0 4
64052: PUSH
64053: LD_EXP 61
64057: PUSH
64058: LD_VAR 0 1
64062: ARRAY
64063: PPUSH
64064: LD_INT 2
64066: PUSH
64067: LD_INT 25
64069: PUSH
64070: LD_INT 1
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: LD_INT 25
64079: PUSH
64080: LD_INT 2
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 25
64089: PUSH
64090: LD_INT 3
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 25
64099: PUSH
64100: LD_INT 4
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 25
64109: PUSH
64110: LD_INT 5
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 25
64119: PUSH
64120: LD_INT 8
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 25
64129: PUSH
64130: LD_INT 9
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: PPUSH
64147: CALL_OW 72
64151: ST_TO_ADDR
// if not tmp then
64152: LD_VAR 0 4
64156: NOT
64157: IFFALSE 64161
// exit ;
64159: GO 67551
// for i in tmp do
64161: LD_ADDR_VAR 0 3
64165: PUSH
64166: LD_VAR 0 4
64170: PUSH
64171: FOR_IN
64172: IFFALSE 64203
// if GetTag ( i ) then
64174: LD_VAR 0 3
64178: PPUSH
64179: CALL_OW 110
64183: IFFALSE 64201
// tmp := tmp diff i ;
64185: LD_ADDR_VAR 0 4
64189: PUSH
64190: LD_VAR 0 4
64194: PUSH
64195: LD_VAR 0 3
64199: DIFF
64200: ST_TO_ADDR
64201: GO 64171
64203: POP
64204: POP
// if not tmp then
64205: LD_VAR 0 4
64209: NOT
64210: IFFALSE 64214
// exit ;
64212: GO 67551
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64214: LD_ADDR_VAR 0 5
64218: PUSH
64219: LD_EXP 61
64223: PUSH
64224: LD_VAR 0 1
64228: ARRAY
64229: PPUSH
64230: LD_INT 2
64232: PUSH
64233: LD_INT 25
64235: PUSH
64236: LD_INT 1
64238: PUSH
64239: EMPTY
64240: LIST
64241: LIST
64242: PUSH
64243: LD_INT 25
64245: PUSH
64246: LD_INT 5
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PUSH
64253: LD_INT 25
64255: PUSH
64256: LD_INT 8
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: PUSH
64263: LD_INT 25
64265: PUSH
64266: LD_INT 9
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: PPUSH
64280: CALL_OW 72
64284: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
64285: LD_ADDR_VAR 0 6
64289: PUSH
64290: LD_EXP 61
64294: PUSH
64295: LD_VAR 0 1
64299: ARRAY
64300: PPUSH
64301: LD_INT 25
64303: PUSH
64304: LD_INT 2
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PPUSH
64311: CALL_OW 72
64315: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
64316: LD_ADDR_VAR 0 7
64320: PUSH
64321: LD_EXP 61
64325: PUSH
64326: LD_VAR 0 1
64330: ARRAY
64331: PPUSH
64332: LD_INT 25
64334: PUSH
64335: LD_INT 3
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PPUSH
64342: CALL_OW 72
64346: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
64347: LD_ADDR_VAR 0 8
64351: PUSH
64352: LD_EXP 61
64356: PUSH
64357: LD_VAR 0 1
64361: ARRAY
64362: PPUSH
64363: LD_INT 25
64365: PUSH
64366: LD_INT 4
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 24
64375: PUSH
64376: LD_INT 251
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PPUSH
64387: CALL_OW 72
64391: ST_TO_ADDR
// if mc_is_defending [ base ] then
64392: LD_EXP 104
64396: PUSH
64397: LD_VAR 0 1
64401: ARRAY
64402: IFFALSE 64863
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
64404: LD_ADDR_EXP 103
64408: PUSH
64409: LD_EXP 103
64413: PPUSH
64414: LD_VAR 0 1
64418: PPUSH
64419: LD_INT 4
64421: PPUSH
64422: CALL_OW 1
64426: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64427: LD_ADDR_VAR 0 12
64431: PUSH
64432: LD_EXP 61
64436: PUSH
64437: LD_VAR 0 1
64441: ARRAY
64442: PPUSH
64443: LD_INT 2
64445: PUSH
64446: LD_INT 30
64448: PUSH
64449: LD_INT 4
64451: PUSH
64452: EMPTY
64453: LIST
64454: LIST
64455: PUSH
64456: LD_INT 30
64458: PUSH
64459: LD_INT 5
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: LIST
64470: PPUSH
64471: CALL_OW 72
64475: ST_TO_ADDR
// if not b then
64476: LD_VAR 0 12
64480: NOT
64481: IFFALSE 64485
// exit ;
64483: GO 67551
// p := [ ] ;
64485: LD_ADDR_VAR 0 11
64489: PUSH
64490: EMPTY
64491: ST_TO_ADDR
// if sci >= 2 then
64492: LD_VAR 0 8
64496: PUSH
64497: LD_INT 2
64499: GREATEREQUAL
64500: IFFALSE 64531
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
64502: LD_ADDR_VAR 0 8
64506: PUSH
64507: LD_VAR 0 8
64511: PUSH
64512: LD_INT 1
64514: ARRAY
64515: PUSH
64516: LD_VAR 0 8
64520: PUSH
64521: LD_INT 2
64523: ARRAY
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: ST_TO_ADDR
64529: GO 64592
// if sci = 1 then
64531: LD_VAR 0 8
64535: PUSH
64536: LD_INT 1
64538: EQUAL
64539: IFFALSE 64560
// sci := [ sci [ 1 ] ] else
64541: LD_ADDR_VAR 0 8
64545: PUSH
64546: LD_VAR 0 8
64550: PUSH
64551: LD_INT 1
64553: ARRAY
64554: PUSH
64555: EMPTY
64556: LIST
64557: ST_TO_ADDR
64558: GO 64592
// if sci = 0 then
64560: LD_VAR 0 8
64564: PUSH
64565: LD_INT 0
64567: EQUAL
64568: IFFALSE 64592
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
64570: LD_ADDR_VAR 0 11
64574: PUSH
64575: LD_VAR 0 4
64579: PPUSH
64580: LD_INT 4
64582: PPUSH
64583: CALL 52630 0 2
64587: PUSH
64588: LD_INT 1
64590: ARRAY
64591: ST_TO_ADDR
// if eng > 4 then
64592: LD_VAR 0 6
64596: PUSH
64597: LD_INT 4
64599: GREATER
64600: IFFALSE 64646
// for i = eng downto 4 do
64602: LD_ADDR_VAR 0 3
64606: PUSH
64607: DOUBLE
64608: LD_VAR 0 6
64612: INC
64613: ST_TO_ADDR
64614: LD_INT 4
64616: PUSH
64617: FOR_DOWNTO
64618: IFFALSE 64644
// eng := eng diff eng [ i ] ;
64620: LD_ADDR_VAR 0 6
64624: PUSH
64625: LD_VAR 0 6
64629: PUSH
64630: LD_VAR 0 6
64634: PUSH
64635: LD_VAR 0 3
64639: ARRAY
64640: DIFF
64641: ST_TO_ADDR
64642: GO 64617
64644: POP
64645: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
64646: LD_ADDR_VAR 0 4
64650: PUSH
64651: LD_VAR 0 4
64655: PUSH
64656: LD_VAR 0 5
64660: PUSH
64661: LD_VAR 0 6
64665: UNION
64666: PUSH
64667: LD_VAR 0 7
64671: UNION
64672: PUSH
64673: LD_VAR 0 8
64677: UNION
64678: DIFF
64679: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
64680: LD_ADDR_VAR 0 13
64684: PUSH
64685: LD_EXP 61
64689: PUSH
64690: LD_VAR 0 1
64694: ARRAY
64695: PPUSH
64696: LD_INT 2
64698: PUSH
64699: LD_INT 30
64701: PUSH
64702: LD_INT 32
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 30
64711: PUSH
64712: LD_INT 31
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: LIST
64723: PPUSH
64724: CALL_OW 72
64728: PUSH
64729: LD_EXP 61
64733: PUSH
64734: LD_VAR 0 1
64738: ARRAY
64739: PPUSH
64740: LD_INT 2
64742: PUSH
64743: LD_INT 30
64745: PUSH
64746: LD_INT 4
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 30
64755: PUSH
64756: LD_INT 5
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: EMPTY
64764: LIST
64765: LIST
64766: LIST
64767: PPUSH
64768: CALL_OW 72
64772: PUSH
64773: LD_INT 6
64775: MUL
64776: PLUS
64777: ST_TO_ADDR
// if bcount < tmp then
64778: LD_VAR 0 13
64782: PUSH
64783: LD_VAR 0 4
64787: LESS
64788: IFFALSE 64834
// for i = tmp downto bcount do
64790: LD_ADDR_VAR 0 3
64794: PUSH
64795: DOUBLE
64796: LD_VAR 0 4
64800: INC
64801: ST_TO_ADDR
64802: LD_VAR 0 13
64806: PUSH
64807: FOR_DOWNTO
64808: IFFALSE 64832
// tmp := Delete ( tmp , tmp ) ;
64810: LD_ADDR_VAR 0 4
64814: PUSH
64815: LD_VAR 0 4
64819: PPUSH
64820: LD_VAR 0 4
64824: PPUSH
64825: CALL_OW 3
64829: ST_TO_ADDR
64830: GO 64807
64832: POP
64833: POP
// result := [ tmp , 0 , 0 , p ] ;
64834: LD_ADDR_VAR 0 2
64838: PUSH
64839: LD_VAR 0 4
64843: PUSH
64844: LD_INT 0
64846: PUSH
64847: LD_INT 0
64849: PUSH
64850: LD_VAR 0 11
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: ST_TO_ADDR
// exit ;
64861: GO 67551
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64863: LD_EXP 61
64867: PUSH
64868: LD_VAR 0 1
64872: ARRAY
64873: PPUSH
64874: LD_INT 2
64876: PUSH
64877: LD_INT 30
64879: PUSH
64880: LD_INT 6
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 30
64889: PUSH
64890: LD_INT 7
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 30
64899: PUSH
64900: LD_INT 8
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: PPUSH
64913: CALL_OW 72
64917: NOT
64918: PUSH
64919: LD_EXP 61
64923: PUSH
64924: LD_VAR 0 1
64928: ARRAY
64929: PPUSH
64930: LD_INT 30
64932: PUSH
64933: LD_INT 3
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PPUSH
64940: CALL_OW 72
64944: NOT
64945: AND
64946: IFFALSE 65018
// begin if eng = tmp then
64948: LD_VAR 0 6
64952: PUSH
64953: LD_VAR 0 4
64957: EQUAL
64958: IFFALSE 64962
// exit ;
64960: GO 67551
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
64962: LD_ADDR_EXP 103
64966: PUSH
64967: LD_EXP 103
64971: PPUSH
64972: LD_VAR 0 1
64976: PPUSH
64977: LD_INT 1
64979: PPUSH
64980: CALL_OW 1
64984: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
64985: LD_ADDR_VAR 0 2
64989: PUSH
64990: LD_INT 0
64992: PUSH
64993: LD_VAR 0 4
64997: PUSH
64998: LD_VAR 0 6
65002: DIFF
65003: PUSH
65004: LD_INT 0
65006: PUSH
65007: LD_INT 0
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: ST_TO_ADDR
// exit ;
65016: GO 67551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65018: LD_EXP 88
65022: PUSH
65023: LD_EXP 87
65027: PUSH
65028: LD_VAR 0 1
65032: ARRAY
65033: ARRAY
65034: PUSH
65035: LD_EXP 61
65039: PUSH
65040: LD_VAR 0 1
65044: ARRAY
65045: PPUSH
65046: LD_INT 2
65048: PUSH
65049: LD_INT 30
65051: PUSH
65052: LD_INT 6
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 30
65061: PUSH
65062: LD_INT 7
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 30
65071: PUSH
65072: LD_INT 8
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: LIST
65083: LIST
65084: PPUSH
65085: CALL_OW 72
65089: AND
65090: PUSH
65091: LD_EXP 61
65095: PUSH
65096: LD_VAR 0 1
65100: ARRAY
65101: PPUSH
65102: LD_INT 30
65104: PUSH
65105: LD_INT 3
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PPUSH
65112: CALL_OW 72
65116: NOT
65117: AND
65118: IFFALSE 65332
// begin if sci >= 6 then
65120: LD_VAR 0 8
65124: PUSH
65125: LD_INT 6
65127: GREATEREQUAL
65128: IFFALSE 65132
// exit ;
65130: GO 67551
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
65132: LD_ADDR_EXP 103
65136: PUSH
65137: LD_EXP 103
65141: PPUSH
65142: LD_VAR 0 1
65146: PPUSH
65147: LD_INT 2
65149: PPUSH
65150: CALL_OW 1
65154: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
65155: LD_ADDR_VAR 0 9
65159: PUSH
65160: LD_VAR 0 4
65164: PUSH
65165: LD_VAR 0 8
65169: DIFF
65170: PPUSH
65171: LD_INT 4
65173: PPUSH
65174: CALL 52630 0 2
65178: ST_TO_ADDR
// p := [ ] ;
65179: LD_ADDR_VAR 0 11
65183: PUSH
65184: EMPTY
65185: ST_TO_ADDR
// if sci < 6 and sort > 6 then
65186: LD_VAR 0 8
65190: PUSH
65191: LD_INT 6
65193: LESS
65194: PUSH
65195: LD_VAR 0 9
65199: PUSH
65200: LD_INT 6
65202: GREATER
65203: AND
65204: IFFALSE 65285
// begin for i = 1 to 6 - sci do
65206: LD_ADDR_VAR 0 3
65210: PUSH
65211: DOUBLE
65212: LD_INT 1
65214: DEC
65215: ST_TO_ADDR
65216: LD_INT 6
65218: PUSH
65219: LD_VAR 0 8
65223: MINUS
65224: PUSH
65225: FOR_TO
65226: IFFALSE 65281
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
65228: LD_ADDR_VAR 0 11
65232: PUSH
65233: LD_VAR 0 11
65237: PPUSH
65238: LD_VAR 0 11
65242: PUSH
65243: LD_INT 1
65245: PLUS
65246: PPUSH
65247: LD_VAR 0 9
65251: PUSH
65252: LD_INT 1
65254: ARRAY
65255: PPUSH
65256: CALL_OW 2
65260: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
65261: LD_ADDR_VAR 0 9
65265: PUSH
65266: LD_VAR 0 9
65270: PPUSH
65271: LD_INT 1
65273: PPUSH
65274: CALL_OW 3
65278: ST_TO_ADDR
// end ;
65279: GO 65225
65281: POP
65282: POP
// end else
65283: GO 65305
// if sort then
65285: LD_VAR 0 9
65289: IFFALSE 65305
// p := sort [ 1 ] ;
65291: LD_ADDR_VAR 0 11
65295: PUSH
65296: LD_VAR 0 9
65300: PUSH
65301: LD_INT 1
65303: ARRAY
65304: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
65305: LD_ADDR_VAR 0 2
65309: PUSH
65310: LD_INT 0
65312: PUSH
65313: LD_INT 0
65315: PUSH
65316: LD_INT 0
65318: PUSH
65319: LD_VAR 0 11
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: ST_TO_ADDR
// exit ;
65330: GO 67551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65332: LD_EXP 88
65336: PUSH
65337: LD_EXP 87
65341: PUSH
65342: LD_VAR 0 1
65346: ARRAY
65347: ARRAY
65348: PUSH
65349: LD_EXP 61
65353: PUSH
65354: LD_VAR 0 1
65358: ARRAY
65359: PPUSH
65360: LD_INT 2
65362: PUSH
65363: LD_INT 30
65365: PUSH
65366: LD_INT 6
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PUSH
65373: LD_INT 30
65375: PUSH
65376: LD_INT 7
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 30
65385: PUSH
65386: LD_INT 8
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: PPUSH
65399: CALL_OW 72
65403: AND
65404: PUSH
65405: LD_EXP 61
65409: PUSH
65410: LD_VAR 0 1
65414: ARRAY
65415: PPUSH
65416: LD_INT 30
65418: PUSH
65419: LD_INT 3
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PPUSH
65426: CALL_OW 72
65430: AND
65431: IFFALSE 66165
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
65433: LD_ADDR_EXP 103
65437: PUSH
65438: LD_EXP 103
65442: PPUSH
65443: LD_VAR 0 1
65447: PPUSH
65448: LD_INT 3
65450: PPUSH
65451: CALL_OW 1
65455: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65456: LD_ADDR_VAR 0 2
65460: PUSH
65461: LD_INT 0
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: LD_INT 0
65469: PUSH
65470: LD_INT 0
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: ST_TO_ADDR
// if not eng then
65479: LD_VAR 0 6
65483: NOT
65484: IFFALSE 65547
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
65486: LD_ADDR_VAR 0 11
65490: PUSH
65491: LD_VAR 0 4
65495: PPUSH
65496: LD_INT 2
65498: PPUSH
65499: CALL 52630 0 2
65503: PUSH
65504: LD_INT 1
65506: ARRAY
65507: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
65508: LD_ADDR_VAR 0 2
65512: PUSH
65513: LD_VAR 0 2
65517: PPUSH
65518: LD_INT 2
65520: PPUSH
65521: LD_VAR 0 11
65525: PPUSH
65526: CALL_OW 1
65530: ST_TO_ADDR
// tmp := tmp diff p ;
65531: LD_ADDR_VAR 0 4
65535: PUSH
65536: LD_VAR 0 4
65540: PUSH
65541: LD_VAR 0 11
65545: DIFF
65546: ST_TO_ADDR
// end ; if tmp and sci < 6 then
65547: LD_VAR 0 4
65551: PUSH
65552: LD_VAR 0 8
65556: PUSH
65557: LD_INT 6
65559: LESS
65560: AND
65561: IFFALSE 65749
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
65563: LD_ADDR_VAR 0 9
65567: PUSH
65568: LD_VAR 0 4
65572: PUSH
65573: LD_VAR 0 8
65577: PUSH
65578: LD_VAR 0 7
65582: UNION
65583: DIFF
65584: PPUSH
65585: LD_INT 4
65587: PPUSH
65588: CALL 52630 0 2
65592: ST_TO_ADDR
// p := [ ] ;
65593: LD_ADDR_VAR 0 11
65597: PUSH
65598: EMPTY
65599: ST_TO_ADDR
// if sort then
65600: LD_VAR 0 9
65604: IFFALSE 65720
// for i = 1 to 6 - sci do
65606: LD_ADDR_VAR 0 3
65610: PUSH
65611: DOUBLE
65612: LD_INT 1
65614: DEC
65615: ST_TO_ADDR
65616: LD_INT 6
65618: PUSH
65619: LD_VAR 0 8
65623: MINUS
65624: PUSH
65625: FOR_TO
65626: IFFALSE 65718
// begin if i = sort then
65628: LD_VAR 0 3
65632: PUSH
65633: LD_VAR 0 9
65637: EQUAL
65638: IFFALSE 65642
// break ;
65640: GO 65718
// if GetClass ( i ) = 4 then
65642: LD_VAR 0 3
65646: PPUSH
65647: CALL_OW 257
65651: PUSH
65652: LD_INT 4
65654: EQUAL
65655: IFFALSE 65659
// continue ;
65657: GO 65625
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65659: LD_ADDR_VAR 0 11
65663: PUSH
65664: LD_VAR 0 11
65668: PPUSH
65669: LD_VAR 0 11
65673: PUSH
65674: LD_INT 1
65676: PLUS
65677: PPUSH
65678: LD_VAR 0 9
65682: PUSH
65683: LD_VAR 0 3
65687: ARRAY
65688: PPUSH
65689: CALL_OW 2
65693: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65694: LD_ADDR_VAR 0 4
65698: PUSH
65699: LD_VAR 0 4
65703: PUSH
65704: LD_VAR 0 9
65708: PUSH
65709: LD_VAR 0 3
65713: ARRAY
65714: DIFF
65715: ST_TO_ADDR
// end ;
65716: GO 65625
65718: POP
65719: POP
// if p then
65720: LD_VAR 0 11
65724: IFFALSE 65749
// result := Replace ( result , 4 , p ) ;
65726: LD_ADDR_VAR 0 2
65730: PUSH
65731: LD_VAR 0 2
65735: PPUSH
65736: LD_INT 4
65738: PPUSH
65739: LD_VAR 0 11
65743: PPUSH
65744: CALL_OW 1
65748: ST_TO_ADDR
// end ; if tmp and mech < 6 then
65749: LD_VAR 0 4
65753: PUSH
65754: LD_VAR 0 7
65758: PUSH
65759: LD_INT 6
65761: LESS
65762: AND
65763: IFFALSE 65951
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65765: LD_ADDR_VAR 0 9
65769: PUSH
65770: LD_VAR 0 4
65774: PUSH
65775: LD_VAR 0 8
65779: PUSH
65780: LD_VAR 0 7
65784: UNION
65785: DIFF
65786: PPUSH
65787: LD_INT 3
65789: PPUSH
65790: CALL 52630 0 2
65794: ST_TO_ADDR
// p := [ ] ;
65795: LD_ADDR_VAR 0 11
65799: PUSH
65800: EMPTY
65801: ST_TO_ADDR
// if sort then
65802: LD_VAR 0 9
65806: IFFALSE 65922
// for i = 1 to 6 - mech do
65808: LD_ADDR_VAR 0 3
65812: PUSH
65813: DOUBLE
65814: LD_INT 1
65816: DEC
65817: ST_TO_ADDR
65818: LD_INT 6
65820: PUSH
65821: LD_VAR 0 7
65825: MINUS
65826: PUSH
65827: FOR_TO
65828: IFFALSE 65920
// begin if i = sort then
65830: LD_VAR 0 3
65834: PUSH
65835: LD_VAR 0 9
65839: EQUAL
65840: IFFALSE 65844
// break ;
65842: GO 65920
// if GetClass ( i ) = 3 then
65844: LD_VAR 0 3
65848: PPUSH
65849: CALL_OW 257
65853: PUSH
65854: LD_INT 3
65856: EQUAL
65857: IFFALSE 65861
// continue ;
65859: GO 65827
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65861: LD_ADDR_VAR 0 11
65865: PUSH
65866: LD_VAR 0 11
65870: PPUSH
65871: LD_VAR 0 11
65875: PUSH
65876: LD_INT 1
65878: PLUS
65879: PPUSH
65880: LD_VAR 0 9
65884: PUSH
65885: LD_VAR 0 3
65889: ARRAY
65890: PPUSH
65891: CALL_OW 2
65895: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65896: LD_ADDR_VAR 0 4
65900: PUSH
65901: LD_VAR 0 4
65905: PUSH
65906: LD_VAR 0 9
65910: PUSH
65911: LD_VAR 0 3
65915: ARRAY
65916: DIFF
65917: ST_TO_ADDR
// end ;
65918: GO 65827
65920: POP
65921: POP
// if p then
65922: LD_VAR 0 11
65926: IFFALSE 65951
// result := Replace ( result , 3 , p ) ;
65928: LD_ADDR_VAR 0 2
65932: PUSH
65933: LD_VAR 0 2
65937: PPUSH
65938: LD_INT 3
65940: PPUSH
65941: LD_VAR 0 11
65945: PPUSH
65946: CALL_OW 1
65950: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
65951: LD_VAR 0 4
65955: PUSH
65956: LD_INT 6
65958: GREATER
65959: PUSH
65960: LD_VAR 0 6
65964: PUSH
65965: LD_INT 6
65967: LESS
65968: AND
65969: IFFALSE 66163
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
65971: LD_ADDR_VAR 0 9
65975: PUSH
65976: LD_VAR 0 4
65980: PUSH
65981: LD_VAR 0 8
65985: PUSH
65986: LD_VAR 0 7
65990: UNION
65991: PUSH
65992: LD_VAR 0 6
65996: UNION
65997: DIFF
65998: PPUSH
65999: LD_INT 2
66001: PPUSH
66002: CALL 52630 0 2
66006: ST_TO_ADDR
// p := [ ] ;
66007: LD_ADDR_VAR 0 11
66011: PUSH
66012: EMPTY
66013: ST_TO_ADDR
// if sort then
66014: LD_VAR 0 9
66018: IFFALSE 66134
// for i = 1 to 6 - eng do
66020: LD_ADDR_VAR 0 3
66024: PUSH
66025: DOUBLE
66026: LD_INT 1
66028: DEC
66029: ST_TO_ADDR
66030: LD_INT 6
66032: PUSH
66033: LD_VAR 0 6
66037: MINUS
66038: PUSH
66039: FOR_TO
66040: IFFALSE 66132
// begin if i = sort then
66042: LD_VAR 0 3
66046: PUSH
66047: LD_VAR 0 9
66051: EQUAL
66052: IFFALSE 66056
// break ;
66054: GO 66132
// if GetClass ( i ) = 2 then
66056: LD_VAR 0 3
66060: PPUSH
66061: CALL_OW 257
66065: PUSH
66066: LD_INT 2
66068: EQUAL
66069: IFFALSE 66073
// continue ;
66071: GO 66039
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66073: LD_ADDR_VAR 0 11
66077: PUSH
66078: LD_VAR 0 11
66082: PPUSH
66083: LD_VAR 0 11
66087: PUSH
66088: LD_INT 1
66090: PLUS
66091: PPUSH
66092: LD_VAR 0 9
66096: PUSH
66097: LD_VAR 0 3
66101: ARRAY
66102: PPUSH
66103: CALL_OW 2
66107: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66108: LD_ADDR_VAR 0 4
66112: PUSH
66113: LD_VAR 0 4
66117: PUSH
66118: LD_VAR 0 9
66122: PUSH
66123: LD_VAR 0 3
66127: ARRAY
66128: DIFF
66129: ST_TO_ADDR
// end ;
66130: GO 66039
66132: POP
66133: POP
// if p then
66134: LD_VAR 0 11
66138: IFFALSE 66163
// result := Replace ( result , 2 , p ) ;
66140: LD_ADDR_VAR 0 2
66144: PUSH
66145: LD_VAR 0 2
66149: PPUSH
66150: LD_INT 2
66152: PPUSH
66153: LD_VAR 0 11
66157: PPUSH
66158: CALL_OW 1
66162: ST_TO_ADDR
// end ; exit ;
66163: GO 67551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
66165: LD_EXP 88
66169: PUSH
66170: LD_EXP 87
66174: PUSH
66175: LD_VAR 0 1
66179: ARRAY
66180: ARRAY
66181: NOT
66182: PUSH
66183: LD_EXP 61
66187: PUSH
66188: LD_VAR 0 1
66192: ARRAY
66193: PPUSH
66194: LD_INT 30
66196: PUSH
66197: LD_INT 3
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PPUSH
66204: CALL_OW 72
66208: AND
66209: PUSH
66210: LD_EXP 66
66214: PUSH
66215: LD_VAR 0 1
66219: ARRAY
66220: AND
66221: IFFALSE 66829
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
66223: LD_ADDR_EXP 103
66227: PUSH
66228: LD_EXP 103
66232: PPUSH
66233: LD_VAR 0 1
66237: PPUSH
66238: LD_INT 5
66240: PPUSH
66241: CALL_OW 1
66245: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66246: LD_ADDR_VAR 0 2
66250: PUSH
66251: LD_INT 0
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: LD_INT 0
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: ST_TO_ADDR
// if sci > 1 then
66269: LD_VAR 0 8
66273: PUSH
66274: LD_INT 1
66276: GREATER
66277: IFFALSE 66305
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
66279: LD_ADDR_VAR 0 4
66283: PUSH
66284: LD_VAR 0 4
66288: PUSH
66289: LD_VAR 0 8
66293: PUSH
66294: LD_VAR 0 8
66298: PUSH
66299: LD_INT 1
66301: ARRAY
66302: DIFF
66303: DIFF
66304: ST_TO_ADDR
// if tmp and not sci then
66305: LD_VAR 0 4
66309: PUSH
66310: LD_VAR 0 8
66314: NOT
66315: AND
66316: IFFALSE 66385
// begin sort := SortBySkill ( tmp , 4 ) ;
66318: LD_ADDR_VAR 0 9
66322: PUSH
66323: LD_VAR 0 4
66327: PPUSH
66328: LD_INT 4
66330: PPUSH
66331: CALL 52630 0 2
66335: ST_TO_ADDR
// if sort then
66336: LD_VAR 0 9
66340: IFFALSE 66356
// p := sort [ 1 ] ;
66342: LD_ADDR_VAR 0 11
66346: PUSH
66347: LD_VAR 0 9
66351: PUSH
66352: LD_INT 1
66354: ARRAY
66355: ST_TO_ADDR
// if p then
66356: LD_VAR 0 11
66360: IFFALSE 66385
// result := Replace ( result , 4 , p ) ;
66362: LD_ADDR_VAR 0 2
66366: PUSH
66367: LD_VAR 0 2
66371: PPUSH
66372: LD_INT 4
66374: PPUSH
66375: LD_VAR 0 11
66379: PPUSH
66380: CALL_OW 1
66384: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66385: LD_ADDR_VAR 0 4
66389: PUSH
66390: LD_VAR 0 4
66394: PUSH
66395: LD_VAR 0 7
66399: DIFF
66400: ST_TO_ADDR
// if tmp and mech < 6 then
66401: LD_VAR 0 4
66405: PUSH
66406: LD_VAR 0 7
66410: PUSH
66411: LD_INT 6
66413: LESS
66414: AND
66415: IFFALSE 66603
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66417: LD_ADDR_VAR 0 9
66421: PUSH
66422: LD_VAR 0 4
66426: PUSH
66427: LD_VAR 0 8
66431: PUSH
66432: LD_VAR 0 7
66436: UNION
66437: DIFF
66438: PPUSH
66439: LD_INT 3
66441: PPUSH
66442: CALL 52630 0 2
66446: ST_TO_ADDR
// p := [ ] ;
66447: LD_ADDR_VAR 0 11
66451: PUSH
66452: EMPTY
66453: ST_TO_ADDR
// if sort then
66454: LD_VAR 0 9
66458: IFFALSE 66574
// for i = 1 to 6 - mech do
66460: LD_ADDR_VAR 0 3
66464: PUSH
66465: DOUBLE
66466: LD_INT 1
66468: DEC
66469: ST_TO_ADDR
66470: LD_INT 6
66472: PUSH
66473: LD_VAR 0 7
66477: MINUS
66478: PUSH
66479: FOR_TO
66480: IFFALSE 66572
// begin if i = sort then
66482: LD_VAR 0 3
66486: PUSH
66487: LD_VAR 0 9
66491: EQUAL
66492: IFFALSE 66496
// break ;
66494: GO 66572
// if GetClass ( i ) = 3 then
66496: LD_VAR 0 3
66500: PPUSH
66501: CALL_OW 257
66505: PUSH
66506: LD_INT 3
66508: EQUAL
66509: IFFALSE 66513
// continue ;
66511: GO 66479
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66513: LD_ADDR_VAR 0 11
66517: PUSH
66518: LD_VAR 0 11
66522: PPUSH
66523: LD_VAR 0 11
66527: PUSH
66528: LD_INT 1
66530: PLUS
66531: PPUSH
66532: LD_VAR 0 9
66536: PUSH
66537: LD_VAR 0 3
66541: ARRAY
66542: PPUSH
66543: CALL_OW 2
66547: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66548: LD_ADDR_VAR 0 4
66552: PUSH
66553: LD_VAR 0 4
66557: PUSH
66558: LD_VAR 0 9
66562: PUSH
66563: LD_VAR 0 3
66567: ARRAY
66568: DIFF
66569: ST_TO_ADDR
// end ;
66570: GO 66479
66572: POP
66573: POP
// if p then
66574: LD_VAR 0 11
66578: IFFALSE 66603
// result := Replace ( result , 3 , p ) ;
66580: LD_ADDR_VAR 0 2
66584: PUSH
66585: LD_VAR 0 2
66589: PPUSH
66590: LD_INT 3
66592: PPUSH
66593: LD_VAR 0 11
66597: PPUSH
66598: CALL_OW 1
66602: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66603: LD_ADDR_VAR 0 4
66607: PUSH
66608: LD_VAR 0 4
66612: PUSH
66613: LD_VAR 0 6
66617: DIFF
66618: ST_TO_ADDR
// if tmp and eng < 6 then
66619: LD_VAR 0 4
66623: PUSH
66624: LD_VAR 0 6
66628: PUSH
66629: LD_INT 6
66631: LESS
66632: AND
66633: IFFALSE 66827
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66635: LD_ADDR_VAR 0 9
66639: PUSH
66640: LD_VAR 0 4
66644: PUSH
66645: LD_VAR 0 8
66649: PUSH
66650: LD_VAR 0 7
66654: UNION
66655: PUSH
66656: LD_VAR 0 6
66660: UNION
66661: DIFF
66662: PPUSH
66663: LD_INT 2
66665: PPUSH
66666: CALL 52630 0 2
66670: ST_TO_ADDR
// p := [ ] ;
66671: LD_ADDR_VAR 0 11
66675: PUSH
66676: EMPTY
66677: ST_TO_ADDR
// if sort then
66678: LD_VAR 0 9
66682: IFFALSE 66798
// for i = 1 to 6 - eng do
66684: LD_ADDR_VAR 0 3
66688: PUSH
66689: DOUBLE
66690: LD_INT 1
66692: DEC
66693: ST_TO_ADDR
66694: LD_INT 6
66696: PUSH
66697: LD_VAR 0 6
66701: MINUS
66702: PUSH
66703: FOR_TO
66704: IFFALSE 66796
// begin if i = sort then
66706: LD_VAR 0 3
66710: PUSH
66711: LD_VAR 0 9
66715: EQUAL
66716: IFFALSE 66720
// break ;
66718: GO 66796
// if GetClass ( i ) = 2 then
66720: LD_VAR 0 3
66724: PPUSH
66725: CALL_OW 257
66729: PUSH
66730: LD_INT 2
66732: EQUAL
66733: IFFALSE 66737
// continue ;
66735: GO 66703
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66737: LD_ADDR_VAR 0 11
66741: PUSH
66742: LD_VAR 0 11
66746: PPUSH
66747: LD_VAR 0 11
66751: PUSH
66752: LD_INT 1
66754: PLUS
66755: PPUSH
66756: LD_VAR 0 9
66760: PUSH
66761: LD_VAR 0 3
66765: ARRAY
66766: PPUSH
66767: CALL_OW 2
66771: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66772: LD_ADDR_VAR 0 4
66776: PUSH
66777: LD_VAR 0 4
66781: PUSH
66782: LD_VAR 0 9
66786: PUSH
66787: LD_VAR 0 3
66791: ARRAY
66792: DIFF
66793: ST_TO_ADDR
// end ;
66794: GO 66703
66796: POP
66797: POP
// if p then
66798: LD_VAR 0 11
66802: IFFALSE 66827
// result := Replace ( result , 2 , p ) ;
66804: LD_ADDR_VAR 0 2
66808: PUSH
66809: LD_VAR 0 2
66813: PPUSH
66814: LD_INT 2
66816: PPUSH
66817: LD_VAR 0 11
66821: PPUSH
66822: CALL_OW 1
66826: ST_TO_ADDR
// end ; exit ;
66827: GO 67551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
66829: LD_EXP 88
66833: PUSH
66834: LD_EXP 87
66838: PUSH
66839: LD_VAR 0 1
66843: ARRAY
66844: ARRAY
66845: NOT
66846: PUSH
66847: LD_EXP 61
66851: PUSH
66852: LD_VAR 0 1
66856: ARRAY
66857: PPUSH
66858: LD_INT 30
66860: PUSH
66861: LD_INT 3
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PPUSH
66868: CALL_OW 72
66872: AND
66873: PUSH
66874: LD_EXP 66
66878: PUSH
66879: LD_VAR 0 1
66883: ARRAY
66884: NOT
66885: AND
66886: IFFALSE 67551
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
66888: LD_ADDR_EXP 103
66892: PUSH
66893: LD_EXP 103
66897: PPUSH
66898: LD_VAR 0 1
66902: PPUSH
66903: LD_INT 6
66905: PPUSH
66906: CALL_OW 1
66910: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66911: LD_ADDR_VAR 0 2
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: LD_INT 0
66924: PUSH
66925: LD_INT 0
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: ST_TO_ADDR
// if sci >= 1 then
66934: LD_VAR 0 8
66938: PUSH
66939: LD_INT 1
66941: GREATEREQUAL
66942: IFFALSE 66964
// tmp := tmp diff sci [ 1 ] ;
66944: LD_ADDR_VAR 0 4
66948: PUSH
66949: LD_VAR 0 4
66953: PUSH
66954: LD_VAR 0 8
66958: PUSH
66959: LD_INT 1
66961: ARRAY
66962: DIFF
66963: ST_TO_ADDR
// if tmp and not sci then
66964: LD_VAR 0 4
66968: PUSH
66969: LD_VAR 0 8
66973: NOT
66974: AND
66975: IFFALSE 67044
// begin sort := SortBySkill ( tmp , 4 ) ;
66977: LD_ADDR_VAR 0 9
66981: PUSH
66982: LD_VAR 0 4
66986: PPUSH
66987: LD_INT 4
66989: PPUSH
66990: CALL 52630 0 2
66994: ST_TO_ADDR
// if sort then
66995: LD_VAR 0 9
66999: IFFALSE 67015
// p := sort [ 1 ] ;
67001: LD_ADDR_VAR 0 11
67005: PUSH
67006: LD_VAR 0 9
67010: PUSH
67011: LD_INT 1
67013: ARRAY
67014: ST_TO_ADDR
// if p then
67015: LD_VAR 0 11
67019: IFFALSE 67044
// result := Replace ( result , 4 , p ) ;
67021: LD_ADDR_VAR 0 2
67025: PUSH
67026: LD_VAR 0 2
67030: PPUSH
67031: LD_INT 4
67033: PPUSH
67034: LD_VAR 0 11
67038: PPUSH
67039: CALL_OW 1
67043: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67044: LD_ADDR_VAR 0 4
67048: PUSH
67049: LD_VAR 0 4
67053: PUSH
67054: LD_VAR 0 7
67058: DIFF
67059: ST_TO_ADDR
// if tmp and mech < 6 then
67060: LD_VAR 0 4
67064: PUSH
67065: LD_VAR 0 7
67069: PUSH
67070: LD_INT 6
67072: LESS
67073: AND
67074: IFFALSE 67256
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67076: LD_ADDR_VAR 0 9
67080: PUSH
67081: LD_VAR 0 4
67085: PUSH
67086: LD_VAR 0 7
67090: DIFF
67091: PPUSH
67092: LD_INT 3
67094: PPUSH
67095: CALL 52630 0 2
67099: ST_TO_ADDR
// p := [ ] ;
67100: LD_ADDR_VAR 0 11
67104: PUSH
67105: EMPTY
67106: ST_TO_ADDR
// if sort then
67107: LD_VAR 0 9
67111: IFFALSE 67227
// for i = 1 to 6 - mech do
67113: LD_ADDR_VAR 0 3
67117: PUSH
67118: DOUBLE
67119: LD_INT 1
67121: DEC
67122: ST_TO_ADDR
67123: LD_INT 6
67125: PUSH
67126: LD_VAR 0 7
67130: MINUS
67131: PUSH
67132: FOR_TO
67133: IFFALSE 67225
// begin if i = sort then
67135: LD_VAR 0 3
67139: PUSH
67140: LD_VAR 0 9
67144: EQUAL
67145: IFFALSE 67149
// break ;
67147: GO 67225
// if GetClass ( i ) = 3 then
67149: LD_VAR 0 3
67153: PPUSH
67154: CALL_OW 257
67158: PUSH
67159: LD_INT 3
67161: EQUAL
67162: IFFALSE 67166
// continue ;
67164: GO 67132
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67166: LD_ADDR_VAR 0 11
67170: PUSH
67171: LD_VAR 0 11
67175: PPUSH
67176: LD_VAR 0 11
67180: PUSH
67181: LD_INT 1
67183: PLUS
67184: PPUSH
67185: LD_VAR 0 9
67189: PUSH
67190: LD_VAR 0 3
67194: ARRAY
67195: PPUSH
67196: CALL_OW 2
67200: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67201: LD_ADDR_VAR 0 4
67205: PUSH
67206: LD_VAR 0 4
67210: PUSH
67211: LD_VAR 0 9
67215: PUSH
67216: LD_VAR 0 3
67220: ARRAY
67221: DIFF
67222: ST_TO_ADDR
// end ;
67223: GO 67132
67225: POP
67226: POP
// if p then
67227: LD_VAR 0 11
67231: IFFALSE 67256
// result := Replace ( result , 3 , p ) ;
67233: LD_ADDR_VAR 0 2
67237: PUSH
67238: LD_VAR 0 2
67242: PPUSH
67243: LD_INT 3
67245: PPUSH
67246: LD_VAR 0 11
67250: PPUSH
67251: CALL_OW 1
67255: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67256: LD_ADDR_VAR 0 4
67260: PUSH
67261: LD_VAR 0 4
67265: PUSH
67266: LD_VAR 0 6
67270: DIFF
67271: ST_TO_ADDR
// if tmp and eng < 4 then
67272: LD_VAR 0 4
67276: PUSH
67277: LD_VAR 0 6
67281: PUSH
67282: LD_INT 4
67284: LESS
67285: AND
67286: IFFALSE 67476
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
67288: LD_ADDR_VAR 0 9
67292: PUSH
67293: LD_VAR 0 4
67297: PUSH
67298: LD_VAR 0 7
67302: PUSH
67303: LD_VAR 0 6
67307: UNION
67308: DIFF
67309: PPUSH
67310: LD_INT 2
67312: PPUSH
67313: CALL 52630 0 2
67317: ST_TO_ADDR
// p := [ ] ;
67318: LD_ADDR_VAR 0 11
67322: PUSH
67323: EMPTY
67324: ST_TO_ADDR
// if sort then
67325: LD_VAR 0 9
67329: IFFALSE 67445
// for i = 1 to 4 - eng do
67331: LD_ADDR_VAR 0 3
67335: PUSH
67336: DOUBLE
67337: LD_INT 1
67339: DEC
67340: ST_TO_ADDR
67341: LD_INT 4
67343: PUSH
67344: LD_VAR 0 6
67348: MINUS
67349: PUSH
67350: FOR_TO
67351: IFFALSE 67443
// begin if i = sort then
67353: LD_VAR 0 3
67357: PUSH
67358: LD_VAR 0 9
67362: EQUAL
67363: IFFALSE 67367
// break ;
67365: GO 67443
// if GetClass ( i ) = 2 then
67367: LD_VAR 0 3
67371: PPUSH
67372: CALL_OW 257
67376: PUSH
67377: LD_INT 2
67379: EQUAL
67380: IFFALSE 67384
// continue ;
67382: GO 67350
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67384: LD_ADDR_VAR 0 11
67388: PUSH
67389: LD_VAR 0 11
67393: PPUSH
67394: LD_VAR 0 11
67398: PUSH
67399: LD_INT 1
67401: PLUS
67402: PPUSH
67403: LD_VAR 0 9
67407: PUSH
67408: LD_VAR 0 3
67412: ARRAY
67413: PPUSH
67414: CALL_OW 2
67418: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67419: LD_ADDR_VAR 0 4
67423: PUSH
67424: LD_VAR 0 4
67428: PUSH
67429: LD_VAR 0 9
67433: PUSH
67434: LD_VAR 0 3
67438: ARRAY
67439: DIFF
67440: ST_TO_ADDR
// end ;
67441: GO 67350
67443: POP
67444: POP
// if p then
67445: LD_VAR 0 11
67449: IFFALSE 67474
// result := Replace ( result , 2 , p ) ;
67451: LD_ADDR_VAR 0 2
67455: PUSH
67456: LD_VAR 0 2
67460: PPUSH
67461: LD_INT 2
67463: PPUSH
67464: LD_VAR 0 11
67468: PPUSH
67469: CALL_OW 1
67473: ST_TO_ADDR
// end else
67474: GO 67520
// for i = eng downto 5 do
67476: LD_ADDR_VAR 0 3
67480: PUSH
67481: DOUBLE
67482: LD_VAR 0 6
67486: INC
67487: ST_TO_ADDR
67488: LD_INT 5
67490: PUSH
67491: FOR_DOWNTO
67492: IFFALSE 67518
// tmp := tmp union eng [ i ] ;
67494: LD_ADDR_VAR 0 4
67498: PUSH
67499: LD_VAR 0 4
67503: PUSH
67504: LD_VAR 0 6
67508: PUSH
67509: LD_VAR 0 3
67513: ARRAY
67514: UNION
67515: ST_TO_ADDR
67516: GO 67491
67518: POP
67519: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
67520: LD_ADDR_VAR 0 2
67524: PUSH
67525: LD_VAR 0 2
67529: PPUSH
67530: LD_INT 1
67532: PPUSH
67533: LD_VAR 0 4
67537: PUSH
67538: LD_VAR 0 5
67542: DIFF
67543: PPUSH
67544: CALL_OW 1
67548: ST_TO_ADDR
// exit ;
67549: GO 67551
// end ; end ;
67551: LD_VAR 0 2
67555: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
67556: LD_INT 0
67558: PPUSH
67559: PPUSH
67560: PPUSH
// if not mc_bases then
67561: LD_EXP 61
67565: NOT
67566: IFFALSE 67570
// exit ;
67568: GO 67712
// for i = 1 to mc_bases do
67570: LD_ADDR_VAR 0 2
67574: PUSH
67575: DOUBLE
67576: LD_INT 1
67578: DEC
67579: ST_TO_ADDR
67580: LD_EXP 61
67584: PUSH
67585: FOR_TO
67586: IFFALSE 67703
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67588: LD_ADDR_VAR 0 3
67592: PUSH
67593: LD_EXP 61
67597: PUSH
67598: LD_VAR 0 2
67602: ARRAY
67603: PPUSH
67604: LD_INT 21
67606: PUSH
67607: LD_INT 3
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 3
67616: PUSH
67617: LD_INT 2
67619: PUSH
67620: LD_INT 30
67622: PUSH
67623: LD_INT 29
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 30
67632: PUSH
67633: LD_INT 30
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: LIST
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 3
67651: PUSH
67652: LD_INT 24
67654: PUSH
67655: LD_INT 1000
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: LIST
67670: PPUSH
67671: CALL_OW 72
67675: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
67676: LD_ADDR_EXP 62
67680: PUSH
67681: LD_EXP 62
67685: PPUSH
67686: LD_VAR 0 2
67690: PPUSH
67691: LD_VAR 0 3
67695: PPUSH
67696: CALL_OW 1
67700: ST_TO_ADDR
// end ;
67701: GO 67585
67703: POP
67704: POP
// RaiseSailEvent ( 101 ) ;
67705: LD_INT 101
67707: PPUSH
67708: CALL_OW 427
// end ;
67712: LD_VAR 0 1
67716: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
67717: LD_INT 0
67719: PPUSH
67720: PPUSH
67721: PPUSH
67722: PPUSH
67723: PPUSH
67724: PPUSH
67725: PPUSH
// if not mc_bases then
67726: LD_EXP 61
67730: NOT
67731: IFFALSE 67735
// exit ;
67733: GO 68297
// for i = 1 to mc_bases do
67735: LD_ADDR_VAR 0 2
67739: PUSH
67740: DOUBLE
67741: LD_INT 1
67743: DEC
67744: ST_TO_ADDR
67745: LD_EXP 61
67749: PUSH
67750: FOR_TO
67751: IFFALSE 68288
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
67753: LD_ADDR_VAR 0 5
67757: PUSH
67758: LD_EXP 61
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: PUSH
67769: LD_EXP 90
67773: PUSH
67774: LD_VAR 0 2
67778: ARRAY
67779: UNION
67780: PPUSH
67781: LD_INT 21
67783: PUSH
67784: LD_INT 1
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 1
67793: PUSH
67794: LD_INT 3
67796: PUSH
67797: LD_INT 54
67799: PUSH
67800: EMPTY
67801: LIST
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 3
67809: PUSH
67810: LD_INT 24
67812: PUSH
67813: LD_INT 1000
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: LIST
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PPUSH
67833: CALL_OW 72
67837: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
67838: LD_ADDR_VAR 0 6
67842: PUSH
67843: LD_EXP 61
67847: PUSH
67848: LD_VAR 0 2
67852: ARRAY
67853: PPUSH
67854: LD_INT 21
67856: PUSH
67857: LD_INT 1
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 1
67866: PUSH
67867: LD_INT 3
67869: PUSH
67870: LD_INT 54
67872: PUSH
67873: EMPTY
67874: LIST
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 3
67882: PUSH
67883: LD_INT 24
67885: PUSH
67886: LD_INT 250
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: LIST
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PPUSH
67906: CALL_OW 72
67910: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
67911: LD_ADDR_VAR 0 7
67915: PUSH
67916: LD_VAR 0 5
67920: PUSH
67921: LD_VAR 0 6
67925: DIFF
67926: ST_TO_ADDR
// if not need_heal_1 then
67927: LD_VAR 0 6
67931: NOT
67932: IFFALSE 67965
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
67934: LD_ADDR_EXP 64
67938: PUSH
67939: LD_EXP 64
67943: PPUSH
67944: LD_VAR 0 2
67948: PUSH
67949: LD_INT 1
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PPUSH
67956: EMPTY
67957: PPUSH
67958: CALL 21397 0 3
67962: ST_TO_ADDR
67963: GO 68035
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
67965: LD_ADDR_EXP 64
67969: PUSH
67970: LD_EXP 64
67974: PPUSH
67975: LD_VAR 0 2
67979: PUSH
67980: LD_INT 1
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PPUSH
67987: LD_EXP 64
67991: PUSH
67992: LD_VAR 0 2
67996: ARRAY
67997: PUSH
67998: LD_INT 1
68000: ARRAY
68001: PPUSH
68002: LD_INT 3
68004: PUSH
68005: LD_INT 24
68007: PUSH
68008: LD_INT 1000
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PPUSH
68019: CALL_OW 72
68023: PUSH
68024: LD_VAR 0 6
68028: UNION
68029: PPUSH
68030: CALL 21397 0 3
68034: ST_TO_ADDR
// if not need_heal_2 then
68035: LD_VAR 0 7
68039: NOT
68040: IFFALSE 68073
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68042: LD_ADDR_EXP 64
68046: PUSH
68047: LD_EXP 64
68051: PPUSH
68052: LD_VAR 0 2
68056: PUSH
68057: LD_INT 2
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PPUSH
68064: EMPTY
68065: PPUSH
68066: CALL 21397 0 3
68070: ST_TO_ADDR
68071: GO 68105
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68073: LD_ADDR_EXP 64
68077: PUSH
68078: LD_EXP 64
68082: PPUSH
68083: LD_VAR 0 2
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PPUSH
68095: LD_VAR 0 7
68099: PPUSH
68100: CALL 21397 0 3
68104: ST_TO_ADDR
// if need_heal_2 then
68105: LD_VAR 0 7
68109: IFFALSE 68270
// for j in need_heal_2 do
68111: LD_ADDR_VAR 0 3
68115: PUSH
68116: LD_VAR 0 7
68120: PUSH
68121: FOR_IN
68122: IFFALSE 68268
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68124: LD_ADDR_VAR 0 5
68128: PUSH
68129: LD_EXP 61
68133: PUSH
68134: LD_VAR 0 2
68138: ARRAY
68139: PPUSH
68140: LD_INT 2
68142: PUSH
68143: LD_INT 30
68145: PUSH
68146: LD_INT 6
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 30
68155: PUSH
68156: LD_INT 7
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 30
68165: PUSH
68166: LD_INT 8
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 30
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 30
68185: PUSH
68186: LD_INT 1
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: PPUSH
68201: CALL_OW 72
68205: ST_TO_ADDR
// if tmp then
68206: LD_VAR 0 5
68210: IFFALSE 68266
// begin k := NearestUnitToUnit ( tmp , j ) ;
68212: LD_ADDR_VAR 0 4
68216: PUSH
68217: LD_VAR 0 5
68221: PPUSH
68222: LD_VAR 0 3
68226: PPUSH
68227: CALL_OW 74
68231: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
68232: LD_VAR 0 3
68236: PPUSH
68237: LD_VAR 0 4
68241: PPUSH
68242: CALL_OW 296
68246: PUSH
68247: LD_INT 5
68249: GREATER
68250: IFFALSE 68266
// ComMoveToNearbyEntrance ( j , k ) ;
68252: LD_VAR 0 3
68256: PPUSH
68257: LD_VAR 0 4
68261: PPUSH
68262: CALL 55003 0 2
// end ; end ;
68266: GO 68121
68268: POP
68269: POP
// if not need_heal_1 and not need_heal_2 then
68270: LD_VAR 0 6
68274: NOT
68275: PUSH
68276: LD_VAR 0 7
68280: NOT
68281: AND
68282: IFFALSE 68286
// continue ;
68284: GO 67750
// end ;
68286: GO 67750
68288: POP
68289: POP
// RaiseSailEvent ( 102 ) ;
68290: LD_INT 102
68292: PPUSH
68293: CALL_OW 427
// end ;
68297: LD_VAR 0 1
68301: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
68302: LD_INT 0
68304: PPUSH
68305: PPUSH
68306: PPUSH
68307: PPUSH
68308: PPUSH
68309: PPUSH
68310: PPUSH
68311: PPUSH
// if not mc_bases then
68312: LD_EXP 61
68316: NOT
68317: IFFALSE 68321
// exit ;
68319: GO 69232
// for i = 1 to mc_bases do
68321: LD_ADDR_VAR 0 2
68325: PUSH
68326: DOUBLE
68327: LD_INT 1
68329: DEC
68330: ST_TO_ADDR
68331: LD_EXP 61
68335: PUSH
68336: FOR_TO
68337: IFFALSE 69230
// begin if not mc_building_need_repair [ i ] then
68339: LD_EXP 62
68343: PUSH
68344: LD_VAR 0 2
68348: ARRAY
68349: NOT
68350: IFFALSE 68535
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
68352: LD_ADDR_VAR 0 6
68356: PUSH
68357: LD_EXP 80
68361: PUSH
68362: LD_VAR 0 2
68366: ARRAY
68367: PPUSH
68368: LD_INT 3
68370: PUSH
68371: LD_INT 24
68373: PUSH
68374: LD_INT 1000
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 2
68387: PUSH
68388: LD_INT 34
68390: PUSH
68391: LD_INT 13
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 34
68400: PUSH
68401: LD_INT 52
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 34
68410: PUSH
68411: LD_INT 88
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PPUSH
68428: CALL_OW 72
68432: ST_TO_ADDR
// if cranes then
68433: LD_VAR 0 6
68437: IFFALSE 68499
// for j in cranes do
68439: LD_ADDR_VAR 0 3
68443: PUSH
68444: LD_VAR 0 6
68448: PUSH
68449: FOR_IN
68450: IFFALSE 68497
// if not IsInArea ( j , mc_parking [ i ] ) then
68452: LD_VAR 0 3
68456: PPUSH
68457: LD_EXP 85
68461: PUSH
68462: LD_VAR 0 2
68466: ARRAY
68467: PPUSH
68468: CALL_OW 308
68472: NOT
68473: IFFALSE 68495
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68475: LD_VAR 0 3
68479: PPUSH
68480: LD_EXP 85
68484: PUSH
68485: LD_VAR 0 2
68489: ARRAY
68490: PPUSH
68491: CALL_OW 113
68495: GO 68449
68497: POP
68498: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
68499: LD_ADDR_EXP 63
68503: PUSH
68504: LD_EXP 63
68508: PPUSH
68509: LD_VAR 0 2
68513: PPUSH
68514: EMPTY
68515: PPUSH
68516: CALL_OW 1
68520: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
68521: LD_VAR 0 2
68525: PPUSH
68526: LD_INT 101
68528: PPUSH
68529: CALL 63375 0 2
// continue ;
68533: GO 68336
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
68535: LD_ADDR_EXP 67
68539: PUSH
68540: LD_EXP 67
68544: PPUSH
68545: LD_VAR 0 2
68549: PPUSH
68550: EMPTY
68551: PPUSH
68552: CALL_OW 1
68556: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68557: LD_VAR 0 2
68561: PPUSH
68562: LD_INT 103
68564: PPUSH
68565: CALL 63375 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
68569: LD_ADDR_VAR 0 5
68573: PUSH
68574: LD_EXP 61
68578: PUSH
68579: LD_VAR 0 2
68583: ARRAY
68584: PUSH
68585: LD_EXP 90
68589: PUSH
68590: LD_VAR 0 2
68594: ARRAY
68595: UNION
68596: PPUSH
68597: LD_INT 2
68599: PUSH
68600: LD_INT 25
68602: PUSH
68603: LD_INT 2
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 25
68612: PUSH
68613: LD_INT 16
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: LIST
68624: PUSH
68625: EMPTY
68626: LIST
68627: PPUSH
68628: CALL_OW 72
68632: ST_TO_ADDR
// if mc_need_heal [ i ] then
68633: LD_EXP 64
68637: PUSH
68638: LD_VAR 0 2
68642: ARRAY
68643: IFFALSE 68687
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
68645: LD_ADDR_VAR 0 5
68649: PUSH
68650: LD_VAR 0 5
68654: PUSH
68655: LD_EXP 64
68659: PUSH
68660: LD_VAR 0 2
68664: ARRAY
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PUSH
68670: LD_EXP 64
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_INT 2
68683: ARRAY
68684: UNION
68685: DIFF
68686: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
68687: LD_ADDR_VAR 0 6
68691: PUSH
68692: LD_EXP 80
68696: PUSH
68697: LD_VAR 0 2
68701: ARRAY
68702: PPUSH
68703: LD_INT 2
68705: PUSH
68706: LD_INT 34
68708: PUSH
68709: LD_INT 13
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 34
68718: PUSH
68719: LD_INT 52
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 34
68728: PUSH
68729: LD_INT 88
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: PPUSH
68742: CALL_OW 72
68746: ST_TO_ADDR
// if cranes then
68747: LD_VAR 0 6
68751: IFFALSE 68919
// begin for j in cranes do
68753: LD_ADDR_VAR 0 3
68757: PUSH
68758: LD_VAR 0 6
68762: PUSH
68763: FOR_IN
68764: IFFALSE 68917
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
68766: LD_VAR 0 3
68770: PPUSH
68771: CALL_OW 256
68775: PUSH
68776: LD_INT 1000
68778: EQUAL
68779: PUSH
68780: LD_VAR 0 3
68784: PPUSH
68785: CALL_OW 314
68789: NOT
68790: AND
68791: IFFALSE 68857
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
68793: LD_ADDR_VAR 0 8
68797: PUSH
68798: LD_EXP 62
68802: PUSH
68803: LD_VAR 0 2
68807: ARRAY
68808: PPUSH
68809: LD_VAR 0 3
68813: PPUSH
68814: CALL_OW 74
68818: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
68819: LD_VAR 0 8
68823: PPUSH
68824: LD_INT 16
68826: PPUSH
68827: CALL 24362 0 2
68831: PUSH
68832: LD_INT 4
68834: ARRAY
68835: PUSH
68836: LD_INT 10
68838: LESS
68839: IFFALSE 68855
// ComRepairBuilding ( j , to_repair ) ;
68841: LD_VAR 0 3
68845: PPUSH
68846: LD_VAR 0 8
68850: PPUSH
68851: CALL_OW 130
// end else
68855: GO 68915
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
68857: LD_VAR 0 3
68861: PPUSH
68862: CALL_OW 256
68866: PUSH
68867: LD_INT 500
68869: LESS
68870: PUSH
68871: LD_VAR 0 3
68875: PPUSH
68876: LD_EXP 85
68880: PUSH
68881: LD_VAR 0 2
68885: ARRAY
68886: PPUSH
68887: CALL_OW 308
68891: NOT
68892: AND
68893: IFFALSE 68915
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68895: LD_VAR 0 3
68899: PPUSH
68900: LD_EXP 85
68904: PUSH
68905: LD_VAR 0 2
68909: ARRAY
68910: PPUSH
68911: CALL_OW 113
// end ;
68915: GO 68763
68917: POP
68918: POP
// end ; if tmp > 3 then
68919: LD_VAR 0 5
68923: PUSH
68924: LD_INT 3
68926: GREATER
68927: IFFALSE 68947
// tmp := ShrinkArray ( tmp , 4 ) ;
68929: LD_ADDR_VAR 0 5
68933: PUSH
68934: LD_VAR 0 5
68938: PPUSH
68939: LD_INT 4
68941: PPUSH
68942: CALL 54441 0 2
68946: ST_TO_ADDR
// if not tmp then
68947: LD_VAR 0 5
68951: NOT
68952: IFFALSE 68956
// continue ;
68954: GO 68336
// for j in tmp do
68956: LD_ADDR_VAR 0 3
68960: PUSH
68961: LD_VAR 0 5
68965: PUSH
68966: FOR_IN
68967: IFFALSE 69226
// begin if IsInUnit ( j ) then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 310
68978: IFFALSE 68989
// ComExitBuilding ( j ) ;
68980: LD_VAR 0 3
68984: PPUSH
68985: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
68989: LD_VAR 0 3
68993: PUSH
68994: LD_EXP 63
68998: PUSH
68999: LD_VAR 0 2
69003: ARRAY
69004: IN
69005: NOT
69006: IFFALSE 69064
// begin SetTag ( j , 101 ) ;
69008: LD_VAR 0 3
69012: PPUSH
69013: LD_INT 101
69015: PPUSH
69016: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69020: LD_ADDR_EXP 63
69024: PUSH
69025: LD_EXP 63
69029: PPUSH
69030: LD_VAR 0 2
69034: PUSH
69035: LD_EXP 63
69039: PUSH
69040: LD_VAR 0 2
69044: ARRAY
69045: PUSH
69046: LD_INT 1
69048: PLUS
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PPUSH
69054: LD_VAR 0 3
69058: PPUSH
69059: CALL 21397 0 3
69063: ST_TO_ADDR
// end ; wait ( 1 ) ;
69064: LD_INT 1
69066: PPUSH
69067: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69071: LD_ADDR_VAR 0 7
69075: PUSH
69076: LD_EXP 62
69080: PUSH
69081: LD_VAR 0 2
69085: ARRAY
69086: ST_TO_ADDR
// if mc_scan [ i ] then
69087: LD_EXP 84
69091: PUSH
69092: LD_VAR 0 2
69096: ARRAY
69097: IFFALSE 69159
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69099: LD_ADDR_VAR 0 7
69103: PUSH
69104: LD_EXP 62
69108: PUSH
69109: LD_VAR 0 2
69113: ARRAY
69114: PPUSH
69115: LD_INT 3
69117: PUSH
69118: LD_INT 30
69120: PUSH
69121: LD_INT 32
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 30
69130: PUSH
69131: LD_INT 33
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 30
69140: PUSH
69141: LD_INT 31
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: PPUSH
69154: CALL_OW 72
69158: ST_TO_ADDR
// if not to_repair_tmp then
69159: LD_VAR 0 7
69163: NOT
69164: IFFALSE 69168
// continue ;
69166: GO 68966
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
69168: LD_ADDR_VAR 0 8
69172: PUSH
69173: LD_VAR 0 7
69177: PPUSH
69178: LD_VAR 0 3
69182: PPUSH
69183: CALL_OW 74
69187: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
69188: LD_VAR 0 8
69192: PPUSH
69193: LD_INT 16
69195: PPUSH
69196: CALL 24362 0 2
69200: PUSH
69201: LD_INT 4
69203: ARRAY
69204: PUSH
69205: LD_INT 14
69207: LESS
69208: IFFALSE 69224
// ComRepairBuilding ( j , to_repair ) ;
69210: LD_VAR 0 3
69214: PPUSH
69215: LD_VAR 0 8
69219: PPUSH
69220: CALL_OW 130
// end ;
69224: GO 68966
69226: POP
69227: POP
// end ;
69228: GO 68336
69230: POP
69231: POP
// end ;
69232: LD_VAR 0 1
69236: RET
// export function MC_Heal ; var i , j , tmp ; begin
69237: LD_INT 0
69239: PPUSH
69240: PPUSH
69241: PPUSH
69242: PPUSH
// if not mc_bases then
69243: LD_EXP 61
69247: NOT
69248: IFFALSE 69252
// exit ;
69250: GO 69654
// for i = 1 to mc_bases do
69252: LD_ADDR_VAR 0 2
69256: PUSH
69257: DOUBLE
69258: LD_INT 1
69260: DEC
69261: ST_TO_ADDR
69262: LD_EXP 61
69266: PUSH
69267: FOR_TO
69268: IFFALSE 69652
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
69270: LD_EXP 64
69274: PUSH
69275: LD_VAR 0 2
69279: ARRAY
69280: PUSH
69281: LD_INT 1
69283: ARRAY
69284: NOT
69285: PUSH
69286: LD_EXP 64
69290: PUSH
69291: LD_VAR 0 2
69295: ARRAY
69296: PUSH
69297: LD_INT 2
69299: ARRAY
69300: NOT
69301: AND
69302: IFFALSE 69340
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
69304: LD_ADDR_EXP 65
69308: PUSH
69309: LD_EXP 65
69313: PPUSH
69314: LD_VAR 0 2
69318: PPUSH
69319: EMPTY
69320: PPUSH
69321: CALL_OW 1
69325: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
69326: LD_VAR 0 2
69330: PPUSH
69331: LD_INT 102
69333: PPUSH
69334: CALL 63375 0 2
// continue ;
69338: GO 69267
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69340: LD_ADDR_VAR 0 4
69344: PUSH
69345: LD_EXP 61
69349: PUSH
69350: LD_VAR 0 2
69354: ARRAY
69355: PPUSH
69356: LD_INT 25
69358: PUSH
69359: LD_INT 4
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PPUSH
69366: CALL_OW 72
69370: ST_TO_ADDR
// if not tmp then
69371: LD_VAR 0 4
69375: NOT
69376: IFFALSE 69380
// continue ;
69378: GO 69267
// if mc_taming [ i ] then
69380: LD_EXP 92
69384: PUSH
69385: LD_VAR 0 2
69389: ARRAY
69390: IFFALSE 69414
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69392: LD_ADDR_EXP 92
69396: PUSH
69397: LD_EXP 92
69401: PPUSH
69402: LD_VAR 0 2
69406: PPUSH
69407: EMPTY
69408: PPUSH
69409: CALL_OW 1
69413: ST_TO_ADDR
// for j in tmp do
69414: LD_ADDR_VAR 0 3
69418: PUSH
69419: LD_VAR 0 4
69423: PUSH
69424: FOR_IN
69425: IFFALSE 69648
// begin if IsInUnit ( j ) then
69427: LD_VAR 0 3
69431: PPUSH
69432: CALL_OW 310
69436: IFFALSE 69447
// ComExitBuilding ( j ) ;
69438: LD_VAR 0 3
69442: PPUSH
69443: CALL_OW 122
// if not j in mc_healers [ i ] then
69447: LD_VAR 0 3
69451: PUSH
69452: LD_EXP 65
69456: PUSH
69457: LD_VAR 0 2
69461: ARRAY
69462: IN
69463: NOT
69464: IFFALSE 69510
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
69466: LD_ADDR_EXP 65
69470: PUSH
69471: LD_EXP 65
69475: PPUSH
69476: LD_VAR 0 2
69480: PUSH
69481: LD_EXP 65
69485: PUSH
69486: LD_VAR 0 2
69490: ARRAY
69491: PUSH
69492: LD_INT 1
69494: PLUS
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PPUSH
69500: LD_VAR 0 3
69504: PPUSH
69505: CALL 21397 0 3
69509: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
69510: LD_VAR 0 3
69514: PPUSH
69515: CALL_OW 110
69519: PUSH
69520: LD_INT 102
69522: NONEQUAL
69523: IFFALSE 69537
// SetTag ( j , 102 ) ;
69525: LD_VAR 0 3
69529: PPUSH
69530: LD_INT 102
69532: PPUSH
69533: CALL_OW 109
// Wait ( 3 ) ;
69537: LD_INT 3
69539: PPUSH
69540: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
69544: LD_EXP 64
69548: PUSH
69549: LD_VAR 0 2
69553: ARRAY
69554: PUSH
69555: LD_INT 1
69557: ARRAY
69558: IFFALSE 69590
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
69560: LD_VAR 0 3
69564: PPUSH
69565: LD_EXP 64
69569: PUSH
69570: LD_VAR 0 2
69574: ARRAY
69575: PUSH
69576: LD_INT 1
69578: ARRAY
69579: PUSH
69580: LD_INT 1
69582: ARRAY
69583: PPUSH
69584: CALL_OW 128
69588: GO 69646
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
69590: LD_VAR 0 3
69594: PPUSH
69595: CALL_OW 314
69599: NOT
69600: PUSH
69601: LD_EXP 64
69605: PUSH
69606: LD_VAR 0 2
69610: ARRAY
69611: PUSH
69612: LD_INT 2
69614: ARRAY
69615: AND
69616: IFFALSE 69646
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
69618: LD_VAR 0 3
69622: PPUSH
69623: LD_EXP 64
69627: PUSH
69628: LD_VAR 0 2
69632: ARRAY
69633: PUSH
69634: LD_INT 2
69636: ARRAY
69637: PUSH
69638: LD_INT 1
69640: ARRAY
69641: PPUSH
69642: CALL_OW 128
// end ;
69646: GO 69424
69648: POP
69649: POP
// end ;
69650: GO 69267
69652: POP
69653: POP
// end ;
69654: LD_VAR 0 1
69658: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
69659: LD_INT 0
69661: PPUSH
69662: PPUSH
69663: PPUSH
69664: PPUSH
69665: PPUSH
69666: PPUSH
// if not mc_bases then
69667: LD_EXP 61
69671: NOT
69672: IFFALSE 69676
// exit ;
69674: GO 70839
// for i = 1 to mc_bases do
69676: LD_ADDR_VAR 0 2
69680: PUSH
69681: DOUBLE
69682: LD_INT 1
69684: DEC
69685: ST_TO_ADDR
69686: LD_EXP 61
69690: PUSH
69691: FOR_TO
69692: IFFALSE 70837
// begin if mc_scan [ i ] then
69694: LD_EXP 84
69698: PUSH
69699: LD_VAR 0 2
69703: ARRAY
69704: IFFALSE 69708
// continue ;
69706: GO 69691
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
69708: LD_EXP 66
69712: PUSH
69713: LD_VAR 0 2
69717: ARRAY
69718: NOT
69719: PUSH
69720: LD_EXP 68
69724: PUSH
69725: LD_VAR 0 2
69729: ARRAY
69730: NOT
69731: AND
69732: PUSH
69733: LD_EXP 67
69737: PUSH
69738: LD_VAR 0 2
69742: ARRAY
69743: AND
69744: IFFALSE 69782
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
69746: LD_ADDR_EXP 67
69750: PUSH
69751: LD_EXP 67
69755: PPUSH
69756: LD_VAR 0 2
69760: PPUSH
69761: EMPTY
69762: PPUSH
69763: CALL_OW 1
69767: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69768: LD_VAR 0 2
69772: PPUSH
69773: LD_INT 103
69775: PPUSH
69776: CALL 63375 0 2
// continue ;
69780: GO 69691
// end ; if mc_construct_list [ i ] then
69782: LD_EXP 68
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: IFFALSE 70012
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69794: LD_ADDR_VAR 0 5
69798: PUSH
69799: LD_EXP 61
69803: PUSH
69804: LD_VAR 0 2
69808: ARRAY
69809: PPUSH
69810: LD_INT 25
69812: PUSH
69813: LD_INT 2
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PPUSH
69820: CALL_OW 72
69824: PUSH
69825: LD_EXP 63
69829: PUSH
69830: LD_VAR 0 2
69834: ARRAY
69835: DIFF
69836: ST_TO_ADDR
// if not tmp then
69837: LD_VAR 0 5
69841: NOT
69842: IFFALSE 69846
// continue ;
69844: GO 69691
// for j in tmp do
69846: LD_ADDR_VAR 0 3
69850: PUSH
69851: LD_VAR 0 5
69855: PUSH
69856: FOR_IN
69857: IFFALSE 70008
// begin if not mc_builders [ i ] then
69859: LD_EXP 67
69863: PUSH
69864: LD_VAR 0 2
69868: ARRAY
69869: NOT
69870: IFFALSE 69928
// begin SetTag ( j , 103 ) ;
69872: LD_VAR 0 3
69876: PPUSH
69877: LD_INT 103
69879: PPUSH
69880: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69884: LD_ADDR_EXP 67
69888: PUSH
69889: LD_EXP 67
69893: PPUSH
69894: LD_VAR 0 2
69898: PUSH
69899: LD_EXP 67
69903: PUSH
69904: LD_VAR 0 2
69908: ARRAY
69909: PUSH
69910: LD_INT 1
69912: PLUS
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PPUSH
69918: LD_VAR 0 3
69922: PPUSH
69923: CALL 21397 0 3
69927: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69928: LD_VAR 0 3
69932: PPUSH
69933: CALL_OW 310
69937: IFFALSE 69948
// ComExitBuilding ( j ) ;
69939: LD_VAR 0 3
69943: PPUSH
69944: CALL_OW 122
// wait ( 3 ) ;
69948: LD_INT 3
69950: PPUSH
69951: CALL_OW 67
// if not mc_construct_list [ i ] then
69955: LD_EXP 68
69959: PUSH
69960: LD_VAR 0 2
69964: ARRAY
69965: NOT
69966: IFFALSE 69970
// break ;
69968: GO 70008
// if not HasTask ( j ) then
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 314
69979: NOT
69980: IFFALSE 70006
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
69982: LD_VAR 0 3
69986: PPUSH
69987: LD_EXP 68
69991: PUSH
69992: LD_VAR 0 2
69996: ARRAY
69997: PUSH
69998: LD_INT 1
70000: ARRAY
70001: PPUSH
70002: CALL 24635 0 2
// end ;
70006: GO 69856
70008: POP
70009: POP
// end else
70010: GO 70835
// if mc_build_list [ i ] then
70012: LD_EXP 66
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: IFFALSE 70835
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70024: LD_EXP 66
70028: PUSH
70029: LD_VAR 0 2
70033: ARRAY
70034: PUSH
70035: LD_INT 1
70037: ARRAY
70038: PUSH
70039: LD_INT 1
70041: ARRAY
70042: PPUSH
70043: CALL 24459 0 1
70047: PUSH
70048: LD_EXP 61
70052: PUSH
70053: LD_VAR 0 2
70057: ARRAY
70058: PPUSH
70059: LD_INT 2
70061: PUSH
70062: LD_INT 30
70064: PUSH
70065: LD_INT 2
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 30
70074: PUSH
70075: LD_INT 3
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: LIST
70086: PPUSH
70087: CALL_OW 72
70091: NOT
70092: AND
70093: IFFALSE 70198
// begin for j = 1 to mc_build_list [ i ] do
70095: LD_ADDR_VAR 0 3
70099: PUSH
70100: DOUBLE
70101: LD_INT 1
70103: DEC
70104: ST_TO_ADDR
70105: LD_EXP 66
70109: PUSH
70110: LD_VAR 0 2
70114: ARRAY
70115: PUSH
70116: FOR_TO
70117: IFFALSE 70196
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
70119: LD_EXP 66
70123: PUSH
70124: LD_VAR 0 2
70128: ARRAY
70129: PUSH
70130: LD_VAR 0 3
70134: ARRAY
70135: PUSH
70136: LD_INT 1
70138: ARRAY
70139: PUSH
70140: LD_INT 2
70142: EQUAL
70143: IFFALSE 70194
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
70145: LD_ADDR_EXP 66
70149: PUSH
70150: LD_EXP 66
70154: PPUSH
70155: LD_VAR 0 2
70159: PPUSH
70160: LD_EXP 66
70164: PUSH
70165: LD_VAR 0 2
70169: ARRAY
70170: PPUSH
70171: LD_VAR 0 3
70175: PPUSH
70176: LD_INT 1
70178: PPUSH
70179: LD_INT 0
70181: PPUSH
70182: CALL 20815 0 4
70186: PPUSH
70187: CALL_OW 1
70191: ST_TO_ADDR
// break ;
70192: GO 70196
// end ;
70194: GO 70116
70196: POP
70197: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70198: LD_ADDR_VAR 0 6
70202: PUSH
70203: LD_EXP 61
70207: PUSH
70208: LD_VAR 0 2
70212: ARRAY
70213: PPUSH
70214: LD_INT 2
70216: PUSH
70217: LD_INT 30
70219: PUSH
70220: LD_INT 0
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 30
70229: PUSH
70230: LD_INT 1
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: LIST
70241: PPUSH
70242: CALL_OW 72
70246: ST_TO_ADDR
// for k := 1 to depot do
70247: LD_ADDR_VAR 0 4
70251: PUSH
70252: DOUBLE
70253: LD_INT 1
70255: DEC
70256: ST_TO_ADDR
70257: LD_VAR 0 6
70261: PUSH
70262: FOR_TO
70263: IFFALSE 70833
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
70265: LD_EXP 66
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: PUSH
70276: LD_INT 1
70278: ARRAY
70279: PUSH
70280: LD_INT 1
70282: ARRAY
70283: PUSH
70284: LD_INT 0
70286: EQUAL
70287: PUSH
70288: LD_VAR 0 6
70292: PUSH
70293: LD_VAR 0 4
70297: ARRAY
70298: PPUSH
70299: LD_EXP 66
70303: PUSH
70304: LD_VAR 0 2
70308: ARRAY
70309: PUSH
70310: LD_INT 1
70312: ARRAY
70313: PUSH
70314: LD_INT 1
70316: ARRAY
70317: PPUSH
70318: LD_EXP 66
70322: PUSH
70323: LD_VAR 0 2
70327: ARRAY
70328: PUSH
70329: LD_INT 1
70331: ARRAY
70332: PUSH
70333: LD_INT 2
70335: ARRAY
70336: PPUSH
70337: LD_EXP 66
70341: PUSH
70342: LD_VAR 0 2
70346: ARRAY
70347: PUSH
70348: LD_INT 1
70350: ARRAY
70351: PUSH
70352: LD_INT 3
70354: ARRAY
70355: PPUSH
70356: LD_EXP 66
70360: PUSH
70361: LD_VAR 0 2
70365: ARRAY
70366: PUSH
70367: LD_INT 1
70369: ARRAY
70370: PUSH
70371: LD_INT 4
70373: ARRAY
70374: PPUSH
70375: CALL 29871 0 5
70379: OR
70380: IFFALSE 70661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70382: LD_ADDR_VAR 0 5
70386: PUSH
70387: LD_EXP 61
70391: PUSH
70392: LD_VAR 0 2
70396: ARRAY
70397: PPUSH
70398: LD_INT 25
70400: PUSH
70401: LD_INT 2
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PPUSH
70408: CALL_OW 72
70412: PUSH
70413: LD_EXP 63
70417: PUSH
70418: LD_VAR 0 2
70422: ARRAY
70423: DIFF
70424: ST_TO_ADDR
// if not tmp then
70425: LD_VAR 0 5
70429: NOT
70430: IFFALSE 70434
// continue ;
70432: GO 70262
// for j in tmp do
70434: LD_ADDR_VAR 0 3
70438: PUSH
70439: LD_VAR 0 5
70443: PUSH
70444: FOR_IN
70445: IFFALSE 70657
// begin if not mc_builders [ i ] then
70447: LD_EXP 67
70451: PUSH
70452: LD_VAR 0 2
70456: ARRAY
70457: NOT
70458: IFFALSE 70516
// begin SetTag ( j , 103 ) ;
70460: LD_VAR 0 3
70464: PPUSH
70465: LD_INT 103
70467: PPUSH
70468: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70472: LD_ADDR_EXP 67
70476: PUSH
70477: LD_EXP 67
70481: PPUSH
70482: LD_VAR 0 2
70486: PUSH
70487: LD_EXP 67
70491: PUSH
70492: LD_VAR 0 2
70496: ARRAY
70497: PUSH
70498: LD_INT 1
70500: PLUS
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PPUSH
70506: LD_VAR 0 3
70510: PPUSH
70511: CALL 21397 0 3
70515: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70516: LD_VAR 0 3
70520: PPUSH
70521: CALL_OW 310
70525: IFFALSE 70536
// ComExitBuilding ( j ) ;
70527: LD_VAR 0 3
70531: PPUSH
70532: CALL_OW 122
// wait ( 3 ) ;
70536: LD_INT 3
70538: PPUSH
70539: CALL_OW 67
// if not mc_build_list [ i ] then
70543: LD_EXP 66
70547: PUSH
70548: LD_VAR 0 2
70552: ARRAY
70553: NOT
70554: IFFALSE 70558
// break ;
70556: GO 70657
// if not HasTask ( j ) then
70558: LD_VAR 0 3
70562: PPUSH
70563: CALL_OW 314
70567: NOT
70568: IFFALSE 70655
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
70570: LD_VAR 0 3
70574: PPUSH
70575: LD_EXP 66
70579: PUSH
70580: LD_VAR 0 2
70584: ARRAY
70585: PUSH
70586: LD_INT 1
70588: ARRAY
70589: PUSH
70590: LD_INT 1
70592: ARRAY
70593: PPUSH
70594: LD_EXP 66
70598: PUSH
70599: LD_VAR 0 2
70603: ARRAY
70604: PUSH
70605: LD_INT 1
70607: ARRAY
70608: PUSH
70609: LD_INT 2
70611: ARRAY
70612: PPUSH
70613: LD_EXP 66
70617: PUSH
70618: LD_VAR 0 2
70622: ARRAY
70623: PUSH
70624: LD_INT 1
70626: ARRAY
70627: PUSH
70628: LD_INT 3
70630: ARRAY
70631: PPUSH
70632: LD_EXP 66
70636: PUSH
70637: LD_VAR 0 2
70641: ARRAY
70642: PUSH
70643: LD_INT 1
70645: ARRAY
70646: PUSH
70647: LD_INT 4
70649: ARRAY
70650: PPUSH
70651: CALL_OW 145
// end ;
70655: GO 70444
70657: POP
70658: POP
// end else
70659: GO 70831
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
70661: LD_EXP 61
70665: PUSH
70666: LD_VAR 0 2
70670: ARRAY
70671: PPUSH
70672: LD_EXP 66
70676: PUSH
70677: LD_VAR 0 2
70681: ARRAY
70682: PUSH
70683: LD_INT 1
70685: ARRAY
70686: PUSH
70687: LD_INT 1
70689: ARRAY
70690: PPUSH
70691: LD_EXP 66
70695: PUSH
70696: LD_VAR 0 2
70700: ARRAY
70701: PUSH
70702: LD_INT 1
70704: ARRAY
70705: PUSH
70706: LD_INT 2
70708: ARRAY
70709: PPUSH
70710: LD_EXP 66
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: PUSH
70721: LD_INT 1
70723: ARRAY
70724: PUSH
70725: LD_INT 3
70727: ARRAY
70728: PPUSH
70729: LD_EXP 66
70733: PUSH
70734: LD_VAR 0 2
70738: ARRAY
70739: PUSH
70740: LD_INT 1
70742: ARRAY
70743: PUSH
70744: LD_INT 4
70746: ARRAY
70747: PPUSH
70748: LD_EXP 61
70752: PUSH
70753: LD_VAR 0 2
70757: ARRAY
70758: PPUSH
70759: LD_INT 21
70761: PUSH
70762: LD_INT 3
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: PPUSH
70769: CALL_OW 72
70773: PPUSH
70774: EMPTY
70775: PPUSH
70776: CALL 28625 0 7
70780: NOT
70781: IFFALSE 70831
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
70783: LD_ADDR_EXP 66
70787: PUSH
70788: LD_EXP 66
70792: PPUSH
70793: LD_VAR 0 2
70797: PPUSH
70798: LD_EXP 66
70802: PUSH
70803: LD_VAR 0 2
70807: ARRAY
70808: PPUSH
70809: LD_INT 1
70811: PPUSH
70812: LD_INT 1
70814: NEG
70815: PPUSH
70816: LD_INT 0
70818: PPUSH
70819: CALL 20815 0 4
70823: PPUSH
70824: CALL_OW 1
70828: ST_TO_ADDR
// continue ;
70829: GO 70262
// end ; end ;
70831: GO 70262
70833: POP
70834: POP
// end ; end ;
70835: GO 69691
70837: POP
70838: POP
// end ;
70839: LD_VAR 0 1
70843: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
70844: LD_INT 0
70846: PPUSH
70847: PPUSH
70848: PPUSH
70849: PPUSH
70850: PPUSH
70851: PPUSH
// if not mc_bases then
70852: LD_EXP 61
70856: NOT
70857: IFFALSE 70861
// exit ;
70859: GO 71288
// for i = 1 to mc_bases do
70861: LD_ADDR_VAR 0 2
70865: PUSH
70866: DOUBLE
70867: LD_INT 1
70869: DEC
70870: ST_TO_ADDR
70871: LD_EXP 61
70875: PUSH
70876: FOR_TO
70877: IFFALSE 71286
// begin tmp := mc_build_upgrade [ i ] ;
70879: LD_ADDR_VAR 0 4
70883: PUSH
70884: LD_EXP 93
70888: PUSH
70889: LD_VAR 0 2
70893: ARRAY
70894: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
70895: LD_ADDR_VAR 0 6
70899: PUSH
70900: LD_EXP 94
70904: PUSH
70905: LD_VAR 0 2
70909: ARRAY
70910: PPUSH
70911: LD_INT 2
70913: PUSH
70914: LD_INT 30
70916: PUSH
70917: LD_INT 6
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 30
70926: PUSH
70927: LD_INT 7
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: LIST
70938: PPUSH
70939: CALL_OW 72
70943: ST_TO_ADDR
// if not tmp and not lab then
70944: LD_VAR 0 4
70948: NOT
70949: PUSH
70950: LD_VAR 0 6
70954: NOT
70955: AND
70956: IFFALSE 70960
// continue ;
70958: GO 70876
// if tmp then
70960: LD_VAR 0 4
70964: IFFALSE 71084
// for j in tmp do
70966: LD_ADDR_VAR 0 3
70970: PUSH
70971: LD_VAR 0 4
70975: PUSH
70976: FOR_IN
70977: IFFALSE 71082
// begin if UpgradeCost ( j ) then
70979: LD_VAR 0 3
70983: PPUSH
70984: CALL 28285 0 1
70988: IFFALSE 71080
// begin ComUpgrade ( j ) ;
70990: LD_VAR 0 3
70994: PPUSH
70995: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
70999: LD_ADDR_EXP 93
71003: PUSH
71004: LD_EXP 93
71008: PPUSH
71009: LD_VAR 0 2
71013: PPUSH
71014: LD_EXP 93
71018: PUSH
71019: LD_VAR 0 2
71023: ARRAY
71024: PUSH
71025: LD_VAR 0 3
71029: DIFF
71030: PPUSH
71031: CALL_OW 1
71035: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71036: LD_ADDR_EXP 68
71040: PUSH
71041: LD_EXP 68
71045: PPUSH
71046: LD_VAR 0 2
71050: PUSH
71051: LD_EXP 68
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: PUSH
71062: LD_INT 1
71064: PLUS
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PPUSH
71070: LD_VAR 0 3
71074: PPUSH
71075: CALL 21397 0 3
71079: ST_TO_ADDR
// end ; end ;
71080: GO 70976
71082: POP
71083: POP
// if not lab or not mc_lab_upgrade [ i ] then
71084: LD_VAR 0 6
71088: NOT
71089: PUSH
71090: LD_EXP 95
71094: PUSH
71095: LD_VAR 0 2
71099: ARRAY
71100: NOT
71101: OR
71102: IFFALSE 71106
// continue ;
71104: GO 70876
// for j in lab do
71106: LD_ADDR_VAR 0 3
71110: PUSH
71111: LD_VAR 0 6
71115: PUSH
71116: FOR_IN
71117: IFFALSE 71282
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
71119: LD_VAR 0 3
71123: PPUSH
71124: CALL_OW 266
71128: PUSH
71129: LD_INT 6
71131: PUSH
71132: LD_INT 7
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: IN
71139: PUSH
71140: LD_VAR 0 3
71144: PPUSH
71145: CALL_OW 461
71149: PUSH
71150: LD_INT 1
71152: NONEQUAL
71153: AND
71154: IFFALSE 71280
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
71156: LD_VAR 0 3
71160: PPUSH
71161: LD_EXP 95
71165: PUSH
71166: LD_VAR 0 2
71170: ARRAY
71171: PUSH
71172: LD_INT 1
71174: ARRAY
71175: PPUSH
71176: CALL 28490 0 2
71180: IFFALSE 71280
// begin ComCancel ( j ) ;
71182: LD_VAR 0 3
71186: PPUSH
71187: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
71191: LD_VAR 0 3
71195: PPUSH
71196: LD_EXP 95
71200: PUSH
71201: LD_VAR 0 2
71205: ARRAY
71206: PUSH
71207: LD_INT 1
71209: ARRAY
71210: PPUSH
71211: CALL_OW 207
// if not j in mc_construct_list [ i ] then
71215: LD_VAR 0 3
71219: PUSH
71220: LD_EXP 68
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: IN
71231: NOT
71232: IFFALSE 71278
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71234: LD_ADDR_EXP 68
71238: PUSH
71239: LD_EXP 68
71243: PPUSH
71244: LD_VAR 0 2
71248: PUSH
71249: LD_EXP 68
71253: PUSH
71254: LD_VAR 0 2
71258: ARRAY
71259: PUSH
71260: LD_INT 1
71262: PLUS
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PPUSH
71268: LD_VAR 0 3
71272: PPUSH
71273: CALL 21397 0 3
71277: ST_TO_ADDR
// break ;
71278: GO 71282
// end ; end ; end ;
71280: GO 71116
71282: POP
71283: POP
// end ;
71284: GO 70876
71286: POP
71287: POP
// end ;
71288: LD_VAR 0 1
71292: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
71293: LD_INT 0
71295: PPUSH
71296: PPUSH
71297: PPUSH
71298: PPUSH
71299: PPUSH
71300: PPUSH
71301: PPUSH
71302: PPUSH
71303: PPUSH
// if not mc_bases then
71304: LD_EXP 61
71308: NOT
71309: IFFALSE 71313
// exit ;
71311: GO 71718
// for i = 1 to mc_bases do
71313: LD_ADDR_VAR 0 2
71317: PUSH
71318: DOUBLE
71319: LD_INT 1
71321: DEC
71322: ST_TO_ADDR
71323: LD_EXP 61
71327: PUSH
71328: FOR_TO
71329: IFFALSE 71716
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
71331: LD_EXP 69
71335: PUSH
71336: LD_VAR 0 2
71340: ARRAY
71341: NOT
71342: PUSH
71343: LD_EXP 61
71347: PUSH
71348: LD_VAR 0 2
71352: ARRAY
71353: PPUSH
71354: LD_INT 30
71356: PUSH
71357: LD_INT 3
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PPUSH
71364: CALL_OW 72
71368: NOT
71369: OR
71370: IFFALSE 71374
// continue ;
71372: GO 71328
// busy := false ;
71374: LD_ADDR_VAR 0 8
71378: PUSH
71379: LD_INT 0
71381: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71382: LD_ADDR_VAR 0 4
71386: PUSH
71387: LD_EXP 61
71391: PUSH
71392: LD_VAR 0 2
71396: ARRAY
71397: PPUSH
71398: LD_INT 30
71400: PUSH
71401: LD_INT 3
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PPUSH
71408: CALL_OW 72
71412: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
71413: LD_ADDR_VAR 0 6
71417: PUSH
71418: LD_EXP 69
71422: PUSH
71423: LD_VAR 0 2
71427: ARRAY
71428: PPUSH
71429: LD_INT 2
71431: PUSH
71432: LD_INT 30
71434: PUSH
71435: LD_INT 32
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 30
71444: PUSH
71445: LD_INT 33
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: LIST
71456: PPUSH
71457: CALL_OW 72
71461: ST_TO_ADDR
// if not t then
71462: LD_VAR 0 6
71466: NOT
71467: IFFALSE 71471
// continue ;
71469: GO 71328
// for j in tmp do
71471: LD_ADDR_VAR 0 3
71475: PUSH
71476: LD_VAR 0 4
71480: PUSH
71481: FOR_IN
71482: IFFALSE 71512
// if not BuildingStatus ( j ) = bs_idle then
71484: LD_VAR 0 3
71488: PPUSH
71489: CALL_OW 461
71493: PUSH
71494: LD_INT 2
71496: EQUAL
71497: NOT
71498: IFFALSE 71510
// begin busy := true ;
71500: LD_ADDR_VAR 0 8
71504: PUSH
71505: LD_INT 1
71507: ST_TO_ADDR
// break ;
71508: GO 71512
// end ;
71510: GO 71481
71512: POP
71513: POP
// if busy then
71514: LD_VAR 0 8
71518: IFFALSE 71522
// continue ;
71520: GO 71328
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
71522: LD_ADDR_VAR 0 7
71526: PUSH
71527: LD_VAR 0 6
71531: PPUSH
71532: LD_INT 35
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PPUSH
71542: CALL_OW 72
71546: ST_TO_ADDR
// if tw then
71547: LD_VAR 0 7
71551: IFFALSE 71628
// begin tw := tw [ 1 ] ;
71553: LD_ADDR_VAR 0 7
71557: PUSH
71558: LD_VAR 0 7
71562: PUSH
71563: LD_INT 1
71565: ARRAY
71566: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
71567: LD_ADDR_VAR 0 9
71571: PUSH
71572: LD_VAR 0 7
71576: PPUSH
71577: LD_EXP 86
71581: PUSH
71582: LD_VAR 0 2
71586: ARRAY
71587: PPUSH
71588: CALL 26782 0 2
71592: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
71593: LD_EXP 100
71597: PUSH
71598: LD_VAR 0 2
71602: ARRAY
71603: IFFALSE 71626
// if not weapon in mc_allowed_tower_weapons [ i ] then
71605: LD_VAR 0 9
71609: PUSH
71610: LD_EXP 100
71614: PUSH
71615: LD_VAR 0 2
71619: ARRAY
71620: IN
71621: NOT
71622: IFFALSE 71626
// continue ;
71624: GO 71328
// end else
71626: GO 71691
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
71628: LD_ADDR_VAR 0 5
71632: PUSH
71633: LD_EXP 69
71637: PUSH
71638: LD_VAR 0 2
71642: ARRAY
71643: PPUSH
71644: LD_VAR 0 4
71648: PPUSH
71649: CALL 53674 0 2
71653: ST_TO_ADDR
// if not tmp2 then
71654: LD_VAR 0 5
71658: NOT
71659: IFFALSE 71663
// continue ;
71661: GO 71328
// tw := tmp2 [ 1 ] ;
71663: LD_ADDR_VAR 0 7
71667: PUSH
71668: LD_VAR 0 5
71672: PUSH
71673: LD_INT 1
71675: ARRAY
71676: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
71677: LD_ADDR_VAR 0 9
71681: PUSH
71682: LD_VAR 0 5
71686: PUSH
71687: LD_INT 2
71689: ARRAY
71690: ST_TO_ADDR
// end ; if not weapon then
71691: LD_VAR 0 9
71695: NOT
71696: IFFALSE 71700
// continue ;
71698: GO 71328
// ComPlaceWeapon ( tw , weapon ) ;
71700: LD_VAR 0 7
71704: PPUSH
71705: LD_VAR 0 9
71709: PPUSH
71710: CALL_OW 148
// end ;
71714: GO 71328
71716: POP
71717: POP
// end ;
71718: LD_VAR 0 1
71722: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
71723: LD_INT 0
71725: PPUSH
71726: PPUSH
71727: PPUSH
71728: PPUSH
71729: PPUSH
71730: PPUSH
71731: PPUSH
// if not mc_bases then
71732: LD_EXP 61
71736: NOT
71737: IFFALSE 71741
// exit ;
71739: GO 72516
// for i = 1 to mc_bases do
71741: LD_ADDR_VAR 0 2
71745: PUSH
71746: DOUBLE
71747: LD_INT 1
71749: DEC
71750: ST_TO_ADDR
71751: LD_EXP 61
71755: PUSH
71756: FOR_TO
71757: IFFALSE 72514
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
71759: LD_EXP 74
71763: PUSH
71764: LD_VAR 0 2
71768: ARRAY
71769: NOT
71770: PUSH
71771: LD_EXP 74
71775: PUSH
71776: LD_VAR 0 2
71780: ARRAY
71781: PUSH
71782: LD_EXP 75
71786: PUSH
71787: LD_VAR 0 2
71791: ARRAY
71792: EQUAL
71793: OR
71794: PUSH
71795: LD_EXP 84
71799: PUSH
71800: LD_VAR 0 2
71804: ARRAY
71805: OR
71806: IFFALSE 71810
// continue ;
71808: GO 71756
// if mc_miners [ i ] then
71810: LD_EXP 75
71814: PUSH
71815: LD_VAR 0 2
71819: ARRAY
71820: IFFALSE 72201
// begin for j = mc_miners [ i ] downto 1 do
71822: LD_ADDR_VAR 0 3
71826: PUSH
71827: DOUBLE
71828: LD_EXP 75
71832: PUSH
71833: LD_VAR 0 2
71837: ARRAY
71838: INC
71839: ST_TO_ADDR
71840: LD_INT 1
71842: PUSH
71843: FOR_DOWNTO
71844: IFFALSE 72199
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
71846: LD_EXP 75
71850: PUSH
71851: LD_VAR 0 2
71855: ARRAY
71856: PUSH
71857: LD_VAR 0 3
71861: ARRAY
71862: PPUSH
71863: CALL_OW 301
71867: PUSH
71868: LD_EXP 75
71872: PUSH
71873: LD_VAR 0 2
71877: ARRAY
71878: PUSH
71879: LD_VAR 0 3
71883: ARRAY
71884: PPUSH
71885: CALL_OW 257
71889: PUSH
71890: LD_INT 1
71892: NONEQUAL
71893: OR
71894: IFFALSE 71957
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
71896: LD_ADDR_VAR 0 5
71900: PUSH
71901: LD_EXP 75
71905: PUSH
71906: LD_VAR 0 2
71910: ARRAY
71911: PUSH
71912: LD_EXP 75
71916: PUSH
71917: LD_VAR 0 2
71921: ARRAY
71922: PUSH
71923: LD_VAR 0 3
71927: ARRAY
71928: DIFF
71929: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
71930: LD_ADDR_EXP 75
71934: PUSH
71935: LD_EXP 75
71939: PPUSH
71940: LD_VAR 0 2
71944: PPUSH
71945: LD_VAR 0 5
71949: PPUSH
71950: CALL_OW 1
71954: ST_TO_ADDR
// continue ;
71955: GO 71843
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
71957: LD_EXP 75
71961: PUSH
71962: LD_VAR 0 2
71966: ARRAY
71967: PUSH
71968: LD_VAR 0 3
71972: ARRAY
71973: PPUSH
71974: CALL_OW 257
71978: PUSH
71979: LD_INT 1
71981: EQUAL
71982: PUSH
71983: LD_EXP 75
71987: PUSH
71988: LD_VAR 0 2
71992: ARRAY
71993: PUSH
71994: LD_VAR 0 3
71998: ARRAY
71999: PPUSH
72000: CALL_OW 459
72004: NOT
72005: AND
72006: PUSH
72007: LD_EXP 75
72011: PUSH
72012: LD_VAR 0 2
72016: ARRAY
72017: PUSH
72018: LD_VAR 0 3
72022: ARRAY
72023: PPUSH
72024: CALL_OW 314
72028: NOT
72029: AND
72030: IFFALSE 72197
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72032: LD_EXP 75
72036: PUSH
72037: LD_VAR 0 2
72041: ARRAY
72042: PUSH
72043: LD_VAR 0 3
72047: ARRAY
72048: PPUSH
72049: CALL_OW 310
72053: IFFALSE 72076
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72055: LD_EXP 75
72059: PUSH
72060: LD_VAR 0 2
72064: ARRAY
72065: PUSH
72066: LD_VAR 0 3
72070: ARRAY
72071: PPUSH
72072: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72076: LD_EXP 75
72080: PUSH
72081: LD_VAR 0 2
72085: ARRAY
72086: PUSH
72087: LD_VAR 0 3
72091: ARRAY
72092: PPUSH
72093: CALL_OW 314
72097: NOT
72098: IFFALSE 72197
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
72100: LD_ADDR_VAR 0 7
72104: PUSH
72105: LD_VAR 0 3
72109: PUSH
72110: LD_EXP 74
72114: PUSH
72115: LD_VAR 0 2
72119: ARRAY
72120: PPUSH
72121: CALL 18537 0 1
72125: MOD
72126: PUSH
72127: LD_INT 1
72129: PLUS
72130: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
72131: LD_EXP 75
72135: PUSH
72136: LD_VAR 0 2
72140: ARRAY
72141: PUSH
72142: LD_VAR 0 3
72146: ARRAY
72147: PPUSH
72148: LD_EXP 74
72152: PUSH
72153: LD_VAR 0 2
72157: ARRAY
72158: PUSH
72159: LD_VAR 0 7
72163: ARRAY
72164: PUSH
72165: LD_INT 1
72167: ARRAY
72168: PPUSH
72169: LD_EXP 74
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: PUSH
72180: LD_VAR 0 7
72184: ARRAY
72185: PUSH
72186: LD_INT 2
72188: ARRAY
72189: PPUSH
72190: LD_INT 0
72192: PPUSH
72193: CALL_OW 193
// end ; end ; end ;
72197: GO 71843
72199: POP
72200: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
72201: LD_ADDR_VAR 0 5
72205: PUSH
72206: LD_EXP 61
72210: PUSH
72211: LD_VAR 0 2
72215: ARRAY
72216: PPUSH
72217: LD_INT 2
72219: PUSH
72220: LD_INT 30
72222: PUSH
72223: LD_INT 4
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 30
72232: PUSH
72233: LD_INT 5
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 30
72242: PUSH
72243: LD_INT 32
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: PPUSH
72256: CALL_OW 72
72260: ST_TO_ADDR
// if not tmp then
72261: LD_VAR 0 5
72265: NOT
72266: IFFALSE 72270
// continue ;
72268: GO 71756
// list := [ ] ;
72270: LD_ADDR_VAR 0 6
72274: PUSH
72275: EMPTY
72276: ST_TO_ADDR
// for j in tmp do
72277: LD_ADDR_VAR 0 3
72281: PUSH
72282: LD_VAR 0 5
72286: PUSH
72287: FOR_IN
72288: IFFALSE 72357
// begin for k in UnitsInside ( j ) do
72290: LD_ADDR_VAR 0 4
72294: PUSH
72295: LD_VAR 0 3
72299: PPUSH
72300: CALL_OW 313
72304: PUSH
72305: FOR_IN
72306: IFFALSE 72353
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
72308: LD_VAR 0 4
72312: PPUSH
72313: CALL_OW 257
72317: PUSH
72318: LD_INT 1
72320: EQUAL
72321: PUSH
72322: LD_VAR 0 4
72326: PPUSH
72327: CALL_OW 459
72331: NOT
72332: AND
72333: IFFALSE 72351
// list := list ^ k ;
72335: LD_ADDR_VAR 0 6
72339: PUSH
72340: LD_VAR 0 6
72344: PUSH
72345: LD_VAR 0 4
72349: ADD
72350: ST_TO_ADDR
72351: GO 72305
72353: POP
72354: POP
// end ;
72355: GO 72287
72357: POP
72358: POP
// list := list diff mc_miners [ i ] ;
72359: LD_ADDR_VAR 0 6
72363: PUSH
72364: LD_VAR 0 6
72368: PUSH
72369: LD_EXP 75
72373: PUSH
72374: LD_VAR 0 2
72378: ARRAY
72379: DIFF
72380: ST_TO_ADDR
// if not list then
72381: LD_VAR 0 6
72385: NOT
72386: IFFALSE 72390
// continue ;
72388: GO 71756
// k := mc_mines [ i ] - mc_miners [ i ] ;
72390: LD_ADDR_VAR 0 4
72394: PUSH
72395: LD_EXP 74
72399: PUSH
72400: LD_VAR 0 2
72404: ARRAY
72405: PUSH
72406: LD_EXP 75
72410: PUSH
72411: LD_VAR 0 2
72415: ARRAY
72416: MINUS
72417: ST_TO_ADDR
// if k > list then
72418: LD_VAR 0 4
72422: PUSH
72423: LD_VAR 0 6
72427: GREATER
72428: IFFALSE 72440
// k := list ;
72430: LD_ADDR_VAR 0 4
72434: PUSH
72435: LD_VAR 0 6
72439: ST_TO_ADDR
// for j = 1 to k do
72440: LD_ADDR_VAR 0 3
72444: PUSH
72445: DOUBLE
72446: LD_INT 1
72448: DEC
72449: ST_TO_ADDR
72450: LD_VAR 0 4
72454: PUSH
72455: FOR_TO
72456: IFFALSE 72510
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
72458: LD_ADDR_EXP 75
72462: PUSH
72463: LD_EXP 75
72467: PPUSH
72468: LD_VAR 0 2
72472: PUSH
72473: LD_EXP 75
72477: PUSH
72478: LD_VAR 0 2
72482: ARRAY
72483: PUSH
72484: LD_INT 1
72486: PLUS
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PPUSH
72492: LD_VAR 0 6
72496: PUSH
72497: LD_VAR 0 3
72501: ARRAY
72502: PPUSH
72503: CALL 21397 0 3
72507: ST_TO_ADDR
72508: GO 72455
72510: POP
72511: POP
// end ;
72512: GO 71756
72514: POP
72515: POP
// end ;
72516: LD_VAR 0 1
72520: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
72521: LD_INT 0
72523: PPUSH
72524: PPUSH
72525: PPUSH
72526: PPUSH
72527: PPUSH
72528: PPUSH
72529: PPUSH
72530: PPUSH
72531: PPUSH
72532: PPUSH
72533: PPUSH
// if not mc_bases then
72534: LD_EXP 61
72538: NOT
72539: IFFALSE 72543
// exit ;
72541: GO 74366
// for i = 1 to mc_bases do
72543: LD_ADDR_VAR 0 2
72547: PUSH
72548: DOUBLE
72549: LD_INT 1
72551: DEC
72552: ST_TO_ADDR
72553: LD_EXP 61
72557: PUSH
72558: FOR_TO
72559: IFFALSE 74364
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
72561: LD_EXP 61
72565: PUSH
72566: LD_VAR 0 2
72570: ARRAY
72571: NOT
72572: PUSH
72573: LD_EXP 68
72577: PUSH
72578: LD_VAR 0 2
72582: ARRAY
72583: OR
72584: IFFALSE 72588
// continue ;
72586: GO 72558
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
72588: LD_EXP 77
72592: PUSH
72593: LD_VAR 0 2
72597: ARRAY
72598: NOT
72599: PUSH
72600: LD_EXP 78
72604: PUSH
72605: LD_VAR 0 2
72609: ARRAY
72610: AND
72611: IFFALSE 72649
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
72613: LD_ADDR_EXP 78
72617: PUSH
72618: LD_EXP 78
72622: PPUSH
72623: LD_VAR 0 2
72627: PPUSH
72628: EMPTY
72629: PPUSH
72630: CALL_OW 1
72634: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
72635: LD_VAR 0 2
72639: PPUSH
72640: LD_INT 107
72642: PPUSH
72643: CALL 63375 0 2
// continue ;
72647: GO 72558
// end ; target := [ ] ;
72649: LD_ADDR_VAR 0 7
72653: PUSH
72654: EMPTY
72655: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72656: LD_ADDR_VAR 0 6
72660: PUSH
72661: LD_EXP 61
72665: PUSH
72666: LD_VAR 0 2
72670: ARRAY
72671: PUSH
72672: LD_INT 1
72674: ARRAY
72675: PPUSH
72676: CALL_OW 255
72680: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72681: LD_ADDR_VAR 0 9
72685: PUSH
72686: LD_EXP 61
72690: PUSH
72691: LD_VAR 0 2
72695: ARRAY
72696: PPUSH
72697: LD_INT 2
72699: PUSH
72700: LD_INT 30
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 30
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: LIST
72724: PPUSH
72725: CALL_OW 72
72729: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
72730: LD_ADDR_VAR 0 3
72734: PUSH
72735: DOUBLE
72736: LD_EXP 77
72740: PUSH
72741: LD_VAR 0 2
72745: ARRAY
72746: INC
72747: ST_TO_ADDR
72748: LD_INT 1
72750: PUSH
72751: FOR_DOWNTO
72752: IFFALSE 72997
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
72754: LD_EXP 77
72758: PUSH
72759: LD_VAR 0 2
72763: ARRAY
72764: PUSH
72765: LD_VAR 0 3
72769: ARRAY
72770: PUSH
72771: LD_INT 2
72773: ARRAY
72774: PPUSH
72775: LD_EXP 77
72779: PUSH
72780: LD_VAR 0 2
72784: ARRAY
72785: PUSH
72786: LD_VAR 0 3
72790: ARRAY
72791: PUSH
72792: LD_INT 3
72794: ARRAY
72795: PPUSH
72796: CALL_OW 488
72800: PUSH
72801: LD_EXP 77
72805: PUSH
72806: LD_VAR 0 2
72810: ARRAY
72811: PUSH
72812: LD_VAR 0 3
72816: ARRAY
72817: PUSH
72818: LD_INT 2
72820: ARRAY
72821: PPUSH
72822: LD_EXP 77
72826: PUSH
72827: LD_VAR 0 2
72831: ARRAY
72832: PUSH
72833: LD_VAR 0 3
72837: ARRAY
72838: PUSH
72839: LD_INT 3
72841: ARRAY
72842: PPUSH
72843: CALL_OW 284
72847: PUSH
72848: LD_INT 0
72850: EQUAL
72851: AND
72852: IFFALSE 72907
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
72854: LD_ADDR_VAR 0 5
72858: PUSH
72859: LD_EXP 77
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: PPUSH
72870: LD_VAR 0 3
72874: PPUSH
72875: CALL_OW 3
72879: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
72880: LD_ADDR_EXP 77
72884: PUSH
72885: LD_EXP 77
72889: PPUSH
72890: LD_VAR 0 2
72894: PPUSH
72895: LD_VAR 0 5
72899: PPUSH
72900: CALL_OW 1
72904: ST_TO_ADDR
// continue ;
72905: GO 72751
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
72907: LD_VAR 0 6
72911: PPUSH
72912: LD_EXP 77
72916: PUSH
72917: LD_VAR 0 2
72921: ARRAY
72922: PUSH
72923: LD_VAR 0 3
72927: ARRAY
72928: PUSH
72929: LD_INT 2
72931: ARRAY
72932: PPUSH
72933: LD_EXP 77
72937: PUSH
72938: LD_VAR 0 2
72942: ARRAY
72943: PUSH
72944: LD_VAR 0 3
72948: ARRAY
72949: PUSH
72950: LD_INT 3
72952: ARRAY
72953: PPUSH
72954: LD_INT 30
72956: PPUSH
72957: CALL 22661 0 4
72961: PUSH
72962: LD_INT 4
72964: ARRAY
72965: PUSH
72966: LD_INT 0
72968: EQUAL
72969: IFFALSE 72995
// begin target := mc_crates [ i ] [ j ] ;
72971: LD_ADDR_VAR 0 7
72975: PUSH
72976: LD_EXP 77
72980: PUSH
72981: LD_VAR 0 2
72985: ARRAY
72986: PUSH
72987: LD_VAR 0 3
72991: ARRAY
72992: ST_TO_ADDR
// break ;
72993: GO 72997
// end ; end ;
72995: GO 72751
72997: POP
72998: POP
// if not target then
72999: LD_VAR 0 7
73003: NOT
73004: IFFALSE 73008
// continue ;
73006: GO 72558
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73008: LD_ADDR_VAR 0 8
73012: PUSH
73013: LD_EXP 80
73017: PUSH
73018: LD_VAR 0 2
73022: ARRAY
73023: PPUSH
73024: LD_INT 2
73026: PUSH
73027: LD_INT 3
73029: PUSH
73030: LD_INT 58
73032: PUSH
73033: EMPTY
73034: LIST
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 61
73042: PUSH
73043: EMPTY
73044: LIST
73045: PUSH
73046: LD_INT 33
73048: PUSH
73049: LD_INT 5
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: LD_INT 33
73058: PUSH
73059: LD_INT 3
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: PUSH
73073: LD_INT 2
73075: PUSH
73076: LD_INT 34
73078: PUSH
73079: LD_INT 32
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 34
73088: PUSH
73089: LD_INT 51
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 34
73098: PUSH
73099: LD_INT 12
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PPUSH
73116: CALL_OW 72
73120: ST_TO_ADDR
// if not cargo then
73121: LD_VAR 0 8
73125: NOT
73126: IFFALSE 73832
// begin if mc_crates_collector [ i ] < 5 then
73128: LD_EXP 78
73132: PUSH
73133: LD_VAR 0 2
73137: ARRAY
73138: PUSH
73139: LD_INT 5
73141: LESS
73142: IFFALSE 73508
// begin if mc_ape [ i ] then
73144: LD_EXP 90
73148: PUSH
73149: LD_VAR 0 2
73153: ARRAY
73154: IFFALSE 73201
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
73156: LD_ADDR_VAR 0 5
73160: PUSH
73161: LD_EXP 90
73165: PUSH
73166: LD_VAR 0 2
73170: ARRAY
73171: PPUSH
73172: LD_INT 25
73174: PUSH
73175: LD_INT 16
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 24
73184: PUSH
73185: LD_INT 750
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PPUSH
73196: CALL_OW 72
73200: ST_TO_ADDR
// if not tmp then
73201: LD_VAR 0 5
73205: NOT
73206: IFFALSE 73253
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
73208: LD_ADDR_VAR 0 5
73212: PUSH
73213: LD_EXP 61
73217: PUSH
73218: LD_VAR 0 2
73222: ARRAY
73223: PPUSH
73224: LD_INT 25
73226: PUSH
73227: LD_INT 2
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 24
73236: PUSH
73237: LD_INT 750
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PPUSH
73248: CALL_OW 72
73252: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
73253: LD_EXP 90
73257: PUSH
73258: LD_VAR 0 2
73262: ARRAY
73263: PUSH
73264: LD_EXP 61
73268: PUSH
73269: LD_VAR 0 2
73273: ARRAY
73274: PPUSH
73275: LD_INT 25
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 24
73287: PUSH
73288: LD_INT 750
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PPUSH
73299: CALL_OW 72
73303: AND
73304: PUSH
73305: LD_VAR 0 5
73309: PUSH
73310: LD_INT 5
73312: LESS
73313: AND
73314: IFFALSE 73396
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
73316: LD_ADDR_VAR 0 3
73320: PUSH
73321: LD_EXP 61
73325: PUSH
73326: LD_VAR 0 2
73330: ARRAY
73331: PPUSH
73332: LD_INT 25
73334: PUSH
73335: LD_INT 2
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 24
73344: PUSH
73345: LD_INT 750
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PPUSH
73356: CALL_OW 72
73360: PUSH
73361: FOR_IN
73362: IFFALSE 73394
// begin tmp := tmp union j ;
73364: LD_ADDR_VAR 0 5
73368: PUSH
73369: LD_VAR 0 5
73373: PUSH
73374: LD_VAR 0 3
73378: UNION
73379: ST_TO_ADDR
// if tmp >= 5 then
73380: LD_VAR 0 5
73384: PUSH
73385: LD_INT 5
73387: GREATEREQUAL
73388: IFFALSE 73392
// break ;
73390: GO 73394
// end ;
73392: GO 73361
73394: POP
73395: POP
// end ; if not tmp then
73396: LD_VAR 0 5
73400: NOT
73401: IFFALSE 73405
// continue ;
73403: GO 72558
// for j in tmp do
73405: LD_ADDR_VAR 0 3
73409: PUSH
73410: LD_VAR 0 5
73414: PUSH
73415: FOR_IN
73416: IFFALSE 73506
// if not GetTag ( j ) then
73418: LD_VAR 0 3
73422: PPUSH
73423: CALL_OW 110
73427: NOT
73428: IFFALSE 73504
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
73430: LD_ADDR_EXP 78
73434: PUSH
73435: LD_EXP 78
73439: PPUSH
73440: LD_VAR 0 2
73444: PUSH
73445: LD_EXP 78
73449: PUSH
73450: LD_VAR 0 2
73454: ARRAY
73455: PUSH
73456: LD_INT 1
73458: PLUS
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PPUSH
73464: LD_VAR 0 3
73468: PPUSH
73469: CALL 21397 0 3
73473: ST_TO_ADDR
// SetTag ( j , 107 ) ;
73474: LD_VAR 0 3
73478: PPUSH
73479: LD_INT 107
73481: PPUSH
73482: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
73486: LD_EXP 78
73490: PUSH
73491: LD_VAR 0 2
73495: ARRAY
73496: PUSH
73497: LD_INT 5
73499: GREATEREQUAL
73500: IFFALSE 73504
// break ;
73502: GO 73506
// end ;
73504: GO 73415
73506: POP
73507: POP
// end ; if mc_crates_collector [ i ] and target then
73508: LD_EXP 78
73512: PUSH
73513: LD_VAR 0 2
73517: ARRAY
73518: PUSH
73519: LD_VAR 0 7
73523: AND
73524: IFFALSE 73830
// begin if mc_crates_collector [ i ] < target [ 1 ] then
73526: LD_EXP 78
73530: PUSH
73531: LD_VAR 0 2
73535: ARRAY
73536: PUSH
73537: LD_VAR 0 7
73541: PUSH
73542: LD_INT 1
73544: ARRAY
73545: LESS
73546: IFFALSE 73566
// tmp := mc_crates_collector [ i ] else
73548: LD_ADDR_VAR 0 5
73552: PUSH
73553: LD_EXP 78
73557: PUSH
73558: LD_VAR 0 2
73562: ARRAY
73563: ST_TO_ADDR
73564: GO 73580
// tmp := target [ 1 ] ;
73566: LD_ADDR_VAR 0 5
73570: PUSH
73571: LD_VAR 0 7
73575: PUSH
73576: LD_INT 1
73578: ARRAY
73579: ST_TO_ADDR
// k := 0 ;
73580: LD_ADDR_VAR 0 4
73584: PUSH
73585: LD_INT 0
73587: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
73588: LD_ADDR_VAR 0 3
73592: PUSH
73593: LD_EXP 78
73597: PUSH
73598: LD_VAR 0 2
73602: ARRAY
73603: PUSH
73604: FOR_IN
73605: IFFALSE 73828
// begin k := k + 1 ;
73607: LD_ADDR_VAR 0 4
73611: PUSH
73612: LD_VAR 0 4
73616: PUSH
73617: LD_INT 1
73619: PLUS
73620: ST_TO_ADDR
// if k > tmp then
73621: LD_VAR 0 4
73625: PUSH
73626: LD_VAR 0 5
73630: GREATER
73631: IFFALSE 73635
// break ;
73633: GO 73828
// if not GetClass ( j ) in [ 2 , 16 ] then
73635: LD_VAR 0 3
73639: PPUSH
73640: CALL_OW 257
73644: PUSH
73645: LD_INT 2
73647: PUSH
73648: LD_INT 16
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: IN
73655: NOT
73656: IFFALSE 73709
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
73658: LD_ADDR_EXP 78
73662: PUSH
73663: LD_EXP 78
73667: PPUSH
73668: LD_VAR 0 2
73672: PPUSH
73673: LD_EXP 78
73677: PUSH
73678: LD_VAR 0 2
73682: ARRAY
73683: PUSH
73684: LD_VAR 0 3
73688: DIFF
73689: PPUSH
73690: CALL_OW 1
73694: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73695: LD_VAR 0 3
73699: PPUSH
73700: LD_INT 0
73702: PPUSH
73703: CALL_OW 109
// continue ;
73707: GO 73604
// end ; if IsInUnit ( j ) then
73709: LD_VAR 0 3
73713: PPUSH
73714: CALL_OW 310
73718: IFFALSE 73729
// ComExitBuilding ( j ) ;
73720: LD_VAR 0 3
73724: PPUSH
73725: CALL_OW 122
// wait ( 3 ) ;
73729: LD_INT 3
73731: PPUSH
73732: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
73736: LD_VAR 0 3
73740: PPUSH
73741: CALL_OW 314
73745: PUSH
73746: LD_VAR 0 6
73750: PPUSH
73751: LD_VAR 0 7
73755: PUSH
73756: LD_INT 2
73758: ARRAY
73759: PPUSH
73760: LD_VAR 0 7
73764: PUSH
73765: LD_INT 3
73767: ARRAY
73768: PPUSH
73769: LD_INT 30
73771: PPUSH
73772: CALL 22661 0 4
73776: PUSH
73777: LD_INT 4
73779: ARRAY
73780: AND
73781: IFFALSE 73799
// ComStandNearbyBuilding ( j , depot ) else
73783: LD_VAR 0 3
73787: PPUSH
73788: LD_VAR 0 9
73792: PPUSH
73793: CALL 17999 0 2
73797: GO 73826
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73799: LD_VAR 0 3
73803: PPUSH
73804: LD_VAR 0 7
73808: PUSH
73809: LD_INT 2
73811: ARRAY
73812: PPUSH
73813: LD_VAR 0 7
73817: PUSH
73818: LD_INT 3
73820: ARRAY
73821: PPUSH
73822: CALL_OW 117
// end ;
73826: GO 73604
73828: POP
73829: POP
// end ; end else
73830: GO 74362
// begin for j in cargo do
73832: LD_ADDR_VAR 0 3
73836: PUSH
73837: LD_VAR 0 8
73841: PUSH
73842: FOR_IN
73843: IFFALSE 74360
// begin if GetTag ( j ) <> 0 then
73845: LD_VAR 0 3
73849: PPUSH
73850: CALL_OW 110
73854: PUSH
73855: LD_INT 0
73857: NONEQUAL
73858: IFFALSE 73862
// continue ;
73860: GO 73842
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
73862: LD_VAR 0 3
73866: PPUSH
73867: CALL_OW 256
73871: PUSH
73872: LD_INT 1000
73874: LESS
73875: PUSH
73876: LD_VAR 0 3
73880: PPUSH
73881: LD_EXP 85
73885: PUSH
73886: LD_VAR 0 2
73890: ARRAY
73891: PPUSH
73892: CALL_OW 308
73896: NOT
73897: AND
73898: IFFALSE 73920
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73900: LD_VAR 0 3
73904: PPUSH
73905: LD_EXP 85
73909: PUSH
73910: LD_VAR 0 2
73914: ARRAY
73915: PPUSH
73916: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
73920: LD_VAR 0 3
73924: PPUSH
73925: CALL_OW 256
73929: PUSH
73930: LD_INT 1000
73932: LESS
73933: PUSH
73934: LD_VAR 0 3
73938: PPUSH
73939: LD_EXP 85
73943: PUSH
73944: LD_VAR 0 2
73948: ARRAY
73949: PPUSH
73950: CALL_OW 308
73954: AND
73955: IFFALSE 73959
// continue ;
73957: GO 73842
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
73959: LD_VAR 0 3
73963: PPUSH
73964: CALL_OW 262
73968: PUSH
73969: LD_INT 2
73971: EQUAL
73972: PUSH
73973: LD_VAR 0 3
73977: PPUSH
73978: CALL_OW 261
73982: PUSH
73983: LD_INT 15
73985: LESS
73986: AND
73987: IFFALSE 73991
// continue ;
73989: GO 73842
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
73991: LD_VAR 0 3
73995: PPUSH
73996: CALL_OW 262
74000: PUSH
74001: LD_INT 1
74003: EQUAL
74004: PUSH
74005: LD_VAR 0 3
74009: PPUSH
74010: CALL_OW 261
74014: PUSH
74015: LD_INT 10
74017: LESS
74018: AND
74019: IFFALSE 74299
// begin if not depot then
74021: LD_VAR 0 9
74025: NOT
74026: IFFALSE 74030
// continue ;
74028: GO 73842
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74030: LD_VAR 0 3
74034: PPUSH
74035: LD_VAR 0 9
74039: PPUSH
74040: LD_VAR 0 3
74044: PPUSH
74045: CALL_OW 74
74049: PPUSH
74050: CALL_OW 296
74054: PUSH
74055: LD_INT 6
74057: LESS
74058: IFFALSE 74074
// SetFuel ( j , 100 ) else
74060: LD_VAR 0 3
74064: PPUSH
74065: LD_INT 100
74067: PPUSH
74068: CALL_OW 240
74072: GO 74299
// if GetFuel ( j ) = 0 then
74074: LD_VAR 0 3
74078: PPUSH
74079: CALL_OW 261
74083: PUSH
74084: LD_INT 0
74086: EQUAL
74087: IFFALSE 74299
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74089: LD_ADDR_EXP 80
74093: PUSH
74094: LD_EXP 80
74098: PPUSH
74099: LD_VAR 0 2
74103: PPUSH
74104: LD_EXP 80
74108: PUSH
74109: LD_VAR 0 2
74113: ARRAY
74114: PUSH
74115: LD_VAR 0 3
74119: DIFF
74120: PPUSH
74121: CALL_OW 1
74125: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
74126: LD_VAR 0 3
74130: PPUSH
74131: CALL_OW 263
74135: PUSH
74136: LD_INT 1
74138: EQUAL
74139: IFFALSE 74155
// ComExitVehicle ( IsInUnit ( j ) ) ;
74141: LD_VAR 0 3
74145: PPUSH
74146: CALL_OW 310
74150: PPUSH
74151: CALL_OW 121
// if GetControl ( j ) = control_remote then
74155: LD_VAR 0 3
74159: PPUSH
74160: CALL_OW 263
74164: PUSH
74165: LD_INT 2
74167: EQUAL
74168: IFFALSE 74179
// ComUnlink ( j ) ;
74170: LD_VAR 0 3
74174: PPUSH
74175: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
74179: LD_ADDR_VAR 0 10
74183: PUSH
74184: LD_VAR 0 2
74188: PPUSH
74189: LD_INT 3
74191: PPUSH
74192: CALL 83943 0 2
74196: ST_TO_ADDR
// if fac then
74197: LD_VAR 0 10
74201: IFFALSE 74297
// begin for k in fac do
74203: LD_ADDR_VAR 0 4
74207: PUSH
74208: LD_VAR 0 10
74212: PUSH
74213: FOR_IN
74214: IFFALSE 74295
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
74216: LD_ADDR_VAR 0 11
74220: PUSH
74221: LD_VAR 0 10
74225: PPUSH
74226: LD_VAR 0 3
74230: PPUSH
74231: CALL_OW 265
74235: PPUSH
74236: LD_VAR 0 3
74240: PPUSH
74241: CALL_OW 262
74245: PPUSH
74246: LD_VAR 0 3
74250: PPUSH
74251: CALL_OW 263
74255: PPUSH
74256: LD_VAR 0 3
74260: PPUSH
74261: CALL_OW 264
74265: PPUSH
74266: CALL 18895 0 5
74270: ST_TO_ADDR
// if components then
74271: LD_VAR 0 11
74275: IFFALSE 74293
// begin MC_InsertProduceList ( i , components ) ;
74277: LD_VAR 0 2
74281: PPUSH
74282: LD_VAR 0 11
74286: PPUSH
74287: CALL 83488 0 2
// break ;
74291: GO 74295
// end ; end ;
74293: GO 74213
74295: POP
74296: POP
// end ; continue ;
74297: GO 73842
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
74299: LD_VAR 0 3
74303: PPUSH
74304: LD_INT 1
74306: PPUSH
74307: CALL_OW 289
74311: PUSH
74312: LD_INT 100
74314: LESS
74315: PUSH
74316: LD_VAR 0 3
74320: PPUSH
74321: CALL_OW 314
74325: NOT
74326: AND
74327: IFFALSE 74356
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74329: LD_VAR 0 3
74333: PPUSH
74334: LD_VAR 0 7
74338: PUSH
74339: LD_INT 2
74341: ARRAY
74342: PPUSH
74343: LD_VAR 0 7
74347: PUSH
74348: LD_INT 3
74350: ARRAY
74351: PPUSH
74352: CALL_OW 117
// break ;
74356: GO 74360
// end ;
74358: GO 73842
74360: POP
74361: POP
// end ; end ;
74362: GO 72558
74364: POP
74365: POP
// end ;
74366: LD_VAR 0 1
74370: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
74371: LD_INT 0
74373: PPUSH
74374: PPUSH
74375: PPUSH
74376: PPUSH
// if not mc_bases then
74377: LD_EXP 61
74381: NOT
74382: IFFALSE 74386
// exit ;
74384: GO 74547
// for i = 1 to mc_bases do
74386: LD_ADDR_VAR 0 2
74390: PUSH
74391: DOUBLE
74392: LD_INT 1
74394: DEC
74395: ST_TO_ADDR
74396: LD_EXP 61
74400: PUSH
74401: FOR_TO
74402: IFFALSE 74545
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
74404: LD_ADDR_VAR 0 4
74408: PUSH
74409: LD_EXP 80
74413: PUSH
74414: LD_VAR 0 2
74418: ARRAY
74419: PUSH
74420: LD_EXP 83
74424: PUSH
74425: LD_VAR 0 2
74429: ARRAY
74430: UNION
74431: PPUSH
74432: LD_INT 33
74434: PUSH
74435: LD_INT 2
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PPUSH
74442: CALL_OW 72
74446: ST_TO_ADDR
// if tmp then
74447: LD_VAR 0 4
74451: IFFALSE 74543
// for j in tmp do
74453: LD_ADDR_VAR 0 3
74457: PUSH
74458: LD_VAR 0 4
74462: PUSH
74463: FOR_IN
74464: IFFALSE 74541
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
74466: LD_VAR 0 3
74470: PPUSH
74471: CALL_OW 312
74475: NOT
74476: PUSH
74477: LD_VAR 0 3
74481: PPUSH
74482: CALL_OW 256
74486: PUSH
74487: LD_INT 250
74489: GREATEREQUAL
74490: AND
74491: IFFALSE 74504
// Connect ( j ) else
74493: LD_VAR 0 3
74497: PPUSH
74498: CALL 24743 0 1
74502: GO 74539
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
74504: LD_VAR 0 3
74508: PPUSH
74509: CALL_OW 256
74513: PUSH
74514: LD_INT 250
74516: LESS
74517: PUSH
74518: LD_VAR 0 3
74522: PPUSH
74523: CALL_OW 312
74527: AND
74528: IFFALSE 74539
// ComUnlink ( j ) ;
74530: LD_VAR 0 3
74534: PPUSH
74535: CALL_OW 136
74539: GO 74463
74541: POP
74542: POP
// end ;
74543: GO 74401
74545: POP
74546: POP
// end ;
74547: LD_VAR 0 1
74551: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
74552: LD_INT 0
74554: PPUSH
74555: PPUSH
74556: PPUSH
74557: PPUSH
74558: PPUSH
// if not mc_bases then
74559: LD_EXP 61
74563: NOT
74564: IFFALSE 74568
// exit ;
74566: GO 75013
// for i = 1 to mc_bases do
74568: LD_ADDR_VAR 0 2
74572: PUSH
74573: DOUBLE
74574: LD_INT 1
74576: DEC
74577: ST_TO_ADDR
74578: LD_EXP 61
74582: PUSH
74583: FOR_TO
74584: IFFALSE 75011
// begin if not mc_produce [ i ] then
74586: LD_EXP 82
74590: PUSH
74591: LD_VAR 0 2
74595: ARRAY
74596: NOT
74597: IFFALSE 74601
// continue ;
74599: GO 74583
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74601: LD_ADDR_VAR 0 5
74605: PUSH
74606: LD_EXP 61
74610: PUSH
74611: LD_VAR 0 2
74615: ARRAY
74616: PPUSH
74617: LD_INT 30
74619: PUSH
74620: LD_INT 3
74622: PUSH
74623: EMPTY
74624: LIST
74625: LIST
74626: PPUSH
74627: CALL_OW 72
74631: ST_TO_ADDR
// if not fac then
74632: LD_VAR 0 5
74636: NOT
74637: IFFALSE 74641
// continue ;
74639: GO 74583
// for j in fac do
74641: LD_ADDR_VAR 0 3
74645: PUSH
74646: LD_VAR 0 5
74650: PUSH
74651: FOR_IN
74652: IFFALSE 75007
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
74654: LD_VAR 0 3
74658: PPUSH
74659: CALL_OW 461
74663: PUSH
74664: LD_INT 2
74666: NONEQUAL
74667: PUSH
74668: LD_VAR 0 3
74672: PPUSH
74673: LD_INT 15
74675: PPUSH
74676: CALL 24362 0 2
74680: PUSH
74681: LD_INT 4
74683: ARRAY
74684: OR
74685: IFFALSE 74689
// continue ;
74687: GO 74651
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
74689: LD_VAR 0 3
74693: PPUSH
74694: LD_EXP 82
74698: PUSH
74699: LD_VAR 0 2
74703: ARRAY
74704: PUSH
74705: LD_INT 1
74707: ARRAY
74708: PUSH
74709: LD_INT 1
74711: ARRAY
74712: PPUSH
74713: LD_EXP 82
74717: PUSH
74718: LD_VAR 0 2
74722: ARRAY
74723: PUSH
74724: LD_INT 1
74726: ARRAY
74727: PUSH
74728: LD_INT 2
74730: ARRAY
74731: PPUSH
74732: LD_EXP 82
74736: PUSH
74737: LD_VAR 0 2
74741: ARRAY
74742: PUSH
74743: LD_INT 1
74745: ARRAY
74746: PUSH
74747: LD_INT 3
74749: ARRAY
74750: PPUSH
74751: LD_EXP 82
74755: PUSH
74756: LD_VAR 0 2
74760: ARRAY
74761: PUSH
74762: LD_INT 1
74764: ARRAY
74765: PUSH
74766: LD_INT 4
74768: ARRAY
74769: PPUSH
74770: CALL_OW 448
74774: PUSH
74775: LD_VAR 0 3
74779: PPUSH
74780: LD_EXP 82
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: PUSH
74791: LD_INT 1
74793: ARRAY
74794: PUSH
74795: LD_INT 1
74797: ARRAY
74798: PUSH
74799: LD_EXP 82
74803: PUSH
74804: LD_VAR 0 2
74808: ARRAY
74809: PUSH
74810: LD_INT 1
74812: ARRAY
74813: PUSH
74814: LD_INT 2
74816: ARRAY
74817: PUSH
74818: LD_EXP 82
74822: PUSH
74823: LD_VAR 0 2
74827: ARRAY
74828: PUSH
74829: LD_INT 1
74831: ARRAY
74832: PUSH
74833: LD_INT 3
74835: ARRAY
74836: PUSH
74837: LD_EXP 82
74841: PUSH
74842: LD_VAR 0 2
74846: ARRAY
74847: PUSH
74848: LD_INT 1
74850: ARRAY
74851: PUSH
74852: LD_INT 4
74854: ARRAY
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: PPUSH
74862: CALL 28138 0 2
74866: AND
74867: IFFALSE 75005
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
74869: LD_VAR 0 3
74873: PPUSH
74874: LD_EXP 82
74878: PUSH
74879: LD_VAR 0 2
74883: ARRAY
74884: PUSH
74885: LD_INT 1
74887: ARRAY
74888: PUSH
74889: LD_INT 1
74891: ARRAY
74892: PPUSH
74893: LD_EXP 82
74897: PUSH
74898: LD_VAR 0 2
74902: ARRAY
74903: PUSH
74904: LD_INT 1
74906: ARRAY
74907: PUSH
74908: LD_INT 2
74910: ARRAY
74911: PPUSH
74912: LD_EXP 82
74916: PUSH
74917: LD_VAR 0 2
74921: ARRAY
74922: PUSH
74923: LD_INT 1
74925: ARRAY
74926: PUSH
74927: LD_INT 3
74929: ARRAY
74930: PPUSH
74931: LD_EXP 82
74935: PUSH
74936: LD_VAR 0 2
74940: ARRAY
74941: PUSH
74942: LD_INT 1
74944: ARRAY
74945: PUSH
74946: LD_INT 4
74948: ARRAY
74949: PPUSH
74950: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
74954: LD_ADDR_VAR 0 4
74958: PUSH
74959: LD_EXP 82
74963: PUSH
74964: LD_VAR 0 2
74968: ARRAY
74969: PPUSH
74970: LD_INT 1
74972: PPUSH
74973: CALL_OW 3
74977: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74978: LD_ADDR_EXP 82
74982: PUSH
74983: LD_EXP 82
74987: PPUSH
74988: LD_VAR 0 2
74992: PPUSH
74993: LD_VAR 0 4
74997: PPUSH
74998: CALL_OW 1
75002: ST_TO_ADDR
// break ;
75003: GO 75007
// end ; end ;
75005: GO 74651
75007: POP
75008: POP
// end ;
75009: GO 74583
75011: POP
75012: POP
// end ;
75013: LD_VAR 0 1
75017: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75018: LD_INT 0
75020: PPUSH
75021: PPUSH
75022: PPUSH
// if not mc_bases then
75023: LD_EXP 61
75027: NOT
75028: IFFALSE 75032
// exit ;
75030: GO 75121
// for i = 1 to mc_bases do
75032: LD_ADDR_VAR 0 2
75036: PUSH
75037: DOUBLE
75038: LD_INT 1
75040: DEC
75041: ST_TO_ADDR
75042: LD_EXP 61
75046: PUSH
75047: FOR_TO
75048: IFFALSE 75119
// begin if mc_attack [ i ] then
75050: LD_EXP 81
75054: PUSH
75055: LD_VAR 0 2
75059: ARRAY
75060: IFFALSE 75117
// begin tmp := mc_attack [ i ] [ 1 ] ;
75062: LD_ADDR_VAR 0 3
75066: PUSH
75067: LD_EXP 81
75071: PUSH
75072: LD_VAR 0 2
75076: ARRAY
75077: PUSH
75078: LD_INT 1
75080: ARRAY
75081: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75082: LD_ADDR_EXP 81
75086: PUSH
75087: LD_EXP 81
75091: PPUSH
75092: LD_VAR 0 2
75096: PPUSH
75097: EMPTY
75098: PPUSH
75099: CALL_OW 1
75103: ST_TO_ADDR
// Attack ( tmp ) ;
75104: LD_VAR 0 3
75108: PPUSH
75109: CALL 110627 0 1
// exit ;
75113: POP
75114: POP
75115: GO 75121
// end ; end ;
75117: GO 75047
75119: POP
75120: POP
// end ;
75121: LD_VAR 0 1
75125: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
75126: LD_INT 0
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
// if not mc_bases then
75135: LD_EXP 61
75139: NOT
75140: IFFALSE 75144
// exit ;
75142: GO 76001
// for i = 1 to mc_bases do
75144: LD_ADDR_VAR 0 2
75148: PUSH
75149: DOUBLE
75150: LD_INT 1
75152: DEC
75153: ST_TO_ADDR
75154: LD_EXP 61
75158: PUSH
75159: FOR_TO
75160: IFFALSE 75999
// begin if not mc_bases [ i ] then
75162: LD_EXP 61
75166: PUSH
75167: LD_VAR 0 2
75171: ARRAY
75172: NOT
75173: IFFALSE 75177
// continue ;
75175: GO 75159
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
75177: LD_ADDR_VAR 0 7
75181: PUSH
75182: LD_EXP 61
75186: PUSH
75187: LD_VAR 0 2
75191: ARRAY
75192: PUSH
75193: LD_INT 1
75195: ARRAY
75196: PPUSH
75197: CALL 18221 0 1
75201: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
75202: LD_ADDR_EXP 84
75206: PUSH
75207: LD_EXP 84
75211: PPUSH
75212: LD_VAR 0 2
75216: PPUSH
75217: LD_EXP 61
75221: PUSH
75222: LD_VAR 0 2
75226: ARRAY
75227: PUSH
75228: LD_INT 1
75230: ARRAY
75231: PPUSH
75232: CALL_OW 255
75236: PPUSH
75237: LD_EXP 86
75241: PUSH
75242: LD_VAR 0 2
75246: ARRAY
75247: PPUSH
75248: CALL 18186 0 2
75252: PPUSH
75253: CALL_OW 1
75257: ST_TO_ADDR
// if not mc_scan [ i ] then
75258: LD_EXP 84
75262: PUSH
75263: LD_VAR 0 2
75267: ARRAY
75268: NOT
75269: IFFALSE 75447
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
75271: LD_ADDR_EXP 104
75275: PUSH
75276: LD_EXP 104
75280: PPUSH
75281: LD_VAR 0 2
75285: PPUSH
75286: LD_INT 0
75288: PPUSH
75289: CALL_OW 1
75293: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75294: LD_ADDR_VAR 0 4
75298: PUSH
75299: LD_EXP 61
75303: PUSH
75304: LD_VAR 0 2
75308: ARRAY
75309: PPUSH
75310: LD_INT 2
75312: PUSH
75313: LD_INT 25
75315: PUSH
75316: LD_INT 5
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 25
75325: PUSH
75326: LD_INT 8
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 25
75335: PUSH
75336: LD_INT 9
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: PPUSH
75349: CALL_OW 72
75353: ST_TO_ADDR
// if not tmp then
75354: LD_VAR 0 4
75358: NOT
75359: IFFALSE 75363
// continue ;
75361: GO 75159
// for j in tmp do
75363: LD_ADDR_VAR 0 3
75367: PUSH
75368: LD_VAR 0 4
75372: PUSH
75373: FOR_IN
75374: IFFALSE 75445
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
75376: LD_VAR 0 3
75380: PPUSH
75381: CALL_OW 310
75385: PPUSH
75386: CALL_OW 266
75390: PUSH
75391: LD_INT 5
75393: EQUAL
75394: PUSH
75395: LD_VAR 0 3
75399: PPUSH
75400: CALL_OW 257
75404: PUSH
75405: LD_INT 1
75407: EQUAL
75408: AND
75409: PUSH
75410: LD_VAR 0 3
75414: PPUSH
75415: CALL_OW 459
75419: NOT
75420: AND
75421: PUSH
75422: LD_VAR 0 7
75426: AND
75427: IFFALSE 75443
// ComChangeProfession ( j , class ) ;
75429: LD_VAR 0 3
75433: PPUSH
75434: LD_VAR 0 7
75438: PPUSH
75439: CALL_OW 123
75443: GO 75373
75445: POP
75446: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
75447: LD_EXP 84
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PUSH
75458: LD_EXP 104
75462: PUSH
75463: LD_VAR 0 2
75467: ARRAY
75468: NOT
75469: AND
75470: PUSH
75471: LD_EXP 83
75475: PUSH
75476: LD_VAR 0 2
75480: ARRAY
75481: NOT
75482: AND
75483: PUSH
75484: LD_EXP 61
75488: PUSH
75489: LD_VAR 0 2
75493: ARRAY
75494: PPUSH
75495: LD_INT 50
75497: PUSH
75498: EMPTY
75499: LIST
75500: PUSH
75501: LD_INT 2
75503: PUSH
75504: LD_INT 30
75506: PUSH
75507: LD_INT 32
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 30
75516: PUSH
75517: LD_INT 33
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 30
75526: PUSH
75527: LD_INT 4
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 30
75536: PUSH
75537: LD_INT 5
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PPUSH
75555: CALL_OW 72
75559: PUSH
75560: LD_INT 4
75562: LESS
75563: PUSH
75564: LD_EXP 61
75568: PUSH
75569: LD_VAR 0 2
75573: ARRAY
75574: PPUSH
75575: LD_INT 3
75577: PUSH
75578: LD_INT 24
75580: PUSH
75581: LD_INT 1000
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: PUSH
75595: LD_INT 30
75597: PUSH
75598: LD_INT 0
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 30
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: LIST
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PPUSH
75624: CALL_OW 72
75628: OR
75629: AND
75630: IFFALSE 75881
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75632: LD_ADDR_EXP 104
75636: PUSH
75637: LD_EXP 104
75641: PPUSH
75642: LD_VAR 0 2
75646: PPUSH
75647: LD_INT 1
75649: PPUSH
75650: CALL_OW 1
75654: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75655: LD_ADDR_VAR 0 4
75659: PUSH
75660: LD_EXP 61
75664: PUSH
75665: LD_VAR 0 2
75669: ARRAY
75670: PPUSH
75671: LD_INT 2
75673: PUSH
75674: LD_INT 25
75676: PUSH
75677: LD_INT 1
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 25
75686: PUSH
75687: LD_INT 5
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 25
75696: PUSH
75697: LD_INT 8
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 25
75706: PUSH
75707: LD_INT 9
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: PPUSH
75721: CALL_OW 72
75725: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
75726: LD_ADDR_VAR 0 4
75730: PUSH
75731: LD_VAR 0 4
75735: PUSH
75736: LD_VAR 0 4
75740: PPUSH
75741: LD_INT 18
75743: PPUSH
75744: CALL 51695 0 2
75748: DIFF
75749: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
75750: LD_VAR 0 4
75754: NOT
75755: PUSH
75756: LD_EXP 61
75760: PUSH
75761: LD_VAR 0 2
75765: ARRAY
75766: PPUSH
75767: LD_INT 2
75769: PUSH
75770: LD_INT 30
75772: PUSH
75773: LD_INT 4
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 30
75782: PUSH
75783: LD_INT 5
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: LIST
75794: PPUSH
75795: CALL_OW 72
75799: NOT
75800: AND
75801: IFFALSE 75863
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
75803: LD_ADDR_VAR 0 4
75807: PUSH
75808: LD_EXP 61
75812: PUSH
75813: LD_VAR 0 2
75817: ARRAY
75818: PPUSH
75819: LD_INT 2
75821: PUSH
75822: LD_INT 25
75824: PUSH
75825: LD_INT 2
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 25
75834: PUSH
75835: LD_INT 3
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 25
75844: PUSH
75845: LD_INT 4
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: PPUSH
75858: CALL_OW 72
75862: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
75863: LD_VAR 0 2
75867: PPUSH
75868: LD_VAR 0 4
75872: PPUSH
75873: CALL 115336 0 2
// exit ;
75877: POP
75878: POP
75879: GO 76001
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
75881: LD_EXP 84
75885: PUSH
75886: LD_VAR 0 2
75890: ARRAY
75891: PUSH
75892: LD_EXP 104
75896: PUSH
75897: LD_VAR 0 2
75901: ARRAY
75902: NOT
75903: AND
75904: PUSH
75905: LD_EXP 83
75909: PUSH
75910: LD_VAR 0 2
75914: ARRAY
75915: AND
75916: IFFALSE 75997
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75918: LD_ADDR_EXP 104
75922: PUSH
75923: LD_EXP 104
75927: PPUSH
75928: LD_VAR 0 2
75932: PPUSH
75933: LD_INT 1
75935: PPUSH
75936: CALL_OW 1
75940: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
75941: LD_ADDR_VAR 0 4
75945: PUSH
75946: LD_EXP 83
75950: PUSH
75951: LD_VAR 0 2
75955: ARRAY
75956: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
75957: LD_ADDR_EXP 83
75961: PUSH
75962: LD_EXP 83
75966: PPUSH
75967: LD_VAR 0 2
75971: PPUSH
75972: EMPTY
75973: PPUSH
75974: CALL_OW 1
75978: ST_TO_ADDR
// Defend ( i , tmp ) ;
75979: LD_VAR 0 2
75983: PPUSH
75984: LD_VAR 0 4
75988: PPUSH
75989: CALL 115932 0 2
// exit ;
75993: POP
75994: POP
75995: GO 76001
// end ; end ;
75997: GO 75159
75999: POP
76000: POP
// end ;
76001: LD_VAR 0 1
76005: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76006: LD_INT 0
76008: PPUSH
76009: PPUSH
76010: PPUSH
76011: PPUSH
76012: PPUSH
76013: PPUSH
76014: PPUSH
76015: PPUSH
76016: PPUSH
76017: PPUSH
76018: PPUSH
// if not mc_bases then
76019: LD_EXP 61
76023: NOT
76024: IFFALSE 76028
// exit ;
76026: GO 77115
// for i = 1 to mc_bases do
76028: LD_ADDR_VAR 0 2
76032: PUSH
76033: DOUBLE
76034: LD_INT 1
76036: DEC
76037: ST_TO_ADDR
76038: LD_EXP 61
76042: PUSH
76043: FOR_TO
76044: IFFALSE 77113
// begin tmp := mc_lab [ i ] ;
76046: LD_ADDR_VAR 0 6
76050: PUSH
76051: LD_EXP 94
76055: PUSH
76056: LD_VAR 0 2
76060: ARRAY
76061: ST_TO_ADDR
// if not tmp then
76062: LD_VAR 0 6
76066: NOT
76067: IFFALSE 76071
// continue ;
76069: GO 76043
// idle_lab := 0 ;
76071: LD_ADDR_VAR 0 11
76075: PUSH
76076: LD_INT 0
76078: ST_TO_ADDR
// for j in tmp do
76079: LD_ADDR_VAR 0 3
76083: PUSH
76084: LD_VAR 0 6
76088: PUSH
76089: FOR_IN
76090: IFFALSE 77109
// begin researching := false ;
76092: LD_ADDR_VAR 0 10
76096: PUSH
76097: LD_INT 0
76099: ST_TO_ADDR
// side := GetSide ( j ) ;
76100: LD_ADDR_VAR 0 4
76104: PUSH
76105: LD_VAR 0 3
76109: PPUSH
76110: CALL_OW 255
76114: ST_TO_ADDR
// if not mc_tech [ side ] then
76115: LD_EXP 88
76119: PUSH
76120: LD_VAR 0 4
76124: ARRAY
76125: NOT
76126: IFFALSE 76130
// continue ;
76128: GO 76089
// if BuildingStatus ( j ) = bs_idle then
76130: LD_VAR 0 3
76134: PPUSH
76135: CALL_OW 461
76139: PUSH
76140: LD_INT 2
76142: EQUAL
76143: IFFALSE 76331
// begin if idle_lab and UnitsInside ( j ) < 6 then
76145: LD_VAR 0 11
76149: PUSH
76150: LD_VAR 0 3
76154: PPUSH
76155: CALL_OW 313
76159: PUSH
76160: LD_INT 6
76162: LESS
76163: AND
76164: IFFALSE 76235
// begin tmp2 := UnitsInside ( idle_lab ) ;
76166: LD_ADDR_VAR 0 9
76170: PUSH
76171: LD_VAR 0 11
76175: PPUSH
76176: CALL_OW 313
76180: ST_TO_ADDR
// if tmp2 then
76181: LD_VAR 0 9
76185: IFFALSE 76227
// for x in tmp2 do
76187: LD_ADDR_VAR 0 7
76191: PUSH
76192: LD_VAR 0 9
76196: PUSH
76197: FOR_IN
76198: IFFALSE 76225
// begin ComExitBuilding ( x ) ;
76200: LD_VAR 0 7
76204: PPUSH
76205: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76209: LD_VAR 0 7
76213: PPUSH
76214: LD_VAR 0 3
76218: PPUSH
76219: CALL_OW 180
// end ;
76223: GO 76197
76225: POP
76226: POP
// idle_lab := 0 ;
76227: LD_ADDR_VAR 0 11
76231: PUSH
76232: LD_INT 0
76234: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
76235: LD_ADDR_VAR 0 5
76239: PUSH
76240: LD_EXP 88
76244: PUSH
76245: LD_VAR 0 4
76249: ARRAY
76250: PUSH
76251: FOR_IN
76252: IFFALSE 76312
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
76254: LD_VAR 0 3
76258: PPUSH
76259: LD_VAR 0 5
76263: PPUSH
76264: CALL_OW 430
76268: PUSH
76269: LD_VAR 0 4
76273: PPUSH
76274: LD_VAR 0 5
76278: PPUSH
76279: CALL 17291 0 2
76283: AND
76284: IFFALSE 76310
// begin researching := true ;
76286: LD_ADDR_VAR 0 10
76290: PUSH
76291: LD_INT 1
76293: ST_TO_ADDR
// ComResearch ( j , t ) ;
76294: LD_VAR 0 3
76298: PPUSH
76299: LD_VAR 0 5
76303: PPUSH
76304: CALL_OW 124
// break ;
76308: GO 76312
// end ;
76310: GO 76251
76312: POP
76313: POP
// if not researching then
76314: LD_VAR 0 10
76318: NOT
76319: IFFALSE 76331
// idle_lab := j ;
76321: LD_ADDR_VAR 0 11
76325: PUSH
76326: LD_VAR 0 3
76330: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
76331: LD_VAR 0 3
76335: PPUSH
76336: CALL_OW 461
76340: PUSH
76341: LD_INT 10
76343: EQUAL
76344: IFFALSE 76932
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
76346: LD_EXP 90
76350: PUSH
76351: LD_VAR 0 2
76355: ARRAY
76356: NOT
76357: PUSH
76358: LD_EXP 91
76362: PUSH
76363: LD_VAR 0 2
76367: ARRAY
76368: NOT
76369: AND
76370: PUSH
76371: LD_EXP 88
76375: PUSH
76376: LD_VAR 0 4
76380: ARRAY
76381: PUSH
76382: LD_INT 1
76384: GREATER
76385: AND
76386: IFFALSE 76517
// begin ComCancel ( j ) ;
76388: LD_VAR 0 3
76392: PPUSH
76393: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
76397: LD_ADDR_EXP 88
76401: PUSH
76402: LD_EXP 88
76406: PPUSH
76407: LD_VAR 0 4
76411: PPUSH
76412: LD_EXP 88
76416: PUSH
76417: LD_VAR 0 4
76421: ARRAY
76422: PPUSH
76423: LD_EXP 88
76427: PUSH
76428: LD_VAR 0 4
76432: ARRAY
76433: PUSH
76434: LD_INT 1
76436: MINUS
76437: PPUSH
76438: LD_EXP 88
76442: PUSH
76443: LD_VAR 0 4
76447: ARRAY
76448: PPUSH
76449: LD_INT 0
76451: PPUSH
76452: CALL 20815 0 4
76456: PPUSH
76457: CALL_OW 1
76461: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
76462: LD_ADDR_EXP 88
76466: PUSH
76467: LD_EXP 88
76471: PPUSH
76472: LD_VAR 0 4
76476: PPUSH
76477: LD_EXP 88
76481: PUSH
76482: LD_VAR 0 4
76486: ARRAY
76487: PPUSH
76488: LD_EXP 88
76492: PUSH
76493: LD_VAR 0 4
76497: ARRAY
76498: PPUSH
76499: LD_INT 1
76501: PPUSH
76502: LD_INT 0
76504: PPUSH
76505: CALL 20815 0 4
76509: PPUSH
76510: CALL_OW 1
76514: ST_TO_ADDR
// continue ;
76515: GO 76089
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
76517: LD_EXP 90
76521: PUSH
76522: LD_VAR 0 2
76526: ARRAY
76527: PUSH
76528: LD_EXP 91
76532: PUSH
76533: LD_VAR 0 2
76537: ARRAY
76538: NOT
76539: AND
76540: IFFALSE 76667
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
76542: LD_ADDR_EXP 91
76546: PUSH
76547: LD_EXP 91
76551: PPUSH
76552: LD_VAR 0 2
76556: PUSH
76557: LD_EXP 91
76561: PUSH
76562: LD_VAR 0 2
76566: ARRAY
76567: PUSH
76568: LD_INT 1
76570: PLUS
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PPUSH
76576: LD_EXP 90
76580: PUSH
76581: LD_VAR 0 2
76585: ARRAY
76586: PUSH
76587: LD_INT 1
76589: ARRAY
76590: PPUSH
76591: CALL 21397 0 3
76595: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
76596: LD_EXP 90
76600: PUSH
76601: LD_VAR 0 2
76605: ARRAY
76606: PUSH
76607: LD_INT 1
76609: ARRAY
76610: PPUSH
76611: LD_INT 112
76613: PPUSH
76614: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
76618: LD_ADDR_VAR 0 9
76622: PUSH
76623: LD_EXP 90
76627: PUSH
76628: LD_VAR 0 2
76632: ARRAY
76633: PPUSH
76634: LD_INT 1
76636: PPUSH
76637: CALL_OW 3
76641: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
76642: LD_ADDR_EXP 90
76646: PUSH
76647: LD_EXP 90
76651: PPUSH
76652: LD_VAR 0 2
76656: PPUSH
76657: LD_VAR 0 9
76661: PPUSH
76662: CALL_OW 1
76666: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
76667: LD_EXP 90
76671: PUSH
76672: LD_VAR 0 2
76676: ARRAY
76677: PUSH
76678: LD_EXP 91
76682: PUSH
76683: LD_VAR 0 2
76687: ARRAY
76688: AND
76689: PUSH
76690: LD_EXP 91
76694: PUSH
76695: LD_VAR 0 2
76699: ARRAY
76700: PUSH
76701: LD_INT 1
76703: ARRAY
76704: PPUSH
76705: CALL_OW 310
76709: NOT
76710: AND
76711: PUSH
76712: LD_VAR 0 3
76716: PPUSH
76717: CALL_OW 313
76721: PUSH
76722: LD_INT 6
76724: EQUAL
76725: AND
76726: IFFALSE 76782
// begin tmp2 := UnitsInside ( j ) ;
76728: LD_ADDR_VAR 0 9
76732: PUSH
76733: LD_VAR 0 3
76737: PPUSH
76738: CALL_OW 313
76742: ST_TO_ADDR
// if tmp2 = 6 then
76743: LD_VAR 0 9
76747: PUSH
76748: LD_INT 6
76750: EQUAL
76751: IFFALSE 76782
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
76753: LD_VAR 0 9
76757: PUSH
76758: LD_INT 1
76760: ARRAY
76761: PPUSH
76762: LD_INT 112
76764: PPUSH
76765: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
76769: LD_VAR 0 9
76773: PUSH
76774: LD_INT 1
76776: ARRAY
76777: PPUSH
76778: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
76782: LD_EXP 91
76786: PUSH
76787: LD_VAR 0 2
76791: ARRAY
76792: PUSH
76793: LD_EXP 91
76797: PUSH
76798: LD_VAR 0 2
76802: ARRAY
76803: PUSH
76804: LD_INT 1
76806: ARRAY
76807: PPUSH
76808: CALL_OW 314
76812: NOT
76813: AND
76814: PUSH
76815: LD_EXP 91
76819: PUSH
76820: LD_VAR 0 2
76824: ARRAY
76825: PUSH
76826: LD_INT 1
76828: ARRAY
76829: PPUSH
76830: CALL_OW 310
76834: NOT
76835: AND
76836: IFFALSE 76862
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
76838: LD_EXP 91
76842: PUSH
76843: LD_VAR 0 2
76847: ARRAY
76848: PUSH
76849: LD_INT 1
76851: ARRAY
76852: PPUSH
76853: LD_VAR 0 3
76857: PPUSH
76858: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
76862: LD_EXP 91
76866: PUSH
76867: LD_VAR 0 2
76871: ARRAY
76872: PUSH
76873: LD_INT 1
76875: ARRAY
76876: PPUSH
76877: CALL_OW 310
76881: PUSH
76882: LD_EXP 91
76886: PUSH
76887: LD_VAR 0 2
76891: ARRAY
76892: PUSH
76893: LD_INT 1
76895: ARRAY
76896: PPUSH
76897: CALL_OW 310
76901: PPUSH
76902: CALL_OW 461
76906: PUSH
76907: LD_INT 3
76909: NONEQUAL
76910: AND
76911: IFFALSE 76932
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
76913: LD_EXP 91
76917: PUSH
76918: LD_VAR 0 2
76922: ARRAY
76923: PUSH
76924: LD_INT 1
76926: ARRAY
76927: PPUSH
76928: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
76932: LD_VAR 0 3
76936: PPUSH
76937: CALL_OW 461
76941: PUSH
76942: LD_INT 6
76944: EQUAL
76945: PUSH
76946: LD_VAR 0 6
76950: PUSH
76951: LD_INT 1
76953: GREATER
76954: AND
76955: IFFALSE 77107
// begin sci := [ ] ;
76957: LD_ADDR_VAR 0 8
76961: PUSH
76962: EMPTY
76963: ST_TO_ADDR
// for x in ( tmp diff j ) do
76964: LD_ADDR_VAR 0 7
76968: PUSH
76969: LD_VAR 0 6
76973: PUSH
76974: LD_VAR 0 3
76978: DIFF
76979: PUSH
76980: FOR_IN
76981: IFFALSE 77033
// begin if sci = 6 then
76983: LD_VAR 0 8
76987: PUSH
76988: LD_INT 6
76990: EQUAL
76991: IFFALSE 76995
// break ;
76993: GO 77033
// if BuildingStatus ( x ) = bs_idle then
76995: LD_VAR 0 7
76999: PPUSH
77000: CALL_OW 461
77004: PUSH
77005: LD_INT 2
77007: EQUAL
77008: IFFALSE 77031
// sci := sci ^ UnitsInside ( x ) ;
77010: LD_ADDR_VAR 0 8
77014: PUSH
77015: LD_VAR 0 8
77019: PUSH
77020: LD_VAR 0 7
77024: PPUSH
77025: CALL_OW 313
77029: ADD
77030: ST_TO_ADDR
// end ;
77031: GO 76980
77033: POP
77034: POP
// if not sci then
77035: LD_VAR 0 8
77039: NOT
77040: IFFALSE 77044
// continue ;
77042: GO 76089
// for x in sci do
77044: LD_ADDR_VAR 0 7
77048: PUSH
77049: LD_VAR 0 8
77053: PUSH
77054: FOR_IN
77055: IFFALSE 77105
// if IsInUnit ( x ) and not HasTask ( x ) then
77057: LD_VAR 0 7
77061: PPUSH
77062: CALL_OW 310
77066: PUSH
77067: LD_VAR 0 7
77071: PPUSH
77072: CALL_OW 314
77076: NOT
77077: AND
77078: IFFALSE 77103
// begin ComExitBuilding ( x ) ;
77080: LD_VAR 0 7
77084: PPUSH
77085: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77089: LD_VAR 0 7
77093: PPUSH
77094: LD_VAR 0 3
77098: PPUSH
77099: CALL_OW 180
// end ;
77103: GO 77054
77105: POP
77106: POP
// end ; end ;
77107: GO 76089
77109: POP
77110: POP
// end ;
77111: GO 76043
77113: POP
77114: POP
// end ;
77115: LD_VAR 0 1
77119: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
77120: LD_INT 0
77122: PPUSH
77123: PPUSH
// if not mc_bases then
77124: LD_EXP 61
77128: NOT
77129: IFFALSE 77133
// exit ;
77131: GO 77214
// for i = 1 to mc_bases do
77133: LD_ADDR_VAR 0 2
77137: PUSH
77138: DOUBLE
77139: LD_INT 1
77141: DEC
77142: ST_TO_ADDR
77143: LD_EXP 61
77147: PUSH
77148: FOR_TO
77149: IFFALSE 77212
// if mc_mines [ i ] and mc_miners [ i ] then
77151: LD_EXP 74
77155: PUSH
77156: LD_VAR 0 2
77160: ARRAY
77161: PUSH
77162: LD_EXP 75
77166: PUSH
77167: LD_VAR 0 2
77171: ARRAY
77172: AND
77173: IFFALSE 77210
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
77175: LD_EXP 75
77179: PUSH
77180: LD_VAR 0 2
77184: ARRAY
77185: PUSH
77186: LD_INT 1
77188: ARRAY
77189: PPUSH
77190: CALL_OW 255
77194: PPUSH
77195: LD_EXP 74
77199: PUSH
77200: LD_VAR 0 2
77204: ARRAY
77205: PPUSH
77206: CALL 18374 0 2
77210: GO 77148
77212: POP
77213: POP
// end ;
77214: LD_VAR 0 1
77218: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
77219: LD_INT 0
77221: PPUSH
77222: PPUSH
77223: PPUSH
77224: PPUSH
77225: PPUSH
77226: PPUSH
77227: PPUSH
77228: PPUSH
// if not mc_bases or not mc_parking then
77229: LD_EXP 61
77233: NOT
77234: PUSH
77235: LD_EXP 85
77239: NOT
77240: OR
77241: IFFALSE 77245
// exit ;
77243: GO 77983
// for i = 1 to mc_bases do
77245: LD_ADDR_VAR 0 2
77249: PUSH
77250: DOUBLE
77251: LD_INT 1
77253: DEC
77254: ST_TO_ADDR
77255: LD_EXP 61
77259: PUSH
77260: FOR_TO
77261: IFFALSE 77981
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
77263: LD_EXP 61
77267: PUSH
77268: LD_VAR 0 2
77272: ARRAY
77273: NOT
77274: PUSH
77275: LD_EXP 85
77279: PUSH
77280: LD_VAR 0 2
77284: ARRAY
77285: NOT
77286: OR
77287: IFFALSE 77291
// continue ;
77289: GO 77260
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77291: LD_ADDR_VAR 0 5
77295: PUSH
77296: LD_EXP 61
77300: PUSH
77301: LD_VAR 0 2
77305: ARRAY
77306: PUSH
77307: LD_INT 1
77309: ARRAY
77310: PPUSH
77311: CALL_OW 255
77315: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77316: LD_ADDR_VAR 0 6
77320: PUSH
77321: LD_EXP 61
77325: PUSH
77326: LD_VAR 0 2
77330: ARRAY
77331: PPUSH
77332: LD_INT 30
77334: PUSH
77335: LD_INT 3
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PPUSH
77342: CALL_OW 72
77346: ST_TO_ADDR
// if not fac then
77347: LD_VAR 0 6
77351: NOT
77352: IFFALSE 77403
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77354: LD_ADDR_VAR 0 6
77358: PUSH
77359: LD_EXP 61
77363: PUSH
77364: LD_VAR 0 2
77368: ARRAY
77369: PPUSH
77370: LD_INT 2
77372: PUSH
77373: LD_INT 30
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 30
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: LIST
77397: PPUSH
77398: CALL_OW 72
77402: ST_TO_ADDR
// if not fac then
77403: LD_VAR 0 6
77407: NOT
77408: IFFALSE 77412
// continue ;
77410: GO 77260
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77412: LD_ADDR_VAR 0 7
77416: PUSH
77417: LD_EXP 85
77421: PUSH
77422: LD_VAR 0 2
77426: ARRAY
77427: PPUSH
77428: LD_INT 22
77430: PUSH
77431: LD_VAR 0 5
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 21
77442: PUSH
77443: LD_INT 2
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 3
77452: PUSH
77453: LD_INT 60
77455: PUSH
77456: EMPTY
77457: LIST
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 3
77465: PUSH
77466: LD_INT 24
77468: PUSH
77469: LD_INT 1000
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: PPUSH
77486: CALL_OW 70
77490: ST_TO_ADDR
// for j in fac do
77491: LD_ADDR_VAR 0 3
77495: PUSH
77496: LD_VAR 0 6
77500: PUSH
77501: FOR_IN
77502: IFFALSE 77597
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77504: LD_ADDR_VAR 0 7
77508: PUSH
77509: LD_VAR 0 7
77513: PUSH
77514: LD_INT 22
77516: PUSH
77517: LD_VAR 0 5
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 91
77528: PUSH
77529: LD_VAR 0 3
77533: PUSH
77534: LD_INT 15
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 21
77544: PUSH
77545: LD_INT 2
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: LD_INT 60
77557: PUSH
77558: EMPTY
77559: LIST
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 3
77567: PUSH
77568: LD_INT 24
77570: PUSH
77571: LD_INT 1000
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: PPUSH
77589: CALL_OW 69
77593: UNION
77594: ST_TO_ADDR
77595: GO 77501
77597: POP
77598: POP
// if not vehs then
77599: LD_VAR 0 7
77603: NOT
77604: IFFALSE 77630
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
77606: LD_ADDR_EXP 73
77610: PUSH
77611: LD_EXP 73
77615: PPUSH
77616: LD_VAR 0 2
77620: PPUSH
77621: EMPTY
77622: PPUSH
77623: CALL_OW 1
77627: ST_TO_ADDR
// continue ;
77628: GO 77260
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77630: LD_ADDR_VAR 0 8
77634: PUSH
77635: LD_EXP 61
77639: PUSH
77640: LD_VAR 0 2
77644: ARRAY
77645: PPUSH
77646: LD_INT 30
77648: PUSH
77649: LD_INT 3
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PPUSH
77656: CALL_OW 72
77660: ST_TO_ADDR
// if tmp then
77661: LD_VAR 0 8
77665: IFFALSE 77768
// begin for j in tmp do
77667: LD_ADDR_VAR 0 3
77671: PUSH
77672: LD_VAR 0 8
77676: PUSH
77677: FOR_IN
77678: IFFALSE 77766
// for k in UnitsInside ( j ) do
77680: LD_ADDR_VAR 0 4
77684: PUSH
77685: LD_VAR 0 3
77689: PPUSH
77690: CALL_OW 313
77694: PUSH
77695: FOR_IN
77696: IFFALSE 77762
// if k then
77698: LD_VAR 0 4
77702: IFFALSE 77760
// if not k in mc_repair_vehicle [ i ] then
77704: LD_VAR 0 4
77708: PUSH
77709: LD_EXP 73
77713: PUSH
77714: LD_VAR 0 2
77718: ARRAY
77719: IN
77720: NOT
77721: IFFALSE 77760
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
77723: LD_ADDR_EXP 73
77727: PUSH
77728: LD_EXP 73
77732: PPUSH
77733: LD_VAR 0 2
77737: PPUSH
77738: LD_EXP 73
77742: PUSH
77743: LD_VAR 0 2
77747: ARRAY
77748: PUSH
77749: LD_VAR 0 4
77753: UNION
77754: PPUSH
77755: CALL_OW 1
77759: ST_TO_ADDR
77760: GO 77695
77762: POP
77763: POP
77764: GO 77677
77766: POP
77767: POP
// end ; if not mc_repair_vehicle [ i ] then
77768: LD_EXP 73
77772: PUSH
77773: LD_VAR 0 2
77777: ARRAY
77778: NOT
77779: IFFALSE 77783
// continue ;
77781: GO 77260
// for j in mc_repair_vehicle [ i ] do
77783: LD_ADDR_VAR 0 3
77787: PUSH
77788: LD_EXP 73
77792: PUSH
77793: LD_VAR 0 2
77797: ARRAY
77798: PUSH
77799: FOR_IN
77800: IFFALSE 77977
// begin if GetClass ( j ) <> 3 then
77802: LD_VAR 0 3
77806: PPUSH
77807: CALL_OW 257
77811: PUSH
77812: LD_INT 3
77814: NONEQUAL
77815: IFFALSE 77856
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
77817: LD_ADDR_EXP 73
77821: PUSH
77822: LD_EXP 73
77826: PPUSH
77827: LD_VAR 0 2
77831: PPUSH
77832: LD_EXP 73
77836: PUSH
77837: LD_VAR 0 2
77841: ARRAY
77842: PUSH
77843: LD_VAR 0 3
77847: DIFF
77848: PPUSH
77849: CALL_OW 1
77853: ST_TO_ADDR
// continue ;
77854: GO 77799
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77856: LD_VAR 0 3
77860: PPUSH
77861: CALL_OW 311
77865: NOT
77866: PUSH
77867: LD_VAR 0 3
77871: PUSH
77872: LD_EXP 64
77876: PUSH
77877: LD_VAR 0 2
77881: ARRAY
77882: PUSH
77883: LD_INT 1
77885: ARRAY
77886: IN
77887: NOT
77888: AND
77889: PUSH
77890: LD_VAR 0 3
77894: PUSH
77895: LD_EXP 64
77899: PUSH
77900: LD_VAR 0 2
77904: ARRAY
77905: PUSH
77906: LD_INT 2
77908: ARRAY
77909: IN
77910: NOT
77911: AND
77912: IFFALSE 77975
// begin if IsInUnit ( j ) then
77914: LD_VAR 0 3
77918: PPUSH
77919: CALL_OW 310
77923: IFFALSE 77936
// ComExitBuilding ( j ) else
77925: LD_VAR 0 3
77929: PPUSH
77930: CALL_OW 122
77934: GO 77975
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
77936: LD_VAR 0 3
77940: PPUSH
77941: LD_VAR 0 7
77945: PUSH
77946: LD_INT 1
77948: ARRAY
77949: PPUSH
77950: CALL 56191 0 2
77954: NOT
77955: IFFALSE 77975
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
77957: LD_VAR 0 3
77961: PPUSH
77962: LD_VAR 0 7
77966: PUSH
77967: LD_INT 1
77969: ARRAY
77970: PPUSH
77971: CALL_OW 129
// end ; end ;
77975: GO 77799
77977: POP
77978: POP
// end ;
77979: GO 77260
77981: POP
77982: POP
// end ;
77983: LD_VAR 0 1
77987: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
77988: LD_INT 0
77990: PPUSH
77991: PPUSH
77992: PPUSH
77993: PPUSH
77994: PPUSH
77995: PPUSH
77996: PPUSH
77997: PPUSH
77998: PPUSH
77999: PPUSH
78000: PPUSH
// if not mc_bases then
78001: LD_EXP 61
78005: NOT
78006: IFFALSE 78010
// exit ;
78008: GO 78812
// for i = 1 to mc_bases do
78010: LD_ADDR_VAR 0 2
78014: PUSH
78015: DOUBLE
78016: LD_INT 1
78018: DEC
78019: ST_TO_ADDR
78020: LD_EXP 61
78024: PUSH
78025: FOR_TO
78026: IFFALSE 78810
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78028: LD_EXP 89
78032: PUSH
78033: LD_VAR 0 2
78037: ARRAY
78038: NOT
78039: PUSH
78040: LD_EXP 64
78044: PUSH
78045: LD_VAR 0 2
78049: ARRAY
78050: PUSH
78051: LD_INT 1
78053: ARRAY
78054: OR
78055: PUSH
78056: LD_EXP 64
78060: PUSH
78061: LD_VAR 0 2
78065: ARRAY
78066: PUSH
78067: LD_INT 2
78069: ARRAY
78070: OR
78071: PUSH
78072: LD_EXP 87
78076: PUSH
78077: LD_VAR 0 2
78081: ARRAY
78082: PPUSH
78083: LD_INT 1
78085: PPUSH
78086: CALL_OW 325
78090: NOT
78091: OR
78092: PUSH
78093: LD_EXP 84
78097: PUSH
78098: LD_VAR 0 2
78102: ARRAY
78103: OR
78104: IFFALSE 78108
// continue ;
78106: GO 78025
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78108: LD_ADDR_VAR 0 8
78112: PUSH
78113: LD_EXP 61
78117: PUSH
78118: LD_VAR 0 2
78122: ARRAY
78123: PPUSH
78124: LD_INT 25
78126: PUSH
78127: LD_INT 4
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 50
78136: PUSH
78137: EMPTY
78138: LIST
78139: PUSH
78140: LD_INT 3
78142: PUSH
78143: LD_INT 60
78145: PUSH
78146: EMPTY
78147: LIST
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: LIST
78157: PPUSH
78158: CALL_OW 72
78162: PUSH
78163: LD_EXP 65
78167: PUSH
78168: LD_VAR 0 2
78172: ARRAY
78173: DIFF
78174: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78175: LD_ADDR_VAR 0 9
78179: PUSH
78180: LD_EXP 61
78184: PUSH
78185: LD_VAR 0 2
78189: ARRAY
78190: PPUSH
78191: LD_INT 2
78193: PUSH
78194: LD_INT 30
78196: PUSH
78197: LD_INT 0
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 30
78206: PUSH
78207: LD_INT 1
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: LIST
78218: PPUSH
78219: CALL_OW 72
78223: ST_TO_ADDR
// if not tmp or not dep then
78224: LD_VAR 0 8
78228: NOT
78229: PUSH
78230: LD_VAR 0 9
78234: NOT
78235: OR
78236: IFFALSE 78240
// continue ;
78238: GO 78025
// side := GetSide ( tmp [ 1 ] ) ;
78240: LD_ADDR_VAR 0 11
78244: PUSH
78245: LD_VAR 0 8
78249: PUSH
78250: LD_INT 1
78252: ARRAY
78253: PPUSH
78254: CALL_OW 255
78258: ST_TO_ADDR
// dep := dep [ 1 ] ;
78259: LD_ADDR_VAR 0 9
78263: PUSH
78264: LD_VAR 0 9
78268: PUSH
78269: LD_INT 1
78271: ARRAY
78272: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
78273: LD_ADDR_VAR 0 7
78277: PUSH
78278: LD_EXP 89
78282: PUSH
78283: LD_VAR 0 2
78287: ARRAY
78288: PPUSH
78289: LD_INT 22
78291: PUSH
78292: LD_INT 0
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 25
78301: PUSH
78302: LD_INT 12
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PPUSH
78313: CALL_OW 70
78317: PUSH
78318: LD_INT 22
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 25
78330: PUSH
78331: LD_INT 12
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 91
78340: PUSH
78341: LD_VAR 0 9
78345: PUSH
78346: LD_INT 20
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: LIST
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: LIST
78358: PPUSH
78359: CALL_OW 69
78363: UNION
78364: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
78365: LD_ADDR_VAR 0 10
78369: PUSH
78370: LD_EXP 89
78374: PUSH
78375: LD_VAR 0 2
78379: ARRAY
78380: PPUSH
78381: LD_INT 81
78383: PUSH
78384: LD_VAR 0 11
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PPUSH
78393: CALL_OW 70
78397: ST_TO_ADDR
// if not apes or danger_at_area then
78398: LD_VAR 0 7
78402: NOT
78403: PUSH
78404: LD_VAR 0 10
78408: OR
78409: IFFALSE 78459
// begin if mc_taming [ i ] then
78411: LD_EXP 92
78415: PUSH
78416: LD_VAR 0 2
78420: ARRAY
78421: IFFALSE 78457
// begin MC_Reset ( i , 121 ) ;
78423: LD_VAR 0 2
78427: PPUSH
78428: LD_INT 121
78430: PPUSH
78431: CALL 63375 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
78435: LD_ADDR_EXP 92
78439: PUSH
78440: LD_EXP 92
78444: PPUSH
78445: LD_VAR 0 2
78449: PPUSH
78450: EMPTY
78451: PPUSH
78452: CALL_OW 1
78456: ST_TO_ADDR
// end ; continue ;
78457: GO 78025
// end ; for j in tmp do
78459: LD_ADDR_VAR 0 3
78463: PUSH
78464: LD_VAR 0 8
78468: PUSH
78469: FOR_IN
78470: IFFALSE 78806
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
78472: LD_VAR 0 3
78476: PUSH
78477: LD_EXP 92
78481: PUSH
78482: LD_VAR 0 2
78486: ARRAY
78487: IN
78488: NOT
78489: PUSH
78490: LD_EXP 92
78494: PUSH
78495: LD_VAR 0 2
78499: ARRAY
78500: PUSH
78501: LD_INT 3
78503: LESS
78504: AND
78505: IFFALSE 78563
// begin SetTag ( j , 121 ) ;
78507: LD_VAR 0 3
78511: PPUSH
78512: LD_INT 121
78514: PPUSH
78515: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
78519: LD_ADDR_EXP 92
78523: PUSH
78524: LD_EXP 92
78528: PPUSH
78529: LD_VAR 0 2
78533: PUSH
78534: LD_EXP 92
78538: PUSH
78539: LD_VAR 0 2
78543: ARRAY
78544: PUSH
78545: LD_INT 1
78547: PLUS
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PPUSH
78553: LD_VAR 0 3
78557: PPUSH
78558: CALL 21397 0 3
78562: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
78563: LD_VAR 0 3
78567: PUSH
78568: LD_EXP 92
78572: PUSH
78573: LD_VAR 0 2
78577: ARRAY
78578: IN
78579: IFFALSE 78804
// begin if GetClass ( j ) <> 4 then
78581: LD_VAR 0 3
78585: PPUSH
78586: CALL_OW 257
78590: PUSH
78591: LD_INT 4
78593: NONEQUAL
78594: IFFALSE 78647
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
78596: LD_ADDR_EXP 92
78600: PUSH
78601: LD_EXP 92
78605: PPUSH
78606: LD_VAR 0 2
78610: PPUSH
78611: LD_EXP 92
78615: PUSH
78616: LD_VAR 0 2
78620: ARRAY
78621: PUSH
78622: LD_VAR 0 3
78626: DIFF
78627: PPUSH
78628: CALL_OW 1
78632: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78633: LD_VAR 0 3
78637: PPUSH
78638: LD_INT 0
78640: PPUSH
78641: CALL_OW 109
// continue ;
78645: GO 78469
// end ; if IsInUnit ( j ) then
78647: LD_VAR 0 3
78651: PPUSH
78652: CALL_OW 310
78656: IFFALSE 78667
// ComExitBuilding ( j ) ;
78658: LD_VAR 0 3
78662: PPUSH
78663: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
78667: LD_ADDR_VAR 0 6
78671: PUSH
78672: LD_VAR 0 7
78676: PPUSH
78677: LD_VAR 0 3
78681: PPUSH
78682: CALL_OW 74
78686: ST_TO_ADDR
// if not ape then
78687: LD_VAR 0 6
78691: NOT
78692: IFFALSE 78696
// break ;
78694: GO 78806
// x := GetX ( ape ) ;
78696: LD_ADDR_VAR 0 4
78700: PUSH
78701: LD_VAR 0 6
78705: PPUSH
78706: CALL_OW 250
78710: ST_TO_ADDR
// y := GetY ( ape ) ;
78711: LD_ADDR_VAR 0 5
78715: PUSH
78716: LD_VAR 0 6
78720: PPUSH
78721: CALL_OW 251
78725: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78726: LD_VAR 0 4
78730: PPUSH
78731: LD_VAR 0 5
78735: PPUSH
78736: CALL_OW 488
78740: NOT
78741: PUSH
78742: LD_VAR 0 11
78746: PPUSH
78747: LD_VAR 0 4
78751: PPUSH
78752: LD_VAR 0 5
78756: PPUSH
78757: LD_INT 20
78759: PPUSH
78760: CALL 22661 0 4
78764: PUSH
78765: LD_INT 4
78767: ARRAY
78768: OR
78769: IFFALSE 78773
// break ;
78771: GO 78806
// if not HasTask ( j ) then
78773: LD_VAR 0 3
78777: PPUSH
78778: CALL_OW 314
78782: NOT
78783: IFFALSE 78804
// ComTameXY ( j , x , y ) ;
78785: LD_VAR 0 3
78789: PPUSH
78790: LD_VAR 0 4
78794: PPUSH
78795: LD_VAR 0 5
78799: PPUSH
78800: CALL_OW 131
// end ; end ;
78804: GO 78469
78806: POP
78807: POP
// end ;
78808: GO 78025
78810: POP
78811: POP
// end ;
78812: LD_VAR 0 1
78816: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
78817: LD_INT 0
78819: PPUSH
78820: PPUSH
78821: PPUSH
78822: PPUSH
78823: PPUSH
78824: PPUSH
78825: PPUSH
78826: PPUSH
// if not mc_bases then
78827: LD_EXP 61
78831: NOT
78832: IFFALSE 78836
// exit ;
78834: GO 79462
// for i = 1 to mc_bases do
78836: LD_ADDR_VAR 0 2
78840: PUSH
78841: DOUBLE
78842: LD_INT 1
78844: DEC
78845: ST_TO_ADDR
78846: LD_EXP 61
78850: PUSH
78851: FOR_TO
78852: IFFALSE 79460
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
78854: LD_EXP 90
78858: PUSH
78859: LD_VAR 0 2
78863: ARRAY
78864: NOT
78865: PUSH
78866: LD_EXP 90
78870: PUSH
78871: LD_VAR 0 2
78875: ARRAY
78876: PPUSH
78877: LD_INT 25
78879: PUSH
78880: LD_INT 12
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PPUSH
78887: CALL_OW 72
78891: NOT
78892: OR
78893: IFFALSE 78897
// continue ;
78895: GO 78851
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
78897: LD_ADDR_VAR 0 5
78901: PUSH
78902: LD_EXP 90
78906: PUSH
78907: LD_VAR 0 2
78911: ARRAY
78912: PUSH
78913: LD_INT 1
78915: ARRAY
78916: PPUSH
78917: CALL_OW 255
78921: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
78922: LD_VAR 0 5
78926: PPUSH
78927: LD_INT 2
78929: PPUSH
78930: CALL_OW 325
78934: IFFALSE 79187
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78936: LD_ADDR_VAR 0 4
78940: PUSH
78941: LD_EXP 90
78945: PUSH
78946: LD_VAR 0 2
78950: ARRAY
78951: PPUSH
78952: LD_INT 25
78954: PUSH
78955: LD_INT 16
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PPUSH
78962: CALL_OW 72
78966: ST_TO_ADDR
// if tmp < 6 then
78967: LD_VAR 0 4
78971: PUSH
78972: LD_INT 6
78974: LESS
78975: IFFALSE 79187
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78977: LD_ADDR_VAR 0 6
78981: PUSH
78982: LD_EXP 61
78986: PUSH
78987: LD_VAR 0 2
78991: ARRAY
78992: PPUSH
78993: LD_INT 2
78995: PUSH
78996: LD_INT 30
78998: PUSH
78999: LD_INT 0
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 30
79008: PUSH
79009: LD_INT 1
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: LIST
79020: PPUSH
79021: CALL_OW 72
79025: ST_TO_ADDR
// if depot then
79026: LD_VAR 0 6
79030: IFFALSE 79187
// begin selected := 0 ;
79032: LD_ADDR_VAR 0 7
79036: PUSH
79037: LD_INT 0
79039: ST_TO_ADDR
// for j in depot do
79040: LD_ADDR_VAR 0 3
79044: PUSH
79045: LD_VAR 0 6
79049: PUSH
79050: FOR_IN
79051: IFFALSE 79082
// begin if UnitsInside ( j ) < 6 then
79053: LD_VAR 0 3
79057: PPUSH
79058: CALL_OW 313
79062: PUSH
79063: LD_INT 6
79065: LESS
79066: IFFALSE 79080
// begin selected := j ;
79068: LD_ADDR_VAR 0 7
79072: PUSH
79073: LD_VAR 0 3
79077: ST_TO_ADDR
// break ;
79078: GO 79082
// end ; end ;
79080: GO 79050
79082: POP
79083: POP
// if selected then
79084: LD_VAR 0 7
79088: IFFALSE 79187
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79090: LD_ADDR_VAR 0 3
79094: PUSH
79095: LD_EXP 90
79099: PUSH
79100: LD_VAR 0 2
79104: ARRAY
79105: PPUSH
79106: LD_INT 25
79108: PUSH
79109: LD_INT 12
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PPUSH
79116: CALL_OW 72
79120: PUSH
79121: FOR_IN
79122: IFFALSE 79185
// if not HasTask ( j ) then
79124: LD_VAR 0 3
79128: PPUSH
79129: CALL_OW 314
79133: NOT
79134: IFFALSE 79183
// begin if not IsInUnit ( j ) then
79136: LD_VAR 0 3
79140: PPUSH
79141: CALL_OW 310
79145: NOT
79146: IFFALSE 79162
// ComEnterUnit ( j , selected ) ;
79148: LD_VAR 0 3
79152: PPUSH
79153: LD_VAR 0 7
79157: PPUSH
79158: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
79162: LD_VAR 0 3
79166: PPUSH
79167: LD_INT 16
79169: PPUSH
79170: CALL_OW 183
// AddComExitBuilding ( j ) ;
79174: LD_VAR 0 3
79178: PPUSH
79179: CALL_OW 182
// end ;
79183: GO 79121
79185: POP
79186: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
79187: LD_VAR 0 5
79191: PPUSH
79192: LD_INT 11
79194: PPUSH
79195: CALL_OW 325
79199: IFFALSE 79458
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79201: LD_ADDR_VAR 0 4
79205: PUSH
79206: LD_EXP 90
79210: PUSH
79211: LD_VAR 0 2
79215: ARRAY
79216: PPUSH
79217: LD_INT 25
79219: PUSH
79220: LD_INT 16
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PPUSH
79227: CALL_OW 72
79231: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
79232: LD_VAR 0 4
79236: PUSH
79237: LD_INT 6
79239: GREATEREQUAL
79240: PUSH
79241: LD_VAR 0 5
79245: PPUSH
79246: LD_INT 2
79248: PPUSH
79249: CALL_OW 325
79253: NOT
79254: OR
79255: IFFALSE 79458
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79257: LD_ADDR_VAR 0 8
79261: PUSH
79262: LD_EXP 61
79266: PUSH
79267: LD_VAR 0 2
79271: ARRAY
79272: PPUSH
79273: LD_INT 2
79275: PUSH
79276: LD_INT 30
79278: PUSH
79279: LD_INT 4
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 30
79288: PUSH
79289: LD_INT 5
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: LIST
79300: PPUSH
79301: CALL_OW 72
79305: ST_TO_ADDR
// if barracks then
79306: LD_VAR 0 8
79310: IFFALSE 79458
// begin selected := 0 ;
79312: LD_ADDR_VAR 0 7
79316: PUSH
79317: LD_INT 0
79319: ST_TO_ADDR
// for j in barracks do
79320: LD_ADDR_VAR 0 3
79324: PUSH
79325: LD_VAR 0 8
79329: PUSH
79330: FOR_IN
79331: IFFALSE 79362
// begin if UnitsInside ( j ) < 6 then
79333: LD_VAR 0 3
79337: PPUSH
79338: CALL_OW 313
79342: PUSH
79343: LD_INT 6
79345: LESS
79346: IFFALSE 79360
// begin selected := j ;
79348: LD_ADDR_VAR 0 7
79352: PUSH
79353: LD_VAR 0 3
79357: ST_TO_ADDR
// break ;
79358: GO 79362
// end ; end ;
79360: GO 79330
79362: POP
79363: POP
// if selected then
79364: LD_VAR 0 7
79368: IFFALSE 79458
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79370: LD_ADDR_VAR 0 3
79374: PUSH
79375: LD_EXP 90
79379: PUSH
79380: LD_VAR 0 2
79384: ARRAY
79385: PPUSH
79386: LD_INT 25
79388: PUSH
79389: LD_INT 12
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PPUSH
79396: CALL_OW 72
79400: PUSH
79401: FOR_IN
79402: IFFALSE 79456
// if not IsInUnit ( j ) and not HasTask ( j ) then
79404: LD_VAR 0 3
79408: PPUSH
79409: CALL_OW 310
79413: NOT
79414: PUSH
79415: LD_VAR 0 3
79419: PPUSH
79420: CALL_OW 314
79424: NOT
79425: AND
79426: IFFALSE 79454
// begin ComEnterUnit ( j , selected ) ;
79428: LD_VAR 0 3
79432: PPUSH
79433: LD_VAR 0 7
79437: PPUSH
79438: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
79442: LD_VAR 0 3
79446: PPUSH
79447: LD_INT 15
79449: PPUSH
79450: CALL_OW 183
// end ;
79454: GO 79401
79456: POP
79457: POP
// end ; end ; end ; end ; end ;
79458: GO 78851
79460: POP
79461: POP
// end ;
79462: LD_VAR 0 1
79466: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
79467: LD_INT 0
79469: PPUSH
79470: PPUSH
79471: PPUSH
79472: PPUSH
// if not mc_bases then
79473: LD_EXP 61
79477: NOT
79478: IFFALSE 79482
// exit ;
79480: GO 79660
// for i = 1 to mc_bases do
79482: LD_ADDR_VAR 0 2
79486: PUSH
79487: DOUBLE
79488: LD_INT 1
79490: DEC
79491: ST_TO_ADDR
79492: LD_EXP 61
79496: PUSH
79497: FOR_TO
79498: IFFALSE 79658
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
79500: LD_ADDR_VAR 0 4
79504: PUSH
79505: LD_EXP 61
79509: PUSH
79510: LD_VAR 0 2
79514: ARRAY
79515: PPUSH
79516: LD_INT 25
79518: PUSH
79519: LD_INT 9
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PPUSH
79526: CALL_OW 72
79530: ST_TO_ADDR
// if not tmp then
79531: LD_VAR 0 4
79535: NOT
79536: IFFALSE 79540
// continue ;
79538: GO 79497
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
79540: LD_EXP 87
79544: PUSH
79545: LD_VAR 0 2
79549: ARRAY
79550: PPUSH
79551: LD_INT 29
79553: PPUSH
79554: CALL_OW 325
79558: NOT
79559: PUSH
79560: LD_EXP 87
79564: PUSH
79565: LD_VAR 0 2
79569: ARRAY
79570: PPUSH
79571: LD_INT 28
79573: PPUSH
79574: CALL_OW 325
79578: NOT
79579: AND
79580: IFFALSE 79584
// continue ;
79582: GO 79497
// for j in tmp do
79584: LD_ADDR_VAR 0 3
79588: PUSH
79589: LD_VAR 0 4
79593: PUSH
79594: FOR_IN
79595: IFFALSE 79654
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79597: LD_VAR 0 3
79601: PUSH
79602: LD_EXP 64
79606: PUSH
79607: LD_VAR 0 2
79611: ARRAY
79612: PUSH
79613: LD_INT 1
79615: ARRAY
79616: IN
79617: NOT
79618: PUSH
79619: LD_VAR 0 3
79623: PUSH
79624: LD_EXP 64
79628: PUSH
79629: LD_VAR 0 2
79633: ARRAY
79634: PUSH
79635: LD_INT 2
79637: ARRAY
79638: IN
79639: NOT
79640: AND
79641: IFFALSE 79652
// ComSpaceTimeShoot ( j ) ;
79643: LD_VAR 0 3
79647: PPUSH
79648: CALL 17382 0 1
79652: GO 79594
79654: POP
79655: POP
// end ;
79656: GO 79497
79658: POP
79659: POP
// end ;
79660: LD_VAR 0 1
79664: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
79665: LD_INT 0
79667: PPUSH
79668: PPUSH
79669: PPUSH
79670: PPUSH
79671: PPUSH
79672: PPUSH
79673: PPUSH
79674: PPUSH
79675: PPUSH
// if not mc_bases then
79676: LD_EXP 61
79680: NOT
79681: IFFALSE 79685
// exit ;
79683: GO 80307
// for i = 1 to mc_bases do
79685: LD_ADDR_VAR 0 2
79689: PUSH
79690: DOUBLE
79691: LD_INT 1
79693: DEC
79694: ST_TO_ADDR
79695: LD_EXP 61
79699: PUSH
79700: FOR_TO
79701: IFFALSE 80305
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
79703: LD_EXP 96
79707: PUSH
79708: LD_VAR 0 2
79712: ARRAY
79713: NOT
79714: PUSH
79715: LD_INT 38
79717: PPUSH
79718: LD_EXP 87
79722: PUSH
79723: LD_VAR 0 2
79727: ARRAY
79728: PPUSH
79729: CALL_OW 321
79733: PUSH
79734: LD_INT 2
79736: NONEQUAL
79737: OR
79738: IFFALSE 79742
// continue ;
79740: GO 79700
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
79742: LD_ADDR_VAR 0 8
79746: PUSH
79747: LD_EXP 61
79751: PUSH
79752: LD_VAR 0 2
79756: ARRAY
79757: PPUSH
79758: LD_INT 30
79760: PUSH
79761: LD_INT 34
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PPUSH
79768: CALL_OW 72
79772: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
79773: LD_ADDR_VAR 0 9
79777: PUSH
79778: LD_EXP 61
79782: PUSH
79783: LD_VAR 0 2
79787: ARRAY
79788: PPUSH
79789: LD_INT 25
79791: PUSH
79792: LD_INT 4
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PPUSH
79799: CALL_OW 72
79803: PPUSH
79804: LD_INT 0
79806: PPUSH
79807: CALL 51695 0 2
79811: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
79812: LD_VAR 0 9
79816: NOT
79817: PUSH
79818: LD_VAR 0 8
79822: NOT
79823: OR
79824: PUSH
79825: LD_EXP 61
79829: PUSH
79830: LD_VAR 0 2
79834: ARRAY
79835: PPUSH
79836: LD_INT 124
79838: PPUSH
79839: CALL 51695 0 2
79843: OR
79844: IFFALSE 79848
// continue ;
79846: GO 79700
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
79848: LD_EXP 97
79852: PUSH
79853: LD_VAR 0 2
79857: ARRAY
79858: PUSH
79859: LD_EXP 96
79863: PUSH
79864: LD_VAR 0 2
79868: ARRAY
79869: LESS
79870: PUSH
79871: LD_EXP 97
79875: PUSH
79876: LD_VAR 0 2
79880: ARRAY
79881: PUSH
79882: LD_VAR 0 8
79886: LESS
79887: AND
79888: IFFALSE 80303
// begin tmp := sci [ 1 ] ;
79890: LD_ADDR_VAR 0 7
79894: PUSH
79895: LD_VAR 0 9
79899: PUSH
79900: LD_INT 1
79902: ARRAY
79903: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
79904: LD_VAR 0 7
79908: PPUSH
79909: LD_INT 124
79911: PPUSH
79912: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
79916: LD_ADDR_VAR 0 3
79920: PUSH
79921: DOUBLE
79922: LD_EXP 96
79926: PUSH
79927: LD_VAR 0 2
79931: ARRAY
79932: INC
79933: ST_TO_ADDR
79934: LD_EXP 96
79938: PUSH
79939: LD_VAR 0 2
79943: ARRAY
79944: PUSH
79945: FOR_DOWNTO
79946: IFFALSE 80289
// begin if IsInUnit ( tmp ) then
79948: LD_VAR 0 7
79952: PPUSH
79953: CALL_OW 310
79957: IFFALSE 79968
// ComExitBuilding ( tmp ) ;
79959: LD_VAR 0 7
79963: PPUSH
79964: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
79968: LD_INT 35
79970: PPUSH
79971: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
79975: LD_VAR 0 7
79979: PPUSH
79980: CALL_OW 310
79984: NOT
79985: PUSH
79986: LD_VAR 0 7
79990: PPUSH
79991: CALL_OW 314
79995: NOT
79996: AND
79997: IFFALSE 79968
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
79999: LD_ADDR_VAR 0 6
80003: PUSH
80004: LD_VAR 0 7
80008: PPUSH
80009: CALL_OW 250
80013: PUSH
80014: LD_VAR 0 7
80018: PPUSH
80019: CALL_OW 251
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80028: LD_INT 35
80030: PPUSH
80031: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80035: LD_ADDR_VAR 0 4
80039: PUSH
80040: LD_EXP 96
80044: PUSH
80045: LD_VAR 0 2
80049: ARRAY
80050: PUSH
80051: LD_VAR 0 3
80055: ARRAY
80056: PUSH
80057: LD_INT 1
80059: ARRAY
80060: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80061: LD_ADDR_VAR 0 5
80065: PUSH
80066: LD_EXP 96
80070: PUSH
80071: LD_VAR 0 2
80075: ARRAY
80076: PUSH
80077: LD_VAR 0 3
80081: ARRAY
80082: PUSH
80083: LD_INT 2
80085: ARRAY
80086: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80087: LD_VAR 0 7
80091: PPUSH
80092: LD_INT 10
80094: PPUSH
80095: CALL 24362 0 2
80099: PUSH
80100: LD_INT 4
80102: ARRAY
80103: IFFALSE 80141
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80105: LD_VAR 0 7
80109: PPUSH
80110: LD_VAR 0 6
80114: PUSH
80115: LD_INT 1
80117: ARRAY
80118: PPUSH
80119: LD_VAR 0 6
80123: PUSH
80124: LD_INT 2
80126: ARRAY
80127: PPUSH
80128: CALL_OW 111
// wait ( 0 0$10 ) ;
80132: LD_INT 350
80134: PPUSH
80135: CALL_OW 67
// end else
80139: GO 80167
// begin ComMoveXY ( tmp , x , y ) ;
80141: LD_VAR 0 7
80145: PPUSH
80146: LD_VAR 0 4
80150: PPUSH
80151: LD_VAR 0 5
80155: PPUSH
80156: CALL_OW 111
// wait ( 0 0$3 ) ;
80160: LD_INT 105
80162: PPUSH
80163: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
80167: LD_VAR 0 7
80171: PPUSH
80172: LD_VAR 0 4
80176: PPUSH
80177: LD_VAR 0 5
80181: PPUSH
80182: CALL_OW 307
80186: IFFALSE 80028
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
80188: LD_VAR 0 7
80192: PPUSH
80193: LD_VAR 0 4
80197: PPUSH
80198: LD_VAR 0 5
80202: PPUSH
80203: LD_VAR 0 8
80207: PUSH
80208: LD_VAR 0 3
80212: ARRAY
80213: PPUSH
80214: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
80218: LD_INT 35
80220: PPUSH
80221: CALL_OW 67
// until not HasTask ( tmp ) ;
80225: LD_VAR 0 7
80229: PPUSH
80230: CALL_OW 314
80234: NOT
80235: IFFALSE 80218
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
80237: LD_ADDR_EXP 97
80241: PUSH
80242: LD_EXP 97
80246: PPUSH
80247: LD_VAR 0 2
80251: PUSH
80252: LD_EXP 97
80256: PUSH
80257: LD_VAR 0 2
80261: ARRAY
80262: PUSH
80263: LD_INT 1
80265: PLUS
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PPUSH
80271: LD_VAR 0 8
80275: PUSH
80276: LD_VAR 0 3
80280: ARRAY
80281: PPUSH
80282: CALL 21397 0 3
80286: ST_TO_ADDR
// end ;
80287: GO 79945
80289: POP
80290: POP
// MC_Reset ( i , 124 ) ;
80291: LD_VAR 0 2
80295: PPUSH
80296: LD_INT 124
80298: PPUSH
80299: CALL 63375 0 2
// end ; end ;
80303: GO 79700
80305: POP
80306: POP
// end ;
80307: LD_VAR 0 1
80311: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
80312: LD_INT 0
80314: PPUSH
80315: PPUSH
80316: PPUSH
// if not mc_bases then
80317: LD_EXP 61
80321: NOT
80322: IFFALSE 80326
// exit ;
80324: GO 80932
// for i = 1 to mc_bases do
80326: LD_ADDR_VAR 0 2
80330: PUSH
80331: DOUBLE
80332: LD_INT 1
80334: DEC
80335: ST_TO_ADDR
80336: LD_EXP 61
80340: PUSH
80341: FOR_TO
80342: IFFALSE 80930
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
80344: LD_ADDR_VAR 0 3
80348: PUSH
80349: LD_EXP 61
80353: PUSH
80354: LD_VAR 0 2
80358: ARRAY
80359: PPUSH
80360: LD_INT 25
80362: PUSH
80363: LD_INT 4
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PPUSH
80370: CALL_OW 72
80374: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80375: LD_VAR 0 3
80379: NOT
80380: PUSH
80381: LD_EXP 98
80385: PUSH
80386: LD_VAR 0 2
80390: ARRAY
80391: NOT
80392: OR
80393: PUSH
80394: LD_EXP 61
80398: PUSH
80399: LD_VAR 0 2
80403: ARRAY
80404: PPUSH
80405: LD_INT 2
80407: PUSH
80408: LD_INT 30
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 30
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: LIST
80432: PPUSH
80433: CALL_OW 72
80437: NOT
80438: OR
80439: IFFALSE 80489
// begin if mc_deposits_finder [ i ] then
80441: LD_EXP 99
80445: PUSH
80446: LD_VAR 0 2
80450: ARRAY
80451: IFFALSE 80487
// begin MC_Reset ( i , 125 ) ;
80453: LD_VAR 0 2
80457: PPUSH
80458: LD_INT 125
80460: PPUSH
80461: CALL 63375 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80465: LD_ADDR_EXP 99
80469: PUSH
80470: LD_EXP 99
80474: PPUSH
80475: LD_VAR 0 2
80479: PPUSH
80480: EMPTY
80481: PPUSH
80482: CALL_OW 1
80486: ST_TO_ADDR
// end ; continue ;
80487: GO 80341
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
80489: LD_EXP 98
80493: PUSH
80494: LD_VAR 0 2
80498: ARRAY
80499: PUSH
80500: LD_INT 1
80502: ARRAY
80503: PUSH
80504: LD_INT 3
80506: ARRAY
80507: PUSH
80508: LD_INT 1
80510: EQUAL
80511: PUSH
80512: LD_INT 20
80514: PPUSH
80515: LD_EXP 87
80519: PUSH
80520: LD_VAR 0 2
80524: ARRAY
80525: PPUSH
80526: CALL_OW 321
80530: PUSH
80531: LD_INT 2
80533: NONEQUAL
80534: AND
80535: IFFALSE 80585
// begin if mc_deposits_finder [ i ] then
80537: LD_EXP 99
80541: PUSH
80542: LD_VAR 0 2
80546: ARRAY
80547: IFFALSE 80583
// begin MC_Reset ( i , 125 ) ;
80549: LD_VAR 0 2
80553: PPUSH
80554: LD_INT 125
80556: PPUSH
80557: CALL 63375 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80561: LD_ADDR_EXP 99
80565: PUSH
80566: LD_EXP 99
80570: PPUSH
80571: LD_VAR 0 2
80575: PPUSH
80576: EMPTY
80577: PPUSH
80578: CALL_OW 1
80582: ST_TO_ADDR
// end ; continue ;
80583: GO 80341
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
80585: LD_EXP 98
80589: PUSH
80590: LD_VAR 0 2
80594: ARRAY
80595: PUSH
80596: LD_INT 1
80598: ARRAY
80599: PUSH
80600: LD_INT 1
80602: ARRAY
80603: PPUSH
80604: LD_EXP 98
80608: PUSH
80609: LD_VAR 0 2
80613: ARRAY
80614: PUSH
80615: LD_INT 1
80617: ARRAY
80618: PUSH
80619: LD_INT 2
80621: ARRAY
80622: PPUSH
80623: LD_EXP 87
80627: PUSH
80628: LD_VAR 0 2
80632: ARRAY
80633: PPUSH
80634: CALL_OW 440
80638: IFFALSE 80681
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
80640: LD_ADDR_EXP 98
80644: PUSH
80645: LD_EXP 98
80649: PPUSH
80650: LD_VAR 0 2
80654: PPUSH
80655: LD_EXP 98
80659: PUSH
80660: LD_VAR 0 2
80664: ARRAY
80665: PPUSH
80666: LD_INT 1
80668: PPUSH
80669: CALL_OW 3
80673: PPUSH
80674: CALL_OW 1
80678: ST_TO_ADDR
80679: GO 80928
// begin if not mc_deposits_finder [ i ] then
80681: LD_EXP 99
80685: PUSH
80686: LD_VAR 0 2
80690: ARRAY
80691: NOT
80692: IFFALSE 80744
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
80694: LD_ADDR_EXP 99
80698: PUSH
80699: LD_EXP 99
80703: PPUSH
80704: LD_VAR 0 2
80708: PPUSH
80709: LD_VAR 0 3
80713: PUSH
80714: LD_INT 1
80716: ARRAY
80717: PUSH
80718: EMPTY
80719: LIST
80720: PPUSH
80721: CALL_OW 1
80725: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
80726: LD_VAR 0 3
80730: PUSH
80731: LD_INT 1
80733: ARRAY
80734: PPUSH
80735: LD_INT 125
80737: PPUSH
80738: CALL_OW 109
// end else
80742: GO 80928
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
80744: LD_EXP 99
80748: PUSH
80749: LD_VAR 0 2
80753: ARRAY
80754: PUSH
80755: LD_INT 1
80757: ARRAY
80758: PPUSH
80759: CALL_OW 310
80763: IFFALSE 80786
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
80765: LD_EXP 99
80769: PUSH
80770: LD_VAR 0 2
80774: ARRAY
80775: PUSH
80776: LD_INT 1
80778: ARRAY
80779: PPUSH
80780: CALL_OW 122
80784: GO 80928
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
80786: LD_EXP 99
80790: PUSH
80791: LD_VAR 0 2
80795: ARRAY
80796: PUSH
80797: LD_INT 1
80799: ARRAY
80800: PPUSH
80801: CALL_OW 314
80805: NOT
80806: PUSH
80807: LD_EXP 99
80811: PUSH
80812: LD_VAR 0 2
80816: ARRAY
80817: PUSH
80818: LD_INT 1
80820: ARRAY
80821: PPUSH
80822: LD_EXP 98
80826: PUSH
80827: LD_VAR 0 2
80831: ARRAY
80832: PUSH
80833: LD_INT 1
80835: ARRAY
80836: PUSH
80837: LD_INT 1
80839: ARRAY
80840: PPUSH
80841: LD_EXP 98
80845: PUSH
80846: LD_VAR 0 2
80850: ARRAY
80851: PUSH
80852: LD_INT 1
80854: ARRAY
80855: PUSH
80856: LD_INT 2
80858: ARRAY
80859: PPUSH
80860: CALL_OW 297
80864: PUSH
80865: LD_INT 6
80867: GREATER
80868: AND
80869: IFFALSE 80928
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
80871: LD_EXP 99
80875: PUSH
80876: LD_VAR 0 2
80880: ARRAY
80881: PUSH
80882: LD_INT 1
80884: ARRAY
80885: PPUSH
80886: LD_EXP 98
80890: PUSH
80891: LD_VAR 0 2
80895: ARRAY
80896: PUSH
80897: LD_INT 1
80899: ARRAY
80900: PUSH
80901: LD_INT 1
80903: ARRAY
80904: PPUSH
80905: LD_EXP 98
80909: PUSH
80910: LD_VAR 0 2
80914: ARRAY
80915: PUSH
80916: LD_INT 1
80918: ARRAY
80919: PUSH
80920: LD_INT 2
80922: ARRAY
80923: PPUSH
80924: CALL_OW 111
// end ; end ; end ;
80928: GO 80341
80930: POP
80931: POP
// end ;
80932: LD_VAR 0 1
80936: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
80937: LD_INT 0
80939: PPUSH
80940: PPUSH
80941: PPUSH
80942: PPUSH
80943: PPUSH
80944: PPUSH
80945: PPUSH
80946: PPUSH
80947: PPUSH
80948: PPUSH
80949: PPUSH
// if not mc_bases then
80950: LD_EXP 61
80954: NOT
80955: IFFALSE 80959
// exit ;
80957: GO 81899
// for i = 1 to mc_bases do
80959: LD_ADDR_VAR 0 2
80963: PUSH
80964: DOUBLE
80965: LD_INT 1
80967: DEC
80968: ST_TO_ADDR
80969: LD_EXP 61
80973: PUSH
80974: FOR_TO
80975: IFFALSE 81897
// begin if not mc_bases [ i ] or mc_scan [ i ] then
80977: LD_EXP 61
80981: PUSH
80982: LD_VAR 0 2
80986: ARRAY
80987: NOT
80988: PUSH
80989: LD_EXP 84
80993: PUSH
80994: LD_VAR 0 2
80998: ARRAY
80999: OR
81000: IFFALSE 81004
// continue ;
81002: GO 80974
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81004: LD_ADDR_VAR 0 7
81008: PUSH
81009: LD_EXP 61
81013: PUSH
81014: LD_VAR 0 2
81018: ARRAY
81019: PUSH
81020: LD_INT 1
81022: ARRAY
81023: PPUSH
81024: CALL_OW 248
81028: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81029: LD_VAR 0 7
81033: PUSH
81034: LD_INT 3
81036: EQUAL
81037: PUSH
81038: LD_EXP 80
81042: PUSH
81043: LD_VAR 0 2
81047: ARRAY
81048: PUSH
81049: LD_EXP 83
81053: PUSH
81054: LD_VAR 0 2
81058: ARRAY
81059: UNION
81060: PPUSH
81061: LD_INT 33
81063: PUSH
81064: LD_INT 2
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PPUSH
81071: CALL_OW 72
81075: NOT
81076: OR
81077: IFFALSE 81081
// continue ;
81079: GO 80974
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81081: LD_ADDR_VAR 0 9
81085: PUSH
81086: LD_EXP 61
81090: PUSH
81091: LD_VAR 0 2
81095: ARRAY
81096: PPUSH
81097: LD_INT 30
81099: PUSH
81100: LD_INT 36
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PPUSH
81107: CALL_OW 72
81111: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81112: LD_ADDR_VAR 0 10
81116: PUSH
81117: LD_EXP 80
81121: PUSH
81122: LD_VAR 0 2
81126: ARRAY
81127: PPUSH
81128: LD_INT 34
81130: PUSH
81131: LD_INT 31
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PPUSH
81138: CALL_OW 72
81142: ST_TO_ADDR
// if not cts and not mcts then
81143: LD_VAR 0 9
81147: NOT
81148: PUSH
81149: LD_VAR 0 10
81153: NOT
81154: AND
81155: IFFALSE 81159
// continue ;
81157: GO 80974
// x := cts ;
81159: LD_ADDR_VAR 0 11
81163: PUSH
81164: LD_VAR 0 9
81168: ST_TO_ADDR
// if not x then
81169: LD_VAR 0 11
81173: NOT
81174: IFFALSE 81186
// x := mcts ;
81176: LD_ADDR_VAR 0 11
81180: PUSH
81181: LD_VAR 0 10
81185: ST_TO_ADDR
// if not x then
81186: LD_VAR 0 11
81190: NOT
81191: IFFALSE 81195
// continue ;
81193: GO 80974
// if mc_remote_driver [ i ] then
81195: LD_EXP 101
81199: PUSH
81200: LD_VAR 0 2
81204: ARRAY
81205: IFFALSE 81592
// for j in mc_remote_driver [ i ] do
81207: LD_ADDR_VAR 0 3
81211: PUSH
81212: LD_EXP 101
81216: PUSH
81217: LD_VAR 0 2
81221: ARRAY
81222: PUSH
81223: FOR_IN
81224: IFFALSE 81590
// begin if GetClass ( j ) <> 3 then
81226: LD_VAR 0 3
81230: PPUSH
81231: CALL_OW 257
81235: PUSH
81236: LD_INT 3
81238: NONEQUAL
81239: IFFALSE 81292
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
81241: LD_ADDR_EXP 101
81245: PUSH
81246: LD_EXP 101
81250: PPUSH
81251: LD_VAR 0 2
81255: PPUSH
81256: LD_EXP 101
81260: PUSH
81261: LD_VAR 0 2
81265: ARRAY
81266: PUSH
81267: LD_VAR 0 3
81271: DIFF
81272: PPUSH
81273: CALL_OW 1
81277: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81278: LD_VAR 0 3
81282: PPUSH
81283: LD_INT 0
81285: PPUSH
81286: CALL_OW 109
// continue ;
81290: GO 81223
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
81292: LD_EXP 80
81296: PUSH
81297: LD_VAR 0 2
81301: ARRAY
81302: PPUSH
81303: LD_INT 34
81305: PUSH
81306: LD_INT 31
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 58
81315: PUSH
81316: EMPTY
81317: LIST
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: PPUSH
81323: CALL_OW 72
81327: PUSH
81328: LD_VAR 0 3
81332: PPUSH
81333: CALL 51730 0 1
81337: NOT
81338: AND
81339: IFFALSE 81410
// begin if IsInUnit ( j ) then
81341: LD_VAR 0 3
81345: PPUSH
81346: CALL_OW 310
81350: IFFALSE 81361
// ComExitBuilding ( j ) ;
81352: LD_VAR 0 3
81356: PPUSH
81357: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
81361: LD_VAR 0 3
81365: PPUSH
81366: LD_EXP 80
81370: PUSH
81371: LD_VAR 0 2
81375: ARRAY
81376: PPUSH
81377: LD_INT 34
81379: PUSH
81380: LD_INT 31
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 58
81389: PUSH
81390: EMPTY
81391: LIST
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PPUSH
81397: CALL_OW 72
81401: PUSH
81402: LD_INT 1
81404: ARRAY
81405: PPUSH
81406: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
81410: LD_VAR 0 3
81414: PPUSH
81415: CALL_OW 310
81419: NOT
81420: PUSH
81421: LD_VAR 0 3
81425: PPUSH
81426: CALL_OW 310
81430: PPUSH
81431: CALL_OW 266
81435: PUSH
81436: LD_INT 36
81438: NONEQUAL
81439: PUSH
81440: LD_VAR 0 3
81444: PPUSH
81445: CALL 51730 0 1
81449: NOT
81450: AND
81451: OR
81452: IFFALSE 81588
// begin if IsInUnit ( j ) then
81454: LD_VAR 0 3
81458: PPUSH
81459: CALL_OW 310
81463: IFFALSE 81474
// ComExitBuilding ( j ) ;
81465: LD_VAR 0 3
81469: PPUSH
81470: CALL_OW 122
// ct := 0 ;
81474: LD_ADDR_VAR 0 8
81478: PUSH
81479: LD_INT 0
81481: ST_TO_ADDR
// for k in x do
81482: LD_ADDR_VAR 0 4
81486: PUSH
81487: LD_VAR 0 11
81491: PUSH
81492: FOR_IN
81493: IFFALSE 81566
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
81495: LD_VAR 0 4
81499: PPUSH
81500: CALL_OW 264
81504: PUSH
81505: LD_INT 31
81507: EQUAL
81508: PUSH
81509: LD_VAR 0 4
81513: PPUSH
81514: CALL_OW 311
81518: NOT
81519: AND
81520: PUSH
81521: LD_VAR 0 4
81525: PPUSH
81526: CALL_OW 266
81530: PUSH
81531: LD_INT 36
81533: EQUAL
81534: PUSH
81535: LD_VAR 0 4
81539: PPUSH
81540: CALL_OW 313
81544: PUSH
81545: LD_INT 3
81547: LESS
81548: AND
81549: OR
81550: IFFALSE 81564
// begin ct := k ;
81552: LD_ADDR_VAR 0 8
81556: PUSH
81557: LD_VAR 0 4
81561: ST_TO_ADDR
// break ;
81562: GO 81566
// end ;
81564: GO 81492
81566: POP
81567: POP
// if ct then
81568: LD_VAR 0 8
81572: IFFALSE 81588
// ComEnterUnit ( j , ct ) ;
81574: LD_VAR 0 3
81578: PPUSH
81579: LD_VAR 0 8
81583: PPUSH
81584: CALL_OW 120
// end ; end ;
81588: GO 81223
81590: POP
81591: POP
// places := 0 ;
81592: LD_ADDR_VAR 0 5
81596: PUSH
81597: LD_INT 0
81599: ST_TO_ADDR
// for j = 1 to x do
81600: LD_ADDR_VAR 0 3
81604: PUSH
81605: DOUBLE
81606: LD_INT 1
81608: DEC
81609: ST_TO_ADDR
81610: LD_VAR 0 11
81614: PUSH
81615: FOR_TO
81616: IFFALSE 81692
// if GetWeapon ( x [ j ] ) = ar_control_tower then
81618: LD_VAR 0 11
81622: PUSH
81623: LD_VAR 0 3
81627: ARRAY
81628: PPUSH
81629: CALL_OW 264
81633: PUSH
81634: LD_INT 31
81636: EQUAL
81637: IFFALSE 81655
// places := places + 1 else
81639: LD_ADDR_VAR 0 5
81643: PUSH
81644: LD_VAR 0 5
81648: PUSH
81649: LD_INT 1
81651: PLUS
81652: ST_TO_ADDR
81653: GO 81690
// if GetBType ( x [ j ] ) = b_control_tower then
81655: LD_VAR 0 11
81659: PUSH
81660: LD_VAR 0 3
81664: ARRAY
81665: PPUSH
81666: CALL_OW 266
81670: PUSH
81671: LD_INT 36
81673: EQUAL
81674: IFFALSE 81690
// places := places + 3 ;
81676: LD_ADDR_VAR 0 5
81680: PUSH
81681: LD_VAR 0 5
81685: PUSH
81686: LD_INT 3
81688: PLUS
81689: ST_TO_ADDR
81690: GO 81615
81692: POP
81693: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
81694: LD_VAR 0 5
81698: PUSH
81699: LD_INT 0
81701: EQUAL
81702: PUSH
81703: LD_VAR 0 5
81707: PUSH
81708: LD_EXP 101
81712: PUSH
81713: LD_VAR 0 2
81717: ARRAY
81718: LESSEQUAL
81719: OR
81720: IFFALSE 81724
// continue ;
81722: GO 80974
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
81724: LD_ADDR_VAR 0 6
81728: PUSH
81729: LD_EXP 61
81733: PUSH
81734: LD_VAR 0 2
81738: ARRAY
81739: PPUSH
81740: LD_INT 25
81742: PUSH
81743: LD_INT 3
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PPUSH
81750: CALL_OW 72
81754: PUSH
81755: LD_EXP 101
81759: PUSH
81760: LD_VAR 0 2
81764: ARRAY
81765: DIFF
81766: PPUSH
81767: LD_INT 3
81769: PPUSH
81770: CALL 52630 0 2
81774: ST_TO_ADDR
// for j in tmp do
81775: LD_ADDR_VAR 0 3
81779: PUSH
81780: LD_VAR 0 6
81784: PUSH
81785: FOR_IN
81786: IFFALSE 81821
// if GetTag ( j ) > 0 then
81788: LD_VAR 0 3
81792: PPUSH
81793: CALL_OW 110
81797: PUSH
81798: LD_INT 0
81800: GREATER
81801: IFFALSE 81819
// tmp := tmp diff j ;
81803: LD_ADDR_VAR 0 6
81807: PUSH
81808: LD_VAR 0 6
81812: PUSH
81813: LD_VAR 0 3
81817: DIFF
81818: ST_TO_ADDR
81819: GO 81785
81821: POP
81822: POP
// if not tmp then
81823: LD_VAR 0 6
81827: NOT
81828: IFFALSE 81832
// continue ;
81830: GO 80974
// if places then
81832: LD_VAR 0 5
81836: IFFALSE 81895
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
81838: LD_ADDR_EXP 101
81842: PUSH
81843: LD_EXP 101
81847: PPUSH
81848: LD_VAR 0 2
81852: PPUSH
81853: LD_EXP 101
81857: PUSH
81858: LD_VAR 0 2
81862: ARRAY
81863: PUSH
81864: LD_VAR 0 6
81868: PUSH
81869: LD_INT 1
81871: ARRAY
81872: UNION
81873: PPUSH
81874: CALL_OW 1
81878: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
81879: LD_VAR 0 6
81883: PUSH
81884: LD_INT 1
81886: ARRAY
81887: PPUSH
81888: LD_INT 126
81890: PPUSH
81891: CALL_OW 109
// end ; end ;
81895: GO 80974
81897: POP
81898: POP
// end ;
81899: LD_VAR 0 1
81903: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
81904: LD_INT 0
81906: PPUSH
81907: PPUSH
81908: PPUSH
81909: PPUSH
81910: PPUSH
81911: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
81912: LD_VAR 0 1
81916: NOT
81917: PUSH
81918: LD_VAR 0 2
81922: NOT
81923: OR
81924: PUSH
81925: LD_VAR 0 3
81929: NOT
81930: OR
81931: PUSH
81932: LD_VAR 0 4
81936: PUSH
81937: LD_INT 1
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: LD_INT 3
81945: PUSH
81946: LD_INT 4
81948: PUSH
81949: LD_INT 5
81951: PUSH
81952: LD_INT 8
81954: PUSH
81955: LD_INT 9
81957: PUSH
81958: LD_INT 15
81960: PUSH
81961: LD_INT 16
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: IN
81975: NOT
81976: OR
81977: IFFALSE 81981
// exit ;
81979: GO 82839
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
81981: LD_ADDR_VAR 0 2
81985: PUSH
81986: LD_VAR 0 2
81990: PPUSH
81991: LD_INT 21
81993: PUSH
81994: LD_INT 3
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 24
82003: PUSH
82004: LD_INT 250
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PPUSH
82015: CALL_OW 72
82019: ST_TO_ADDR
// case class of 1 , 15 :
82020: LD_VAR 0 4
82024: PUSH
82025: LD_INT 1
82027: DOUBLE
82028: EQUAL
82029: IFTRUE 82039
82031: LD_INT 15
82033: DOUBLE
82034: EQUAL
82035: IFTRUE 82039
82037: GO 82124
82039: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82040: LD_ADDR_VAR 0 8
82044: PUSH
82045: LD_VAR 0 2
82049: PPUSH
82050: LD_INT 2
82052: PUSH
82053: LD_INT 30
82055: PUSH
82056: LD_INT 32
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 30
82065: PUSH
82066: LD_INT 31
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: LIST
82077: PPUSH
82078: CALL_OW 72
82082: PUSH
82083: LD_VAR 0 2
82087: PPUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 30
82093: PUSH
82094: LD_INT 4
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 30
82103: PUSH
82104: LD_INT 5
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: PPUSH
82116: CALL_OW 72
82120: ADD
82121: ST_TO_ADDR
82122: GO 82370
82124: LD_INT 2
82126: DOUBLE
82127: EQUAL
82128: IFTRUE 82138
82130: LD_INT 16
82132: DOUBLE
82133: EQUAL
82134: IFTRUE 82138
82136: GO 82184
82138: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
82139: LD_ADDR_VAR 0 8
82143: PUSH
82144: LD_VAR 0 2
82148: PPUSH
82149: LD_INT 2
82151: PUSH
82152: LD_INT 30
82154: PUSH
82155: LD_INT 0
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 30
82164: PUSH
82165: LD_INT 1
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: LIST
82176: PPUSH
82177: CALL_OW 72
82181: ST_TO_ADDR
82182: GO 82370
82184: LD_INT 3
82186: DOUBLE
82187: EQUAL
82188: IFTRUE 82192
82190: GO 82238
82192: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
82193: LD_ADDR_VAR 0 8
82197: PUSH
82198: LD_VAR 0 2
82202: PPUSH
82203: LD_INT 2
82205: PUSH
82206: LD_INT 30
82208: PUSH
82209: LD_INT 2
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 30
82218: PUSH
82219: LD_INT 3
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: LIST
82230: PPUSH
82231: CALL_OW 72
82235: ST_TO_ADDR
82236: GO 82370
82238: LD_INT 4
82240: DOUBLE
82241: EQUAL
82242: IFTRUE 82246
82244: GO 82303
82246: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
82247: LD_ADDR_VAR 0 8
82251: PUSH
82252: LD_VAR 0 2
82256: PPUSH
82257: LD_INT 2
82259: PUSH
82260: LD_INT 30
82262: PUSH
82263: LD_INT 6
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 30
82272: PUSH
82273: LD_INT 7
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 30
82282: PUSH
82283: LD_INT 8
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: PPUSH
82296: CALL_OW 72
82300: ST_TO_ADDR
82301: GO 82370
82303: LD_INT 5
82305: DOUBLE
82306: EQUAL
82307: IFTRUE 82323
82309: LD_INT 8
82311: DOUBLE
82312: EQUAL
82313: IFTRUE 82323
82315: LD_INT 9
82317: DOUBLE
82318: EQUAL
82319: IFTRUE 82323
82321: GO 82369
82323: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
82324: LD_ADDR_VAR 0 8
82328: PUSH
82329: LD_VAR 0 2
82333: PPUSH
82334: LD_INT 2
82336: PUSH
82337: LD_INT 30
82339: PUSH
82340: LD_INT 4
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 30
82349: PUSH
82350: LD_INT 5
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: LIST
82361: PPUSH
82362: CALL_OW 72
82366: ST_TO_ADDR
82367: GO 82370
82369: POP
// if not tmp then
82370: LD_VAR 0 8
82374: NOT
82375: IFFALSE 82379
// exit ;
82377: GO 82839
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
82379: LD_VAR 0 4
82383: PUSH
82384: LD_INT 1
82386: PUSH
82387: LD_INT 15
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: IN
82394: PUSH
82395: LD_EXP 70
82399: PUSH
82400: LD_VAR 0 1
82404: ARRAY
82405: AND
82406: IFFALSE 82562
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
82408: LD_ADDR_VAR 0 9
82412: PUSH
82413: LD_EXP 70
82417: PUSH
82418: LD_VAR 0 1
82422: ARRAY
82423: PUSH
82424: LD_INT 1
82426: ARRAY
82427: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
82428: LD_VAR 0 9
82432: PUSH
82433: LD_EXP 71
82437: PUSH
82438: LD_VAR 0 1
82442: ARRAY
82443: IN
82444: NOT
82445: IFFALSE 82560
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
82447: LD_ADDR_EXP 71
82451: PUSH
82452: LD_EXP 71
82456: PPUSH
82457: LD_VAR 0 1
82461: PUSH
82462: LD_EXP 71
82466: PUSH
82467: LD_VAR 0 1
82471: ARRAY
82472: PUSH
82473: LD_INT 1
82475: PLUS
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PPUSH
82481: LD_VAR 0 9
82485: PPUSH
82486: CALL 21397 0 3
82490: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
82491: LD_ADDR_EXP 70
82495: PUSH
82496: LD_EXP 70
82500: PPUSH
82501: LD_VAR 0 1
82505: PPUSH
82506: LD_EXP 70
82510: PUSH
82511: LD_VAR 0 1
82515: ARRAY
82516: PUSH
82517: LD_VAR 0 9
82521: DIFF
82522: PPUSH
82523: CALL_OW 1
82527: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
82528: LD_VAR 0 3
82532: PPUSH
82533: LD_EXP 71
82537: PUSH
82538: LD_VAR 0 1
82542: ARRAY
82543: PUSH
82544: LD_EXP 71
82548: PUSH
82549: LD_VAR 0 1
82553: ARRAY
82554: ARRAY
82555: PPUSH
82556: CALL_OW 120
// end ; exit ;
82560: GO 82839
// end ; if tmp > 1 then
82562: LD_VAR 0 8
82566: PUSH
82567: LD_INT 1
82569: GREATER
82570: IFFALSE 82674
// for i = 2 to tmp do
82572: LD_ADDR_VAR 0 6
82576: PUSH
82577: DOUBLE
82578: LD_INT 2
82580: DEC
82581: ST_TO_ADDR
82582: LD_VAR 0 8
82586: PUSH
82587: FOR_TO
82588: IFFALSE 82672
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
82590: LD_VAR 0 8
82594: PUSH
82595: LD_VAR 0 6
82599: ARRAY
82600: PPUSH
82601: CALL_OW 461
82605: PUSH
82606: LD_INT 6
82608: EQUAL
82609: IFFALSE 82670
// begin x := tmp [ i ] ;
82611: LD_ADDR_VAR 0 9
82615: PUSH
82616: LD_VAR 0 8
82620: PUSH
82621: LD_VAR 0 6
82625: ARRAY
82626: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
82627: LD_ADDR_VAR 0 8
82631: PUSH
82632: LD_VAR 0 8
82636: PPUSH
82637: LD_VAR 0 6
82641: PPUSH
82642: CALL_OW 3
82646: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
82647: LD_ADDR_VAR 0 8
82651: PUSH
82652: LD_VAR 0 8
82656: PPUSH
82657: LD_INT 1
82659: PPUSH
82660: LD_VAR 0 9
82664: PPUSH
82665: CALL_OW 2
82669: ST_TO_ADDR
// end ;
82670: GO 82587
82672: POP
82673: POP
// for i in tmp do
82674: LD_ADDR_VAR 0 6
82678: PUSH
82679: LD_VAR 0 8
82683: PUSH
82684: FOR_IN
82685: IFFALSE 82712
// begin if IsNotFull ( i ) then
82687: LD_VAR 0 6
82691: PPUSH
82692: CALL 18619 0 1
82696: IFFALSE 82710
// begin j := i ;
82698: LD_ADDR_VAR 0 7
82702: PUSH
82703: LD_VAR 0 6
82707: ST_TO_ADDR
// break ;
82708: GO 82712
// end ; end ;
82710: GO 82684
82712: POP
82713: POP
// if j then
82714: LD_VAR 0 7
82718: IFFALSE 82736
// ComEnterUnit ( unit , j ) else
82720: LD_VAR 0 3
82724: PPUSH
82725: LD_VAR 0 7
82729: PPUSH
82730: CALL_OW 120
82734: GO 82839
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82736: LD_ADDR_VAR 0 10
82740: PUSH
82741: LD_VAR 0 2
82745: PPUSH
82746: LD_INT 2
82748: PUSH
82749: LD_INT 30
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 30
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: LIST
82773: PPUSH
82774: CALL_OW 72
82778: ST_TO_ADDR
// if depot then
82779: LD_VAR 0 10
82783: IFFALSE 82839
// begin depot := NearestUnitToUnit ( depot , unit ) ;
82785: LD_ADDR_VAR 0 10
82789: PUSH
82790: LD_VAR 0 10
82794: PPUSH
82795: LD_VAR 0 3
82799: PPUSH
82800: CALL_OW 74
82804: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
82805: LD_VAR 0 3
82809: PPUSH
82810: LD_VAR 0 10
82814: PPUSH
82815: CALL_OW 296
82819: PUSH
82820: LD_INT 10
82822: GREATER
82823: IFFALSE 82839
// ComStandNearbyBuilding ( unit , depot ) ;
82825: LD_VAR 0 3
82829: PPUSH
82830: LD_VAR 0 10
82834: PPUSH
82835: CALL 17999 0 2
// end ; end ; end ;
82839: LD_VAR 0 5
82843: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
82844: LD_INT 0
82846: PPUSH
82847: PPUSH
82848: PPUSH
82849: PPUSH
// if not mc_bases then
82850: LD_EXP 61
82854: NOT
82855: IFFALSE 82859
// exit ;
82857: GO 83098
// for i = 1 to mc_bases do
82859: LD_ADDR_VAR 0 2
82863: PUSH
82864: DOUBLE
82865: LD_INT 1
82867: DEC
82868: ST_TO_ADDR
82869: LD_EXP 61
82873: PUSH
82874: FOR_TO
82875: IFFALSE 83096
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
82877: LD_ADDR_VAR 0 4
82881: PUSH
82882: LD_EXP 61
82886: PUSH
82887: LD_VAR 0 2
82891: ARRAY
82892: PPUSH
82893: LD_INT 21
82895: PUSH
82896: LD_INT 1
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PPUSH
82903: CALL_OW 72
82907: PUSH
82908: LD_EXP 90
82912: PUSH
82913: LD_VAR 0 2
82917: ARRAY
82918: UNION
82919: ST_TO_ADDR
// if not tmp then
82920: LD_VAR 0 4
82924: NOT
82925: IFFALSE 82929
// continue ;
82927: GO 82874
// for j in tmp do
82929: LD_ADDR_VAR 0 3
82933: PUSH
82934: LD_VAR 0 4
82938: PUSH
82939: FOR_IN
82940: IFFALSE 83092
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
82942: LD_VAR 0 3
82946: PPUSH
82947: CALL_OW 110
82951: NOT
82952: PUSH
82953: LD_VAR 0 3
82957: PPUSH
82958: CALL_OW 314
82962: NOT
82963: AND
82964: PUSH
82965: LD_VAR 0 3
82969: PPUSH
82970: CALL_OW 311
82974: NOT
82975: AND
82976: PUSH
82977: LD_VAR 0 3
82981: PPUSH
82982: CALL_OW 310
82986: NOT
82987: AND
82988: PUSH
82989: LD_VAR 0 3
82993: PUSH
82994: LD_EXP 64
82998: PUSH
82999: LD_VAR 0 2
83003: ARRAY
83004: PUSH
83005: LD_INT 1
83007: ARRAY
83008: IN
83009: NOT
83010: AND
83011: PUSH
83012: LD_VAR 0 3
83016: PUSH
83017: LD_EXP 64
83021: PUSH
83022: LD_VAR 0 2
83026: ARRAY
83027: PUSH
83028: LD_INT 2
83030: ARRAY
83031: IN
83032: NOT
83033: AND
83034: PUSH
83035: LD_VAR 0 3
83039: PUSH
83040: LD_EXP 73
83044: PUSH
83045: LD_VAR 0 2
83049: ARRAY
83050: IN
83051: NOT
83052: AND
83053: IFFALSE 83090
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83055: LD_VAR 0 2
83059: PPUSH
83060: LD_EXP 61
83064: PUSH
83065: LD_VAR 0 2
83069: ARRAY
83070: PPUSH
83071: LD_VAR 0 3
83075: PPUSH
83076: LD_VAR 0 3
83080: PPUSH
83081: CALL_OW 257
83085: PPUSH
83086: CALL 81904 0 4
// end ;
83090: GO 82939
83092: POP
83093: POP
// end ;
83094: GO 82874
83096: POP
83097: POP
// end ;
83098: LD_VAR 0 1
83102: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
83103: LD_INT 0
83105: PPUSH
83106: PPUSH
83107: PPUSH
83108: PPUSH
83109: PPUSH
83110: PPUSH
// if not mc_bases [ base ] then
83111: LD_EXP 61
83115: PUSH
83116: LD_VAR 0 1
83120: ARRAY
83121: NOT
83122: IFFALSE 83126
// exit ;
83124: GO 83327
// tmp := [ ] ;
83126: LD_ADDR_VAR 0 6
83130: PUSH
83131: EMPTY
83132: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
83133: LD_ADDR_VAR 0 7
83137: PUSH
83138: LD_VAR 0 3
83142: PPUSH
83143: LD_INT 0
83145: PPUSH
83146: CALL_OW 517
83150: ST_TO_ADDR
// if not list then
83151: LD_VAR 0 7
83155: NOT
83156: IFFALSE 83160
// exit ;
83158: GO 83327
// c := Count ( list [ 1 ] ) ;
83160: LD_ADDR_VAR 0 9
83164: PUSH
83165: LD_VAR 0 7
83169: PUSH
83170: LD_INT 1
83172: ARRAY
83173: PPUSH
83174: CALL 18537 0 1
83178: ST_TO_ADDR
// if amount > c then
83179: LD_VAR 0 2
83183: PUSH
83184: LD_VAR 0 9
83188: GREATER
83189: IFFALSE 83201
// amount := c ;
83191: LD_ADDR_VAR 0 2
83195: PUSH
83196: LD_VAR 0 9
83200: ST_TO_ADDR
// for i := 1 to amount do
83201: LD_ADDR_VAR 0 5
83205: PUSH
83206: DOUBLE
83207: LD_INT 1
83209: DEC
83210: ST_TO_ADDR
83211: LD_VAR 0 2
83215: PUSH
83216: FOR_TO
83217: IFFALSE 83275
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
83219: LD_ADDR_VAR 0 6
83223: PUSH
83224: LD_VAR 0 6
83228: PPUSH
83229: LD_VAR 0 5
83233: PPUSH
83234: LD_VAR 0 7
83238: PUSH
83239: LD_INT 1
83241: ARRAY
83242: PUSH
83243: LD_VAR 0 5
83247: ARRAY
83248: PUSH
83249: LD_VAR 0 7
83253: PUSH
83254: LD_INT 2
83256: ARRAY
83257: PUSH
83258: LD_VAR 0 5
83262: ARRAY
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PPUSH
83268: CALL_OW 1
83272: ST_TO_ADDR
83273: GO 83216
83275: POP
83276: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
83277: LD_ADDR_EXP 74
83281: PUSH
83282: LD_EXP 74
83286: PPUSH
83287: LD_VAR 0 1
83291: PPUSH
83292: LD_VAR 0 6
83296: PPUSH
83297: CALL_OW 1
83301: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
83302: LD_ADDR_EXP 76
83306: PUSH
83307: LD_EXP 76
83311: PPUSH
83312: LD_VAR 0 1
83316: PPUSH
83317: LD_VAR 0 3
83321: PPUSH
83322: CALL_OW 1
83326: ST_TO_ADDR
// end ;
83327: LD_VAR 0 4
83331: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
83332: LD_INT 0
83334: PPUSH
// if not mc_bases [ base ] then
83335: LD_EXP 61
83339: PUSH
83340: LD_VAR 0 1
83344: ARRAY
83345: NOT
83346: IFFALSE 83350
// exit ;
83348: GO 83375
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
83350: LD_ADDR_EXP 66
83354: PUSH
83355: LD_EXP 66
83359: PPUSH
83360: LD_VAR 0 1
83364: PPUSH
83365: LD_VAR 0 2
83369: PPUSH
83370: CALL_OW 1
83374: ST_TO_ADDR
// end ;
83375: LD_VAR 0 3
83379: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
83380: LD_INT 0
83382: PPUSH
// if not mc_bases [ base ] then
83383: LD_EXP 61
83387: PUSH
83388: LD_VAR 0 1
83392: ARRAY
83393: NOT
83394: IFFALSE 83398
// exit ;
83396: GO 83435
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
83398: LD_ADDR_EXP 66
83402: PUSH
83403: LD_EXP 66
83407: PPUSH
83408: LD_VAR 0 1
83412: PPUSH
83413: LD_EXP 66
83417: PUSH
83418: LD_VAR 0 1
83422: ARRAY
83423: PUSH
83424: LD_VAR 0 2
83428: UNION
83429: PPUSH
83430: CALL_OW 1
83434: ST_TO_ADDR
// end ;
83435: LD_VAR 0 3
83439: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
83440: LD_INT 0
83442: PPUSH
// if not mc_bases [ base ] then
83443: LD_EXP 61
83447: PUSH
83448: LD_VAR 0 1
83452: ARRAY
83453: NOT
83454: IFFALSE 83458
// exit ;
83456: GO 83483
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
83458: LD_ADDR_EXP 82
83462: PUSH
83463: LD_EXP 82
83467: PPUSH
83468: LD_VAR 0 1
83472: PPUSH
83473: LD_VAR 0 2
83477: PPUSH
83478: CALL_OW 1
83482: ST_TO_ADDR
// end ;
83483: LD_VAR 0 3
83487: RET
// export function MC_InsertProduceList ( base , components ) ; begin
83488: LD_INT 0
83490: PPUSH
// if not mc_bases [ base ] then
83491: LD_EXP 61
83495: PUSH
83496: LD_VAR 0 1
83500: ARRAY
83501: NOT
83502: IFFALSE 83506
// exit ;
83504: GO 83543
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
83506: LD_ADDR_EXP 82
83510: PUSH
83511: LD_EXP 82
83515: PPUSH
83516: LD_VAR 0 1
83520: PPUSH
83521: LD_EXP 82
83525: PUSH
83526: LD_VAR 0 1
83530: ARRAY
83531: PUSH
83532: LD_VAR 0 2
83536: ADD
83537: PPUSH
83538: CALL_OW 1
83542: ST_TO_ADDR
// end ;
83543: LD_VAR 0 3
83547: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
83548: LD_INT 0
83550: PPUSH
// if not mc_bases [ base ] then
83551: LD_EXP 61
83555: PUSH
83556: LD_VAR 0 1
83560: ARRAY
83561: NOT
83562: IFFALSE 83566
// exit ;
83564: GO 83620
// mc_defender := Replace ( mc_defender , base , deflist ) ;
83566: LD_ADDR_EXP 83
83570: PUSH
83571: LD_EXP 83
83575: PPUSH
83576: LD_VAR 0 1
83580: PPUSH
83581: LD_VAR 0 2
83585: PPUSH
83586: CALL_OW 1
83590: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
83591: LD_ADDR_EXP 72
83595: PUSH
83596: LD_EXP 72
83600: PPUSH
83601: LD_VAR 0 1
83605: PPUSH
83606: LD_VAR 0 2
83610: PUSH
83611: LD_INT 0
83613: PLUS
83614: PPUSH
83615: CALL_OW 1
83619: ST_TO_ADDR
// end ;
83620: LD_VAR 0 3
83624: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
83625: LD_INT 0
83627: PPUSH
// if not mc_bases [ base ] then
83628: LD_EXP 61
83632: PUSH
83633: LD_VAR 0 1
83637: ARRAY
83638: NOT
83639: IFFALSE 83643
// exit ;
83641: GO 83668
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
83643: LD_ADDR_EXP 72
83647: PUSH
83648: LD_EXP 72
83652: PPUSH
83653: LD_VAR 0 1
83657: PPUSH
83658: LD_VAR 0 2
83662: PPUSH
83663: CALL_OW 1
83667: ST_TO_ADDR
// end ;
83668: LD_VAR 0 3
83672: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
83673: LD_INT 0
83675: PPUSH
83676: PPUSH
83677: PPUSH
83678: PPUSH
// if not mc_bases [ base ] then
83679: LD_EXP 61
83683: PUSH
83684: LD_VAR 0 1
83688: ARRAY
83689: NOT
83690: IFFALSE 83694
// exit ;
83692: GO 83759
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
83694: LD_ADDR_EXP 81
83698: PUSH
83699: LD_EXP 81
83703: PPUSH
83704: LD_VAR 0 1
83708: PUSH
83709: LD_EXP 81
83713: PUSH
83714: LD_VAR 0 1
83718: ARRAY
83719: PUSH
83720: LD_INT 1
83722: PLUS
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PPUSH
83728: LD_VAR 0 1
83732: PUSH
83733: LD_VAR 0 2
83737: PUSH
83738: LD_VAR 0 3
83742: PUSH
83743: LD_VAR 0 4
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: PPUSH
83754: CALL 21397 0 3
83758: ST_TO_ADDR
// end ;
83759: LD_VAR 0 5
83763: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
83764: LD_INT 0
83766: PPUSH
// if not mc_bases [ base ] then
83767: LD_EXP 61
83771: PUSH
83772: LD_VAR 0 1
83776: ARRAY
83777: NOT
83778: IFFALSE 83782
// exit ;
83780: GO 83807
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
83782: LD_ADDR_EXP 98
83786: PUSH
83787: LD_EXP 98
83791: PPUSH
83792: LD_VAR 0 1
83796: PPUSH
83797: LD_VAR 0 2
83801: PPUSH
83802: CALL_OW 1
83806: ST_TO_ADDR
// end ;
83807: LD_VAR 0 3
83811: RET
// export function MC_GetMinesField ( base ) ; begin
83812: LD_INT 0
83814: PPUSH
// result := mc_mines [ base ] ;
83815: LD_ADDR_VAR 0 2
83819: PUSH
83820: LD_EXP 74
83824: PUSH
83825: LD_VAR 0 1
83829: ARRAY
83830: ST_TO_ADDR
// end ;
83831: LD_VAR 0 2
83835: RET
// export function MC_GetProduceList ( base ) ; begin
83836: LD_INT 0
83838: PPUSH
// result := mc_produce [ base ] ;
83839: LD_ADDR_VAR 0 2
83843: PUSH
83844: LD_EXP 82
83848: PUSH
83849: LD_VAR 0 1
83853: ARRAY
83854: ST_TO_ADDR
// end ;
83855: LD_VAR 0 2
83859: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
83860: LD_INT 0
83862: PPUSH
83863: PPUSH
// if not mc_bases then
83864: LD_EXP 61
83868: NOT
83869: IFFALSE 83873
// exit ;
83871: GO 83938
// if mc_bases [ base ] then
83873: LD_EXP 61
83877: PUSH
83878: LD_VAR 0 1
83882: ARRAY
83883: IFFALSE 83938
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83885: LD_ADDR_VAR 0 3
83889: PUSH
83890: LD_EXP 61
83894: PUSH
83895: LD_VAR 0 1
83899: ARRAY
83900: PPUSH
83901: LD_INT 30
83903: PUSH
83904: LD_VAR 0 2
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PPUSH
83913: CALL_OW 72
83917: ST_TO_ADDR
// if result then
83918: LD_VAR 0 3
83922: IFFALSE 83938
// result := result [ 1 ] ;
83924: LD_ADDR_VAR 0 3
83928: PUSH
83929: LD_VAR 0 3
83933: PUSH
83934: LD_INT 1
83936: ARRAY
83937: ST_TO_ADDR
// end ; end ;
83938: LD_VAR 0 3
83942: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
83943: LD_INT 0
83945: PPUSH
83946: PPUSH
// if not mc_bases then
83947: LD_EXP 61
83951: NOT
83952: IFFALSE 83956
// exit ;
83954: GO 84001
// if mc_bases [ base ] then
83956: LD_EXP 61
83960: PUSH
83961: LD_VAR 0 1
83965: ARRAY
83966: IFFALSE 84001
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83968: LD_ADDR_VAR 0 3
83972: PUSH
83973: LD_EXP 61
83977: PUSH
83978: LD_VAR 0 1
83982: ARRAY
83983: PPUSH
83984: LD_INT 30
83986: PUSH
83987: LD_VAR 0 2
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PPUSH
83996: CALL_OW 72
84000: ST_TO_ADDR
// end ;
84001: LD_VAR 0 3
84005: RET
// export function MC_SetTame ( base , area ) ; begin
84006: LD_INT 0
84008: PPUSH
// if not mc_bases or not base then
84009: LD_EXP 61
84013: NOT
84014: PUSH
84015: LD_VAR 0 1
84019: NOT
84020: OR
84021: IFFALSE 84025
// exit ;
84023: GO 84050
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84025: LD_ADDR_EXP 89
84029: PUSH
84030: LD_EXP 89
84034: PPUSH
84035: LD_VAR 0 1
84039: PPUSH
84040: LD_VAR 0 2
84044: PPUSH
84045: CALL_OW 1
84049: ST_TO_ADDR
// end ;
84050: LD_VAR 0 3
84054: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84055: LD_INT 0
84057: PPUSH
84058: PPUSH
// if not mc_bases or not base then
84059: LD_EXP 61
84063: NOT
84064: PUSH
84065: LD_VAR 0 1
84069: NOT
84070: OR
84071: IFFALSE 84075
// exit ;
84073: GO 84177
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84075: LD_ADDR_VAR 0 4
84079: PUSH
84080: LD_EXP 61
84084: PUSH
84085: LD_VAR 0 1
84089: ARRAY
84090: PPUSH
84091: LD_INT 30
84093: PUSH
84094: LD_VAR 0 2
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PPUSH
84103: CALL_OW 72
84107: ST_TO_ADDR
// if not tmp then
84108: LD_VAR 0 4
84112: NOT
84113: IFFALSE 84117
// exit ;
84115: GO 84177
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
84117: LD_ADDR_EXP 93
84121: PUSH
84122: LD_EXP 93
84126: PPUSH
84127: LD_VAR 0 1
84131: PPUSH
84132: LD_EXP 93
84136: PUSH
84137: LD_VAR 0 1
84141: ARRAY
84142: PPUSH
84143: LD_EXP 93
84147: PUSH
84148: LD_VAR 0 1
84152: ARRAY
84153: PUSH
84154: LD_INT 1
84156: PLUS
84157: PPUSH
84158: LD_VAR 0 4
84162: PUSH
84163: LD_INT 1
84165: ARRAY
84166: PPUSH
84167: CALL_OW 2
84171: PPUSH
84172: CALL_OW 1
84176: ST_TO_ADDR
// end ;
84177: LD_VAR 0 3
84181: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
84182: LD_INT 0
84184: PPUSH
84185: PPUSH
// if not mc_bases or not base or not kinds then
84186: LD_EXP 61
84190: NOT
84191: PUSH
84192: LD_VAR 0 1
84196: NOT
84197: OR
84198: PUSH
84199: LD_VAR 0 2
84203: NOT
84204: OR
84205: IFFALSE 84209
// exit ;
84207: GO 84270
// for i in kinds do
84209: LD_ADDR_VAR 0 4
84213: PUSH
84214: LD_VAR 0 2
84218: PUSH
84219: FOR_IN
84220: IFFALSE 84268
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
84222: LD_ADDR_EXP 95
84226: PUSH
84227: LD_EXP 95
84231: PPUSH
84232: LD_VAR 0 1
84236: PUSH
84237: LD_EXP 95
84241: PUSH
84242: LD_VAR 0 1
84246: ARRAY
84247: PUSH
84248: LD_INT 1
84250: PLUS
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PPUSH
84256: LD_VAR 0 4
84260: PPUSH
84261: CALL 21397 0 3
84265: ST_TO_ADDR
84266: GO 84219
84268: POP
84269: POP
// end ;
84270: LD_VAR 0 3
84274: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
84275: LD_INT 0
84277: PPUSH
// if not mc_bases or not base or not areas then
84278: LD_EXP 61
84282: NOT
84283: PUSH
84284: LD_VAR 0 1
84288: NOT
84289: OR
84290: PUSH
84291: LD_VAR 0 2
84295: NOT
84296: OR
84297: IFFALSE 84301
// exit ;
84299: GO 84326
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
84301: LD_ADDR_EXP 79
84305: PUSH
84306: LD_EXP 79
84310: PPUSH
84311: LD_VAR 0 1
84315: PPUSH
84316: LD_VAR 0 2
84320: PPUSH
84321: CALL_OW 1
84325: ST_TO_ADDR
// end ;
84326: LD_VAR 0 3
84330: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
84331: LD_INT 0
84333: PPUSH
// if not mc_bases or not base or not teleports_exit then
84334: LD_EXP 61
84338: NOT
84339: PUSH
84340: LD_VAR 0 1
84344: NOT
84345: OR
84346: PUSH
84347: LD_VAR 0 2
84351: NOT
84352: OR
84353: IFFALSE 84357
// exit ;
84355: GO 84382
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
84357: LD_ADDR_EXP 96
84361: PUSH
84362: LD_EXP 96
84366: PPUSH
84367: LD_VAR 0 1
84371: PPUSH
84372: LD_VAR 0 2
84376: PPUSH
84377: CALL_OW 1
84381: ST_TO_ADDR
// end ;
84382: LD_VAR 0 3
84386: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
84387: LD_INT 0
84389: PPUSH
84390: PPUSH
84391: PPUSH
// if not mc_bases or not base or not ext_list then
84392: LD_EXP 61
84396: NOT
84397: PUSH
84398: LD_VAR 0 1
84402: NOT
84403: OR
84404: PUSH
84405: LD_VAR 0 5
84409: NOT
84410: OR
84411: IFFALSE 84415
// exit ;
84413: GO 84588
// tmp := GetFacExtXYD ( x , y , d ) ;
84415: LD_ADDR_VAR 0 8
84419: PUSH
84420: LD_VAR 0 2
84424: PPUSH
84425: LD_VAR 0 3
84429: PPUSH
84430: LD_VAR 0 4
84434: PPUSH
84435: CALL 51760 0 3
84439: ST_TO_ADDR
// if not tmp then
84440: LD_VAR 0 8
84444: NOT
84445: IFFALSE 84449
// exit ;
84447: GO 84588
// for i in tmp do
84449: LD_ADDR_VAR 0 7
84453: PUSH
84454: LD_VAR 0 8
84458: PUSH
84459: FOR_IN
84460: IFFALSE 84586
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
84462: LD_ADDR_EXP 66
84466: PUSH
84467: LD_EXP 66
84471: PPUSH
84472: LD_VAR 0 1
84476: PPUSH
84477: LD_EXP 66
84481: PUSH
84482: LD_VAR 0 1
84486: ARRAY
84487: PPUSH
84488: LD_EXP 66
84492: PUSH
84493: LD_VAR 0 1
84497: ARRAY
84498: PUSH
84499: LD_INT 1
84501: PLUS
84502: PPUSH
84503: LD_VAR 0 5
84507: PUSH
84508: LD_INT 1
84510: ARRAY
84511: PUSH
84512: LD_VAR 0 7
84516: PUSH
84517: LD_INT 1
84519: ARRAY
84520: PUSH
84521: LD_VAR 0 7
84525: PUSH
84526: LD_INT 2
84528: ARRAY
84529: PUSH
84530: LD_VAR 0 7
84534: PUSH
84535: LD_INT 3
84537: ARRAY
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: PPUSH
84545: CALL_OW 2
84549: PPUSH
84550: CALL_OW 1
84554: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
84555: LD_ADDR_VAR 0 5
84559: PUSH
84560: LD_VAR 0 5
84564: PPUSH
84565: LD_INT 1
84567: PPUSH
84568: CALL_OW 3
84572: ST_TO_ADDR
// if not ext_list then
84573: LD_VAR 0 5
84577: NOT
84578: IFFALSE 84584
// exit ;
84580: POP
84581: POP
84582: GO 84588
// end ;
84584: GO 84459
84586: POP
84587: POP
// end ;
84588: LD_VAR 0 6
84592: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
84593: LD_INT 0
84595: PPUSH
// if not mc_bases or not base or not weapon_list then
84596: LD_EXP 61
84600: NOT
84601: PUSH
84602: LD_VAR 0 1
84606: NOT
84607: OR
84608: PUSH
84609: LD_VAR 0 2
84613: NOT
84614: OR
84615: IFFALSE 84619
// exit ;
84617: GO 84644
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
84619: LD_ADDR_EXP 100
84623: PUSH
84624: LD_EXP 100
84628: PPUSH
84629: LD_VAR 0 1
84633: PPUSH
84634: LD_VAR 0 2
84638: PPUSH
84639: CALL_OW 1
84643: ST_TO_ADDR
// end ;
84644: LD_VAR 0 3
84648: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
84649: LD_INT 0
84651: PPUSH
// if not mc_bases or not base or not tech_list then
84652: LD_EXP 61
84656: NOT
84657: PUSH
84658: LD_VAR 0 1
84662: NOT
84663: OR
84664: PUSH
84665: LD_VAR 0 2
84669: NOT
84670: OR
84671: IFFALSE 84675
// exit ;
84673: GO 84700
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
84675: LD_ADDR_EXP 88
84679: PUSH
84680: LD_EXP 88
84684: PPUSH
84685: LD_VAR 0 1
84689: PPUSH
84690: LD_VAR 0 2
84694: PPUSH
84695: CALL_OW 1
84699: ST_TO_ADDR
// end ;
84700: LD_VAR 0 3
84704: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
84705: LD_INT 0
84707: PPUSH
// if not mc_bases or not parking_area or not base then
84708: LD_EXP 61
84712: NOT
84713: PUSH
84714: LD_VAR 0 2
84718: NOT
84719: OR
84720: PUSH
84721: LD_VAR 0 1
84725: NOT
84726: OR
84727: IFFALSE 84731
// exit ;
84729: GO 84756
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
84731: LD_ADDR_EXP 85
84735: PUSH
84736: LD_EXP 85
84740: PPUSH
84741: LD_VAR 0 1
84745: PPUSH
84746: LD_VAR 0 2
84750: PPUSH
84751: CALL_OW 1
84755: ST_TO_ADDR
// end ;
84756: LD_VAR 0 3
84760: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
84761: LD_INT 0
84763: PPUSH
// if not mc_bases or not base or not scan_area then
84764: LD_EXP 61
84768: NOT
84769: PUSH
84770: LD_VAR 0 1
84774: NOT
84775: OR
84776: PUSH
84777: LD_VAR 0 2
84781: NOT
84782: OR
84783: IFFALSE 84787
// exit ;
84785: GO 84812
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
84787: LD_ADDR_EXP 86
84791: PUSH
84792: LD_EXP 86
84796: PPUSH
84797: LD_VAR 0 1
84801: PPUSH
84802: LD_VAR 0 2
84806: PPUSH
84807: CALL_OW 1
84811: ST_TO_ADDR
// end ;
84812: LD_VAR 0 3
84816: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
84817: LD_INT 0
84819: PPUSH
84820: PPUSH
// if not mc_bases or not base then
84821: LD_EXP 61
84825: NOT
84826: PUSH
84827: LD_VAR 0 1
84831: NOT
84832: OR
84833: IFFALSE 84837
// exit ;
84835: GO 84901
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
84837: LD_ADDR_VAR 0 3
84841: PUSH
84842: LD_INT 1
84844: PUSH
84845: LD_INT 2
84847: PUSH
84848: LD_INT 3
84850: PUSH
84851: LD_INT 4
84853: PUSH
84854: LD_INT 11
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
84864: LD_ADDR_EXP 88
84868: PUSH
84869: LD_EXP 88
84873: PPUSH
84874: LD_VAR 0 1
84878: PPUSH
84879: LD_EXP 88
84883: PUSH
84884: LD_VAR 0 1
84888: ARRAY
84889: PUSH
84890: LD_VAR 0 3
84894: DIFF
84895: PPUSH
84896: CALL_OW 1
84900: ST_TO_ADDR
// end ;
84901: LD_VAR 0 2
84905: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
84906: LD_INT 0
84908: PPUSH
// result := mc_vehicles [ base ] ;
84909: LD_ADDR_VAR 0 3
84913: PUSH
84914: LD_EXP 80
84918: PUSH
84919: LD_VAR 0 1
84923: ARRAY
84924: ST_TO_ADDR
// if onlyCombat then
84925: LD_VAR 0 2
84929: IFFALSE 85101
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
84931: LD_ADDR_VAR 0 3
84935: PUSH
84936: LD_VAR 0 3
84940: PUSH
84941: LD_VAR 0 3
84945: PPUSH
84946: LD_INT 2
84948: PUSH
84949: LD_INT 34
84951: PUSH
84952: LD_INT 12
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: LD_INT 34
84961: PUSH
84962: LD_INT 51
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 34
84971: PUSH
84972: LD_INT 89
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 34
84981: PUSH
84982: LD_INT 32
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 34
84991: PUSH
84992: LD_INT 13
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 34
85001: PUSH
85002: LD_INT 52
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 34
85011: PUSH
85012: LD_INT 88
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 34
85021: PUSH
85022: LD_INT 14
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 34
85031: PUSH
85032: LD_INT 53
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 34
85041: PUSH
85042: LD_INT 98
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 34
85051: PUSH
85052: LD_INT 31
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 34
85061: PUSH
85062: LD_INT 48
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 34
85071: PUSH
85072: LD_INT 8
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: PPUSH
85095: CALL_OW 72
85099: DIFF
85100: ST_TO_ADDR
// end ; end_of_file
85101: LD_VAR 0 3
85105: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85106: LD_INT 0
85108: PPUSH
85109: PPUSH
85110: PPUSH
// if not mc_bases or not skirmish then
85111: LD_EXP 61
85115: NOT
85116: PUSH
85117: LD_EXP 59
85121: NOT
85122: OR
85123: IFFALSE 85127
// exit ;
85125: GO 85292
// for i = 1 to mc_bases do
85127: LD_ADDR_VAR 0 4
85131: PUSH
85132: DOUBLE
85133: LD_INT 1
85135: DEC
85136: ST_TO_ADDR
85137: LD_EXP 61
85141: PUSH
85142: FOR_TO
85143: IFFALSE 85290
// begin if sci in mc_bases [ i ] then
85145: LD_VAR 0 2
85149: PUSH
85150: LD_EXP 61
85154: PUSH
85155: LD_VAR 0 4
85159: ARRAY
85160: IN
85161: IFFALSE 85288
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
85163: LD_ADDR_EXP 90
85167: PUSH
85168: LD_EXP 90
85172: PPUSH
85173: LD_VAR 0 4
85177: PUSH
85178: LD_EXP 90
85182: PUSH
85183: LD_VAR 0 4
85187: ARRAY
85188: PUSH
85189: LD_INT 1
85191: PLUS
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PPUSH
85197: LD_VAR 0 1
85201: PPUSH
85202: CALL 21397 0 3
85206: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
85207: LD_ADDR_VAR 0 5
85211: PUSH
85212: LD_EXP 61
85216: PUSH
85217: LD_VAR 0 4
85221: ARRAY
85222: PPUSH
85223: LD_INT 2
85225: PUSH
85226: LD_INT 30
85228: PUSH
85229: LD_INT 0
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 30
85238: PUSH
85239: LD_INT 1
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: LIST
85250: PPUSH
85251: CALL_OW 72
85255: PPUSH
85256: LD_VAR 0 1
85260: PPUSH
85261: CALL_OW 74
85265: ST_TO_ADDR
// if tmp then
85266: LD_VAR 0 5
85270: IFFALSE 85286
// ComStandNearbyBuilding ( ape , tmp ) ;
85272: LD_VAR 0 1
85276: PPUSH
85277: LD_VAR 0 5
85281: PPUSH
85282: CALL 17999 0 2
// break ;
85286: GO 85290
// end ; end ;
85288: GO 85142
85290: POP
85291: POP
// end ;
85292: LD_VAR 0 3
85296: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
85297: LD_INT 0
85299: PPUSH
85300: PPUSH
85301: PPUSH
// if not mc_bases or not skirmish then
85302: LD_EXP 61
85306: NOT
85307: PUSH
85308: LD_EXP 59
85312: NOT
85313: OR
85314: IFFALSE 85318
// exit ;
85316: GO 85407
// for i = 1 to mc_bases do
85318: LD_ADDR_VAR 0 4
85322: PUSH
85323: DOUBLE
85324: LD_INT 1
85326: DEC
85327: ST_TO_ADDR
85328: LD_EXP 61
85332: PUSH
85333: FOR_TO
85334: IFFALSE 85405
// begin if building in mc_busy_turret_list [ i ] then
85336: LD_VAR 0 1
85340: PUSH
85341: LD_EXP 71
85345: PUSH
85346: LD_VAR 0 4
85350: ARRAY
85351: IN
85352: IFFALSE 85403
// begin tmp := mc_busy_turret_list [ i ] diff building ;
85354: LD_ADDR_VAR 0 5
85358: PUSH
85359: LD_EXP 71
85363: PUSH
85364: LD_VAR 0 4
85368: ARRAY
85369: PUSH
85370: LD_VAR 0 1
85374: DIFF
85375: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
85376: LD_ADDR_EXP 71
85380: PUSH
85381: LD_EXP 71
85385: PPUSH
85386: LD_VAR 0 4
85390: PPUSH
85391: LD_VAR 0 5
85395: PPUSH
85396: CALL_OW 1
85400: ST_TO_ADDR
// break ;
85401: GO 85405
// end ; end ;
85403: GO 85333
85405: POP
85406: POP
// end ;
85407: LD_VAR 0 3
85411: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
85412: LD_INT 0
85414: PPUSH
85415: PPUSH
85416: PPUSH
// if not mc_bases or not skirmish then
85417: LD_EXP 61
85421: NOT
85422: PUSH
85423: LD_EXP 59
85427: NOT
85428: OR
85429: IFFALSE 85433
// exit ;
85431: GO 85632
// for i = 1 to mc_bases do
85433: LD_ADDR_VAR 0 5
85437: PUSH
85438: DOUBLE
85439: LD_INT 1
85441: DEC
85442: ST_TO_ADDR
85443: LD_EXP 61
85447: PUSH
85448: FOR_TO
85449: IFFALSE 85630
// if building in mc_bases [ i ] then
85451: LD_VAR 0 1
85455: PUSH
85456: LD_EXP 61
85460: PUSH
85461: LD_VAR 0 5
85465: ARRAY
85466: IN
85467: IFFALSE 85628
// begin tmp := mc_bases [ i ] diff building ;
85469: LD_ADDR_VAR 0 6
85473: PUSH
85474: LD_EXP 61
85478: PUSH
85479: LD_VAR 0 5
85483: ARRAY
85484: PUSH
85485: LD_VAR 0 1
85489: DIFF
85490: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
85491: LD_ADDR_EXP 61
85495: PUSH
85496: LD_EXP 61
85500: PPUSH
85501: LD_VAR 0 5
85505: PPUSH
85506: LD_VAR 0 6
85510: PPUSH
85511: CALL_OW 1
85515: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
85516: LD_VAR 0 1
85520: PUSH
85521: LD_EXP 69
85525: PUSH
85526: LD_VAR 0 5
85530: ARRAY
85531: IN
85532: IFFALSE 85571
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
85534: LD_ADDR_EXP 69
85538: PUSH
85539: LD_EXP 69
85543: PPUSH
85544: LD_VAR 0 5
85548: PPUSH
85549: LD_EXP 69
85553: PUSH
85554: LD_VAR 0 5
85558: ARRAY
85559: PUSH
85560: LD_VAR 0 1
85564: DIFF
85565: PPUSH
85566: CALL_OW 1
85570: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
85571: LD_VAR 0 1
85575: PUSH
85576: LD_EXP 70
85580: PUSH
85581: LD_VAR 0 5
85585: ARRAY
85586: IN
85587: IFFALSE 85626
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
85589: LD_ADDR_EXP 70
85593: PUSH
85594: LD_EXP 70
85598: PPUSH
85599: LD_VAR 0 5
85603: PPUSH
85604: LD_EXP 70
85608: PUSH
85609: LD_VAR 0 5
85613: ARRAY
85614: PUSH
85615: LD_VAR 0 1
85619: DIFF
85620: PPUSH
85621: CALL_OW 1
85625: ST_TO_ADDR
// break ;
85626: GO 85630
// end ;
85628: GO 85448
85630: POP
85631: POP
// end ;
85632: LD_VAR 0 4
85636: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
85637: LD_INT 0
85639: PPUSH
85640: PPUSH
85641: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
85642: LD_EXP 61
85646: NOT
85647: PUSH
85648: LD_EXP 59
85652: NOT
85653: OR
85654: PUSH
85655: LD_VAR 0 3
85659: PUSH
85660: LD_EXP 87
85664: IN
85665: NOT
85666: OR
85667: IFFALSE 85671
// exit ;
85669: GO 85794
// for i = 1 to mc_vehicles do
85671: LD_ADDR_VAR 0 6
85675: PUSH
85676: DOUBLE
85677: LD_INT 1
85679: DEC
85680: ST_TO_ADDR
85681: LD_EXP 80
85685: PUSH
85686: FOR_TO
85687: IFFALSE 85792
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
85689: LD_VAR 0 2
85693: PUSH
85694: LD_EXP 80
85698: PUSH
85699: LD_VAR 0 6
85703: ARRAY
85704: IN
85705: PUSH
85706: LD_VAR 0 1
85710: PUSH
85711: LD_EXP 80
85715: PUSH
85716: LD_VAR 0 6
85720: ARRAY
85721: IN
85722: OR
85723: IFFALSE 85790
// begin tmp := mc_vehicles [ i ] diff old ;
85725: LD_ADDR_VAR 0 7
85729: PUSH
85730: LD_EXP 80
85734: PUSH
85735: LD_VAR 0 6
85739: ARRAY
85740: PUSH
85741: LD_VAR 0 2
85745: DIFF
85746: ST_TO_ADDR
// tmp := tmp diff new ;
85747: LD_ADDR_VAR 0 7
85751: PUSH
85752: LD_VAR 0 7
85756: PUSH
85757: LD_VAR 0 1
85761: DIFF
85762: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
85763: LD_ADDR_EXP 80
85767: PUSH
85768: LD_EXP 80
85772: PPUSH
85773: LD_VAR 0 6
85777: PPUSH
85778: LD_VAR 0 7
85782: PPUSH
85783: CALL_OW 1
85787: ST_TO_ADDR
// break ;
85788: GO 85792
// end ;
85790: GO 85686
85792: POP
85793: POP
// end ;
85794: LD_VAR 0 5
85798: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
85799: LD_INT 0
85801: PPUSH
85802: PPUSH
85803: PPUSH
85804: PPUSH
// if not mc_bases or not skirmish then
85805: LD_EXP 61
85809: NOT
85810: PUSH
85811: LD_EXP 59
85815: NOT
85816: OR
85817: IFFALSE 85821
// exit ;
85819: GO 86241
// repeat wait ( 0 0$1 ) ;
85821: LD_INT 35
85823: PPUSH
85824: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
85828: LD_EXP 105
85832: NOT
85833: IFFALSE 85821
// mc_block_vehicle_constructed_thread := true ;
85835: LD_ADDR_EXP 105
85839: PUSH
85840: LD_INT 1
85842: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
85843: LD_ADDR_VAR 0 5
85847: PUSH
85848: LD_VAR 0 1
85852: PPUSH
85853: CALL_OW 255
85857: ST_TO_ADDR
// for i = 1 to mc_bases do
85858: LD_ADDR_VAR 0 4
85862: PUSH
85863: DOUBLE
85864: LD_INT 1
85866: DEC
85867: ST_TO_ADDR
85868: LD_EXP 61
85872: PUSH
85873: FOR_TO
85874: IFFALSE 86231
// begin if factory in mc_bases [ i ] then
85876: LD_VAR 0 2
85880: PUSH
85881: LD_EXP 61
85885: PUSH
85886: LD_VAR 0 4
85890: ARRAY
85891: IN
85892: IFFALSE 86229
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
85894: LD_EXP 83
85898: PUSH
85899: LD_VAR 0 4
85903: ARRAY
85904: PUSH
85905: LD_EXP 72
85909: PUSH
85910: LD_VAR 0 4
85914: ARRAY
85915: LESS
85916: PUSH
85917: LD_VAR 0 1
85921: PPUSH
85922: CALL_OW 264
85926: PUSH
85927: LD_INT 31
85929: PUSH
85930: LD_INT 32
85932: PUSH
85933: LD_INT 51
85935: PUSH
85936: LD_INT 89
85938: PUSH
85939: LD_INT 12
85941: PUSH
85942: LD_INT 30
85944: PUSH
85945: LD_INT 98
85947: PUSH
85948: LD_INT 11
85950: PUSH
85951: LD_INT 53
85953: PUSH
85954: LD_INT 14
85956: PUSH
85957: LD_INT 91
85959: PUSH
85960: LD_INT 29
85962: PUSH
85963: LD_INT 99
85965: PUSH
85966: LD_INT 13
85968: PUSH
85969: LD_INT 52
85971: PUSH
85972: LD_INT 88
85974: PUSH
85975: LD_INT 48
85977: PUSH
85978: LD_INT 8
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: IN
86001: NOT
86002: AND
86003: IFFALSE 86051
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86005: LD_ADDR_EXP 83
86009: PUSH
86010: LD_EXP 83
86014: PPUSH
86015: LD_VAR 0 4
86019: PUSH
86020: LD_EXP 83
86024: PUSH
86025: LD_VAR 0 4
86029: ARRAY
86030: PUSH
86031: LD_INT 1
86033: PLUS
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PPUSH
86039: LD_VAR 0 1
86043: PPUSH
86044: CALL 21397 0 3
86048: ST_TO_ADDR
86049: GO 86095
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86051: LD_ADDR_EXP 80
86055: PUSH
86056: LD_EXP 80
86060: PPUSH
86061: LD_VAR 0 4
86065: PUSH
86066: LD_EXP 80
86070: PUSH
86071: LD_VAR 0 4
86075: ARRAY
86076: PUSH
86077: LD_INT 1
86079: PLUS
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PPUSH
86085: LD_VAR 0 1
86089: PPUSH
86090: CALL 21397 0 3
86094: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
86095: LD_ADDR_EXP 105
86099: PUSH
86100: LD_INT 0
86102: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86103: LD_VAR 0 1
86107: PPUSH
86108: CALL_OW 263
86112: PUSH
86113: LD_INT 2
86115: EQUAL
86116: IFFALSE 86145
// begin repeat wait ( 0 0$3 ) ;
86118: LD_INT 105
86120: PPUSH
86121: CALL_OW 67
// Connect ( vehicle ) ;
86125: LD_VAR 0 1
86129: PPUSH
86130: CALL 24743 0 1
// until IsControledBy ( vehicle ) ;
86134: LD_VAR 0 1
86138: PPUSH
86139: CALL_OW 312
86143: IFFALSE 86118
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86145: LD_VAR 0 1
86149: PPUSH
86150: LD_EXP 85
86154: PUSH
86155: LD_VAR 0 4
86159: ARRAY
86160: PPUSH
86161: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
86165: LD_VAR 0 1
86169: PPUSH
86170: CALL_OW 263
86174: PUSH
86175: LD_INT 1
86177: NONEQUAL
86178: IFFALSE 86182
// break ;
86180: GO 86231
// repeat wait ( 0 0$1 ) ;
86182: LD_INT 35
86184: PPUSH
86185: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
86189: LD_VAR 0 1
86193: PPUSH
86194: LD_EXP 85
86198: PUSH
86199: LD_VAR 0 4
86203: ARRAY
86204: PPUSH
86205: CALL_OW 308
86209: IFFALSE 86182
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
86211: LD_VAR 0 1
86215: PPUSH
86216: CALL_OW 311
86220: PPUSH
86221: CALL_OW 121
// exit ;
86225: POP
86226: POP
86227: GO 86241
// end ; end ;
86229: GO 85873
86231: POP
86232: POP
// mc_block_vehicle_constructed_thread := false ;
86233: LD_ADDR_EXP 105
86237: PUSH
86238: LD_INT 0
86240: ST_TO_ADDR
// end ;
86241: LD_VAR 0 3
86245: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
86246: LD_INT 0
86248: PPUSH
86249: PPUSH
86250: PPUSH
86251: PPUSH
// if not mc_bases or not skirmish then
86252: LD_EXP 61
86256: NOT
86257: PUSH
86258: LD_EXP 59
86262: NOT
86263: OR
86264: IFFALSE 86268
// exit ;
86266: GO 86621
// repeat wait ( 0 0$1 ) ;
86268: LD_INT 35
86270: PPUSH
86271: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
86275: LD_VAR 0 2
86279: PPUSH
86280: LD_VAR 0 3
86284: PPUSH
86285: CALL_OW 284
86289: IFFALSE 86268
// if GetResourceTypeXY ( x , y ) = mat_artefact then
86291: LD_VAR 0 2
86295: PPUSH
86296: LD_VAR 0 3
86300: PPUSH
86301: CALL_OW 283
86305: PUSH
86306: LD_INT 4
86308: EQUAL
86309: IFFALSE 86313
// exit ;
86311: GO 86621
// for i = 1 to mc_bases do
86313: LD_ADDR_VAR 0 7
86317: PUSH
86318: DOUBLE
86319: LD_INT 1
86321: DEC
86322: ST_TO_ADDR
86323: LD_EXP 61
86327: PUSH
86328: FOR_TO
86329: IFFALSE 86619
// begin if mc_crates_area [ i ] then
86331: LD_EXP 79
86335: PUSH
86336: LD_VAR 0 7
86340: ARRAY
86341: IFFALSE 86452
// for j in mc_crates_area [ i ] do
86343: LD_ADDR_VAR 0 8
86347: PUSH
86348: LD_EXP 79
86352: PUSH
86353: LD_VAR 0 7
86357: ARRAY
86358: PUSH
86359: FOR_IN
86360: IFFALSE 86450
// if InArea ( x , y , j ) then
86362: LD_VAR 0 2
86366: PPUSH
86367: LD_VAR 0 3
86371: PPUSH
86372: LD_VAR 0 8
86376: PPUSH
86377: CALL_OW 309
86381: IFFALSE 86448
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86383: LD_ADDR_EXP 77
86387: PUSH
86388: LD_EXP 77
86392: PPUSH
86393: LD_VAR 0 7
86397: PUSH
86398: LD_EXP 77
86402: PUSH
86403: LD_VAR 0 7
86407: ARRAY
86408: PUSH
86409: LD_INT 1
86411: PLUS
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PPUSH
86417: LD_VAR 0 4
86421: PUSH
86422: LD_VAR 0 2
86426: PUSH
86427: LD_VAR 0 3
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: PPUSH
86437: CALL 21397 0 3
86441: ST_TO_ADDR
// exit ;
86442: POP
86443: POP
86444: POP
86445: POP
86446: GO 86621
// end ;
86448: GO 86359
86450: POP
86451: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86452: LD_ADDR_VAR 0 9
86456: PUSH
86457: LD_EXP 61
86461: PUSH
86462: LD_VAR 0 7
86466: ARRAY
86467: PPUSH
86468: LD_INT 2
86470: PUSH
86471: LD_INT 30
86473: PUSH
86474: LD_INT 0
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 30
86483: PUSH
86484: LD_INT 1
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: LIST
86495: PPUSH
86496: CALL_OW 72
86500: ST_TO_ADDR
// if not depot then
86501: LD_VAR 0 9
86505: NOT
86506: IFFALSE 86510
// continue ;
86508: GO 86328
// for j in depot do
86510: LD_ADDR_VAR 0 8
86514: PUSH
86515: LD_VAR 0 9
86519: PUSH
86520: FOR_IN
86521: IFFALSE 86615
// if GetDistUnitXY ( j , x , y ) < 30 then
86523: LD_VAR 0 8
86527: PPUSH
86528: LD_VAR 0 2
86532: PPUSH
86533: LD_VAR 0 3
86537: PPUSH
86538: CALL_OW 297
86542: PUSH
86543: LD_INT 30
86545: LESS
86546: IFFALSE 86613
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86548: LD_ADDR_EXP 77
86552: PUSH
86553: LD_EXP 77
86557: PPUSH
86558: LD_VAR 0 7
86562: PUSH
86563: LD_EXP 77
86567: PUSH
86568: LD_VAR 0 7
86572: ARRAY
86573: PUSH
86574: LD_INT 1
86576: PLUS
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PPUSH
86582: LD_VAR 0 4
86586: PUSH
86587: LD_VAR 0 2
86591: PUSH
86592: LD_VAR 0 3
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: LIST
86601: PPUSH
86602: CALL 21397 0 3
86606: ST_TO_ADDR
// exit ;
86607: POP
86608: POP
86609: POP
86610: POP
86611: GO 86621
// end ;
86613: GO 86520
86615: POP
86616: POP
// end ;
86617: GO 86328
86619: POP
86620: POP
// end ;
86621: LD_VAR 0 6
86625: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
86626: LD_INT 0
86628: PPUSH
86629: PPUSH
86630: PPUSH
86631: PPUSH
// if not mc_bases or not skirmish then
86632: LD_EXP 61
86636: NOT
86637: PUSH
86638: LD_EXP 59
86642: NOT
86643: OR
86644: IFFALSE 86648
// exit ;
86646: GO 86925
// side := GetSide ( lab ) ;
86648: LD_ADDR_VAR 0 4
86652: PUSH
86653: LD_VAR 0 2
86657: PPUSH
86658: CALL_OW 255
86662: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
86663: LD_VAR 0 4
86667: PUSH
86668: LD_EXP 87
86672: IN
86673: NOT
86674: PUSH
86675: LD_EXP 88
86679: NOT
86680: OR
86681: PUSH
86682: LD_EXP 61
86686: NOT
86687: OR
86688: IFFALSE 86692
// exit ;
86690: GO 86925
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
86692: LD_ADDR_EXP 88
86696: PUSH
86697: LD_EXP 88
86701: PPUSH
86702: LD_VAR 0 4
86706: PPUSH
86707: LD_EXP 88
86711: PUSH
86712: LD_VAR 0 4
86716: ARRAY
86717: PUSH
86718: LD_VAR 0 1
86722: DIFF
86723: PPUSH
86724: CALL_OW 1
86728: ST_TO_ADDR
// for i = 1 to mc_bases do
86729: LD_ADDR_VAR 0 5
86733: PUSH
86734: DOUBLE
86735: LD_INT 1
86737: DEC
86738: ST_TO_ADDR
86739: LD_EXP 61
86743: PUSH
86744: FOR_TO
86745: IFFALSE 86923
// begin if lab in mc_bases [ i ] then
86747: LD_VAR 0 2
86751: PUSH
86752: LD_EXP 61
86756: PUSH
86757: LD_VAR 0 5
86761: ARRAY
86762: IN
86763: IFFALSE 86921
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
86765: LD_VAR 0 1
86769: PUSH
86770: LD_INT 11
86772: PUSH
86773: LD_INT 4
86775: PUSH
86776: LD_INT 3
86778: PUSH
86779: LD_INT 2
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: IN
86788: PUSH
86789: LD_EXP 91
86793: PUSH
86794: LD_VAR 0 5
86798: ARRAY
86799: AND
86800: IFFALSE 86921
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
86802: LD_ADDR_VAR 0 6
86806: PUSH
86807: LD_EXP 91
86811: PUSH
86812: LD_VAR 0 5
86816: ARRAY
86817: PUSH
86818: LD_INT 1
86820: ARRAY
86821: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86822: LD_ADDR_EXP 91
86826: PUSH
86827: LD_EXP 91
86831: PPUSH
86832: LD_VAR 0 5
86836: PPUSH
86837: EMPTY
86838: PPUSH
86839: CALL_OW 1
86843: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
86844: LD_VAR 0 6
86848: PPUSH
86849: LD_INT 0
86851: PPUSH
86852: CALL_OW 109
// ComExitBuilding ( tmp ) ;
86856: LD_VAR 0 6
86860: PPUSH
86861: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
86865: LD_ADDR_EXP 90
86869: PUSH
86870: LD_EXP 90
86874: PPUSH
86875: LD_VAR 0 5
86879: PPUSH
86880: LD_EXP 90
86884: PUSH
86885: LD_VAR 0 5
86889: ARRAY
86890: PPUSH
86891: LD_INT 1
86893: PPUSH
86894: LD_VAR 0 6
86898: PPUSH
86899: CALL_OW 2
86903: PPUSH
86904: CALL_OW 1
86908: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
86909: LD_VAR 0 5
86913: PPUSH
86914: LD_INT 112
86916: PPUSH
86917: CALL 63375 0 2
// end ; end ; end ;
86921: GO 86744
86923: POP
86924: POP
// end ;
86925: LD_VAR 0 3
86929: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
86930: LD_INT 0
86932: PPUSH
86933: PPUSH
86934: PPUSH
86935: PPUSH
86936: PPUSH
86937: PPUSH
86938: PPUSH
86939: PPUSH
// if not mc_bases or not skirmish then
86940: LD_EXP 61
86944: NOT
86945: PUSH
86946: LD_EXP 59
86950: NOT
86951: OR
86952: IFFALSE 86956
// exit ;
86954: GO 88325
// for i = 1 to mc_bases do
86956: LD_ADDR_VAR 0 3
86960: PUSH
86961: DOUBLE
86962: LD_INT 1
86964: DEC
86965: ST_TO_ADDR
86966: LD_EXP 61
86970: PUSH
86971: FOR_TO
86972: IFFALSE 88323
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
86974: LD_VAR 0 1
86978: PUSH
86979: LD_EXP 61
86983: PUSH
86984: LD_VAR 0 3
86988: ARRAY
86989: IN
86990: PUSH
86991: LD_VAR 0 1
86995: PUSH
86996: LD_EXP 68
87000: PUSH
87001: LD_VAR 0 3
87005: ARRAY
87006: IN
87007: OR
87008: PUSH
87009: LD_VAR 0 1
87013: PUSH
87014: LD_EXP 83
87018: PUSH
87019: LD_VAR 0 3
87023: ARRAY
87024: IN
87025: OR
87026: PUSH
87027: LD_VAR 0 1
87031: PUSH
87032: LD_EXP 80
87036: PUSH
87037: LD_VAR 0 3
87041: ARRAY
87042: IN
87043: OR
87044: PUSH
87045: LD_VAR 0 1
87049: PUSH
87050: LD_EXP 90
87054: PUSH
87055: LD_VAR 0 3
87059: ARRAY
87060: IN
87061: OR
87062: PUSH
87063: LD_VAR 0 1
87067: PUSH
87068: LD_EXP 91
87072: PUSH
87073: LD_VAR 0 3
87077: ARRAY
87078: IN
87079: OR
87080: IFFALSE 88321
// begin if un in mc_ape [ i ] then
87082: LD_VAR 0 1
87086: PUSH
87087: LD_EXP 90
87091: PUSH
87092: LD_VAR 0 3
87096: ARRAY
87097: IN
87098: IFFALSE 87137
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87100: LD_ADDR_EXP 90
87104: PUSH
87105: LD_EXP 90
87109: PPUSH
87110: LD_VAR 0 3
87114: PPUSH
87115: LD_EXP 90
87119: PUSH
87120: LD_VAR 0 3
87124: ARRAY
87125: PUSH
87126: LD_VAR 0 1
87130: DIFF
87131: PPUSH
87132: CALL_OW 1
87136: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
87137: LD_VAR 0 1
87141: PUSH
87142: LD_EXP 91
87146: PUSH
87147: LD_VAR 0 3
87151: ARRAY
87152: IN
87153: IFFALSE 87177
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87155: LD_ADDR_EXP 91
87159: PUSH
87160: LD_EXP 91
87164: PPUSH
87165: LD_VAR 0 3
87169: PPUSH
87170: EMPTY
87171: PPUSH
87172: CALL_OW 1
87176: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
87177: LD_VAR 0 1
87181: PPUSH
87182: CALL_OW 247
87186: PUSH
87187: LD_INT 2
87189: EQUAL
87190: PUSH
87191: LD_VAR 0 1
87195: PPUSH
87196: CALL_OW 110
87200: PUSH
87201: LD_INT 20
87203: EQUAL
87204: PUSH
87205: LD_VAR 0 1
87209: PUSH
87210: LD_EXP 83
87214: PUSH
87215: LD_VAR 0 3
87219: ARRAY
87220: IN
87221: OR
87222: PUSH
87223: LD_VAR 0 1
87227: PPUSH
87228: CALL_OW 264
87232: PUSH
87233: LD_INT 12
87235: PUSH
87236: LD_INT 51
87238: PUSH
87239: LD_INT 89
87241: PUSH
87242: LD_INT 32
87244: PUSH
87245: LD_INT 13
87247: PUSH
87248: LD_INT 52
87250: PUSH
87251: LD_INT 31
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: IN
87263: OR
87264: AND
87265: IFFALSE 87573
// begin if un in mc_defender [ i ] then
87267: LD_VAR 0 1
87271: PUSH
87272: LD_EXP 83
87276: PUSH
87277: LD_VAR 0 3
87281: ARRAY
87282: IN
87283: IFFALSE 87322
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87285: LD_ADDR_EXP 83
87289: PUSH
87290: LD_EXP 83
87294: PPUSH
87295: LD_VAR 0 3
87299: PPUSH
87300: LD_EXP 83
87304: PUSH
87305: LD_VAR 0 3
87309: ARRAY
87310: PUSH
87311: LD_VAR 0 1
87315: DIFF
87316: PPUSH
87317: CALL_OW 1
87321: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
87322: LD_ADDR_VAR 0 8
87326: PUSH
87327: LD_VAR 0 3
87331: PPUSH
87332: LD_INT 3
87334: PPUSH
87335: CALL 83943 0 2
87339: ST_TO_ADDR
// if fac then
87340: LD_VAR 0 8
87344: IFFALSE 87573
// begin for j in fac do
87346: LD_ADDR_VAR 0 4
87350: PUSH
87351: LD_VAR 0 8
87355: PUSH
87356: FOR_IN
87357: IFFALSE 87571
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
87359: LD_ADDR_VAR 0 9
87363: PUSH
87364: LD_VAR 0 8
87368: PPUSH
87369: LD_VAR 0 1
87373: PPUSH
87374: CALL_OW 265
87378: PPUSH
87379: LD_VAR 0 1
87383: PPUSH
87384: CALL_OW 262
87388: PPUSH
87389: LD_VAR 0 1
87393: PPUSH
87394: CALL_OW 263
87398: PPUSH
87399: LD_VAR 0 1
87403: PPUSH
87404: CALL_OW 264
87408: PPUSH
87409: CALL 18895 0 5
87413: ST_TO_ADDR
// if components then
87414: LD_VAR 0 9
87418: IFFALSE 87569
// begin if GetWeapon ( un ) = ar_control_tower then
87420: LD_VAR 0 1
87424: PPUSH
87425: CALL_OW 264
87429: PUSH
87430: LD_INT 31
87432: EQUAL
87433: IFFALSE 87550
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
87435: LD_VAR 0 1
87439: PPUSH
87440: CALL_OW 311
87444: PPUSH
87445: LD_INT 0
87447: PPUSH
87448: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
87452: LD_ADDR_EXP 101
87456: PUSH
87457: LD_EXP 101
87461: PPUSH
87462: LD_VAR 0 3
87466: PPUSH
87467: LD_EXP 101
87471: PUSH
87472: LD_VAR 0 3
87476: ARRAY
87477: PUSH
87478: LD_VAR 0 1
87482: PPUSH
87483: CALL_OW 311
87487: DIFF
87488: PPUSH
87489: CALL_OW 1
87493: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
87494: LD_ADDR_VAR 0 7
87498: PUSH
87499: LD_EXP 82
87503: PUSH
87504: LD_VAR 0 3
87508: ARRAY
87509: PPUSH
87510: LD_INT 1
87512: PPUSH
87513: LD_VAR 0 9
87517: PPUSH
87518: CALL_OW 2
87522: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
87523: LD_ADDR_EXP 82
87527: PUSH
87528: LD_EXP 82
87532: PPUSH
87533: LD_VAR 0 3
87537: PPUSH
87538: LD_VAR 0 7
87542: PPUSH
87543: CALL_OW 1
87547: ST_TO_ADDR
// end else
87548: GO 87567
// MC_InsertProduceList ( i , [ components ] ) ;
87550: LD_VAR 0 3
87554: PPUSH
87555: LD_VAR 0 9
87559: PUSH
87560: EMPTY
87561: LIST
87562: PPUSH
87563: CALL 83488 0 2
// break ;
87567: GO 87571
// end ; end ;
87569: GO 87356
87571: POP
87572: POP
// end ; end ; if GetType ( un ) = unit_building then
87573: LD_VAR 0 1
87577: PPUSH
87578: CALL_OW 247
87582: PUSH
87583: LD_INT 3
87585: EQUAL
87586: IFFALSE 87989
// begin btype := GetBType ( un ) ;
87588: LD_ADDR_VAR 0 5
87592: PUSH
87593: LD_VAR 0 1
87597: PPUSH
87598: CALL_OW 266
87602: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
87603: LD_VAR 0 5
87607: PUSH
87608: LD_INT 29
87610: PUSH
87611: LD_INT 30
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: IN
87618: IFFALSE 87691
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
87620: LD_VAR 0 1
87624: PPUSH
87625: CALL_OW 250
87629: PPUSH
87630: LD_VAR 0 1
87634: PPUSH
87635: CALL_OW 251
87639: PPUSH
87640: LD_VAR 0 1
87644: PPUSH
87645: CALL_OW 255
87649: PPUSH
87650: CALL_OW 440
87654: NOT
87655: IFFALSE 87691
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
87657: LD_VAR 0 1
87661: PPUSH
87662: CALL_OW 250
87666: PPUSH
87667: LD_VAR 0 1
87671: PPUSH
87672: CALL_OW 251
87676: PPUSH
87677: LD_VAR 0 1
87681: PPUSH
87682: CALL_OW 255
87686: PPUSH
87687: CALL_OW 441
// end ; if btype = b_warehouse then
87691: LD_VAR 0 5
87695: PUSH
87696: LD_INT 1
87698: EQUAL
87699: IFFALSE 87717
// begin btype := b_depot ;
87701: LD_ADDR_VAR 0 5
87705: PUSH
87706: LD_INT 0
87708: ST_TO_ADDR
// pos := 1 ;
87709: LD_ADDR_VAR 0 6
87713: PUSH
87714: LD_INT 1
87716: ST_TO_ADDR
// end ; if btype = b_factory then
87717: LD_VAR 0 5
87721: PUSH
87722: LD_INT 3
87724: EQUAL
87725: IFFALSE 87743
// begin btype := b_workshop ;
87727: LD_ADDR_VAR 0 5
87731: PUSH
87732: LD_INT 2
87734: ST_TO_ADDR
// pos := 1 ;
87735: LD_ADDR_VAR 0 6
87739: PUSH
87740: LD_INT 1
87742: ST_TO_ADDR
// end ; if btype = b_barracks then
87743: LD_VAR 0 5
87747: PUSH
87748: LD_INT 5
87750: EQUAL
87751: IFFALSE 87761
// btype := b_armoury ;
87753: LD_ADDR_VAR 0 5
87757: PUSH
87758: LD_INT 4
87760: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
87761: LD_VAR 0 5
87765: PUSH
87766: LD_INT 7
87768: PUSH
87769: LD_INT 8
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: IN
87776: IFFALSE 87786
// btype := b_lab ;
87778: LD_ADDR_VAR 0 5
87782: PUSH
87783: LD_INT 6
87785: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
87786: LD_ADDR_EXP 66
87790: PUSH
87791: LD_EXP 66
87795: PPUSH
87796: LD_VAR 0 3
87800: PUSH
87801: LD_EXP 66
87805: PUSH
87806: LD_VAR 0 3
87810: ARRAY
87811: PUSH
87812: LD_INT 1
87814: PLUS
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PPUSH
87820: LD_VAR 0 5
87824: PUSH
87825: LD_VAR 0 1
87829: PPUSH
87830: CALL_OW 250
87834: PUSH
87835: LD_VAR 0 1
87839: PPUSH
87840: CALL_OW 251
87844: PUSH
87845: LD_VAR 0 1
87849: PPUSH
87850: CALL_OW 254
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: PPUSH
87861: CALL 21397 0 3
87865: ST_TO_ADDR
// if pos = 1 then
87866: LD_VAR 0 6
87870: PUSH
87871: LD_INT 1
87873: EQUAL
87874: IFFALSE 87989
// begin tmp := mc_build_list [ i ] ;
87876: LD_ADDR_VAR 0 7
87880: PUSH
87881: LD_EXP 66
87885: PUSH
87886: LD_VAR 0 3
87890: ARRAY
87891: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
87892: LD_VAR 0 7
87896: PPUSH
87897: LD_INT 2
87899: PUSH
87900: LD_INT 30
87902: PUSH
87903: LD_INT 0
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 30
87912: PUSH
87913: LD_INT 1
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: LIST
87924: PPUSH
87925: CALL_OW 72
87929: IFFALSE 87939
// pos := 2 ;
87931: LD_ADDR_VAR 0 6
87935: PUSH
87936: LD_INT 2
87938: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
87939: LD_ADDR_VAR 0 7
87943: PUSH
87944: LD_VAR 0 7
87948: PPUSH
87949: LD_VAR 0 6
87953: PPUSH
87954: LD_VAR 0 7
87958: PPUSH
87959: CALL 21723 0 3
87963: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
87964: LD_ADDR_EXP 66
87968: PUSH
87969: LD_EXP 66
87973: PPUSH
87974: LD_VAR 0 3
87978: PPUSH
87979: LD_VAR 0 7
87983: PPUSH
87984: CALL_OW 1
87988: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
87989: LD_VAR 0 1
87993: PUSH
87994: LD_EXP 61
87998: PUSH
87999: LD_VAR 0 3
88003: ARRAY
88004: IN
88005: IFFALSE 88044
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88007: LD_ADDR_EXP 61
88011: PUSH
88012: LD_EXP 61
88016: PPUSH
88017: LD_VAR 0 3
88021: PPUSH
88022: LD_EXP 61
88026: PUSH
88027: LD_VAR 0 3
88031: ARRAY
88032: PUSH
88033: LD_VAR 0 1
88037: DIFF
88038: PPUSH
88039: CALL_OW 1
88043: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88044: LD_VAR 0 1
88048: PUSH
88049: LD_EXP 68
88053: PUSH
88054: LD_VAR 0 3
88058: ARRAY
88059: IN
88060: IFFALSE 88099
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88062: LD_ADDR_EXP 68
88066: PUSH
88067: LD_EXP 68
88071: PPUSH
88072: LD_VAR 0 3
88076: PPUSH
88077: LD_EXP 68
88081: PUSH
88082: LD_VAR 0 3
88086: ARRAY
88087: PUSH
88088: LD_VAR 0 1
88092: DIFF
88093: PPUSH
88094: CALL_OW 1
88098: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88099: LD_VAR 0 1
88103: PUSH
88104: LD_EXP 80
88108: PUSH
88109: LD_VAR 0 3
88113: ARRAY
88114: IN
88115: IFFALSE 88154
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
88117: LD_ADDR_EXP 80
88121: PUSH
88122: LD_EXP 80
88126: PPUSH
88127: LD_VAR 0 3
88131: PPUSH
88132: LD_EXP 80
88136: PUSH
88137: LD_VAR 0 3
88141: ARRAY
88142: PUSH
88143: LD_VAR 0 1
88147: DIFF
88148: PPUSH
88149: CALL_OW 1
88153: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88154: LD_VAR 0 1
88158: PUSH
88159: LD_EXP 83
88163: PUSH
88164: LD_VAR 0 3
88168: ARRAY
88169: IN
88170: IFFALSE 88209
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88172: LD_ADDR_EXP 83
88176: PUSH
88177: LD_EXP 83
88181: PPUSH
88182: LD_VAR 0 3
88186: PPUSH
88187: LD_EXP 83
88191: PUSH
88192: LD_VAR 0 3
88196: ARRAY
88197: PUSH
88198: LD_VAR 0 1
88202: DIFF
88203: PPUSH
88204: CALL_OW 1
88208: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
88209: LD_VAR 0 1
88213: PUSH
88214: LD_EXP 70
88218: PUSH
88219: LD_VAR 0 3
88223: ARRAY
88224: IN
88225: IFFALSE 88264
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
88227: LD_ADDR_EXP 70
88231: PUSH
88232: LD_EXP 70
88236: PPUSH
88237: LD_VAR 0 3
88241: PPUSH
88242: LD_EXP 70
88246: PUSH
88247: LD_VAR 0 3
88251: ARRAY
88252: PUSH
88253: LD_VAR 0 1
88257: DIFF
88258: PPUSH
88259: CALL_OW 1
88263: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
88264: LD_VAR 0 1
88268: PUSH
88269: LD_EXP 69
88273: PUSH
88274: LD_VAR 0 3
88278: ARRAY
88279: IN
88280: IFFALSE 88319
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
88282: LD_ADDR_EXP 69
88286: PUSH
88287: LD_EXP 69
88291: PPUSH
88292: LD_VAR 0 3
88296: PPUSH
88297: LD_EXP 69
88301: PUSH
88302: LD_VAR 0 3
88306: ARRAY
88307: PUSH
88308: LD_VAR 0 1
88312: DIFF
88313: PPUSH
88314: CALL_OW 1
88318: ST_TO_ADDR
// end ; break ;
88319: GO 88323
// end ;
88321: GO 86971
88323: POP
88324: POP
// end ;
88325: LD_VAR 0 2
88329: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
88330: LD_INT 0
88332: PPUSH
88333: PPUSH
88334: PPUSH
// if not mc_bases or not skirmish then
88335: LD_EXP 61
88339: NOT
88340: PUSH
88341: LD_EXP 59
88345: NOT
88346: OR
88347: IFFALSE 88351
// exit ;
88349: GO 88566
// for i = 1 to mc_bases do
88351: LD_ADDR_VAR 0 3
88355: PUSH
88356: DOUBLE
88357: LD_INT 1
88359: DEC
88360: ST_TO_ADDR
88361: LD_EXP 61
88365: PUSH
88366: FOR_TO
88367: IFFALSE 88564
// begin if building in mc_construct_list [ i ] then
88369: LD_VAR 0 1
88373: PUSH
88374: LD_EXP 68
88378: PUSH
88379: LD_VAR 0 3
88383: ARRAY
88384: IN
88385: IFFALSE 88562
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88387: LD_ADDR_EXP 68
88391: PUSH
88392: LD_EXP 68
88396: PPUSH
88397: LD_VAR 0 3
88401: PPUSH
88402: LD_EXP 68
88406: PUSH
88407: LD_VAR 0 3
88411: ARRAY
88412: PUSH
88413: LD_VAR 0 1
88417: DIFF
88418: PPUSH
88419: CALL_OW 1
88423: ST_TO_ADDR
// if building in mc_lab [ i ] then
88424: LD_VAR 0 1
88428: PUSH
88429: LD_EXP 94
88433: PUSH
88434: LD_VAR 0 3
88438: ARRAY
88439: IN
88440: IFFALSE 88495
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
88442: LD_ADDR_EXP 95
88446: PUSH
88447: LD_EXP 95
88451: PPUSH
88452: LD_VAR 0 3
88456: PPUSH
88457: LD_EXP 95
88461: PUSH
88462: LD_VAR 0 3
88466: ARRAY
88467: PPUSH
88468: LD_INT 1
88470: PPUSH
88471: LD_EXP 95
88475: PUSH
88476: LD_VAR 0 3
88480: ARRAY
88481: PPUSH
88482: LD_INT 0
88484: PPUSH
88485: CALL 20815 0 4
88489: PPUSH
88490: CALL_OW 1
88494: ST_TO_ADDR
// if not building in mc_bases [ i ] then
88495: LD_VAR 0 1
88499: PUSH
88500: LD_EXP 61
88504: PUSH
88505: LD_VAR 0 3
88509: ARRAY
88510: IN
88511: NOT
88512: IFFALSE 88558
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88514: LD_ADDR_EXP 61
88518: PUSH
88519: LD_EXP 61
88523: PPUSH
88524: LD_VAR 0 3
88528: PUSH
88529: LD_EXP 61
88533: PUSH
88534: LD_VAR 0 3
88538: ARRAY
88539: PUSH
88540: LD_INT 1
88542: PLUS
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PPUSH
88548: LD_VAR 0 1
88552: PPUSH
88553: CALL 21397 0 3
88557: ST_TO_ADDR
// exit ;
88558: POP
88559: POP
88560: GO 88566
// end ; end ;
88562: GO 88366
88564: POP
88565: POP
// end ;
88566: LD_VAR 0 2
88570: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
88571: LD_INT 0
88573: PPUSH
88574: PPUSH
88575: PPUSH
88576: PPUSH
88577: PPUSH
88578: PPUSH
88579: PPUSH
// if not mc_bases or not skirmish then
88580: LD_EXP 61
88584: NOT
88585: PUSH
88586: LD_EXP 59
88590: NOT
88591: OR
88592: IFFALSE 88596
// exit ;
88594: GO 89257
// for i = 1 to mc_bases do
88596: LD_ADDR_VAR 0 3
88600: PUSH
88601: DOUBLE
88602: LD_INT 1
88604: DEC
88605: ST_TO_ADDR
88606: LD_EXP 61
88610: PUSH
88611: FOR_TO
88612: IFFALSE 89255
// begin if building in mc_construct_list [ i ] then
88614: LD_VAR 0 1
88618: PUSH
88619: LD_EXP 68
88623: PUSH
88624: LD_VAR 0 3
88628: ARRAY
88629: IN
88630: IFFALSE 89253
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88632: LD_ADDR_EXP 68
88636: PUSH
88637: LD_EXP 68
88641: PPUSH
88642: LD_VAR 0 3
88646: PPUSH
88647: LD_EXP 68
88651: PUSH
88652: LD_VAR 0 3
88656: ARRAY
88657: PUSH
88658: LD_VAR 0 1
88662: DIFF
88663: PPUSH
88664: CALL_OW 1
88668: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88669: LD_ADDR_EXP 61
88673: PUSH
88674: LD_EXP 61
88678: PPUSH
88679: LD_VAR 0 3
88683: PUSH
88684: LD_EXP 61
88688: PUSH
88689: LD_VAR 0 3
88693: ARRAY
88694: PUSH
88695: LD_INT 1
88697: PLUS
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PPUSH
88703: LD_VAR 0 1
88707: PPUSH
88708: CALL 21397 0 3
88712: ST_TO_ADDR
// btype := GetBType ( building ) ;
88713: LD_ADDR_VAR 0 5
88717: PUSH
88718: LD_VAR 0 1
88722: PPUSH
88723: CALL_OW 266
88727: ST_TO_ADDR
// side := GetSide ( building ) ;
88728: LD_ADDR_VAR 0 8
88732: PUSH
88733: LD_VAR 0 1
88737: PPUSH
88738: CALL_OW 255
88742: ST_TO_ADDR
// if btype = b_lab then
88743: LD_VAR 0 5
88747: PUSH
88748: LD_INT 6
88750: EQUAL
88751: IFFALSE 88801
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
88753: LD_ADDR_EXP 94
88757: PUSH
88758: LD_EXP 94
88762: PPUSH
88763: LD_VAR 0 3
88767: PUSH
88768: LD_EXP 94
88772: PUSH
88773: LD_VAR 0 3
88777: ARRAY
88778: PUSH
88779: LD_INT 1
88781: PLUS
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PPUSH
88787: LD_VAR 0 1
88791: PPUSH
88792: CALL 21397 0 3
88796: ST_TO_ADDR
// exit ;
88797: POP
88798: POP
88799: GO 89257
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
88801: LD_VAR 0 5
88805: PUSH
88806: LD_INT 0
88808: PUSH
88809: LD_INT 2
88811: PUSH
88812: LD_INT 4
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: LIST
88819: IN
88820: IFFALSE 88944
// begin if btype = b_armoury then
88822: LD_VAR 0 5
88826: PUSH
88827: LD_INT 4
88829: EQUAL
88830: IFFALSE 88840
// btype := b_barracks ;
88832: LD_ADDR_VAR 0 5
88836: PUSH
88837: LD_INT 5
88839: ST_TO_ADDR
// if btype = b_depot then
88840: LD_VAR 0 5
88844: PUSH
88845: LD_INT 0
88847: EQUAL
88848: IFFALSE 88858
// btype := b_warehouse ;
88850: LD_ADDR_VAR 0 5
88854: PUSH
88855: LD_INT 1
88857: ST_TO_ADDR
// if btype = b_workshop then
88858: LD_VAR 0 5
88862: PUSH
88863: LD_INT 2
88865: EQUAL
88866: IFFALSE 88876
// btype := b_factory ;
88868: LD_ADDR_VAR 0 5
88872: PUSH
88873: LD_INT 3
88875: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
88876: LD_VAR 0 5
88880: PPUSH
88881: LD_VAR 0 8
88885: PPUSH
88886: CALL_OW 323
88890: PUSH
88891: LD_INT 1
88893: EQUAL
88894: IFFALSE 88940
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
88896: LD_ADDR_EXP 93
88900: PUSH
88901: LD_EXP 93
88905: PPUSH
88906: LD_VAR 0 3
88910: PUSH
88911: LD_EXP 93
88915: PUSH
88916: LD_VAR 0 3
88920: ARRAY
88921: PUSH
88922: LD_INT 1
88924: PLUS
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PPUSH
88930: LD_VAR 0 1
88934: PPUSH
88935: CALL 21397 0 3
88939: ST_TO_ADDR
// exit ;
88940: POP
88941: POP
88942: GO 89257
// end ; if btype in [ b_bunker , b_turret ] then
88944: LD_VAR 0 5
88948: PUSH
88949: LD_INT 32
88951: PUSH
88952: LD_INT 33
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: IN
88959: IFFALSE 89249
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
88961: LD_ADDR_EXP 69
88965: PUSH
88966: LD_EXP 69
88970: PPUSH
88971: LD_VAR 0 3
88975: PUSH
88976: LD_EXP 69
88980: PUSH
88981: LD_VAR 0 3
88985: ARRAY
88986: PUSH
88987: LD_INT 1
88989: PLUS
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PPUSH
88995: LD_VAR 0 1
88999: PPUSH
89000: CALL 21397 0 3
89004: ST_TO_ADDR
// if btype = b_bunker then
89005: LD_VAR 0 5
89009: PUSH
89010: LD_INT 32
89012: EQUAL
89013: IFFALSE 89249
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89015: LD_ADDR_EXP 70
89019: PUSH
89020: LD_EXP 70
89024: PPUSH
89025: LD_VAR 0 3
89029: PUSH
89030: LD_EXP 70
89034: PUSH
89035: LD_VAR 0 3
89039: ARRAY
89040: PUSH
89041: LD_INT 1
89043: PLUS
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PPUSH
89049: LD_VAR 0 1
89053: PPUSH
89054: CALL 21397 0 3
89058: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89059: LD_ADDR_VAR 0 6
89063: PUSH
89064: LD_EXP 61
89068: PUSH
89069: LD_VAR 0 3
89073: ARRAY
89074: PPUSH
89075: LD_INT 25
89077: PUSH
89078: LD_INT 1
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 3
89087: PUSH
89088: LD_INT 54
89090: PUSH
89091: EMPTY
89092: LIST
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PPUSH
89102: CALL_OW 72
89106: ST_TO_ADDR
// if tmp then
89107: LD_VAR 0 6
89111: IFFALSE 89117
// exit ;
89113: POP
89114: POP
89115: GO 89257
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89117: LD_ADDR_VAR 0 6
89121: PUSH
89122: LD_EXP 61
89126: PUSH
89127: LD_VAR 0 3
89131: ARRAY
89132: PPUSH
89133: LD_INT 2
89135: PUSH
89136: LD_INT 30
89138: PUSH
89139: LD_INT 4
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 30
89148: PUSH
89149: LD_INT 5
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: LIST
89160: PPUSH
89161: CALL_OW 72
89165: ST_TO_ADDR
// if not tmp then
89166: LD_VAR 0 6
89170: NOT
89171: IFFALSE 89177
// exit ;
89173: POP
89174: POP
89175: GO 89257
// for j in tmp do
89177: LD_ADDR_VAR 0 4
89181: PUSH
89182: LD_VAR 0 6
89186: PUSH
89187: FOR_IN
89188: IFFALSE 89247
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
89190: LD_ADDR_VAR 0 7
89194: PUSH
89195: LD_VAR 0 4
89199: PPUSH
89200: CALL_OW 313
89204: PPUSH
89205: LD_INT 25
89207: PUSH
89208: LD_INT 1
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PPUSH
89215: CALL_OW 72
89219: ST_TO_ADDR
// if units then
89220: LD_VAR 0 7
89224: IFFALSE 89245
// begin ComExitBuilding ( units [ 1 ] ) ;
89226: LD_VAR 0 7
89230: PUSH
89231: LD_INT 1
89233: ARRAY
89234: PPUSH
89235: CALL_OW 122
// exit ;
89239: POP
89240: POP
89241: POP
89242: POP
89243: GO 89257
// end ; end ;
89245: GO 89187
89247: POP
89248: POP
// end ; end ; exit ;
89249: POP
89250: POP
89251: GO 89257
// end ; end ;
89253: GO 88611
89255: POP
89256: POP
// end ;
89257: LD_VAR 0 2
89261: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
89262: LD_INT 0
89264: PPUSH
89265: PPUSH
89266: PPUSH
89267: PPUSH
89268: PPUSH
89269: PPUSH
89270: PPUSH
// if not mc_bases or not skirmish then
89271: LD_EXP 61
89275: NOT
89276: PUSH
89277: LD_EXP 59
89281: NOT
89282: OR
89283: IFFALSE 89287
// exit ;
89285: GO 89552
// btype := GetBType ( building ) ;
89287: LD_ADDR_VAR 0 6
89291: PUSH
89292: LD_VAR 0 1
89296: PPUSH
89297: CALL_OW 266
89301: ST_TO_ADDR
// x := GetX ( building ) ;
89302: LD_ADDR_VAR 0 7
89306: PUSH
89307: LD_VAR 0 1
89311: PPUSH
89312: CALL_OW 250
89316: ST_TO_ADDR
// y := GetY ( building ) ;
89317: LD_ADDR_VAR 0 8
89321: PUSH
89322: LD_VAR 0 1
89326: PPUSH
89327: CALL_OW 251
89331: ST_TO_ADDR
// d := GetDir ( building ) ;
89332: LD_ADDR_VAR 0 9
89336: PUSH
89337: LD_VAR 0 1
89341: PPUSH
89342: CALL_OW 254
89346: ST_TO_ADDR
// for i = 1 to mc_bases do
89347: LD_ADDR_VAR 0 4
89351: PUSH
89352: DOUBLE
89353: LD_INT 1
89355: DEC
89356: ST_TO_ADDR
89357: LD_EXP 61
89361: PUSH
89362: FOR_TO
89363: IFFALSE 89550
// begin if not mc_build_list [ i ] then
89365: LD_EXP 66
89369: PUSH
89370: LD_VAR 0 4
89374: ARRAY
89375: NOT
89376: IFFALSE 89380
// continue ;
89378: GO 89362
// for j := 1 to mc_build_list [ i ] do
89380: LD_ADDR_VAR 0 5
89384: PUSH
89385: DOUBLE
89386: LD_INT 1
89388: DEC
89389: ST_TO_ADDR
89390: LD_EXP 66
89394: PUSH
89395: LD_VAR 0 4
89399: ARRAY
89400: PUSH
89401: FOR_TO
89402: IFFALSE 89546
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
89404: LD_VAR 0 6
89408: PUSH
89409: LD_VAR 0 7
89413: PUSH
89414: LD_VAR 0 8
89418: PUSH
89419: LD_VAR 0 9
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: PPUSH
89430: LD_EXP 66
89434: PUSH
89435: LD_VAR 0 4
89439: ARRAY
89440: PUSH
89441: LD_VAR 0 5
89445: ARRAY
89446: PPUSH
89447: CALL 27954 0 2
89451: IFFALSE 89544
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
89453: LD_ADDR_EXP 66
89457: PUSH
89458: LD_EXP 66
89462: PPUSH
89463: LD_VAR 0 4
89467: PPUSH
89468: LD_EXP 66
89472: PUSH
89473: LD_VAR 0 4
89477: ARRAY
89478: PPUSH
89479: LD_VAR 0 5
89483: PPUSH
89484: CALL_OW 3
89488: PPUSH
89489: CALL_OW 1
89493: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
89494: LD_ADDR_EXP 68
89498: PUSH
89499: LD_EXP 68
89503: PPUSH
89504: LD_VAR 0 4
89508: PUSH
89509: LD_EXP 68
89513: PUSH
89514: LD_VAR 0 4
89518: ARRAY
89519: PUSH
89520: LD_INT 1
89522: PLUS
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PPUSH
89528: LD_VAR 0 1
89532: PPUSH
89533: CALL 21397 0 3
89537: ST_TO_ADDR
// exit ;
89538: POP
89539: POP
89540: POP
89541: POP
89542: GO 89552
// end ;
89544: GO 89401
89546: POP
89547: POP
// end ;
89548: GO 89362
89550: POP
89551: POP
// end ;
89552: LD_VAR 0 3
89556: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
89557: LD_INT 0
89559: PPUSH
89560: PPUSH
89561: PPUSH
// if not mc_bases or not skirmish then
89562: LD_EXP 61
89566: NOT
89567: PUSH
89568: LD_EXP 59
89572: NOT
89573: OR
89574: IFFALSE 89578
// exit ;
89576: GO 89768
// for i = 1 to mc_bases do
89578: LD_ADDR_VAR 0 4
89582: PUSH
89583: DOUBLE
89584: LD_INT 1
89586: DEC
89587: ST_TO_ADDR
89588: LD_EXP 61
89592: PUSH
89593: FOR_TO
89594: IFFALSE 89681
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
89596: LD_VAR 0 1
89600: PUSH
89601: LD_EXP 69
89605: PUSH
89606: LD_VAR 0 4
89610: ARRAY
89611: IN
89612: PUSH
89613: LD_VAR 0 1
89617: PUSH
89618: LD_EXP 70
89622: PUSH
89623: LD_VAR 0 4
89627: ARRAY
89628: IN
89629: NOT
89630: AND
89631: IFFALSE 89679
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89633: LD_ADDR_EXP 70
89637: PUSH
89638: LD_EXP 70
89642: PPUSH
89643: LD_VAR 0 4
89647: PUSH
89648: LD_EXP 70
89652: PUSH
89653: LD_VAR 0 4
89657: ARRAY
89658: PUSH
89659: LD_INT 1
89661: PLUS
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: PPUSH
89667: LD_VAR 0 1
89671: PPUSH
89672: CALL 21397 0 3
89676: ST_TO_ADDR
// break ;
89677: GO 89681
// end ; end ;
89679: GO 89593
89681: POP
89682: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
89683: LD_VAR 0 1
89687: PPUSH
89688: CALL_OW 257
89692: PUSH
89693: LD_EXP 87
89697: IN
89698: PUSH
89699: LD_VAR 0 1
89703: PPUSH
89704: CALL_OW 266
89708: PUSH
89709: LD_INT 5
89711: EQUAL
89712: AND
89713: PUSH
89714: LD_VAR 0 2
89718: PPUSH
89719: CALL_OW 110
89723: PUSH
89724: LD_INT 18
89726: NONEQUAL
89727: AND
89728: IFFALSE 89768
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
89730: LD_VAR 0 2
89734: PPUSH
89735: CALL_OW 257
89739: PUSH
89740: LD_INT 5
89742: PUSH
89743: LD_INT 8
89745: PUSH
89746: LD_INT 9
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: LIST
89753: IN
89754: IFFALSE 89768
// SetClass ( unit , 1 ) ;
89756: LD_VAR 0 2
89760: PPUSH
89761: LD_INT 1
89763: PPUSH
89764: CALL_OW 336
// end ;
89768: LD_VAR 0 3
89772: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
89773: LD_INT 0
89775: PPUSH
89776: PPUSH
// if not mc_bases or not skirmish then
89777: LD_EXP 61
89781: NOT
89782: PUSH
89783: LD_EXP 59
89787: NOT
89788: OR
89789: IFFALSE 89793
// exit ;
89791: GO 89909
// if GetLives ( abandoned_vehicle ) > 250 then
89793: LD_VAR 0 2
89797: PPUSH
89798: CALL_OW 256
89802: PUSH
89803: LD_INT 250
89805: GREATER
89806: IFFALSE 89810
// exit ;
89808: GO 89909
// for i = 1 to mc_bases do
89810: LD_ADDR_VAR 0 6
89814: PUSH
89815: DOUBLE
89816: LD_INT 1
89818: DEC
89819: ST_TO_ADDR
89820: LD_EXP 61
89824: PUSH
89825: FOR_TO
89826: IFFALSE 89907
// begin if driver in mc_bases [ i ] then
89828: LD_VAR 0 1
89832: PUSH
89833: LD_EXP 61
89837: PUSH
89838: LD_VAR 0 6
89842: ARRAY
89843: IN
89844: IFFALSE 89905
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
89846: LD_VAR 0 1
89850: PPUSH
89851: LD_EXP 61
89855: PUSH
89856: LD_VAR 0 6
89860: ARRAY
89861: PPUSH
89862: LD_INT 2
89864: PUSH
89865: LD_INT 30
89867: PUSH
89868: LD_INT 0
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 30
89877: PUSH
89878: LD_INT 1
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: LIST
89889: PPUSH
89890: CALL_OW 72
89894: PUSH
89895: LD_INT 1
89897: ARRAY
89898: PPUSH
89899: CALL 55003 0 2
// break ;
89903: GO 89907
// end ; end ;
89905: GO 89825
89907: POP
89908: POP
// end ; end_of_file end_of_file
89909: LD_VAR 0 5
89913: RET
// export globalGameSaveCounter ; every 0 0$1 do
89914: GO 89916
89916: DISABLE
// begin enable ;
89917: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89918: LD_STRING updateTimer(
89920: PUSH
89921: LD_OWVAR 1
89925: STR
89926: PUSH
89927: LD_STRING );
89929: STR
89930: PPUSH
89931: CALL_OW 559
// end ;
89935: END
// every 0 0$1 do
89936: GO 89938
89938: DISABLE
// begin globalGameSaveCounter := 0 ;
89939: LD_ADDR_EXP 106
89943: PUSH
89944: LD_INT 0
89946: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
89947: LD_STRING setGameSaveCounter(0)
89949: PPUSH
89950: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
89954: LD_STRING initStreamRollete();
89956: PPUSH
89957: CALL_OW 559
// InitStreamMode ;
89961: CALL 91304 0 0
// DefineStreamItems ( false ) ;
89965: LD_INT 0
89967: PPUSH
89968: CALL 91768 0 1
// end ;
89972: END
// export function SOS_MapStart ( ) ; begin
89973: LD_INT 0
89975: PPUSH
// if streamModeActive then
89976: LD_EXP 107
89980: IFFALSE 89989
// DefineStreamItems ( true ) ;
89982: LD_INT 1
89984: PPUSH
89985: CALL 91768 0 1
// UpdateLuaVariables ( ) ;
89989: CALL 90006 0 0
// UpdateFactoryWaypoints ( ) ;
89993: CALL 104637 0 0
// UpdateWarehouseGatheringPoints ( ) ;
89997: CALL 104894 0 0
// end ;
90001: LD_VAR 0 1
90005: RET
// function UpdateLuaVariables ( ) ; begin
90006: LD_INT 0
90008: PPUSH
// if globalGameSaveCounter then
90009: LD_EXP 106
90013: IFFALSE 90047
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90015: LD_ADDR_EXP 106
90019: PUSH
90020: LD_EXP 106
90024: PPUSH
90025: CALL 55487 0 1
90029: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90030: LD_STRING setGameSaveCounter(
90032: PUSH
90033: LD_EXP 106
90037: STR
90038: PUSH
90039: LD_STRING )
90041: STR
90042: PPUSH
90043: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90047: LD_STRING setGameDifficulty(
90049: PUSH
90050: LD_OWVAR 67
90054: STR
90055: PUSH
90056: LD_STRING )
90058: STR
90059: PPUSH
90060: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
90064: LD_STRING displayDifficulty(
90066: PUSH
90067: LD_OWVAR 67
90071: STR
90072: PUSH
90073: LD_STRING )
90075: STR
90076: PPUSH
90077: CALL_OW 559
// end ;
90081: LD_VAR 0 1
90085: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90086: LD_INT 0
90088: PPUSH
// if p2 = stream_mode then
90089: LD_VAR 0 2
90093: PUSH
90094: LD_INT 100
90096: EQUAL
90097: IFFALSE 91100
// begin if not StreamModeActive then
90099: LD_EXP 107
90103: NOT
90104: IFFALSE 90114
// StreamModeActive := true ;
90106: LD_ADDR_EXP 107
90110: PUSH
90111: LD_INT 1
90113: ST_TO_ADDR
// if p3 = 0 then
90114: LD_VAR 0 3
90118: PUSH
90119: LD_INT 0
90121: EQUAL
90122: IFFALSE 90128
// InitStreamMode ;
90124: CALL 91304 0 0
// if p3 = 1 then
90128: LD_VAR 0 3
90132: PUSH
90133: LD_INT 1
90135: EQUAL
90136: IFFALSE 90146
// sRocket := true ;
90138: LD_ADDR_EXP 112
90142: PUSH
90143: LD_INT 1
90145: ST_TO_ADDR
// if p3 = 2 then
90146: LD_VAR 0 3
90150: PUSH
90151: LD_INT 2
90153: EQUAL
90154: IFFALSE 90164
// sSpeed := true ;
90156: LD_ADDR_EXP 111
90160: PUSH
90161: LD_INT 1
90163: ST_TO_ADDR
// if p3 = 3 then
90164: LD_VAR 0 3
90168: PUSH
90169: LD_INT 3
90171: EQUAL
90172: IFFALSE 90182
// sEngine := true ;
90174: LD_ADDR_EXP 113
90178: PUSH
90179: LD_INT 1
90181: ST_TO_ADDR
// if p3 = 4 then
90182: LD_VAR 0 3
90186: PUSH
90187: LD_INT 4
90189: EQUAL
90190: IFFALSE 90200
// sSpec := true ;
90192: LD_ADDR_EXP 110
90196: PUSH
90197: LD_INT 1
90199: ST_TO_ADDR
// if p3 = 5 then
90200: LD_VAR 0 3
90204: PUSH
90205: LD_INT 5
90207: EQUAL
90208: IFFALSE 90218
// sLevel := true ;
90210: LD_ADDR_EXP 114
90214: PUSH
90215: LD_INT 1
90217: ST_TO_ADDR
// if p3 = 6 then
90218: LD_VAR 0 3
90222: PUSH
90223: LD_INT 6
90225: EQUAL
90226: IFFALSE 90236
// sArmoury := true ;
90228: LD_ADDR_EXP 115
90232: PUSH
90233: LD_INT 1
90235: ST_TO_ADDR
// if p3 = 7 then
90236: LD_VAR 0 3
90240: PUSH
90241: LD_INT 7
90243: EQUAL
90244: IFFALSE 90254
// sRadar := true ;
90246: LD_ADDR_EXP 116
90250: PUSH
90251: LD_INT 1
90253: ST_TO_ADDR
// if p3 = 8 then
90254: LD_VAR 0 3
90258: PUSH
90259: LD_INT 8
90261: EQUAL
90262: IFFALSE 90272
// sBunker := true ;
90264: LD_ADDR_EXP 117
90268: PUSH
90269: LD_INT 1
90271: ST_TO_ADDR
// if p3 = 9 then
90272: LD_VAR 0 3
90276: PUSH
90277: LD_INT 9
90279: EQUAL
90280: IFFALSE 90290
// sHack := true ;
90282: LD_ADDR_EXP 118
90286: PUSH
90287: LD_INT 1
90289: ST_TO_ADDR
// if p3 = 10 then
90290: LD_VAR 0 3
90294: PUSH
90295: LD_INT 10
90297: EQUAL
90298: IFFALSE 90308
// sFire := true ;
90300: LD_ADDR_EXP 119
90304: PUSH
90305: LD_INT 1
90307: ST_TO_ADDR
// if p3 = 11 then
90308: LD_VAR 0 3
90312: PUSH
90313: LD_INT 11
90315: EQUAL
90316: IFFALSE 90326
// sRefresh := true ;
90318: LD_ADDR_EXP 120
90322: PUSH
90323: LD_INT 1
90325: ST_TO_ADDR
// if p3 = 12 then
90326: LD_VAR 0 3
90330: PUSH
90331: LD_INT 12
90333: EQUAL
90334: IFFALSE 90344
// sExp := true ;
90336: LD_ADDR_EXP 121
90340: PUSH
90341: LD_INT 1
90343: ST_TO_ADDR
// if p3 = 13 then
90344: LD_VAR 0 3
90348: PUSH
90349: LD_INT 13
90351: EQUAL
90352: IFFALSE 90362
// sDepot := true ;
90354: LD_ADDR_EXP 122
90358: PUSH
90359: LD_INT 1
90361: ST_TO_ADDR
// if p3 = 14 then
90362: LD_VAR 0 3
90366: PUSH
90367: LD_INT 14
90369: EQUAL
90370: IFFALSE 90380
// sFlag := true ;
90372: LD_ADDR_EXP 123
90376: PUSH
90377: LD_INT 1
90379: ST_TO_ADDR
// if p3 = 15 then
90380: LD_VAR 0 3
90384: PUSH
90385: LD_INT 15
90387: EQUAL
90388: IFFALSE 90398
// sKamikadze := true ;
90390: LD_ADDR_EXP 131
90394: PUSH
90395: LD_INT 1
90397: ST_TO_ADDR
// if p3 = 16 then
90398: LD_VAR 0 3
90402: PUSH
90403: LD_INT 16
90405: EQUAL
90406: IFFALSE 90416
// sTroll := true ;
90408: LD_ADDR_EXP 132
90412: PUSH
90413: LD_INT 1
90415: ST_TO_ADDR
// if p3 = 17 then
90416: LD_VAR 0 3
90420: PUSH
90421: LD_INT 17
90423: EQUAL
90424: IFFALSE 90434
// sSlow := true ;
90426: LD_ADDR_EXP 133
90430: PUSH
90431: LD_INT 1
90433: ST_TO_ADDR
// if p3 = 18 then
90434: LD_VAR 0 3
90438: PUSH
90439: LD_INT 18
90441: EQUAL
90442: IFFALSE 90452
// sLack := true ;
90444: LD_ADDR_EXP 134
90448: PUSH
90449: LD_INT 1
90451: ST_TO_ADDR
// if p3 = 19 then
90452: LD_VAR 0 3
90456: PUSH
90457: LD_INT 19
90459: EQUAL
90460: IFFALSE 90470
// sTank := true ;
90462: LD_ADDR_EXP 136
90466: PUSH
90467: LD_INT 1
90469: ST_TO_ADDR
// if p3 = 20 then
90470: LD_VAR 0 3
90474: PUSH
90475: LD_INT 20
90477: EQUAL
90478: IFFALSE 90488
// sRemote := true ;
90480: LD_ADDR_EXP 137
90484: PUSH
90485: LD_INT 1
90487: ST_TO_ADDR
// if p3 = 21 then
90488: LD_VAR 0 3
90492: PUSH
90493: LD_INT 21
90495: EQUAL
90496: IFFALSE 90506
// sPowell := true ;
90498: LD_ADDR_EXP 138
90502: PUSH
90503: LD_INT 1
90505: ST_TO_ADDR
// if p3 = 22 then
90506: LD_VAR 0 3
90510: PUSH
90511: LD_INT 22
90513: EQUAL
90514: IFFALSE 90524
// sTeleport := true ;
90516: LD_ADDR_EXP 141
90520: PUSH
90521: LD_INT 1
90523: ST_TO_ADDR
// if p3 = 23 then
90524: LD_VAR 0 3
90528: PUSH
90529: LD_INT 23
90531: EQUAL
90532: IFFALSE 90542
// sOilTower := true ;
90534: LD_ADDR_EXP 143
90538: PUSH
90539: LD_INT 1
90541: ST_TO_ADDR
// if p3 = 24 then
90542: LD_VAR 0 3
90546: PUSH
90547: LD_INT 24
90549: EQUAL
90550: IFFALSE 90560
// sShovel := true ;
90552: LD_ADDR_EXP 144
90556: PUSH
90557: LD_INT 1
90559: ST_TO_ADDR
// if p3 = 25 then
90560: LD_VAR 0 3
90564: PUSH
90565: LD_INT 25
90567: EQUAL
90568: IFFALSE 90578
// sSheik := true ;
90570: LD_ADDR_EXP 145
90574: PUSH
90575: LD_INT 1
90577: ST_TO_ADDR
// if p3 = 26 then
90578: LD_VAR 0 3
90582: PUSH
90583: LD_INT 26
90585: EQUAL
90586: IFFALSE 90596
// sEarthquake := true ;
90588: LD_ADDR_EXP 147
90592: PUSH
90593: LD_INT 1
90595: ST_TO_ADDR
// if p3 = 27 then
90596: LD_VAR 0 3
90600: PUSH
90601: LD_INT 27
90603: EQUAL
90604: IFFALSE 90614
// sAI := true ;
90606: LD_ADDR_EXP 148
90610: PUSH
90611: LD_INT 1
90613: ST_TO_ADDR
// if p3 = 28 then
90614: LD_VAR 0 3
90618: PUSH
90619: LD_INT 28
90621: EQUAL
90622: IFFALSE 90632
// sCargo := true ;
90624: LD_ADDR_EXP 151
90628: PUSH
90629: LD_INT 1
90631: ST_TO_ADDR
// if p3 = 29 then
90632: LD_VAR 0 3
90636: PUSH
90637: LD_INT 29
90639: EQUAL
90640: IFFALSE 90650
// sDLaser := true ;
90642: LD_ADDR_EXP 152
90646: PUSH
90647: LD_INT 1
90649: ST_TO_ADDR
// if p3 = 30 then
90650: LD_VAR 0 3
90654: PUSH
90655: LD_INT 30
90657: EQUAL
90658: IFFALSE 90668
// sExchange := true ;
90660: LD_ADDR_EXP 153
90664: PUSH
90665: LD_INT 1
90667: ST_TO_ADDR
// if p3 = 31 then
90668: LD_VAR 0 3
90672: PUSH
90673: LD_INT 31
90675: EQUAL
90676: IFFALSE 90686
// sFac := true ;
90678: LD_ADDR_EXP 154
90682: PUSH
90683: LD_INT 1
90685: ST_TO_ADDR
// if p3 = 32 then
90686: LD_VAR 0 3
90690: PUSH
90691: LD_INT 32
90693: EQUAL
90694: IFFALSE 90704
// sPower := true ;
90696: LD_ADDR_EXP 155
90700: PUSH
90701: LD_INT 1
90703: ST_TO_ADDR
// if p3 = 33 then
90704: LD_VAR 0 3
90708: PUSH
90709: LD_INT 33
90711: EQUAL
90712: IFFALSE 90722
// sRandom := true ;
90714: LD_ADDR_EXP 156
90718: PUSH
90719: LD_INT 1
90721: ST_TO_ADDR
// if p3 = 34 then
90722: LD_VAR 0 3
90726: PUSH
90727: LD_INT 34
90729: EQUAL
90730: IFFALSE 90740
// sShield := true ;
90732: LD_ADDR_EXP 157
90736: PUSH
90737: LD_INT 1
90739: ST_TO_ADDR
// if p3 = 35 then
90740: LD_VAR 0 3
90744: PUSH
90745: LD_INT 35
90747: EQUAL
90748: IFFALSE 90758
// sTime := true ;
90750: LD_ADDR_EXP 158
90754: PUSH
90755: LD_INT 1
90757: ST_TO_ADDR
// if p3 = 36 then
90758: LD_VAR 0 3
90762: PUSH
90763: LD_INT 36
90765: EQUAL
90766: IFFALSE 90776
// sTools := true ;
90768: LD_ADDR_EXP 159
90772: PUSH
90773: LD_INT 1
90775: ST_TO_ADDR
// if p3 = 101 then
90776: LD_VAR 0 3
90780: PUSH
90781: LD_INT 101
90783: EQUAL
90784: IFFALSE 90794
// sSold := true ;
90786: LD_ADDR_EXP 124
90790: PUSH
90791: LD_INT 1
90793: ST_TO_ADDR
// if p3 = 102 then
90794: LD_VAR 0 3
90798: PUSH
90799: LD_INT 102
90801: EQUAL
90802: IFFALSE 90812
// sDiff := true ;
90804: LD_ADDR_EXP 125
90808: PUSH
90809: LD_INT 1
90811: ST_TO_ADDR
// if p3 = 103 then
90812: LD_VAR 0 3
90816: PUSH
90817: LD_INT 103
90819: EQUAL
90820: IFFALSE 90830
// sFog := true ;
90822: LD_ADDR_EXP 128
90826: PUSH
90827: LD_INT 1
90829: ST_TO_ADDR
// if p3 = 104 then
90830: LD_VAR 0 3
90834: PUSH
90835: LD_INT 104
90837: EQUAL
90838: IFFALSE 90848
// sReset := true ;
90840: LD_ADDR_EXP 129
90844: PUSH
90845: LD_INT 1
90847: ST_TO_ADDR
// if p3 = 105 then
90848: LD_VAR 0 3
90852: PUSH
90853: LD_INT 105
90855: EQUAL
90856: IFFALSE 90866
// sSun := true ;
90858: LD_ADDR_EXP 130
90862: PUSH
90863: LD_INT 1
90865: ST_TO_ADDR
// if p3 = 106 then
90866: LD_VAR 0 3
90870: PUSH
90871: LD_INT 106
90873: EQUAL
90874: IFFALSE 90884
// sTiger := true ;
90876: LD_ADDR_EXP 126
90880: PUSH
90881: LD_INT 1
90883: ST_TO_ADDR
// if p3 = 107 then
90884: LD_VAR 0 3
90888: PUSH
90889: LD_INT 107
90891: EQUAL
90892: IFFALSE 90902
// sBomb := true ;
90894: LD_ADDR_EXP 127
90898: PUSH
90899: LD_INT 1
90901: ST_TO_ADDR
// if p3 = 108 then
90902: LD_VAR 0 3
90906: PUSH
90907: LD_INT 108
90909: EQUAL
90910: IFFALSE 90920
// sWound := true ;
90912: LD_ADDR_EXP 135
90916: PUSH
90917: LD_INT 1
90919: ST_TO_ADDR
// if p3 = 109 then
90920: LD_VAR 0 3
90924: PUSH
90925: LD_INT 109
90927: EQUAL
90928: IFFALSE 90938
// sBetray := true ;
90930: LD_ADDR_EXP 139
90934: PUSH
90935: LD_INT 1
90937: ST_TO_ADDR
// if p3 = 110 then
90938: LD_VAR 0 3
90942: PUSH
90943: LD_INT 110
90945: EQUAL
90946: IFFALSE 90956
// sContamin := true ;
90948: LD_ADDR_EXP 140
90952: PUSH
90953: LD_INT 1
90955: ST_TO_ADDR
// if p3 = 111 then
90956: LD_VAR 0 3
90960: PUSH
90961: LD_INT 111
90963: EQUAL
90964: IFFALSE 90974
// sOil := true ;
90966: LD_ADDR_EXP 142
90970: PUSH
90971: LD_INT 1
90973: ST_TO_ADDR
// if p3 = 112 then
90974: LD_VAR 0 3
90978: PUSH
90979: LD_INT 112
90981: EQUAL
90982: IFFALSE 90992
// sStu := true ;
90984: LD_ADDR_EXP 146
90988: PUSH
90989: LD_INT 1
90991: ST_TO_ADDR
// if p3 = 113 then
90992: LD_VAR 0 3
90996: PUSH
90997: LD_INT 113
90999: EQUAL
91000: IFFALSE 91010
// sBazooka := true ;
91002: LD_ADDR_EXP 149
91006: PUSH
91007: LD_INT 1
91009: ST_TO_ADDR
// if p3 = 114 then
91010: LD_VAR 0 3
91014: PUSH
91015: LD_INT 114
91017: EQUAL
91018: IFFALSE 91028
// sMortar := true ;
91020: LD_ADDR_EXP 150
91024: PUSH
91025: LD_INT 1
91027: ST_TO_ADDR
// if p3 = 115 then
91028: LD_VAR 0 3
91032: PUSH
91033: LD_INT 115
91035: EQUAL
91036: IFFALSE 91046
// sRanger := true ;
91038: LD_ADDR_EXP 160
91042: PUSH
91043: LD_INT 1
91045: ST_TO_ADDR
// if p3 = 116 then
91046: LD_VAR 0 3
91050: PUSH
91051: LD_INT 116
91053: EQUAL
91054: IFFALSE 91064
// sComputer := true ;
91056: LD_ADDR_EXP 161
91060: PUSH
91061: LD_INT 1
91063: ST_TO_ADDR
// if p3 = 117 then
91064: LD_VAR 0 3
91068: PUSH
91069: LD_INT 117
91071: EQUAL
91072: IFFALSE 91082
// s30 := true ;
91074: LD_ADDR_EXP 162
91078: PUSH
91079: LD_INT 1
91081: ST_TO_ADDR
// if p3 = 118 then
91082: LD_VAR 0 3
91086: PUSH
91087: LD_INT 118
91089: EQUAL
91090: IFFALSE 91100
// s60 := true ;
91092: LD_ADDR_EXP 163
91096: PUSH
91097: LD_INT 1
91099: ST_TO_ADDR
// end ; if p2 = hack_mode then
91100: LD_VAR 0 2
91104: PUSH
91105: LD_INT 101
91107: EQUAL
91108: IFFALSE 91236
// begin case p3 of 1 :
91110: LD_VAR 0 3
91114: PUSH
91115: LD_INT 1
91117: DOUBLE
91118: EQUAL
91119: IFTRUE 91123
91121: GO 91130
91123: POP
// hHackUnlimitedResources ; 2 :
91124: CALL 103383 0 0
91128: GO 91236
91130: LD_INT 2
91132: DOUBLE
91133: EQUAL
91134: IFTRUE 91138
91136: GO 91145
91138: POP
// hHackSetLevel10 ; 3 :
91139: CALL 103516 0 0
91143: GO 91236
91145: LD_INT 3
91147: DOUBLE
91148: EQUAL
91149: IFTRUE 91153
91151: GO 91160
91153: POP
// hHackSetLevel10YourUnits ; 4 :
91154: CALL 103601 0 0
91158: GO 91236
91160: LD_INT 4
91162: DOUBLE
91163: EQUAL
91164: IFTRUE 91168
91166: GO 91175
91168: POP
// hHackInvincible ; 5 :
91169: CALL 104049 0 0
91173: GO 91236
91175: LD_INT 5
91177: DOUBLE
91178: EQUAL
91179: IFTRUE 91183
91181: GO 91190
91183: POP
// hHackInvisible ; 6 :
91184: CALL 104160 0 0
91188: GO 91236
91190: LD_INT 6
91192: DOUBLE
91193: EQUAL
91194: IFTRUE 91198
91196: GO 91205
91198: POP
// hHackChangeYourSide ; 7 :
91199: CALL 104217 0 0
91203: GO 91236
91205: LD_INT 7
91207: DOUBLE
91208: EQUAL
91209: IFTRUE 91213
91211: GO 91220
91213: POP
// hHackChangeUnitSide ; 8 :
91214: CALL 104259 0 0
91218: GO 91236
91220: LD_INT 8
91222: DOUBLE
91223: EQUAL
91224: IFTRUE 91228
91226: GO 91235
91228: POP
// hHackFog ; end ;
91229: CALL 104360 0 0
91233: GO 91236
91235: POP
// end ; if p2 = game_save_mode then
91236: LD_VAR 0 2
91240: PUSH
91241: LD_INT 102
91243: EQUAL
91244: IFFALSE 91299
// begin if p3 = 1 then
91246: LD_VAR 0 3
91250: PUSH
91251: LD_INT 1
91253: EQUAL
91254: IFFALSE 91266
// globalGameSaveCounter := p4 ;
91256: LD_ADDR_EXP 106
91260: PUSH
91261: LD_VAR 0 4
91265: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91266: LD_VAR 0 3
91270: PUSH
91271: LD_INT 2
91273: EQUAL
91274: PUSH
91275: LD_EXP 106
91279: AND
91280: IFFALSE 91299
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91282: LD_STRING setGameSaveCounter(
91284: PUSH
91285: LD_EXP 106
91289: STR
91290: PUSH
91291: LD_STRING )
91293: STR
91294: PPUSH
91295: CALL_OW 559
// end ; end ;
91299: LD_VAR 0 7
91303: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91304: LD_INT 0
91306: PPUSH
// streamModeActive := false ;
91307: LD_ADDR_EXP 107
91311: PUSH
91312: LD_INT 0
91314: ST_TO_ADDR
// normalCounter := 36 ;
91315: LD_ADDR_EXP 108
91319: PUSH
91320: LD_INT 36
91322: ST_TO_ADDR
// hardcoreCounter := 18 ;
91323: LD_ADDR_EXP 109
91327: PUSH
91328: LD_INT 18
91330: ST_TO_ADDR
// sRocket := false ;
91331: LD_ADDR_EXP 112
91335: PUSH
91336: LD_INT 0
91338: ST_TO_ADDR
// sSpeed := false ;
91339: LD_ADDR_EXP 111
91343: PUSH
91344: LD_INT 0
91346: ST_TO_ADDR
// sEngine := false ;
91347: LD_ADDR_EXP 113
91351: PUSH
91352: LD_INT 0
91354: ST_TO_ADDR
// sSpec := false ;
91355: LD_ADDR_EXP 110
91359: PUSH
91360: LD_INT 0
91362: ST_TO_ADDR
// sLevel := false ;
91363: LD_ADDR_EXP 114
91367: PUSH
91368: LD_INT 0
91370: ST_TO_ADDR
// sArmoury := false ;
91371: LD_ADDR_EXP 115
91375: PUSH
91376: LD_INT 0
91378: ST_TO_ADDR
// sRadar := false ;
91379: LD_ADDR_EXP 116
91383: PUSH
91384: LD_INT 0
91386: ST_TO_ADDR
// sBunker := false ;
91387: LD_ADDR_EXP 117
91391: PUSH
91392: LD_INT 0
91394: ST_TO_ADDR
// sHack := false ;
91395: LD_ADDR_EXP 118
91399: PUSH
91400: LD_INT 0
91402: ST_TO_ADDR
// sFire := false ;
91403: LD_ADDR_EXP 119
91407: PUSH
91408: LD_INT 0
91410: ST_TO_ADDR
// sRefresh := false ;
91411: LD_ADDR_EXP 120
91415: PUSH
91416: LD_INT 0
91418: ST_TO_ADDR
// sExp := false ;
91419: LD_ADDR_EXP 121
91423: PUSH
91424: LD_INT 0
91426: ST_TO_ADDR
// sDepot := false ;
91427: LD_ADDR_EXP 122
91431: PUSH
91432: LD_INT 0
91434: ST_TO_ADDR
// sFlag := false ;
91435: LD_ADDR_EXP 123
91439: PUSH
91440: LD_INT 0
91442: ST_TO_ADDR
// sKamikadze := false ;
91443: LD_ADDR_EXP 131
91447: PUSH
91448: LD_INT 0
91450: ST_TO_ADDR
// sTroll := false ;
91451: LD_ADDR_EXP 132
91455: PUSH
91456: LD_INT 0
91458: ST_TO_ADDR
// sSlow := false ;
91459: LD_ADDR_EXP 133
91463: PUSH
91464: LD_INT 0
91466: ST_TO_ADDR
// sLack := false ;
91467: LD_ADDR_EXP 134
91471: PUSH
91472: LD_INT 0
91474: ST_TO_ADDR
// sTank := false ;
91475: LD_ADDR_EXP 136
91479: PUSH
91480: LD_INT 0
91482: ST_TO_ADDR
// sRemote := false ;
91483: LD_ADDR_EXP 137
91487: PUSH
91488: LD_INT 0
91490: ST_TO_ADDR
// sPowell := false ;
91491: LD_ADDR_EXP 138
91495: PUSH
91496: LD_INT 0
91498: ST_TO_ADDR
// sTeleport := false ;
91499: LD_ADDR_EXP 141
91503: PUSH
91504: LD_INT 0
91506: ST_TO_ADDR
// sOilTower := false ;
91507: LD_ADDR_EXP 143
91511: PUSH
91512: LD_INT 0
91514: ST_TO_ADDR
// sShovel := false ;
91515: LD_ADDR_EXP 144
91519: PUSH
91520: LD_INT 0
91522: ST_TO_ADDR
// sSheik := false ;
91523: LD_ADDR_EXP 145
91527: PUSH
91528: LD_INT 0
91530: ST_TO_ADDR
// sEarthquake := false ;
91531: LD_ADDR_EXP 147
91535: PUSH
91536: LD_INT 0
91538: ST_TO_ADDR
// sAI := false ;
91539: LD_ADDR_EXP 148
91543: PUSH
91544: LD_INT 0
91546: ST_TO_ADDR
// sCargo := false ;
91547: LD_ADDR_EXP 151
91551: PUSH
91552: LD_INT 0
91554: ST_TO_ADDR
// sDLaser := false ;
91555: LD_ADDR_EXP 152
91559: PUSH
91560: LD_INT 0
91562: ST_TO_ADDR
// sExchange := false ;
91563: LD_ADDR_EXP 153
91567: PUSH
91568: LD_INT 0
91570: ST_TO_ADDR
// sFac := false ;
91571: LD_ADDR_EXP 154
91575: PUSH
91576: LD_INT 0
91578: ST_TO_ADDR
// sPower := false ;
91579: LD_ADDR_EXP 155
91583: PUSH
91584: LD_INT 0
91586: ST_TO_ADDR
// sRandom := false ;
91587: LD_ADDR_EXP 156
91591: PUSH
91592: LD_INT 0
91594: ST_TO_ADDR
// sShield := false ;
91595: LD_ADDR_EXP 157
91599: PUSH
91600: LD_INT 0
91602: ST_TO_ADDR
// sTime := false ;
91603: LD_ADDR_EXP 158
91607: PUSH
91608: LD_INT 0
91610: ST_TO_ADDR
// sTools := false ;
91611: LD_ADDR_EXP 159
91615: PUSH
91616: LD_INT 0
91618: ST_TO_ADDR
// sSold := false ;
91619: LD_ADDR_EXP 124
91623: PUSH
91624: LD_INT 0
91626: ST_TO_ADDR
// sDiff := false ;
91627: LD_ADDR_EXP 125
91631: PUSH
91632: LD_INT 0
91634: ST_TO_ADDR
// sFog := false ;
91635: LD_ADDR_EXP 128
91639: PUSH
91640: LD_INT 0
91642: ST_TO_ADDR
// sReset := false ;
91643: LD_ADDR_EXP 129
91647: PUSH
91648: LD_INT 0
91650: ST_TO_ADDR
// sSun := false ;
91651: LD_ADDR_EXP 130
91655: PUSH
91656: LD_INT 0
91658: ST_TO_ADDR
// sTiger := false ;
91659: LD_ADDR_EXP 126
91663: PUSH
91664: LD_INT 0
91666: ST_TO_ADDR
// sBomb := false ;
91667: LD_ADDR_EXP 127
91671: PUSH
91672: LD_INT 0
91674: ST_TO_ADDR
// sWound := false ;
91675: LD_ADDR_EXP 135
91679: PUSH
91680: LD_INT 0
91682: ST_TO_ADDR
// sBetray := false ;
91683: LD_ADDR_EXP 139
91687: PUSH
91688: LD_INT 0
91690: ST_TO_ADDR
// sContamin := false ;
91691: LD_ADDR_EXP 140
91695: PUSH
91696: LD_INT 0
91698: ST_TO_ADDR
// sOil := false ;
91699: LD_ADDR_EXP 142
91703: PUSH
91704: LD_INT 0
91706: ST_TO_ADDR
// sStu := false ;
91707: LD_ADDR_EXP 146
91711: PUSH
91712: LD_INT 0
91714: ST_TO_ADDR
// sBazooka := false ;
91715: LD_ADDR_EXP 149
91719: PUSH
91720: LD_INT 0
91722: ST_TO_ADDR
// sMortar := false ;
91723: LD_ADDR_EXP 150
91727: PUSH
91728: LD_INT 0
91730: ST_TO_ADDR
// sRanger := false ;
91731: LD_ADDR_EXP 160
91735: PUSH
91736: LD_INT 0
91738: ST_TO_ADDR
// sComputer := false ;
91739: LD_ADDR_EXP 161
91743: PUSH
91744: LD_INT 0
91746: ST_TO_ADDR
// s30 := false ;
91747: LD_ADDR_EXP 162
91751: PUSH
91752: LD_INT 0
91754: ST_TO_ADDR
// s60 := false ;
91755: LD_ADDR_EXP 163
91759: PUSH
91760: LD_INT 0
91762: ST_TO_ADDR
// end ;
91763: LD_VAR 0 1
91767: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91768: LD_INT 0
91770: PPUSH
91771: PPUSH
91772: PPUSH
91773: PPUSH
91774: PPUSH
91775: PPUSH
91776: PPUSH
// result := [ ] ;
91777: LD_ADDR_VAR 0 2
91781: PUSH
91782: EMPTY
91783: ST_TO_ADDR
// if campaign_id = 1 then
91784: LD_OWVAR 69
91788: PUSH
91789: LD_INT 1
91791: EQUAL
91792: IFFALSE 94958
// begin case mission_number of 1 :
91794: LD_OWVAR 70
91798: PUSH
91799: LD_INT 1
91801: DOUBLE
91802: EQUAL
91803: IFTRUE 91807
91805: GO 91883
91807: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91808: LD_ADDR_VAR 0 2
91812: PUSH
91813: LD_INT 2
91815: PUSH
91816: LD_INT 4
91818: PUSH
91819: LD_INT 11
91821: PUSH
91822: LD_INT 12
91824: PUSH
91825: LD_INT 15
91827: PUSH
91828: LD_INT 16
91830: PUSH
91831: LD_INT 22
91833: PUSH
91834: LD_INT 23
91836: PUSH
91837: LD_INT 26
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 101
91853: PUSH
91854: LD_INT 102
91856: PUSH
91857: LD_INT 106
91859: PUSH
91860: LD_INT 116
91862: PUSH
91863: LD_INT 117
91865: PUSH
91866: LD_INT 118
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: ST_TO_ADDR
91881: GO 94956
91883: LD_INT 2
91885: DOUBLE
91886: EQUAL
91887: IFTRUE 91891
91889: GO 91975
91891: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91892: LD_ADDR_VAR 0 2
91896: PUSH
91897: LD_INT 2
91899: PUSH
91900: LD_INT 4
91902: PUSH
91903: LD_INT 11
91905: PUSH
91906: LD_INT 12
91908: PUSH
91909: LD_INT 15
91911: PUSH
91912: LD_INT 16
91914: PUSH
91915: LD_INT 22
91917: PUSH
91918: LD_INT 23
91920: PUSH
91921: LD_INT 26
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 101
91937: PUSH
91938: LD_INT 102
91940: PUSH
91941: LD_INT 105
91943: PUSH
91944: LD_INT 106
91946: PUSH
91947: LD_INT 108
91949: PUSH
91950: LD_INT 116
91952: PUSH
91953: LD_INT 117
91955: PUSH
91956: LD_INT 118
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: ST_TO_ADDR
91973: GO 94956
91975: LD_INT 3
91977: DOUBLE
91978: EQUAL
91979: IFTRUE 91983
91981: GO 92071
91983: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91984: LD_ADDR_VAR 0 2
91988: PUSH
91989: LD_INT 2
91991: PUSH
91992: LD_INT 4
91994: PUSH
91995: LD_INT 5
91997: PUSH
91998: LD_INT 11
92000: PUSH
92001: LD_INT 12
92003: PUSH
92004: LD_INT 15
92006: PUSH
92007: LD_INT 16
92009: PUSH
92010: LD_INT 22
92012: PUSH
92013: LD_INT 26
92015: PUSH
92016: LD_INT 36
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 101
92033: PUSH
92034: LD_INT 102
92036: PUSH
92037: LD_INT 105
92039: PUSH
92040: LD_INT 106
92042: PUSH
92043: LD_INT 108
92045: PUSH
92046: LD_INT 116
92048: PUSH
92049: LD_INT 117
92051: PUSH
92052: LD_INT 118
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: ST_TO_ADDR
92069: GO 94956
92071: LD_INT 4
92073: DOUBLE
92074: EQUAL
92075: IFTRUE 92079
92077: GO 92175
92079: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92080: LD_ADDR_VAR 0 2
92084: PUSH
92085: LD_INT 2
92087: PUSH
92088: LD_INT 4
92090: PUSH
92091: LD_INT 5
92093: PUSH
92094: LD_INT 8
92096: PUSH
92097: LD_INT 11
92099: PUSH
92100: LD_INT 12
92102: PUSH
92103: LD_INT 15
92105: PUSH
92106: LD_INT 16
92108: PUSH
92109: LD_INT 22
92111: PUSH
92112: LD_INT 23
92114: PUSH
92115: LD_INT 26
92117: PUSH
92118: LD_INT 36
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 101
92137: PUSH
92138: LD_INT 102
92140: PUSH
92141: LD_INT 105
92143: PUSH
92144: LD_INT 106
92146: PUSH
92147: LD_INT 108
92149: PUSH
92150: LD_INT 116
92152: PUSH
92153: LD_INT 117
92155: PUSH
92156: LD_INT 118
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: ST_TO_ADDR
92173: GO 94956
92175: LD_INT 5
92177: DOUBLE
92178: EQUAL
92179: IFTRUE 92183
92181: GO 92295
92183: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92184: LD_ADDR_VAR 0 2
92188: PUSH
92189: LD_INT 2
92191: PUSH
92192: LD_INT 4
92194: PUSH
92195: LD_INT 5
92197: PUSH
92198: LD_INT 6
92200: PUSH
92201: LD_INT 8
92203: PUSH
92204: LD_INT 11
92206: PUSH
92207: LD_INT 12
92209: PUSH
92210: LD_INT 15
92212: PUSH
92213: LD_INT 16
92215: PUSH
92216: LD_INT 22
92218: PUSH
92219: LD_INT 23
92221: PUSH
92222: LD_INT 25
92224: PUSH
92225: LD_INT 26
92227: PUSH
92228: LD_INT 36
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 101
92249: PUSH
92250: LD_INT 102
92252: PUSH
92253: LD_INT 105
92255: PUSH
92256: LD_INT 106
92258: PUSH
92259: LD_INT 108
92261: PUSH
92262: LD_INT 109
92264: PUSH
92265: LD_INT 112
92267: PUSH
92268: LD_INT 116
92270: PUSH
92271: LD_INT 117
92273: PUSH
92274: LD_INT 118
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: ST_TO_ADDR
92293: GO 94956
92295: LD_INT 6
92297: DOUBLE
92298: EQUAL
92299: IFTRUE 92303
92301: GO 92435
92303: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92304: LD_ADDR_VAR 0 2
92308: PUSH
92309: LD_INT 2
92311: PUSH
92312: LD_INT 4
92314: PUSH
92315: LD_INT 5
92317: PUSH
92318: LD_INT 6
92320: PUSH
92321: LD_INT 8
92323: PUSH
92324: LD_INT 11
92326: PUSH
92327: LD_INT 12
92329: PUSH
92330: LD_INT 15
92332: PUSH
92333: LD_INT 16
92335: PUSH
92336: LD_INT 20
92338: PUSH
92339: LD_INT 21
92341: PUSH
92342: LD_INT 22
92344: PUSH
92345: LD_INT 23
92347: PUSH
92348: LD_INT 25
92350: PUSH
92351: LD_INT 26
92353: PUSH
92354: LD_INT 30
92356: PUSH
92357: LD_INT 31
92359: PUSH
92360: LD_INT 32
92362: PUSH
92363: LD_INT 36
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 101
92389: PUSH
92390: LD_INT 102
92392: PUSH
92393: LD_INT 105
92395: PUSH
92396: LD_INT 106
92398: PUSH
92399: LD_INT 108
92401: PUSH
92402: LD_INT 109
92404: PUSH
92405: LD_INT 112
92407: PUSH
92408: LD_INT 116
92410: PUSH
92411: LD_INT 117
92413: PUSH
92414: LD_INT 118
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: ST_TO_ADDR
92433: GO 94956
92435: LD_INT 7
92437: DOUBLE
92438: EQUAL
92439: IFTRUE 92443
92441: GO 92555
92443: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92444: LD_ADDR_VAR 0 2
92448: PUSH
92449: LD_INT 2
92451: PUSH
92452: LD_INT 4
92454: PUSH
92455: LD_INT 5
92457: PUSH
92458: LD_INT 7
92460: PUSH
92461: LD_INT 11
92463: PUSH
92464: LD_INT 12
92466: PUSH
92467: LD_INT 15
92469: PUSH
92470: LD_INT 16
92472: PUSH
92473: LD_INT 20
92475: PUSH
92476: LD_INT 21
92478: PUSH
92479: LD_INT 22
92481: PUSH
92482: LD_INT 23
92484: PUSH
92485: LD_INT 25
92487: PUSH
92488: LD_INT 26
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 101
92509: PUSH
92510: LD_INT 102
92512: PUSH
92513: LD_INT 103
92515: PUSH
92516: LD_INT 105
92518: PUSH
92519: LD_INT 106
92521: PUSH
92522: LD_INT 108
92524: PUSH
92525: LD_INT 112
92527: PUSH
92528: LD_INT 116
92530: PUSH
92531: LD_INT 117
92533: PUSH
92534: LD_INT 118
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: ST_TO_ADDR
92553: GO 94956
92555: LD_INT 8
92557: DOUBLE
92558: EQUAL
92559: IFTRUE 92563
92561: GO 92703
92563: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92564: LD_ADDR_VAR 0 2
92568: PUSH
92569: LD_INT 2
92571: PUSH
92572: LD_INT 4
92574: PUSH
92575: LD_INT 5
92577: PUSH
92578: LD_INT 6
92580: PUSH
92581: LD_INT 7
92583: PUSH
92584: LD_INT 8
92586: PUSH
92587: LD_INT 11
92589: PUSH
92590: LD_INT 12
92592: PUSH
92593: LD_INT 15
92595: PUSH
92596: LD_INT 16
92598: PUSH
92599: LD_INT 20
92601: PUSH
92602: LD_INT 21
92604: PUSH
92605: LD_INT 22
92607: PUSH
92608: LD_INT 23
92610: PUSH
92611: LD_INT 25
92613: PUSH
92614: LD_INT 26
92616: PUSH
92617: LD_INT 30
92619: PUSH
92620: LD_INT 31
92622: PUSH
92623: LD_INT 32
92625: PUSH
92626: LD_INT 36
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 101
92653: PUSH
92654: LD_INT 102
92656: PUSH
92657: LD_INT 103
92659: PUSH
92660: LD_INT 105
92662: PUSH
92663: LD_INT 106
92665: PUSH
92666: LD_INT 108
92668: PUSH
92669: LD_INT 109
92671: PUSH
92672: LD_INT 112
92674: PUSH
92675: LD_INT 116
92677: PUSH
92678: LD_INT 117
92680: PUSH
92681: LD_INT 118
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: ST_TO_ADDR
92701: GO 94956
92703: LD_INT 9
92705: DOUBLE
92706: EQUAL
92707: IFTRUE 92711
92709: GO 92859
92711: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92712: LD_ADDR_VAR 0 2
92716: PUSH
92717: LD_INT 2
92719: PUSH
92720: LD_INT 4
92722: PUSH
92723: LD_INT 5
92725: PUSH
92726: LD_INT 6
92728: PUSH
92729: LD_INT 7
92731: PUSH
92732: LD_INT 8
92734: PUSH
92735: LD_INT 11
92737: PUSH
92738: LD_INT 12
92740: PUSH
92741: LD_INT 15
92743: PUSH
92744: LD_INT 16
92746: PUSH
92747: LD_INT 20
92749: PUSH
92750: LD_INT 21
92752: PUSH
92753: LD_INT 22
92755: PUSH
92756: LD_INT 23
92758: PUSH
92759: LD_INT 25
92761: PUSH
92762: LD_INT 26
92764: PUSH
92765: LD_INT 28
92767: PUSH
92768: LD_INT 30
92770: PUSH
92771: LD_INT 31
92773: PUSH
92774: LD_INT 32
92776: PUSH
92777: LD_INT 36
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: PUSH
92803: LD_INT 101
92805: PUSH
92806: LD_INT 102
92808: PUSH
92809: LD_INT 103
92811: PUSH
92812: LD_INT 105
92814: PUSH
92815: LD_INT 106
92817: PUSH
92818: LD_INT 108
92820: PUSH
92821: LD_INT 109
92823: PUSH
92824: LD_INT 112
92826: PUSH
92827: LD_INT 114
92829: PUSH
92830: LD_INT 116
92832: PUSH
92833: LD_INT 117
92835: PUSH
92836: LD_INT 118
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: ST_TO_ADDR
92857: GO 94956
92859: LD_INT 10
92861: DOUBLE
92862: EQUAL
92863: IFTRUE 92867
92865: GO 93063
92867: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92868: LD_ADDR_VAR 0 2
92872: PUSH
92873: LD_INT 2
92875: PUSH
92876: LD_INT 4
92878: PUSH
92879: LD_INT 5
92881: PUSH
92882: LD_INT 6
92884: PUSH
92885: LD_INT 7
92887: PUSH
92888: LD_INT 8
92890: PUSH
92891: LD_INT 9
92893: PUSH
92894: LD_INT 10
92896: PUSH
92897: LD_INT 11
92899: PUSH
92900: LD_INT 12
92902: PUSH
92903: LD_INT 13
92905: PUSH
92906: LD_INT 14
92908: PUSH
92909: LD_INT 15
92911: PUSH
92912: LD_INT 16
92914: PUSH
92915: LD_INT 17
92917: PUSH
92918: LD_INT 18
92920: PUSH
92921: LD_INT 19
92923: PUSH
92924: LD_INT 20
92926: PUSH
92927: LD_INT 21
92929: PUSH
92930: LD_INT 22
92932: PUSH
92933: LD_INT 23
92935: PUSH
92936: LD_INT 24
92938: PUSH
92939: LD_INT 25
92941: PUSH
92942: LD_INT 26
92944: PUSH
92945: LD_INT 28
92947: PUSH
92948: LD_INT 30
92950: PUSH
92951: LD_INT 31
92953: PUSH
92954: LD_INT 32
92956: PUSH
92957: LD_INT 36
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 101
92993: PUSH
92994: LD_INT 102
92996: PUSH
92997: LD_INT 103
92999: PUSH
93000: LD_INT 104
93002: PUSH
93003: LD_INT 105
93005: PUSH
93006: LD_INT 106
93008: PUSH
93009: LD_INT 107
93011: PUSH
93012: LD_INT 108
93014: PUSH
93015: LD_INT 109
93017: PUSH
93018: LD_INT 110
93020: PUSH
93021: LD_INT 111
93023: PUSH
93024: LD_INT 112
93026: PUSH
93027: LD_INT 114
93029: PUSH
93030: LD_INT 116
93032: PUSH
93033: LD_INT 117
93035: PUSH
93036: LD_INT 118
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: ST_TO_ADDR
93061: GO 94956
93063: LD_INT 11
93065: DOUBLE
93066: EQUAL
93067: IFTRUE 93071
93069: GO 93275
93071: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93072: LD_ADDR_VAR 0 2
93076: PUSH
93077: LD_INT 2
93079: PUSH
93080: LD_INT 3
93082: PUSH
93083: LD_INT 4
93085: PUSH
93086: LD_INT 5
93088: PUSH
93089: LD_INT 6
93091: PUSH
93092: LD_INT 7
93094: PUSH
93095: LD_INT 8
93097: PUSH
93098: LD_INT 9
93100: PUSH
93101: LD_INT 10
93103: PUSH
93104: LD_INT 11
93106: PUSH
93107: LD_INT 12
93109: PUSH
93110: LD_INT 13
93112: PUSH
93113: LD_INT 14
93115: PUSH
93116: LD_INT 15
93118: PUSH
93119: LD_INT 16
93121: PUSH
93122: LD_INT 17
93124: PUSH
93125: LD_INT 18
93127: PUSH
93128: LD_INT 19
93130: PUSH
93131: LD_INT 20
93133: PUSH
93134: LD_INT 21
93136: PUSH
93137: LD_INT 22
93139: PUSH
93140: LD_INT 23
93142: PUSH
93143: LD_INT 24
93145: PUSH
93146: LD_INT 25
93148: PUSH
93149: LD_INT 26
93151: PUSH
93152: LD_INT 28
93154: PUSH
93155: LD_INT 30
93157: PUSH
93158: LD_INT 31
93160: PUSH
93161: LD_INT 32
93163: PUSH
93164: LD_INT 34
93166: PUSH
93167: LD_INT 36
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: PUSH
93203: LD_INT 101
93205: PUSH
93206: LD_INT 102
93208: PUSH
93209: LD_INT 103
93211: PUSH
93212: LD_INT 104
93214: PUSH
93215: LD_INT 105
93217: PUSH
93218: LD_INT 106
93220: PUSH
93221: LD_INT 107
93223: PUSH
93224: LD_INT 108
93226: PUSH
93227: LD_INT 109
93229: PUSH
93230: LD_INT 110
93232: PUSH
93233: LD_INT 111
93235: PUSH
93236: LD_INT 112
93238: PUSH
93239: LD_INT 114
93241: PUSH
93242: LD_INT 116
93244: PUSH
93245: LD_INT 117
93247: PUSH
93248: LD_INT 118
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: ST_TO_ADDR
93273: GO 94956
93275: LD_INT 12
93277: DOUBLE
93278: EQUAL
93279: IFTRUE 93283
93281: GO 93503
93283: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93284: LD_ADDR_VAR 0 2
93288: PUSH
93289: LD_INT 1
93291: PUSH
93292: LD_INT 2
93294: PUSH
93295: LD_INT 3
93297: PUSH
93298: LD_INT 4
93300: PUSH
93301: LD_INT 5
93303: PUSH
93304: LD_INT 6
93306: PUSH
93307: LD_INT 7
93309: PUSH
93310: LD_INT 8
93312: PUSH
93313: LD_INT 9
93315: PUSH
93316: LD_INT 10
93318: PUSH
93319: LD_INT 11
93321: PUSH
93322: LD_INT 12
93324: PUSH
93325: LD_INT 13
93327: PUSH
93328: LD_INT 14
93330: PUSH
93331: LD_INT 15
93333: PUSH
93334: LD_INT 16
93336: PUSH
93337: LD_INT 17
93339: PUSH
93340: LD_INT 18
93342: PUSH
93343: LD_INT 19
93345: PUSH
93346: LD_INT 20
93348: PUSH
93349: LD_INT 21
93351: PUSH
93352: LD_INT 22
93354: PUSH
93355: LD_INT 23
93357: PUSH
93358: LD_INT 24
93360: PUSH
93361: LD_INT 25
93363: PUSH
93364: LD_INT 26
93366: PUSH
93367: LD_INT 27
93369: PUSH
93370: LD_INT 28
93372: PUSH
93373: LD_INT 30
93375: PUSH
93376: LD_INT 31
93378: PUSH
93379: LD_INT 32
93381: PUSH
93382: LD_INT 33
93384: PUSH
93385: LD_INT 34
93387: PUSH
93388: LD_INT 36
93390: PUSH
93391: EMPTY
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 101
93429: PUSH
93430: LD_INT 102
93432: PUSH
93433: LD_INT 103
93435: PUSH
93436: LD_INT 104
93438: PUSH
93439: LD_INT 105
93441: PUSH
93442: LD_INT 106
93444: PUSH
93445: LD_INT 107
93447: PUSH
93448: LD_INT 108
93450: PUSH
93451: LD_INT 109
93453: PUSH
93454: LD_INT 110
93456: PUSH
93457: LD_INT 111
93459: PUSH
93460: LD_INT 112
93462: PUSH
93463: LD_INT 113
93465: PUSH
93466: LD_INT 114
93468: PUSH
93469: LD_INT 116
93471: PUSH
93472: LD_INT 117
93474: PUSH
93475: LD_INT 118
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: ST_TO_ADDR
93501: GO 94956
93503: LD_INT 13
93505: DOUBLE
93506: EQUAL
93507: IFTRUE 93511
93509: GO 93719
93511: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93512: LD_ADDR_VAR 0 2
93516: PUSH
93517: LD_INT 1
93519: PUSH
93520: LD_INT 2
93522: PUSH
93523: LD_INT 3
93525: PUSH
93526: LD_INT 4
93528: PUSH
93529: LD_INT 5
93531: PUSH
93532: LD_INT 8
93534: PUSH
93535: LD_INT 9
93537: PUSH
93538: LD_INT 10
93540: PUSH
93541: LD_INT 11
93543: PUSH
93544: LD_INT 12
93546: PUSH
93547: LD_INT 14
93549: PUSH
93550: LD_INT 15
93552: PUSH
93553: LD_INT 16
93555: PUSH
93556: LD_INT 17
93558: PUSH
93559: LD_INT 18
93561: PUSH
93562: LD_INT 19
93564: PUSH
93565: LD_INT 20
93567: PUSH
93568: LD_INT 21
93570: PUSH
93571: LD_INT 22
93573: PUSH
93574: LD_INT 23
93576: PUSH
93577: LD_INT 24
93579: PUSH
93580: LD_INT 25
93582: PUSH
93583: LD_INT 26
93585: PUSH
93586: LD_INT 27
93588: PUSH
93589: LD_INT 28
93591: PUSH
93592: LD_INT 30
93594: PUSH
93595: LD_INT 31
93597: PUSH
93598: LD_INT 32
93600: PUSH
93601: LD_INT 33
93603: PUSH
93604: LD_INT 34
93606: PUSH
93607: LD_INT 36
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 101
93645: PUSH
93646: LD_INT 102
93648: PUSH
93649: LD_INT 103
93651: PUSH
93652: LD_INT 104
93654: PUSH
93655: LD_INT 105
93657: PUSH
93658: LD_INT 106
93660: PUSH
93661: LD_INT 107
93663: PUSH
93664: LD_INT 108
93666: PUSH
93667: LD_INT 109
93669: PUSH
93670: LD_INT 110
93672: PUSH
93673: LD_INT 111
93675: PUSH
93676: LD_INT 112
93678: PUSH
93679: LD_INT 113
93681: PUSH
93682: LD_INT 114
93684: PUSH
93685: LD_INT 116
93687: PUSH
93688: LD_INT 117
93690: PUSH
93691: LD_INT 118
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: ST_TO_ADDR
93717: GO 94956
93719: LD_INT 14
93721: DOUBLE
93722: EQUAL
93723: IFTRUE 93727
93725: GO 93951
93727: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93728: LD_ADDR_VAR 0 2
93732: PUSH
93733: LD_INT 1
93735: PUSH
93736: LD_INT 2
93738: PUSH
93739: LD_INT 3
93741: PUSH
93742: LD_INT 4
93744: PUSH
93745: LD_INT 5
93747: PUSH
93748: LD_INT 6
93750: PUSH
93751: LD_INT 7
93753: PUSH
93754: LD_INT 8
93756: PUSH
93757: LD_INT 9
93759: PUSH
93760: LD_INT 10
93762: PUSH
93763: LD_INT 11
93765: PUSH
93766: LD_INT 12
93768: PUSH
93769: LD_INT 13
93771: PUSH
93772: LD_INT 14
93774: PUSH
93775: LD_INT 15
93777: PUSH
93778: LD_INT 16
93780: PUSH
93781: LD_INT 17
93783: PUSH
93784: LD_INT 18
93786: PUSH
93787: LD_INT 19
93789: PUSH
93790: LD_INT 20
93792: PUSH
93793: LD_INT 21
93795: PUSH
93796: LD_INT 22
93798: PUSH
93799: LD_INT 23
93801: PUSH
93802: LD_INT 24
93804: PUSH
93805: LD_INT 25
93807: PUSH
93808: LD_INT 26
93810: PUSH
93811: LD_INT 27
93813: PUSH
93814: LD_INT 28
93816: PUSH
93817: LD_INT 29
93819: PUSH
93820: LD_INT 30
93822: PUSH
93823: LD_INT 31
93825: PUSH
93826: LD_INT 32
93828: PUSH
93829: LD_INT 33
93831: PUSH
93832: LD_INT 34
93834: PUSH
93835: LD_INT 36
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 101
93877: PUSH
93878: LD_INT 102
93880: PUSH
93881: LD_INT 103
93883: PUSH
93884: LD_INT 104
93886: PUSH
93887: LD_INT 105
93889: PUSH
93890: LD_INT 106
93892: PUSH
93893: LD_INT 107
93895: PUSH
93896: LD_INT 108
93898: PUSH
93899: LD_INT 109
93901: PUSH
93902: LD_INT 110
93904: PUSH
93905: LD_INT 111
93907: PUSH
93908: LD_INT 112
93910: PUSH
93911: LD_INT 113
93913: PUSH
93914: LD_INT 114
93916: PUSH
93917: LD_INT 116
93919: PUSH
93920: LD_INT 117
93922: PUSH
93923: LD_INT 118
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: ST_TO_ADDR
93949: GO 94956
93951: LD_INT 15
93953: DOUBLE
93954: EQUAL
93955: IFTRUE 93959
93957: GO 94183
93959: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93960: LD_ADDR_VAR 0 2
93964: PUSH
93965: LD_INT 1
93967: PUSH
93968: LD_INT 2
93970: PUSH
93971: LD_INT 3
93973: PUSH
93974: LD_INT 4
93976: PUSH
93977: LD_INT 5
93979: PUSH
93980: LD_INT 6
93982: PUSH
93983: LD_INT 7
93985: PUSH
93986: LD_INT 8
93988: PUSH
93989: LD_INT 9
93991: PUSH
93992: LD_INT 10
93994: PUSH
93995: LD_INT 11
93997: PUSH
93998: LD_INT 12
94000: PUSH
94001: LD_INT 13
94003: PUSH
94004: LD_INT 14
94006: PUSH
94007: LD_INT 15
94009: PUSH
94010: LD_INT 16
94012: PUSH
94013: LD_INT 17
94015: PUSH
94016: LD_INT 18
94018: PUSH
94019: LD_INT 19
94021: PUSH
94022: LD_INT 20
94024: PUSH
94025: LD_INT 21
94027: PUSH
94028: LD_INT 22
94030: PUSH
94031: LD_INT 23
94033: PUSH
94034: LD_INT 24
94036: PUSH
94037: LD_INT 25
94039: PUSH
94040: LD_INT 26
94042: PUSH
94043: LD_INT 27
94045: PUSH
94046: LD_INT 28
94048: PUSH
94049: LD_INT 29
94051: PUSH
94052: LD_INT 30
94054: PUSH
94055: LD_INT 31
94057: PUSH
94058: LD_INT 32
94060: PUSH
94061: LD_INT 33
94063: PUSH
94064: LD_INT 34
94066: PUSH
94067: LD_INT 36
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 101
94109: PUSH
94110: LD_INT 102
94112: PUSH
94113: LD_INT 103
94115: PUSH
94116: LD_INT 104
94118: PUSH
94119: LD_INT 105
94121: PUSH
94122: LD_INT 106
94124: PUSH
94125: LD_INT 107
94127: PUSH
94128: LD_INT 108
94130: PUSH
94131: LD_INT 109
94133: PUSH
94134: LD_INT 110
94136: PUSH
94137: LD_INT 111
94139: PUSH
94140: LD_INT 112
94142: PUSH
94143: LD_INT 113
94145: PUSH
94146: LD_INT 114
94148: PUSH
94149: LD_INT 116
94151: PUSH
94152: LD_INT 117
94154: PUSH
94155: LD_INT 118
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: ST_TO_ADDR
94181: GO 94956
94183: LD_INT 16
94185: DOUBLE
94186: EQUAL
94187: IFTRUE 94191
94189: GO 94327
94191: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94192: LD_ADDR_VAR 0 2
94196: PUSH
94197: LD_INT 2
94199: PUSH
94200: LD_INT 4
94202: PUSH
94203: LD_INT 5
94205: PUSH
94206: LD_INT 7
94208: PUSH
94209: LD_INT 11
94211: PUSH
94212: LD_INT 12
94214: PUSH
94215: LD_INT 15
94217: PUSH
94218: LD_INT 16
94220: PUSH
94221: LD_INT 20
94223: PUSH
94224: LD_INT 21
94226: PUSH
94227: LD_INT 22
94229: PUSH
94230: LD_INT 23
94232: PUSH
94233: LD_INT 25
94235: PUSH
94236: LD_INT 26
94238: PUSH
94239: LD_INT 30
94241: PUSH
94242: LD_INT 31
94244: PUSH
94245: LD_INT 32
94247: PUSH
94248: LD_INT 33
94250: PUSH
94251: LD_INT 34
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 101
94277: PUSH
94278: LD_INT 102
94280: PUSH
94281: LD_INT 103
94283: PUSH
94284: LD_INT 106
94286: PUSH
94287: LD_INT 108
94289: PUSH
94290: LD_INT 112
94292: PUSH
94293: LD_INT 113
94295: PUSH
94296: LD_INT 114
94298: PUSH
94299: LD_INT 116
94301: PUSH
94302: LD_INT 117
94304: PUSH
94305: LD_INT 118
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: ST_TO_ADDR
94325: GO 94956
94327: LD_INT 17
94329: DOUBLE
94330: EQUAL
94331: IFTRUE 94335
94333: GO 94559
94335: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94336: LD_ADDR_VAR 0 2
94340: PUSH
94341: LD_INT 1
94343: PUSH
94344: LD_INT 2
94346: PUSH
94347: LD_INT 3
94349: PUSH
94350: LD_INT 4
94352: PUSH
94353: LD_INT 5
94355: PUSH
94356: LD_INT 6
94358: PUSH
94359: LD_INT 7
94361: PUSH
94362: LD_INT 8
94364: PUSH
94365: LD_INT 9
94367: PUSH
94368: LD_INT 10
94370: PUSH
94371: LD_INT 11
94373: PUSH
94374: LD_INT 12
94376: PUSH
94377: LD_INT 13
94379: PUSH
94380: LD_INT 14
94382: PUSH
94383: LD_INT 15
94385: PUSH
94386: LD_INT 16
94388: PUSH
94389: LD_INT 17
94391: PUSH
94392: LD_INT 18
94394: PUSH
94395: LD_INT 19
94397: PUSH
94398: LD_INT 20
94400: PUSH
94401: LD_INT 21
94403: PUSH
94404: LD_INT 22
94406: PUSH
94407: LD_INT 23
94409: PUSH
94410: LD_INT 24
94412: PUSH
94413: LD_INT 25
94415: PUSH
94416: LD_INT 26
94418: PUSH
94419: LD_INT 27
94421: PUSH
94422: LD_INT 28
94424: PUSH
94425: LD_INT 29
94427: PUSH
94428: LD_INT 30
94430: PUSH
94431: LD_INT 31
94433: PUSH
94434: LD_INT 32
94436: PUSH
94437: LD_INT 33
94439: PUSH
94440: LD_INT 34
94442: PUSH
94443: LD_INT 36
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 101
94485: PUSH
94486: LD_INT 102
94488: PUSH
94489: LD_INT 103
94491: PUSH
94492: LD_INT 104
94494: PUSH
94495: LD_INT 105
94497: PUSH
94498: LD_INT 106
94500: PUSH
94501: LD_INT 107
94503: PUSH
94504: LD_INT 108
94506: PUSH
94507: LD_INT 109
94509: PUSH
94510: LD_INT 110
94512: PUSH
94513: LD_INT 111
94515: PUSH
94516: LD_INT 112
94518: PUSH
94519: LD_INT 113
94521: PUSH
94522: LD_INT 114
94524: PUSH
94525: LD_INT 116
94527: PUSH
94528: LD_INT 117
94530: PUSH
94531: LD_INT 118
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: ST_TO_ADDR
94557: GO 94956
94559: LD_INT 18
94561: DOUBLE
94562: EQUAL
94563: IFTRUE 94567
94565: GO 94715
94567: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94568: LD_ADDR_VAR 0 2
94572: PUSH
94573: LD_INT 2
94575: PUSH
94576: LD_INT 4
94578: PUSH
94579: LD_INT 5
94581: PUSH
94582: LD_INT 7
94584: PUSH
94585: LD_INT 11
94587: PUSH
94588: LD_INT 12
94590: PUSH
94591: LD_INT 15
94593: PUSH
94594: LD_INT 16
94596: PUSH
94597: LD_INT 20
94599: PUSH
94600: LD_INT 21
94602: PUSH
94603: LD_INT 22
94605: PUSH
94606: LD_INT 23
94608: PUSH
94609: LD_INT 25
94611: PUSH
94612: LD_INT 26
94614: PUSH
94615: LD_INT 30
94617: PUSH
94618: LD_INT 31
94620: PUSH
94621: LD_INT 32
94623: PUSH
94624: LD_INT 33
94626: PUSH
94627: LD_INT 34
94629: PUSH
94630: LD_INT 35
94632: PUSH
94633: LD_INT 36
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: PUSH
94659: LD_INT 101
94661: PUSH
94662: LD_INT 102
94664: PUSH
94665: LD_INT 103
94667: PUSH
94668: LD_INT 106
94670: PUSH
94671: LD_INT 108
94673: PUSH
94674: LD_INT 112
94676: PUSH
94677: LD_INT 113
94679: PUSH
94680: LD_INT 114
94682: PUSH
94683: LD_INT 115
94685: PUSH
94686: LD_INT 116
94688: PUSH
94689: LD_INT 117
94691: PUSH
94692: LD_INT 118
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: ST_TO_ADDR
94713: GO 94956
94715: LD_INT 19
94717: DOUBLE
94718: EQUAL
94719: IFTRUE 94723
94721: GO 94955
94723: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94724: LD_ADDR_VAR 0 2
94728: PUSH
94729: LD_INT 1
94731: PUSH
94732: LD_INT 2
94734: PUSH
94735: LD_INT 3
94737: PUSH
94738: LD_INT 4
94740: PUSH
94741: LD_INT 5
94743: PUSH
94744: LD_INT 6
94746: PUSH
94747: LD_INT 7
94749: PUSH
94750: LD_INT 8
94752: PUSH
94753: LD_INT 9
94755: PUSH
94756: LD_INT 10
94758: PUSH
94759: LD_INT 11
94761: PUSH
94762: LD_INT 12
94764: PUSH
94765: LD_INT 13
94767: PUSH
94768: LD_INT 14
94770: PUSH
94771: LD_INT 15
94773: PUSH
94774: LD_INT 16
94776: PUSH
94777: LD_INT 17
94779: PUSH
94780: LD_INT 18
94782: PUSH
94783: LD_INT 19
94785: PUSH
94786: LD_INT 20
94788: PUSH
94789: LD_INT 21
94791: PUSH
94792: LD_INT 22
94794: PUSH
94795: LD_INT 23
94797: PUSH
94798: LD_INT 24
94800: PUSH
94801: LD_INT 25
94803: PUSH
94804: LD_INT 26
94806: PUSH
94807: LD_INT 27
94809: PUSH
94810: LD_INT 28
94812: PUSH
94813: LD_INT 29
94815: PUSH
94816: LD_INT 30
94818: PUSH
94819: LD_INT 31
94821: PUSH
94822: LD_INT 32
94824: PUSH
94825: LD_INT 33
94827: PUSH
94828: LD_INT 34
94830: PUSH
94831: LD_INT 35
94833: PUSH
94834: LD_INT 36
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 101
94877: PUSH
94878: LD_INT 102
94880: PUSH
94881: LD_INT 103
94883: PUSH
94884: LD_INT 104
94886: PUSH
94887: LD_INT 105
94889: PUSH
94890: LD_INT 106
94892: PUSH
94893: LD_INT 107
94895: PUSH
94896: LD_INT 108
94898: PUSH
94899: LD_INT 109
94901: PUSH
94902: LD_INT 110
94904: PUSH
94905: LD_INT 111
94907: PUSH
94908: LD_INT 112
94910: PUSH
94911: LD_INT 113
94913: PUSH
94914: LD_INT 114
94916: PUSH
94917: LD_INT 115
94919: PUSH
94920: LD_INT 116
94922: PUSH
94923: LD_INT 117
94925: PUSH
94926: LD_INT 118
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: ST_TO_ADDR
94953: GO 94956
94955: POP
// end else
94956: GO 95187
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94958: LD_ADDR_VAR 0 2
94962: PUSH
94963: LD_INT 1
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: LD_INT 3
94971: PUSH
94972: LD_INT 4
94974: PUSH
94975: LD_INT 5
94977: PUSH
94978: LD_INT 6
94980: PUSH
94981: LD_INT 7
94983: PUSH
94984: LD_INT 8
94986: PUSH
94987: LD_INT 9
94989: PUSH
94990: LD_INT 10
94992: PUSH
94993: LD_INT 11
94995: PUSH
94996: LD_INT 12
94998: PUSH
94999: LD_INT 13
95001: PUSH
95002: LD_INT 14
95004: PUSH
95005: LD_INT 15
95007: PUSH
95008: LD_INT 16
95010: PUSH
95011: LD_INT 17
95013: PUSH
95014: LD_INT 18
95016: PUSH
95017: LD_INT 19
95019: PUSH
95020: LD_INT 20
95022: PUSH
95023: LD_INT 21
95025: PUSH
95026: LD_INT 22
95028: PUSH
95029: LD_INT 23
95031: PUSH
95032: LD_INT 24
95034: PUSH
95035: LD_INT 25
95037: PUSH
95038: LD_INT 26
95040: PUSH
95041: LD_INT 27
95043: PUSH
95044: LD_INT 28
95046: PUSH
95047: LD_INT 29
95049: PUSH
95050: LD_INT 30
95052: PUSH
95053: LD_INT 31
95055: PUSH
95056: LD_INT 32
95058: PUSH
95059: LD_INT 33
95061: PUSH
95062: LD_INT 34
95064: PUSH
95065: LD_INT 35
95067: PUSH
95068: LD_INT 36
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: PUSH
95109: LD_INT 101
95111: PUSH
95112: LD_INT 102
95114: PUSH
95115: LD_INT 103
95117: PUSH
95118: LD_INT 104
95120: PUSH
95121: LD_INT 105
95123: PUSH
95124: LD_INT 106
95126: PUSH
95127: LD_INT 107
95129: PUSH
95130: LD_INT 108
95132: PUSH
95133: LD_INT 109
95135: PUSH
95136: LD_INT 110
95138: PUSH
95139: LD_INT 111
95141: PUSH
95142: LD_INT 112
95144: PUSH
95145: LD_INT 113
95147: PUSH
95148: LD_INT 114
95150: PUSH
95151: LD_INT 115
95153: PUSH
95154: LD_INT 116
95156: PUSH
95157: LD_INT 117
95159: PUSH
95160: LD_INT 118
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: ST_TO_ADDR
// if result then
95187: LD_VAR 0 2
95191: IFFALSE 95977
// begin normal :=  ;
95193: LD_ADDR_VAR 0 5
95197: PUSH
95198: LD_STRING 
95200: ST_TO_ADDR
// hardcore :=  ;
95201: LD_ADDR_VAR 0 6
95205: PUSH
95206: LD_STRING 
95208: ST_TO_ADDR
// active :=  ;
95209: LD_ADDR_VAR 0 7
95213: PUSH
95214: LD_STRING 
95216: ST_TO_ADDR
// for i = 1 to normalCounter do
95217: LD_ADDR_VAR 0 8
95221: PUSH
95222: DOUBLE
95223: LD_INT 1
95225: DEC
95226: ST_TO_ADDR
95227: LD_EXP 108
95231: PUSH
95232: FOR_TO
95233: IFFALSE 95334
// begin tmp := 0 ;
95235: LD_ADDR_VAR 0 3
95239: PUSH
95240: LD_STRING 0
95242: ST_TO_ADDR
// if result [ 1 ] then
95243: LD_VAR 0 2
95247: PUSH
95248: LD_INT 1
95250: ARRAY
95251: IFFALSE 95316
// if result [ 1 ] [ 1 ] = i then
95253: LD_VAR 0 2
95257: PUSH
95258: LD_INT 1
95260: ARRAY
95261: PUSH
95262: LD_INT 1
95264: ARRAY
95265: PUSH
95266: LD_VAR 0 8
95270: EQUAL
95271: IFFALSE 95316
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95273: LD_ADDR_VAR 0 2
95277: PUSH
95278: LD_VAR 0 2
95282: PPUSH
95283: LD_INT 1
95285: PPUSH
95286: LD_VAR 0 2
95290: PUSH
95291: LD_INT 1
95293: ARRAY
95294: PPUSH
95295: LD_INT 1
95297: PPUSH
95298: CALL_OW 3
95302: PPUSH
95303: CALL_OW 1
95307: ST_TO_ADDR
// tmp := 1 ;
95308: LD_ADDR_VAR 0 3
95312: PUSH
95313: LD_STRING 1
95315: ST_TO_ADDR
// end ; normal := normal & tmp ;
95316: LD_ADDR_VAR 0 5
95320: PUSH
95321: LD_VAR 0 5
95325: PUSH
95326: LD_VAR 0 3
95330: STR
95331: ST_TO_ADDR
// end ;
95332: GO 95232
95334: POP
95335: POP
// for i = 1 to hardcoreCounter do
95336: LD_ADDR_VAR 0 8
95340: PUSH
95341: DOUBLE
95342: LD_INT 1
95344: DEC
95345: ST_TO_ADDR
95346: LD_EXP 109
95350: PUSH
95351: FOR_TO
95352: IFFALSE 95457
// begin tmp := 0 ;
95354: LD_ADDR_VAR 0 3
95358: PUSH
95359: LD_STRING 0
95361: ST_TO_ADDR
// if result [ 2 ] then
95362: LD_VAR 0 2
95366: PUSH
95367: LD_INT 2
95369: ARRAY
95370: IFFALSE 95439
// if result [ 2 ] [ 1 ] = 100 + i then
95372: LD_VAR 0 2
95376: PUSH
95377: LD_INT 2
95379: ARRAY
95380: PUSH
95381: LD_INT 1
95383: ARRAY
95384: PUSH
95385: LD_INT 100
95387: PUSH
95388: LD_VAR 0 8
95392: PLUS
95393: EQUAL
95394: IFFALSE 95439
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95396: LD_ADDR_VAR 0 2
95400: PUSH
95401: LD_VAR 0 2
95405: PPUSH
95406: LD_INT 2
95408: PPUSH
95409: LD_VAR 0 2
95413: PUSH
95414: LD_INT 2
95416: ARRAY
95417: PPUSH
95418: LD_INT 1
95420: PPUSH
95421: CALL_OW 3
95425: PPUSH
95426: CALL_OW 1
95430: ST_TO_ADDR
// tmp := 1 ;
95431: LD_ADDR_VAR 0 3
95435: PUSH
95436: LD_STRING 1
95438: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95439: LD_ADDR_VAR 0 6
95443: PUSH
95444: LD_VAR 0 6
95448: PUSH
95449: LD_VAR 0 3
95453: STR
95454: ST_TO_ADDR
// end ;
95455: GO 95351
95457: POP
95458: POP
// if isGameLoad then
95459: LD_VAR 0 1
95463: IFFALSE 95938
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95465: LD_ADDR_VAR 0 4
95469: PUSH
95470: LD_EXP 112
95474: PUSH
95475: LD_EXP 111
95479: PUSH
95480: LD_EXP 113
95484: PUSH
95485: LD_EXP 110
95489: PUSH
95490: LD_EXP 114
95494: PUSH
95495: LD_EXP 115
95499: PUSH
95500: LD_EXP 116
95504: PUSH
95505: LD_EXP 117
95509: PUSH
95510: LD_EXP 118
95514: PUSH
95515: LD_EXP 119
95519: PUSH
95520: LD_EXP 120
95524: PUSH
95525: LD_EXP 121
95529: PUSH
95530: LD_EXP 122
95534: PUSH
95535: LD_EXP 123
95539: PUSH
95540: LD_EXP 131
95544: PUSH
95545: LD_EXP 132
95549: PUSH
95550: LD_EXP 133
95554: PUSH
95555: LD_EXP 134
95559: PUSH
95560: LD_EXP 136
95564: PUSH
95565: LD_EXP 137
95569: PUSH
95570: LD_EXP 138
95574: PUSH
95575: LD_EXP 141
95579: PUSH
95580: LD_EXP 143
95584: PUSH
95585: LD_EXP 144
95589: PUSH
95590: LD_EXP 145
95594: PUSH
95595: LD_EXP 147
95599: PUSH
95600: LD_EXP 148
95604: PUSH
95605: LD_EXP 151
95609: PUSH
95610: LD_EXP 152
95614: PUSH
95615: LD_EXP 153
95619: PUSH
95620: LD_EXP 154
95624: PUSH
95625: LD_EXP 155
95629: PUSH
95630: LD_EXP 156
95634: PUSH
95635: LD_EXP 157
95639: PUSH
95640: LD_EXP 158
95644: PUSH
95645: LD_EXP 159
95649: PUSH
95650: LD_EXP 124
95654: PUSH
95655: LD_EXP 125
95659: PUSH
95660: LD_EXP 128
95664: PUSH
95665: LD_EXP 129
95669: PUSH
95670: LD_EXP 130
95674: PUSH
95675: LD_EXP 126
95679: PUSH
95680: LD_EXP 127
95684: PUSH
95685: LD_EXP 135
95689: PUSH
95690: LD_EXP 139
95694: PUSH
95695: LD_EXP 140
95699: PUSH
95700: LD_EXP 142
95704: PUSH
95705: LD_EXP 146
95709: PUSH
95710: LD_EXP 149
95714: PUSH
95715: LD_EXP 150
95719: PUSH
95720: LD_EXP 160
95724: PUSH
95725: LD_EXP 161
95729: PUSH
95730: LD_EXP 162
95734: PUSH
95735: LD_EXP 163
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: ST_TO_ADDR
// tmp :=  ;
95796: LD_ADDR_VAR 0 3
95800: PUSH
95801: LD_STRING 
95803: ST_TO_ADDR
// for i = 1 to normalCounter do
95804: LD_ADDR_VAR 0 8
95808: PUSH
95809: DOUBLE
95810: LD_INT 1
95812: DEC
95813: ST_TO_ADDR
95814: LD_EXP 108
95818: PUSH
95819: FOR_TO
95820: IFFALSE 95856
// begin if flags [ i ] then
95822: LD_VAR 0 4
95826: PUSH
95827: LD_VAR 0 8
95831: ARRAY
95832: IFFALSE 95854
// tmp := tmp & i & ; ;
95834: LD_ADDR_VAR 0 3
95838: PUSH
95839: LD_VAR 0 3
95843: PUSH
95844: LD_VAR 0 8
95848: STR
95849: PUSH
95850: LD_STRING ;
95852: STR
95853: ST_TO_ADDR
// end ;
95854: GO 95819
95856: POP
95857: POP
// for i = 1 to hardcoreCounter do
95858: LD_ADDR_VAR 0 8
95862: PUSH
95863: DOUBLE
95864: LD_INT 1
95866: DEC
95867: ST_TO_ADDR
95868: LD_EXP 109
95872: PUSH
95873: FOR_TO
95874: IFFALSE 95920
// begin if flags [ normalCounter + i ] then
95876: LD_VAR 0 4
95880: PUSH
95881: LD_EXP 108
95885: PUSH
95886: LD_VAR 0 8
95890: PLUS
95891: ARRAY
95892: IFFALSE 95918
// tmp := tmp & ( 100 + i ) & ; ;
95894: LD_ADDR_VAR 0 3
95898: PUSH
95899: LD_VAR 0 3
95903: PUSH
95904: LD_INT 100
95906: PUSH
95907: LD_VAR 0 8
95911: PLUS
95912: STR
95913: PUSH
95914: LD_STRING ;
95916: STR
95917: ST_TO_ADDR
// end ;
95918: GO 95873
95920: POP
95921: POP
// if tmp then
95922: LD_VAR 0 3
95926: IFFALSE 95938
// active := tmp ;
95928: LD_ADDR_VAR 0 7
95932: PUSH
95933: LD_VAR 0 3
95937: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95938: LD_STRING getStreamItemsFromMission("
95940: PUSH
95941: LD_VAR 0 5
95945: STR
95946: PUSH
95947: LD_STRING ","
95949: STR
95950: PUSH
95951: LD_VAR 0 6
95955: STR
95956: PUSH
95957: LD_STRING ","
95959: STR
95960: PUSH
95961: LD_VAR 0 7
95965: STR
95966: PUSH
95967: LD_STRING ")
95969: STR
95970: PPUSH
95971: CALL_OW 559
// end else
95975: GO 95984
// ToLua ( getStreamItemsFromMission("","","") ) ;
95977: LD_STRING getStreamItemsFromMission("","","")
95979: PPUSH
95980: CALL_OW 559
// end ;
95984: LD_VAR 0 2
95988: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95989: LD_EXP 107
95993: PUSH
95994: LD_EXP 112
95998: AND
95999: IFFALSE 96123
96001: GO 96003
96003: DISABLE
96004: LD_INT 0
96006: PPUSH
96007: PPUSH
// begin enable ;
96008: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96009: LD_ADDR_VAR 0 2
96013: PUSH
96014: LD_INT 22
96016: PUSH
96017: LD_OWVAR 2
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: PUSH
96029: LD_INT 34
96031: PUSH
96032: LD_INT 7
96034: PUSH
96035: EMPTY
96036: LIST
96037: LIST
96038: PUSH
96039: LD_INT 34
96041: PUSH
96042: LD_INT 45
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: PUSH
96049: LD_INT 34
96051: PUSH
96052: LD_INT 28
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 34
96061: PUSH
96062: LD_INT 47
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: PPUSH
96080: CALL_OW 69
96084: ST_TO_ADDR
// if not tmp then
96085: LD_VAR 0 2
96089: NOT
96090: IFFALSE 96094
// exit ;
96092: GO 96123
// for i in tmp do
96094: LD_ADDR_VAR 0 1
96098: PUSH
96099: LD_VAR 0 2
96103: PUSH
96104: FOR_IN
96105: IFFALSE 96121
// begin SetLives ( i , 0 ) ;
96107: LD_VAR 0 1
96111: PPUSH
96112: LD_INT 0
96114: PPUSH
96115: CALL_OW 234
// end ;
96119: GO 96104
96121: POP
96122: POP
// end ;
96123: PPOPN 2
96125: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96126: LD_EXP 107
96130: PUSH
96131: LD_EXP 113
96135: AND
96136: IFFALSE 96220
96138: GO 96140
96140: DISABLE
96141: LD_INT 0
96143: PPUSH
96144: PPUSH
// begin enable ;
96145: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96146: LD_ADDR_VAR 0 2
96150: PUSH
96151: LD_INT 22
96153: PUSH
96154: LD_OWVAR 2
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 32
96165: PUSH
96166: LD_INT 3
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PPUSH
96177: CALL_OW 69
96181: ST_TO_ADDR
// if not tmp then
96182: LD_VAR 0 2
96186: NOT
96187: IFFALSE 96191
// exit ;
96189: GO 96220
// for i in tmp do
96191: LD_ADDR_VAR 0 1
96195: PUSH
96196: LD_VAR 0 2
96200: PUSH
96201: FOR_IN
96202: IFFALSE 96218
// begin SetLives ( i , 0 ) ;
96204: LD_VAR 0 1
96208: PPUSH
96209: LD_INT 0
96211: PPUSH
96212: CALL_OW 234
// end ;
96216: GO 96201
96218: POP
96219: POP
// end ;
96220: PPOPN 2
96222: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96223: LD_EXP 107
96227: PUSH
96228: LD_EXP 110
96232: AND
96233: IFFALSE 96326
96235: GO 96237
96237: DISABLE
96238: LD_INT 0
96240: PPUSH
// begin enable ;
96241: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96242: LD_ADDR_VAR 0 1
96246: PUSH
96247: LD_INT 22
96249: PUSH
96250: LD_OWVAR 2
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 2
96261: PUSH
96262: LD_INT 25
96264: PUSH
96265: LD_INT 5
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 25
96274: PUSH
96275: LD_INT 9
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 25
96284: PUSH
96285: LD_INT 8
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PPUSH
96302: CALL_OW 69
96306: PUSH
96307: FOR_IN
96308: IFFALSE 96324
// begin SetClass ( i , 1 ) ;
96310: LD_VAR 0 1
96314: PPUSH
96315: LD_INT 1
96317: PPUSH
96318: CALL_OW 336
// end ;
96322: GO 96307
96324: POP
96325: POP
// end ;
96326: PPOPN 1
96328: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96329: LD_EXP 107
96333: PUSH
96334: LD_EXP 111
96338: AND
96339: PUSH
96340: LD_OWVAR 65
96344: PUSH
96345: LD_INT 7
96347: LESS
96348: AND
96349: IFFALSE 96363
96351: GO 96353
96353: DISABLE
// begin enable ;
96354: ENABLE
// game_speed := 7 ;
96355: LD_ADDR_OWVAR 65
96359: PUSH
96360: LD_INT 7
96362: ST_TO_ADDR
// end ;
96363: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96364: LD_EXP 107
96368: PUSH
96369: LD_EXP 114
96373: AND
96374: IFFALSE 96576
96376: GO 96378
96378: DISABLE
96379: LD_INT 0
96381: PPUSH
96382: PPUSH
96383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96384: LD_ADDR_VAR 0 3
96388: PUSH
96389: LD_INT 81
96391: PUSH
96392: LD_OWVAR 2
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: PUSH
96401: LD_INT 21
96403: PUSH
96404: LD_INT 1
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PPUSH
96415: CALL_OW 69
96419: ST_TO_ADDR
// if not tmp then
96420: LD_VAR 0 3
96424: NOT
96425: IFFALSE 96429
// exit ;
96427: GO 96576
// if tmp > 5 then
96429: LD_VAR 0 3
96433: PUSH
96434: LD_INT 5
96436: GREATER
96437: IFFALSE 96449
// k := 5 else
96439: LD_ADDR_VAR 0 2
96443: PUSH
96444: LD_INT 5
96446: ST_TO_ADDR
96447: GO 96459
// k := tmp ;
96449: LD_ADDR_VAR 0 2
96453: PUSH
96454: LD_VAR 0 3
96458: ST_TO_ADDR
// for i := 1 to k do
96459: LD_ADDR_VAR 0 1
96463: PUSH
96464: DOUBLE
96465: LD_INT 1
96467: DEC
96468: ST_TO_ADDR
96469: LD_VAR 0 2
96473: PUSH
96474: FOR_TO
96475: IFFALSE 96574
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96477: LD_VAR 0 3
96481: PUSH
96482: LD_VAR 0 1
96486: ARRAY
96487: PPUSH
96488: LD_VAR 0 1
96492: PUSH
96493: LD_INT 4
96495: MOD
96496: PUSH
96497: LD_INT 1
96499: PLUS
96500: PPUSH
96501: CALL_OW 259
96505: PUSH
96506: LD_INT 10
96508: LESS
96509: IFFALSE 96572
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96511: LD_VAR 0 3
96515: PUSH
96516: LD_VAR 0 1
96520: ARRAY
96521: PPUSH
96522: LD_VAR 0 1
96526: PUSH
96527: LD_INT 4
96529: MOD
96530: PUSH
96531: LD_INT 1
96533: PLUS
96534: PPUSH
96535: LD_VAR 0 3
96539: PUSH
96540: LD_VAR 0 1
96544: ARRAY
96545: PPUSH
96546: LD_VAR 0 1
96550: PUSH
96551: LD_INT 4
96553: MOD
96554: PUSH
96555: LD_INT 1
96557: PLUS
96558: PPUSH
96559: CALL_OW 259
96563: PUSH
96564: LD_INT 1
96566: PLUS
96567: PPUSH
96568: CALL_OW 237
96572: GO 96474
96574: POP
96575: POP
// end ;
96576: PPOPN 3
96578: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96579: LD_EXP 107
96583: PUSH
96584: LD_EXP 115
96588: AND
96589: IFFALSE 96609
96591: GO 96593
96593: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96594: LD_INT 4
96596: PPUSH
96597: LD_OWVAR 2
96601: PPUSH
96602: LD_INT 0
96604: PPUSH
96605: CALL_OW 324
96609: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96610: LD_EXP 107
96614: PUSH
96615: LD_EXP 144
96619: AND
96620: IFFALSE 96640
96622: GO 96624
96624: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96625: LD_INT 19
96627: PPUSH
96628: LD_OWVAR 2
96632: PPUSH
96633: LD_INT 0
96635: PPUSH
96636: CALL_OW 324
96640: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96641: LD_EXP 107
96645: PUSH
96646: LD_EXP 116
96650: AND
96651: IFFALSE 96753
96653: GO 96655
96655: DISABLE
96656: LD_INT 0
96658: PPUSH
96659: PPUSH
// begin enable ;
96660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96661: LD_ADDR_VAR 0 2
96665: PUSH
96666: LD_INT 22
96668: PUSH
96669: LD_OWVAR 2
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 2
96680: PUSH
96681: LD_INT 34
96683: PUSH
96684: LD_INT 11
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 34
96693: PUSH
96694: LD_INT 30
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: LIST
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PPUSH
96710: CALL_OW 69
96714: ST_TO_ADDR
// if not tmp then
96715: LD_VAR 0 2
96719: NOT
96720: IFFALSE 96724
// exit ;
96722: GO 96753
// for i in tmp do
96724: LD_ADDR_VAR 0 1
96728: PUSH
96729: LD_VAR 0 2
96733: PUSH
96734: FOR_IN
96735: IFFALSE 96751
// begin SetLives ( i , 0 ) ;
96737: LD_VAR 0 1
96741: PPUSH
96742: LD_INT 0
96744: PPUSH
96745: CALL_OW 234
// end ;
96749: GO 96734
96751: POP
96752: POP
// end ;
96753: PPOPN 2
96755: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96756: LD_EXP 107
96760: PUSH
96761: LD_EXP 117
96765: AND
96766: IFFALSE 96786
96768: GO 96770
96770: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96771: LD_INT 32
96773: PPUSH
96774: LD_OWVAR 2
96778: PPUSH
96779: LD_INT 0
96781: PPUSH
96782: CALL_OW 324
96786: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96787: LD_EXP 107
96791: PUSH
96792: LD_EXP 118
96796: AND
96797: IFFALSE 96978
96799: GO 96801
96801: DISABLE
96802: LD_INT 0
96804: PPUSH
96805: PPUSH
96806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96807: LD_ADDR_VAR 0 2
96811: PUSH
96812: LD_INT 22
96814: PUSH
96815: LD_OWVAR 2
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 33
96826: PUSH
96827: LD_INT 3
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PPUSH
96838: CALL_OW 69
96842: ST_TO_ADDR
// if not tmp then
96843: LD_VAR 0 2
96847: NOT
96848: IFFALSE 96852
// exit ;
96850: GO 96978
// side := 0 ;
96852: LD_ADDR_VAR 0 3
96856: PUSH
96857: LD_INT 0
96859: ST_TO_ADDR
// for i := 1 to 8 do
96860: LD_ADDR_VAR 0 1
96864: PUSH
96865: DOUBLE
96866: LD_INT 1
96868: DEC
96869: ST_TO_ADDR
96870: LD_INT 8
96872: PUSH
96873: FOR_TO
96874: IFFALSE 96922
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96876: LD_OWVAR 2
96880: PUSH
96881: LD_VAR 0 1
96885: NONEQUAL
96886: PUSH
96887: LD_OWVAR 2
96891: PPUSH
96892: LD_VAR 0 1
96896: PPUSH
96897: CALL_OW 81
96901: PUSH
96902: LD_INT 2
96904: EQUAL
96905: AND
96906: IFFALSE 96920
// begin side := i ;
96908: LD_ADDR_VAR 0 3
96912: PUSH
96913: LD_VAR 0 1
96917: ST_TO_ADDR
// break ;
96918: GO 96922
// end ;
96920: GO 96873
96922: POP
96923: POP
// if not side then
96924: LD_VAR 0 3
96928: NOT
96929: IFFALSE 96933
// exit ;
96931: GO 96978
// for i := 1 to tmp do
96933: LD_ADDR_VAR 0 1
96937: PUSH
96938: DOUBLE
96939: LD_INT 1
96941: DEC
96942: ST_TO_ADDR
96943: LD_VAR 0 2
96947: PUSH
96948: FOR_TO
96949: IFFALSE 96976
// if Prob ( 60 ) then
96951: LD_INT 60
96953: PPUSH
96954: CALL_OW 13
96958: IFFALSE 96974
// SetSide ( i , side ) ;
96960: LD_VAR 0 1
96964: PPUSH
96965: LD_VAR 0 3
96969: PPUSH
96970: CALL_OW 235
96974: GO 96948
96976: POP
96977: POP
// end ;
96978: PPOPN 3
96980: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96981: LD_EXP 107
96985: PUSH
96986: LD_EXP 120
96990: AND
96991: IFFALSE 97110
96993: GO 96995
96995: DISABLE
96996: LD_INT 0
96998: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96999: LD_ADDR_VAR 0 1
97003: PUSH
97004: LD_INT 22
97006: PUSH
97007: LD_OWVAR 2
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: LD_INT 21
97018: PUSH
97019: LD_INT 1
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 3
97028: PUSH
97029: LD_INT 23
97031: PUSH
97032: LD_INT 0
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: LIST
97047: PPUSH
97048: CALL_OW 69
97052: PUSH
97053: FOR_IN
97054: IFFALSE 97108
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97056: LD_VAR 0 1
97060: PPUSH
97061: CALL_OW 257
97065: PUSH
97066: LD_INT 1
97068: PUSH
97069: LD_INT 2
97071: PUSH
97072: LD_INT 3
97074: PUSH
97075: LD_INT 4
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: IN
97084: IFFALSE 97106
// SetClass ( un , rand ( 1 , 4 ) ) ;
97086: LD_VAR 0 1
97090: PPUSH
97091: LD_INT 1
97093: PPUSH
97094: LD_INT 4
97096: PPUSH
97097: CALL_OW 12
97101: PPUSH
97102: CALL_OW 336
97106: GO 97053
97108: POP
97109: POP
// end ;
97110: PPOPN 1
97112: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97113: LD_EXP 107
97117: PUSH
97118: LD_EXP 119
97122: AND
97123: IFFALSE 97202
97125: GO 97127
97127: DISABLE
97128: LD_INT 0
97130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97131: LD_ADDR_VAR 0 1
97135: PUSH
97136: LD_INT 22
97138: PUSH
97139: LD_OWVAR 2
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: LD_INT 21
97150: PUSH
97151: LD_INT 3
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PPUSH
97162: CALL_OW 69
97166: ST_TO_ADDR
// if not tmp then
97167: LD_VAR 0 1
97171: NOT
97172: IFFALSE 97176
// exit ;
97174: GO 97202
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97176: LD_VAR 0 1
97180: PUSH
97181: LD_INT 1
97183: PPUSH
97184: LD_VAR 0 1
97188: PPUSH
97189: CALL_OW 12
97193: ARRAY
97194: PPUSH
97195: LD_INT 100
97197: PPUSH
97198: CALL_OW 234
// end ;
97202: PPOPN 1
97204: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97205: LD_EXP 107
97209: PUSH
97210: LD_EXP 121
97214: AND
97215: IFFALSE 97313
97217: GO 97219
97219: DISABLE
97220: LD_INT 0
97222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97223: LD_ADDR_VAR 0 1
97227: PUSH
97228: LD_INT 22
97230: PUSH
97231: LD_OWVAR 2
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 21
97242: PUSH
97243: LD_INT 1
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PPUSH
97254: CALL_OW 69
97258: ST_TO_ADDR
// if not tmp then
97259: LD_VAR 0 1
97263: NOT
97264: IFFALSE 97268
// exit ;
97266: GO 97313
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97268: LD_VAR 0 1
97272: PUSH
97273: LD_INT 1
97275: PPUSH
97276: LD_VAR 0 1
97280: PPUSH
97281: CALL_OW 12
97285: ARRAY
97286: PPUSH
97287: LD_INT 1
97289: PPUSH
97290: LD_INT 4
97292: PPUSH
97293: CALL_OW 12
97297: PPUSH
97298: LD_INT 3000
97300: PPUSH
97301: LD_INT 9000
97303: PPUSH
97304: CALL_OW 12
97308: PPUSH
97309: CALL_OW 492
// end ;
97313: PPOPN 1
97315: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97316: LD_EXP 107
97320: PUSH
97321: LD_EXP 122
97325: AND
97326: IFFALSE 97346
97328: GO 97330
97330: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97331: LD_INT 1
97333: PPUSH
97334: LD_OWVAR 2
97338: PPUSH
97339: LD_INT 0
97341: PPUSH
97342: CALL_OW 324
97346: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97347: LD_EXP 107
97351: PUSH
97352: LD_EXP 123
97356: AND
97357: IFFALSE 97440
97359: GO 97361
97361: DISABLE
97362: LD_INT 0
97364: PPUSH
97365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97366: LD_ADDR_VAR 0 2
97370: PUSH
97371: LD_INT 22
97373: PUSH
97374: LD_OWVAR 2
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 21
97385: PUSH
97386: LD_INT 3
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PPUSH
97397: CALL_OW 69
97401: ST_TO_ADDR
// if not tmp then
97402: LD_VAR 0 2
97406: NOT
97407: IFFALSE 97411
// exit ;
97409: GO 97440
// for i in tmp do
97411: LD_ADDR_VAR 0 1
97415: PUSH
97416: LD_VAR 0 2
97420: PUSH
97421: FOR_IN
97422: IFFALSE 97438
// SetBLevel ( i , 10 ) ;
97424: LD_VAR 0 1
97428: PPUSH
97429: LD_INT 10
97431: PPUSH
97432: CALL_OW 241
97436: GO 97421
97438: POP
97439: POP
// end ;
97440: PPOPN 2
97442: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97443: LD_EXP 107
97447: PUSH
97448: LD_EXP 124
97452: AND
97453: IFFALSE 97564
97455: GO 97457
97457: DISABLE
97458: LD_INT 0
97460: PPUSH
97461: PPUSH
97462: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97463: LD_ADDR_VAR 0 3
97467: PUSH
97468: LD_INT 22
97470: PUSH
97471: LD_OWVAR 2
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 25
97482: PUSH
97483: LD_INT 1
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: PPUSH
97494: CALL_OW 69
97498: ST_TO_ADDR
// if not tmp then
97499: LD_VAR 0 3
97503: NOT
97504: IFFALSE 97508
// exit ;
97506: GO 97564
// un := tmp [ rand ( 1 , tmp ) ] ;
97508: LD_ADDR_VAR 0 2
97512: PUSH
97513: LD_VAR 0 3
97517: PUSH
97518: LD_INT 1
97520: PPUSH
97521: LD_VAR 0 3
97525: PPUSH
97526: CALL_OW 12
97530: ARRAY
97531: ST_TO_ADDR
// if Crawls ( un ) then
97532: LD_VAR 0 2
97536: PPUSH
97537: CALL_OW 318
97541: IFFALSE 97552
// ComWalk ( un ) ;
97543: LD_VAR 0 2
97547: PPUSH
97548: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97552: LD_VAR 0 2
97556: PPUSH
97557: LD_INT 5
97559: PPUSH
97560: CALL_OW 336
// end ;
97564: PPOPN 3
97566: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97567: LD_EXP 107
97571: PUSH
97572: LD_EXP 125
97576: AND
97577: PUSH
97578: LD_OWVAR 67
97582: PUSH
97583: LD_INT 4
97585: LESS
97586: AND
97587: IFFALSE 97606
97589: GO 97591
97591: DISABLE
// begin Difficulty := Difficulty + 1 ;
97592: LD_ADDR_OWVAR 67
97596: PUSH
97597: LD_OWVAR 67
97601: PUSH
97602: LD_INT 1
97604: PLUS
97605: ST_TO_ADDR
// end ;
97606: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97607: LD_EXP 107
97611: PUSH
97612: LD_EXP 126
97616: AND
97617: IFFALSE 97720
97619: GO 97621
97621: DISABLE
97622: LD_INT 0
97624: PPUSH
// begin for i := 1 to 5 do
97625: LD_ADDR_VAR 0 1
97629: PUSH
97630: DOUBLE
97631: LD_INT 1
97633: DEC
97634: ST_TO_ADDR
97635: LD_INT 5
97637: PUSH
97638: FOR_TO
97639: IFFALSE 97718
// begin uc_nation := nation_nature ;
97641: LD_ADDR_OWVAR 21
97645: PUSH
97646: LD_INT 0
97648: ST_TO_ADDR
// uc_side := 0 ;
97649: LD_ADDR_OWVAR 20
97653: PUSH
97654: LD_INT 0
97656: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97657: LD_ADDR_OWVAR 29
97661: PUSH
97662: LD_INT 12
97664: PUSH
97665: LD_INT 12
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: ST_TO_ADDR
// hc_agressivity := 20 ;
97672: LD_ADDR_OWVAR 35
97676: PUSH
97677: LD_INT 20
97679: ST_TO_ADDR
// hc_class := class_tiger ;
97680: LD_ADDR_OWVAR 28
97684: PUSH
97685: LD_INT 14
97687: ST_TO_ADDR
// hc_gallery :=  ;
97688: LD_ADDR_OWVAR 33
97692: PUSH
97693: LD_STRING 
97695: ST_TO_ADDR
// hc_name :=  ;
97696: LD_ADDR_OWVAR 26
97700: PUSH
97701: LD_STRING 
97703: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97704: CALL_OW 44
97708: PPUSH
97709: LD_INT 0
97711: PPUSH
97712: CALL_OW 51
// end ;
97716: GO 97638
97718: POP
97719: POP
// end ;
97720: PPOPN 1
97722: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97723: LD_EXP 107
97727: PUSH
97728: LD_EXP 127
97732: AND
97733: IFFALSE 97742
97735: GO 97737
97737: DISABLE
// StreamSibBomb ;
97738: CALL 97743 0 0
97742: END
// export function StreamSibBomb ; var i , x , y ; begin
97743: LD_INT 0
97745: PPUSH
97746: PPUSH
97747: PPUSH
97748: PPUSH
// result := false ;
97749: LD_ADDR_VAR 0 1
97753: PUSH
97754: LD_INT 0
97756: ST_TO_ADDR
// for i := 1 to 16 do
97757: LD_ADDR_VAR 0 2
97761: PUSH
97762: DOUBLE
97763: LD_INT 1
97765: DEC
97766: ST_TO_ADDR
97767: LD_INT 16
97769: PUSH
97770: FOR_TO
97771: IFFALSE 97970
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97773: LD_ADDR_VAR 0 3
97777: PUSH
97778: LD_INT 10
97780: PUSH
97781: LD_INT 20
97783: PUSH
97784: LD_INT 30
97786: PUSH
97787: LD_INT 40
97789: PUSH
97790: LD_INT 50
97792: PUSH
97793: LD_INT 60
97795: PUSH
97796: LD_INT 70
97798: PUSH
97799: LD_INT 80
97801: PUSH
97802: LD_INT 90
97804: PUSH
97805: LD_INT 100
97807: PUSH
97808: LD_INT 110
97810: PUSH
97811: LD_INT 120
97813: PUSH
97814: LD_INT 130
97816: PUSH
97817: LD_INT 140
97819: PUSH
97820: LD_INT 150
97822: PUSH
97823: EMPTY
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 1
97842: PPUSH
97843: LD_INT 15
97845: PPUSH
97846: CALL_OW 12
97850: ARRAY
97851: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97852: LD_ADDR_VAR 0 4
97856: PUSH
97857: LD_INT 10
97859: PUSH
97860: LD_INT 20
97862: PUSH
97863: LD_INT 30
97865: PUSH
97866: LD_INT 40
97868: PUSH
97869: LD_INT 50
97871: PUSH
97872: LD_INT 60
97874: PUSH
97875: LD_INT 70
97877: PUSH
97878: LD_INT 80
97880: PUSH
97881: LD_INT 90
97883: PUSH
97884: LD_INT 100
97886: PUSH
97887: LD_INT 110
97889: PUSH
97890: LD_INT 120
97892: PUSH
97893: LD_INT 130
97895: PUSH
97896: LD_INT 140
97898: PUSH
97899: LD_INT 150
97901: PUSH
97902: EMPTY
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: PUSH
97919: LD_INT 1
97921: PPUSH
97922: LD_INT 15
97924: PPUSH
97925: CALL_OW 12
97929: ARRAY
97930: ST_TO_ADDR
// if ValidHex ( x , y ) then
97931: LD_VAR 0 3
97935: PPUSH
97936: LD_VAR 0 4
97940: PPUSH
97941: CALL_OW 488
97945: IFFALSE 97968
// begin result := [ x , y ] ;
97947: LD_ADDR_VAR 0 1
97951: PUSH
97952: LD_VAR 0 3
97956: PUSH
97957: LD_VAR 0 4
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: ST_TO_ADDR
// break ;
97966: GO 97970
// end ; end ;
97968: GO 97770
97970: POP
97971: POP
// if result then
97972: LD_VAR 0 1
97976: IFFALSE 98036
// begin ToLua ( playSibBomb() ) ;
97978: LD_STRING playSibBomb()
97980: PPUSH
97981: CALL_OW 559
// wait ( 0 0$14 ) ;
97985: LD_INT 490
97987: PPUSH
97988: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97992: LD_VAR 0 1
97996: PUSH
97997: LD_INT 1
97999: ARRAY
98000: PPUSH
98001: LD_VAR 0 1
98005: PUSH
98006: LD_INT 2
98008: ARRAY
98009: PPUSH
98010: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98014: LD_VAR 0 1
98018: PUSH
98019: LD_INT 1
98021: ARRAY
98022: PPUSH
98023: LD_VAR 0 1
98027: PUSH
98028: LD_INT 2
98030: ARRAY
98031: PPUSH
98032: CALL_OW 429
// end ; end ;
98036: LD_VAR 0 1
98040: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98041: LD_EXP 107
98045: PUSH
98046: LD_EXP 129
98050: AND
98051: IFFALSE 98063
98053: GO 98055
98055: DISABLE
// YouLost (  ) ;
98056: LD_STRING 
98058: PPUSH
98059: CALL_OW 104
98063: END
// every 0 0$1 trigger StreamModeActive and sFog do
98064: LD_EXP 107
98068: PUSH
98069: LD_EXP 128
98073: AND
98074: IFFALSE 98088
98076: GO 98078
98078: DISABLE
// FogOff ( your_side ) ;
98079: LD_OWVAR 2
98083: PPUSH
98084: CALL_OW 344
98088: END
// every 0 0$1 trigger StreamModeActive and sSun do
98089: LD_EXP 107
98093: PUSH
98094: LD_EXP 130
98098: AND
98099: IFFALSE 98127
98101: GO 98103
98103: DISABLE
// begin solar_recharge_percent := 0 ;
98104: LD_ADDR_OWVAR 79
98108: PUSH
98109: LD_INT 0
98111: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98112: LD_INT 10500
98114: PPUSH
98115: CALL_OW 67
// solar_recharge_percent := 100 ;
98119: LD_ADDR_OWVAR 79
98123: PUSH
98124: LD_INT 100
98126: ST_TO_ADDR
// end ;
98127: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98128: LD_EXP 107
98132: PUSH
98133: LD_EXP 131
98137: AND
98138: IFFALSE 98377
98140: GO 98142
98142: DISABLE
98143: LD_INT 0
98145: PPUSH
98146: PPUSH
98147: PPUSH
// begin tmp := [ ] ;
98148: LD_ADDR_VAR 0 3
98152: PUSH
98153: EMPTY
98154: ST_TO_ADDR
// for i := 1 to 6 do
98155: LD_ADDR_VAR 0 1
98159: PUSH
98160: DOUBLE
98161: LD_INT 1
98163: DEC
98164: ST_TO_ADDR
98165: LD_INT 6
98167: PUSH
98168: FOR_TO
98169: IFFALSE 98274
// begin uc_nation := nation_nature ;
98171: LD_ADDR_OWVAR 21
98175: PUSH
98176: LD_INT 0
98178: ST_TO_ADDR
// uc_side := 0 ;
98179: LD_ADDR_OWVAR 20
98183: PUSH
98184: LD_INT 0
98186: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98187: LD_ADDR_OWVAR 29
98191: PUSH
98192: LD_INT 12
98194: PUSH
98195: LD_INT 12
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: ST_TO_ADDR
// hc_agressivity := 20 ;
98202: LD_ADDR_OWVAR 35
98206: PUSH
98207: LD_INT 20
98209: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98210: LD_ADDR_OWVAR 28
98214: PUSH
98215: LD_INT 17
98217: ST_TO_ADDR
// hc_gallery :=  ;
98218: LD_ADDR_OWVAR 33
98222: PUSH
98223: LD_STRING 
98225: ST_TO_ADDR
// hc_name :=  ;
98226: LD_ADDR_OWVAR 26
98230: PUSH
98231: LD_STRING 
98233: ST_TO_ADDR
// un := CreateHuman ;
98234: LD_ADDR_VAR 0 2
98238: PUSH
98239: CALL_OW 44
98243: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98244: LD_VAR 0 2
98248: PPUSH
98249: LD_INT 1
98251: PPUSH
98252: CALL_OW 51
// tmp := tmp ^ un ;
98256: LD_ADDR_VAR 0 3
98260: PUSH
98261: LD_VAR 0 3
98265: PUSH
98266: LD_VAR 0 2
98270: ADD
98271: ST_TO_ADDR
// end ;
98272: GO 98168
98274: POP
98275: POP
// repeat wait ( 0 0$1 ) ;
98276: LD_INT 35
98278: PPUSH
98279: CALL_OW 67
// for un in tmp do
98283: LD_ADDR_VAR 0 2
98287: PUSH
98288: LD_VAR 0 3
98292: PUSH
98293: FOR_IN
98294: IFFALSE 98368
// begin if IsDead ( un ) then
98296: LD_VAR 0 2
98300: PPUSH
98301: CALL_OW 301
98305: IFFALSE 98325
// begin tmp := tmp diff un ;
98307: LD_ADDR_VAR 0 3
98311: PUSH
98312: LD_VAR 0 3
98316: PUSH
98317: LD_VAR 0 2
98321: DIFF
98322: ST_TO_ADDR
// continue ;
98323: GO 98293
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98325: LD_VAR 0 2
98329: PPUSH
98330: LD_INT 3
98332: PUSH
98333: LD_INT 22
98335: PUSH
98336: LD_INT 0
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PPUSH
98347: CALL_OW 69
98351: PPUSH
98352: LD_VAR 0 2
98356: PPUSH
98357: CALL_OW 74
98361: PPUSH
98362: CALL_OW 115
// end ;
98366: GO 98293
98368: POP
98369: POP
// until not tmp ;
98370: LD_VAR 0 3
98374: NOT
98375: IFFALSE 98276
// end ;
98377: PPOPN 3
98379: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98380: LD_EXP 107
98384: PUSH
98385: LD_EXP 132
98389: AND
98390: IFFALSE 98444
98392: GO 98394
98394: DISABLE
// begin ToLua ( displayTroll(); ) ;
98395: LD_STRING displayTroll();
98397: PPUSH
98398: CALL_OW 559
// wait ( 3 3$00 ) ;
98402: LD_INT 6300
98404: PPUSH
98405: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98409: LD_STRING hideTroll();
98411: PPUSH
98412: CALL_OW 559
// wait ( 1 1$00 ) ;
98416: LD_INT 2100
98418: PPUSH
98419: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98423: LD_STRING displayTroll();
98425: PPUSH
98426: CALL_OW 559
// wait ( 1 1$00 ) ;
98430: LD_INT 2100
98432: PPUSH
98433: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98437: LD_STRING hideTroll();
98439: PPUSH
98440: CALL_OW 559
// end ;
98444: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98445: LD_EXP 107
98449: PUSH
98450: LD_EXP 133
98454: AND
98455: IFFALSE 98518
98457: GO 98459
98459: DISABLE
98460: LD_INT 0
98462: PPUSH
// begin p := 0 ;
98463: LD_ADDR_VAR 0 1
98467: PUSH
98468: LD_INT 0
98470: ST_TO_ADDR
// repeat game_speed := 1 ;
98471: LD_ADDR_OWVAR 65
98475: PUSH
98476: LD_INT 1
98478: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98479: LD_INT 35
98481: PPUSH
98482: CALL_OW 67
// p := p + 1 ;
98486: LD_ADDR_VAR 0 1
98490: PUSH
98491: LD_VAR 0 1
98495: PUSH
98496: LD_INT 1
98498: PLUS
98499: ST_TO_ADDR
// until p >= 60 ;
98500: LD_VAR 0 1
98504: PUSH
98505: LD_INT 60
98507: GREATEREQUAL
98508: IFFALSE 98471
// game_speed := 4 ;
98510: LD_ADDR_OWVAR 65
98514: PUSH
98515: LD_INT 4
98517: ST_TO_ADDR
// end ;
98518: PPOPN 1
98520: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98521: LD_EXP 107
98525: PUSH
98526: LD_EXP 134
98530: AND
98531: IFFALSE 98677
98533: GO 98535
98535: DISABLE
98536: LD_INT 0
98538: PPUSH
98539: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98540: LD_ADDR_VAR 0 1
98544: PUSH
98545: LD_INT 22
98547: PUSH
98548: LD_OWVAR 2
98552: PUSH
98553: EMPTY
98554: LIST
98555: LIST
98556: PUSH
98557: LD_INT 2
98559: PUSH
98560: LD_INT 30
98562: PUSH
98563: LD_INT 0
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: PUSH
98570: LD_INT 30
98572: PUSH
98573: LD_INT 1
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: LIST
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PPUSH
98589: CALL_OW 69
98593: ST_TO_ADDR
// if not depot then
98594: LD_VAR 0 1
98598: NOT
98599: IFFALSE 98603
// exit ;
98601: GO 98677
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98603: LD_ADDR_VAR 0 2
98607: PUSH
98608: LD_VAR 0 1
98612: PUSH
98613: LD_INT 1
98615: PPUSH
98616: LD_VAR 0 1
98620: PPUSH
98621: CALL_OW 12
98625: ARRAY
98626: PPUSH
98627: CALL_OW 274
98631: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98632: LD_VAR 0 2
98636: PPUSH
98637: LD_INT 1
98639: PPUSH
98640: LD_INT 0
98642: PPUSH
98643: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98647: LD_VAR 0 2
98651: PPUSH
98652: LD_INT 2
98654: PPUSH
98655: LD_INT 0
98657: PPUSH
98658: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98662: LD_VAR 0 2
98666: PPUSH
98667: LD_INT 3
98669: PPUSH
98670: LD_INT 0
98672: PPUSH
98673: CALL_OW 277
// end ;
98677: PPOPN 2
98679: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98680: LD_EXP 107
98684: PUSH
98685: LD_EXP 135
98689: AND
98690: IFFALSE 98787
98692: GO 98694
98694: DISABLE
98695: LD_INT 0
98697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98698: LD_ADDR_VAR 0 1
98702: PUSH
98703: LD_INT 22
98705: PUSH
98706: LD_OWVAR 2
98710: PUSH
98711: EMPTY
98712: LIST
98713: LIST
98714: PUSH
98715: LD_INT 21
98717: PUSH
98718: LD_INT 1
98720: PUSH
98721: EMPTY
98722: LIST
98723: LIST
98724: PUSH
98725: LD_INT 3
98727: PUSH
98728: LD_INT 23
98730: PUSH
98731: LD_INT 0
98733: PUSH
98734: EMPTY
98735: LIST
98736: LIST
98737: PUSH
98738: EMPTY
98739: LIST
98740: LIST
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: LIST
98746: PPUSH
98747: CALL_OW 69
98751: ST_TO_ADDR
// if not tmp then
98752: LD_VAR 0 1
98756: NOT
98757: IFFALSE 98761
// exit ;
98759: GO 98787
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98761: LD_VAR 0 1
98765: PUSH
98766: LD_INT 1
98768: PPUSH
98769: LD_VAR 0 1
98773: PPUSH
98774: CALL_OW 12
98778: ARRAY
98779: PPUSH
98780: LD_INT 200
98782: PPUSH
98783: CALL_OW 234
// end ;
98787: PPOPN 1
98789: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98790: LD_EXP 107
98794: PUSH
98795: LD_EXP 136
98799: AND
98800: IFFALSE 98879
98802: GO 98804
98804: DISABLE
98805: LD_INT 0
98807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98808: LD_ADDR_VAR 0 1
98812: PUSH
98813: LD_INT 22
98815: PUSH
98816: LD_OWVAR 2
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 21
98827: PUSH
98828: LD_INT 2
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: EMPTY
98836: LIST
98837: LIST
98838: PPUSH
98839: CALL_OW 69
98843: ST_TO_ADDR
// if not tmp then
98844: LD_VAR 0 1
98848: NOT
98849: IFFALSE 98853
// exit ;
98851: GO 98879
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98853: LD_VAR 0 1
98857: PUSH
98858: LD_INT 1
98860: PPUSH
98861: LD_VAR 0 1
98865: PPUSH
98866: CALL_OW 12
98870: ARRAY
98871: PPUSH
98872: LD_INT 60
98874: PPUSH
98875: CALL_OW 234
// end ;
98879: PPOPN 1
98881: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98882: LD_EXP 107
98886: PUSH
98887: LD_EXP 137
98891: AND
98892: IFFALSE 98991
98894: GO 98896
98896: DISABLE
98897: LD_INT 0
98899: PPUSH
98900: PPUSH
// begin enable ;
98901: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98902: LD_ADDR_VAR 0 1
98906: PUSH
98907: LD_INT 22
98909: PUSH
98910: LD_OWVAR 2
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: PUSH
98919: LD_INT 61
98921: PUSH
98922: EMPTY
98923: LIST
98924: PUSH
98925: LD_INT 33
98927: PUSH
98928: LD_INT 2
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: EMPTY
98936: LIST
98937: LIST
98938: LIST
98939: PPUSH
98940: CALL_OW 69
98944: ST_TO_ADDR
// if not tmp then
98945: LD_VAR 0 1
98949: NOT
98950: IFFALSE 98954
// exit ;
98952: GO 98991
// for i in tmp do
98954: LD_ADDR_VAR 0 2
98958: PUSH
98959: LD_VAR 0 1
98963: PUSH
98964: FOR_IN
98965: IFFALSE 98989
// if IsControledBy ( i ) then
98967: LD_VAR 0 2
98971: PPUSH
98972: CALL_OW 312
98976: IFFALSE 98987
// ComUnlink ( i ) ;
98978: LD_VAR 0 2
98982: PPUSH
98983: CALL_OW 136
98987: GO 98964
98989: POP
98990: POP
// end ;
98991: PPOPN 2
98993: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98994: LD_EXP 107
98998: PUSH
98999: LD_EXP 138
99003: AND
99004: IFFALSE 99144
99006: GO 99008
99008: DISABLE
99009: LD_INT 0
99011: PPUSH
99012: PPUSH
// begin ToLua ( displayPowell(); ) ;
99013: LD_STRING displayPowell();
99015: PPUSH
99016: CALL_OW 559
// uc_side := 0 ;
99020: LD_ADDR_OWVAR 20
99024: PUSH
99025: LD_INT 0
99027: ST_TO_ADDR
// uc_nation := 2 ;
99028: LD_ADDR_OWVAR 21
99032: PUSH
99033: LD_INT 2
99035: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99036: LD_ADDR_OWVAR 37
99040: PUSH
99041: LD_INT 14
99043: ST_TO_ADDR
// vc_engine := engine_siberite ;
99044: LD_ADDR_OWVAR 39
99048: PUSH
99049: LD_INT 3
99051: ST_TO_ADDR
// vc_control := control_apeman ;
99052: LD_ADDR_OWVAR 38
99056: PUSH
99057: LD_INT 5
99059: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99060: LD_ADDR_OWVAR 40
99064: PUSH
99065: LD_INT 29
99067: ST_TO_ADDR
// un := CreateVehicle ;
99068: LD_ADDR_VAR 0 2
99072: PUSH
99073: CALL_OW 45
99077: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99078: LD_VAR 0 2
99082: PPUSH
99083: LD_INT 1
99085: PPUSH
99086: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99090: LD_INT 35
99092: PPUSH
99093: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99097: LD_VAR 0 2
99101: PPUSH
99102: LD_INT 22
99104: PUSH
99105: LD_OWVAR 2
99109: PUSH
99110: EMPTY
99111: LIST
99112: LIST
99113: PPUSH
99114: CALL_OW 69
99118: PPUSH
99119: LD_VAR 0 2
99123: PPUSH
99124: CALL_OW 74
99128: PPUSH
99129: CALL_OW 115
// until IsDead ( un ) ;
99133: LD_VAR 0 2
99137: PPUSH
99138: CALL_OW 301
99142: IFFALSE 99090
// end ;
99144: PPOPN 2
99146: END
// every 0 0$1 trigger StreamModeActive and sStu do
99147: LD_EXP 107
99151: PUSH
99152: LD_EXP 146
99156: AND
99157: IFFALSE 99173
99159: GO 99161
99161: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99162: LD_STRING displayStucuk();
99164: PPUSH
99165: CALL_OW 559
// ResetFog ;
99169: CALL_OW 335
// end ;
99173: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99174: LD_EXP 107
99178: PUSH
99179: LD_EXP 139
99183: AND
99184: IFFALSE 99325
99186: GO 99188
99188: DISABLE
99189: LD_INT 0
99191: PPUSH
99192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99193: LD_ADDR_VAR 0 2
99197: PUSH
99198: LD_INT 22
99200: PUSH
99201: LD_OWVAR 2
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: PUSH
99210: LD_INT 21
99212: PUSH
99213: LD_INT 1
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: PPUSH
99224: CALL_OW 69
99228: ST_TO_ADDR
// if not tmp then
99229: LD_VAR 0 2
99233: NOT
99234: IFFALSE 99238
// exit ;
99236: GO 99325
// un := tmp [ rand ( 1 , tmp ) ] ;
99238: LD_ADDR_VAR 0 1
99242: PUSH
99243: LD_VAR 0 2
99247: PUSH
99248: LD_INT 1
99250: PPUSH
99251: LD_VAR 0 2
99255: PPUSH
99256: CALL_OW 12
99260: ARRAY
99261: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99262: LD_VAR 0 1
99266: PPUSH
99267: LD_INT 0
99269: PPUSH
99270: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99274: LD_VAR 0 1
99278: PPUSH
99279: LD_OWVAR 3
99283: PUSH
99284: LD_VAR 0 1
99288: DIFF
99289: PPUSH
99290: LD_VAR 0 1
99294: PPUSH
99295: CALL_OW 74
99299: PPUSH
99300: CALL_OW 115
// wait ( 0 0$20 ) ;
99304: LD_INT 700
99306: PPUSH
99307: CALL_OW 67
// SetSide ( un , your_side ) ;
99311: LD_VAR 0 1
99315: PPUSH
99316: LD_OWVAR 2
99320: PPUSH
99321: CALL_OW 235
// end ;
99325: PPOPN 2
99327: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99328: LD_EXP 107
99332: PUSH
99333: LD_EXP 140
99337: AND
99338: IFFALSE 99444
99340: GO 99342
99342: DISABLE
99343: LD_INT 0
99345: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99346: LD_ADDR_VAR 0 1
99350: PUSH
99351: LD_INT 22
99353: PUSH
99354: LD_OWVAR 2
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: LD_INT 2
99365: PUSH
99366: LD_INT 30
99368: PUSH
99369: LD_INT 0
99371: PUSH
99372: EMPTY
99373: LIST
99374: LIST
99375: PUSH
99376: LD_INT 30
99378: PUSH
99379: LD_INT 1
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: LIST
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: PPUSH
99395: CALL_OW 69
99399: ST_TO_ADDR
// if not depot then
99400: LD_VAR 0 1
99404: NOT
99405: IFFALSE 99409
// exit ;
99407: GO 99444
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99409: LD_VAR 0 1
99413: PUSH
99414: LD_INT 1
99416: ARRAY
99417: PPUSH
99418: CALL_OW 250
99422: PPUSH
99423: LD_VAR 0 1
99427: PUSH
99428: LD_INT 1
99430: ARRAY
99431: PPUSH
99432: CALL_OW 251
99436: PPUSH
99437: LD_INT 70
99439: PPUSH
99440: CALL_OW 495
// end ;
99444: PPOPN 1
99446: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99447: LD_EXP 107
99451: PUSH
99452: LD_EXP 141
99456: AND
99457: IFFALSE 99668
99459: GO 99461
99461: DISABLE
99462: LD_INT 0
99464: PPUSH
99465: PPUSH
99466: PPUSH
99467: PPUSH
99468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99469: LD_ADDR_VAR 0 5
99473: PUSH
99474: LD_INT 22
99476: PUSH
99477: LD_OWVAR 2
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: PUSH
99486: LD_INT 21
99488: PUSH
99489: LD_INT 1
99491: PUSH
99492: EMPTY
99493: LIST
99494: LIST
99495: PUSH
99496: EMPTY
99497: LIST
99498: LIST
99499: PPUSH
99500: CALL_OW 69
99504: ST_TO_ADDR
// if not tmp then
99505: LD_VAR 0 5
99509: NOT
99510: IFFALSE 99514
// exit ;
99512: GO 99668
// for i in tmp do
99514: LD_ADDR_VAR 0 1
99518: PUSH
99519: LD_VAR 0 5
99523: PUSH
99524: FOR_IN
99525: IFFALSE 99666
// begin d := rand ( 0 , 5 ) ;
99527: LD_ADDR_VAR 0 4
99531: PUSH
99532: LD_INT 0
99534: PPUSH
99535: LD_INT 5
99537: PPUSH
99538: CALL_OW 12
99542: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99543: LD_ADDR_VAR 0 2
99547: PUSH
99548: LD_VAR 0 1
99552: PPUSH
99553: CALL_OW 250
99557: PPUSH
99558: LD_VAR 0 4
99562: PPUSH
99563: LD_INT 3
99565: PPUSH
99566: LD_INT 12
99568: PPUSH
99569: CALL_OW 12
99573: PPUSH
99574: CALL_OW 272
99578: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99579: LD_ADDR_VAR 0 3
99583: PUSH
99584: LD_VAR 0 1
99588: PPUSH
99589: CALL_OW 251
99593: PPUSH
99594: LD_VAR 0 4
99598: PPUSH
99599: LD_INT 3
99601: PPUSH
99602: LD_INT 12
99604: PPUSH
99605: CALL_OW 12
99609: PPUSH
99610: CALL_OW 273
99614: ST_TO_ADDR
// if ValidHex ( x , y ) then
99615: LD_VAR 0 2
99619: PPUSH
99620: LD_VAR 0 3
99624: PPUSH
99625: CALL_OW 488
99629: IFFALSE 99664
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99631: LD_VAR 0 1
99635: PPUSH
99636: LD_VAR 0 2
99640: PPUSH
99641: LD_VAR 0 3
99645: PPUSH
99646: LD_INT 3
99648: PPUSH
99649: LD_INT 6
99651: PPUSH
99652: CALL_OW 12
99656: PPUSH
99657: LD_INT 1
99659: PPUSH
99660: CALL_OW 483
// end ;
99664: GO 99524
99666: POP
99667: POP
// end ;
99668: PPOPN 5
99670: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99671: LD_EXP 107
99675: PUSH
99676: LD_EXP 142
99680: AND
99681: IFFALSE 99775
99683: GO 99685
99685: DISABLE
99686: LD_INT 0
99688: PPUSH
99689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99690: LD_ADDR_VAR 0 2
99694: PUSH
99695: LD_INT 22
99697: PUSH
99698: LD_OWVAR 2
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: PUSH
99707: LD_INT 32
99709: PUSH
99710: LD_INT 1
99712: PUSH
99713: EMPTY
99714: LIST
99715: LIST
99716: PUSH
99717: LD_INT 21
99719: PUSH
99720: LD_INT 2
99722: PUSH
99723: EMPTY
99724: LIST
99725: LIST
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: LIST
99731: PPUSH
99732: CALL_OW 69
99736: ST_TO_ADDR
// if not tmp then
99737: LD_VAR 0 2
99741: NOT
99742: IFFALSE 99746
// exit ;
99744: GO 99775
// for i in tmp do
99746: LD_ADDR_VAR 0 1
99750: PUSH
99751: LD_VAR 0 2
99755: PUSH
99756: FOR_IN
99757: IFFALSE 99773
// SetFuel ( i , 0 ) ;
99759: LD_VAR 0 1
99763: PPUSH
99764: LD_INT 0
99766: PPUSH
99767: CALL_OW 240
99771: GO 99756
99773: POP
99774: POP
// end ;
99775: PPOPN 2
99777: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99778: LD_EXP 107
99782: PUSH
99783: LD_EXP 143
99787: AND
99788: IFFALSE 99854
99790: GO 99792
99792: DISABLE
99793: LD_INT 0
99795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99796: LD_ADDR_VAR 0 1
99800: PUSH
99801: LD_INT 22
99803: PUSH
99804: LD_OWVAR 2
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 30
99815: PUSH
99816: LD_INT 29
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: EMPTY
99824: LIST
99825: LIST
99826: PPUSH
99827: CALL_OW 69
99831: ST_TO_ADDR
// if not tmp then
99832: LD_VAR 0 1
99836: NOT
99837: IFFALSE 99841
// exit ;
99839: GO 99854
// DestroyUnit ( tmp [ 1 ] ) ;
99841: LD_VAR 0 1
99845: PUSH
99846: LD_INT 1
99848: ARRAY
99849: PPUSH
99850: CALL_OW 65
// end ;
99854: PPOPN 1
99856: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99857: LD_EXP 107
99861: PUSH
99862: LD_EXP 145
99866: AND
99867: IFFALSE 99996
99869: GO 99871
99871: DISABLE
99872: LD_INT 0
99874: PPUSH
// begin uc_side := 0 ;
99875: LD_ADDR_OWVAR 20
99879: PUSH
99880: LD_INT 0
99882: ST_TO_ADDR
// uc_nation := nation_arabian ;
99883: LD_ADDR_OWVAR 21
99887: PUSH
99888: LD_INT 2
99890: ST_TO_ADDR
// hc_gallery :=  ;
99891: LD_ADDR_OWVAR 33
99895: PUSH
99896: LD_STRING 
99898: ST_TO_ADDR
// hc_name :=  ;
99899: LD_ADDR_OWVAR 26
99903: PUSH
99904: LD_STRING 
99906: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99907: LD_INT 1
99909: PPUSH
99910: LD_INT 11
99912: PPUSH
99913: LD_INT 10
99915: PPUSH
99916: CALL_OW 380
// un := CreateHuman ;
99920: LD_ADDR_VAR 0 1
99924: PUSH
99925: CALL_OW 44
99929: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99930: LD_VAR 0 1
99934: PPUSH
99935: LD_INT 1
99937: PPUSH
99938: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99942: LD_INT 35
99944: PPUSH
99945: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99949: LD_VAR 0 1
99953: PPUSH
99954: LD_INT 22
99956: PUSH
99957: LD_OWVAR 2
99961: PUSH
99962: EMPTY
99963: LIST
99964: LIST
99965: PPUSH
99966: CALL_OW 69
99970: PPUSH
99971: LD_VAR 0 1
99975: PPUSH
99976: CALL_OW 74
99980: PPUSH
99981: CALL_OW 115
// until IsDead ( un ) ;
99985: LD_VAR 0 1
99989: PPUSH
99990: CALL_OW 301
99994: IFFALSE 99942
// end ;
99996: PPOPN 1
99998: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99999: LD_EXP 107
100003: PUSH
100004: LD_EXP 147
100008: AND
100009: IFFALSE 100021
100011: GO 100013
100013: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100014: LD_STRING earthquake(getX(game), 0, 32)
100016: PPUSH
100017: CALL_OW 559
100021: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100022: LD_EXP 107
100026: PUSH
100027: LD_EXP 148
100031: AND
100032: IFFALSE 100123
100034: GO 100036
100036: DISABLE
100037: LD_INT 0
100039: PPUSH
// begin enable ;
100040: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100041: LD_ADDR_VAR 0 1
100045: PUSH
100046: LD_INT 22
100048: PUSH
100049: LD_OWVAR 2
100053: PUSH
100054: EMPTY
100055: LIST
100056: LIST
100057: PUSH
100058: LD_INT 21
100060: PUSH
100061: LD_INT 2
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: PUSH
100068: LD_INT 33
100070: PUSH
100071: LD_INT 3
100073: PUSH
100074: EMPTY
100075: LIST
100076: LIST
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: LIST
100082: PPUSH
100083: CALL_OW 69
100087: ST_TO_ADDR
// if not tmp then
100088: LD_VAR 0 1
100092: NOT
100093: IFFALSE 100097
// exit ;
100095: GO 100123
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100097: LD_VAR 0 1
100101: PUSH
100102: LD_INT 1
100104: PPUSH
100105: LD_VAR 0 1
100109: PPUSH
100110: CALL_OW 12
100114: ARRAY
100115: PPUSH
100116: LD_INT 1
100118: PPUSH
100119: CALL_OW 234
// end ;
100123: PPOPN 1
100125: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100126: LD_EXP 107
100130: PUSH
100131: LD_EXP 149
100135: AND
100136: IFFALSE 100277
100138: GO 100140
100140: DISABLE
100141: LD_INT 0
100143: PPUSH
100144: PPUSH
100145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100146: LD_ADDR_VAR 0 3
100150: PUSH
100151: LD_INT 22
100153: PUSH
100154: LD_OWVAR 2
100158: PUSH
100159: EMPTY
100160: LIST
100161: LIST
100162: PUSH
100163: LD_INT 25
100165: PUSH
100166: LD_INT 1
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PPUSH
100177: CALL_OW 69
100181: ST_TO_ADDR
// if not tmp then
100182: LD_VAR 0 3
100186: NOT
100187: IFFALSE 100191
// exit ;
100189: GO 100277
// un := tmp [ rand ( 1 , tmp ) ] ;
100191: LD_ADDR_VAR 0 2
100195: PUSH
100196: LD_VAR 0 3
100200: PUSH
100201: LD_INT 1
100203: PPUSH
100204: LD_VAR 0 3
100208: PPUSH
100209: CALL_OW 12
100213: ARRAY
100214: ST_TO_ADDR
// if Crawls ( un ) then
100215: LD_VAR 0 2
100219: PPUSH
100220: CALL_OW 318
100224: IFFALSE 100235
// ComWalk ( un ) ;
100226: LD_VAR 0 2
100230: PPUSH
100231: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100235: LD_VAR 0 2
100239: PPUSH
100240: LD_INT 9
100242: PPUSH
100243: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100247: LD_INT 28
100249: PPUSH
100250: LD_OWVAR 2
100254: PPUSH
100255: LD_INT 2
100257: PPUSH
100258: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100262: LD_INT 29
100264: PPUSH
100265: LD_OWVAR 2
100269: PPUSH
100270: LD_INT 2
100272: PPUSH
100273: CALL_OW 322
// end ;
100277: PPOPN 3
100279: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100280: LD_EXP 107
100284: PUSH
100285: LD_EXP 150
100289: AND
100290: IFFALSE 100401
100292: GO 100294
100294: DISABLE
100295: LD_INT 0
100297: PPUSH
100298: PPUSH
100299: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100300: LD_ADDR_VAR 0 3
100304: PUSH
100305: LD_INT 22
100307: PUSH
100308: LD_OWVAR 2
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: LD_INT 25
100319: PUSH
100320: LD_INT 1
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PPUSH
100331: CALL_OW 69
100335: ST_TO_ADDR
// if not tmp then
100336: LD_VAR 0 3
100340: NOT
100341: IFFALSE 100345
// exit ;
100343: GO 100401
// un := tmp [ rand ( 1 , tmp ) ] ;
100345: LD_ADDR_VAR 0 2
100349: PUSH
100350: LD_VAR 0 3
100354: PUSH
100355: LD_INT 1
100357: PPUSH
100358: LD_VAR 0 3
100362: PPUSH
100363: CALL_OW 12
100367: ARRAY
100368: ST_TO_ADDR
// if Crawls ( un ) then
100369: LD_VAR 0 2
100373: PPUSH
100374: CALL_OW 318
100378: IFFALSE 100389
// ComWalk ( un ) ;
100380: LD_VAR 0 2
100384: PPUSH
100385: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100389: LD_VAR 0 2
100393: PPUSH
100394: LD_INT 8
100396: PPUSH
100397: CALL_OW 336
// end ;
100401: PPOPN 3
100403: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100404: LD_EXP 107
100408: PUSH
100409: LD_EXP 151
100413: AND
100414: IFFALSE 100558
100416: GO 100418
100418: DISABLE
100419: LD_INT 0
100421: PPUSH
100422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100423: LD_ADDR_VAR 0 2
100427: PUSH
100428: LD_INT 22
100430: PUSH
100431: LD_OWVAR 2
100435: PUSH
100436: EMPTY
100437: LIST
100438: LIST
100439: PUSH
100440: LD_INT 21
100442: PUSH
100443: LD_INT 2
100445: PUSH
100446: EMPTY
100447: LIST
100448: LIST
100449: PUSH
100450: LD_INT 2
100452: PUSH
100453: LD_INT 34
100455: PUSH
100456: LD_INT 12
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: PUSH
100463: LD_INT 34
100465: PUSH
100466: LD_INT 51
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PUSH
100473: LD_INT 34
100475: PUSH
100476: LD_INT 32
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: EMPTY
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: LIST
100493: PPUSH
100494: CALL_OW 69
100498: ST_TO_ADDR
// if not tmp then
100499: LD_VAR 0 2
100503: NOT
100504: IFFALSE 100508
// exit ;
100506: GO 100558
// for i in tmp do
100508: LD_ADDR_VAR 0 1
100512: PUSH
100513: LD_VAR 0 2
100517: PUSH
100518: FOR_IN
100519: IFFALSE 100556
// if GetCargo ( i , mat_artifact ) = 0 then
100521: LD_VAR 0 1
100525: PPUSH
100526: LD_INT 4
100528: PPUSH
100529: CALL_OW 289
100533: PUSH
100534: LD_INT 0
100536: EQUAL
100537: IFFALSE 100554
// SetCargo ( i , mat_siberit , 100 ) ;
100539: LD_VAR 0 1
100543: PPUSH
100544: LD_INT 3
100546: PPUSH
100547: LD_INT 100
100549: PPUSH
100550: CALL_OW 290
100554: GO 100518
100556: POP
100557: POP
// end ;
100558: PPOPN 2
100560: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100561: LD_EXP 107
100565: PUSH
100566: LD_EXP 152
100570: AND
100571: IFFALSE 100754
100573: GO 100575
100575: DISABLE
100576: LD_INT 0
100578: PPUSH
100579: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100580: LD_ADDR_VAR 0 2
100584: PUSH
100585: LD_INT 22
100587: PUSH
100588: LD_OWVAR 2
100592: PUSH
100593: EMPTY
100594: LIST
100595: LIST
100596: PPUSH
100597: CALL_OW 69
100601: ST_TO_ADDR
// if not tmp then
100602: LD_VAR 0 2
100606: NOT
100607: IFFALSE 100611
// exit ;
100609: GO 100754
// for i := 1 to 2 do
100611: LD_ADDR_VAR 0 1
100615: PUSH
100616: DOUBLE
100617: LD_INT 1
100619: DEC
100620: ST_TO_ADDR
100621: LD_INT 2
100623: PUSH
100624: FOR_TO
100625: IFFALSE 100752
// begin uc_side := your_side ;
100627: LD_ADDR_OWVAR 20
100631: PUSH
100632: LD_OWVAR 2
100636: ST_TO_ADDR
// uc_nation := nation_american ;
100637: LD_ADDR_OWVAR 21
100641: PUSH
100642: LD_INT 1
100644: ST_TO_ADDR
// vc_chassis := us_morphling ;
100645: LD_ADDR_OWVAR 37
100649: PUSH
100650: LD_INT 5
100652: ST_TO_ADDR
// vc_engine := engine_siberite ;
100653: LD_ADDR_OWVAR 39
100657: PUSH
100658: LD_INT 3
100660: ST_TO_ADDR
// vc_control := control_computer ;
100661: LD_ADDR_OWVAR 38
100665: PUSH
100666: LD_INT 3
100668: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100669: LD_ADDR_OWVAR 40
100673: PUSH
100674: LD_INT 10
100676: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100677: LD_VAR 0 2
100681: PUSH
100682: LD_INT 1
100684: ARRAY
100685: PPUSH
100686: CALL_OW 310
100690: NOT
100691: IFFALSE 100738
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100693: CALL_OW 45
100697: PPUSH
100698: LD_VAR 0 2
100702: PUSH
100703: LD_INT 1
100705: ARRAY
100706: PPUSH
100707: CALL_OW 250
100711: PPUSH
100712: LD_VAR 0 2
100716: PUSH
100717: LD_INT 1
100719: ARRAY
100720: PPUSH
100721: CALL_OW 251
100725: PPUSH
100726: LD_INT 12
100728: PPUSH
100729: LD_INT 1
100731: PPUSH
100732: CALL_OW 50
100736: GO 100750
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100738: CALL_OW 45
100742: PPUSH
100743: LD_INT 1
100745: PPUSH
100746: CALL_OW 51
// end ;
100750: GO 100624
100752: POP
100753: POP
// end ;
100754: PPOPN 2
100756: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100757: LD_EXP 107
100761: PUSH
100762: LD_EXP 153
100766: AND
100767: IFFALSE 100989
100769: GO 100771
100771: DISABLE
100772: LD_INT 0
100774: PPUSH
100775: PPUSH
100776: PPUSH
100777: PPUSH
100778: PPUSH
100779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100780: LD_ADDR_VAR 0 6
100784: PUSH
100785: LD_INT 22
100787: PUSH
100788: LD_OWVAR 2
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 21
100799: PUSH
100800: LD_INT 1
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 3
100809: PUSH
100810: LD_INT 23
100812: PUSH
100813: LD_INT 0
100815: PUSH
100816: EMPTY
100817: LIST
100818: LIST
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: PUSH
100824: EMPTY
100825: LIST
100826: LIST
100827: LIST
100828: PPUSH
100829: CALL_OW 69
100833: ST_TO_ADDR
// if not tmp then
100834: LD_VAR 0 6
100838: NOT
100839: IFFALSE 100843
// exit ;
100841: GO 100989
// s1 := rand ( 1 , 4 ) ;
100843: LD_ADDR_VAR 0 2
100847: PUSH
100848: LD_INT 1
100850: PPUSH
100851: LD_INT 4
100853: PPUSH
100854: CALL_OW 12
100858: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100859: LD_ADDR_VAR 0 4
100863: PUSH
100864: LD_VAR 0 6
100868: PUSH
100869: LD_INT 1
100871: ARRAY
100872: PPUSH
100873: LD_VAR 0 2
100877: PPUSH
100878: CALL_OW 259
100882: ST_TO_ADDR
// if s1 = 1 then
100883: LD_VAR 0 2
100887: PUSH
100888: LD_INT 1
100890: EQUAL
100891: IFFALSE 100911
// s2 := rand ( 2 , 4 ) else
100893: LD_ADDR_VAR 0 3
100897: PUSH
100898: LD_INT 2
100900: PPUSH
100901: LD_INT 4
100903: PPUSH
100904: CALL_OW 12
100908: ST_TO_ADDR
100909: GO 100919
// s2 := 1 ;
100911: LD_ADDR_VAR 0 3
100915: PUSH
100916: LD_INT 1
100918: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100919: LD_ADDR_VAR 0 5
100923: PUSH
100924: LD_VAR 0 6
100928: PUSH
100929: LD_INT 1
100931: ARRAY
100932: PPUSH
100933: LD_VAR 0 3
100937: PPUSH
100938: CALL_OW 259
100942: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100943: LD_VAR 0 6
100947: PUSH
100948: LD_INT 1
100950: ARRAY
100951: PPUSH
100952: LD_VAR 0 2
100956: PPUSH
100957: LD_VAR 0 5
100961: PPUSH
100962: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100966: LD_VAR 0 6
100970: PUSH
100971: LD_INT 1
100973: ARRAY
100974: PPUSH
100975: LD_VAR 0 3
100979: PPUSH
100980: LD_VAR 0 4
100984: PPUSH
100985: CALL_OW 237
// end ;
100989: PPOPN 6
100991: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100992: LD_EXP 107
100996: PUSH
100997: LD_EXP 154
101001: AND
101002: IFFALSE 101081
101004: GO 101006
101006: DISABLE
101007: LD_INT 0
101009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101010: LD_ADDR_VAR 0 1
101014: PUSH
101015: LD_INT 22
101017: PUSH
101018: LD_OWVAR 2
101022: PUSH
101023: EMPTY
101024: LIST
101025: LIST
101026: PUSH
101027: LD_INT 30
101029: PUSH
101030: LD_INT 3
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PPUSH
101041: CALL_OW 69
101045: ST_TO_ADDR
// if not tmp then
101046: LD_VAR 0 1
101050: NOT
101051: IFFALSE 101055
// exit ;
101053: GO 101081
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101055: LD_VAR 0 1
101059: PUSH
101060: LD_INT 1
101062: PPUSH
101063: LD_VAR 0 1
101067: PPUSH
101068: CALL_OW 12
101072: ARRAY
101073: PPUSH
101074: LD_INT 1
101076: PPUSH
101077: CALL_OW 234
// end ;
101081: PPOPN 1
101083: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101084: LD_EXP 107
101088: PUSH
101089: LD_EXP 155
101093: AND
101094: IFFALSE 101206
101096: GO 101098
101098: DISABLE
101099: LD_INT 0
101101: PPUSH
101102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101103: LD_ADDR_VAR 0 2
101107: PUSH
101108: LD_INT 22
101110: PUSH
101111: LD_OWVAR 2
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PUSH
101120: LD_INT 2
101122: PUSH
101123: LD_INT 30
101125: PUSH
101126: LD_INT 27
101128: PUSH
101129: EMPTY
101130: LIST
101131: LIST
101132: PUSH
101133: LD_INT 30
101135: PUSH
101136: LD_INT 26
101138: PUSH
101139: EMPTY
101140: LIST
101141: LIST
101142: PUSH
101143: LD_INT 30
101145: PUSH
101146: LD_INT 28
101148: PUSH
101149: EMPTY
101150: LIST
101151: LIST
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: LIST
101157: LIST
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PPUSH
101163: CALL_OW 69
101167: ST_TO_ADDR
// if not tmp then
101168: LD_VAR 0 2
101172: NOT
101173: IFFALSE 101177
// exit ;
101175: GO 101206
// for i in tmp do
101177: LD_ADDR_VAR 0 1
101181: PUSH
101182: LD_VAR 0 2
101186: PUSH
101187: FOR_IN
101188: IFFALSE 101204
// SetLives ( i , 1 ) ;
101190: LD_VAR 0 1
101194: PPUSH
101195: LD_INT 1
101197: PPUSH
101198: CALL_OW 234
101202: GO 101187
101204: POP
101205: POP
// end ;
101206: PPOPN 2
101208: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101209: LD_EXP 107
101213: PUSH
101214: LD_EXP 156
101218: AND
101219: IFFALSE 101506
101221: GO 101223
101223: DISABLE
101224: LD_INT 0
101226: PPUSH
101227: PPUSH
101228: PPUSH
// begin i := rand ( 1 , 7 ) ;
101229: LD_ADDR_VAR 0 1
101233: PUSH
101234: LD_INT 1
101236: PPUSH
101237: LD_INT 7
101239: PPUSH
101240: CALL_OW 12
101244: ST_TO_ADDR
// case i of 1 :
101245: LD_VAR 0 1
101249: PUSH
101250: LD_INT 1
101252: DOUBLE
101253: EQUAL
101254: IFTRUE 101258
101256: GO 101268
101258: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101259: LD_STRING earthquake(getX(game), 0, 32)
101261: PPUSH
101262: CALL_OW 559
101266: GO 101506
101268: LD_INT 2
101270: DOUBLE
101271: EQUAL
101272: IFTRUE 101276
101274: GO 101290
101276: POP
// begin ToLua ( displayStucuk(); ) ;
101277: LD_STRING displayStucuk();
101279: PPUSH
101280: CALL_OW 559
// ResetFog ;
101284: CALL_OW 335
// end ; 3 :
101288: GO 101506
101290: LD_INT 3
101292: DOUBLE
101293: EQUAL
101294: IFTRUE 101298
101296: GO 101402
101298: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101299: LD_ADDR_VAR 0 2
101303: PUSH
101304: LD_INT 22
101306: PUSH
101307: LD_OWVAR 2
101311: PUSH
101312: EMPTY
101313: LIST
101314: LIST
101315: PUSH
101316: LD_INT 25
101318: PUSH
101319: LD_INT 1
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: EMPTY
101327: LIST
101328: LIST
101329: PPUSH
101330: CALL_OW 69
101334: ST_TO_ADDR
// if not tmp then
101335: LD_VAR 0 2
101339: NOT
101340: IFFALSE 101344
// exit ;
101342: GO 101506
// un := tmp [ rand ( 1 , tmp ) ] ;
101344: LD_ADDR_VAR 0 3
101348: PUSH
101349: LD_VAR 0 2
101353: PUSH
101354: LD_INT 1
101356: PPUSH
101357: LD_VAR 0 2
101361: PPUSH
101362: CALL_OW 12
101366: ARRAY
101367: ST_TO_ADDR
// if Crawls ( un ) then
101368: LD_VAR 0 3
101372: PPUSH
101373: CALL_OW 318
101377: IFFALSE 101388
// ComWalk ( un ) ;
101379: LD_VAR 0 3
101383: PPUSH
101384: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101388: LD_VAR 0 3
101392: PPUSH
101393: LD_INT 8
101395: PPUSH
101396: CALL_OW 336
// end ; 4 :
101400: GO 101506
101402: LD_INT 4
101404: DOUBLE
101405: EQUAL
101406: IFTRUE 101410
101408: GO 101484
101410: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101411: LD_ADDR_VAR 0 2
101415: PUSH
101416: LD_INT 22
101418: PUSH
101419: LD_OWVAR 2
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 30
101430: PUSH
101431: LD_INT 29
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: EMPTY
101439: LIST
101440: LIST
101441: PPUSH
101442: CALL_OW 69
101446: ST_TO_ADDR
// if not tmp then
101447: LD_VAR 0 2
101451: NOT
101452: IFFALSE 101456
// exit ;
101454: GO 101506
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101456: LD_VAR 0 2
101460: PUSH
101461: LD_INT 1
101463: ARRAY
101464: PPUSH
101465: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101469: LD_VAR 0 2
101473: PUSH
101474: LD_INT 1
101476: ARRAY
101477: PPUSH
101478: CALL_OW 65
// end ; 5 .. 7 :
101482: GO 101506
101484: LD_INT 5
101486: DOUBLE
101487: GREATEREQUAL
101488: IFFALSE 101496
101490: LD_INT 7
101492: DOUBLE
101493: LESSEQUAL
101494: IFTRUE 101498
101496: GO 101505
101498: POP
// StreamSibBomb ; end ;
101499: CALL 97743 0 0
101503: GO 101506
101505: POP
// end ;
101506: PPOPN 3
101508: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101509: LD_EXP 107
101513: PUSH
101514: LD_EXP 157
101518: AND
101519: IFFALSE 101675
101521: GO 101523
101523: DISABLE
101524: LD_INT 0
101526: PPUSH
101527: PPUSH
101528: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101529: LD_ADDR_VAR 0 2
101533: PUSH
101534: LD_INT 81
101536: PUSH
101537: LD_OWVAR 2
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PUSH
101546: LD_INT 2
101548: PUSH
101549: LD_INT 21
101551: PUSH
101552: LD_INT 1
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: PUSH
101559: LD_INT 21
101561: PUSH
101562: LD_INT 2
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: PUSH
101569: EMPTY
101570: LIST
101571: LIST
101572: LIST
101573: PUSH
101574: EMPTY
101575: LIST
101576: LIST
101577: PPUSH
101578: CALL_OW 69
101582: ST_TO_ADDR
// if not tmp then
101583: LD_VAR 0 2
101587: NOT
101588: IFFALSE 101592
// exit ;
101590: GO 101675
// p := 0 ;
101592: LD_ADDR_VAR 0 3
101596: PUSH
101597: LD_INT 0
101599: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101600: LD_INT 35
101602: PPUSH
101603: CALL_OW 67
// p := p + 1 ;
101607: LD_ADDR_VAR 0 3
101611: PUSH
101612: LD_VAR 0 3
101616: PUSH
101617: LD_INT 1
101619: PLUS
101620: ST_TO_ADDR
// for i in tmp do
101621: LD_ADDR_VAR 0 1
101625: PUSH
101626: LD_VAR 0 2
101630: PUSH
101631: FOR_IN
101632: IFFALSE 101663
// if GetLives ( i ) < 1000 then
101634: LD_VAR 0 1
101638: PPUSH
101639: CALL_OW 256
101643: PUSH
101644: LD_INT 1000
101646: LESS
101647: IFFALSE 101661
// SetLives ( i , 1000 ) ;
101649: LD_VAR 0 1
101653: PPUSH
101654: LD_INT 1000
101656: PPUSH
101657: CALL_OW 234
101661: GO 101631
101663: POP
101664: POP
// until p > 20 ;
101665: LD_VAR 0 3
101669: PUSH
101670: LD_INT 20
101672: GREATER
101673: IFFALSE 101600
// end ;
101675: PPOPN 3
101677: END
// every 0 0$1 trigger StreamModeActive and sTime do
101678: LD_EXP 107
101682: PUSH
101683: LD_EXP 158
101687: AND
101688: IFFALSE 101723
101690: GO 101692
101692: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101693: LD_INT 28
101695: PPUSH
101696: LD_OWVAR 2
101700: PPUSH
101701: LD_INT 2
101703: PPUSH
101704: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101708: LD_INT 30
101710: PPUSH
101711: LD_OWVAR 2
101715: PPUSH
101716: LD_INT 2
101718: PPUSH
101719: CALL_OW 322
// end ;
101723: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101724: LD_EXP 107
101728: PUSH
101729: LD_EXP 159
101733: AND
101734: IFFALSE 101855
101736: GO 101738
101738: DISABLE
101739: LD_INT 0
101741: PPUSH
101742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101743: LD_ADDR_VAR 0 2
101747: PUSH
101748: LD_INT 22
101750: PUSH
101751: LD_OWVAR 2
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 21
101762: PUSH
101763: LD_INT 1
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: LD_INT 3
101772: PUSH
101773: LD_INT 23
101775: PUSH
101776: LD_INT 0
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: PUSH
101783: EMPTY
101784: LIST
101785: LIST
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: LIST
101791: PPUSH
101792: CALL_OW 69
101796: ST_TO_ADDR
// if not tmp then
101797: LD_VAR 0 2
101801: NOT
101802: IFFALSE 101806
// exit ;
101804: GO 101855
// for i in tmp do
101806: LD_ADDR_VAR 0 1
101810: PUSH
101811: LD_VAR 0 2
101815: PUSH
101816: FOR_IN
101817: IFFALSE 101853
// begin if Crawls ( i ) then
101819: LD_VAR 0 1
101823: PPUSH
101824: CALL_OW 318
101828: IFFALSE 101839
// ComWalk ( i ) ;
101830: LD_VAR 0 1
101834: PPUSH
101835: CALL_OW 138
// SetClass ( i , 2 ) ;
101839: LD_VAR 0 1
101843: PPUSH
101844: LD_INT 2
101846: PPUSH
101847: CALL_OW 336
// end ;
101851: GO 101816
101853: POP
101854: POP
// end ;
101855: PPOPN 2
101857: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101858: LD_EXP 107
101862: PUSH
101863: LD_EXP 160
101867: AND
101868: IFFALSE 102156
101870: GO 101872
101872: DISABLE
101873: LD_INT 0
101875: PPUSH
101876: PPUSH
101877: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101878: LD_OWVAR 2
101882: PPUSH
101883: LD_INT 9
101885: PPUSH
101886: LD_INT 1
101888: PPUSH
101889: LD_INT 1
101891: PPUSH
101892: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101896: LD_INT 9
101898: PPUSH
101899: LD_OWVAR 2
101903: PPUSH
101904: CALL_OW 343
// uc_side := 9 ;
101908: LD_ADDR_OWVAR 20
101912: PUSH
101913: LD_INT 9
101915: ST_TO_ADDR
// uc_nation := 2 ;
101916: LD_ADDR_OWVAR 21
101920: PUSH
101921: LD_INT 2
101923: ST_TO_ADDR
// hc_name := Dark Warrior ;
101924: LD_ADDR_OWVAR 26
101928: PUSH
101929: LD_STRING Dark Warrior
101931: ST_TO_ADDR
// hc_gallery :=  ;
101932: LD_ADDR_OWVAR 33
101936: PUSH
101937: LD_STRING 
101939: ST_TO_ADDR
// hc_noskilllimit := true ;
101940: LD_ADDR_OWVAR 76
101944: PUSH
101945: LD_INT 1
101947: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101948: LD_ADDR_OWVAR 31
101952: PUSH
101953: LD_INT 30
101955: PUSH
101956: LD_INT 30
101958: PUSH
101959: LD_INT 30
101961: PUSH
101962: LD_INT 30
101964: PUSH
101965: EMPTY
101966: LIST
101967: LIST
101968: LIST
101969: LIST
101970: ST_TO_ADDR
// un := CreateHuman ;
101971: LD_ADDR_VAR 0 3
101975: PUSH
101976: CALL_OW 44
101980: ST_TO_ADDR
// hc_noskilllimit := false ;
101981: LD_ADDR_OWVAR 76
101985: PUSH
101986: LD_INT 0
101988: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101989: LD_VAR 0 3
101993: PPUSH
101994: LD_INT 1
101996: PPUSH
101997: CALL_OW 51
// ToLua ( playRanger() ) ;
102001: LD_STRING playRanger()
102003: PPUSH
102004: CALL_OW 559
// p := 0 ;
102008: LD_ADDR_VAR 0 2
102012: PUSH
102013: LD_INT 0
102015: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102016: LD_INT 35
102018: PPUSH
102019: CALL_OW 67
// p := p + 1 ;
102023: LD_ADDR_VAR 0 2
102027: PUSH
102028: LD_VAR 0 2
102032: PUSH
102033: LD_INT 1
102035: PLUS
102036: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102037: LD_VAR 0 3
102041: PPUSH
102042: CALL_OW 256
102046: PUSH
102047: LD_INT 1000
102049: LESS
102050: IFFALSE 102064
// SetLives ( un , 1000 ) ;
102052: LD_VAR 0 3
102056: PPUSH
102057: LD_INT 1000
102059: PPUSH
102060: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102064: LD_VAR 0 3
102068: PPUSH
102069: LD_INT 81
102071: PUSH
102072: LD_OWVAR 2
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: PUSH
102081: LD_INT 91
102083: PUSH
102084: LD_VAR 0 3
102088: PUSH
102089: LD_INT 30
102091: PUSH
102092: EMPTY
102093: LIST
102094: LIST
102095: LIST
102096: PUSH
102097: EMPTY
102098: LIST
102099: LIST
102100: PPUSH
102101: CALL_OW 69
102105: PPUSH
102106: LD_VAR 0 3
102110: PPUSH
102111: CALL_OW 74
102115: PPUSH
102116: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102120: LD_VAR 0 2
102124: PUSH
102125: LD_INT 80
102127: GREATER
102128: PUSH
102129: LD_VAR 0 3
102133: PPUSH
102134: CALL_OW 301
102138: OR
102139: IFFALSE 102016
// if un then
102141: LD_VAR 0 3
102145: IFFALSE 102156
// RemoveUnit ( un ) ;
102147: LD_VAR 0 3
102151: PPUSH
102152: CALL_OW 64
// end ;
102156: PPOPN 3
102158: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102159: LD_EXP 161
102163: IFFALSE 102279
102165: GO 102167
102167: DISABLE
102168: LD_INT 0
102170: PPUSH
102171: PPUSH
102172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102173: LD_ADDR_VAR 0 2
102177: PUSH
102178: LD_INT 81
102180: PUSH
102181: LD_OWVAR 2
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: PUSH
102190: LD_INT 21
102192: PUSH
102193: LD_INT 1
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PPUSH
102204: CALL_OW 69
102208: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102209: LD_STRING playComputer()
102211: PPUSH
102212: CALL_OW 559
// if not tmp then
102216: LD_VAR 0 2
102220: NOT
102221: IFFALSE 102225
// exit ;
102223: GO 102279
// for i in tmp do
102225: LD_ADDR_VAR 0 1
102229: PUSH
102230: LD_VAR 0 2
102234: PUSH
102235: FOR_IN
102236: IFFALSE 102277
// for j := 1 to 4 do
102238: LD_ADDR_VAR 0 3
102242: PUSH
102243: DOUBLE
102244: LD_INT 1
102246: DEC
102247: ST_TO_ADDR
102248: LD_INT 4
102250: PUSH
102251: FOR_TO
102252: IFFALSE 102273
// SetSkill ( i , j , 10 ) ;
102254: LD_VAR 0 1
102258: PPUSH
102259: LD_VAR 0 3
102263: PPUSH
102264: LD_INT 10
102266: PPUSH
102267: CALL_OW 237
102271: GO 102251
102273: POP
102274: POP
102275: GO 102235
102277: POP
102278: POP
// end ;
102279: PPOPN 3
102281: END
// every 0 0$1 trigger s30 do var i , tmp ;
102282: LD_EXP 162
102286: IFFALSE 102355
102288: GO 102290
102290: DISABLE
102291: LD_INT 0
102293: PPUSH
102294: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102295: LD_ADDR_VAR 0 2
102299: PUSH
102300: LD_INT 22
102302: PUSH
102303: LD_OWVAR 2
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: PPUSH
102312: CALL_OW 69
102316: ST_TO_ADDR
// if not tmp then
102317: LD_VAR 0 2
102321: NOT
102322: IFFALSE 102326
// exit ;
102324: GO 102355
// for i in tmp do
102326: LD_ADDR_VAR 0 1
102330: PUSH
102331: LD_VAR 0 2
102335: PUSH
102336: FOR_IN
102337: IFFALSE 102353
// SetLives ( i , 300 ) ;
102339: LD_VAR 0 1
102343: PPUSH
102344: LD_INT 300
102346: PPUSH
102347: CALL_OW 234
102351: GO 102336
102353: POP
102354: POP
// end ;
102355: PPOPN 2
102357: END
// every 0 0$1 trigger s60 do var i , tmp ;
102358: LD_EXP 163
102362: IFFALSE 102431
102364: GO 102366
102366: DISABLE
102367: LD_INT 0
102369: PPUSH
102370: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102371: LD_ADDR_VAR 0 2
102375: PUSH
102376: LD_INT 22
102378: PUSH
102379: LD_OWVAR 2
102383: PUSH
102384: EMPTY
102385: LIST
102386: LIST
102387: PPUSH
102388: CALL_OW 69
102392: ST_TO_ADDR
// if not tmp then
102393: LD_VAR 0 2
102397: NOT
102398: IFFALSE 102402
// exit ;
102400: GO 102431
// for i in tmp do
102402: LD_ADDR_VAR 0 1
102406: PUSH
102407: LD_VAR 0 2
102411: PUSH
102412: FOR_IN
102413: IFFALSE 102429
// SetLives ( i , 600 ) ;
102415: LD_VAR 0 1
102419: PPUSH
102420: LD_INT 600
102422: PPUSH
102423: CALL_OW 234
102427: GO 102412
102429: POP
102430: POP
// end ;
102431: PPOPN 2
102433: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102434: LD_INT 0
102436: PPUSH
// case cmd of 301 :
102437: LD_VAR 0 1
102441: PUSH
102442: LD_INT 301
102444: DOUBLE
102445: EQUAL
102446: IFTRUE 102450
102448: GO 102482
102450: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102451: LD_VAR 0 6
102455: PPUSH
102456: LD_VAR 0 7
102460: PPUSH
102461: LD_VAR 0 8
102465: PPUSH
102466: LD_VAR 0 4
102470: PPUSH
102471: LD_VAR 0 5
102475: PPUSH
102476: CALL 103691 0 5
102480: GO 102603
102482: LD_INT 302
102484: DOUBLE
102485: EQUAL
102486: IFTRUE 102490
102488: GO 102527
102490: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102491: LD_VAR 0 6
102495: PPUSH
102496: LD_VAR 0 7
102500: PPUSH
102501: LD_VAR 0 8
102505: PPUSH
102506: LD_VAR 0 9
102510: PPUSH
102511: LD_VAR 0 4
102515: PPUSH
102516: LD_VAR 0 5
102520: PPUSH
102521: CALL 103782 0 6
102525: GO 102603
102527: LD_INT 303
102529: DOUBLE
102530: EQUAL
102531: IFTRUE 102535
102533: GO 102572
102535: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102536: LD_VAR 0 6
102540: PPUSH
102541: LD_VAR 0 7
102545: PPUSH
102546: LD_VAR 0 8
102550: PPUSH
102551: LD_VAR 0 9
102555: PPUSH
102556: LD_VAR 0 4
102560: PPUSH
102561: LD_VAR 0 5
102565: PPUSH
102566: CALL 102608 0 6
102570: GO 102603
102572: LD_INT 304
102574: DOUBLE
102575: EQUAL
102576: IFTRUE 102580
102578: GO 102602
102580: POP
// hHackTeleport ( unit , x , y ) ; end ;
102581: LD_VAR 0 2
102585: PPUSH
102586: LD_VAR 0 4
102590: PPUSH
102591: LD_VAR 0 5
102595: PPUSH
102596: CALL 104375 0 3
102600: GO 102603
102602: POP
// end ;
102603: LD_VAR 0 12
102607: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102608: LD_INT 0
102610: PPUSH
102611: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102612: LD_VAR 0 1
102616: PUSH
102617: LD_INT 1
102619: LESS
102620: PUSH
102621: LD_VAR 0 1
102625: PUSH
102626: LD_INT 3
102628: GREATER
102629: OR
102630: PUSH
102631: LD_VAR 0 5
102635: PPUSH
102636: LD_VAR 0 6
102640: PPUSH
102641: CALL_OW 428
102645: OR
102646: IFFALSE 102650
// exit ;
102648: GO 103378
// uc_side := your_side ;
102650: LD_ADDR_OWVAR 20
102654: PUSH
102655: LD_OWVAR 2
102659: ST_TO_ADDR
// uc_nation := nation ;
102660: LD_ADDR_OWVAR 21
102664: PUSH
102665: LD_VAR 0 1
102669: ST_TO_ADDR
// bc_level = 1 ;
102670: LD_ADDR_OWVAR 43
102674: PUSH
102675: LD_INT 1
102677: ST_TO_ADDR
// case btype of 1 :
102678: LD_VAR 0 2
102682: PUSH
102683: LD_INT 1
102685: DOUBLE
102686: EQUAL
102687: IFTRUE 102691
102689: GO 102702
102691: POP
// bc_type := b_depot ; 2 :
102692: LD_ADDR_OWVAR 42
102696: PUSH
102697: LD_INT 0
102699: ST_TO_ADDR
102700: GO 103322
102702: LD_INT 2
102704: DOUBLE
102705: EQUAL
102706: IFTRUE 102710
102708: GO 102721
102710: POP
// bc_type := b_warehouse ; 3 :
102711: LD_ADDR_OWVAR 42
102715: PUSH
102716: LD_INT 1
102718: ST_TO_ADDR
102719: GO 103322
102721: LD_INT 3
102723: DOUBLE
102724: EQUAL
102725: IFTRUE 102729
102727: GO 102740
102729: POP
// bc_type := b_lab ; 4 .. 9 :
102730: LD_ADDR_OWVAR 42
102734: PUSH
102735: LD_INT 6
102737: ST_TO_ADDR
102738: GO 103322
102740: LD_INT 4
102742: DOUBLE
102743: GREATEREQUAL
102744: IFFALSE 102752
102746: LD_INT 9
102748: DOUBLE
102749: LESSEQUAL
102750: IFTRUE 102754
102752: GO 102814
102754: POP
// begin bc_type := b_lab_half ;
102755: LD_ADDR_OWVAR 42
102759: PUSH
102760: LD_INT 7
102762: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102763: LD_ADDR_OWVAR 44
102767: PUSH
102768: LD_INT 10
102770: PUSH
102771: LD_INT 11
102773: PUSH
102774: LD_INT 12
102776: PUSH
102777: LD_INT 15
102779: PUSH
102780: LD_INT 14
102782: PUSH
102783: LD_INT 13
102785: PUSH
102786: EMPTY
102787: LIST
102788: LIST
102789: LIST
102790: LIST
102791: LIST
102792: LIST
102793: PUSH
102794: LD_VAR 0 2
102798: PUSH
102799: LD_INT 3
102801: MINUS
102802: ARRAY
102803: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
102804: LD_ADDR_OWVAR 45
102808: PUSH
102809: LD_INT 9
102811: ST_TO_ADDR
// end ; 10 .. 13 :
102812: GO 103322
102814: LD_INT 10
102816: DOUBLE
102817: GREATEREQUAL
102818: IFFALSE 102826
102820: LD_INT 13
102822: DOUBLE
102823: LESSEQUAL
102824: IFTRUE 102828
102826: GO 102905
102828: POP
// begin bc_type := b_lab_full ;
102829: LD_ADDR_OWVAR 42
102833: PUSH
102834: LD_INT 8
102836: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102837: LD_ADDR_OWVAR 44
102841: PUSH
102842: LD_INT 10
102844: PUSH
102845: LD_INT 12
102847: PUSH
102848: LD_INT 14
102850: PUSH
102851: LD_INT 13
102853: PUSH
102854: EMPTY
102855: LIST
102856: LIST
102857: LIST
102858: LIST
102859: PUSH
102860: LD_VAR 0 2
102864: PUSH
102865: LD_INT 9
102867: MINUS
102868: ARRAY
102869: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102870: LD_ADDR_OWVAR 45
102874: PUSH
102875: LD_INT 11
102877: PUSH
102878: LD_INT 15
102880: PUSH
102881: LD_INT 12
102883: PUSH
102884: LD_INT 15
102886: PUSH
102887: EMPTY
102888: LIST
102889: LIST
102890: LIST
102891: LIST
102892: PUSH
102893: LD_VAR 0 2
102897: PUSH
102898: LD_INT 9
102900: MINUS
102901: ARRAY
102902: ST_TO_ADDR
// end ; 14 :
102903: GO 103322
102905: LD_INT 14
102907: DOUBLE
102908: EQUAL
102909: IFTRUE 102913
102911: GO 102924
102913: POP
// bc_type := b_workshop ; 15 :
102914: LD_ADDR_OWVAR 42
102918: PUSH
102919: LD_INT 2
102921: ST_TO_ADDR
102922: GO 103322
102924: LD_INT 15
102926: DOUBLE
102927: EQUAL
102928: IFTRUE 102932
102930: GO 102943
102932: POP
// bc_type := b_factory ; 16 :
102933: LD_ADDR_OWVAR 42
102937: PUSH
102938: LD_INT 3
102940: ST_TO_ADDR
102941: GO 103322
102943: LD_INT 16
102945: DOUBLE
102946: EQUAL
102947: IFTRUE 102951
102949: GO 102962
102951: POP
// bc_type := b_ext_gun ; 17 :
102952: LD_ADDR_OWVAR 42
102956: PUSH
102957: LD_INT 17
102959: ST_TO_ADDR
102960: GO 103322
102962: LD_INT 17
102964: DOUBLE
102965: EQUAL
102966: IFTRUE 102970
102968: GO 102998
102970: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102971: LD_ADDR_OWVAR 42
102975: PUSH
102976: LD_INT 19
102978: PUSH
102979: LD_INT 23
102981: PUSH
102982: LD_INT 19
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: LIST
102989: PUSH
102990: LD_VAR 0 1
102994: ARRAY
102995: ST_TO_ADDR
102996: GO 103322
102998: LD_INT 18
103000: DOUBLE
103001: EQUAL
103002: IFTRUE 103006
103004: GO 103017
103006: POP
// bc_type := b_ext_radar ; 19 :
103007: LD_ADDR_OWVAR 42
103011: PUSH
103012: LD_INT 20
103014: ST_TO_ADDR
103015: GO 103322
103017: LD_INT 19
103019: DOUBLE
103020: EQUAL
103021: IFTRUE 103025
103023: GO 103036
103025: POP
// bc_type := b_ext_radio ; 20 :
103026: LD_ADDR_OWVAR 42
103030: PUSH
103031: LD_INT 22
103033: ST_TO_ADDR
103034: GO 103322
103036: LD_INT 20
103038: DOUBLE
103039: EQUAL
103040: IFTRUE 103044
103042: GO 103055
103044: POP
// bc_type := b_ext_siberium ; 21 :
103045: LD_ADDR_OWVAR 42
103049: PUSH
103050: LD_INT 21
103052: ST_TO_ADDR
103053: GO 103322
103055: LD_INT 21
103057: DOUBLE
103058: EQUAL
103059: IFTRUE 103063
103061: GO 103074
103063: POP
// bc_type := b_ext_computer ; 22 :
103064: LD_ADDR_OWVAR 42
103068: PUSH
103069: LD_INT 24
103071: ST_TO_ADDR
103072: GO 103322
103074: LD_INT 22
103076: DOUBLE
103077: EQUAL
103078: IFTRUE 103082
103080: GO 103093
103082: POP
// bc_type := b_ext_track ; 23 :
103083: LD_ADDR_OWVAR 42
103087: PUSH
103088: LD_INT 16
103090: ST_TO_ADDR
103091: GO 103322
103093: LD_INT 23
103095: DOUBLE
103096: EQUAL
103097: IFTRUE 103101
103099: GO 103112
103101: POP
// bc_type := b_ext_laser ; 24 :
103102: LD_ADDR_OWVAR 42
103106: PUSH
103107: LD_INT 25
103109: ST_TO_ADDR
103110: GO 103322
103112: LD_INT 24
103114: DOUBLE
103115: EQUAL
103116: IFTRUE 103120
103118: GO 103131
103120: POP
// bc_type := b_control_tower ; 25 :
103121: LD_ADDR_OWVAR 42
103125: PUSH
103126: LD_INT 36
103128: ST_TO_ADDR
103129: GO 103322
103131: LD_INT 25
103133: DOUBLE
103134: EQUAL
103135: IFTRUE 103139
103137: GO 103150
103139: POP
// bc_type := b_breastwork ; 26 :
103140: LD_ADDR_OWVAR 42
103144: PUSH
103145: LD_INT 31
103147: ST_TO_ADDR
103148: GO 103322
103150: LD_INT 26
103152: DOUBLE
103153: EQUAL
103154: IFTRUE 103158
103156: GO 103169
103158: POP
// bc_type := b_bunker ; 27 :
103159: LD_ADDR_OWVAR 42
103163: PUSH
103164: LD_INT 32
103166: ST_TO_ADDR
103167: GO 103322
103169: LD_INT 27
103171: DOUBLE
103172: EQUAL
103173: IFTRUE 103177
103175: GO 103188
103177: POP
// bc_type := b_turret ; 28 :
103178: LD_ADDR_OWVAR 42
103182: PUSH
103183: LD_INT 33
103185: ST_TO_ADDR
103186: GO 103322
103188: LD_INT 28
103190: DOUBLE
103191: EQUAL
103192: IFTRUE 103196
103194: GO 103207
103196: POP
// bc_type := b_armoury ; 29 :
103197: LD_ADDR_OWVAR 42
103201: PUSH
103202: LD_INT 4
103204: ST_TO_ADDR
103205: GO 103322
103207: LD_INT 29
103209: DOUBLE
103210: EQUAL
103211: IFTRUE 103215
103213: GO 103226
103215: POP
// bc_type := b_barracks ; 30 :
103216: LD_ADDR_OWVAR 42
103220: PUSH
103221: LD_INT 5
103223: ST_TO_ADDR
103224: GO 103322
103226: LD_INT 30
103228: DOUBLE
103229: EQUAL
103230: IFTRUE 103234
103232: GO 103245
103234: POP
// bc_type := b_solar_power ; 31 :
103235: LD_ADDR_OWVAR 42
103239: PUSH
103240: LD_INT 27
103242: ST_TO_ADDR
103243: GO 103322
103245: LD_INT 31
103247: DOUBLE
103248: EQUAL
103249: IFTRUE 103253
103251: GO 103264
103253: POP
// bc_type := b_oil_power ; 32 :
103254: LD_ADDR_OWVAR 42
103258: PUSH
103259: LD_INT 26
103261: ST_TO_ADDR
103262: GO 103322
103264: LD_INT 32
103266: DOUBLE
103267: EQUAL
103268: IFTRUE 103272
103270: GO 103283
103272: POP
// bc_type := b_siberite_power ; 33 :
103273: LD_ADDR_OWVAR 42
103277: PUSH
103278: LD_INT 28
103280: ST_TO_ADDR
103281: GO 103322
103283: LD_INT 33
103285: DOUBLE
103286: EQUAL
103287: IFTRUE 103291
103289: GO 103302
103291: POP
// bc_type := b_oil_mine ; 34 :
103292: LD_ADDR_OWVAR 42
103296: PUSH
103297: LD_INT 29
103299: ST_TO_ADDR
103300: GO 103322
103302: LD_INT 34
103304: DOUBLE
103305: EQUAL
103306: IFTRUE 103310
103308: GO 103321
103310: POP
// bc_type := b_siberite_mine ; end ;
103311: LD_ADDR_OWVAR 42
103315: PUSH
103316: LD_INT 30
103318: ST_TO_ADDR
103319: GO 103322
103321: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103322: LD_ADDR_VAR 0 8
103326: PUSH
103327: LD_VAR 0 5
103331: PPUSH
103332: LD_VAR 0 6
103336: PPUSH
103337: LD_VAR 0 3
103341: PPUSH
103342: CALL_OW 47
103346: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103347: LD_OWVAR 42
103351: PUSH
103352: LD_INT 32
103354: PUSH
103355: LD_INT 33
103357: PUSH
103358: EMPTY
103359: LIST
103360: LIST
103361: IN
103362: IFFALSE 103378
// PlaceWeaponTurret ( b , weapon ) ;
103364: LD_VAR 0 8
103368: PPUSH
103369: LD_VAR 0 4
103373: PPUSH
103374: CALL_OW 431
// end ;
103378: LD_VAR 0 7
103382: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103383: LD_INT 0
103385: PPUSH
103386: PPUSH
103387: PPUSH
103388: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103389: LD_ADDR_VAR 0 4
103393: PUSH
103394: LD_INT 22
103396: PUSH
103397: LD_OWVAR 2
103401: PUSH
103402: EMPTY
103403: LIST
103404: LIST
103405: PUSH
103406: LD_INT 2
103408: PUSH
103409: LD_INT 30
103411: PUSH
103412: LD_INT 0
103414: PUSH
103415: EMPTY
103416: LIST
103417: LIST
103418: PUSH
103419: LD_INT 30
103421: PUSH
103422: LD_INT 1
103424: PUSH
103425: EMPTY
103426: LIST
103427: LIST
103428: PUSH
103429: EMPTY
103430: LIST
103431: LIST
103432: LIST
103433: PUSH
103434: EMPTY
103435: LIST
103436: LIST
103437: PPUSH
103438: CALL_OW 69
103442: ST_TO_ADDR
// if not tmp then
103443: LD_VAR 0 4
103447: NOT
103448: IFFALSE 103452
// exit ;
103450: GO 103511
// for i in tmp do
103452: LD_ADDR_VAR 0 2
103456: PUSH
103457: LD_VAR 0 4
103461: PUSH
103462: FOR_IN
103463: IFFALSE 103509
// for j = 1 to 3 do
103465: LD_ADDR_VAR 0 3
103469: PUSH
103470: DOUBLE
103471: LD_INT 1
103473: DEC
103474: ST_TO_ADDR
103475: LD_INT 3
103477: PUSH
103478: FOR_TO
103479: IFFALSE 103505
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103481: LD_VAR 0 2
103485: PPUSH
103486: CALL_OW 274
103490: PPUSH
103491: LD_VAR 0 3
103495: PPUSH
103496: LD_INT 99999
103498: PPUSH
103499: CALL_OW 277
103503: GO 103478
103505: POP
103506: POP
103507: GO 103462
103509: POP
103510: POP
// end ;
103511: LD_VAR 0 1
103515: RET
// export function hHackSetLevel10 ; var i , j ; begin
103516: LD_INT 0
103518: PPUSH
103519: PPUSH
103520: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103521: LD_ADDR_VAR 0 2
103525: PUSH
103526: LD_INT 21
103528: PUSH
103529: LD_INT 1
103531: PUSH
103532: EMPTY
103533: LIST
103534: LIST
103535: PPUSH
103536: CALL_OW 69
103540: PUSH
103541: FOR_IN
103542: IFFALSE 103594
// if IsSelected ( i ) then
103544: LD_VAR 0 2
103548: PPUSH
103549: CALL_OW 306
103553: IFFALSE 103592
// begin for j := 1 to 4 do
103555: LD_ADDR_VAR 0 3
103559: PUSH
103560: DOUBLE
103561: LD_INT 1
103563: DEC
103564: ST_TO_ADDR
103565: LD_INT 4
103567: PUSH
103568: FOR_TO
103569: IFFALSE 103590
// SetSkill ( i , j , 10 ) ;
103571: LD_VAR 0 2
103575: PPUSH
103576: LD_VAR 0 3
103580: PPUSH
103581: LD_INT 10
103583: PPUSH
103584: CALL_OW 237
103588: GO 103568
103590: POP
103591: POP
// end ;
103592: GO 103541
103594: POP
103595: POP
// end ;
103596: LD_VAR 0 1
103600: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103601: LD_INT 0
103603: PPUSH
103604: PPUSH
103605: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103606: LD_ADDR_VAR 0 2
103610: PUSH
103611: LD_INT 22
103613: PUSH
103614: LD_OWVAR 2
103618: PUSH
103619: EMPTY
103620: LIST
103621: LIST
103622: PUSH
103623: LD_INT 21
103625: PUSH
103626: LD_INT 1
103628: PUSH
103629: EMPTY
103630: LIST
103631: LIST
103632: PUSH
103633: EMPTY
103634: LIST
103635: LIST
103636: PPUSH
103637: CALL_OW 69
103641: PUSH
103642: FOR_IN
103643: IFFALSE 103684
// begin for j := 1 to 4 do
103645: LD_ADDR_VAR 0 3
103649: PUSH
103650: DOUBLE
103651: LD_INT 1
103653: DEC
103654: ST_TO_ADDR
103655: LD_INT 4
103657: PUSH
103658: FOR_TO
103659: IFFALSE 103680
// SetSkill ( i , j , 10 ) ;
103661: LD_VAR 0 2
103665: PPUSH
103666: LD_VAR 0 3
103670: PPUSH
103671: LD_INT 10
103673: PPUSH
103674: CALL_OW 237
103678: GO 103658
103680: POP
103681: POP
// end ;
103682: GO 103642
103684: POP
103685: POP
// end ;
103686: LD_VAR 0 1
103690: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103691: LD_INT 0
103693: PPUSH
// uc_side := your_side ;
103694: LD_ADDR_OWVAR 20
103698: PUSH
103699: LD_OWVAR 2
103703: ST_TO_ADDR
// uc_nation := nation ;
103704: LD_ADDR_OWVAR 21
103708: PUSH
103709: LD_VAR 0 1
103713: ST_TO_ADDR
// InitHc ;
103714: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103718: LD_INT 0
103720: PPUSH
103721: LD_VAR 0 2
103725: PPUSH
103726: LD_VAR 0 3
103730: PPUSH
103731: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103735: LD_VAR 0 4
103739: PPUSH
103740: LD_VAR 0 5
103744: PPUSH
103745: CALL_OW 428
103749: PUSH
103750: LD_INT 0
103752: EQUAL
103753: IFFALSE 103777
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103755: CALL_OW 44
103759: PPUSH
103760: LD_VAR 0 4
103764: PPUSH
103765: LD_VAR 0 5
103769: PPUSH
103770: LD_INT 1
103772: PPUSH
103773: CALL_OW 48
// end ;
103777: LD_VAR 0 6
103781: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103782: LD_INT 0
103784: PPUSH
103785: PPUSH
// uc_side := your_side ;
103786: LD_ADDR_OWVAR 20
103790: PUSH
103791: LD_OWVAR 2
103795: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103796: LD_VAR 0 1
103800: PUSH
103801: LD_INT 1
103803: PUSH
103804: LD_INT 2
103806: PUSH
103807: LD_INT 3
103809: PUSH
103810: LD_INT 4
103812: PUSH
103813: LD_INT 5
103815: PUSH
103816: EMPTY
103817: LIST
103818: LIST
103819: LIST
103820: LIST
103821: LIST
103822: IN
103823: IFFALSE 103835
// uc_nation := nation_american else
103825: LD_ADDR_OWVAR 21
103829: PUSH
103830: LD_INT 1
103832: ST_TO_ADDR
103833: GO 103878
// if chassis in [ 11 , 12 , 13 , 14 ] then
103835: LD_VAR 0 1
103839: PUSH
103840: LD_INT 11
103842: PUSH
103843: LD_INT 12
103845: PUSH
103846: LD_INT 13
103848: PUSH
103849: LD_INT 14
103851: PUSH
103852: EMPTY
103853: LIST
103854: LIST
103855: LIST
103856: LIST
103857: IN
103858: IFFALSE 103870
// uc_nation := nation_arabian else
103860: LD_ADDR_OWVAR 21
103864: PUSH
103865: LD_INT 2
103867: ST_TO_ADDR
103868: GO 103878
// uc_nation := nation_russian ;
103870: LD_ADDR_OWVAR 21
103874: PUSH
103875: LD_INT 3
103877: ST_TO_ADDR
// vc_chassis := chassis ;
103878: LD_ADDR_OWVAR 37
103882: PUSH
103883: LD_VAR 0 1
103887: ST_TO_ADDR
// vc_engine := engine ;
103888: LD_ADDR_OWVAR 39
103892: PUSH
103893: LD_VAR 0 2
103897: ST_TO_ADDR
// vc_control := control ;
103898: LD_ADDR_OWVAR 38
103902: PUSH
103903: LD_VAR 0 3
103907: ST_TO_ADDR
// vc_weapon := weapon ;
103908: LD_ADDR_OWVAR 40
103912: PUSH
103913: LD_VAR 0 4
103917: ST_TO_ADDR
// un := CreateVehicle ;
103918: LD_ADDR_VAR 0 8
103922: PUSH
103923: CALL_OW 45
103927: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103928: LD_VAR 0 8
103932: PPUSH
103933: LD_INT 0
103935: PPUSH
103936: LD_INT 5
103938: PPUSH
103939: CALL_OW 12
103943: PPUSH
103944: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103948: LD_VAR 0 8
103952: PPUSH
103953: LD_VAR 0 5
103957: PPUSH
103958: LD_VAR 0 6
103962: PPUSH
103963: LD_INT 1
103965: PPUSH
103966: CALL_OW 48
// end ;
103970: LD_VAR 0 7
103974: RET
// export hInvincible ; every 1 do
103975: GO 103977
103977: DISABLE
// hInvincible := [ ] ;
103978: LD_ADDR_EXP 164
103982: PUSH
103983: EMPTY
103984: ST_TO_ADDR
103985: END
// every 10 do var i ;
103986: GO 103988
103988: DISABLE
103989: LD_INT 0
103991: PPUSH
// begin enable ;
103992: ENABLE
// if not hInvincible then
103993: LD_EXP 164
103997: NOT
103998: IFFALSE 104002
// exit ;
104000: GO 104046
// for i in hInvincible do
104002: LD_ADDR_VAR 0 1
104006: PUSH
104007: LD_EXP 164
104011: PUSH
104012: FOR_IN
104013: IFFALSE 104044
// if GetLives ( i ) < 1000 then
104015: LD_VAR 0 1
104019: PPUSH
104020: CALL_OW 256
104024: PUSH
104025: LD_INT 1000
104027: LESS
104028: IFFALSE 104042
// SetLives ( i , 1000 ) ;
104030: LD_VAR 0 1
104034: PPUSH
104035: LD_INT 1000
104037: PPUSH
104038: CALL_OW 234
104042: GO 104012
104044: POP
104045: POP
// end ;
104046: PPOPN 1
104048: END
// export function hHackInvincible ; var i ; begin
104049: LD_INT 0
104051: PPUSH
104052: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104053: LD_ADDR_VAR 0 2
104057: PUSH
104058: LD_INT 2
104060: PUSH
104061: LD_INT 21
104063: PUSH
104064: LD_INT 1
104066: PUSH
104067: EMPTY
104068: LIST
104069: LIST
104070: PUSH
104071: LD_INT 21
104073: PUSH
104074: LD_INT 2
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PUSH
104081: EMPTY
104082: LIST
104083: LIST
104084: LIST
104085: PPUSH
104086: CALL_OW 69
104090: PUSH
104091: FOR_IN
104092: IFFALSE 104153
// if IsSelected ( i ) then
104094: LD_VAR 0 2
104098: PPUSH
104099: CALL_OW 306
104103: IFFALSE 104151
// begin if i in hInvincible then
104105: LD_VAR 0 2
104109: PUSH
104110: LD_EXP 164
104114: IN
104115: IFFALSE 104135
// hInvincible := hInvincible diff i else
104117: LD_ADDR_EXP 164
104121: PUSH
104122: LD_EXP 164
104126: PUSH
104127: LD_VAR 0 2
104131: DIFF
104132: ST_TO_ADDR
104133: GO 104151
// hInvincible := hInvincible union i ;
104135: LD_ADDR_EXP 164
104139: PUSH
104140: LD_EXP 164
104144: PUSH
104145: LD_VAR 0 2
104149: UNION
104150: ST_TO_ADDR
// end ;
104151: GO 104091
104153: POP
104154: POP
// end ;
104155: LD_VAR 0 1
104159: RET
// export function hHackInvisible ; var i , j ; begin
104160: LD_INT 0
104162: PPUSH
104163: PPUSH
104164: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104165: LD_ADDR_VAR 0 2
104169: PUSH
104170: LD_INT 21
104172: PUSH
104173: LD_INT 1
104175: PUSH
104176: EMPTY
104177: LIST
104178: LIST
104179: PPUSH
104180: CALL_OW 69
104184: PUSH
104185: FOR_IN
104186: IFFALSE 104210
// if IsSelected ( i ) then
104188: LD_VAR 0 2
104192: PPUSH
104193: CALL_OW 306
104197: IFFALSE 104208
// ComForceInvisible ( i ) ;
104199: LD_VAR 0 2
104203: PPUSH
104204: CALL_OW 496
104208: GO 104185
104210: POP
104211: POP
// end ;
104212: LD_VAR 0 1
104216: RET
// export function hHackChangeYourSide ; begin
104217: LD_INT 0
104219: PPUSH
// if your_side = 8 then
104220: LD_OWVAR 2
104224: PUSH
104225: LD_INT 8
104227: EQUAL
104228: IFFALSE 104240
// your_side := 0 else
104230: LD_ADDR_OWVAR 2
104234: PUSH
104235: LD_INT 0
104237: ST_TO_ADDR
104238: GO 104254
// your_side := your_side + 1 ;
104240: LD_ADDR_OWVAR 2
104244: PUSH
104245: LD_OWVAR 2
104249: PUSH
104250: LD_INT 1
104252: PLUS
104253: ST_TO_ADDR
// end ;
104254: LD_VAR 0 1
104258: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104259: LD_INT 0
104261: PPUSH
104262: PPUSH
104263: PPUSH
// for i in all_units do
104264: LD_ADDR_VAR 0 2
104268: PUSH
104269: LD_OWVAR 3
104273: PUSH
104274: FOR_IN
104275: IFFALSE 104353
// if IsSelected ( i ) then
104277: LD_VAR 0 2
104281: PPUSH
104282: CALL_OW 306
104286: IFFALSE 104351
// begin j := GetSide ( i ) ;
104288: LD_ADDR_VAR 0 3
104292: PUSH
104293: LD_VAR 0 2
104297: PPUSH
104298: CALL_OW 255
104302: ST_TO_ADDR
// if j = 8 then
104303: LD_VAR 0 3
104307: PUSH
104308: LD_INT 8
104310: EQUAL
104311: IFFALSE 104323
// j := 0 else
104313: LD_ADDR_VAR 0 3
104317: PUSH
104318: LD_INT 0
104320: ST_TO_ADDR
104321: GO 104337
// j := j + 1 ;
104323: LD_ADDR_VAR 0 3
104327: PUSH
104328: LD_VAR 0 3
104332: PUSH
104333: LD_INT 1
104335: PLUS
104336: ST_TO_ADDR
// SetSide ( i , j ) ;
104337: LD_VAR 0 2
104341: PPUSH
104342: LD_VAR 0 3
104346: PPUSH
104347: CALL_OW 235
// end ;
104351: GO 104274
104353: POP
104354: POP
// end ;
104355: LD_VAR 0 1
104359: RET
// export function hHackFog ; begin
104360: LD_INT 0
104362: PPUSH
// FogOff ( true ) ;
104363: LD_INT 1
104365: PPUSH
104366: CALL_OW 344
// end ;
104370: LD_VAR 0 1
104374: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104375: LD_INT 0
104377: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104378: LD_VAR 0 1
104382: PPUSH
104383: LD_VAR 0 2
104387: PPUSH
104388: LD_VAR 0 3
104392: PPUSH
104393: LD_INT 1
104395: PPUSH
104396: LD_INT 1
104398: PPUSH
104399: CALL_OW 483
// CenterOnXY ( x , y ) ;
104403: LD_VAR 0 2
104407: PPUSH
104408: LD_VAR 0 3
104412: PPUSH
104413: CALL_OW 84
// end ;
104417: LD_VAR 0 4
104421: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104422: LD_INT 0
104424: PPUSH
104425: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104426: LD_VAR 0 1
104430: NOT
104431: PUSH
104432: LD_VAR 0 2
104436: PPUSH
104437: LD_VAR 0 3
104441: PPUSH
104442: CALL_OW 488
104446: NOT
104447: OR
104448: PUSH
104449: LD_VAR 0 1
104453: PPUSH
104454: CALL_OW 266
104458: PUSH
104459: LD_INT 3
104461: NONEQUAL
104462: PUSH
104463: LD_VAR 0 1
104467: PPUSH
104468: CALL_OW 247
104472: PUSH
104473: LD_INT 1
104475: EQUAL
104476: NOT
104477: AND
104478: OR
104479: IFFALSE 104483
// exit ;
104481: GO 104632
// if GetType ( factory ) = unit_human then
104483: LD_VAR 0 1
104487: PPUSH
104488: CALL_OW 247
104492: PUSH
104493: LD_INT 1
104495: EQUAL
104496: IFFALSE 104513
// factory := IsInUnit ( factory ) ;
104498: LD_ADDR_VAR 0 1
104502: PUSH
104503: LD_VAR 0 1
104507: PPUSH
104508: CALL_OW 310
104512: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104513: LD_VAR 0 1
104517: PPUSH
104518: CALL_OW 266
104522: PUSH
104523: LD_INT 3
104525: NONEQUAL
104526: IFFALSE 104530
// exit ;
104528: GO 104632
// if HexInfo ( x , y ) = factory then
104530: LD_VAR 0 2
104534: PPUSH
104535: LD_VAR 0 3
104539: PPUSH
104540: CALL_OW 428
104544: PUSH
104545: LD_VAR 0 1
104549: EQUAL
104550: IFFALSE 104577
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104552: LD_ADDR_EXP 165
104556: PUSH
104557: LD_EXP 165
104561: PPUSH
104562: LD_VAR 0 1
104566: PPUSH
104567: LD_INT 0
104569: PPUSH
104570: CALL_OW 1
104574: ST_TO_ADDR
104575: GO 104628
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104577: LD_ADDR_EXP 165
104581: PUSH
104582: LD_EXP 165
104586: PPUSH
104587: LD_VAR 0 1
104591: PPUSH
104592: LD_VAR 0 1
104596: PPUSH
104597: CALL_OW 255
104601: PUSH
104602: LD_VAR 0 1
104606: PUSH
104607: LD_VAR 0 2
104611: PUSH
104612: LD_VAR 0 3
104616: PUSH
104617: EMPTY
104618: LIST
104619: LIST
104620: LIST
104621: LIST
104622: PPUSH
104623: CALL_OW 1
104627: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104628: CALL 104637 0 0
// end ;
104632: LD_VAR 0 4
104636: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104637: LD_INT 0
104639: PPUSH
104640: PPUSH
104641: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104642: LD_STRING resetFactoryWaypoint();
104644: PPUSH
104645: CALL_OW 559
// if factoryWaypoints then
104649: LD_EXP 165
104653: IFFALSE 104779
// begin list := PrepareArray ( factoryWaypoints ) ;
104655: LD_ADDR_VAR 0 3
104659: PUSH
104660: LD_EXP 165
104664: PPUSH
104665: CALL 57884 0 1
104669: ST_TO_ADDR
// for i := 1 to list do
104670: LD_ADDR_VAR 0 2
104674: PUSH
104675: DOUBLE
104676: LD_INT 1
104678: DEC
104679: ST_TO_ADDR
104680: LD_VAR 0 3
104684: PUSH
104685: FOR_TO
104686: IFFALSE 104777
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104688: LD_STRING setFactoryWaypointXY(
104690: PUSH
104691: LD_VAR 0 3
104695: PUSH
104696: LD_VAR 0 2
104700: ARRAY
104701: PUSH
104702: LD_INT 1
104704: ARRAY
104705: STR
104706: PUSH
104707: LD_STRING ,
104709: STR
104710: PUSH
104711: LD_VAR 0 3
104715: PUSH
104716: LD_VAR 0 2
104720: ARRAY
104721: PUSH
104722: LD_INT 2
104724: ARRAY
104725: STR
104726: PUSH
104727: LD_STRING ,
104729: STR
104730: PUSH
104731: LD_VAR 0 3
104735: PUSH
104736: LD_VAR 0 2
104740: ARRAY
104741: PUSH
104742: LD_INT 3
104744: ARRAY
104745: STR
104746: PUSH
104747: LD_STRING ,
104749: STR
104750: PUSH
104751: LD_VAR 0 3
104755: PUSH
104756: LD_VAR 0 2
104760: ARRAY
104761: PUSH
104762: LD_INT 4
104764: ARRAY
104765: STR
104766: PUSH
104767: LD_STRING )
104769: STR
104770: PPUSH
104771: CALL_OW 559
104775: GO 104685
104777: POP
104778: POP
// end ; end ;
104779: LD_VAR 0 1
104783: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104784: LD_INT 0
104786: PPUSH
// if HexInfo ( x , y ) = warehouse then
104787: LD_VAR 0 2
104791: PPUSH
104792: LD_VAR 0 3
104796: PPUSH
104797: CALL_OW 428
104801: PUSH
104802: LD_VAR 0 1
104806: EQUAL
104807: IFFALSE 104834
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104809: LD_ADDR_EXP 166
104813: PUSH
104814: LD_EXP 166
104818: PPUSH
104819: LD_VAR 0 1
104823: PPUSH
104824: LD_INT 0
104826: PPUSH
104827: CALL_OW 1
104831: ST_TO_ADDR
104832: GO 104885
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104834: LD_ADDR_EXP 166
104838: PUSH
104839: LD_EXP 166
104843: PPUSH
104844: LD_VAR 0 1
104848: PPUSH
104849: LD_VAR 0 1
104853: PPUSH
104854: CALL_OW 255
104858: PUSH
104859: LD_VAR 0 1
104863: PUSH
104864: LD_VAR 0 2
104868: PUSH
104869: LD_VAR 0 3
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: LIST
104878: LIST
104879: PPUSH
104880: CALL_OW 1
104884: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104885: CALL 104894 0 0
// end ;
104889: LD_VAR 0 4
104893: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104894: LD_INT 0
104896: PPUSH
104897: PPUSH
104898: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104899: LD_STRING resetWarehouseGatheringPoints();
104901: PPUSH
104902: CALL_OW 559
// if warehouseGatheringPoints then
104906: LD_EXP 166
104910: IFFALSE 105036
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104912: LD_ADDR_VAR 0 3
104916: PUSH
104917: LD_EXP 166
104921: PPUSH
104922: CALL 57884 0 1
104926: ST_TO_ADDR
// for i := 1 to list do
104927: LD_ADDR_VAR 0 2
104931: PUSH
104932: DOUBLE
104933: LD_INT 1
104935: DEC
104936: ST_TO_ADDR
104937: LD_VAR 0 3
104941: PUSH
104942: FOR_TO
104943: IFFALSE 105034
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104945: LD_STRING setWarehouseGatheringPointXY(
104947: PUSH
104948: LD_VAR 0 3
104952: PUSH
104953: LD_VAR 0 2
104957: ARRAY
104958: PUSH
104959: LD_INT 1
104961: ARRAY
104962: STR
104963: PUSH
104964: LD_STRING ,
104966: STR
104967: PUSH
104968: LD_VAR 0 3
104972: PUSH
104973: LD_VAR 0 2
104977: ARRAY
104978: PUSH
104979: LD_INT 2
104981: ARRAY
104982: STR
104983: PUSH
104984: LD_STRING ,
104986: STR
104987: PUSH
104988: LD_VAR 0 3
104992: PUSH
104993: LD_VAR 0 2
104997: ARRAY
104998: PUSH
104999: LD_INT 3
105001: ARRAY
105002: STR
105003: PUSH
105004: LD_STRING ,
105006: STR
105007: PUSH
105008: LD_VAR 0 3
105012: PUSH
105013: LD_VAR 0 2
105017: ARRAY
105018: PUSH
105019: LD_INT 4
105021: ARRAY
105022: STR
105023: PUSH
105024: LD_STRING )
105026: STR
105027: PPUSH
105028: CALL_OW 559
105032: GO 104942
105034: POP
105035: POP
// end ; end ;
105036: LD_VAR 0 1
105040: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105041: LD_EXP 166
105045: IFFALSE 105730
105047: GO 105049
105049: DISABLE
105050: LD_INT 0
105052: PPUSH
105053: PPUSH
105054: PPUSH
105055: PPUSH
105056: PPUSH
105057: PPUSH
105058: PPUSH
105059: PPUSH
105060: PPUSH
// begin enable ;
105061: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105062: LD_ADDR_VAR 0 3
105066: PUSH
105067: LD_EXP 166
105071: PPUSH
105072: CALL 57884 0 1
105076: ST_TO_ADDR
// if not list then
105077: LD_VAR 0 3
105081: NOT
105082: IFFALSE 105086
// exit ;
105084: GO 105730
// for i := 1 to list do
105086: LD_ADDR_VAR 0 1
105090: PUSH
105091: DOUBLE
105092: LD_INT 1
105094: DEC
105095: ST_TO_ADDR
105096: LD_VAR 0 3
105100: PUSH
105101: FOR_TO
105102: IFFALSE 105728
// begin depot := list [ i ] [ 2 ] ;
105104: LD_ADDR_VAR 0 8
105108: PUSH
105109: LD_VAR 0 3
105113: PUSH
105114: LD_VAR 0 1
105118: ARRAY
105119: PUSH
105120: LD_INT 2
105122: ARRAY
105123: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105124: LD_ADDR_VAR 0 5
105128: PUSH
105129: LD_VAR 0 3
105133: PUSH
105134: LD_VAR 0 1
105138: ARRAY
105139: PUSH
105140: LD_INT 1
105142: ARRAY
105143: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105144: LD_VAR 0 8
105148: PPUSH
105149: CALL_OW 301
105153: PUSH
105154: LD_VAR 0 5
105158: PUSH
105159: LD_VAR 0 8
105163: PPUSH
105164: CALL_OW 255
105168: NONEQUAL
105169: OR
105170: IFFALSE 105199
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105172: LD_ADDR_EXP 166
105176: PUSH
105177: LD_EXP 166
105181: PPUSH
105182: LD_VAR 0 8
105186: PPUSH
105187: LD_INT 0
105189: PPUSH
105190: CALL_OW 1
105194: ST_TO_ADDR
// exit ;
105195: POP
105196: POP
105197: GO 105730
// end ; x := list [ i ] [ 3 ] ;
105199: LD_ADDR_VAR 0 6
105203: PUSH
105204: LD_VAR 0 3
105208: PUSH
105209: LD_VAR 0 1
105213: ARRAY
105214: PUSH
105215: LD_INT 3
105217: ARRAY
105218: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105219: LD_ADDR_VAR 0 7
105223: PUSH
105224: LD_VAR 0 3
105228: PUSH
105229: LD_VAR 0 1
105233: ARRAY
105234: PUSH
105235: LD_INT 4
105237: ARRAY
105238: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105239: LD_ADDR_VAR 0 9
105243: PUSH
105244: LD_VAR 0 6
105248: PPUSH
105249: LD_VAR 0 7
105253: PPUSH
105254: LD_INT 16
105256: PPUSH
105257: CALL 56472 0 3
105261: ST_TO_ADDR
// if not cratesNearbyPoint then
105262: LD_VAR 0 9
105266: NOT
105267: IFFALSE 105273
// exit ;
105269: POP
105270: POP
105271: GO 105730
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105273: LD_ADDR_VAR 0 4
105277: PUSH
105278: LD_INT 22
105280: PUSH
105281: LD_VAR 0 5
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: PUSH
105290: LD_INT 3
105292: PUSH
105293: LD_INT 60
105295: PUSH
105296: EMPTY
105297: LIST
105298: PUSH
105299: EMPTY
105300: LIST
105301: LIST
105302: PUSH
105303: LD_INT 91
105305: PUSH
105306: LD_VAR 0 8
105310: PUSH
105311: LD_INT 6
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: LIST
105318: PUSH
105319: LD_INT 2
105321: PUSH
105322: LD_INT 25
105324: PUSH
105325: LD_INT 2
105327: PUSH
105328: EMPTY
105329: LIST
105330: LIST
105331: PUSH
105332: LD_INT 25
105334: PUSH
105335: LD_INT 16
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: PUSH
105342: EMPTY
105343: LIST
105344: LIST
105345: LIST
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: LIST
105351: LIST
105352: PPUSH
105353: CALL_OW 69
105357: PUSH
105358: LD_VAR 0 8
105362: PPUSH
105363: CALL_OW 313
105367: PPUSH
105368: LD_INT 3
105370: PUSH
105371: LD_INT 60
105373: PUSH
105374: EMPTY
105375: LIST
105376: PUSH
105377: EMPTY
105378: LIST
105379: LIST
105380: PUSH
105381: LD_INT 2
105383: PUSH
105384: LD_INT 25
105386: PUSH
105387: LD_INT 2
105389: PUSH
105390: EMPTY
105391: LIST
105392: LIST
105393: PUSH
105394: LD_INT 25
105396: PUSH
105397: LD_INT 16
105399: PUSH
105400: EMPTY
105401: LIST
105402: LIST
105403: PUSH
105404: EMPTY
105405: LIST
105406: LIST
105407: LIST
105408: PUSH
105409: EMPTY
105410: LIST
105411: LIST
105412: PPUSH
105413: CALL_OW 72
105417: UNION
105418: ST_TO_ADDR
// if tmp then
105419: LD_VAR 0 4
105423: IFFALSE 105503
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105425: LD_ADDR_VAR 0 4
105429: PUSH
105430: LD_VAR 0 4
105434: PPUSH
105435: LD_INT 3
105437: PPUSH
105438: CALL 54441 0 2
105442: ST_TO_ADDR
// for j in tmp do
105443: LD_ADDR_VAR 0 2
105447: PUSH
105448: LD_VAR 0 4
105452: PUSH
105453: FOR_IN
105454: IFFALSE 105497
// begin if IsInUnit ( j ) then
105456: LD_VAR 0 2
105460: PPUSH
105461: CALL_OW 310
105465: IFFALSE 105476
// ComExit ( j ) ;
105467: LD_VAR 0 2
105471: PPUSH
105472: CALL 54524 0 1
// AddComCollect ( j , x , y ) ;
105476: LD_VAR 0 2
105480: PPUSH
105481: LD_VAR 0 6
105485: PPUSH
105486: LD_VAR 0 7
105490: PPUSH
105491: CALL_OW 177
// end ;
105495: GO 105453
105497: POP
105498: POP
// exit ;
105499: POP
105500: POP
105501: GO 105730
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105503: LD_ADDR_VAR 0 4
105507: PUSH
105508: LD_INT 22
105510: PUSH
105511: LD_VAR 0 5
105515: PUSH
105516: EMPTY
105517: LIST
105518: LIST
105519: PUSH
105520: LD_INT 91
105522: PUSH
105523: LD_VAR 0 8
105527: PUSH
105528: LD_INT 8
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: LIST
105535: PUSH
105536: LD_INT 2
105538: PUSH
105539: LD_INT 34
105541: PUSH
105542: LD_INT 12
105544: PUSH
105545: EMPTY
105546: LIST
105547: LIST
105548: PUSH
105549: LD_INT 34
105551: PUSH
105552: LD_INT 51
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: PUSH
105559: LD_INT 34
105561: PUSH
105562: LD_INT 32
105564: PUSH
105565: EMPTY
105566: LIST
105567: LIST
105568: PUSH
105569: LD_INT 34
105571: PUSH
105572: LD_INT 89
105574: PUSH
105575: EMPTY
105576: LIST
105577: LIST
105578: PUSH
105579: EMPTY
105580: LIST
105581: LIST
105582: LIST
105583: LIST
105584: LIST
105585: PUSH
105586: EMPTY
105587: LIST
105588: LIST
105589: LIST
105590: PPUSH
105591: CALL_OW 69
105595: ST_TO_ADDR
// if tmp then
105596: LD_VAR 0 4
105600: IFFALSE 105726
// begin for j in tmp do
105602: LD_ADDR_VAR 0 2
105606: PUSH
105607: LD_VAR 0 4
105611: PUSH
105612: FOR_IN
105613: IFFALSE 105724
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105615: LD_VAR 0 2
105619: PPUSH
105620: CALL_OW 262
105624: PUSH
105625: LD_INT 3
105627: EQUAL
105628: PUSH
105629: LD_VAR 0 2
105633: PPUSH
105634: CALL_OW 261
105638: PUSH
105639: LD_INT 20
105641: GREATER
105642: OR
105643: PUSH
105644: LD_VAR 0 2
105648: PPUSH
105649: CALL_OW 314
105653: NOT
105654: AND
105655: PUSH
105656: LD_VAR 0 2
105660: PPUSH
105661: CALL_OW 263
105665: PUSH
105666: LD_INT 1
105668: NONEQUAL
105669: PUSH
105670: LD_VAR 0 2
105674: PPUSH
105675: CALL_OW 311
105679: OR
105680: AND
105681: IFFALSE 105722
// begin ComCollect ( j , x , y ) ;
105683: LD_VAR 0 2
105687: PPUSH
105688: LD_VAR 0 6
105692: PPUSH
105693: LD_VAR 0 7
105697: PPUSH
105698: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105702: LD_VAR 0 2
105706: PPUSH
105707: LD_VAR 0 8
105711: PPUSH
105712: CALL_OW 172
// exit ;
105716: POP
105717: POP
105718: POP
105719: POP
105720: GO 105730
// end ;
105722: GO 105612
105724: POP
105725: POP
// end ; end ;
105726: GO 105101
105728: POP
105729: POP
// end ; end_of_file
105730: PPOPN 9
105732: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105733: LD_INT 0
105735: PPUSH
105736: PPUSH
105737: PPUSH
105738: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105739: LD_VAR 0 1
105743: PPUSH
105744: CALL_OW 264
105748: PUSH
105749: LD_INT 91
105751: EQUAL
105752: IFFALSE 105824
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105754: LD_INT 68
105756: PPUSH
105757: LD_VAR 0 1
105761: PPUSH
105762: CALL_OW 255
105766: PPUSH
105767: CALL_OW 321
105771: PUSH
105772: LD_INT 2
105774: EQUAL
105775: IFFALSE 105787
// eff := 70 else
105777: LD_ADDR_VAR 0 4
105781: PUSH
105782: LD_INT 70
105784: ST_TO_ADDR
105785: GO 105795
// eff := 30 ;
105787: LD_ADDR_VAR 0 4
105791: PUSH
105792: LD_INT 30
105794: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105795: LD_VAR 0 1
105799: PPUSH
105800: CALL_OW 250
105804: PPUSH
105805: LD_VAR 0 1
105809: PPUSH
105810: CALL_OW 251
105814: PPUSH
105815: LD_VAR 0 4
105819: PPUSH
105820: CALL_OW 495
// end ; end ;
105824: LD_VAR 0 2
105828: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105829: LD_INT 0
105831: PPUSH
// end ;
105832: LD_VAR 0 4
105836: RET
// export function SOS_Command ( cmd ) ; begin
105837: LD_INT 0
105839: PPUSH
// end ;
105840: LD_VAR 0 2
105844: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105845: LD_INT 0
105847: PPUSH
// end ;
105848: LD_VAR 0 6
105852: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105853: LD_INT 0
105855: PPUSH
105856: PPUSH
// if not vehicle or not factory then
105857: LD_VAR 0 1
105861: NOT
105862: PUSH
105863: LD_VAR 0 2
105867: NOT
105868: OR
105869: IFFALSE 105873
// exit ;
105871: GO 106104
// if factoryWaypoints >= factory then
105873: LD_EXP 165
105877: PUSH
105878: LD_VAR 0 2
105882: GREATEREQUAL
105883: IFFALSE 106104
// if factoryWaypoints [ factory ] then
105885: LD_EXP 165
105889: PUSH
105890: LD_VAR 0 2
105894: ARRAY
105895: IFFALSE 106104
// begin if GetControl ( vehicle ) = control_manual then
105897: LD_VAR 0 1
105901: PPUSH
105902: CALL_OW 263
105906: PUSH
105907: LD_INT 1
105909: EQUAL
105910: IFFALSE 105991
// begin driver := IsDrivenBy ( vehicle ) ;
105912: LD_ADDR_VAR 0 4
105916: PUSH
105917: LD_VAR 0 1
105921: PPUSH
105922: CALL_OW 311
105926: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105927: LD_VAR 0 4
105931: PPUSH
105932: LD_EXP 165
105936: PUSH
105937: LD_VAR 0 2
105941: ARRAY
105942: PUSH
105943: LD_INT 3
105945: ARRAY
105946: PPUSH
105947: LD_EXP 165
105951: PUSH
105952: LD_VAR 0 2
105956: ARRAY
105957: PUSH
105958: LD_INT 4
105960: ARRAY
105961: PPUSH
105962: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105966: LD_VAR 0 4
105970: PPUSH
105971: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105975: LD_VAR 0 4
105979: PPUSH
105980: LD_VAR 0 2
105984: PPUSH
105985: CALL_OW 180
// end else
105989: GO 106104
// if GetControl ( vehicle ) = control_remote then
105991: LD_VAR 0 1
105995: PPUSH
105996: CALL_OW 263
106000: PUSH
106001: LD_INT 2
106003: EQUAL
106004: IFFALSE 106065
// begin wait ( 0 0$2 ) ;
106006: LD_INT 70
106008: PPUSH
106009: CALL_OW 67
// if Connect ( vehicle ) then
106013: LD_VAR 0 1
106017: PPUSH
106018: CALL 24743 0 1
106022: IFFALSE 106063
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106024: LD_VAR 0 1
106028: PPUSH
106029: LD_EXP 165
106033: PUSH
106034: LD_VAR 0 2
106038: ARRAY
106039: PUSH
106040: LD_INT 3
106042: ARRAY
106043: PPUSH
106044: LD_EXP 165
106048: PUSH
106049: LD_VAR 0 2
106053: ARRAY
106054: PUSH
106055: LD_INT 4
106057: ARRAY
106058: PPUSH
106059: CALL_OW 171
// end else
106063: GO 106104
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106065: LD_VAR 0 1
106069: PPUSH
106070: LD_EXP 165
106074: PUSH
106075: LD_VAR 0 2
106079: ARRAY
106080: PUSH
106081: LD_INT 3
106083: ARRAY
106084: PPUSH
106085: LD_EXP 165
106089: PUSH
106090: LD_VAR 0 2
106094: ARRAY
106095: PUSH
106096: LD_INT 4
106098: ARRAY
106099: PPUSH
106100: CALL_OW 171
// end ; end ;
106104: LD_VAR 0 3
106108: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106109: LD_INT 0
106111: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106112: LD_VAR 0 1
106116: PUSH
106117: LD_INT 250
106119: EQUAL
106120: PUSH
106121: LD_VAR 0 2
106125: PPUSH
106126: CALL_OW 264
106130: PUSH
106131: LD_INT 81
106133: EQUAL
106134: AND
106135: IFFALSE 106156
// MinerPlaceMine ( unit , x , y ) ;
106137: LD_VAR 0 2
106141: PPUSH
106142: LD_VAR 0 4
106146: PPUSH
106147: LD_VAR 0 5
106151: PPUSH
106152: CALL 109146 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106156: LD_VAR 0 1
106160: PUSH
106161: LD_INT 251
106163: EQUAL
106164: PUSH
106165: LD_VAR 0 2
106169: PPUSH
106170: CALL_OW 264
106174: PUSH
106175: LD_INT 81
106177: EQUAL
106178: AND
106179: IFFALSE 106200
// MinerDetonateMine ( unit , x , y ) ;
106181: LD_VAR 0 2
106185: PPUSH
106186: LD_VAR 0 4
106190: PPUSH
106191: LD_VAR 0 5
106195: PPUSH
106196: CALL 109421 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106200: LD_VAR 0 1
106204: PUSH
106205: LD_INT 252
106207: EQUAL
106208: PUSH
106209: LD_VAR 0 2
106213: PPUSH
106214: CALL_OW 264
106218: PUSH
106219: LD_INT 81
106221: EQUAL
106222: AND
106223: IFFALSE 106244
// MinerCreateMinefield ( unit , x , y ) ;
106225: LD_VAR 0 2
106229: PPUSH
106230: LD_VAR 0 4
106234: PPUSH
106235: LD_VAR 0 5
106239: PPUSH
106240: CALL 109838 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106244: LD_VAR 0 1
106248: PUSH
106249: LD_INT 253
106251: EQUAL
106252: PUSH
106253: LD_VAR 0 2
106257: PPUSH
106258: CALL_OW 257
106262: PUSH
106263: LD_INT 5
106265: EQUAL
106266: AND
106267: IFFALSE 106288
// ComBinocular ( unit , x , y ) ;
106269: LD_VAR 0 2
106273: PPUSH
106274: LD_VAR 0 4
106278: PPUSH
106279: LD_VAR 0 5
106283: PPUSH
106284: CALL 110207 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106288: LD_VAR 0 1
106292: PUSH
106293: LD_INT 254
106295: EQUAL
106296: PUSH
106297: LD_VAR 0 2
106301: PPUSH
106302: CALL_OW 264
106306: PUSH
106307: LD_INT 99
106309: EQUAL
106310: AND
106311: PUSH
106312: LD_VAR 0 3
106316: PPUSH
106317: CALL_OW 263
106321: PUSH
106322: LD_INT 3
106324: EQUAL
106325: AND
106326: IFFALSE 106342
// HackDestroyVehicle ( unit , selectedUnit ) ;
106328: LD_VAR 0 2
106332: PPUSH
106333: LD_VAR 0 3
106337: PPUSH
106338: CALL 108510 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106342: LD_VAR 0 1
106346: PUSH
106347: LD_INT 255
106349: EQUAL
106350: PUSH
106351: LD_VAR 0 2
106355: PPUSH
106356: CALL_OW 264
106360: PUSH
106361: LD_INT 14
106363: PUSH
106364: LD_INT 53
106366: PUSH
106367: EMPTY
106368: LIST
106369: LIST
106370: IN
106371: AND
106372: PUSH
106373: LD_VAR 0 4
106377: PPUSH
106378: LD_VAR 0 5
106382: PPUSH
106383: CALL_OW 488
106387: AND
106388: IFFALSE 106412
// CutTreeXYR ( unit , x , y , 12 ) ;
106390: LD_VAR 0 2
106394: PPUSH
106395: LD_VAR 0 4
106399: PPUSH
106400: LD_VAR 0 5
106404: PPUSH
106405: LD_INT 12
106407: PPUSH
106408: CALL 106507 0 4
// if cmd = 256 then
106412: LD_VAR 0 1
106416: PUSH
106417: LD_INT 256
106419: EQUAL
106420: IFFALSE 106441
// SetFactoryWaypoint ( unit , x , y ) ;
106422: LD_VAR 0 2
106426: PPUSH
106427: LD_VAR 0 4
106431: PPUSH
106432: LD_VAR 0 5
106436: PPUSH
106437: CALL 104422 0 3
// if cmd = 257 then
106441: LD_VAR 0 1
106445: PUSH
106446: LD_INT 257
106448: EQUAL
106449: IFFALSE 106470
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106451: LD_VAR 0 2
106455: PPUSH
106456: LD_VAR 0 4
106460: PPUSH
106461: LD_VAR 0 5
106465: PPUSH
106466: CALL 104784 0 3
// if cmd = 258 then
106470: LD_VAR 0 1
106474: PUSH
106475: LD_INT 258
106477: EQUAL
106478: IFFALSE 106502
// BurnTreeXYR ( unit , x , y , 8 ) ;
106480: LD_VAR 0 2
106484: PPUSH
106485: LD_VAR 0 4
106489: PPUSH
106490: LD_VAR 0 5
106494: PPUSH
106495: LD_INT 8
106497: PPUSH
106498: CALL 106901 0 4
// end ;
106502: LD_VAR 0 6
106506: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106507: LD_INT 0
106509: PPUSH
106510: PPUSH
106511: PPUSH
106512: PPUSH
106513: PPUSH
106514: PPUSH
106515: PPUSH
106516: PPUSH
106517: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
106518: LD_VAR 0 1
106522: PPUSH
106523: CALL_OW 302
106527: NOT
106528: PUSH
106529: LD_VAR 0 2
106533: PPUSH
106534: LD_VAR 0 3
106538: PPUSH
106539: CALL_OW 488
106543: NOT
106544: OR
106545: PUSH
106546: LD_VAR 0 4
106550: NOT
106551: OR
106552: IFFALSE 106556
// exit ;
106554: GO 106896
// list := [ ] ;
106556: LD_ADDR_VAR 0 13
106560: PUSH
106561: EMPTY
106562: ST_TO_ADDR
// if x - r < 0 then
106563: LD_VAR 0 2
106567: PUSH
106568: LD_VAR 0 4
106572: MINUS
106573: PUSH
106574: LD_INT 0
106576: LESS
106577: IFFALSE 106589
// min_x := 0 else
106579: LD_ADDR_VAR 0 7
106583: PUSH
106584: LD_INT 0
106586: ST_TO_ADDR
106587: GO 106605
// min_x := x - r ;
106589: LD_ADDR_VAR 0 7
106593: PUSH
106594: LD_VAR 0 2
106598: PUSH
106599: LD_VAR 0 4
106603: MINUS
106604: ST_TO_ADDR
// if y - r < 0 then
106605: LD_VAR 0 3
106609: PUSH
106610: LD_VAR 0 4
106614: MINUS
106615: PUSH
106616: LD_INT 0
106618: LESS
106619: IFFALSE 106631
// min_y := 0 else
106621: LD_ADDR_VAR 0 8
106625: PUSH
106626: LD_INT 0
106628: ST_TO_ADDR
106629: GO 106647
// min_y := y - r ;
106631: LD_ADDR_VAR 0 8
106635: PUSH
106636: LD_VAR 0 3
106640: PUSH
106641: LD_VAR 0 4
106645: MINUS
106646: ST_TO_ADDR
// max_x := x + r ;
106647: LD_ADDR_VAR 0 9
106651: PUSH
106652: LD_VAR 0 2
106656: PUSH
106657: LD_VAR 0 4
106661: PLUS
106662: ST_TO_ADDR
// max_y := y + r ;
106663: LD_ADDR_VAR 0 10
106667: PUSH
106668: LD_VAR 0 3
106672: PUSH
106673: LD_VAR 0 4
106677: PLUS
106678: ST_TO_ADDR
// for _x = min_x to max_x do
106679: LD_ADDR_VAR 0 11
106683: PUSH
106684: DOUBLE
106685: LD_VAR 0 7
106689: DEC
106690: ST_TO_ADDR
106691: LD_VAR 0 9
106695: PUSH
106696: FOR_TO
106697: IFFALSE 106814
// for _y = min_y to max_y do
106699: LD_ADDR_VAR 0 12
106703: PUSH
106704: DOUBLE
106705: LD_VAR 0 8
106709: DEC
106710: ST_TO_ADDR
106711: LD_VAR 0 10
106715: PUSH
106716: FOR_TO
106717: IFFALSE 106810
// begin if not ValidHex ( _x , _y ) then
106719: LD_VAR 0 11
106723: PPUSH
106724: LD_VAR 0 12
106728: PPUSH
106729: CALL_OW 488
106733: NOT
106734: IFFALSE 106738
// continue ;
106736: GO 106716
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106738: LD_VAR 0 11
106742: PPUSH
106743: LD_VAR 0 12
106747: PPUSH
106748: CALL_OW 351
106752: PUSH
106753: LD_VAR 0 11
106757: PPUSH
106758: LD_VAR 0 12
106762: PPUSH
106763: CALL_OW 554
106767: AND
106768: IFFALSE 106808
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106770: LD_ADDR_VAR 0 13
106774: PUSH
106775: LD_VAR 0 13
106779: PPUSH
106780: LD_VAR 0 13
106784: PUSH
106785: LD_INT 1
106787: PLUS
106788: PPUSH
106789: LD_VAR 0 11
106793: PUSH
106794: LD_VAR 0 12
106798: PUSH
106799: EMPTY
106800: LIST
106801: LIST
106802: PPUSH
106803: CALL_OW 2
106807: ST_TO_ADDR
// end ;
106808: GO 106716
106810: POP
106811: POP
106812: GO 106696
106814: POP
106815: POP
// if not list then
106816: LD_VAR 0 13
106820: NOT
106821: IFFALSE 106825
// exit ;
106823: GO 106896
// for i in list do
106825: LD_ADDR_VAR 0 6
106829: PUSH
106830: LD_VAR 0 13
106834: PUSH
106835: FOR_IN
106836: IFFALSE 106894
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106838: LD_VAR 0 1
106842: PPUSH
106843: LD_STRING M
106845: PUSH
106846: LD_VAR 0 6
106850: PUSH
106851: LD_INT 1
106853: ARRAY
106854: PUSH
106855: LD_VAR 0 6
106859: PUSH
106860: LD_INT 2
106862: ARRAY
106863: PUSH
106864: LD_INT 0
106866: PUSH
106867: LD_INT 0
106869: PUSH
106870: LD_INT 0
106872: PUSH
106873: LD_INT 0
106875: PUSH
106876: EMPTY
106877: LIST
106878: LIST
106879: LIST
106880: LIST
106881: LIST
106882: LIST
106883: LIST
106884: PUSH
106885: EMPTY
106886: LIST
106887: PPUSH
106888: CALL_OW 447
106892: GO 106835
106894: POP
106895: POP
// end ;
106896: LD_VAR 0 5
106900: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
106901: LD_INT 0
106903: PPUSH
106904: PPUSH
106905: PPUSH
106906: PPUSH
106907: PPUSH
106908: PPUSH
106909: PPUSH
106910: PPUSH
106911: PPUSH
106912: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
106913: LD_VAR 0 1
106917: PPUSH
106918: CALL_OW 302
106922: NOT
106923: PUSH
106924: LD_VAR 0 2
106928: PPUSH
106929: LD_VAR 0 3
106933: PPUSH
106934: CALL_OW 488
106938: NOT
106939: OR
106940: PUSH
106941: LD_VAR 0 4
106945: NOT
106946: OR
106947: IFFALSE 106951
// exit ;
106949: GO 107464
// list := [ ] ;
106951: LD_ADDR_VAR 0 13
106955: PUSH
106956: EMPTY
106957: ST_TO_ADDR
// if x - r < 0 then
106958: LD_VAR 0 2
106962: PUSH
106963: LD_VAR 0 4
106967: MINUS
106968: PUSH
106969: LD_INT 0
106971: LESS
106972: IFFALSE 106984
// min_x := 0 else
106974: LD_ADDR_VAR 0 7
106978: PUSH
106979: LD_INT 0
106981: ST_TO_ADDR
106982: GO 107000
// min_x := x - r ;
106984: LD_ADDR_VAR 0 7
106988: PUSH
106989: LD_VAR 0 2
106993: PUSH
106994: LD_VAR 0 4
106998: MINUS
106999: ST_TO_ADDR
// if y - r < 0 then
107000: LD_VAR 0 3
107004: PUSH
107005: LD_VAR 0 4
107009: MINUS
107010: PUSH
107011: LD_INT 0
107013: LESS
107014: IFFALSE 107026
// min_y := 0 else
107016: LD_ADDR_VAR 0 8
107020: PUSH
107021: LD_INT 0
107023: ST_TO_ADDR
107024: GO 107042
// min_y := y - r ;
107026: LD_ADDR_VAR 0 8
107030: PUSH
107031: LD_VAR 0 3
107035: PUSH
107036: LD_VAR 0 4
107040: MINUS
107041: ST_TO_ADDR
// max_x := x + r ;
107042: LD_ADDR_VAR 0 9
107046: PUSH
107047: LD_VAR 0 2
107051: PUSH
107052: LD_VAR 0 4
107056: PLUS
107057: ST_TO_ADDR
// max_y := y + r ;
107058: LD_ADDR_VAR 0 10
107062: PUSH
107063: LD_VAR 0 3
107067: PUSH
107068: LD_VAR 0 4
107072: PLUS
107073: ST_TO_ADDR
// for _x = min_x to max_x do
107074: LD_ADDR_VAR 0 11
107078: PUSH
107079: DOUBLE
107080: LD_VAR 0 7
107084: DEC
107085: ST_TO_ADDR
107086: LD_VAR 0 9
107090: PUSH
107091: FOR_TO
107092: IFFALSE 107209
// for _y = min_y to max_y do
107094: LD_ADDR_VAR 0 12
107098: PUSH
107099: DOUBLE
107100: LD_VAR 0 8
107104: DEC
107105: ST_TO_ADDR
107106: LD_VAR 0 10
107110: PUSH
107111: FOR_TO
107112: IFFALSE 107205
// begin if not ValidHex ( _x , _y ) then
107114: LD_VAR 0 11
107118: PPUSH
107119: LD_VAR 0 12
107123: PPUSH
107124: CALL_OW 488
107128: NOT
107129: IFFALSE 107133
// continue ;
107131: GO 107111
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107133: LD_VAR 0 11
107137: PPUSH
107138: LD_VAR 0 12
107142: PPUSH
107143: CALL_OW 351
107147: PUSH
107148: LD_VAR 0 11
107152: PPUSH
107153: LD_VAR 0 12
107157: PPUSH
107158: CALL_OW 554
107162: AND
107163: IFFALSE 107203
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107165: LD_ADDR_VAR 0 13
107169: PUSH
107170: LD_VAR 0 13
107174: PPUSH
107175: LD_VAR 0 13
107179: PUSH
107180: LD_INT 1
107182: PLUS
107183: PPUSH
107184: LD_VAR 0 11
107188: PUSH
107189: LD_VAR 0 12
107193: PUSH
107194: EMPTY
107195: LIST
107196: LIST
107197: PPUSH
107198: CALL_OW 2
107202: ST_TO_ADDR
// end ;
107203: GO 107111
107205: POP
107206: POP
107207: GO 107091
107209: POP
107210: POP
// if not list then
107211: LD_VAR 0 13
107215: NOT
107216: IFFALSE 107220
// exit ;
107218: GO 107464
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
107220: LD_ADDR_VAR 0 13
107224: PUSH
107225: LD_VAR 0 1
107229: PPUSH
107230: LD_VAR 0 13
107234: PPUSH
107235: LD_INT 1
107237: PPUSH
107238: LD_INT 1
107240: PPUSH
107241: CALL 21885 0 4
107245: ST_TO_ADDR
// ComStop ( flame ) ;
107246: LD_VAR 0 1
107250: PPUSH
107251: CALL_OW 141
// for i in list do
107255: LD_ADDR_VAR 0 6
107259: PUSH
107260: LD_VAR 0 13
107264: PUSH
107265: FOR_IN
107266: IFFALSE 107297
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
107268: LD_VAR 0 1
107272: PPUSH
107273: LD_VAR 0 6
107277: PUSH
107278: LD_INT 1
107280: ARRAY
107281: PPUSH
107282: LD_VAR 0 6
107286: PUSH
107287: LD_INT 2
107289: ARRAY
107290: PPUSH
107291: CALL_OW 176
107295: GO 107265
107297: POP
107298: POP
// repeat wait ( 0 0$1 ) ;
107299: LD_INT 35
107301: PPUSH
107302: CALL_OW 67
// task := GetTaskList ( flame ) ;
107306: LD_ADDR_VAR 0 14
107310: PUSH
107311: LD_VAR 0 1
107315: PPUSH
107316: CALL_OW 437
107320: ST_TO_ADDR
// if not task then
107321: LD_VAR 0 14
107325: NOT
107326: IFFALSE 107330
// exit ;
107328: GO 107464
// if task [ 1 ] [ 1 ] <> | then
107330: LD_VAR 0 14
107334: PUSH
107335: LD_INT 1
107337: ARRAY
107338: PUSH
107339: LD_INT 1
107341: ARRAY
107342: PUSH
107343: LD_STRING |
107345: NONEQUAL
107346: IFFALSE 107350
// exit ;
107348: GO 107464
// _x := task [ 1 ] [ 2 ] ;
107350: LD_ADDR_VAR 0 11
107354: PUSH
107355: LD_VAR 0 14
107359: PUSH
107360: LD_INT 1
107362: ARRAY
107363: PUSH
107364: LD_INT 2
107366: ARRAY
107367: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
107368: LD_ADDR_VAR 0 12
107372: PUSH
107373: LD_VAR 0 14
107377: PUSH
107378: LD_INT 1
107380: ARRAY
107381: PUSH
107382: LD_INT 3
107384: ARRAY
107385: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
107386: LD_VAR 0 11
107390: PPUSH
107391: LD_VAR 0 12
107395: PPUSH
107396: CALL_OW 351
107400: NOT
107401: PUSH
107402: LD_VAR 0 11
107406: PPUSH
107407: LD_VAR 0 12
107411: PPUSH
107412: CALL_OW 554
107416: NOT
107417: OR
107418: IFFALSE 107452
// begin task := Delete ( task , 1 ) ;
107420: LD_ADDR_VAR 0 14
107424: PUSH
107425: LD_VAR 0 14
107429: PPUSH
107430: LD_INT 1
107432: PPUSH
107433: CALL_OW 3
107437: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
107438: LD_VAR 0 1
107442: PPUSH
107443: LD_VAR 0 14
107447: PPUSH
107448: CALL_OW 446
// end ; until not HasTask ( flame ) ;
107452: LD_VAR 0 1
107456: PPUSH
107457: CALL_OW 314
107461: NOT
107462: IFFALSE 107299
// end ;
107464: LD_VAR 0 5
107468: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107469: LD_EXP 168
107473: NOT
107474: IFFALSE 107524
107476: GO 107478
107478: DISABLE
// begin initHack := true ;
107479: LD_ADDR_EXP 168
107483: PUSH
107484: LD_INT 1
107486: ST_TO_ADDR
// hackTanks := [ ] ;
107487: LD_ADDR_EXP 169
107491: PUSH
107492: EMPTY
107493: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107494: LD_ADDR_EXP 170
107498: PUSH
107499: EMPTY
107500: ST_TO_ADDR
// hackLimit := 3 ;
107501: LD_ADDR_EXP 171
107505: PUSH
107506: LD_INT 3
107508: ST_TO_ADDR
// hackDist := 12 ;
107509: LD_ADDR_EXP 172
107513: PUSH
107514: LD_INT 12
107516: ST_TO_ADDR
// hackCounter := [ ] ;
107517: LD_ADDR_EXP 173
107521: PUSH
107522: EMPTY
107523: ST_TO_ADDR
// end ;
107524: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107525: LD_EXP 168
107529: PUSH
107530: LD_INT 34
107532: PUSH
107533: LD_INT 99
107535: PUSH
107536: EMPTY
107537: LIST
107538: LIST
107539: PPUSH
107540: CALL_OW 69
107544: AND
107545: IFFALSE 107798
107547: GO 107549
107549: DISABLE
107550: LD_INT 0
107552: PPUSH
107553: PPUSH
// begin enable ;
107554: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107555: LD_ADDR_VAR 0 1
107559: PUSH
107560: LD_INT 34
107562: PUSH
107563: LD_INT 99
107565: PUSH
107566: EMPTY
107567: LIST
107568: LIST
107569: PPUSH
107570: CALL_OW 69
107574: PUSH
107575: FOR_IN
107576: IFFALSE 107796
// begin if not i in hackTanks then
107578: LD_VAR 0 1
107582: PUSH
107583: LD_EXP 169
107587: IN
107588: NOT
107589: IFFALSE 107672
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107591: LD_ADDR_EXP 169
107595: PUSH
107596: LD_EXP 169
107600: PPUSH
107601: LD_EXP 169
107605: PUSH
107606: LD_INT 1
107608: PLUS
107609: PPUSH
107610: LD_VAR 0 1
107614: PPUSH
107615: CALL_OW 1
107619: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107620: LD_ADDR_EXP 170
107624: PUSH
107625: LD_EXP 170
107629: PPUSH
107630: LD_EXP 170
107634: PUSH
107635: LD_INT 1
107637: PLUS
107638: PPUSH
107639: EMPTY
107640: PPUSH
107641: CALL_OW 1
107645: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107646: LD_ADDR_EXP 173
107650: PUSH
107651: LD_EXP 173
107655: PPUSH
107656: LD_EXP 173
107660: PUSH
107661: LD_INT 1
107663: PLUS
107664: PPUSH
107665: EMPTY
107666: PPUSH
107667: CALL_OW 1
107671: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107672: LD_VAR 0 1
107676: PPUSH
107677: CALL_OW 302
107681: NOT
107682: IFFALSE 107695
// begin HackUnlinkAll ( i ) ;
107684: LD_VAR 0 1
107688: PPUSH
107689: CALL 107801 0 1
// continue ;
107693: GO 107575
// end ; HackCheckCapturedStatus ( i ) ;
107695: LD_VAR 0 1
107699: PPUSH
107700: CALL 108244 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107704: LD_ADDR_VAR 0 2
107708: PUSH
107709: LD_INT 81
107711: PUSH
107712: LD_VAR 0 1
107716: PPUSH
107717: CALL_OW 255
107721: PUSH
107722: EMPTY
107723: LIST
107724: LIST
107725: PUSH
107726: LD_INT 33
107728: PUSH
107729: LD_INT 3
107731: PUSH
107732: EMPTY
107733: LIST
107734: LIST
107735: PUSH
107736: LD_INT 91
107738: PUSH
107739: LD_VAR 0 1
107743: PUSH
107744: LD_EXP 172
107748: PUSH
107749: EMPTY
107750: LIST
107751: LIST
107752: LIST
107753: PUSH
107754: LD_INT 50
107756: PUSH
107757: EMPTY
107758: LIST
107759: PUSH
107760: EMPTY
107761: LIST
107762: LIST
107763: LIST
107764: LIST
107765: PPUSH
107766: CALL_OW 69
107770: ST_TO_ADDR
// if not tmp then
107771: LD_VAR 0 2
107775: NOT
107776: IFFALSE 107780
// continue ;
107778: GO 107575
// HackLink ( i , tmp ) ;
107780: LD_VAR 0 1
107784: PPUSH
107785: LD_VAR 0 2
107789: PPUSH
107790: CALL 107937 0 2
// end ;
107794: GO 107575
107796: POP
107797: POP
// end ;
107798: PPOPN 2
107800: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107801: LD_INT 0
107803: PPUSH
107804: PPUSH
107805: PPUSH
// if not hack in hackTanks then
107806: LD_VAR 0 1
107810: PUSH
107811: LD_EXP 169
107815: IN
107816: NOT
107817: IFFALSE 107821
// exit ;
107819: GO 107932
// index := GetElementIndex ( hackTanks , hack ) ;
107821: LD_ADDR_VAR 0 4
107825: PUSH
107826: LD_EXP 169
107830: PPUSH
107831: LD_VAR 0 1
107835: PPUSH
107836: CALL 21182 0 2
107840: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107841: LD_EXP 170
107845: PUSH
107846: LD_VAR 0 4
107850: ARRAY
107851: IFFALSE 107932
// begin for i in hackTanksCaptured [ index ] do
107853: LD_ADDR_VAR 0 3
107857: PUSH
107858: LD_EXP 170
107862: PUSH
107863: LD_VAR 0 4
107867: ARRAY
107868: PUSH
107869: FOR_IN
107870: IFFALSE 107896
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107872: LD_VAR 0 3
107876: PUSH
107877: LD_INT 1
107879: ARRAY
107880: PPUSH
107881: LD_VAR 0 3
107885: PUSH
107886: LD_INT 2
107888: ARRAY
107889: PPUSH
107890: CALL_OW 235
107894: GO 107869
107896: POP
107897: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107898: LD_ADDR_EXP 170
107902: PUSH
107903: LD_EXP 170
107907: PPUSH
107908: LD_VAR 0 4
107912: PPUSH
107913: EMPTY
107914: PPUSH
107915: CALL_OW 1
107919: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107920: LD_VAR 0 1
107924: PPUSH
107925: LD_INT 0
107927: PPUSH
107928: CALL_OW 505
// end ; end ;
107932: LD_VAR 0 2
107936: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107937: LD_INT 0
107939: PPUSH
107940: PPUSH
107941: PPUSH
// if not hack in hackTanks or not vehicles then
107942: LD_VAR 0 1
107946: PUSH
107947: LD_EXP 169
107951: IN
107952: NOT
107953: PUSH
107954: LD_VAR 0 2
107958: NOT
107959: OR
107960: IFFALSE 107964
// exit ;
107962: GO 108239
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107964: LD_ADDR_VAR 0 2
107968: PUSH
107969: LD_VAR 0 1
107973: PPUSH
107974: LD_VAR 0 2
107978: PPUSH
107979: LD_INT 1
107981: PPUSH
107982: LD_INT 1
107984: PPUSH
107985: CALL 21832 0 4
107989: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107990: LD_ADDR_VAR 0 5
107994: PUSH
107995: LD_EXP 169
107999: PPUSH
108000: LD_VAR 0 1
108004: PPUSH
108005: CALL 21182 0 2
108009: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108010: LD_EXP 170
108014: PUSH
108015: LD_VAR 0 5
108019: ARRAY
108020: PUSH
108021: LD_EXP 171
108025: LESS
108026: IFFALSE 108215
// begin for i := 1 to vehicles do
108028: LD_ADDR_VAR 0 4
108032: PUSH
108033: DOUBLE
108034: LD_INT 1
108036: DEC
108037: ST_TO_ADDR
108038: LD_VAR 0 2
108042: PUSH
108043: FOR_TO
108044: IFFALSE 108213
// begin if hackTanksCaptured [ index ] = hackLimit then
108046: LD_EXP 170
108050: PUSH
108051: LD_VAR 0 5
108055: ARRAY
108056: PUSH
108057: LD_EXP 171
108061: EQUAL
108062: IFFALSE 108066
// break ;
108064: GO 108213
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108066: LD_ADDR_EXP 173
108070: PUSH
108071: LD_EXP 173
108075: PPUSH
108076: LD_VAR 0 5
108080: PPUSH
108081: LD_EXP 173
108085: PUSH
108086: LD_VAR 0 5
108090: ARRAY
108091: PUSH
108092: LD_INT 1
108094: PLUS
108095: PPUSH
108096: CALL_OW 1
108100: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108101: LD_ADDR_EXP 170
108105: PUSH
108106: LD_EXP 170
108110: PPUSH
108111: LD_VAR 0 5
108115: PUSH
108116: LD_EXP 170
108120: PUSH
108121: LD_VAR 0 5
108125: ARRAY
108126: PUSH
108127: LD_INT 1
108129: PLUS
108130: PUSH
108131: EMPTY
108132: LIST
108133: LIST
108134: PPUSH
108135: LD_VAR 0 2
108139: PUSH
108140: LD_VAR 0 4
108144: ARRAY
108145: PUSH
108146: LD_VAR 0 2
108150: PUSH
108151: LD_VAR 0 4
108155: ARRAY
108156: PPUSH
108157: CALL_OW 255
108161: PUSH
108162: EMPTY
108163: LIST
108164: LIST
108165: PPUSH
108166: CALL 21397 0 3
108170: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108171: LD_VAR 0 2
108175: PUSH
108176: LD_VAR 0 4
108180: ARRAY
108181: PPUSH
108182: LD_VAR 0 1
108186: PPUSH
108187: CALL_OW 255
108191: PPUSH
108192: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108196: LD_VAR 0 2
108200: PUSH
108201: LD_VAR 0 4
108205: ARRAY
108206: PPUSH
108207: CALL_OW 141
// end ;
108211: GO 108043
108213: POP
108214: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108215: LD_VAR 0 1
108219: PPUSH
108220: LD_EXP 170
108224: PUSH
108225: LD_VAR 0 5
108229: ARRAY
108230: PUSH
108231: LD_INT 0
108233: PLUS
108234: PPUSH
108235: CALL_OW 505
// end ;
108239: LD_VAR 0 3
108243: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108244: LD_INT 0
108246: PPUSH
108247: PPUSH
108248: PPUSH
108249: PPUSH
// if not hack in hackTanks then
108250: LD_VAR 0 1
108254: PUSH
108255: LD_EXP 169
108259: IN
108260: NOT
108261: IFFALSE 108265
// exit ;
108263: GO 108505
// index := GetElementIndex ( hackTanks , hack ) ;
108265: LD_ADDR_VAR 0 4
108269: PUSH
108270: LD_EXP 169
108274: PPUSH
108275: LD_VAR 0 1
108279: PPUSH
108280: CALL 21182 0 2
108284: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108285: LD_ADDR_VAR 0 3
108289: PUSH
108290: DOUBLE
108291: LD_EXP 170
108295: PUSH
108296: LD_VAR 0 4
108300: ARRAY
108301: INC
108302: ST_TO_ADDR
108303: LD_INT 1
108305: PUSH
108306: FOR_DOWNTO
108307: IFFALSE 108479
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108309: LD_ADDR_VAR 0 5
108313: PUSH
108314: LD_EXP 170
108318: PUSH
108319: LD_VAR 0 4
108323: ARRAY
108324: PUSH
108325: LD_VAR 0 3
108329: ARRAY
108330: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108331: LD_VAR 0 5
108335: PUSH
108336: LD_INT 1
108338: ARRAY
108339: PPUSH
108340: CALL_OW 302
108344: NOT
108345: PUSH
108346: LD_VAR 0 5
108350: PUSH
108351: LD_INT 1
108353: ARRAY
108354: PPUSH
108355: CALL_OW 255
108359: PUSH
108360: LD_VAR 0 1
108364: PPUSH
108365: CALL_OW 255
108369: NONEQUAL
108370: OR
108371: IFFALSE 108477
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108373: LD_VAR 0 5
108377: PUSH
108378: LD_INT 1
108380: ARRAY
108381: PPUSH
108382: CALL_OW 305
108386: PUSH
108387: LD_VAR 0 5
108391: PUSH
108392: LD_INT 1
108394: ARRAY
108395: PPUSH
108396: CALL_OW 255
108400: PUSH
108401: LD_VAR 0 1
108405: PPUSH
108406: CALL_OW 255
108410: EQUAL
108411: AND
108412: IFFALSE 108436
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108414: LD_VAR 0 5
108418: PUSH
108419: LD_INT 1
108421: ARRAY
108422: PPUSH
108423: LD_VAR 0 5
108427: PUSH
108428: LD_INT 2
108430: ARRAY
108431: PPUSH
108432: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108436: LD_ADDR_EXP 170
108440: PUSH
108441: LD_EXP 170
108445: PPUSH
108446: LD_VAR 0 4
108450: PPUSH
108451: LD_EXP 170
108455: PUSH
108456: LD_VAR 0 4
108460: ARRAY
108461: PPUSH
108462: LD_VAR 0 3
108466: PPUSH
108467: CALL_OW 3
108471: PPUSH
108472: CALL_OW 1
108476: ST_TO_ADDR
// end ; end ;
108477: GO 108306
108479: POP
108480: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108481: LD_VAR 0 1
108485: PPUSH
108486: LD_EXP 170
108490: PUSH
108491: LD_VAR 0 4
108495: ARRAY
108496: PUSH
108497: LD_INT 0
108499: PLUS
108500: PPUSH
108501: CALL_OW 505
// end ;
108505: LD_VAR 0 2
108509: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108510: LD_INT 0
108512: PPUSH
108513: PPUSH
108514: PPUSH
108515: PPUSH
// if not hack in hackTanks then
108516: LD_VAR 0 1
108520: PUSH
108521: LD_EXP 169
108525: IN
108526: NOT
108527: IFFALSE 108531
// exit ;
108529: GO 108616
// index := GetElementIndex ( hackTanks , hack ) ;
108531: LD_ADDR_VAR 0 5
108535: PUSH
108536: LD_EXP 169
108540: PPUSH
108541: LD_VAR 0 1
108545: PPUSH
108546: CALL 21182 0 2
108550: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108551: LD_ADDR_VAR 0 4
108555: PUSH
108556: DOUBLE
108557: LD_INT 1
108559: DEC
108560: ST_TO_ADDR
108561: LD_EXP 170
108565: PUSH
108566: LD_VAR 0 5
108570: ARRAY
108571: PUSH
108572: FOR_TO
108573: IFFALSE 108614
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108575: LD_EXP 170
108579: PUSH
108580: LD_VAR 0 5
108584: ARRAY
108585: PUSH
108586: LD_VAR 0 4
108590: ARRAY
108591: PUSH
108592: LD_INT 1
108594: ARRAY
108595: PUSH
108596: LD_VAR 0 2
108600: EQUAL
108601: IFFALSE 108612
// KillUnit ( vehicle ) ;
108603: LD_VAR 0 2
108607: PPUSH
108608: CALL_OW 66
108612: GO 108572
108614: POP
108615: POP
// end ;
108616: LD_VAR 0 3
108620: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108621: LD_EXP 174
108625: NOT
108626: IFFALSE 108661
108628: GO 108630
108630: DISABLE
// begin initMiner := true ;
108631: LD_ADDR_EXP 174
108635: PUSH
108636: LD_INT 1
108638: ST_TO_ADDR
// minersList := [ ] ;
108639: LD_ADDR_EXP 175
108643: PUSH
108644: EMPTY
108645: ST_TO_ADDR
// minerMinesList := [ ] ;
108646: LD_ADDR_EXP 176
108650: PUSH
108651: EMPTY
108652: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108653: LD_ADDR_EXP 177
108657: PUSH
108658: LD_INT 5
108660: ST_TO_ADDR
// end ;
108661: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108662: LD_EXP 174
108666: PUSH
108667: LD_INT 34
108669: PUSH
108670: LD_INT 81
108672: PUSH
108673: EMPTY
108674: LIST
108675: LIST
108676: PPUSH
108677: CALL_OW 69
108681: AND
108682: IFFALSE 109143
108684: GO 108686
108686: DISABLE
108687: LD_INT 0
108689: PPUSH
108690: PPUSH
108691: PPUSH
108692: PPUSH
// begin enable ;
108693: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108694: LD_ADDR_VAR 0 1
108698: PUSH
108699: LD_INT 34
108701: PUSH
108702: LD_INT 81
108704: PUSH
108705: EMPTY
108706: LIST
108707: LIST
108708: PPUSH
108709: CALL_OW 69
108713: PUSH
108714: FOR_IN
108715: IFFALSE 108787
// begin if not i in minersList then
108717: LD_VAR 0 1
108721: PUSH
108722: LD_EXP 175
108726: IN
108727: NOT
108728: IFFALSE 108785
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108730: LD_ADDR_EXP 175
108734: PUSH
108735: LD_EXP 175
108739: PPUSH
108740: LD_EXP 175
108744: PUSH
108745: LD_INT 1
108747: PLUS
108748: PPUSH
108749: LD_VAR 0 1
108753: PPUSH
108754: CALL_OW 1
108758: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108759: LD_ADDR_EXP 176
108763: PUSH
108764: LD_EXP 176
108768: PPUSH
108769: LD_EXP 176
108773: PUSH
108774: LD_INT 1
108776: PLUS
108777: PPUSH
108778: EMPTY
108779: PPUSH
108780: CALL_OW 1
108784: ST_TO_ADDR
// end end ;
108785: GO 108714
108787: POP
108788: POP
// for i := minerMinesList downto 1 do
108789: LD_ADDR_VAR 0 1
108793: PUSH
108794: DOUBLE
108795: LD_EXP 176
108799: INC
108800: ST_TO_ADDR
108801: LD_INT 1
108803: PUSH
108804: FOR_DOWNTO
108805: IFFALSE 109141
// begin if IsLive ( minersList [ i ] ) then
108807: LD_EXP 175
108811: PUSH
108812: LD_VAR 0 1
108816: ARRAY
108817: PPUSH
108818: CALL_OW 300
108822: IFFALSE 108850
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108824: LD_EXP 175
108828: PUSH
108829: LD_VAR 0 1
108833: ARRAY
108834: PPUSH
108835: LD_EXP 176
108839: PUSH
108840: LD_VAR 0 1
108844: ARRAY
108845: PPUSH
108846: CALL_OW 505
// if not minerMinesList [ i ] then
108850: LD_EXP 176
108854: PUSH
108855: LD_VAR 0 1
108859: ARRAY
108860: NOT
108861: IFFALSE 108865
// continue ;
108863: GO 108804
// for j := minerMinesList [ i ] downto 1 do
108865: LD_ADDR_VAR 0 2
108869: PUSH
108870: DOUBLE
108871: LD_EXP 176
108875: PUSH
108876: LD_VAR 0 1
108880: ARRAY
108881: INC
108882: ST_TO_ADDR
108883: LD_INT 1
108885: PUSH
108886: FOR_DOWNTO
108887: IFFALSE 109137
// begin side := GetSide ( minersList [ i ] ) ;
108889: LD_ADDR_VAR 0 3
108893: PUSH
108894: LD_EXP 175
108898: PUSH
108899: LD_VAR 0 1
108903: ARRAY
108904: PPUSH
108905: CALL_OW 255
108909: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108910: LD_ADDR_VAR 0 4
108914: PUSH
108915: LD_EXP 176
108919: PUSH
108920: LD_VAR 0 1
108924: ARRAY
108925: PUSH
108926: LD_VAR 0 2
108930: ARRAY
108931: PUSH
108932: LD_INT 1
108934: ARRAY
108935: PPUSH
108936: LD_EXP 176
108940: PUSH
108941: LD_VAR 0 1
108945: ARRAY
108946: PUSH
108947: LD_VAR 0 2
108951: ARRAY
108952: PUSH
108953: LD_INT 2
108955: ARRAY
108956: PPUSH
108957: CALL_OW 428
108961: ST_TO_ADDR
// if not tmp then
108962: LD_VAR 0 4
108966: NOT
108967: IFFALSE 108971
// continue ;
108969: GO 108886
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108971: LD_VAR 0 4
108975: PUSH
108976: LD_INT 81
108978: PUSH
108979: LD_VAR 0 3
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: PPUSH
108988: CALL_OW 69
108992: IN
108993: PUSH
108994: LD_EXP 176
108998: PUSH
108999: LD_VAR 0 1
109003: ARRAY
109004: PUSH
109005: LD_VAR 0 2
109009: ARRAY
109010: PUSH
109011: LD_INT 1
109013: ARRAY
109014: PPUSH
109015: LD_EXP 176
109019: PUSH
109020: LD_VAR 0 1
109024: ARRAY
109025: PUSH
109026: LD_VAR 0 2
109030: ARRAY
109031: PUSH
109032: LD_INT 2
109034: ARRAY
109035: PPUSH
109036: CALL_OW 458
109040: AND
109041: IFFALSE 109135
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109043: LD_EXP 176
109047: PUSH
109048: LD_VAR 0 1
109052: ARRAY
109053: PUSH
109054: LD_VAR 0 2
109058: ARRAY
109059: PUSH
109060: LD_INT 1
109062: ARRAY
109063: PPUSH
109064: LD_EXP 176
109068: PUSH
109069: LD_VAR 0 1
109073: ARRAY
109074: PUSH
109075: LD_VAR 0 2
109079: ARRAY
109080: PUSH
109081: LD_INT 2
109083: ARRAY
109084: PPUSH
109085: LD_VAR 0 3
109089: PPUSH
109090: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109094: LD_ADDR_EXP 176
109098: PUSH
109099: LD_EXP 176
109103: PPUSH
109104: LD_VAR 0 1
109108: PPUSH
109109: LD_EXP 176
109113: PUSH
109114: LD_VAR 0 1
109118: ARRAY
109119: PPUSH
109120: LD_VAR 0 2
109124: PPUSH
109125: CALL_OW 3
109129: PPUSH
109130: CALL_OW 1
109134: ST_TO_ADDR
// end ; end ;
109135: GO 108886
109137: POP
109138: POP
// end ;
109139: GO 108804
109141: POP
109142: POP
// end ;
109143: PPOPN 4
109145: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109146: LD_INT 0
109148: PPUSH
109149: PPUSH
// result := false ;
109150: LD_ADDR_VAR 0 4
109154: PUSH
109155: LD_INT 0
109157: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109158: LD_VAR 0 1
109162: PPUSH
109163: CALL_OW 264
109167: PUSH
109168: LD_INT 81
109170: EQUAL
109171: NOT
109172: IFFALSE 109176
// exit ;
109174: GO 109416
// index := GetElementIndex ( minersList , unit ) ;
109176: LD_ADDR_VAR 0 5
109180: PUSH
109181: LD_EXP 175
109185: PPUSH
109186: LD_VAR 0 1
109190: PPUSH
109191: CALL 21182 0 2
109195: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109196: LD_EXP 176
109200: PUSH
109201: LD_VAR 0 5
109205: ARRAY
109206: PUSH
109207: LD_EXP 177
109211: GREATEREQUAL
109212: IFFALSE 109216
// exit ;
109214: GO 109416
// ComMoveXY ( unit , x , y ) ;
109216: LD_VAR 0 1
109220: PPUSH
109221: LD_VAR 0 2
109225: PPUSH
109226: LD_VAR 0 3
109230: PPUSH
109231: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109235: LD_INT 35
109237: PPUSH
109238: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109242: LD_VAR 0 1
109246: PPUSH
109247: LD_VAR 0 2
109251: PPUSH
109252: LD_VAR 0 3
109256: PPUSH
109257: CALL 52923 0 3
109261: NOT
109262: PUSH
109263: LD_VAR 0 1
109267: PPUSH
109268: CALL_OW 314
109272: AND
109273: IFFALSE 109277
// exit ;
109275: GO 109416
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109277: LD_VAR 0 2
109281: PPUSH
109282: LD_VAR 0 3
109286: PPUSH
109287: CALL_OW 428
109291: PUSH
109292: LD_VAR 0 1
109296: EQUAL
109297: PUSH
109298: LD_VAR 0 1
109302: PPUSH
109303: CALL_OW 314
109307: NOT
109308: AND
109309: IFFALSE 109235
// PlaySoundXY ( x , y , PlantMine ) ;
109311: LD_VAR 0 2
109315: PPUSH
109316: LD_VAR 0 3
109320: PPUSH
109321: LD_STRING PlantMine
109323: PPUSH
109324: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109328: LD_VAR 0 2
109332: PPUSH
109333: LD_VAR 0 3
109337: PPUSH
109338: LD_VAR 0 1
109342: PPUSH
109343: CALL_OW 255
109347: PPUSH
109348: LD_INT 0
109350: PPUSH
109351: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109355: LD_ADDR_EXP 176
109359: PUSH
109360: LD_EXP 176
109364: PPUSH
109365: LD_VAR 0 5
109369: PUSH
109370: LD_EXP 176
109374: PUSH
109375: LD_VAR 0 5
109379: ARRAY
109380: PUSH
109381: LD_INT 1
109383: PLUS
109384: PUSH
109385: EMPTY
109386: LIST
109387: LIST
109388: PPUSH
109389: LD_VAR 0 2
109393: PUSH
109394: LD_VAR 0 3
109398: PUSH
109399: EMPTY
109400: LIST
109401: LIST
109402: PPUSH
109403: CALL 21397 0 3
109407: ST_TO_ADDR
// result := true ;
109408: LD_ADDR_VAR 0 4
109412: PUSH
109413: LD_INT 1
109415: ST_TO_ADDR
// end ;
109416: LD_VAR 0 4
109420: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109421: LD_INT 0
109423: PPUSH
109424: PPUSH
109425: PPUSH
// if not unit in minersList then
109426: LD_VAR 0 1
109430: PUSH
109431: LD_EXP 175
109435: IN
109436: NOT
109437: IFFALSE 109441
// exit ;
109439: GO 109833
// index := GetElementIndex ( minersList , unit ) ;
109441: LD_ADDR_VAR 0 6
109445: PUSH
109446: LD_EXP 175
109450: PPUSH
109451: LD_VAR 0 1
109455: PPUSH
109456: CALL 21182 0 2
109460: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109461: LD_ADDR_VAR 0 5
109465: PUSH
109466: DOUBLE
109467: LD_EXP 176
109471: PUSH
109472: LD_VAR 0 6
109476: ARRAY
109477: INC
109478: ST_TO_ADDR
109479: LD_INT 1
109481: PUSH
109482: FOR_DOWNTO
109483: IFFALSE 109644
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109485: LD_EXP 176
109489: PUSH
109490: LD_VAR 0 6
109494: ARRAY
109495: PUSH
109496: LD_VAR 0 5
109500: ARRAY
109501: PUSH
109502: LD_INT 1
109504: ARRAY
109505: PUSH
109506: LD_VAR 0 2
109510: EQUAL
109511: PUSH
109512: LD_EXP 176
109516: PUSH
109517: LD_VAR 0 6
109521: ARRAY
109522: PUSH
109523: LD_VAR 0 5
109527: ARRAY
109528: PUSH
109529: LD_INT 2
109531: ARRAY
109532: PUSH
109533: LD_VAR 0 3
109537: EQUAL
109538: AND
109539: IFFALSE 109642
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109541: LD_EXP 176
109545: PUSH
109546: LD_VAR 0 6
109550: ARRAY
109551: PUSH
109552: LD_VAR 0 5
109556: ARRAY
109557: PUSH
109558: LD_INT 1
109560: ARRAY
109561: PPUSH
109562: LD_EXP 176
109566: PUSH
109567: LD_VAR 0 6
109571: ARRAY
109572: PUSH
109573: LD_VAR 0 5
109577: ARRAY
109578: PUSH
109579: LD_INT 2
109581: ARRAY
109582: PPUSH
109583: LD_VAR 0 1
109587: PPUSH
109588: CALL_OW 255
109592: PPUSH
109593: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109597: LD_ADDR_EXP 176
109601: PUSH
109602: LD_EXP 176
109606: PPUSH
109607: LD_VAR 0 6
109611: PPUSH
109612: LD_EXP 176
109616: PUSH
109617: LD_VAR 0 6
109621: ARRAY
109622: PPUSH
109623: LD_VAR 0 5
109627: PPUSH
109628: CALL_OW 3
109632: PPUSH
109633: CALL_OW 1
109637: ST_TO_ADDR
// exit ;
109638: POP
109639: POP
109640: GO 109833
// end ; end ;
109642: GO 109482
109644: POP
109645: POP
// for i := minerMinesList [ index ] downto 1 do
109646: LD_ADDR_VAR 0 5
109650: PUSH
109651: DOUBLE
109652: LD_EXP 176
109656: PUSH
109657: LD_VAR 0 6
109661: ARRAY
109662: INC
109663: ST_TO_ADDR
109664: LD_INT 1
109666: PUSH
109667: FOR_DOWNTO
109668: IFFALSE 109831
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109670: LD_EXP 176
109674: PUSH
109675: LD_VAR 0 6
109679: ARRAY
109680: PUSH
109681: LD_VAR 0 5
109685: ARRAY
109686: PUSH
109687: LD_INT 1
109689: ARRAY
109690: PPUSH
109691: LD_EXP 176
109695: PUSH
109696: LD_VAR 0 6
109700: ARRAY
109701: PUSH
109702: LD_VAR 0 5
109706: ARRAY
109707: PUSH
109708: LD_INT 2
109710: ARRAY
109711: PPUSH
109712: LD_VAR 0 2
109716: PPUSH
109717: LD_VAR 0 3
109721: PPUSH
109722: CALL_OW 298
109726: PUSH
109727: LD_INT 6
109729: LESS
109730: IFFALSE 109829
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109732: LD_EXP 176
109736: PUSH
109737: LD_VAR 0 6
109741: ARRAY
109742: PUSH
109743: LD_VAR 0 5
109747: ARRAY
109748: PUSH
109749: LD_INT 1
109751: ARRAY
109752: PPUSH
109753: LD_EXP 176
109757: PUSH
109758: LD_VAR 0 6
109762: ARRAY
109763: PUSH
109764: LD_VAR 0 5
109768: ARRAY
109769: PUSH
109770: LD_INT 2
109772: ARRAY
109773: PPUSH
109774: LD_VAR 0 1
109778: PPUSH
109779: CALL_OW 255
109783: PPUSH
109784: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109788: LD_ADDR_EXP 176
109792: PUSH
109793: LD_EXP 176
109797: PPUSH
109798: LD_VAR 0 6
109802: PPUSH
109803: LD_EXP 176
109807: PUSH
109808: LD_VAR 0 6
109812: ARRAY
109813: PPUSH
109814: LD_VAR 0 5
109818: PPUSH
109819: CALL_OW 3
109823: PPUSH
109824: CALL_OW 1
109828: ST_TO_ADDR
// end ; end ;
109829: GO 109667
109831: POP
109832: POP
// end ;
109833: LD_VAR 0 4
109837: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109838: LD_INT 0
109840: PPUSH
109841: PPUSH
109842: PPUSH
109843: PPUSH
109844: PPUSH
109845: PPUSH
109846: PPUSH
109847: PPUSH
109848: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109849: LD_VAR 0 1
109853: PPUSH
109854: CALL_OW 264
109858: PUSH
109859: LD_INT 81
109861: EQUAL
109862: NOT
109863: PUSH
109864: LD_VAR 0 1
109868: PUSH
109869: LD_EXP 175
109873: IN
109874: NOT
109875: OR
109876: IFFALSE 109880
// exit ;
109878: GO 110202
// index := GetElementIndex ( minersList , unit ) ;
109880: LD_ADDR_VAR 0 6
109884: PUSH
109885: LD_EXP 175
109889: PPUSH
109890: LD_VAR 0 1
109894: PPUSH
109895: CALL 21182 0 2
109899: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109900: LD_ADDR_VAR 0 8
109904: PUSH
109905: LD_EXP 177
109909: PUSH
109910: LD_EXP 176
109914: PUSH
109915: LD_VAR 0 6
109919: ARRAY
109920: MINUS
109921: ST_TO_ADDR
// if not minesFreeAmount then
109922: LD_VAR 0 8
109926: NOT
109927: IFFALSE 109931
// exit ;
109929: GO 110202
// tmp := [ ] ;
109931: LD_ADDR_VAR 0 7
109935: PUSH
109936: EMPTY
109937: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109938: LD_ADDR_VAR 0 5
109942: PUSH
109943: DOUBLE
109944: LD_INT 1
109946: DEC
109947: ST_TO_ADDR
109948: LD_VAR 0 8
109952: PUSH
109953: FOR_TO
109954: IFFALSE 110149
// begin _d := rand ( 0 , 5 ) ;
109956: LD_ADDR_VAR 0 11
109960: PUSH
109961: LD_INT 0
109963: PPUSH
109964: LD_INT 5
109966: PPUSH
109967: CALL_OW 12
109971: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109972: LD_ADDR_VAR 0 12
109976: PUSH
109977: LD_INT 2
109979: PPUSH
109980: LD_INT 6
109982: PPUSH
109983: CALL_OW 12
109987: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109988: LD_ADDR_VAR 0 9
109992: PUSH
109993: LD_VAR 0 2
109997: PPUSH
109998: LD_VAR 0 11
110002: PPUSH
110003: LD_VAR 0 12
110007: PPUSH
110008: CALL_OW 272
110012: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110013: LD_ADDR_VAR 0 10
110017: PUSH
110018: LD_VAR 0 3
110022: PPUSH
110023: LD_VAR 0 11
110027: PPUSH
110028: LD_VAR 0 12
110032: PPUSH
110033: CALL_OW 273
110037: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110038: LD_VAR 0 9
110042: PPUSH
110043: LD_VAR 0 10
110047: PPUSH
110048: CALL_OW 488
110052: PUSH
110053: LD_VAR 0 9
110057: PUSH
110058: LD_VAR 0 10
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: PUSH
110067: LD_VAR 0 7
110071: IN
110072: NOT
110073: AND
110074: PUSH
110075: LD_VAR 0 9
110079: PPUSH
110080: LD_VAR 0 10
110084: PPUSH
110085: CALL_OW 458
110089: NOT
110090: AND
110091: IFFALSE 110133
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110093: LD_ADDR_VAR 0 7
110097: PUSH
110098: LD_VAR 0 7
110102: PPUSH
110103: LD_VAR 0 7
110107: PUSH
110108: LD_INT 1
110110: PLUS
110111: PPUSH
110112: LD_VAR 0 9
110116: PUSH
110117: LD_VAR 0 10
110121: PUSH
110122: EMPTY
110123: LIST
110124: LIST
110125: PPUSH
110126: CALL_OW 1
110130: ST_TO_ADDR
110131: GO 110147
// i := i - 1 ;
110133: LD_ADDR_VAR 0 5
110137: PUSH
110138: LD_VAR 0 5
110142: PUSH
110143: LD_INT 1
110145: MINUS
110146: ST_TO_ADDR
// end ;
110147: GO 109953
110149: POP
110150: POP
// for i in tmp do
110151: LD_ADDR_VAR 0 5
110155: PUSH
110156: LD_VAR 0 7
110160: PUSH
110161: FOR_IN
110162: IFFALSE 110200
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110164: LD_VAR 0 1
110168: PPUSH
110169: LD_VAR 0 5
110173: PUSH
110174: LD_INT 1
110176: ARRAY
110177: PPUSH
110178: LD_VAR 0 5
110182: PUSH
110183: LD_INT 2
110185: ARRAY
110186: PPUSH
110187: CALL 109146 0 3
110191: NOT
110192: IFFALSE 110198
// exit ;
110194: POP
110195: POP
110196: GO 110202
110198: GO 110161
110200: POP
110201: POP
// end ;
110202: LD_VAR 0 4
110206: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110207: LD_INT 0
110209: PPUSH
110210: PPUSH
110211: PPUSH
110212: PPUSH
110213: PPUSH
110214: PPUSH
110215: PPUSH
// if not GetClass ( unit ) = class_sniper then
110216: LD_VAR 0 1
110220: PPUSH
110221: CALL_OW 257
110225: PUSH
110226: LD_INT 5
110228: EQUAL
110229: NOT
110230: IFFALSE 110234
// exit ;
110232: GO 110622
// dist := 8 ;
110234: LD_ADDR_VAR 0 5
110238: PUSH
110239: LD_INT 8
110241: ST_TO_ADDR
// viewRange := 12 ;
110242: LD_ADDR_VAR 0 7
110246: PUSH
110247: LD_INT 12
110249: ST_TO_ADDR
// side := GetSide ( unit ) ;
110250: LD_ADDR_VAR 0 6
110254: PUSH
110255: LD_VAR 0 1
110259: PPUSH
110260: CALL_OW 255
110264: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110265: LD_INT 61
110267: PPUSH
110268: LD_VAR 0 6
110272: PPUSH
110273: CALL_OW 321
110277: PUSH
110278: LD_INT 2
110280: EQUAL
110281: IFFALSE 110291
// viewRange := 16 ;
110283: LD_ADDR_VAR 0 7
110287: PUSH
110288: LD_INT 16
110290: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110291: LD_VAR 0 1
110295: PPUSH
110296: LD_VAR 0 2
110300: PPUSH
110301: LD_VAR 0 3
110305: PPUSH
110306: CALL_OW 297
110310: PUSH
110311: LD_VAR 0 5
110315: GREATER
110316: IFFALSE 110395
// begin ComMoveXY ( unit , x , y ) ;
110318: LD_VAR 0 1
110322: PPUSH
110323: LD_VAR 0 2
110327: PPUSH
110328: LD_VAR 0 3
110332: PPUSH
110333: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110337: LD_INT 35
110339: PPUSH
110340: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110344: LD_VAR 0 1
110348: PPUSH
110349: LD_VAR 0 2
110353: PPUSH
110354: LD_VAR 0 3
110358: PPUSH
110359: CALL 52923 0 3
110363: NOT
110364: IFFALSE 110368
// exit ;
110366: GO 110622
// until GetDistUnitXY ( unit , x , y ) < dist ;
110368: LD_VAR 0 1
110372: PPUSH
110373: LD_VAR 0 2
110377: PPUSH
110378: LD_VAR 0 3
110382: PPUSH
110383: CALL_OW 297
110387: PUSH
110388: LD_VAR 0 5
110392: LESS
110393: IFFALSE 110337
// end ; ComTurnXY ( unit , x , y ) ;
110395: LD_VAR 0 1
110399: PPUSH
110400: LD_VAR 0 2
110404: PPUSH
110405: LD_VAR 0 3
110409: PPUSH
110410: CALL_OW 118
// wait ( 5 ) ;
110414: LD_INT 5
110416: PPUSH
110417: CALL_OW 67
// _d := GetDir ( unit ) ;
110421: LD_ADDR_VAR 0 10
110425: PUSH
110426: LD_VAR 0 1
110430: PPUSH
110431: CALL_OW 254
110435: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110436: LD_ADDR_VAR 0 8
110440: PUSH
110441: LD_VAR 0 1
110445: PPUSH
110446: CALL_OW 250
110450: PPUSH
110451: LD_VAR 0 10
110455: PPUSH
110456: LD_VAR 0 5
110460: PPUSH
110461: CALL_OW 272
110465: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110466: LD_ADDR_VAR 0 9
110470: PUSH
110471: LD_VAR 0 1
110475: PPUSH
110476: CALL_OW 251
110480: PPUSH
110481: LD_VAR 0 10
110485: PPUSH
110486: LD_VAR 0 5
110490: PPUSH
110491: CALL_OW 273
110495: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110496: LD_VAR 0 8
110500: PPUSH
110501: LD_VAR 0 9
110505: PPUSH
110506: CALL_OW 488
110510: NOT
110511: IFFALSE 110515
// exit ;
110513: GO 110622
// ComAnimCustom ( unit , 1 ) ;
110515: LD_VAR 0 1
110519: PPUSH
110520: LD_INT 1
110522: PPUSH
110523: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110527: LD_VAR 0 8
110531: PPUSH
110532: LD_VAR 0 9
110536: PPUSH
110537: LD_VAR 0 6
110541: PPUSH
110542: LD_VAR 0 7
110546: PPUSH
110547: CALL_OW 330
// repeat wait ( 1 ) ;
110551: LD_INT 1
110553: PPUSH
110554: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110558: LD_VAR 0 1
110562: PPUSH
110563: CALL_OW 316
110567: PUSH
110568: LD_VAR 0 1
110572: PPUSH
110573: CALL_OW 314
110577: OR
110578: PUSH
110579: LD_VAR 0 1
110583: PPUSH
110584: CALL_OW 302
110588: NOT
110589: OR
110590: PUSH
110591: LD_VAR 0 1
110595: PPUSH
110596: CALL_OW 301
110600: OR
110601: IFFALSE 110551
// RemoveSeeing ( _x , _y , side ) ;
110603: LD_VAR 0 8
110607: PPUSH
110608: LD_VAR 0 9
110612: PPUSH
110613: LD_VAR 0 6
110617: PPUSH
110618: CALL_OW 331
// end ; end_of_file
110622: LD_VAR 0 4
110626: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110627: LD_INT 0
110629: PPUSH
110630: PPUSH
110631: PPUSH
110632: PPUSH
110633: PPUSH
110634: PPUSH
110635: PPUSH
110636: PPUSH
110637: PPUSH
110638: PPUSH
110639: PPUSH
110640: PPUSH
110641: PPUSH
110642: PPUSH
110643: PPUSH
110644: PPUSH
110645: PPUSH
110646: PPUSH
110647: PPUSH
110648: PPUSH
110649: PPUSH
110650: PPUSH
110651: PPUSH
110652: PPUSH
110653: PPUSH
110654: PPUSH
110655: PPUSH
110656: PPUSH
110657: PPUSH
110658: PPUSH
110659: PPUSH
110660: PPUSH
110661: PPUSH
110662: PPUSH
// if not list then
110663: LD_VAR 0 1
110667: NOT
110668: IFFALSE 110672
// exit ;
110670: GO 115331
// base := list [ 1 ] ;
110672: LD_ADDR_VAR 0 3
110676: PUSH
110677: LD_VAR 0 1
110681: PUSH
110682: LD_INT 1
110684: ARRAY
110685: ST_TO_ADDR
// group := list [ 2 ] ;
110686: LD_ADDR_VAR 0 4
110690: PUSH
110691: LD_VAR 0 1
110695: PUSH
110696: LD_INT 2
110698: ARRAY
110699: ST_TO_ADDR
// path := list [ 3 ] ;
110700: LD_ADDR_VAR 0 5
110704: PUSH
110705: LD_VAR 0 1
110709: PUSH
110710: LD_INT 3
110712: ARRAY
110713: ST_TO_ADDR
// flags := list [ 4 ] ;
110714: LD_ADDR_VAR 0 6
110718: PUSH
110719: LD_VAR 0 1
110723: PUSH
110724: LD_INT 4
110726: ARRAY
110727: ST_TO_ADDR
// mined := [ ] ;
110728: LD_ADDR_VAR 0 27
110732: PUSH
110733: EMPTY
110734: ST_TO_ADDR
// bombed := [ ] ;
110735: LD_ADDR_VAR 0 28
110739: PUSH
110740: EMPTY
110741: ST_TO_ADDR
// healers := [ ] ;
110742: LD_ADDR_VAR 0 31
110746: PUSH
110747: EMPTY
110748: ST_TO_ADDR
// to_heal := [ ] ;
110749: LD_ADDR_VAR 0 30
110753: PUSH
110754: EMPTY
110755: ST_TO_ADDR
// repairs := [ ] ;
110756: LD_ADDR_VAR 0 33
110760: PUSH
110761: EMPTY
110762: ST_TO_ADDR
// to_repair := [ ] ;
110763: LD_ADDR_VAR 0 32
110767: PUSH
110768: EMPTY
110769: ST_TO_ADDR
// if not group or not path then
110770: LD_VAR 0 4
110774: NOT
110775: PUSH
110776: LD_VAR 0 5
110780: NOT
110781: OR
110782: IFFALSE 110786
// exit ;
110784: GO 115331
// side := GetSide ( group [ 1 ] ) ;
110786: LD_ADDR_VAR 0 35
110790: PUSH
110791: LD_VAR 0 4
110795: PUSH
110796: LD_INT 1
110798: ARRAY
110799: PPUSH
110800: CALL_OW 255
110804: ST_TO_ADDR
// if flags then
110805: LD_VAR 0 6
110809: IFFALSE 110953
// begin f_ignore_area := flags [ 1 ] ;
110811: LD_ADDR_VAR 0 17
110815: PUSH
110816: LD_VAR 0 6
110820: PUSH
110821: LD_INT 1
110823: ARRAY
110824: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110825: LD_ADDR_VAR 0 18
110829: PUSH
110830: LD_VAR 0 6
110834: PUSH
110835: LD_INT 2
110837: ARRAY
110838: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110839: LD_ADDR_VAR 0 19
110843: PUSH
110844: LD_VAR 0 6
110848: PUSH
110849: LD_INT 3
110851: ARRAY
110852: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110853: LD_ADDR_VAR 0 20
110857: PUSH
110858: LD_VAR 0 6
110862: PUSH
110863: LD_INT 4
110865: ARRAY
110866: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110867: LD_ADDR_VAR 0 21
110871: PUSH
110872: LD_VAR 0 6
110876: PUSH
110877: LD_INT 5
110879: ARRAY
110880: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110881: LD_ADDR_VAR 0 22
110885: PUSH
110886: LD_VAR 0 6
110890: PUSH
110891: LD_INT 6
110893: ARRAY
110894: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110895: LD_ADDR_VAR 0 23
110899: PUSH
110900: LD_VAR 0 6
110904: PUSH
110905: LD_INT 7
110907: ARRAY
110908: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110909: LD_ADDR_VAR 0 24
110913: PUSH
110914: LD_VAR 0 6
110918: PUSH
110919: LD_INT 8
110921: ARRAY
110922: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110923: LD_ADDR_VAR 0 25
110927: PUSH
110928: LD_VAR 0 6
110932: PUSH
110933: LD_INT 9
110935: ARRAY
110936: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110937: LD_ADDR_VAR 0 26
110941: PUSH
110942: LD_VAR 0 6
110946: PUSH
110947: LD_INT 10
110949: ARRAY
110950: ST_TO_ADDR
// end else
110951: GO 111033
// begin f_ignore_area := false ;
110953: LD_ADDR_VAR 0 17
110957: PUSH
110958: LD_INT 0
110960: ST_TO_ADDR
// f_capture := false ;
110961: LD_ADDR_VAR 0 18
110965: PUSH
110966: LD_INT 0
110968: ST_TO_ADDR
// f_ignore_civ := false ;
110969: LD_ADDR_VAR 0 19
110973: PUSH
110974: LD_INT 0
110976: ST_TO_ADDR
// f_murder := false ;
110977: LD_ADDR_VAR 0 20
110981: PUSH
110982: LD_INT 0
110984: ST_TO_ADDR
// f_mines := false ;
110985: LD_ADDR_VAR 0 21
110989: PUSH
110990: LD_INT 0
110992: ST_TO_ADDR
// f_repair := false ;
110993: LD_ADDR_VAR 0 22
110997: PUSH
110998: LD_INT 0
111000: ST_TO_ADDR
// f_heal := false ;
111001: LD_ADDR_VAR 0 23
111005: PUSH
111006: LD_INT 0
111008: ST_TO_ADDR
// f_spacetime := false ;
111009: LD_ADDR_VAR 0 24
111013: PUSH
111014: LD_INT 0
111016: ST_TO_ADDR
// f_attack_depot := false ;
111017: LD_ADDR_VAR 0 25
111021: PUSH
111022: LD_INT 0
111024: ST_TO_ADDR
// f_crawl := false ;
111025: LD_ADDR_VAR 0 26
111029: PUSH
111030: LD_INT 0
111032: ST_TO_ADDR
// end ; if f_heal then
111033: LD_VAR 0 23
111037: IFFALSE 111064
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111039: LD_ADDR_VAR 0 31
111043: PUSH
111044: LD_VAR 0 4
111048: PPUSH
111049: LD_INT 25
111051: PUSH
111052: LD_INT 4
111054: PUSH
111055: EMPTY
111056: LIST
111057: LIST
111058: PPUSH
111059: CALL_OW 72
111063: ST_TO_ADDR
// if f_repair then
111064: LD_VAR 0 22
111068: IFFALSE 111095
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111070: LD_ADDR_VAR 0 33
111074: PUSH
111075: LD_VAR 0 4
111079: PPUSH
111080: LD_INT 25
111082: PUSH
111083: LD_INT 3
111085: PUSH
111086: EMPTY
111087: LIST
111088: LIST
111089: PPUSH
111090: CALL_OW 72
111094: ST_TO_ADDR
// units_path := [ ] ;
111095: LD_ADDR_VAR 0 16
111099: PUSH
111100: EMPTY
111101: ST_TO_ADDR
// for i = 1 to group do
111102: LD_ADDR_VAR 0 7
111106: PUSH
111107: DOUBLE
111108: LD_INT 1
111110: DEC
111111: ST_TO_ADDR
111112: LD_VAR 0 4
111116: PUSH
111117: FOR_TO
111118: IFFALSE 111147
// units_path := Replace ( units_path , i , path ) ;
111120: LD_ADDR_VAR 0 16
111124: PUSH
111125: LD_VAR 0 16
111129: PPUSH
111130: LD_VAR 0 7
111134: PPUSH
111135: LD_VAR 0 5
111139: PPUSH
111140: CALL_OW 1
111144: ST_TO_ADDR
111145: GO 111117
111147: POP
111148: POP
// repeat for i = group downto 1 do
111149: LD_ADDR_VAR 0 7
111153: PUSH
111154: DOUBLE
111155: LD_VAR 0 4
111159: INC
111160: ST_TO_ADDR
111161: LD_INT 1
111163: PUSH
111164: FOR_DOWNTO
111165: IFFALSE 115287
// begin wait ( 5 ) ;
111167: LD_INT 5
111169: PPUSH
111170: CALL_OW 67
// tmp := [ ] ;
111174: LD_ADDR_VAR 0 14
111178: PUSH
111179: EMPTY
111180: ST_TO_ADDR
// attacking := false ;
111181: LD_ADDR_VAR 0 29
111185: PUSH
111186: LD_INT 0
111188: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111189: LD_VAR 0 4
111193: PUSH
111194: LD_VAR 0 7
111198: ARRAY
111199: PPUSH
111200: CALL_OW 301
111204: PUSH
111205: LD_VAR 0 4
111209: PUSH
111210: LD_VAR 0 7
111214: ARRAY
111215: NOT
111216: OR
111217: IFFALSE 111326
// begin if GetType ( group [ i ] ) = unit_human then
111219: LD_VAR 0 4
111223: PUSH
111224: LD_VAR 0 7
111228: ARRAY
111229: PPUSH
111230: CALL_OW 247
111234: PUSH
111235: LD_INT 1
111237: EQUAL
111238: IFFALSE 111284
// begin to_heal := to_heal diff group [ i ] ;
111240: LD_ADDR_VAR 0 30
111244: PUSH
111245: LD_VAR 0 30
111249: PUSH
111250: LD_VAR 0 4
111254: PUSH
111255: LD_VAR 0 7
111259: ARRAY
111260: DIFF
111261: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111262: LD_ADDR_VAR 0 31
111266: PUSH
111267: LD_VAR 0 31
111271: PUSH
111272: LD_VAR 0 4
111276: PUSH
111277: LD_VAR 0 7
111281: ARRAY
111282: DIFF
111283: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111284: LD_ADDR_VAR 0 4
111288: PUSH
111289: LD_VAR 0 4
111293: PPUSH
111294: LD_VAR 0 7
111298: PPUSH
111299: CALL_OW 3
111303: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111304: LD_ADDR_VAR 0 16
111308: PUSH
111309: LD_VAR 0 16
111313: PPUSH
111314: LD_VAR 0 7
111318: PPUSH
111319: CALL_OW 3
111323: ST_TO_ADDR
// continue ;
111324: GO 111164
// end ; if f_repair then
111326: LD_VAR 0 22
111330: IFFALSE 111819
// begin if GetType ( group [ i ] ) = unit_vehicle then
111332: LD_VAR 0 4
111336: PUSH
111337: LD_VAR 0 7
111341: ARRAY
111342: PPUSH
111343: CALL_OW 247
111347: PUSH
111348: LD_INT 2
111350: EQUAL
111351: IFFALSE 111541
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111353: LD_VAR 0 4
111357: PUSH
111358: LD_VAR 0 7
111362: ARRAY
111363: PPUSH
111364: CALL_OW 256
111368: PUSH
111369: LD_INT 700
111371: LESS
111372: PUSH
111373: LD_VAR 0 4
111377: PUSH
111378: LD_VAR 0 7
111382: ARRAY
111383: PUSH
111384: LD_VAR 0 32
111388: IN
111389: NOT
111390: AND
111391: IFFALSE 111415
// to_repair := to_repair union group [ i ] ;
111393: LD_ADDR_VAR 0 32
111397: PUSH
111398: LD_VAR 0 32
111402: PUSH
111403: LD_VAR 0 4
111407: PUSH
111408: LD_VAR 0 7
111412: ARRAY
111413: UNION
111414: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111415: LD_VAR 0 4
111419: PUSH
111420: LD_VAR 0 7
111424: ARRAY
111425: PPUSH
111426: CALL_OW 256
111430: PUSH
111431: LD_INT 1000
111433: EQUAL
111434: PUSH
111435: LD_VAR 0 4
111439: PUSH
111440: LD_VAR 0 7
111444: ARRAY
111445: PUSH
111446: LD_VAR 0 32
111450: IN
111451: AND
111452: IFFALSE 111476
// to_repair := to_repair diff group [ i ] ;
111454: LD_ADDR_VAR 0 32
111458: PUSH
111459: LD_VAR 0 32
111463: PUSH
111464: LD_VAR 0 4
111468: PUSH
111469: LD_VAR 0 7
111473: ARRAY
111474: DIFF
111475: ST_TO_ADDR
// if group [ i ] in to_repair then
111476: LD_VAR 0 4
111480: PUSH
111481: LD_VAR 0 7
111485: ARRAY
111486: PUSH
111487: LD_VAR 0 32
111491: IN
111492: IFFALSE 111539
// begin if not IsInArea ( group [ i ] , f_repair ) then
111494: LD_VAR 0 4
111498: PUSH
111499: LD_VAR 0 7
111503: ARRAY
111504: PPUSH
111505: LD_VAR 0 22
111509: PPUSH
111510: CALL_OW 308
111514: NOT
111515: IFFALSE 111537
// ComMoveToArea ( group [ i ] , f_repair ) ;
111517: LD_VAR 0 4
111521: PUSH
111522: LD_VAR 0 7
111526: ARRAY
111527: PPUSH
111528: LD_VAR 0 22
111532: PPUSH
111533: CALL_OW 113
// continue ;
111537: GO 111164
// end ; end else
111539: GO 111819
// if group [ i ] in repairs then
111541: LD_VAR 0 4
111545: PUSH
111546: LD_VAR 0 7
111550: ARRAY
111551: PUSH
111552: LD_VAR 0 33
111556: IN
111557: IFFALSE 111819
// begin if IsInUnit ( group [ i ] ) then
111559: LD_VAR 0 4
111563: PUSH
111564: LD_VAR 0 7
111568: ARRAY
111569: PPUSH
111570: CALL_OW 310
111574: IFFALSE 111642
// begin z := IsInUnit ( group [ i ] ) ;
111576: LD_ADDR_VAR 0 13
111580: PUSH
111581: LD_VAR 0 4
111585: PUSH
111586: LD_VAR 0 7
111590: ARRAY
111591: PPUSH
111592: CALL_OW 310
111596: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111597: LD_VAR 0 13
111601: PUSH
111602: LD_VAR 0 32
111606: IN
111607: PUSH
111608: LD_VAR 0 13
111612: PPUSH
111613: LD_VAR 0 22
111617: PPUSH
111618: CALL_OW 308
111622: AND
111623: IFFALSE 111640
// ComExitVehicle ( group [ i ] ) ;
111625: LD_VAR 0 4
111629: PUSH
111630: LD_VAR 0 7
111634: ARRAY
111635: PPUSH
111636: CALL_OW 121
// end else
111640: GO 111819
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111642: LD_ADDR_VAR 0 13
111646: PUSH
111647: LD_VAR 0 4
111651: PPUSH
111652: LD_INT 95
111654: PUSH
111655: LD_VAR 0 22
111659: PUSH
111660: EMPTY
111661: LIST
111662: LIST
111663: PUSH
111664: LD_INT 58
111666: PUSH
111667: EMPTY
111668: LIST
111669: PUSH
111670: EMPTY
111671: LIST
111672: LIST
111673: PPUSH
111674: CALL_OW 72
111678: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111679: LD_VAR 0 4
111683: PUSH
111684: LD_VAR 0 7
111688: ARRAY
111689: PPUSH
111690: CALL_OW 314
111694: NOT
111695: IFFALSE 111817
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111697: LD_ADDR_VAR 0 10
111701: PUSH
111702: LD_VAR 0 13
111706: PPUSH
111707: LD_VAR 0 4
111711: PUSH
111712: LD_VAR 0 7
111716: ARRAY
111717: PPUSH
111718: CALL_OW 74
111722: ST_TO_ADDR
// if not x then
111723: LD_VAR 0 10
111727: NOT
111728: IFFALSE 111732
// continue ;
111730: GO 111164
// if GetLives ( x ) < 1000 then
111732: LD_VAR 0 10
111736: PPUSH
111737: CALL_OW 256
111741: PUSH
111742: LD_INT 1000
111744: LESS
111745: IFFALSE 111769
// ComRepairVehicle ( group [ i ] , x ) else
111747: LD_VAR 0 4
111751: PUSH
111752: LD_VAR 0 7
111756: ARRAY
111757: PPUSH
111758: LD_VAR 0 10
111762: PPUSH
111763: CALL_OW 129
111767: GO 111817
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111769: LD_VAR 0 23
111773: PUSH
111774: LD_VAR 0 4
111778: PUSH
111779: LD_VAR 0 7
111783: ARRAY
111784: PPUSH
111785: CALL_OW 256
111789: PUSH
111790: LD_INT 1000
111792: LESS
111793: AND
111794: NOT
111795: IFFALSE 111817
// ComEnterUnit ( group [ i ] , x ) ;
111797: LD_VAR 0 4
111801: PUSH
111802: LD_VAR 0 7
111806: ARRAY
111807: PPUSH
111808: LD_VAR 0 10
111812: PPUSH
111813: CALL_OW 120
// end ; continue ;
111817: GO 111164
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111819: LD_VAR 0 23
111823: PUSH
111824: LD_VAR 0 4
111828: PUSH
111829: LD_VAR 0 7
111833: ARRAY
111834: PPUSH
111835: CALL_OW 247
111839: PUSH
111840: LD_INT 1
111842: EQUAL
111843: AND
111844: IFFALSE 112322
// begin if group [ i ] in healers then
111846: LD_VAR 0 4
111850: PUSH
111851: LD_VAR 0 7
111855: ARRAY
111856: PUSH
111857: LD_VAR 0 31
111861: IN
111862: IFFALSE 112135
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111864: LD_VAR 0 4
111868: PUSH
111869: LD_VAR 0 7
111873: ARRAY
111874: PPUSH
111875: LD_VAR 0 23
111879: PPUSH
111880: CALL_OW 308
111884: NOT
111885: PUSH
111886: LD_VAR 0 4
111890: PUSH
111891: LD_VAR 0 7
111895: ARRAY
111896: PPUSH
111897: CALL_OW 314
111901: NOT
111902: AND
111903: IFFALSE 111927
// ComMoveToArea ( group [ i ] , f_heal ) else
111905: LD_VAR 0 4
111909: PUSH
111910: LD_VAR 0 7
111914: ARRAY
111915: PPUSH
111916: LD_VAR 0 23
111920: PPUSH
111921: CALL_OW 113
111925: GO 112133
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111927: LD_VAR 0 4
111931: PUSH
111932: LD_VAR 0 7
111936: ARRAY
111937: PPUSH
111938: CALL 51506 0 1
111942: PPUSH
111943: CALL_OW 256
111947: PUSH
111948: LD_INT 1000
111950: EQUAL
111951: IFFALSE 111970
// ComStop ( group [ i ] ) else
111953: LD_VAR 0 4
111957: PUSH
111958: LD_VAR 0 7
111962: ARRAY
111963: PPUSH
111964: CALL_OW 141
111968: GO 112133
// if not HasTask ( group [ i ] ) and to_heal then
111970: LD_VAR 0 4
111974: PUSH
111975: LD_VAR 0 7
111979: ARRAY
111980: PPUSH
111981: CALL_OW 314
111985: NOT
111986: PUSH
111987: LD_VAR 0 30
111991: AND
111992: IFFALSE 112133
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111994: LD_ADDR_VAR 0 13
111998: PUSH
111999: LD_VAR 0 30
112003: PPUSH
112004: LD_INT 3
112006: PUSH
112007: LD_INT 54
112009: PUSH
112010: EMPTY
112011: LIST
112012: PUSH
112013: EMPTY
112014: LIST
112015: LIST
112016: PPUSH
112017: CALL_OW 72
112021: PPUSH
112022: LD_VAR 0 4
112026: PUSH
112027: LD_VAR 0 7
112031: ARRAY
112032: PPUSH
112033: CALL_OW 74
112037: ST_TO_ADDR
// if z then
112038: LD_VAR 0 13
112042: IFFALSE 112133
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112044: LD_INT 91
112046: PUSH
112047: LD_VAR 0 13
112051: PUSH
112052: LD_INT 10
112054: PUSH
112055: EMPTY
112056: LIST
112057: LIST
112058: LIST
112059: PUSH
112060: LD_INT 81
112062: PUSH
112063: LD_VAR 0 13
112067: PPUSH
112068: CALL_OW 255
112072: PUSH
112073: EMPTY
112074: LIST
112075: LIST
112076: PUSH
112077: EMPTY
112078: LIST
112079: LIST
112080: PPUSH
112081: CALL_OW 69
112085: PUSH
112086: LD_INT 0
112088: EQUAL
112089: IFFALSE 112113
// ComHeal ( group [ i ] , z ) else
112091: LD_VAR 0 4
112095: PUSH
112096: LD_VAR 0 7
112100: ARRAY
112101: PPUSH
112102: LD_VAR 0 13
112106: PPUSH
112107: CALL_OW 128
112111: GO 112133
// ComMoveToArea ( group [ i ] , f_heal ) ;
112113: LD_VAR 0 4
112117: PUSH
112118: LD_VAR 0 7
112122: ARRAY
112123: PPUSH
112124: LD_VAR 0 23
112128: PPUSH
112129: CALL_OW 113
// end ; continue ;
112133: GO 111164
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112135: LD_VAR 0 4
112139: PUSH
112140: LD_VAR 0 7
112144: ARRAY
112145: PPUSH
112146: CALL_OW 256
112150: PUSH
112151: LD_INT 700
112153: LESS
112154: PUSH
112155: LD_VAR 0 4
112159: PUSH
112160: LD_VAR 0 7
112164: ARRAY
112165: PUSH
112166: LD_VAR 0 30
112170: IN
112171: NOT
112172: AND
112173: IFFALSE 112197
// to_heal := to_heal union group [ i ] ;
112175: LD_ADDR_VAR 0 30
112179: PUSH
112180: LD_VAR 0 30
112184: PUSH
112185: LD_VAR 0 4
112189: PUSH
112190: LD_VAR 0 7
112194: ARRAY
112195: UNION
112196: ST_TO_ADDR
// if group [ i ] in to_heal then
112197: LD_VAR 0 4
112201: PUSH
112202: LD_VAR 0 7
112206: ARRAY
112207: PUSH
112208: LD_VAR 0 30
112212: IN
112213: IFFALSE 112322
// begin if GetLives ( group [ i ] ) = 1000 then
112215: LD_VAR 0 4
112219: PUSH
112220: LD_VAR 0 7
112224: ARRAY
112225: PPUSH
112226: CALL_OW 256
112230: PUSH
112231: LD_INT 1000
112233: EQUAL
112234: IFFALSE 112260
// to_heal := to_heal diff group [ i ] else
112236: LD_ADDR_VAR 0 30
112240: PUSH
112241: LD_VAR 0 30
112245: PUSH
112246: LD_VAR 0 4
112250: PUSH
112251: LD_VAR 0 7
112255: ARRAY
112256: DIFF
112257: ST_TO_ADDR
112258: GO 112322
// begin if not IsInArea ( group [ i ] , to_heal ) then
112260: LD_VAR 0 4
112264: PUSH
112265: LD_VAR 0 7
112269: ARRAY
112270: PPUSH
112271: LD_VAR 0 30
112275: PPUSH
112276: CALL_OW 308
112280: NOT
112281: IFFALSE 112305
// ComMoveToArea ( group [ i ] , f_heal ) else
112283: LD_VAR 0 4
112287: PUSH
112288: LD_VAR 0 7
112292: ARRAY
112293: PPUSH
112294: LD_VAR 0 23
112298: PPUSH
112299: CALL_OW 113
112303: GO 112320
// ComHold ( group [ i ] ) ;
112305: LD_VAR 0 4
112309: PUSH
112310: LD_VAR 0 7
112314: ARRAY
112315: PPUSH
112316: CALL_OW 140
// continue ;
112320: GO 111164
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112322: LD_VAR 0 4
112326: PUSH
112327: LD_VAR 0 7
112331: ARRAY
112332: PPUSH
112333: LD_INT 10
112335: PPUSH
112336: CALL 49288 0 2
112340: NOT
112341: PUSH
112342: LD_VAR 0 16
112346: PUSH
112347: LD_VAR 0 7
112351: ARRAY
112352: PUSH
112353: EMPTY
112354: EQUAL
112355: NOT
112356: AND
112357: IFFALSE 112623
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112359: LD_VAR 0 4
112363: PUSH
112364: LD_VAR 0 7
112368: ARRAY
112369: PPUSH
112370: CALL_OW 262
112374: PUSH
112375: LD_INT 1
112377: PUSH
112378: LD_INT 2
112380: PUSH
112381: EMPTY
112382: LIST
112383: LIST
112384: IN
112385: IFFALSE 112426
// if GetFuel ( group [ i ] ) < 10 then
112387: LD_VAR 0 4
112391: PUSH
112392: LD_VAR 0 7
112396: ARRAY
112397: PPUSH
112398: CALL_OW 261
112402: PUSH
112403: LD_INT 10
112405: LESS
112406: IFFALSE 112426
// SetFuel ( group [ i ] , 12 ) ;
112408: LD_VAR 0 4
112412: PUSH
112413: LD_VAR 0 7
112417: ARRAY
112418: PPUSH
112419: LD_INT 12
112421: PPUSH
112422: CALL_OW 240
// if units_path [ i ] then
112426: LD_VAR 0 16
112430: PUSH
112431: LD_VAR 0 7
112435: ARRAY
112436: IFFALSE 112621
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112438: LD_VAR 0 4
112442: PUSH
112443: LD_VAR 0 7
112447: ARRAY
112448: PPUSH
112449: LD_VAR 0 16
112453: PUSH
112454: LD_VAR 0 7
112458: ARRAY
112459: PUSH
112460: LD_INT 1
112462: ARRAY
112463: PUSH
112464: LD_INT 1
112466: ARRAY
112467: PPUSH
112468: LD_VAR 0 16
112472: PUSH
112473: LD_VAR 0 7
112477: ARRAY
112478: PUSH
112479: LD_INT 1
112481: ARRAY
112482: PUSH
112483: LD_INT 2
112485: ARRAY
112486: PPUSH
112487: CALL_OW 297
112491: PUSH
112492: LD_INT 6
112494: GREATER
112495: IFFALSE 112570
// begin if not HasTask ( group [ i ] ) then
112497: LD_VAR 0 4
112501: PUSH
112502: LD_VAR 0 7
112506: ARRAY
112507: PPUSH
112508: CALL_OW 314
112512: NOT
112513: IFFALSE 112568
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112515: LD_VAR 0 4
112519: PUSH
112520: LD_VAR 0 7
112524: ARRAY
112525: PPUSH
112526: LD_VAR 0 16
112530: PUSH
112531: LD_VAR 0 7
112535: ARRAY
112536: PUSH
112537: LD_INT 1
112539: ARRAY
112540: PUSH
112541: LD_INT 1
112543: ARRAY
112544: PPUSH
112545: LD_VAR 0 16
112549: PUSH
112550: LD_VAR 0 7
112554: ARRAY
112555: PUSH
112556: LD_INT 1
112558: ARRAY
112559: PUSH
112560: LD_INT 2
112562: ARRAY
112563: PPUSH
112564: CALL_OW 114
// end else
112568: GO 112621
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112570: LD_ADDR_VAR 0 15
112574: PUSH
112575: LD_VAR 0 16
112579: PUSH
112580: LD_VAR 0 7
112584: ARRAY
112585: PPUSH
112586: LD_INT 1
112588: PPUSH
112589: CALL_OW 3
112593: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112594: LD_ADDR_VAR 0 16
112598: PUSH
112599: LD_VAR 0 16
112603: PPUSH
112604: LD_VAR 0 7
112608: PPUSH
112609: LD_VAR 0 15
112613: PPUSH
112614: CALL_OW 1
112618: ST_TO_ADDR
// continue ;
112619: GO 111164
// end ; end ; end else
112621: GO 115285
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112623: LD_ADDR_VAR 0 14
112627: PUSH
112628: LD_INT 81
112630: PUSH
112631: LD_VAR 0 4
112635: PUSH
112636: LD_VAR 0 7
112640: ARRAY
112641: PPUSH
112642: CALL_OW 255
112646: PUSH
112647: EMPTY
112648: LIST
112649: LIST
112650: PPUSH
112651: CALL_OW 69
112655: ST_TO_ADDR
// if not tmp then
112656: LD_VAR 0 14
112660: NOT
112661: IFFALSE 112665
// continue ;
112663: GO 111164
// if f_ignore_area then
112665: LD_VAR 0 17
112669: IFFALSE 112757
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112671: LD_ADDR_VAR 0 15
112675: PUSH
112676: LD_VAR 0 14
112680: PPUSH
112681: LD_INT 3
112683: PUSH
112684: LD_INT 92
112686: PUSH
112687: LD_VAR 0 17
112691: PUSH
112692: LD_INT 1
112694: ARRAY
112695: PUSH
112696: LD_VAR 0 17
112700: PUSH
112701: LD_INT 2
112703: ARRAY
112704: PUSH
112705: LD_VAR 0 17
112709: PUSH
112710: LD_INT 3
112712: ARRAY
112713: PUSH
112714: EMPTY
112715: LIST
112716: LIST
112717: LIST
112718: LIST
112719: PUSH
112720: EMPTY
112721: LIST
112722: LIST
112723: PPUSH
112724: CALL_OW 72
112728: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112729: LD_VAR 0 14
112733: PUSH
112734: LD_VAR 0 15
112738: DIFF
112739: IFFALSE 112757
// tmp := tmp diff tmp2 ;
112741: LD_ADDR_VAR 0 14
112745: PUSH
112746: LD_VAR 0 14
112750: PUSH
112751: LD_VAR 0 15
112755: DIFF
112756: ST_TO_ADDR
// end ; if not f_murder then
112757: LD_VAR 0 20
112761: NOT
112762: IFFALSE 112820
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112764: LD_ADDR_VAR 0 15
112768: PUSH
112769: LD_VAR 0 14
112773: PPUSH
112774: LD_INT 3
112776: PUSH
112777: LD_INT 50
112779: PUSH
112780: EMPTY
112781: LIST
112782: PUSH
112783: EMPTY
112784: LIST
112785: LIST
112786: PPUSH
112787: CALL_OW 72
112791: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112792: LD_VAR 0 14
112796: PUSH
112797: LD_VAR 0 15
112801: DIFF
112802: IFFALSE 112820
// tmp := tmp diff tmp2 ;
112804: LD_ADDR_VAR 0 14
112808: PUSH
112809: LD_VAR 0 14
112813: PUSH
112814: LD_VAR 0 15
112818: DIFF
112819: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112820: LD_ADDR_VAR 0 14
112824: PUSH
112825: LD_VAR 0 4
112829: PUSH
112830: LD_VAR 0 7
112834: ARRAY
112835: PPUSH
112836: LD_VAR 0 14
112840: PPUSH
112841: LD_INT 1
112843: PPUSH
112844: LD_INT 1
112846: PPUSH
112847: CALL 21832 0 4
112851: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112852: LD_VAR 0 4
112856: PUSH
112857: LD_VAR 0 7
112861: ARRAY
112862: PPUSH
112863: CALL_OW 257
112867: PUSH
112868: LD_INT 1
112870: EQUAL
112871: IFFALSE 113319
// begin if WantPlant ( group [ i ] ) then
112873: LD_VAR 0 4
112877: PUSH
112878: LD_VAR 0 7
112882: ARRAY
112883: PPUSH
112884: CALL 21333 0 1
112888: IFFALSE 112892
// continue ;
112890: GO 111164
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112892: LD_VAR 0 18
112896: PUSH
112897: LD_VAR 0 4
112901: PUSH
112902: LD_VAR 0 7
112906: ARRAY
112907: PPUSH
112908: CALL_OW 310
112912: NOT
112913: AND
112914: PUSH
112915: LD_VAR 0 14
112919: PUSH
112920: LD_INT 1
112922: ARRAY
112923: PUSH
112924: LD_VAR 0 14
112928: PPUSH
112929: LD_INT 21
112931: PUSH
112932: LD_INT 2
112934: PUSH
112935: EMPTY
112936: LIST
112937: LIST
112938: PUSH
112939: LD_INT 58
112941: PUSH
112942: EMPTY
112943: LIST
112944: PUSH
112945: EMPTY
112946: LIST
112947: LIST
112948: PPUSH
112949: CALL_OW 72
112953: IN
112954: AND
112955: IFFALSE 112991
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112957: LD_VAR 0 4
112961: PUSH
112962: LD_VAR 0 7
112966: ARRAY
112967: PPUSH
112968: LD_VAR 0 14
112972: PUSH
112973: LD_INT 1
112975: ARRAY
112976: PPUSH
112977: CALL_OW 120
// attacking := true ;
112981: LD_ADDR_VAR 0 29
112985: PUSH
112986: LD_INT 1
112988: ST_TO_ADDR
// continue ;
112989: GO 111164
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112991: LD_VAR 0 26
112995: PUSH
112996: LD_VAR 0 4
113000: PUSH
113001: LD_VAR 0 7
113005: ARRAY
113006: PPUSH
113007: CALL_OW 257
113011: PUSH
113012: LD_INT 1
113014: EQUAL
113015: AND
113016: PUSH
113017: LD_VAR 0 4
113021: PUSH
113022: LD_VAR 0 7
113026: ARRAY
113027: PPUSH
113028: CALL_OW 256
113032: PUSH
113033: LD_INT 800
113035: LESS
113036: AND
113037: PUSH
113038: LD_VAR 0 4
113042: PUSH
113043: LD_VAR 0 7
113047: ARRAY
113048: PPUSH
113049: CALL_OW 318
113053: NOT
113054: AND
113055: IFFALSE 113072
// ComCrawl ( group [ i ] ) ;
113057: LD_VAR 0 4
113061: PUSH
113062: LD_VAR 0 7
113066: ARRAY
113067: PPUSH
113068: CALL_OW 137
// if f_mines then
113072: LD_VAR 0 21
113076: IFFALSE 113319
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113078: LD_VAR 0 14
113082: PUSH
113083: LD_INT 1
113085: ARRAY
113086: PPUSH
113087: CALL_OW 247
113091: PUSH
113092: LD_INT 3
113094: EQUAL
113095: PUSH
113096: LD_VAR 0 14
113100: PUSH
113101: LD_INT 1
113103: ARRAY
113104: PUSH
113105: LD_VAR 0 27
113109: IN
113110: NOT
113111: AND
113112: IFFALSE 113319
// begin x := GetX ( tmp [ 1 ] ) ;
113114: LD_ADDR_VAR 0 10
113118: PUSH
113119: LD_VAR 0 14
113123: PUSH
113124: LD_INT 1
113126: ARRAY
113127: PPUSH
113128: CALL_OW 250
113132: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113133: LD_ADDR_VAR 0 11
113137: PUSH
113138: LD_VAR 0 14
113142: PUSH
113143: LD_INT 1
113145: ARRAY
113146: PPUSH
113147: CALL_OW 251
113151: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113152: LD_ADDR_VAR 0 12
113156: PUSH
113157: LD_VAR 0 4
113161: PUSH
113162: LD_VAR 0 7
113166: ARRAY
113167: PPUSH
113168: CALL 49373 0 1
113172: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113173: LD_VAR 0 4
113177: PUSH
113178: LD_VAR 0 7
113182: ARRAY
113183: PPUSH
113184: LD_VAR 0 10
113188: PPUSH
113189: LD_VAR 0 11
113193: PPUSH
113194: LD_VAR 0 14
113198: PUSH
113199: LD_INT 1
113201: ARRAY
113202: PPUSH
113203: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113207: LD_VAR 0 4
113211: PUSH
113212: LD_VAR 0 7
113216: ARRAY
113217: PPUSH
113218: LD_VAR 0 10
113222: PPUSH
113223: LD_VAR 0 12
113227: PPUSH
113228: LD_INT 7
113230: PPUSH
113231: CALL_OW 272
113235: PPUSH
113236: LD_VAR 0 11
113240: PPUSH
113241: LD_VAR 0 12
113245: PPUSH
113246: LD_INT 7
113248: PPUSH
113249: CALL_OW 273
113253: PPUSH
113254: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113258: LD_VAR 0 4
113262: PUSH
113263: LD_VAR 0 7
113267: ARRAY
113268: PPUSH
113269: LD_INT 71
113271: PPUSH
113272: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113276: LD_ADDR_VAR 0 27
113280: PUSH
113281: LD_VAR 0 27
113285: PPUSH
113286: LD_VAR 0 27
113290: PUSH
113291: LD_INT 1
113293: PLUS
113294: PPUSH
113295: LD_VAR 0 14
113299: PUSH
113300: LD_INT 1
113302: ARRAY
113303: PPUSH
113304: CALL_OW 1
113308: ST_TO_ADDR
// attacking := true ;
113309: LD_ADDR_VAR 0 29
113313: PUSH
113314: LD_INT 1
113316: ST_TO_ADDR
// continue ;
113317: GO 111164
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113319: LD_VAR 0 4
113323: PUSH
113324: LD_VAR 0 7
113328: ARRAY
113329: PPUSH
113330: CALL_OW 257
113334: PUSH
113335: LD_INT 17
113337: EQUAL
113338: PUSH
113339: LD_VAR 0 4
113343: PUSH
113344: LD_VAR 0 7
113348: ARRAY
113349: PPUSH
113350: CALL_OW 110
113354: PUSH
113355: LD_INT 71
113357: EQUAL
113358: NOT
113359: AND
113360: IFFALSE 113506
// begin attacking := false ;
113362: LD_ADDR_VAR 0 29
113366: PUSH
113367: LD_INT 0
113369: ST_TO_ADDR
// k := 5 ;
113370: LD_ADDR_VAR 0 9
113374: PUSH
113375: LD_INT 5
113377: ST_TO_ADDR
// if tmp < k then
113378: LD_VAR 0 14
113382: PUSH
113383: LD_VAR 0 9
113387: LESS
113388: IFFALSE 113400
// k := tmp ;
113390: LD_ADDR_VAR 0 9
113394: PUSH
113395: LD_VAR 0 14
113399: ST_TO_ADDR
// for j = 1 to k do
113400: LD_ADDR_VAR 0 8
113404: PUSH
113405: DOUBLE
113406: LD_INT 1
113408: DEC
113409: ST_TO_ADDR
113410: LD_VAR 0 9
113414: PUSH
113415: FOR_TO
113416: IFFALSE 113504
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113418: LD_VAR 0 14
113422: PUSH
113423: LD_VAR 0 8
113427: ARRAY
113428: PUSH
113429: LD_VAR 0 14
113433: PPUSH
113434: LD_INT 58
113436: PUSH
113437: EMPTY
113438: LIST
113439: PPUSH
113440: CALL_OW 72
113444: IN
113445: NOT
113446: IFFALSE 113502
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113448: LD_VAR 0 4
113452: PUSH
113453: LD_VAR 0 7
113457: ARRAY
113458: PPUSH
113459: LD_VAR 0 14
113463: PUSH
113464: LD_VAR 0 8
113468: ARRAY
113469: PPUSH
113470: CALL_OW 115
// attacking := true ;
113474: LD_ADDR_VAR 0 29
113478: PUSH
113479: LD_INT 1
113481: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113482: LD_VAR 0 4
113486: PUSH
113487: LD_VAR 0 7
113491: ARRAY
113492: PPUSH
113493: LD_INT 71
113495: PPUSH
113496: CALL_OW 109
// continue ;
113500: GO 113415
// end ; end ;
113502: GO 113415
113504: POP
113505: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113506: LD_VAR 0 4
113510: PUSH
113511: LD_VAR 0 7
113515: ARRAY
113516: PPUSH
113517: CALL_OW 257
113521: PUSH
113522: LD_INT 8
113524: EQUAL
113525: PUSH
113526: LD_VAR 0 4
113530: PUSH
113531: LD_VAR 0 7
113535: ARRAY
113536: PPUSH
113537: CALL_OW 264
113541: PUSH
113542: LD_INT 28
113544: PUSH
113545: LD_INT 45
113547: PUSH
113548: LD_INT 7
113550: PUSH
113551: LD_INT 47
113553: PUSH
113554: EMPTY
113555: LIST
113556: LIST
113557: LIST
113558: LIST
113559: IN
113560: OR
113561: IFFALSE 113817
// begin attacking := false ;
113563: LD_ADDR_VAR 0 29
113567: PUSH
113568: LD_INT 0
113570: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113571: LD_VAR 0 14
113575: PUSH
113576: LD_INT 1
113578: ARRAY
113579: PPUSH
113580: CALL_OW 266
113584: PUSH
113585: LD_INT 32
113587: PUSH
113588: LD_INT 31
113590: PUSH
113591: LD_INT 33
113593: PUSH
113594: LD_INT 4
113596: PUSH
113597: LD_INT 5
113599: PUSH
113600: EMPTY
113601: LIST
113602: LIST
113603: LIST
113604: LIST
113605: LIST
113606: IN
113607: IFFALSE 113793
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113609: LD_ADDR_VAR 0 9
113613: PUSH
113614: LD_VAR 0 14
113618: PUSH
113619: LD_INT 1
113621: ARRAY
113622: PPUSH
113623: CALL_OW 266
113627: PPUSH
113628: LD_VAR 0 14
113632: PUSH
113633: LD_INT 1
113635: ARRAY
113636: PPUSH
113637: CALL_OW 250
113641: PPUSH
113642: LD_VAR 0 14
113646: PUSH
113647: LD_INT 1
113649: ARRAY
113650: PPUSH
113651: CALL_OW 251
113655: PPUSH
113656: LD_VAR 0 14
113660: PUSH
113661: LD_INT 1
113663: ARRAY
113664: PPUSH
113665: CALL_OW 254
113669: PPUSH
113670: LD_VAR 0 14
113674: PUSH
113675: LD_INT 1
113677: ARRAY
113678: PPUSH
113679: CALL_OW 248
113683: PPUSH
113684: LD_INT 0
113686: PPUSH
113687: CALL 30743 0 6
113691: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113692: LD_ADDR_VAR 0 8
113696: PUSH
113697: LD_VAR 0 4
113701: PUSH
113702: LD_VAR 0 7
113706: ARRAY
113707: PPUSH
113708: LD_VAR 0 9
113712: PPUSH
113713: CALL 49486 0 2
113717: ST_TO_ADDR
// if j then
113718: LD_VAR 0 8
113722: IFFALSE 113791
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113724: LD_VAR 0 8
113728: PUSH
113729: LD_INT 1
113731: ARRAY
113732: PPUSH
113733: LD_VAR 0 8
113737: PUSH
113738: LD_INT 2
113740: ARRAY
113741: PPUSH
113742: CALL_OW 488
113746: IFFALSE 113791
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113748: LD_VAR 0 4
113752: PUSH
113753: LD_VAR 0 7
113757: ARRAY
113758: PPUSH
113759: LD_VAR 0 8
113763: PUSH
113764: LD_INT 1
113766: ARRAY
113767: PPUSH
113768: LD_VAR 0 8
113772: PUSH
113773: LD_INT 2
113775: ARRAY
113776: PPUSH
113777: CALL_OW 116
// attacking := true ;
113781: LD_ADDR_VAR 0 29
113785: PUSH
113786: LD_INT 1
113788: ST_TO_ADDR
// continue ;
113789: GO 111164
// end ; end else
113791: GO 113817
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113793: LD_VAR 0 4
113797: PUSH
113798: LD_VAR 0 7
113802: ARRAY
113803: PPUSH
113804: LD_VAR 0 14
113808: PUSH
113809: LD_INT 1
113811: ARRAY
113812: PPUSH
113813: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113817: LD_VAR 0 4
113821: PUSH
113822: LD_VAR 0 7
113826: ARRAY
113827: PPUSH
113828: CALL_OW 265
113832: PUSH
113833: LD_INT 11
113835: EQUAL
113836: IFFALSE 114114
// begin k := 10 ;
113838: LD_ADDR_VAR 0 9
113842: PUSH
113843: LD_INT 10
113845: ST_TO_ADDR
// x := 0 ;
113846: LD_ADDR_VAR 0 10
113850: PUSH
113851: LD_INT 0
113853: ST_TO_ADDR
// if tmp < k then
113854: LD_VAR 0 14
113858: PUSH
113859: LD_VAR 0 9
113863: LESS
113864: IFFALSE 113876
// k := tmp ;
113866: LD_ADDR_VAR 0 9
113870: PUSH
113871: LD_VAR 0 14
113875: ST_TO_ADDR
// for j = k downto 1 do
113876: LD_ADDR_VAR 0 8
113880: PUSH
113881: DOUBLE
113882: LD_VAR 0 9
113886: INC
113887: ST_TO_ADDR
113888: LD_INT 1
113890: PUSH
113891: FOR_DOWNTO
113892: IFFALSE 113967
// begin if GetType ( tmp [ j ] ) = unit_human then
113894: LD_VAR 0 14
113898: PUSH
113899: LD_VAR 0 8
113903: ARRAY
113904: PPUSH
113905: CALL_OW 247
113909: PUSH
113910: LD_INT 1
113912: EQUAL
113913: IFFALSE 113965
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113915: LD_VAR 0 4
113919: PUSH
113920: LD_VAR 0 7
113924: ARRAY
113925: PPUSH
113926: LD_VAR 0 14
113930: PUSH
113931: LD_VAR 0 8
113935: ARRAY
113936: PPUSH
113937: CALL 49740 0 2
// x := tmp [ j ] ;
113941: LD_ADDR_VAR 0 10
113945: PUSH
113946: LD_VAR 0 14
113950: PUSH
113951: LD_VAR 0 8
113955: ARRAY
113956: ST_TO_ADDR
// attacking := true ;
113957: LD_ADDR_VAR 0 29
113961: PUSH
113962: LD_INT 1
113964: ST_TO_ADDR
// end ; end ;
113965: GO 113891
113967: POP
113968: POP
// if not x then
113969: LD_VAR 0 10
113973: NOT
113974: IFFALSE 114114
// begin attacking := true ;
113976: LD_ADDR_VAR 0 29
113980: PUSH
113981: LD_INT 1
113983: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113984: LD_VAR 0 4
113988: PUSH
113989: LD_VAR 0 7
113993: ARRAY
113994: PPUSH
113995: CALL_OW 250
113999: PPUSH
114000: LD_VAR 0 4
114004: PUSH
114005: LD_VAR 0 7
114009: ARRAY
114010: PPUSH
114011: CALL_OW 251
114015: PPUSH
114016: CALL_OW 546
114020: PUSH
114021: LD_INT 2
114023: ARRAY
114024: PUSH
114025: LD_VAR 0 14
114029: PUSH
114030: LD_INT 1
114032: ARRAY
114033: PPUSH
114034: CALL_OW 250
114038: PPUSH
114039: LD_VAR 0 14
114043: PUSH
114044: LD_INT 1
114046: ARRAY
114047: PPUSH
114048: CALL_OW 251
114052: PPUSH
114053: CALL_OW 546
114057: PUSH
114058: LD_INT 2
114060: ARRAY
114061: EQUAL
114062: IFFALSE 114090
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114064: LD_VAR 0 4
114068: PUSH
114069: LD_VAR 0 7
114073: ARRAY
114074: PPUSH
114075: LD_VAR 0 14
114079: PUSH
114080: LD_INT 1
114082: ARRAY
114083: PPUSH
114084: CALL 49740 0 2
114088: GO 114114
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114090: LD_VAR 0 4
114094: PUSH
114095: LD_VAR 0 7
114099: ARRAY
114100: PPUSH
114101: LD_VAR 0 14
114105: PUSH
114106: LD_INT 1
114108: ARRAY
114109: PPUSH
114110: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114114: LD_VAR 0 4
114118: PUSH
114119: LD_VAR 0 7
114123: ARRAY
114124: PPUSH
114125: CALL_OW 264
114129: PUSH
114130: LD_INT 29
114132: EQUAL
114133: IFFALSE 114499
// begin if WantsToAttack ( group [ i ] ) in bombed then
114135: LD_VAR 0 4
114139: PUSH
114140: LD_VAR 0 7
114144: ARRAY
114145: PPUSH
114146: CALL_OW 319
114150: PUSH
114151: LD_VAR 0 28
114155: IN
114156: IFFALSE 114160
// continue ;
114158: GO 111164
// k := 8 ;
114160: LD_ADDR_VAR 0 9
114164: PUSH
114165: LD_INT 8
114167: ST_TO_ADDR
// x := 0 ;
114168: LD_ADDR_VAR 0 10
114172: PUSH
114173: LD_INT 0
114175: ST_TO_ADDR
// if tmp < k then
114176: LD_VAR 0 14
114180: PUSH
114181: LD_VAR 0 9
114185: LESS
114186: IFFALSE 114198
// k := tmp ;
114188: LD_ADDR_VAR 0 9
114192: PUSH
114193: LD_VAR 0 14
114197: ST_TO_ADDR
// for j = 1 to k do
114198: LD_ADDR_VAR 0 8
114202: PUSH
114203: DOUBLE
114204: LD_INT 1
114206: DEC
114207: ST_TO_ADDR
114208: LD_VAR 0 9
114212: PUSH
114213: FOR_TO
114214: IFFALSE 114346
// begin if GetType ( tmp [ j ] ) = unit_building then
114216: LD_VAR 0 14
114220: PUSH
114221: LD_VAR 0 8
114225: ARRAY
114226: PPUSH
114227: CALL_OW 247
114231: PUSH
114232: LD_INT 3
114234: EQUAL
114235: IFFALSE 114344
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114237: LD_VAR 0 14
114241: PUSH
114242: LD_VAR 0 8
114246: ARRAY
114247: PUSH
114248: LD_VAR 0 28
114252: IN
114253: NOT
114254: PUSH
114255: LD_VAR 0 14
114259: PUSH
114260: LD_VAR 0 8
114264: ARRAY
114265: PPUSH
114266: CALL_OW 313
114270: AND
114271: IFFALSE 114344
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114273: LD_VAR 0 4
114277: PUSH
114278: LD_VAR 0 7
114282: ARRAY
114283: PPUSH
114284: LD_VAR 0 14
114288: PUSH
114289: LD_VAR 0 8
114293: ARRAY
114294: PPUSH
114295: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114299: LD_ADDR_VAR 0 28
114303: PUSH
114304: LD_VAR 0 28
114308: PPUSH
114309: LD_VAR 0 28
114313: PUSH
114314: LD_INT 1
114316: PLUS
114317: PPUSH
114318: LD_VAR 0 14
114322: PUSH
114323: LD_VAR 0 8
114327: ARRAY
114328: PPUSH
114329: CALL_OW 1
114333: ST_TO_ADDR
// attacking := true ;
114334: LD_ADDR_VAR 0 29
114338: PUSH
114339: LD_INT 1
114341: ST_TO_ADDR
// break ;
114342: GO 114346
// end ; end ;
114344: GO 114213
114346: POP
114347: POP
// if not attacking and f_attack_depot then
114348: LD_VAR 0 29
114352: NOT
114353: PUSH
114354: LD_VAR 0 25
114358: AND
114359: IFFALSE 114454
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114361: LD_ADDR_VAR 0 13
114365: PUSH
114366: LD_VAR 0 14
114370: PPUSH
114371: LD_INT 2
114373: PUSH
114374: LD_INT 30
114376: PUSH
114377: LD_INT 0
114379: PUSH
114380: EMPTY
114381: LIST
114382: LIST
114383: PUSH
114384: LD_INT 30
114386: PUSH
114387: LD_INT 1
114389: PUSH
114390: EMPTY
114391: LIST
114392: LIST
114393: PUSH
114394: EMPTY
114395: LIST
114396: LIST
114397: LIST
114398: PPUSH
114399: CALL_OW 72
114403: ST_TO_ADDR
// if z then
114404: LD_VAR 0 13
114408: IFFALSE 114454
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114410: LD_VAR 0 4
114414: PUSH
114415: LD_VAR 0 7
114419: ARRAY
114420: PPUSH
114421: LD_VAR 0 13
114425: PPUSH
114426: LD_VAR 0 4
114430: PUSH
114431: LD_VAR 0 7
114435: ARRAY
114436: PPUSH
114437: CALL_OW 74
114441: PPUSH
114442: CALL_OW 115
// attacking := true ;
114446: LD_ADDR_VAR 0 29
114450: PUSH
114451: LD_INT 1
114453: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114454: LD_VAR 0 4
114458: PUSH
114459: LD_VAR 0 7
114463: ARRAY
114464: PPUSH
114465: CALL_OW 256
114469: PUSH
114470: LD_INT 500
114472: LESS
114473: IFFALSE 114499
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114475: LD_VAR 0 4
114479: PUSH
114480: LD_VAR 0 7
114484: ARRAY
114485: PPUSH
114486: LD_VAR 0 14
114490: PUSH
114491: LD_INT 1
114493: ARRAY
114494: PPUSH
114495: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114499: LD_VAR 0 4
114503: PUSH
114504: LD_VAR 0 7
114508: ARRAY
114509: PPUSH
114510: CALL_OW 264
114514: PUSH
114515: LD_INT 49
114517: EQUAL
114518: IFFALSE 114639
// begin if not HasTask ( group [ i ] ) then
114520: LD_VAR 0 4
114524: PUSH
114525: LD_VAR 0 7
114529: ARRAY
114530: PPUSH
114531: CALL_OW 314
114535: NOT
114536: IFFALSE 114639
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114538: LD_ADDR_VAR 0 9
114542: PUSH
114543: LD_INT 81
114545: PUSH
114546: LD_VAR 0 4
114550: PUSH
114551: LD_VAR 0 7
114555: ARRAY
114556: PPUSH
114557: CALL_OW 255
114561: PUSH
114562: EMPTY
114563: LIST
114564: LIST
114565: PPUSH
114566: CALL_OW 69
114570: PPUSH
114571: LD_VAR 0 4
114575: PUSH
114576: LD_VAR 0 7
114580: ARRAY
114581: PPUSH
114582: CALL_OW 74
114586: ST_TO_ADDR
// if k then
114587: LD_VAR 0 9
114591: IFFALSE 114639
// if GetDistUnits ( group [ i ] , k ) > 10 then
114593: LD_VAR 0 4
114597: PUSH
114598: LD_VAR 0 7
114602: ARRAY
114603: PPUSH
114604: LD_VAR 0 9
114608: PPUSH
114609: CALL_OW 296
114613: PUSH
114614: LD_INT 10
114616: GREATER
114617: IFFALSE 114639
// ComMoveUnit ( group [ i ] , k ) ;
114619: LD_VAR 0 4
114623: PUSH
114624: LD_VAR 0 7
114628: ARRAY
114629: PPUSH
114630: LD_VAR 0 9
114634: PPUSH
114635: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114639: LD_VAR 0 4
114643: PUSH
114644: LD_VAR 0 7
114648: ARRAY
114649: PPUSH
114650: CALL_OW 256
114654: PUSH
114655: LD_INT 250
114657: LESS
114658: PUSH
114659: LD_VAR 0 4
114663: PUSH
114664: LD_VAR 0 7
114668: ARRAY
114669: PUSH
114670: LD_INT 21
114672: PUSH
114673: LD_INT 2
114675: PUSH
114676: EMPTY
114677: LIST
114678: LIST
114679: PUSH
114680: LD_INT 23
114682: PUSH
114683: LD_INT 2
114685: PUSH
114686: EMPTY
114687: LIST
114688: LIST
114689: PUSH
114690: EMPTY
114691: LIST
114692: LIST
114693: PPUSH
114694: CALL_OW 69
114698: IN
114699: AND
114700: IFFALSE 114825
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114702: LD_ADDR_VAR 0 9
114706: PUSH
114707: LD_OWVAR 3
114711: PUSH
114712: LD_VAR 0 4
114716: PUSH
114717: LD_VAR 0 7
114721: ARRAY
114722: DIFF
114723: PPUSH
114724: LD_VAR 0 4
114728: PUSH
114729: LD_VAR 0 7
114733: ARRAY
114734: PPUSH
114735: CALL_OW 74
114739: ST_TO_ADDR
// if not k then
114740: LD_VAR 0 9
114744: NOT
114745: IFFALSE 114749
// continue ;
114747: GO 111164
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114749: LD_VAR 0 9
114753: PUSH
114754: LD_INT 81
114756: PUSH
114757: LD_VAR 0 4
114761: PUSH
114762: LD_VAR 0 7
114766: ARRAY
114767: PPUSH
114768: CALL_OW 255
114772: PUSH
114773: EMPTY
114774: LIST
114775: LIST
114776: PPUSH
114777: CALL_OW 69
114781: IN
114782: PUSH
114783: LD_VAR 0 9
114787: PPUSH
114788: LD_VAR 0 4
114792: PUSH
114793: LD_VAR 0 7
114797: ARRAY
114798: PPUSH
114799: CALL_OW 296
114803: PUSH
114804: LD_INT 5
114806: LESS
114807: AND
114808: IFFALSE 114825
// ComAutodestruct ( group [ i ] ) ;
114810: LD_VAR 0 4
114814: PUSH
114815: LD_VAR 0 7
114819: ARRAY
114820: PPUSH
114821: CALL 49638 0 1
// end ; if f_attack_depot then
114825: LD_VAR 0 25
114829: IFFALSE 114941
// begin k := 6 ;
114831: LD_ADDR_VAR 0 9
114835: PUSH
114836: LD_INT 6
114838: ST_TO_ADDR
// if tmp < k then
114839: LD_VAR 0 14
114843: PUSH
114844: LD_VAR 0 9
114848: LESS
114849: IFFALSE 114861
// k := tmp ;
114851: LD_ADDR_VAR 0 9
114855: PUSH
114856: LD_VAR 0 14
114860: ST_TO_ADDR
// for j = 1 to k do
114861: LD_ADDR_VAR 0 8
114865: PUSH
114866: DOUBLE
114867: LD_INT 1
114869: DEC
114870: ST_TO_ADDR
114871: LD_VAR 0 9
114875: PUSH
114876: FOR_TO
114877: IFFALSE 114939
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114879: LD_VAR 0 8
114883: PPUSH
114884: CALL_OW 266
114888: PUSH
114889: LD_INT 0
114891: PUSH
114892: LD_INT 1
114894: PUSH
114895: EMPTY
114896: LIST
114897: LIST
114898: IN
114899: IFFALSE 114937
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114901: LD_VAR 0 4
114905: PUSH
114906: LD_VAR 0 7
114910: ARRAY
114911: PPUSH
114912: LD_VAR 0 14
114916: PUSH
114917: LD_VAR 0 8
114921: ARRAY
114922: PPUSH
114923: CALL_OW 115
// attacking := true ;
114927: LD_ADDR_VAR 0 29
114931: PUSH
114932: LD_INT 1
114934: ST_TO_ADDR
// break ;
114935: GO 114939
// end ;
114937: GO 114876
114939: POP
114940: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114941: LD_VAR 0 4
114945: PUSH
114946: LD_VAR 0 7
114950: ARRAY
114951: PPUSH
114952: CALL_OW 302
114956: PUSH
114957: LD_VAR 0 29
114961: NOT
114962: AND
114963: IFFALSE 115285
// begin if GetTag ( group [ i ] ) = 71 then
114965: LD_VAR 0 4
114969: PUSH
114970: LD_VAR 0 7
114974: ARRAY
114975: PPUSH
114976: CALL_OW 110
114980: PUSH
114981: LD_INT 71
114983: EQUAL
114984: IFFALSE 115025
// begin if HasTask ( group [ i ] ) then
114986: LD_VAR 0 4
114990: PUSH
114991: LD_VAR 0 7
114995: ARRAY
114996: PPUSH
114997: CALL_OW 314
115001: IFFALSE 115007
// continue else
115003: GO 111164
115005: GO 115025
// SetTag ( group [ i ] , 0 ) ;
115007: LD_VAR 0 4
115011: PUSH
115012: LD_VAR 0 7
115016: ARRAY
115017: PPUSH
115018: LD_INT 0
115020: PPUSH
115021: CALL_OW 109
// end ; k := 8 ;
115025: LD_ADDR_VAR 0 9
115029: PUSH
115030: LD_INT 8
115032: ST_TO_ADDR
// x := 0 ;
115033: LD_ADDR_VAR 0 10
115037: PUSH
115038: LD_INT 0
115040: ST_TO_ADDR
// if tmp < k then
115041: LD_VAR 0 14
115045: PUSH
115046: LD_VAR 0 9
115050: LESS
115051: IFFALSE 115063
// k := tmp ;
115053: LD_ADDR_VAR 0 9
115057: PUSH
115058: LD_VAR 0 14
115062: ST_TO_ADDR
// for j = 1 to k do
115063: LD_ADDR_VAR 0 8
115067: PUSH
115068: DOUBLE
115069: LD_INT 1
115071: DEC
115072: ST_TO_ADDR
115073: LD_VAR 0 9
115077: PUSH
115078: FOR_TO
115079: IFFALSE 115177
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115081: LD_VAR 0 14
115085: PUSH
115086: LD_VAR 0 8
115090: ARRAY
115091: PPUSH
115092: CALL_OW 247
115096: PUSH
115097: LD_INT 1
115099: EQUAL
115100: PUSH
115101: LD_VAR 0 14
115105: PUSH
115106: LD_VAR 0 8
115110: ARRAY
115111: PPUSH
115112: CALL_OW 256
115116: PUSH
115117: LD_INT 250
115119: LESS
115120: PUSH
115121: LD_VAR 0 20
115125: AND
115126: PUSH
115127: LD_VAR 0 20
115131: NOT
115132: PUSH
115133: LD_VAR 0 14
115137: PUSH
115138: LD_VAR 0 8
115142: ARRAY
115143: PPUSH
115144: CALL_OW 256
115148: PUSH
115149: LD_INT 250
115151: GREATEREQUAL
115152: AND
115153: OR
115154: AND
115155: IFFALSE 115175
// begin x := tmp [ j ] ;
115157: LD_ADDR_VAR 0 10
115161: PUSH
115162: LD_VAR 0 14
115166: PUSH
115167: LD_VAR 0 8
115171: ARRAY
115172: ST_TO_ADDR
// break ;
115173: GO 115177
// end ;
115175: GO 115078
115177: POP
115178: POP
// if x then
115179: LD_VAR 0 10
115183: IFFALSE 115207
// ComAttackUnit ( group [ i ] , x ) else
115185: LD_VAR 0 4
115189: PUSH
115190: LD_VAR 0 7
115194: ARRAY
115195: PPUSH
115196: LD_VAR 0 10
115200: PPUSH
115201: CALL_OW 115
115205: GO 115231
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115207: LD_VAR 0 4
115211: PUSH
115212: LD_VAR 0 7
115216: ARRAY
115217: PPUSH
115218: LD_VAR 0 14
115222: PUSH
115223: LD_INT 1
115225: ARRAY
115226: PPUSH
115227: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115231: LD_VAR 0 4
115235: PUSH
115236: LD_VAR 0 7
115240: ARRAY
115241: PPUSH
115242: CALL_OW 314
115246: NOT
115247: IFFALSE 115285
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115249: LD_VAR 0 4
115253: PUSH
115254: LD_VAR 0 7
115258: ARRAY
115259: PPUSH
115260: LD_VAR 0 14
115264: PPUSH
115265: LD_VAR 0 4
115269: PUSH
115270: LD_VAR 0 7
115274: ARRAY
115275: PPUSH
115276: CALL_OW 74
115280: PPUSH
115281: CALL_OW 115
// end ; end ; end ;
115285: GO 111164
115287: POP
115288: POP
// wait ( 0 0$2 ) ;
115289: LD_INT 70
115291: PPUSH
115292: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115296: LD_VAR 0 4
115300: NOT
115301: PUSH
115302: LD_VAR 0 4
115306: PUSH
115307: EMPTY
115308: EQUAL
115309: OR
115310: PUSH
115311: LD_INT 81
115313: PUSH
115314: LD_VAR 0 35
115318: PUSH
115319: EMPTY
115320: LIST
115321: LIST
115322: PPUSH
115323: CALL_OW 69
115327: NOT
115328: OR
115329: IFFALSE 111149
// end ;
115331: LD_VAR 0 2
115335: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115336: LD_INT 0
115338: PPUSH
115339: PPUSH
115340: PPUSH
115341: PPUSH
115342: PPUSH
115343: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115344: LD_VAR 0 1
115348: NOT
115349: PUSH
115350: LD_EXP 61
115354: PUSH
115355: LD_VAR 0 1
115359: ARRAY
115360: NOT
115361: OR
115362: PUSH
115363: LD_VAR 0 2
115367: NOT
115368: OR
115369: IFFALSE 115373
// exit ;
115371: GO 115927
// side := mc_sides [ base ] ;
115373: LD_ADDR_VAR 0 6
115377: PUSH
115378: LD_EXP 87
115382: PUSH
115383: LD_VAR 0 1
115387: ARRAY
115388: ST_TO_ADDR
// if not side then
115389: LD_VAR 0 6
115393: NOT
115394: IFFALSE 115398
// exit ;
115396: GO 115927
// for i in solds do
115398: LD_ADDR_VAR 0 7
115402: PUSH
115403: LD_VAR 0 2
115407: PUSH
115408: FOR_IN
115409: IFFALSE 115470
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115411: LD_VAR 0 7
115415: PPUSH
115416: CALL_OW 310
115420: PPUSH
115421: CALL_OW 266
115425: PUSH
115426: LD_INT 32
115428: PUSH
115429: LD_INT 31
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: IN
115436: IFFALSE 115456
// solds := solds diff i else
115438: LD_ADDR_VAR 0 2
115442: PUSH
115443: LD_VAR 0 2
115447: PUSH
115448: LD_VAR 0 7
115452: DIFF
115453: ST_TO_ADDR
115454: GO 115468
// SetTag ( i , 18 ) ;
115456: LD_VAR 0 7
115460: PPUSH
115461: LD_INT 18
115463: PPUSH
115464: CALL_OW 109
115468: GO 115408
115470: POP
115471: POP
// if not solds then
115472: LD_VAR 0 2
115476: NOT
115477: IFFALSE 115481
// exit ;
115479: GO 115927
// repeat wait ( 0 0$2 ) ;
115481: LD_INT 70
115483: PPUSH
115484: CALL_OW 67
// enemy := mc_scan [ base ] ;
115488: LD_ADDR_VAR 0 4
115492: PUSH
115493: LD_EXP 84
115497: PUSH
115498: LD_VAR 0 1
115502: ARRAY
115503: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115504: LD_EXP 61
115508: PUSH
115509: LD_VAR 0 1
115513: ARRAY
115514: NOT
115515: PUSH
115516: LD_EXP 61
115520: PUSH
115521: LD_VAR 0 1
115525: ARRAY
115526: PUSH
115527: EMPTY
115528: EQUAL
115529: OR
115530: IFFALSE 115567
// begin for i in solds do
115532: LD_ADDR_VAR 0 7
115536: PUSH
115537: LD_VAR 0 2
115541: PUSH
115542: FOR_IN
115543: IFFALSE 115556
// ComStop ( i ) ;
115545: LD_VAR 0 7
115549: PPUSH
115550: CALL_OW 141
115554: GO 115542
115556: POP
115557: POP
// solds := [ ] ;
115558: LD_ADDR_VAR 0 2
115562: PUSH
115563: EMPTY
115564: ST_TO_ADDR
// exit ;
115565: GO 115927
// end ; for i in solds do
115567: LD_ADDR_VAR 0 7
115571: PUSH
115572: LD_VAR 0 2
115576: PUSH
115577: FOR_IN
115578: IFFALSE 115899
// begin if IsInUnit ( i ) then
115580: LD_VAR 0 7
115584: PPUSH
115585: CALL_OW 310
115589: IFFALSE 115600
// ComExitBuilding ( i ) ;
115591: LD_VAR 0 7
115595: PPUSH
115596: CALL_OW 122
// if GetLives ( i ) > 500 then
115600: LD_VAR 0 7
115604: PPUSH
115605: CALL_OW 256
115609: PUSH
115610: LD_INT 500
115612: GREATER
115613: IFFALSE 115666
// begin e := NearestUnitToUnit ( enemy , i ) ;
115615: LD_ADDR_VAR 0 5
115619: PUSH
115620: LD_VAR 0 4
115624: PPUSH
115625: LD_VAR 0 7
115629: PPUSH
115630: CALL_OW 74
115634: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115635: LD_VAR 0 7
115639: PPUSH
115640: LD_VAR 0 5
115644: PPUSH
115645: CALL_OW 250
115649: PPUSH
115650: LD_VAR 0 5
115654: PPUSH
115655: CALL_OW 251
115659: PPUSH
115660: CALL_OW 114
// end else
115664: GO 115897
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115666: LD_VAR 0 7
115670: PPUSH
115671: LD_EXP 61
115675: PUSH
115676: LD_VAR 0 1
115680: ARRAY
115681: PPUSH
115682: LD_INT 2
115684: PUSH
115685: LD_INT 30
115687: PUSH
115688: LD_INT 0
115690: PUSH
115691: EMPTY
115692: LIST
115693: LIST
115694: PUSH
115695: LD_INT 30
115697: PUSH
115698: LD_INT 1
115700: PUSH
115701: EMPTY
115702: LIST
115703: LIST
115704: PUSH
115705: LD_INT 30
115707: PUSH
115708: LD_INT 6
115710: PUSH
115711: EMPTY
115712: LIST
115713: LIST
115714: PUSH
115715: EMPTY
115716: LIST
115717: LIST
115718: LIST
115719: LIST
115720: PPUSH
115721: CALL_OW 72
115725: PPUSH
115726: LD_VAR 0 7
115730: PPUSH
115731: CALL_OW 74
115735: PPUSH
115736: CALL_OW 296
115740: PUSH
115741: LD_INT 10
115743: GREATER
115744: IFFALSE 115897
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115746: LD_ADDR_VAR 0 8
115750: PUSH
115751: LD_EXP 61
115755: PUSH
115756: LD_VAR 0 1
115760: ARRAY
115761: PPUSH
115762: LD_INT 2
115764: PUSH
115765: LD_INT 30
115767: PUSH
115768: LD_INT 0
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: PUSH
115775: LD_INT 30
115777: PUSH
115778: LD_INT 1
115780: PUSH
115781: EMPTY
115782: LIST
115783: LIST
115784: PUSH
115785: LD_INT 30
115787: PUSH
115788: LD_INT 6
115790: PUSH
115791: EMPTY
115792: LIST
115793: LIST
115794: PUSH
115795: EMPTY
115796: LIST
115797: LIST
115798: LIST
115799: LIST
115800: PPUSH
115801: CALL_OW 72
115805: PPUSH
115806: LD_VAR 0 7
115810: PPUSH
115811: CALL_OW 74
115815: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115816: LD_VAR 0 7
115820: PPUSH
115821: LD_VAR 0 8
115825: PPUSH
115826: CALL_OW 250
115830: PPUSH
115831: LD_INT 3
115833: PPUSH
115834: LD_INT 5
115836: PPUSH
115837: CALL_OW 272
115841: PPUSH
115842: LD_VAR 0 8
115846: PPUSH
115847: CALL_OW 251
115851: PPUSH
115852: LD_INT 3
115854: PPUSH
115855: LD_INT 5
115857: PPUSH
115858: CALL_OW 273
115862: PPUSH
115863: CALL_OW 111
// SetTag ( i , 0 ) ;
115867: LD_VAR 0 7
115871: PPUSH
115872: LD_INT 0
115874: PPUSH
115875: CALL_OW 109
// solds := solds diff i ;
115879: LD_ADDR_VAR 0 2
115883: PUSH
115884: LD_VAR 0 2
115888: PUSH
115889: LD_VAR 0 7
115893: DIFF
115894: ST_TO_ADDR
// continue ;
115895: GO 115577
// end ; end ;
115897: GO 115577
115899: POP
115900: POP
// until not solds or not enemy ;
115901: LD_VAR 0 2
115905: NOT
115906: PUSH
115907: LD_VAR 0 4
115911: NOT
115912: OR
115913: IFFALSE 115481
// MC_Reset ( base , 18 ) ;
115915: LD_VAR 0 1
115919: PPUSH
115920: LD_INT 18
115922: PPUSH
115923: CALL 63375 0 2
// end ;
115927: LD_VAR 0 3
115931: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115932: LD_INT 0
115934: PPUSH
115935: PPUSH
115936: PPUSH
115937: PPUSH
115938: PPUSH
115939: PPUSH
115940: PPUSH
115941: PPUSH
115942: PPUSH
115943: PPUSH
115944: PPUSH
115945: PPUSH
115946: PPUSH
115947: PPUSH
115948: PPUSH
115949: PPUSH
115950: PPUSH
115951: PPUSH
115952: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115953: LD_ADDR_VAR 0 12
115957: PUSH
115958: LD_EXP 61
115962: PUSH
115963: LD_VAR 0 1
115967: ARRAY
115968: PPUSH
115969: LD_INT 25
115971: PUSH
115972: LD_INT 3
115974: PUSH
115975: EMPTY
115976: LIST
115977: LIST
115978: PPUSH
115979: CALL_OW 72
115983: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115984: LD_EXP 101
115988: PUSH
115989: LD_VAR 0 1
115993: ARRAY
115994: IFFALSE 116018
// mechs := mechs diff mc_remote_driver [ base ] ;
115996: LD_ADDR_VAR 0 12
116000: PUSH
116001: LD_VAR 0 12
116005: PUSH
116006: LD_EXP 101
116010: PUSH
116011: LD_VAR 0 1
116015: ARRAY
116016: DIFF
116017: ST_TO_ADDR
// for i in mechs do
116018: LD_ADDR_VAR 0 4
116022: PUSH
116023: LD_VAR 0 12
116027: PUSH
116028: FOR_IN
116029: IFFALSE 116064
// if GetTag ( i ) > 0 then
116031: LD_VAR 0 4
116035: PPUSH
116036: CALL_OW 110
116040: PUSH
116041: LD_INT 0
116043: GREATER
116044: IFFALSE 116062
// mechs := mechs diff i ;
116046: LD_ADDR_VAR 0 12
116050: PUSH
116051: LD_VAR 0 12
116055: PUSH
116056: LD_VAR 0 4
116060: DIFF
116061: ST_TO_ADDR
116062: GO 116028
116064: POP
116065: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116066: LD_ADDR_VAR 0 8
116070: PUSH
116071: LD_EXP 61
116075: PUSH
116076: LD_VAR 0 1
116080: ARRAY
116081: PPUSH
116082: LD_INT 2
116084: PUSH
116085: LD_INT 25
116087: PUSH
116088: LD_INT 1
116090: PUSH
116091: EMPTY
116092: LIST
116093: LIST
116094: PUSH
116095: LD_INT 25
116097: PUSH
116098: LD_INT 5
116100: PUSH
116101: EMPTY
116102: LIST
116103: LIST
116104: PUSH
116105: LD_INT 25
116107: PUSH
116108: LD_INT 8
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PUSH
116115: LD_INT 25
116117: PUSH
116118: LD_INT 9
116120: PUSH
116121: EMPTY
116122: LIST
116123: LIST
116124: PUSH
116125: EMPTY
116126: LIST
116127: LIST
116128: LIST
116129: LIST
116130: LIST
116131: PPUSH
116132: CALL_OW 72
116136: ST_TO_ADDR
// if not defenders and not solds then
116137: LD_VAR 0 2
116141: NOT
116142: PUSH
116143: LD_VAR 0 8
116147: NOT
116148: AND
116149: IFFALSE 116153
// exit ;
116151: GO 117923
// depot_under_attack := false ;
116153: LD_ADDR_VAR 0 16
116157: PUSH
116158: LD_INT 0
116160: ST_TO_ADDR
// sold_defenders := [ ] ;
116161: LD_ADDR_VAR 0 17
116165: PUSH
116166: EMPTY
116167: ST_TO_ADDR
// if mechs then
116168: LD_VAR 0 12
116172: IFFALSE 116325
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116174: LD_ADDR_VAR 0 4
116178: PUSH
116179: LD_VAR 0 2
116183: PPUSH
116184: LD_INT 21
116186: PUSH
116187: LD_INT 2
116189: PUSH
116190: EMPTY
116191: LIST
116192: LIST
116193: PPUSH
116194: CALL_OW 72
116198: PUSH
116199: FOR_IN
116200: IFFALSE 116323
// begin if GetTag ( i ) <> 20 then
116202: LD_VAR 0 4
116206: PPUSH
116207: CALL_OW 110
116211: PUSH
116212: LD_INT 20
116214: NONEQUAL
116215: IFFALSE 116229
// SetTag ( i , 20 ) ;
116217: LD_VAR 0 4
116221: PPUSH
116222: LD_INT 20
116224: PPUSH
116225: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116229: LD_VAR 0 4
116233: PPUSH
116234: CALL_OW 263
116238: PUSH
116239: LD_INT 1
116241: EQUAL
116242: PUSH
116243: LD_VAR 0 4
116247: PPUSH
116248: CALL_OW 311
116252: NOT
116253: AND
116254: IFFALSE 116321
// begin un := mechs [ 1 ] ;
116256: LD_ADDR_VAR 0 10
116260: PUSH
116261: LD_VAR 0 12
116265: PUSH
116266: LD_INT 1
116268: ARRAY
116269: ST_TO_ADDR
// ComExit ( un ) ;
116270: LD_VAR 0 10
116274: PPUSH
116275: CALL 54524 0 1
// AddComEnterUnit ( un , i ) ;
116279: LD_VAR 0 10
116283: PPUSH
116284: LD_VAR 0 4
116288: PPUSH
116289: CALL_OW 180
// SetTag ( un , 19 ) ;
116293: LD_VAR 0 10
116297: PPUSH
116298: LD_INT 19
116300: PPUSH
116301: CALL_OW 109
// mechs := mechs diff un ;
116305: LD_ADDR_VAR 0 12
116309: PUSH
116310: LD_VAR 0 12
116314: PUSH
116315: LD_VAR 0 10
116319: DIFF
116320: ST_TO_ADDR
// end ; end ;
116321: GO 116199
116323: POP
116324: POP
// if solds then
116325: LD_VAR 0 8
116329: IFFALSE 116388
// for i in solds do
116331: LD_ADDR_VAR 0 4
116335: PUSH
116336: LD_VAR 0 8
116340: PUSH
116341: FOR_IN
116342: IFFALSE 116386
// if not GetTag ( i ) then
116344: LD_VAR 0 4
116348: PPUSH
116349: CALL_OW 110
116353: NOT
116354: IFFALSE 116384
// begin defenders := defenders union i ;
116356: LD_ADDR_VAR 0 2
116360: PUSH
116361: LD_VAR 0 2
116365: PUSH
116366: LD_VAR 0 4
116370: UNION
116371: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116372: LD_VAR 0 4
116376: PPUSH
116377: LD_INT 18
116379: PPUSH
116380: CALL_OW 109
// end ;
116384: GO 116341
116386: POP
116387: POP
// repeat wait ( 0 0$2 ) ;
116388: LD_INT 70
116390: PPUSH
116391: CALL_OW 67
// enemy := mc_scan [ base ] ;
116395: LD_ADDR_VAR 0 21
116399: PUSH
116400: LD_EXP 84
116404: PUSH
116405: LD_VAR 0 1
116409: ARRAY
116410: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116411: LD_EXP 61
116415: PUSH
116416: LD_VAR 0 1
116420: ARRAY
116421: NOT
116422: PUSH
116423: LD_EXP 61
116427: PUSH
116428: LD_VAR 0 1
116432: ARRAY
116433: PUSH
116434: EMPTY
116435: EQUAL
116436: OR
116437: IFFALSE 116474
// begin for i in defenders do
116439: LD_ADDR_VAR 0 4
116443: PUSH
116444: LD_VAR 0 2
116448: PUSH
116449: FOR_IN
116450: IFFALSE 116463
// ComStop ( i ) ;
116452: LD_VAR 0 4
116456: PPUSH
116457: CALL_OW 141
116461: GO 116449
116463: POP
116464: POP
// defenders := [ ] ;
116465: LD_ADDR_VAR 0 2
116469: PUSH
116470: EMPTY
116471: ST_TO_ADDR
// exit ;
116472: GO 117923
// end ; for i in defenders do
116474: LD_ADDR_VAR 0 4
116478: PUSH
116479: LD_VAR 0 2
116483: PUSH
116484: FOR_IN
116485: IFFALSE 117383
// begin e := NearestUnitToUnit ( enemy , i ) ;
116487: LD_ADDR_VAR 0 13
116491: PUSH
116492: LD_VAR 0 21
116496: PPUSH
116497: LD_VAR 0 4
116501: PPUSH
116502: CALL_OW 74
116506: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116507: LD_ADDR_VAR 0 7
116511: PUSH
116512: LD_EXP 61
116516: PUSH
116517: LD_VAR 0 1
116521: ARRAY
116522: PPUSH
116523: LD_INT 2
116525: PUSH
116526: LD_INT 30
116528: PUSH
116529: LD_INT 0
116531: PUSH
116532: EMPTY
116533: LIST
116534: LIST
116535: PUSH
116536: LD_INT 30
116538: PUSH
116539: LD_INT 1
116541: PUSH
116542: EMPTY
116543: LIST
116544: LIST
116545: PUSH
116546: EMPTY
116547: LIST
116548: LIST
116549: LIST
116550: PPUSH
116551: CALL_OW 72
116555: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116556: LD_ADDR_VAR 0 16
116560: PUSH
116561: LD_VAR 0 7
116565: NOT
116566: PUSH
116567: LD_VAR 0 7
116571: PPUSH
116572: LD_INT 3
116574: PUSH
116575: LD_INT 24
116577: PUSH
116578: LD_INT 600
116580: PUSH
116581: EMPTY
116582: LIST
116583: LIST
116584: PUSH
116585: EMPTY
116586: LIST
116587: LIST
116588: PPUSH
116589: CALL_OW 72
116593: OR
116594: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116595: LD_VAR 0 4
116599: PPUSH
116600: CALL_OW 247
116604: PUSH
116605: LD_INT 2
116607: DOUBLE
116608: EQUAL
116609: IFTRUE 116613
116611: GO 117009
116613: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116614: LD_VAR 0 4
116618: PPUSH
116619: CALL_OW 256
116623: PUSH
116624: LD_INT 1000
116626: EQUAL
116627: PUSH
116628: LD_VAR 0 4
116632: PPUSH
116633: LD_VAR 0 13
116637: PPUSH
116638: CALL_OW 296
116642: PUSH
116643: LD_INT 40
116645: LESS
116646: PUSH
116647: LD_VAR 0 13
116651: PPUSH
116652: LD_EXP 86
116656: PUSH
116657: LD_VAR 0 1
116661: ARRAY
116662: PPUSH
116663: CALL_OW 308
116667: OR
116668: AND
116669: IFFALSE 116791
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116671: LD_VAR 0 4
116675: PPUSH
116676: CALL_OW 262
116680: PUSH
116681: LD_INT 1
116683: EQUAL
116684: PUSH
116685: LD_VAR 0 4
116689: PPUSH
116690: CALL_OW 261
116694: PUSH
116695: LD_INT 30
116697: LESS
116698: AND
116699: PUSH
116700: LD_VAR 0 7
116704: AND
116705: IFFALSE 116775
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116707: LD_VAR 0 4
116711: PPUSH
116712: LD_VAR 0 7
116716: PPUSH
116717: LD_VAR 0 4
116721: PPUSH
116722: CALL_OW 74
116726: PPUSH
116727: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116731: LD_VAR 0 4
116735: PPUSH
116736: LD_VAR 0 7
116740: PPUSH
116741: LD_VAR 0 4
116745: PPUSH
116746: CALL_OW 74
116750: PPUSH
116751: CALL_OW 296
116755: PUSH
116756: LD_INT 6
116758: LESS
116759: IFFALSE 116773
// SetFuel ( i , 100 ) ;
116761: LD_VAR 0 4
116765: PPUSH
116766: LD_INT 100
116768: PPUSH
116769: CALL_OW 240
// end else
116773: GO 116789
// ComAttackUnit ( i , e ) ;
116775: LD_VAR 0 4
116779: PPUSH
116780: LD_VAR 0 13
116784: PPUSH
116785: CALL_OW 115
// end else
116789: GO 116892
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116791: LD_VAR 0 13
116795: PPUSH
116796: LD_EXP 86
116800: PUSH
116801: LD_VAR 0 1
116805: ARRAY
116806: PPUSH
116807: CALL_OW 308
116811: NOT
116812: PUSH
116813: LD_VAR 0 4
116817: PPUSH
116818: LD_VAR 0 13
116822: PPUSH
116823: CALL_OW 296
116827: PUSH
116828: LD_INT 40
116830: GREATEREQUAL
116831: AND
116832: PUSH
116833: LD_VAR 0 4
116837: PPUSH
116838: CALL_OW 256
116842: PUSH
116843: LD_INT 650
116845: LESSEQUAL
116846: OR
116847: PUSH
116848: LD_VAR 0 4
116852: PPUSH
116853: LD_EXP 85
116857: PUSH
116858: LD_VAR 0 1
116862: ARRAY
116863: PPUSH
116864: CALL_OW 308
116868: NOT
116869: AND
116870: IFFALSE 116892
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116872: LD_VAR 0 4
116876: PPUSH
116877: LD_EXP 85
116881: PUSH
116882: LD_VAR 0 1
116886: ARRAY
116887: PPUSH
116888: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116892: LD_VAR 0 4
116896: PPUSH
116897: CALL_OW 256
116901: PUSH
116902: LD_INT 1000
116904: LESS
116905: PUSH
116906: LD_VAR 0 4
116910: PPUSH
116911: CALL_OW 263
116915: PUSH
116916: LD_INT 1
116918: EQUAL
116919: AND
116920: PUSH
116921: LD_VAR 0 4
116925: PPUSH
116926: CALL_OW 311
116930: AND
116931: PUSH
116932: LD_VAR 0 4
116936: PPUSH
116937: LD_EXP 85
116941: PUSH
116942: LD_VAR 0 1
116946: ARRAY
116947: PPUSH
116948: CALL_OW 308
116952: AND
116953: IFFALSE 117007
// begin mech := IsDrivenBy ( i ) ;
116955: LD_ADDR_VAR 0 9
116959: PUSH
116960: LD_VAR 0 4
116964: PPUSH
116965: CALL_OW 311
116969: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116970: LD_VAR 0 9
116974: PPUSH
116975: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116979: LD_VAR 0 9
116983: PPUSH
116984: LD_VAR 0 4
116988: PPUSH
116989: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116993: LD_VAR 0 9
116997: PPUSH
116998: LD_VAR 0 4
117002: PPUSH
117003: CALL_OW 180
// end ; end ; unit_human :
117007: GO 117354
117009: LD_INT 1
117011: DOUBLE
117012: EQUAL
117013: IFTRUE 117017
117015: GO 117353
117017: POP
// begin b := IsInUnit ( i ) ;
117018: LD_ADDR_VAR 0 18
117022: PUSH
117023: LD_VAR 0 4
117027: PPUSH
117028: CALL_OW 310
117032: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117033: LD_ADDR_VAR 0 19
117037: PUSH
117038: LD_VAR 0 18
117042: NOT
117043: PUSH
117044: LD_VAR 0 18
117048: PPUSH
117049: CALL_OW 266
117053: PUSH
117054: LD_INT 32
117056: PUSH
117057: LD_INT 31
117059: PUSH
117060: EMPTY
117061: LIST
117062: LIST
117063: IN
117064: OR
117065: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117066: LD_VAR 0 18
117070: PPUSH
117071: CALL_OW 266
117075: PUSH
117076: LD_INT 5
117078: EQUAL
117079: PUSH
117080: LD_VAR 0 4
117084: PPUSH
117085: CALL_OW 257
117089: PUSH
117090: LD_INT 1
117092: PUSH
117093: LD_INT 2
117095: PUSH
117096: LD_INT 3
117098: PUSH
117099: LD_INT 4
117101: PUSH
117102: EMPTY
117103: LIST
117104: LIST
117105: LIST
117106: LIST
117107: IN
117108: AND
117109: IFFALSE 117146
// begin class := AllowSpecClass ( i ) ;
117111: LD_ADDR_VAR 0 20
117115: PUSH
117116: LD_VAR 0 4
117120: PPUSH
117121: CALL 18221 0 1
117125: ST_TO_ADDR
// if class then
117126: LD_VAR 0 20
117130: IFFALSE 117146
// ComChangeProfession ( i , class ) ;
117132: LD_VAR 0 4
117136: PPUSH
117137: LD_VAR 0 20
117141: PPUSH
117142: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117146: LD_VAR 0 16
117150: PUSH
117151: LD_VAR 0 2
117155: PPUSH
117156: LD_INT 21
117158: PUSH
117159: LD_INT 2
117161: PUSH
117162: EMPTY
117163: LIST
117164: LIST
117165: PPUSH
117166: CALL_OW 72
117170: PUSH
117171: LD_INT 1
117173: LESSEQUAL
117174: OR
117175: PUSH
117176: LD_VAR 0 19
117180: AND
117181: PUSH
117182: LD_VAR 0 4
117186: PUSH
117187: LD_VAR 0 17
117191: IN
117192: NOT
117193: AND
117194: IFFALSE 117287
// begin if b then
117196: LD_VAR 0 18
117200: IFFALSE 117249
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117202: LD_VAR 0 18
117206: PPUSH
117207: LD_VAR 0 21
117211: PPUSH
117212: LD_VAR 0 18
117216: PPUSH
117217: CALL_OW 74
117221: PPUSH
117222: CALL_OW 296
117226: PUSH
117227: LD_INT 10
117229: LESS
117230: PUSH
117231: LD_VAR 0 18
117235: PPUSH
117236: CALL_OW 461
117240: PUSH
117241: LD_INT 7
117243: NONEQUAL
117244: AND
117245: IFFALSE 117249
// continue ;
117247: GO 116484
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117249: LD_ADDR_VAR 0 17
117253: PUSH
117254: LD_VAR 0 17
117258: PPUSH
117259: LD_VAR 0 17
117263: PUSH
117264: LD_INT 1
117266: PLUS
117267: PPUSH
117268: LD_VAR 0 4
117272: PPUSH
117273: CALL_OW 1
117277: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117278: LD_VAR 0 4
117282: PPUSH
117283: CALL_OW 122
// end ; if sold_defenders then
117287: LD_VAR 0 17
117291: IFFALSE 117351
// if i in sold_defenders then
117293: LD_VAR 0 4
117297: PUSH
117298: LD_VAR 0 17
117302: IN
117303: IFFALSE 117351
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117305: LD_VAR 0 4
117309: PPUSH
117310: CALL_OW 314
117314: NOT
117315: PUSH
117316: LD_VAR 0 4
117320: PPUSH
117321: LD_VAR 0 13
117325: PPUSH
117326: CALL_OW 296
117330: PUSH
117331: LD_INT 30
117333: LESS
117334: AND
117335: IFFALSE 117351
// ComAttackUnit ( i , e ) ;
117337: LD_VAR 0 4
117341: PPUSH
117342: LD_VAR 0 13
117346: PPUSH
117347: CALL_OW 115
// end ; end ; end ;
117351: GO 117354
117353: POP
// if IsDead ( i ) then
117354: LD_VAR 0 4
117358: PPUSH
117359: CALL_OW 301
117363: IFFALSE 117381
// defenders := defenders diff i ;
117365: LD_ADDR_VAR 0 2
117369: PUSH
117370: LD_VAR 0 2
117374: PUSH
117375: LD_VAR 0 4
117379: DIFF
117380: ST_TO_ADDR
// end ;
117381: GO 116484
117383: POP
117384: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117385: LD_VAR 0 21
117389: NOT
117390: PUSH
117391: LD_VAR 0 2
117395: NOT
117396: OR
117397: PUSH
117398: LD_EXP 61
117402: PUSH
117403: LD_VAR 0 1
117407: ARRAY
117408: NOT
117409: OR
117410: IFFALSE 116388
// MC_Reset ( base , 18 ) ;
117412: LD_VAR 0 1
117416: PPUSH
117417: LD_INT 18
117419: PPUSH
117420: CALL 63375 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117424: LD_ADDR_VAR 0 2
117428: PUSH
117429: LD_VAR 0 2
117433: PUSH
117434: LD_VAR 0 2
117438: PPUSH
117439: LD_INT 2
117441: PUSH
117442: LD_INT 25
117444: PUSH
117445: LD_INT 1
117447: PUSH
117448: EMPTY
117449: LIST
117450: LIST
117451: PUSH
117452: LD_INT 25
117454: PUSH
117455: LD_INT 5
117457: PUSH
117458: EMPTY
117459: LIST
117460: LIST
117461: PUSH
117462: LD_INT 25
117464: PUSH
117465: LD_INT 8
117467: PUSH
117468: EMPTY
117469: LIST
117470: LIST
117471: PUSH
117472: LD_INT 25
117474: PUSH
117475: LD_INT 9
117477: PUSH
117478: EMPTY
117479: LIST
117480: LIST
117481: PUSH
117482: EMPTY
117483: LIST
117484: LIST
117485: LIST
117486: LIST
117487: LIST
117488: PPUSH
117489: CALL_OW 72
117493: DIFF
117494: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117495: LD_VAR 0 21
117499: NOT
117500: PUSH
117501: LD_VAR 0 2
117505: PPUSH
117506: LD_INT 21
117508: PUSH
117509: LD_INT 2
117511: PUSH
117512: EMPTY
117513: LIST
117514: LIST
117515: PPUSH
117516: CALL_OW 72
117520: AND
117521: IFFALSE 117859
// begin tmp := FilterByTag ( defenders , 19 ) ;
117523: LD_ADDR_VAR 0 11
117527: PUSH
117528: LD_VAR 0 2
117532: PPUSH
117533: LD_INT 19
117535: PPUSH
117536: CALL 51695 0 2
117540: ST_TO_ADDR
// if tmp then
117541: LD_VAR 0 11
117545: IFFALSE 117615
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117547: LD_ADDR_VAR 0 11
117551: PUSH
117552: LD_VAR 0 11
117556: PPUSH
117557: LD_INT 25
117559: PUSH
117560: LD_INT 3
117562: PUSH
117563: EMPTY
117564: LIST
117565: LIST
117566: PPUSH
117567: CALL_OW 72
117571: ST_TO_ADDR
// if tmp then
117572: LD_VAR 0 11
117576: IFFALSE 117615
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117578: LD_ADDR_EXP 73
117582: PUSH
117583: LD_EXP 73
117587: PPUSH
117588: LD_VAR 0 1
117592: PPUSH
117593: LD_EXP 73
117597: PUSH
117598: LD_VAR 0 1
117602: ARRAY
117603: PUSH
117604: LD_VAR 0 11
117608: UNION
117609: PPUSH
117610: CALL_OW 1
117614: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117615: LD_VAR 0 1
117619: PPUSH
117620: LD_INT 19
117622: PPUSH
117623: CALL 63375 0 2
// repeat wait ( 0 0$1 ) ;
117627: LD_INT 35
117629: PPUSH
117630: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117634: LD_EXP 61
117638: PUSH
117639: LD_VAR 0 1
117643: ARRAY
117644: NOT
117645: PUSH
117646: LD_EXP 61
117650: PUSH
117651: LD_VAR 0 1
117655: ARRAY
117656: PUSH
117657: EMPTY
117658: EQUAL
117659: OR
117660: IFFALSE 117697
// begin for i in defenders do
117662: LD_ADDR_VAR 0 4
117666: PUSH
117667: LD_VAR 0 2
117671: PUSH
117672: FOR_IN
117673: IFFALSE 117686
// ComStop ( i ) ;
117675: LD_VAR 0 4
117679: PPUSH
117680: CALL_OW 141
117684: GO 117672
117686: POP
117687: POP
// defenders := [ ] ;
117688: LD_ADDR_VAR 0 2
117692: PUSH
117693: EMPTY
117694: ST_TO_ADDR
// exit ;
117695: GO 117923
// end ; for i in defenders do
117697: LD_ADDR_VAR 0 4
117701: PUSH
117702: LD_VAR 0 2
117706: PUSH
117707: FOR_IN
117708: IFFALSE 117797
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117710: LD_VAR 0 4
117714: PPUSH
117715: LD_EXP 85
117719: PUSH
117720: LD_VAR 0 1
117724: ARRAY
117725: PPUSH
117726: CALL_OW 308
117730: NOT
117731: IFFALSE 117755
// ComMoveToArea ( i , mc_parking [ base ] ) else
117733: LD_VAR 0 4
117737: PPUSH
117738: LD_EXP 85
117742: PUSH
117743: LD_VAR 0 1
117747: ARRAY
117748: PPUSH
117749: CALL_OW 113
117753: GO 117795
// if GetControl ( i ) = control_manual then
117755: LD_VAR 0 4
117759: PPUSH
117760: CALL_OW 263
117764: PUSH
117765: LD_INT 1
117767: EQUAL
117768: IFFALSE 117795
// if IsDrivenBy ( i ) then
117770: LD_VAR 0 4
117774: PPUSH
117775: CALL_OW 311
117779: IFFALSE 117795
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117781: LD_VAR 0 4
117785: PPUSH
117786: CALL_OW 311
117790: PPUSH
117791: CALL_OW 121
// end ;
117795: GO 117707
117797: POP
117798: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117799: LD_VAR 0 2
117803: PPUSH
117804: LD_INT 95
117806: PUSH
117807: LD_EXP 85
117811: PUSH
117812: LD_VAR 0 1
117816: ARRAY
117817: PUSH
117818: EMPTY
117819: LIST
117820: LIST
117821: PPUSH
117822: CALL_OW 72
117826: PUSH
117827: LD_VAR 0 2
117831: EQUAL
117832: PUSH
117833: LD_EXP 84
117837: PUSH
117838: LD_VAR 0 1
117842: ARRAY
117843: OR
117844: PUSH
117845: LD_EXP 61
117849: PUSH
117850: LD_VAR 0 1
117854: ARRAY
117855: NOT
117856: OR
117857: IFFALSE 117627
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117859: LD_ADDR_EXP 83
117863: PUSH
117864: LD_EXP 83
117868: PPUSH
117869: LD_VAR 0 1
117873: PPUSH
117874: LD_VAR 0 2
117878: PPUSH
117879: LD_INT 21
117881: PUSH
117882: LD_INT 2
117884: PUSH
117885: EMPTY
117886: LIST
117887: LIST
117888: PPUSH
117889: CALL_OW 72
117893: PPUSH
117894: CALL_OW 1
117898: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117899: LD_VAR 0 1
117903: PPUSH
117904: LD_INT 19
117906: PPUSH
117907: CALL 63375 0 2
// MC_Reset ( base , 20 ) ;
117911: LD_VAR 0 1
117915: PPUSH
117916: LD_INT 20
117918: PPUSH
117919: CALL 63375 0 2
// end ; end_of_file
117923: LD_VAR 0 3
117927: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117928: LD_VAR 0 1
117932: PUSH
117933: LD_INT 200
117935: DOUBLE
117936: GREATEREQUAL
117937: IFFALSE 117945
117939: LD_INT 299
117941: DOUBLE
117942: LESSEQUAL
117943: IFTRUE 117947
117945: GO 117979
117947: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117948: LD_VAR 0 1
117952: PPUSH
117953: LD_VAR 0 2
117957: PPUSH
117958: LD_VAR 0 3
117962: PPUSH
117963: LD_VAR 0 4
117967: PPUSH
117968: LD_VAR 0 5
117972: PPUSH
117973: CALL 106109 0 5
117977: GO 118056
117979: LD_INT 300
117981: DOUBLE
117982: GREATEREQUAL
117983: IFFALSE 117991
117985: LD_INT 399
117987: DOUBLE
117988: LESSEQUAL
117989: IFTRUE 117993
117991: GO 118055
117993: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117994: LD_VAR 0 1
117998: PPUSH
117999: LD_VAR 0 2
118003: PPUSH
118004: LD_VAR 0 3
118008: PPUSH
118009: LD_VAR 0 4
118013: PPUSH
118014: LD_VAR 0 5
118018: PPUSH
118019: LD_VAR 0 6
118023: PPUSH
118024: LD_VAR 0 7
118028: PPUSH
118029: LD_VAR 0 8
118033: PPUSH
118034: LD_VAR 0 9
118038: PPUSH
118039: LD_VAR 0 10
118043: PPUSH
118044: LD_VAR 0 11
118048: PPUSH
118049: CALL 102434 0 11
118053: GO 118056
118055: POP
// end ;
118056: PPOPN 11
118058: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118059: LD_VAR 0 1
118063: PPUSH
118064: LD_VAR 0 2
118068: PPUSH
118069: LD_VAR 0 3
118073: PPUSH
118074: LD_VAR 0 4
118078: PPUSH
118079: LD_VAR 0 5
118083: PPUSH
118084: CALL 105845 0 5
// end ; end_of_file
118088: PPOPN 5
118090: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118091: LD_VAR 0 1
118095: PPUSH
118096: LD_VAR 0 2
118100: PPUSH
118101: LD_VAR 0 3
118105: PPUSH
118106: LD_VAR 0 4
118110: PPUSH
118111: LD_VAR 0 5
118115: PPUSH
118116: LD_VAR 0 6
118120: PPUSH
118121: CALL 90086 0 6
// end ;
118125: PPOPN 6
118127: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118128: LD_INT 0
118130: PPUSH
// begin if not units then
118131: LD_VAR 0 1
118135: NOT
118136: IFFALSE 118140
// exit ;
118138: GO 118140
// end ;
118140: PPOPN 7
118142: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118143: CALL 89973 0 0
// end ;
118147: PPOPN 1
118149: END
