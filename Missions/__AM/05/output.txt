// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 2370 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05a_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05a_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , tmp ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// PrepareBase ;
 119: CALL 2012 0 0
// uc_side := 1 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// uc_nation := 1 ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// team := [ ] ;
 139: LD_ADDR_VAR 0 5
 143: PUSH
 144: EMPTY
 145: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_STRING JMM
 153: PPUSH
 154: LD_EXP 1
 158: NOT
 159: PPUSH
 160: CALL 4701 0 2
 164: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_STRING Gladstone
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: CALL 4701 0 2
 180: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_STRING Frank
 188: PPUSH
 189: LD_EXP 1
 193: NOT
 194: PPUSH
 195: CALL 4701 0 2
 199: ST_TO_ADDR
// if Frank then
 200: LD_EXP 9
 204: IFFALSE 222
// team := team ^ Frank ;
 206: LD_ADDR_VAR 0 5
 210: PUSH
 211: LD_VAR 0 5
 215: PUSH
 216: LD_EXP 9
 220: ADD
 221: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 222: LD_ADDR_EXP 10
 226: PUSH
 227: LD_STRING Lisa
 229: PPUSH
 230: LD_EXP 1
 234: NOT
 235: PPUSH
 236: CALL 4701 0 2
 240: ST_TO_ADDR
// if Lisa then
 241: LD_EXP 10
 245: IFFALSE 263
// team := team ^ Lisa ;
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_EXP 10
 261: ADD
 262: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 263: LD_ADDR_EXP 13
 267: PUSH
 268: LD_STRING Donaldson
 270: PPUSH
 271: LD_EXP 1
 275: NOT
 276: PPUSH
 277: CALL 4701 0 2
 281: ST_TO_ADDR
// if Donaldson then
 282: LD_EXP 13
 286: IFFALSE 304
// team := team ^ Donaldson ;
 288: LD_ADDR_VAR 0 5
 292: PUSH
 293: LD_VAR 0 5
 297: PUSH
 298: LD_EXP 13
 302: ADD
 303: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 304: LD_ADDR_EXP 14
 308: PUSH
 309: LD_STRING Brown
 311: PPUSH
 312: LD_EXP 1
 316: NOT
 317: PPUSH
 318: CALL 4701 0 2
 322: ST_TO_ADDR
// if Brown then
 323: LD_EXP 14
 327: IFFALSE 345
// team := team ^ Brown ;
 329: LD_ADDR_VAR 0 5
 333: PUSH
 334: LD_VAR 0 5
 338: PUSH
 339: LD_EXP 14
 343: ADD
 344: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 345: LD_ADDR_VAR 0 3
 349: PUSH
 350: LD_STRING 04_other_survivors
 352: PPUSH
 353: CALL_OW 31
 357: ST_TO_ADDR
// DeleteCharacters ( 04_other_survivors ) ;
 358: LD_STRING 04_other_survivors
 360: PPUSH
 361: CALL_OW 40
// if not Lisa then
 365: LD_EXP 10
 369: NOT
 370: IFFALSE 488
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 372: LD_ADDR_EXP 11
 376: PUSH
 377: LD_STRING Cyrus
 379: PPUSH
 380: LD_EXP 1
 384: NOT
 385: PPUSH
 386: CALL 4701 0 2
 390: ST_TO_ADDR
// if Cyrus then
 391: LD_EXP 11
 395: IFFALSE 413
// team := team ^ Cyrus ;
 397: LD_ADDR_VAR 0 5
 401: PUSH
 402: LD_VAR 0 5
 406: PUSH
 407: LD_EXP 11
 411: ADD
 412: ST_TO_ADDR
// if not Cyrus then
 413: LD_EXP 11
 417: NOT
 418: IFFALSE 488
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 420: LD_ADDR_EXP 12
 424: PUSH
 425: LD_STRING Bobby
 427: PPUSH
 428: LD_EXP 1
 432: NOT
 433: PPUSH
 434: CALL 4701 0 2
 438: ST_TO_ADDR
// if Bobby then
 439: LD_EXP 12
 443: IFFALSE 461
// team := team ^ Bobby ;
 445: LD_ADDR_VAR 0 5
 449: PUSH
 450: LD_VAR 0 5
 454: PUSH
 455: LD_EXP 12
 459: ADD
 460: ST_TO_ADDR
// if not Bobby then
 461: LD_EXP 12
 465: NOT
 466: IFFALSE 488
// begin others3 := CreateCharacterSet ( 03_others ) ;
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: LD_STRING 03_others
 475: PPUSH
 476: CALL_OW 31
 480: ST_TO_ADDR
// DeleteCharacters ( 03_others ) ;
 481: LD_STRING 03_others
 483: PPUSH
 484: CALL_OW 40
// end ; end ; end ; if others4 then
 488: LD_VAR 0 3
 492: IFFALSE 510
// team := team ^ others4 ;
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_VAR 0 5
 503: PUSH
 504: LD_VAR 0 3
 508: ADD
 509: ST_TO_ADDR
// if others3 then
 510: LD_VAR 0 2
 514: IFFALSE 532
// team := team ^ others3 ;
 516: LD_ADDR_VAR 0 5
 520: PUSH
 521: LD_VAR 0 5
 525: PUSH
 526: LD_VAR 0 2
 530: ADD
 531: ST_TO_ADDR
// hc_class := class_scientistic ;
 532: LD_ADDR_OWVAR 28
 536: PUSH
 537: LD_INT 4
 539: ST_TO_ADDR
// hc_name := Christopher Jenner ;
 540: LD_ADDR_OWVAR 26
 544: PUSH
 545: LD_STRING Christopher Jenner
 547: ST_TO_ADDR
// hc_sex := sex_male ;
 548: LD_ADDR_OWVAR 27
 552: PUSH
 553: LD_INT 1
 555: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 556: LD_ADDR_OWVAR 29
 560: PUSH
 561: LD_INT 10
 563: PUSH
 564: LD_INT 10
 566: PUSH
 567: EMPTY
 568: LIST
 569: LIST
 570: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 571: LD_ADDR_OWVAR 33
 575: PUSH
 576: LD_STRING SecondCharsGal
 578: ST_TO_ADDR
// hc_face_number := 74 ;
 579: LD_ADDR_OWVAR 34
 583: PUSH
 584: LD_INT 74
 586: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 0 , 2 ] ;
 587: LD_ADDR_OWVAR 30
 591: PUSH
 592: LD_INT 0
 594: PUSH
 595: LD_INT 1
 597: PUSH
 598: LD_INT 0
 600: PUSH
 601: LD_INT 2
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 0 , 5 ] ;
 610: LD_ADDR_OWVAR 31
 614: PUSH
 615: LD_INT 1
 617: PUSH
 618: LD_INT 0
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 5
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// team := team ^ CreateHuman ;
 633: LD_ADDR_VAR 0 5
 637: PUSH
 638: LD_VAR 0 5
 642: PUSH
 643: CALL_OW 44
 647: ADD
 648: ST_TO_ADDR
// hc_name := Phil Higgins ;
 649: LD_ADDR_OWVAR 26
 653: PUSH
 654: LD_STRING Phil Higgins
 656: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
 657: LD_ADDR_OWVAR 33
 661: PUSH
 662: LD_STRING SecondCharsGal
 664: ST_TO_ADDR
// hc_face_number := 73 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 73
 672: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
 673: LD_ADDR_OWVAR 29
 677: PUSH
 678: LD_INT 12
 680: PUSH
 681: LD_INT 9
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: ST_TO_ADDR
// hc_basic_skills := [ 2 , 0 , 0 , 1 ] ;
 688: LD_ADDR_OWVAR 30
 692: PUSH
 693: LD_INT 2
 695: PUSH
 696: LD_INT 0
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 1
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: LIST
 709: LIST
 710: ST_TO_ADDR
// hc_skills := [ 3 , 0 , 0 , 3 ] ;
 711: LD_ADDR_OWVAR 31
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 0
 721: PUSH
 722: LD_INT 0
 724: PUSH
 725: LD_INT 3
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: ST_TO_ADDR
// team := team ^ CreateHuman ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: LD_VAR 0 5
 743: PUSH
 744: CALL_OW 44
 748: ADD
 749: ST_TO_ADDR
// InitHc_All ( ) ;
 750: CALL_OW 584
// if team < 9 then
 754: LD_VAR 0 5
 758: PUSH
 759: LD_INT 9
 761: LESS
 762: IFFALSE 811
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 4 ) ;
 764: LD_INT 0
 766: PPUSH
 767: LD_INT 1
 769: PPUSH
 770: LD_INT 4
 772: PPUSH
 773: CALL_OW 12
 777: PPUSH
 778: LD_INT 4
 780: PPUSH
 781: CALL_OW 380
// team := team ^ CreateHuman ;
 785: LD_ADDR_VAR 0 5
 789: PUSH
 790: LD_VAR 0 5
 794: PUSH
 795: CALL_OW 44
 799: ADD
 800: ST_TO_ADDR
// until team = 9 ;
 801: LD_VAR 0 5
 805: PUSH
 806: LD_INT 9
 808: EQUAL
 809: IFFALSE 764
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 811: LD_ADDR_VAR 0 6
 815: PUSH
 816: LD_INT 30
 818: PUSH
 819: LD_INT 0
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PPUSH
 826: CALL_OW 69
 830: PUSH
 831: LD_INT 1
 833: ARRAY
 834: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 835: LD_ADDR_VAR 0 7
 839: PUSH
 840: LD_INT 30
 842: PUSH
 843: LD_INT 4
 845: PUSH
 846: EMPTY
 847: LIST
 848: LIST
 849: PPUSH
 850: CALL_OW 69
 854: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 855: LD_ADDR_VAR 0 8
 859: PUSH
 860: LD_INT 2
 862: PUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 7
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: LD_INT 30
 875: PUSH
 876: LD_INT 6
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: LIST
 887: PPUSH
 888: CALL_OW 69
 892: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 893: LD_ADDR_VAR 0 9
 897: PUSH
 898: LD_INT 30
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PPUSH
 908: CALL_OW 69
 912: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 913: LD_ADDR_VAR 0 10
 917: PUSH
 918: LD_INT 2
 920: PUSH
 921: LD_INT 30
 923: PUSH
 924: LD_INT 32
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 30
 933: PUSH
 934: LD_INT 31
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: PUSH
 941: EMPTY
 942: LIST
 943: LIST
 944: LIST
 945: PPUSH
 946: CALL_OW 69
 950: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 951: LD_VAR 0 6
 955: PPUSH
 956: LD_STRING Gamma
 958: PPUSH
 959: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 963: LD_VAR 0 6
 967: PPUSH
 968: CALL_OW 274
 972: PPUSH
 973: LD_INT 2
 975: PPUSH
 976: LD_INT 10000
 978: PPUSH
 979: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 983: LD_VAR 0 6
 987: PPUSH
 988: CALL_OW 274
 992: PPUSH
 993: LD_INT 1
 995: PPUSH
 996: LD_INT 10000
 998: PPUSH
 999: CALL_OW 277
// if dep then
1003: LD_VAR 0 6
1007: IFFALSE 1089
// begin if Brown then
1009: LD_EXP 14
1013: IFFALSE 1049
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1015: LD_EXP 14
1019: PPUSH
1020: LD_VAR 0 6
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: CALL_OW 52
// team := team diff Brown ;
1033: LD_ADDR_VAR 0 5
1037: PUSH
1038: LD_VAR 0 5
1042: PUSH
1043: LD_EXP 14
1047: DIFF
1048: ST_TO_ADDR
// end ; if Donaldson then
1049: LD_EXP 13
1053: IFFALSE 1089
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1055: LD_EXP 13
1059: PPUSH
1060: LD_VAR 0 6
1064: PUSH
1065: LD_INT 1
1067: ARRAY
1068: PPUSH
1069: CALL_OW 52
// team := team diff Donaldson ;
1073: LD_ADDR_VAR 0 5
1077: PUSH
1078: LD_VAR 0 5
1082: PUSH
1083: LD_EXP 13
1087: DIFF
1088: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1089: LD_VAR 0 10
1093: PUSH
1094: LD_VAR 0 5
1098: PPUSH
1099: LD_INT 25
1101: PUSH
1102: LD_INT 1
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: PPUSH
1109: CALL_OW 72
1113: AND
1114: IFFALSE 1223
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1116: LD_ADDR_VAR 0 11
1120: PUSH
1121: LD_VAR 0 5
1125: PPUSH
1126: LD_INT 25
1128: PUSH
1129: LD_INT 1
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: PPUSH
1136: CALL_OW 72
1140: ST_TO_ADDR
// for i in bun do
1141: LD_ADDR_VAR 0 12
1145: PUSH
1146: LD_VAR 0 10
1150: PUSH
1151: FOR_IN
1152: IFFALSE 1221
// begin if not filter then
1154: LD_VAR 0 11
1158: NOT
1159: IFFALSE 1163
// break ;
1161: GO 1221
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1163: LD_VAR 0 11
1167: PUSH
1168: LD_INT 1
1170: ARRAY
1171: PPUSH
1172: LD_VAR 0 12
1176: PPUSH
1177: CALL_OW 52
// team := team diff filter [ 1 ] ;
1181: LD_ADDR_VAR 0 5
1185: PUSH
1186: LD_VAR 0 5
1190: PUSH
1191: LD_VAR 0 11
1195: PUSH
1196: LD_INT 1
1198: ARRAY
1199: DIFF
1200: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1201: LD_ADDR_VAR 0 11
1205: PUSH
1206: LD_VAR 0 11
1210: PPUSH
1211: LD_INT 1
1213: PPUSH
1214: CALL_OW 3
1218: ST_TO_ADDR
// end ;
1219: GO 1151
1221: POP
1222: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1223: LD_VAR 0 7
1227: PUSH
1228: LD_VAR 0 5
1232: PPUSH
1233: LD_INT 25
1235: PUSH
1236: LD_INT 1
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: PPUSH
1243: CALL_OW 72
1247: AND
1248: IFFALSE 1370
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1250: LD_ADDR_VAR 0 11
1254: PUSH
1255: LD_VAR 0 5
1259: PPUSH
1260: LD_INT 25
1262: PUSH
1263: LD_INT 1
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: PPUSH
1270: CALL_OW 72
1274: ST_TO_ADDR
// for i = 1 to filter do
1275: LD_ADDR_VAR 0 12
1279: PUSH
1280: DOUBLE
1281: LD_INT 1
1283: DEC
1284: ST_TO_ADDR
1285: LD_VAR 0 11
1289: PUSH
1290: FOR_TO
1291: IFFALSE 1352
// begin if ( i <= 6 ) then
1293: LD_VAR 0 12
1297: PUSH
1298: LD_INT 6
1300: LESSEQUAL
1301: IFFALSE 1329
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1303: LD_VAR 0 11
1307: PUSH
1308: LD_VAR 0 12
1312: ARRAY
1313: PPUSH
1314: LD_VAR 0 7
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PPUSH
1323: CALL_OW 52
1327: GO 1350
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1329: LD_VAR 0 11
1333: PUSH
1334: LD_VAR 0 12
1338: ARRAY
1339: PPUSH
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 49
// end ;
1350: GO 1290
1352: POP
1353: POP
// team := team diff filter ;
1354: LD_ADDR_VAR 0 5
1358: PUSH
1359: LD_VAR 0 5
1363: PUSH
1364: LD_VAR 0 11
1368: DIFF
1369: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1370: LD_VAR 0 8
1374: PUSH
1375: LD_VAR 0 5
1379: PPUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 4
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PPUSH
1390: CALL_OW 72
1394: AND
1395: IFFALSE 1517
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1397: LD_ADDR_VAR 0 11
1401: PUSH
1402: LD_VAR 0 5
1406: PPUSH
1407: LD_INT 25
1409: PUSH
1410: LD_INT 4
1412: PUSH
1413: EMPTY
1414: LIST
1415: LIST
1416: PPUSH
1417: CALL_OW 72
1421: ST_TO_ADDR
// for i = 1 to filter do
1422: LD_ADDR_VAR 0 12
1426: PUSH
1427: DOUBLE
1428: LD_INT 1
1430: DEC
1431: ST_TO_ADDR
1432: LD_VAR 0 11
1436: PUSH
1437: FOR_TO
1438: IFFALSE 1499
// begin if ( i <= 6 ) then
1440: LD_VAR 0 12
1444: PUSH
1445: LD_INT 6
1447: LESSEQUAL
1448: IFFALSE 1476
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1450: LD_VAR 0 11
1454: PUSH
1455: LD_VAR 0 12
1459: ARRAY
1460: PPUSH
1461: LD_VAR 0 8
1465: PUSH
1466: LD_INT 1
1468: ARRAY
1469: PPUSH
1470: CALL_OW 52
1474: GO 1497
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1476: LD_VAR 0 11
1480: PUSH
1481: LD_VAR 0 12
1485: ARRAY
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 0
1492: PPUSH
1493: CALL_OW 49
// end ;
1497: GO 1437
1499: POP
1500: POP
// team := team diff filter ;
1501: LD_ADDR_VAR 0 5
1505: PUSH
1506: LD_VAR 0 5
1510: PUSH
1511: LD_VAR 0 11
1515: DIFF
1516: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1517: LD_VAR 0 9
1521: PUSH
1522: LD_VAR 0 5
1526: PPUSH
1527: LD_INT 25
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PPUSH
1537: CALL_OW 72
1541: AND
1542: IFFALSE 1664
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1544: LD_ADDR_VAR 0 11
1548: PUSH
1549: LD_VAR 0 5
1553: PPUSH
1554: LD_INT 25
1556: PUSH
1557: LD_INT 3
1559: PUSH
1560: EMPTY
1561: LIST
1562: LIST
1563: PPUSH
1564: CALL_OW 72
1568: ST_TO_ADDR
// for i = 1 to filter do
1569: LD_ADDR_VAR 0 12
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_VAR 0 11
1583: PUSH
1584: FOR_TO
1585: IFFALSE 1646
// begin if ( i <= 6 ) then
1587: LD_VAR 0 12
1591: PUSH
1592: LD_INT 6
1594: LESSEQUAL
1595: IFFALSE 1623
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1597: LD_VAR 0 11
1601: PUSH
1602: LD_VAR 0 12
1606: ARRAY
1607: PPUSH
1608: LD_VAR 0 9
1612: PUSH
1613: LD_INT 1
1615: ARRAY
1616: PPUSH
1617: CALL_OW 52
1621: GO 1644
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1623: LD_VAR 0 11
1627: PUSH
1628: LD_VAR 0 12
1632: ARRAY
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: LD_INT 0
1639: PPUSH
1640: CALL_OW 49
// end ;
1644: GO 1584
1646: POP
1647: POP
// team := team diff filter ;
1648: LD_ADDR_VAR 0 5
1652: PUSH
1653: LD_VAR 0 5
1657: PUSH
1658: LD_VAR 0 11
1662: DIFF
1663: ST_TO_ADDR
// end ; if team then
1664: LD_VAR 0 5
1668: IFFALSE 1711
// for i in team do
1670: LD_ADDR_VAR 0 12
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: FOR_IN
1681: IFFALSE 1709
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1683: LD_VAR 0 12
1687: PPUSH
1688: LD_INT 1
1690: PPUSH
1691: LD_INT 0
1693: PPUSH
1694: CALL_OW 49
// ComHold ( i ) ;
1698: LD_VAR 0 12
1702: PPUSH
1703: CALL_OW 140
// end ;
1707: GO 1680
1709: POP
1710: POP
// if fac then
1711: LD_VAR 0 9
1715: IFFALSE 1751
// if UnitsInside ( fac [ 1 ] ) then
1717: LD_VAR 0 9
1721: PUSH
1722: LD_INT 1
1724: ARRAY
1725: PPUSH
1726: CALL_OW 313
1730: IFFALSE 1751
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1732: LD_VAR 0 9
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_INT 10
1743: PPUSH
1744: LD_INT 0
1746: PPUSH
1747: CALL_OW 486
// if lab then
1751: LD_VAR 0 8
1755: IFFALSE 1791
// if UnitsInside ( lab [ 1 ] ) then
1757: LD_VAR 0 8
1761: PUSH
1762: LD_INT 1
1764: ARRAY
1765: PPUSH
1766: CALL_OW 313
1770: IFFALSE 1791
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1772: LD_VAR 0 8
1776: PUSH
1777: LD_INT 1
1779: ARRAY
1780: PPUSH
1781: LD_INT 10
1783: PPUSH
1784: LD_INT 0
1786: PPUSH
1787: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1791: LD_ADDR_VAR 0 4
1795: PUSH
1796: LD_INT 1
1798: PPUSH
1799: LD_INT 1
1801: PPUSH
1802: LD_INT 1
1804: PPUSH
1805: LD_INT 2
1807: PPUSH
1808: LD_INT 1
1810: PPUSH
1811: LD_INT 3
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 4764 0 7
1821: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1822: LD_VAR 0 4
1826: PPUSH
1827: LD_INT 2
1829: PPUSH
1830: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1834: LD_VAR 0 4
1838: PPUSH
1839: LD_INT 21
1841: PPUSH
1842: LD_INT 8
1844: PPUSH
1845: LD_INT 0
1847: PPUSH
1848: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1852: LD_EXP 7
1856: PPUSH
1857: LD_VAR 0 4
1861: PPUSH
1862: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1866: LD_ADDR_VAR 0 4
1870: PUSH
1871: LD_INT 1
1873: PPUSH
1874: LD_INT 1
1876: PPUSH
1877: LD_INT 1
1879: PPUSH
1880: LD_INT 2
1882: PPUSH
1883: LD_INT 1
1885: PPUSH
1886: LD_INT 2
1888: PPUSH
1889: LD_INT 100
1891: PPUSH
1892: CALL 4764 0 7
1896: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1897: LD_VAR 0 4
1901: PPUSH
1902: LD_INT 2
1904: PPUSH
1905: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1909: LD_VAR 0 4
1913: PPUSH
1914: LD_INT 16
1916: PPUSH
1917: LD_INT 3
1919: PPUSH
1920: LD_INT 0
1922: PPUSH
1923: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1927: LD_EXP 8
1931: PPUSH
1932: LD_VAR 0 4
1936: PPUSH
1937: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1941: LD_ADDR_VAR 0 4
1945: PUSH
1946: LD_INT 1
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 2
1954: PPUSH
1955: LD_INT 2
1957: PPUSH
1958: LD_INT 1
1960: PPUSH
1961: LD_INT 12
1963: PPUSH
1964: LD_INT 100
1966: PPUSH
1967: CALL 4764 0 7
1971: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1972: LD_VAR 0 4
1976: PPUSH
1977: LD_INT 0
1979: PPUSH
1980: LD_INT 5
1982: PPUSH
1983: CALL_OW 12
1987: PPUSH
1988: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1992: LD_VAR 0 4
1996: PPUSH
1997: LD_INT 1
1999: PPUSH
2000: LD_INT 0
2002: PPUSH
2003: CALL_OW 49
// end ;
2007: LD_VAR 0 1
2011: RET
// function PrepareBase ; var blist , i , b ; begin
2012: LD_INT 0
2014: PPUSH
2015: PPUSH
2016: PPUSH
2017: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2018: LD_INT 71
2020: PPUSH
2021: LD_INT 5
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2031: LD_ADDR_VAR 0 2
2035: PUSH
2036: LD_STRING GammaBase
2038: PPUSH
2039: EMPTY
2040: PPUSH
2041: CALL_OW 30
2045: ST_TO_ADDR
// if not blist then
2046: LD_VAR 0 2
2050: NOT
2051: IFFALSE 2091
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: LD_INT 0
2060: PUSH
2061: LD_INT 52
2063: PUSH
2064: LD_INT 12
2066: PUSH
2067: LD_INT 3
2069: PUSH
2070: LD_INT 3
2072: PUSH
2073: LD_INT 0
2075: PUSH
2076: LD_INT 0
2078: PUSH
2079: EMPTY
2080: LIST
2081: LIST
2082: LIST
2083: LIST
2084: LIST
2085: LIST
2086: LIST
2087: PUSH
2088: EMPTY
2089: LIST
2090: ST_TO_ADDR
// uc_side := 1 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 1
2098: ST_TO_ADDR
// uc_nation := 1 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 1
2106: ST_TO_ADDR
// for i in blist do
2107: LD_ADDR_VAR 0 3
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: FOR_IN
2118: IFFALSE 2311
// begin InitBc ;
2120: CALL_OW 21
// bc_type := i [ 1 ] ;
2124: LD_ADDR_OWVAR 42
2128: PUSH
2129: LD_VAR 0 3
2133: PUSH
2134: LD_INT 1
2136: ARRAY
2137: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2138: LD_ADDR_OWVAR 43
2142: PUSH
2143: LD_VAR 0 3
2147: PUSH
2148: LD_INT 5
2150: ARRAY
2151: ST_TO_ADDR
// bc_kind1 := b_lab_basic ;
2152: LD_ADDR_OWVAR 44
2156: PUSH
2157: LD_INT 9
2159: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
2160: LD_ADDR_OWVAR 45
2164: PUSH
2165: LD_INT 9
2167: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2168: LD_VAR 0 3
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: PUSH
2177: LD_INT 7
2179: PUSH
2180: LD_INT 8
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: IN
2187: IFFALSE 2239
// begin bc_kind1 := i [ 7 ] ;
2189: LD_ADDR_OWVAR 44
2193: PUSH
2194: LD_VAR 0 3
2198: PUSH
2199: LD_INT 7
2201: ARRAY
2202: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
2203: LD_ADDR_OWVAR 45
2207: PUSH
2208: LD_INT 9
2210: ST_TO_ADDR
// if i [ 1 ] = b_lab_full then
2211: LD_VAR 0 3
2215: PUSH
2216: LD_INT 1
2218: ARRAY
2219: PUSH
2220: LD_INT 8
2222: EQUAL
2223: IFFALSE 2239
// bc_kind2 := i [ 8 ] ;
2225: LD_ADDR_OWVAR 45
2229: PUSH
2230: LD_VAR 0 3
2234: PUSH
2235: LD_INT 8
2237: ARRAY
2238: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2239: LD_ADDR_VAR 0 4
2243: PUSH
2244: LD_VAR 0 3
2248: PUSH
2249: LD_INT 2
2251: ARRAY
2252: PPUSH
2253: LD_VAR 0 3
2257: PUSH
2258: LD_INT 3
2260: ARRAY
2261: PPUSH
2262: LD_VAR 0 3
2266: PUSH
2267: LD_INT 4
2269: ARRAY
2270: PPUSH
2271: CALL_OW 47
2275: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2276: LD_VAR 0 4
2280: PPUSH
2281: CALL_OW 266
2285: PUSH
2286: LD_INT 32
2288: EQUAL
2289: IFFALSE 2309
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2291: LD_VAR 0 4
2295: PPUSH
2296: LD_VAR 0 3
2300: PUSH
2301: LD_INT 7
2303: ARRAY
2304: PPUSH
2305: CALL_OW 431
// end ; end ;
2309: GO 2117
2311: POP
2312: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2313: LD_INT 30
2315: PUSH
2316: LD_INT 0
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PPUSH
2323: CALL_OW 69
2327: NOT
2328: IFFALSE 2365
// begin bc_type := b_depot ;
2330: LD_ADDR_OWVAR 42
2334: PUSH
2335: LD_INT 0
2337: ST_TO_ADDR
// bc_level := 6 ;
2338: LD_ADDR_OWVAR 43
2342: PUSH
2343: LD_INT 6
2345: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2346: LD_ADDR_VAR 0 4
2350: PUSH
2351: LD_INT 52
2353: PPUSH
2354: LD_INT 12
2356: PPUSH
2357: LD_INT 3
2359: PPUSH
2360: CALL_OW 47
2364: ST_TO_ADDR
// end ; end ; end_of_file
2365: LD_VAR 0 1
2369: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2370: LD_INT 0
2372: PPUSH
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
2377: PPUSH
2378: PPUSH
2379: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
2380: LD_INT 0
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: LD_INT 1
2388: PPUSH
2389: LD_INT 32976
2391: NEG
2392: PPUSH
2393: CALL_OW 330
// InGameOn ;
2397: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2401: LD_INT 33
2403: PPUSH
2404: LD_INT 11
2406: PPUSH
2407: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2411: LD_ADDR_VAR 0 2
2415: PUSH
2416: LD_INT 29
2418: PUSH
2419: LD_INT 21
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 41
2428: PUSH
2429: LD_INT 28
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 52
2438: PUSH
2439: LD_INT 26
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PUSH
2446: LD_INT 49
2448: PUSH
2449: LD_INT 16
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i in points do
2462: LD_ADDR_VAR 0 3
2466: PUSH
2467: LD_VAR 0 2
2471: PUSH
2472: FOR_IN
2473: IFFALSE 2513
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2475: LD_EXP 7
2479: PUSH
2480: LD_EXP 8
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: PPUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_INT 1
2496: ARRAY
2497: PPUSH
2498: LD_VAR 0 3
2502: PUSH
2503: LD_INT 2
2505: ARRAY
2506: PPUSH
2507: CALL_OW 171
2511: GO 2472
2513: POP
2514: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2515: LD_EXP 7
2519: PUSH
2520: LD_EXP 8
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: PPUSH
2529: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2533: LD_INT 35
2535: PPUSH
2536: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2540: LD_EXP 7
2544: PPUSH
2545: CALL_OW 310
2549: NOT
2550: PUSH
2551: LD_EXP 8
2555: PPUSH
2556: CALL_OW 310
2560: NOT
2561: AND
2562: IFFALSE 2533
// ComTurnUnit ( JMM , Gladstone ) ;
2564: LD_EXP 7
2568: PPUSH
2569: LD_EXP 8
2573: PPUSH
2574: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2578: LD_EXP 8
2582: PPUSH
2583: LD_EXP 7
2587: PPUSH
2588: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2592: LD_ADDR_VAR 0 4
2596: PUSH
2597: LD_INT 26
2599: PUSH
2600: LD_INT 1
2602: PUSH
2603: EMPTY
2604: LIST
2605: LIST
2606: PPUSH
2607: CALL_OW 69
2611: PUSH
2612: LD_EXP 7
2616: PUSH
2617: LD_EXP 8
2621: PUSH
2622: LD_EXP 12
2626: PUSH
2627: LD_EXP 11
2631: PUSH
2632: LD_EXP 9
2636: PUSH
2637: LD_EXP 14
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: DIFF
2650: ST_TO_ADDR
// if sol then
2651: LD_VAR 0 4
2655: IFFALSE 2671
// sol := sol [ 1 ] ;
2657: LD_ADDR_VAR 0 4
2661: PUSH
2662: LD_VAR 0 4
2666: PUSH
2667: LD_INT 1
2669: ARRAY
2670: ST_TO_ADDR
// team := [ ] ;
2671: LD_ADDR_VAR 0 5
2675: PUSH
2676: EMPTY
2677: ST_TO_ADDR
// if sol then
2678: LD_VAR 0 4
2682: IFFALSE 2700
// team := team ^ sol ;
2684: LD_ADDR_VAR 0 5
2688: PUSH
2689: LD_VAR 0 5
2693: PUSH
2694: LD_VAR 0 4
2698: ADD
2699: ST_TO_ADDR
// if Lisa then
2700: LD_EXP 10
2704: IFFALSE 2722
// team := team ^ Lisa ;
2706: LD_ADDR_VAR 0 5
2710: PUSH
2711: LD_VAR 0 5
2715: PUSH
2716: LD_EXP 10
2720: ADD
2721: ST_TO_ADDR
// if Donaldson then
2722: LD_EXP 13
2726: IFFALSE 2744
// team := team ^ Donaldson ;
2728: LD_ADDR_VAR 0 5
2732: PUSH
2733: LD_VAR 0 5
2737: PUSH
2738: LD_EXP 13
2742: ADD
2743: ST_TO_ADDR
// if Brown then
2744: LD_EXP 14
2748: IFFALSE 2766
// team := team ^ Brown ;
2750: LD_ADDR_VAR 0 5
2754: PUSH
2755: LD_VAR 0 5
2759: PUSH
2760: LD_EXP 14
2764: ADD
2765: ST_TO_ADDR
// if Bobby then
2766: LD_EXP 12
2770: IFFALSE 2788
// team := team ^ Bobby ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 12
2786: ADD
2787: ST_TO_ADDR
// if Cyrus then
2788: LD_EXP 11
2792: IFFALSE 2810
// team := team ^ Cyrus ;
2794: LD_ADDR_VAR 0 5
2798: PUSH
2799: LD_VAR 0 5
2803: PUSH
2804: LD_EXP 11
2808: ADD
2809: ST_TO_ADDR
// if Frank then
2810: LD_EXP 9
2814: IFFALSE 2832
// team := team ^ Frank ;
2816: LD_ADDR_VAR 0 5
2820: PUSH
2821: LD_VAR 0 5
2825: PUSH
2826: LD_EXP 9
2830: ADD
2831: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2832: LD_ADDR_VAR 0 3
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 3
2842: PUSH
2843: LD_INT 54
2845: PUSH
2846: EMPTY
2847: LIST
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PUSH
2853: LD_INT 21
2855: PUSH
2856: LD_INT 1
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: PPUSH
2867: CALL_OW 70
2871: PUSH
2872: LD_EXP 7
2876: PUSH
2877: LD_EXP 8
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: DIFF
2886: PUSH
2887: EMPTY
2888: LIST
2889: PUSH
2890: FOR_IN
2891: IFFALSE 2911
// team := team ^ i ;
2893: LD_ADDR_VAR 0 5
2897: PUSH
2898: LD_VAR 0 5
2902: PUSH
2903: LD_VAR 0 3
2907: ADD
2908: ST_TO_ADDR
2909: GO 2890
2911: POP
2912: POP
// if team then
2913: LD_VAR 0 5
2917: IFFALSE 2993
// begin ComExitBuilding ( team ) ;
2919: LD_VAR 0 5
2923: PPUSH
2924: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2928: LD_VAR 0 5
2932: PPUSH
2933: LD_EXP 7
2937: PPUSH
2938: CALL_OW 172
// repeat wait ( 1 ) ;
2942: LD_INT 1
2944: PPUSH
2945: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2949: LD_EXP 7
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_EXP 7
2963: PPUSH
2964: CALL_OW 74
2968: PPUSH
2969: CALL_OW 296
2973: PUSH
2974: LD_INT 6
2976: LESS
2977: IFFALSE 2942
// ComTurnUnit ( team , JMM ) ;
2979: LD_VAR 0 5
2983: PPUSH
2984: LD_EXP 7
2988: PPUSH
2989: CALL_OW 119
// end ; if Lisa then
2993: LD_EXP 10
2997: IFFALSE 3025
// begin ComTurnUnit ( JMM , Lisa ) ;
2999: LD_EXP 7
3003: PPUSH
3004: LD_EXP 10
3008: PPUSH
3009: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
3013: LD_EXP 10
3017: PPUSH
3018: LD_STRING D1-Lisa-1
3020: PPUSH
3021: CALL_OW 88
// end ; if sol then
3025: LD_VAR 0 4
3029: IFFALSE 3057
// begin ComTurnUnit ( JMM , sol ) ;
3031: LD_EXP 7
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
3045: LD_VAR 0 4
3049: PPUSH
3050: LD_STRING D1-Sol1-1
3052: PPUSH
3053: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
3057: LD_EXP 7
3061: PPUSH
3062: LD_STRING D1-JMM-1
3064: PPUSH
3065: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
3069: LD_EXP 7
3073: PPUSH
3074: LD_STRING D1-JMM-1a
3076: PPUSH
3077: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
3081: LD_EXP 7
3085: PPUSH
3086: LD_EXP 8
3090: PPUSH
3091: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
3095: LD_VAR 0 5
3099: PPUSH
3100: LD_EXP 8
3104: PPUSH
3105: CALL_OW 119
// if Frank then
3109: LD_EXP 9
3113: IFFALSE 3141
// begin Say ( Frank , D1-Frank-1 ) ;
3115: LD_EXP 9
3119: PPUSH
3120: LD_STRING D1-Frank-1
3122: PPUSH
3123: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
3127: LD_EXP 7
3131: PPUSH
3132: LD_EXP 9
3136: PPUSH
3137: CALL_OW 119
// end ; if Lisa then
3141: LD_EXP 10
3145: IFFALSE 3173
// begin ComTurnUnit ( JMM , Lisa ) ;
3147: LD_EXP 7
3151: PPUSH
3152: LD_EXP 10
3156: PPUSH
3157: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
3161: LD_EXP 10
3165: PPUSH
3166: LD_STRING D1-Lisa-2
3168: PPUSH
3169: CALL_OW 88
// end ; if sol then
3173: LD_VAR 0 4
3177: IFFALSE 3205
// begin ComTurnUnit ( JMM , sol ) ;
3179: LD_EXP 7
3183: PPUSH
3184: LD_VAR 0 4
3188: PPUSH
3189: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
3193: LD_VAR 0 4
3197: PPUSH
3198: LD_STRING D1-Sol1-2
3200: PPUSH
3201: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
3205: LD_EXP 8
3209: PPUSH
3210: LD_STRING D1-Glad-2
3212: PPUSH
3213: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
3217: LD_VAR 0 5
3221: PPUSH
3222: LD_EXP 7
3226: PPUSH
3227: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
3231: LD_EXP 7
3235: PPUSH
3236: LD_STRING D1-JMM-2
3238: PPUSH
3239: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
3243: LD_EXP 7
3247: PPUSH
3248: LD_EXP 8
3252: PPUSH
3253: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
3257: LD_EXP 8
3261: PPUSH
3262: LD_STRING D1-Glad-3
3264: PPUSH
3265: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3269: LD_EXP 7
3273: PPUSH
3274: LD_STRING D1-JMM-3
3276: PPUSH
3277: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
3281: LD_EXP 8
3285: PPUSH
3286: LD_STRING D1-Glad-4
3288: PPUSH
3289: CALL_OW 88
// if Frank then
3293: LD_EXP 9
3297: IFFALSE 3325
// begin ComTurnUnit ( JMM , Frank ) ;
3299: LD_EXP 7
3303: PPUSH
3304: LD_EXP 9
3308: PPUSH
3309: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
3313: LD_EXP 9
3317: PPUSH
3318: LD_STRING D1-Frank-4
3320: PPUSH
3321: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3325: LD_EXP 7
3329: PPUSH
3330: LD_EXP 8
3334: PPUSH
3335: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
3339: LD_EXP 7
3343: PPUSH
3344: LD_STRING D1-JMM-4
3346: PPUSH
3347: CALL_OW 88
// if Lisa then
3351: LD_EXP 10
3355: IFFALSE 3422
// begin Say ( Lisa , D1-Lisa-4 ) ;
3357: LD_EXP 10
3361: PPUSH
3362: LD_STRING D1-Lisa-4
3364: PPUSH
3365: CALL_OW 88
// if Frank then
3369: LD_EXP 9
3373: IFFALSE 3422
// begin ComTurnUnit ( Frank , Lisa ) ;
3375: LD_EXP 9
3379: PPUSH
3380: LD_EXP 10
3384: PPUSH
3385: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3389: LD_EXP 9
3393: PPUSH
3394: LD_STRING D1-Frank-5
3396: PPUSH
3397: CALL_OW 88
// Wait ( 3 ) ;
3401: LD_INT 3
3403: PPUSH
3404: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3408: LD_EXP 9
3412: PPUSH
3413: LD_EXP 7
3417: PPUSH
3418: CALL_OW 179
// end ; end ; if sol then
3422: LD_VAR 0 4
3426: IFFALSE 3440
// Say ( sol , D1-Sol1-5 ) ;
3428: LD_VAR 0 4
3432: PPUSH
3433: LD_STRING D1-Sol1-5
3435: PPUSH
3436: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3440: LD_EXP 7
3444: PPUSH
3445: LD_STRING D1-JMM-5
3447: PPUSH
3448: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3452: LD_EXP 8
3456: PPUSH
3457: LD_STRING D1-Glad-5
3459: PPUSH
3460: CALL_OW 88
// if Frank then
3464: LD_EXP 9
3468: IFFALSE 3482
// Say ( Frank , D1-Frank-6 ) ;
3470: LD_EXP 9
3474: PPUSH
3475: LD_STRING D1-Frank-6
3477: PPUSH
3478: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3482: LD_EXP 7
3486: PPUSH
3487: LD_STRING D1-JMM-6
3489: PPUSH
3490: CALL_OW 88
// if Brown and Donaldson then
3494: LD_EXP 14
3498: PUSH
3499: LD_EXP 13
3503: AND
3504: IFFALSE 3553
// case Query ( QCommander ) of 1 :
3506: LD_STRING QCommander
3508: PPUSH
3509: CALL_OW 97
3513: PUSH
3514: LD_INT 1
3516: DOUBLE
3517: EQUAL
3518: IFTRUE 3522
3520: GO 3533
3522: POP
// donaldson_commander := true ; 2 :
3523: LD_ADDR_EXP 4
3527: PUSH
3528: LD_INT 1
3530: ST_TO_ADDR
3531: GO 3553
3533: LD_INT 2
3535: DOUBLE
3536: EQUAL
3537: IFTRUE 3541
3539: GO 3552
3541: POP
// brown_commander := true ; end ;
3542: LD_ADDR_EXP 5
3546: PUSH
3547: LD_INT 1
3549: ST_TO_ADDR
3550: GO 3553
3552: POP
// if not Brown and Donaldson then
3553: LD_EXP 14
3557: NOT
3558: PUSH
3559: LD_EXP 13
3563: AND
3564: IFFALSE 3574
// donaldson_commander := true ;
3566: LD_ADDR_EXP 4
3570: PUSH
3571: LD_INT 1
3573: ST_TO_ADDR
// if Brown and not Donaldson then
3574: LD_EXP 14
3578: PUSH
3579: LD_EXP 13
3583: NOT
3584: AND
3585: IFFALSE 3595
// brown_commander := true ;
3587: LD_ADDR_EXP 5
3591: PUSH
3592: LD_INT 1
3594: ST_TO_ADDR
// if donaldson_commander then
3595: LD_EXP 4
3599: IFFALSE 3746
// begin ComTurnUnit ( JMM , Donaldson ) ;
3601: LD_EXP 7
3605: PPUSH
3606: LD_EXP 13
3610: PPUSH
3611: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3615: LD_EXP 7
3619: PPUSH
3620: LD_STRING D1a-JMM-1
3622: PPUSH
3623: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3627: LD_EXP 13
3631: PPUSH
3632: LD_EXP 7
3636: PPUSH
3637: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3641: LD_EXP 13
3645: PPUSH
3646: LD_EXP 7
3650: PPUSH
3651: CALL_OW 179
// Wait ( 3 ) ;
3655: LD_INT 3
3657: PPUSH
3658: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3662: LD_EXP 13
3666: PPUSH
3667: LD_STRING D1a-Don-1
3669: PPUSH
3670: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3674: LD_EXP 7
3678: PPUSH
3679: LD_STRING D1b-JMM-2
3681: PPUSH
3682: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3686: LD_EXP 13
3690: PPUSH
3691: LD_STRING D1a-Don-2
3693: PPUSH
3694: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3698: LD_EXP 13
3702: PPUSH
3703: LD_INT 30
3705: PUSH
3706: LD_INT 0
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PUSH
3718: LD_INT 1
3720: ARRAY
3721: PPUSH
3722: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3726: LD_INT 1
3728: PPUSH
3729: LD_STRING GammaCommander
3731: PPUSH
3732: CALL_OW 39
// commander := Donaldson ;
3736: LD_ADDR_VAR 0 7
3740: PUSH
3741: LD_EXP 13
3745: ST_TO_ADDR
// end ; if brown_commander then
3746: LD_EXP 5
3750: IFFALSE 3897
// begin ComTurnUnit ( JMM , Brown ) ;
3752: LD_EXP 7
3756: PPUSH
3757: LD_EXP 14
3761: PPUSH
3762: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3766: LD_EXP 7
3770: PPUSH
3771: LD_STRING D1b-JMM-1
3773: PPUSH
3774: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3778: LD_EXP 14
3782: PPUSH
3783: LD_EXP 7
3787: PPUSH
3788: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3792: LD_EXP 14
3796: PPUSH
3797: LD_EXP 7
3801: PPUSH
3802: CALL_OW 179
// Wait ( 3 ) ;
3806: LD_INT 3
3808: PPUSH
3809: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3813: LD_EXP 14
3817: PPUSH
3818: LD_STRING D1b-Brown-1
3820: PPUSH
3821: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3825: LD_EXP 7
3829: PPUSH
3830: LD_STRING D1a-JMM-2
3832: PPUSH
3833: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3837: LD_EXP 14
3841: PPUSH
3842: LD_STRING D1b-Brown-2
3844: PPUSH
3845: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3849: LD_EXP 14
3853: PPUSH
3854: LD_INT 30
3856: PUSH
3857: LD_INT 0
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: PUSH
3869: LD_INT 1
3871: ARRAY
3872: PPUSH
3873: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3877: LD_INT 2
3879: PPUSH
3880: LD_STRING GammaCommander
3882: PPUSH
3883: CALL_OW 39
// commander := Brown ;
3887: LD_ADDR_VAR 0 7
3891: PUSH
3892: LD_EXP 14
3896: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3897: LD_EXP 7
3901: PPUSH
3902: LD_EXP 8
3906: PPUSH
3907: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3911: LD_EXP 4
3915: NOT
3916: PUSH
3917: LD_EXP 5
3921: NOT
3922: AND
3923: IFFALSE 3947
// begin Say ( JMM , D1c-JMM-1 ) ;
3925: LD_EXP 7
3929: PPUSH
3930: LD_STRING D1c-JMM-1
3932: PPUSH
3933: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3937: LD_INT 3
3939: PPUSH
3940: LD_STRING GammaCommander
3942: PPUSH
3943: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3947: LD_EXP 7
3951: PPUSH
3952: LD_STRING D1d-JMM-1
3954: PPUSH
3955: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3959: LD_ADDR_VAR 0 6
3963: PUSH
3964: LD_INT 21
3966: PUSH
3967: LD_INT 1
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PPUSH
3974: CALL_OW 69
3978: PUSH
3979: LD_EXP 7
3983: PUSH
3984: LD_EXP 8
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: LIST
3998: DIFF
3999: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
4000: LD_ADDR_EXP 6
4004: PUSH
4005: LD_STRING 1
4007: PPUSH
4008: LD_INT 5
4010: PPUSH
4011: LD_INT 5
4013: PPUSH
4014: LD_INT -5
4016: PUSH
4017: LD_EXP 7
4021: PUSH
4022: LD_INT -6
4024: PUSH
4025: LD_EXP 8
4029: PUSH
4030: LD_INT -2
4032: PUSH
4033: LD_INT -3
4035: PUSH
4036: LD_INT -5
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: PUSH
4048: LD_VAR 0 6
4052: ADD
4053: PUSH
4054: LD_INT -6
4056: PUSH
4057: LD_INT -4
4059: PUSH
4060: LD_VAR 0 7
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: LIST
4069: ADD
4070: PPUSH
4071: LD_INT 1
4073: PUSH
4074: LD_INT 3
4076: PUSH
4077: LD_INT 2
4079: PUSH
4080: LD_INT 1
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 4
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: LIST
4095: PPUSH
4096: CALL_OW 42
4100: ST_TO_ADDR
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4101: LD_EXP 7
4105: PPUSH
4106: LD_EXP 2
4110: PUSH
4111: LD_STRING JMM
4113: STR
4114: PPUSH
4115: CALL_OW 38
// if Lisa in save_group then
4119: LD_EXP 10
4123: PUSH
4124: LD_EXP 6
4128: IN
4129: IFFALSE 4159
// begin SaveVariable ( true , LisaInDelta ) ;
4131: LD_INT 1
4133: PPUSH
4134: LD_STRING LisaInDelta
4136: PPUSH
4137: CALL_OW 39
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4141: LD_EXP 10
4145: PPUSH
4146: LD_EXP 2
4150: PUSH
4151: LD_STRING Lisa
4153: STR
4154: PPUSH
4155: CALL_OW 38
// end ; if Bobby in save_group then
4159: LD_EXP 12
4163: PUSH
4164: LD_EXP 6
4168: IN
4169: IFFALSE 4199
// begin SaveVariable ( true , BobbyInDelta ) ;
4171: LD_INT 1
4173: PPUSH
4174: LD_STRING BobbyInDelta
4176: PPUSH
4177: CALL_OW 39
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4181: LD_EXP 12
4185: PPUSH
4186: LD_EXP 2
4190: PUSH
4191: LD_STRING Bobby
4193: STR
4194: PPUSH
4195: CALL_OW 38
// end ; if Cyrus in save_group then
4199: LD_EXP 11
4203: PUSH
4204: LD_EXP 6
4208: IN
4209: IFFALSE 4239
// begin SaveVariable ( true , CyrusInDelta ) ;
4211: LD_INT 1
4213: PPUSH
4214: LD_STRING CyrusInDelta
4216: PPUSH
4217: CALL_OW 39
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4221: LD_EXP 11
4225: PPUSH
4226: LD_EXP 2
4230: PUSH
4231: LD_STRING Cyrus
4233: STR
4234: PPUSH
4235: CALL_OW 38
// end ; if Frank in save_group then
4239: LD_EXP 9
4243: PUSH
4244: LD_EXP 6
4248: IN
4249: IFFALSE 4279
// begin SaveVariable ( true , FrankInDelta ) ;
4251: LD_INT 1
4253: PPUSH
4254: LD_STRING FrankInDelta
4256: PPUSH
4257: CALL_OW 39
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
4261: LD_EXP 9
4265: PPUSH
4266: LD_EXP 2
4270: PUSH
4271: LD_STRING Frank
4273: STR
4274: PPUSH
4275: CALL_OW 38
// end ; if Brown in save_group then
4279: LD_EXP 14
4283: PUSH
4284: LD_EXP 6
4288: IN
4289: IFFALSE 4319
// begin SaveVariable ( true , BrownInDelta ) ;
4291: LD_INT 1
4293: PPUSH
4294: LD_STRING BrownInDelta
4296: PPUSH
4297: CALL_OW 39
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
4301: LD_EXP 14
4305: PPUSH
4306: LD_EXP 2
4310: PUSH
4311: LD_STRING Brown
4313: STR
4314: PPUSH
4315: CALL_OW 38
// end ; if Donaldson in save_group then
4319: LD_EXP 13
4323: PUSH
4324: LD_EXP 6
4328: IN
4329: IFFALSE 4359
// begin SaveVariable ( true , DonaldsonInDelta ) ;
4331: LD_INT 1
4333: PPUSH
4334: LD_STRING DonaldsonInDelta
4336: PPUSH
4337: CALL_OW 39
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4341: LD_EXP 13
4345: PPUSH
4346: LD_EXP 2
4350: PUSH
4351: LD_STRING Donaldson
4353: STR
4354: PPUSH
4355: CALL_OW 38
// end ; SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] ^ save_group , othersGamma ) ;
4359: LD_VAR 0 6
4363: PUSH
4364: LD_EXP 7
4368: PUSH
4369: LD_EXP 8
4373: PUSH
4374: LD_EXP 10
4378: PUSH
4379: LD_EXP 11
4383: PUSH
4384: LD_EXP 12
4388: PUSH
4389: LD_EXP 9
4393: PUSH
4394: LD_EXP 13
4398: PUSH
4399: LD_EXP 14
4403: PUSH
4404: LD_INT 0
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: PUSH
4418: LD_EXP 6
4422: ADD
4423: DIFF
4424: PPUSH
4425: LD_STRING othersGamma
4427: PPUSH
4428: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
4432: LD_EXP 6
4436: PUSH
4437: LD_EXP 7
4441: PUSH
4442: LD_EXP 8
4446: PUSH
4447: LD_EXP 10
4451: PUSH
4452: LD_EXP 11
4456: PUSH
4457: LD_EXP 12
4461: PUSH
4462: LD_EXP 9
4466: PUSH
4467: LD_EXP 13
4471: PUSH
4472: LD_EXP 14
4476: PUSH
4477: LD_INT 0
4479: PUSH
4480: EMPTY
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: LIST
4488: LIST
4489: LIST
4490: DIFF
4491: PPUSH
4492: LD_STRING othersDelta
4494: PPUSH
4495: CALL_OW 38
// Wait ( 3 ) ;
4499: LD_INT 3
4501: PPUSH
4502: CALL_OW 67
// for i in save_group do
4506: LD_ADDR_VAR 0 3
4510: PUSH
4511: LD_EXP 6
4515: PUSH
4516: FOR_IN
4517: IFFALSE 4548
// begin if IsInUnit ( i ) then
4519: LD_VAR 0 3
4523: PPUSH
4524: CALL_OW 310
4528: IFFALSE 4539
// ComExitBuilding ( i ) ;
4530: LD_VAR 0 3
4534: PPUSH
4535: CALL_OW 122
// Wait ( 3 ) ;
4539: LD_INT 3
4541: PPUSH
4542: CALL_OW 67
// end ;
4546: GO 4516
4548: POP
4549: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4550: LD_ADDR_EXP 6
4554: PUSH
4555: LD_EXP 6
4559: PPUSH
4560: LD_INT 1
4562: PPUSH
4563: LD_EXP 7
4567: PPUSH
4568: CALL_OW 2
4572: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4573: LD_ADDR_EXP 6
4577: PUSH
4578: LD_EXP 6
4582: PPUSH
4583: LD_INT 2
4585: PPUSH
4586: LD_EXP 8
4590: PPUSH
4591: CALL_OW 2
4595: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4596: LD_ADDR_VAR 0 8
4600: PUSH
4601: LD_INT 21
4603: PUSH
4604: LD_INT 2
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PPUSH
4611: CALL_OW 69
4615: ST_TO_ADDR
// for i = 1 to filter do
4616: LD_ADDR_VAR 0 3
4620: PUSH
4621: DOUBLE
4622: LD_INT 1
4624: DEC
4625: ST_TO_ADDR
4626: LD_VAR 0 8
4630: PUSH
4631: FOR_TO
4632: IFFALSE 4662
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4634: LD_EXP 6
4638: PUSH
4639: LD_VAR 0 3
4643: ARRAY
4644: PPUSH
4645: LD_VAR 0 8
4649: PUSH
4650: LD_VAR 0 3
4654: ARRAY
4655: PPUSH
4656: CALL_OW 120
4660: GO 4631
4662: POP
4663: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4664: LD_EXP 6
4668: PPUSH
4669: LD_INT 87
4671: PPUSH
4672: LD_INT 27
4674: PPUSH
4675: CALL_OW 171
// Wait ( 0 0$05 ) ;
4679: LD_INT 175
4681: PPUSH
4682: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4686: LD_INT 1
4688: PPUSH
4689: LD_STRING %_cont
4691: PPUSH
4692: CALL_OW 340
// end ; end_of_file
4696: LD_VAR 0 1
4700: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4701: LD_INT 0
4703: PPUSH
4704: PPUSH
// if exist_mode then
4705: LD_VAR 0 2
4709: IFFALSE 4734
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4711: LD_ADDR_VAR 0 4
4715: PUSH
4716: LD_EXP 3
4720: PUSH
4721: LD_VAR 0 1
4725: STR
4726: PPUSH
4727: CALL_OW 34
4731: ST_TO_ADDR
4732: GO 4749
// unit := NewCharacter ( ident ) ;
4734: LD_ADDR_VAR 0 4
4738: PUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 25
4748: ST_TO_ADDR
// result := unit ;
4749: LD_ADDR_VAR 0 3
4753: PUSH
4754: LD_VAR 0 4
4758: ST_TO_ADDR
// end ;
4759: LD_VAR 0 3
4763: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4764: LD_INT 0
4766: PPUSH
// uc_side := side ;
4767: LD_ADDR_OWVAR 20
4771: PUSH
4772: LD_VAR 0 1
4776: ST_TO_ADDR
// uc_nation := nation ;
4777: LD_ADDR_OWVAR 21
4781: PUSH
4782: LD_VAR 0 2
4786: ST_TO_ADDR
// vc_chassis := chassis ;
4787: LD_ADDR_OWVAR 37
4791: PUSH
4792: LD_VAR 0 3
4796: ST_TO_ADDR
// vc_engine := engine ;
4797: LD_ADDR_OWVAR 39
4801: PUSH
4802: LD_VAR 0 4
4806: ST_TO_ADDR
// vc_control := control ;
4807: LD_ADDR_OWVAR 38
4811: PUSH
4812: LD_VAR 0 5
4816: ST_TO_ADDR
// vc_weapon := weapon ;
4817: LD_ADDR_OWVAR 40
4821: PUSH
4822: LD_VAR 0 6
4826: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4827: LD_ADDR_OWVAR 41
4831: PUSH
4832: LD_VAR 0 7
4836: ST_TO_ADDR
// result := CreateVehicle ;
4837: LD_ADDR_VAR 0 8
4841: PUSH
4842: CALL_OW 45
4846: ST_TO_ADDR
// end ;
4847: LD_VAR 0 8
4851: RET
// export function SayX ( units , ident ) ; var i ; begin
4852: LD_INT 0
4854: PPUSH
4855: PPUSH
// result := false ;
4856: LD_ADDR_VAR 0 3
4860: PUSH
4861: LD_INT 0
4863: ST_TO_ADDR
// if not units then
4864: LD_VAR 0 1
4868: NOT
4869: IFFALSE 4873
// exit ;
4871: GO 4927
// for i in units do
4873: LD_ADDR_VAR 0 4
4877: PUSH
4878: LD_VAR 0 1
4882: PUSH
4883: FOR_IN
4884: IFFALSE 4925
// if IsOk ( i ) then
4886: LD_VAR 0 4
4890: PPUSH
4891: CALL_OW 302
4895: IFFALSE 4923
// begin Say ( i , ident ) ;
4897: LD_VAR 0 4
4901: PPUSH
4902: LD_VAR 0 2
4906: PPUSH
4907: CALL_OW 88
// result := i ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 4
4920: ST_TO_ADDR
// break ;
4921: GO 4925
// end ;
4923: GO 4883
4925: POP
4926: POP
// end ;
4927: LD_VAR 0 3
4931: RET
