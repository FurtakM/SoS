// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 2055 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05a_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05a_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , tmp ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// PrepareBase ;
 119: CALL 1776 0 0
// uc_side := 1 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// uc_nation := 1 ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// team := [ ] ;
 139: LD_ADDR_VAR 0 5
 143: PUSH
 144: EMPTY
 145: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_STRING JMM
 153: PPUSH
 154: LD_EXP 1
 158: NOT
 159: PPUSH
 160: CALL 4386 0 2
 164: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_STRING Gladstone
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: CALL 4386 0 2
 180: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_STRING Frank
 188: PPUSH
 189: LD_EXP 1
 193: NOT
 194: PPUSH
 195: CALL 4386 0 2
 199: ST_TO_ADDR
// if Frank then
 200: LD_EXP 9
 204: IFFALSE 222
// team := team ^ Frank ;
 206: LD_ADDR_VAR 0 5
 210: PUSH
 211: LD_VAR 0 5
 215: PUSH
 216: LD_EXP 9
 220: ADD
 221: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 222: LD_ADDR_EXP 10
 226: PUSH
 227: LD_STRING Lisa
 229: PPUSH
 230: LD_EXP 1
 234: NOT
 235: PPUSH
 236: CALL 4386 0 2
 240: ST_TO_ADDR
// if Lisa then
 241: LD_EXP 10
 245: IFFALSE 263
// team := team ^ Lisa ;
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_EXP 10
 261: ADD
 262: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 263: LD_ADDR_EXP 13
 267: PUSH
 268: LD_STRING Donaldson
 270: PPUSH
 271: LD_EXP 1
 275: NOT
 276: PPUSH
 277: CALL 4386 0 2
 281: ST_TO_ADDR
// if Donaldson then
 282: LD_EXP 13
 286: IFFALSE 304
// team := team ^ Donaldson ;
 288: LD_ADDR_VAR 0 5
 292: PUSH
 293: LD_VAR 0 5
 297: PUSH
 298: LD_EXP 13
 302: ADD
 303: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 304: LD_ADDR_EXP 14
 308: PUSH
 309: LD_STRING Brown
 311: PPUSH
 312: LD_EXP 1
 316: NOT
 317: PPUSH
 318: CALL 4386 0 2
 322: ST_TO_ADDR
// if Brown then
 323: LD_EXP 14
 327: IFFALSE 345
// team := team ^ Brown ;
 329: LD_ADDR_VAR 0 5
 333: PUSH
 334: LD_VAR 0 5
 338: PUSH
 339: LD_EXP 14
 343: ADD
 344: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 345: LD_ADDR_VAR 0 3
 349: PUSH
 350: LD_STRING 04_other_survivors
 352: PPUSH
 353: CALL_OW 31
 357: ST_TO_ADDR
// if not Lisa then
 358: LD_EXP 10
 362: NOT
 363: IFFALSE 474
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 365: LD_ADDR_EXP 11
 369: PUSH
 370: LD_STRING Cyrus
 372: PPUSH
 373: LD_EXP 1
 377: NOT
 378: PPUSH
 379: CALL 4386 0 2
 383: ST_TO_ADDR
// if Cyrus then
 384: LD_EXP 11
 388: IFFALSE 406
// team := team ^ Cyrus ;
 390: LD_ADDR_VAR 0 5
 394: PUSH
 395: LD_VAR 0 5
 399: PUSH
 400: LD_EXP 11
 404: ADD
 405: ST_TO_ADDR
// if not Cyrus then
 406: LD_EXP 11
 410: NOT
 411: IFFALSE 474
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 413: LD_ADDR_EXP 12
 417: PUSH
 418: LD_STRING Bobby
 420: PPUSH
 421: LD_EXP 1
 425: NOT
 426: PPUSH
 427: CALL 4386 0 2
 431: ST_TO_ADDR
// if Bobby then
 432: LD_EXP 12
 436: IFFALSE 454
// team := team ^ Bobby ;
 438: LD_ADDR_VAR 0 5
 442: PUSH
 443: LD_VAR 0 5
 447: PUSH
 448: LD_EXP 12
 452: ADD
 453: ST_TO_ADDR
// if not Bobby then
 454: LD_EXP 12
 458: NOT
 459: IFFALSE 474
// begin others3 := CreateCharacterSet ( 03_others ) ;
 461: LD_ADDR_VAR 0 2
 465: PUSH
 466: LD_STRING 03_others
 468: PPUSH
 469: CALL_OW 31
 473: ST_TO_ADDR
// end ; end ; end ; if others4 then
 474: LD_VAR 0 3
 478: IFFALSE 496
// team := team ^ others4 ;
 480: LD_ADDR_VAR 0 5
 484: PUSH
 485: LD_VAR 0 5
 489: PUSH
 490: LD_VAR 0 3
 494: ADD
 495: ST_TO_ADDR
// if others3 then
 496: LD_VAR 0 2
 500: IFFALSE 518
// team := team ^ others3 ;
 502: LD_ADDR_VAR 0 5
 506: PUSH
 507: LD_VAR 0 5
 511: PUSH
 512: LD_VAR 0 2
 516: ADD
 517: ST_TO_ADDR
// if team < 9 then
 518: LD_VAR 0 5
 522: PUSH
 523: LD_INT 9
 525: LESS
 526: IFFALSE 575
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 4 ) ;
 528: LD_INT 0
 530: PPUSH
 531: LD_INT 1
 533: PPUSH
 534: LD_INT 4
 536: PPUSH
 537: CALL_OW 12
 541: PPUSH
 542: LD_INT 4
 544: PPUSH
 545: CALL_OW 380
// team := team ^ CreateHuman ;
 549: LD_ADDR_VAR 0 5
 553: PUSH
 554: LD_VAR 0 5
 558: PUSH
 559: CALL_OW 44
 563: ADD
 564: ST_TO_ADDR
// until team = 9 ;
 565: LD_VAR 0 5
 569: PUSH
 570: LD_INT 9
 572: EQUAL
 573: IFFALSE 528
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 575: LD_ADDR_VAR 0 6
 579: PUSH
 580: LD_INT 30
 582: PUSH
 583: LD_INT 0
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: PPUSH
 590: CALL_OW 69
 594: PUSH
 595: LD_INT 1
 597: ARRAY
 598: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 599: LD_ADDR_VAR 0 7
 603: PUSH
 604: LD_INT 30
 606: PUSH
 607: LD_INT 4
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL_OW 69
 618: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 619: LD_ADDR_VAR 0 8
 623: PUSH
 624: LD_INT 2
 626: PUSH
 627: LD_INT 30
 629: PUSH
 630: LD_INT 7
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 30
 639: PUSH
 640: LD_INT 6
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: PPUSH
 652: CALL_OW 69
 656: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 657: LD_ADDR_VAR 0 9
 661: PUSH
 662: LD_INT 30
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: EMPTY
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL_OW 69
 676: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 677: LD_ADDR_VAR 0 10
 681: PUSH
 682: LD_INT 2
 684: PUSH
 685: LD_INT 30
 687: PUSH
 688: LD_INT 32
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: PUSH
 695: LD_INT 30
 697: PUSH
 698: LD_INT 31
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: LIST
 709: PPUSH
 710: CALL_OW 69
 714: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 715: LD_VAR 0 6
 719: PPUSH
 720: LD_STRING Gamma
 722: PPUSH
 723: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 727: LD_VAR 0 6
 731: PPUSH
 732: CALL_OW 274
 736: PPUSH
 737: LD_INT 2
 739: PPUSH
 740: LD_INT 10000
 742: PPUSH
 743: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 747: LD_VAR 0 6
 751: PPUSH
 752: CALL_OW 274
 756: PPUSH
 757: LD_INT 1
 759: PPUSH
 760: LD_INT 10000
 762: PPUSH
 763: CALL_OW 277
// if dep then
 767: LD_VAR 0 6
 771: IFFALSE 853
// begin if Brown then
 773: LD_EXP 14
 777: IFFALSE 813
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 779: LD_EXP 14
 783: PPUSH
 784: LD_VAR 0 6
 788: PUSH
 789: LD_INT 1
 791: ARRAY
 792: PPUSH
 793: CALL_OW 52
// team := team diff Brown ;
 797: LD_ADDR_VAR 0 5
 801: PUSH
 802: LD_VAR 0 5
 806: PUSH
 807: LD_EXP 14
 811: DIFF
 812: ST_TO_ADDR
// end ; if Donaldson then
 813: LD_EXP 13
 817: IFFALSE 853
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 819: LD_EXP 13
 823: PPUSH
 824: LD_VAR 0 6
 828: PUSH
 829: LD_INT 1
 831: ARRAY
 832: PPUSH
 833: CALL_OW 52
// team := team diff Donaldson ;
 837: LD_ADDR_VAR 0 5
 841: PUSH
 842: LD_VAR 0 5
 846: PUSH
 847: LD_EXP 13
 851: DIFF
 852: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 853: LD_VAR 0 10
 857: PUSH
 858: LD_VAR 0 5
 862: PPUSH
 863: LD_INT 25
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 72
 877: AND
 878: IFFALSE 987
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 880: LD_ADDR_VAR 0 11
 884: PUSH
 885: LD_VAR 0 5
 889: PPUSH
 890: LD_INT 25
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 72
 904: ST_TO_ADDR
// for i in bun do
 905: LD_ADDR_VAR 0 12
 909: PUSH
 910: LD_VAR 0 10
 914: PUSH
 915: FOR_IN
 916: IFFALSE 985
// begin if not filter then
 918: LD_VAR 0 11
 922: NOT
 923: IFFALSE 927
// break ;
 925: GO 985
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 927: LD_VAR 0 11
 931: PUSH
 932: LD_INT 1
 934: ARRAY
 935: PPUSH
 936: LD_VAR 0 12
 940: PPUSH
 941: CALL_OW 52
// team := team diff filter [ 1 ] ;
 945: LD_ADDR_VAR 0 5
 949: PUSH
 950: LD_VAR 0 5
 954: PUSH
 955: LD_VAR 0 11
 959: PUSH
 960: LD_INT 1
 962: ARRAY
 963: DIFF
 964: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 965: LD_ADDR_VAR 0 11
 969: PUSH
 970: LD_VAR 0 11
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 3
 982: ST_TO_ADDR
// end ;
 983: GO 915
 985: POP
 986: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 987: LD_VAR 0 7
 991: PUSH
 992: LD_VAR 0 5
 996: PPUSH
 997: LD_INT 25
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PPUSH
1007: CALL_OW 72
1011: AND
1012: IFFALSE 1134
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1014: LD_ADDR_VAR 0 11
1018: PUSH
1019: LD_VAR 0 5
1023: PPUSH
1024: LD_INT 25
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: PPUSH
1034: CALL_OW 72
1038: ST_TO_ADDR
// for i = 1 to filter do
1039: LD_ADDR_VAR 0 12
1043: PUSH
1044: DOUBLE
1045: LD_INT 1
1047: DEC
1048: ST_TO_ADDR
1049: LD_VAR 0 11
1053: PUSH
1054: FOR_TO
1055: IFFALSE 1116
// begin if ( i <= 6 ) then
1057: LD_VAR 0 12
1061: PUSH
1062: LD_INT 6
1064: LESSEQUAL
1065: IFFALSE 1093
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1067: LD_VAR 0 11
1071: PUSH
1072: LD_VAR 0 12
1076: ARRAY
1077: PPUSH
1078: LD_VAR 0 7
1082: PUSH
1083: LD_INT 1
1085: ARRAY
1086: PPUSH
1087: CALL_OW 52
1091: GO 1114
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1093: LD_VAR 0 11
1097: PUSH
1098: LD_VAR 0 12
1102: ARRAY
1103: PPUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_INT 0
1109: PPUSH
1110: CALL_OW 49
// end ;
1114: GO 1054
1116: POP
1117: POP
// team := team diff filter ;
1118: LD_ADDR_VAR 0 5
1122: PUSH
1123: LD_VAR 0 5
1127: PUSH
1128: LD_VAR 0 11
1132: DIFF
1133: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1134: LD_VAR 0 8
1138: PUSH
1139: LD_VAR 0 5
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 4
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: PPUSH
1154: CALL_OW 72
1158: AND
1159: IFFALSE 1281
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1161: LD_ADDR_VAR 0 11
1165: PUSH
1166: LD_VAR 0 5
1170: PPUSH
1171: LD_INT 25
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: PPUSH
1181: CALL_OW 72
1185: ST_TO_ADDR
// for i = 1 to filter do
1186: LD_ADDR_VAR 0 12
1190: PUSH
1191: DOUBLE
1192: LD_INT 1
1194: DEC
1195: ST_TO_ADDR
1196: LD_VAR 0 11
1200: PUSH
1201: FOR_TO
1202: IFFALSE 1263
// begin if ( i <= 6 ) then
1204: LD_VAR 0 12
1208: PUSH
1209: LD_INT 6
1211: LESSEQUAL
1212: IFFALSE 1240
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1214: LD_VAR 0 11
1218: PUSH
1219: LD_VAR 0 12
1223: ARRAY
1224: PPUSH
1225: LD_VAR 0 8
1229: PUSH
1230: LD_INT 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 52
1238: GO 1261
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1240: LD_VAR 0 11
1244: PUSH
1245: LD_VAR 0 12
1249: ARRAY
1250: PPUSH
1251: LD_INT 1
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL_OW 49
// end ;
1261: GO 1201
1263: POP
1264: POP
// team := team diff filter ;
1265: LD_ADDR_VAR 0 5
1269: PUSH
1270: LD_VAR 0 5
1274: PUSH
1275: LD_VAR 0 11
1279: DIFF
1280: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1281: LD_VAR 0 9
1285: PUSH
1286: LD_VAR 0 5
1290: PPUSH
1291: LD_INT 25
1293: PUSH
1294: LD_INT 3
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: PPUSH
1301: CALL_OW 72
1305: AND
1306: IFFALSE 1428
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1308: LD_ADDR_VAR 0 11
1312: PUSH
1313: LD_VAR 0 5
1317: PPUSH
1318: LD_INT 25
1320: PUSH
1321: LD_INT 3
1323: PUSH
1324: EMPTY
1325: LIST
1326: LIST
1327: PPUSH
1328: CALL_OW 72
1332: ST_TO_ADDR
// for i = 1 to filter do
1333: LD_ADDR_VAR 0 12
1337: PUSH
1338: DOUBLE
1339: LD_INT 1
1341: DEC
1342: ST_TO_ADDR
1343: LD_VAR 0 11
1347: PUSH
1348: FOR_TO
1349: IFFALSE 1410
// begin if ( i <= 6 ) then
1351: LD_VAR 0 12
1355: PUSH
1356: LD_INT 6
1358: LESSEQUAL
1359: IFFALSE 1387
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1361: LD_VAR 0 11
1365: PUSH
1366: LD_VAR 0 12
1370: ARRAY
1371: PPUSH
1372: LD_VAR 0 9
1376: PUSH
1377: LD_INT 1
1379: ARRAY
1380: PPUSH
1381: CALL_OW 52
1385: GO 1408
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1387: LD_VAR 0 11
1391: PUSH
1392: LD_VAR 0 12
1396: ARRAY
1397: PPUSH
1398: LD_INT 1
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// end ;
1408: GO 1348
1410: POP
1411: POP
// team := team diff filter ;
1412: LD_ADDR_VAR 0 5
1416: PUSH
1417: LD_VAR 0 5
1421: PUSH
1422: LD_VAR 0 11
1426: DIFF
1427: ST_TO_ADDR
// end ; if team then
1428: LD_VAR 0 5
1432: IFFALSE 1475
// for i in team do
1434: LD_ADDR_VAR 0 12
1438: PUSH
1439: LD_VAR 0 5
1443: PUSH
1444: FOR_IN
1445: IFFALSE 1473
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1447: LD_VAR 0 12
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: LD_INT 0
1457: PPUSH
1458: CALL_OW 49
// ComHold ( i ) ;
1462: LD_VAR 0 12
1466: PPUSH
1467: CALL_OW 140
// end ;
1471: GO 1444
1473: POP
1474: POP
// if fac then
1475: LD_VAR 0 9
1479: IFFALSE 1515
// if UnitsInside ( fac [ 1 ] ) then
1481: LD_VAR 0 9
1485: PUSH
1486: LD_INT 1
1488: ARRAY
1489: PPUSH
1490: CALL_OW 313
1494: IFFALSE 1515
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1496: LD_VAR 0 9
1500: PUSH
1501: LD_INT 1
1503: ARRAY
1504: PPUSH
1505: LD_INT 10
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 486
// if lab then
1515: LD_VAR 0 8
1519: IFFALSE 1555
// if UnitsInside ( lab [ 1 ] ) then
1521: LD_VAR 0 8
1525: PUSH
1526: LD_INT 1
1528: ARRAY
1529: PPUSH
1530: CALL_OW 313
1534: IFFALSE 1555
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1536: LD_VAR 0 8
1540: PUSH
1541: LD_INT 1
1543: ARRAY
1544: PPUSH
1545: LD_INT 10
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1555: LD_ADDR_VAR 0 4
1559: PUSH
1560: LD_INT 1
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 2
1571: PPUSH
1572: LD_INT 1
1574: PPUSH
1575: LD_INT 3
1577: PPUSH
1578: LD_INT 100
1580: PPUSH
1581: CALL 4449 0 7
1585: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1586: LD_VAR 0 4
1590: PPUSH
1591: LD_INT 2
1593: PPUSH
1594: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1598: LD_VAR 0 4
1602: PPUSH
1603: LD_INT 21
1605: PPUSH
1606: LD_INT 8
1608: PPUSH
1609: LD_INT 0
1611: PPUSH
1612: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1616: LD_EXP 7
1620: PPUSH
1621: LD_VAR 0 4
1625: PPUSH
1626: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1630: LD_ADDR_VAR 0 4
1634: PUSH
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 1
1643: PPUSH
1644: LD_INT 2
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: LD_INT 2
1652: PPUSH
1653: LD_INT 100
1655: PPUSH
1656: CALL 4449 0 7
1660: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 2
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 16
1680: PPUSH
1681: LD_INT 3
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1691: LD_EXP 8
1695: PPUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1705: LD_ADDR_VAR 0 4
1709: PUSH
1710: LD_INT 1
1712: PPUSH
1713: LD_INT 1
1715: PPUSH
1716: LD_INT 2
1718: PPUSH
1719: LD_INT 2
1721: PPUSH
1722: LD_INT 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 4449 0 7
1735: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1736: LD_VAR 0 4
1740: PPUSH
1741: LD_INT 0
1743: PPUSH
1744: LD_INT 5
1746: PPUSH
1747: CALL_OW 12
1751: PPUSH
1752: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1756: LD_VAR 0 4
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: LD_INT 0
1766: PPUSH
1767: CALL_OW 49
// end ;
1771: LD_VAR 0 1
1775: RET
// function PrepareBase ; var blist , i , b ; begin
1776: LD_INT 0
1778: PPUSH
1779: PPUSH
1780: PPUSH
1781: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
1782: LD_INT 71
1784: PPUSH
1785: LD_INT 5
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
1795: LD_ADDR_VAR 0 2
1799: PUSH
1800: LD_STRING GammaBase
1802: PPUSH
1803: EMPTY
1804: PPUSH
1805: CALL_OW 30
1809: ST_TO_ADDR
// if not blist and debug then
1810: LD_VAR 0 2
1814: NOT
1815: PUSH
1816: LD_EXP 1
1820: AND
1821: IFFALSE 1861
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 51
1833: PUSH
1834: LD_INT 10
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: LD_INT 3
1842: PUSH
1843: LD_INT 0
1845: PUSH
1846: LD_INT 0
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: PUSH
1858: EMPTY
1859: LIST
1860: ST_TO_ADDR
// if not blist then
1861: LD_VAR 0 2
1865: NOT
1866: IFFALSE 1870
// exit ;
1868: GO 2050
// uc_side := 1 ;
1870: LD_ADDR_OWVAR 20
1874: PUSH
1875: LD_INT 1
1877: ST_TO_ADDR
// uc_nation := 1 ;
1878: LD_ADDR_OWVAR 21
1882: PUSH
1883: LD_INT 1
1885: ST_TO_ADDR
// for i in blist do
1886: LD_ADDR_VAR 0 3
1890: PUSH
1891: LD_VAR 0 2
1895: PUSH
1896: FOR_IN
1897: IFFALSE 2048
// begin bc_type := i [ 1 ] ;
1899: LD_ADDR_OWVAR 42
1903: PUSH
1904: LD_VAR 0 3
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1913: LD_ADDR_OWVAR 43
1917: PUSH
1918: LD_VAR 0 3
1922: PUSH
1923: LD_INT 5
1925: ARRAY
1926: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1927: LD_VAR 0 3
1931: PUSH
1932: LD_INT 1
1934: ARRAY
1935: PUSH
1936: LD_INT 7
1938: PUSH
1939: LD_INT 8
1941: PUSH
1942: EMPTY
1943: LIST
1944: LIST
1945: IN
1946: IFFALSE 1976
// begin bc_kind1 := i [ 7 ] ;
1948: LD_ADDR_OWVAR 44
1952: PUSH
1953: LD_VAR 0 3
1957: PUSH
1958: LD_INT 7
1960: ARRAY
1961: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1962: LD_ADDR_OWVAR 45
1966: PUSH
1967: LD_VAR 0 3
1971: PUSH
1972: LD_INT 8
1974: ARRAY
1975: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1976: LD_ADDR_VAR 0 4
1980: PUSH
1981: LD_VAR 0 3
1985: PUSH
1986: LD_INT 2
1988: ARRAY
1989: PPUSH
1990: LD_VAR 0 3
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PPUSH
1999: LD_VAR 0 3
2003: PUSH
2004: LD_INT 4
2006: ARRAY
2007: PPUSH
2008: CALL_OW 47
2012: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2013: LD_VAR 0 4
2017: PPUSH
2018: CALL_OW 266
2022: PUSH
2023: LD_INT 32
2025: EQUAL
2026: IFFALSE 2046
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2028: LD_VAR 0 4
2032: PPUSH
2033: LD_VAR 0 3
2037: PUSH
2038: LD_INT 7
2040: ARRAY
2041: PPUSH
2042: CALL_OW 431
// end ; end ;
2046: GO 1896
2048: POP
2049: POP
// end ; end_of_file
2050: LD_VAR 0 1
2054: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2055: LD_INT 0
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
2064: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
2065: LD_INT 0
2067: PPUSH
2068: LD_INT 0
2070: PPUSH
2071: LD_INT 1
2073: PPUSH
2074: LD_INT 32976
2076: NEG
2077: PPUSH
2078: CALL_OW 330
// InGameOn ;
2082: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2086: LD_INT 33
2088: PPUSH
2089: LD_INT 11
2091: PPUSH
2092: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2096: LD_ADDR_VAR 0 2
2100: PUSH
2101: LD_INT 29
2103: PUSH
2104: LD_INT 21
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: PUSH
2111: LD_INT 41
2113: PUSH
2114: LD_INT 28
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 52
2123: PUSH
2124: LD_INT 26
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 49
2133: PUSH
2134: LD_INT 16
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: ST_TO_ADDR
// for i in points do
2147: LD_ADDR_VAR 0 3
2151: PUSH
2152: LD_VAR 0 2
2156: PUSH
2157: FOR_IN
2158: IFFALSE 2198
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2160: LD_EXP 7
2164: PUSH
2165: LD_EXP 8
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: PPUSH
2174: LD_VAR 0 3
2178: PUSH
2179: LD_INT 1
2181: ARRAY
2182: PPUSH
2183: LD_VAR 0 3
2187: PUSH
2188: LD_INT 2
2190: ARRAY
2191: PPUSH
2192: CALL_OW 171
2196: GO 2157
2198: POP
2199: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2200: LD_EXP 7
2204: PUSH
2205: LD_EXP 8
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PPUSH
2214: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2218: LD_INT 35
2220: PPUSH
2221: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2225: LD_EXP 7
2229: PPUSH
2230: CALL_OW 310
2234: NOT
2235: PUSH
2236: LD_EXP 8
2240: PPUSH
2241: CALL_OW 310
2245: NOT
2246: AND
2247: IFFALSE 2218
// ComTurnUnit ( JMM , Gladstone ) ;
2249: LD_EXP 7
2253: PPUSH
2254: LD_EXP 8
2258: PPUSH
2259: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2263: LD_EXP 8
2267: PPUSH
2268: LD_EXP 7
2272: PPUSH
2273: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2277: LD_ADDR_VAR 0 4
2281: PUSH
2282: LD_INT 26
2284: PUSH
2285: LD_INT 1
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 69
2296: PUSH
2297: LD_EXP 7
2301: PUSH
2302: LD_EXP 8
2306: PUSH
2307: LD_EXP 12
2311: PUSH
2312: LD_EXP 11
2316: PUSH
2317: LD_EXP 9
2321: PUSH
2322: LD_EXP 14
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: LIST
2331: LIST
2332: LIST
2333: LIST
2334: DIFF
2335: ST_TO_ADDR
// if sol then
2336: LD_VAR 0 4
2340: IFFALSE 2356
// sol := sol [ 1 ] ;
2342: LD_ADDR_VAR 0 4
2346: PUSH
2347: LD_VAR 0 4
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: ST_TO_ADDR
// team := [ ] ;
2356: LD_ADDR_VAR 0 5
2360: PUSH
2361: EMPTY
2362: ST_TO_ADDR
// if sol then
2363: LD_VAR 0 4
2367: IFFALSE 2385
// team := team ^ sol ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_VAR 0 4
2383: ADD
2384: ST_TO_ADDR
// if Lisa then
2385: LD_EXP 10
2389: IFFALSE 2407
// team := team ^ Lisa ;
2391: LD_ADDR_VAR 0 5
2395: PUSH
2396: LD_VAR 0 5
2400: PUSH
2401: LD_EXP 10
2405: ADD
2406: ST_TO_ADDR
// if Donaldson then
2407: LD_EXP 13
2411: IFFALSE 2429
// team := team ^ Donaldson ;
2413: LD_ADDR_VAR 0 5
2417: PUSH
2418: LD_VAR 0 5
2422: PUSH
2423: LD_EXP 13
2427: ADD
2428: ST_TO_ADDR
// if Brown then
2429: LD_EXP 14
2433: IFFALSE 2451
// team := team ^ Brown ;
2435: LD_ADDR_VAR 0 5
2439: PUSH
2440: LD_VAR 0 5
2444: PUSH
2445: LD_EXP 14
2449: ADD
2450: ST_TO_ADDR
// if Bobby then
2451: LD_EXP 12
2455: IFFALSE 2473
// team := team ^ Bobby ;
2457: LD_ADDR_VAR 0 5
2461: PUSH
2462: LD_VAR 0 5
2466: PUSH
2467: LD_EXP 12
2471: ADD
2472: ST_TO_ADDR
// if Cyrus then
2473: LD_EXP 11
2477: IFFALSE 2495
// team := team ^ Cyrus ;
2479: LD_ADDR_VAR 0 5
2483: PUSH
2484: LD_VAR 0 5
2488: PUSH
2489: LD_EXP 11
2493: ADD
2494: ST_TO_ADDR
// if Frank then
2495: LD_EXP 9
2499: IFFALSE 2517
// team := team ^ Frank ;
2501: LD_ADDR_VAR 0 5
2505: PUSH
2506: LD_VAR 0 5
2510: PUSH
2511: LD_EXP 9
2515: ADD
2516: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2517: LD_ADDR_VAR 0 3
2521: PUSH
2522: LD_INT 1
2524: PPUSH
2525: LD_INT 3
2527: PUSH
2528: LD_INT 54
2530: PUSH
2531: EMPTY
2532: LIST
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_INT 21
2540: PUSH
2541: LD_INT 1
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PPUSH
2552: CALL_OW 70
2556: PUSH
2557: LD_EXP 7
2561: PUSH
2562: LD_EXP 8
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: DIFF
2571: PUSH
2572: EMPTY
2573: LIST
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2596
// team := team ^ i ;
2578: LD_ADDR_VAR 0 5
2582: PUSH
2583: LD_VAR 0 5
2587: PUSH
2588: LD_VAR 0 3
2592: ADD
2593: ST_TO_ADDR
2594: GO 2575
2596: POP
2597: POP
// if team then
2598: LD_VAR 0 5
2602: IFFALSE 2678
// begin ComExitBuilding ( team ) ;
2604: LD_VAR 0 5
2608: PPUSH
2609: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2613: LD_VAR 0 5
2617: PPUSH
2618: LD_EXP 7
2622: PPUSH
2623: CALL_OW 172
// repeat wait ( 1 ) ;
2627: LD_INT 1
2629: PPUSH
2630: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2634: LD_EXP 7
2638: PPUSH
2639: LD_VAR 0 5
2643: PPUSH
2644: LD_EXP 7
2648: PPUSH
2649: CALL_OW 74
2653: PPUSH
2654: CALL_OW 296
2658: PUSH
2659: LD_INT 6
2661: LESS
2662: IFFALSE 2627
// ComTurnUnit ( team , JMM ) ;
2664: LD_VAR 0 5
2668: PPUSH
2669: LD_EXP 7
2673: PPUSH
2674: CALL_OW 119
// end ; if Lisa then
2678: LD_EXP 10
2682: IFFALSE 2710
// begin ComTurnUnit ( JMM , Lisa ) ;
2684: LD_EXP 7
2688: PPUSH
2689: LD_EXP 10
2693: PPUSH
2694: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2698: LD_EXP 10
2702: PPUSH
2703: LD_STRING D1-Lisa-1
2705: PPUSH
2706: CALL_OW 88
// end ; if sol then
2710: LD_VAR 0 4
2714: IFFALSE 2742
// begin ComTurnUnit ( JMM , sol ) ;
2716: LD_EXP 7
2720: PPUSH
2721: LD_VAR 0 4
2725: PPUSH
2726: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2730: LD_VAR 0 4
2734: PPUSH
2735: LD_STRING D1-Sol1-1
2737: PPUSH
2738: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2742: LD_EXP 7
2746: PPUSH
2747: LD_STRING D1-JMM-1
2749: PPUSH
2750: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2754: LD_EXP 7
2758: PPUSH
2759: LD_STRING D1-JMM-1a
2761: PPUSH
2762: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2766: LD_EXP 7
2770: PPUSH
2771: LD_EXP 8
2775: PPUSH
2776: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2780: LD_VAR 0 5
2784: PPUSH
2785: LD_EXP 8
2789: PPUSH
2790: CALL_OW 119
// if Frank then
2794: LD_EXP 9
2798: IFFALSE 2826
// begin Say ( Frank , D1-Frank-1 ) ;
2800: LD_EXP 9
2804: PPUSH
2805: LD_STRING D1-Frank-1
2807: PPUSH
2808: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2812: LD_EXP 7
2816: PPUSH
2817: LD_EXP 9
2821: PPUSH
2822: CALL_OW 119
// end ; if Lisa then
2826: LD_EXP 10
2830: IFFALSE 2858
// begin ComTurnUnit ( JMM , Lisa ) ;
2832: LD_EXP 7
2836: PPUSH
2837: LD_EXP 10
2841: PPUSH
2842: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2846: LD_EXP 10
2850: PPUSH
2851: LD_STRING D1-Lisa-2
2853: PPUSH
2854: CALL_OW 88
// end ; if sol then
2858: LD_VAR 0 4
2862: IFFALSE 2890
// begin ComTurnUnit ( JMM , sol ) ;
2864: LD_EXP 7
2868: PPUSH
2869: LD_VAR 0 4
2873: PPUSH
2874: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2878: LD_VAR 0 4
2882: PPUSH
2883: LD_STRING D1-Sol1-2
2885: PPUSH
2886: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2890: LD_EXP 8
2894: PPUSH
2895: LD_STRING D1-Glad-2
2897: PPUSH
2898: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2902: LD_VAR 0 5
2906: PPUSH
2907: LD_EXP 7
2911: PPUSH
2912: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2916: LD_EXP 7
2920: PPUSH
2921: LD_STRING D1-JMM-2
2923: PPUSH
2924: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2928: LD_EXP 7
2932: PPUSH
2933: LD_EXP 8
2937: PPUSH
2938: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2942: LD_EXP 8
2946: PPUSH
2947: LD_STRING D1-Glad-3
2949: PPUSH
2950: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2954: LD_EXP 7
2958: PPUSH
2959: LD_STRING D1-JMM-3
2961: PPUSH
2962: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2966: LD_EXP 8
2970: PPUSH
2971: LD_STRING D1-Glad-4
2973: PPUSH
2974: CALL_OW 88
// if Frank then
2978: LD_EXP 9
2982: IFFALSE 3010
// begin ComTurnUnit ( JMM , Frank ) ;
2984: LD_EXP 7
2988: PPUSH
2989: LD_EXP 9
2993: PPUSH
2994: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2998: LD_EXP 9
3002: PPUSH
3003: LD_STRING D1-Frank-4
3005: PPUSH
3006: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3010: LD_EXP 7
3014: PPUSH
3015: LD_EXP 8
3019: PPUSH
3020: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
3024: LD_EXP 7
3028: PPUSH
3029: LD_STRING D1-JMM-4
3031: PPUSH
3032: CALL_OW 88
// if Lisa then
3036: LD_EXP 10
3040: IFFALSE 3107
// begin Say ( Lisa , D1-Lisa-4 ) ;
3042: LD_EXP 10
3046: PPUSH
3047: LD_STRING D1-Lisa-4
3049: PPUSH
3050: CALL_OW 88
// if Frank then
3054: LD_EXP 9
3058: IFFALSE 3107
// begin ComTurnUnit ( Frank , Lisa ) ;
3060: LD_EXP 9
3064: PPUSH
3065: LD_EXP 10
3069: PPUSH
3070: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3074: LD_EXP 9
3078: PPUSH
3079: LD_STRING D1-Frank-5
3081: PPUSH
3082: CALL_OW 88
// Wait ( 3 ) ;
3086: LD_INT 3
3088: PPUSH
3089: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3093: LD_EXP 9
3097: PPUSH
3098: LD_EXP 7
3102: PPUSH
3103: CALL_OW 179
// end ; end ; if sol then
3107: LD_VAR 0 4
3111: IFFALSE 3125
// Say ( sol , D1-Sol1-5 ) ;
3113: LD_VAR 0 4
3117: PPUSH
3118: LD_STRING D1-Sol1-5
3120: PPUSH
3121: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3125: LD_EXP 7
3129: PPUSH
3130: LD_STRING D1-JMM-5
3132: PPUSH
3133: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3137: LD_EXP 8
3141: PPUSH
3142: LD_STRING D1-Glad-5
3144: PPUSH
3145: CALL_OW 88
// if Frank then
3149: LD_EXP 9
3153: IFFALSE 3167
// Say ( Frank , D1-Frank-6 ) ;
3155: LD_EXP 9
3159: PPUSH
3160: LD_STRING D1-Frank-6
3162: PPUSH
3163: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3167: LD_EXP 7
3171: PPUSH
3172: LD_STRING D1-JMM-6
3174: PPUSH
3175: CALL_OW 88
// if Brown and Donaldson then
3179: LD_EXP 14
3183: PUSH
3184: LD_EXP 13
3188: AND
3189: IFFALSE 3238
// case Query ( QCommander ) of 1 :
3191: LD_STRING QCommander
3193: PPUSH
3194: CALL_OW 97
3198: PUSH
3199: LD_INT 1
3201: DOUBLE
3202: EQUAL
3203: IFTRUE 3207
3205: GO 3218
3207: POP
// donaldson_commander := true ; 2 :
3208: LD_ADDR_EXP 4
3212: PUSH
3213: LD_INT 1
3215: ST_TO_ADDR
3216: GO 3238
3218: LD_INT 2
3220: DOUBLE
3221: EQUAL
3222: IFTRUE 3226
3224: GO 3237
3226: POP
// brown_commander := true ; end ;
3227: LD_ADDR_EXP 5
3231: PUSH
3232: LD_INT 1
3234: ST_TO_ADDR
3235: GO 3238
3237: POP
// if not Brown and Donaldson then
3238: LD_EXP 14
3242: NOT
3243: PUSH
3244: LD_EXP 13
3248: AND
3249: IFFALSE 3259
// donaldson_commander := true ;
3251: LD_ADDR_EXP 4
3255: PUSH
3256: LD_INT 1
3258: ST_TO_ADDR
// if Brown and not Donaldson then
3259: LD_EXP 14
3263: PUSH
3264: LD_EXP 13
3268: NOT
3269: AND
3270: IFFALSE 3280
// brown_commander := true ;
3272: LD_ADDR_EXP 5
3276: PUSH
3277: LD_INT 1
3279: ST_TO_ADDR
// if donaldson_commander then
3280: LD_EXP 4
3284: IFFALSE 3431
// begin ComTurnUnit ( JMM , Donaldson ) ;
3286: LD_EXP 7
3290: PPUSH
3291: LD_EXP 13
3295: PPUSH
3296: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3300: LD_EXP 7
3304: PPUSH
3305: LD_STRING D1a-JMM-1
3307: PPUSH
3308: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3312: LD_EXP 13
3316: PPUSH
3317: LD_EXP 7
3321: PPUSH
3322: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3326: LD_EXP 13
3330: PPUSH
3331: LD_EXP 7
3335: PPUSH
3336: CALL_OW 179
// Wait ( 3 ) ;
3340: LD_INT 3
3342: PPUSH
3343: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3347: LD_EXP 13
3351: PPUSH
3352: LD_STRING D1a-Don-1
3354: PPUSH
3355: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3359: LD_EXP 7
3363: PPUSH
3364: LD_STRING D1b-JMM-2
3366: PPUSH
3367: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3371: LD_EXP 13
3375: PPUSH
3376: LD_STRING D1a-Don-2
3378: PPUSH
3379: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3383: LD_EXP 13
3387: PPUSH
3388: LD_INT 30
3390: PUSH
3391: LD_INT 0
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: PPUSH
3398: CALL_OW 69
3402: PUSH
3403: LD_INT 1
3405: ARRAY
3406: PPUSH
3407: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3411: LD_INT 1
3413: PPUSH
3414: LD_STRING GammaCommander
3416: PPUSH
3417: CALL_OW 39
// commander := Donaldson ;
3421: LD_ADDR_VAR 0 7
3425: PUSH
3426: LD_EXP 13
3430: ST_TO_ADDR
// end ; if brown_commander then
3431: LD_EXP 5
3435: IFFALSE 3582
// begin ComTurnUnit ( JMM , Brown ) ;
3437: LD_EXP 7
3441: PPUSH
3442: LD_EXP 14
3446: PPUSH
3447: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3451: LD_EXP 7
3455: PPUSH
3456: LD_STRING D1b-JMM-1
3458: PPUSH
3459: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3463: LD_EXP 14
3467: PPUSH
3468: LD_EXP 7
3472: PPUSH
3473: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3477: LD_EXP 14
3481: PPUSH
3482: LD_EXP 7
3486: PPUSH
3487: CALL_OW 179
// Wait ( 3 ) ;
3491: LD_INT 3
3493: PPUSH
3494: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3498: LD_EXP 14
3502: PPUSH
3503: LD_STRING D1b-Brown-1
3505: PPUSH
3506: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3510: LD_EXP 7
3514: PPUSH
3515: LD_STRING D1a-JMM-2
3517: PPUSH
3518: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3522: LD_EXP 14
3526: PPUSH
3527: LD_STRING D1b-Brown-2
3529: PPUSH
3530: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3534: LD_EXP 14
3538: PPUSH
3539: LD_INT 30
3541: PUSH
3542: LD_INT 0
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: PPUSH
3549: CALL_OW 69
3553: PUSH
3554: LD_INT 1
3556: ARRAY
3557: PPUSH
3558: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3562: LD_INT 2
3564: PPUSH
3565: LD_STRING GammaCommander
3567: PPUSH
3568: CALL_OW 39
// commander := Brown ;
3572: LD_ADDR_VAR 0 7
3576: PUSH
3577: LD_EXP 14
3581: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3582: LD_EXP 7
3586: PPUSH
3587: LD_EXP 8
3591: PPUSH
3592: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3596: LD_EXP 4
3600: NOT
3601: PUSH
3602: LD_EXP 5
3606: NOT
3607: AND
3608: IFFALSE 3632
// begin Say ( JMM , D1c-JMM-1 ) ;
3610: LD_EXP 7
3614: PPUSH
3615: LD_STRING D1c-JMM-1
3617: PPUSH
3618: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3622: LD_INT 3
3624: PPUSH
3625: LD_STRING GammaCommander
3627: PPUSH
3628: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3632: LD_EXP 7
3636: PPUSH
3637: LD_STRING D1d-JMM-1
3639: PPUSH
3640: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3644: LD_ADDR_VAR 0 6
3648: PUSH
3649: LD_INT 21
3651: PUSH
3652: LD_INT 1
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PPUSH
3659: CALL_OW 69
3663: PUSH
3664: LD_EXP 7
3668: PUSH
3669: LD_EXP 8
3673: PUSH
3674: LD_VAR 0 7
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: DIFF
3684: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3685: LD_ADDR_EXP 6
3689: PUSH
3690: LD_STRING 1
3692: PPUSH
3693: LD_INT 5
3695: PPUSH
3696: LD_INT 5
3698: PPUSH
3699: LD_INT -5
3701: PUSH
3702: LD_EXP 7
3706: PUSH
3707: LD_INT -6
3709: PUSH
3710: LD_EXP 8
3714: PUSH
3715: LD_INT -2
3717: PUSH
3718: LD_INT -3
3720: PUSH
3721: LD_INT -5
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: PUSH
3733: LD_VAR 0 6
3737: ADD
3738: PUSH
3739: LD_INT -6
3741: PUSH
3742: LD_INT -4
3744: PUSH
3745: LD_VAR 0 7
3749: PUSH
3750: EMPTY
3751: LIST
3752: LIST
3753: LIST
3754: ADD
3755: PPUSH
3756: LD_INT 1
3758: PUSH
3759: LD_INT 3
3761: PUSH
3762: LD_INT 2
3764: PUSH
3765: LD_INT 1
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 4
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: PPUSH
3781: CALL_OW 42
3785: ST_TO_ADDR
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3786: LD_EXP 7
3790: PPUSH
3791: LD_EXP 2
3795: PUSH
3796: LD_STRING JMM
3798: STR
3799: PPUSH
3800: CALL_OW 38
// if Lisa in save_group then
3804: LD_EXP 10
3808: PUSH
3809: LD_EXP 6
3813: IN
3814: IFFALSE 3844
// begin SaveVariable ( true , LisaInDelta ) ;
3816: LD_INT 1
3818: PPUSH
3819: LD_STRING LisaInDelta
3821: PPUSH
3822: CALL_OW 39
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3826: LD_EXP 10
3830: PPUSH
3831: LD_EXP 2
3835: PUSH
3836: LD_STRING Lisa
3838: STR
3839: PPUSH
3840: CALL_OW 38
// end ; if Bobby in save_group then
3844: LD_EXP 12
3848: PUSH
3849: LD_EXP 6
3853: IN
3854: IFFALSE 3884
// begin SaveVariable ( true , BobbyInDelta ) ;
3856: LD_INT 1
3858: PPUSH
3859: LD_STRING BobbyInDelta
3861: PPUSH
3862: CALL_OW 39
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3866: LD_EXP 12
3870: PPUSH
3871: LD_EXP 2
3875: PUSH
3876: LD_STRING Bobby
3878: STR
3879: PPUSH
3880: CALL_OW 38
// end ; if Cyrus in save_group then
3884: LD_EXP 11
3888: PUSH
3889: LD_EXP 6
3893: IN
3894: IFFALSE 3924
// begin SaveVariable ( true , CyrusInDelta ) ;
3896: LD_INT 1
3898: PPUSH
3899: LD_STRING CyrusInDelta
3901: PPUSH
3902: CALL_OW 39
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3906: LD_EXP 11
3910: PPUSH
3911: LD_EXP 2
3915: PUSH
3916: LD_STRING Cyrus
3918: STR
3919: PPUSH
3920: CALL_OW 38
// end ; if Frank in save_group then
3924: LD_EXP 9
3928: PUSH
3929: LD_EXP 6
3933: IN
3934: IFFALSE 3964
// begin SaveVariable ( true , FrankInDelta ) ;
3936: LD_INT 1
3938: PPUSH
3939: LD_STRING FrankInDelta
3941: PPUSH
3942: CALL_OW 39
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
3946: LD_EXP 9
3950: PPUSH
3951: LD_EXP 2
3955: PUSH
3956: LD_STRING Frank
3958: STR
3959: PPUSH
3960: CALL_OW 38
// end ; if Brown in save_group then
3964: LD_EXP 14
3968: PUSH
3969: LD_EXP 6
3973: IN
3974: IFFALSE 4004
// begin SaveVariable ( true , BrownInDelta ) ;
3976: LD_INT 1
3978: PPUSH
3979: LD_STRING BrownInDelta
3981: PPUSH
3982: CALL_OW 39
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
3986: LD_EXP 14
3990: PPUSH
3991: LD_EXP 2
3995: PUSH
3996: LD_STRING Brown
3998: STR
3999: PPUSH
4000: CALL_OW 38
// end ; if Donaldson in save_group then
4004: LD_EXP 13
4008: PUSH
4009: LD_EXP 6
4013: IN
4014: IFFALSE 4044
// begin SaveVariable ( true , DonaldsonInDelta ) ;
4016: LD_INT 1
4018: PPUSH
4019: LD_STRING DonaldsonInDelta
4021: PPUSH
4022: CALL_OW 39
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4026: LD_EXP 13
4030: PPUSH
4031: LD_EXP 2
4035: PUSH
4036: LD_STRING Donaldson
4038: STR
4039: PPUSH
4040: CALL_OW 38
// end ; SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] ^ save_group , othersGamma ) ;
4044: LD_VAR 0 6
4048: PUSH
4049: LD_EXP 7
4053: PUSH
4054: LD_EXP 8
4058: PUSH
4059: LD_EXP 10
4063: PUSH
4064: LD_EXP 11
4068: PUSH
4069: LD_EXP 12
4073: PUSH
4074: LD_EXP 9
4078: PUSH
4079: LD_EXP 13
4083: PUSH
4084: LD_EXP 14
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_EXP 6
4107: ADD
4108: DIFF
4109: PPUSH
4110: LD_STRING othersGamma
4112: PPUSH
4113: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
4117: LD_EXP 6
4121: PUSH
4122: LD_EXP 7
4126: PUSH
4127: LD_EXP 8
4131: PUSH
4132: LD_EXP 10
4136: PUSH
4137: LD_EXP 11
4141: PUSH
4142: LD_EXP 12
4146: PUSH
4147: LD_EXP 9
4151: PUSH
4152: LD_EXP 13
4156: PUSH
4157: LD_EXP 14
4161: PUSH
4162: LD_INT 0
4164: PUSH
4165: EMPTY
4166: LIST
4167: LIST
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: LIST
4174: LIST
4175: DIFF
4176: PPUSH
4177: LD_STRING othersDelta
4179: PPUSH
4180: CALL_OW 38
// Wait ( 3 ) ;
4184: LD_INT 3
4186: PPUSH
4187: CALL_OW 67
// for i in save_group do
4191: LD_ADDR_VAR 0 3
4195: PUSH
4196: LD_EXP 6
4200: PUSH
4201: FOR_IN
4202: IFFALSE 4233
// begin if IsInUnit ( i ) then
4204: LD_VAR 0 3
4208: PPUSH
4209: CALL_OW 310
4213: IFFALSE 4224
// ComExitBuilding ( i ) ;
4215: LD_VAR 0 3
4219: PPUSH
4220: CALL_OW 122
// Wait ( 3 ) ;
4224: LD_INT 3
4226: PPUSH
4227: CALL_OW 67
// end ;
4231: GO 4201
4233: POP
4234: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4235: LD_ADDR_EXP 6
4239: PUSH
4240: LD_EXP 6
4244: PPUSH
4245: LD_INT 1
4247: PPUSH
4248: LD_EXP 7
4252: PPUSH
4253: CALL_OW 2
4257: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4258: LD_ADDR_EXP 6
4262: PUSH
4263: LD_EXP 6
4267: PPUSH
4268: LD_INT 2
4270: PPUSH
4271: LD_EXP 8
4275: PPUSH
4276: CALL_OW 2
4280: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4281: LD_ADDR_VAR 0 8
4285: PUSH
4286: LD_INT 21
4288: PUSH
4289: LD_INT 2
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PPUSH
4296: CALL_OW 69
4300: ST_TO_ADDR
// for i = 1 to filter do
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: DOUBLE
4307: LD_INT 1
4309: DEC
4310: ST_TO_ADDR
4311: LD_VAR 0 8
4315: PUSH
4316: FOR_TO
4317: IFFALSE 4347
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4319: LD_EXP 6
4323: PUSH
4324: LD_VAR 0 3
4328: ARRAY
4329: PPUSH
4330: LD_VAR 0 8
4334: PUSH
4335: LD_VAR 0 3
4339: ARRAY
4340: PPUSH
4341: CALL_OW 120
4345: GO 4316
4347: POP
4348: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4349: LD_EXP 6
4353: PPUSH
4354: LD_INT 87
4356: PPUSH
4357: LD_INT 27
4359: PPUSH
4360: CALL_OW 171
// Wait ( 0 0$05 ) ;
4364: LD_INT 175
4366: PPUSH
4367: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4371: LD_INT 1
4373: PPUSH
4374: LD_STRING %_cont
4376: PPUSH
4377: CALL_OW 340
// end ; end_of_file
4381: LD_VAR 0 1
4385: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4386: LD_INT 0
4388: PPUSH
4389: PPUSH
// if exist_mode then
4390: LD_VAR 0 2
4394: IFFALSE 4419
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4396: LD_ADDR_VAR 0 4
4400: PUSH
4401: LD_EXP 3
4405: PUSH
4406: LD_VAR 0 1
4410: STR
4411: PPUSH
4412: CALL_OW 34
4416: ST_TO_ADDR
4417: GO 4434
// unit := NewCharacter ( ident ) ;
4419: LD_ADDR_VAR 0 4
4423: PUSH
4424: LD_VAR 0 1
4428: PPUSH
4429: CALL_OW 25
4433: ST_TO_ADDR
// result := unit ;
4434: LD_ADDR_VAR 0 3
4438: PUSH
4439: LD_VAR 0 4
4443: ST_TO_ADDR
// end ;
4444: LD_VAR 0 3
4448: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4449: LD_INT 0
4451: PPUSH
// uc_side := side ;
4452: LD_ADDR_OWVAR 20
4456: PUSH
4457: LD_VAR 0 1
4461: ST_TO_ADDR
// uc_nation := nation ;
4462: LD_ADDR_OWVAR 21
4466: PUSH
4467: LD_VAR 0 2
4471: ST_TO_ADDR
// vc_chassis := chassis ;
4472: LD_ADDR_OWVAR 37
4476: PUSH
4477: LD_VAR 0 3
4481: ST_TO_ADDR
// vc_engine := engine ;
4482: LD_ADDR_OWVAR 39
4486: PUSH
4487: LD_VAR 0 4
4491: ST_TO_ADDR
// vc_control := control ;
4492: LD_ADDR_OWVAR 38
4496: PUSH
4497: LD_VAR 0 5
4501: ST_TO_ADDR
// vc_weapon := weapon ;
4502: LD_ADDR_OWVAR 40
4506: PUSH
4507: LD_VAR 0 6
4511: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4512: LD_ADDR_OWVAR 41
4516: PUSH
4517: LD_VAR 0 7
4521: ST_TO_ADDR
// result := CreateVehicle ;
4522: LD_ADDR_VAR 0 8
4526: PUSH
4527: CALL_OW 45
4531: ST_TO_ADDR
// end ;
4532: LD_VAR 0 8
4536: RET
// export function SayX ( units , ident ) ; var i ; begin
4537: LD_INT 0
4539: PPUSH
4540: PPUSH
// result := false ;
4541: LD_ADDR_VAR 0 3
4545: PUSH
4546: LD_INT 0
4548: ST_TO_ADDR
// if not units then
4549: LD_VAR 0 1
4553: NOT
4554: IFFALSE 4558
// exit ;
4556: GO 4612
// for i in units do
4558: LD_ADDR_VAR 0 4
4562: PUSH
4563: LD_VAR 0 1
4567: PUSH
4568: FOR_IN
4569: IFFALSE 4610
// if IsOk ( i ) then
4571: LD_VAR 0 4
4575: PPUSH
4576: CALL_OW 302
4580: IFFALSE 4608
// begin Say ( i , ident ) ;
4582: LD_VAR 0 4
4586: PPUSH
4587: LD_VAR 0 2
4591: PPUSH
4592: CALL_OW 88
// result := i ;
4596: LD_ADDR_VAR 0 3
4600: PUSH
4601: LD_VAR 0 4
4605: ST_TO_ADDR
// break ;
4606: GO 4610
// end ;
4608: GO 4568
4610: POP
4611: POP
// end ;
4612: LD_VAR 0 3
4616: RET
