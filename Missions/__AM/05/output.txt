// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 2148 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05a_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05a_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , tmp ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// PrepareBase ;
 119: CALL 1790 0 0
// uc_side := 1 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// uc_nation := 1 ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// team := [ ] ;
 139: LD_ADDR_VAR 0 5
 143: PUSH
 144: EMPTY
 145: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_STRING JMM
 153: PPUSH
 154: LD_EXP 1
 158: NOT
 159: PPUSH
 160: CALL 4479 0 2
 164: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_STRING Gladstone
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: CALL 4479 0 2
 180: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_STRING Frank
 188: PPUSH
 189: LD_EXP 1
 193: NOT
 194: PPUSH
 195: CALL 4479 0 2
 199: ST_TO_ADDR
// if Frank then
 200: LD_EXP 9
 204: IFFALSE 222
// team := team ^ Frank ;
 206: LD_ADDR_VAR 0 5
 210: PUSH
 211: LD_VAR 0 5
 215: PUSH
 216: LD_EXP 9
 220: ADD
 221: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 222: LD_ADDR_EXP 10
 226: PUSH
 227: LD_STRING Lisa
 229: PPUSH
 230: LD_EXP 1
 234: NOT
 235: PPUSH
 236: CALL 4479 0 2
 240: ST_TO_ADDR
// if Lisa then
 241: LD_EXP 10
 245: IFFALSE 263
// team := team ^ Lisa ;
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_EXP 10
 261: ADD
 262: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 263: LD_ADDR_EXP 13
 267: PUSH
 268: LD_STRING Donaldson
 270: PPUSH
 271: LD_EXP 1
 275: NOT
 276: PPUSH
 277: CALL 4479 0 2
 281: ST_TO_ADDR
// if Donaldson then
 282: LD_EXP 13
 286: IFFALSE 304
// team := team ^ Donaldson ;
 288: LD_ADDR_VAR 0 5
 292: PUSH
 293: LD_VAR 0 5
 297: PUSH
 298: LD_EXP 13
 302: ADD
 303: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 304: LD_ADDR_EXP 14
 308: PUSH
 309: LD_STRING Brown
 311: PPUSH
 312: LD_EXP 1
 316: NOT
 317: PPUSH
 318: CALL 4479 0 2
 322: ST_TO_ADDR
// if Brown then
 323: LD_EXP 14
 327: IFFALSE 345
// team := team ^ Brown ;
 329: LD_ADDR_VAR 0 5
 333: PUSH
 334: LD_VAR 0 5
 338: PUSH
 339: LD_EXP 14
 343: ADD
 344: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 345: LD_ADDR_VAR 0 3
 349: PUSH
 350: LD_STRING 04_other_survivors
 352: PPUSH
 353: CALL_OW 31
 357: ST_TO_ADDR
// DeleteCharacters ( 04_other_survivors ) ;
 358: LD_STRING 04_other_survivors
 360: PPUSH
 361: CALL_OW 40
// if not Lisa then
 365: LD_EXP 10
 369: NOT
 370: IFFALSE 488
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 372: LD_ADDR_EXP 11
 376: PUSH
 377: LD_STRING Cyrus
 379: PPUSH
 380: LD_EXP 1
 384: NOT
 385: PPUSH
 386: CALL 4479 0 2
 390: ST_TO_ADDR
// if Cyrus then
 391: LD_EXP 11
 395: IFFALSE 413
// team := team ^ Cyrus ;
 397: LD_ADDR_VAR 0 5
 401: PUSH
 402: LD_VAR 0 5
 406: PUSH
 407: LD_EXP 11
 411: ADD
 412: ST_TO_ADDR
// if not Cyrus then
 413: LD_EXP 11
 417: NOT
 418: IFFALSE 488
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 420: LD_ADDR_EXP 12
 424: PUSH
 425: LD_STRING Bobby
 427: PPUSH
 428: LD_EXP 1
 432: NOT
 433: PPUSH
 434: CALL 4479 0 2
 438: ST_TO_ADDR
// if Bobby then
 439: LD_EXP 12
 443: IFFALSE 461
// team := team ^ Bobby ;
 445: LD_ADDR_VAR 0 5
 449: PUSH
 450: LD_VAR 0 5
 454: PUSH
 455: LD_EXP 12
 459: ADD
 460: ST_TO_ADDR
// if not Bobby then
 461: LD_EXP 12
 465: NOT
 466: IFFALSE 488
// begin others3 := CreateCharacterSet ( 03_others ) ;
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: LD_STRING 03_others
 475: PPUSH
 476: CALL_OW 31
 480: ST_TO_ADDR
// DeleteCharacters ( 03_others ) ;
 481: LD_STRING 03_others
 483: PPUSH
 484: CALL_OW 40
// end ; end ; end ; if others4 then
 488: LD_VAR 0 3
 492: IFFALSE 510
// team := team ^ others4 ;
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_VAR 0 5
 503: PUSH
 504: LD_VAR 0 3
 508: ADD
 509: ST_TO_ADDR
// if others3 then
 510: LD_VAR 0 2
 514: IFFALSE 532
// team := team ^ others3 ;
 516: LD_ADDR_VAR 0 5
 520: PUSH
 521: LD_VAR 0 5
 525: PUSH
 526: LD_VAR 0 2
 530: ADD
 531: ST_TO_ADDR
// if team < 9 then
 532: LD_VAR 0 5
 536: PUSH
 537: LD_INT 9
 539: LESS
 540: IFFALSE 589
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 4 ) ;
 542: LD_INT 0
 544: PPUSH
 545: LD_INT 1
 547: PPUSH
 548: LD_INT 4
 550: PPUSH
 551: CALL_OW 12
 555: PPUSH
 556: LD_INT 4
 558: PPUSH
 559: CALL_OW 380
// team := team ^ CreateHuman ;
 563: LD_ADDR_VAR 0 5
 567: PUSH
 568: LD_VAR 0 5
 572: PUSH
 573: CALL_OW 44
 577: ADD
 578: ST_TO_ADDR
// until team = 9 ;
 579: LD_VAR 0 5
 583: PUSH
 584: LD_INT 9
 586: EQUAL
 587: IFFALSE 542
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 589: LD_ADDR_VAR 0 6
 593: PUSH
 594: LD_INT 30
 596: PUSH
 597: LD_INT 0
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: PPUSH
 604: CALL_OW 69
 608: PUSH
 609: LD_INT 1
 611: ARRAY
 612: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 613: LD_ADDR_VAR 0 7
 617: PUSH
 618: LD_INT 30
 620: PUSH
 621: LD_INT 4
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL_OW 69
 632: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 633: LD_ADDR_VAR 0 8
 637: PUSH
 638: LD_INT 2
 640: PUSH
 641: LD_INT 30
 643: PUSH
 644: LD_INT 7
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 30
 653: PUSH
 654: LD_INT 6
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: PPUSH
 666: CALL_OW 69
 670: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 671: LD_ADDR_VAR 0 9
 675: PUSH
 676: LD_INT 30
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: PPUSH
 686: CALL_OW 69
 690: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 691: LD_ADDR_VAR 0 10
 695: PUSH
 696: LD_INT 2
 698: PUSH
 699: LD_INT 30
 701: PUSH
 702: LD_INT 32
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: PUSH
 709: LD_INT 30
 711: PUSH
 712: LD_INT 31
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: PPUSH
 724: CALL_OW 69
 728: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 729: LD_VAR 0 6
 733: PPUSH
 734: LD_STRING Gamma
 736: PPUSH
 737: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 741: LD_VAR 0 6
 745: PPUSH
 746: CALL_OW 274
 750: PPUSH
 751: LD_INT 2
 753: PPUSH
 754: LD_INT 10000
 756: PPUSH
 757: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 761: LD_VAR 0 6
 765: PPUSH
 766: CALL_OW 274
 770: PPUSH
 771: LD_INT 1
 773: PPUSH
 774: LD_INT 10000
 776: PPUSH
 777: CALL_OW 277
// if dep then
 781: LD_VAR 0 6
 785: IFFALSE 867
// begin if Brown then
 787: LD_EXP 14
 791: IFFALSE 827
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 793: LD_EXP 14
 797: PPUSH
 798: LD_VAR 0 6
 802: PUSH
 803: LD_INT 1
 805: ARRAY
 806: PPUSH
 807: CALL_OW 52
// team := team diff Brown ;
 811: LD_ADDR_VAR 0 5
 815: PUSH
 816: LD_VAR 0 5
 820: PUSH
 821: LD_EXP 14
 825: DIFF
 826: ST_TO_ADDR
// end ; if Donaldson then
 827: LD_EXP 13
 831: IFFALSE 867
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 833: LD_EXP 13
 837: PPUSH
 838: LD_VAR 0 6
 842: PUSH
 843: LD_INT 1
 845: ARRAY
 846: PPUSH
 847: CALL_OW 52
// team := team diff Donaldson ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 5
 860: PUSH
 861: LD_EXP 13
 865: DIFF
 866: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 867: LD_VAR 0 10
 871: PUSH
 872: LD_VAR 0 5
 876: PPUSH
 877: LD_INT 25
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: PPUSH
 887: CALL_OW 72
 891: AND
 892: IFFALSE 1001
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 894: LD_ADDR_VAR 0 11
 898: PUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: LD_INT 25
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: PPUSH
 914: CALL_OW 72
 918: ST_TO_ADDR
// for i in bun do
 919: LD_ADDR_VAR 0 12
 923: PUSH
 924: LD_VAR 0 10
 928: PUSH
 929: FOR_IN
 930: IFFALSE 999
// begin if not filter then
 932: LD_VAR 0 11
 936: NOT
 937: IFFALSE 941
// break ;
 939: GO 999
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 941: LD_VAR 0 11
 945: PUSH
 946: LD_INT 1
 948: ARRAY
 949: PPUSH
 950: LD_VAR 0 12
 954: PPUSH
 955: CALL_OW 52
// team := team diff filter [ 1 ] ;
 959: LD_ADDR_VAR 0 5
 963: PUSH
 964: LD_VAR 0 5
 968: PUSH
 969: LD_VAR 0 11
 973: PUSH
 974: LD_INT 1
 976: ARRAY
 977: DIFF
 978: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 979: LD_ADDR_VAR 0 11
 983: PUSH
 984: LD_VAR 0 11
 988: PPUSH
 989: LD_INT 1
 991: PPUSH
 992: CALL_OW 3
 996: ST_TO_ADDR
// end ;
 997: GO 929
 999: POP
1000: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1001: LD_VAR 0 7
1005: PUSH
1006: LD_VAR 0 5
1010: PPUSH
1011: LD_INT 25
1013: PUSH
1014: LD_INT 1
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: PPUSH
1021: CALL_OW 72
1025: AND
1026: IFFALSE 1148
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1028: LD_ADDR_VAR 0 11
1032: PUSH
1033: LD_VAR 0 5
1037: PPUSH
1038: LD_INT 25
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: EMPTY
1045: LIST
1046: LIST
1047: PPUSH
1048: CALL_OW 72
1052: ST_TO_ADDR
// for i = 1 to filter do
1053: LD_ADDR_VAR 0 12
1057: PUSH
1058: DOUBLE
1059: LD_INT 1
1061: DEC
1062: ST_TO_ADDR
1063: LD_VAR 0 11
1067: PUSH
1068: FOR_TO
1069: IFFALSE 1130
// begin if ( i <= 6 ) then
1071: LD_VAR 0 12
1075: PUSH
1076: LD_INT 6
1078: LESSEQUAL
1079: IFFALSE 1107
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1081: LD_VAR 0 11
1085: PUSH
1086: LD_VAR 0 12
1090: ARRAY
1091: PPUSH
1092: LD_VAR 0 7
1096: PUSH
1097: LD_INT 1
1099: ARRAY
1100: PPUSH
1101: CALL_OW 52
1105: GO 1128
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1107: LD_VAR 0 11
1111: PUSH
1112: LD_VAR 0 12
1116: ARRAY
1117: PPUSH
1118: LD_INT 1
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL_OW 49
// end ;
1128: GO 1068
1130: POP
1131: POP
// team := team diff filter ;
1132: LD_ADDR_VAR 0 5
1136: PUSH
1137: LD_VAR 0 5
1141: PUSH
1142: LD_VAR 0 11
1146: DIFF
1147: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1148: LD_VAR 0 8
1152: PUSH
1153: LD_VAR 0 5
1157: PPUSH
1158: LD_INT 25
1160: PUSH
1161: LD_INT 4
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: PPUSH
1168: CALL_OW 72
1172: AND
1173: IFFALSE 1295
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1175: LD_ADDR_VAR 0 11
1179: PUSH
1180: LD_VAR 0 5
1184: PPUSH
1185: LD_INT 25
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PPUSH
1195: CALL_OW 72
1199: ST_TO_ADDR
// for i = 1 to filter do
1200: LD_ADDR_VAR 0 12
1204: PUSH
1205: DOUBLE
1206: LD_INT 1
1208: DEC
1209: ST_TO_ADDR
1210: LD_VAR 0 11
1214: PUSH
1215: FOR_TO
1216: IFFALSE 1277
// begin if ( i <= 6 ) then
1218: LD_VAR 0 12
1222: PUSH
1223: LD_INT 6
1225: LESSEQUAL
1226: IFFALSE 1254
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1228: LD_VAR 0 11
1232: PUSH
1233: LD_VAR 0 12
1237: ARRAY
1238: PPUSH
1239: LD_VAR 0 8
1243: PUSH
1244: LD_INT 1
1246: ARRAY
1247: PPUSH
1248: CALL_OW 52
1252: GO 1275
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1254: LD_VAR 0 11
1258: PUSH
1259: LD_VAR 0 12
1263: ARRAY
1264: PPUSH
1265: LD_INT 1
1267: PPUSH
1268: LD_INT 0
1270: PPUSH
1271: CALL_OW 49
// end ;
1275: GO 1215
1277: POP
1278: POP
// team := team diff filter ;
1279: LD_ADDR_VAR 0 5
1283: PUSH
1284: LD_VAR 0 5
1288: PUSH
1289: LD_VAR 0 11
1293: DIFF
1294: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1295: LD_VAR 0 9
1299: PUSH
1300: LD_VAR 0 5
1304: PPUSH
1305: LD_INT 25
1307: PUSH
1308: LD_INT 3
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL_OW 72
1319: AND
1320: IFFALSE 1442
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1322: LD_ADDR_VAR 0 11
1326: PUSH
1327: LD_VAR 0 5
1331: PPUSH
1332: LD_INT 25
1334: PUSH
1335: LD_INT 3
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: PPUSH
1342: CALL_OW 72
1346: ST_TO_ADDR
// for i = 1 to filter do
1347: LD_ADDR_VAR 0 12
1351: PUSH
1352: DOUBLE
1353: LD_INT 1
1355: DEC
1356: ST_TO_ADDR
1357: LD_VAR 0 11
1361: PUSH
1362: FOR_TO
1363: IFFALSE 1424
// begin if ( i <= 6 ) then
1365: LD_VAR 0 12
1369: PUSH
1370: LD_INT 6
1372: LESSEQUAL
1373: IFFALSE 1401
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1375: LD_VAR 0 11
1379: PUSH
1380: LD_VAR 0 12
1384: ARRAY
1385: PPUSH
1386: LD_VAR 0 9
1390: PUSH
1391: LD_INT 1
1393: ARRAY
1394: PPUSH
1395: CALL_OW 52
1399: GO 1422
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1401: LD_VAR 0 11
1405: PUSH
1406: LD_VAR 0 12
1410: ARRAY
1411: PPUSH
1412: LD_INT 1
1414: PPUSH
1415: LD_INT 0
1417: PPUSH
1418: CALL_OW 49
// end ;
1422: GO 1362
1424: POP
1425: POP
// team := team diff filter ;
1426: LD_ADDR_VAR 0 5
1430: PUSH
1431: LD_VAR 0 5
1435: PUSH
1436: LD_VAR 0 11
1440: DIFF
1441: ST_TO_ADDR
// end ; if team then
1442: LD_VAR 0 5
1446: IFFALSE 1489
// for i in team do
1448: LD_ADDR_VAR 0 12
1452: PUSH
1453: LD_VAR 0 5
1457: PUSH
1458: FOR_IN
1459: IFFALSE 1487
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1461: LD_VAR 0 12
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 0
1471: PPUSH
1472: CALL_OW 49
// ComHold ( i ) ;
1476: LD_VAR 0 12
1480: PPUSH
1481: CALL_OW 140
// end ;
1485: GO 1458
1487: POP
1488: POP
// if fac then
1489: LD_VAR 0 9
1493: IFFALSE 1529
// if UnitsInside ( fac [ 1 ] ) then
1495: LD_VAR 0 9
1499: PUSH
1500: LD_INT 1
1502: ARRAY
1503: PPUSH
1504: CALL_OW 313
1508: IFFALSE 1529
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1510: LD_VAR 0 9
1514: PUSH
1515: LD_INT 1
1517: ARRAY
1518: PPUSH
1519: LD_INT 10
1521: PPUSH
1522: LD_INT 0
1524: PPUSH
1525: CALL_OW 486
// if lab then
1529: LD_VAR 0 8
1533: IFFALSE 1569
// if UnitsInside ( lab [ 1 ] ) then
1535: LD_VAR 0 8
1539: PUSH
1540: LD_INT 1
1542: ARRAY
1543: PPUSH
1544: CALL_OW 313
1548: IFFALSE 1569
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1550: LD_VAR 0 8
1554: PUSH
1555: LD_INT 1
1557: ARRAY
1558: PPUSH
1559: LD_INT 10
1561: PPUSH
1562: LD_INT 0
1564: PPUSH
1565: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1569: LD_ADDR_VAR 0 4
1573: PUSH
1574: LD_INT 1
1576: PPUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 1
1582: PPUSH
1583: LD_INT 2
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: LD_INT 3
1591: PPUSH
1592: LD_INT 100
1594: PPUSH
1595: CALL 4542 0 7
1599: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1600: LD_VAR 0 4
1604: PPUSH
1605: LD_INT 2
1607: PPUSH
1608: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1612: LD_VAR 0 4
1616: PPUSH
1617: LD_INT 21
1619: PPUSH
1620: LD_INT 8
1622: PPUSH
1623: LD_INT 0
1625: PPUSH
1626: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1630: LD_EXP 7
1634: PPUSH
1635: LD_VAR 0 4
1639: PPUSH
1640: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1644: LD_ADDR_VAR 0 4
1648: PUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 2
1660: PPUSH
1661: LD_INT 1
1663: PPUSH
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 100
1669: PPUSH
1670: CALL 4542 0 7
1674: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1675: LD_VAR 0 4
1679: PPUSH
1680: LD_INT 2
1682: PPUSH
1683: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1687: LD_VAR 0 4
1691: PPUSH
1692: LD_INT 16
1694: PPUSH
1695: LD_INT 3
1697: PPUSH
1698: LD_INT 0
1700: PPUSH
1701: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1705: LD_EXP 8
1709: PPUSH
1710: LD_VAR 0 4
1714: PPUSH
1715: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_INT 1
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: LD_INT 2
1732: PPUSH
1733: LD_INT 2
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 12
1741: PPUSH
1742: LD_INT 100
1744: PPUSH
1745: CALL 4542 0 7
1749: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1750: LD_VAR 0 4
1754: PPUSH
1755: LD_INT 0
1757: PPUSH
1758: LD_INT 5
1760: PPUSH
1761: CALL_OW 12
1765: PPUSH
1766: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1770: LD_VAR 0 4
1774: PPUSH
1775: LD_INT 1
1777: PPUSH
1778: LD_INT 0
1780: PPUSH
1781: CALL_OW 49
// end ;
1785: LD_VAR 0 1
1789: RET
// function PrepareBase ; var blist , i , b ; begin
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
1796: LD_INT 71
1798: PPUSH
1799: LD_INT 5
1801: PPUSH
1802: LD_INT 1
1804: PPUSH
1805: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
1809: LD_ADDR_VAR 0 2
1813: PUSH
1814: LD_STRING GammaBase
1816: PPUSH
1817: EMPTY
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if not blist then
1824: LD_VAR 0 2
1828: NOT
1829: IFFALSE 1869
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: LD_INT 0
1838: PUSH
1839: LD_INT 52
1841: PUSH
1842: LD_INT 12
1844: PUSH
1845: LD_INT 3
1847: PUSH
1848: LD_INT 3
1850: PUSH
1851: LD_INT 0
1853: PUSH
1854: LD_INT 0
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PUSH
1866: EMPTY
1867: LIST
1868: ST_TO_ADDR
// uc_side := 1 ;
1869: LD_ADDR_OWVAR 20
1873: PUSH
1874: LD_INT 1
1876: ST_TO_ADDR
// uc_nation := 1 ;
1877: LD_ADDR_OWVAR 21
1881: PUSH
1882: LD_INT 1
1884: ST_TO_ADDR
// for i in blist do
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_VAR 0 2
1894: PUSH
1895: FOR_IN
1896: IFFALSE 2089
// begin InitBc ;
1898: CALL_OW 21
// bc_type := i [ 1 ] ;
1902: LD_ADDR_OWVAR 42
1906: PUSH
1907: LD_VAR 0 3
1911: PUSH
1912: LD_INT 1
1914: ARRAY
1915: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1916: LD_ADDR_OWVAR 43
1920: PUSH
1921: LD_VAR 0 3
1925: PUSH
1926: LD_INT 5
1928: ARRAY
1929: ST_TO_ADDR
// bc_kind1 := b_lab_basic ;
1930: LD_ADDR_OWVAR 44
1934: PUSH
1935: LD_INT 9
1937: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
1938: LD_ADDR_OWVAR 45
1942: PUSH
1943: LD_INT 9
1945: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PUSH
1955: LD_INT 7
1957: PUSH
1958: LD_INT 8
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: IN
1965: IFFALSE 2017
// begin bc_kind1 := i [ 7 ] ;
1967: LD_ADDR_OWVAR 44
1971: PUSH
1972: LD_VAR 0 3
1976: PUSH
1977: LD_INT 7
1979: ARRAY
1980: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
1981: LD_ADDR_OWVAR 45
1985: PUSH
1986: LD_INT 9
1988: ST_TO_ADDR
// if i [ 1 ] = b_lab_full then
1989: LD_VAR 0 3
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 8
2000: EQUAL
2001: IFFALSE 2017
// bc_kind2 := i [ 8 ] ;
2003: LD_ADDR_OWVAR 45
2007: PUSH
2008: LD_VAR 0 3
2012: PUSH
2013: LD_INT 8
2015: ARRAY
2016: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2017: LD_ADDR_VAR 0 4
2021: PUSH
2022: LD_VAR 0 3
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: PPUSH
2031: LD_VAR 0 3
2035: PUSH
2036: LD_INT 3
2038: ARRAY
2039: PPUSH
2040: LD_VAR 0 3
2044: PUSH
2045: LD_INT 4
2047: ARRAY
2048: PPUSH
2049: CALL_OW 47
2053: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2054: LD_VAR 0 4
2058: PPUSH
2059: CALL_OW 266
2063: PUSH
2064: LD_INT 32
2066: EQUAL
2067: IFFALSE 2087
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2069: LD_VAR 0 4
2073: PPUSH
2074: LD_VAR 0 3
2078: PUSH
2079: LD_INT 7
2081: ARRAY
2082: PPUSH
2083: CALL_OW 431
// end ; end ;
2087: GO 1895
2089: POP
2090: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2091: LD_INT 30
2093: PUSH
2094: LD_INT 0
2096: PUSH
2097: EMPTY
2098: LIST
2099: LIST
2100: PPUSH
2101: CALL_OW 69
2105: NOT
2106: IFFALSE 2143
// begin bc_type := b_depot ;
2108: LD_ADDR_OWVAR 42
2112: PUSH
2113: LD_INT 0
2115: ST_TO_ADDR
// bc_level := 6 ;
2116: LD_ADDR_OWVAR 43
2120: PUSH
2121: LD_INT 6
2123: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2124: LD_ADDR_VAR 0 4
2128: PUSH
2129: LD_INT 52
2131: PPUSH
2132: LD_INT 12
2134: PPUSH
2135: LD_INT 3
2137: PPUSH
2138: CALL_OW 47
2142: ST_TO_ADDR
// end ; end ; end_of_file
2143: LD_VAR 0 1
2147: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2148: LD_INT 0
2150: PPUSH
2151: PPUSH
2152: PPUSH
2153: PPUSH
2154: PPUSH
2155: PPUSH
2156: PPUSH
2157: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
2158: LD_INT 0
2160: PPUSH
2161: LD_INT 0
2163: PPUSH
2164: LD_INT 1
2166: PPUSH
2167: LD_INT 32976
2169: NEG
2170: PPUSH
2171: CALL_OW 330
// InGameOn ;
2175: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2179: LD_INT 33
2181: PPUSH
2182: LD_INT 11
2184: PPUSH
2185: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2189: LD_ADDR_VAR 0 2
2193: PUSH
2194: LD_INT 29
2196: PUSH
2197: LD_INT 21
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: PUSH
2204: LD_INT 41
2206: PUSH
2207: LD_INT 28
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 52
2216: PUSH
2217: LD_INT 26
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 49
2226: PUSH
2227: LD_INT 16
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: LIST
2238: LIST
2239: ST_TO_ADDR
// for i in points do
2240: LD_ADDR_VAR 0 3
2244: PUSH
2245: LD_VAR 0 2
2249: PUSH
2250: FOR_IN
2251: IFFALSE 2291
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2253: LD_EXP 7
2257: PUSH
2258: LD_EXP 8
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PPUSH
2267: LD_VAR 0 3
2271: PUSH
2272: LD_INT 1
2274: ARRAY
2275: PPUSH
2276: LD_VAR 0 3
2280: PUSH
2281: LD_INT 2
2283: ARRAY
2284: PPUSH
2285: CALL_OW 171
2289: GO 2250
2291: POP
2292: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2293: LD_EXP 7
2297: PUSH
2298: LD_EXP 8
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2311: LD_INT 35
2313: PPUSH
2314: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2318: LD_EXP 7
2322: PPUSH
2323: CALL_OW 310
2327: NOT
2328: PUSH
2329: LD_EXP 8
2333: PPUSH
2334: CALL_OW 310
2338: NOT
2339: AND
2340: IFFALSE 2311
// ComTurnUnit ( JMM , Gladstone ) ;
2342: LD_EXP 7
2346: PPUSH
2347: LD_EXP 8
2351: PPUSH
2352: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2356: LD_EXP 8
2360: PPUSH
2361: LD_EXP 7
2365: PPUSH
2366: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2370: LD_ADDR_VAR 0 4
2374: PUSH
2375: LD_INT 26
2377: PUSH
2378: LD_INT 1
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PUSH
2390: LD_EXP 7
2394: PUSH
2395: LD_EXP 8
2399: PUSH
2400: LD_EXP 12
2404: PUSH
2405: LD_EXP 11
2409: PUSH
2410: LD_EXP 9
2414: PUSH
2415: LD_EXP 14
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: LIST
2426: LIST
2427: DIFF
2428: ST_TO_ADDR
// if sol then
2429: LD_VAR 0 4
2433: IFFALSE 2449
// sol := sol [ 1 ] ;
2435: LD_ADDR_VAR 0 4
2439: PUSH
2440: LD_VAR 0 4
2444: PUSH
2445: LD_INT 1
2447: ARRAY
2448: ST_TO_ADDR
// team := [ ] ;
2449: LD_ADDR_VAR 0 5
2453: PUSH
2454: EMPTY
2455: ST_TO_ADDR
// if sol then
2456: LD_VAR 0 4
2460: IFFALSE 2478
// team := team ^ sol ;
2462: LD_ADDR_VAR 0 5
2466: PUSH
2467: LD_VAR 0 5
2471: PUSH
2472: LD_VAR 0 4
2476: ADD
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 10
2482: IFFALSE 2500
// team := team ^ Lisa ;
2484: LD_ADDR_VAR 0 5
2488: PUSH
2489: LD_VAR 0 5
2493: PUSH
2494: LD_EXP 10
2498: ADD
2499: ST_TO_ADDR
// if Donaldson then
2500: LD_EXP 13
2504: IFFALSE 2522
// team := team ^ Donaldson ;
2506: LD_ADDR_VAR 0 5
2510: PUSH
2511: LD_VAR 0 5
2515: PUSH
2516: LD_EXP 13
2520: ADD
2521: ST_TO_ADDR
// if Brown then
2522: LD_EXP 14
2526: IFFALSE 2544
// team := team ^ Brown ;
2528: LD_ADDR_VAR 0 5
2532: PUSH
2533: LD_VAR 0 5
2537: PUSH
2538: LD_EXP 14
2542: ADD
2543: ST_TO_ADDR
// if Bobby then
2544: LD_EXP 12
2548: IFFALSE 2566
// team := team ^ Bobby ;
2550: LD_ADDR_VAR 0 5
2554: PUSH
2555: LD_VAR 0 5
2559: PUSH
2560: LD_EXP 12
2564: ADD
2565: ST_TO_ADDR
// if Cyrus then
2566: LD_EXP 11
2570: IFFALSE 2588
// team := team ^ Cyrus ;
2572: LD_ADDR_VAR 0 5
2576: PUSH
2577: LD_VAR 0 5
2581: PUSH
2582: LD_EXP 11
2586: ADD
2587: ST_TO_ADDR
// if Frank then
2588: LD_EXP 9
2592: IFFALSE 2610
// team := team ^ Frank ;
2594: LD_ADDR_VAR 0 5
2598: PUSH
2599: LD_VAR 0 5
2603: PUSH
2604: LD_EXP 9
2608: ADD
2609: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2610: LD_ADDR_VAR 0 3
2614: PUSH
2615: LD_INT 1
2617: PPUSH
2618: LD_INT 3
2620: PUSH
2621: LD_INT 54
2623: PUSH
2624: EMPTY
2625: LIST
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 21
2633: PUSH
2634: LD_INT 1
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: PPUSH
2645: CALL_OW 70
2649: PUSH
2650: LD_EXP 7
2654: PUSH
2655: LD_EXP 8
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: DIFF
2664: PUSH
2665: EMPTY
2666: LIST
2667: PUSH
2668: FOR_IN
2669: IFFALSE 2689
// team := team ^ i ;
2671: LD_ADDR_VAR 0 5
2675: PUSH
2676: LD_VAR 0 5
2680: PUSH
2681: LD_VAR 0 3
2685: ADD
2686: ST_TO_ADDR
2687: GO 2668
2689: POP
2690: POP
// if team then
2691: LD_VAR 0 5
2695: IFFALSE 2771
// begin ComExitBuilding ( team ) ;
2697: LD_VAR 0 5
2701: PPUSH
2702: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2706: LD_VAR 0 5
2710: PPUSH
2711: LD_EXP 7
2715: PPUSH
2716: CALL_OW 172
// repeat wait ( 1 ) ;
2720: LD_INT 1
2722: PPUSH
2723: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2727: LD_EXP 7
2731: PPUSH
2732: LD_VAR 0 5
2736: PPUSH
2737: LD_EXP 7
2741: PPUSH
2742: CALL_OW 74
2746: PPUSH
2747: CALL_OW 296
2751: PUSH
2752: LD_INT 6
2754: LESS
2755: IFFALSE 2720
// ComTurnUnit ( team , JMM ) ;
2757: LD_VAR 0 5
2761: PPUSH
2762: LD_EXP 7
2766: PPUSH
2767: CALL_OW 119
// end ; if Lisa then
2771: LD_EXP 10
2775: IFFALSE 2803
// begin ComTurnUnit ( JMM , Lisa ) ;
2777: LD_EXP 7
2781: PPUSH
2782: LD_EXP 10
2786: PPUSH
2787: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2791: LD_EXP 10
2795: PPUSH
2796: LD_STRING D1-Lisa-1
2798: PPUSH
2799: CALL_OW 88
// end ; if sol then
2803: LD_VAR 0 4
2807: IFFALSE 2835
// begin ComTurnUnit ( JMM , sol ) ;
2809: LD_EXP 7
2813: PPUSH
2814: LD_VAR 0 4
2818: PPUSH
2819: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2823: LD_VAR 0 4
2827: PPUSH
2828: LD_STRING D1-Sol1-1
2830: PPUSH
2831: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2835: LD_EXP 7
2839: PPUSH
2840: LD_STRING D1-JMM-1
2842: PPUSH
2843: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2847: LD_EXP 7
2851: PPUSH
2852: LD_STRING D1-JMM-1a
2854: PPUSH
2855: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2859: LD_EXP 7
2863: PPUSH
2864: LD_EXP 8
2868: PPUSH
2869: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2873: LD_VAR 0 5
2877: PPUSH
2878: LD_EXP 8
2882: PPUSH
2883: CALL_OW 119
// if Frank then
2887: LD_EXP 9
2891: IFFALSE 2919
// begin Say ( Frank , D1-Frank-1 ) ;
2893: LD_EXP 9
2897: PPUSH
2898: LD_STRING D1-Frank-1
2900: PPUSH
2901: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2905: LD_EXP 7
2909: PPUSH
2910: LD_EXP 9
2914: PPUSH
2915: CALL_OW 119
// end ; if Lisa then
2919: LD_EXP 10
2923: IFFALSE 2951
// begin ComTurnUnit ( JMM , Lisa ) ;
2925: LD_EXP 7
2929: PPUSH
2930: LD_EXP 10
2934: PPUSH
2935: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2939: LD_EXP 10
2943: PPUSH
2944: LD_STRING D1-Lisa-2
2946: PPUSH
2947: CALL_OW 88
// end ; if sol then
2951: LD_VAR 0 4
2955: IFFALSE 2983
// begin ComTurnUnit ( JMM , sol ) ;
2957: LD_EXP 7
2961: PPUSH
2962: LD_VAR 0 4
2966: PPUSH
2967: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2971: LD_VAR 0 4
2975: PPUSH
2976: LD_STRING D1-Sol1-2
2978: PPUSH
2979: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2983: LD_EXP 8
2987: PPUSH
2988: LD_STRING D1-Glad-2
2990: PPUSH
2991: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2995: LD_VAR 0 5
2999: PPUSH
3000: LD_EXP 7
3004: PPUSH
3005: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
3009: LD_EXP 7
3013: PPUSH
3014: LD_STRING D1-JMM-2
3016: PPUSH
3017: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
3021: LD_EXP 7
3025: PPUSH
3026: LD_EXP 8
3030: PPUSH
3031: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
3035: LD_EXP 8
3039: PPUSH
3040: LD_STRING D1-Glad-3
3042: PPUSH
3043: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3047: LD_EXP 7
3051: PPUSH
3052: LD_STRING D1-JMM-3
3054: PPUSH
3055: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
3059: LD_EXP 8
3063: PPUSH
3064: LD_STRING D1-Glad-4
3066: PPUSH
3067: CALL_OW 88
// if Frank then
3071: LD_EXP 9
3075: IFFALSE 3103
// begin ComTurnUnit ( JMM , Frank ) ;
3077: LD_EXP 7
3081: PPUSH
3082: LD_EXP 9
3086: PPUSH
3087: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
3091: LD_EXP 9
3095: PPUSH
3096: LD_STRING D1-Frank-4
3098: PPUSH
3099: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3103: LD_EXP 7
3107: PPUSH
3108: LD_EXP 8
3112: PPUSH
3113: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
3117: LD_EXP 7
3121: PPUSH
3122: LD_STRING D1-JMM-4
3124: PPUSH
3125: CALL_OW 88
// if Lisa then
3129: LD_EXP 10
3133: IFFALSE 3200
// begin Say ( Lisa , D1-Lisa-4 ) ;
3135: LD_EXP 10
3139: PPUSH
3140: LD_STRING D1-Lisa-4
3142: PPUSH
3143: CALL_OW 88
// if Frank then
3147: LD_EXP 9
3151: IFFALSE 3200
// begin ComTurnUnit ( Frank , Lisa ) ;
3153: LD_EXP 9
3157: PPUSH
3158: LD_EXP 10
3162: PPUSH
3163: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3167: LD_EXP 9
3171: PPUSH
3172: LD_STRING D1-Frank-5
3174: PPUSH
3175: CALL_OW 88
// Wait ( 3 ) ;
3179: LD_INT 3
3181: PPUSH
3182: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3186: LD_EXP 9
3190: PPUSH
3191: LD_EXP 7
3195: PPUSH
3196: CALL_OW 179
// end ; end ; if sol then
3200: LD_VAR 0 4
3204: IFFALSE 3218
// Say ( sol , D1-Sol1-5 ) ;
3206: LD_VAR 0 4
3210: PPUSH
3211: LD_STRING D1-Sol1-5
3213: PPUSH
3214: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3218: LD_EXP 7
3222: PPUSH
3223: LD_STRING D1-JMM-5
3225: PPUSH
3226: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3230: LD_EXP 8
3234: PPUSH
3235: LD_STRING D1-Glad-5
3237: PPUSH
3238: CALL_OW 88
// if Frank then
3242: LD_EXP 9
3246: IFFALSE 3260
// Say ( Frank , D1-Frank-6 ) ;
3248: LD_EXP 9
3252: PPUSH
3253: LD_STRING D1-Frank-6
3255: PPUSH
3256: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3260: LD_EXP 7
3264: PPUSH
3265: LD_STRING D1-JMM-6
3267: PPUSH
3268: CALL_OW 88
// if Brown and Donaldson then
3272: LD_EXP 14
3276: PUSH
3277: LD_EXP 13
3281: AND
3282: IFFALSE 3331
// case Query ( QCommander ) of 1 :
3284: LD_STRING QCommander
3286: PPUSH
3287: CALL_OW 97
3291: PUSH
3292: LD_INT 1
3294: DOUBLE
3295: EQUAL
3296: IFTRUE 3300
3298: GO 3311
3300: POP
// donaldson_commander := true ; 2 :
3301: LD_ADDR_EXP 4
3305: PUSH
3306: LD_INT 1
3308: ST_TO_ADDR
3309: GO 3331
3311: LD_INT 2
3313: DOUBLE
3314: EQUAL
3315: IFTRUE 3319
3317: GO 3330
3319: POP
// brown_commander := true ; end ;
3320: LD_ADDR_EXP 5
3324: PUSH
3325: LD_INT 1
3327: ST_TO_ADDR
3328: GO 3331
3330: POP
// if not Brown and Donaldson then
3331: LD_EXP 14
3335: NOT
3336: PUSH
3337: LD_EXP 13
3341: AND
3342: IFFALSE 3352
// donaldson_commander := true ;
3344: LD_ADDR_EXP 4
3348: PUSH
3349: LD_INT 1
3351: ST_TO_ADDR
// if Brown and not Donaldson then
3352: LD_EXP 14
3356: PUSH
3357: LD_EXP 13
3361: NOT
3362: AND
3363: IFFALSE 3373
// brown_commander := true ;
3365: LD_ADDR_EXP 5
3369: PUSH
3370: LD_INT 1
3372: ST_TO_ADDR
// if donaldson_commander then
3373: LD_EXP 4
3377: IFFALSE 3524
// begin ComTurnUnit ( JMM , Donaldson ) ;
3379: LD_EXP 7
3383: PPUSH
3384: LD_EXP 13
3388: PPUSH
3389: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3393: LD_EXP 7
3397: PPUSH
3398: LD_STRING D1a-JMM-1
3400: PPUSH
3401: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3405: LD_EXP 13
3409: PPUSH
3410: LD_EXP 7
3414: PPUSH
3415: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3419: LD_EXP 13
3423: PPUSH
3424: LD_EXP 7
3428: PPUSH
3429: CALL_OW 179
// Wait ( 3 ) ;
3433: LD_INT 3
3435: PPUSH
3436: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3440: LD_EXP 13
3444: PPUSH
3445: LD_STRING D1a-Don-1
3447: PPUSH
3448: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3452: LD_EXP 7
3456: PPUSH
3457: LD_STRING D1b-JMM-2
3459: PPUSH
3460: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3464: LD_EXP 13
3468: PPUSH
3469: LD_STRING D1a-Don-2
3471: PPUSH
3472: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3476: LD_EXP 13
3480: PPUSH
3481: LD_INT 30
3483: PUSH
3484: LD_INT 0
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: PUSH
3496: LD_INT 1
3498: ARRAY
3499: PPUSH
3500: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3504: LD_INT 1
3506: PPUSH
3507: LD_STRING GammaCommander
3509: PPUSH
3510: CALL_OW 39
// commander := Donaldson ;
3514: LD_ADDR_VAR 0 7
3518: PUSH
3519: LD_EXP 13
3523: ST_TO_ADDR
// end ; if brown_commander then
3524: LD_EXP 5
3528: IFFALSE 3675
// begin ComTurnUnit ( JMM , Brown ) ;
3530: LD_EXP 7
3534: PPUSH
3535: LD_EXP 14
3539: PPUSH
3540: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3544: LD_EXP 7
3548: PPUSH
3549: LD_STRING D1b-JMM-1
3551: PPUSH
3552: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3556: LD_EXP 14
3560: PPUSH
3561: LD_EXP 7
3565: PPUSH
3566: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3570: LD_EXP 14
3574: PPUSH
3575: LD_EXP 7
3579: PPUSH
3580: CALL_OW 179
// Wait ( 3 ) ;
3584: LD_INT 3
3586: PPUSH
3587: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3591: LD_EXP 14
3595: PPUSH
3596: LD_STRING D1b-Brown-1
3598: PPUSH
3599: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3603: LD_EXP 7
3607: PPUSH
3608: LD_STRING D1a-JMM-2
3610: PPUSH
3611: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3615: LD_EXP 14
3619: PPUSH
3620: LD_STRING D1b-Brown-2
3622: PPUSH
3623: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3627: LD_EXP 14
3631: PPUSH
3632: LD_INT 30
3634: PUSH
3635: LD_INT 0
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 69
3646: PUSH
3647: LD_INT 1
3649: ARRAY
3650: PPUSH
3651: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3655: LD_INT 2
3657: PPUSH
3658: LD_STRING GammaCommander
3660: PPUSH
3661: CALL_OW 39
// commander := Brown ;
3665: LD_ADDR_VAR 0 7
3669: PUSH
3670: LD_EXP 14
3674: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3675: LD_EXP 7
3679: PPUSH
3680: LD_EXP 8
3684: PPUSH
3685: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3689: LD_EXP 4
3693: NOT
3694: PUSH
3695: LD_EXP 5
3699: NOT
3700: AND
3701: IFFALSE 3725
// begin Say ( JMM , D1c-JMM-1 ) ;
3703: LD_EXP 7
3707: PPUSH
3708: LD_STRING D1c-JMM-1
3710: PPUSH
3711: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3715: LD_INT 3
3717: PPUSH
3718: LD_STRING GammaCommander
3720: PPUSH
3721: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3725: LD_EXP 7
3729: PPUSH
3730: LD_STRING D1d-JMM-1
3732: PPUSH
3733: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3737: LD_ADDR_VAR 0 6
3741: PUSH
3742: LD_INT 21
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: PUSH
3757: LD_EXP 7
3761: PUSH
3762: LD_EXP 8
3766: PUSH
3767: LD_VAR 0 7
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: DIFF
3777: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3778: LD_ADDR_EXP 6
3782: PUSH
3783: LD_STRING 1
3785: PPUSH
3786: LD_INT 5
3788: PPUSH
3789: LD_INT 5
3791: PPUSH
3792: LD_INT -5
3794: PUSH
3795: LD_EXP 7
3799: PUSH
3800: LD_INT -6
3802: PUSH
3803: LD_EXP 8
3807: PUSH
3808: LD_INT -2
3810: PUSH
3811: LD_INT -3
3813: PUSH
3814: LD_INT -5
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_VAR 0 6
3830: ADD
3831: PUSH
3832: LD_INT -6
3834: PUSH
3835: LD_INT -4
3837: PUSH
3838: LD_VAR 0 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: ADD
3848: PPUSH
3849: LD_INT 1
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 2
3857: PUSH
3858: LD_INT 1
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: PPUSH
3874: CALL_OW 42
3878: ST_TO_ADDR
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3879: LD_EXP 7
3883: PPUSH
3884: LD_EXP 2
3888: PUSH
3889: LD_STRING JMM
3891: STR
3892: PPUSH
3893: CALL_OW 38
// if Lisa in save_group then
3897: LD_EXP 10
3901: PUSH
3902: LD_EXP 6
3906: IN
3907: IFFALSE 3937
// begin SaveVariable ( true , LisaInDelta ) ;
3909: LD_INT 1
3911: PPUSH
3912: LD_STRING LisaInDelta
3914: PPUSH
3915: CALL_OW 39
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3919: LD_EXP 10
3923: PPUSH
3924: LD_EXP 2
3928: PUSH
3929: LD_STRING Lisa
3931: STR
3932: PPUSH
3933: CALL_OW 38
// end ; if Bobby in save_group then
3937: LD_EXP 12
3941: PUSH
3942: LD_EXP 6
3946: IN
3947: IFFALSE 3977
// begin SaveVariable ( true , BobbyInDelta ) ;
3949: LD_INT 1
3951: PPUSH
3952: LD_STRING BobbyInDelta
3954: PPUSH
3955: CALL_OW 39
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3959: LD_EXP 12
3963: PPUSH
3964: LD_EXP 2
3968: PUSH
3969: LD_STRING Bobby
3971: STR
3972: PPUSH
3973: CALL_OW 38
// end ; if Cyrus in save_group then
3977: LD_EXP 11
3981: PUSH
3982: LD_EXP 6
3986: IN
3987: IFFALSE 4017
// begin SaveVariable ( true , CyrusInDelta ) ;
3989: LD_INT 1
3991: PPUSH
3992: LD_STRING CyrusInDelta
3994: PPUSH
3995: CALL_OW 39
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3999: LD_EXP 11
4003: PPUSH
4004: LD_EXP 2
4008: PUSH
4009: LD_STRING Cyrus
4011: STR
4012: PPUSH
4013: CALL_OW 38
// end ; if Frank in save_group then
4017: LD_EXP 9
4021: PUSH
4022: LD_EXP 6
4026: IN
4027: IFFALSE 4057
// begin SaveVariable ( true , FrankInDelta ) ;
4029: LD_INT 1
4031: PPUSH
4032: LD_STRING FrankInDelta
4034: PPUSH
4035: CALL_OW 39
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
4039: LD_EXP 9
4043: PPUSH
4044: LD_EXP 2
4048: PUSH
4049: LD_STRING Frank
4051: STR
4052: PPUSH
4053: CALL_OW 38
// end ; if Brown in save_group then
4057: LD_EXP 14
4061: PUSH
4062: LD_EXP 6
4066: IN
4067: IFFALSE 4097
// begin SaveVariable ( true , BrownInDelta ) ;
4069: LD_INT 1
4071: PPUSH
4072: LD_STRING BrownInDelta
4074: PPUSH
4075: CALL_OW 39
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
4079: LD_EXP 14
4083: PPUSH
4084: LD_EXP 2
4088: PUSH
4089: LD_STRING Brown
4091: STR
4092: PPUSH
4093: CALL_OW 38
// end ; if Donaldson in save_group then
4097: LD_EXP 13
4101: PUSH
4102: LD_EXP 6
4106: IN
4107: IFFALSE 4137
// begin SaveVariable ( true , DonaldsonInDelta ) ;
4109: LD_INT 1
4111: PPUSH
4112: LD_STRING DonaldsonInDelta
4114: PPUSH
4115: CALL_OW 39
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4119: LD_EXP 13
4123: PPUSH
4124: LD_EXP 2
4128: PUSH
4129: LD_STRING Donaldson
4131: STR
4132: PPUSH
4133: CALL_OW 38
// end ; SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] ^ save_group , othersGamma ) ;
4137: LD_VAR 0 6
4141: PUSH
4142: LD_EXP 7
4146: PUSH
4147: LD_EXP 8
4151: PUSH
4152: LD_EXP 10
4156: PUSH
4157: LD_EXP 11
4161: PUSH
4162: LD_EXP 12
4166: PUSH
4167: LD_EXP 9
4171: PUSH
4172: LD_EXP 13
4176: PUSH
4177: LD_EXP 14
4181: PUSH
4182: LD_INT 0
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_EXP 6
4200: ADD
4201: DIFF
4202: PPUSH
4203: LD_STRING othersGamma
4205: PPUSH
4206: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
4210: LD_EXP 6
4214: PUSH
4215: LD_EXP 7
4219: PUSH
4220: LD_EXP 8
4224: PUSH
4225: LD_EXP 10
4229: PUSH
4230: LD_EXP 11
4234: PUSH
4235: LD_EXP 12
4239: PUSH
4240: LD_EXP 9
4244: PUSH
4245: LD_EXP 13
4249: PUSH
4250: LD_EXP 14
4254: PUSH
4255: LD_INT 0
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: DIFF
4269: PPUSH
4270: LD_STRING othersDelta
4272: PPUSH
4273: CALL_OW 38
// Wait ( 3 ) ;
4277: LD_INT 3
4279: PPUSH
4280: CALL_OW 67
// for i in save_group do
4284: LD_ADDR_VAR 0 3
4288: PUSH
4289: LD_EXP 6
4293: PUSH
4294: FOR_IN
4295: IFFALSE 4326
// begin if IsInUnit ( i ) then
4297: LD_VAR 0 3
4301: PPUSH
4302: CALL_OW 310
4306: IFFALSE 4317
// ComExitBuilding ( i ) ;
4308: LD_VAR 0 3
4312: PPUSH
4313: CALL_OW 122
// Wait ( 3 ) ;
4317: LD_INT 3
4319: PPUSH
4320: CALL_OW 67
// end ;
4324: GO 4294
4326: POP
4327: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4328: LD_ADDR_EXP 6
4332: PUSH
4333: LD_EXP 6
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: LD_EXP 7
4345: PPUSH
4346: CALL_OW 2
4350: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4351: LD_ADDR_EXP 6
4355: PUSH
4356: LD_EXP 6
4360: PPUSH
4361: LD_INT 2
4363: PPUSH
4364: LD_EXP 8
4368: PPUSH
4369: CALL_OW 2
4373: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4374: LD_ADDR_VAR 0 8
4378: PUSH
4379: LD_INT 21
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PPUSH
4389: CALL_OW 69
4393: ST_TO_ADDR
// for i = 1 to filter do
4394: LD_ADDR_VAR 0 3
4398: PUSH
4399: DOUBLE
4400: LD_INT 1
4402: DEC
4403: ST_TO_ADDR
4404: LD_VAR 0 8
4408: PUSH
4409: FOR_TO
4410: IFFALSE 4440
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4412: LD_EXP 6
4416: PUSH
4417: LD_VAR 0 3
4421: ARRAY
4422: PPUSH
4423: LD_VAR 0 8
4427: PUSH
4428: LD_VAR 0 3
4432: ARRAY
4433: PPUSH
4434: CALL_OW 120
4438: GO 4409
4440: POP
4441: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4442: LD_EXP 6
4446: PPUSH
4447: LD_INT 87
4449: PPUSH
4450: LD_INT 27
4452: PPUSH
4453: CALL_OW 171
// Wait ( 0 0$05 ) ;
4457: LD_INT 175
4459: PPUSH
4460: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4464: LD_INT 1
4466: PPUSH
4467: LD_STRING %_cont
4469: PPUSH
4470: CALL_OW 340
// end ; end_of_file
4474: LD_VAR 0 1
4478: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4479: LD_INT 0
4481: PPUSH
4482: PPUSH
// if exist_mode then
4483: LD_VAR 0 2
4487: IFFALSE 4512
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4489: LD_ADDR_VAR 0 4
4493: PUSH
4494: LD_EXP 3
4498: PUSH
4499: LD_VAR 0 1
4503: STR
4504: PPUSH
4505: CALL_OW 34
4509: ST_TO_ADDR
4510: GO 4527
// unit := NewCharacter ( ident ) ;
4512: LD_ADDR_VAR 0 4
4516: PUSH
4517: LD_VAR 0 1
4521: PPUSH
4522: CALL_OW 25
4526: ST_TO_ADDR
// result := unit ;
4527: LD_ADDR_VAR 0 3
4531: PUSH
4532: LD_VAR 0 4
4536: ST_TO_ADDR
// end ;
4537: LD_VAR 0 3
4541: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4542: LD_INT 0
4544: PPUSH
// uc_side := side ;
4545: LD_ADDR_OWVAR 20
4549: PUSH
4550: LD_VAR 0 1
4554: ST_TO_ADDR
// uc_nation := nation ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_VAR 0 2
4564: ST_TO_ADDR
// vc_chassis := chassis ;
4565: LD_ADDR_OWVAR 37
4569: PUSH
4570: LD_VAR 0 3
4574: ST_TO_ADDR
// vc_engine := engine ;
4575: LD_ADDR_OWVAR 39
4579: PUSH
4580: LD_VAR 0 4
4584: ST_TO_ADDR
// vc_control := control ;
4585: LD_ADDR_OWVAR 38
4589: PUSH
4590: LD_VAR 0 5
4594: ST_TO_ADDR
// vc_weapon := weapon ;
4595: LD_ADDR_OWVAR 40
4599: PUSH
4600: LD_VAR 0 6
4604: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4605: LD_ADDR_OWVAR 41
4609: PUSH
4610: LD_VAR 0 7
4614: ST_TO_ADDR
// result := CreateVehicle ;
4615: LD_ADDR_VAR 0 8
4619: PUSH
4620: CALL_OW 45
4624: ST_TO_ADDR
// end ;
4625: LD_VAR 0 8
4629: RET
// export function SayX ( units , ident ) ; var i ; begin
4630: LD_INT 0
4632: PPUSH
4633: PPUSH
// result := false ;
4634: LD_ADDR_VAR 0 3
4638: PUSH
4639: LD_INT 0
4641: ST_TO_ADDR
// if not units then
4642: LD_VAR 0 1
4646: NOT
4647: IFFALSE 4651
// exit ;
4649: GO 4705
// for i in units do
4651: LD_ADDR_VAR 0 4
4655: PUSH
4656: LD_VAR 0 1
4660: PUSH
4661: FOR_IN
4662: IFFALSE 4703
// if IsOk ( i ) then
4664: LD_VAR 0 4
4668: PPUSH
4669: CALL_OW 302
4673: IFFALSE 4701
// begin Say ( i , ident ) ;
4675: LD_VAR 0 4
4679: PPUSH
4680: LD_VAR 0 2
4684: PPUSH
4685: CALL_OW 88
// result := i ;
4689: LD_ADDR_VAR 0 3
4693: PUSH
4694: LD_VAR 0 4
4698: ST_TO_ADDR
// break ;
4699: GO 4703
// end ;
4701: GO 4661
4703: POP
4704: POP
// end ;
4705: LD_VAR 0 3
4709: RET
