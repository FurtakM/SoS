// starting begin RandomizeAll ;
   0: CALL_OW 11
// Baza ;
   4: CALL 9 0 0
// end ; end_of_file
   8: END
// export ArBuildings ; export function Baza ; var i ; begin
   9: LD_INT 0
  11: PPUSH
  12: PPUSH
// ArBuildings := [ [ b_depot , 42 , 20 , 2 ] , [ b_armoury , 46 , 15 , 2 ] , [ b_breastwork , 35 , 21 , 0 ] , [ b_lab , 30 , 10 , 2 , b_lab_weapon , b_lab_siberium ] , [ b_workshop , 24 , 17 , 4 ] , [ b_solar_power , 35 , 5 , 3 ] , [ b_solar_power , 37 , 5 , 3 ] , [ b_solar_power , 39 , 5 , 3 ] , ] ;
  13: LD_ADDR_EXP 1
  17: PUSH
  18: LD_INT 0
  20: PUSH
  21: LD_INT 42
  23: PUSH
  24: LD_INT 20
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: EMPTY
  31: LIST
  32: LIST
  33: LIST
  34: LIST
  35: PUSH
  36: LD_INT 4
  38: PUSH
  39: LD_INT 46
  41: PUSH
  42: LD_INT 15
  44: PUSH
  45: LD_INT 2
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: LIST
  53: PUSH
  54: LD_INT 31
  56: PUSH
  57: LD_INT 35
  59: PUSH
  60: LD_INT 21
  62: PUSH
  63: LD_INT 0
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: LIST
  70: LIST
  71: PUSH
  72: LD_INT 6
  74: PUSH
  75: LD_INT 30
  77: PUSH
  78: LD_INT 10
  80: PUSH
  81: LD_INT 2
  83: PUSH
  84: LD_INT 10
  86: PUSH
  87: LD_INT 11
  89: PUSH
  90: EMPTY
  91: LIST
  92: LIST
  93: LIST
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_INT 2
 100: PUSH
 101: LD_INT 24
 103: PUSH
 104: LD_INT 17
 106: PUSH
 107: LD_INT 4
 109: PUSH
 110: EMPTY
 111: LIST
 112: LIST
 113: LIST
 114: LIST
 115: PUSH
 116: LD_INT 27
 118: PUSH
 119: LD_INT 35
 121: PUSH
 122: LD_INT 5
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: LIST
 132: LIST
 133: PUSH
 134: LD_INT 27
 136: PUSH
 137: LD_INT 37
 139: PUSH
 140: LD_INT 5
 142: PUSH
 143: LD_INT 3
 145: PUSH
 146: EMPTY
 147: LIST
 148: LIST
 149: LIST
 150: LIST
 151: PUSH
 152: LD_INT 27
 154: PUSH
 155: LD_INT 39
 157: PUSH
 158: LD_INT 5
 160: PUSH
 161: LD_INT 3
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: LIST
 168: LIST
 169: PUSH
 170: EMPTY
 171: LIST
 172: LIST
 173: LIST
 174: LIST
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: ST_TO_ADDR
// end ;
 180: LD_VAR 0 1
 184: RET
// on BuildingComplete ( b ) do var side , type , depot , toUpgrade ;
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
// begin side := GetSide ( b ) ;
 191: LD_ADDR_VAR 0 2
 195: PUSH
 196: LD_VAR 0 1
 200: PPUSH
 201: CALL_OW 255
 205: ST_TO_ADDR
// type := GetBType ( b ) ;
 206: LD_ADDR_VAR 0 3
 210: PUSH
 211: LD_VAR 0 1
 215: PPUSH
 216: CALL_OW 266
 220: ST_TO_ADDR
// if side = 8 then
 221: LD_VAR 0 2
 225: PUSH
 226: LD_INT 8
 228: EQUAL
 229: IFFALSE 446
// begin ArBuildings := Delete ( ArBuildings , 1 ) ;
 231: LD_ADDR_EXP 1
 235: PUSH
 236: LD_EXP 1
 240: PPUSH
 241: LD_INT 1
 243: PPUSH
 244: CALL_OW 3
 248: ST_TO_ADDR
// depot := FilterUnitsInArea ( ArBaza , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_INT 2
 256: PPUSH
 257: LD_INT 2
 259: PUSH
 260: LD_INT 30
 262: PUSH
 263: LD_INT 0
 265: PUSH
 266: EMPTY
 267: LIST
 268: LIST
 269: PUSH
 270: LD_INT 30
 272: PUSH
 273: LD_INT 1
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: EMPTY
 281: LIST
 282: LIST
 283: LIST
 284: PPUSH
 285: CALL_OW 70
 289: ST_TO_ADDR
// if not depot then
 290: LD_VAR 0 4
 294: NOT
 295: IFFALSE 299
// exit ;
 297: GO 446
// depot := depot [ 1 ] ;
 299: LD_ADDR_VAR 0 4
 303: PUSH
 304: LD_VAR 0 4
 308: PUSH
 309: LD_INT 1
 311: ARRAY
 312: ST_TO_ADDR
// toUpgrade := 0 ;
 313: LD_ADDR_VAR 0 5
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// case type of b_depot :
 321: LD_VAR 0 3
 325: PUSH
 326: LD_INT 0
 328: DOUBLE
 329: EQUAL
 330: IFTRUE 334
 332: GO 345
 334: POP
// toUpgrade := b_warehouse ; b_armoury :
 335: LD_ADDR_VAR 0 5
 339: PUSH
 340: LD_INT 1
 342: ST_TO_ADDR
 343: GO 384
 345: LD_INT 4
 347: DOUBLE
 348: EQUAL
 349: IFTRUE 353
 351: GO 364
 353: POP
// toUpgrade := b_barracks ; b_workshop :
 354: LD_ADDR_VAR 0 5
 358: PUSH
 359: LD_INT 5
 361: ST_TO_ADDR
 362: GO 384
 364: LD_INT 2
 366: DOUBLE
 367: EQUAL
 368: IFTRUE 372
 370: GO 383
 372: POP
// toUpgrade := b_factory ; end ;
 373: LD_ADDR_VAR 0 5
 377: PUSH
 378: LD_INT 3
 380: ST_TO_ADDR
 381: GO 384
 383: POP
// if not toUpgrade then
 384: LD_VAR 0 5
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 446
// repeat wait ( 0 0$1 ) ;
 393: LD_INT 35
 395: PPUSH
 396: CALL_OW 67
// until CanBeBuiltOnlyResources ( depot , toUpgrade ) ;
 400: LD_VAR 0 4
 404: PPUSH
 405: LD_VAR 0 5
 409: PPUSH
 410: CALL 2555 0 2
 414: IFFALSE 393
// if type in [ b_depot , b_armoury , b_workshop ] then
 416: LD_VAR 0 3
 420: PUSH
 421: LD_INT 0
 423: PUSH
 424: LD_INT 4
 426: PUSH
 427: LD_INT 2
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: IN
 435: IFFALSE 446
// ComUpgrade ( b ) ;
 437: LD_VAR 0 1
 441: PPUSH
 442: CALL_OW 146
// end ; end ;
 446: PPOPN 5
 448: END
// on UnitDestroyed ( unit ) do if GetSide ( unit ) = 8 and IsInArea ( unit , ArBaza ) then
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 255
 458: PUSH
 459: LD_INT 8
 461: EQUAL
 462: PUSH
 463: LD_VAR 0 1
 467: PPUSH
 468: LD_INT 2
 470: PPUSH
 471: CALL_OW 308
 475: AND
 476: IFFALSE 630
// begin if GetBType ( unit ) in [ b_bunker , b_turret ] then
 478: LD_VAR 0 1
 482: PPUSH
 483: CALL_OW 266
 487: PUSH
 488: LD_INT 32
 490: PUSH
 491: LD_INT 33
 493: PUSH
 494: EMPTY
 495: LIST
 496: LIST
 497: IN
 498: IFFALSE 554
// ArBuildings := Join ( ArBuildings , [ b_turret , GetX ( unit ) , GetY ( unit ) , GetDir ( unit ) ] ) ;
 500: LD_ADDR_EXP 1
 504: PUSH
 505: LD_EXP 1
 509: PPUSH
 510: LD_INT 33
 512: PUSH
 513: LD_VAR 0 1
 517: PPUSH
 518: CALL_OW 250
 522: PUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 251
 532: PUSH
 533: LD_VAR 0 1
 537: PPUSH
 538: CALL_OW 254
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PPUSH
 549: CALL 1855 0 2
 553: ST_TO_ADDR
// if GetBType ( unit ) in [ b_armoury , b_barracks ] then
 554: LD_VAR 0 1
 558: PPUSH
 559: CALL_OW 266
 563: PUSH
 564: LD_INT 4
 566: PUSH
 567: LD_INT 5
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: IN
 574: IFFALSE 630
// ArBuildings := Join ( ArBuildings , [ b_armoury , GetX ( unit ) , GetY ( unit ) , GetDir ( unit ) ] ) ;
 576: LD_ADDR_EXP 1
 580: PUSH
 581: LD_EXP 1
 585: PPUSH
 586: LD_INT 4
 588: PUSH
 589: LD_VAR 0 1
 593: PPUSH
 594: CALL_OW 250
 598: PUSH
 599: LD_VAR 0 1
 603: PPUSH
 604: CALL_OW 251
 608: PUSH
 609: LD_VAR 0 1
 613: PPUSH
 614: CALL_OW 254
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PPUSH
 625: CALL 1855 0 2
 629: ST_TO_ADDR
// end ;
 630: PPOPN 1
 632: END
// every 0 0$5 do var i , tmp , depot , undone , lab , eng , tag , tw , cr , sci , sol , hurtUnits , enemyInBase , empty , fac , emptyTowers , weapon , D , LudzieEng ;
 633: GO 635
 635: DISABLE
 636: LD_INT 0
 638: PPUSH
 639: PPUSH
 640: PPUSH
 641: PPUSH
 642: PPUSH
 643: PPUSH
 644: PPUSH
 645: PPUSH
 646: PPUSH
 647: PPUSH
 648: PPUSH
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// begin enable ;
 657: ENABLE
// depot := FilterUnitsInArea ( ArBaza , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
 658: LD_ADDR_VAR 0 3
 662: PUSH
 663: LD_INT 2
 665: PPUSH
 666: LD_INT 2
 668: PUSH
 669: LD_INT 30
 671: PUSH
 672: LD_INT 0
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 30
 681: PUSH
 682: LD_INT 1
 684: PUSH
 685: EMPTY
 686: LIST
 687: LIST
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: PPUSH
 694: CALL_OW 70
 698: ST_TO_ADDR
// if depot then
 699: LD_VAR 0 3
 703: IFFALSE 719
// depot := depot [ 1 ] ;
 705: LD_ADDR_VAR 0 3
 709: PUSH
 710: LD_VAR 0 3
 714: PUSH
 715: LD_INT 1
 717: ARRAY
 718: ST_TO_ADDR
// LudzieEng := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) ;
 719: LD_ADDR_VAR 0 19
 723: PUSH
 724: LD_INT 22
 726: PUSH
 727: LD_INT 8
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 21
 736: PUSH
 737: LD_INT 1
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 25
 746: PUSH
 747: LD_INT 2
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: PPUSH
 759: CALL_OW 69
 763: ST_TO_ADDR
// tmp := FilterUnitsInArea ( ArBaza , [ [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
 764: LD_ADDR_VAR 0 2
 768: PUSH
 769: LD_INT 2
 771: PPUSH
 772: LD_INT 21
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: EMPTY
 779: LIST
 780: LIST
 781: PUSH
 782: LD_INT 3
 784: PUSH
 785: LD_INT 57
 787: PUSH
 788: EMPTY
 789: LIST
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 24
 800: PUSH
 801: LD_INT 1000
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: PUSH
 812: EMPTY
 813: LIST
 814: LIST
 815: LIST
 816: PPUSH
 817: CALL_OW 70
 821: ST_TO_ADDR
// cr := GetListOfCratesInArea ( Skrzynie ) ;
 822: LD_ADDR_VAR 0 9
 826: PUSH
 827: LD_INT 3
 829: PPUSH
 830: CALL_OW 435
 834: ST_TO_ADDR
// if LudzieEng then
 835: LD_VAR 0 19
 839: IFFALSE 1553
// begin for i in LudzieEng do
 841: LD_ADDR_VAR 0 1
 845: PUSH
 846: LD_VAR 0 19
 850: PUSH
 851: FOR_IN
 852: IFFALSE 1551
// begin tag := GetTag ( i ) ;
 854: LD_ADDR_VAR 0 7
 858: PUSH
 859: LD_VAR 0 1
 863: PPUSH
 864: CALL_OW 110
 868: ST_TO_ADDR
// if GetLives ( i ) < 800 then
 869: LD_VAR 0 1
 873: PPUSH
 874: CALL_OW 256
 878: PUSH
 879: LD_INT 800
 881: LESS
 882: IFFALSE 916
// begin ComMoveXY ( i , ArBaza [ 1 ] , ArBaza [ 2 ] ) ;
 884: LD_VAR 0 1
 888: PPUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PPUSH
 896: LD_INT 2
 898: PUSH
 899: LD_INT 2
 901: ARRAY
 902: PPUSH
 903: CALL_OW 111
// AddComHold ( i ) ;
 907: LD_VAR 0 1
 911: PPUSH
 912: CALL_OW 200
// end ; if not tag then
 916: LD_VAR 0 7
 920: NOT
 921: IFFALSE 1091
// begin undone := FilterUnitsInArea ( ArBaza , [ f_constructed ] ) ;
 923: LD_ADDR_VAR 0 4
 927: PUSH
 928: LD_INT 2
 930: PPUSH
 931: LD_INT 57
 933: PUSH
 934: EMPTY
 935: LIST
 936: PPUSH
 937: CALL_OW 70
 941: ST_TO_ADDR
// if undone then
 942: LD_VAR 0 4
 946: IFFALSE 968
// begin ComComplete ( i , undone [ 1 ] ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PUSH
 958: LD_INT 1
 960: ARRAY
 961: PPUSH
 962: CALL 1892 0 2
// continue ;
 966: GO 851
// end ; if cr or tmp or Count ( ArBuildings ) then
 968: LD_VAR 0 9
 972: PUSH
 973: LD_VAR 0 2
 977: OR
 978: PUSH
 979: LD_EXP 1
 983: PPUSH
 984: CALL 2533 0 1
 988: OR
 989: IFFALSE 1065
// begin if IsInUnit ( i ) then
 991: LD_VAR 0 1
 995: PPUSH
 996: CALL_OW 310
1000: IFFALSE 1011
// ComExitBuilding ( i ) ;
1002: LD_VAR 0 1
1006: PPUSH
1007: CALL_OW 122
// if tmp then
1011: LD_VAR 0 2
1015: IFFALSE 1031
// SetTag ( i , 200 ) else
1017: LD_VAR 0 1
1021: PPUSH
1022: LD_INT 200
1024: PPUSH
1025: CALL_OW 109
1029: GO 1063
// if cr then
1031: LD_VAR 0 9
1035: IFFALSE 1051
// SetTag ( i , 201 ) else
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_INT 201
1044: PPUSH
1045: CALL_OW 109
1049: GO 1063
// SetTag ( i , 202 ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_INT 202
1058: PPUSH
1059: CALL_OW 109
// end else
1063: GO 1091
// if not IsInUnit ( i ) then
1065: LD_VAR 0 1
1069: PPUSH
1070: CALL_OW 310
1074: NOT
1075: IFFALSE 1091
// ComEnterUnit ( i , D ) ;
1077: LD_VAR 0 1
1081: PPUSH
1082: LD_VAR 0 18
1086: PPUSH
1087: CALL_OW 120
// end ; if tag = 200 then
1091: LD_VAR 0 7
1095: PUSH
1096: LD_INT 200
1098: EQUAL
1099: IFFALSE 1201
// begin if IsInUnit ( i ) then
1101: LD_VAR 0 1
1105: PPUSH
1106: CALL_OW 310
1110: IFFALSE 1123
// begin ComExitBuilding ( i ) ;
1112: LD_VAR 0 1
1116: PPUSH
1117: CALL_OW 122
// continue ;
1121: GO 851
// end ; if not tmp then
1123: LD_VAR 0 2
1127: NOT
1128: IFFALSE 1144
// begin SetTag ( i , 0 ) ;
1130: LD_VAR 0 1
1134: PPUSH
1135: LD_INT 0
1137: PPUSH
1138: CALL_OW 109
// continue ;
1142: GO 851
// end ; if not HasTask ( i ) then
1144: LD_VAR 0 1
1148: PPUSH
1149: CALL_OW 314
1153: NOT
1154: IFFALSE 1174
// ComRepairBuilding ( i , tmp [ 1 ] ) ;
1156: LD_VAR 0 1
1160: PPUSH
1161: LD_VAR 0 2
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: PPUSH
1170: CALL_OW 130
// if not IsInArea ( i , ArBaza ) then
1174: LD_VAR 0 1
1178: PPUSH
1179: LD_INT 2
1181: PPUSH
1182: CALL_OW 308
1186: NOT
1187: IFFALSE 1201
// ComMoveToArea ( i , ArBaza ) ;
1189: LD_VAR 0 1
1193: PPUSH
1194: LD_INT 2
1196: PPUSH
1197: CALL_OW 113
// end ; if tag = 202 then
1201: LD_VAR 0 7
1205: PUSH
1206: LD_INT 202
1208: EQUAL
1209: IFFALSE 1406
// begin if IsInUnit ( i ) then
1211: LD_VAR 0 1
1215: PPUSH
1216: CALL_OW 310
1220: IFFALSE 1233
// begin ComExitBuilding ( i ) ;
1222: LD_VAR 0 1
1226: PPUSH
1227: CALL_OW 122
// continue ;
1231: GO 851
// end ; if not Count ( ArBuildings ) then
1233: LD_EXP 1
1237: PPUSH
1238: CALL 2533 0 1
1242: NOT
1243: IFFALSE 1261
// begin SetTag ( i , 0 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: LD_INT 0
1252: PPUSH
1253: CALL_OW 109
// continue ;
1257: GO 851
// end else
1259: GO 1300
// if not CanBeBuiltOnlyResources ( depot , ArBuildings [ 1 ] [ 1 ] ) then
1261: LD_VAR 0 3
1265: PPUSH
1266: LD_EXP 1
1270: PUSH
1271: LD_INT 1
1273: ARRAY
1274: PUSH
1275: LD_INT 1
1277: ARRAY
1278: PPUSH
1279: CALL 2555 0 2
1283: NOT
1284: IFFALSE 1300
// begin SetTag ( i , 0 ) ;
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 0
1293: PPUSH
1294: CALL_OW 109
// continue ;
1298: GO 851
// end ; undone := FilterUnitsInArea ( ArBaza , [ f_constructed ] ) ;
1300: LD_ADDR_VAR 0 4
1304: PUSH
1305: LD_INT 2
1307: PPUSH
1308: LD_INT 57
1310: PUSH
1311: EMPTY
1312: LIST
1313: PPUSH
1314: CALL_OW 70
1318: ST_TO_ADDR
// if undone then
1319: LD_VAR 0 4
1323: IFFALSE 1345
// begin ComComplete ( i , undone [ 1 ] ) ;
1325: LD_VAR 0 1
1329: PPUSH
1330: LD_VAR 0 4
1334: PUSH
1335: LD_INT 1
1337: ARRAY
1338: PPUSH
1339: CALL 1892 0 2
// continue ;
1343: GO 851
// end ; ComBuild ( i , ArBuildings [ 1 ] [ 1 ] , ArBuildings [ 1 ] [ 2 ] , ArBuildings [ 1 ] [ 3 ] , ArBuildings [ 1 ] [ 4 ] ) ;
1345: LD_VAR 0 1
1349: PPUSH
1350: LD_EXP 1
1354: PUSH
1355: LD_INT 1
1357: ARRAY
1358: PUSH
1359: LD_INT 1
1361: ARRAY
1362: PPUSH
1363: LD_EXP 1
1367: PUSH
1368: LD_INT 1
1370: ARRAY
1371: PUSH
1372: LD_INT 2
1374: ARRAY
1375: PPUSH
1376: LD_EXP 1
1380: PUSH
1381: LD_INT 1
1383: ARRAY
1384: PUSH
1385: LD_INT 3
1387: ARRAY
1388: PPUSH
1389: LD_EXP 1
1393: PUSH
1394: LD_INT 1
1396: ARRAY
1397: PUSH
1398: LD_INT 4
1400: ARRAY
1401: PPUSH
1402: CALL_OW 145
// end ; if tag = 201 then
1406: LD_VAR 0 7
1410: PUSH
1411: LD_INT 201
1413: EQUAL
1414: IFFALSE 1549
// begin if IsInUnit ( i ) then
1416: LD_VAR 0 1
1420: PPUSH
1421: CALL_OW 310
1425: IFFALSE 1438
// begin ComExitBuilding ( i ) ;
1427: LD_VAR 0 1
1431: PPUSH
1432: CALL_OW 122
// continue ;
1436: GO 851
// end ; if not cr then
1438: LD_VAR 0 9
1442: NOT
1443: IFFALSE 1459
// begin SetTag ( i , 0 ) ;
1445: LD_VAR 0 1
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 109
// continue ;
1457: GO 851
// end ; if not HasTask ( i ) and not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_distxy , cr [ 1 ] , cr [ 2 ] , 12 ] ] ) then
1459: LD_VAR 0 1
1463: PPUSH
1464: CALL_OW 314
1468: NOT
1469: PUSH
1470: LD_INT 81
1472: PUSH
1473: LD_INT 8
1475: PUSH
1476: EMPTY
1477: LIST
1478: LIST
1479: PUSH
1480: LD_INT 92
1482: PUSH
1483: LD_VAR 0 9
1487: PUSH
1488: LD_INT 1
1490: ARRAY
1491: PUSH
1492: LD_VAR 0 9
1496: PUSH
1497: LD_INT 2
1499: ARRAY
1500: PUSH
1501: LD_INT 12
1503: PUSH
1504: EMPTY
1505: LIST
1506: LIST
1507: LIST
1508: LIST
1509: PUSH
1510: EMPTY
1511: LIST
1512: LIST
1513: PPUSH
1514: CALL_OW 69
1518: NOT
1519: AND
1520: IFFALSE 1549
// ComCollect ( i , cr [ 1 ] , cr [ 2 ] ) ;
1522: LD_VAR 0 1
1526: PPUSH
1527: LD_VAR 0 9
1531: PUSH
1532: LD_INT 1
1534: ARRAY
1535: PPUSH
1536: LD_VAR 0 9
1540: PUSH
1541: LD_INT 2
1543: ARRAY
1544: PPUSH
1545: CALL_OW 117
// end ; end ;
1549: GO 851
1551: POP
1552: POP
// end ; end ; end_of_file
1553: PPOPN 19
1555: END
// every 0 0$45 do var i , tmp , blist , class ;
1556: GO 1558
1558: DISABLE
1559: LD_INT 0
1561: PPUSH
1562: PPUSH
1563: PPUSH
1564: PPUSH
// begin enable ;
1565: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_inside ] ] ) ;
1566: LD_ADDR_VAR 0 2
1570: PUSH
1571: LD_INT 22
1573: PUSH
1574: LD_INT 8
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: PUSH
1581: LD_INT 21
1583: PUSH
1584: LD_INT 1
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: PUSH
1591: LD_INT 54
1593: PUSH
1594: EMPTY
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: PPUSH
1602: CALL_OW 69
1606: ST_TO_ADDR
// if not tmp then
1607: LD_VAR 0 2
1611: NOT
1612: IFFALSE 1616
// exit ;
1614: GO 1793
// blist := [ [ b_barracks , b_armoury , b_bunker , b_breastwork ] , [ b_depot , b_warehouse ] , [ b_workshop , b_factory ] , [ b_lab , b_lab_half , b_lab_full ] ] ;
1616: LD_ADDR_VAR 0 3
1620: PUSH
1621: LD_INT 5
1623: PUSH
1624: LD_INT 4
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: PUSH
1639: LD_INT 0
1641: PUSH
1642: LD_INT 1
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PUSH
1649: LD_INT 2
1651: PUSH
1652: LD_INT 3
1654: PUSH
1655: EMPTY
1656: LIST
1657: LIST
1658: PUSH
1659: LD_INT 6
1661: PUSH
1662: LD_INT 7
1664: PUSH
1665: LD_INT 8
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: ST_TO_ADDR
// for i in tmp do
1679: LD_ADDR_VAR 0 1
1683: PUSH
1684: LD_VAR 0 2
1688: PUSH
1689: FOR_IN
1690: IFFALSE 1791
// begin class := GetClass ( i ) ;
1692: LD_ADDR_VAR 0 4
1696: PUSH
1697: LD_VAR 0 1
1701: PPUSH
1702: CALL_OW 257
1706: ST_TO_ADDR
// if class > 4 then
1707: LD_VAR 0 4
1711: PUSH
1712: LD_INT 4
1714: GREATER
1715: IFFALSE 1725
// class := 1 ;
1717: LD_ADDR_VAR 0 4
1721: PUSH
1722: LD_INT 1
1724: ST_TO_ADDR
// if GetBType ( IsInUnit ( i ) ) in blist [ class ] then
1725: LD_VAR 0 1
1729: PPUSH
1730: CALL_OW 310
1734: PPUSH
1735: CALL_OW 266
1739: PUSH
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 4
1749: ARRAY
1750: IN
1751: IFFALSE 1772
// AddExperience ( i , class , 100 ) else
1753: LD_VAR 0 1
1757: PPUSH
1758: LD_VAR 0 4
1762: PPUSH
1763: LD_INT 100
1765: PPUSH
1766: CALL_OW 492
1770: GO 1789
// AddExperience ( i , class , 50 ) end ;
1772: LD_VAR 0 1
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: LD_INT 50
1784: PPUSH
1785: CALL_OW 492
1789: GO 1689
1791: POP
1792: POP
// end ;
1793: PPOPN 4
1795: END
// every 1 1$06 trigger FilterUnitsInArea ( Skrzynie , [ [ f_placed ] , [ f_type , unit_crate ] ] ) < 5 do
1796: LD_INT 3
1798: PPUSH
1799: LD_INT 52
1801: PUSH
1802: EMPTY
1803: LIST
1804: PUSH
1805: LD_INT 21
1807: PUSH
1808: LD_INT 4
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: PPUSH
1819: CALL_OW 70
1823: PUSH
1824: LD_INT 5
1826: LESS
1827: IFFALSE 1854
1829: GO 1831
1831: DISABLE
// begin enable ;
1832: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , Skrzynie , true ) ;
1833: LD_INT 1
1835: PPUSH
1836: LD_INT 5
1838: PPUSH
1839: CALL_OW 12
1843: PPUSH
1844: LD_INT 3
1846: PPUSH
1847: LD_INT 1
1849: PPUSH
1850: CALL_OW 55
// end ; end_of_file end_of_file
1854: END
// export function Join ( array , element ) ; begin
1855: LD_INT 0
1857: PPUSH
// result := Replace ( array , array + 1 , element ) ;
1858: LD_ADDR_VAR 0 3
1862: PUSH
1863: LD_VAR 0 1
1867: PPUSH
1868: LD_VAR 0 1
1872: PUSH
1873: LD_INT 1
1875: PLUS
1876: PPUSH
1877: LD_VAR 0 2
1881: PPUSH
1882: CALL_OW 1
1886: ST_TO_ADDR
// end ;
1887: LD_VAR 0 3
1891: RET
// export function ComComplete ( units , b ) ; var i ; begin
1892: LD_INT 0
1894: PPUSH
1895: PPUSH
// if not units then
1896: LD_VAR 0 1
1900: NOT
1901: IFFALSE 1905
// exit ;
1903: GO 1995
// for i in units do
1905: LD_ADDR_VAR 0 4
1909: PUSH
1910: LD_VAR 0 1
1914: PUSH
1915: FOR_IN
1916: IFFALSE 1993
// if BuildingStatus ( b ) = bs_build then
1918: LD_VAR 0 2
1922: PPUSH
1923: CALL_OW 461
1927: PUSH
1928: LD_INT 1
1930: EQUAL
1931: IFFALSE 1991
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_STRING h
1940: PUSH
1941: LD_VAR 0 2
1945: PPUSH
1946: CALL_OW 250
1950: PUSH
1951: LD_VAR 0 2
1955: PPUSH
1956: CALL_OW 251
1960: PUSH
1961: LD_VAR 0 2
1965: PUSH
1966: LD_INT 0
1968: PUSH
1969: LD_INT 0
1971: PUSH
1972: LD_INT 0
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: PUSH
1984: EMPTY
1985: LIST
1986: PPUSH
1987: CALL_OW 446
1991: GO 1915
1993: POP
1994: POP
// end ;
1995: LD_VAR 0 3
1999: RET
// export function DangerInArea ( side , area ) ; begin
2000: LD_INT 0
2002: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
2003: LD_ADDR_VAR 0 3
2007: PUSH
2008: LD_VAR 0 2
2012: PPUSH
2013: LD_INT 81
2015: PUSH
2016: LD_VAR 0 1
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: PPUSH
2025: CALL_OW 70
2029: ST_TO_ADDR
// end ;
2030: LD_VAR 0 3
2034: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
2035: LD_INT 0
2037: PPUSH
2038: PPUSH
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
2043: LD_VAR 0 1
2047: NOT
2048: PUSH
2049: LD_VAR 0 1
2053: PPUSH
2054: CALL_OW 263
2058: PUSH
2059: LD_INT 2
2061: NONEQUAL
2062: OR
2063: IFFALSE 2067
// exit ;
2065: GO 2383
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_INT 22
2074: PUSH
2075: LD_VAR 0 1
2079: PPUSH
2080: CALL_OW 255
2084: PUSH
2085: EMPTY
2086: LIST
2087: LIST
2088: PUSH
2089: LD_INT 2
2091: PUSH
2092: LD_INT 30
2094: PUSH
2095: LD_INT 36
2097: PUSH
2098: EMPTY
2099: LIST
2100: LIST
2101: PUSH
2102: LD_INT 34
2104: PUSH
2105: LD_INT 31
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: PUSH
2112: EMPTY
2113: LIST
2114: LIST
2115: LIST
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PPUSH
2121: CALL_OW 69
2125: ST_TO_ADDR
// if not tmp then
2126: LD_VAR 0 6
2130: NOT
2131: IFFALSE 2135
// exit ;
2133: GO 2383
// result := [ ] ;
2135: LD_ADDR_VAR 0 2
2139: PUSH
2140: EMPTY
2141: ST_TO_ADDR
// for i in tmp do
2142: LD_ADDR_VAR 0 3
2146: PUSH
2147: LD_VAR 0 6
2151: PUSH
2152: FOR_IN
2153: IFFALSE 2224
// begin t := UnitsInside ( i ) ;
2155: LD_ADDR_VAR 0 4
2159: PUSH
2160: LD_VAR 0 3
2164: PPUSH
2165: CALL_OW 313
2169: ST_TO_ADDR
// if t then
2170: LD_VAR 0 4
2174: IFFALSE 2222
// for j in t do
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: LD_VAR 0 4
2185: PUSH
2186: FOR_IN
2187: IFFALSE 2220
// result := Replace ( result , result + 1 , j ) ;
2189: LD_ADDR_VAR 0 2
2193: PUSH
2194: LD_VAR 0 2
2198: PPUSH
2199: LD_VAR 0 2
2203: PUSH
2204: LD_INT 1
2206: PLUS
2207: PPUSH
2208: LD_VAR 0 7
2212: PPUSH
2213: CALL_OW 1
2217: ST_TO_ADDR
2218: GO 2186
2220: POP
2221: POP
// end ;
2222: GO 2152
2224: POP
2225: POP
// if not result then
2226: LD_VAR 0 2
2230: NOT
2231: IFFALSE 2235
// exit ;
2233: GO 2383
// mech := result [ 1 ] ;
2235: LD_ADDR_VAR 0 5
2239: PUSH
2240: LD_VAR 0 2
2244: PUSH
2245: LD_INT 1
2247: ARRAY
2248: ST_TO_ADDR
// if result > 1 then
2249: LD_VAR 0 2
2253: PUSH
2254: LD_INT 1
2256: GREATER
2257: IFFALSE 2369
// begin for i = 2 to result do
2259: LD_ADDR_VAR 0 3
2263: PUSH
2264: DOUBLE
2265: LD_INT 2
2267: DEC
2268: ST_TO_ADDR
2269: LD_VAR 0 2
2273: PUSH
2274: FOR_TO
2275: IFFALSE 2367
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2277: LD_ADDR_VAR 0 4
2281: PUSH
2282: LD_VAR 0 2
2286: PUSH
2287: LD_VAR 0 3
2291: ARRAY
2292: PPUSH
2293: LD_INT 3
2295: PPUSH
2296: CALL_OW 259
2300: PUSH
2301: LD_VAR 0 2
2305: PUSH
2306: LD_VAR 0 3
2310: ARRAY
2311: PPUSH
2312: CALL_OW 432
2316: MINUS
2317: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2318: LD_VAR 0 4
2322: PUSH
2323: LD_VAR 0 5
2327: PPUSH
2328: LD_INT 3
2330: PPUSH
2331: CALL_OW 259
2335: PUSH
2336: LD_VAR 0 5
2340: PPUSH
2341: CALL_OW 432
2345: MINUS
2346: GREATEREQUAL
2347: IFFALSE 2365
// mech := result [ i ] ;
2349: LD_ADDR_VAR 0 5
2353: PUSH
2354: LD_VAR 0 2
2358: PUSH
2359: LD_VAR 0 3
2363: ARRAY
2364: ST_TO_ADDR
// end ;
2365: GO 2274
2367: POP
2368: POP
// end ; ComLinkTo ( vehicle , mech ) ;
2369: LD_VAR 0 1
2373: PPUSH
2374: LD_VAR 0 5
2378: PPUSH
2379: CALL_OW 135
// end ;
2383: LD_VAR 0 2
2387: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
2388: LD_INT 0
2390: PPUSH
2391: PPUSH
2392: PPUSH
// if not side or not area then
2393: LD_VAR 0 1
2397: NOT
2398: PUSH
2399: LD_VAR 0 2
2403: NOT
2404: OR
2405: IFFALSE 2409
// exit ;
2407: GO 2528
// tmp := AreaToList ( area , 0 ) ;
2409: LD_ADDR_VAR 0 5
2413: PUSH
2414: LD_VAR 0 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 517
2426: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
2427: LD_ADDR_VAR 0 4
2431: PUSH
2432: DOUBLE
2433: LD_INT 1
2435: DEC
2436: ST_TO_ADDR
2437: LD_VAR 0 5
2441: PUSH
2442: LD_INT 1
2444: ARRAY
2445: PUSH
2446: FOR_TO
2447: IFFALSE 2526
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
2449: LD_VAR 0 5
2453: PUSH
2454: LD_INT 1
2456: ARRAY
2457: PUSH
2458: LD_VAR 0 4
2462: ARRAY
2463: PPUSH
2464: LD_VAR 0 5
2468: PUSH
2469: LD_INT 2
2471: ARRAY
2472: PUSH
2473: LD_VAR 0 4
2477: ARRAY
2478: PPUSH
2479: CALL_OW 351
2483: IFFALSE 2524
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
2485: LD_VAR 0 5
2489: PUSH
2490: LD_INT 1
2492: ARRAY
2493: PUSH
2494: LD_VAR 0 4
2498: ARRAY
2499: PPUSH
2500: LD_VAR 0 5
2504: PUSH
2505: LD_INT 2
2507: ARRAY
2508: PUSH
2509: LD_VAR 0 4
2513: ARRAY
2514: PPUSH
2515: LD_VAR 0 1
2519: PPUSH
2520: CALL_OW 244
// end ;
2524: GO 2446
2526: POP
2527: POP
// end ;
2528: LD_VAR 0 3
2532: RET
// export function Count ( array ) ; begin
2533: LD_INT 0
2535: PPUSH
// result := array + 0 ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 1
2545: PUSH
2546: LD_INT 0
2548: PLUS
2549: ST_TO_ADDR
// end ;
2550: LD_VAR 0 2
2554: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
2555: LD_INT 0
2557: PPUSH
2558: PPUSH
2559: PPUSH
// if btype = b_depot then
2560: LD_VAR 0 2
2564: PUSH
2565: LD_INT 0
2567: EQUAL
2568: IFFALSE 2580
// begin result := true ;
2570: LD_ADDR_VAR 0 3
2574: PUSH
2575: LD_INT 1
2577: ST_TO_ADDR
// exit ;
2578: GO 2696
// end ; pom := GetBase ( depot ) ;
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: LD_VAR 0 1
2589: PPUSH
2590: CALL_OW 274
2594: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
2595: LD_ADDR_VAR 0 5
2599: PUSH
2600: LD_VAR 0 2
2604: PPUSH
2605: LD_VAR 0 1
2609: PPUSH
2610: CALL_OW 248
2614: PPUSH
2615: CALL_OW 450
2619: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
2620: LD_ADDR_VAR 0 3
2624: PUSH
2625: LD_VAR 0 4
2629: PPUSH
2630: LD_INT 1
2632: PPUSH
2633: CALL_OW 275
2637: PUSH
2638: LD_VAR 0 5
2642: PUSH
2643: LD_INT 1
2645: ARRAY
2646: GREATEREQUAL
2647: PUSH
2648: LD_VAR 0 4
2652: PPUSH
2653: LD_INT 2
2655: PPUSH
2656: CALL_OW 275
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_INT 2
2668: ARRAY
2669: GREATEREQUAL
2670: AND
2671: PUSH
2672: LD_VAR 0 4
2676: PPUSH
2677: LD_INT 3
2679: PPUSH
2680: CALL_OW 275
2684: PUSH
2685: LD_VAR 0 5
2689: PUSH
2690: LD_INT 3
2692: ARRAY
2693: GREATEREQUAL
2694: AND
2695: ST_TO_ADDR
// end ;
2696: LD_VAR 0 3
2700: RET
