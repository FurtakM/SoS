// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: NOP4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: NOP4
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: NOP4
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: NOP4
10651: PUSH
10652: NOP4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: NOP4
10664: PPUSH
10665: NOP4
10669: PPUSH
10670: NOP4
10674: PUSH
10675: NOP4
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: NOP4
10686: PUSH
10687: NOP4
10691: PUSH
10692: NOP4
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: NOP4
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: NOP4
10724: PUSH
10725: NOP4
10729: PPUSH
10730: NOP4
10734: ST_TO_ADDR
// if not tmp then
10735: NOP4
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: NOP4
10748: PUSH
10749: NOP4
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: NOP4
10761: PPUSH
10762: NOP4
10766: PPUSH
10767: NOP4
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: NOP4
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: NOP4
10817: NOT
10818: PUSH
10819: NOP4
10823: PPUSH
10824: NOP4
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: NOP4
10841: PUSH
10842: NOP4
10846: PPUSH
10847: NOP4
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: NOP4
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: NOP4
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: NOP4
10872: PUSH
10873: NOP4
10877: PPUSH
10878: NOP4
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: NOP4
10887: PPUSH
10888: NOP4
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: NOP4
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: NOP4
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: NOP4
10942: ST_TO_ADDR
// if not tmp then
10943: NOP4
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: NOP4
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: NOP4
10962: PUSH
10963: NOP4
10967: PPUSH
10968: NOP4
10972: PPUSH
10973: NOP4
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: NOP4
10984: PUSH
10985: NOP4
10989: PPUSH
10990: NOP4
10994: PPUSH
10995: NOP4
10999: ST_TO_ADDR
// if not enemy then
11000: NOP4
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: NOP4
11013: PUSH
11014: NOP4
11018: PPUSH
11019: NOP4
11023: PPUSH
11024: NOP4
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: NOP4
11038: PPUSH
11039: NOP4
11043: PPUSH
11044: NOP4
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: NOP4
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: NOP4
11072: PPUSH
11073: NOP4
11077: PPUSH
11078: NOP4
11082: IFFALSE 11111
// missile := Replace ( missile , missile + 1 , 2 ) ;
11084: NOP4
11088: PUSH
11089: NOP4
11093: PPUSH
11094: NOP4
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: NOP4
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: NOP4
11115: PPUSH
11116: NOP4
11120: PPUSH
11121: NOP4
11125: PUSH
11126: NOP4
11130: PPUSH
11131: NOP4
11135: PPUSH
11136: NOP4
11140: PPUSH
11141: NOP4
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Replace ( missile , missile + 1 , 3 ) ;
11149: NOP4
11153: PUSH
11154: NOP4
11158: PPUSH
11159: NOP4
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: NOP4
11175: ST_TO_ADDR
// if missile < 2 then
11176: NOP4
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: NOP4
11192: PUSH
11193: NOP4
11197: PPUSH
11198: NOP4
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: NOP4
11207: PUSH
11208: NOP4
11212: PPUSH
11213: NOP4
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: NOP4
11222: PUSH
11223: NOP4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: NOP4
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: NOP4
11245: PUSH
11246: NOP4
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: NOP4
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: NOP4
11268: PPUSH
11269: NOP4
11273: PPUSH
11274: NOP4
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: NOP4
11285: PUSH
11286: NOP4
11290: ST_TO_ADDR
// _y := y ;
11291: NOP4
11295: PUSH
11296: NOP4
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: NOP4
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: NOP4
11313: PPUSH
11314: NOP4
11318: ST_TO_ADDR
// case i of 1 :
11319: NOP4
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: NOP4
11337: PPUSH
11338: NOP4
11342: PPUSH
11343: NOP4
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: NOP4
11362: PPUSH
11363: NOP4
11367: PPUSH
11368: NOP4
11372: PPUSH
11373: NOP4
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: NOP4
11392: PPUSH
11393: NOP4
11397: PPUSH
11398: NOP4
11402: PPUSH
11403: NOP4
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: NOP4
11427: NOT
11428: PUSH
11429: NOP4
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: NOP4
11443: PUSH
11444: NOP4
11448: PPUSH
11449: NOP4
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: NOP4
11458: PUSH
11459: NOP4
11463: PPUSH
11464: NOP4
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: NOP4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: NOP4
11489: PUSH
11490: NOP4
11494: PPUSH
11495: NOP4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: NOP4
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: NOP4
11512: PUSH
11513: NOP4
11517: PPUSH
11518: NOP4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: NOP4
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: NOP4
11535: PPUSH
11536: NOP4
11540: PPUSH
11541: NOP4
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: NOP4
11554: PPUSH
11555: NOP4
11559: PPUSH
11560: NOP4
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: NOP4
11574: PPUSH
11575: NOP4
11579: PPUSH
11580: NOP4
11584: PPUSH
11585: NOP4
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: NOP4
11609: PUSH
11610: NOP4
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: NOP4
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: NOP4
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: NOP4
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: NOP4
11655: PUSH
11656: NOP4
11660: PPUSH
11661: NOP4
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: NOP4
11670: PUSH
11671: NOP4
11675: PPUSH
11676: NOP4
11680: ST_TO_ADDR
// case nat of 1 :
11681: NOP4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: NOP4
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: NOP4
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: NOP4
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: NOP4
11748: PPUSH
11749: NOP4
11753: PPUSH
11754: NOP4
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: NOP4
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: NOP4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: NOP4
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: NOP4
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: NOP4
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: NOP4
11846: ST_TO_ADDR
// for i in mines do
11847: NOP4
11851: PUSH
11852: NOP4
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: NOP4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: NOP4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: NOP4
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: NOP4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: NOP4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: NOP4
11909: PUSH
11910: NOP4
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: NOP4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: NOP4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: NOP4
11939: PPUSH
11940: NOP4
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: NOP4
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: NOP4
11969: PUSH
11970: NOP4
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: NOP4
11982: IFFALSE 11998
// result := result + 1 ;
11984: NOP4
11988: PUSH
11989: NOP4
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: NOP4
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: NOP4
12023: PUSH
12024: NOP4
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: NOP4
12036: PPUSH
12037: NOP4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: NOP4
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; var places ; begin
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// if not building then
12071: NOP4
12075: NOT
12076: IFFALSE 12080
// exit ;
12078: GO 12251
// result := false ;
12080: NOP4
12084: PUSH
12085: LD_INT 0
12087: ST_TO_ADDR
// places := 0 ;
12088: NOP4
12092: PUSH
12093: LD_INT 0
12095: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12096: NOP4
12100: PPUSH
12101: NOP4
12105: PUSH
12106: LD_INT 0
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12168
12112: LD_INT 1
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12168
12118: LD_INT 6
12120: DOUBLE
12121: EQUAL
12122: IFTRUE 12168
12124: LD_INT 7
12126: DOUBLE
12127: EQUAL
12128: IFTRUE 12168
12130: LD_INT 8
12132: DOUBLE
12133: EQUAL
12134: IFTRUE 12168
12136: LD_INT 4
12138: DOUBLE
12139: EQUAL
12140: IFTRUE 12168
12142: LD_INT 5
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12168
12148: LD_INT 2
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12168
12154: LD_INT 3
12156: DOUBLE
12157: EQUAL
12158: IFTRUE 12168
12160: LD_INT 35
12162: DOUBLE
12163: EQUAL
12164: IFTRUE 12168
12166: GO 12179
12168: POP
// places := 6 ; b_bunker , b_breastwork :
12169: NOP4
12173: PUSH
12174: LD_INT 6
12176: ST_TO_ADDR
12177: GO 12224
12179: LD_INT 32
12181: DOUBLE
12182: EQUAL
12183: IFTRUE 12193
12185: LD_INT 31
12187: DOUBLE
12188: EQUAL
12189: IFTRUE 12193
12191: GO 12204
12193: POP
// places := 1 ; b_control_tower :
12194: NOP4
12198: PUSH
12199: LD_INT 1
12201: ST_TO_ADDR
12202: GO 12224
12204: LD_INT 36
12206: DOUBLE
12207: EQUAL
12208: IFTRUE 12212
12210: GO 12223
12212: POP
// places := 3 ; end ;
12213: NOP4
12217: PUSH
12218: LD_INT 3
12220: ST_TO_ADDR
12221: GO 12224
12223: POP
// if places then
12224: NOP4
12228: IFFALSE 12251
// result := UnitsInside ( building ) < places ;
12230: NOP4
12234: PUSH
12235: NOP4
12239: PPUSH
12240: NOP4
12244: PUSH
12245: NOP4
12249: LESS
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 2
12255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
12261: PPUSH
// tmp := [ ] ;
12262: NOP4
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// list := [ ] ;
12269: NOP4
12273: PUSH
12274: EMPTY
12275: ST_TO_ADDR
// for i = 16 to 25 do
12276: NOP4
12280: PUSH
12281: DOUBLE
12282: LD_INT 16
12284: DEC
12285: ST_TO_ADDR
12286: LD_INT 25
12288: PUSH
12289: FOR_TO
12290: IFFALSE 12363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12292: NOP4
12296: PUSH
12297: NOP4
12301: PUSH
12302: LD_INT 22
12304: PUSH
12305: NOP4
12309: PPUSH
12310: NOP4
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 91
12321: PUSH
12322: NOP4
12326: PUSH
12327: LD_INT 6
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 30
12337: PUSH
12338: NOP4
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: LIST
12351: PUSH
12352: EMPTY
12353: LIST
12354: PPUSH
12355: NOP4
12359: ADD
12360: ST_TO_ADDR
12361: GO 12289
12363: POP
12364: POP
// for i = 1 to tmp do
12365: NOP4
12369: PUSH
12370: DOUBLE
12371: LD_INT 1
12373: DEC
12374: ST_TO_ADDR
12375: NOP4
12379: PUSH
12380: FOR_TO
12381: IFFALSE 12469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12383: NOP4
12387: PUSH
12388: NOP4
12392: PUSH
12393: NOP4
12397: PUSH
12398: NOP4
12402: ARRAY
12403: PPUSH
12404: NOP4
12408: PUSH
12409: NOP4
12413: PUSH
12414: NOP4
12418: ARRAY
12419: PPUSH
12420: NOP4
12424: PUSH
12425: NOP4
12429: PUSH
12430: NOP4
12434: ARRAY
12435: PPUSH
12436: NOP4
12440: PUSH
12441: NOP4
12445: PUSH
12446: NOP4
12450: ARRAY
12451: PPUSH
12452: NOP4
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: PUSH
12463: EMPTY
12464: LIST
12465: ADD
12466: ST_TO_ADDR
12467: GO 12380
12469: POP
12470: POP
// result := list ;
12471: NOP4
12475: PUSH
12476: NOP4
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 2
12485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
12491: PPUSH
12492: PPUSH
12493: PPUSH
12494: PPUSH
// if not factory then
12495: NOP4
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 13097
// if control = control_apeman then
12504: NOP4
12508: PUSH
12509: LD_INT 5
12511: EQUAL
12512: IFFALSE 12621
// begin tmp := UnitsInside ( factory ) ;
12514: NOP4
12518: PUSH
12519: NOP4
12523: PPUSH
12524: NOP4
12528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12529: NOP4
12533: PPUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 12
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PPUSH
12544: NOP4
12548: NOT
12549: IFFALSE 12559
// control := control_manual ;
12551: NOP4
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12559: NOP4
12563: PUSH
12564: NOP4
12568: PPUSH
12569: NOP4
12573: ST_TO_ADDR
// if tmp then
12574: NOP4
12578: IFFALSE 12621
// begin for i in tmp do
12580: NOP4
12584: PUSH
12585: NOP4
12589: PUSH
12590: FOR_IN
12591: IFFALSE 12619
// if i [ 1 ] = b_ext_radio then
12593: NOP4
12597: PUSH
12598: LD_INT 1
12600: ARRAY
12601: PUSH
12602: LD_INT 22
12604: EQUAL
12605: IFFALSE 12617
// begin control := control_remote ;
12607: NOP4
12611: PUSH
12612: LD_INT 2
12614: ST_TO_ADDR
// break ;
12615: GO 12619
// end ;
12617: GO 12590
12619: POP
12620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12621: NOP4
12625: PPUSH
12626: NOP4
12630: PPUSH
12631: NOP4
12635: PPUSH
12636: NOP4
12640: PPUSH
12641: NOP4
12645: PPUSH
12646: NOP4
12650: IFFALSE 12685
// begin result := [ chassis , engine , control , weapon ] ;
12652: NOP4
12656: PUSH
12657: NOP4
12661: PUSH
12662: NOP4
12666: PUSH
12667: NOP4
12671: PUSH
12672: NOP4
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: ST_TO_ADDR
// exit ;
12683: GO 13097
// end ; _chassis := AvailableChassisList ( factory ) ;
12685: NOP4
12689: PUSH
12690: NOP4
12694: PPUSH
12695: NOP4
12699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12700: NOP4
12704: PUSH
12705: NOP4
12709: PPUSH
12710: NOP4
12714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12715: NOP4
12719: PUSH
12720: NOP4
12724: PPUSH
12725: NOP4
12729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12730: NOP4
12734: PUSH
12735: NOP4
12739: PPUSH
12740: NOP4
12744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12745: NOP4
12749: NOT
12750: PUSH
12751: NOP4
12755: NOT
12756: OR
12757: PUSH
12758: NOP4
12762: NOT
12763: OR
12764: PUSH
12765: NOP4
12769: NOT
12770: OR
12771: IFFALSE 12806
// begin result := [ chassis , engine , control , weapon ] ;
12773: NOP4
12777: PUSH
12778: NOP4
12782: PUSH
12783: NOP4
12787: PUSH
12788: NOP4
12792: PUSH
12793: NOP4
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// exit ;
12804: GO 13097
// end ; if not chassis in _chassis then
12806: NOP4
12810: PUSH
12811: NOP4
12815: IN
12816: NOT
12817: IFFALSE 12843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12819: NOP4
12823: PUSH
12824: NOP4
12828: PUSH
12829: LD_INT 1
12831: PPUSH
12832: NOP4
12836: PPUSH
12837: NOP4
12841: ARRAY
12842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12843: NOP4
12847: PPUSH
12848: NOP4
12852: PPUSH
12853: NOP4
12857: NOT
12858: IFFALSE 12917
// repeat engine := _engine [ 1 ] ;
12860: NOP4
12864: PUSH
12865: NOP4
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12874: NOP4
12878: PUSH
12879: NOP4
12883: PPUSH
12884: LD_INT 1
12886: PPUSH
12887: NOP4
12891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12892: NOP4
12896: PPUSH
12897: NOP4
12901: PPUSH
12902: NOP4
12906: PUSH
12907: NOP4
12911: PUSH
12912: EMPTY
12913: EQUAL
12914: OR
12915: IFFALSE 12860
// if not control in _control then
12917: NOP4
12921: PUSH
12922: NOP4
12926: IN
12927: NOT
12928: IFFALSE 12954
// control := _control [ rand ( 1 , _control ) ] ;
12930: NOP4
12934: PUSH
12935: NOP4
12939: PUSH
12940: LD_INT 1
12942: PPUSH
12943: NOP4
12947: PPUSH
12948: NOP4
12952: ARRAY
12953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12954: NOP4
12958: PPUSH
12959: NOP4
12963: PPUSH
12964: NOP4
12968: NOT
12969: IFFALSE 13028
// repeat weapon := _weapon [ 1 ] ;
12971: NOP4
12975: PUSH
12976: NOP4
12980: PUSH
12981: LD_INT 1
12983: ARRAY
12984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12985: NOP4
12989: PUSH
12990: NOP4
12994: PPUSH
12995: LD_INT 1
12997: PPUSH
12998: NOP4
13002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
13003: NOP4
13007: PPUSH
13008: NOP4
13012: PPUSH
13013: NOP4
13017: PUSH
13018: NOP4
13022: PUSH
13023: EMPTY
13024: EQUAL
13025: OR
13026: IFFALSE 12971
// result := [ ] ;
13028: NOP4
13032: PUSH
13033: EMPTY
13034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13035: NOP4
13039: PPUSH
13040: NOP4
13044: PPUSH
13045: NOP4
13049: PPUSH
13050: NOP4
13054: PPUSH
13055: NOP4
13059: PPUSH
13060: NOP4
13064: IFFALSE 13097
// result := [ chassis , engine , control , weapon ] ;
13066: NOP4
13070: PUSH
13071: NOP4
13075: PUSH
13076: NOP4
13080: PUSH
13081: NOP4
13085: PUSH
13086: NOP4
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: ST_TO_ADDR
// end ;
13097: LD_VAR 0 6
13101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13102: LD_INT 0
13104: PPUSH
// if not chassis or not engine then
13105: NOP4
13109: NOT
13110: PUSH
13111: NOP4
13115: NOT
13116: OR
13117: IFFALSE 13121
// exit ;
13119: GO 13317
// case engine of engine_solar :
13121: NOP4
13125: PUSH
13126: LD_INT 2
13128: DOUBLE
13129: EQUAL
13130: IFTRUE 13134
13132: GO 13172
13134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13135: NOP4
13139: PUSH
13140: LD_INT 11
13142: PUSH
13143: LD_INT 12
13145: PUSH
13146: LD_INT 13
13148: PUSH
13149: LD_INT 14
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: LD_INT 2
13157: PUSH
13158: LD_INT 3
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13301
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13242
13180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13181: NOP4
13185: PUSH
13186: LD_INT 11
13188: PUSH
13189: LD_INT 12
13191: PUSH
13192: LD_INT 13
13194: PUSH
13195: LD_INT 14
13197: PUSH
13198: LD_INT 1
13200: PUSH
13201: LD_INT 2
13203: PUSH
13204: LD_INT 3
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: LD_INT 5
13212: PUSH
13213: LD_INT 21
13215: PUSH
13216: LD_INT 23
13218: PUSH
13219: LD_INT 22
13221: PUSH
13222: LD_INT 24
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: ST_TO_ADDR
13240: GO 13301
13242: LD_INT 3
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13300
13250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13251: NOP4
13255: PUSH
13256: LD_INT 13
13258: PUSH
13259: LD_INT 14
13261: PUSH
13262: LD_INT 2
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: LD_INT 4
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 21
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 23
13282: PUSH
13283: LD_INT 24
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: ST_TO_ADDR
13298: GO 13301
13300: POP
// result := ( chassis in result ) ;
13301: NOP4
13305: PUSH
13306: NOP4
13310: PUSH
13311: NOP4
13315: IN
13316: ST_TO_ADDR
// end ;
13317: LD_VAR 0 3
13321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13322: LD_INT 0
13324: PPUSH
// if not chassis or not weapon then
13325: NOP4
13329: NOT
13330: PUSH
13331: NOP4
13335: NOT
13336: OR
13337: IFFALSE 13341
// exit ;
13339: GO 14403
// case weapon of us_machine_gun :
13341: NOP4
13345: PUSH
13346: LD_INT 2
13348: DOUBLE
13349: EQUAL
13350: IFTRUE 13354
13352: GO 13384
13354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13355: NOP4
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: LD_INT 2
13365: PUSH
13366: LD_INT 3
13368: PUSH
13369: LD_INT 4
13371: PUSH
13372: LD_INT 5
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: ST_TO_ADDR
13382: GO 14387
13384: LD_INT 3
13386: DOUBLE
13387: EQUAL
13388: IFTRUE 13392
13390: GO 13422
13392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13393: NOP4
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: LD_INT 2
13403: PUSH
13404: LD_INT 3
13406: PUSH
13407: LD_INT 4
13409: PUSH
13410: LD_INT 5
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: ST_TO_ADDR
13420: GO 14387
13422: LD_INT 11
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13460
13430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13431: NOP4
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 2
13441: PUSH
13442: LD_INT 3
13444: PUSH
13445: LD_INT 4
13447: PUSH
13448: LD_INT 5
13450: PUSH
13451: EMPTY
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: ST_TO_ADDR
13458: GO 14387
13460: LD_INT 4
13462: DOUBLE
13463: EQUAL
13464: IFTRUE 13468
13466: GO 13494
13468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13469: NOP4
13473: PUSH
13474: LD_INT 2
13476: PUSH
13477: LD_INT 3
13479: PUSH
13480: LD_INT 4
13482: PUSH
13483: LD_INT 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: ST_TO_ADDR
13492: GO 14387
13494: LD_INT 5
13496: DOUBLE
13497: EQUAL
13498: IFTRUE 13502
13500: GO 13528
13502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13503: NOP4
13507: PUSH
13508: LD_INT 2
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: LD_INT 4
13516: PUSH
13517: LD_INT 5
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14387
13528: LD_INT 9
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13537: NOP4
13541: PUSH
13542: LD_INT 2
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: LD_INT 5
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14387
13562: LD_INT 7
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13571: NOP4
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: LD_INT 3
13581: PUSH
13582: LD_INT 4
13584: PUSH
13585: LD_INT 5
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14387
13596: LD_INT 12
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13605: NOP4
13609: PUSH
13610: LD_INT 2
13612: PUSH
13613: LD_INT 3
13615: PUSH
13616: LD_INT 4
13618: PUSH
13619: LD_INT 5
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14387
13630: LD_INT 13
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13639: NOP4
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: LD_INT 3
13649: PUSH
13650: LD_INT 4
13652: PUSH
13653: LD_INT 5
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14387
13664: LD_INT 14
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13673: NOP4
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: LD_INT 5
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14387
13690: LD_INT 6
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13699: NOP4
13703: PUSH
13704: LD_INT 4
13706: PUSH
13707: LD_INT 5
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14387
13716: LD_INT 10
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13742
13724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13725: NOP4
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: LD_INT 5
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: ST_TO_ADDR
13740: GO 14387
13742: LD_INT 22
13744: DOUBLE
13745: EQUAL
13746: IFTRUE 13750
13748: GO 13776
13750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13751: NOP4
13755: PUSH
13756: LD_INT 11
13758: PUSH
13759: LD_INT 12
13761: PUSH
13762: LD_INT 13
13764: PUSH
13765: LD_INT 14
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14387
13776: LD_INT 23
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13810
13784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13785: NOP4
13789: PUSH
13790: LD_INT 11
13792: PUSH
13793: LD_INT 12
13795: PUSH
13796: LD_INT 13
13798: PUSH
13799: LD_INT 14
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: ST_TO_ADDR
13808: GO 14387
13810: LD_INT 24
13812: DOUBLE
13813: EQUAL
13814: IFTRUE 13818
13816: GO 13844
13818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13819: NOP4
13823: PUSH
13824: LD_INT 11
13826: PUSH
13827: LD_INT 12
13829: PUSH
13830: LD_INT 13
13832: PUSH
13833: LD_INT 14
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: ST_TO_ADDR
13842: GO 14387
13844: LD_INT 30
13846: DOUBLE
13847: EQUAL
13848: IFTRUE 13852
13850: GO 13878
13852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13853: NOP4
13857: PUSH
13858: LD_INT 11
13860: PUSH
13861: LD_INT 12
13863: PUSH
13864: LD_INT 13
13866: PUSH
13867: LD_INT 14
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: ST_TO_ADDR
13876: GO 14387
13878: LD_INT 25
13880: DOUBLE
13881: EQUAL
13882: IFTRUE 13886
13884: GO 13904
13886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13887: NOP4
13891: PUSH
13892: LD_INT 13
13894: PUSH
13895: LD_INT 14
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: ST_TO_ADDR
13902: GO 14387
13904: LD_INT 27
13906: DOUBLE
13907: EQUAL
13908: IFTRUE 13912
13910: GO 13930
13912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13913: NOP4
13917: PUSH
13918: LD_INT 13
13920: PUSH
13921: LD_INT 14
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: ST_TO_ADDR
13928: GO 14387
13930: NOP4
13934: DOUBLE
13935: EQUAL
13936: IFTRUE 13940
13938: GO 13966
13940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13941: NOP4
13945: PUSH
13946: LD_INT 11
13948: PUSH
13949: LD_INT 12
13951: PUSH
13952: LD_INT 13
13954: PUSH
13955: LD_INT 14
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: ST_TO_ADDR
13964: GO 14387
13966: LD_INT 28
13968: DOUBLE
13969: EQUAL
13970: IFTRUE 13974
13972: GO 13992
13974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13975: NOP4
13979: PUSH
13980: LD_INT 13
13982: PUSH
13983: LD_INT 14
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: ST_TO_ADDR
13990: GO 14387
13992: LD_INT 29
13994: DOUBLE
13995: EQUAL
13996: IFTRUE 14000
13998: GO 14018
14000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
14001: NOP4
14005: PUSH
14006: LD_INT 13
14008: PUSH
14009: LD_INT 14
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: ST_TO_ADDR
14016: GO 14387
14018: LD_INT 31
14020: DOUBLE
14021: EQUAL
14022: IFTRUE 14026
14024: GO 14044
14026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14027: NOP4
14031: PUSH
14032: LD_INT 13
14034: PUSH
14035: LD_INT 14
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: ST_TO_ADDR
14042: GO 14387
14044: LD_INT 26
14046: DOUBLE
14047: EQUAL
14048: IFTRUE 14052
14050: GO 14070
14052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14053: NOP4
14057: PUSH
14058: LD_INT 13
14060: PUSH
14061: LD_INT 14
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: ST_TO_ADDR
14068: GO 14387
14070: LD_INT 42
14072: DOUBLE
14073: EQUAL
14074: IFTRUE 14078
14076: GO 14104
14078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14079: NOP4
14083: PUSH
14084: LD_INT 21
14086: PUSH
14087: LD_INT 22
14089: PUSH
14090: LD_INT 23
14092: PUSH
14093: LD_INT 24
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: ST_TO_ADDR
14102: GO 14387
14104: LD_INT 43
14106: DOUBLE
14107: EQUAL
14108: IFTRUE 14112
14110: GO 14138
14112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14113: NOP4
14117: PUSH
14118: LD_INT 21
14120: PUSH
14121: LD_INT 22
14123: PUSH
14124: LD_INT 23
14126: PUSH
14127: LD_INT 24
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: ST_TO_ADDR
14136: GO 14387
14138: LD_INT 44
14140: DOUBLE
14141: EQUAL
14142: IFTRUE 14146
14144: GO 14172
14146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14147: NOP4
14151: PUSH
14152: LD_INT 21
14154: PUSH
14155: LD_INT 22
14157: PUSH
14158: LD_INT 23
14160: PUSH
14161: LD_INT 24
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14387
14172: LD_INT 45
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14206
14180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14181: NOP4
14185: PUSH
14186: LD_INT 21
14188: PUSH
14189: LD_INT 22
14191: PUSH
14192: LD_INT 23
14194: PUSH
14195: LD_INT 24
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: ST_TO_ADDR
14204: GO 14387
14206: LD_INT 49
14208: DOUBLE
14209: EQUAL
14210: IFTRUE 14214
14212: GO 14240
14214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14215: NOP4
14219: PUSH
14220: LD_INT 21
14222: PUSH
14223: LD_INT 22
14225: PUSH
14226: LD_INT 23
14228: PUSH
14229: LD_INT 24
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: ST_TO_ADDR
14238: GO 14387
14240: LD_INT 51
14242: DOUBLE
14243: EQUAL
14244: IFTRUE 14248
14246: GO 14274
14248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14249: NOP4
14253: PUSH
14254: LD_INT 21
14256: PUSH
14257: LD_INT 22
14259: PUSH
14260: LD_INT 23
14262: PUSH
14263: LD_INT 24
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: ST_TO_ADDR
14272: GO 14387
14274: LD_INT 52
14276: DOUBLE
14277: EQUAL
14278: IFTRUE 14282
14280: GO 14308
14282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14283: NOP4
14287: PUSH
14288: LD_INT 21
14290: PUSH
14291: LD_INT 22
14293: PUSH
14294: LD_INT 23
14296: PUSH
14297: LD_INT 24
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: ST_TO_ADDR
14306: GO 14387
14308: LD_INT 53
14310: DOUBLE
14311: EQUAL
14312: IFTRUE 14316
14314: GO 14334
14316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14317: NOP4
14321: PUSH
14322: LD_INT 23
14324: PUSH
14325: LD_INT 24
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: ST_TO_ADDR
14332: GO 14387
14334: LD_INT 46
14336: DOUBLE
14337: EQUAL
14338: IFTRUE 14342
14340: GO 14360
14342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14343: NOP4
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 24
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: ST_TO_ADDR
14358: GO 14387
14360: LD_INT 47
14362: DOUBLE
14363: EQUAL
14364: IFTRUE 14368
14366: GO 14386
14368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14369: NOP4
14373: PUSH
14374: LD_INT 23
14376: PUSH
14377: LD_INT 24
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: ST_TO_ADDR
14384: GO 14387
14386: POP
// result := ( chassis in result ) ;
14387: NOP4
14391: PUSH
14392: NOP4
14396: PUSH
14397: NOP4
14401: IN
14402: ST_TO_ADDR
// end ;
14403: LD_VAR 0 3
14407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14408: LD_INT 0
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
14415: PPUSH
14416: PPUSH
// result := array ;
14417: NOP4
14421: PUSH
14422: NOP4
14426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14427: NOP4
14431: NOT
14432: PUSH
14433: NOP4
14437: NOT
14438: OR
14439: PUSH
14440: NOP4
14444: NOT
14445: OR
14446: PUSH
14447: NOP4
14451: PUSH
14452: NOP4
14456: GREATER
14457: OR
14458: PUSH
14459: NOP4
14463: PUSH
14464: NOP4
14468: GREATER
14469: OR
14470: IFFALSE 14474
// exit ;
14472: GO 14770
// if direction then
14474: NOP4
14478: IFFALSE 14542
// begin d := 1 ;
14480: NOP4
14484: PUSH
14485: LD_INT 1
14487: ST_TO_ADDR
// if i_from > i_to then
14488: NOP4
14492: PUSH
14493: NOP4
14497: GREATER
14498: IFFALSE 14524
// length := ( array - i_from ) + i_to else
14500: NOP4
14504: PUSH
14505: NOP4
14509: PUSH
14510: NOP4
14514: MINUS
14515: PUSH
14516: NOP4
14520: PLUS
14521: ST_TO_ADDR
14522: GO 14540
// length := i_to - i_from ;
14524: NOP4
14528: PUSH
14529: NOP4
14533: PUSH
14534: NOP4
14538: MINUS
14539: ST_TO_ADDR
// end else
14540: GO 14603
// begin d := - 1 ;
14542: NOP4
14546: PUSH
14547: LD_INT 1
14549: NEG
14550: ST_TO_ADDR
// if i_from > i_to then
14551: NOP4
14555: PUSH
14556: NOP4
14560: GREATER
14561: IFFALSE 14581
// length := i_from - i_to else
14563: NOP4
14567: PUSH
14568: NOP4
14572: PUSH
14573: NOP4
14577: MINUS
14578: ST_TO_ADDR
14579: GO 14603
// length := ( array - i_to ) + i_from ;
14581: NOP4
14585: PUSH
14586: NOP4
14590: PUSH
14591: NOP4
14595: MINUS
14596: PUSH
14597: NOP4
14601: PLUS
14602: ST_TO_ADDR
// end ; if not length then
14603: NOP4
14607: NOT
14608: IFFALSE 14612
// exit ;
14610: GO 14770
// tmp := array ;
14612: NOP4
14616: PUSH
14617: NOP4
14621: ST_TO_ADDR
// for i = 1 to length do
14622: NOP4
14626: PUSH
14627: DOUBLE
14628: LD_INT 1
14630: DEC
14631: ST_TO_ADDR
14632: NOP4
14636: PUSH
14637: FOR_TO
14638: IFFALSE 14758
// begin for j = 1 to array do
14640: NOP4
14644: PUSH
14645: DOUBLE
14646: LD_INT 1
14648: DEC
14649: ST_TO_ADDR
14650: NOP4
14654: PUSH
14655: FOR_TO
14656: IFFALSE 14744
// begin k := j + d ;
14658: NOP4
14662: PUSH
14663: NOP4
14667: PUSH
14668: NOP4
14672: PLUS
14673: ST_TO_ADDR
// if k > array then
14674: NOP4
14678: PUSH
14679: NOP4
14683: GREATER
14684: IFFALSE 14694
// k := 1 ;
14686: NOP4
14690: PUSH
14691: LD_INT 1
14693: ST_TO_ADDR
// if not k then
14694: NOP4
14698: NOT
14699: IFFALSE 14711
// k := array ;
14701: NOP4
14705: PUSH
14706: NOP4
14710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14711: NOP4
14715: PUSH
14716: NOP4
14720: PPUSH
14721: NOP4
14725: PPUSH
14726: NOP4
14730: PUSH
14731: NOP4
14735: ARRAY
14736: PPUSH
14737: NOP4
14741: ST_TO_ADDR
// end ;
14742: GO 14655
14744: POP
14745: POP
// array := tmp ;
14746: NOP4
14750: PUSH
14751: NOP4
14755: ST_TO_ADDR
// end ;
14756: GO 14637
14758: POP
14759: POP
// result := array ;
14760: NOP4
14764: PUSH
14765: NOP4
14769: ST_TO_ADDR
// end ;
14770: LD_VAR 0 5
14774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14775: LD_INT 0
14777: PPUSH
14778: PPUSH
// result := 0 ;
14779: NOP4
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// if not array or not value in array then
14787: NOP4
14791: NOT
14792: PUSH
14793: NOP4
14797: PUSH
14798: NOP4
14802: IN
14803: NOT
14804: OR
14805: IFFALSE 14809
// exit ;
14807: GO 14863
// for i = 1 to array do
14809: NOP4
14813: PUSH
14814: DOUBLE
14815: LD_INT 1
14817: DEC
14818: ST_TO_ADDR
14819: NOP4
14823: PUSH
14824: FOR_TO
14825: IFFALSE 14861
// if value = array [ i ] then
14827: NOP4
14831: PUSH
14832: NOP4
14836: PUSH
14837: NOP4
14841: ARRAY
14842: EQUAL
14843: IFFALSE 14859
// begin result := i ;
14845: NOP4
14849: PUSH
14850: NOP4
14854: ST_TO_ADDR
// exit ;
14855: POP
14856: POP
14857: GO 14863
// end ;
14859: GO 14824
14861: POP
14862: POP
// end ;
14863: LD_VAR 0 3
14867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14868: LD_INT 0
14870: PPUSH
// vc_chassis := chassis ;
14871: LD_ADDR_OWVAR 37
14875: PUSH
14876: NOP4
14880: ST_TO_ADDR
// vc_engine := engine ;
14881: LD_ADDR_OWVAR 39
14885: PUSH
14886: NOP4
14890: ST_TO_ADDR
// vc_control := control ;
14891: LD_ADDR_OWVAR 38
14895: PUSH
14896: NOP4
14900: ST_TO_ADDR
// vc_weapon := weapon ;
14901: LD_ADDR_OWVAR 40
14905: PUSH
14906: NOP4
14910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14911: LD_ADDR_OWVAR 41
14915: PUSH
14916: NOP4
14920: ST_TO_ADDR
// end ;
14921: LD_VAR 0 6
14925: RET
// export function WantPlant ( unit ) ; var task ; begin
14926: LD_INT 0
14928: PPUSH
14929: PPUSH
// result := false ;
14930: NOP4
14934: PUSH
14935: LD_INT 0
14937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14938: NOP4
14942: PUSH
14943: NOP4
14947: PPUSH
14948: NOP4
14952: ST_TO_ADDR
// if task then
14953: NOP4
14957: IFFALSE 14985
// if task [ 1 ] [ 1 ] = p then
14959: NOP4
14963: PUSH
14964: LD_INT 1
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_STRING p
14974: EQUAL
14975: IFFALSE 14985
// result := true ;
14977: NOP4
14981: PUSH
14982: LD_INT 1
14984: ST_TO_ADDR
// end ;
14985: LD_VAR 0 2
14989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14990: LD_INT 0
14992: PPUSH
14993: PPUSH
14994: PPUSH
14995: PPUSH
// if pos < 1 then
14996: NOP4
15000: PUSH
15001: LD_INT 1
15003: LESS
15004: IFFALSE 15008
// exit ;
15006: GO 15311
// if pos = 1 then
15008: NOP4
15012: PUSH
15013: LD_INT 1
15015: EQUAL
15016: IFFALSE 15049
// result := Replace ( arr , pos [ 1 ] , value ) else
15018: NOP4
15022: PUSH
15023: NOP4
15027: PPUSH
15028: NOP4
15032: PUSH
15033: LD_INT 1
15035: ARRAY
15036: PPUSH
15037: NOP4
15041: PPUSH
15042: NOP4
15046: ST_TO_ADDR
15047: GO 15311
// begin tmp := arr ;
15049: NOP4
15053: PUSH
15054: NOP4
15058: ST_TO_ADDR
// s_arr := [ tmp ] ;
15059: NOP4
15063: PUSH
15064: NOP4
15068: PUSH
15069: EMPTY
15070: LIST
15071: ST_TO_ADDR
// for i = 1 to pos - 1 do
15072: NOP4
15076: PUSH
15077: DOUBLE
15078: LD_INT 1
15080: DEC
15081: ST_TO_ADDR
15082: NOP4
15086: PUSH
15087: LD_INT 1
15089: MINUS
15090: PUSH
15091: FOR_TO
15092: IFFALSE 15137
// begin tmp := tmp [ pos [ i ] ] ;
15094: NOP4
15098: PUSH
15099: NOP4
15103: PUSH
15104: NOP4
15108: PUSH
15109: NOP4
15113: ARRAY
15114: ARRAY
15115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15116: NOP4
15120: PUSH
15121: NOP4
15125: PUSH
15126: NOP4
15130: PUSH
15131: EMPTY
15132: LIST
15133: ADD
15134: ST_TO_ADDR
// end ;
15135: GO 15091
15137: POP
15138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15139: NOP4
15143: PUSH
15144: NOP4
15148: PPUSH
15149: NOP4
15153: PUSH
15154: NOP4
15158: ARRAY
15159: PPUSH
15160: NOP4
15164: PPUSH
15165: NOP4
15169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15170: NOP4
15174: PUSH
15175: NOP4
15179: PPUSH
15180: NOP4
15184: PPUSH
15185: NOP4
15189: PPUSH
15190: NOP4
15194: ST_TO_ADDR
// for i = s_arr downto 2 do
15195: NOP4
15199: PUSH
15200: DOUBLE
15201: NOP4
15205: INC
15206: ST_TO_ADDR
15207: LD_INT 2
15209: PUSH
15210: FOR_DOWNTO
15211: IFFALSE 15295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15213: NOP4
15217: PUSH
15218: NOP4
15222: PUSH
15223: NOP4
15227: PUSH
15228: LD_INT 1
15230: MINUS
15231: ARRAY
15232: PPUSH
15233: NOP4
15237: PUSH
15238: NOP4
15242: PUSH
15243: LD_INT 1
15245: MINUS
15246: ARRAY
15247: PPUSH
15248: NOP4
15252: PUSH
15253: NOP4
15257: ARRAY
15258: PPUSH
15259: NOP4
15263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15264: NOP4
15268: PUSH
15269: NOP4
15273: PPUSH
15274: NOP4
15278: PUSH
15279: LD_INT 1
15281: MINUS
15282: PPUSH
15283: NOP4
15287: PPUSH
15288: NOP4
15292: ST_TO_ADDR
// end ;
15293: GO 15210
15295: POP
15296: POP
// result := s_arr [ 1 ] ;
15297: NOP4
15301: PUSH
15302: NOP4
15306: PUSH
15307: LD_INT 1
15309: ARRAY
15310: ST_TO_ADDR
// end ; end ;
15311: LD_VAR 0 4
15315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15316: LD_INT 0
15318: PPUSH
15319: PPUSH
// if not list then
15320: NOP4
15324: NOT
15325: IFFALSE 15329
// exit ;
15327: GO 15420
// i := list [ pos1 ] ;
15329: NOP4
15333: PUSH
15334: NOP4
15338: PUSH
15339: NOP4
15343: ARRAY
15344: ST_TO_ADDR
// if not i then
15345: NOP4
15349: NOT
15350: IFFALSE 15354
// exit ;
15352: GO 15420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15354: NOP4
15358: PUSH
15359: NOP4
15363: PPUSH
15364: NOP4
15368: PPUSH
15369: NOP4
15373: PUSH
15374: NOP4
15378: ARRAY
15379: PPUSH
15380: NOP4
15384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15385: NOP4
15389: PUSH
15390: NOP4
15394: PPUSH
15395: NOP4
15399: PPUSH
15400: NOP4
15404: PPUSH
15405: NOP4
15409: ST_TO_ADDR
// result := list ;
15410: NOP4
15414: PUSH
15415: NOP4
15419: ST_TO_ADDR
// end ;
15420: LD_VAR 0 4
15424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15425: LD_INT 0
15427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15428: NOP4
15432: PUSH
15433: NOP4
15437: PPUSH
15438: NOP4
15442: PPUSH
15443: NOP4
15447: PPUSH
15448: NOP4
15452: PPUSH
15453: NOP4
15457: PPUSH
15458: NOP4
15462: PPUSH
15463: NOP4
15467: PPUSH
15468: NOP4
15472: ST_TO_ADDR
// end ;
15473: LD_VAR 0 5
15477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15478: LD_INT 0
15480: PPUSH
15481: PPUSH
15482: PPUSH
15483: PPUSH
// if not list then
15484: NOP4
15488: NOT
15489: IFFALSE 15493
// exit ;
15491: GO 15881
// result := [ ] ;
15493: NOP4
15497: PUSH
15498: EMPTY
15499: ST_TO_ADDR
// for i in list do
15500: NOP4
15504: PUSH
15505: NOP4
15509: PUSH
15510: FOR_IN
15511: IFFALSE 15713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15513: NOP4
15517: PUSH
15518: NOP4
15522: PPUSH
15523: NOP4
15527: PPUSH
15528: NOP4
15532: PPUSH
15533: NOP4
15537: ST_TO_ADDR
// if not result then
15538: NOP4
15542: NOT
15543: IFFALSE 15569
// result := [ [ i , tmp ] ] else
15545: NOP4
15549: PUSH
15550: NOP4
15554: PUSH
15555: NOP4
15559: PUSH
15560: EMPTY
15561: LIST
15562: LIST
15563: PUSH
15564: EMPTY
15565: LIST
15566: ST_TO_ADDR
15567: GO 15711
// begin if result [ result ] [ 2 ] < tmp then
15569: NOP4
15573: PUSH
15574: NOP4
15578: ARRAY
15579: PUSH
15580: LD_INT 2
15582: ARRAY
15583: PUSH
15584: NOP4
15588: LESS
15589: IFFALSE 15631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15591: NOP4
15595: PUSH
15596: NOP4
15600: PPUSH
15601: NOP4
15605: PUSH
15606: LD_INT 1
15608: PLUS
15609: PPUSH
15610: NOP4
15614: PUSH
15615: NOP4
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PPUSH
15624: NOP4
15628: ST_TO_ADDR
15629: GO 15711
// for j = 1 to result do
15631: NOP4
15635: PUSH
15636: DOUBLE
15637: LD_INT 1
15639: DEC
15640: ST_TO_ADDR
15641: NOP4
15645: PUSH
15646: FOR_TO
15647: IFFALSE 15709
// begin if tmp < result [ j ] [ 2 ] then
15649: NOP4
15653: PUSH
15654: NOP4
15658: PUSH
15659: NOP4
15663: ARRAY
15664: PUSH
15665: LD_INT 2
15667: ARRAY
15668: LESS
15669: IFFALSE 15707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15671: NOP4
15675: PUSH
15676: NOP4
15680: PPUSH
15681: NOP4
15685: PPUSH
15686: NOP4
15690: PUSH
15691: NOP4
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: NOP4
15704: ST_TO_ADDR
// break ;
15705: GO 15709
// end ; end ;
15707: GO 15646
15709: POP
15710: POP
// end ; end ;
15711: GO 15510
15713: POP
15714: POP
// if result and not asc then
15715: NOP4
15719: PUSH
15720: NOP4
15724: NOT
15725: AND
15726: IFFALSE 15801
// begin tmp := result ;
15728: NOP4
15732: PUSH
15733: NOP4
15737: ST_TO_ADDR
// for i = tmp downto 1 do
15738: NOP4
15742: PUSH
15743: DOUBLE
15744: NOP4
15748: INC
15749: ST_TO_ADDR
15750: LD_INT 1
15752: PUSH
15753: FOR_DOWNTO
15754: IFFALSE 15799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15756: NOP4
15760: PUSH
15761: NOP4
15765: PPUSH
15766: NOP4
15770: PUSH
15771: NOP4
15775: MINUS
15776: PUSH
15777: LD_INT 1
15779: PLUS
15780: PPUSH
15781: NOP4
15785: PUSH
15786: NOP4
15790: ARRAY
15791: PPUSH
15792: NOP4
15796: ST_TO_ADDR
15797: GO 15753
15799: POP
15800: POP
// end ; tmp := [ ] ;
15801: NOP4
15805: PUSH
15806: EMPTY
15807: ST_TO_ADDR
// if mode then
15808: NOP4
15812: IFFALSE 15881
// begin for i = 1 to result do
15814: NOP4
15818: PUSH
15819: DOUBLE
15820: LD_INT 1
15822: DEC
15823: ST_TO_ADDR
15824: NOP4
15828: PUSH
15829: FOR_TO
15830: IFFALSE 15869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15832: NOP4
15836: PUSH
15837: NOP4
15841: PPUSH
15842: NOP4
15846: PPUSH
15847: NOP4
15851: PUSH
15852: NOP4
15856: ARRAY
15857: PUSH
15858: LD_INT 1
15860: ARRAY
15861: PPUSH
15862: NOP4
15866: ST_TO_ADDR
15867: GO 15829
15869: POP
15870: POP
// result := tmp ;
15871: NOP4
15875: PUSH
15876: NOP4
15880: ST_TO_ADDR
// end ; end ;
15881: LD_VAR 0 6
15885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15886: LD_INT 0
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
15892: PPUSH
15893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15894: NOP4
15898: PUSH
15899: LD_INT 0
15901: PUSH
15902: LD_INT 0
15904: PUSH
15905: LD_INT 0
15907: PUSH
15908: EMPTY
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: LIST
15914: LIST
15915: ST_TO_ADDR
// if not x or not y then
15916: NOP4
15920: NOT
15921: PUSH
15922: NOP4
15926: NOT
15927: OR
15928: IFFALSE 15932
// exit ;
15930: GO 17584
// if not range then
15932: NOP4
15936: NOT
15937: IFFALSE 15947
// range := 10 ;
15939: NOP4
15943: PUSH
15944: LD_INT 10
15946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15947: NOP4
15951: PUSH
15952: LD_INT 81
15954: PUSH
15955: NOP4
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: LD_INT 92
15966: PUSH
15967: NOP4
15971: PUSH
15972: NOP4
15976: PUSH
15977: NOP4
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: LIST
15986: LIST
15987: PUSH
15988: LD_INT 3
15990: PUSH
15991: LD_INT 21
15993: PUSH
15994: LD_INT 3
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: LIST
16009: PPUSH
16010: NOP4
16014: ST_TO_ADDR
// if not tmp then
16015: NOP4
16019: NOT
16020: IFFALSE 16024
// exit ;
16022: GO 17584
// for i in tmp do
16024: NOP4
16028: PUSH
16029: NOP4
16033: PUSH
16034: FOR_IN
16035: IFFALSE 17559
// begin points := [ 0 , 0 , 0 ] ;
16037: NOP4
16041: PUSH
16042: LD_INT 0
16044: PUSH
16045: LD_INT 0
16047: PUSH
16048: LD_INT 0
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: ST_TO_ADDR
// bpoints := 1 ;
16056: NOP4
16060: PUSH
16061: LD_INT 1
16063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16064: NOP4
16068: PPUSH
16069: NOP4
16073: PUSH
16074: LD_INT 1
16076: DOUBLE
16077: EQUAL
16078: IFTRUE 16082
16080: GO 16660
16082: POP
// begin if GetClass ( i ) = 1 then
16083: NOP4
16087: PPUSH
16088: NOP4
16092: PUSH
16093: LD_INT 1
16095: EQUAL
16096: IFFALSE 16117
// points := [ 10 , 5 , 3 ] ;
16098: NOP4
16102: PUSH
16103: LD_INT 10
16105: PUSH
16106: LD_INT 5
16108: PUSH
16109: LD_INT 3
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16117: NOP4
16121: PPUSH
16122: NOP4
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: LIST
16140: IN
16141: IFFALSE 16162
// points := [ 3 , 2 , 1 ] ;
16143: NOP4
16147: PUSH
16148: LD_INT 3
16150: PUSH
16151: LD_INT 2
16153: PUSH
16154: LD_INT 1
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16162: NOP4
16166: PPUSH
16167: NOP4
16171: PUSH
16172: LD_INT 5
16174: EQUAL
16175: IFFALSE 16196
// points := [ 130 , 5 , 2 ] ;
16177: NOP4
16181: PUSH
16182: LD_INT 130
16184: PUSH
16185: LD_INT 5
16187: PUSH
16188: LD_INT 2
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: LIST
16195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16196: NOP4
16200: PPUSH
16201: NOP4
16205: PUSH
16206: LD_INT 8
16208: EQUAL
16209: IFFALSE 16230
// points := [ 35 , 35 , 30 ] ;
16211: NOP4
16215: PUSH
16216: LD_INT 35
16218: PUSH
16219: LD_INT 35
16221: PUSH
16222: LD_INT 30
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16230: NOP4
16234: PPUSH
16235: NOP4
16239: PUSH
16240: LD_INT 9
16242: EQUAL
16243: IFFALSE 16264
// points := [ 20 , 55 , 40 ] ;
16245: NOP4
16249: PUSH
16250: LD_INT 20
16252: PUSH
16253: LD_INT 55
16255: PUSH
16256: LD_INT 40
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: LIST
16263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16264: NOP4
16268: PPUSH
16269: NOP4
16273: PUSH
16274: LD_INT 12
16276: PUSH
16277: LD_INT 16
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: IN
16284: IFFALSE 16305
// points := [ 5 , 3 , 2 ] ;
16286: NOP4
16290: PUSH
16291: LD_INT 5
16293: PUSH
16294: LD_INT 3
16296: PUSH
16297: LD_INT 2
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: LIST
16304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16305: NOP4
16309: PPUSH
16310: NOP4
16314: PUSH
16315: LD_INT 17
16317: EQUAL
16318: IFFALSE 16339
// points := [ 100 , 50 , 75 ] ;
16320: NOP4
16324: PUSH
16325: LD_INT 100
16327: PUSH
16328: LD_INT 50
16330: PUSH
16331: LD_INT 75
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: LIST
16338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16339: NOP4
16343: PPUSH
16344: NOP4
16348: PUSH
16349: LD_INT 15
16351: EQUAL
16352: IFFALSE 16373
// points := [ 10 , 5 , 3 ] ;
16354: NOP4
16358: PUSH
16359: LD_INT 10
16361: PUSH
16362: LD_INT 5
16364: PUSH
16365: LD_INT 3
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: LIST
16372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16373: NOP4
16377: PPUSH
16378: NOP4
16382: PUSH
16383: LD_INT 14
16385: EQUAL
16386: IFFALSE 16407
// points := [ 10 , 0 , 0 ] ;
16388: NOP4
16392: PUSH
16393: LD_INT 10
16395: PUSH
16396: LD_INT 0
16398: PUSH
16399: LD_INT 0
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16407: NOP4
16411: PPUSH
16412: NOP4
16416: PUSH
16417: LD_INT 11
16419: EQUAL
16420: IFFALSE 16441
// points := [ 30 , 10 , 5 ] ;
16422: NOP4
16426: PUSH
16427: LD_INT 30
16429: PUSH
16430: LD_INT 10
16432: PUSH
16433: LD_INT 5
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16441: NOP4
16445: PPUSH
16446: LD_INT 5
16448: PPUSH
16449: NOP4
16453: PUSH
16454: LD_INT 2
16456: EQUAL
16457: IFFALSE 16474
// bpoints := bpoints * 1.8 ;
16459: NOP4
16463: PUSH
16464: NOP4
16468: PUSH
16469: LD_REAL  1.80000000000000E+0000
16472: MUL
16473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16474: NOP4
16478: PPUSH
16479: NOP4
16483: PUSH
16484: LD_INT 1
16486: PUSH
16487: LD_INT 2
16489: PUSH
16490: LD_INT 3
16492: PUSH
16493: LD_INT 4
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: LIST
16501: IN
16502: PUSH
16503: NOP4
16507: PPUSH
16508: LD_INT 51
16510: PPUSH
16511: NOP4
16515: PUSH
16516: LD_INT 2
16518: EQUAL
16519: AND
16520: IFFALSE 16537
// bpoints := bpoints * 1.2 ;
16522: NOP4
16526: PUSH
16527: NOP4
16531: PUSH
16532: LD_REAL  1.20000000000000E+0000
16535: MUL
16536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16537: NOP4
16541: PPUSH
16542: NOP4
16546: PUSH
16547: LD_INT 5
16549: PUSH
16550: LD_INT 7
16552: PUSH
16553: LD_INT 9
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: IN
16561: PUSH
16562: NOP4
16566: PPUSH
16567: LD_INT 52
16569: PPUSH
16570: NOP4
16574: PUSH
16575: LD_INT 2
16577: EQUAL
16578: AND
16579: IFFALSE 16596
// bpoints := bpoints * 1.5 ;
16581: NOP4
16585: PUSH
16586: NOP4
16590: PUSH
16591: LD_REAL  1.50000000000000E+0000
16594: MUL
16595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16596: NOP4
16600: PPUSH
16601: LD_INT 66
16603: PPUSH
16604: NOP4
16608: PUSH
16609: LD_INT 2
16611: EQUAL
16612: IFFALSE 16629
// bpoints := bpoints * 1.1 ;
16614: NOP4
16618: PUSH
16619: NOP4
16623: PUSH
16624: LD_REAL  1.10000000000000E+0000
16627: MUL
16628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16629: NOP4
16633: PUSH
16634: NOP4
16638: PUSH
16639: NOP4
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: NOP4
16651: PUSH
16652: LD_REAL  1.15000000000000E+0000
16655: MUL
16656: MUL
16657: ST_TO_ADDR
// end ; unit_vehicle :
16658: GO 17488
16660: LD_INT 2
16662: DOUBLE
16663: EQUAL
16664: IFTRUE 16668
16666: GO 17476
16668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16669: NOP4
16673: PPUSH
16674: NOP4
16678: PUSH
16679: LD_INT 2
16681: PUSH
16682: LD_INT 42
16684: PUSH
16685: LD_INT 24
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: IN
16693: IFFALSE 16714
// points := [ 25 , 5 , 3 ] ;
16695: NOP4
16699: PUSH
16700: LD_INT 25
16702: PUSH
16703: LD_INT 5
16705: PUSH
16706: LD_INT 3
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16714: NOP4
16718: PPUSH
16719: NOP4
16723: PUSH
16724: LD_INT 4
16726: PUSH
16727: LD_INT 43
16729: PUSH
16730: LD_INT 25
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: IN
16738: IFFALSE 16759
// points := [ 40 , 15 , 5 ] ;
16740: NOP4
16744: PUSH
16745: LD_INT 40
16747: PUSH
16748: LD_INT 15
16750: PUSH
16751: LD_INT 5
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: LIST
16758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16759: NOP4
16763: PPUSH
16764: NOP4
16768: PUSH
16769: LD_INT 3
16771: PUSH
16772: LD_INT 23
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: IN
16779: IFFALSE 16800
// points := [ 7 , 25 , 8 ] ;
16781: NOP4
16785: PUSH
16786: LD_INT 7
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 8
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: LIST
16799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16800: NOP4
16804: PPUSH
16805: NOP4
16809: PUSH
16810: LD_INT 5
16812: PUSH
16813: LD_INT 27
16815: PUSH
16816: LD_INT 44
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: IN
16824: IFFALSE 16845
// points := [ 14 , 50 , 16 ] ;
16826: NOP4
16830: PUSH
16831: LD_INT 14
16833: PUSH
16834: LD_INT 50
16836: PUSH
16837: LD_INT 16
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16845: NOP4
16849: PPUSH
16850: NOP4
16854: PUSH
16855: LD_INT 6
16857: PUSH
16858: LD_INT 46
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 32 , 120 , 70 ] ;
16867: NOP4
16871: PUSH
16872: LD_INT 32
16874: PUSH
16875: LD_INT 120
16877: PUSH
16878: LD_INT 70
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16886: NOP4
16890: PPUSH
16891: NOP4
16895: PUSH
16896: LD_INT 7
16898: PUSH
16899: LD_INT 28
16901: PUSH
16902: LD_INT 45
16904: PUSH
16905: NOP4
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: IN
16916: IFFALSE 16937
// points := [ 35 , 20 , 45 ] ;
16918: NOP4
16922: PUSH
16923: LD_INT 35
16925: PUSH
16926: LD_INT 20
16928: PUSH
16929: LD_INT 45
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16937: NOP4
16941: PPUSH
16942: NOP4
16946: PUSH
16947: LD_INT 47
16949: PUSH
16950: EMPTY
16951: LIST
16952: IN
16953: IFFALSE 16974
// points := [ 67 , 45 , 75 ] ;
16955: NOP4
16959: PUSH
16960: LD_INT 67
16962: PUSH
16963: LD_INT 45
16965: PUSH
16966: LD_INT 75
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16974: NOP4
16978: PPUSH
16979: NOP4
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: IN
16990: IFFALSE 17011
// points := [ 120 , 30 , 80 ] ;
16992: NOP4
16996: PUSH
16997: LD_INT 120
16999: PUSH
17000: LD_INT 30
17002: PUSH
17003: LD_INT 80
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17011: NOP4
17015: PPUSH
17016: NOP4
17020: PUSH
17021: LD_INT 22
17023: PUSH
17024: EMPTY
17025: LIST
17026: IN
17027: IFFALSE 17048
// points := [ 40 , 1 , 1 ] ;
17029: NOP4
17033: PUSH
17034: LD_INT 40
17036: PUSH
17037: LD_INT 1
17039: PUSH
17040: LD_INT 1
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: LIST
17047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17048: NOP4
17052: PPUSH
17053: NOP4
17057: PUSH
17058: LD_INT 29
17060: PUSH
17061: EMPTY
17062: LIST
17063: IN
17064: IFFALSE 17085
// points := [ 70 , 200 , 400 ] ;
17066: NOP4
17070: PUSH
17071: LD_INT 70
17073: PUSH
17074: LD_INT 200
17076: PUSH
17077: LD_INT 400
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17085: NOP4
17089: PPUSH
17090: NOP4
17094: PUSH
17095: LD_INT 14
17097: PUSH
17098: LD_INT 53
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: IN
17105: IFFALSE 17126
// points := [ 40 , 10 , 20 ] ;
17107: NOP4
17111: PUSH
17112: LD_INT 40
17114: PUSH
17115: LD_INT 10
17117: PUSH
17118: LD_INT 20
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: LIST
17125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17126: NOP4
17130: PPUSH
17131: NOP4
17135: PUSH
17136: LD_INT 9
17138: PUSH
17139: EMPTY
17140: LIST
17141: IN
17142: IFFALSE 17163
// points := [ 5 , 70 , 20 ] ;
17144: NOP4
17148: PUSH
17149: LD_INT 5
17151: PUSH
17152: LD_INT 70
17154: PUSH
17155: LD_INT 20
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17163: NOP4
17167: PPUSH
17168: NOP4
17172: PUSH
17173: LD_INT 10
17175: PUSH
17176: EMPTY
17177: LIST
17178: IN
17179: IFFALSE 17200
// points := [ 35 , 110 , 70 ] ;
17181: NOP4
17185: PUSH
17186: LD_INT 35
17188: PUSH
17189: LD_INT 110
17191: PUSH
17192: LD_INT 70
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: LIST
17199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17200: NOP4
17204: PPUSH
17205: NOP4
17209: PUSH
17210: LD_INT 25
17212: EQUAL
17213: IFFALSE 17234
// points := [ 80 , 65 , 100 ] ;
17215: NOP4
17219: PUSH
17220: LD_INT 80
17222: PUSH
17223: LD_INT 65
17225: PUSH
17226: LD_INT 100
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: LIST
17233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17234: NOP4
17238: PPUSH
17239: NOP4
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: IFFALSE 17282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17249: NOP4
17253: PUSH
17254: NOP4
17258: PUSH
17259: NOP4
17263: PPUSH
17264: NOP4
17268: PPUSH
17269: LD_INT 3
17271: PPUSH
17272: NOP4
17276: PUSH
17277: LD_INT 4
17279: MUL
17280: MUL
17281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17282: NOP4
17286: PPUSH
17287: NOP4
17291: PUSH
17292: LD_INT 2
17294: EQUAL
17295: IFFALSE 17346
// begin j := IsControledBy ( i ) ;
17297: NOP4
17301: PUSH
17302: NOP4
17306: PPUSH
17307: NOP4
17311: ST_TO_ADDR
// if j then
17312: NOP4
17316: IFFALSE 17346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17318: NOP4
17322: PUSH
17323: NOP4
17327: PUSH
17328: NOP4
17332: PPUSH
17333: LD_INT 3
17335: PPUSH
17336: NOP4
17340: PUSH
17341: LD_INT 3
17343: MUL
17344: MUL
17345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17346: NOP4
17350: PPUSH
17351: NOP4
17355: PUSH
17356: LD_INT 5
17358: PUSH
17359: LD_INT 6
17361: PUSH
17362: LD_INT 46
17364: PUSH
17365: LD_INT 44
17367: PUSH
17368: LD_INT 47
17370: PUSH
17371: LD_INT 45
17373: PUSH
17374: LD_INT 28
17376: PUSH
17377: LD_INT 7
17379: PUSH
17380: LD_INT 27
17382: PUSH
17383: LD_INT 29
17385: PUSH
17386: EMPTY
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: IN
17398: PUSH
17399: NOP4
17403: PPUSH
17404: LD_INT 52
17406: PPUSH
17407: NOP4
17411: PUSH
17412: LD_INT 2
17414: EQUAL
17415: AND
17416: IFFALSE 17433
// bpoints := bpoints * 1.2 ;
17418: NOP4
17422: PUSH
17423: NOP4
17427: PUSH
17428: LD_REAL  1.20000000000000E+0000
17431: MUL
17432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17433: NOP4
17437: PPUSH
17438: NOP4
17442: PUSH
17443: LD_INT 6
17445: PUSH
17446: LD_INT 46
17448: PUSH
17449: LD_INT 47
17451: PUSH
17452: EMPTY
17453: LIST
17454: LIST
17455: LIST
17456: IN
17457: IFFALSE 17474
// bpoints := bpoints * 1.2 ;
17459: NOP4
17463: PUSH
17464: NOP4
17468: PUSH
17469: LD_REAL  1.20000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// end ; unit_building :
17474: GO 17488
17476: LD_INT 3
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17487
17484: POP
// ; end ;
17485: GO 17488
17487: POP
// for j = 1 to 3 do
17488: NOP4
17492: PUSH
17493: DOUBLE
17494: LD_INT 1
17496: DEC
17497: ST_TO_ADDR
17498: LD_INT 3
17500: PUSH
17501: FOR_TO
17502: IFFALSE 17555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17504: NOP4
17508: PUSH
17509: NOP4
17513: PPUSH
17514: NOP4
17518: PPUSH
17519: NOP4
17523: PUSH
17524: NOP4
17528: ARRAY
17529: PUSH
17530: NOP4
17534: PUSH
17535: NOP4
17539: ARRAY
17540: PUSH
17541: NOP4
17545: MUL
17546: PLUS
17547: PPUSH
17548: NOP4
17552: ST_TO_ADDR
17553: GO 17501
17555: POP
17556: POP
// end ;
17557: GO 16034
17559: POP
17560: POP
// result := Replace ( result , 4 , tmp ) ;
17561: NOP4
17565: PUSH
17566: NOP4
17570: PPUSH
17571: LD_INT 4
17573: PPUSH
17574: NOP4
17578: PPUSH
17579: NOP4
17583: ST_TO_ADDR
// end ;
17584: LD_VAR 0 5
17588: RET
// export function DangerAtRange ( unit , range ) ; begin
17589: LD_INT 0
17591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17592: NOP4
17596: PUSH
17597: NOP4
17601: PPUSH
17602: NOP4
17606: PPUSH
17607: NOP4
17611: PPUSH
17612: NOP4
17616: PPUSH
17617: NOP4
17621: PPUSH
17622: NOP4
17626: PPUSH
17627: NOP4
17631: PPUSH
17632: NOP4
17636: ST_TO_ADDR
// end ;
17637: LD_VAR 0 3
17641: RET
// export function DangerInArea ( side , area ) ; begin
17642: LD_INT 0
17644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17645: NOP4
17649: PUSH
17650: NOP4
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: NOP4
17662: PUSH
17663: EMPTY
17664: LIST
17665: LIST
17666: PPUSH
17667: NOP4
17671: ST_TO_ADDR
// end ;
17672: LD_VAR 0 3
17676: RET
// export function IsExtension ( b ) ; begin
17677: LD_INT 0
17679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17680: NOP4
17684: PUSH
17685: NOP4
17689: PUSH
17690: LD_INT 23
17692: PUSH
17693: LD_INT 20
17695: PUSH
17696: LD_INT 22
17698: PUSH
17699: LD_INT 17
17701: PUSH
17702: LD_INT 24
17704: PUSH
17705: LD_INT 21
17707: PUSH
17708: LD_INT 19
17710: PUSH
17711: LD_INT 16
17713: PUSH
17714: LD_INT 25
17716: PUSH
17717: LD_INT 18
17719: PUSH
17720: EMPTY
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: LIST
17728: LIST
17729: LIST
17730: LIST
17731: IN
17732: ST_TO_ADDR
// end ;
17733: LD_VAR 0 2
17737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17738: LD_INT 0
17740: PPUSH
17741: PPUSH
17742: PPUSH
// result := [ ] ;
17743: NOP4
17747: PUSH
17748: EMPTY
17749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17750: NOP4
17754: PUSH
17755: NOP4
17759: PPUSH
17760: LD_INT 21
17762: PUSH
17763: LD_INT 3
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PPUSH
17770: NOP4
17774: ST_TO_ADDR
// if not tmp then
17775: NOP4
17779: NOT
17780: IFFALSE 17784
// exit ;
17782: GO 17848
// if checkLink then
17784: NOP4
17788: IFFALSE 17838
// begin for i in tmp do
17790: NOP4
17794: PUSH
17795: NOP4
17799: PUSH
17800: FOR_IN
17801: IFFALSE 17836
// if GetBase ( i ) <> base then
17803: NOP4
17807: PPUSH
17808: NOP4
17812: PUSH
17813: NOP4
17817: NONEQUAL
17818: IFFALSE 17834
// ComLinkToBase ( base , i ) ;
17820: NOP4
17824: PPUSH
17825: NOP4
17829: PPUSH
17830: NOP4
17834: GO 17800
17836: POP
17837: POP
// end ; result := tmp ;
17838: NOP4
17842: PUSH
17843: NOP4
17847: ST_TO_ADDR
// end ;
17848: LD_VAR 0 4
17852: RET
// export function ComComplete ( units , b ) ; var i ; begin
17853: LD_INT 0
17855: PPUSH
17856: PPUSH
// if not units then
17857: NOP4
17861: NOT
17862: IFFALSE 17866
// exit ;
17864: GO 17956
// for i in units do
17866: NOP4
17870: PUSH
17871: NOP4
17875: PUSH
17876: FOR_IN
17877: IFFALSE 17954
// if BuildingStatus ( b ) = bs_build then
17879: NOP4
17883: PPUSH
17884: NOP4
17888: PUSH
17889: LD_INT 1
17891: EQUAL
17892: IFFALSE 17952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17894: NOP4
17898: PPUSH
17899: LD_STRING h
17901: PUSH
17902: NOP4
17906: PPUSH
17907: NOP4
17911: PUSH
17912: NOP4
17916: PPUSH
17917: NOP4
17921: PUSH
17922: NOP4
17926: PUSH
17927: LD_INT 0
17929: PUSH
17930: LD_INT 0
17932: PUSH
17933: LD_INT 0
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: LIST
17943: LIST
17944: PUSH
17945: EMPTY
17946: LIST
17947: PPUSH
17948: NOP4
17952: GO 17876
17954: POP
17955: POP
// end ;
17956: LD_VAR 0 3
17960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17961: LD_INT 0
17963: PPUSH
17964: PPUSH
17965: PPUSH
17966: PPUSH
17967: PPUSH
17968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17969: NOP4
17973: NOT
17974: PUSH
17975: NOP4
17979: PPUSH
17980: NOP4
17984: PUSH
17985: LD_INT 2
17987: NONEQUAL
17988: OR
17989: IFFALSE 17993
// exit ;
17991: GO 18309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17993: NOP4
17997: PUSH
17998: LD_INT 22
18000: PUSH
18001: NOP4
18005: PPUSH
18006: NOP4
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: PUSH
18015: LD_INT 2
18017: PUSH
18018: LD_INT 30
18020: PUSH
18021: LD_INT 36
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: PUSH
18028: LD_INT 34
18030: PUSH
18031: LD_INT 31
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: LIST
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PPUSH
18047: NOP4
18051: ST_TO_ADDR
// if not tmp then
18052: NOP4
18056: NOT
18057: IFFALSE 18061
// exit ;
18059: GO 18309
// result := [ ] ;
18061: NOP4
18065: PUSH
18066: EMPTY
18067: ST_TO_ADDR
// for i in tmp do
18068: NOP4
18072: PUSH
18073: NOP4
18077: PUSH
18078: FOR_IN
18079: IFFALSE 18150
// begin t := UnitsInside ( i ) ;
18081: NOP4
18085: PUSH
18086: NOP4
18090: PPUSH
18091: NOP4
18095: ST_TO_ADDR
// if t then
18096: NOP4
18100: IFFALSE 18148
// for j in t do
18102: NOP4
18106: PUSH
18107: NOP4
18111: PUSH
18112: FOR_IN
18113: IFFALSE 18146
// result := Replace ( result , result + 1 , j ) ;
18115: NOP4
18119: PUSH
18120: NOP4
18124: PPUSH
18125: NOP4
18129: PUSH
18130: LD_INT 1
18132: PLUS
18133: PPUSH
18134: NOP4
18138: PPUSH
18139: NOP4
18143: ST_TO_ADDR
18144: GO 18112
18146: POP
18147: POP
// end ;
18148: GO 18078
18150: POP
18151: POP
// if not result then
18152: NOP4
18156: NOT
18157: IFFALSE 18161
// exit ;
18159: GO 18309
// mech := result [ 1 ] ;
18161: NOP4
18165: PUSH
18166: NOP4
18170: PUSH
18171: LD_INT 1
18173: ARRAY
18174: ST_TO_ADDR
// if result > 1 then
18175: NOP4
18179: PUSH
18180: LD_INT 1
18182: GREATER
18183: IFFALSE 18295
// begin for i = 2 to result do
18185: NOP4
18189: PUSH
18190: DOUBLE
18191: LD_INT 2
18193: DEC
18194: ST_TO_ADDR
18195: NOP4
18199: PUSH
18200: FOR_TO
18201: IFFALSE 18293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18203: NOP4
18207: PUSH
18208: NOP4
18212: PUSH
18213: NOP4
18217: ARRAY
18218: PPUSH
18219: LD_INT 3
18221: PPUSH
18222: NOP4
18226: PUSH
18227: NOP4
18231: PUSH
18232: NOP4
18236: ARRAY
18237: PPUSH
18238: NOP4
18242: MINUS
18243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18244: NOP4
18248: PUSH
18249: NOP4
18253: PPUSH
18254: LD_INT 3
18256: PPUSH
18257: NOP4
18261: PUSH
18262: NOP4
18266: PPUSH
18267: NOP4
18271: MINUS
18272: GREATEREQUAL
18273: IFFALSE 18291
// mech := result [ i ] ;
18275: NOP4
18279: PUSH
18280: NOP4
18284: PUSH
18285: NOP4
18289: ARRAY
18290: ST_TO_ADDR
// end ;
18291: GO 18200
18293: POP
18294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18295: NOP4
18299: PPUSH
18300: NOP4
18304: PPUSH
18305: NOP4
// end ;
18309: LD_VAR 0 2
18313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18314: LD_INT 0
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
18325: PPUSH
18326: PPUSH
18327: PPUSH
18328: PPUSH
// result := [ ] ;
18329: NOP4
18333: PUSH
18334: EMPTY
18335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18336: NOP4
18340: PPUSH
18341: NOP4
18345: PUSH
18346: LD_INT 0
18348: PUSH
18349: LD_INT 1
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: IN
18356: NOT
18357: IFFALSE 18361
// exit ;
18359: GO 19995
// if name then
18361: NOP4
18365: IFFALSE 18381
// SetBName ( base_dep , name ) ;
18367: NOP4
18371: PPUSH
18372: NOP4
18376: PPUSH
18377: NOP4
// base := GetBase ( base_dep ) ;
18381: NOP4
18385: PUSH
18386: NOP4
18390: PPUSH
18391: NOP4
18395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18396: NOP4
18400: PUSH
18401: NOP4
18405: PPUSH
18406: NOP4
18410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18411: NOP4
18415: PUSH
18416: NOP4
18420: PPUSH
18421: NOP4
18425: ST_TO_ADDR
// if sources then
18426: NOP4
18430: IFFALSE 18477
// for i = 1 to 3 do
18432: NOP4
18436: PUSH
18437: DOUBLE
18438: LD_INT 1
18440: DEC
18441: ST_TO_ADDR
18442: LD_INT 3
18444: PUSH
18445: FOR_TO
18446: IFFALSE 18475
// AddResourceType ( base , i , sources [ i ] ) ;
18448: NOP4
18452: PPUSH
18453: NOP4
18457: PPUSH
18458: NOP4
18462: PUSH
18463: NOP4
18467: ARRAY
18468: PPUSH
18469: NOP4
18473: GO 18445
18475: POP
18476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18477: NOP4
18481: PUSH
18482: NOP4
18486: PPUSH
18487: NOP4
18491: PPUSH
18492: LD_INT 1
18494: PPUSH
18495: NOP4
18499: ST_TO_ADDR
// InitHc ;
18500: NOP4
// InitUc ;
18504: NOP4
// uc_side := side ;
18508: LD_ADDR_OWVAR 20
18512: PUSH
18513: NOP4
18517: ST_TO_ADDR
// uc_nation := nation ;
18518: LD_ADDR_OWVAR 21
18522: PUSH
18523: NOP4
18527: ST_TO_ADDR
// if buildings then
18528: NOP4
18532: IFFALSE 19854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18534: NOP4
18538: PUSH
18539: NOP4
18543: PPUSH
18544: LD_INT 2
18546: PUSH
18547: LD_INT 30
18549: PUSH
18550: LD_INT 29
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: PUSH
18557: LD_INT 30
18559: PUSH
18560: LD_INT 30
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: LIST
18571: PPUSH
18572: NOP4
18576: ST_TO_ADDR
// if tmp then
18577: NOP4
18581: IFFALSE 18629
// for i in tmp do
18583: NOP4
18587: PUSH
18588: NOP4
18592: PUSH
18593: FOR_IN
18594: IFFALSE 18627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18596: NOP4
18600: PPUSH
18601: NOP4
18605: PPUSH
18606: NOP4
18610: PPUSH
18611: NOP4
18615: PPUSH
18616: NOP4
18620: PPUSH
18621: NOP4
18625: GO 18593
18627: POP
18628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18629: NOP4
18633: PPUSH
18634: LD_INT 2
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 32
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 30
18649: PUSH
18650: LD_INT 33
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: LIST
18661: PPUSH
18662: NOP4
18666: IFFALSE 18754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18668: NOP4
18672: PUSH
18673: NOP4
18677: PPUSH
18678: LD_INT 2
18680: PUSH
18681: LD_INT 30
18683: PUSH
18684: LD_INT 32
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 30
18693: PUSH
18694: LD_INT 33
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: LIST
18705: PPUSH
18706: NOP4
18710: PUSH
18711: FOR_IN
18712: IFFALSE 18752
// begin if not GetBWeapon ( i ) then
18714: NOP4
18718: PPUSH
18719: NOP4
18723: NOT
18724: IFFALSE 18750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18726: NOP4
18730: PPUSH
18731: NOP4
18735: PPUSH
18736: NOP4
18740: PPUSH
18741: NOP4
18745: PPUSH
18746: NOP4
// end ;
18750: GO 18711
18752: POP
18753: POP
// end ; for i = 1 to personel do
18754: NOP4
18758: PUSH
18759: DOUBLE
18760: LD_INT 1
18762: DEC
18763: ST_TO_ADDR
18764: NOP4
18768: PUSH
18769: FOR_TO
18770: IFFALSE 19834
// begin if i > 4 then
18772: NOP4
18776: PUSH
18777: LD_INT 4
18779: GREATER
18780: IFFALSE 18784
// break ;
18782: GO 19834
// case i of 1 :
18784: NOP4
18788: PUSH
18789: LD_INT 1
18791: DOUBLE
18792: EQUAL
18793: IFTRUE 18797
18795: GO 18877
18797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18798: NOP4
18802: PUSH
18803: NOP4
18807: PPUSH
18808: LD_INT 22
18810: PUSH
18811: NOP4
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: PUSH
18820: LD_INT 58
18822: PUSH
18823: EMPTY
18824: LIST
18825: PUSH
18826: LD_INT 2
18828: PUSH
18829: LD_INT 30
18831: PUSH
18832: LD_INT 32
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: PUSH
18839: LD_INT 30
18841: PUSH
18842: LD_INT 4
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PUSH
18849: LD_INT 30
18851: PUSH
18852: LD_INT 5
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: LIST
18869: PPUSH
18870: NOP4
18874: ST_TO_ADDR
18875: GO 19099
18877: LD_INT 2
18879: DOUBLE
18880: EQUAL
18881: IFTRUE 18885
18883: GO 18947
18885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18886: NOP4
18890: PUSH
18891: NOP4
18895: PPUSH
18896: LD_INT 22
18898: PUSH
18899: NOP4
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 2
18910: PUSH
18911: LD_INT 30
18913: PUSH
18914: LD_INT 0
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 1
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: LIST
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: PPUSH
18940: NOP4
18944: ST_TO_ADDR
18945: GO 19099
18947: LD_INT 3
18949: DOUBLE
18950: EQUAL
18951: IFTRUE 18955
18953: GO 19017
18955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18956: NOP4
18960: PUSH
18961: NOP4
18965: PPUSH
18966: LD_INT 22
18968: PUSH
18969: NOP4
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: PUSH
18978: LD_INT 2
18980: PUSH
18981: LD_INT 30
18983: PUSH
18984: LD_INT 2
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: PUSH
18991: LD_INT 30
18993: PUSH
18994: LD_INT 3
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: PUSH
19001: EMPTY
19002: LIST
19003: LIST
19004: LIST
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: PPUSH
19010: NOP4
19014: ST_TO_ADDR
19015: GO 19099
19017: LD_INT 4
19019: DOUBLE
19020: EQUAL
19021: IFTRUE 19025
19023: GO 19098
19025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19026: NOP4
19030: PUSH
19031: NOP4
19035: PPUSH
19036: LD_INT 22
19038: PUSH
19039: NOP4
19043: PUSH
19044: EMPTY
19045: LIST
19046: LIST
19047: PUSH
19048: LD_INT 2
19050: PUSH
19051: LD_INT 30
19053: PUSH
19054: LD_INT 6
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PUSH
19061: LD_INT 30
19063: PUSH
19064: LD_INT 7
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: PUSH
19071: LD_INT 30
19073: PUSH
19074: LD_INT 8
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: PUSH
19081: EMPTY
19082: LIST
19083: LIST
19084: LIST
19085: LIST
19086: PUSH
19087: EMPTY
19088: LIST
19089: LIST
19090: PPUSH
19091: NOP4
19095: ST_TO_ADDR
19096: GO 19099
19098: POP
// if i = 1 then
19099: NOP4
19103: PUSH
19104: LD_INT 1
19106: EQUAL
19107: IFFALSE 19218
// begin tmp := [ ] ;
19109: NOP4
19113: PUSH
19114: EMPTY
19115: ST_TO_ADDR
// for j in f do
19116: NOP4
19120: PUSH
19121: NOP4
19125: PUSH
19126: FOR_IN
19127: IFFALSE 19200
// if GetBType ( j ) = b_bunker then
19129: NOP4
19133: PPUSH
19134: NOP4
19138: PUSH
19139: LD_INT 32
19141: EQUAL
19142: IFFALSE 19169
// tmp := Insert ( tmp , 1 , j ) else
19144: NOP4
19148: PUSH
19149: NOP4
19153: PPUSH
19154: LD_INT 1
19156: PPUSH
19157: NOP4
19161: PPUSH
19162: NOP4
19166: ST_TO_ADDR
19167: GO 19198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19169: NOP4
19173: PUSH
19174: NOP4
19178: PPUSH
19179: NOP4
19183: PUSH
19184: LD_INT 1
19186: PLUS
19187: PPUSH
19188: NOP4
19192: PPUSH
19193: NOP4
19197: ST_TO_ADDR
19198: GO 19126
19200: POP
19201: POP
// if tmp then
19202: NOP4
19206: IFFALSE 19218
// f := tmp ;
19208: NOP4
19212: PUSH
19213: NOP4
19217: ST_TO_ADDR
// end ; x := personel [ i ] ;
19218: NOP4
19222: PUSH
19223: NOP4
19227: PUSH
19228: NOP4
19232: ARRAY
19233: ST_TO_ADDR
// if x = - 1 then
19234: NOP4
19238: PUSH
19239: LD_INT 1
19241: NEG
19242: EQUAL
19243: IFFALSE 19452
// begin for j in f do
19245: NOP4
19249: PUSH
19250: NOP4
19254: PUSH
19255: FOR_IN
19256: IFFALSE 19448
// repeat InitHc ;
19258: NOP4
// if GetBType ( j ) = b_barracks then
19262: NOP4
19266: PPUSH
19267: NOP4
19271: PUSH
19272: LD_INT 5
19274: EQUAL
19275: IFFALSE 19345
// begin if UnitsInside ( j ) < 3 then
19277: NOP4
19281: PPUSH
19282: NOP4
19286: PUSH
19287: LD_INT 3
19289: LESS
19290: IFFALSE 19326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19292: LD_INT 0
19294: PPUSH
19295: LD_INT 5
19297: PUSH
19298: LD_INT 8
19300: PUSH
19301: LD_INT 9
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: LIST
19308: PUSH
19309: NOP4
19313: ARRAY
19314: PPUSH
19315: NOP4
19319: PPUSH
19320: NOP4
19324: GO 19343
// PrepareHuman ( false , i , skill ) ;
19326: LD_INT 0
19328: PPUSH
19329: NOP4
19333: PPUSH
19334: NOP4
19338: PPUSH
19339: NOP4
// end else
19343: GO 19362
// PrepareHuman ( false , i , skill ) ;
19345: LD_INT 0
19347: PPUSH
19348: NOP4
19352: PPUSH
19353: NOP4
19357: PPUSH
19358: NOP4
// un := CreateHuman ;
19362: NOP4
19366: PUSH
19367: NOP4
19371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19372: NOP4
19376: PUSH
19377: NOP4
19381: PPUSH
19382: LD_INT 1
19384: PPUSH
19385: NOP4
19389: PPUSH
19390: NOP4
19394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19395: NOP4
19399: PPUSH
19400: NOP4
19404: PPUSH
19405: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19409: NOP4
19413: PPUSH
19414: NOP4
19418: PUSH
19419: LD_INT 6
19421: EQUAL
19422: PUSH
19423: NOP4
19427: PPUSH
19428: NOP4
19432: PUSH
19433: LD_INT 32
19435: PUSH
19436: LD_INT 31
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: IN
19443: OR
19444: IFFALSE 19258
19446: GO 19255
19448: POP
19449: POP
// end else
19450: GO 19832
// for j = 1 to x do
19452: NOP4
19456: PUSH
19457: DOUBLE
19458: LD_INT 1
19460: DEC
19461: ST_TO_ADDR
19462: NOP4
19466: PUSH
19467: FOR_TO
19468: IFFALSE 19830
// begin InitHc ;
19470: NOP4
// if not f then
19474: NOP4
19478: NOT
19479: IFFALSE 19568
// begin PrepareHuman ( false , i , skill ) ;
19481: LD_INT 0
19483: PPUSH
19484: NOP4
19488: PPUSH
19489: NOP4
19493: PPUSH
19494: NOP4
// un := CreateHuman ;
19498: NOP4
19502: PUSH
19503: NOP4
19507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19508: NOP4
19512: PUSH
19513: NOP4
19517: PPUSH
19518: LD_INT 1
19520: PPUSH
19521: NOP4
19525: PPUSH
19526: NOP4
19530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19531: NOP4
19535: PPUSH
19536: NOP4
19540: PPUSH
19541: NOP4
19545: PPUSH
19546: NOP4
19550: PPUSH
19551: NOP4
19555: PPUSH
19556: LD_INT 10
19558: PPUSH
19559: LD_INT 0
19561: PPUSH
19562: NOP4
// continue ;
19566: GO 19467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19568: NOP4
19572: PUSH
19573: LD_INT 1
19575: ARRAY
19576: PPUSH
19577: NOP4
19581: PUSH
19582: NOP4
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: NOP4
19595: PUSH
19596: LD_INT 32
19598: PUSH
19599: LD_INT 31
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: IN
19606: AND
19607: PUSH
19608: NOP4
19612: PUSH
19613: LD_INT 1
19615: ARRAY
19616: PPUSH
19617: NOP4
19621: PUSH
19622: LD_INT 6
19624: EQUAL
19625: OR
19626: IFFALSE 19646
// f := Delete ( f , 1 ) ;
19628: NOP4
19632: PUSH
19633: NOP4
19637: PPUSH
19638: LD_INT 1
19640: PPUSH
19641: NOP4
19645: ST_TO_ADDR
// if not f then
19646: NOP4
19650: NOT
19651: IFFALSE 19669
// begin x := x + 2 ;
19653: NOP4
19657: PUSH
19658: NOP4
19662: PUSH
19663: LD_INT 2
19665: PLUS
19666: ST_TO_ADDR
// continue ;
19667: GO 19467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19669: NOP4
19673: PUSH
19674: LD_INT 1
19676: ARRAY
19677: PPUSH
19678: NOP4
19682: PUSH
19683: LD_INT 5
19685: EQUAL
19686: IFFALSE 19760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19688: NOP4
19692: PUSH
19693: LD_INT 1
19695: ARRAY
19696: PPUSH
19697: NOP4
19701: PUSH
19702: LD_INT 3
19704: LESS
19705: IFFALSE 19741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19707: LD_INT 0
19709: PPUSH
19710: LD_INT 5
19712: PUSH
19713: LD_INT 8
19715: PUSH
19716: LD_INT 9
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: PUSH
19724: NOP4
19728: ARRAY
19729: PPUSH
19730: NOP4
19734: PPUSH
19735: NOP4
19739: GO 19758
// PrepareHuman ( false , i , skill ) ;
19741: LD_INT 0
19743: PPUSH
19744: NOP4
19748: PPUSH
19749: NOP4
19753: PPUSH
19754: NOP4
// end else
19758: GO 19777
// PrepareHuman ( false , i , skill ) ;
19760: LD_INT 0
19762: PPUSH
19763: NOP4
19767: PPUSH
19768: NOP4
19772: PPUSH
19773: NOP4
// un := CreateHuman ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19787: NOP4
19791: PUSH
19792: NOP4
19796: PPUSH
19797: LD_INT 1
19799: PPUSH
19800: NOP4
19804: PPUSH
19805: NOP4
19809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19810: NOP4
19814: PPUSH
19815: NOP4
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: NOP4
// end ;
19828: GO 19467
19830: POP
19831: POP
// end ;
19832: GO 18769
19834: POP
19835: POP
// result := result ^ buildings ;
19836: NOP4
19840: PUSH
19841: NOP4
19845: PUSH
19846: NOP4
19850: ADD
19851: ST_TO_ADDR
// end else
19852: GO 19995
// begin for i = 1 to personel do
19854: NOP4
19858: PUSH
19859: DOUBLE
19860: LD_INT 1
19862: DEC
19863: ST_TO_ADDR
19864: NOP4
19868: PUSH
19869: FOR_TO
19870: IFFALSE 19993
// begin if i > 4 then
19872: NOP4
19876: PUSH
19877: LD_INT 4
19879: GREATER
19880: IFFALSE 19884
// break ;
19882: GO 19993
// x := personel [ i ] ;
19884: NOP4
19888: PUSH
19889: NOP4
19893: PUSH
19894: NOP4
19898: ARRAY
19899: ST_TO_ADDR
// if x = - 1 then
19900: NOP4
19904: PUSH
19905: LD_INT 1
19907: NEG
19908: EQUAL
19909: IFFALSE 19913
// continue ;
19911: GO 19869
// PrepareHuman ( false , i , skill ) ;
19913: LD_INT 0
19915: PPUSH
19916: NOP4
19920: PPUSH
19921: NOP4
19925: PPUSH
19926: NOP4
// un := CreateHuman ;
19930: NOP4
19934: PUSH
19935: NOP4
19939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19940: NOP4
19944: PPUSH
19945: NOP4
19949: PPUSH
19950: NOP4
19954: PPUSH
19955: NOP4
19959: PPUSH
19960: NOP4
19964: PPUSH
19965: LD_INT 10
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: NOP4
// result := result ^ un ;
19975: NOP4
19979: PUSH
19980: NOP4
19984: PUSH
19985: NOP4
19989: ADD
19990: ST_TO_ADDR
// end ;
19991: GO 19869
19993: POP
19994: POP
// end ; end ;
19995: LD_VAR 0 7
19999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
20000: LD_INT 0
20002: PPUSH
20003: PPUSH
20004: PPUSH
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
20012: PPUSH
20013: PPUSH
20014: PPUSH
20015: PPUSH
20016: PPUSH
20017: PPUSH
// result := false ;
20018: NOP4
20022: PUSH
20023: LD_INT 0
20025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20026: NOP4
20030: NOT
20031: PUSH
20032: NOP4
20036: PPUSH
20037: NOP4
20041: PUSH
20042: LD_INT 32
20044: PUSH
20045: LD_INT 33
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: IN
20052: NOT
20053: OR
20054: IFFALSE 20058
// exit ;
20056: GO 21167
// nat := GetNation ( tower ) ;
20058: NOP4
20062: PUSH
20063: NOP4
20067: PPUSH
20068: NOP4
20072: ST_TO_ADDR
// side := GetSide ( tower ) ;
20073: NOP4
20077: PUSH
20078: NOP4
20082: PPUSH
20083: NOP4
20087: ST_TO_ADDR
// x := GetX ( tower ) ;
20088: NOP4
20092: PUSH
20093: NOP4
20097: PPUSH
20098: NOP4
20102: ST_TO_ADDR
// y := GetY ( tower ) ;
20103: NOP4
20107: PUSH
20108: NOP4
20112: PPUSH
20113: NOP4
20117: ST_TO_ADDR
// if not x or not y then
20118: NOP4
20122: NOT
20123: PUSH
20124: NOP4
20128: NOT
20129: OR
20130: IFFALSE 20134
// exit ;
20132: GO 21167
// weapon := 0 ;
20134: NOP4
20138: PUSH
20139: LD_INT 0
20141: ST_TO_ADDR
// fac_list := [ ] ;
20142: NOP4
20146: PUSH
20147: EMPTY
20148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20149: NOP4
20153: PUSH
20154: NOP4
20158: PPUSH
20159: NOP4
20163: PPUSH
20164: NOP4
20168: PPUSH
20169: LD_INT 0
20171: PPUSH
20172: NOP4
20176: PPUSH
20177: LD_INT 30
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: PPUSH
20187: NOP4
20191: ST_TO_ADDR
// if not factories then
20192: NOP4
20196: NOT
20197: IFFALSE 20201
// exit ;
20199: GO 21167
// for i in factories do
20201: NOP4
20205: PUSH
20206: NOP4
20210: PUSH
20211: FOR_IN
20212: IFFALSE 20237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20214: NOP4
20218: PUSH
20219: NOP4
20223: PUSH
20224: NOP4
20228: PPUSH
20229: NOP4
20233: UNION
20234: ST_TO_ADDR
20235: GO 20211
20237: POP
20238: POP
// if not fac_list then
20239: NOP4
20243: NOT
20244: IFFALSE 20248
// exit ;
20246: GO 21167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20248: NOP4
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: LD_INT 5
20258: PUSH
20259: LD_INT 9
20261: PUSH
20262: LD_INT 10
20264: PUSH
20265: LD_INT 6
20267: PUSH
20268: LD_INT 7
20270: PUSH
20271: LD_INT 11
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: PUSH
20283: LD_INT 27
20285: PUSH
20286: LD_INT 28
20288: PUSH
20289: LD_INT 26
20291: PUSH
20292: LD_INT 30
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 44
20306: PUSH
20307: LD_INT 46
20309: PUSH
20310: LD_INT 45
20312: PUSH
20313: LD_INT 47
20315: PUSH
20316: LD_INT 49
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: PUSH
20332: NOP4
20336: ARRAY
20337: ST_TO_ADDR
// list := list isect fac_list ;
20338: NOP4
20342: PUSH
20343: NOP4
20347: PUSH
20348: NOP4
20352: ISECT
20353: ST_TO_ADDR
// if not list then
20354: NOP4
20358: NOT
20359: IFFALSE 20363
// exit ;
20361: GO 21167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20363: NOP4
20367: PUSH
20368: LD_INT 3
20370: EQUAL
20371: PUSH
20372: LD_INT 49
20374: PUSH
20375: NOP4
20379: IN
20380: AND
20381: PUSH
20382: LD_INT 31
20384: PPUSH
20385: NOP4
20389: PPUSH
20390: NOP4
20394: PUSH
20395: LD_INT 2
20397: EQUAL
20398: AND
20399: IFFALSE 20459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20401: LD_INT 22
20403: PUSH
20404: NOP4
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PUSH
20413: LD_INT 35
20415: PUSH
20416: LD_INT 49
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 91
20425: PUSH
20426: NOP4
20430: PUSH
20431: LD_INT 10
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: LIST
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: PPUSH
20444: NOP4
20448: NOT
20449: IFFALSE 20459
// weapon := ru_time_lapser ;
20451: NOP4
20455: PUSH
20456: LD_INT 49
20458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20459: NOP4
20463: PUSH
20464: LD_INT 1
20466: PUSH
20467: LD_INT 2
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: IN
20474: PUSH
20475: LD_INT 11
20477: PUSH
20478: NOP4
20482: IN
20483: PUSH
20484: LD_INT 30
20486: PUSH
20487: NOP4
20491: IN
20492: OR
20493: AND
20494: PUSH
20495: LD_INT 6
20497: PPUSH
20498: NOP4
20502: PPUSH
20503: NOP4
20507: PUSH
20508: LD_INT 2
20510: EQUAL
20511: AND
20512: IFFALSE 20677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20514: LD_INT 22
20516: PUSH
20517: NOP4
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 2
20528: PUSH
20529: LD_INT 35
20531: PUSH
20532: LD_INT 11
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: LD_INT 35
20541: PUSH
20542: LD_INT 30
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: LIST
20553: PUSH
20554: LD_INT 91
20556: PUSH
20557: NOP4
20561: PUSH
20562: LD_INT 18
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: LIST
20569: PUSH
20570: EMPTY
20571: LIST
20572: LIST
20573: LIST
20574: PPUSH
20575: NOP4
20579: NOT
20580: PUSH
20581: LD_INT 22
20583: PUSH
20584: NOP4
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: PUSH
20593: LD_INT 2
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 32
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: LD_INT 30
20608: PUSH
20609: LD_INT 33
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: PUSH
20621: LD_INT 91
20623: PUSH
20624: NOP4
20628: PUSH
20629: LD_INT 12
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: LIST
20641: PUSH
20642: EMPTY
20643: LIST
20644: PPUSH
20645: NOP4
20649: PUSH
20650: LD_INT 2
20652: GREATER
20653: AND
20654: IFFALSE 20677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20656: NOP4
20660: PUSH
20661: LD_INT 11
20663: PUSH
20664: LD_INT 30
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: NOP4
20675: ARRAY
20676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20677: NOP4
20681: NOT
20682: PUSH
20683: LD_INT 40
20685: PPUSH
20686: NOP4
20690: PPUSH
20691: NOP4
20695: PUSH
20696: LD_INT 2
20698: EQUAL
20699: AND
20700: PUSH
20701: LD_INT 7
20703: PUSH
20704: NOP4
20708: IN
20709: PUSH
20710: LD_INT 28
20712: PUSH
20713: NOP4
20717: IN
20718: OR
20719: PUSH
20720: LD_INT 45
20722: PUSH
20723: NOP4
20727: IN
20728: OR
20729: AND
20730: IFFALSE 20984
// begin hex := GetHexInfo ( x , y ) ;
20732: NOP4
20736: PUSH
20737: NOP4
20741: PPUSH
20742: NOP4
20746: PPUSH
20747: NOP4
20751: ST_TO_ADDR
// if hex [ 1 ] then
20752: NOP4
20756: PUSH
20757: LD_INT 1
20759: ARRAY
20760: IFFALSE 20764
// exit ;
20762: GO 21167
// height := hex [ 2 ] ;
20764: NOP4
20768: PUSH
20769: NOP4
20773: PUSH
20774: LD_INT 2
20776: ARRAY
20777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20778: NOP4
20782: PUSH
20783: LD_INT 0
20785: PUSH
20786: LD_INT 2
20788: PUSH
20789: LD_INT 3
20791: PUSH
20792: LD_INT 5
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: ST_TO_ADDR
// for i in tmp do
20801: NOP4
20805: PUSH
20806: NOP4
20810: PUSH
20811: FOR_IN
20812: IFFALSE 20982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20814: NOP4
20818: PUSH
20819: NOP4
20823: PPUSH
20824: NOP4
20828: PPUSH
20829: LD_INT 5
20831: PPUSH
20832: NOP4
20836: PUSH
20837: NOP4
20841: PPUSH
20842: NOP4
20846: PPUSH
20847: LD_INT 5
20849: PPUSH
20850: NOP4
20854: PUSH
20855: EMPTY
20856: LIST
20857: LIST
20858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20859: NOP4
20863: PUSH
20864: LD_INT 1
20866: ARRAY
20867: PPUSH
20868: NOP4
20872: PUSH
20873: LD_INT 2
20875: ARRAY
20876: PPUSH
20877: NOP4
20881: IFFALSE 20980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20883: NOP4
20887: PUSH
20888: NOP4
20892: PUSH
20893: LD_INT 1
20895: ARRAY
20896: PPUSH
20897: NOP4
20901: PUSH
20902: LD_INT 2
20904: ARRAY
20905: PPUSH
20906: NOP4
20910: ST_TO_ADDR
// if hex [ 1 ] then
20911: NOP4
20915: PUSH
20916: LD_INT 1
20918: ARRAY
20919: IFFALSE 20923
// continue ;
20921: GO 20811
// h := hex [ 2 ] ;
20923: NOP4
20927: PUSH
20928: NOP4
20932: PUSH
20933: LD_INT 2
20935: ARRAY
20936: ST_TO_ADDR
// if h + 7 < height then
20937: NOP4
20941: PUSH
20942: LD_INT 7
20944: PLUS
20945: PUSH
20946: NOP4
20950: LESS
20951: IFFALSE 20980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20953: NOP4
20957: PUSH
20958: LD_INT 7
20960: PUSH
20961: LD_INT 28
20963: PUSH
20964: LD_INT 45
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: LIST
20971: PUSH
20972: NOP4
20976: ARRAY
20977: ST_TO_ADDR
// break ;
20978: GO 20982
// end ; end ; end ;
20980: GO 20811
20982: POP
20983: POP
// end ; if not weapon then
20984: NOP4
20988: NOT
20989: IFFALSE 21049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20991: NOP4
20995: PUSH
20996: NOP4
21000: PUSH
21001: LD_INT 11
21003: PUSH
21004: LD_INT 30
21006: PUSH
21007: LD_INT 49
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: LIST
21014: DIFF
21015: ST_TO_ADDR
// if not list then
21016: NOP4
21020: NOT
21021: IFFALSE 21025
// exit ;
21023: GO 21167
// weapon := list [ rand ( 1 , list ) ] ;
21025: NOP4
21029: PUSH
21030: NOP4
21034: PUSH
21035: LD_INT 1
21037: PPUSH
21038: NOP4
21042: PPUSH
21043: NOP4
21047: ARRAY
21048: ST_TO_ADDR
// end ; if weapon then
21049: NOP4
21053: IFFALSE 21167
// begin tmp := CostOfWeapon ( weapon ) ;
21055: NOP4
21059: PUSH
21060: NOP4
21064: PPUSH
21065: NOP4
21069: ST_TO_ADDR
// j := GetBase ( tower ) ;
21070: NOP4
21074: PUSH
21075: NOP4
21079: PPUSH
21080: NOP4
21084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21085: NOP4
21089: PPUSH
21090: LD_INT 1
21092: PPUSH
21093: NOP4
21097: PUSH
21098: NOP4
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: GREATEREQUAL
21107: PUSH
21108: NOP4
21112: PPUSH
21113: LD_INT 2
21115: PPUSH
21116: NOP4
21120: PUSH
21121: NOP4
21125: PUSH
21126: LD_INT 2
21128: ARRAY
21129: GREATEREQUAL
21130: AND
21131: PUSH
21132: NOP4
21136: PPUSH
21137: LD_INT 3
21139: PPUSH
21140: NOP4
21144: PUSH
21145: NOP4
21149: PUSH
21150: LD_INT 3
21152: ARRAY
21153: GREATEREQUAL
21154: AND
21155: IFFALSE 21167
// result := weapon ;
21157: NOP4
21161: PUSH
21162: NOP4
21166: ST_TO_ADDR
// end ; end ;
21167: LD_VAR 0 3
21171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21172: LD_INT 0
21174: PPUSH
21175: PPUSH
// result := true ;
21176: NOP4
21180: PUSH
21181: LD_INT 1
21183: ST_TO_ADDR
// if array1 = array2 then
21184: NOP4
21188: PUSH
21189: NOP4
21193: EQUAL
21194: IFFALSE 21254
// begin for i = 1 to array1 do
21196: NOP4
21200: PUSH
21201: DOUBLE
21202: LD_INT 1
21204: DEC
21205: ST_TO_ADDR
21206: NOP4
21210: PUSH
21211: FOR_TO
21212: IFFALSE 21250
// if array1 [ i ] <> array2 [ i ] then
21214: NOP4
21218: PUSH
21219: NOP4
21223: ARRAY
21224: PUSH
21225: NOP4
21229: PUSH
21230: NOP4
21234: ARRAY
21235: NONEQUAL
21236: IFFALSE 21248
// begin result := false ;
21238: NOP4
21242: PUSH
21243: LD_INT 0
21245: ST_TO_ADDR
// break ;
21246: GO 21250
// end ;
21248: GO 21211
21250: POP
21251: POP
// end else
21252: GO 21262
// result := false ;
21254: NOP4
21258: PUSH
21259: LD_INT 0
21261: ST_TO_ADDR
// end ;
21262: LD_VAR 0 3
21266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21267: LD_INT 0
21269: PPUSH
21270: PPUSH
// if not array1 or not array2 then
21271: NOP4
21275: NOT
21276: PUSH
21277: NOP4
21281: NOT
21282: OR
21283: IFFALSE 21287
// exit ;
21285: GO 21351
// result := true ;
21287: NOP4
21291: PUSH
21292: LD_INT 1
21294: ST_TO_ADDR
// for i = 1 to array1 do
21295: NOP4
21299: PUSH
21300: DOUBLE
21301: LD_INT 1
21303: DEC
21304: ST_TO_ADDR
21305: NOP4
21309: PUSH
21310: FOR_TO
21311: IFFALSE 21349
// if array1 [ i ] <> array2 [ i ] then
21313: NOP4
21317: PUSH
21318: NOP4
21322: ARRAY
21323: PUSH
21324: NOP4
21328: PUSH
21329: NOP4
21333: ARRAY
21334: NONEQUAL
21335: IFFALSE 21347
// begin result := false ;
21337: NOP4
21341: PUSH
21342: LD_INT 0
21344: ST_TO_ADDR
// break ;
21345: GO 21349
// end ;
21347: GO 21310
21349: POP
21350: POP
// end ;
21351: LD_VAR 0 3
21355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21356: LD_INT 0
21358: PPUSH
21359: PPUSH
21360: PPUSH
// pom := GetBase ( fac ) ;
21361: NOP4
21365: PUSH
21366: NOP4
21370: PPUSH
21371: NOP4
21375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21376: NOP4
21380: PUSH
21381: NOP4
21385: PUSH
21386: LD_INT 1
21388: ARRAY
21389: PPUSH
21390: NOP4
21394: PUSH
21395: LD_INT 2
21397: ARRAY
21398: PPUSH
21399: NOP4
21403: PUSH
21404: LD_INT 3
21406: ARRAY
21407: PPUSH
21408: NOP4
21412: PUSH
21413: LD_INT 4
21415: ARRAY
21416: PPUSH
21417: NOP4
21421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21422: NOP4
21426: PUSH
21427: NOP4
21431: PPUSH
21432: LD_INT 1
21434: PPUSH
21435: NOP4
21439: PUSH
21440: NOP4
21444: PUSH
21445: LD_INT 1
21447: ARRAY
21448: GREATEREQUAL
21449: PUSH
21450: NOP4
21454: PPUSH
21455: LD_INT 2
21457: PPUSH
21458: NOP4
21462: PUSH
21463: NOP4
21467: PUSH
21468: LD_INT 2
21470: ARRAY
21471: GREATEREQUAL
21472: AND
21473: PUSH
21474: NOP4
21478: PPUSH
21479: LD_INT 3
21481: PPUSH
21482: NOP4
21486: PUSH
21487: NOP4
21491: PUSH
21492: LD_INT 3
21494: ARRAY
21495: GREATEREQUAL
21496: AND
21497: ST_TO_ADDR
// end ;
21498: LD_VAR 0 3
21502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21503: LD_INT 0
21505: PPUSH
21506: PPUSH
21507: PPUSH
21508: PPUSH
// pom := GetBase ( building ) ;
21509: NOP4
21513: PUSH
21514: NOP4
21518: PPUSH
21519: NOP4
21523: ST_TO_ADDR
// if not pom then
21524: NOP4
21528: NOT
21529: IFFALSE 21533
// exit ;
21531: GO 21703
// btype := GetBType ( building ) ;
21533: NOP4
21537: PUSH
21538: NOP4
21542: PPUSH
21543: NOP4
21547: ST_TO_ADDR
// if btype = b_armoury then
21548: NOP4
21552: PUSH
21553: LD_INT 4
21555: EQUAL
21556: IFFALSE 21566
// btype := b_barracks ;
21558: NOP4
21562: PUSH
21563: LD_INT 5
21565: ST_TO_ADDR
// if btype = b_depot then
21566: NOP4
21570: PUSH
21571: LD_INT 0
21573: EQUAL
21574: IFFALSE 21584
// btype := b_warehouse ;
21576: NOP4
21580: PUSH
21581: LD_INT 1
21583: ST_TO_ADDR
// if btype = b_workshop then
21584: NOP4
21588: PUSH
21589: LD_INT 2
21591: EQUAL
21592: IFFALSE 21602
// btype := b_factory ;
21594: NOP4
21598: PUSH
21599: LD_INT 3
21601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21602: NOP4
21606: PUSH
21607: NOP4
21611: PPUSH
21612: NOP4
21616: PPUSH
21617: NOP4
21621: PPUSH
21622: NOP4
21626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21627: NOP4
21631: PUSH
21632: NOP4
21636: PPUSH
21637: LD_INT 1
21639: PPUSH
21640: NOP4
21644: PUSH
21645: NOP4
21649: PUSH
21650: LD_INT 1
21652: ARRAY
21653: GREATEREQUAL
21654: PUSH
21655: NOP4
21659: PPUSH
21660: LD_INT 2
21662: PPUSH
21663: NOP4
21667: PUSH
21668: NOP4
21672: PUSH
21673: LD_INT 2
21675: ARRAY
21676: GREATEREQUAL
21677: AND
21678: PUSH
21679: NOP4
21683: PPUSH
21684: LD_INT 3
21686: PPUSH
21687: NOP4
21691: PUSH
21692: NOP4
21696: PUSH
21697: LD_INT 3
21699: ARRAY
21700: GREATEREQUAL
21701: AND
21702: ST_TO_ADDR
// end ;
21703: LD_VAR 0 2
21707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21708: LD_INT 0
21710: PPUSH
21711: PPUSH
21712: PPUSH
// pom := GetBase ( building ) ;
21713: NOP4
21717: PUSH
21718: NOP4
21722: PPUSH
21723: NOP4
21727: ST_TO_ADDR
// if not pom then
21728: NOP4
21732: NOT
21733: IFFALSE 21737
// exit ;
21735: GO 21838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21737: NOP4
21741: PUSH
21742: NOP4
21746: PPUSH
21747: NOP4
21751: PPUSH
21752: NOP4
21756: PPUSH
21757: NOP4
21761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21762: NOP4
21766: PUSH
21767: NOP4
21771: PPUSH
21772: LD_INT 1
21774: PPUSH
21775: NOP4
21779: PUSH
21780: NOP4
21784: PUSH
21785: LD_INT 1
21787: ARRAY
21788: GREATEREQUAL
21789: PUSH
21790: NOP4
21794: PPUSH
21795: LD_INT 2
21797: PPUSH
21798: NOP4
21802: PUSH
21803: NOP4
21807: PUSH
21808: LD_INT 2
21810: ARRAY
21811: GREATEREQUAL
21812: AND
21813: PUSH
21814: NOP4
21818: PPUSH
21819: LD_INT 3
21821: PPUSH
21822: NOP4
21826: PUSH
21827: NOP4
21831: PUSH
21832: LD_INT 3
21834: ARRAY
21835: GREATEREQUAL
21836: AND
21837: ST_TO_ADDR
// end ;
21838: LD_VAR 0 3
21842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21843: LD_INT 0
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
21850: PPUSH
21851: PPUSH
21852: PPUSH
21853: PPUSH
21854: PPUSH
21855: PPUSH
// result := false ;
21856: NOP4
21860: PUSH
21861: LD_INT 0
21863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21864: NOP4
21868: NOT
21869: PUSH
21870: NOP4
21874: NOT
21875: OR
21876: PUSH
21877: NOP4
21881: NOT
21882: OR
21883: PUSH
21884: NOP4
21888: NOT
21889: OR
21890: IFFALSE 21894
// exit ;
21892: GO 22708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21894: NOP4
21898: PUSH
21899: NOP4
21903: PPUSH
21904: NOP4
21908: PPUSH
21909: NOP4
21913: PPUSH
21914: NOP4
21918: PPUSH
21919: NOP4
21923: PUSH
21924: LD_INT 1
21926: ARRAY
21927: PPUSH
21928: NOP4
21932: PPUSH
21933: LD_INT 0
21935: PPUSH
21936: NOP4
21940: ST_TO_ADDR
// if not hexes then
21941: NOP4
21945: NOT
21946: IFFALSE 21950
// exit ;
21948: GO 22708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21950: NOP4
21954: PUSH
21955: NOP4
21959: PPUSH
21960: LD_INT 22
21962: PUSH
21963: NOP4
21967: PPUSH
21968: NOP4
21972: PUSH
21973: EMPTY
21974: LIST
21975: LIST
21976: PUSH
21977: LD_INT 2
21979: PUSH
21980: LD_INT 30
21982: PUSH
21983: LD_INT 0
21985: PUSH
21986: EMPTY
21987: LIST
21988: LIST
21989: PUSH
21990: LD_INT 30
21992: PUSH
21993: LD_INT 1
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PPUSH
22009: NOP4
22013: ST_TO_ADDR
// for i = 1 to hexes do
22014: NOP4
22018: PUSH
22019: DOUBLE
22020: LD_INT 1
22022: DEC
22023: ST_TO_ADDR
22024: NOP4
22028: PUSH
22029: FOR_TO
22030: IFFALSE 22706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22032: NOP4
22036: PUSH
22037: NOP4
22041: PUSH
22042: NOP4
22046: ARRAY
22047: PUSH
22048: LD_INT 1
22050: ARRAY
22051: PPUSH
22052: NOP4
22056: PUSH
22057: NOP4
22061: ARRAY
22062: PUSH
22063: LD_INT 2
22065: ARRAY
22066: PPUSH
22067: NOP4
22071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22072: NOP4
22076: PUSH
22077: NOP4
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PPUSH
22087: NOP4
22091: PUSH
22092: NOP4
22096: ARRAY
22097: PUSH
22098: LD_INT 2
22100: ARRAY
22101: PPUSH
22102: NOP4
22106: PUSH
22107: NOP4
22111: PUSH
22112: NOP4
22116: ARRAY
22117: PUSH
22118: LD_INT 1
22120: ARRAY
22121: PPUSH
22122: NOP4
22126: PUSH
22127: NOP4
22131: ARRAY
22132: PUSH
22133: LD_INT 2
22135: ARRAY
22136: PPUSH
22137: NOP4
22141: NOT
22142: OR
22143: PUSH
22144: NOP4
22148: PPUSH
22149: NOP4
22153: PUSH
22154: LD_INT 3
22156: EQUAL
22157: OR
22158: IFFALSE 22164
// exit ;
22160: POP
22161: POP
22162: GO 22708
// if not tmp then
22164: NOP4
22168: NOT
22169: IFFALSE 22173
// continue ;
22171: GO 22029
// result := true ;
22173: NOP4
22177: PUSH
22178: LD_INT 1
22180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22181: NOP4
22185: PUSH
22186: NOP4
22190: PPUSH
22191: NOP4
22195: PUSH
22196: LD_INT 2
22198: EQUAL
22199: AND
22200: PUSH
22201: NOP4
22205: PPUSH
22206: NOP4
22210: PUSH
22211: LD_INT 1
22213: EQUAL
22214: AND
22215: IFFALSE 22379
// begin if IsDrivenBy ( tmp ) then
22217: NOP4
22221: PPUSH
22222: NOP4
22226: IFFALSE 22230
// continue ;
22228: GO 22029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22230: NOP4
22234: PPUSH
22235: LD_INT 3
22237: PUSH
22238: LD_INT 60
22240: PUSH
22241: EMPTY
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PUSH
22248: LD_INT 3
22250: PUSH
22251: LD_INT 55
22253: PUSH
22254: EMPTY
22255: LIST
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: PPUSH
22265: NOP4
22269: IFFALSE 22377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22271: NOP4
22275: PUSH
22276: NOP4
22280: PPUSH
22281: LD_INT 3
22283: PUSH
22284: LD_INT 60
22286: PUSH
22287: EMPTY
22288: LIST
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 3
22296: PUSH
22297: LD_INT 55
22299: PUSH
22300: EMPTY
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PPUSH
22311: NOP4
22315: PUSH
22316: LD_INT 1
22318: ARRAY
22319: ST_TO_ADDR
// if IsInUnit ( driver ) then
22320: NOP4
22324: PPUSH
22325: NOP4
22329: IFFALSE 22340
// ComExit ( driver ) ;
22331: NOP4
22335: PPUSH
22336: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22340: NOP4
22344: PPUSH
22345: NOP4
22349: PPUSH
22350: NOP4
// AddComMoveToArea ( driver , parking ) ;
22354: NOP4
22358: PPUSH
22359: NOP4
22363: PPUSH
22364: NOP4
// AddComExitVehicle ( driver ) ;
22368: NOP4
22372: PPUSH
22373: NOP4
// end ; continue ;
22377: GO 22029
// end ; if not cleaners or not tmp in cleaners then
22379: NOP4
22383: NOT
22384: PUSH
22385: NOP4
22389: PUSH
22390: NOP4
22394: IN
22395: NOT
22396: OR
22397: IFFALSE 22704
// begin if dep then
22399: NOP4
22403: IFFALSE 22539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22405: NOP4
22409: PUSH
22410: NOP4
22414: PUSH
22415: LD_INT 1
22417: ARRAY
22418: PPUSH
22419: NOP4
22423: PPUSH
22424: NOP4
22428: PUSH
22429: LD_INT 1
22431: ARRAY
22432: PPUSH
22433: NOP4
22437: PPUSH
22438: LD_INT 5
22440: PPUSH
22441: NOP4
22445: PUSH
22446: NOP4
22450: PUSH
22451: LD_INT 1
22453: ARRAY
22454: PPUSH
22455: NOP4
22459: PPUSH
22460: NOP4
22464: PUSH
22465: LD_INT 1
22467: ARRAY
22468: PPUSH
22469: NOP4
22473: PPUSH
22474: LD_INT 5
22476: PPUSH
22477: NOP4
22481: PUSH
22482: EMPTY
22483: LIST
22484: LIST
22485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22486: NOP4
22490: PUSH
22491: LD_INT 1
22493: ARRAY
22494: PPUSH
22495: NOP4
22499: PUSH
22500: LD_INT 2
22502: ARRAY
22503: PPUSH
22504: NOP4
22508: IFFALSE 22539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22510: NOP4
22514: PPUSH
22515: NOP4
22519: PUSH
22520: LD_INT 1
22522: ARRAY
22523: PPUSH
22524: NOP4
22528: PUSH
22529: LD_INT 2
22531: ARRAY
22532: PPUSH
22533: NOP4
// continue ;
22537: GO 22029
// end ; end ; r := GetDir ( tmp ) ;
22539: NOP4
22543: PUSH
22544: NOP4
22548: PPUSH
22549: NOP4
22553: ST_TO_ADDR
// if r = 5 then
22554: NOP4
22558: PUSH
22559: LD_INT 5
22561: EQUAL
22562: IFFALSE 22572
// r := 0 ;
22564: NOP4
22568: PUSH
22569: LD_INT 0
22571: ST_TO_ADDR
// for j = r to 5 do
22572: NOP4
22576: PUSH
22577: DOUBLE
22578: NOP4
22582: DEC
22583: ST_TO_ADDR
22584: LD_INT 5
22586: PUSH
22587: FOR_TO
22588: IFFALSE 22702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22590: NOP4
22594: PUSH
22595: NOP4
22599: PPUSH
22600: NOP4
22604: PPUSH
22605: NOP4
22609: PPUSH
22610: LD_INT 2
22612: PPUSH
22613: NOP4
22617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22618: NOP4
22622: PUSH
22623: NOP4
22627: PPUSH
22628: NOP4
22632: PPUSH
22633: NOP4
22637: PPUSH
22638: LD_INT 2
22640: PPUSH
22641: NOP4
22645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22646: NOP4
22650: PPUSH
22651: NOP4
22655: PPUSH
22656: NOP4
22660: PUSH
22661: NOP4
22665: PPUSH
22666: NOP4
22670: PPUSH
22671: NOP4
22675: NOT
22676: AND
22677: IFFALSE 22700
// begin ComMoveXY ( tmp , _x , _y ) ;
22679: NOP4
22683: PPUSH
22684: NOP4
22688: PPUSH
22689: NOP4
22693: PPUSH
22694: NOP4
// break ;
22698: GO 22702
// end ; end ;
22700: GO 22587
22702: POP
22703: POP
// end ; end ;
22704: GO 22029
22706: POP
22707: POP
// end ;
22708: LD_VAR 0 8
22712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22713: LD_INT 0
22715: PPUSH
// result := true ;
22716: NOP4
22720: PUSH
22721: LD_INT 1
22723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22724: NOP4
22728: PUSH
22729: LD_INT 24
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22743
22735: LD_INT 33
22737: DOUBLE
22738: EQUAL
22739: IFTRUE 22743
22741: GO 22768
22743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22744: NOP4
22748: PUSH
22749: LD_INT 32
22751: PPUSH
22752: NOP4
22756: PPUSH
22757: NOP4
22761: PUSH
22762: LD_INT 2
22764: EQUAL
22765: ST_TO_ADDR
22766: GO 23088
22768: LD_INT 20
22770: DOUBLE
22771: EQUAL
22772: IFTRUE 22776
22774: GO 22801
22776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22777: NOP4
22781: PUSH
22782: LD_INT 6
22784: PPUSH
22785: NOP4
22789: PPUSH
22790: NOP4
22794: PUSH
22795: LD_INT 2
22797: EQUAL
22798: ST_TO_ADDR
22799: GO 23088
22801: LD_INT 22
22803: DOUBLE
22804: EQUAL
22805: IFTRUE 22815
22807: LD_INT 36
22809: DOUBLE
22810: EQUAL
22811: IFTRUE 22815
22813: GO 22840
22815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22816: NOP4
22820: PUSH
22821: LD_INT 15
22823: PPUSH
22824: NOP4
22828: PPUSH
22829: NOP4
22833: PUSH
22834: LD_INT 2
22836: EQUAL
22837: ST_TO_ADDR
22838: GO 23088
22840: LD_INT 30
22842: DOUBLE
22843: EQUAL
22844: IFTRUE 22848
22846: GO 22873
22848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22849: NOP4
22853: PUSH
22854: LD_INT 20
22856: PPUSH
22857: NOP4
22861: PPUSH
22862: NOP4
22866: PUSH
22867: LD_INT 2
22869: EQUAL
22870: ST_TO_ADDR
22871: GO 23088
22873: LD_INT 28
22875: DOUBLE
22876: EQUAL
22877: IFTRUE 22887
22879: LD_INT 21
22881: DOUBLE
22882: EQUAL
22883: IFTRUE 22887
22885: GO 22912
22887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22888: NOP4
22892: PUSH
22893: LD_INT 21
22895: PPUSH
22896: NOP4
22900: PPUSH
22901: NOP4
22905: PUSH
22906: LD_INT 2
22908: EQUAL
22909: ST_TO_ADDR
22910: GO 23088
22912: LD_INT 16
22914: DOUBLE
22915: EQUAL
22916: IFTRUE 22920
22918: GO 22947
22920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22921: NOP4
22925: PUSH
22926: NOP4
22930: PPUSH
22931: NOP4
22935: PPUSH
22936: NOP4
22940: PUSH
22941: LD_INT 2
22943: EQUAL
22944: ST_TO_ADDR
22945: GO 23088
22947: LD_INT 19
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22961
22953: LD_INT 23
22955: DOUBLE
22956: EQUAL
22957: IFTRUE 22961
22959: GO 22988
22961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22962: NOP4
22966: PUSH
22967: NOP4
22971: PPUSH
22972: NOP4
22976: PPUSH
22977: NOP4
22981: PUSH
22982: LD_INT 2
22984: EQUAL
22985: ST_TO_ADDR
22986: GO 23088
22988: LD_INT 17
22990: DOUBLE
22991: EQUAL
22992: IFTRUE 22996
22994: GO 23021
22996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22997: NOP4
23001: PUSH
23002: LD_INT 39
23004: PPUSH
23005: NOP4
23009: PPUSH
23010: NOP4
23014: PUSH
23015: LD_INT 2
23017: EQUAL
23018: ST_TO_ADDR
23019: GO 23088
23021: LD_INT 18
23023: DOUBLE
23024: EQUAL
23025: IFTRUE 23029
23027: GO 23054
23029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23030: NOP4
23034: PUSH
23035: LD_INT 40
23037: PPUSH
23038: NOP4
23042: PPUSH
23043: NOP4
23047: PUSH
23048: LD_INT 2
23050: EQUAL
23051: ST_TO_ADDR
23052: GO 23088
23054: LD_INT 27
23056: DOUBLE
23057: EQUAL
23058: IFTRUE 23062
23060: GO 23087
23062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23063: NOP4
23067: PUSH
23068: LD_INT 35
23070: PPUSH
23071: NOP4
23075: PPUSH
23076: NOP4
23080: PUSH
23081: LD_INT 2
23083: EQUAL
23084: ST_TO_ADDR
23085: GO 23088
23087: POP
// end ;
23088: LD_VAR 0 3
23092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23093: LD_INT 0
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
23104: PPUSH
23105: PPUSH
// result := false ;
23106: NOP4
23110: PUSH
23111: LD_INT 0
23113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23114: NOP4
23118: NOT
23119: PUSH
23120: NOP4
23124: PPUSH
23125: NOP4
23129: PUSH
23130: LD_INT 0
23132: PUSH
23133: LD_INT 1
23135: PUSH
23136: EMPTY
23137: LIST
23138: LIST
23139: IN
23140: NOT
23141: OR
23142: PUSH
23143: NOP4
23147: NOT
23148: OR
23149: PUSH
23150: NOP4
23154: PUSH
23155: LD_INT 0
23157: PUSH
23158: LD_INT 1
23160: PUSH
23161: LD_INT 2
23163: PUSH
23164: LD_INT 3
23166: PUSH
23167: LD_INT 4
23169: PUSH
23170: LD_INT 5
23172: PUSH
23173: EMPTY
23174: LIST
23175: LIST
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: IN
23181: NOT
23182: OR
23183: PUSH
23184: NOP4
23188: PPUSH
23189: NOP4
23193: PPUSH
23194: NOP4
23198: NOT
23199: OR
23200: IFFALSE 23204
// exit ;
23202: GO 23940
// side := GetSide ( depot ) ;
23204: NOP4
23208: PUSH
23209: NOP4
23213: PPUSH
23214: NOP4
23218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23219: NOP4
23223: PPUSH
23224: NOP4
23228: PPUSH
23229: NOP4
23233: NOT
23234: IFFALSE 23238
// exit ;
23236: GO 23940
// pom := GetBase ( depot ) ;
23238: NOP4
23242: PUSH
23243: NOP4
23247: PPUSH
23248: NOP4
23252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23253: NOP4
23257: PUSH
23258: NOP4
23262: PPUSH
23263: NOP4
23267: PPUSH
23268: NOP4
23272: PPUSH
23273: NOP4
23277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23278: NOP4
23282: PPUSH
23283: LD_INT 1
23285: PPUSH
23286: NOP4
23290: PUSH
23291: NOP4
23295: PUSH
23296: LD_INT 1
23298: ARRAY
23299: GREATEREQUAL
23300: PUSH
23301: NOP4
23305: PPUSH
23306: LD_INT 2
23308: PPUSH
23309: NOP4
23313: PUSH
23314: NOP4
23318: PUSH
23319: LD_INT 2
23321: ARRAY
23322: GREATEREQUAL
23323: AND
23324: PUSH
23325: NOP4
23329: PPUSH
23330: LD_INT 3
23332: PPUSH
23333: NOP4
23337: PUSH
23338: NOP4
23342: PUSH
23343: LD_INT 3
23345: ARRAY
23346: GREATEREQUAL
23347: AND
23348: NOT
23349: IFFALSE 23353
// exit ;
23351: GO 23940
// if GetBType ( depot ) = b_depot then
23353: NOP4
23357: PPUSH
23358: NOP4
23362: PUSH
23363: LD_INT 0
23365: EQUAL
23366: IFFALSE 23378
// dist := 28 else
23368: NOP4
23372: PUSH
23373: LD_INT 28
23375: ST_TO_ADDR
23376: GO 23386
// dist := 36 ;
23378: NOP4
23382: PUSH
23383: LD_INT 36
23385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23386: NOP4
23390: PPUSH
23391: NOP4
23395: PPUSH
23396: NOP4
23400: PPUSH
23401: NOP4
23405: PUSH
23406: NOP4
23410: GREATER
23411: IFFALSE 23415
// exit ;
23413: GO 23940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23415: NOP4
23419: PUSH
23420: NOP4
23424: PPUSH
23425: NOP4
23429: PPUSH
23430: NOP4
23434: PPUSH
23435: NOP4
23439: PPUSH
23440: NOP4
23444: PPUSH
23445: NOP4
23449: PPUSH
23450: LD_INT 0
23452: PPUSH
23453: NOP4
23457: ST_TO_ADDR
// if not hexes then
23458: NOP4
23462: NOT
23463: IFFALSE 23467
// exit ;
23465: GO 23940
// hex := GetHexInfo ( x , y ) ;
23467: NOP4
23471: PUSH
23472: NOP4
23476: PPUSH
23477: NOP4
23481: PPUSH
23482: NOP4
23486: ST_TO_ADDR
// if hex [ 1 ] then
23487: NOP4
23491: PUSH
23492: LD_INT 1
23494: ARRAY
23495: IFFALSE 23499
// exit ;
23497: GO 23940
// height := hex [ 2 ] ;
23499: NOP4
23503: PUSH
23504: NOP4
23508: PUSH
23509: LD_INT 2
23511: ARRAY
23512: ST_TO_ADDR
// for i = 1 to hexes do
23513: NOP4
23517: PUSH
23518: DOUBLE
23519: LD_INT 1
23521: DEC
23522: ST_TO_ADDR
23523: NOP4
23527: PUSH
23528: FOR_TO
23529: IFFALSE 23859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23531: NOP4
23535: PUSH
23536: NOP4
23540: ARRAY
23541: PUSH
23542: LD_INT 1
23544: ARRAY
23545: PPUSH
23546: NOP4
23550: PUSH
23551: NOP4
23555: ARRAY
23556: PUSH
23557: LD_INT 2
23559: ARRAY
23560: PPUSH
23561: NOP4
23565: NOT
23566: PUSH
23567: NOP4
23571: PUSH
23572: NOP4
23576: ARRAY
23577: PUSH
23578: LD_INT 1
23580: ARRAY
23581: PPUSH
23582: NOP4
23586: PUSH
23587: NOP4
23591: ARRAY
23592: PUSH
23593: LD_INT 2
23595: ARRAY
23596: PPUSH
23597: NOP4
23601: PUSH
23602: LD_INT 0
23604: GREATER
23605: OR
23606: PUSH
23607: NOP4
23611: PUSH
23612: NOP4
23616: ARRAY
23617: PUSH
23618: LD_INT 1
23620: ARRAY
23621: PPUSH
23622: NOP4
23626: PUSH
23627: NOP4
23631: ARRAY
23632: PUSH
23633: LD_INT 2
23635: ARRAY
23636: PPUSH
23637: NOP4
23641: OR
23642: IFFALSE 23648
// exit ;
23644: POP
23645: POP
23646: GO 23940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23648: NOP4
23652: PUSH
23653: NOP4
23657: PUSH
23658: NOP4
23662: ARRAY
23663: PUSH
23664: LD_INT 1
23666: ARRAY
23667: PPUSH
23668: NOP4
23672: PUSH
23673: NOP4
23677: ARRAY
23678: PUSH
23679: LD_INT 2
23681: ARRAY
23682: PPUSH
23683: NOP4
23687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23688: NOP4
23692: PUSH
23693: LD_INT 1
23695: ARRAY
23696: PUSH
23697: NOP4
23701: PUSH
23702: LD_INT 2
23704: ARRAY
23705: PUSH
23706: NOP4
23710: PUSH
23711: LD_INT 2
23713: PLUS
23714: GREATER
23715: OR
23716: PUSH
23717: NOP4
23721: PUSH
23722: LD_INT 2
23724: ARRAY
23725: PUSH
23726: NOP4
23730: PUSH
23731: LD_INT 2
23733: MINUS
23734: LESS
23735: OR
23736: PUSH
23737: NOP4
23741: PUSH
23742: LD_INT 3
23744: ARRAY
23745: PUSH
23746: LD_INT 0
23748: PUSH
23749: LD_INT 8
23751: PUSH
23752: LD_INT 9
23754: PUSH
23755: LD_INT 10
23757: PUSH
23758: LD_INT 11
23760: PUSH
23761: LD_INT 12
23763: PUSH
23764: LD_INT 13
23766: PUSH
23767: LD_INT 16
23769: PUSH
23770: LD_INT 17
23772: PUSH
23773: LD_INT 18
23775: PUSH
23776: LD_INT 19
23778: PUSH
23779: LD_INT 20
23781: PUSH
23782: LD_INT 21
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: LIST
23798: LIST
23799: IN
23800: NOT
23801: OR
23802: PUSH
23803: NOP4
23807: PUSH
23808: LD_INT 5
23810: ARRAY
23811: NOT
23812: OR
23813: PUSH
23814: NOP4
23818: PUSH
23819: LD_INT 6
23821: ARRAY
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 2
23828: PUSH
23829: LD_INT 7
23831: PUSH
23832: LD_INT 9
23834: PUSH
23835: LD_INT 10
23837: PUSH
23838: LD_INT 11
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: LIST
23845: LIST
23846: LIST
23847: LIST
23848: IN
23849: NOT
23850: OR
23851: IFFALSE 23857
// exit ;
23853: POP
23854: POP
23855: GO 23940
// end ;
23857: GO 23528
23859: POP
23860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23861: NOP4
23865: PPUSH
23866: NOP4
23870: PPUSH
23871: NOP4
23875: PPUSH
23876: LD_INT 20
23878: PPUSH
23879: NOP4
23883: PUSH
23884: LD_INT 4
23886: ARRAY
23887: IFFALSE 23891
// exit ;
23889: GO 23940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23891: NOP4
23895: PUSH
23896: LD_INT 29
23898: PUSH
23899: LD_INT 30
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: IN
23906: PUSH
23907: NOP4
23911: PPUSH
23912: NOP4
23916: PPUSH
23917: NOP4
23921: PPUSH
23922: NOP4
23926: NOT
23927: AND
23928: IFFALSE 23932
// exit ;
23930: GO 23940
// result := true ;
23932: NOP4
23936: PUSH
23937: LD_INT 1
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 6
23944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
23976: PPUSH
23977: PPUSH
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
23997: PPUSH
23998: PPUSH
23999: PPUSH
24000: PPUSH
24001: PPUSH
24002: PPUSH
24003: PPUSH
24004: PPUSH
// result = [ ] ;
24005: NOP4
24009: PUSH
24010: EMPTY
24011: ST_TO_ADDR
// temp_list = [ ] ;
24012: NOP4
24016: PUSH
24017: EMPTY
24018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24019: NOP4
24023: PUSH
24024: LD_INT 0
24026: PUSH
24027: LD_INT 1
24029: PUSH
24030: LD_INT 2
24032: PUSH
24033: LD_INT 3
24035: PUSH
24036: LD_INT 4
24038: PUSH
24039: LD_INT 5
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: LIST
24047: LIST
24048: LIST
24049: IN
24050: NOT
24051: PUSH
24052: NOP4
24056: PUSH
24057: LD_INT 0
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: IN
24067: PUSH
24068: NOP4
24072: PUSH
24073: LD_INT 1
24075: PUSH
24076: LD_INT 2
24078: PUSH
24079: LD_INT 3
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: LIST
24086: IN
24087: NOT
24088: AND
24089: OR
24090: IFFALSE 24094
// exit ;
24092: GO 42485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24094: NOP4
24098: PUSH
24099: LD_INT 6
24101: PUSH
24102: LD_INT 7
24104: PUSH
24105: LD_INT 8
24107: PUSH
24108: LD_INT 13
24110: PUSH
24111: LD_INT 12
24113: PUSH
24114: LD_INT 15
24116: PUSH
24117: LD_INT 11
24119: PUSH
24120: LD_INT 14
24122: PUSH
24123: LD_INT 10
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: IN
24137: IFFALSE 24147
// btype = b_lab ;
24139: NOP4
24143: PUSH
24144: LD_INT 6
24146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24147: NOP4
24151: PUSH
24152: LD_INT 0
24154: PUSH
24155: LD_INT 1
24157: PUSH
24158: LD_INT 2
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: IN
24166: NOT
24167: PUSH
24168: NOP4
24172: PUSH
24173: LD_INT 0
24175: PUSH
24176: LD_INT 1
24178: PUSH
24179: LD_INT 2
24181: PUSH
24182: LD_INT 3
24184: PUSH
24185: LD_INT 6
24187: PUSH
24188: LD_INT 36
24190: PUSH
24191: LD_INT 4
24193: PUSH
24194: LD_INT 5
24196: PUSH
24197: LD_INT 31
24199: PUSH
24200: LD_INT 32
24202: PUSH
24203: LD_INT 33
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: IN
24219: NOT
24220: PUSH
24221: NOP4
24225: PUSH
24226: LD_INT 1
24228: EQUAL
24229: AND
24230: OR
24231: PUSH
24232: NOP4
24236: PUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 3
24242: PUSH
24243: EMPTY
24244: LIST
24245: LIST
24246: IN
24247: NOT
24248: PUSH
24249: NOP4
24253: PUSH
24254: LD_INT 2
24256: EQUAL
24257: AND
24258: OR
24259: IFFALSE 24269
// mode = 0 ;
24261: NOP4
24265: PUSH
24266: LD_INT 0
24268: ST_TO_ADDR
// case mode of 0 :
24269: NOP4
24273: PUSH
24274: LD_INT 0
24276: DOUBLE
24277: EQUAL
24278: IFTRUE 24282
24280: GO 35735
24282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24283: NOP4
24287: PUSH
24288: LD_INT 0
24290: PUSH
24291: LD_INT 0
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: LD_INT 1
24303: NEG
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PUSH
24309: LD_INT 1
24311: PUSH
24312: LD_INT 0
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 1
24321: PUSH
24322: LD_INT 1
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 0
24331: PUSH
24332: LD_INT 1
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: NEG
24342: PUSH
24343: LD_INT 0
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: LD_INT 1
24352: NEG
24353: PUSH
24354: LD_INT 1
24356: NEG
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 1
24364: NEG
24365: PUSH
24366: LD_INT 2
24368: NEG
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PUSH
24374: LD_INT 0
24376: PUSH
24377: LD_INT 2
24379: NEG
24380: PUSH
24381: EMPTY
24382: LIST
24383: LIST
24384: PUSH
24385: LD_INT 1
24387: PUSH
24388: LD_INT 1
24390: NEG
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: PUSH
24396: LD_INT 1
24398: PUSH
24399: LD_INT 2
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: PUSH
24406: LD_INT 0
24408: PUSH
24409: LD_INT 2
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PUSH
24416: LD_INT 1
24418: NEG
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_INT 1
24429: PUSH
24430: LD_INT 3
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: LD_INT 3
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: LD_INT 2
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: LIST
24468: LIST
24469: LIST
24470: LIST
24471: LIST
24472: LIST
24473: LIST
24474: LIST
24475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24476: NOP4
24480: PUSH
24481: LD_INT 0
24483: PUSH
24484: LD_INT 0
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: PUSH
24491: LD_INT 0
24493: PUSH
24494: LD_INT 1
24496: NEG
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 1
24504: PUSH
24505: LD_INT 0
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: PUSH
24512: LD_INT 1
24514: PUSH
24515: LD_INT 1
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: LD_INT 1
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: LD_INT 1
24534: NEG
24535: PUSH
24536: LD_INT 0
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: LD_INT 1
24545: NEG
24546: PUSH
24547: LD_INT 1
24549: NEG
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: PUSH
24558: LD_INT 1
24560: NEG
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: LD_INT 2
24568: PUSH
24569: LD_INT 0
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 2
24578: PUSH
24579: LD_INT 1
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 1
24588: NEG
24589: PUSH
24590: LD_INT 1
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: PUSH
24597: LD_INT 2
24599: NEG
24600: PUSH
24601: LD_INT 0
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: LD_INT 2
24610: NEG
24611: PUSH
24612: LD_INT 1
24614: NEG
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: NEG
24623: PUSH
24624: LD_INT 1
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 3
24633: NEG
24634: PUSH
24635: LD_INT 0
24637: PUSH
24638: EMPTY
24639: LIST
24640: LIST
24641: PUSH
24642: LD_INT 3
24644: NEG
24645: PUSH
24646: LD_INT 1
24648: NEG
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: LIST
24670: LIST
24671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24672: NOP4
24676: PUSH
24677: LD_INT 0
24679: PUSH
24680: LD_INT 0
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 0
24689: PUSH
24690: LD_INT 1
24692: NEG
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: PUSH
24698: LD_INT 1
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: EMPTY
24705: LIST
24706: LIST
24707: PUSH
24708: LD_INT 1
24710: PUSH
24711: LD_INT 1
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 0
24720: PUSH
24721: LD_INT 1
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 1
24730: NEG
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: PUSH
24739: LD_INT 1
24741: NEG
24742: PUSH
24743: LD_INT 1
24745: NEG
24746: PUSH
24747: EMPTY
24748: LIST
24749: LIST
24750: PUSH
24751: LD_INT 1
24753: NEG
24754: PUSH
24755: LD_INT 2
24757: NEG
24758: PUSH
24759: EMPTY
24760: LIST
24761: LIST
24762: PUSH
24763: LD_INT 2
24765: PUSH
24766: LD_INT 1
24768: PUSH
24769: EMPTY
24770: LIST
24771: LIST
24772: PUSH
24773: LD_INT 2
24775: PUSH
24776: LD_INT 2
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 1
24785: PUSH
24786: LD_INT 2
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 2
24795: NEG
24796: PUSH
24797: LD_INT 1
24799: NEG
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 2
24807: NEG
24808: PUSH
24809: LD_INT 2
24811: NEG
24812: PUSH
24813: EMPTY
24814: LIST
24815: LIST
24816: PUSH
24817: LD_INT 2
24819: NEG
24820: PUSH
24821: LD_INT 3
24823: NEG
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: LD_INT 3
24831: NEG
24832: PUSH
24833: LD_INT 2
24835: NEG
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 3
24843: NEG
24844: PUSH
24845: LD_INT 3
24847: NEG
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24871: NOP4
24875: PUSH
24876: LD_INT 0
24878: PUSH
24879: LD_INT 0
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: PUSH
24886: LD_INT 0
24888: PUSH
24889: LD_INT 1
24891: NEG
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: PUSH
24897: LD_INT 1
24899: PUSH
24900: LD_INT 0
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: PUSH
24907: LD_INT 1
24909: PUSH
24910: LD_INT 1
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: PUSH
24917: LD_INT 0
24919: PUSH
24920: LD_INT 1
24922: PUSH
24923: EMPTY
24924: LIST
24925: LIST
24926: PUSH
24927: LD_INT 1
24929: NEG
24930: PUSH
24931: LD_INT 0
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 1
24940: NEG
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: NEG
24953: PUSH
24954: LD_INT 2
24956: NEG
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PUSH
24962: LD_INT 0
24964: PUSH
24965: LD_INT 2
24967: NEG
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 1
24975: PUSH
24976: LD_INT 1
24978: NEG
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: PUSH
24984: LD_INT 1
24986: PUSH
24987: LD_INT 2
24989: PUSH
24990: EMPTY
24991: LIST
24992: LIST
24993: PUSH
24994: LD_INT 0
24996: PUSH
24997: LD_INT 2
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 1
25006: NEG
25007: PUSH
25008: LD_INT 1
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 1
25017: NEG
25018: PUSH
25019: LD_INT 3
25021: NEG
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: LD_INT 0
25029: PUSH
25030: LD_INT 3
25032: NEG
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 1
25040: PUSH
25041: LD_INT 2
25043: NEG
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: LIST
25064: LIST
25065: LIST
25066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25067: NOP4
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 0
25084: PUSH
25085: LD_INT 1
25087: NEG
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 1
25095: PUSH
25096: LD_INT 0
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 1
25105: PUSH
25106: LD_INT 1
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: PUSH
25113: LD_INT 0
25115: PUSH
25116: LD_INT 1
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: PUSH
25123: LD_INT 1
25125: NEG
25126: PUSH
25127: LD_INT 0
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 1
25136: NEG
25137: PUSH
25138: LD_INT 1
25140: NEG
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: LD_INT 1
25151: NEG
25152: PUSH
25153: EMPTY
25154: LIST
25155: LIST
25156: PUSH
25157: LD_INT 2
25159: PUSH
25160: LD_INT 0
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PUSH
25167: LD_INT 2
25169: PUSH
25170: LD_INT 1
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 1
25179: NEG
25180: PUSH
25181: LD_INT 1
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 2
25190: NEG
25191: PUSH
25192: LD_INT 0
25194: PUSH
25195: EMPTY
25196: LIST
25197: LIST
25198: PUSH
25199: LD_INT 2
25201: NEG
25202: PUSH
25203: LD_INT 1
25205: NEG
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: PUSH
25211: LD_INT 2
25213: PUSH
25214: LD_INT 1
25216: NEG
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: PUSH
25222: LD_INT 3
25224: PUSH
25225: LD_INT 0
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: PUSH
25232: LD_INT 3
25234: PUSH
25235: LD_INT 1
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25260: NOP4
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 0
25277: PUSH
25278: LD_INT 1
25280: NEG
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: PUSH
25296: LD_INT 1
25298: PUSH
25299: LD_INT 1
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: PUSH
25306: LD_INT 0
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: NEG
25319: PUSH
25320: LD_INT 0
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 1
25329: NEG
25330: PUSH
25331: LD_INT 1
25333: NEG
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 2
25345: NEG
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: LD_INT 1
25356: PUSH
25357: EMPTY
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 2
25363: PUSH
25364: LD_INT 2
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: PUSH
25371: LD_INT 1
25373: PUSH
25374: LD_INT 2
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: PUSH
25381: LD_INT 2
25383: NEG
25384: PUSH
25385: LD_INT 1
25387: NEG
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PUSH
25393: LD_INT 2
25395: NEG
25396: PUSH
25397: LD_INT 2
25399: NEG
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: LD_INT 3
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: PUSH
25415: LD_INT 3
25417: PUSH
25418: LD_INT 3
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: PUSH
25425: LD_INT 2
25427: PUSH
25428: LD_INT 3
25430: PUSH
25431: EMPTY
25432: LIST
25433: LIST
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: LIST
25446: LIST
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25453: NOP4
25457: PUSH
25458: LD_INT 0
25460: PUSH
25461: LD_INT 0
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 0
25470: PUSH
25471: LD_INT 1
25473: NEG
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PUSH
25479: LD_INT 1
25481: PUSH
25482: LD_INT 0
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PUSH
25489: LD_INT 1
25491: PUSH
25492: LD_INT 1
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 0
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: LD_INT 1
25511: NEG
25512: PUSH
25513: LD_INT 0
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 1
25522: NEG
25523: PUSH
25524: LD_INT 1
25526: NEG
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 2
25538: NEG
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 0
25546: PUSH
25547: LD_INT 2
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 2
25588: PUSH
25589: LD_INT 2
25591: PUSH
25592: EMPTY
25593: LIST
25594: LIST
25595: PUSH
25596: LD_INT 1
25598: PUSH
25599: LD_INT 2
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 0
25608: PUSH
25609: LD_INT 2
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PUSH
25616: LD_INT 1
25618: NEG
25619: PUSH
25620: LD_INT 1
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: LD_INT 2
25629: NEG
25630: PUSH
25631: LD_INT 0
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: PUSH
25638: LD_INT 2
25640: NEG
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 2
25652: NEG
25653: PUSH
25654: LD_INT 2
25656: NEG
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25683: NOP4
25687: PUSH
25688: LD_INT 0
25690: PUSH
25691: LD_INT 0
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 0
25700: PUSH
25701: LD_INT 1
25703: NEG
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: LD_INT 1
25711: PUSH
25712: LD_INT 0
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: LD_INT 1
25721: PUSH
25722: LD_INT 1
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 0
25731: PUSH
25732: LD_INT 1
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 0
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 1
25752: NEG
25753: PUSH
25754: LD_INT 1
25756: NEG
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 1
25764: NEG
25765: PUSH
25766: LD_INT 2
25768: NEG
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: LD_INT 0
25776: PUSH
25777: LD_INT 2
25779: NEG
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: PUSH
25785: LD_INT 1
25787: PUSH
25788: LD_INT 1
25790: NEG
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 2
25798: PUSH
25799: LD_INT 0
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 2
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 2
25818: PUSH
25819: LD_INT 2
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PUSH
25826: LD_INT 1
25828: PUSH
25829: LD_INT 2
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: LD_INT 2
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 1
25848: NEG
25849: PUSH
25850: LD_INT 1
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PUSH
25857: LD_INT 2
25859: NEG
25860: PUSH
25861: LD_INT 0
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: LD_INT 2
25870: NEG
25871: PUSH
25872: LD_INT 1
25874: NEG
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 2
25882: NEG
25883: PUSH
25884: LD_INT 2
25886: NEG
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: LIST
25907: LIST
25908: LIST
25909: LIST
25910: LIST
25911: LIST
25912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25913: NOP4
25917: PUSH
25918: LD_INT 0
25920: PUSH
25921: LD_INT 0
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 0
25930: PUSH
25931: LD_INT 1
25933: NEG
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 1
25941: PUSH
25942: LD_INT 0
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 1
25951: PUSH
25952: LD_INT 1
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: LD_INT 0
25961: PUSH
25962: LD_INT 1
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 1
25971: NEG
25972: PUSH
25973: LD_INT 0
25975: PUSH
25976: EMPTY
25977: LIST
25978: LIST
25979: PUSH
25980: LD_INT 1
25982: NEG
25983: PUSH
25984: LD_INT 1
25986: NEG
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: LD_INT 1
25994: NEG
25995: PUSH
25996: LD_INT 2
25998: NEG
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 0
26006: PUSH
26007: LD_INT 2
26009: NEG
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: PUSH
26018: LD_INT 1
26020: NEG
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 2
26028: PUSH
26029: LD_INT 0
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 2
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 2
26048: PUSH
26049: LD_INT 2
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PUSH
26056: LD_INT 1
26058: PUSH
26059: LD_INT 2
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: PUSH
26066: LD_INT 0
26068: PUSH
26069: LD_INT 2
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 1
26078: NEG
26079: PUSH
26080: LD_INT 1
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 2
26089: NEG
26090: PUSH
26091: LD_INT 0
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 2
26100: NEG
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 2
26112: NEG
26113: PUSH
26114: LD_INT 2
26116: NEG
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: LIST
26136: LIST
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: LIST
26142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26143: NOP4
26147: PUSH
26148: LD_INT 0
26150: PUSH
26151: LD_INT 0
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: PUSH
26158: LD_INT 0
26160: PUSH
26161: LD_INT 1
26163: NEG
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: LD_INT 1
26171: PUSH
26172: LD_INT 0
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PUSH
26179: LD_INT 1
26181: PUSH
26182: LD_INT 1
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PUSH
26189: LD_INT 0
26191: PUSH
26192: LD_INT 1
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 1
26201: NEG
26202: PUSH
26203: LD_INT 0
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: PUSH
26210: LD_INT 1
26212: NEG
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 1
26224: NEG
26225: PUSH
26226: LD_INT 2
26228: NEG
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 0
26236: PUSH
26237: LD_INT 2
26239: NEG
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 1
26247: PUSH
26248: LD_INT 1
26250: NEG
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 2
26258: PUSH
26259: LD_INT 0
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 2
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: LD_INT 2
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 2
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 0
26298: PUSH
26299: LD_INT 2
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 1
26308: NEG
26309: PUSH
26310: LD_INT 1
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: LD_INT 2
26319: NEG
26320: PUSH
26321: LD_INT 0
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 2
26330: NEG
26331: PUSH
26332: LD_INT 1
26334: NEG
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_INT 2
26342: NEG
26343: PUSH
26344: LD_INT 2
26346: NEG
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: LIST
26370: LIST
26371: LIST
26372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26373: NOP4
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 0
26390: PUSH
26391: LD_INT 1
26393: NEG
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: LD_INT 1
26401: PUSH
26402: LD_INT 0
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 1
26411: PUSH
26412: LD_INT 1
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: PUSH
26419: LD_INT 0
26421: PUSH
26422: LD_INT 1
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: LD_INT 1
26431: NEG
26432: PUSH
26433: LD_INT 0
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 1
26442: NEG
26443: PUSH
26444: LD_INT 1
26446: NEG
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: LD_INT 1
26454: NEG
26455: PUSH
26456: LD_INT 2
26458: NEG
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 0
26466: PUSH
26467: LD_INT 2
26469: NEG
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 1
26477: PUSH
26478: LD_INT 1
26480: NEG
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 2
26488: PUSH
26489: LD_INT 0
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 2
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 2
26508: PUSH
26509: LD_INT 2
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: PUSH
26519: LD_INT 2
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 0
26528: PUSH
26529: LD_INT 2
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 1
26538: NEG
26539: PUSH
26540: LD_INT 1
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: LD_INT 0
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 2
26560: NEG
26561: PUSH
26562: LD_INT 1
26564: NEG
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 2
26572: NEG
26573: PUSH
26574: LD_INT 2
26576: NEG
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26603: NOP4
26607: PUSH
26608: LD_INT 0
26610: PUSH
26611: LD_INT 0
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PUSH
26618: LD_INT 0
26620: PUSH
26621: LD_INT 1
26623: NEG
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: LD_INT 1
26631: PUSH
26632: LD_INT 0
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: LD_INT 1
26641: PUSH
26642: LD_INT 1
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 0
26651: PUSH
26652: LD_INT 1
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: LD_INT 1
26661: NEG
26662: PUSH
26663: LD_INT 0
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 1
26672: NEG
26673: PUSH
26674: LD_INT 1
26676: NEG
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: PUSH
26682: LD_INT 1
26684: NEG
26685: PUSH
26686: LD_INT 2
26688: NEG
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 0
26696: PUSH
26697: LD_INT 2
26699: NEG
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 1
26707: PUSH
26708: LD_INT 1
26710: NEG
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 2
26718: PUSH
26719: LD_INT 0
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 2
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 2
26738: PUSH
26739: LD_INT 2
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 1
26748: PUSH
26749: LD_INT 2
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 0
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: LD_INT 1
26768: NEG
26769: PUSH
26770: LD_INT 1
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: LD_INT 0
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 2
26790: NEG
26791: PUSH
26792: LD_INT 1
26794: NEG
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 2
26802: NEG
26803: PUSH
26804: LD_INT 2
26806: NEG
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26833: NOP4
26837: PUSH
26838: LD_INT 0
26840: PUSH
26841: LD_INT 0
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 0
26850: PUSH
26851: LD_INT 1
26853: NEG
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 1
26861: PUSH
26862: LD_INT 0
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 1
26871: PUSH
26872: LD_INT 1
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_INT 0
26881: PUSH
26882: LD_INT 1
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 1
26891: NEG
26892: PUSH
26893: LD_INT 0
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 1
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 1
26914: NEG
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 0
26926: PUSH
26927: LD_INT 2
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 1
26937: PUSH
26938: LD_INT 1
26940: NEG
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 2
26948: PUSH
26949: LD_INT 0
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 2
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: PUSH
26969: LD_INT 2
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 1
26978: PUSH
26979: LD_INT 2
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 0
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: NEG
26999: PUSH
27000: LD_INT 1
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: LD_INT 0
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 2
27020: NEG
27021: PUSH
27022: LD_INT 1
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 2
27032: NEG
27033: PUSH
27034: LD_INT 2
27036: NEG
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 2
27044: NEG
27045: PUSH
27046: LD_INT 3
27048: NEG
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 1
27056: NEG
27057: PUSH
27058: LD_INT 3
27060: NEG
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 2
27071: NEG
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: LD_INT 2
27079: PUSH
27080: LD_INT 1
27082: NEG
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: LIST
27112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27113: NOP4
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: LD_INT 0
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 0
27130: PUSH
27131: LD_INT 1
27133: NEG
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 1
27141: PUSH
27142: LD_INT 0
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PUSH
27149: LD_INT 1
27151: PUSH
27152: LD_INT 1
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PUSH
27159: LD_INT 0
27161: PUSH
27162: LD_INT 1
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: NEG
27172: PUSH
27173: LD_INT 0
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 1
27182: NEG
27183: PUSH
27184: LD_INT 1
27186: NEG
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 1
27194: NEG
27195: PUSH
27196: LD_INT 2
27198: NEG
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: PUSH
27204: LD_INT 0
27206: PUSH
27207: LD_INT 2
27209: NEG
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: LD_INT 1
27217: PUSH
27218: LD_INT 1
27220: NEG
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 2
27228: PUSH
27229: LD_INT 0
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 2
27238: PUSH
27239: LD_INT 1
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 2
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 0
27268: PUSH
27269: LD_INT 2
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 1
27278: NEG
27279: PUSH
27280: LD_INT 1
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 2
27289: NEG
27290: PUSH
27291: LD_INT 0
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: LD_INT 2
27300: NEG
27301: PUSH
27302: LD_INT 1
27304: NEG
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PUSH
27310: LD_INT 2
27312: NEG
27313: PUSH
27314: LD_INT 2
27316: NEG
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: PUSH
27322: LD_INT 1
27324: PUSH
27325: LD_INT 2
27327: NEG
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PUSH
27333: LD_INT 2
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 3
27346: PUSH
27347: LD_INT 1
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 3
27356: PUSH
27357: LD_INT 2
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27389: NOP4
27393: PUSH
27394: LD_INT 0
27396: PUSH
27397: LD_INT 0
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 0
27406: PUSH
27407: LD_INT 1
27409: NEG
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 1
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 1
27427: PUSH
27428: LD_INT 1
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: LD_INT 0
27437: PUSH
27438: LD_INT 1
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 1
27447: NEG
27448: PUSH
27449: LD_INT 0
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 1
27458: NEG
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 1
27470: NEG
27471: PUSH
27472: LD_INT 2
27474: NEG
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 0
27482: PUSH
27483: LD_INT 2
27485: NEG
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PUSH
27491: LD_INT 1
27493: PUSH
27494: LD_INT 1
27496: NEG
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 2
27504: PUSH
27505: LD_INT 0
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 2
27514: PUSH
27515: LD_INT 1
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 2
27524: PUSH
27525: LD_INT 2
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: PUSH
27532: LD_INT 1
27534: PUSH
27535: LD_INT 2
27537: PUSH
27538: EMPTY
27539: LIST
27540: LIST
27541: PUSH
27542: LD_INT 0
27544: PUSH
27545: LD_INT 2
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PUSH
27552: LD_INT 1
27554: NEG
27555: PUSH
27556: LD_INT 1
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 2
27565: NEG
27566: PUSH
27567: LD_INT 0
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: LD_INT 1
27580: NEG
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: LD_INT 2
27588: NEG
27589: PUSH
27590: LD_INT 2
27592: NEG
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 3
27600: PUSH
27601: LD_INT 1
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 3
27610: PUSH
27611: LD_INT 2
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 2
27620: PUSH
27621: LD_INT 3
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: LIST
27659: LIST
27660: LIST
27661: LIST
27662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27663: NOP4
27667: PUSH
27668: LD_INT 0
27670: PUSH
27671: LD_INT 0
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PUSH
27678: LD_INT 0
27680: PUSH
27681: LD_INT 1
27683: NEG
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: LD_INT 1
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 1
27701: PUSH
27702: LD_INT 1
27704: PUSH
27705: EMPTY
27706: LIST
27707: LIST
27708: PUSH
27709: LD_INT 0
27711: PUSH
27712: LD_INT 1
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 1
27721: NEG
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 1
27744: NEG
27745: PUSH
27746: LD_INT 2
27748: NEG
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 0
27756: PUSH
27757: LD_INT 2
27759: NEG
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: PUSH
27765: LD_INT 1
27767: PUSH
27768: LD_INT 1
27770: NEG
27771: PUSH
27772: EMPTY
27773: LIST
27774: LIST
27775: PUSH
27776: LD_INT 2
27778: PUSH
27779: LD_INT 0
27781: PUSH
27782: EMPTY
27783: LIST
27784: LIST
27785: PUSH
27786: LD_INT 2
27788: PUSH
27789: LD_INT 1
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 2
27798: PUSH
27799: LD_INT 2
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 1
27808: PUSH
27809: LD_INT 2
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: LD_INT 0
27818: PUSH
27819: LD_INT 2
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: LD_INT 1
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 2
27839: NEG
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: NEG
27851: PUSH
27852: LD_INT 1
27854: NEG
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 2
27862: NEG
27863: PUSH
27864: LD_INT 2
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 2
27874: PUSH
27875: LD_INT 3
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: LD_INT 3
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 1
27894: NEG
27895: PUSH
27896: LD_INT 2
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 2
27905: NEG
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27939: NOP4
27943: PUSH
27944: LD_INT 0
27946: PUSH
27947: LD_INT 0
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PUSH
27954: LD_INT 0
27956: PUSH
27957: LD_INT 1
27959: NEG
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 1
27967: PUSH
27968: LD_INT 0
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: LD_INT 1
27977: PUSH
27978: LD_INT 1
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 0
27987: PUSH
27988: LD_INT 1
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: LD_INT 0
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 1
28008: NEG
28009: PUSH
28010: LD_INT 1
28012: NEG
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 1
28020: NEG
28021: PUSH
28022: LD_INT 2
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 0
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 1
28043: PUSH
28044: LD_INT 1
28046: NEG
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 2
28054: PUSH
28055: LD_INT 0
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 2
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 2
28074: PUSH
28075: LD_INT 2
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: LD_INT 2
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 0
28094: PUSH
28095: LD_INT 2
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: NEG
28105: PUSH
28106: LD_INT 1
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: LD_INT 2
28115: NEG
28116: PUSH
28117: LD_INT 0
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: LD_INT 2
28126: NEG
28127: PUSH
28128: LD_INT 1
28130: NEG
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 2
28138: NEG
28139: PUSH
28140: LD_INT 2
28142: NEG
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: LD_INT 2
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 2
28161: NEG
28162: PUSH
28163: LD_INT 1
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PUSH
28170: LD_INT 3
28172: NEG
28173: PUSH
28174: LD_INT 1
28176: NEG
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 2
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28219: NOP4
28223: PUSH
28224: LD_INT 0
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: LD_INT 1
28239: NEG
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PUSH
28245: LD_INT 1
28247: PUSH
28248: LD_INT 0
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 1
28257: PUSH
28258: LD_INT 1
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: LD_INT 1
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 1
28277: NEG
28278: PUSH
28279: LD_INT 0
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 1
28288: NEG
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 1
28300: NEG
28301: PUSH
28302: LD_INT 2
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 0
28312: PUSH
28313: LD_INT 2
28315: NEG
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 1
28323: PUSH
28324: LD_INT 1
28326: NEG
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 2
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: EMPTY
28339: LIST
28340: LIST
28341: PUSH
28342: LD_INT 2
28344: PUSH
28345: LD_INT 1
28347: PUSH
28348: EMPTY
28349: LIST
28350: LIST
28351: PUSH
28352: LD_INT 2
28354: PUSH
28355: LD_INT 2
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: LD_INT 2
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 0
28374: PUSH
28375: LD_INT 2
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: LD_INT 1
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: LD_INT 2
28395: NEG
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 2
28406: NEG
28407: PUSH
28408: LD_INT 1
28410: NEG
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 2
28418: NEG
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: LD_INT 3
28434: NEG
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 1
28442: NEG
28443: PUSH
28444: LD_INT 3
28446: NEG
28447: PUSH
28448: EMPTY
28449: LIST
28450: LIST
28451: PUSH
28452: LD_INT 3
28454: NEG
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 3
28466: NEG
28467: PUSH
28468: LD_INT 2
28470: NEG
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: LIST
28495: LIST
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28501: NOP4
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 0
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: PUSH
28516: LD_INT 0
28518: PUSH
28519: LD_INT 1
28521: NEG
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 1
28529: PUSH
28530: LD_INT 0
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: LD_INT 1
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PUSH
28547: LD_INT 0
28549: PUSH
28550: LD_INT 1
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 0
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 1
28570: NEG
28571: PUSH
28572: LD_INT 1
28574: NEG
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: NEG
28583: PUSH
28584: LD_INT 2
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 2
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 1
28608: NEG
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: LD_INT 2
28616: PUSH
28617: LD_INT 0
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 2
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 0
28646: PUSH
28647: LD_INT 2
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 1
28671: NEG
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: NEG
28692: PUSH
28693: LD_INT 3
28695: NEG
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 2
28703: PUSH
28704: LD_INT 1
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 3
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 1
28724: PUSH
28725: LD_INT 3
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 2
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: LD_INT 3
28745: NEG
28746: PUSH
28747: LD_INT 2
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28780: NOP4
28784: PUSH
28785: LD_INT 0
28787: PUSH
28788: LD_INT 0
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: LD_INT 1
28800: NEG
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 0
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: LD_INT 1
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 0
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: NEG
28839: PUSH
28840: LD_INT 0
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: NEG
28850: PUSH
28851: LD_INT 1
28853: NEG
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 1
28861: NEG
28862: PUSH
28863: LD_INT 2
28865: NEG
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 2
28876: NEG
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 2
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 1
28925: PUSH
28926: LD_INT 2
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: LD_INT 2
28946: NEG
28947: PUSH
28948: LD_INT 0
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 2
28957: NEG
28958: PUSH
28959: LD_INT 1
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 1
28969: NEG
28970: PUSH
28971: LD_INT 3
28973: NEG
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 1
28981: PUSH
28982: LD_INT 2
28984: NEG
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 3
28992: PUSH
28993: LD_INT 2
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: LD_INT 3
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 2
29012: NEG
29013: PUSH
29014: LD_INT 1
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 3
29023: NEG
29024: PUSH
29025: LD_INT 1
29027: NEG
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29058: NOP4
29062: PUSH
29063: LD_INT 0
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 0
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 1
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 1
29096: PUSH
29097: LD_INT 1
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: LD_INT 1
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: LD_INT 0
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: LD_INT 1
29131: NEG
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: NEG
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: EMPTY
29146: LIST
29147: LIST
29148: PUSH
29149: LD_INT 1
29151: PUSH
29152: LD_INT 1
29154: NEG
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: LD_INT 0
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: LD_INT 1
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 2
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 1
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 0
29202: PUSH
29203: LD_INT 2
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 1
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 2
29223: NEG
29224: PUSH
29225: LD_INT 1
29227: NEG
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 2
29235: NEG
29236: PUSH
29237: LD_INT 2
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 2
29247: NEG
29248: PUSH
29249: LD_INT 3
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 2
29259: PUSH
29260: LD_INT 1
29262: NEG
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 3
29270: PUSH
29271: LD_INT 1
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: LD_INT 3
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: LD_INT 2
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 3
29301: NEG
29302: PUSH
29303: LD_INT 2
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29336: NOP4
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: LD_INT 0
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 0
29353: PUSH
29354: LD_INT 1
29356: NEG
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 0
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: LD_INT 1
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: LD_INT 1
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: LD_INT 0
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: NEG
29406: PUSH
29407: LD_INT 1
29409: NEG
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 1
29417: NEG
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 0
29429: PUSH
29430: LD_INT 2
29432: NEG
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 1
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PUSH
29449: LD_INT 2
29451: PUSH
29452: LD_INT 1
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 2
29461: PUSH
29462: LD_INT 2
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 2
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 1
29525: NEG
29526: PUSH
29527: LD_INT 3
29529: NEG
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: LD_INT 2
29540: NEG
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 3
29548: PUSH
29549: LD_INT 2
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 3
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: NEG
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 3
29579: NEG
29580: PUSH
29581: LD_INT 1
29583: NEG
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29614: NOP4
29618: PUSH
29619: LD_INT 0
29621: PUSH
29622: LD_INT 0
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 1
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: LD_INT 1
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: LD_INT 1
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: LD_INT 0
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 1
29683: NEG
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: NEG
29696: PUSH
29697: LD_INT 2
29699: NEG
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: PUSH
29705: LD_INT 1
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 2
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: LD_INT 2
29728: PUSH
29729: LD_INT 1
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 1
29738: PUSH
29739: LD_INT 2
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 2
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: LD_INT 1
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 2
29769: NEG
29770: PUSH
29771: LD_INT 0
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 2
29780: NEG
29781: PUSH
29782: LD_INT 1
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 2
29792: NEG
29793: PUSH
29794: LD_INT 2
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: LD_INT 3
29808: NEG
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: LD_INT 2
29816: PUSH
29817: LD_INT 1
29819: NEG
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 3
29827: PUSH
29828: LD_INT 1
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 1
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: LD_INT 2
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 3
29858: NEG
29859: PUSH
29860: LD_INT 2
29862: NEG
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29893: NOP4
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: LD_INT 0
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 1
29921: PUSH
29922: LD_INT 0
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 1
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 0
29941: PUSH
29942: LD_INT 1
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 1
29974: NEG
29975: PUSH
29976: LD_INT 2
29978: NEG
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 2
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 1
29997: PUSH
29998: LD_INT 1
30000: NEG
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 2
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 1
30028: PUSH
30029: LD_INT 2
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 1
30038: NEG
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 2
30049: NEG
30050: PUSH
30051: LD_INT 0
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 2
30060: NEG
30061: PUSH
30062: LD_INT 1
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 2
30072: NEG
30073: PUSH
30074: LD_INT 2
30076: NEG
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 1
30084: NEG
30085: PUSH
30086: LD_INT 3
30088: NEG
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 2
30099: NEG
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: LD_INT 3
30107: PUSH
30108: LD_INT 2
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 2
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 2
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 3
30138: NEG
30139: PUSH
30140: LD_INT 1
30142: NEG
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30173: NOP4
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: LD_INT 0
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 0
30190: PUSH
30191: LD_INT 1
30193: NEG
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: PUSH
30202: LD_INT 0
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: LD_INT 1
30211: PUSH
30212: LD_INT 1
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 1
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 1
30231: NEG
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: NEG
30243: PUSH
30244: LD_INT 1
30246: NEG
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 2
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30285: NOP4
30289: PUSH
30290: LD_INT 0
30292: PUSH
30293: LD_INT 0
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 0
30302: PUSH
30303: LD_INT 1
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 1
30323: PUSH
30324: LD_INT 1
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 0
30333: PUSH
30334: LD_INT 1
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: NEG
30367: PUSH
30368: LD_INT 2
30370: NEG
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30397: NOP4
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 0
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: LD_INT 0
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: LD_INT 1
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: LD_INT 0
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 1
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30509: NOP4
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 0
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: LD_INT 1
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 0
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 1
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: LD_INT 0
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 1
30578: NEG
30579: PUSH
30580: LD_INT 1
30582: NEG
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 2
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 2
30600: NEG
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30621: NOP4
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: LD_INT 1
30641: NEG
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: LD_INT 0
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 1
30659: PUSH
30660: LD_INT 1
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 1
30679: NEG
30680: PUSH
30681: LD_INT 0
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 1
30694: NEG
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 1
30702: NEG
30703: PUSH
30704: LD_INT 2
30706: NEG
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: LD_INT 2
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30733: NOP4
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 0
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: LD_INT 1
30753: NEG
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: PUSH
30772: LD_INT 1
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 1
30791: NEG
30792: PUSH
30793: LD_INT 0
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 1
30802: NEG
30803: PUSH
30804: LD_INT 1
30806: NEG
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: LD_INT 1
30817: NEG
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 1
30825: NEG
30826: PUSH
30827: LD_INT 1
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: LIST
30844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30845: NOP4
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 0
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 1
30865: NEG
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: LD_INT 1
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 1
30903: NEG
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: NEG
30927: PUSH
30928: LD_INT 2
30930: NEG
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: PUSH
30939: LD_INT 1
30941: NEG
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 2
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 2
30959: PUSH
30960: LD_INT 1
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 2
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: NEG
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: LD_INT 2
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 2
31035: NEG
31036: PUSH
31037: LD_INT 3
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 2
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 3
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 3
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 3
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 3
31088: PUSH
31089: LD_INT 3
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 2
31098: PUSH
31099: LD_INT 3
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 2
31108: NEG
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 3
31119: NEG
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 3
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 3
31142: NEG
31143: PUSH
31144: LD_INT 2
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 3
31154: NEG
31155: PUSH
31156: LD_INT 3
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31195: NOP4
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 0
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: PUSH
31221: LD_INT 1
31223: PUSH
31224: LD_INT 0
31226: PUSH
31227: EMPTY
31228: LIST
31229: LIST
31230: PUSH
31231: LD_INT 1
31233: PUSH
31234: LD_INT 1
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: LD_INT 0
31243: PUSH
31244: LD_INT 1
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: LD_INT 0
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 0
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 1
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 2
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 2
31320: PUSH
31321: LD_INT 2
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: LD_INT 2
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: LD_INT 2
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 1
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 2
31361: NEG
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 2
31373: NEG
31374: PUSH
31375: LD_INT 2
31377: NEG
31378: PUSH
31379: EMPTY
31380: LIST
31381: LIST
31382: PUSH
31383: LD_INT 2
31385: NEG
31386: PUSH
31387: LD_INT 3
31389: NEG
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 1
31397: NEG
31398: PUSH
31399: LD_INT 3
31401: NEG
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 3
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 2
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 3
31431: PUSH
31432: LD_INT 2
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 3
31441: PUSH
31442: LD_INT 3
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 2
31451: PUSH
31452: LD_INT 3
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: PUSH
31462: LD_INT 3
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 3
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: LD_INT 2
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 3
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 3
31504: NEG
31505: PUSH
31506: LD_INT 3
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31545: NOP4
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 0
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 1
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 2
31630: NEG
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 2
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 1
31652: NEG
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: LD_INT 2
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: LD_INT 2
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 0
31690: PUSH
31691: LD_INT 2
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 2
31711: NEG
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 2
31722: NEG
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: LD_INT 3
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: LD_INT 3
31749: NEG
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: LD_INT 1
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 3
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 3
31789: PUSH
31790: LD_INT 1
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: PUSH
31800: LD_INT 3
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 0
31809: PUSH
31810: LD_INT 3
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: LD_INT 2
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 2
31830: NEG
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 3
31841: NEG
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 3
31852: NEG
31853: PUSH
31854: LD_INT 1
31856: NEG
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31893: NOP4
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: LD_INT 0
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 1
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 1
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 1
31951: NEG
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 1
31974: NEG
31975: PUSH
31976: LD_INT 2
31978: NEG
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 2
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 2
32017: PUSH
32018: LD_INT 2
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 1
32027: PUSH
32028: LD_INT 2
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: LD_INT 1
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: LD_INT 1
32063: NEG
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 2
32071: NEG
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: NEG
32084: PUSH
32085: LD_INT 3
32087: NEG
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 3
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 3
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 3
32126: PUSH
32127: LD_INT 2
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 3
32136: PUSH
32137: LD_INT 3
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: PUSH
32147: LD_INT 3
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: NEG
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 3
32167: NEG
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 3
32178: NEG
32179: PUSH
32180: LD_INT 1
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 3
32190: NEG
32191: PUSH
32192: LD_INT 2
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 3
32202: NEG
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32243: NOP4
32247: PUSH
32248: LD_INT 0
32250: PUSH
32251: LD_INT 0
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: LD_INT 1
32263: NEG
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: PUSH
32282: LD_INT 1
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 0
32291: PUSH
32292: LD_INT 1
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 1
32301: NEG
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 1
32312: NEG
32313: PUSH
32314: LD_INT 1
32316: NEG
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: LD_INT 2
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: LD_INT 2
32339: NEG
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 2
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: LD_INT 2
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: LD_INT 2
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: LD_INT 1
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 2
32409: NEG
32410: PUSH
32411: LD_INT 1
32413: NEG
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 2
32421: NEG
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 2
32433: NEG
32434: PUSH
32435: LD_INT 3
32437: NEG
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: LD_INT 3
32449: NEG
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 3
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 3
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 3
32489: PUSH
32490: LD_INT 3
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: LD_INT 3
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 3
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 3
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 1
32529: NEG
32530: PUSH
32531: LD_INT 2
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 3
32540: NEG
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 3
32552: NEG
32553: PUSH
32554: LD_INT 3
32556: NEG
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32593: NOP4
32597: PUSH
32598: LD_INT 0
32600: PUSH
32601: LD_INT 0
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 1
32631: PUSH
32632: LD_INT 1
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: LD_INT 1
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 1
32651: NEG
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 1
32662: NEG
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 2
32678: NEG
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: LD_INT 2
32689: NEG
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 0
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 2
32718: PUSH
32719: LD_INT 1
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: PUSH
32729: LD_INT 2
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 1
32748: NEG
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 2
32759: NEG
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: NEG
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 3
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: LD_INT 3
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: LD_INT 2
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 2
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 3
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 3
32837: PUSH
32838: LD_INT 1
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 1
32847: PUSH
32848: LD_INT 3
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 0
32857: PUSH
32858: LD_INT 3
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: LD_INT 2
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 3
32889: NEG
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 3
32900: NEG
32901: PUSH
32902: LD_INT 1
32904: NEG
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32941: NOP4
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 2
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: NEG
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 2
33068: NEG
33069: PUSH
33070: LD_INT 2
33072: NEG
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33092: NOP4
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: PUSH
33131: LD_INT 1
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 0
33140: PUSH
33141: LD_INT 1
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 1
33150: NEG
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: NEG
33174: PUSH
33175: LD_INT 2
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 2
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33239: NOP4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 0
33256: PUSH
33257: LD_INT 1
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: LD_INT 0
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 1
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 0
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 1
33308: NEG
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 2
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: LD_INT 2
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 2
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33383: NOP4
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: LD_INT 0
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: LD_INT 0
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 1
33421: PUSH
33422: LD_INT 1
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 0
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: LD_INT 0
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: LD_INT 1
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 2
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: PUSH
33472: LD_INT 2
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: LD_INT 2
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 2
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 1
33504: NEG
33505: PUSH
33506: LD_INT 1
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: LIST
33525: LIST
33526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33527: NOP4
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 0
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: LD_INT 0
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: NEG
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 1
33596: NEG
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 0
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 1
33628: NEG
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 2
33650: NEG
33651: PUSH
33652: LD_INT 1
33654: NEG
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33674: NOP4
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 0
33691: PUSH
33692: LD_INT 1
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 1
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: LD_INT 1
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 1
33743: NEG
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 1
33755: NEG
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: NEG
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: LD_INT 2
33778: NEG
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: LD_INT 1
33793: NEG
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 2
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33825: NOP4
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: LD_INT 2
33921: NEG
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 1
33932: NEG
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 2
33940: PUSH
33941: LD_INT 0
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 2
33960: PUSH
33961: LD_INT 2
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 0
33980: PUSH
33981: LD_INT 2
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 2
34001: NEG
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 2
34012: NEG
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 2
34024: NEG
34025: PUSH
34026: LD_INT 2
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34055: NOP4
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 1
34113: NEG
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 0
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 2
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 2
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 2
34231: NEG
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 2
34242: NEG
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34285: NOP4
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 0
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 2
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: LD_INT 2
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 2
34461: NEG
34462: PUSH
34463: LD_INT 0
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 2
34472: NEG
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 2
34484: NEG
34485: PUSH
34486: LD_INT 2
34488: NEG
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34515: NOP4
34519: PUSH
34520: LD_INT 0
34522: PUSH
34523: LD_INT 0
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: LD_INT 1
34535: NEG
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 1
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 1
34553: PUSH
34554: LD_INT 1
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: LD_INT 1
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 1
34573: NEG
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 2
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: LD_INT 2
34611: NEG
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 1
34619: PUSH
34620: LD_INT 1
34622: NEG
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: LD_INT 0
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 2
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 2
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 2
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 2
34714: NEG
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34745: NOP4
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 0
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: LD_INT 1
34765: NEG
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 1
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 0
34793: PUSH
34794: LD_INT 1
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 0
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 1
34814: NEG
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: NEG
34827: PUSH
34828: LD_INT 2
34830: NEG
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 0
34838: PUSH
34839: LD_INT 2
34841: NEG
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 1
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 0
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 2
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 2
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: LD_INT 2
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: LD_INT 2
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 1
34910: NEG
34911: PUSH
34912: LD_INT 1
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 0
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 2
34932: NEG
34933: PUSH
34934: LD_INT 1
34936: NEG
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 2
34944: NEG
34945: PUSH
34946: LD_INT 2
34948: NEG
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34975: NOP4
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: LD_INT 0
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 1
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: LD_INT 1
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 0
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 0
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 1
35044: NEG
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 1
35056: NEG
35057: PUSH
35058: LD_INT 2
35060: NEG
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 0
35068: PUSH
35069: LD_INT 2
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 2
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 2
35110: PUSH
35111: LD_INT 2
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 0
35130: PUSH
35131: LD_INT 2
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: LD_INT 0
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 2
35162: NEG
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: LD_INT 2
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35205: NOP4
35209: PUSH
35210: LD_INT 0
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: LD_INT 0
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 1
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 0
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 1
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35293: NOP4
35297: PUSH
35298: LD_INT 0
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 0
35310: PUSH
35311: LD_INT 1
35313: NEG
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 1
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 0
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: LD_INT 0
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: NEG
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35381: NOP4
35385: PUSH
35386: LD_INT 0
35388: PUSH
35389: LD_INT 0
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: LD_INT 1
35401: NEG
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 1
35419: PUSH
35420: LD_INT 1
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 0
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35469: NOP4
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 0
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35557: NOP4
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: LD_INT 0
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: LD_INT 0
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: NEG
35627: PUSH
35628: LD_INT 1
35630: NEG
35631: PUSH
35632: EMPTY
35633: LIST
35634: LIST
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35645: NOP4
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: ST_TO_ADDR
// end ; 1 :
35733: GO 41630
35735: LD_INT 1
35737: DOUBLE
35738: EQUAL
35739: IFTRUE 35743
35741: GO 38366
35743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35744: NOP4
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 3
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 3
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: LIST
35787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35788: NOP4
35792: PUSH
35793: LD_INT 2
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 3
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 3
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: LIST
35828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35829: NOP4
35833: PUSH
35834: LD_INT 3
35836: PUSH
35837: LD_INT 2
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 3
35846: PUSH
35847: LD_INT 3
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: LD_INT 3
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: LIST
35868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35869: NOP4
35873: PUSH
35874: LD_INT 1
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: LD_INT 3
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: LD_INT 2
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: LIST
35909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35910: NOP4
35914: PUSH
35915: LD_INT 2
35917: NEG
35918: PUSH
35919: LD_INT 1
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 3
35928: NEG
35929: PUSH
35930: LD_INT 0
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 3
35939: NEG
35940: PUSH
35941: LD_INT 1
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: LIST
35953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35954: NOP4
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 3
35973: NEG
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 3
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: LIST
35999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36000: NOP4
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 3
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 0
36019: PUSH
36020: LD_INT 3
36022: NEG
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 1
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: LIST
36043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36044: NOP4
36048: PUSH
36049: LD_INT 2
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 3
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36085: NOP4
36089: PUSH
36090: LD_INT 3
36092: PUSH
36093: LD_INT 2
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 3
36102: PUSH
36103: LD_INT 3
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 2
36112: PUSH
36113: LD_INT 3
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: LIST
36124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36125: NOP4
36129: PUSH
36130: LD_INT 1
36132: PUSH
36133: LD_INT 3
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 0
36142: PUSH
36143: LD_INT 3
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 1
36152: NEG
36153: PUSH
36154: LD_INT 2
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: LIST
36165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36166: NOP4
36170: PUSH
36171: LD_INT 2
36173: NEG
36174: PUSH
36175: LD_INT 1
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 3
36184: NEG
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 3
36195: NEG
36196: PUSH
36197: LD_INT 1
36199: NEG
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: LIST
36209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36210: NOP4
36214: PUSH
36215: LD_INT 2
36217: NEG
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 3
36229: NEG
36230: PUSH
36231: LD_INT 2
36233: NEG
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 3
36241: NEG
36242: PUSH
36243: LD_INT 3
36245: NEG
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: LIST
36255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36256: NOP4
36260: PUSH
36261: LD_INT 0
36263: PUSH
36264: LD_INT 3
36266: NEG
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 4
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 3
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: LIST
36299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36300: NOP4
36304: PUSH
36305: LD_INT 3
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 3
36317: PUSH
36318: LD_INT 1
36320: NEG
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 4
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: LIST
36340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36341: NOP4
36345: PUSH
36346: LD_INT 3
36348: PUSH
36349: LD_INT 3
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 4
36358: PUSH
36359: LD_INT 3
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 3
36368: PUSH
36369: LD_INT 4
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36381: NOP4
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 3
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 1
36398: PUSH
36399: LD_INT 4
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: LD_INT 3
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36422: NOP4
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 4
36451: NEG
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: LIST
36465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36466: NOP4
36470: PUSH
36471: LD_INT 3
36473: NEG
36474: PUSH
36475: LD_INT 3
36477: NEG
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 3
36485: NEG
36486: PUSH
36487: LD_INT 4
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 4
36497: NEG
36498: PUSH
36499: LD_INT 3
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: LIST
36511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36512: NOP4
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: LD_INT 3
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: LD_INT 3
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: PUSH
36543: LD_INT 2
36545: NEG
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: LD_INT 4
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 4
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: LD_INT 3
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: LD_INT 5
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 5
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 4
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: LD_INT 6
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: LD_INT 6
36636: NEG
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: PUSH
36645: LD_INT 5
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36667: NOP4
36671: PUSH
36672: LD_INT 2
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 3
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 3
36695: PUSH
36696: LD_INT 1
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 3
36705: PUSH
36706: LD_INT 1
36708: NEG
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 4
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 4
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 4
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 5
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 5
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 6
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 6
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: LIST
36805: LIST
36806: LIST
36807: LIST
36808: LIST
36809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36810: NOP4
36814: PUSH
36815: LD_INT 3
36817: PUSH
36818: LD_INT 2
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 3
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 2
36837: PUSH
36838: LD_INT 3
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: LD_INT 3
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 4
36857: PUSH
36858: LD_INT 4
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 3
36867: PUSH
36868: LD_INT 4
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 5
36877: PUSH
36878: LD_INT 4
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 5
36887: PUSH
36888: LD_INT 5
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 4
36897: PUSH
36898: LD_INT 5
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 6
36907: PUSH
36908: LD_INT 5
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 6
36917: PUSH
36918: LD_INT 6
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 5
36927: PUSH
36928: LD_INT 6
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36949: NOP4
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: LD_INT 3
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 0
36966: PUSH
36967: LD_INT 3
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: NEG
36977: PUSH
36978: LD_INT 2
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 4
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 0
36997: PUSH
36998: LD_INT 4
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: LD_INT 5
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: LD_INT 5
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: LD_INT 4
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 6
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: LD_INT 6
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: LD_INT 5
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37092: NOP4
37096: PUSH
37097: LD_INT 2
37099: NEG
37100: PUSH
37101: LD_INT 1
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 3
37110: NEG
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 3
37133: NEG
37134: PUSH
37135: LD_INT 1
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 4
37144: NEG
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 4
37155: NEG
37156: PUSH
37157: LD_INT 1
37159: NEG
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 4
37167: NEG
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 5
37178: NEG
37179: PUSH
37180: LD_INT 0
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 5
37189: NEG
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 5
37201: NEG
37202: PUSH
37203: LD_INT 1
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 6
37212: NEG
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 6
37223: NEG
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37247: NOP4
37251: PUSH
37252: LD_INT 2
37254: NEG
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 3
37278: NEG
37279: PUSH
37280: LD_INT 3
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 3
37290: NEG
37291: PUSH
37292: LD_INT 4
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 4
37302: NEG
37303: PUSH
37304: LD_INT 3
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 4
37314: NEG
37315: PUSH
37316: LD_INT 4
37318: NEG
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 4
37326: NEG
37327: PUSH
37328: LD_INT 5
37330: NEG
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 5
37338: NEG
37339: PUSH
37340: LD_INT 4
37342: NEG
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 5
37350: NEG
37351: PUSH
37352: LD_INT 5
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 5
37362: NEG
37363: PUSH
37364: LD_INT 6
37366: NEG
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 6
37374: NEG
37375: PUSH
37376: LD_INT 5
37378: NEG
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 6
37386: NEG
37387: PUSH
37388: LD_INT 6
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37410: NOP4
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 1
37428: NEG
37429: PUSH
37430: LD_INT 3
37432: NEG
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 1
37440: PUSH
37441: LD_INT 2
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: LIST
37453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37454: NOP4
37458: PUSH
37459: LD_INT 2
37461: PUSH
37462: LD_INT 0
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 2
37471: PUSH
37472: LD_INT 1
37474: NEG
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 3
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37495: NOP4
37499: PUSH
37500: LD_INT 2
37502: PUSH
37503: LD_INT 2
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 3
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 2
37522: PUSH
37523: LD_INT 3
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37535: NOP4
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: LD_INT 2
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: LD_INT 3
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: LD_INT 2
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37576: NOP4
37580: PUSH
37581: LD_INT 2
37583: NEG
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 2
37594: NEG
37595: PUSH
37596: LD_INT 1
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 3
37605: NEG
37606: PUSH
37607: LD_INT 1
37609: NEG
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: LIST
37619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37620: NOP4
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: LD_INT 2
37631: NEG
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 2
37639: NEG
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 3
37651: NEG
37652: PUSH
37653: LD_INT 2
37655: NEG
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: LIST
37665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37666: NOP4
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: LD_INT 3
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 3
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37699: NOP4
37703: PUSH
37704: LD_INT 1
37706: PUSH
37707: LD_INT 2
37709: NEG
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 2
37717: PUSH
37718: LD_INT 1
37720: NEG
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37730: NOP4
37734: PUSH
37735: LD_INT 3
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37759: NOP4
37763: PUSH
37764: LD_INT 2
37766: PUSH
37767: LD_INT 3
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 1
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37788: NOP4
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: LD_INT 2
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: LD_INT 1
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37819: NOP4
37823: PUSH
37824: LD_INT 3
37826: NEG
37827: PUSH
37828: LD_INT 1
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 3
37838: NEG
37839: PUSH
37840: LD_INT 2
37842: NEG
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37852: NOP4
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: LD_INT 3
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 0
37871: PUSH
37872: LD_INT 3
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: LIST
37895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37896: NOP4
37900: PUSH
37901: LD_INT 2
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 3
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: LD_INT 1
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37937: NOP4
37941: PUSH
37942: LD_INT 3
37944: PUSH
37945: LD_INT 2
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 2
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: LIST
37976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37977: NOP4
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: LD_INT 3
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 0
37994: PUSH
37995: LD_INT 3
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: LIST
38017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38018: NOP4
38022: PUSH
38023: LD_INT 2
38025: NEG
38026: PUSH
38027: LD_INT 1
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 3
38036: NEG
38037: PUSH
38038: LD_INT 0
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 3
38047: NEG
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: LIST
38061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38062: NOP4
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: LD_INT 3
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 3
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 3
38093: NEG
38094: PUSH
38095: LD_INT 3
38097: NEG
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: LIST
38107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38108: NOP4
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: LD_INT 2
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: LIST
38151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38152: NOP4
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38193: NOP4
38197: PUSH
38198: LD_INT 2
38200: PUSH
38201: LD_INT 1
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 2
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: LD_INT 2
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: LIST
38232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38233: NOP4
38237: PUSH
38238: LD_INT 1
38240: PUSH
38241: LD_INT 2
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: LD_INT 2
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: LIST
38273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38274: NOP4
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 2
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 2
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: LIST
38317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38318: NOP4
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 2
38337: NEG
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: LD_INT 2
38353: NEG
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: LIST
38363: ST_TO_ADDR
// end ; 2 :
38364: GO 41630
38366: LD_INT 2
38368: DOUBLE
38369: EQUAL
38370: IFTRUE 38374
38372: GO 41629
38374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38375: NOP4
38379: PUSH
38380: LD_INT 4
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 1
38395: NEG
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 5
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 5
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 4
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 3
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 3
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 3
38454: PUSH
38455: LD_INT 2
38457: NEG
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 5
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 3
38475: PUSH
38476: LD_INT 3
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 3
38485: PUSH
38486: LD_INT 2
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 4
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 4
38505: PUSH
38506: LD_INT 4
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 3
38515: PUSH
38516: LD_INT 4
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 2
38525: PUSH
38526: LD_INT 3
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: PUSH
38536: LD_INT 2
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 4
38545: PUSH
38546: LD_INT 2
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 4
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: LD_INT 4
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 3
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: LD_INT 4
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: PUSH
38596: LD_INT 5
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 0
38605: PUSH
38606: LD_INT 5
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 1
38615: NEG
38616: PUSH
38617: LD_INT 4
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: LD_INT 3
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 2
38637: PUSH
38638: LD_INT 5
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: NEG
38648: PUSH
38649: LD_INT 3
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 3
38658: NEG
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 3
38669: NEG
38670: PUSH
38671: LD_INT 1
38673: NEG
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 3
38703: NEG
38704: PUSH
38705: LD_INT 1
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 4
38714: NEG
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 4
38725: NEG
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 4
38737: NEG
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 2
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 4
38760: NEG
38761: PUSH
38762: LD_INT 4
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 4
38772: NEG
38773: PUSH
38774: LD_INT 5
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 3
38784: NEG
38785: PUSH
38786: LD_INT 4
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 3
38796: NEG
38797: PUSH
38798: LD_INT 3
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 4
38808: NEG
38809: PUSH
38810: LD_INT 3
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 5
38820: NEG
38821: PUSH
38822: LD_INT 4
38824: NEG
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 5
38832: NEG
38833: PUSH
38834: LD_INT 5
38836: NEG
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 3
38844: NEG
38845: PUSH
38846: LD_INT 5
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 5
38856: NEG
38857: PUSH
38858: LD_INT 3
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38913: NOP4
38917: PUSH
38918: LD_INT 4
38920: PUSH
38921: LD_INT 4
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 4
38930: PUSH
38931: LD_INT 3
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 5
38940: PUSH
38941: LD_INT 4
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 5
38950: PUSH
38951: LD_INT 5
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 4
38960: PUSH
38961: LD_INT 5
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 3
38970: PUSH
38971: LD_INT 4
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 3
38980: PUSH
38981: LD_INT 3
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 5
38990: PUSH
38991: LD_INT 3
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: PUSH
39001: LD_INT 5
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 3
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 2
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 3
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: PUSH
39041: LD_INT 4
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: LD_INT 4
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 3
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: LD_INT 2
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 2
39082: PUSH
39083: LD_INT 4
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 2
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 4
39103: NEG
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 4
39114: NEG
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 3
39126: NEG
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 3
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 4
39148: NEG
39149: PUSH
39150: LD_INT 1
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 5
39159: NEG
39160: PUSH
39161: LD_INT 0
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 5
39170: NEG
39171: PUSH
39172: LD_INT 1
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 5
39182: NEG
39183: PUSH
39184: LD_INT 2
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: LD_INT 3
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 3
39217: NEG
39218: PUSH
39219: LD_INT 4
39221: NEG
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: LD_INT 3
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 2
39241: NEG
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: LD_INT 2
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 4
39265: NEG
39266: PUSH
39267: LD_INT 3
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 4
39277: NEG
39278: PUSH
39279: LD_INT 4
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 2
39289: NEG
39290: PUSH
39291: LD_INT 4
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: LD_INT 2
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: LD_INT 4
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 5
39327: NEG
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: LD_INT 4
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: LD_INT 3
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: LD_INT 3
39360: NEG
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 4
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: NEG
39381: PUSH
39382: LD_INT 5
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 2
39392: PUSH
39393: LD_INT 3
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 2
39403: NEG
39404: PUSH
39405: LD_INT 5
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39460: NOP4
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: LD_INT 4
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 0
39477: PUSH
39478: LD_INT 3
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: LD_INT 4
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: LD_INT 5
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: LD_INT 5
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: LD_INT 4
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 1
39528: NEG
39529: PUSH
39530: LD_INT 3
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: LD_INT 5
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: LD_INT 3
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 3
39560: NEG
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 1
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: NEG
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 2
39594: NEG
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 3
39605: NEG
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 4
39616: NEG
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 4
39627: NEG
39628: PUSH
39629: LD_INT 1
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 4
39639: NEG
39640: PUSH
39641: LD_INT 2
39643: NEG
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: LD_INT 2
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 4
39662: NEG
39663: PUSH
39664: LD_INT 4
39666: NEG
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 4
39674: NEG
39675: PUSH
39676: LD_INT 5
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 3
39686: NEG
39687: PUSH
39688: LD_INT 4
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 3
39698: NEG
39699: PUSH
39700: LD_INT 3
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 4
39710: NEG
39711: PUSH
39712: LD_INT 3
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 5
39722: NEG
39723: PUSH
39724: LD_INT 4
39726: NEG
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 5
39734: NEG
39735: PUSH
39736: LD_INT 5
39738: NEG
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 3
39746: NEG
39747: PUSH
39748: LD_INT 5
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 5
39758: NEG
39759: PUSH
39760: LD_INT 3
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: LD_INT 3
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 0
39781: PUSH
39782: LD_INT 4
39784: NEG
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 1
39792: PUSH
39793: LD_INT 3
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 0
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: NEG
39838: PUSH
39839: LD_INT 4
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 2
39860: NEG
39861: PUSH
39862: LD_INT 4
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 4
39872: PUSH
39873: LD_INT 0
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 4
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 5
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 5
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 4
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 3
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: LD_INT 1
39936: NEG
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 3
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 5
39955: PUSH
39956: LD_INT 2
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40010: NOP4
40014: PUSH
40015: LD_INT 4
40017: NEG
40018: PUSH
40019: LD_INT 0
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 4
40028: NEG
40029: PUSH
40030: LD_INT 1
40032: NEG
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 3
40040: NEG
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 3
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 1
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 5
40073: NEG
40074: PUSH
40075: LD_INT 0
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 5
40084: NEG
40085: PUSH
40086: LD_INT 1
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 5
40096: NEG
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 3
40108: NEG
40109: PUSH
40110: LD_INT 2
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: LD_INT 3
40123: NEG
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 3
40131: NEG
40132: PUSH
40133: LD_INT 4
40135: NEG
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 2
40155: NEG
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 3
40167: NEG
40168: PUSH
40169: LD_INT 2
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 4
40179: NEG
40180: PUSH
40181: LD_INT 3
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 4
40191: NEG
40192: PUSH
40193: LD_INT 4
40195: NEG
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 2
40203: NEG
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 4
40215: NEG
40216: PUSH
40217: LD_INT 2
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 0
40227: PUSH
40228: LD_INT 4
40230: NEG
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 5
40241: NEG
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: LD_INT 4
40252: NEG
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 1
40260: PUSH
40261: LD_INT 3
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 3
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: NEG
40283: PUSH
40284: LD_INT 4
40286: NEG
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: PUSH
40296: LD_INT 5
40298: NEG
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 2
40306: PUSH
40307: LD_INT 3
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 2
40317: NEG
40318: PUSH
40319: LD_INT 5
40321: NEG
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 3
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: PUSH
40340: LD_INT 1
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 4
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 4
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 2
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 2
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 2
40401: PUSH
40402: LD_INT 2
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: LD_INT 2
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 4
40422: PUSH
40423: LD_INT 4
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 4
40432: PUSH
40433: LD_INT 3
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 5
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 5
40452: PUSH
40453: LD_INT 5
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 4
40462: PUSH
40463: LD_INT 5
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 3
40472: PUSH
40473: LD_INT 4
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 3
40482: PUSH
40483: LD_INT 3
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 5
40492: PUSH
40493: LD_INT 3
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 3
40502: PUSH
40503: LD_INT 5
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40557: NOP4
40561: PUSH
40562: LD_INT 4
40564: NEG
40565: PUSH
40566: LD_INT 4
40568: NEG
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 4
40576: NEG
40577: PUSH
40578: LD_INT 5
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 3
40588: NEG
40589: PUSH
40590: LD_INT 4
40592: NEG
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 3
40600: NEG
40601: PUSH
40602: LD_INT 3
40604: NEG
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 4
40612: NEG
40613: PUSH
40614: LD_INT 3
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 5
40624: NEG
40625: PUSH
40626: LD_INT 4
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 5
40636: NEG
40637: PUSH
40638: LD_INT 5
40640: NEG
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 3
40648: NEG
40649: PUSH
40650: LD_INT 5
40652: NEG
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 5
40660: NEG
40661: PUSH
40662: LD_INT 3
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: LD_INT 3
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 0
40683: PUSH
40684: LD_INT 4
40686: NEG
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 1
40694: PUSH
40695: LD_INT 3
40697: NEG
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: LD_INT 4
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 2
40762: NEG
40763: PUSH
40764: LD_INT 4
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 4
40774: PUSH
40775: LD_INT 0
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 5
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 5
40805: PUSH
40806: LD_INT 1
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 4
40815: PUSH
40816: LD_INT 1
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 3
40825: PUSH
40826: LD_INT 0
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 3
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 3
40846: PUSH
40847: LD_INT 2
40849: NEG
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 5
40857: PUSH
40858: LD_INT 2
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 3
40867: PUSH
40868: LD_INT 3
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 4
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 4
40897: PUSH
40898: LD_INT 4
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 3
40907: PUSH
40908: LD_INT 4
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 2
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 2
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 4
40937: PUSH
40938: LD_INT 2
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 2
40947: PUSH
40948: LD_INT 4
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 4
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 0
40967: PUSH
40968: LD_INT 3
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 4
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: LD_INT 5
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 0
40997: PUSH
40998: LD_INT 5
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 1
41007: NEG
41008: PUSH
41009: LD_INT 4
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 2
41029: PUSH
41030: LD_INT 5
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 3
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41095: NOP4
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: LD_INT 4
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 0
41113: PUSH
41114: LD_INT 5
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: LD_INT 4
41127: NEG
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: LD_INT 3
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: LD_INT 3
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: LD_INT 4
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: LD_INT 5
41173: NEG
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 2
41181: PUSH
41182: LD_INT 3
41184: NEG
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 5
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 3
41204: PUSH
41205: LD_INT 0
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 3
41214: PUSH
41215: LD_INT 1
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 4
41225: PUSH
41226: LD_INT 0
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 4
41235: PUSH
41236: LD_INT 1
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 3
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 2
41255: PUSH
41256: LD_INT 0
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 2
41265: PUSH
41266: LD_INT 1
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 4
41297: PUSH
41298: LD_INT 4
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 4
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 5
41317: PUSH
41318: LD_INT 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 5
41327: PUSH
41328: LD_INT 5
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: PUSH
41335: LD_INT 4
41337: PUSH
41338: LD_INT 5
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 3
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 3
41357: PUSH
41358: LD_INT 3
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 5
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 3
41377: PUSH
41378: LD_INT 5
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 3
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 0
41397: PUSH
41398: LD_INT 2
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 1
41407: PUSH
41408: LD_INT 3
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: LD_INT 4
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 0
41427: PUSH
41428: LD_INT 4
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 1
41437: NEG
41438: PUSH
41439: LD_INT 3
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 1
41448: NEG
41449: PUSH
41450: LD_INT 2
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 2
41469: NEG
41470: PUSH
41471: LD_INT 2
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 4
41480: NEG
41481: PUSH
41482: LD_INT 0
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 4
41491: NEG
41492: PUSH
41493: LD_INT 1
41495: NEG
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 3
41503: NEG
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: LD_INT 1
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 4
41525: NEG
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 5
41536: NEG
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 5
41547: NEG
41548: PUSH
41549: LD_INT 1
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 5
41559: NEG
41560: PUSH
41561: LD_INT 2
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 3
41571: NEG
41572: PUSH
41573: LD_INT 2
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: LIST
41623: LIST
41624: LIST
41625: LIST
41626: ST_TO_ADDR
// end ; end ;
41627: GO 41630
41629: POP
// case btype of b_depot , b_warehouse :
41630: NOP4
41634: PUSH
41635: LD_INT 0
41637: DOUBLE
41638: EQUAL
41639: IFTRUE 41649
41641: LD_INT 1
41643: DOUBLE
41644: EQUAL
41645: IFTRUE 41649
41647: GO 41850
41649: POP
// case nation of nation_american :
41650: NOP4
41654: PUSH
41655: LD_INT 1
41657: DOUBLE
41658: EQUAL
41659: IFTRUE 41663
41661: GO 41719
41663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41664: NOP4
41668: PUSH
41669: NOP4
41673: PUSH
41674: NOP4
41678: PUSH
41679: NOP4
41683: PUSH
41684: NOP4
41688: PUSH
41689: NOP4
41693: PUSH
41694: NOP4
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: PUSH
41707: NOP4
41711: PUSH
41712: LD_INT 1
41714: PLUS
41715: ARRAY
41716: ST_TO_ADDR
41717: GO 41848
41719: LD_INT 2
41721: DOUBLE
41722: EQUAL
41723: IFTRUE 41727
41725: GO 41783
41727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41728: NOP4
41732: PUSH
41733: NOP4
41737: PUSH
41738: NOP4
41742: PUSH
41743: NOP4
41747: PUSH
41748: NOP4
41752: PUSH
41753: NOP4
41757: PUSH
41758: NOP4
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: PUSH
41771: NOP4
41775: PUSH
41776: LD_INT 1
41778: PLUS
41779: ARRAY
41780: ST_TO_ADDR
41781: GO 41848
41783: LD_INT 3
41785: DOUBLE
41786: EQUAL
41787: IFTRUE 41791
41789: GO 41847
41791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41792: NOP4
41796: PUSH
41797: NOP4
41801: PUSH
41802: NOP4
41806: PUSH
41807: NOP4
41811: PUSH
41812: NOP4
41816: PUSH
41817: NOP4
41821: PUSH
41822: NOP4
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: LIST
41831: LIST
41832: LIST
41833: LIST
41834: PUSH
41835: NOP4
41839: PUSH
41840: LD_INT 1
41842: PLUS
41843: ARRAY
41844: ST_TO_ADDR
41845: GO 41848
41847: POP
41848: GO 42403
41850: LD_INT 2
41852: DOUBLE
41853: EQUAL
41854: IFTRUE 41864
41856: LD_INT 3
41858: DOUBLE
41859: EQUAL
41860: IFTRUE 41864
41862: GO 41920
41864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41865: NOP4
41869: PUSH
41870: NOP4
41874: PUSH
41875: NOP4
41879: PUSH
41880: NOP4
41884: PUSH
41885: NOP4
41889: PUSH
41890: NOP4
41894: PUSH
41895: NOP4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: PUSH
41908: NOP4
41912: PUSH
41913: LD_INT 1
41915: PLUS
41916: ARRAY
41917: ST_TO_ADDR
41918: GO 42403
41920: LD_INT 16
41922: DOUBLE
41923: EQUAL
41924: IFTRUE 41982
41926: LD_INT 17
41928: DOUBLE
41929: EQUAL
41930: IFTRUE 41982
41932: LD_INT 18
41934: DOUBLE
41935: EQUAL
41936: IFTRUE 41982
41938: LD_INT 19
41940: DOUBLE
41941: EQUAL
41942: IFTRUE 41982
41944: LD_INT 22
41946: DOUBLE
41947: EQUAL
41948: IFTRUE 41982
41950: LD_INT 20
41952: DOUBLE
41953: EQUAL
41954: IFTRUE 41982
41956: LD_INT 21
41958: DOUBLE
41959: EQUAL
41960: IFTRUE 41982
41962: LD_INT 23
41964: DOUBLE
41965: EQUAL
41966: IFTRUE 41982
41968: LD_INT 24
41970: DOUBLE
41971: EQUAL
41972: IFTRUE 41982
41974: LD_INT 25
41976: DOUBLE
41977: EQUAL
41978: IFTRUE 41982
41980: GO 42038
41982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41983: NOP4
41987: PUSH
41988: NOP4
41992: PUSH
41993: NOP4
41997: PUSH
41998: NOP4
42002: PUSH
42003: NOP4
42007: PUSH
42008: NOP4
42012: PUSH
42013: NOP4
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: PUSH
42026: NOP4
42030: PUSH
42031: LD_INT 1
42033: PLUS
42034: ARRAY
42035: ST_TO_ADDR
42036: GO 42403
42038: LD_INT 6
42040: DOUBLE
42041: EQUAL
42042: IFTRUE 42094
42044: LD_INT 7
42046: DOUBLE
42047: EQUAL
42048: IFTRUE 42094
42050: LD_INT 8
42052: DOUBLE
42053: EQUAL
42054: IFTRUE 42094
42056: LD_INT 13
42058: DOUBLE
42059: EQUAL
42060: IFTRUE 42094
42062: LD_INT 12
42064: DOUBLE
42065: EQUAL
42066: IFTRUE 42094
42068: LD_INT 15
42070: DOUBLE
42071: EQUAL
42072: IFTRUE 42094
42074: LD_INT 11
42076: DOUBLE
42077: EQUAL
42078: IFTRUE 42094
42080: LD_INT 14
42082: DOUBLE
42083: EQUAL
42084: IFTRUE 42094
42086: LD_INT 10
42088: DOUBLE
42089: EQUAL
42090: IFTRUE 42094
42092: GO 42150
42094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42095: NOP4
42099: PUSH
42100: NOP4
42104: PUSH
42105: NOP4
42109: PUSH
42110: NOP4
42114: PUSH
42115: NOP4
42119: PUSH
42120: NOP4
42124: PUSH
42125: NOP4
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: PUSH
42138: NOP4
42142: PUSH
42143: LD_INT 1
42145: PLUS
42146: ARRAY
42147: ST_TO_ADDR
42148: GO 42403
42150: LD_INT 36
42152: DOUBLE
42153: EQUAL
42154: IFTRUE 42158
42156: GO 42214
42158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42159: NOP4
42163: PUSH
42164: NOP4
42168: PUSH
42169: NOP4
42173: PUSH
42174: NOP4
42178: PUSH
42179: NOP4
42183: PUSH
42184: NOP4
42188: PUSH
42189: NOP4
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: PUSH
42202: NOP4
42206: PUSH
42207: LD_INT 1
42209: PLUS
42210: ARRAY
42211: ST_TO_ADDR
42212: GO 42403
42214: LD_INT 4
42216: DOUBLE
42217: EQUAL
42218: IFTRUE 42240
42220: LD_INT 5
42222: DOUBLE
42223: EQUAL
42224: IFTRUE 42240
42226: LD_INT 34
42228: DOUBLE
42229: EQUAL
42230: IFTRUE 42240
42232: LD_INT 37
42234: DOUBLE
42235: EQUAL
42236: IFTRUE 42240
42238: GO 42296
42240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42241: NOP4
42245: PUSH
42246: NOP4
42250: PUSH
42251: NOP4
42255: PUSH
42256: NOP4
42260: PUSH
42261: NOP4
42265: PUSH
42266: NOP4
42270: PUSH
42271: NOP4
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: PUSH
42284: NOP4
42288: PUSH
42289: LD_INT 1
42291: PLUS
42292: ARRAY
42293: ST_TO_ADDR
42294: GO 42403
42296: LD_INT 31
42298: DOUBLE
42299: EQUAL
42300: IFTRUE 42346
42302: LD_INT 32
42304: DOUBLE
42305: EQUAL
42306: IFTRUE 42346
42308: LD_INT 33
42310: DOUBLE
42311: EQUAL
42312: IFTRUE 42346
42314: LD_INT 27
42316: DOUBLE
42317: EQUAL
42318: IFTRUE 42346
42320: LD_INT 26
42322: DOUBLE
42323: EQUAL
42324: IFTRUE 42346
42326: LD_INT 28
42328: DOUBLE
42329: EQUAL
42330: IFTRUE 42346
42332: LD_INT 29
42334: DOUBLE
42335: EQUAL
42336: IFTRUE 42346
42338: LD_INT 30
42340: DOUBLE
42341: EQUAL
42342: IFTRUE 42346
42344: GO 42402
42346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42347: NOP4
42351: PUSH
42352: NOP4
42356: PUSH
42357: NOP4
42361: PUSH
42362: NOP4
42366: PUSH
42367: NOP4
42371: PUSH
42372: NOP4
42376: PUSH
42377: NOP4
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: LIST
42388: LIST
42389: PUSH
42390: NOP4
42394: PUSH
42395: LD_INT 1
42397: PLUS
42398: ARRAY
42399: ST_TO_ADDR
42400: GO 42403
42402: POP
// temp_list2 = [ ] ;
42403: NOP4
42407: PUSH
42408: EMPTY
42409: ST_TO_ADDR
// for i in temp_list do
42410: NOP4
42414: PUSH
42415: NOP4
42419: PUSH
42420: FOR_IN
42421: IFFALSE 42473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42423: NOP4
42427: PUSH
42428: NOP4
42432: PUSH
42433: NOP4
42437: PUSH
42438: LD_INT 1
42440: ARRAY
42441: PUSH
42442: NOP4
42446: PLUS
42447: PUSH
42448: NOP4
42452: PUSH
42453: LD_INT 2
42455: ARRAY
42456: PUSH
42457: NOP4
42461: PLUS
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: EMPTY
42468: LIST
42469: ADD
42470: ST_TO_ADDR
42471: GO 42420
42473: POP
42474: POP
// result = temp_list2 ;
42475: NOP4
42479: PUSH
42480: NOP4
42484: ST_TO_ADDR
// end ;
42485: LD_VAR 0 7
42489: RET
// export function EnemyInRange ( unit , dist ) ; begin
42490: LD_INT 0
42492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42493: NOP4
42497: PUSH
42498: NOP4
42502: PPUSH
42503: NOP4
42507: PPUSH
42508: NOP4
42512: PPUSH
42513: NOP4
42517: PPUSH
42518: NOP4
42522: PPUSH
42523: NOP4
42527: PPUSH
42528: NOP4
42532: PPUSH
42533: NOP4
42537: PUSH
42538: LD_INT 4
42540: ARRAY
42541: ST_TO_ADDR
// end ;
42542: LD_VAR 0 3
42546: RET
// export function PlayerSeeMe ( unit ) ; begin
42547: LD_INT 0
42549: PPUSH
// result := See ( your_side , unit ) ;
42550: NOP4
42554: PUSH
42555: NOP4
42559: PPUSH
42560: NOP4
42564: PPUSH
42565: NOP4
42569: ST_TO_ADDR
// end ;
42570: LD_VAR 0 2
42574: RET
// export function ReverseDir ( unit ) ; begin
42575: LD_INT 0
42577: PPUSH
// if not unit then
42578: NOP4
42582: NOT
42583: IFFALSE 42587
// exit ;
42585: GO 42610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42587: NOP4
42591: PUSH
42592: NOP4
42596: PPUSH
42597: NOP4
42601: PUSH
42602: LD_INT 3
42604: PLUS
42605: PUSH
42606: LD_INT 6
42608: MOD
42609: ST_TO_ADDR
// end ;
42610: LD_VAR 0 2
42614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42615: LD_INT 0
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
// if not hexes then
42622: NOP4
42626: NOT
42627: IFFALSE 42631
// exit ;
42629: GO 42779
// dist := 9999 ;
42631: NOP4
42635: PUSH
42636: LD_INT 9999
42638: ST_TO_ADDR
// for i = 1 to hexes do
42639: NOP4
42643: PUSH
42644: DOUBLE
42645: LD_INT 1
42647: DEC
42648: ST_TO_ADDR
42649: NOP4
42653: PUSH
42654: FOR_TO
42655: IFFALSE 42767
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42657: NOP4
42661: PPUSH
42662: NOP4
42666: PUSH
42667: NOP4
42671: ARRAY
42672: PUSH
42673: LD_INT 1
42675: ARRAY
42676: PPUSH
42677: NOP4
42681: PUSH
42682: NOP4
42686: ARRAY
42687: PUSH
42688: LD_INT 2
42690: ARRAY
42691: PPUSH
42692: NOP4
42696: PUSH
42697: NOP4
42701: LESS
42702: IFFALSE 42765
// begin hex := hexes [ i ] ;
42704: NOP4
42708: PUSH
42709: NOP4
42713: PUSH
42714: NOP4
42718: ARRAY
42719: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42720: NOP4
42724: PUSH
42725: NOP4
42729: PPUSH
42730: NOP4
42734: PUSH
42735: NOP4
42739: ARRAY
42740: PUSH
42741: LD_INT 1
42743: ARRAY
42744: PPUSH
42745: NOP4
42749: PUSH
42750: NOP4
42754: ARRAY
42755: PUSH
42756: LD_INT 2
42758: ARRAY
42759: PPUSH
42760: NOP4
42764: ST_TO_ADDR
// end ; end ;
42765: GO 42654
42767: POP
42768: POP
// result := hex ;
42769: NOP4
42773: PUSH
42774: NOP4
42778: ST_TO_ADDR
// end ;
42779: LD_VAR 0 3
42783: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42784: LD_INT 0
42786: PPUSH
42787: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42788: NOP4
42792: NOT
42793: PUSH
42794: NOP4
42798: PUSH
42799: LD_INT 21
42801: PUSH
42802: LD_INT 2
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: LD_INT 23
42811: PUSH
42812: LD_INT 2
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PPUSH
42823: NOP4
42827: IN
42828: NOT
42829: OR
42830: IFFALSE 42834
// exit ;
42832: GO 42881
// for i = 1 to 3 do
42834: NOP4
42838: PUSH
42839: DOUBLE
42840: LD_INT 1
42842: DEC
42843: ST_TO_ADDR
42844: LD_INT 3
42846: PUSH
42847: FOR_TO
42848: IFFALSE 42879
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42850: NOP4
42854: PPUSH
42855: NOP4
42859: PPUSH
42860: NOP4
42864: PPUSH
42865: NOP4
42869: PPUSH
42870: LD_INT 1
42872: PPUSH
42873: NOP4
42877: GO 42847
42879: POP
42880: POP
// end ;
42881: LD_VAR 0 2
42885: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42886: LD_INT 0
42888: PPUSH
42889: PPUSH
42890: PPUSH
42891: PPUSH
42892: PPUSH
42893: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42894: NOP4
42898: NOT
42899: PUSH
42900: NOP4
42904: NOT
42905: OR
42906: PUSH
42907: NOP4
42911: PPUSH
42912: NOP4
42916: OR
42917: IFFALSE 42921
// exit ;
42919: GO 43362
// x := GetX ( enemy_unit ) ;
42921: NOP4
42925: PUSH
42926: NOP4
42930: PPUSH
42931: NOP4
42935: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42936: NOP4
42940: PUSH
42941: NOP4
42945: PPUSH
42946: NOP4
42950: ST_TO_ADDR
// if not x or not y then
42951: NOP4
42955: NOT
42956: PUSH
42957: NOP4
42961: NOT
42962: OR
42963: IFFALSE 42967
// exit ;
42965: GO 43362
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42967: NOP4
42971: PUSH
42972: NOP4
42976: PPUSH
42977: LD_INT 0
42979: PPUSH
42980: LD_INT 4
42982: PPUSH
42983: NOP4
42987: PUSH
42988: NOP4
42992: PPUSH
42993: LD_INT 0
42995: PPUSH
42996: LD_INT 4
42998: PPUSH
42999: NOP4
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: NOP4
43012: PPUSH
43013: LD_INT 1
43015: PPUSH
43016: LD_INT 4
43018: PPUSH
43019: NOP4
43023: PUSH
43024: NOP4
43028: PPUSH
43029: LD_INT 1
43031: PPUSH
43032: LD_INT 4
43034: PPUSH
43035: NOP4
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: NOP4
43048: PPUSH
43049: LD_INT 2
43051: PPUSH
43052: LD_INT 4
43054: PPUSH
43055: NOP4
43059: PUSH
43060: NOP4
43064: PPUSH
43065: LD_INT 2
43067: PPUSH
43068: LD_INT 4
43070: PPUSH
43071: NOP4
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: NOP4
43084: PPUSH
43085: LD_INT 3
43087: PPUSH
43088: LD_INT 4
43090: PPUSH
43091: NOP4
43095: PUSH
43096: NOP4
43100: PPUSH
43101: LD_INT 3
43103: PPUSH
43104: LD_INT 4
43106: PPUSH
43107: NOP4
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: NOP4
43120: PPUSH
43121: LD_INT 4
43123: PPUSH
43124: LD_INT 4
43126: PPUSH
43127: NOP4
43131: PUSH
43132: NOP4
43136: PPUSH
43137: LD_INT 4
43139: PPUSH
43140: LD_INT 4
43142: PPUSH
43143: NOP4
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: NOP4
43156: PPUSH
43157: LD_INT 5
43159: PPUSH
43160: LD_INT 4
43162: PPUSH
43163: NOP4
43167: PUSH
43168: NOP4
43172: PPUSH
43173: LD_INT 5
43175: PPUSH
43176: LD_INT 4
43178: PPUSH
43179: NOP4
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: ST_TO_ADDR
// for i = tmp downto 1 do
43196: NOP4
43200: PUSH
43201: DOUBLE
43202: NOP4
43206: INC
43207: ST_TO_ADDR
43208: LD_INT 1
43210: PUSH
43211: FOR_DOWNTO
43212: IFFALSE 43313
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43214: NOP4
43218: PUSH
43219: NOP4
43223: ARRAY
43224: PUSH
43225: LD_INT 1
43227: ARRAY
43228: PPUSH
43229: NOP4
43233: PUSH
43234: NOP4
43238: ARRAY
43239: PUSH
43240: LD_INT 2
43242: ARRAY
43243: PPUSH
43244: NOP4
43248: NOT
43249: PUSH
43250: NOP4
43254: PUSH
43255: NOP4
43259: ARRAY
43260: PUSH
43261: LD_INT 1
43263: ARRAY
43264: PPUSH
43265: NOP4
43269: PUSH
43270: NOP4
43274: ARRAY
43275: PUSH
43276: LD_INT 2
43278: ARRAY
43279: PPUSH
43280: NOP4
43284: PUSH
43285: LD_INT 0
43287: NONEQUAL
43288: OR
43289: IFFALSE 43311
// tmp := Delete ( tmp , i ) ;
43291: NOP4
43295: PUSH
43296: NOP4
43300: PPUSH
43301: NOP4
43305: PPUSH
43306: NOP4
43310: ST_TO_ADDR
43311: GO 43211
43313: POP
43314: POP
// j := GetClosestHex ( unit , tmp ) ;
43315: NOP4
43319: PUSH
43320: NOP4
43324: PPUSH
43325: NOP4
43329: PPUSH
43330: NOP4
43334: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43335: NOP4
43339: PPUSH
43340: NOP4
43344: PUSH
43345: LD_INT 1
43347: ARRAY
43348: PPUSH
43349: NOP4
43353: PUSH
43354: LD_INT 2
43356: ARRAY
43357: PPUSH
43358: NOP4
// end ;
43362: LD_VAR 0 3
43366: RET
// export function PrepareApemanSoldier ( ) ; begin
43367: LD_INT 0
43369: PPUSH
// uc_nation := 0 ;
43370: LD_ADDR_OWVAR 21
43374: PUSH
43375: LD_INT 0
43377: ST_TO_ADDR
// hc_sex := sex_male ;
43378: LD_ADDR_OWVAR 27
43382: PUSH
43383: LD_INT 1
43385: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43386: LD_ADDR_OWVAR 28
43390: PUSH
43391: LD_INT 15
43393: ST_TO_ADDR
// hc_gallery :=  ;
43394: LD_ADDR_OWVAR 33
43398: PUSH
43399: LD_STRING 
43401: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43402: LD_ADDR_OWVAR 31
43406: PUSH
43407: LD_INT 0
43409: PPUSH
43410: LD_INT 3
43412: PPUSH
43413: NOP4
43417: PUSH
43418: LD_INT 0
43420: PPUSH
43421: LD_INT 3
43423: PPUSH
43424: NOP4
43428: PUSH
43429: LD_INT 0
43431: PUSH
43432: LD_INT 0
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: ST_TO_ADDR
// end ;
43441: LD_VAR 0 1
43445: RET
// export function PrepareApemanEngineer ( ) ; begin
43446: LD_INT 0
43448: PPUSH
// uc_nation := 0 ;
43449: LD_ADDR_OWVAR 21
43453: PUSH
43454: LD_INT 0
43456: ST_TO_ADDR
// hc_sex := sex_male ;
43457: LD_ADDR_OWVAR 27
43461: PUSH
43462: LD_INT 1
43464: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43465: LD_ADDR_OWVAR 28
43469: PUSH
43470: LD_INT 16
43472: ST_TO_ADDR
// hc_gallery :=  ;
43473: LD_ADDR_OWVAR 33
43477: PUSH
43478: LD_STRING 
43480: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43481: LD_ADDR_OWVAR 31
43485: PUSH
43486: LD_INT 0
43488: PPUSH
43489: LD_INT 3
43491: PPUSH
43492: NOP4
43496: PUSH
43497: LD_INT 0
43499: PPUSH
43500: LD_INT 3
43502: PPUSH
43503: NOP4
43507: PUSH
43508: LD_INT 0
43510: PUSH
43511: LD_INT 0
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: ST_TO_ADDR
// end ;
43520: LD_VAR 0 1
43524: RET
// export function PrepareApeman ( agressivity ) ; begin
43525: LD_INT 0
43527: PPUSH
// uc_side := 0 ;
43528: LD_ADDR_OWVAR 20
43532: PUSH
43533: LD_INT 0
43535: ST_TO_ADDR
// uc_nation := 0 ;
43536: LD_ADDR_OWVAR 21
43540: PUSH
43541: LD_INT 0
43543: ST_TO_ADDR
// hc_sex := sex_male ;
43544: LD_ADDR_OWVAR 27
43548: PUSH
43549: LD_INT 1
43551: ST_TO_ADDR
// hc_class := class_apeman ;
43552: LD_ADDR_OWVAR 28
43556: PUSH
43557: LD_INT 12
43559: ST_TO_ADDR
// hc_gallery :=  ;
43560: LD_ADDR_OWVAR 33
43564: PUSH
43565: LD_STRING 
43567: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43568: LD_ADDR_OWVAR 35
43572: PUSH
43573: NOP4
43577: NEG
43578: PPUSH
43579: NOP4
43583: PPUSH
43584: NOP4
43588: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43589: LD_ADDR_OWVAR 31
43593: PUSH
43594: LD_INT 0
43596: PPUSH
43597: LD_INT 3
43599: PPUSH
43600: NOP4
43604: PUSH
43605: LD_INT 0
43607: PPUSH
43608: LD_INT 3
43610: PPUSH
43611: NOP4
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: LD_INT 0
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: LIST
43626: LIST
43627: ST_TO_ADDR
// end ;
43628: LD_VAR 0 2
43632: RET
// export function PrepareTiger ( agressivity ) ; begin
43633: LD_INT 0
43635: PPUSH
// uc_side := 0 ;
43636: LD_ADDR_OWVAR 20
43640: PUSH
43641: LD_INT 0
43643: ST_TO_ADDR
// uc_nation := 0 ;
43644: LD_ADDR_OWVAR 21
43648: PUSH
43649: LD_INT 0
43651: ST_TO_ADDR
// hc_class := class_tiger ;
43652: LD_ADDR_OWVAR 28
43656: PUSH
43657: LD_INT 14
43659: ST_TO_ADDR
// hc_gallery :=  ;
43660: LD_ADDR_OWVAR 33
43664: PUSH
43665: LD_STRING 
43667: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43668: LD_ADDR_OWVAR 35
43672: PUSH
43673: NOP4
43677: NEG
43678: PPUSH
43679: NOP4
43683: PPUSH
43684: NOP4
43688: ST_TO_ADDR
// end ;
43689: LD_VAR 0 2
43693: RET
// export function PrepareEnchidna ( ) ; begin
43694: LD_INT 0
43696: PPUSH
// uc_side := 0 ;
43697: LD_ADDR_OWVAR 20
43701: PUSH
43702: LD_INT 0
43704: ST_TO_ADDR
// uc_nation := 0 ;
43705: LD_ADDR_OWVAR 21
43709: PUSH
43710: LD_INT 0
43712: ST_TO_ADDR
// hc_class := class_baggie ;
43713: LD_ADDR_OWVAR 28
43717: PUSH
43718: LD_INT 13
43720: ST_TO_ADDR
// hc_gallery :=  ;
43721: LD_ADDR_OWVAR 33
43725: PUSH
43726: LD_STRING 
43728: ST_TO_ADDR
// end ;
43729: LD_VAR 0 1
43733: RET
// export function PrepareFrog ( ) ; begin
43734: LD_INT 0
43736: PPUSH
// uc_side := 0 ;
43737: LD_ADDR_OWVAR 20
43741: PUSH
43742: LD_INT 0
43744: ST_TO_ADDR
// uc_nation := 0 ;
43745: LD_ADDR_OWVAR 21
43749: PUSH
43750: LD_INT 0
43752: ST_TO_ADDR
// hc_class := class_frog ;
43753: LD_ADDR_OWVAR 28
43757: PUSH
43758: LD_INT 19
43760: ST_TO_ADDR
// hc_gallery :=  ;
43761: LD_ADDR_OWVAR 33
43765: PUSH
43766: LD_STRING 
43768: ST_TO_ADDR
// end ;
43769: LD_VAR 0 1
43773: RET
// export function PrepareFish ( ) ; begin
43774: LD_INT 0
43776: PPUSH
// uc_side := 0 ;
43777: LD_ADDR_OWVAR 20
43781: PUSH
43782: LD_INT 0
43784: ST_TO_ADDR
// uc_nation := 0 ;
43785: LD_ADDR_OWVAR 21
43789: PUSH
43790: LD_INT 0
43792: ST_TO_ADDR
// hc_class := class_fish ;
43793: LD_ADDR_OWVAR 28
43797: PUSH
43798: LD_INT 20
43800: ST_TO_ADDR
// hc_gallery :=  ;
43801: LD_ADDR_OWVAR 33
43805: PUSH
43806: LD_STRING 
43808: ST_TO_ADDR
// end ;
43809: LD_VAR 0 1
43813: RET
// export function PrepareBird ( ) ; begin
43814: LD_INT 0
43816: PPUSH
// uc_side := 0 ;
43817: LD_ADDR_OWVAR 20
43821: PUSH
43822: LD_INT 0
43824: ST_TO_ADDR
// uc_nation := 0 ;
43825: LD_ADDR_OWVAR 21
43829: PUSH
43830: LD_INT 0
43832: ST_TO_ADDR
// hc_class := class_phororhacos ;
43833: LD_ADDR_OWVAR 28
43837: PUSH
43838: LD_INT 18
43840: ST_TO_ADDR
// hc_gallery :=  ;
43841: LD_ADDR_OWVAR 33
43845: PUSH
43846: LD_STRING 
43848: ST_TO_ADDR
// end ;
43849: LD_VAR 0 1
43853: RET
// export function PrepareHorse ( ) ; begin
43854: LD_INT 0
43856: PPUSH
// uc_side := 0 ;
43857: LD_ADDR_OWVAR 20
43861: PUSH
43862: LD_INT 0
43864: ST_TO_ADDR
// uc_nation := 0 ;
43865: LD_ADDR_OWVAR 21
43869: PUSH
43870: LD_INT 0
43872: ST_TO_ADDR
// hc_class := class_horse ;
43873: LD_ADDR_OWVAR 28
43877: PUSH
43878: LD_INT 21
43880: ST_TO_ADDR
// hc_gallery :=  ;
43881: LD_ADDR_OWVAR 33
43885: PUSH
43886: LD_STRING 
43888: ST_TO_ADDR
// end ;
43889: LD_VAR 0 1
43893: RET
// export function PrepareMastodont ( ) ; begin
43894: LD_INT 0
43896: PPUSH
// uc_side := 0 ;
43897: LD_ADDR_OWVAR 20
43901: PUSH
43902: LD_INT 0
43904: ST_TO_ADDR
// uc_nation := 0 ;
43905: LD_ADDR_OWVAR 21
43909: PUSH
43910: LD_INT 0
43912: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43913: LD_ADDR_OWVAR 37
43917: PUSH
43918: LD_INT 31
43920: ST_TO_ADDR
// vc_control := control_rider ;
43921: LD_ADDR_OWVAR 38
43925: PUSH
43926: LD_INT 4
43928: ST_TO_ADDR
// end ;
43929: LD_VAR 0 1
43933: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43934: LD_INT 0
43936: PPUSH
43937: PPUSH
43938: PPUSH
// uc_side = 0 ;
43939: LD_ADDR_OWVAR 20
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// uc_nation = 0 ;
43947: LD_ADDR_OWVAR 21
43951: PUSH
43952: LD_INT 0
43954: ST_TO_ADDR
// InitHc_All ( ) ;
43955: NOP4
// InitVc ;
43959: NOP4
// if mastodonts then
43963: NOP4
43967: IFFALSE 44034
// for i = 1 to mastodonts do
43969: NOP4
43973: PUSH
43974: DOUBLE
43975: LD_INT 1
43977: DEC
43978: ST_TO_ADDR
43979: NOP4
43983: PUSH
43984: FOR_TO
43985: IFFALSE 44032
// begin vc_chassis := 31 ;
43987: LD_ADDR_OWVAR 37
43991: PUSH
43992: LD_INT 31
43994: ST_TO_ADDR
// vc_control := control_rider ;
43995: LD_ADDR_OWVAR 38
43999: PUSH
44000: LD_INT 4
44002: ST_TO_ADDR
// animal := CreateVehicle ;
44003: NOP4
44007: PUSH
44008: NOP4
44012: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44013: NOP4
44017: PPUSH
44018: NOP4
44022: PPUSH
44023: LD_INT 0
44025: PPUSH
44026: NOP4
// end ;
44030: GO 43984
44032: POP
44033: POP
// if horses then
44034: NOP4
44038: IFFALSE 44105
// for i = 1 to horses do
44040: NOP4
44044: PUSH
44045: DOUBLE
44046: LD_INT 1
44048: DEC
44049: ST_TO_ADDR
44050: NOP4
44054: PUSH
44055: FOR_TO
44056: IFFALSE 44103
// begin hc_class := 21 ;
44058: LD_ADDR_OWVAR 28
44062: PUSH
44063: LD_INT 21
44065: ST_TO_ADDR
// hc_gallery :=  ;
44066: LD_ADDR_OWVAR 33
44070: PUSH
44071: LD_STRING 
44073: ST_TO_ADDR
// animal := CreateHuman ;
44074: NOP4
44078: PUSH
44079: NOP4
44083: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44084: NOP4
44088: PPUSH
44089: NOP4
44093: PPUSH
44094: LD_INT 0
44096: PPUSH
44097: NOP4
// end ;
44101: GO 44055
44103: POP
44104: POP
// if birds then
44105: NOP4
44109: IFFALSE 44176
// for i = 1 to birds do
44111: NOP4
44115: PUSH
44116: DOUBLE
44117: LD_INT 1
44119: DEC
44120: ST_TO_ADDR
44121: NOP4
44125: PUSH
44126: FOR_TO
44127: IFFALSE 44174
// begin hc_class = 18 ;
44129: LD_ADDR_OWVAR 28
44133: PUSH
44134: LD_INT 18
44136: ST_TO_ADDR
// hc_gallery =  ;
44137: LD_ADDR_OWVAR 33
44141: PUSH
44142: LD_STRING 
44144: ST_TO_ADDR
// animal := CreateHuman ;
44145: NOP4
44149: PUSH
44150: NOP4
44154: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44155: NOP4
44159: PPUSH
44160: NOP4
44164: PPUSH
44165: LD_INT 0
44167: PPUSH
44168: NOP4
// end ;
44172: GO 44126
44174: POP
44175: POP
// if tigers then
44176: NOP4
44180: IFFALSE 44264
// for i = 1 to tigers do
44182: NOP4
44186: PUSH
44187: DOUBLE
44188: LD_INT 1
44190: DEC
44191: ST_TO_ADDR
44192: NOP4
44196: PUSH
44197: FOR_TO
44198: IFFALSE 44262
// begin hc_class = class_tiger ;
44200: LD_ADDR_OWVAR 28
44204: PUSH
44205: LD_INT 14
44207: ST_TO_ADDR
// hc_gallery =  ;
44208: LD_ADDR_OWVAR 33
44212: PUSH
44213: LD_STRING 
44215: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44216: LD_ADDR_OWVAR 35
44220: PUSH
44221: LD_INT 7
44223: NEG
44224: PPUSH
44225: LD_INT 7
44227: PPUSH
44228: NOP4
44232: ST_TO_ADDR
// animal := CreateHuman ;
44233: NOP4
44237: PUSH
44238: NOP4
44242: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44243: NOP4
44247: PPUSH
44248: NOP4
44252: PPUSH
44253: LD_INT 0
44255: PPUSH
44256: NOP4
// end ;
44260: GO 44197
44262: POP
44263: POP
// if apemans then
44264: NOP4
44268: IFFALSE 44391
// for i = 1 to apemans do
44270: NOP4
44274: PUSH
44275: DOUBLE
44276: LD_INT 1
44278: DEC
44279: ST_TO_ADDR
44280: NOP4
44284: PUSH
44285: FOR_TO
44286: IFFALSE 44389
// begin hc_class = class_apeman ;
44288: LD_ADDR_OWVAR 28
44292: PUSH
44293: LD_INT 12
44295: ST_TO_ADDR
// hc_gallery =  ;
44296: LD_ADDR_OWVAR 33
44300: PUSH
44301: LD_STRING 
44303: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44304: LD_ADDR_OWVAR 35
44308: PUSH
44309: LD_INT 2
44311: NEG
44312: PPUSH
44313: LD_INT 2
44315: PPUSH
44316: NOP4
44320: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44321: LD_ADDR_OWVAR 31
44325: PUSH
44326: LD_INT 1
44328: PPUSH
44329: LD_INT 3
44331: PPUSH
44332: NOP4
44336: PUSH
44337: LD_INT 1
44339: PPUSH
44340: LD_INT 3
44342: PPUSH
44343: NOP4
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 0
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: ST_TO_ADDR
// animal := CreateHuman ;
44360: NOP4
44364: PUSH
44365: NOP4
44369: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44370: NOP4
44374: PPUSH
44375: NOP4
44379: PPUSH
44380: LD_INT 0
44382: PPUSH
44383: NOP4
// end ;
44387: GO 44285
44389: POP
44390: POP
// if enchidnas then
44391: NOP4
44395: IFFALSE 44462
// for i = 1 to enchidnas do
44397: NOP4
44401: PUSH
44402: DOUBLE
44403: LD_INT 1
44405: DEC
44406: ST_TO_ADDR
44407: NOP4
44411: PUSH
44412: FOR_TO
44413: IFFALSE 44460
// begin hc_class = 13 ;
44415: LD_ADDR_OWVAR 28
44419: PUSH
44420: LD_INT 13
44422: ST_TO_ADDR
// hc_gallery =  ;
44423: LD_ADDR_OWVAR 33
44427: PUSH
44428: LD_STRING 
44430: ST_TO_ADDR
// animal := CreateHuman ;
44431: NOP4
44435: PUSH
44436: NOP4
44440: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44441: NOP4
44445: PPUSH
44446: NOP4
44450: PPUSH
44451: LD_INT 0
44453: PPUSH
44454: NOP4
// end ;
44458: GO 44412
44460: POP
44461: POP
// if fishes then
44462: NOP4
44466: IFFALSE 44533
// for i = 1 to fishes do
44468: NOP4
44472: PUSH
44473: DOUBLE
44474: LD_INT 1
44476: DEC
44477: ST_TO_ADDR
44478: NOP4
44482: PUSH
44483: FOR_TO
44484: IFFALSE 44531
// begin hc_class = 20 ;
44486: LD_ADDR_OWVAR 28
44490: PUSH
44491: LD_INT 20
44493: ST_TO_ADDR
// hc_gallery =  ;
44494: LD_ADDR_OWVAR 33
44498: PUSH
44499: LD_STRING 
44501: ST_TO_ADDR
// animal := CreateHuman ;
44502: NOP4
44506: PUSH
44507: NOP4
44511: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44512: NOP4
44516: PPUSH
44517: NOP4
44521: PPUSH
44522: LD_INT 0
44524: PPUSH
44525: NOP4
// end ;
44529: GO 44483
44531: POP
44532: POP
// end ;
44533: LD_VAR 0 10
44537: RET
// export function WantHeal ( sci , unit ) ; begin
44538: LD_INT 0
44540: PPUSH
// if GetTaskList ( sci ) > 0 then
44541: NOP4
44545: PPUSH
44546: NOP4
44550: PUSH
44551: LD_INT 0
44553: GREATER
44554: IFFALSE 44624
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44556: NOP4
44560: PPUSH
44561: NOP4
44565: PUSH
44566: LD_INT 1
44568: ARRAY
44569: PUSH
44570: LD_INT 1
44572: ARRAY
44573: PUSH
44574: LD_STRING l
44576: EQUAL
44577: PUSH
44578: NOP4
44582: PPUSH
44583: NOP4
44587: PUSH
44588: LD_INT 1
44590: ARRAY
44591: PUSH
44592: LD_INT 4
44594: ARRAY
44595: PUSH
44596: NOP4
44600: EQUAL
44601: AND
44602: IFFALSE 44614
// result := true else
44604: NOP4
44608: PUSH
44609: LD_INT 1
44611: ST_TO_ADDR
44612: GO 44622
// result := false ;
44614: NOP4
44618: PUSH
44619: LD_INT 0
44621: ST_TO_ADDR
// end else
44622: GO 44632
// result := false ;
44624: NOP4
44628: PUSH
44629: LD_INT 0
44631: ST_TO_ADDR
// end ;
44632: LD_VAR 0 3
44636: RET
// export function HealTarget ( sci ) ; begin
44637: LD_INT 0
44639: PPUSH
// if not sci then
44640: NOP4
44644: NOT
44645: IFFALSE 44649
// exit ;
44647: GO 44714
// result := 0 ;
44649: NOP4
44653: PUSH
44654: LD_INT 0
44656: ST_TO_ADDR
// if GetTaskList ( sci ) then
44657: NOP4
44661: PPUSH
44662: NOP4
44666: IFFALSE 44714
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44668: NOP4
44672: PPUSH
44673: NOP4
44677: PUSH
44678: LD_INT 1
44680: ARRAY
44681: PUSH
44682: LD_INT 1
44684: ARRAY
44685: PUSH
44686: LD_STRING l
44688: EQUAL
44689: IFFALSE 44714
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44691: NOP4
44695: PUSH
44696: NOP4
44700: PPUSH
44701: NOP4
44705: PUSH
44706: LD_INT 1
44708: ARRAY
44709: PUSH
44710: LD_INT 4
44712: ARRAY
44713: ST_TO_ADDR
// end ;
44714: LD_VAR 0 2
44718: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44719: LD_INT 0
44721: PPUSH
44722: PPUSH
44723: PPUSH
44724: PPUSH
// if not base_units then
44725: NOP4
44729: NOT
44730: IFFALSE 44734
// exit ;
44732: GO 44821
// result := false ;
44734: NOP4
44738: PUSH
44739: LD_INT 0
44741: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44742: NOP4
44746: PUSH
44747: NOP4
44751: PPUSH
44752: LD_INT 21
44754: PUSH
44755: LD_INT 3
44757: PUSH
44758: EMPTY
44759: LIST
44760: LIST
44761: PPUSH
44762: NOP4
44766: ST_TO_ADDR
// if not tmp then
44767: NOP4
44771: NOT
44772: IFFALSE 44776
// exit ;
44774: GO 44821
// for i in tmp do
44776: NOP4
44780: PUSH
44781: NOP4
44785: PUSH
44786: FOR_IN
44787: IFFALSE 44819
// begin result := EnemyInRange ( i , 22 ) ;
44789: NOP4
44793: PUSH
44794: NOP4
44798: PPUSH
44799: LD_INT 22
44801: PPUSH
44802: NOP4
44806: ST_TO_ADDR
// if result then
44807: NOP4
44811: IFFALSE 44817
// exit ;
44813: POP
44814: POP
44815: GO 44821
// end ;
44817: GO 44786
44819: POP
44820: POP
// end ;
44821: LD_VAR 0 2
44825: RET
// export function FilterByTag ( units , tag ) ; begin
44826: LD_INT 0
44828: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44829: NOP4
44833: PUSH
44834: NOP4
44838: PPUSH
44839: LD_INT 120
44841: PUSH
44842: NOP4
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PPUSH
44851: NOP4
44855: ST_TO_ADDR
// end ;
44856: LD_VAR 0 3
44860: RET
// export function IsDriver ( un ) ; begin
44861: LD_INT 0
44863: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44864: NOP4
44868: PUSH
44869: NOP4
44873: PUSH
44874: LD_INT 55
44876: PUSH
44877: EMPTY
44878: LIST
44879: PPUSH
44880: NOP4
44884: IN
44885: ST_TO_ADDR
// end ;
44886: LD_VAR 0 2
44890: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44891: LD_INT 0
44893: PPUSH
44894: PPUSH
// list := [ ] ;
44895: NOP4
44899: PUSH
44900: EMPTY
44901: ST_TO_ADDR
// case d of 0 :
44902: NOP4
44906: PUSH
44907: LD_INT 0
44909: DOUBLE
44910: EQUAL
44911: IFTRUE 44915
44913: GO 45048
44915: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44916: NOP4
44920: PUSH
44921: NOP4
44925: PUSH
44926: LD_INT 4
44928: MINUS
44929: PUSH
44930: NOP4
44934: PUSH
44935: LD_INT 4
44937: MINUS
44938: PUSH
44939: LD_INT 2
44941: PUSH
44942: EMPTY
44943: LIST
44944: LIST
44945: LIST
44946: PUSH
44947: NOP4
44951: PUSH
44952: LD_INT 3
44954: MINUS
44955: PUSH
44956: NOP4
44960: PUSH
44961: LD_INT 1
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: LIST
44968: PUSH
44969: NOP4
44973: PUSH
44974: LD_INT 4
44976: PLUS
44977: PUSH
44978: NOP4
44982: PUSH
44983: LD_INT 4
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: LIST
44990: PUSH
44991: NOP4
44995: PUSH
44996: LD_INT 3
44998: PLUS
44999: PUSH
45000: NOP4
45004: PUSH
45005: LD_INT 3
45007: PLUS
45008: PUSH
45009: LD_INT 5
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: LIST
45016: PUSH
45017: NOP4
45021: PUSH
45022: NOP4
45026: PUSH
45027: LD_INT 4
45029: PLUS
45030: PUSH
45031: LD_INT 0
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: LIST
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: ST_TO_ADDR
// end ; 1 :
45046: GO 45746
45048: LD_INT 1
45050: DOUBLE
45051: EQUAL
45052: IFTRUE 45056
45054: GO 45189
45056: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45057: NOP4
45061: PUSH
45062: NOP4
45066: PUSH
45067: NOP4
45071: PUSH
45072: LD_INT 4
45074: MINUS
45075: PUSH
45076: LD_INT 3
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: LIST
45083: PUSH
45084: NOP4
45088: PUSH
45089: LD_INT 3
45091: MINUS
45092: PUSH
45093: NOP4
45097: PUSH
45098: LD_INT 3
45100: MINUS
45101: PUSH
45102: LD_INT 2
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: LIST
45109: PUSH
45110: NOP4
45114: PUSH
45115: LD_INT 4
45117: MINUS
45118: PUSH
45119: NOP4
45123: PUSH
45124: LD_INT 1
45126: PUSH
45127: EMPTY
45128: LIST
45129: LIST
45130: LIST
45131: PUSH
45132: NOP4
45136: PUSH
45137: NOP4
45141: PUSH
45142: LD_INT 3
45144: PLUS
45145: PUSH
45146: LD_INT 0
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: LIST
45153: PUSH
45154: NOP4
45158: PUSH
45159: LD_INT 4
45161: PLUS
45162: PUSH
45163: NOP4
45167: PUSH
45168: LD_INT 4
45170: PLUS
45171: PUSH
45172: LD_INT 5
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: LIST
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: ST_TO_ADDR
// end ; 2 :
45187: GO 45746
45189: LD_INT 2
45191: DOUBLE
45192: EQUAL
45193: IFTRUE 45197
45195: GO 45326
45197: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45198: NOP4
45202: PUSH
45203: NOP4
45207: PUSH
45208: NOP4
45212: PUSH
45213: LD_INT 3
45215: MINUS
45216: PUSH
45217: LD_INT 3
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: LIST
45224: PUSH
45225: NOP4
45229: PUSH
45230: LD_INT 4
45232: PLUS
45233: PUSH
45234: NOP4
45238: PUSH
45239: LD_INT 4
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: LIST
45246: PUSH
45247: NOP4
45251: PUSH
45252: NOP4
45256: PUSH
45257: LD_INT 4
45259: PLUS
45260: PUSH
45261: LD_INT 0
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: LIST
45268: PUSH
45269: NOP4
45273: PUSH
45274: LD_INT 3
45276: MINUS
45277: PUSH
45278: NOP4
45282: PUSH
45283: LD_INT 1
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: LIST
45290: PUSH
45291: NOP4
45295: PUSH
45296: LD_INT 4
45298: MINUS
45299: PUSH
45300: NOP4
45304: PUSH
45305: LD_INT 4
45307: MINUS
45308: PUSH
45309: LD_INT 2
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: LIST
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: ST_TO_ADDR
// end ; 3 :
45324: GO 45746
45326: LD_INT 3
45328: DOUBLE
45329: EQUAL
45330: IFTRUE 45334
45332: GO 45467
45334: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45335: NOP4
45339: PUSH
45340: NOP4
45344: PUSH
45345: LD_INT 3
45347: PLUS
45348: PUSH
45349: NOP4
45353: PUSH
45354: LD_INT 4
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: LIST
45361: PUSH
45362: NOP4
45366: PUSH
45367: LD_INT 4
45369: PLUS
45370: PUSH
45371: NOP4
45375: PUSH
45376: LD_INT 4
45378: PLUS
45379: PUSH
45380: LD_INT 5
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: LIST
45387: PUSH
45388: NOP4
45392: PUSH
45393: LD_INT 4
45395: MINUS
45396: PUSH
45397: NOP4
45401: PUSH
45402: LD_INT 1
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: LIST
45409: PUSH
45410: NOP4
45414: PUSH
45415: NOP4
45419: PUSH
45420: LD_INT 4
45422: MINUS
45423: PUSH
45424: LD_INT 3
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: LIST
45431: PUSH
45432: NOP4
45436: PUSH
45437: LD_INT 3
45439: MINUS
45440: PUSH
45441: NOP4
45445: PUSH
45446: LD_INT 3
45448: MINUS
45449: PUSH
45450: LD_INT 2
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: LIST
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: ST_TO_ADDR
// end ; 4 :
45465: GO 45746
45467: LD_INT 4
45469: DOUBLE
45470: EQUAL
45471: IFTRUE 45475
45473: GO 45608
45475: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45476: NOP4
45480: PUSH
45481: NOP4
45485: PUSH
45486: NOP4
45490: PUSH
45491: LD_INT 4
45493: PLUS
45494: PUSH
45495: LD_INT 0
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: NOP4
45507: PUSH
45508: LD_INT 3
45510: PLUS
45511: PUSH
45512: NOP4
45516: PUSH
45517: LD_INT 3
45519: PLUS
45520: PUSH
45521: LD_INT 5
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: LIST
45528: PUSH
45529: NOP4
45533: PUSH
45534: LD_INT 4
45536: PLUS
45537: PUSH
45538: NOP4
45542: PUSH
45543: LD_INT 4
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: LIST
45550: PUSH
45551: NOP4
45555: PUSH
45556: NOP4
45560: PUSH
45561: LD_INT 3
45563: MINUS
45564: PUSH
45565: LD_INT 3
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: LIST
45572: PUSH
45573: NOP4
45577: PUSH
45578: LD_INT 4
45580: MINUS
45581: PUSH
45582: NOP4
45586: PUSH
45587: LD_INT 4
45589: MINUS
45590: PUSH
45591: LD_INT 2
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: LIST
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: ST_TO_ADDR
// end ; 5 :
45606: GO 45746
45608: LD_INT 5
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45616
45614: GO 45745
45616: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45617: NOP4
45621: PUSH
45622: NOP4
45626: PUSH
45627: LD_INT 4
45629: MINUS
45630: PUSH
45631: NOP4
45635: PUSH
45636: LD_INT 1
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: LIST
45643: PUSH
45644: NOP4
45648: PUSH
45649: NOP4
45653: PUSH
45654: LD_INT 4
45656: MINUS
45657: PUSH
45658: LD_INT 3
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: PUSH
45666: NOP4
45670: PUSH
45671: LD_INT 4
45673: PLUS
45674: PUSH
45675: NOP4
45679: PUSH
45680: LD_INT 4
45682: PLUS
45683: PUSH
45684: LD_INT 5
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: LIST
45691: PUSH
45692: NOP4
45696: PUSH
45697: LD_INT 3
45699: PLUS
45700: PUSH
45701: NOP4
45705: PUSH
45706: LD_INT 4
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: LIST
45713: PUSH
45714: NOP4
45718: PUSH
45719: NOP4
45723: PUSH
45724: LD_INT 3
45726: PLUS
45727: PUSH
45728: LD_INT 0
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: LIST
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: ST_TO_ADDR
// end ; end ;
45743: GO 45746
45745: POP
// result := list ;
45746: NOP4
45750: PUSH
45751: NOP4
45755: ST_TO_ADDR
// end ;
45756: LD_VAR 0 4
45760: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45761: LD_INT 0
45763: PPUSH
45764: PPUSH
45765: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45766: NOP4
45770: NOT
45771: PUSH
45772: NOP4
45776: PUSH
45777: LD_INT 1
45779: PUSH
45780: LD_INT 2
45782: PUSH
45783: LD_INT 3
45785: PUSH
45786: LD_INT 4
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: IN
45795: NOT
45796: OR
45797: IFFALSE 45801
// exit ;
45799: GO 45893
// tmp := [ ] ;
45801: NOP4
45805: PUSH
45806: EMPTY
45807: ST_TO_ADDR
// for i in units do
45808: NOP4
45812: PUSH
45813: NOP4
45817: PUSH
45818: FOR_IN
45819: IFFALSE 45862
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45821: NOP4
45825: PUSH
45826: NOP4
45830: PPUSH
45831: NOP4
45835: PUSH
45836: LD_INT 1
45838: PLUS
45839: PPUSH
45840: NOP4
45844: PPUSH
45845: NOP4
45849: PPUSH
45850: NOP4
45854: PPUSH
45855: NOP4
45859: ST_TO_ADDR
45860: GO 45818
45862: POP
45863: POP
// if not tmp then
45864: NOP4
45868: NOT
45869: IFFALSE 45873
// exit ;
45871: GO 45893
// result := SortListByListDesc ( units , tmp ) ;
45873: NOP4
45877: PUSH
45878: NOP4
45882: PPUSH
45883: NOP4
45887: PPUSH
45888: NOP4
45892: ST_TO_ADDR
// end ;
45893: LD_VAR 0 3
45897: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45898: LD_INT 0
45900: PPUSH
45901: PPUSH
45902: PPUSH
// result := false ;
45903: NOP4
45907: PUSH
45908: LD_INT 0
45910: ST_TO_ADDR
// x := GetX ( building ) ;
45911: NOP4
45915: PUSH
45916: NOP4
45920: PPUSH
45921: NOP4
45925: ST_TO_ADDR
// y := GetY ( building ) ;
45926: NOP4
45930: PUSH
45931: NOP4
45935: PPUSH
45936: NOP4
45940: ST_TO_ADDR
// if not building or not x or not y then
45941: NOP4
45945: NOT
45946: PUSH
45947: NOP4
45951: NOT
45952: OR
45953: PUSH
45954: NOP4
45958: NOT
45959: OR
45960: IFFALSE 45964
// exit ;
45962: GO 46056
// if GetTaskList ( unit ) then
45964: NOP4
45968: PPUSH
45969: NOP4
45973: IFFALSE 46056
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45975: LD_STRING e
45977: PUSH
45978: NOP4
45982: PPUSH
45983: NOP4
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: PUSH
45992: LD_INT 1
45994: ARRAY
45995: EQUAL
45996: PUSH
45997: NOP4
46001: PUSH
46002: NOP4
46006: PPUSH
46007: NOP4
46011: PUSH
46012: LD_INT 1
46014: ARRAY
46015: PUSH
46016: LD_INT 2
46018: ARRAY
46019: EQUAL
46020: AND
46021: PUSH
46022: NOP4
46026: PUSH
46027: NOP4
46031: PPUSH
46032: NOP4
46036: PUSH
46037: LD_INT 1
46039: ARRAY
46040: PUSH
46041: LD_INT 3
46043: ARRAY
46044: EQUAL
46045: AND
46046: IFFALSE 46056
// result := true end ;
46048: NOP4
46052: PUSH
46053: LD_INT 1
46055: ST_TO_ADDR
// end ;
46056: LD_VAR 0 3
46060: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46061: LD_INT 0
46063: PPUSH
// result := false ;
46064: NOP4
46068: PUSH
46069: LD_INT 0
46071: ST_TO_ADDR
// if GetTaskList ( unit ) then
46072: NOP4
46076: PPUSH
46077: NOP4
46081: IFFALSE 46164
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46083: LD_STRING M
46085: PUSH
46086: NOP4
46090: PPUSH
46091: NOP4
46095: PUSH
46096: LD_INT 1
46098: ARRAY
46099: PUSH
46100: LD_INT 1
46102: ARRAY
46103: EQUAL
46104: PUSH
46105: NOP4
46109: PUSH
46110: NOP4
46114: PPUSH
46115: NOP4
46119: PUSH
46120: LD_INT 1
46122: ARRAY
46123: PUSH
46124: LD_INT 2
46126: ARRAY
46127: EQUAL
46128: AND
46129: PUSH
46130: NOP4
46134: PUSH
46135: NOP4
46139: PPUSH
46140: NOP4
46144: PUSH
46145: LD_INT 1
46147: ARRAY
46148: PUSH
46149: LD_INT 3
46151: ARRAY
46152: EQUAL
46153: AND
46154: IFFALSE 46164
// result := true ;
46156: NOP4
46160: PUSH
46161: LD_INT 1
46163: ST_TO_ADDR
// end ; end ;
46164: LD_VAR 0 4
46168: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46169: LD_INT 0
46171: PPUSH
46172: PPUSH
46173: PPUSH
46174: PPUSH
// if not unit or not area then
46175: NOP4
46179: NOT
46180: PUSH
46181: NOP4
46185: NOT
46186: OR
46187: IFFALSE 46191
// exit ;
46189: GO 46355
// tmp := AreaToList ( area , i ) ;
46191: NOP4
46195: PUSH
46196: NOP4
46200: PPUSH
46201: NOP4
46205: PPUSH
46206: NOP4
46210: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46211: NOP4
46215: PUSH
46216: DOUBLE
46217: LD_INT 1
46219: DEC
46220: ST_TO_ADDR
46221: NOP4
46225: PUSH
46226: LD_INT 1
46228: ARRAY
46229: PUSH
46230: FOR_TO
46231: IFFALSE 46353
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46233: NOP4
46237: PUSH
46238: NOP4
46242: PUSH
46243: LD_INT 1
46245: ARRAY
46246: PUSH
46247: NOP4
46251: ARRAY
46252: PUSH
46253: NOP4
46257: PUSH
46258: LD_INT 2
46260: ARRAY
46261: PUSH
46262: NOP4
46266: ARRAY
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46272: NOP4
46276: PUSH
46277: LD_INT 1
46279: ARRAY
46280: PPUSH
46281: NOP4
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PPUSH
46290: NOP4
46294: PUSH
46295: LD_INT 0
46297: EQUAL
46298: IFFALSE 46351
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46300: NOP4
46304: PPUSH
46305: NOP4
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: PPUSH
46314: NOP4
46318: PUSH
46319: LD_INT 2
46321: ARRAY
46322: PPUSH
46323: NOP4
46327: PPUSH
46328: NOP4
// result := IsPlaced ( unit ) ;
46332: NOP4
46336: PUSH
46337: NOP4
46341: PPUSH
46342: NOP4
46346: ST_TO_ADDR
// exit ;
46347: POP
46348: POP
46349: GO 46355
// end ; end ;
46351: GO 46230
46353: POP
46354: POP
// end ;
46355: LD_VAR 0 4
46359: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46360: LD_INT 0
46362: PPUSH
46363: PPUSH
46364: PPUSH
// if not side or side > 8 then
46365: NOP4
46369: NOT
46370: PUSH
46371: NOP4
46375: PUSH
46376: LD_INT 8
46378: GREATER
46379: OR
46380: IFFALSE 46384
// exit ;
46382: GO 46571
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46384: NOP4
46388: PUSH
46389: LD_INT 22
46391: PUSH
46392: NOP4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 21
46403: PUSH
46404: LD_INT 3
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PPUSH
46415: NOP4
46419: ST_TO_ADDR
// if not tmp then
46420: NOP4
46424: NOT
46425: IFFALSE 46429
// exit ;
46427: GO 46571
// enable_addtolog := true ;
46429: LD_ADDR_OWVAR 81
46433: PUSH
46434: LD_INT 1
46436: ST_TO_ADDR
// AddToLog ( [ ) ;
46437: LD_STRING [
46439: PPUSH
46440: NOP4
// for i in tmp do
46444: NOP4
46448: PUSH
46449: NOP4
46453: PUSH
46454: FOR_IN
46455: IFFALSE 46562
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46457: LD_STRING [
46459: PUSH
46460: NOP4
46464: PPUSH
46465: NOP4
46469: STR
46470: PUSH
46471: LD_STRING , 
46473: STR
46474: PUSH
46475: NOP4
46479: PPUSH
46480: NOP4
46484: STR
46485: PUSH
46486: LD_STRING , 
46488: STR
46489: PUSH
46490: NOP4
46494: PPUSH
46495: NOP4
46499: STR
46500: PUSH
46501: LD_STRING , 
46503: STR
46504: PUSH
46505: NOP4
46509: PPUSH
46510: NOP4
46514: STR
46515: PUSH
46516: LD_STRING , 
46518: STR
46519: PUSH
46520: NOP4
46524: PPUSH
46525: LD_INT 1
46527: PPUSH
46528: NOP4
46532: STR
46533: PUSH
46534: LD_STRING , 
46536: STR
46537: PUSH
46538: NOP4
46542: PPUSH
46543: LD_INT 2
46545: PPUSH
46546: NOP4
46550: STR
46551: PUSH
46552: LD_STRING ],
46554: STR
46555: PPUSH
46556: NOP4
// end ;
46560: GO 46454
46562: POP
46563: POP
// AddToLog ( ]; ) ;
46564: LD_STRING ];
46566: PPUSH
46567: NOP4
// end ;
46571: LD_VAR 0 2
46575: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46576: LD_INT 0
46578: PPUSH
46579: PPUSH
46580: PPUSH
46581: PPUSH
46582: PPUSH
// if not area or not rate or not max then
46583: NOP4
46587: NOT
46588: PUSH
46589: NOP4
46593: NOT
46594: OR
46595: PUSH
46596: NOP4
46600: NOT
46601: OR
46602: IFFALSE 46606
// exit ;
46604: GO 46795
// while 1 do
46606: LD_INT 1
46608: IFFALSE 46795
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46610: NOP4
46614: PUSH
46615: NOP4
46619: PPUSH
46620: LD_INT 1
46622: PPUSH
46623: NOP4
46627: PUSH
46628: LD_INT 10
46630: MUL
46631: ST_TO_ADDR
// r := rate / 10 ;
46632: NOP4
46636: PUSH
46637: NOP4
46641: PUSH
46642: LD_INT 10
46644: DIVREAL
46645: ST_TO_ADDR
// time := 1 1$00 ;
46646: NOP4
46650: PUSH
46651: LD_INT 2100
46653: ST_TO_ADDR
// if amount < min then
46654: NOP4
46658: PUSH
46659: NOP4
46663: LESS
46664: IFFALSE 46682
// r := r * 2 else
46666: NOP4
46670: PUSH
46671: NOP4
46675: PUSH
46676: LD_INT 2
46678: MUL
46679: ST_TO_ADDR
46680: GO 46708
// if amount > max then
46682: NOP4
46686: PUSH
46687: NOP4
46691: GREATER
46692: IFFALSE 46708
// r := r / 2 ;
46694: NOP4
46698: PUSH
46699: NOP4
46703: PUSH
46704: LD_INT 2
46706: DIVREAL
46707: ST_TO_ADDR
// time := time / r ;
46708: NOP4
46712: PUSH
46713: NOP4
46717: PUSH
46718: NOP4
46722: DIVREAL
46723: ST_TO_ADDR
// if time < 0 then
46724: NOP4
46728: PUSH
46729: LD_INT 0
46731: LESS
46732: IFFALSE 46749
// time := time * - 1 ;
46734: NOP4
46738: PUSH
46739: NOP4
46743: PUSH
46744: LD_INT 1
46746: NEG
46747: MUL
46748: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46749: NOP4
46753: PUSH
46754: LD_INT 35
46756: PPUSH
46757: LD_INT 875
46759: PPUSH
46760: NOP4
46764: PLUS
46765: PPUSH
46766: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46770: LD_INT 1
46772: PPUSH
46773: LD_INT 5
46775: PPUSH
46776: NOP4
46780: PPUSH
46781: NOP4
46785: PPUSH
46786: LD_INT 1
46788: PPUSH
46789: NOP4
// end ;
46793: GO 46606
// end ;
46795: LD_VAR 0 5
46799: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46800: LD_INT 0
46802: PPUSH
46803: PPUSH
46804: PPUSH
46805: PPUSH
46806: PPUSH
46807: PPUSH
46808: PPUSH
46809: PPUSH
// if not turrets or not factories then
46810: NOP4
46814: NOT
46815: PUSH
46816: NOP4
46820: NOT
46821: OR
46822: IFFALSE 46826
// exit ;
46824: GO 47133
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46826: NOP4
46830: PUSH
46831: LD_INT 5
46833: PUSH
46834: LD_INT 6
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: PUSH
46841: LD_INT 2
46843: PUSH
46844: LD_INT 4
46846: PUSH
46847: EMPTY
46848: LIST
46849: LIST
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: LD_INT 5
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 24
46868: PUSH
46869: LD_INT 25
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 23
46878: PUSH
46879: LD_INT 27
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 42
46892: PUSH
46893: LD_INT 43
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 44
46902: PUSH
46903: LD_INT 46
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 45
46912: PUSH
46913: LD_INT 47
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: EMPTY
46921: LIST
46922: LIST
46923: LIST
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: LIST
46929: ST_TO_ADDR
// result := [ ] ;
46930: NOP4
46934: PUSH
46935: EMPTY
46936: ST_TO_ADDR
// for i in turrets do
46937: NOP4
46941: PUSH
46942: NOP4
46946: PUSH
46947: FOR_IN
46948: IFFALSE 47131
// begin nat := GetNation ( i ) ;
46950: NOP4
46954: PUSH
46955: NOP4
46959: PPUSH
46960: NOP4
46964: ST_TO_ADDR
// weapon := 0 ;
46965: NOP4
46969: PUSH
46970: LD_INT 0
46972: ST_TO_ADDR
// if not nat then
46973: NOP4
46977: NOT
46978: IFFALSE 46982
// continue ;
46980: GO 46947
// for j in list [ nat ] do
46982: NOP4
46986: PUSH
46987: NOP4
46991: PUSH
46992: NOP4
46996: ARRAY
46997: PUSH
46998: FOR_IN
46999: IFFALSE 47040
// if GetBWeapon ( i ) = j [ 1 ] then
47001: NOP4
47005: PPUSH
47006: NOP4
47010: PUSH
47011: NOP4
47015: PUSH
47016: LD_INT 1
47018: ARRAY
47019: EQUAL
47020: IFFALSE 47038
// begin weapon := j [ 2 ] ;
47022: NOP4
47026: PUSH
47027: NOP4
47031: PUSH
47032: LD_INT 2
47034: ARRAY
47035: ST_TO_ADDR
// break ;
47036: GO 47040
// end ;
47038: GO 46998
47040: POP
47041: POP
// if not weapon then
47042: NOP4
47046: NOT
47047: IFFALSE 47051
// continue ;
47049: GO 46947
// for k in factories do
47051: NOP4
47055: PUSH
47056: NOP4
47060: PUSH
47061: FOR_IN
47062: IFFALSE 47127
// begin weapons := AvailableWeaponList ( k ) ;
47064: NOP4
47068: PUSH
47069: NOP4
47073: PPUSH
47074: NOP4
47078: ST_TO_ADDR
// if not weapons then
47079: NOP4
47083: NOT
47084: IFFALSE 47088
// continue ;
47086: GO 47061
// if weapon in weapons then
47088: NOP4
47092: PUSH
47093: NOP4
47097: IN
47098: IFFALSE 47125
// begin result := [ i , weapon ] ;
47100: NOP4
47104: PUSH
47105: NOP4
47109: PUSH
47110: NOP4
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: ST_TO_ADDR
// exit ;
47119: POP
47120: POP
47121: POP
47122: POP
47123: GO 47133
// end ; end ;
47125: GO 47061
47127: POP
47128: POP
// end ;
47129: GO 46947
47131: POP
47132: POP
// end ;
47133: LD_VAR 0 3
47137: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47138: LD_INT 0
47140: PPUSH
// if not side or side > 8 then
47141: NOP4
47145: NOT
47146: PUSH
47147: NOP4
47151: PUSH
47152: LD_INT 8
47154: GREATER
47155: OR
47156: IFFALSE 47160
// exit ;
47158: GO 47219
// if not range then
47160: NOP4
47164: NOT
47165: IFFALSE 47176
// range := - 12 ;
47167: NOP4
47171: PUSH
47172: LD_INT 12
47174: NEG
47175: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47176: NOP4
47180: PPUSH
47181: NOP4
47185: PPUSH
47186: NOP4
47190: PPUSH
47191: NOP4
47195: PPUSH
47196: NOP4
// RemoveSeeing ( x , y , side ) ;
47200: NOP4
47204: PPUSH
47205: NOP4
47209: PPUSH
47210: NOP4
47214: PPUSH
47215: NOP4
// end ;
47219: LD_VAR 0 5
47223: RET
// export function Video ( mode ) ; begin
47224: LD_INT 0
47226: PPUSH
// ingame_video = mode ;
47227: LD_ADDR_OWVAR 52
47231: PUSH
47232: NOP4
47236: ST_TO_ADDR
// interface_hidden = mode ;
47237: LD_ADDR_OWVAR 54
47241: PUSH
47242: NOP4
47246: ST_TO_ADDR
// end ;
47247: LD_VAR 0 2
47251: RET
// export function Join ( array , element ) ; begin
47252: LD_INT 0
47254: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47255: NOP4
47259: PUSH
47260: NOP4
47264: PPUSH
47265: NOP4
47269: PUSH
47270: LD_INT 1
47272: PLUS
47273: PPUSH
47274: NOP4
47278: PPUSH
47279: NOP4
47283: ST_TO_ADDR
// end ;
47284: LD_VAR 0 3
47288: RET
// export function JoinUnion ( array , element ) ; begin
47289: LD_INT 0
47291: PPUSH
// result := array union element ;
47292: NOP4
47296: PUSH
47297: NOP4
47301: PUSH
47302: NOP4
47306: UNION
47307: ST_TO_ADDR
// end ;
47308: LD_VAR 0 3
47312: RET
// export function GetBehemoths ( side ) ; begin
47313: LD_INT 0
47315: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47316: NOP4
47320: PUSH
47321: LD_INT 22
47323: PUSH
47324: NOP4
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 31
47335: PUSH
47336: LD_INT 25
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PPUSH
47347: NOP4
47351: ST_TO_ADDR
// end ;
47352: LD_VAR 0 2
47356: RET
// export function Shuffle ( array ) ; var i , index ; begin
47357: LD_INT 0
47359: PPUSH
47360: PPUSH
47361: PPUSH
// result := [ ] ;
47362: NOP4
47366: PUSH
47367: EMPTY
47368: ST_TO_ADDR
// if not array then
47369: NOP4
47373: NOT
47374: IFFALSE 47378
// exit ;
47376: GO 47477
// Randomize ;
47378: NOP4
// for i = array downto 1 do
47382: NOP4
47386: PUSH
47387: DOUBLE
47388: NOP4
47392: INC
47393: ST_TO_ADDR
47394: LD_INT 1
47396: PUSH
47397: FOR_DOWNTO
47398: IFFALSE 47475
// begin index := rand ( 1 , array ) ;
47400: NOP4
47404: PUSH
47405: LD_INT 1
47407: PPUSH
47408: NOP4
47412: PPUSH
47413: NOP4
47417: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47418: NOP4
47422: PUSH
47423: NOP4
47427: PPUSH
47428: NOP4
47432: PUSH
47433: LD_INT 1
47435: PLUS
47436: PPUSH
47437: NOP4
47441: PUSH
47442: NOP4
47446: ARRAY
47447: PPUSH
47448: NOP4
47452: ST_TO_ADDR
// array := Delete ( array , index ) ;
47453: NOP4
47457: PUSH
47458: NOP4
47462: PPUSH
47463: NOP4
47467: PPUSH
47468: NOP4
47472: ST_TO_ADDR
// end ;
47473: GO 47397
47475: POP
47476: POP
// end ;
47477: LD_VAR 0 2
47481: RET
// export function GetBaseMaterials ( base ) ; begin
47482: LD_INT 0
47484: PPUSH
// result := [ 0 , 0 , 0 ] ;
47485: NOP4
47489: PUSH
47490: LD_INT 0
47492: PUSH
47493: LD_INT 0
47495: PUSH
47496: LD_INT 0
47498: PUSH
47499: EMPTY
47500: LIST
47501: LIST
47502: LIST
47503: ST_TO_ADDR
// if not base then
47504: NOP4
47508: NOT
47509: IFFALSE 47513
// exit ;
47511: GO 47562
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47513: NOP4
47517: PUSH
47518: NOP4
47522: PPUSH
47523: LD_INT 1
47525: PPUSH
47526: NOP4
47530: PUSH
47531: NOP4
47535: PPUSH
47536: LD_INT 2
47538: PPUSH
47539: NOP4
47543: PUSH
47544: NOP4
47548: PPUSH
47549: LD_INT 3
47551: PPUSH
47552: NOP4
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: LIST
47561: ST_TO_ADDR
// end ;
47562: LD_VAR 0 2
47566: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47567: LD_INT 0
47569: PPUSH
47570: PPUSH
// result := array ;
47571: NOP4
47575: PUSH
47576: NOP4
47580: ST_TO_ADDR
// if size >= result then
47581: NOP4
47585: PUSH
47586: NOP4
47590: GREATEREQUAL
47591: IFFALSE 47595
// exit ;
47593: GO 47645
// if size then
47595: NOP4
47599: IFFALSE 47645
// for i := array downto size do
47601: NOP4
47605: PUSH
47606: DOUBLE
47607: NOP4
47611: INC
47612: ST_TO_ADDR
47613: NOP4
47617: PUSH
47618: FOR_DOWNTO
47619: IFFALSE 47643
// result := Delete ( result , result ) ;
47621: NOP4
47625: PUSH
47626: NOP4
47630: PPUSH
47631: NOP4
47635: PPUSH
47636: NOP4
47640: ST_TO_ADDR
47641: GO 47618
47643: POP
47644: POP
// end ;
47645: LD_VAR 0 3
47649: RET
// export function ComExit ( unit ) ; var tmp ; begin
47650: LD_INT 0
47652: PPUSH
47653: PPUSH
// if not IsInUnit ( unit ) then
47654: NOP4
47658: PPUSH
47659: NOP4
47663: NOT
47664: IFFALSE 47668
// exit ;
47666: GO 47728
// tmp := IsInUnit ( unit ) ;
47668: NOP4
47672: PUSH
47673: NOP4
47677: PPUSH
47678: NOP4
47682: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47683: NOP4
47687: PPUSH
47688: NOP4
47692: PUSH
47693: LD_INT 2
47695: EQUAL
47696: IFFALSE 47709
// ComExitVehicle ( unit ) else
47698: NOP4
47702: PPUSH
47703: NOP4
47707: GO 47718
// ComExitBuilding ( unit ) ;
47709: NOP4
47713: PPUSH
47714: NOP4
// result := tmp ;
47718: NOP4
47722: PUSH
47723: NOP4
47727: ST_TO_ADDR
// end ;
47728: LD_VAR 0 2
47732: RET
// export function ComExitAll ( units ) ; var i ; begin
47733: LD_INT 0
47735: PPUSH
47736: PPUSH
// if not units then
47737: NOP4
47741: NOT
47742: IFFALSE 47746
// exit ;
47744: GO 47772
// for i in units do
47746: NOP4
47750: PUSH
47751: NOP4
47755: PUSH
47756: FOR_IN
47757: IFFALSE 47770
// ComExit ( i ) ;
47759: NOP4
47763: PPUSH
47764: NOP4
47768: GO 47756
47770: POP
47771: POP
// end ;
47772: LD_VAR 0 2
47776: RET
// export function ResetHc ; begin
47777: LD_INT 0
47779: PPUSH
// InitHc ;
47780: NOP4
// hc_importance := 0 ;
47784: LD_ADDR_OWVAR 32
47788: PUSH
47789: LD_INT 0
47791: ST_TO_ADDR
// end ;
47792: LD_VAR 0 1
47796: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
47801: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47802: NOP4
47806: PUSH
47807: NOP4
47811: PUSH
47812: NOP4
47816: PLUS
47817: PUSH
47818: LD_INT 2
47820: DIV
47821: ST_TO_ADDR
// if _x < 0 then
47822: NOP4
47826: PUSH
47827: LD_INT 0
47829: LESS
47830: IFFALSE 47847
// _x := _x * - 1 ;
47832: NOP4
47836: PUSH
47837: NOP4
47841: PUSH
47842: LD_INT 1
47844: NEG
47845: MUL
47846: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47847: NOP4
47851: PUSH
47852: NOP4
47856: PUSH
47857: NOP4
47861: PLUS
47862: PUSH
47863: LD_INT 2
47865: DIV
47866: ST_TO_ADDR
// if _y < 0 then
47867: NOP4
47871: PUSH
47872: LD_INT 0
47874: LESS
47875: IFFALSE 47892
// _y := _y * - 1 ;
47877: NOP4
47881: PUSH
47882: NOP4
47886: PUSH
47887: LD_INT 1
47889: NEG
47890: MUL
47891: ST_TO_ADDR
// result := [ _x , _y ] ;
47892: NOP4
47896: PUSH
47897: NOP4
47901: PUSH
47902: NOP4
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: ST_TO_ADDR
// end ;
47911: LD_VAR 0 5
47915: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47916: LD_INT 0
47918: PPUSH
47919: PPUSH
47920: PPUSH
47921: PPUSH
// task := GetTaskList ( unit ) ;
47922: NOP4
47926: PUSH
47927: NOP4
47931: PPUSH
47932: NOP4
47936: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47937: NOP4
47941: NOT
47942: PUSH
47943: NOP4
47947: PPUSH
47948: NOP4
47952: PPUSH
47953: NOP4
47957: NOT
47958: AND
47959: IFFALSE 47963
// exit ;
47961: GO 48081
// if IsInArea ( unit , area ) then
47963: NOP4
47967: PPUSH
47968: NOP4
47972: PPUSH
47973: NOP4
47977: IFFALSE 47995
// begin ComMoveToArea ( unit , goAway ) ;
47979: NOP4
47983: PPUSH
47984: NOP4
47988: PPUSH
47989: NOP4
// exit ;
47993: GO 48081
// end ; if task [ 1 ] [ 1 ] <> M then
47995: NOP4
47999: PUSH
48000: LD_INT 1
48002: ARRAY
48003: PUSH
48004: LD_INT 1
48006: ARRAY
48007: PUSH
48008: LD_STRING M
48010: NONEQUAL
48011: IFFALSE 48015
// exit ;
48013: GO 48081
// x := task [ 1 ] [ 2 ] ;
48015: NOP4
48019: PUSH
48020: NOP4
48024: PUSH
48025: LD_INT 1
48027: ARRAY
48028: PUSH
48029: LD_INT 2
48031: ARRAY
48032: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48033: NOP4
48037: PUSH
48038: NOP4
48042: PUSH
48043: LD_INT 1
48045: ARRAY
48046: PUSH
48047: LD_INT 3
48049: ARRAY
48050: ST_TO_ADDR
// if InArea ( x , y , area ) then
48051: NOP4
48055: PPUSH
48056: NOP4
48060: PPUSH
48061: NOP4
48065: PPUSH
48066: NOP4
48070: IFFALSE 48081
// ComStop ( unit ) ;
48072: NOP4
48076: PPUSH
48077: NOP4
// end ;
48081: LD_VAR 0 4
48085: RET
// export function Abs ( value ) ; begin
48086: LD_INT 0
48088: PPUSH
// result := value ;
48089: NOP4
48093: PUSH
48094: NOP4
48098: ST_TO_ADDR
// if value < 0 then
48099: NOP4
48103: PUSH
48104: LD_INT 0
48106: LESS
48107: IFFALSE 48124
// result := value * - 1 ;
48109: NOP4
48113: PUSH
48114: NOP4
48118: PUSH
48119: LD_INT 1
48121: NEG
48122: MUL
48123: ST_TO_ADDR
// end ;
48124: LD_VAR 0 2
48128: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48129: LD_INT 0
48131: PPUSH
48132: PPUSH
48133: PPUSH
48134: PPUSH
48135: PPUSH
48136: PPUSH
48137: PPUSH
48138: PPUSH
// if not unit or not building then
48139: NOP4
48143: NOT
48144: PUSH
48145: NOP4
48149: NOT
48150: OR
48151: IFFALSE 48155
// exit ;
48153: GO 48381
// x := GetX ( building ) ;
48155: NOP4
48159: PUSH
48160: NOP4
48164: PPUSH
48165: NOP4
48169: ST_TO_ADDR
// y := GetY ( building ) ;
48170: NOP4
48174: PUSH
48175: NOP4
48179: PPUSH
48180: NOP4
48184: ST_TO_ADDR
// d := GetDir ( building ) ;
48185: NOP4
48189: PUSH
48190: NOP4
48194: PPUSH
48195: NOP4
48199: ST_TO_ADDR
// r := 4 ;
48200: NOP4
48204: PUSH
48205: LD_INT 4
48207: ST_TO_ADDR
// for i := 1 to 5 do
48208: NOP4
48212: PUSH
48213: DOUBLE
48214: LD_INT 1
48216: DEC
48217: ST_TO_ADDR
48218: LD_INT 5
48220: PUSH
48221: FOR_TO
48222: IFFALSE 48379
// begin _x := ShiftX ( x , d , r + i ) ;
48224: NOP4
48228: PUSH
48229: NOP4
48233: PPUSH
48234: NOP4
48238: PPUSH
48239: NOP4
48243: PUSH
48244: NOP4
48248: PLUS
48249: PPUSH
48250: NOP4
48254: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48255: NOP4
48259: PUSH
48260: NOP4
48264: PPUSH
48265: NOP4
48269: PPUSH
48270: NOP4
48274: PUSH
48275: NOP4
48279: PLUS
48280: PPUSH
48281: NOP4
48285: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48286: NOP4
48290: PPUSH
48291: NOP4
48295: PPUSH
48296: NOP4
48300: PUSH
48301: NOP4
48305: PPUSH
48306: NOP4
48310: PPUSH
48311: NOP4
48315: PPUSH
48316: NOP4
48320: PUSH
48321: LD_INT 3
48323: PUSH
48324: LD_INT 2
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: IN
48331: NOT
48332: AND
48333: IFFALSE 48377
// begin ComMoveXY ( unit , _x , _y ) ;
48335: NOP4
48339: PPUSH
48340: NOP4
48344: PPUSH
48345: NOP4
48349: PPUSH
48350: NOP4
// result := [ _x , _y ] ;
48354: NOP4
48358: PUSH
48359: NOP4
48363: PUSH
48364: NOP4
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: ST_TO_ADDR
// exit ;
48373: POP
48374: POP
48375: GO 48381
// end ; end ;
48377: GO 48221
48379: POP
48380: POP
// end ;
48381: LD_VAR 0 3
48385: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48386: LD_INT 0
48388: PPUSH
48389: PPUSH
48390: PPUSH
// result := 0 ;
48391: NOP4
48395: PUSH
48396: LD_INT 0
48398: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48399: NOP4
48403: PUSH
48404: LD_INT 0
48406: LESS
48407: PUSH
48408: NOP4
48412: PUSH
48413: LD_INT 8
48415: GREATER
48416: OR
48417: PUSH
48418: NOP4
48422: PUSH
48423: LD_INT 0
48425: LESS
48426: OR
48427: PUSH
48428: NOP4
48432: PUSH
48433: LD_INT 8
48435: GREATER
48436: OR
48437: IFFALSE 48441
// exit ;
48439: GO 48516
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48441: NOP4
48445: PUSH
48446: LD_INT 22
48448: PUSH
48449: NOP4
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PPUSH
48458: NOP4
48462: PUSH
48463: FOR_IN
48464: IFFALSE 48514
// begin un := UnitShoot ( i ) ;
48466: NOP4
48470: PUSH
48471: NOP4
48475: PPUSH
48476: NOP4
48480: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48481: NOP4
48485: PPUSH
48486: NOP4
48490: PUSH
48491: NOP4
48495: EQUAL
48496: IFFALSE 48512
// begin result := un ;
48498: NOP4
48502: PUSH
48503: NOP4
48507: ST_TO_ADDR
// exit ;
48508: POP
48509: POP
48510: GO 48516
// end ; end ;
48512: GO 48463
48514: POP
48515: POP
// end ;
48516: LD_VAR 0 3
48520: RET
// export function GetCargoBay ( units ) ; begin
48521: LD_INT 0
48523: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48524: NOP4
48528: PUSH
48529: NOP4
48533: PPUSH
48534: LD_INT 2
48536: PUSH
48537: LD_INT 34
48539: PUSH
48540: LD_INT 12
48542: PUSH
48543: EMPTY
48544: LIST
48545: LIST
48546: PUSH
48547: LD_INT 34
48549: PUSH
48550: LD_INT 51
48552: PUSH
48553: EMPTY
48554: LIST
48555: LIST
48556: PUSH
48557: LD_INT 34
48559: PUSH
48560: LD_INT 32
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PUSH
48567: LD_INT 34
48569: PUSH
48570: NOP4
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: PUSH
48579: EMPTY
48580: LIST
48581: LIST
48582: LIST
48583: LIST
48584: LIST
48585: PPUSH
48586: NOP4
48590: ST_TO_ADDR
// end ;
48591: LD_VAR 0 2
48595: RET
// export function Negate ( value ) ; begin
48596: LD_INT 0
48598: PPUSH
// result := not value ;
48599: NOP4
48603: PUSH
48604: NOP4
48608: NOT
48609: ST_TO_ADDR
// end ;
48610: LD_VAR 0 2
48614: RET
// export function Inc ( value ) ; begin
48615: LD_INT 0
48617: PPUSH
// result := value + 1 ;
48618: NOP4
48622: PUSH
48623: NOP4
48627: PUSH
48628: LD_INT 1
48630: PLUS
48631: ST_TO_ADDR
// end ;
48632: LD_VAR 0 2
48636: RET
// export function Dec ( value ) ; begin
48637: LD_INT 0
48639: PPUSH
// result := value - 1 ;
48640: NOP4
48644: PUSH
48645: NOP4
48649: PUSH
48650: LD_INT 1
48652: MINUS
48653: ST_TO_ADDR
// end ;
48654: LD_VAR 0 2
48658: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48659: LD_INT 0
48661: PPUSH
48662: PPUSH
48663: PPUSH
48664: PPUSH
48665: PPUSH
48666: PPUSH
48667: PPUSH
48668: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48669: NOP4
48673: PPUSH
48674: NOP4
48678: PPUSH
48679: NOP4
48683: NOT
48684: PUSH
48685: NOP4
48689: PPUSH
48690: NOP4
48694: PPUSH
48695: NOP4
48699: NOT
48700: OR
48701: IFFALSE 48714
// begin result := - 1 ;
48703: NOP4
48707: PUSH
48708: LD_INT 1
48710: NEG
48711: ST_TO_ADDR
// exit ;
48712: GO 48949
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48714: NOP4
48718: PUSH
48719: NOP4
48723: PPUSH
48724: NOP4
48728: PPUSH
48729: NOP4
48733: PPUSH
48734: NOP4
48738: PPUSH
48739: NOP4
48743: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48744: NOP4
48748: PUSH
48749: NOP4
48753: PPUSH
48754: NOP4
48758: PPUSH
48759: NOP4
48763: PUSH
48764: LD_INT 1
48766: ARRAY
48767: PPUSH
48768: NOP4
48772: PUSH
48773: LD_INT 2
48775: ARRAY
48776: PPUSH
48777: NOP4
48781: ST_TO_ADDR
// distance := 9999 ;
48782: NOP4
48786: PUSH
48787: LD_INT 9999
48789: ST_TO_ADDR
// for i := 0 to 5 do
48790: NOP4
48794: PUSH
48795: DOUBLE
48796: LD_INT 0
48798: DEC
48799: ST_TO_ADDR
48800: LD_INT 5
48802: PUSH
48803: FOR_TO
48804: IFFALSE 48947
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48806: NOP4
48810: PUSH
48811: NOP4
48815: PPUSH
48816: NOP4
48820: PPUSH
48821: NOP4
48825: PPUSH
48826: NOP4
48830: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48831: NOP4
48835: PUSH
48836: NOP4
48840: PPUSH
48841: NOP4
48845: PPUSH
48846: NOP4
48850: PPUSH
48851: NOP4
48855: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48856: NOP4
48860: PPUSH
48861: NOP4
48865: PPUSH
48866: NOP4
48870: NOT
48871: IFFALSE 48875
// continue ;
48873: GO 48803
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48875: NOP4
48879: PUSH
48880: NOP4
48884: PUSH
48885: LD_INT 1
48887: ARRAY
48888: PPUSH
48889: NOP4
48893: PUSH
48894: LD_INT 2
48896: ARRAY
48897: PPUSH
48898: NOP4
48902: PPUSH
48903: NOP4
48907: PPUSH
48908: NOP4
48912: ST_TO_ADDR
// if tmp < distance then
48913: NOP4
48917: PUSH
48918: NOP4
48922: LESS
48923: IFFALSE 48945
// begin result := i ;
48925: NOP4
48929: PUSH
48930: NOP4
48934: ST_TO_ADDR
// distance := tmp ;
48935: NOP4
48939: PUSH
48940: NOP4
48944: ST_TO_ADDR
// end ; end ;
48945: GO 48803
48947: POP
48948: POP
// end ;
48949: LD_VAR 0 5
48953: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48954: LD_INT 0
48956: PPUSH
48957: PPUSH
// if not driver or not IsInUnit ( driver ) then
48958: NOP4
48962: NOT
48963: PUSH
48964: NOP4
48968: PPUSH
48969: NOP4
48973: NOT
48974: OR
48975: IFFALSE 48979
// exit ;
48977: GO 49069
// vehicle := IsInUnit ( driver ) ;
48979: NOP4
48983: PUSH
48984: NOP4
48988: PPUSH
48989: NOP4
48993: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48994: NOP4
48998: PPUSH
48999: LD_STRING \
49001: PUSH
49002: LD_INT 0
49004: PUSH
49005: LD_INT 0
49007: PUSH
49008: LD_INT 0
49010: PUSH
49011: LD_INT 0
49013: PUSH
49014: LD_INT 0
49016: PUSH
49017: LD_INT 0
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: LIST
49024: LIST
49025: LIST
49026: LIST
49027: LIST
49028: PUSH
49029: LD_STRING E
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 0
49037: PUSH
49038: NOP4
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 0
49048: PUSH
49049: LD_INT 0
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: PUSH
49061: EMPTY
49062: LIST
49063: LIST
49064: PPUSH
49065: NOP4
// end ;
49069: LD_VAR 0 2
49073: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49074: LD_INT 0
49076: PPUSH
49077: PPUSH
// if not driver or not IsInUnit ( driver ) then
49078: NOP4
49082: NOT
49083: PUSH
49084: NOP4
49088: PPUSH
49089: NOP4
49093: NOT
49094: OR
49095: IFFALSE 49099
// exit ;
49097: GO 49189
// vehicle := IsInUnit ( driver ) ;
49099: NOP4
49103: PUSH
49104: NOP4
49108: PPUSH
49109: NOP4
49113: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49114: NOP4
49118: PPUSH
49119: LD_STRING \
49121: PUSH
49122: LD_INT 0
49124: PUSH
49125: LD_INT 0
49127: PUSH
49128: LD_INT 0
49130: PUSH
49131: LD_INT 0
49133: PUSH
49134: LD_INT 0
49136: PUSH
49137: LD_INT 0
49139: PUSH
49140: EMPTY
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: PUSH
49149: LD_STRING E
49151: PUSH
49152: LD_INT 0
49154: PUSH
49155: LD_INT 0
49157: PUSH
49158: NOP4
49162: PUSH
49163: LD_INT 0
49165: PUSH
49166: LD_INT 0
49168: PUSH
49169: LD_INT 0
49171: PUSH
49172: EMPTY
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: LIST
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PPUSH
49185: NOP4
// end ;
49189: LD_VAR 0 2
49193: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49194: LD_INT 0
49196: PPUSH
49197: PPUSH
49198: PPUSH
// tmp := [ ] ;
49199: NOP4
49203: PUSH
49204: EMPTY
49205: ST_TO_ADDR
// for i in units do
49206: NOP4
49210: PUSH
49211: NOP4
49215: PUSH
49216: FOR_IN
49217: IFFALSE 49255
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49219: NOP4
49223: PUSH
49224: NOP4
49228: PPUSH
49229: NOP4
49233: PUSH
49234: LD_INT 1
49236: PLUS
49237: PPUSH
49238: NOP4
49242: PPUSH
49243: NOP4
49247: PPUSH
49248: NOP4
49252: ST_TO_ADDR
49253: GO 49216
49255: POP
49256: POP
// if not tmp then
49257: NOP4
49261: NOT
49262: IFFALSE 49266
// exit ;
49264: GO 49314
// if asc then
49266: NOP4
49270: IFFALSE 49294
// result := SortListByListAsc ( units , tmp ) else
49272: NOP4
49276: PUSH
49277: NOP4
49281: PPUSH
49282: NOP4
49286: PPUSH
49287: NOP4
49291: ST_TO_ADDR
49292: GO 49314
// result := SortListByListDesc ( units , tmp ) ;
49294: NOP4
49298: PUSH
49299: NOP4
49303: PPUSH
49304: NOP4
49308: PPUSH
49309: NOP4
49313: ST_TO_ADDR
// end ;
49314: LD_VAR 0 3
49318: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49319: LD_INT 0
49321: PPUSH
49322: PPUSH
// task := GetTaskList ( mech ) ;
49323: NOP4
49327: PUSH
49328: NOP4
49332: PPUSH
49333: NOP4
49337: ST_TO_ADDR
// if not task then
49338: NOP4
49342: NOT
49343: IFFALSE 49347
// exit ;
49345: GO 49389
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49347: NOP4
49351: PUSH
49352: NOP4
49356: PUSH
49357: LD_INT 1
49359: ARRAY
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PUSH
49365: LD_STRING r
49367: EQUAL
49368: PUSH
49369: NOP4
49373: PUSH
49374: LD_INT 1
49376: ARRAY
49377: PUSH
49378: LD_INT 4
49380: ARRAY
49381: PUSH
49382: NOP4
49386: EQUAL
49387: AND
49388: ST_TO_ADDR
// end ;
49389: LD_VAR 0 3
49393: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49394: LD_INT 0
49396: PPUSH
// SetDir ( unit , d ) ;
49397: NOP4
49401: PPUSH
49402: NOP4
49406: PPUSH
49407: NOP4
// PlaceUnitXY ( unit , x , y , mode ) ;
49411: NOP4
49415: PPUSH
49416: NOP4
49420: PPUSH
49421: NOP4
49425: PPUSH
49426: NOP4
49430: PPUSH
49431: NOP4
// end ;
49435: LD_VAR 0 6
49439: RET
// export function ToNaturalNumber ( number ) ; begin
49440: LD_INT 0
49442: PPUSH
// result := number div 1 ;
49443: NOP4
49447: PUSH
49448: NOP4
49452: PUSH
49453: LD_INT 1
49455: DIV
49456: ST_TO_ADDR
// if number < 0 then
49457: NOP4
49461: PUSH
49462: LD_INT 0
49464: LESS
49465: IFFALSE 49475
// result := 0 ;
49467: NOP4
49471: PUSH
49472: LD_INT 0
49474: ST_TO_ADDR
// end ;
49475: LD_VAR 0 2
49479: RET
// export function SortByClass ( units , class ) ; var un ; begin
49480: LD_INT 0
49482: PPUSH
49483: PPUSH
// if not units or not class then
49484: NOP4
49488: NOT
49489: PUSH
49490: NOP4
49494: NOT
49495: OR
49496: IFFALSE 49500
// exit ;
49498: GO 49595
// result := [ ] ;
49500: NOP4
49504: PUSH
49505: EMPTY
49506: ST_TO_ADDR
// for un in units do
49507: NOP4
49511: PUSH
49512: NOP4
49516: PUSH
49517: FOR_IN
49518: IFFALSE 49593
// if GetClass ( un ) = class then
49520: NOP4
49524: PPUSH
49525: NOP4
49529: PUSH
49530: NOP4
49534: EQUAL
49535: IFFALSE 49562
// result := Insert ( result , 1 , un ) else
49537: NOP4
49541: PUSH
49542: NOP4
49546: PPUSH
49547: LD_INT 1
49549: PPUSH
49550: NOP4
49554: PPUSH
49555: NOP4
49559: ST_TO_ADDR
49560: GO 49591
// result := Replace ( result , result + 1 , un ) ;
49562: NOP4
49566: PUSH
49567: NOP4
49571: PPUSH
49572: NOP4
49576: PUSH
49577: LD_INT 1
49579: PLUS
49580: PPUSH
49581: NOP4
49585: PPUSH
49586: NOP4
49590: ST_TO_ADDR
49591: GO 49517
49593: POP
49594: POP
// end ;
49595: LD_VAR 0 3
49599: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49600: LD_INT 0
49602: PPUSH
49603: PPUSH
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
// result := [ ] ;
49609: NOP4
49613: PUSH
49614: EMPTY
49615: ST_TO_ADDR
// if x - r < 0 then
49616: NOP4
49620: PUSH
49621: NOP4
49625: MINUS
49626: PUSH
49627: LD_INT 0
49629: LESS
49630: IFFALSE 49642
// min_x := 0 else
49632: NOP4
49636: PUSH
49637: LD_INT 0
49639: ST_TO_ADDR
49640: GO 49658
// min_x := x - r ;
49642: NOP4
49646: PUSH
49647: NOP4
49651: PUSH
49652: NOP4
49656: MINUS
49657: ST_TO_ADDR
// if y - r < 0 then
49658: NOP4
49662: PUSH
49663: NOP4
49667: MINUS
49668: PUSH
49669: LD_INT 0
49671: LESS
49672: IFFALSE 49684
// min_y := 0 else
49674: NOP4
49678: PUSH
49679: LD_INT 0
49681: ST_TO_ADDR
49682: GO 49700
// min_y := y - r ;
49684: NOP4
49688: PUSH
49689: NOP4
49693: PUSH
49694: NOP4
49698: MINUS
49699: ST_TO_ADDR
// max_x := x + r ;
49700: NOP4
49704: PUSH
49705: NOP4
49709: PUSH
49710: NOP4
49714: PLUS
49715: ST_TO_ADDR
// max_y := y + r ;
49716: NOP4
49720: PUSH
49721: NOP4
49725: PUSH
49726: NOP4
49730: PLUS
49731: ST_TO_ADDR
// for _x = min_x to max_x do
49732: NOP4
49736: PUSH
49737: DOUBLE
49738: NOP4
49742: DEC
49743: ST_TO_ADDR
49744: NOP4
49748: PUSH
49749: FOR_TO
49750: IFFALSE 49851
// for _y = min_y to max_y do
49752: NOP4
49756: PUSH
49757: DOUBLE
49758: NOP4
49762: DEC
49763: ST_TO_ADDR
49764: NOP4
49768: PUSH
49769: FOR_TO
49770: IFFALSE 49847
// begin if not ValidHex ( _x , _y ) then
49772: NOP4
49776: PPUSH
49777: NOP4
49781: PPUSH
49782: NOP4
49786: NOT
49787: IFFALSE 49791
// continue ;
49789: GO 49769
// if GetResourceTypeXY ( _x , _y ) then
49791: NOP4
49795: PPUSH
49796: NOP4
49800: PPUSH
49801: NOP4
49805: IFFALSE 49845
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49807: NOP4
49811: PUSH
49812: NOP4
49816: PPUSH
49817: NOP4
49821: PUSH
49822: LD_INT 1
49824: PLUS
49825: PPUSH
49826: NOP4
49830: PUSH
49831: NOP4
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: PPUSH
49840: NOP4
49844: ST_TO_ADDR
// end ;
49845: GO 49769
49847: POP
49848: POP
49849: GO 49749
49851: POP
49852: POP
// end ;
49853: LD_VAR 0 4
49857: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49858: LD_INT 0
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
49864: PPUSH
49865: PPUSH
49866: PPUSH
49867: PPUSH
// if not units then
49868: NOP4
49872: NOT
49873: IFFALSE 49877
// exit ;
49875: GO 50403
// result := UnitFilter ( units , [ f_ok ] ) ;
49877: NOP4
49881: PUSH
49882: NOP4
49886: PPUSH
49887: LD_INT 50
49889: PUSH
49890: EMPTY
49891: LIST
49892: PPUSH
49893: NOP4
49897: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49898: NOP4
49902: PUSH
49903: NOP4
49907: PUSH
49908: LD_INT 1
49910: ARRAY
49911: PPUSH
49912: NOP4
49916: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49917: NOP4
49921: PUSH
49922: LD_INT 29
49924: PUSH
49925: NOP4
49929: PUSH
49930: LD_INT 49
49932: PUSH
49933: EMPTY
49934: LIST
49935: LIST
49936: LIST
49937: ST_TO_ADDR
// if not result then
49938: NOP4
49942: NOT
49943: IFFALSE 49947
// exit ;
49945: GO 50403
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49947: NOP4
49951: PUSH
49952: LD_INT 81
49954: PUSH
49955: NOP4
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PPUSH
49964: NOP4
49968: ST_TO_ADDR
// for i in result do
49969: NOP4
49973: PUSH
49974: NOP4
49978: PUSH
49979: FOR_IN
49980: IFFALSE 50401
// begin tag := GetTag ( i ) + 1 ;
49982: NOP4
49986: PUSH
49987: NOP4
49991: PPUSH
49992: NOP4
49996: PUSH
49997: LD_INT 1
49999: PLUS
50000: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50001: NOP4
50005: PUSH
50006: NOP4
50010: PPUSH
50011: NOP4
50015: PPUSH
50016: NOP4
50020: PPUSH
50021: NOP4
50025: PPUSH
50026: LD_INT 6
50028: PPUSH
50029: NOP4
50033: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50034: NOP4
50038: PPUSH
50039: NOP4
50043: PUSH
50044: LD_INT 2
50046: EQUAL
50047: PUSH
50048: NOP4
50052: AND
50053: PUSH
50054: NOP4
50058: PPUSH
50059: NOP4
50063: PUSH
50064: NOP4
50068: IN
50069: NOT
50070: AND
50071: IFFALSE 50110
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50073: NOP4
50077: PPUSH
50078: NOP4
50082: PUSH
50083: LD_INT 1
50085: ARRAY
50086: PUSH
50087: LD_INT 1
50089: ARRAY
50090: PPUSH
50091: NOP4
50095: PUSH
50096: LD_INT 1
50098: ARRAY
50099: PUSH
50100: LD_INT 2
50102: ARRAY
50103: PPUSH
50104: NOP4
50108: GO 50399
// if path > tag then
50110: NOP4
50114: PUSH
50115: NOP4
50119: GREATER
50120: IFFALSE 50328
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50122: NOP4
50126: PUSH
50127: NOP4
50131: PPUSH
50132: LD_INT 91
50134: PUSH
50135: NOP4
50139: PUSH
50140: LD_INT 8
50142: PUSH
50143: EMPTY
50144: LIST
50145: LIST
50146: LIST
50147: PPUSH
50148: NOP4
50152: ST_TO_ADDR
// if nearEnemy then
50153: NOP4
50157: IFFALSE 50226
// begin if GetWeapon ( i ) = ru_time_lapser then
50159: NOP4
50163: PPUSH
50164: NOP4
50168: PUSH
50169: LD_INT 49
50171: EQUAL
50172: IFFALSE 50200
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50174: NOP4
50178: PPUSH
50179: NOP4
50183: PPUSH
50184: NOP4
50188: PPUSH
50189: NOP4
50193: PPUSH
50194: NOP4
50198: GO 50224
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50200: NOP4
50204: PPUSH
50205: NOP4
50209: PPUSH
50210: NOP4
50214: PPUSH
50215: NOP4
50219: PPUSH
50220: NOP4
// end else
50224: GO 50326
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50226: NOP4
50230: PPUSH
50231: NOP4
50235: PUSH
50236: NOP4
50240: ARRAY
50241: PUSH
50242: LD_INT 1
50244: ARRAY
50245: PPUSH
50246: NOP4
50250: PUSH
50251: NOP4
50255: ARRAY
50256: PUSH
50257: LD_INT 2
50259: ARRAY
50260: PPUSH
50261: NOP4
50265: PUSH
50266: LD_INT 6
50268: GREATER
50269: IFFALSE 50312
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50271: NOP4
50275: PPUSH
50276: NOP4
50280: PUSH
50281: NOP4
50285: ARRAY
50286: PUSH
50287: LD_INT 1
50289: ARRAY
50290: PPUSH
50291: NOP4
50295: PUSH
50296: NOP4
50300: ARRAY
50301: PUSH
50302: LD_INT 2
50304: ARRAY
50305: PPUSH
50306: NOP4
50310: GO 50326
// SetTag ( i , tag ) ;
50312: NOP4
50316: PPUSH
50317: NOP4
50321: PPUSH
50322: NOP4
// end else
50326: GO 50399
// if enemy then
50328: NOP4
50332: IFFALSE 50399
// begin if GetWeapon ( i ) = ru_time_lapser then
50334: NOP4
50338: PPUSH
50339: NOP4
50343: PUSH
50344: LD_INT 49
50346: EQUAL
50347: IFFALSE 50375
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50349: NOP4
50353: PPUSH
50354: NOP4
50358: PPUSH
50359: NOP4
50363: PPUSH
50364: NOP4
50368: PPUSH
50369: NOP4
50373: GO 50399
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50375: NOP4
50379: PPUSH
50380: NOP4
50384: PPUSH
50385: NOP4
50389: PPUSH
50390: NOP4
50394: PPUSH
50395: NOP4
// end ; end ;
50399: GO 49979
50401: POP
50402: POP
// end ;
50403: LD_VAR 0 3
50407: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50408: LD_INT 0
50410: PPUSH
50411: PPUSH
50412: PPUSH
// if not unit or IsInUnit ( unit ) then
50413: NOP4
50417: NOT
50418: PUSH
50419: NOP4
50423: PPUSH
50424: NOP4
50428: OR
50429: IFFALSE 50433
// exit ;
50431: GO 50524
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50433: NOP4
50437: PUSH
50438: NOP4
50442: PPUSH
50443: NOP4
50447: PPUSH
50448: NOP4
50452: PPUSH
50453: LD_INT 1
50455: PPUSH
50456: NOP4
50460: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50461: NOP4
50465: PUSH
50466: NOP4
50470: PPUSH
50471: NOP4
50475: PPUSH
50476: NOP4
50480: PPUSH
50481: LD_INT 1
50483: PPUSH
50484: NOP4
50488: ST_TO_ADDR
// if ValidHex ( x , y ) then
50489: NOP4
50493: PPUSH
50494: NOP4
50498: PPUSH
50499: NOP4
50503: IFFALSE 50524
// ComTurnXY ( unit , x , y ) ;
50505: NOP4
50509: PPUSH
50510: NOP4
50514: PPUSH
50515: NOP4
50519: PPUSH
50520: NOP4
// end ;
50524: LD_VAR 0 3
50528: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50529: LD_INT 0
50531: PPUSH
50532: PPUSH
// result := false ;
50533: NOP4
50537: PUSH
50538: LD_INT 0
50540: ST_TO_ADDR
// if not units then
50541: NOP4
50545: NOT
50546: IFFALSE 50550
// exit ;
50548: GO 50595
// for i in units do
50550: NOP4
50554: PUSH
50555: NOP4
50559: PUSH
50560: FOR_IN
50561: IFFALSE 50593
// if See ( side , i ) then
50563: NOP4
50567: PPUSH
50568: NOP4
50572: PPUSH
50573: NOP4
50577: IFFALSE 50591
// begin result := true ;
50579: NOP4
50583: PUSH
50584: LD_INT 1
50586: ST_TO_ADDR
// exit ;
50587: POP
50588: POP
50589: GO 50595
// end ;
50591: GO 50560
50593: POP
50594: POP
// end ;
50595: LD_VAR 0 3
50599: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50600: LD_INT 0
50602: PPUSH
50603: PPUSH
50604: PPUSH
50605: PPUSH
// if not unit or not points then
50606: NOP4
50610: NOT
50611: PUSH
50612: NOP4
50616: NOT
50617: OR
50618: IFFALSE 50622
// exit ;
50620: GO 50712
// dist := 99999 ;
50622: NOP4
50626: PUSH
50627: LD_INT 99999
50629: ST_TO_ADDR
// for i in points do
50630: NOP4
50634: PUSH
50635: NOP4
50639: PUSH
50640: FOR_IN
50641: IFFALSE 50710
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50643: NOP4
50647: PUSH
50648: NOP4
50652: PPUSH
50653: NOP4
50657: PUSH
50658: LD_INT 1
50660: ARRAY
50661: PPUSH
50662: NOP4
50666: PUSH
50667: LD_INT 2
50669: ARRAY
50670: PPUSH
50671: NOP4
50675: ST_TO_ADDR
// if tmpDist < dist then
50676: NOP4
50680: PUSH
50681: NOP4
50685: LESS
50686: IFFALSE 50708
// begin result := i ;
50688: NOP4
50692: PUSH
50693: NOP4
50697: ST_TO_ADDR
// dist := tmpDist ;
50698: NOP4
50702: PUSH
50703: NOP4
50707: ST_TO_ADDR
// end ; end ;
50708: GO 50640
50710: POP
50711: POP
// end ;
50712: LD_VAR 0 3
50716: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50717: LD_INT 0
50719: PPUSH
// uc_side := side ;
50720: LD_ADDR_OWVAR 20
50724: PUSH
50725: NOP4
50729: ST_TO_ADDR
// uc_nation := 3 ;
50730: LD_ADDR_OWVAR 21
50734: PUSH
50735: LD_INT 3
50737: ST_TO_ADDR
// vc_chassis := 25 ;
50738: LD_ADDR_OWVAR 37
50742: PUSH
50743: LD_INT 25
50745: ST_TO_ADDR
// vc_engine := engine_siberite ;
50746: LD_ADDR_OWVAR 39
50750: PUSH
50751: LD_INT 3
50753: ST_TO_ADDR
// vc_control := control_computer ;
50754: LD_ADDR_OWVAR 38
50758: PUSH
50759: LD_INT 3
50761: ST_TO_ADDR
// vc_weapon := 59 ;
50762: LD_ADDR_OWVAR 40
50766: PUSH
50767: LD_INT 59
50769: ST_TO_ADDR
// result := CreateVehicle ;
50770: NOP4
50774: PUSH
50775: NOP4
50779: ST_TO_ADDR
// SetDir ( result , d ) ;
50780: NOP4
50784: PPUSH
50785: NOP4
50789: PPUSH
50790: NOP4
// PlaceUnitXY ( result , x , y , false ) ;
50794: NOP4
50798: PPUSH
50799: NOP4
50803: PPUSH
50804: NOP4
50808: PPUSH
50809: LD_INT 0
50811: PPUSH
50812: NOP4
// end ;
50816: LD_VAR 0 5
50820: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50821: LD_INT 0
50823: PPUSH
50824: PPUSH
50825: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50826: NOP4
50830: PUSH
50831: LD_INT 0
50833: PUSH
50834: LD_INT 0
50836: PUSH
50837: LD_INT 0
50839: PUSH
50840: LD_INT 0
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: LIST
50847: LIST
50848: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50849: NOP4
50853: NOT
50854: PUSH
50855: NOP4
50859: PPUSH
50860: NOP4
50864: PUSH
50865: LD_INT 12
50867: PUSH
50868: LD_INT 51
50870: PUSH
50871: LD_INT 32
50873: PUSH
50874: NOP4
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: IN
50885: NOT
50886: OR
50887: IFFALSE 50891
// exit ;
50889: GO 50989
// for i := 1 to 3 do
50891: NOP4
50895: PUSH
50896: DOUBLE
50897: LD_INT 1
50899: DEC
50900: ST_TO_ADDR
50901: LD_INT 3
50903: PUSH
50904: FOR_TO
50905: IFFALSE 50987
// begin tmp := GetCargo ( cargo , i ) ;
50907: NOP4
50911: PUSH
50912: NOP4
50916: PPUSH
50917: NOP4
50921: PPUSH
50922: NOP4
50926: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50927: NOP4
50931: PUSH
50932: NOP4
50936: PPUSH
50937: NOP4
50941: PPUSH
50942: NOP4
50946: PPUSH
50947: NOP4
50951: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
50952: NOP4
50956: PUSH
50957: NOP4
50961: PPUSH
50962: LD_INT 4
50964: PPUSH
50965: NOP4
50969: PUSH
50970: LD_INT 4
50972: ARRAY
50973: PUSH
50974: NOP4
50978: PLUS
50979: PPUSH
50980: NOP4
50984: ST_TO_ADDR
// end ;
50985: GO 50904
50987: POP
50988: POP
// end ;
50989: LD_VAR 0 2
50993: RET
// export function Length ( array ) ; begin
50994: LD_INT 0
50996: PPUSH
// result := array + 0 ;
50997: NOP4
51001: PUSH
51002: NOP4
51006: PUSH
51007: LD_INT 0
51009: PLUS
51010: ST_TO_ADDR
// end ;
51011: LD_VAR 0 2
51015: RET
// export function PrepareArray ( array ) ; begin
51016: LD_INT 0
51018: PPUSH
// result := array diff 0 ;
51019: NOP4
51023: PUSH
51024: NOP4
51028: PUSH
51029: LD_INT 0
51031: DIFF
51032: ST_TO_ADDR
// if not result [ 1 ] then
51033: NOP4
51037: PUSH
51038: LD_INT 1
51040: ARRAY
51041: NOT
51042: IFFALSE 51062
// result := Delete ( result , 1 ) ;
51044: NOP4
51048: PUSH
51049: NOP4
51053: PPUSH
51054: LD_INT 1
51056: PPUSH
51057: NOP4
51061: ST_TO_ADDR
// end ; end_of_file
51062: LD_VAR 0 2
51066: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51067: LD_INT 0
51069: PPUSH
51070: PPUSH
// skirmish := false ;
51071: NOP4
51075: PUSH
51076: LD_INT 0
51078: ST_TO_ADDR
// debug_mc := false ;
51079: NOP4
51083: PUSH
51084: LD_INT 0
51086: ST_TO_ADDR
// mc_bases := [ ] ;
51087: NOP4
51091: PUSH
51092: EMPTY
51093: ST_TO_ADDR
// mc_sides := [ ] ;
51094: NOP4
51098: PUSH
51099: EMPTY
51100: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51101: NOP4
51105: PUSH
51106: EMPTY
51107: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51108: NOP4
51112: PUSH
51113: EMPTY
51114: ST_TO_ADDR
// mc_need_heal := [ ] ;
51115: NOP4
51119: PUSH
51120: EMPTY
51121: ST_TO_ADDR
// mc_healers := [ ] ;
51122: NOP4
51126: PUSH
51127: EMPTY
51128: ST_TO_ADDR
// mc_build_list := [ ] ;
51129: NOP4
51133: PUSH
51134: EMPTY
51135: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51136: NOP4
51140: PUSH
51141: EMPTY
51142: ST_TO_ADDR
// mc_builders := [ ] ;
51143: NOP4
51147: PUSH
51148: EMPTY
51149: ST_TO_ADDR
// mc_construct_list := [ ] ;
51150: NOP4
51154: PUSH
51155: EMPTY
51156: ST_TO_ADDR
// mc_turret_list := [ ] ;
51157: NOP4
51161: PUSH
51162: EMPTY
51163: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51164: NOP4
51168: PUSH
51169: EMPTY
51170: ST_TO_ADDR
// mc_miners := [ ] ;
51171: NOP4
51175: PUSH
51176: EMPTY
51177: ST_TO_ADDR
// mc_mines := [ ] ;
51178: NOP4
51182: PUSH
51183: EMPTY
51184: ST_TO_ADDR
// mc_minefields := [ ] ;
51185: NOP4
51189: PUSH
51190: EMPTY
51191: ST_TO_ADDR
// mc_crates := [ ] ;
51192: NOP4
51196: PUSH
51197: EMPTY
51198: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51199: NOP4
51203: PUSH
51204: EMPTY
51205: ST_TO_ADDR
// mc_crates_area := [ ] ;
51206: NOP4
51210: PUSH
51211: EMPTY
51212: ST_TO_ADDR
// mc_vehicles := [ ] ;
51213: NOP4
51217: PUSH
51218: EMPTY
51219: ST_TO_ADDR
// mc_attack := [ ] ;
51220: NOP4
51224: PUSH
51225: EMPTY
51226: ST_TO_ADDR
// mc_produce := [ ] ;
51227: NOP4
51231: PUSH
51232: EMPTY
51233: ST_TO_ADDR
// mc_defender := [ ] ;
51234: NOP4
51238: PUSH
51239: EMPTY
51240: ST_TO_ADDR
// mc_parking := [ ] ;
51241: NOP4
51245: PUSH
51246: EMPTY
51247: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51248: NOP4
51252: PUSH
51253: EMPTY
51254: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51255: NOP4
51259: PUSH
51260: EMPTY
51261: ST_TO_ADDR
// mc_scan := [ ] ;
51262: NOP4
51266: PUSH
51267: EMPTY
51268: ST_TO_ADDR
// mc_scan_area := [ ] ;
51269: NOP4
51273: PUSH
51274: EMPTY
51275: ST_TO_ADDR
// mc_tech := [ ] ;
51276: NOP4
51280: PUSH
51281: EMPTY
51282: ST_TO_ADDR
// mc_class := [ ] ;
51283: NOP4
51287: PUSH
51288: EMPTY
51289: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51290: NOP4
51294: PUSH
51295: EMPTY
51296: ST_TO_ADDR
// mc_is_defending := [ ] ;
51297: NOP4
51301: PUSH
51302: EMPTY
51303: ST_TO_ADDR
// end ;
51304: LD_VAR 0 1
51308: RET
// export function MC_Kill ( base ) ; begin
51309: LD_INT 0
51311: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51312: NOP4
51316: PUSH
51317: NOP4
51321: PPUSH
51322: NOP4
51326: PPUSH
51327: EMPTY
51328: PPUSH
51329: NOP4
51333: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51334: NOP4
51338: PUSH
51339: NOP4
51343: PPUSH
51344: NOP4
51348: PPUSH
51349: EMPTY
51350: PPUSH
51351: NOP4
51355: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51356: NOP4
51360: PUSH
51361: NOP4
51365: PPUSH
51366: NOP4
51370: PPUSH
51371: EMPTY
51372: PPUSH
51373: NOP4
51377: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51378: NOP4
51382: PUSH
51383: NOP4
51387: PPUSH
51388: NOP4
51392: PPUSH
51393: EMPTY
51394: PPUSH
51395: NOP4
51399: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51400: NOP4
51404: PUSH
51405: NOP4
51409: PPUSH
51410: NOP4
51414: PPUSH
51415: EMPTY
51416: PPUSH
51417: NOP4
51421: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51422: NOP4
51426: PUSH
51427: NOP4
51431: PPUSH
51432: NOP4
51436: PPUSH
51437: EMPTY
51438: PPUSH
51439: NOP4
51443: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51444: NOP4
51448: PUSH
51449: NOP4
51453: PPUSH
51454: NOP4
51458: PPUSH
51459: EMPTY
51460: PPUSH
51461: NOP4
51465: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51466: NOP4
51470: PUSH
51471: NOP4
51475: PPUSH
51476: NOP4
51480: PPUSH
51481: EMPTY
51482: PPUSH
51483: NOP4
51487: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51488: NOP4
51492: PUSH
51493: NOP4
51497: PPUSH
51498: NOP4
51502: PPUSH
51503: EMPTY
51504: PPUSH
51505: NOP4
51509: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51510: NOP4
51514: PUSH
51515: NOP4
51519: PPUSH
51520: NOP4
51524: PPUSH
51525: EMPTY
51526: PPUSH
51527: NOP4
51531: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51532: NOP4
51536: PUSH
51537: NOP4
51541: PPUSH
51542: NOP4
51546: PPUSH
51547: EMPTY
51548: PPUSH
51549: NOP4
51553: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51554: NOP4
51558: PUSH
51559: NOP4
51563: PPUSH
51564: NOP4
51568: PPUSH
51569: LD_INT 0
51571: PPUSH
51572: NOP4
51576: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51577: NOP4
51581: PUSH
51582: NOP4
51586: PPUSH
51587: NOP4
51591: PPUSH
51592: EMPTY
51593: PPUSH
51594: NOP4
51598: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51599: NOP4
51603: PUSH
51604: NOP4
51608: PPUSH
51609: NOP4
51613: PPUSH
51614: EMPTY
51615: PPUSH
51616: NOP4
51620: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51621: NOP4
51625: PUSH
51626: NOP4
51630: PPUSH
51631: NOP4
51635: PPUSH
51636: EMPTY
51637: PPUSH
51638: NOP4
51642: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51643: NOP4
51647: PUSH
51648: NOP4
51652: PPUSH
51653: NOP4
51657: PPUSH
51658: EMPTY
51659: PPUSH
51660: NOP4
51664: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51665: NOP4
51669: PUSH
51670: NOP4
51674: PPUSH
51675: NOP4
51679: PPUSH
51680: EMPTY
51681: PPUSH
51682: NOP4
51686: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51687: NOP4
51691: PUSH
51692: NOP4
51696: PPUSH
51697: NOP4
51701: PPUSH
51702: EMPTY
51703: PPUSH
51704: NOP4
51708: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51709: NOP4
51713: PUSH
51714: NOP4
51718: PPUSH
51719: NOP4
51723: PPUSH
51724: EMPTY
51725: PPUSH
51726: NOP4
51730: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51731: NOP4
51735: PUSH
51736: NOP4
51740: PPUSH
51741: NOP4
51745: PPUSH
51746: EMPTY
51747: PPUSH
51748: NOP4
51752: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51753: NOP4
51757: PUSH
51758: NOP4
51762: PPUSH
51763: NOP4
51767: PPUSH
51768: EMPTY
51769: PPUSH
51770: NOP4
51774: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51775: NOP4
51779: PUSH
51780: NOP4
51784: PPUSH
51785: NOP4
51789: PPUSH
51790: EMPTY
51791: PPUSH
51792: NOP4
51796: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51797: NOP4
51801: PUSH
51802: NOP4
51806: PPUSH
51807: NOP4
51811: PPUSH
51812: EMPTY
51813: PPUSH
51814: NOP4
51818: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51819: NOP4
51823: PUSH
51824: NOP4
51828: PPUSH
51829: NOP4
51833: PPUSH
51834: EMPTY
51835: PPUSH
51836: NOP4
51840: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51841: NOP4
51845: PUSH
51846: NOP4
51850: PPUSH
51851: NOP4
51855: PPUSH
51856: EMPTY
51857: PPUSH
51858: NOP4
51862: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51863: NOP4
51867: PUSH
51868: NOP4
51872: PPUSH
51873: NOP4
51877: PPUSH
51878: EMPTY
51879: PPUSH
51880: NOP4
51884: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51885: NOP4
51889: PUSH
51890: NOP4
51894: PPUSH
51895: NOP4
51899: PPUSH
51900: EMPTY
51901: PPUSH
51902: NOP4
51906: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51907: NOP4
51911: PUSH
51912: NOP4
51916: PPUSH
51917: NOP4
51921: PPUSH
51922: EMPTY
51923: PPUSH
51924: NOP4
51928: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51929: NOP4
51933: PUSH
51934: NOP4
51938: PPUSH
51939: NOP4
51943: PPUSH
51944: EMPTY
51945: PPUSH
51946: NOP4
51950: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51951: NOP4
51955: PUSH
51956: NOP4
51960: PPUSH
51961: NOP4
51965: PPUSH
51966: EMPTY
51967: PPUSH
51968: NOP4
51972: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51973: NOP4
51977: PUSH
51978: NOP4
51982: PPUSH
51983: NOP4
51987: PPUSH
51988: EMPTY
51989: PPUSH
51990: NOP4
51994: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51995: NOP4
51999: PUSH
52000: NOP4
52004: PPUSH
52005: NOP4
52009: PPUSH
52010: EMPTY
52011: PPUSH
52012: NOP4
52016: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52017: NOP4
52021: PUSH
52022: NOP4
52026: PPUSH
52027: NOP4
52031: PPUSH
52032: EMPTY
52033: PPUSH
52034: NOP4
52038: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52039: NOP4
52043: PUSH
52044: NOP4
52048: PPUSH
52049: NOP4
52053: PPUSH
52054: EMPTY
52055: PPUSH
52056: NOP4
52060: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52061: NOP4
52065: PUSH
52066: NOP4
52070: PPUSH
52071: NOP4
52075: PPUSH
52076: EMPTY
52077: PPUSH
52078: NOP4
52082: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52083: NOP4
52087: PUSH
52088: NOP4
52092: PPUSH
52093: NOP4
52097: PPUSH
52098: EMPTY
52099: PPUSH
52100: NOP4
52104: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52105: NOP4
52109: PUSH
52110: NOP4
52114: PPUSH
52115: NOP4
52119: PPUSH
52120: EMPTY
52121: PPUSH
52122: NOP4
52126: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52127: NOP4
52131: PUSH
52132: NOP4
52136: PPUSH
52137: NOP4
52141: PPUSH
52142: EMPTY
52143: PPUSH
52144: NOP4
52148: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52149: NOP4
52153: PUSH
52154: NOP4
52158: PPUSH
52159: NOP4
52163: PPUSH
52164: EMPTY
52165: PPUSH
52166: NOP4
52170: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52171: NOP4
52175: PUSH
52176: NOP4
52180: PPUSH
52181: NOP4
52185: PPUSH
52186: EMPTY
52187: PPUSH
52188: NOP4
52192: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52193: NOP4
52197: PUSH
52198: NOP4
52202: PPUSH
52203: NOP4
52207: PPUSH
52208: LD_INT 0
52210: PPUSH
52211: NOP4
52215: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52216: NOP4
52220: PUSH
52221: NOP4
52225: PPUSH
52226: NOP4
52230: PPUSH
52231: LD_INT 0
52233: PPUSH
52234: NOP4
52238: ST_TO_ADDR
// end ;
52239: LD_VAR 0 2
52243: RET
// export function MC_Add ( side , units ) ; var base ; begin
52244: LD_INT 0
52246: PPUSH
52247: PPUSH
// base := mc_bases + 1 ;
52248: NOP4
52252: PUSH
52253: NOP4
52257: PUSH
52258: LD_INT 1
52260: PLUS
52261: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52262: NOP4
52266: PUSH
52267: NOP4
52271: PPUSH
52272: NOP4
52276: PPUSH
52277: NOP4
52281: PPUSH
52282: NOP4
52286: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52287: NOP4
52291: PUSH
52292: NOP4
52296: PPUSH
52297: NOP4
52301: PPUSH
52302: NOP4
52306: PPUSH
52307: NOP4
52311: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52312: NOP4
52316: PUSH
52317: NOP4
52321: PPUSH
52322: NOP4
52326: PPUSH
52327: EMPTY
52328: PPUSH
52329: NOP4
52333: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52334: NOP4
52338: PUSH
52339: NOP4
52343: PPUSH
52344: NOP4
52348: PPUSH
52349: EMPTY
52350: PPUSH
52351: NOP4
52355: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52356: NOP4
52360: PUSH
52361: NOP4
52365: PPUSH
52366: NOP4
52370: PPUSH
52371: EMPTY
52372: PPUSH
52373: NOP4
52377: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52378: NOP4
52382: PUSH
52383: NOP4
52387: PPUSH
52388: NOP4
52392: PPUSH
52393: EMPTY
52394: PPUSH
52395: NOP4
52399: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52400: NOP4
52404: PUSH
52405: NOP4
52409: PPUSH
52410: NOP4
52414: PPUSH
52415: EMPTY
52416: PPUSH
52417: NOP4
52421: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52422: NOP4
52426: PUSH
52427: NOP4
52431: PPUSH
52432: NOP4
52436: PPUSH
52437: EMPTY
52438: PPUSH
52439: NOP4
52443: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52444: NOP4
52448: PUSH
52449: NOP4
52453: PPUSH
52454: NOP4
52458: PPUSH
52459: EMPTY
52460: PPUSH
52461: NOP4
52465: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52466: NOP4
52470: PUSH
52471: NOP4
52475: PPUSH
52476: NOP4
52480: PPUSH
52481: EMPTY
52482: PPUSH
52483: NOP4
52487: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52488: NOP4
52492: PUSH
52493: NOP4
52497: PPUSH
52498: NOP4
52502: PPUSH
52503: EMPTY
52504: PPUSH
52505: NOP4
52509: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52510: NOP4
52514: PUSH
52515: NOP4
52519: PPUSH
52520: NOP4
52524: PPUSH
52525: EMPTY
52526: PPUSH
52527: NOP4
52531: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52532: NOP4
52536: PUSH
52537: NOP4
52541: PPUSH
52542: NOP4
52546: PPUSH
52547: LD_INT 0
52549: PPUSH
52550: NOP4
52554: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52555: NOP4
52559: PUSH
52560: NOP4
52564: PPUSH
52565: NOP4
52569: PPUSH
52570: EMPTY
52571: PPUSH
52572: NOP4
52576: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52577: NOP4
52581: PUSH
52582: NOP4
52586: PPUSH
52587: NOP4
52591: PPUSH
52592: EMPTY
52593: PPUSH
52594: NOP4
52598: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52599: NOP4
52603: PUSH
52604: NOP4
52608: PPUSH
52609: NOP4
52613: PPUSH
52614: EMPTY
52615: PPUSH
52616: NOP4
52620: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52621: NOP4
52625: PUSH
52626: NOP4
52630: PPUSH
52631: NOP4
52635: PPUSH
52636: EMPTY
52637: PPUSH
52638: NOP4
52642: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52643: NOP4
52647: PUSH
52648: NOP4
52652: PPUSH
52653: NOP4
52657: PPUSH
52658: EMPTY
52659: PPUSH
52660: NOP4
52664: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52665: NOP4
52669: PUSH
52670: NOP4
52674: PPUSH
52675: NOP4
52679: PPUSH
52680: EMPTY
52681: PPUSH
52682: NOP4
52686: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52687: NOP4
52691: PUSH
52692: NOP4
52696: PPUSH
52697: NOP4
52701: PPUSH
52702: EMPTY
52703: PPUSH
52704: NOP4
52708: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52709: NOP4
52713: PUSH
52714: NOP4
52718: PPUSH
52719: NOP4
52723: PPUSH
52724: EMPTY
52725: PPUSH
52726: NOP4
52730: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52731: NOP4
52735: PUSH
52736: NOP4
52740: PPUSH
52741: NOP4
52745: PPUSH
52746: EMPTY
52747: PPUSH
52748: NOP4
52752: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52753: NOP4
52757: PUSH
52758: NOP4
52762: PPUSH
52763: NOP4
52767: PPUSH
52768: EMPTY
52769: PPUSH
52770: NOP4
52774: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52775: NOP4
52779: PUSH
52780: NOP4
52784: PPUSH
52785: NOP4
52789: PPUSH
52790: EMPTY
52791: PPUSH
52792: NOP4
52796: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52797: NOP4
52801: PUSH
52802: NOP4
52806: PPUSH
52807: NOP4
52811: PPUSH
52812: EMPTY
52813: PPUSH
52814: NOP4
52818: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52819: NOP4
52823: PUSH
52824: NOP4
52828: PPUSH
52829: NOP4
52833: PPUSH
52834: EMPTY
52835: PPUSH
52836: NOP4
52840: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52841: NOP4
52845: PUSH
52846: NOP4
52850: PPUSH
52851: NOP4
52855: PPUSH
52856: EMPTY
52857: PPUSH
52858: NOP4
52862: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52863: NOP4
52867: PUSH
52868: NOP4
52872: PPUSH
52873: NOP4
52877: PPUSH
52878: EMPTY
52879: PPUSH
52880: NOP4
52884: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52885: NOP4
52889: PUSH
52890: NOP4
52894: PPUSH
52895: NOP4
52899: PPUSH
52900: EMPTY
52901: PPUSH
52902: NOP4
52906: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52907: NOP4
52911: PUSH
52912: NOP4
52916: PPUSH
52917: NOP4
52921: PPUSH
52922: EMPTY
52923: PPUSH
52924: NOP4
52928: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52929: NOP4
52933: PUSH
52934: NOP4
52938: PPUSH
52939: NOP4
52943: PPUSH
52944: EMPTY
52945: PPUSH
52946: NOP4
52950: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52951: NOP4
52955: PUSH
52956: NOP4
52960: PPUSH
52961: NOP4
52965: PPUSH
52966: EMPTY
52967: PPUSH
52968: NOP4
52972: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52973: NOP4
52977: PUSH
52978: NOP4
52982: PPUSH
52983: NOP4
52987: PPUSH
52988: EMPTY
52989: PPUSH
52990: NOP4
52994: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52995: NOP4
52999: PUSH
53000: NOP4
53004: PPUSH
53005: NOP4
53009: PPUSH
53010: EMPTY
53011: PPUSH
53012: NOP4
53016: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53017: NOP4
53021: PUSH
53022: NOP4
53026: PPUSH
53027: NOP4
53031: PPUSH
53032: EMPTY
53033: PPUSH
53034: NOP4
53038: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53039: NOP4
53043: PUSH
53044: NOP4
53048: PPUSH
53049: NOP4
53053: PPUSH
53054: EMPTY
53055: PPUSH
53056: NOP4
53060: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53061: NOP4
53065: PUSH
53066: NOP4
53070: PPUSH
53071: NOP4
53075: PPUSH
53076: EMPTY
53077: PPUSH
53078: NOP4
53082: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53083: NOP4
53087: PUSH
53088: NOP4
53092: PPUSH
53093: NOP4
53097: PPUSH
53098: EMPTY
53099: PPUSH
53100: NOP4
53104: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53105: NOP4
53109: PUSH
53110: NOP4
53114: PPUSH
53115: NOP4
53119: PPUSH
53120: EMPTY
53121: PPUSH
53122: NOP4
53126: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53127: NOP4
53131: PUSH
53132: NOP4
53136: PPUSH
53137: NOP4
53141: PPUSH
53142: EMPTY
53143: PPUSH
53144: NOP4
53148: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53149: NOP4
53153: PUSH
53154: NOP4
53158: PPUSH
53159: NOP4
53163: PPUSH
53164: EMPTY
53165: PPUSH
53166: NOP4
53170: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53171: NOP4
53175: PUSH
53176: NOP4
53180: PPUSH
53181: NOP4
53185: PPUSH
53186: LD_INT 0
53188: PPUSH
53189: NOP4
53193: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53194: NOP4
53198: PUSH
53199: NOP4
53203: PPUSH
53204: NOP4
53208: PPUSH
53209: LD_INT 0
53211: PPUSH
53212: NOP4
53216: ST_TO_ADDR
// result := base ;
53217: NOP4
53221: PUSH
53222: NOP4
53226: ST_TO_ADDR
// end ;
53227: LD_VAR 0 3
53231: RET
// export function MC_Start ( ) ; var i ; begin
53232: LD_INT 0
53234: PPUSH
53235: PPUSH
// for i = 1 to mc_bases do
53236: NOP4
53240: PUSH
53241: DOUBLE
53242: LD_INT 1
53244: DEC
53245: ST_TO_ADDR
53246: NOP4
53250: PUSH
53251: FOR_TO
53252: IFFALSE 54352
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53254: NOP4
53258: PUSH
53259: NOP4
53263: PPUSH
53264: NOP4
53268: PPUSH
53269: NOP4
53273: PUSH
53274: NOP4
53278: ARRAY
53279: PUSH
53280: LD_INT 0
53282: DIFF
53283: PPUSH
53284: NOP4
53288: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53289: NOP4
53293: PUSH
53294: NOP4
53298: PPUSH
53299: NOP4
53303: PPUSH
53304: EMPTY
53305: PPUSH
53306: NOP4
53310: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53311: NOP4
53315: PUSH
53316: NOP4
53320: PPUSH
53321: NOP4
53325: PPUSH
53326: EMPTY
53327: PPUSH
53328: NOP4
53332: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53333: NOP4
53337: PUSH
53338: NOP4
53342: PPUSH
53343: NOP4
53347: PPUSH
53348: EMPTY
53349: PPUSH
53350: NOP4
53354: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53355: NOP4
53359: PUSH
53360: NOP4
53364: PPUSH
53365: NOP4
53369: PPUSH
53370: EMPTY
53371: PUSH
53372: EMPTY
53373: PUSH
53374: EMPTY
53375: LIST
53376: LIST
53377: PPUSH
53378: NOP4
53382: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53383: NOP4
53387: PUSH
53388: NOP4
53392: PPUSH
53393: NOP4
53397: PPUSH
53398: EMPTY
53399: PPUSH
53400: NOP4
53404: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53405: NOP4
53409: PUSH
53410: NOP4
53414: PPUSH
53415: NOP4
53419: PPUSH
53420: EMPTY
53421: PPUSH
53422: NOP4
53426: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53427: NOP4
53431: PUSH
53432: NOP4
53436: PPUSH
53437: NOP4
53441: PPUSH
53442: EMPTY
53443: PPUSH
53444: NOP4
53448: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53449: NOP4
53453: PUSH
53454: NOP4
53458: PPUSH
53459: NOP4
53463: PPUSH
53464: EMPTY
53465: PPUSH
53466: NOP4
53470: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53471: NOP4
53475: PUSH
53476: NOP4
53480: PPUSH
53481: NOP4
53485: PPUSH
53486: NOP4
53490: PUSH
53491: NOP4
53495: ARRAY
53496: PPUSH
53497: LD_INT 2
53499: PUSH
53500: LD_INT 30
53502: PUSH
53503: LD_INT 32
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: PUSH
53510: LD_INT 30
53512: PUSH
53513: LD_INT 33
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: PUSH
53520: EMPTY
53521: LIST
53522: LIST
53523: LIST
53524: PPUSH
53525: NOP4
53529: PPUSH
53530: NOP4
53534: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53535: NOP4
53539: PUSH
53540: NOP4
53544: PPUSH
53545: NOP4
53549: PPUSH
53550: NOP4
53554: PUSH
53555: NOP4
53559: ARRAY
53560: PPUSH
53561: LD_INT 2
53563: PUSH
53564: LD_INT 30
53566: PUSH
53567: LD_INT 32
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: PUSH
53574: LD_INT 30
53576: PUSH
53577: LD_INT 31
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: EMPTY
53585: LIST
53586: LIST
53587: LIST
53588: PUSH
53589: LD_INT 58
53591: PUSH
53592: EMPTY
53593: LIST
53594: PUSH
53595: EMPTY
53596: LIST
53597: LIST
53598: PPUSH
53599: NOP4
53603: PPUSH
53604: NOP4
53608: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53609: NOP4
53613: PUSH
53614: NOP4
53618: PPUSH
53619: NOP4
53623: PPUSH
53624: EMPTY
53625: PPUSH
53626: NOP4
53630: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53631: NOP4
53635: PUSH
53636: NOP4
53640: PPUSH
53641: NOP4
53645: PPUSH
53646: EMPTY
53647: PPUSH
53648: NOP4
53652: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53653: NOP4
53657: PUSH
53658: NOP4
53662: PPUSH
53663: NOP4
53667: PPUSH
53668: EMPTY
53669: PPUSH
53670: NOP4
53674: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53675: NOP4
53679: PUSH
53680: NOP4
53684: PPUSH
53685: NOP4
53689: PPUSH
53690: EMPTY
53691: PPUSH
53692: NOP4
53696: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53697: NOP4
53701: PUSH
53702: NOP4
53706: PPUSH
53707: NOP4
53711: PPUSH
53712: EMPTY
53713: PPUSH
53714: NOP4
53718: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53719: NOP4
53723: PUSH
53724: NOP4
53728: PPUSH
53729: NOP4
53733: PPUSH
53734: EMPTY
53735: PPUSH
53736: NOP4
53740: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53741: NOP4
53745: PUSH
53746: NOP4
53750: PPUSH
53751: NOP4
53755: PPUSH
53756: EMPTY
53757: PPUSH
53758: NOP4
53762: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53763: NOP4
53767: PUSH
53768: NOP4
53772: PPUSH
53773: NOP4
53777: PPUSH
53778: EMPTY
53779: PPUSH
53780: NOP4
53784: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53785: NOP4
53789: PUSH
53790: NOP4
53794: PPUSH
53795: NOP4
53799: PPUSH
53800: EMPTY
53801: PPUSH
53802: NOP4
53806: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53807: NOP4
53811: PUSH
53812: NOP4
53816: PPUSH
53817: NOP4
53821: PPUSH
53822: EMPTY
53823: PPUSH
53824: NOP4
53828: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53829: NOP4
53833: PUSH
53834: NOP4
53838: PPUSH
53839: NOP4
53843: PPUSH
53844: EMPTY
53845: PPUSH
53846: NOP4
53850: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53851: NOP4
53855: PUSH
53856: NOP4
53860: PPUSH
53861: NOP4
53865: PPUSH
53866: LD_INT 0
53868: PPUSH
53869: NOP4
53873: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53874: NOP4
53878: PUSH
53879: NOP4
53883: PPUSH
53884: NOP4
53888: PPUSH
53889: LD_INT 0
53891: PPUSH
53892: NOP4
53896: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53897: NOP4
53901: PUSH
53902: NOP4
53906: PPUSH
53907: NOP4
53911: PPUSH
53912: EMPTY
53913: PPUSH
53914: NOP4
53918: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53919: NOP4
53923: PUSH
53924: NOP4
53928: PPUSH
53929: NOP4
53933: PPUSH
53934: LD_INT 0
53936: PPUSH
53937: NOP4
53941: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53942: NOP4
53946: PUSH
53947: NOP4
53951: PPUSH
53952: NOP4
53956: PPUSH
53957: EMPTY
53958: PPUSH
53959: NOP4
53963: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53964: NOP4
53968: PUSH
53969: NOP4
53973: PPUSH
53974: NOP4
53978: PPUSH
53979: LD_INT 0
53981: PPUSH
53982: NOP4
53986: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53987: NOP4
53991: PUSH
53992: NOP4
53996: PPUSH
53997: NOP4
54001: PPUSH
54002: EMPTY
54003: PPUSH
54004: NOP4
54008: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54009: NOP4
54013: PUSH
54014: NOP4
54018: PPUSH
54019: NOP4
54023: PPUSH
54024: EMPTY
54025: PPUSH
54026: NOP4
54030: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54031: NOP4
54035: PUSH
54036: NOP4
54040: PPUSH
54041: NOP4
54045: PPUSH
54046: EMPTY
54047: PPUSH
54048: NOP4
54052: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54053: NOP4
54057: PUSH
54058: NOP4
54062: PPUSH
54063: NOP4
54067: PPUSH
54068: NOP4
54072: PUSH
54073: NOP4
54077: ARRAY
54078: PPUSH
54079: LD_INT 2
54081: PUSH
54082: LD_INT 30
54084: PUSH
54085: LD_INT 6
54087: PUSH
54088: EMPTY
54089: LIST
54090: LIST
54091: PUSH
54092: LD_INT 30
54094: PUSH
54095: LD_INT 7
54097: PUSH
54098: EMPTY
54099: LIST
54100: LIST
54101: PUSH
54102: LD_INT 30
54104: PUSH
54105: LD_INT 8
54107: PUSH
54108: EMPTY
54109: LIST
54110: LIST
54111: PUSH
54112: EMPTY
54113: LIST
54114: LIST
54115: LIST
54116: LIST
54117: PPUSH
54118: NOP4
54122: PPUSH
54123: NOP4
54127: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54128: NOP4
54132: PUSH
54133: NOP4
54137: PPUSH
54138: NOP4
54142: PPUSH
54143: EMPTY
54144: PPUSH
54145: NOP4
54149: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54150: NOP4
54154: PUSH
54155: NOP4
54159: PPUSH
54160: NOP4
54164: PPUSH
54165: EMPTY
54166: PPUSH
54167: NOP4
54171: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54172: NOP4
54176: PUSH
54177: NOP4
54181: PPUSH
54182: NOP4
54186: PPUSH
54187: EMPTY
54188: PPUSH
54189: NOP4
54193: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54194: NOP4
54198: PUSH
54199: NOP4
54203: PPUSH
54204: NOP4
54208: PPUSH
54209: EMPTY
54210: PPUSH
54211: NOP4
54215: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54216: NOP4
54220: PUSH
54221: NOP4
54225: PPUSH
54226: NOP4
54230: PPUSH
54231: EMPTY
54232: PPUSH
54233: NOP4
54237: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54238: NOP4
54242: PUSH
54243: NOP4
54247: PPUSH
54248: NOP4
54252: PPUSH
54253: EMPTY
54254: PPUSH
54255: NOP4
54259: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54260: NOP4
54264: PUSH
54265: NOP4
54269: PPUSH
54270: NOP4
54274: PPUSH
54275: EMPTY
54276: PPUSH
54277: NOP4
54281: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54282: NOP4
54286: PUSH
54287: NOP4
54291: PPUSH
54292: NOP4
54296: PPUSH
54297: EMPTY
54298: PPUSH
54299: NOP4
54303: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54304: NOP4
54308: PUSH
54309: NOP4
54313: PPUSH
54314: NOP4
54318: PPUSH
54319: LD_INT 0
54321: PPUSH
54322: NOP4
54326: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54327: NOP4
54331: PUSH
54332: NOP4
54336: PPUSH
54337: NOP4
54341: PPUSH
54342: LD_INT 0
54344: PPUSH
54345: NOP4
54349: ST_TO_ADDR
// end ;
54350: GO 53251
54352: POP
54353: POP
// MC_InitSides ( ) ;
54354: NOP4
// MC_InitResearch ( ) ;
54358: NOP4
// CustomInitMacro ( ) ;
54362: NOP4
// skirmish := true ;
54366: NOP4
54370: PUSH
54371: LD_INT 1
54373: ST_TO_ADDR
// end ;
54374: LD_VAR 0 1
54378: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54379: LD_INT 0
54381: PPUSH
54382: PPUSH
54383: PPUSH
54384: PPUSH
54385: PPUSH
54386: PPUSH
// if not mc_bases then
54387: NOP4
54391: NOT
54392: IFFALSE 54396
// exit ;
54394: GO 54635
// for i = 1 to 8 do
54396: NOP4
54400: PUSH
54401: DOUBLE
54402: LD_INT 1
54404: DEC
54405: ST_TO_ADDR
54406: LD_INT 8
54408: PUSH
54409: FOR_TO
54410: IFFALSE 54436
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54412: NOP4
54416: PUSH
54417: NOP4
54421: PPUSH
54422: NOP4
54426: PPUSH
54427: EMPTY
54428: PPUSH
54429: NOP4
54433: ST_TO_ADDR
54434: GO 54409
54436: POP
54437: POP
// tmp := [ ] ;
54438: NOP4
54442: PUSH
54443: EMPTY
54444: ST_TO_ADDR
// for i = 1 to mc_sides do
54445: NOP4
54449: PUSH
54450: DOUBLE
54451: LD_INT 1
54453: DEC
54454: ST_TO_ADDR
54455: NOP4
54459: PUSH
54460: FOR_TO
54461: IFFALSE 54519
// if not mc_sides [ i ] in tmp then
54463: NOP4
54467: PUSH
54468: NOP4
54472: ARRAY
54473: PUSH
54474: NOP4
54478: IN
54479: NOT
54480: IFFALSE 54517
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54482: NOP4
54486: PUSH
54487: NOP4
54491: PPUSH
54492: NOP4
54496: PUSH
54497: LD_INT 1
54499: PLUS
54500: PPUSH
54501: NOP4
54505: PUSH
54506: NOP4
54510: ARRAY
54511: PPUSH
54512: NOP4
54516: ST_TO_ADDR
54517: GO 54460
54519: POP
54520: POP
// if not tmp then
54521: NOP4
54525: NOT
54526: IFFALSE 54530
// exit ;
54528: GO 54635
// for j in tmp do
54530: NOP4
54534: PUSH
54535: NOP4
54539: PUSH
54540: FOR_IN
54541: IFFALSE 54633
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54543: NOP4
54547: PUSH
54548: LD_INT 22
54550: PUSH
54551: NOP4
54555: PUSH
54556: EMPTY
54557: LIST
54558: LIST
54559: PPUSH
54560: NOP4
54564: ST_TO_ADDR
// if not un then
54565: NOP4
54569: NOT
54570: IFFALSE 54574
// continue ;
54572: GO 54540
// nation := GetNation ( un [ 1 ] ) ;
54574: NOP4
54578: PUSH
54579: NOP4
54583: PUSH
54584: LD_INT 1
54586: ARRAY
54587: PPUSH
54588: NOP4
54592: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54593: NOP4
54597: PUSH
54598: NOP4
54602: PPUSH
54603: NOP4
54607: PPUSH
54608: NOP4
54612: PPUSH
54613: NOP4
54617: PPUSH
54618: LD_INT 1
54620: PPUSH
54621: NOP4
54625: PPUSH
54626: NOP4
54630: ST_TO_ADDR
// end ;
54631: GO 54540
54633: POP
54634: POP
// end ;
54635: LD_VAR 0 1
54639: RET
// export function MC_InitSides ( ) ; var i ; begin
54640: LD_INT 0
54642: PPUSH
54643: PPUSH
// if not mc_bases then
54644: NOP4
54648: NOT
54649: IFFALSE 54653
// exit ;
54651: GO 54727
// for i = 1 to mc_bases do
54653: NOP4
54657: PUSH
54658: DOUBLE
54659: LD_INT 1
54661: DEC
54662: ST_TO_ADDR
54663: NOP4
54667: PUSH
54668: FOR_TO
54669: IFFALSE 54725
// if mc_bases [ i ] then
54671: NOP4
54675: PUSH
54676: NOP4
54680: ARRAY
54681: IFFALSE 54723
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54683: NOP4
54687: PUSH
54688: NOP4
54692: PPUSH
54693: NOP4
54697: PPUSH
54698: NOP4
54702: PUSH
54703: NOP4
54707: ARRAY
54708: PUSH
54709: LD_INT 1
54711: ARRAY
54712: PPUSH
54713: NOP4
54717: PPUSH
54718: NOP4
54722: ST_TO_ADDR
54723: GO 54668
54725: POP
54726: POP
// end ;
54727: LD_VAR 0 1
54731: RET
// every 0 0$03 trigger skirmish do
54732: NOP4
54736: IFFALSE 54890
54738: GO 54740
54740: DISABLE
// begin enable ;
54741: ENABLE
// MC_CheckBuildings ( ) ;
54742: NOP4
// MC_CheckPeopleLife ( ) ;
54746: NOP4
// RaiseSailEvent ( 100 ) ;
54750: LD_INT 100
54752: PPUSH
54753: NOP4
// RaiseSailEvent ( 103 ) ;
54757: LD_INT 103
54759: PPUSH
54760: NOP4
// RaiseSailEvent ( 104 ) ;
54764: LD_INT 104
54766: PPUSH
54767: NOP4
// RaiseSailEvent ( 105 ) ;
54771: LD_INT 105
54773: PPUSH
54774: NOP4
// RaiseSailEvent ( 106 ) ;
54778: LD_INT 106
54780: PPUSH
54781: NOP4
// RaiseSailEvent ( 107 ) ;
54785: LD_INT 107
54787: PPUSH
54788: NOP4
// RaiseSailEvent ( 108 ) ;
54792: LD_INT 108
54794: PPUSH
54795: NOP4
// RaiseSailEvent ( 109 ) ;
54799: LD_INT 109
54801: PPUSH
54802: NOP4
// RaiseSailEvent ( 110 ) ;
54806: LD_INT 110
54808: PPUSH
54809: NOP4
// RaiseSailEvent ( 111 ) ;
54813: LD_INT 111
54815: PPUSH
54816: NOP4
// RaiseSailEvent ( 112 ) ;
54820: LD_INT 112
54822: PPUSH
54823: NOP4
// RaiseSailEvent ( 113 ) ;
54827: LD_INT 113
54829: PPUSH
54830: NOP4
// RaiseSailEvent ( 120 ) ;
54834: LD_INT 120
54836: PPUSH
54837: NOP4
// RaiseSailEvent ( 121 ) ;
54841: LD_INT 121
54843: PPUSH
54844: NOP4
// RaiseSailEvent ( 122 ) ;
54848: LD_INT 122
54850: PPUSH
54851: NOP4
// RaiseSailEvent ( 123 ) ;
54855: LD_INT 123
54857: PPUSH
54858: NOP4
// RaiseSailEvent ( 124 ) ;
54862: LD_INT 124
54864: PPUSH
54865: NOP4
// RaiseSailEvent ( 125 ) ;
54869: LD_INT 125
54871: PPUSH
54872: NOP4
// RaiseSailEvent ( 126 ) ;
54876: LD_INT 126
54878: PPUSH
54879: NOP4
// RaiseSailEvent ( 200 ) ;
54883: LD_INT 200
54885: PPUSH
54886: NOP4
// end ;
54890: END
// on SailEvent ( event ) do begin if event < 100 then
54891: NOP4
54895: PUSH
54896: LD_INT 100
54898: LESS
54899: IFFALSE 54910
// CustomEvent ( event ) ;
54901: NOP4
54905: PPUSH
54906: NOP4
// if event = 100 then
54910: NOP4
54914: PUSH
54915: LD_INT 100
54917: EQUAL
54918: IFFALSE 54924
// MC_ClassManager ( ) ;
54920: NOP4
// if event = 101 then
54924: NOP4
54928: PUSH
54929: LD_INT 101
54931: EQUAL
54932: IFFALSE 54938
// MC_RepairBuildings ( ) ;
54934: NOP4
// if event = 102 then
54938: NOP4
54942: PUSH
54943: LD_INT 102
54945: EQUAL
54946: IFFALSE 54952
// MC_Heal ( ) ;
54948: NOP4
// if event = 103 then
54952: NOP4
54956: PUSH
54957: LD_INT 103
54959: EQUAL
54960: IFFALSE 54966
// MC_Build ( ) ;
54962: NOP4
// if event = 104 then
54966: NOP4
54970: PUSH
54971: LD_INT 104
54973: EQUAL
54974: IFFALSE 54980
// MC_TurretWeapon ( ) ;
54976: NOP4
// if event = 105 then
54980: NOP4
54984: PUSH
54985: LD_INT 105
54987: EQUAL
54988: IFFALSE 54994
// MC_BuildUpgrade ( ) ;
54990: NOP4
// if event = 106 then
54994: NOP4
54998: PUSH
54999: LD_INT 106
55001: EQUAL
55002: IFFALSE 55008
// MC_PlantMines ( ) ;
55004: NOP4
// if event = 107 then
55008: NOP4
55012: PUSH
55013: LD_INT 107
55015: EQUAL
55016: IFFALSE 55022
// MC_CollectCrates ( ) ;
55018: NOP4
// if event = 108 then
55022: NOP4
55026: PUSH
55027: LD_INT 108
55029: EQUAL
55030: IFFALSE 55036
// MC_LinkRemoteControl ( ) ;
55032: NOP4
// if event = 109 then
55036: NOP4
55040: PUSH
55041: LD_INT 109
55043: EQUAL
55044: IFFALSE 55050
// MC_ProduceVehicle ( ) ;
55046: NOP4
// if event = 110 then
55050: NOP4
55054: PUSH
55055: LD_INT 110
55057: EQUAL
55058: IFFALSE 55064
// MC_SendAttack ( ) ;
55060: NOP4
// if event = 111 then
55064: NOP4
55068: PUSH
55069: LD_INT 111
55071: EQUAL
55072: IFFALSE 55078
// MC_Defend ( ) ;
55074: NOP4
// if event = 112 then
55078: NOP4
55082: PUSH
55083: LD_INT 112
55085: EQUAL
55086: IFFALSE 55092
// MC_Research ( ) ;
55088: NOP4
// if event = 113 then
55092: NOP4
55096: PUSH
55097: LD_INT 113
55099: EQUAL
55100: IFFALSE 55106
// MC_MinesTrigger ( ) ;
55102: NOP4
// if event = 120 then
55106: NOP4
55110: PUSH
55111: LD_INT 120
55113: EQUAL
55114: IFFALSE 55120
// MC_RepairVehicle ( ) ;
55116: NOP4
// if event = 121 then
55120: NOP4
55124: PUSH
55125: LD_INT 121
55127: EQUAL
55128: IFFALSE 55134
// MC_TameApe ( ) ;
55130: NOP4
// if event = 122 then
55134: NOP4
55138: PUSH
55139: LD_INT 122
55141: EQUAL
55142: IFFALSE 55148
// MC_ChangeApeClass ( ) ;
55144: NOP4
// if event = 123 then
55148: NOP4
55152: PUSH
55153: LD_INT 123
55155: EQUAL
55156: IFFALSE 55162
// MC_Bazooka ( ) ;
55158: NOP4
// if event = 124 then
55162: NOP4
55166: PUSH
55167: LD_INT 124
55169: EQUAL
55170: IFFALSE 55176
// MC_TeleportExit ( ) ;
55172: NOP4
// if event = 125 then
55176: NOP4
55180: PUSH
55181: LD_INT 125
55183: EQUAL
55184: IFFALSE 55190
// MC_Deposits ( ) ;
55186: NOP4
// if event = 126 then
55190: NOP4
55194: PUSH
55195: LD_INT 126
55197: EQUAL
55198: IFFALSE 55204
// MC_RemoteDriver ( ) ;
55200: NOP4
// if event = 200 then
55204: NOP4
55208: PUSH
55209: LD_INT 200
55211: EQUAL
55212: IFFALSE 55218
// MC_Idle ( ) ;
55214: NOP4
// end ;
55218: PPOPN 1
55220: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55221: LD_INT 0
55223: PPUSH
55224: PPUSH
// if not mc_bases [ base ] or not tag then
55225: NOP4
55229: PUSH
55230: NOP4
55234: ARRAY
55235: NOT
55236: PUSH
55237: NOP4
55241: NOT
55242: OR
55243: IFFALSE 55247
// exit ;
55245: GO 55311
// for i in mc_bases [ base ] union mc_ape [ base ] do
55247: NOP4
55251: PUSH
55252: NOP4
55256: PUSH
55257: NOP4
55261: ARRAY
55262: PUSH
55263: NOP4
55267: PUSH
55268: NOP4
55272: ARRAY
55273: UNION
55274: PUSH
55275: FOR_IN
55276: IFFALSE 55309
// if GetTag ( i ) = tag then
55278: NOP4
55282: PPUSH
55283: NOP4
55287: PUSH
55288: NOP4
55292: EQUAL
55293: IFFALSE 55307
// SetTag ( i , 0 ) ;
55295: NOP4
55299: PPUSH
55300: LD_INT 0
55302: PPUSH
55303: NOP4
55307: GO 55275
55309: POP
55310: POP
// end ;
55311: LD_VAR 0 3
55315: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55316: LD_INT 0
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
55322: PPUSH
55323: PPUSH
55324: PPUSH
55325: PPUSH
// if not mc_bases then
55326: NOP4
55330: NOT
55331: IFFALSE 55335
// exit ;
55333: GO 55793
// for i = 1 to mc_bases do
55335: NOP4
55339: PUSH
55340: DOUBLE
55341: LD_INT 1
55343: DEC
55344: ST_TO_ADDR
55345: NOP4
55349: PUSH
55350: FOR_TO
55351: IFFALSE 55791
// begin tmp := MC_ClassCheckReq ( i ) ;
55353: NOP4
55357: PUSH
55358: NOP4
55362: PPUSH
55363: NOP4
55367: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55368: NOP4
55372: PUSH
55373: NOP4
55377: PPUSH
55378: NOP4
55382: PPUSH
55383: NOP4
55387: PPUSH
55388: NOP4
55392: ST_TO_ADDR
// if not tmp then
55393: NOP4
55397: NOT
55398: IFFALSE 55402
// continue ;
55400: GO 55350
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55402: NOP4
55406: PUSH
55407: NOP4
55411: PUSH
55412: NOP4
55416: ARRAY
55417: PPUSH
55418: LD_INT 2
55420: PUSH
55421: LD_INT 30
55423: PUSH
55424: LD_INT 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 30
55433: PUSH
55434: LD_INT 5
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: LIST
55445: PPUSH
55446: NOP4
55450: PUSH
55451: NOP4
55455: PUSH
55456: NOP4
55460: ARRAY
55461: PPUSH
55462: LD_INT 2
55464: PUSH
55465: LD_INT 30
55467: PUSH
55468: LD_INT 0
55470: PUSH
55471: EMPTY
55472: LIST
55473: LIST
55474: PUSH
55475: LD_INT 30
55477: PUSH
55478: LD_INT 1
55480: PUSH
55481: EMPTY
55482: LIST
55483: LIST
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: LIST
55489: PPUSH
55490: NOP4
55494: PUSH
55495: NOP4
55499: PUSH
55500: NOP4
55504: ARRAY
55505: PPUSH
55506: LD_INT 30
55508: PUSH
55509: LD_INT 3
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: PPUSH
55516: NOP4
55520: PUSH
55521: NOP4
55525: PUSH
55526: NOP4
55530: ARRAY
55531: PPUSH
55532: LD_INT 2
55534: PUSH
55535: LD_INT 30
55537: PUSH
55538: LD_INT 6
55540: PUSH
55541: EMPTY
55542: LIST
55543: LIST
55544: PUSH
55545: LD_INT 30
55547: PUSH
55548: LD_INT 7
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: PUSH
55555: LD_INT 30
55557: PUSH
55558: LD_INT 8
55560: PUSH
55561: EMPTY
55562: LIST
55563: LIST
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: LIST
55569: LIST
55570: PPUSH
55571: NOP4
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: LIST
55580: LIST
55581: ST_TO_ADDR
// for j = 1 to 4 do
55582: NOP4
55586: PUSH
55587: DOUBLE
55588: LD_INT 1
55590: DEC
55591: ST_TO_ADDR
55592: LD_INT 4
55594: PUSH
55595: FOR_TO
55596: IFFALSE 55787
// begin if not tmp [ j ] then
55598: NOP4
55602: PUSH
55603: NOP4
55607: ARRAY
55608: NOT
55609: IFFALSE 55613
// continue ;
55611: GO 55595
// for p in tmp [ j ] do
55613: NOP4
55617: PUSH
55618: NOP4
55622: PUSH
55623: NOP4
55627: ARRAY
55628: PUSH
55629: FOR_IN
55630: IFFALSE 55783
// begin if not b [ j ] then
55632: NOP4
55636: PUSH
55637: NOP4
55641: ARRAY
55642: NOT
55643: IFFALSE 55647
// break ;
55645: GO 55783
// e := 0 ;
55647: NOP4
55651: PUSH
55652: LD_INT 0
55654: ST_TO_ADDR
// for k in b [ j ] do
55655: NOP4
55659: PUSH
55660: NOP4
55664: PUSH
55665: NOP4
55669: ARRAY
55670: PUSH
55671: FOR_IN
55672: IFFALSE 55699
// if IsNotFull ( k ) then
55674: NOP4
55678: PPUSH
55679: NOP4
55683: IFFALSE 55697
// begin e := k ;
55685: NOP4
55689: PUSH
55690: NOP4
55694: ST_TO_ADDR
// break ;
55695: GO 55699
// end ;
55697: GO 55671
55699: POP
55700: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55701: NOP4
55705: PUSH
55706: NOP4
55710: PPUSH
55711: NOP4
55715: PPUSH
55716: NOP4
55720: NOT
55721: AND
55722: IFFALSE 55781
// begin if IsInUnit ( p ) then
55724: NOP4
55728: PPUSH
55729: NOP4
55733: IFFALSE 55744
// ComExitBuilding ( p ) ;
55735: NOP4
55739: PPUSH
55740: NOP4
// ComEnterUnit ( p , e ) ;
55744: NOP4
55748: PPUSH
55749: NOP4
55753: PPUSH
55754: NOP4
// AddComChangeProfession ( p , j ) ;
55758: NOP4
55762: PPUSH
55763: NOP4
55767: PPUSH
55768: NOP4
// AddComExitBuilding ( p ) ;
55772: NOP4
55776: PPUSH
55777: NOP4
// end ; end ;
55781: GO 55629
55783: POP
55784: POP
// end ;
55785: GO 55595
55787: POP
55788: POP
// end ;
55789: GO 55350
55791: POP
55792: POP
// end ;
55793: LD_VAR 0 1
55797: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55798: LD_INT 0
55800: PPUSH
55801: PPUSH
55802: PPUSH
55803: PPUSH
55804: PPUSH
55805: PPUSH
55806: PPUSH
55807: PPUSH
55808: PPUSH
55809: PPUSH
55810: PPUSH
55811: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55812: NOP4
55816: NOT
55817: PUSH
55818: NOP4
55822: PUSH
55823: NOP4
55827: ARRAY
55828: NOT
55829: OR
55830: PUSH
55831: NOP4
55835: PUSH
55836: NOP4
55840: ARRAY
55841: PPUSH
55842: LD_INT 2
55844: PUSH
55845: LD_INT 30
55847: PUSH
55848: LD_INT 0
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PUSH
55855: LD_INT 30
55857: PUSH
55858: LD_INT 1
55860: PUSH
55861: EMPTY
55862: LIST
55863: LIST
55864: PUSH
55865: EMPTY
55866: LIST
55867: LIST
55868: LIST
55869: PPUSH
55870: NOP4
55874: NOT
55875: OR
55876: IFFALSE 55880
// exit ;
55878: GO 59383
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55880: NOP4
55884: PUSH
55885: NOP4
55889: PUSH
55890: NOP4
55894: ARRAY
55895: PPUSH
55896: LD_INT 2
55898: PUSH
55899: LD_INT 25
55901: PUSH
55902: LD_INT 1
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: PUSH
55909: LD_INT 25
55911: PUSH
55912: LD_INT 2
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: LD_INT 25
55921: PUSH
55922: LD_INT 3
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PUSH
55929: LD_INT 25
55931: PUSH
55932: LD_INT 4
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: LD_INT 25
55941: PUSH
55942: LD_INT 5
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: PUSH
55949: LD_INT 25
55951: PUSH
55952: LD_INT 8
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: PUSH
55959: LD_INT 25
55961: PUSH
55962: LD_INT 9
55964: PUSH
55965: EMPTY
55966: LIST
55967: LIST
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: LIST
55973: LIST
55974: LIST
55975: LIST
55976: LIST
55977: LIST
55978: PPUSH
55979: NOP4
55983: ST_TO_ADDR
// if not tmp then
55984: NOP4
55988: NOT
55989: IFFALSE 55993
// exit ;
55991: GO 59383
// for i in tmp do
55993: NOP4
55997: PUSH
55998: NOP4
56002: PUSH
56003: FOR_IN
56004: IFFALSE 56035
// if GetTag ( i ) then
56006: NOP4
56010: PPUSH
56011: NOP4
56015: IFFALSE 56033
// tmp := tmp diff i ;
56017: NOP4
56021: PUSH
56022: NOP4
56026: PUSH
56027: NOP4
56031: DIFF
56032: ST_TO_ADDR
56033: GO 56003
56035: POP
56036: POP
// if not tmp then
56037: NOP4
56041: NOT
56042: IFFALSE 56046
// exit ;
56044: GO 59383
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56046: NOP4
56050: PUSH
56051: NOP4
56055: PUSH
56056: NOP4
56060: ARRAY
56061: PPUSH
56062: LD_INT 2
56064: PUSH
56065: LD_INT 25
56067: PUSH
56068: LD_INT 1
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: PUSH
56075: LD_INT 25
56077: PUSH
56078: LD_INT 5
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: PUSH
56085: LD_INT 25
56087: PUSH
56088: LD_INT 8
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: PUSH
56095: LD_INT 25
56097: PUSH
56098: LD_INT 9
56100: PUSH
56101: EMPTY
56102: LIST
56103: LIST
56104: PUSH
56105: EMPTY
56106: LIST
56107: LIST
56108: LIST
56109: LIST
56110: LIST
56111: PPUSH
56112: NOP4
56116: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56117: NOP4
56121: PUSH
56122: NOP4
56126: PUSH
56127: NOP4
56131: ARRAY
56132: PPUSH
56133: LD_INT 25
56135: PUSH
56136: LD_INT 2
56138: PUSH
56139: EMPTY
56140: LIST
56141: LIST
56142: PPUSH
56143: NOP4
56147: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56148: NOP4
56152: PUSH
56153: NOP4
56157: PUSH
56158: NOP4
56162: ARRAY
56163: PPUSH
56164: LD_INT 25
56166: PUSH
56167: LD_INT 3
56169: PUSH
56170: EMPTY
56171: LIST
56172: LIST
56173: PPUSH
56174: NOP4
56178: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56179: NOP4
56183: PUSH
56184: NOP4
56188: PUSH
56189: NOP4
56193: ARRAY
56194: PPUSH
56195: LD_INT 25
56197: PUSH
56198: LD_INT 4
56200: PUSH
56201: EMPTY
56202: LIST
56203: LIST
56204: PUSH
56205: LD_INT 24
56207: PUSH
56208: LD_INT 251
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: PPUSH
56219: NOP4
56223: ST_TO_ADDR
// if mc_is_defending [ base ] then
56224: NOP4
56228: PUSH
56229: NOP4
56233: ARRAY
56234: IFFALSE 56695
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56236: NOP4
56240: PUSH
56241: NOP4
56245: PPUSH
56246: NOP4
56250: PPUSH
56251: LD_INT 4
56253: PPUSH
56254: NOP4
56258: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56259: NOP4
56263: PUSH
56264: NOP4
56268: PUSH
56269: NOP4
56273: ARRAY
56274: PPUSH
56275: LD_INT 2
56277: PUSH
56278: LD_INT 30
56280: PUSH
56281: LD_INT 4
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: PUSH
56288: LD_INT 30
56290: PUSH
56291: LD_INT 5
56293: PUSH
56294: EMPTY
56295: LIST
56296: LIST
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: LIST
56302: PPUSH
56303: NOP4
56307: ST_TO_ADDR
// if not b then
56308: NOP4
56312: NOT
56313: IFFALSE 56317
// exit ;
56315: GO 59383
// p := [ ] ;
56317: NOP4
56321: PUSH
56322: EMPTY
56323: ST_TO_ADDR
// if sci >= 2 then
56324: NOP4
56328: PUSH
56329: LD_INT 2
56331: GREATEREQUAL
56332: IFFALSE 56363
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56334: NOP4
56338: PUSH
56339: NOP4
56343: PUSH
56344: LD_INT 1
56346: ARRAY
56347: PUSH
56348: NOP4
56352: PUSH
56353: LD_INT 2
56355: ARRAY
56356: PUSH
56357: EMPTY
56358: LIST
56359: LIST
56360: ST_TO_ADDR
56361: GO 56424
// if sci = 1 then
56363: NOP4
56367: PUSH
56368: LD_INT 1
56370: EQUAL
56371: IFFALSE 56392
// sci := [ sci [ 1 ] ] else
56373: NOP4
56377: PUSH
56378: NOP4
56382: PUSH
56383: LD_INT 1
56385: ARRAY
56386: PUSH
56387: EMPTY
56388: LIST
56389: ST_TO_ADDR
56390: GO 56424
// if sci = 0 then
56392: NOP4
56396: PUSH
56397: LD_INT 0
56399: EQUAL
56400: IFFALSE 56424
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56402: NOP4
56406: PUSH
56407: NOP4
56411: PPUSH
56412: LD_INT 4
56414: PPUSH
56415: NOP4
56419: PUSH
56420: LD_INT 1
56422: ARRAY
56423: ST_TO_ADDR
// if eng > 4 then
56424: NOP4
56428: PUSH
56429: LD_INT 4
56431: GREATER
56432: IFFALSE 56478
// for i = eng downto 4 do
56434: NOP4
56438: PUSH
56439: DOUBLE
56440: NOP4
56444: INC
56445: ST_TO_ADDR
56446: LD_INT 4
56448: PUSH
56449: FOR_DOWNTO
56450: IFFALSE 56476
// eng := eng diff eng [ i ] ;
56452: NOP4
56456: PUSH
56457: NOP4
56461: PUSH
56462: NOP4
56466: PUSH
56467: NOP4
56471: ARRAY
56472: DIFF
56473: ST_TO_ADDR
56474: GO 56449
56476: POP
56477: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56478: NOP4
56482: PUSH
56483: NOP4
56487: PUSH
56488: NOP4
56492: PUSH
56493: NOP4
56497: UNION
56498: PUSH
56499: NOP4
56503: UNION
56504: PUSH
56505: NOP4
56509: UNION
56510: DIFF
56511: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56512: NOP4
56516: PUSH
56517: NOP4
56521: PUSH
56522: NOP4
56526: ARRAY
56527: PPUSH
56528: LD_INT 2
56530: PUSH
56531: LD_INT 30
56533: PUSH
56534: LD_INT 32
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: PUSH
56541: LD_INT 30
56543: PUSH
56544: LD_INT 31
56546: PUSH
56547: EMPTY
56548: LIST
56549: LIST
56550: PUSH
56551: EMPTY
56552: LIST
56553: LIST
56554: LIST
56555: PPUSH
56556: NOP4
56560: PUSH
56561: NOP4
56565: PUSH
56566: NOP4
56570: ARRAY
56571: PPUSH
56572: LD_INT 2
56574: PUSH
56575: LD_INT 30
56577: PUSH
56578: LD_INT 4
56580: PUSH
56581: EMPTY
56582: LIST
56583: LIST
56584: PUSH
56585: LD_INT 30
56587: PUSH
56588: LD_INT 5
56590: PUSH
56591: EMPTY
56592: LIST
56593: LIST
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: LIST
56599: PPUSH
56600: NOP4
56604: PUSH
56605: LD_INT 6
56607: MUL
56608: PLUS
56609: ST_TO_ADDR
// if bcount < tmp then
56610: NOP4
56614: PUSH
56615: NOP4
56619: LESS
56620: IFFALSE 56666
// for i = tmp downto bcount do
56622: NOP4
56626: PUSH
56627: DOUBLE
56628: NOP4
56632: INC
56633: ST_TO_ADDR
56634: NOP4
56638: PUSH
56639: FOR_DOWNTO
56640: IFFALSE 56664
// tmp := Delete ( tmp , tmp ) ;
56642: NOP4
56646: PUSH
56647: NOP4
56651: PPUSH
56652: NOP4
56656: PPUSH
56657: NOP4
56661: ST_TO_ADDR
56662: GO 56639
56664: POP
56665: POP
// result := [ tmp , 0 , 0 , p ] ;
56666: NOP4
56670: PUSH
56671: NOP4
56675: PUSH
56676: LD_INT 0
56678: PUSH
56679: LD_INT 0
56681: PUSH
56682: NOP4
56686: PUSH
56687: EMPTY
56688: LIST
56689: LIST
56690: LIST
56691: LIST
56692: ST_TO_ADDR
// exit ;
56693: GO 59383
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56695: NOP4
56699: PUSH
56700: NOP4
56704: ARRAY
56705: PPUSH
56706: LD_INT 2
56708: PUSH
56709: LD_INT 30
56711: PUSH
56712: LD_INT 6
56714: PUSH
56715: EMPTY
56716: LIST
56717: LIST
56718: PUSH
56719: LD_INT 30
56721: PUSH
56722: LD_INT 7
56724: PUSH
56725: EMPTY
56726: LIST
56727: LIST
56728: PUSH
56729: LD_INT 30
56731: PUSH
56732: LD_INT 8
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: LIST
56743: LIST
56744: PPUSH
56745: NOP4
56749: NOT
56750: PUSH
56751: NOP4
56755: PUSH
56756: NOP4
56760: ARRAY
56761: PPUSH
56762: LD_INT 30
56764: PUSH
56765: LD_INT 3
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PPUSH
56772: NOP4
56776: NOT
56777: AND
56778: IFFALSE 56850
// begin if eng = tmp then
56780: NOP4
56784: PUSH
56785: NOP4
56789: EQUAL
56790: IFFALSE 56794
// exit ;
56792: GO 59383
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56794: NOP4
56798: PUSH
56799: NOP4
56803: PPUSH
56804: NOP4
56808: PPUSH
56809: LD_INT 1
56811: PPUSH
56812: NOP4
56816: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56817: NOP4
56821: PUSH
56822: LD_INT 0
56824: PUSH
56825: NOP4
56829: PUSH
56830: NOP4
56834: DIFF
56835: PUSH
56836: LD_INT 0
56838: PUSH
56839: LD_INT 0
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: LIST
56846: LIST
56847: ST_TO_ADDR
// exit ;
56848: GO 59383
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56850: NOP4
56854: PUSH
56855: NOP4
56859: PUSH
56860: NOP4
56864: ARRAY
56865: ARRAY
56866: PUSH
56867: NOP4
56871: PUSH
56872: NOP4
56876: ARRAY
56877: PPUSH
56878: LD_INT 2
56880: PUSH
56881: LD_INT 30
56883: PUSH
56884: LD_INT 6
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: PUSH
56891: LD_INT 30
56893: PUSH
56894: LD_INT 7
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: PUSH
56901: LD_INT 30
56903: PUSH
56904: LD_INT 8
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: PUSH
56911: EMPTY
56912: LIST
56913: LIST
56914: LIST
56915: LIST
56916: PPUSH
56917: NOP4
56921: AND
56922: PUSH
56923: NOP4
56927: PUSH
56928: NOP4
56932: ARRAY
56933: PPUSH
56934: LD_INT 30
56936: PUSH
56937: LD_INT 3
56939: PUSH
56940: EMPTY
56941: LIST
56942: LIST
56943: PPUSH
56944: NOP4
56948: NOT
56949: AND
56950: IFFALSE 57164
// begin if sci >= 6 then
56952: NOP4
56956: PUSH
56957: LD_INT 6
56959: GREATEREQUAL
56960: IFFALSE 56964
// exit ;
56962: GO 59383
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56964: NOP4
56968: PUSH
56969: NOP4
56973: PPUSH
56974: NOP4
56978: PPUSH
56979: LD_INT 2
56981: PPUSH
56982: NOP4
56986: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56987: NOP4
56991: PUSH
56992: NOP4
56996: PUSH
56997: NOP4
57001: DIFF
57002: PPUSH
57003: LD_INT 4
57005: PPUSH
57006: NOP4
57010: ST_TO_ADDR
// p := [ ] ;
57011: NOP4
57015: PUSH
57016: EMPTY
57017: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57018: NOP4
57022: PUSH
57023: LD_INT 6
57025: LESS
57026: PUSH
57027: NOP4
57031: PUSH
57032: LD_INT 6
57034: GREATER
57035: AND
57036: IFFALSE 57117
// begin for i = 1 to 6 - sci do
57038: NOP4
57042: PUSH
57043: DOUBLE
57044: LD_INT 1
57046: DEC
57047: ST_TO_ADDR
57048: LD_INT 6
57050: PUSH
57051: NOP4
57055: MINUS
57056: PUSH
57057: FOR_TO
57058: IFFALSE 57113
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57060: NOP4
57064: PUSH
57065: NOP4
57069: PPUSH
57070: NOP4
57074: PUSH
57075: LD_INT 1
57077: PLUS
57078: PPUSH
57079: NOP4
57083: PUSH
57084: LD_INT 1
57086: ARRAY
57087: PPUSH
57088: NOP4
57092: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57093: NOP4
57097: PUSH
57098: NOP4
57102: PPUSH
57103: LD_INT 1
57105: PPUSH
57106: NOP4
57110: ST_TO_ADDR
// end ;
57111: GO 57057
57113: POP
57114: POP
// end else
57115: GO 57137
// if sort then
57117: NOP4
57121: IFFALSE 57137
// p := sort [ 1 ] ;
57123: NOP4
57127: PUSH
57128: NOP4
57132: PUSH
57133: LD_INT 1
57135: ARRAY
57136: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57137: NOP4
57141: PUSH
57142: LD_INT 0
57144: PUSH
57145: LD_INT 0
57147: PUSH
57148: LD_INT 0
57150: PUSH
57151: NOP4
57155: PUSH
57156: EMPTY
57157: LIST
57158: LIST
57159: LIST
57160: LIST
57161: ST_TO_ADDR
// exit ;
57162: GO 59383
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57164: NOP4
57168: PUSH
57169: NOP4
57173: PUSH
57174: NOP4
57178: ARRAY
57179: ARRAY
57180: PUSH
57181: NOP4
57185: PUSH
57186: NOP4
57190: ARRAY
57191: PPUSH
57192: LD_INT 2
57194: PUSH
57195: LD_INT 30
57197: PUSH
57198: LD_INT 6
57200: PUSH
57201: EMPTY
57202: LIST
57203: LIST
57204: PUSH
57205: LD_INT 30
57207: PUSH
57208: LD_INT 7
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: PUSH
57215: LD_INT 30
57217: PUSH
57218: LD_INT 8
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: LIST
57229: LIST
57230: PPUSH
57231: NOP4
57235: AND
57236: PUSH
57237: NOP4
57241: PUSH
57242: NOP4
57246: ARRAY
57247: PPUSH
57248: LD_INT 30
57250: PUSH
57251: LD_INT 3
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: PPUSH
57258: NOP4
57262: AND
57263: IFFALSE 57997
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57265: NOP4
57269: PUSH
57270: NOP4
57274: PPUSH
57275: NOP4
57279: PPUSH
57280: LD_INT 3
57282: PPUSH
57283: NOP4
57287: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57288: NOP4
57292: PUSH
57293: LD_INT 0
57295: PUSH
57296: LD_INT 0
57298: PUSH
57299: LD_INT 0
57301: PUSH
57302: LD_INT 0
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: LIST
57309: LIST
57310: ST_TO_ADDR
// if not eng then
57311: NOP4
57315: NOT
57316: IFFALSE 57379
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57318: NOP4
57322: PUSH
57323: NOP4
57327: PPUSH
57328: LD_INT 2
57330: PPUSH
57331: NOP4
57335: PUSH
57336: LD_INT 1
57338: ARRAY
57339: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57340: NOP4
57344: PUSH
57345: NOP4
57349: PPUSH
57350: LD_INT 2
57352: PPUSH
57353: NOP4
57357: PPUSH
57358: NOP4
57362: ST_TO_ADDR
// tmp := tmp diff p ;
57363: NOP4
57367: PUSH
57368: NOP4
57372: PUSH
57373: NOP4
57377: DIFF
57378: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57379: NOP4
57383: PUSH
57384: NOP4
57388: PUSH
57389: LD_INT 6
57391: LESS
57392: AND
57393: IFFALSE 57581
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57395: NOP4
57399: PUSH
57400: NOP4
57404: PUSH
57405: NOP4
57409: PUSH
57410: NOP4
57414: UNION
57415: DIFF
57416: PPUSH
57417: LD_INT 4
57419: PPUSH
57420: NOP4
57424: ST_TO_ADDR
// p := [ ] ;
57425: NOP4
57429: PUSH
57430: EMPTY
57431: ST_TO_ADDR
// if sort then
57432: NOP4
57436: IFFALSE 57552
// for i = 1 to 6 - sci do
57438: NOP4
57442: PUSH
57443: DOUBLE
57444: LD_INT 1
57446: DEC
57447: ST_TO_ADDR
57448: LD_INT 6
57450: PUSH
57451: NOP4
57455: MINUS
57456: PUSH
57457: FOR_TO
57458: IFFALSE 57550
// begin if i = sort then
57460: NOP4
57464: PUSH
57465: NOP4
57469: EQUAL
57470: IFFALSE 57474
// break ;
57472: GO 57550
// if GetClass ( i ) = 4 then
57474: NOP4
57478: PPUSH
57479: NOP4
57483: PUSH
57484: LD_INT 4
57486: EQUAL
57487: IFFALSE 57491
// continue ;
57489: GO 57457
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57491: NOP4
57495: PUSH
57496: NOP4
57500: PPUSH
57501: NOP4
57505: PUSH
57506: LD_INT 1
57508: PLUS
57509: PPUSH
57510: NOP4
57514: PUSH
57515: NOP4
57519: ARRAY
57520: PPUSH
57521: NOP4
57525: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57526: NOP4
57530: PUSH
57531: NOP4
57535: PUSH
57536: NOP4
57540: PUSH
57541: NOP4
57545: ARRAY
57546: DIFF
57547: ST_TO_ADDR
// end ;
57548: GO 57457
57550: POP
57551: POP
// if p then
57552: NOP4
57556: IFFALSE 57581
// result := Replace ( result , 4 , p ) ;
57558: NOP4
57562: PUSH
57563: NOP4
57567: PPUSH
57568: LD_INT 4
57570: PPUSH
57571: NOP4
57575: PPUSH
57576: NOP4
57580: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57581: NOP4
57585: PUSH
57586: NOP4
57590: PUSH
57591: LD_INT 6
57593: LESS
57594: AND
57595: IFFALSE 57783
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57597: NOP4
57601: PUSH
57602: NOP4
57606: PUSH
57607: NOP4
57611: PUSH
57612: NOP4
57616: UNION
57617: DIFF
57618: PPUSH
57619: LD_INT 3
57621: PPUSH
57622: NOP4
57626: ST_TO_ADDR
// p := [ ] ;
57627: NOP4
57631: PUSH
57632: EMPTY
57633: ST_TO_ADDR
// if sort then
57634: NOP4
57638: IFFALSE 57754
// for i = 1 to 6 - mech do
57640: NOP4
57644: PUSH
57645: DOUBLE
57646: LD_INT 1
57648: DEC
57649: ST_TO_ADDR
57650: LD_INT 6
57652: PUSH
57653: NOP4
57657: MINUS
57658: PUSH
57659: FOR_TO
57660: IFFALSE 57752
// begin if i = sort then
57662: NOP4
57666: PUSH
57667: NOP4
57671: EQUAL
57672: IFFALSE 57676
// break ;
57674: GO 57752
// if GetClass ( i ) = 3 then
57676: NOP4
57680: PPUSH
57681: NOP4
57685: PUSH
57686: LD_INT 3
57688: EQUAL
57689: IFFALSE 57693
// continue ;
57691: GO 57659
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57693: NOP4
57697: PUSH
57698: NOP4
57702: PPUSH
57703: NOP4
57707: PUSH
57708: LD_INT 1
57710: PLUS
57711: PPUSH
57712: NOP4
57716: PUSH
57717: NOP4
57721: ARRAY
57722: PPUSH
57723: NOP4
57727: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57728: NOP4
57732: PUSH
57733: NOP4
57737: PUSH
57738: NOP4
57742: PUSH
57743: NOP4
57747: ARRAY
57748: DIFF
57749: ST_TO_ADDR
// end ;
57750: GO 57659
57752: POP
57753: POP
// if p then
57754: NOP4
57758: IFFALSE 57783
// result := Replace ( result , 3 , p ) ;
57760: NOP4
57764: PUSH
57765: NOP4
57769: PPUSH
57770: LD_INT 3
57772: PPUSH
57773: NOP4
57777: PPUSH
57778: NOP4
57782: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57783: NOP4
57787: PUSH
57788: LD_INT 6
57790: GREATER
57791: PUSH
57792: NOP4
57796: PUSH
57797: LD_INT 6
57799: LESS
57800: AND
57801: IFFALSE 57995
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57803: NOP4
57807: PUSH
57808: NOP4
57812: PUSH
57813: NOP4
57817: PUSH
57818: NOP4
57822: UNION
57823: PUSH
57824: NOP4
57828: UNION
57829: DIFF
57830: PPUSH
57831: LD_INT 2
57833: PPUSH
57834: NOP4
57838: ST_TO_ADDR
// p := [ ] ;
57839: NOP4
57843: PUSH
57844: EMPTY
57845: ST_TO_ADDR
// if sort then
57846: NOP4
57850: IFFALSE 57966
// for i = 1 to 6 - eng do
57852: NOP4
57856: PUSH
57857: DOUBLE
57858: LD_INT 1
57860: DEC
57861: ST_TO_ADDR
57862: LD_INT 6
57864: PUSH
57865: NOP4
57869: MINUS
57870: PUSH
57871: FOR_TO
57872: IFFALSE 57964
// begin if i = sort then
57874: NOP4
57878: PUSH
57879: NOP4
57883: EQUAL
57884: IFFALSE 57888
// break ;
57886: GO 57964
// if GetClass ( i ) = 2 then
57888: NOP4
57892: PPUSH
57893: NOP4
57897: PUSH
57898: LD_INT 2
57900: EQUAL
57901: IFFALSE 57905
// continue ;
57903: GO 57871
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57905: NOP4
57909: PUSH
57910: NOP4
57914: PPUSH
57915: NOP4
57919: PUSH
57920: LD_INT 1
57922: PLUS
57923: PPUSH
57924: NOP4
57928: PUSH
57929: NOP4
57933: ARRAY
57934: PPUSH
57935: NOP4
57939: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57940: NOP4
57944: PUSH
57945: NOP4
57949: PUSH
57950: NOP4
57954: PUSH
57955: NOP4
57959: ARRAY
57960: DIFF
57961: ST_TO_ADDR
// end ;
57962: GO 57871
57964: POP
57965: POP
// if p then
57966: NOP4
57970: IFFALSE 57995
// result := Replace ( result , 2 , p ) ;
57972: NOP4
57976: PUSH
57977: NOP4
57981: PPUSH
57982: LD_INT 2
57984: PPUSH
57985: NOP4
57989: PPUSH
57990: NOP4
57994: ST_TO_ADDR
// end ; exit ;
57995: GO 59383
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57997: NOP4
58001: PUSH
58002: NOP4
58006: PUSH
58007: NOP4
58011: ARRAY
58012: ARRAY
58013: NOT
58014: PUSH
58015: NOP4
58019: PUSH
58020: NOP4
58024: ARRAY
58025: PPUSH
58026: LD_INT 30
58028: PUSH
58029: LD_INT 3
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: PPUSH
58036: NOP4
58040: AND
58041: PUSH
58042: NOP4
58046: PUSH
58047: NOP4
58051: ARRAY
58052: AND
58053: IFFALSE 58661
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58055: NOP4
58059: PUSH
58060: NOP4
58064: PPUSH
58065: NOP4
58069: PPUSH
58070: LD_INT 5
58072: PPUSH
58073: NOP4
58077: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58078: NOP4
58082: PUSH
58083: LD_INT 0
58085: PUSH
58086: LD_INT 0
58088: PUSH
58089: LD_INT 0
58091: PUSH
58092: LD_INT 0
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: LIST
58099: LIST
58100: ST_TO_ADDR
// if sci > 1 then
58101: NOP4
58105: PUSH
58106: LD_INT 1
58108: GREATER
58109: IFFALSE 58137
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58111: NOP4
58115: PUSH
58116: NOP4
58120: PUSH
58121: NOP4
58125: PUSH
58126: NOP4
58130: PUSH
58131: LD_INT 1
58133: ARRAY
58134: DIFF
58135: DIFF
58136: ST_TO_ADDR
// if tmp and not sci then
58137: NOP4
58141: PUSH
58142: NOP4
58146: NOT
58147: AND
58148: IFFALSE 58217
// begin sort := SortBySkill ( tmp , 4 ) ;
58150: NOP4
58154: PUSH
58155: NOP4
58159: PPUSH
58160: LD_INT 4
58162: PPUSH
58163: NOP4
58167: ST_TO_ADDR
// if sort then
58168: NOP4
58172: IFFALSE 58188
// p := sort [ 1 ] ;
58174: NOP4
58178: PUSH
58179: NOP4
58183: PUSH
58184: LD_INT 1
58186: ARRAY
58187: ST_TO_ADDR
// if p then
58188: NOP4
58192: IFFALSE 58217
// result := Replace ( result , 4 , p ) ;
58194: NOP4
58198: PUSH
58199: NOP4
58203: PPUSH
58204: LD_INT 4
58206: PPUSH
58207: NOP4
58211: PPUSH
58212: NOP4
58216: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58217: NOP4
58221: PUSH
58222: NOP4
58226: PUSH
58227: NOP4
58231: DIFF
58232: ST_TO_ADDR
// if tmp and mech < 6 then
58233: NOP4
58237: PUSH
58238: NOP4
58242: PUSH
58243: LD_INT 6
58245: LESS
58246: AND
58247: IFFALSE 58435
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58249: NOP4
58253: PUSH
58254: NOP4
58258: PUSH
58259: NOP4
58263: PUSH
58264: NOP4
58268: UNION
58269: DIFF
58270: PPUSH
58271: LD_INT 3
58273: PPUSH
58274: NOP4
58278: ST_TO_ADDR
// p := [ ] ;
58279: NOP4
58283: PUSH
58284: EMPTY
58285: ST_TO_ADDR
// if sort then
58286: NOP4
58290: IFFALSE 58406
// for i = 1 to 6 - mech do
58292: NOP4
58296: PUSH
58297: DOUBLE
58298: LD_INT 1
58300: DEC
58301: ST_TO_ADDR
58302: LD_INT 6
58304: PUSH
58305: NOP4
58309: MINUS
58310: PUSH
58311: FOR_TO
58312: IFFALSE 58404
// begin if i = sort then
58314: NOP4
58318: PUSH
58319: NOP4
58323: EQUAL
58324: IFFALSE 58328
// break ;
58326: GO 58404
// if GetClass ( i ) = 3 then
58328: NOP4
58332: PPUSH
58333: NOP4
58337: PUSH
58338: LD_INT 3
58340: EQUAL
58341: IFFALSE 58345
// continue ;
58343: GO 58311
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58345: NOP4
58349: PUSH
58350: NOP4
58354: PPUSH
58355: NOP4
58359: PUSH
58360: LD_INT 1
58362: PLUS
58363: PPUSH
58364: NOP4
58368: PUSH
58369: NOP4
58373: ARRAY
58374: PPUSH
58375: NOP4
58379: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58380: NOP4
58384: PUSH
58385: NOP4
58389: PUSH
58390: NOP4
58394: PUSH
58395: NOP4
58399: ARRAY
58400: DIFF
58401: ST_TO_ADDR
// end ;
58402: GO 58311
58404: POP
58405: POP
// if p then
58406: NOP4
58410: IFFALSE 58435
// result := Replace ( result , 3 , p ) ;
58412: NOP4
58416: PUSH
58417: NOP4
58421: PPUSH
58422: LD_INT 3
58424: PPUSH
58425: NOP4
58429: PPUSH
58430: NOP4
58434: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58435: NOP4
58439: PUSH
58440: NOP4
58444: PUSH
58445: NOP4
58449: DIFF
58450: ST_TO_ADDR
// if tmp and eng < 6 then
58451: NOP4
58455: PUSH
58456: NOP4
58460: PUSH
58461: LD_INT 6
58463: LESS
58464: AND
58465: IFFALSE 58659
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58467: NOP4
58471: PUSH
58472: NOP4
58476: PUSH
58477: NOP4
58481: PUSH
58482: NOP4
58486: UNION
58487: PUSH
58488: NOP4
58492: UNION
58493: DIFF
58494: PPUSH
58495: LD_INT 2
58497: PPUSH
58498: NOP4
58502: ST_TO_ADDR
// p := [ ] ;
58503: NOP4
58507: PUSH
58508: EMPTY
58509: ST_TO_ADDR
// if sort then
58510: NOP4
58514: IFFALSE 58630
// for i = 1 to 6 - eng do
58516: NOP4
58520: PUSH
58521: DOUBLE
58522: LD_INT 1
58524: DEC
58525: ST_TO_ADDR
58526: LD_INT 6
58528: PUSH
58529: NOP4
58533: MINUS
58534: PUSH
58535: FOR_TO
58536: IFFALSE 58628
// begin if i = sort then
58538: NOP4
58542: PUSH
58543: NOP4
58547: EQUAL
58548: IFFALSE 58552
// break ;
58550: GO 58628
// if GetClass ( i ) = 2 then
58552: NOP4
58556: PPUSH
58557: NOP4
58561: PUSH
58562: LD_INT 2
58564: EQUAL
58565: IFFALSE 58569
// continue ;
58567: GO 58535
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58569: NOP4
58573: PUSH
58574: NOP4
58578: PPUSH
58579: NOP4
58583: PUSH
58584: LD_INT 1
58586: PLUS
58587: PPUSH
58588: NOP4
58592: PUSH
58593: NOP4
58597: ARRAY
58598: PPUSH
58599: NOP4
58603: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58604: NOP4
58608: PUSH
58609: NOP4
58613: PUSH
58614: NOP4
58618: PUSH
58619: NOP4
58623: ARRAY
58624: DIFF
58625: ST_TO_ADDR
// end ;
58626: GO 58535
58628: POP
58629: POP
// if p then
58630: NOP4
58634: IFFALSE 58659
// result := Replace ( result , 2 , p ) ;
58636: NOP4
58640: PUSH
58641: NOP4
58645: PPUSH
58646: LD_INT 2
58648: PPUSH
58649: NOP4
58653: PPUSH
58654: NOP4
58658: ST_TO_ADDR
// end ; exit ;
58659: GO 59383
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58661: NOP4
58665: PUSH
58666: NOP4
58670: PUSH
58671: NOP4
58675: ARRAY
58676: ARRAY
58677: NOT
58678: PUSH
58679: NOP4
58683: PUSH
58684: NOP4
58688: ARRAY
58689: PPUSH
58690: LD_INT 30
58692: PUSH
58693: LD_INT 3
58695: PUSH
58696: EMPTY
58697: LIST
58698: LIST
58699: PPUSH
58700: NOP4
58704: AND
58705: PUSH
58706: NOP4
58710: PUSH
58711: NOP4
58715: ARRAY
58716: NOT
58717: AND
58718: IFFALSE 59383
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58720: NOP4
58724: PUSH
58725: NOP4
58729: PPUSH
58730: NOP4
58734: PPUSH
58735: LD_INT 6
58737: PPUSH
58738: NOP4
58742: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58743: NOP4
58747: PUSH
58748: LD_INT 0
58750: PUSH
58751: LD_INT 0
58753: PUSH
58754: LD_INT 0
58756: PUSH
58757: LD_INT 0
58759: PUSH
58760: EMPTY
58761: LIST
58762: LIST
58763: LIST
58764: LIST
58765: ST_TO_ADDR
// if sci >= 1 then
58766: NOP4
58770: PUSH
58771: LD_INT 1
58773: GREATEREQUAL
58774: IFFALSE 58796
// tmp := tmp diff sci [ 1 ] ;
58776: NOP4
58780: PUSH
58781: NOP4
58785: PUSH
58786: NOP4
58790: PUSH
58791: LD_INT 1
58793: ARRAY
58794: DIFF
58795: ST_TO_ADDR
// if tmp and not sci then
58796: NOP4
58800: PUSH
58801: NOP4
58805: NOT
58806: AND
58807: IFFALSE 58876
// begin sort := SortBySkill ( tmp , 4 ) ;
58809: NOP4
58813: PUSH
58814: NOP4
58818: PPUSH
58819: LD_INT 4
58821: PPUSH
58822: NOP4
58826: ST_TO_ADDR
// if sort then
58827: NOP4
58831: IFFALSE 58847
// p := sort [ 1 ] ;
58833: NOP4
58837: PUSH
58838: NOP4
58842: PUSH
58843: LD_INT 1
58845: ARRAY
58846: ST_TO_ADDR
// if p then
58847: NOP4
58851: IFFALSE 58876
// result := Replace ( result , 4 , p ) ;
58853: NOP4
58857: PUSH
58858: NOP4
58862: PPUSH
58863: LD_INT 4
58865: PPUSH
58866: NOP4
58870: PPUSH
58871: NOP4
58875: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58876: NOP4
58880: PUSH
58881: NOP4
58885: PUSH
58886: NOP4
58890: DIFF
58891: ST_TO_ADDR
// if tmp and mech < 6 then
58892: NOP4
58896: PUSH
58897: NOP4
58901: PUSH
58902: LD_INT 6
58904: LESS
58905: AND
58906: IFFALSE 59088
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58908: NOP4
58912: PUSH
58913: NOP4
58917: PUSH
58918: NOP4
58922: DIFF
58923: PPUSH
58924: LD_INT 3
58926: PPUSH
58927: NOP4
58931: ST_TO_ADDR
// p := [ ] ;
58932: NOP4
58936: PUSH
58937: EMPTY
58938: ST_TO_ADDR
// if sort then
58939: NOP4
58943: IFFALSE 59059
// for i = 1 to 6 - mech do
58945: NOP4
58949: PUSH
58950: DOUBLE
58951: LD_INT 1
58953: DEC
58954: ST_TO_ADDR
58955: LD_INT 6
58957: PUSH
58958: NOP4
58962: MINUS
58963: PUSH
58964: FOR_TO
58965: IFFALSE 59057
// begin if i = sort then
58967: NOP4
58971: PUSH
58972: NOP4
58976: EQUAL
58977: IFFALSE 58981
// break ;
58979: GO 59057
// if GetClass ( i ) = 3 then
58981: NOP4
58985: PPUSH
58986: NOP4
58990: PUSH
58991: LD_INT 3
58993: EQUAL
58994: IFFALSE 58998
// continue ;
58996: GO 58964
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58998: NOP4
59002: PUSH
59003: NOP4
59007: PPUSH
59008: NOP4
59012: PUSH
59013: LD_INT 1
59015: PLUS
59016: PPUSH
59017: NOP4
59021: PUSH
59022: NOP4
59026: ARRAY
59027: PPUSH
59028: NOP4
59032: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59033: NOP4
59037: PUSH
59038: NOP4
59042: PUSH
59043: NOP4
59047: PUSH
59048: NOP4
59052: ARRAY
59053: DIFF
59054: ST_TO_ADDR
// end ;
59055: GO 58964
59057: POP
59058: POP
// if p then
59059: NOP4
59063: IFFALSE 59088
// result := Replace ( result , 3 , p ) ;
59065: NOP4
59069: PUSH
59070: NOP4
59074: PPUSH
59075: LD_INT 3
59077: PPUSH
59078: NOP4
59082: PPUSH
59083: NOP4
59087: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59088: NOP4
59092: PUSH
59093: NOP4
59097: PUSH
59098: NOP4
59102: DIFF
59103: ST_TO_ADDR
// if tmp and eng < 4 then
59104: NOP4
59108: PUSH
59109: NOP4
59113: PUSH
59114: LD_INT 4
59116: LESS
59117: AND
59118: IFFALSE 59308
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59120: NOP4
59124: PUSH
59125: NOP4
59129: PUSH
59130: NOP4
59134: PUSH
59135: NOP4
59139: UNION
59140: DIFF
59141: PPUSH
59142: LD_INT 2
59144: PPUSH
59145: NOP4
59149: ST_TO_ADDR
// p := [ ] ;
59150: NOP4
59154: PUSH
59155: EMPTY
59156: ST_TO_ADDR
// if sort then
59157: NOP4
59161: IFFALSE 59277
// for i = 1 to 4 - eng do
59163: NOP4
59167: PUSH
59168: DOUBLE
59169: LD_INT 1
59171: DEC
59172: ST_TO_ADDR
59173: LD_INT 4
59175: PUSH
59176: NOP4
59180: MINUS
59181: PUSH
59182: FOR_TO
59183: IFFALSE 59275
// begin if i = sort then
59185: NOP4
59189: PUSH
59190: NOP4
59194: EQUAL
59195: IFFALSE 59199
// break ;
59197: GO 59275
// if GetClass ( i ) = 2 then
59199: NOP4
59203: PPUSH
59204: NOP4
59208: PUSH
59209: LD_INT 2
59211: EQUAL
59212: IFFALSE 59216
// continue ;
59214: GO 59182
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59216: NOP4
59220: PUSH
59221: NOP4
59225: PPUSH
59226: NOP4
59230: PUSH
59231: LD_INT 1
59233: PLUS
59234: PPUSH
59235: NOP4
59239: PUSH
59240: NOP4
59244: ARRAY
59245: PPUSH
59246: NOP4
59250: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59251: NOP4
59255: PUSH
59256: NOP4
59260: PUSH
59261: NOP4
59265: PUSH
59266: NOP4
59270: ARRAY
59271: DIFF
59272: ST_TO_ADDR
// end ;
59273: GO 59182
59275: POP
59276: POP
// if p then
59277: NOP4
59281: IFFALSE 59306
// result := Replace ( result , 2 , p ) ;
59283: NOP4
59287: PUSH
59288: NOP4
59292: PPUSH
59293: LD_INT 2
59295: PPUSH
59296: NOP4
59300: PPUSH
59301: NOP4
59305: ST_TO_ADDR
// end else
59306: GO 59352
// for i = eng downto 5 do
59308: NOP4
59312: PUSH
59313: DOUBLE
59314: NOP4
59318: INC
59319: ST_TO_ADDR
59320: LD_INT 5
59322: PUSH
59323: FOR_DOWNTO
59324: IFFALSE 59350
// tmp := tmp union eng [ i ] ;
59326: NOP4
59330: PUSH
59331: NOP4
59335: PUSH
59336: NOP4
59340: PUSH
59341: NOP4
59345: ARRAY
59346: UNION
59347: ST_TO_ADDR
59348: GO 59323
59350: POP
59351: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59352: NOP4
59356: PUSH
59357: NOP4
59361: PPUSH
59362: LD_INT 1
59364: PPUSH
59365: NOP4
59369: PUSH
59370: NOP4
59374: DIFF
59375: PPUSH
59376: NOP4
59380: ST_TO_ADDR
// exit ;
59381: GO 59383
// end ; end ;
59383: LD_VAR 0 2
59387: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59388: LD_INT 0
59390: PPUSH
59391: PPUSH
59392: PPUSH
// if not mc_bases then
59393: NOP4
59397: NOT
59398: IFFALSE 59402
// exit ;
59400: GO 59544
// for i = 1 to mc_bases do
59402: NOP4
59406: PUSH
59407: DOUBLE
59408: LD_INT 1
59410: DEC
59411: ST_TO_ADDR
59412: NOP4
59416: PUSH
59417: FOR_TO
59418: IFFALSE 59535
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59420: NOP4
59424: PUSH
59425: NOP4
59429: PUSH
59430: NOP4
59434: ARRAY
59435: PPUSH
59436: LD_INT 21
59438: PUSH
59439: LD_INT 3
59441: PUSH
59442: EMPTY
59443: LIST
59444: LIST
59445: PUSH
59446: LD_INT 3
59448: PUSH
59449: LD_INT 2
59451: PUSH
59452: LD_INT 30
59454: PUSH
59455: LD_INT 29
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: LD_INT 30
59464: PUSH
59465: LD_INT 30
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: LIST
59476: PUSH
59477: EMPTY
59478: LIST
59479: LIST
59480: PUSH
59481: LD_INT 3
59483: PUSH
59484: LD_INT 24
59486: PUSH
59487: LD_INT 1000
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: EMPTY
59495: LIST
59496: LIST
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: LIST
59502: PPUSH
59503: NOP4
59507: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59508: NOP4
59512: PUSH
59513: NOP4
59517: PPUSH
59518: NOP4
59522: PPUSH
59523: NOP4
59527: PPUSH
59528: NOP4
59532: ST_TO_ADDR
// end ;
59533: GO 59417
59535: POP
59536: POP
// RaiseSailEvent ( 101 ) ;
59537: LD_INT 101
59539: PPUSH
59540: NOP4
// end ;
59544: LD_VAR 0 1
59548: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59549: LD_INT 0
59551: PPUSH
59552: PPUSH
59553: PPUSH
59554: PPUSH
59555: PPUSH
59556: PPUSH
59557: PPUSH
// if not mc_bases then
59558: NOP4
59562: NOT
59563: IFFALSE 59567
// exit ;
59565: GO 60129
// for i = 1 to mc_bases do
59567: NOP4
59571: PUSH
59572: DOUBLE
59573: LD_INT 1
59575: DEC
59576: ST_TO_ADDR
59577: NOP4
59581: PUSH
59582: FOR_TO
59583: IFFALSE 60120
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59585: NOP4
59589: PUSH
59590: NOP4
59594: PUSH
59595: NOP4
59599: ARRAY
59600: PUSH
59601: NOP4
59605: PUSH
59606: NOP4
59610: ARRAY
59611: UNION
59612: PPUSH
59613: LD_INT 21
59615: PUSH
59616: LD_INT 1
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: PUSH
59623: LD_INT 1
59625: PUSH
59626: LD_INT 3
59628: PUSH
59629: LD_INT 54
59631: PUSH
59632: EMPTY
59633: LIST
59634: PUSH
59635: EMPTY
59636: LIST
59637: LIST
59638: PUSH
59639: LD_INT 3
59641: PUSH
59642: LD_INT 24
59644: PUSH
59645: LD_INT 1000
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: LIST
59660: PUSH
59661: EMPTY
59662: LIST
59663: LIST
59664: PPUSH
59665: NOP4
59669: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59670: NOP4
59674: PUSH
59675: NOP4
59679: PUSH
59680: NOP4
59684: ARRAY
59685: PPUSH
59686: LD_INT 21
59688: PUSH
59689: LD_INT 1
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: PUSH
59696: LD_INT 1
59698: PUSH
59699: LD_INT 3
59701: PUSH
59702: LD_INT 54
59704: PUSH
59705: EMPTY
59706: LIST
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: LD_INT 3
59714: PUSH
59715: LD_INT 24
59717: PUSH
59718: LD_INT 250
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: PUSH
59725: EMPTY
59726: LIST
59727: LIST
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: LIST
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PPUSH
59738: NOP4
59742: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59743: NOP4
59747: PUSH
59748: NOP4
59752: PUSH
59753: NOP4
59757: DIFF
59758: ST_TO_ADDR
// if not need_heal_1 then
59759: NOP4
59763: NOT
59764: IFFALSE 59797
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59766: NOP4
59770: PUSH
59771: NOP4
59775: PPUSH
59776: NOP4
59780: PUSH
59781: LD_INT 1
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: PPUSH
59788: EMPTY
59789: PPUSH
59790: NOP4
59794: ST_TO_ADDR
59795: GO 59867
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59797: NOP4
59801: PUSH
59802: NOP4
59806: PPUSH
59807: NOP4
59811: PUSH
59812: LD_INT 1
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: PPUSH
59819: NOP4
59823: PUSH
59824: NOP4
59828: ARRAY
59829: PUSH
59830: LD_INT 1
59832: ARRAY
59833: PPUSH
59834: LD_INT 3
59836: PUSH
59837: LD_INT 24
59839: PUSH
59840: LD_INT 1000
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PPUSH
59851: NOP4
59855: PUSH
59856: NOP4
59860: UNION
59861: PPUSH
59862: NOP4
59866: ST_TO_ADDR
// if not need_heal_2 then
59867: NOP4
59871: NOT
59872: IFFALSE 59905
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59874: NOP4
59878: PUSH
59879: NOP4
59883: PPUSH
59884: NOP4
59888: PUSH
59889: LD_INT 2
59891: PUSH
59892: EMPTY
59893: LIST
59894: LIST
59895: PPUSH
59896: EMPTY
59897: PPUSH
59898: NOP4
59902: ST_TO_ADDR
59903: GO 59937
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59905: NOP4
59909: PUSH
59910: NOP4
59914: PPUSH
59915: NOP4
59919: PUSH
59920: LD_INT 2
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: PPUSH
59927: NOP4
59931: PPUSH
59932: NOP4
59936: ST_TO_ADDR
// if need_heal_2 then
59937: NOP4
59941: IFFALSE 60102
// for j in need_heal_2 do
59943: NOP4
59947: PUSH
59948: NOP4
59952: PUSH
59953: FOR_IN
59954: IFFALSE 60100
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59956: NOP4
59960: PUSH
59961: NOP4
59965: PUSH
59966: NOP4
59970: ARRAY
59971: PPUSH
59972: LD_INT 2
59974: PUSH
59975: LD_INT 30
59977: PUSH
59978: LD_INT 6
59980: PUSH
59981: EMPTY
59982: LIST
59983: LIST
59984: PUSH
59985: LD_INT 30
59987: PUSH
59988: LD_INT 7
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: PUSH
59995: LD_INT 30
59997: PUSH
59998: LD_INT 8
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: PUSH
60005: LD_INT 30
60007: PUSH
60008: LD_INT 0
60010: PUSH
60011: EMPTY
60012: LIST
60013: LIST
60014: PUSH
60015: LD_INT 30
60017: PUSH
60018: LD_INT 1
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PUSH
60025: EMPTY
60026: LIST
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: PPUSH
60033: NOP4
60037: ST_TO_ADDR
// if tmp then
60038: NOP4
60042: IFFALSE 60098
// begin k := NearestUnitToUnit ( tmp , j ) ;
60044: NOP4
60048: PUSH
60049: NOP4
60053: PPUSH
60054: NOP4
60058: PPUSH
60059: NOP4
60063: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60064: NOP4
60068: PPUSH
60069: NOP4
60073: PPUSH
60074: NOP4
60078: PUSH
60079: LD_INT 5
60081: GREATER
60082: IFFALSE 60098
// ComMoveToNearbyEntrance ( j , k ) ;
60084: NOP4
60088: PPUSH
60089: NOP4
60093: PPUSH
60094: NOP4
// end ; end ;
60098: GO 59953
60100: POP
60101: POP
// if not need_heal_1 and not need_heal_2 then
60102: NOP4
60106: NOT
60107: PUSH
60108: NOP4
60112: NOT
60113: AND
60114: IFFALSE 60118
// continue ;
60116: GO 59582
// end ;
60118: GO 59582
60120: POP
60121: POP
// RaiseSailEvent ( 102 ) ;
60122: LD_INT 102
60124: PPUSH
60125: NOP4
// end ;
60129: LD_VAR 0 1
60133: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60134: LD_INT 0
60136: PPUSH
60137: PPUSH
60138: PPUSH
60139: PPUSH
60140: PPUSH
60141: PPUSH
60142: PPUSH
60143: PPUSH
// if not mc_bases then
60144: NOP4
60148: NOT
60149: IFFALSE 60153
// exit ;
60151: GO 61036
// for i = 1 to mc_bases do
60153: NOP4
60157: PUSH
60158: DOUBLE
60159: LD_INT 1
60161: DEC
60162: ST_TO_ADDR
60163: NOP4
60167: PUSH
60168: FOR_TO
60169: IFFALSE 61034
// begin if not mc_building_need_repair [ i ] then
60171: NOP4
60175: PUSH
60176: NOP4
60180: ARRAY
60181: NOT
60182: IFFALSE 60369
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60184: NOP4
60188: PUSH
60189: NOP4
60193: PUSH
60194: NOP4
60198: ARRAY
60199: PPUSH
60200: LD_INT 3
60202: PUSH
60203: LD_INT 24
60205: PUSH
60206: LD_INT 1000
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: PUSH
60213: EMPTY
60214: LIST
60215: LIST
60216: PUSH
60217: LD_INT 2
60219: PUSH
60220: LD_INT 34
60222: PUSH
60223: LD_INT 13
60225: PUSH
60226: EMPTY
60227: LIST
60228: LIST
60229: PUSH
60230: LD_INT 34
60232: PUSH
60233: LD_INT 52
60235: PUSH
60236: EMPTY
60237: LIST
60238: LIST
60239: PUSH
60240: LD_INT 34
60242: PUSH
60243: NOP4
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: LIST
60256: LIST
60257: PUSH
60258: EMPTY
60259: LIST
60260: LIST
60261: PPUSH
60262: NOP4
60266: ST_TO_ADDR
// if cranes then
60267: NOP4
60271: IFFALSE 60333
// for j in cranes do
60273: NOP4
60277: PUSH
60278: NOP4
60282: PUSH
60283: FOR_IN
60284: IFFALSE 60331
// if not IsInArea ( j , mc_parking [ i ] ) then
60286: NOP4
60290: PPUSH
60291: NOP4
60295: PUSH
60296: NOP4
60300: ARRAY
60301: PPUSH
60302: NOP4
60306: NOT
60307: IFFALSE 60329
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60309: NOP4
60313: PPUSH
60314: NOP4
60318: PUSH
60319: NOP4
60323: ARRAY
60324: PPUSH
60325: NOP4
60329: GO 60283
60331: POP
60332: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60333: NOP4
60337: PUSH
60338: NOP4
60342: PPUSH
60343: NOP4
60347: PPUSH
60348: EMPTY
60349: PPUSH
60350: NOP4
60354: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60355: NOP4
60359: PPUSH
60360: LD_INT 101
60362: PPUSH
60363: NOP4
// continue ;
60367: GO 60168
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60369: NOP4
60373: PUSH
60374: NOP4
60378: PPUSH
60379: NOP4
60383: PPUSH
60384: EMPTY
60385: PPUSH
60386: NOP4
60390: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60391: NOP4
60395: PPUSH
60396: LD_INT 103
60398: PPUSH
60399: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60403: NOP4
60407: PUSH
60408: NOP4
60412: PUSH
60413: NOP4
60417: ARRAY
60418: PUSH
60419: NOP4
60423: PUSH
60424: NOP4
60428: ARRAY
60429: UNION
60430: PPUSH
60431: LD_INT 2
60433: PUSH
60434: LD_INT 25
60436: PUSH
60437: LD_INT 2
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: LD_INT 25
60446: PUSH
60447: LD_INT 16
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: EMPTY
60455: LIST
60456: LIST
60457: LIST
60458: PUSH
60459: EMPTY
60460: LIST
60461: PPUSH
60462: NOP4
60466: ST_TO_ADDR
// if mc_need_heal [ i ] then
60467: NOP4
60471: PUSH
60472: NOP4
60476: ARRAY
60477: IFFALSE 60521
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60479: NOP4
60483: PUSH
60484: NOP4
60488: PUSH
60489: NOP4
60493: PUSH
60494: NOP4
60498: ARRAY
60499: PUSH
60500: LD_INT 1
60502: ARRAY
60503: PUSH
60504: NOP4
60508: PUSH
60509: NOP4
60513: ARRAY
60514: PUSH
60515: LD_INT 2
60517: ARRAY
60518: UNION
60519: DIFF
60520: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60521: NOP4
60525: PUSH
60526: NOP4
60530: PUSH
60531: NOP4
60535: ARRAY
60536: PPUSH
60537: LD_INT 2
60539: PUSH
60540: LD_INT 34
60542: PUSH
60543: LD_INT 13
60545: PUSH
60546: EMPTY
60547: LIST
60548: LIST
60549: PUSH
60550: LD_INT 34
60552: PUSH
60553: LD_INT 52
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PUSH
60560: LD_INT 34
60562: PUSH
60563: NOP4
60567: PUSH
60568: EMPTY
60569: LIST
60570: LIST
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: LIST
60576: LIST
60577: PPUSH
60578: NOP4
60582: ST_TO_ADDR
// if cranes then
60583: NOP4
60587: IFFALSE 60723
// begin for j in cranes do
60589: NOP4
60593: PUSH
60594: NOP4
60598: PUSH
60599: FOR_IN
60600: IFFALSE 60721
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60602: NOP4
60606: PPUSH
60607: NOP4
60611: PUSH
60612: LD_INT 1000
60614: EQUAL
60615: PUSH
60616: NOP4
60620: PPUSH
60621: NOP4
60625: NOT
60626: AND
60627: IFFALSE 60661
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60629: NOP4
60633: PPUSH
60634: NOP4
60638: PUSH
60639: NOP4
60643: ARRAY
60644: PPUSH
60645: NOP4
60649: PPUSH
60650: NOP4
60654: PPUSH
60655: NOP4
60659: GO 60719
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60661: NOP4
60665: PPUSH
60666: NOP4
60670: PUSH
60671: LD_INT 500
60673: LESS
60674: PUSH
60675: NOP4
60679: PPUSH
60680: NOP4
60684: PUSH
60685: NOP4
60689: ARRAY
60690: PPUSH
60691: NOP4
60695: NOT
60696: AND
60697: IFFALSE 60719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60699: NOP4
60703: PPUSH
60704: NOP4
60708: PUSH
60709: NOP4
60713: ARRAY
60714: PPUSH
60715: NOP4
// end ;
60719: GO 60599
60721: POP
60722: POP
// end ; if tmp > 3 then
60723: NOP4
60727: PUSH
60728: LD_INT 3
60730: GREATER
60731: IFFALSE 60751
// tmp := ShrinkArray ( tmp , 4 ) ;
60733: NOP4
60737: PUSH
60738: NOP4
60742: PPUSH
60743: LD_INT 4
60745: PPUSH
60746: NOP4
60750: ST_TO_ADDR
// if not tmp then
60751: NOP4
60755: NOT
60756: IFFALSE 60760
// continue ;
60758: GO 60168
// for j in tmp do
60760: NOP4
60764: PUSH
60765: NOP4
60769: PUSH
60770: FOR_IN
60771: IFFALSE 61030
// begin if IsInUnit ( j ) then
60773: NOP4
60777: PPUSH
60778: NOP4
60782: IFFALSE 60793
// ComExitBuilding ( j ) ;
60784: NOP4
60788: PPUSH
60789: NOP4
// if not j in mc_building_repairs [ i ] then
60793: NOP4
60797: PUSH
60798: NOP4
60802: PUSH
60803: NOP4
60807: ARRAY
60808: IN
60809: NOT
60810: IFFALSE 60868
// begin SetTag ( j , 101 ) ;
60812: NOP4
60816: PPUSH
60817: LD_INT 101
60819: PPUSH
60820: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60824: NOP4
60828: PUSH
60829: NOP4
60833: PPUSH
60834: NOP4
60838: PUSH
60839: NOP4
60843: PUSH
60844: NOP4
60848: ARRAY
60849: PUSH
60850: LD_INT 1
60852: PLUS
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PPUSH
60858: NOP4
60862: PPUSH
60863: NOP4
60867: ST_TO_ADDR
// end ; wait ( 1 ) ;
60868: LD_INT 1
60870: PPUSH
60871: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
60875: NOP4
60879: PUSH
60880: NOP4
60884: PUSH
60885: NOP4
60889: ARRAY
60890: ST_TO_ADDR
// if mc_scan [ i ] then
60891: NOP4
60895: PUSH
60896: NOP4
60900: ARRAY
60901: IFFALSE 60963
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60903: NOP4
60907: PUSH
60908: NOP4
60912: PUSH
60913: NOP4
60917: ARRAY
60918: PPUSH
60919: LD_INT 3
60921: PUSH
60922: LD_INT 30
60924: PUSH
60925: LD_INT 32
60927: PUSH
60928: EMPTY
60929: LIST
60930: LIST
60931: PUSH
60932: LD_INT 30
60934: PUSH
60935: LD_INT 33
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 30
60944: PUSH
60945: LD_INT 31
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: LIST
60956: LIST
60957: PPUSH
60958: NOP4
60962: ST_TO_ADDR
// if not to_repair_tmp then
60963: NOP4
60967: NOT
60968: IFFALSE 60972
// continue ;
60970: GO 60770
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60972: NOP4
60976: PUSH
60977: NOP4
60981: PPUSH
60982: NOP4
60986: PPUSH
60987: NOP4
60991: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60992: NOP4
60996: PPUSH
60997: LD_INT 16
60999: PPUSH
61000: NOP4
61004: PUSH
61005: LD_INT 4
61007: ARRAY
61008: PUSH
61009: LD_INT 10
61011: LESS
61012: IFFALSE 61028
// ComRepairBuilding ( j , to_repair ) ;
61014: NOP4
61018: PPUSH
61019: NOP4
61023: PPUSH
61024: NOP4
// end ;
61028: GO 60770
61030: POP
61031: POP
// end ;
61032: GO 60168
61034: POP
61035: POP
// end ;
61036: LD_VAR 0 1
61040: RET
// export function MC_Heal ; var i , j , tmp ; begin
61041: LD_INT 0
61043: PPUSH
61044: PPUSH
61045: PPUSH
61046: PPUSH
// if not mc_bases then
61047: NOP4
61051: NOT
61052: IFFALSE 61056
// exit ;
61054: GO 61458
// for i = 1 to mc_bases do
61056: NOP4
61060: PUSH
61061: DOUBLE
61062: LD_INT 1
61064: DEC
61065: ST_TO_ADDR
61066: NOP4
61070: PUSH
61071: FOR_TO
61072: IFFALSE 61456
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61074: NOP4
61078: PUSH
61079: NOP4
61083: ARRAY
61084: PUSH
61085: LD_INT 1
61087: ARRAY
61088: NOT
61089: PUSH
61090: NOP4
61094: PUSH
61095: NOP4
61099: ARRAY
61100: PUSH
61101: LD_INT 2
61103: ARRAY
61104: NOT
61105: AND
61106: IFFALSE 61144
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61108: NOP4
61112: PUSH
61113: NOP4
61117: PPUSH
61118: NOP4
61122: PPUSH
61123: EMPTY
61124: PPUSH
61125: NOP4
61129: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61130: NOP4
61134: PPUSH
61135: LD_INT 102
61137: PPUSH
61138: NOP4
// continue ;
61142: GO 61071
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61144: NOP4
61148: PUSH
61149: NOP4
61153: PUSH
61154: NOP4
61158: ARRAY
61159: PPUSH
61160: LD_INT 25
61162: PUSH
61163: LD_INT 4
61165: PUSH
61166: EMPTY
61167: LIST
61168: LIST
61169: PPUSH
61170: NOP4
61174: ST_TO_ADDR
// if not tmp then
61175: NOP4
61179: NOT
61180: IFFALSE 61184
// continue ;
61182: GO 61071
// if mc_taming [ i ] then
61184: NOP4
61188: PUSH
61189: NOP4
61193: ARRAY
61194: IFFALSE 61218
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61196: NOP4
61200: PUSH
61201: NOP4
61205: PPUSH
61206: NOP4
61210: PPUSH
61211: EMPTY
61212: PPUSH
61213: NOP4
61217: ST_TO_ADDR
// for j in tmp do
61218: NOP4
61222: PUSH
61223: NOP4
61227: PUSH
61228: FOR_IN
61229: IFFALSE 61452
// begin if IsInUnit ( j ) then
61231: NOP4
61235: PPUSH
61236: NOP4
61240: IFFALSE 61251
// ComExitBuilding ( j ) ;
61242: NOP4
61246: PPUSH
61247: NOP4
// if not j in mc_healers [ i ] then
61251: NOP4
61255: PUSH
61256: NOP4
61260: PUSH
61261: NOP4
61265: ARRAY
61266: IN
61267: NOT
61268: IFFALSE 61314
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61270: NOP4
61274: PUSH
61275: NOP4
61279: PPUSH
61280: NOP4
61284: PUSH
61285: NOP4
61289: PUSH
61290: NOP4
61294: ARRAY
61295: PUSH
61296: LD_INT 1
61298: PLUS
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PPUSH
61304: NOP4
61308: PPUSH
61309: NOP4
61313: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61314: NOP4
61318: PPUSH
61319: NOP4
61323: PUSH
61324: LD_INT 102
61326: NONEQUAL
61327: IFFALSE 61341
// SetTag ( j , 102 ) ;
61329: NOP4
61333: PPUSH
61334: LD_INT 102
61336: PPUSH
61337: NOP4
// Wait ( 3 ) ;
61341: LD_INT 3
61343: PPUSH
61344: NOP4
// if mc_need_heal [ i ] [ 1 ] then
61348: NOP4
61352: PUSH
61353: NOP4
61357: ARRAY
61358: PUSH
61359: LD_INT 1
61361: ARRAY
61362: IFFALSE 61394
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61364: NOP4
61368: PPUSH
61369: NOP4
61373: PUSH
61374: NOP4
61378: ARRAY
61379: PUSH
61380: LD_INT 1
61382: ARRAY
61383: PUSH
61384: LD_INT 1
61386: ARRAY
61387: PPUSH
61388: NOP4
61392: GO 61450
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61394: NOP4
61398: PPUSH
61399: NOP4
61403: NOT
61404: PUSH
61405: NOP4
61409: PUSH
61410: NOP4
61414: ARRAY
61415: PUSH
61416: LD_INT 2
61418: ARRAY
61419: AND
61420: IFFALSE 61450
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61422: NOP4
61426: PPUSH
61427: NOP4
61431: PUSH
61432: NOP4
61436: ARRAY
61437: PUSH
61438: LD_INT 2
61440: ARRAY
61441: PUSH
61442: LD_INT 1
61444: ARRAY
61445: PPUSH
61446: NOP4
// end ;
61450: GO 61228
61452: POP
61453: POP
// end ;
61454: GO 61071
61456: POP
61457: POP
// end ;
61458: LD_VAR 0 1
61462: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61463: LD_INT 0
61465: PPUSH
61466: PPUSH
61467: PPUSH
61468: PPUSH
61469: PPUSH
// if not mc_bases then
61470: NOP4
61474: NOT
61475: IFFALSE 61479
// exit ;
61477: GO 62650
// for i = 1 to mc_bases do
61479: NOP4
61483: PUSH
61484: DOUBLE
61485: LD_INT 1
61487: DEC
61488: ST_TO_ADDR
61489: NOP4
61493: PUSH
61494: FOR_TO
61495: IFFALSE 62648
// begin if mc_scan [ i ] then
61497: NOP4
61501: PUSH
61502: NOP4
61506: ARRAY
61507: IFFALSE 61511
// continue ;
61509: GO 61494
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61511: NOP4
61515: PUSH
61516: NOP4
61520: ARRAY
61521: NOT
61522: PUSH
61523: NOP4
61527: PUSH
61528: NOP4
61532: ARRAY
61533: NOT
61534: AND
61535: PUSH
61536: NOP4
61540: PUSH
61541: NOP4
61545: ARRAY
61546: AND
61547: IFFALSE 61585
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61549: NOP4
61553: PUSH
61554: NOP4
61558: PPUSH
61559: NOP4
61563: PPUSH
61564: EMPTY
61565: PPUSH
61566: NOP4
61570: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61571: NOP4
61575: PPUSH
61576: LD_INT 103
61578: PPUSH
61579: NOP4
// continue ;
61583: GO 61494
// end ; if mc_construct_list [ i ] then
61585: NOP4
61589: PUSH
61590: NOP4
61594: ARRAY
61595: IFFALSE 61815
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61597: NOP4
61601: PUSH
61602: NOP4
61606: PUSH
61607: NOP4
61611: ARRAY
61612: PPUSH
61613: LD_INT 25
61615: PUSH
61616: LD_INT 2
61618: PUSH
61619: EMPTY
61620: LIST
61621: LIST
61622: PPUSH
61623: NOP4
61627: PUSH
61628: NOP4
61632: PUSH
61633: NOP4
61637: ARRAY
61638: DIFF
61639: ST_TO_ADDR
// if not tmp then
61640: NOP4
61644: NOT
61645: IFFALSE 61649
// continue ;
61647: GO 61494
// for j in tmp do
61649: NOP4
61653: PUSH
61654: NOP4
61658: PUSH
61659: FOR_IN
61660: IFFALSE 61811
// begin if not mc_builders [ i ] then
61662: NOP4
61666: PUSH
61667: NOP4
61671: ARRAY
61672: NOT
61673: IFFALSE 61731
// begin SetTag ( j , 103 ) ;
61675: NOP4
61679: PPUSH
61680: LD_INT 103
61682: PPUSH
61683: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61687: NOP4
61691: PUSH
61692: NOP4
61696: PPUSH
61697: NOP4
61701: PUSH
61702: NOP4
61706: PUSH
61707: NOP4
61711: ARRAY
61712: PUSH
61713: LD_INT 1
61715: PLUS
61716: PUSH
61717: EMPTY
61718: LIST
61719: LIST
61720: PPUSH
61721: NOP4
61725: PPUSH
61726: NOP4
61730: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61731: NOP4
61735: PPUSH
61736: NOP4
61740: IFFALSE 61751
// ComExitBuilding ( j ) ;
61742: NOP4
61746: PPUSH
61747: NOP4
// wait ( 3 ) ;
61751: LD_INT 3
61753: PPUSH
61754: NOP4
// if not mc_construct_list [ i ] then
61758: NOP4
61762: PUSH
61763: NOP4
61767: ARRAY
61768: NOT
61769: IFFALSE 61773
// break ;
61771: GO 61811
// if not HasTask ( j ) then
61773: NOP4
61777: PPUSH
61778: NOP4
61782: NOT
61783: IFFALSE 61809
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61785: NOP4
61789: PPUSH
61790: NOP4
61794: PUSH
61795: NOP4
61799: ARRAY
61800: PUSH
61801: LD_INT 1
61803: ARRAY
61804: PPUSH
61805: NOP4
// end ;
61809: GO 61659
61811: POP
61812: POP
// end else
61813: GO 62646
// if mc_build_list [ i ] then
61815: NOP4
61819: PUSH
61820: NOP4
61824: ARRAY
61825: IFFALSE 62646
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61827: NOP4
61831: PUSH
61832: NOP4
61836: PUSH
61837: NOP4
61841: ARRAY
61842: PPUSH
61843: LD_INT 2
61845: PUSH
61846: LD_INT 30
61848: PUSH
61849: LD_INT 0
61851: PUSH
61852: EMPTY
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 30
61858: PUSH
61859: LD_INT 1
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: LIST
61870: PPUSH
61871: NOP4
61875: ST_TO_ADDR
// if depot then
61876: NOP4
61880: IFFALSE 61898
// depot := depot [ 1 ] else
61882: NOP4
61886: PUSH
61887: NOP4
61891: PUSH
61892: LD_INT 1
61894: ARRAY
61895: ST_TO_ADDR
61896: GO 61906
// depot := 0 ;
61898: NOP4
61902: PUSH
61903: LD_INT 0
61905: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61906: NOP4
61910: PUSH
61911: NOP4
61915: ARRAY
61916: PUSH
61917: LD_INT 1
61919: ARRAY
61920: PUSH
61921: LD_INT 1
61923: ARRAY
61924: PPUSH
61925: NOP4
61929: PUSH
61930: NOP4
61934: PUSH
61935: NOP4
61939: ARRAY
61940: PPUSH
61941: LD_INT 2
61943: PUSH
61944: LD_INT 30
61946: PUSH
61947: LD_INT 2
61949: PUSH
61950: EMPTY
61951: LIST
61952: LIST
61953: PUSH
61954: LD_INT 30
61956: PUSH
61957: LD_INT 3
61959: PUSH
61960: EMPTY
61961: LIST
61962: LIST
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: LIST
61968: PPUSH
61969: NOP4
61973: NOT
61974: AND
61975: IFFALSE 62080
// begin for j = 1 to mc_build_list [ i ] do
61977: NOP4
61981: PUSH
61982: DOUBLE
61983: LD_INT 1
61985: DEC
61986: ST_TO_ADDR
61987: NOP4
61991: PUSH
61992: NOP4
61996: ARRAY
61997: PUSH
61998: FOR_TO
61999: IFFALSE 62078
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62001: NOP4
62005: PUSH
62006: NOP4
62010: ARRAY
62011: PUSH
62012: NOP4
62016: ARRAY
62017: PUSH
62018: LD_INT 1
62020: ARRAY
62021: PUSH
62022: LD_INT 2
62024: EQUAL
62025: IFFALSE 62076
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62027: NOP4
62031: PUSH
62032: NOP4
62036: PPUSH
62037: NOP4
62041: PPUSH
62042: NOP4
62046: PUSH
62047: NOP4
62051: ARRAY
62052: PPUSH
62053: NOP4
62057: PPUSH
62058: LD_INT 1
62060: PPUSH
62061: LD_INT 0
62063: PPUSH
62064: NOP4
62068: PPUSH
62069: NOP4
62073: ST_TO_ADDR
// break ;
62074: GO 62078
// end ;
62076: GO 61998
62078: POP
62079: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62080: NOP4
62084: PUSH
62085: NOP4
62089: ARRAY
62090: PUSH
62091: LD_INT 1
62093: ARRAY
62094: PUSH
62095: LD_INT 1
62097: ARRAY
62098: PUSH
62099: LD_INT 0
62101: EQUAL
62102: PUSH
62103: NOP4
62107: PUSH
62108: NOP4
62112: PPUSH
62113: NOP4
62117: PUSH
62118: NOP4
62122: ARRAY
62123: PUSH
62124: LD_INT 1
62126: ARRAY
62127: PUSH
62128: LD_INT 1
62130: ARRAY
62131: PPUSH
62132: NOP4
62136: PUSH
62137: NOP4
62141: ARRAY
62142: PUSH
62143: LD_INT 1
62145: ARRAY
62146: PUSH
62147: LD_INT 2
62149: ARRAY
62150: PPUSH
62151: NOP4
62155: PUSH
62156: NOP4
62160: ARRAY
62161: PUSH
62162: LD_INT 1
62164: ARRAY
62165: PUSH
62166: LD_INT 3
62168: ARRAY
62169: PPUSH
62170: NOP4
62174: PUSH
62175: NOP4
62179: ARRAY
62180: PUSH
62181: LD_INT 1
62183: ARRAY
62184: PUSH
62185: LD_INT 4
62187: ARRAY
62188: PPUSH
62189: NOP4
62193: AND
62194: OR
62195: IFFALSE 62476
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62197: NOP4
62201: PUSH
62202: NOP4
62206: PUSH
62207: NOP4
62211: ARRAY
62212: PPUSH
62213: LD_INT 25
62215: PUSH
62216: LD_INT 2
62218: PUSH
62219: EMPTY
62220: LIST
62221: LIST
62222: PPUSH
62223: NOP4
62227: PUSH
62228: NOP4
62232: PUSH
62233: NOP4
62237: ARRAY
62238: DIFF
62239: ST_TO_ADDR
// if not tmp then
62240: NOP4
62244: NOT
62245: IFFALSE 62249
// continue ;
62247: GO 61494
// for j in tmp do
62249: NOP4
62253: PUSH
62254: NOP4
62258: PUSH
62259: FOR_IN
62260: IFFALSE 62472
// begin if not mc_builders [ i ] then
62262: NOP4
62266: PUSH
62267: NOP4
62271: ARRAY
62272: NOT
62273: IFFALSE 62331
// begin SetTag ( j , 103 ) ;
62275: NOP4
62279: PPUSH
62280: LD_INT 103
62282: PPUSH
62283: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62287: NOP4
62291: PUSH
62292: NOP4
62296: PPUSH
62297: NOP4
62301: PUSH
62302: NOP4
62306: PUSH
62307: NOP4
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: PLUS
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PPUSH
62321: NOP4
62325: PPUSH
62326: NOP4
62330: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62331: NOP4
62335: PPUSH
62336: NOP4
62340: IFFALSE 62351
// ComExitBuilding ( j ) ;
62342: NOP4
62346: PPUSH
62347: NOP4
// wait ( 3 ) ;
62351: LD_INT 3
62353: PPUSH
62354: NOP4
// if not mc_build_list [ i ] then
62358: NOP4
62362: PUSH
62363: NOP4
62367: ARRAY
62368: NOT
62369: IFFALSE 62373
// break ;
62371: GO 62472
// if not HasTask ( j ) then
62373: NOP4
62377: PPUSH
62378: NOP4
62382: NOT
62383: IFFALSE 62470
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62385: NOP4
62389: PPUSH
62390: NOP4
62394: PUSH
62395: NOP4
62399: ARRAY
62400: PUSH
62401: LD_INT 1
62403: ARRAY
62404: PUSH
62405: LD_INT 1
62407: ARRAY
62408: PPUSH
62409: NOP4
62413: PUSH
62414: NOP4
62418: ARRAY
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PUSH
62424: LD_INT 2
62426: ARRAY
62427: PPUSH
62428: NOP4
62432: PUSH
62433: NOP4
62437: ARRAY
62438: PUSH
62439: LD_INT 1
62441: ARRAY
62442: PUSH
62443: LD_INT 3
62445: ARRAY
62446: PPUSH
62447: NOP4
62451: PUSH
62452: NOP4
62456: ARRAY
62457: PUSH
62458: LD_INT 1
62460: ARRAY
62461: PUSH
62462: LD_INT 4
62464: ARRAY
62465: PPUSH
62466: NOP4
// end ;
62470: GO 62259
62472: POP
62473: POP
// end else
62474: GO 62646
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62476: NOP4
62480: PUSH
62481: NOP4
62485: ARRAY
62486: PPUSH
62487: NOP4
62491: PUSH
62492: NOP4
62496: ARRAY
62497: PUSH
62498: LD_INT 1
62500: ARRAY
62501: PUSH
62502: LD_INT 1
62504: ARRAY
62505: PPUSH
62506: NOP4
62510: PUSH
62511: NOP4
62515: ARRAY
62516: PUSH
62517: LD_INT 1
62519: ARRAY
62520: PUSH
62521: LD_INT 2
62523: ARRAY
62524: PPUSH
62525: NOP4
62529: PUSH
62530: NOP4
62534: ARRAY
62535: PUSH
62536: LD_INT 1
62538: ARRAY
62539: PUSH
62540: LD_INT 3
62542: ARRAY
62543: PPUSH
62544: NOP4
62548: PUSH
62549: NOP4
62553: ARRAY
62554: PUSH
62555: LD_INT 1
62557: ARRAY
62558: PUSH
62559: LD_INT 4
62561: ARRAY
62562: PPUSH
62563: NOP4
62567: PUSH
62568: NOP4
62572: ARRAY
62573: PPUSH
62574: LD_INT 21
62576: PUSH
62577: LD_INT 3
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PPUSH
62584: NOP4
62588: PPUSH
62589: EMPTY
62590: PPUSH
62591: NOP4
62595: NOT
62596: IFFALSE 62646
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62598: NOP4
62602: PUSH
62603: NOP4
62607: PPUSH
62608: NOP4
62612: PPUSH
62613: NOP4
62617: PUSH
62618: NOP4
62622: ARRAY
62623: PPUSH
62624: LD_INT 1
62626: PPUSH
62627: LD_INT 1
62629: NEG
62630: PPUSH
62631: LD_INT 0
62633: PPUSH
62634: NOP4
62638: PPUSH
62639: NOP4
62643: ST_TO_ADDR
// continue ;
62644: GO 61494
// end ; end ; end ;
62646: GO 61494
62648: POP
62649: POP
// end ;
62650: LD_VAR 0 1
62654: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62655: LD_INT 0
62657: PPUSH
62658: PPUSH
62659: PPUSH
62660: PPUSH
62661: PPUSH
62662: PPUSH
// if not mc_bases then
62663: NOP4
62667: NOT
62668: IFFALSE 62672
// exit ;
62670: GO 63099
// for i = 1 to mc_bases do
62672: NOP4
62676: PUSH
62677: DOUBLE
62678: LD_INT 1
62680: DEC
62681: ST_TO_ADDR
62682: NOP4
62686: PUSH
62687: FOR_TO
62688: IFFALSE 63097
// begin tmp := mc_build_upgrade [ i ] ;
62690: NOP4
62694: PUSH
62695: NOP4
62699: PUSH
62700: NOP4
62704: ARRAY
62705: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62706: NOP4
62710: PUSH
62711: NOP4
62715: PUSH
62716: NOP4
62720: ARRAY
62721: PPUSH
62722: LD_INT 2
62724: PUSH
62725: LD_INT 30
62727: PUSH
62728: LD_INT 6
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: LD_INT 30
62737: PUSH
62738: LD_INT 7
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: LIST
62749: PPUSH
62750: NOP4
62754: ST_TO_ADDR
// if not tmp and not lab then
62755: NOP4
62759: NOT
62760: PUSH
62761: NOP4
62765: NOT
62766: AND
62767: IFFALSE 62771
// continue ;
62769: GO 62687
// if tmp then
62771: NOP4
62775: IFFALSE 62895
// for j in tmp do
62777: NOP4
62781: PUSH
62782: NOP4
62786: PUSH
62787: FOR_IN
62788: IFFALSE 62893
// begin if UpgradeCost ( j ) then
62790: NOP4
62794: PPUSH
62795: NOP4
62799: IFFALSE 62891
// begin ComUpgrade ( j ) ;
62801: NOP4
62805: PPUSH
62806: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62810: NOP4
62814: PUSH
62815: NOP4
62819: PPUSH
62820: NOP4
62824: PPUSH
62825: NOP4
62829: PUSH
62830: NOP4
62834: ARRAY
62835: PUSH
62836: NOP4
62840: DIFF
62841: PPUSH
62842: NOP4
62846: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62847: NOP4
62851: PUSH
62852: NOP4
62856: PPUSH
62857: NOP4
62861: PUSH
62862: NOP4
62866: PUSH
62867: NOP4
62871: ARRAY
62872: PUSH
62873: LD_INT 1
62875: PLUS
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: PPUSH
62881: NOP4
62885: PPUSH
62886: NOP4
62890: ST_TO_ADDR
// end ; end ;
62891: GO 62787
62893: POP
62894: POP
// if not lab or not mc_lab_upgrade [ i ] then
62895: NOP4
62899: NOT
62900: PUSH
62901: NOP4
62905: PUSH
62906: NOP4
62910: ARRAY
62911: NOT
62912: OR
62913: IFFALSE 62917
// continue ;
62915: GO 62687
// for j in lab do
62917: NOP4
62921: PUSH
62922: NOP4
62926: PUSH
62927: FOR_IN
62928: IFFALSE 63093
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62930: NOP4
62934: PPUSH
62935: NOP4
62939: PUSH
62940: LD_INT 6
62942: PUSH
62943: LD_INT 7
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: IN
62950: PUSH
62951: NOP4
62955: PPUSH
62956: NOP4
62960: PUSH
62961: LD_INT 1
62963: NONEQUAL
62964: AND
62965: IFFALSE 63091
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62967: NOP4
62971: PPUSH
62972: NOP4
62976: PUSH
62977: NOP4
62981: ARRAY
62982: PUSH
62983: LD_INT 1
62985: ARRAY
62986: PPUSH
62987: NOP4
62991: IFFALSE 63091
// begin ComCancel ( j ) ;
62993: NOP4
62997: PPUSH
62998: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63002: NOP4
63006: PPUSH
63007: NOP4
63011: PUSH
63012: NOP4
63016: ARRAY
63017: PUSH
63018: LD_INT 1
63020: ARRAY
63021: PPUSH
63022: NOP4
// if not j in mc_construct_list [ i ] then
63026: NOP4
63030: PUSH
63031: NOP4
63035: PUSH
63036: NOP4
63040: ARRAY
63041: IN
63042: NOT
63043: IFFALSE 63089
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63045: NOP4
63049: PUSH
63050: NOP4
63054: PPUSH
63055: NOP4
63059: PUSH
63060: NOP4
63064: PUSH
63065: NOP4
63069: ARRAY
63070: PUSH
63071: LD_INT 1
63073: PLUS
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PPUSH
63079: NOP4
63083: PPUSH
63084: NOP4
63088: ST_TO_ADDR
// break ;
63089: GO 63093
// end ; end ; end ;
63091: GO 62927
63093: POP
63094: POP
// end ;
63095: GO 62687
63097: POP
63098: POP
// end ;
63099: LD_VAR 0 1
63103: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63104: LD_INT 0
63106: PPUSH
63107: PPUSH
63108: PPUSH
63109: PPUSH
63110: PPUSH
63111: PPUSH
63112: PPUSH
63113: PPUSH
63114: PPUSH
// if not mc_bases then
63115: NOP4
63119: NOT
63120: IFFALSE 63124
// exit ;
63122: GO 63529
// for i = 1 to mc_bases do
63124: NOP4
63128: PUSH
63129: DOUBLE
63130: LD_INT 1
63132: DEC
63133: ST_TO_ADDR
63134: NOP4
63138: PUSH
63139: FOR_TO
63140: IFFALSE 63527
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63142: NOP4
63146: PUSH
63147: NOP4
63151: ARRAY
63152: NOT
63153: PUSH
63154: NOP4
63158: PUSH
63159: NOP4
63163: ARRAY
63164: PPUSH
63165: LD_INT 30
63167: PUSH
63168: LD_INT 3
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: PPUSH
63175: NOP4
63179: NOT
63180: OR
63181: IFFALSE 63185
// continue ;
63183: GO 63139
// busy := false ;
63185: NOP4
63189: PUSH
63190: LD_INT 0
63192: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63193: NOP4
63197: PUSH
63198: NOP4
63202: PUSH
63203: NOP4
63207: ARRAY
63208: PPUSH
63209: LD_INT 30
63211: PUSH
63212: LD_INT 3
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PPUSH
63219: NOP4
63223: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63224: NOP4
63228: PUSH
63229: NOP4
63233: PUSH
63234: NOP4
63238: ARRAY
63239: PPUSH
63240: LD_INT 2
63242: PUSH
63243: LD_INT 30
63245: PUSH
63246: LD_INT 32
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: PUSH
63253: LD_INT 30
63255: PUSH
63256: LD_INT 33
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: LIST
63267: PPUSH
63268: NOP4
63272: ST_TO_ADDR
// if not t then
63273: NOP4
63277: NOT
63278: IFFALSE 63282
// continue ;
63280: GO 63139
// for j in tmp do
63282: NOP4
63286: PUSH
63287: NOP4
63291: PUSH
63292: FOR_IN
63293: IFFALSE 63323
// if not BuildingStatus ( j ) = bs_idle then
63295: NOP4
63299: PPUSH
63300: NOP4
63304: PUSH
63305: LD_INT 2
63307: EQUAL
63308: NOT
63309: IFFALSE 63321
// begin busy := true ;
63311: NOP4
63315: PUSH
63316: LD_INT 1
63318: ST_TO_ADDR
// break ;
63319: GO 63323
// end ;
63321: GO 63292
63323: POP
63324: POP
// if busy then
63325: NOP4
63329: IFFALSE 63333
// continue ;
63331: GO 63139
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63333: NOP4
63337: PUSH
63338: NOP4
63342: PPUSH
63343: LD_INT 35
63345: PUSH
63346: LD_INT 0
63348: PUSH
63349: EMPTY
63350: LIST
63351: LIST
63352: PPUSH
63353: NOP4
63357: ST_TO_ADDR
// if tw then
63358: NOP4
63362: IFFALSE 63439
// begin tw := tw [ 1 ] ;
63364: NOP4
63368: PUSH
63369: NOP4
63373: PUSH
63374: LD_INT 1
63376: ARRAY
63377: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63378: NOP4
63382: PUSH
63383: NOP4
63387: PPUSH
63388: NOP4
63392: PUSH
63393: NOP4
63397: ARRAY
63398: PPUSH
63399: NOP4
63403: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63404: NOP4
63408: PUSH
63409: NOP4
63413: ARRAY
63414: IFFALSE 63437
// if not weapon in mc_allowed_tower_weapons [ i ] then
63416: NOP4
63420: PUSH
63421: NOP4
63425: PUSH
63426: NOP4
63430: ARRAY
63431: IN
63432: NOT
63433: IFFALSE 63437
// continue ;
63435: GO 63139
// end else
63437: GO 63502
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63439: NOP4
63443: PUSH
63444: NOP4
63448: PUSH
63449: NOP4
63453: ARRAY
63454: PPUSH
63455: NOP4
63459: PPUSH
63460: NOP4
63464: ST_TO_ADDR
// if not tmp2 then
63465: NOP4
63469: NOT
63470: IFFALSE 63474
// continue ;
63472: GO 63139
// tw := tmp2 [ 1 ] ;
63474: NOP4
63478: PUSH
63479: NOP4
63483: PUSH
63484: LD_INT 1
63486: ARRAY
63487: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63488: NOP4
63492: PUSH
63493: NOP4
63497: PUSH
63498: LD_INT 2
63500: ARRAY
63501: ST_TO_ADDR
// end ; if not weapon then
63502: NOP4
63506: NOT
63507: IFFALSE 63511
// continue ;
63509: GO 63139
// ComPlaceWeapon ( tw , weapon ) ;
63511: NOP4
63515: PPUSH
63516: NOP4
63520: PPUSH
63521: NOP4
// end ;
63525: GO 63139
63527: POP
63528: POP
// end ;
63529: LD_VAR 0 1
63533: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63534: LD_INT 0
63536: PPUSH
63537: PPUSH
63538: PPUSH
63539: PPUSH
63540: PPUSH
63541: PPUSH
63542: PPUSH
// if not mc_bases then
63543: NOP4
63547: NOT
63548: IFFALSE 63552
// exit ;
63550: GO 64320
// for i = 1 to mc_bases do
63552: NOP4
63556: PUSH
63557: DOUBLE
63558: LD_INT 1
63560: DEC
63561: ST_TO_ADDR
63562: NOP4
63566: PUSH
63567: FOR_TO
63568: IFFALSE 64318
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63570: NOP4
63574: PUSH
63575: NOP4
63579: ARRAY
63580: NOT
63581: PUSH
63582: NOP4
63586: PUSH
63587: NOP4
63591: ARRAY
63592: PUSH
63593: NOP4
63597: PUSH
63598: NOP4
63602: ARRAY
63603: EQUAL
63604: OR
63605: PUSH
63606: NOP4
63610: PUSH
63611: NOP4
63615: ARRAY
63616: OR
63617: IFFALSE 63621
// continue ;
63619: GO 63567
// if mc_miners [ i ] then
63621: NOP4
63625: PUSH
63626: NOP4
63630: ARRAY
63631: IFFALSE 64005
// begin for j = mc_miners [ i ] downto 1 do
63633: NOP4
63637: PUSH
63638: DOUBLE
63639: NOP4
63643: PUSH
63644: NOP4
63648: ARRAY
63649: INC
63650: ST_TO_ADDR
63651: LD_INT 1
63653: PUSH
63654: FOR_DOWNTO
63655: IFFALSE 64003
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63657: NOP4
63661: PUSH
63662: NOP4
63666: ARRAY
63667: PUSH
63668: NOP4
63672: ARRAY
63673: PPUSH
63674: NOP4
63678: PUSH
63679: NOP4
63683: PUSH
63684: NOP4
63688: ARRAY
63689: PUSH
63690: NOP4
63694: ARRAY
63695: PPUSH
63696: NOP4
63700: PUSH
63701: LD_INT 1
63703: NONEQUAL
63704: OR
63705: IFFALSE 63768
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63707: NOP4
63711: PUSH
63712: NOP4
63716: PUSH
63717: NOP4
63721: ARRAY
63722: PUSH
63723: NOP4
63727: PUSH
63728: NOP4
63732: ARRAY
63733: PUSH
63734: NOP4
63738: ARRAY
63739: DIFF
63740: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63741: NOP4
63745: PUSH
63746: NOP4
63750: PPUSH
63751: NOP4
63755: PPUSH
63756: NOP4
63760: PPUSH
63761: NOP4
63765: ST_TO_ADDR
// continue ;
63766: GO 63654
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63768: NOP4
63772: PUSH
63773: NOP4
63777: ARRAY
63778: PUSH
63779: NOP4
63783: ARRAY
63784: PPUSH
63785: NOP4
63789: PUSH
63790: LD_INT 1
63792: EQUAL
63793: PUSH
63794: NOP4
63798: PUSH
63799: NOP4
63803: ARRAY
63804: PUSH
63805: NOP4
63809: ARRAY
63810: PPUSH
63811: NOP4
63815: NOT
63816: AND
63817: PUSH
63818: NOP4
63822: PUSH
63823: NOP4
63827: ARRAY
63828: PUSH
63829: NOP4
63833: ARRAY
63834: PPUSH
63835: NOP4
63839: NOT
63840: AND
63841: IFFALSE 64001
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63843: NOP4
63847: PUSH
63848: NOP4
63852: ARRAY
63853: PUSH
63854: NOP4
63858: ARRAY
63859: PPUSH
63860: NOP4
63864: IFFALSE 63887
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63866: NOP4
63870: PUSH
63871: NOP4
63875: ARRAY
63876: PUSH
63877: NOP4
63881: ARRAY
63882: PPUSH
63883: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63887: NOP4
63891: PUSH
63892: NOP4
63896: ARRAY
63897: PUSH
63898: NOP4
63902: ARRAY
63903: PPUSH
63904: NOP4
63908: NOT
63909: IFFALSE 64001
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63911: NOP4
63915: PUSH
63916: LD_INT 1
63918: PPUSH
63919: NOP4
63923: PUSH
63924: NOP4
63928: ARRAY
63929: PPUSH
63930: NOP4
63934: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63935: NOP4
63939: PUSH
63940: NOP4
63944: ARRAY
63945: PUSH
63946: NOP4
63950: ARRAY
63951: PPUSH
63952: NOP4
63956: PUSH
63957: NOP4
63961: ARRAY
63962: PUSH
63963: NOP4
63967: ARRAY
63968: PUSH
63969: LD_INT 1
63971: ARRAY
63972: PPUSH
63973: NOP4
63977: PUSH
63978: NOP4
63982: ARRAY
63983: PUSH
63984: NOP4
63988: ARRAY
63989: PUSH
63990: LD_INT 2
63992: ARRAY
63993: PPUSH
63994: LD_INT 0
63996: PPUSH
63997: NOP4
// end ; end ; end ;
64001: GO 63654
64003: POP
64004: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64005: NOP4
64009: PUSH
64010: NOP4
64014: PUSH
64015: NOP4
64019: ARRAY
64020: PPUSH
64021: LD_INT 2
64023: PUSH
64024: LD_INT 30
64026: PUSH
64027: LD_INT 4
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 30
64036: PUSH
64037: LD_INT 5
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: LD_INT 30
64046: PUSH
64047: LD_INT 32
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: PPUSH
64060: NOP4
64064: ST_TO_ADDR
// if not tmp then
64065: NOP4
64069: NOT
64070: IFFALSE 64074
// continue ;
64072: GO 63567
// list := [ ] ;
64074: NOP4
64078: PUSH
64079: EMPTY
64080: ST_TO_ADDR
// for j in tmp do
64081: NOP4
64085: PUSH
64086: NOP4
64090: PUSH
64091: FOR_IN
64092: IFFALSE 64161
// begin for k in UnitsInside ( j ) do
64094: NOP4
64098: PUSH
64099: NOP4
64103: PPUSH
64104: NOP4
64108: PUSH
64109: FOR_IN
64110: IFFALSE 64157
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64112: NOP4
64116: PPUSH
64117: NOP4
64121: PUSH
64122: LD_INT 1
64124: EQUAL
64125: PUSH
64126: NOP4
64130: PPUSH
64131: NOP4
64135: NOT
64136: AND
64137: IFFALSE 64155
// list := list ^ k ;
64139: NOP4
64143: PUSH
64144: NOP4
64148: PUSH
64149: NOP4
64153: ADD
64154: ST_TO_ADDR
64155: GO 64109
64157: POP
64158: POP
// end ;
64159: GO 64091
64161: POP
64162: POP
// list := list diff mc_miners [ i ] ;
64163: NOP4
64167: PUSH
64168: NOP4
64172: PUSH
64173: NOP4
64177: PUSH
64178: NOP4
64182: ARRAY
64183: DIFF
64184: ST_TO_ADDR
// if not list then
64185: NOP4
64189: NOT
64190: IFFALSE 64194
// continue ;
64192: GO 63567
// k := mc_mines [ i ] - mc_miners [ i ] ;
64194: NOP4
64198: PUSH
64199: NOP4
64203: PUSH
64204: NOP4
64208: ARRAY
64209: PUSH
64210: NOP4
64214: PUSH
64215: NOP4
64219: ARRAY
64220: MINUS
64221: ST_TO_ADDR
// if k > list then
64222: NOP4
64226: PUSH
64227: NOP4
64231: GREATER
64232: IFFALSE 64244
// k := list ;
64234: NOP4
64238: PUSH
64239: NOP4
64243: ST_TO_ADDR
// for j = 1 to k do
64244: NOP4
64248: PUSH
64249: DOUBLE
64250: LD_INT 1
64252: DEC
64253: ST_TO_ADDR
64254: NOP4
64258: PUSH
64259: FOR_TO
64260: IFFALSE 64314
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64262: NOP4
64266: PUSH
64267: NOP4
64271: PPUSH
64272: NOP4
64276: PUSH
64277: NOP4
64281: PUSH
64282: NOP4
64286: ARRAY
64287: PUSH
64288: LD_INT 1
64290: PLUS
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PPUSH
64296: NOP4
64300: PUSH
64301: NOP4
64305: ARRAY
64306: PPUSH
64307: NOP4
64311: ST_TO_ADDR
64312: GO 64259
64314: POP
64315: POP
// end ;
64316: GO 63567
64318: POP
64319: POP
// end ;
64320: LD_VAR 0 1
64324: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64325: LD_INT 0
64327: PPUSH
64328: PPUSH
64329: PPUSH
64330: PPUSH
64331: PPUSH
64332: PPUSH
64333: PPUSH
64334: PPUSH
64335: PPUSH
64336: PPUSH
64337: PPUSH
// if not mc_bases then
64338: NOP4
64342: NOT
64343: IFFALSE 64347
// exit ;
64345: GO 66170
// for i = 1 to mc_bases do
64347: NOP4
64351: PUSH
64352: DOUBLE
64353: LD_INT 1
64355: DEC
64356: ST_TO_ADDR
64357: NOP4
64361: PUSH
64362: FOR_TO
64363: IFFALSE 66168
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64365: NOP4
64369: PUSH
64370: NOP4
64374: ARRAY
64375: NOT
64376: PUSH
64377: NOP4
64381: PUSH
64382: NOP4
64386: ARRAY
64387: OR
64388: IFFALSE 64392
// continue ;
64390: GO 64362
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64392: NOP4
64396: PUSH
64397: NOP4
64401: ARRAY
64402: NOT
64403: PUSH
64404: NOP4
64408: PUSH
64409: NOP4
64413: ARRAY
64414: AND
64415: IFFALSE 64453
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64417: NOP4
64421: PUSH
64422: NOP4
64426: PPUSH
64427: NOP4
64431: PPUSH
64432: EMPTY
64433: PPUSH
64434: NOP4
64438: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64439: NOP4
64443: PPUSH
64444: LD_INT 107
64446: PPUSH
64447: NOP4
// continue ;
64451: GO 64362
// end ; target := [ ] ;
64453: NOP4
64457: PUSH
64458: EMPTY
64459: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64460: NOP4
64464: PUSH
64465: NOP4
64469: PUSH
64470: NOP4
64474: ARRAY
64475: PUSH
64476: LD_INT 1
64478: ARRAY
64479: PPUSH
64480: NOP4
64484: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64485: NOP4
64489: PUSH
64490: NOP4
64494: PUSH
64495: NOP4
64499: ARRAY
64500: PPUSH
64501: LD_INT 2
64503: PUSH
64504: LD_INT 30
64506: PUSH
64507: LD_INT 0
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: LD_INT 30
64516: PUSH
64517: LD_INT 1
64519: PUSH
64520: EMPTY
64521: LIST
64522: LIST
64523: PUSH
64524: EMPTY
64525: LIST
64526: LIST
64527: LIST
64528: PPUSH
64529: NOP4
64533: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64534: NOP4
64538: PUSH
64539: DOUBLE
64540: NOP4
64544: PUSH
64545: NOP4
64549: ARRAY
64550: INC
64551: ST_TO_ADDR
64552: LD_INT 1
64554: PUSH
64555: FOR_DOWNTO
64556: IFFALSE 64801
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64558: NOP4
64562: PUSH
64563: NOP4
64567: ARRAY
64568: PUSH
64569: NOP4
64573: ARRAY
64574: PUSH
64575: LD_INT 2
64577: ARRAY
64578: PPUSH
64579: NOP4
64583: PUSH
64584: NOP4
64588: ARRAY
64589: PUSH
64590: NOP4
64594: ARRAY
64595: PUSH
64596: LD_INT 3
64598: ARRAY
64599: PPUSH
64600: NOP4
64604: PUSH
64605: NOP4
64609: PUSH
64610: NOP4
64614: ARRAY
64615: PUSH
64616: NOP4
64620: ARRAY
64621: PUSH
64622: LD_INT 2
64624: ARRAY
64625: PPUSH
64626: NOP4
64630: PUSH
64631: NOP4
64635: ARRAY
64636: PUSH
64637: NOP4
64641: ARRAY
64642: PUSH
64643: LD_INT 3
64645: ARRAY
64646: PPUSH
64647: NOP4
64651: PUSH
64652: LD_INT 0
64654: EQUAL
64655: AND
64656: IFFALSE 64711
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64658: NOP4
64662: PUSH
64663: NOP4
64667: PUSH
64668: NOP4
64672: ARRAY
64673: PPUSH
64674: NOP4
64678: PPUSH
64679: NOP4
64683: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64684: NOP4
64688: PUSH
64689: NOP4
64693: PPUSH
64694: NOP4
64698: PPUSH
64699: NOP4
64703: PPUSH
64704: NOP4
64708: ST_TO_ADDR
// continue ;
64709: GO 64555
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64711: NOP4
64715: PPUSH
64716: NOP4
64720: PUSH
64721: NOP4
64725: ARRAY
64726: PUSH
64727: NOP4
64731: ARRAY
64732: PUSH
64733: LD_INT 2
64735: ARRAY
64736: PPUSH
64737: NOP4
64741: PUSH
64742: NOP4
64746: ARRAY
64747: PUSH
64748: NOP4
64752: ARRAY
64753: PUSH
64754: LD_INT 3
64756: ARRAY
64757: PPUSH
64758: LD_INT 30
64760: PPUSH
64761: NOP4
64765: PUSH
64766: LD_INT 4
64768: ARRAY
64769: PUSH
64770: LD_INT 0
64772: EQUAL
64773: IFFALSE 64799
// begin target := mc_crates [ i ] [ j ] ;
64775: NOP4
64779: PUSH
64780: NOP4
64784: PUSH
64785: NOP4
64789: ARRAY
64790: PUSH
64791: NOP4
64795: ARRAY
64796: ST_TO_ADDR
// break ;
64797: GO 64801
// end ; end ;
64799: GO 64555
64801: POP
64802: POP
// if not target then
64803: NOP4
64807: NOT
64808: IFFALSE 64812
// continue ;
64810: GO 64362
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64812: NOP4
64816: PUSH
64817: NOP4
64821: PUSH
64822: NOP4
64826: ARRAY
64827: PPUSH
64828: LD_INT 2
64830: PUSH
64831: LD_INT 3
64833: PUSH
64834: LD_INT 58
64836: PUSH
64837: EMPTY
64838: LIST
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 61
64846: PUSH
64847: EMPTY
64848: LIST
64849: PUSH
64850: LD_INT 33
64852: PUSH
64853: LD_INT 5
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 33
64862: PUSH
64863: LD_INT 3
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: PUSH
64877: LD_INT 2
64879: PUSH
64880: LD_INT 34
64882: PUSH
64883: LD_INT 32
64885: PUSH
64886: EMPTY
64887: LIST
64888: LIST
64889: PUSH
64890: LD_INT 34
64892: PUSH
64893: LD_INT 51
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_INT 34
64902: PUSH
64903: LD_INT 12
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PPUSH
64920: NOP4
64924: ST_TO_ADDR
// if not cargo then
64925: NOP4
64929: NOT
64930: IFFALSE 65636
// begin if mc_crates_collector [ i ] < 5 then
64932: NOP4
64936: PUSH
64937: NOP4
64941: ARRAY
64942: PUSH
64943: LD_INT 5
64945: LESS
64946: IFFALSE 65312
// begin if mc_ape [ i ] then
64948: NOP4
64952: PUSH
64953: NOP4
64957: ARRAY
64958: IFFALSE 65005
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64960: NOP4
64964: PUSH
64965: NOP4
64969: PUSH
64970: NOP4
64974: ARRAY
64975: PPUSH
64976: LD_INT 25
64978: PUSH
64979: LD_INT 16
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: LD_INT 24
64988: PUSH
64989: LD_INT 750
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PPUSH
65000: NOP4
65004: ST_TO_ADDR
// if not tmp then
65005: NOP4
65009: NOT
65010: IFFALSE 65057
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65012: NOP4
65016: PUSH
65017: NOP4
65021: PUSH
65022: NOP4
65026: ARRAY
65027: PPUSH
65028: LD_INT 25
65030: PUSH
65031: LD_INT 2
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: LD_INT 24
65040: PUSH
65041: LD_INT 750
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: PPUSH
65052: NOP4
65056: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65057: NOP4
65061: PUSH
65062: NOP4
65066: ARRAY
65067: PUSH
65068: NOP4
65072: PUSH
65073: NOP4
65077: ARRAY
65078: PPUSH
65079: LD_INT 25
65081: PUSH
65082: LD_INT 2
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 24
65091: PUSH
65092: LD_INT 750
65094: PUSH
65095: EMPTY
65096: LIST
65097: LIST
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: PPUSH
65103: NOP4
65107: AND
65108: PUSH
65109: NOP4
65113: PUSH
65114: LD_INT 5
65116: LESS
65117: AND
65118: IFFALSE 65200
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65120: NOP4
65124: PUSH
65125: NOP4
65129: PUSH
65130: NOP4
65134: ARRAY
65135: PPUSH
65136: LD_INT 25
65138: PUSH
65139: LD_INT 2
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 24
65148: PUSH
65149: LD_INT 750
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PPUSH
65160: NOP4
65164: PUSH
65165: FOR_IN
65166: IFFALSE 65198
// begin tmp := tmp union j ;
65168: NOP4
65172: PUSH
65173: NOP4
65177: PUSH
65178: NOP4
65182: UNION
65183: ST_TO_ADDR
// if tmp >= 5 then
65184: NOP4
65188: PUSH
65189: LD_INT 5
65191: GREATEREQUAL
65192: IFFALSE 65196
// break ;
65194: GO 65198
// end ;
65196: GO 65165
65198: POP
65199: POP
// end ; if not tmp then
65200: NOP4
65204: NOT
65205: IFFALSE 65209
// continue ;
65207: GO 64362
// for j in tmp do
65209: NOP4
65213: PUSH
65214: NOP4
65218: PUSH
65219: FOR_IN
65220: IFFALSE 65310
// if not GetTag ( j ) then
65222: NOP4
65226: PPUSH
65227: NOP4
65231: NOT
65232: IFFALSE 65308
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65234: NOP4
65238: PUSH
65239: NOP4
65243: PPUSH
65244: NOP4
65248: PUSH
65249: NOP4
65253: PUSH
65254: NOP4
65258: ARRAY
65259: PUSH
65260: LD_INT 1
65262: PLUS
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PPUSH
65268: NOP4
65272: PPUSH
65273: NOP4
65277: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65278: NOP4
65282: PPUSH
65283: LD_INT 107
65285: PPUSH
65286: NOP4
// if mc_crates_collector [ i ] >= 5 then
65290: NOP4
65294: PUSH
65295: NOP4
65299: ARRAY
65300: PUSH
65301: LD_INT 5
65303: GREATEREQUAL
65304: IFFALSE 65308
// break ;
65306: GO 65310
// end ;
65308: GO 65219
65310: POP
65311: POP
// end ; if mc_crates_collector [ i ] and target then
65312: NOP4
65316: PUSH
65317: NOP4
65321: ARRAY
65322: PUSH
65323: NOP4
65327: AND
65328: IFFALSE 65634
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65330: NOP4
65334: PUSH
65335: NOP4
65339: ARRAY
65340: PUSH
65341: NOP4
65345: PUSH
65346: LD_INT 1
65348: ARRAY
65349: LESS
65350: IFFALSE 65370
// tmp := mc_crates_collector [ i ] else
65352: NOP4
65356: PUSH
65357: NOP4
65361: PUSH
65362: NOP4
65366: ARRAY
65367: ST_TO_ADDR
65368: GO 65384
// tmp := target [ 1 ] ;
65370: NOP4
65374: PUSH
65375: NOP4
65379: PUSH
65380: LD_INT 1
65382: ARRAY
65383: ST_TO_ADDR
// k := 0 ;
65384: NOP4
65388: PUSH
65389: LD_INT 0
65391: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65392: NOP4
65396: PUSH
65397: NOP4
65401: PUSH
65402: NOP4
65406: ARRAY
65407: PUSH
65408: FOR_IN
65409: IFFALSE 65632
// begin k := k + 1 ;
65411: NOP4
65415: PUSH
65416: NOP4
65420: PUSH
65421: LD_INT 1
65423: PLUS
65424: ST_TO_ADDR
// if k > tmp then
65425: NOP4
65429: PUSH
65430: NOP4
65434: GREATER
65435: IFFALSE 65439
// break ;
65437: GO 65632
// if not GetClass ( j ) in [ 2 , 16 ] then
65439: NOP4
65443: PPUSH
65444: NOP4
65448: PUSH
65449: LD_INT 2
65451: PUSH
65452: LD_INT 16
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: IN
65459: NOT
65460: IFFALSE 65513
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65462: NOP4
65466: PUSH
65467: NOP4
65471: PPUSH
65472: NOP4
65476: PPUSH
65477: NOP4
65481: PUSH
65482: NOP4
65486: ARRAY
65487: PUSH
65488: NOP4
65492: DIFF
65493: PPUSH
65494: NOP4
65498: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65499: NOP4
65503: PPUSH
65504: LD_INT 0
65506: PPUSH
65507: NOP4
// continue ;
65511: GO 65408
// end ; if IsInUnit ( j ) then
65513: NOP4
65517: PPUSH
65518: NOP4
65522: IFFALSE 65533
// ComExitBuilding ( j ) ;
65524: NOP4
65528: PPUSH
65529: NOP4
// wait ( 3 ) ;
65533: LD_INT 3
65535: PPUSH
65536: NOP4
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65540: NOP4
65544: PPUSH
65545: NOP4
65549: PUSH
65550: NOP4
65554: PPUSH
65555: NOP4
65559: PUSH
65560: LD_INT 2
65562: ARRAY
65563: PPUSH
65564: NOP4
65568: PUSH
65569: LD_INT 3
65571: ARRAY
65572: PPUSH
65573: LD_INT 30
65575: PPUSH
65576: NOP4
65580: PUSH
65581: LD_INT 4
65583: ARRAY
65584: AND
65585: IFFALSE 65603
// ComStandNearbyBuilding ( j , depot ) else
65587: NOP4
65591: PPUSH
65592: NOP4
65596: PPUSH
65597: NOP4
65601: GO 65630
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65603: NOP4
65607: PPUSH
65608: NOP4
65612: PUSH
65613: LD_INT 2
65615: ARRAY
65616: PPUSH
65617: NOP4
65621: PUSH
65622: LD_INT 3
65624: ARRAY
65625: PPUSH
65626: NOP4
// end ;
65630: GO 65408
65632: POP
65633: POP
// end ; end else
65634: GO 66166
// begin for j in cargo do
65636: NOP4
65640: PUSH
65641: NOP4
65645: PUSH
65646: FOR_IN
65647: IFFALSE 66164
// begin if GetTag ( j ) <> 0 then
65649: NOP4
65653: PPUSH
65654: NOP4
65658: PUSH
65659: LD_INT 0
65661: NONEQUAL
65662: IFFALSE 65666
// continue ;
65664: GO 65646
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65666: NOP4
65670: PPUSH
65671: NOP4
65675: PUSH
65676: LD_INT 1000
65678: LESS
65679: PUSH
65680: NOP4
65684: PPUSH
65685: NOP4
65689: PUSH
65690: NOP4
65694: ARRAY
65695: PPUSH
65696: NOP4
65700: NOT
65701: AND
65702: IFFALSE 65724
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65704: NOP4
65708: PPUSH
65709: NOP4
65713: PUSH
65714: NOP4
65718: ARRAY
65719: PPUSH
65720: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65724: NOP4
65728: PPUSH
65729: NOP4
65733: PUSH
65734: LD_INT 1000
65736: LESS
65737: PUSH
65738: NOP4
65742: PPUSH
65743: NOP4
65747: PUSH
65748: NOP4
65752: ARRAY
65753: PPUSH
65754: NOP4
65758: AND
65759: IFFALSE 65763
// continue ;
65761: GO 65646
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65763: NOP4
65767: PPUSH
65768: NOP4
65772: PUSH
65773: LD_INT 2
65775: EQUAL
65776: PUSH
65777: NOP4
65781: PPUSH
65782: NOP4
65786: PUSH
65787: LD_INT 15
65789: LESS
65790: AND
65791: IFFALSE 65795
// continue ;
65793: GO 65646
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65795: NOP4
65799: PPUSH
65800: NOP4
65804: PUSH
65805: LD_INT 1
65807: EQUAL
65808: PUSH
65809: NOP4
65813: PPUSH
65814: NOP4
65818: PUSH
65819: LD_INT 10
65821: LESS
65822: AND
65823: IFFALSE 66103
// begin if not depot then
65825: NOP4
65829: NOT
65830: IFFALSE 65834
// continue ;
65832: GO 65646
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65834: NOP4
65838: PPUSH
65839: NOP4
65843: PPUSH
65844: NOP4
65848: PPUSH
65849: NOP4
65853: PPUSH
65854: NOP4
65858: PUSH
65859: LD_INT 6
65861: LESS
65862: IFFALSE 65878
// SetFuel ( j , 100 ) else
65864: NOP4
65868: PPUSH
65869: LD_INT 100
65871: PPUSH
65872: NOP4
65876: GO 66103
// if GetFuel ( j ) = 0 then
65878: NOP4
65882: PPUSH
65883: NOP4
65887: PUSH
65888: LD_INT 0
65890: EQUAL
65891: IFFALSE 66103
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65893: NOP4
65897: PUSH
65898: NOP4
65902: PPUSH
65903: NOP4
65907: PPUSH
65908: NOP4
65912: PUSH
65913: NOP4
65917: ARRAY
65918: PUSH
65919: NOP4
65923: DIFF
65924: PPUSH
65925: NOP4
65929: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65930: NOP4
65934: PPUSH
65935: NOP4
65939: PUSH
65940: LD_INT 1
65942: EQUAL
65943: IFFALSE 65959
// ComExitVehicle ( IsInUnit ( j ) ) ;
65945: NOP4
65949: PPUSH
65950: NOP4
65954: PPUSH
65955: NOP4
// if GetControl ( j ) = control_remote then
65959: NOP4
65963: PPUSH
65964: NOP4
65968: PUSH
65969: LD_INT 2
65971: EQUAL
65972: IFFALSE 65983
// ComUnlink ( j ) ;
65974: NOP4
65978: PPUSH
65979: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
65983: NOP4
65987: PUSH
65988: NOP4
65992: PPUSH
65993: LD_INT 3
65995: PPUSH
65996: NOP4
66000: ST_TO_ADDR
// if fac then
66001: NOP4
66005: IFFALSE 66101
// begin for k in fac do
66007: NOP4
66011: PUSH
66012: NOP4
66016: PUSH
66017: FOR_IN
66018: IFFALSE 66099
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66020: NOP4
66024: PUSH
66025: NOP4
66029: PPUSH
66030: NOP4
66034: PPUSH
66035: NOP4
66039: PPUSH
66040: NOP4
66044: PPUSH
66045: NOP4
66049: PPUSH
66050: NOP4
66054: PPUSH
66055: NOP4
66059: PPUSH
66060: NOP4
66064: PPUSH
66065: NOP4
66069: PPUSH
66070: NOP4
66074: ST_TO_ADDR
// if components then
66075: NOP4
66079: IFFALSE 66097
// begin MC_InsertProduceList ( i , components ) ;
66081: NOP4
66085: PPUSH
66086: NOP4
66090: PPUSH
66091: NOP4
// break ;
66095: GO 66099
// end ; end ;
66097: GO 66017
66099: POP
66100: POP
// end ; continue ;
66101: GO 65646
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66103: NOP4
66107: PPUSH
66108: LD_INT 1
66110: PPUSH
66111: NOP4
66115: PUSH
66116: LD_INT 100
66118: LESS
66119: PUSH
66120: NOP4
66124: PPUSH
66125: NOP4
66129: NOT
66130: AND
66131: IFFALSE 66160
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66133: NOP4
66137: PPUSH
66138: NOP4
66142: PUSH
66143: LD_INT 2
66145: ARRAY
66146: PPUSH
66147: NOP4
66151: PUSH
66152: LD_INT 3
66154: ARRAY
66155: PPUSH
66156: NOP4
// break ;
66160: GO 66164
// end ;
66162: GO 65646
66164: POP
66165: POP
// end ; end ;
66166: GO 64362
66168: POP
66169: POP
// end ;
66170: LD_VAR 0 1
66174: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66175: LD_INT 0
66177: PPUSH
66178: PPUSH
66179: PPUSH
66180: PPUSH
// if not mc_bases then
66181: NOP4
66185: NOT
66186: IFFALSE 66190
// exit ;
66188: GO 66351
// for i = 1 to mc_bases do
66190: NOP4
66194: PUSH
66195: DOUBLE
66196: LD_INT 1
66198: DEC
66199: ST_TO_ADDR
66200: NOP4
66204: PUSH
66205: FOR_TO
66206: IFFALSE 66349
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66208: NOP4
66212: PUSH
66213: NOP4
66217: PUSH
66218: NOP4
66222: ARRAY
66223: PUSH
66224: NOP4
66228: PUSH
66229: NOP4
66233: ARRAY
66234: UNION
66235: PPUSH
66236: LD_INT 33
66238: PUSH
66239: LD_INT 2
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PPUSH
66246: NOP4
66250: ST_TO_ADDR
// if tmp then
66251: NOP4
66255: IFFALSE 66347
// for j in tmp do
66257: NOP4
66261: PUSH
66262: NOP4
66266: PUSH
66267: FOR_IN
66268: IFFALSE 66345
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66270: NOP4
66274: PPUSH
66275: NOP4
66279: NOT
66280: PUSH
66281: NOP4
66285: PPUSH
66286: NOP4
66290: PUSH
66291: LD_INT 250
66293: GREATEREQUAL
66294: AND
66295: IFFALSE 66308
// Connect ( j ) else
66297: NOP4
66301: PPUSH
66302: NOP4
66306: GO 66343
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66308: NOP4
66312: PPUSH
66313: NOP4
66317: PUSH
66318: LD_INT 250
66320: LESS
66321: PUSH
66322: NOP4
66326: PPUSH
66327: NOP4
66331: AND
66332: IFFALSE 66343
// ComUnlink ( j ) ;
66334: NOP4
66338: PPUSH
66339: NOP4
66343: GO 66267
66345: POP
66346: POP
// end ;
66347: GO 66205
66349: POP
66350: POP
// end ;
66351: LD_VAR 0 1
66355: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66356: LD_INT 0
66358: PPUSH
66359: PPUSH
66360: PPUSH
66361: PPUSH
66362: PPUSH
// if not mc_bases then
66363: NOP4
66367: NOT
66368: IFFALSE 66372
// exit ;
66370: GO 66817
// for i = 1 to mc_bases do
66372: NOP4
66376: PUSH
66377: DOUBLE
66378: LD_INT 1
66380: DEC
66381: ST_TO_ADDR
66382: NOP4
66386: PUSH
66387: FOR_TO
66388: IFFALSE 66815
// begin if not mc_produce [ i ] then
66390: NOP4
66394: PUSH
66395: NOP4
66399: ARRAY
66400: NOT
66401: IFFALSE 66405
// continue ;
66403: GO 66387
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66405: NOP4
66409: PUSH
66410: NOP4
66414: PUSH
66415: NOP4
66419: ARRAY
66420: PPUSH
66421: LD_INT 30
66423: PUSH
66424: LD_INT 3
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PPUSH
66431: NOP4
66435: ST_TO_ADDR
// if not fac then
66436: NOP4
66440: NOT
66441: IFFALSE 66445
// continue ;
66443: GO 66387
// for j in fac do
66445: NOP4
66449: PUSH
66450: NOP4
66454: PUSH
66455: FOR_IN
66456: IFFALSE 66811
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66458: NOP4
66462: PPUSH
66463: NOP4
66467: PUSH
66468: LD_INT 2
66470: NONEQUAL
66471: PUSH
66472: NOP4
66476: PPUSH
66477: LD_INT 15
66479: PPUSH
66480: NOP4
66484: PUSH
66485: LD_INT 4
66487: ARRAY
66488: OR
66489: IFFALSE 66493
// continue ;
66491: GO 66455
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66493: NOP4
66497: PPUSH
66498: NOP4
66502: PUSH
66503: NOP4
66507: ARRAY
66508: PUSH
66509: LD_INT 1
66511: ARRAY
66512: PUSH
66513: LD_INT 1
66515: ARRAY
66516: PPUSH
66517: NOP4
66521: PUSH
66522: NOP4
66526: ARRAY
66527: PUSH
66528: LD_INT 1
66530: ARRAY
66531: PUSH
66532: LD_INT 2
66534: ARRAY
66535: PPUSH
66536: NOP4
66540: PUSH
66541: NOP4
66545: ARRAY
66546: PUSH
66547: LD_INT 1
66549: ARRAY
66550: PUSH
66551: LD_INT 3
66553: ARRAY
66554: PPUSH
66555: NOP4
66559: PUSH
66560: NOP4
66564: ARRAY
66565: PUSH
66566: LD_INT 1
66568: ARRAY
66569: PUSH
66570: LD_INT 4
66572: ARRAY
66573: PPUSH
66574: NOP4
66578: PUSH
66579: NOP4
66583: PPUSH
66584: NOP4
66588: PUSH
66589: NOP4
66593: ARRAY
66594: PUSH
66595: LD_INT 1
66597: ARRAY
66598: PUSH
66599: LD_INT 1
66601: ARRAY
66602: PUSH
66603: NOP4
66607: PUSH
66608: NOP4
66612: ARRAY
66613: PUSH
66614: LD_INT 1
66616: ARRAY
66617: PUSH
66618: LD_INT 2
66620: ARRAY
66621: PUSH
66622: NOP4
66626: PUSH
66627: NOP4
66631: ARRAY
66632: PUSH
66633: LD_INT 1
66635: ARRAY
66636: PUSH
66637: LD_INT 3
66639: ARRAY
66640: PUSH
66641: NOP4
66645: PUSH
66646: NOP4
66650: ARRAY
66651: PUSH
66652: LD_INT 1
66654: ARRAY
66655: PUSH
66656: LD_INT 4
66658: ARRAY
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: PPUSH
66666: NOP4
66670: AND
66671: IFFALSE 66809
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66673: NOP4
66677: PPUSH
66678: NOP4
66682: PUSH
66683: NOP4
66687: ARRAY
66688: PUSH
66689: LD_INT 1
66691: ARRAY
66692: PUSH
66693: LD_INT 1
66695: ARRAY
66696: PPUSH
66697: NOP4
66701: PUSH
66702: NOP4
66706: ARRAY
66707: PUSH
66708: LD_INT 1
66710: ARRAY
66711: PUSH
66712: LD_INT 2
66714: ARRAY
66715: PPUSH
66716: NOP4
66720: PUSH
66721: NOP4
66725: ARRAY
66726: PUSH
66727: LD_INT 1
66729: ARRAY
66730: PUSH
66731: LD_INT 3
66733: ARRAY
66734: PPUSH
66735: NOP4
66739: PUSH
66740: NOP4
66744: ARRAY
66745: PUSH
66746: LD_INT 1
66748: ARRAY
66749: PUSH
66750: LD_INT 4
66752: ARRAY
66753: PPUSH
66754: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66758: NOP4
66762: PUSH
66763: NOP4
66767: PUSH
66768: NOP4
66772: ARRAY
66773: PPUSH
66774: LD_INT 1
66776: PPUSH
66777: NOP4
66781: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66782: NOP4
66786: PUSH
66787: NOP4
66791: PPUSH
66792: NOP4
66796: PPUSH
66797: NOP4
66801: PPUSH
66802: NOP4
66806: ST_TO_ADDR
// break ;
66807: GO 66811
// end ; end ;
66809: GO 66455
66811: POP
66812: POP
// end ;
66813: GO 66387
66815: POP
66816: POP
// end ;
66817: LD_VAR 0 1
66821: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66822: LD_INT 0
66824: PPUSH
66825: PPUSH
66826: PPUSH
// if not mc_bases then
66827: NOP4
66831: NOT
66832: IFFALSE 66836
// exit ;
66834: GO 66925
// for i = 1 to mc_bases do
66836: NOP4
66840: PUSH
66841: DOUBLE
66842: LD_INT 1
66844: DEC
66845: ST_TO_ADDR
66846: NOP4
66850: PUSH
66851: FOR_TO
66852: IFFALSE 66923
// begin if mc_attack [ i ] then
66854: NOP4
66858: PUSH
66859: NOP4
66863: ARRAY
66864: IFFALSE 66921
// begin tmp := mc_attack [ i ] [ 1 ] ;
66866: NOP4
66870: PUSH
66871: NOP4
66875: PUSH
66876: NOP4
66880: ARRAY
66881: PUSH
66882: LD_INT 1
66884: ARRAY
66885: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66886: NOP4
66890: PUSH
66891: NOP4
66895: PPUSH
66896: NOP4
66900: PPUSH
66901: EMPTY
66902: PPUSH
66903: NOP4
66907: ST_TO_ADDR
// Attack ( tmp ) ;
66908: NOP4
66912: PPUSH
66913: NOP4
// exit ;
66917: POP
66918: POP
66919: GO 66925
// end ; end ;
66921: GO 66851
66923: POP
66924: POP
// end ;
66925: LD_VAR 0 1
66929: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66930: LD_INT 0
66932: PPUSH
66933: PPUSH
66934: PPUSH
66935: PPUSH
66936: PPUSH
66937: PPUSH
66938: PPUSH
// if not mc_bases then
66939: NOP4
66943: NOT
66944: IFFALSE 66948
// exit ;
66946: GO 67805
// for i = 1 to mc_bases do
66948: NOP4
66952: PUSH
66953: DOUBLE
66954: LD_INT 1
66956: DEC
66957: ST_TO_ADDR
66958: NOP4
66962: PUSH
66963: FOR_TO
66964: IFFALSE 67803
// begin if not mc_bases [ i ] then
66966: NOP4
66970: PUSH
66971: NOP4
66975: ARRAY
66976: NOT
66977: IFFALSE 66981
// continue ;
66979: GO 66963
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66981: NOP4
66985: PUSH
66986: NOP4
66990: PUSH
66991: NOP4
66995: ARRAY
66996: PUSH
66997: LD_INT 1
66999: ARRAY
67000: PPUSH
67001: NOP4
67005: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67006: NOP4
67010: PUSH
67011: NOP4
67015: PPUSH
67016: NOP4
67020: PPUSH
67021: NOP4
67025: PUSH
67026: NOP4
67030: ARRAY
67031: PUSH
67032: LD_INT 1
67034: ARRAY
67035: PPUSH
67036: NOP4
67040: PPUSH
67041: NOP4
67045: PUSH
67046: NOP4
67050: ARRAY
67051: PPUSH
67052: NOP4
67056: PPUSH
67057: NOP4
67061: ST_TO_ADDR
// if not mc_scan [ i ] then
67062: NOP4
67066: PUSH
67067: NOP4
67071: ARRAY
67072: NOT
67073: IFFALSE 67251
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67075: NOP4
67079: PUSH
67080: NOP4
67084: PPUSH
67085: NOP4
67089: PPUSH
67090: LD_INT 0
67092: PPUSH
67093: NOP4
67097: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67098: NOP4
67102: PUSH
67103: NOP4
67107: PUSH
67108: NOP4
67112: ARRAY
67113: PPUSH
67114: LD_INT 2
67116: PUSH
67117: LD_INT 25
67119: PUSH
67120: LD_INT 5
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: LD_INT 25
67129: PUSH
67130: LD_INT 8
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 25
67139: PUSH
67140: LD_INT 9
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: PPUSH
67153: NOP4
67157: ST_TO_ADDR
// if not tmp then
67158: NOP4
67162: NOT
67163: IFFALSE 67167
// continue ;
67165: GO 66963
// for j in tmp do
67167: NOP4
67171: PUSH
67172: NOP4
67176: PUSH
67177: FOR_IN
67178: IFFALSE 67249
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67180: NOP4
67184: PPUSH
67185: NOP4
67189: PPUSH
67190: NOP4
67194: PUSH
67195: LD_INT 5
67197: EQUAL
67198: PUSH
67199: NOP4
67203: PPUSH
67204: NOP4
67208: PUSH
67209: LD_INT 1
67211: EQUAL
67212: AND
67213: PUSH
67214: NOP4
67218: PPUSH
67219: NOP4
67223: NOT
67224: AND
67225: PUSH
67226: NOP4
67230: AND
67231: IFFALSE 67247
// ComChangeProfession ( j , class ) ;
67233: NOP4
67237: PPUSH
67238: NOP4
67242: PPUSH
67243: NOP4
67247: GO 67177
67249: POP
67250: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67251: NOP4
67255: PUSH
67256: NOP4
67260: ARRAY
67261: PUSH
67262: NOP4
67266: PUSH
67267: NOP4
67271: ARRAY
67272: NOT
67273: AND
67274: PUSH
67275: NOP4
67279: PUSH
67280: NOP4
67284: ARRAY
67285: NOT
67286: AND
67287: PUSH
67288: NOP4
67292: PUSH
67293: NOP4
67297: ARRAY
67298: PPUSH
67299: LD_INT 50
67301: PUSH
67302: EMPTY
67303: LIST
67304: PUSH
67305: LD_INT 2
67307: PUSH
67308: LD_INT 30
67310: PUSH
67311: LD_INT 32
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 30
67320: PUSH
67321: LD_INT 33
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 30
67330: PUSH
67331: LD_INT 4
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 30
67340: PUSH
67341: LD_INT 5
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PPUSH
67359: NOP4
67363: PUSH
67364: LD_INT 4
67366: LESS
67367: PUSH
67368: NOP4
67372: PUSH
67373: NOP4
67377: ARRAY
67378: PPUSH
67379: LD_INT 3
67381: PUSH
67382: LD_INT 24
67384: PUSH
67385: LD_INT 1000
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 2
67398: PUSH
67399: LD_INT 30
67401: PUSH
67402: LD_INT 0
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 30
67411: PUSH
67412: LD_INT 1
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: LIST
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PPUSH
67428: NOP4
67432: OR
67433: AND
67434: IFFALSE 67685
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67436: NOP4
67440: PUSH
67441: NOP4
67445: PPUSH
67446: NOP4
67450: PPUSH
67451: LD_INT 1
67453: PPUSH
67454: NOP4
67458: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67459: NOP4
67463: PUSH
67464: NOP4
67468: PUSH
67469: NOP4
67473: ARRAY
67474: PPUSH
67475: LD_INT 2
67477: PUSH
67478: LD_INT 25
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 25
67490: PUSH
67491: LD_INT 5
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 25
67500: PUSH
67501: LD_INT 8
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 25
67510: PUSH
67511: LD_INT 9
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: PPUSH
67525: NOP4
67529: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67530: NOP4
67534: PUSH
67535: NOP4
67539: PUSH
67540: NOP4
67544: PPUSH
67545: LD_INT 18
67547: PPUSH
67548: NOP4
67552: DIFF
67553: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67554: NOP4
67558: NOT
67559: PUSH
67560: NOP4
67564: PUSH
67565: NOP4
67569: ARRAY
67570: PPUSH
67571: LD_INT 2
67573: PUSH
67574: LD_INT 30
67576: PUSH
67577: LD_INT 4
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 30
67586: PUSH
67587: LD_INT 5
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: LIST
67598: PPUSH
67599: NOP4
67603: NOT
67604: AND
67605: IFFALSE 67667
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67607: NOP4
67611: PUSH
67612: NOP4
67616: PUSH
67617: NOP4
67621: ARRAY
67622: PPUSH
67623: LD_INT 2
67625: PUSH
67626: LD_INT 25
67628: PUSH
67629: LD_INT 2
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 25
67638: PUSH
67639: LD_INT 3
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 25
67648: PUSH
67649: LD_INT 4
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: PPUSH
67662: NOP4
67666: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67667: NOP4
67671: PPUSH
67672: NOP4
67676: PPUSH
67677: NOP4
// exit ;
67681: POP
67682: POP
67683: GO 67805
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67685: NOP4
67689: PUSH
67690: NOP4
67694: ARRAY
67695: PUSH
67696: NOP4
67700: PUSH
67701: NOP4
67705: ARRAY
67706: NOT
67707: AND
67708: PUSH
67709: NOP4
67713: PUSH
67714: NOP4
67718: ARRAY
67719: AND
67720: IFFALSE 67801
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67722: NOP4
67726: PUSH
67727: NOP4
67731: PPUSH
67732: NOP4
67736: PPUSH
67737: LD_INT 1
67739: PPUSH
67740: NOP4
67744: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67745: NOP4
67749: PUSH
67750: NOP4
67754: PUSH
67755: NOP4
67759: ARRAY
67760: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67761: NOP4
67765: PUSH
67766: NOP4
67770: PPUSH
67771: NOP4
67775: PPUSH
67776: EMPTY
67777: PPUSH
67778: NOP4
67782: ST_TO_ADDR
// Defend ( i , tmp ) ;
67783: NOP4
67787: PPUSH
67788: NOP4
67792: PPUSH
67793: NOP4
// exit ;
67797: POP
67798: POP
67799: GO 67805
// end ; end ;
67801: GO 66963
67803: POP
67804: POP
// end ;
67805: LD_VAR 0 1
67809: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67810: LD_INT 0
67812: PPUSH
67813: PPUSH
67814: PPUSH
67815: PPUSH
67816: PPUSH
67817: PPUSH
67818: PPUSH
67819: PPUSH
67820: PPUSH
67821: PPUSH
67822: PPUSH
// if not mc_bases then
67823: NOP4
67827: NOT
67828: IFFALSE 67832
// exit ;
67830: GO 68919
// for i = 1 to mc_bases do
67832: NOP4
67836: PUSH
67837: DOUBLE
67838: LD_INT 1
67840: DEC
67841: ST_TO_ADDR
67842: NOP4
67846: PUSH
67847: FOR_TO
67848: IFFALSE 68917
// begin tmp := mc_lab [ i ] ;
67850: NOP4
67854: PUSH
67855: NOP4
67859: PUSH
67860: NOP4
67864: ARRAY
67865: ST_TO_ADDR
// if not tmp then
67866: NOP4
67870: NOT
67871: IFFALSE 67875
// continue ;
67873: GO 67847
// idle_lab := 0 ;
67875: NOP4
67879: PUSH
67880: LD_INT 0
67882: ST_TO_ADDR
// for j in tmp do
67883: NOP4
67887: PUSH
67888: NOP4
67892: PUSH
67893: FOR_IN
67894: IFFALSE 68913
// begin researching := false ;
67896: NOP4
67900: PUSH
67901: LD_INT 0
67903: ST_TO_ADDR
// side := GetSide ( j ) ;
67904: NOP4
67908: PUSH
67909: NOP4
67913: PPUSH
67914: NOP4
67918: ST_TO_ADDR
// if not mc_tech [ side ] then
67919: NOP4
67923: PUSH
67924: NOP4
67928: ARRAY
67929: NOT
67930: IFFALSE 67934
// continue ;
67932: GO 67893
// if BuildingStatus ( j ) = bs_idle then
67934: NOP4
67938: PPUSH
67939: NOP4
67943: PUSH
67944: LD_INT 2
67946: EQUAL
67947: IFFALSE 68135
// begin if idle_lab and UnitsInside ( j ) < 6 then
67949: NOP4
67953: PUSH
67954: NOP4
67958: PPUSH
67959: NOP4
67963: PUSH
67964: LD_INT 6
67966: LESS
67967: AND
67968: IFFALSE 68039
// begin tmp2 := UnitsInside ( idle_lab ) ;
67970: NOP4
67974: PUSH
67975: NOP4
67979: PPUSH
67980: NOP4
67984: ST_TO_ADDR
// if tmp2 then
67985: NOP4
67989: IFFALSE 68031
// for x in tmp2 do
67991: NOP4
67995: PUSH
67996: NOP4
68000: PUSH
68001: FOR_IN
68002: IFFALSE 68029
// begin ComExitBuilding ( x ) ;
68004: NOP4
68008: PPUSH
68009: NOP4
// AddComEnterUnit ( x , j ) ;
68013: NOP4
68017: PPUSH
68018: NOP4
68022: PPUSH
68023: NOP4
// end ;
68027: GO 68001
68029: POP
68030: POP
// idle_lab := 0 ;
68031: NOP4
68035: PUSH
68036: LD_INT 0
68038: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68039: NOP4
68043: PUSH
68044: NOP4
68048: PUSH
68049: NOP4
68053: ARRAY
68054: PUSH
68055: FOR_IN
68056: IFFALSE 68116
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68058: NOP4
68062: PPUSH
68063: NOP4
68067: PPUSH
68068: NOP4
68072: PUSH
68073: NOP4
68077: PPUSH
68078: NOP4
68082: PPUSH
68083: NOP4
68087: AND
68088: IFFALSE 68114
// begin researching := true ;
68090: NOP4
68094: PUSH
68095: LD_INT 1
68097: ST_TO_ADDR
// ComResearch ( j , t ) ;
68098: NOP4
68102: PPUSH
68103: NOP4
68107: PPUSH
68108: NOP4
// break ;
68112: GO 68116
// end ;
68114: GO 68055
68116: POP
68117: POP
// if not researching then
68118: NOP4
68122: NOT
68123: IFFALSE 68135
// idle_lab := j ;
68125: NOP4
68129: PUSH
68130: NOP4
68134: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68135: NOP4
68139: PPUSH
68140: NOP4
68144: PUSH
68145: LD_INT 10
68147: EQUAL
68148: IFFALSE 68736
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68150: NOP4
68154: PUSH
68155: NOP4
68159: ARRAY
68160: NOT
68161: PUSH
68162: NOP4
68166: PUSH
68167: NOP4
68171: ARRAY
68172: NOT
68173: AND
68174: PUSH
68175: NOP4
68179: PUSH
68180: NOP4
68184: ARRAY
68185: PUSH
68186: LD_INT 1
68188: GREATER
68189: AND
68190: IFFALSE 68321
// begin ComCancel ( j ) ;
68192: NOP4
68196: PPUSH
68197: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68201: NOP4
68205: PUSH
68206: NOP4
68210: PPUSH
68211: NOP4
68215: PPUSH
68216: NOP4
68220: PUSH
68221: NOP4
68225: ARRAY
68226: PPUSH
68227: NOP4
68231: PUSH
68232: NOP4
68236: ARRAY
68237: PUSH
68238: LD_INT 1
68240: MINUS
68241: PPUSH
68242: NOP4
68246: PUSH
68247: NOP4
68251: ARRAY
68252: PPUSH
68253: LD_INT 0
68255: PPUSH
68256: NOP4
68260: PPUSH
68261: NOP4
68265: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68266: NOP4
68270: PUSH
68271: NOP4
68275: PPUSH
68276: NOP4
68280: PPUSH
68281: NOP4
68285: PUSH
68286: NOP4
68290: ARRAY
68291: PPUSH
68292: NOP4
68296: PUSH
68297: NOP4
68301: ARRAY
68302: PPUSH
68303: LD_INT 1
68305: PPUSH
68306: LD_INT 0
68308: PPUSH
68309: NOP4
68313: PPUSH
68314: NOP4
68318: ST_TO_ADDR
// continue ;
68319: GO 67893
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68321: NOP4
68325: PUSH
68326: NOP4
68330: ARRAY
68331: PUSH
68332: NOP4
68336: PUSH
68337: NOP4
68341: ARRAY
68342: NOT
68343: AND
68344: IFFALSE 68471
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68346: NOP4
68350: PUSH
68351: NOP4
68355: PPUSH
68356: NOP4
68360: PUSH
68361: NOP4
68365: PUSH
68366: NOP4
68370: ARRAY
68371: PUSH
68372: LD_INT 1
68374: PLUS
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PPUSH
68380: NOP4
68384: PUSH
68385: NOP4
68389: ARRAY
68390: PUSH
68391: LD_INT 1
68393: ARRAY
68394: PPUSH
68395: NOP4
68399: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68400: NOP4
68404: PUSH
68405: NOP4
68409: ARRAY
68410: PUSH
68411: LD_INT 1
68413: ARRAY
68414: PPUSH
68415: LD_INT 112
68417: PPUSH
68418: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68422: NOP4
68426: PUSH
68427: NOP4
68431: PUSH
68432: NOP4
68436: ARRAY
68437: PPUSH
68438: LD_INT 1
68440: PPUSH
68441: NOP4
68445: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68446: NOP4
68450: PUSH
68451: NOP4
68455: PPUSH
68456: NOP4
68460: PPUSH
68461: NOP4
68465: PPUSH
68466: NOP4
68470: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68471: NOP4
68475: PUSH
68476: NOP4
68480: ARRAY
68481: PUSH
68482: NOP4
68486: PUSH
68487: NOP4
68491: ARRAY
68492: AND
68493: PUSH
68494: NOP4
68498: PUSH
68499: NOP4
68503: ARRAY
68504: PUSH
68505: LD_INT 1
68507: ARRAY
68508: PPUSH
68509: NOP4
68513: NOT
68514: AND
68515: PUSH
68516: NOP4
68520: PPUSH
68521: NOP4
68525: PUSH
68526: LD_INT 6
68528: EQUAL
68529: AND
68530: IFFALSE 68586
// begin tmp2 := UnitsInside ( j ) ;
68532: NOP4
68536: PUSH
68537: NOP4
68541: PPUSH
68542: NOP4
68546: ST_TO_ADDR
// if tmp2 = 6 then
68547: NOP4
68551: PUSH
68552: LD_INT 6
68554: EQUAL
68555: IFFALSE 68586
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68557: NOP4
68561: PUSH
68562: LD_INT 1
68564: ARRAY
68565: PPUSH
68566: LD_INT 112
68568: PPUSH
68569: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68573: NOP4
68577: PUSH
68578: LD_INT 1
68580: ARRAY
68581: PPUSH
68582: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68586: NOP4
68590: PUSH
68591: NOP4
68595: ARRAY
68596: PUSH
68597: NOP4
68601: PUSH
68602: NOP4
68606: ARRAY
68607: PUSH
68608: LD_INT 1
68610: ARRAY
68611: PPUSH
68612: NOP4
68616: NOT
68617: AND
68618: PUSH
68619: NOP4
68623: PUSH
68624: NOP4
68628: ARRAY
68629: PUSH
68630: LD_INT 1
68632: ARRAY
68633: PPUSH
68634: NOP4
68638: NOT
68639: AND
68640: IFFALSE 68666
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68642: NOP4
68646: PUSH
68647: NOP4
68651: ARRAY
68652: PUSH
68653: LD_INT 1
68655: ARRAY
68656: PPUSH
68657: NOP4
68661: PPUSH
68662: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68666: NOP4
68670: PUSH
68671: NOP4
68675: ARRAY
68676: PUSH
68677: LD_INT 1
68679: ARRAY
68680: PPUSH
68681: NOP4
68685: PUSH
68686: NOP4
68690: PUSH
68691: NOP4
68695: ARRAY
68696: PUSH
68697: LD_INT 1
68699: ARRAY
68700: PPUSH
68701: NOP4
68705: PPUSH
68706: NOP4
68710: PUSH
68711: LD_INT 3
68713: NONEQUAL
68714: AND
68715: IFFALSE 68736
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68717: NOP4
68721: PUSH
68722: NOP4
68726: ARRAY
68727: PUSH
68728: LD_INT 1
68730: ARRAY
68731: PPUSH
68732: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68736: NOP4
68740: PPUSH
68741: NOP4
68745: PUSH
68746: LD_INT 6
68748: EQUAL
68749: PUSH
68750: NOP4
68754: PUSH
68755: LD_INT 1
68757: GREATER
68758: AND
68759: IFFALSE 68911
// begin sci := [ ] ;
68761: NOP4
68765: PUSH
68766: EMPTY
68767: ST_TO_ADDR
// for x in ( tmp diff j ) do
68768: NOP4
68772: PUSH
68773: NOP4
68777: PUSH
68778: NOP4
68782: DIFF
68783: PUSH
68784: FOR_IN
68785: IFFALSE 68837
// begin if sci = 6 then
68787: NOP4
68791: PUSH
68792: LD_INT 6
68794: EQUAL
68795: IFFALSE 68799
// break ;
68797: GO 68837
// if BuildingStatus ( x ) = bs_idle then
68799: NOP4
68803: PPUSH
68804: NOP4
68808: PUSH
68809: LD_INT 2
68811: EQUAL
68812: IFFALSE 68835
// sci := sci ^ UnitsInside ( x ) ;
68814: NOP4
68818: PUSH
68819: NOP4
68823: PUSH
68824: NOP4
68828: PPUSH
68829: NOP4
68833: ADD
68834: ST_TO_ADDR
// end ;
68835: GO 68784
68837: POP
68838: POP
// if not sci then
68839: NOP4
68843: NOT
68844: IFFALSE 68848
// continue ;
68846: GO 67893
// for x in sci do
68848: NOP4
68852: PUSH
68853: NOP4
68857: PUSH
68858: FOR_IN
68859: IFFALSE 68909
// if IsInUnit ( x ) and not HasTask ( x ) then
68861: NOP4
68865: PPUSH
68866: NOP4
68870: PUSH
68871: NOP4
68875: PPUSH
68876: NOP4
68880: NOT
68881: AND
68882: IFFALSE 68907
// begin ComExitBuilding ( x ) ;
68884: NOP4
68888: PPUSH
68889: NOP4
// AddComEnterUnit ( x , j ) ;
68893: NOP4
68897: PPUSH
68898: NOP4
68902: PPUSH
68903: NOP4
// end ;
68907: GO 68858
68909: POP
68910: POP
// end ; end ;
68911: GO 67893
68913: POP
68914: POP
// end ;
68915: GO 67847
68917: POP
68918: POP
// end ;
68919: LD_VAR 0 1
68923: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68924: LD_INT 0
68926: PPUSH
68927: PPUSH
// if not mc_bases then
68928: NOP4
68932: NOT
68933: IFFALSE 68937
// exit ;
68935: GO 69018
// for i = 1 to mc_bases do
68937: NOP4
68941: PUSH
68942: DOUBLE
68943: LD_INT 1
68945: DEC
68946: ST_TO_ADDR
68947: NOP4
68951: PUSH
68952: FOR_TO
68953: IFFALSE 69016
// if mc_mines [ i ] and mc_miners [ i ] then
68955: NOP4
68959: PUSH
68960: NOP4
68964: ARRAY
68965: PUSH
68966: NOP4
68970: PUSH
68971: NOP4
68975: ARRAY
68976: AND
68977: IFFALSE 69014
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68979: NOP4
68983: PUSH
68984: NOP4
68988: ARRAY
68989: PUSH
68990: LD_INT 1
68992: ARRAY
68993: PPUSH
68994: NOP4
68998: PPUSH
68999: NOP4
69003: PUSH
69004: NOP4
69008: ARRAY
69009: PPUSH
69010: NOP4
69014: GO 68952
69016: POP
69017: POP
// end ;
69018: LD_VAR 0 1
69022: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69023: LD_INT 0
69025: PPUSH
69026: PPUSH
69027: PPUSH
69028: PPUSH
69029: PPUSH
69030: PPUSH
69031: PPUSH
69032: PPUSH
// if not mc_bases or not mc_parking then
69033: NOP4
69037: NOT
69038: PUSH
69039: NOP4
69043: NOT
69044: OR
69045: IFFALSE 69049
// exit ;
69047: GO 69759
// for i = 1 to mc_bases do
69049: NOP4
69053: PUSH
69054: DOUBLE
69055: LD_INT 1
69057: DEC
69058: ST_TO_ADDR
69059: NOP4
69063: PUSH
69064: FOR_TO
69065: IFFALSE 69757
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69067: NOP4
69071: PUSH
69072: NOP4
69076: ARRAY
69077: NOT
69078: PUSH
69079: NOP4
69083: PUSH
69084: NOP4
69088: ARRAY
69089: NOT
69090: OR
69091: IFFALSE 69095
// continue ;
69093: GO 69064
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69095: NOP4
69099: PUSH
69100: NOP4
69104: PUSH
69105: NOP4
69109: ARRAY
69110: PUSH
69111: LD_INT 1
69113: ARRAY
69114: PPUSH
69115: NOP4
69119: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69120: NOP4
69124: PUSH
69125: NOP4
69129: PUSH
69130: NOP4
69134: ARRAY
69135: PPUSH
69136: LD_INT 30
69138: PUSH
69139: LD_INT 3
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PPUSH
69146: NOP4
69150: ST_TO_ADDR
// if not fac then
69151: NOP4
69155: NOT
69156: IFFALSE 69207
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69158: NOP4
69162: PUSH
69163: NOP4
69167: PUSH
69168: NOP4
69172: ARRAY
69173: PPUSH
69174: LD_INT 2
69176: PUSH
69177: LD_INT 30
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 30
69189: PUSH
69190: LD_INT 1
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: LIST
69201: PPUSH
69202: NOP4
69206: ST_TO_ADDR
// if not fac then
69207: NOP4
69211: NOT
69212: IFFALSE 69216
// continue ;
69214: GO 69064
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69216: NOP4
69220: PUSH
69221: NOP4
69225: PUSH
69226: NOP4
69230: ARRAY
69231: PPUSH
69232: LD_INT 22
69234: PUSH
69235: NOP4
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 21
69246: PUSH
69247: LD_INT 2
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 3
69256: PUSH
69257: LD_INT 24
69259: PUSH
69260: LD_INT 1000
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: LIST
69275: PPUSH
69276: NOP4
69280: ST_TO_ADDR
// for j in fac do
69281: NOP4
69285: PUSH
69286: NOP4
69290: PUSH
69291: FOR_IN
69292: IFFALSE 69373
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69294: NOP4
69298: PUSH
69299: NOP4
69303: PUSH
69304: LD_INT 22
69306: PUSH
69307: NOP4
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: LD_INT 91
69318: PUSH
69319: NOP4
69323: PUSH
69324: LD_INT 15
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 21
69334: PUSH
69335: LD_INT 2
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 3
69344: PUSH
69345: LD_INT 24
69347: PUSH
69348: LD_INT 1000
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: PPUSH
69365: NOP4
69369: UNION
69370: ST_TO_ADDR
69371: GO 69291
69373: POP
69374: POP
// if not vehs then
69375: NOP4
69379: NOT
69380: IFFALSE 69406
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69382: NOP4
69386: PUSH
69387: NOP4
69391: PPUSH
69392: NOP4
69396: PPUSH
69397: EMPTY
69398: PPUSH
69399: NOP4
69403: ST_TO_ADDR
// continue ;
69404: GO 69064
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69406: NOP4
69410: PUSH
69411: NOP4
69415: PUSH
69416: NOP4
69420: ARRAY
69421: PPUSH
69422: LD_INT 30
69424: PUSH
69425: LD_INT 3
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PPUSH
69432: NOP4
69436: ST_TO_ADDR
// if tmp then
69437: NOP4
69441: IFFALSE 69544
// begin for j in tmp do
69443: NOP4
69447: PUSH
69448: NOP4
69452: PUSH
69453: FOR_IN
69454: IFFALSE 69542
// for k in UnitsInside ( j ) do
69456: NOP4
69460: PUSH
69461: NOP4
69465: PPUSH
69466: NOP4
69470: PUSH
69471: FOR_IN
69472: IFFALSE 69538
// if k then
69474: NOP4
69478: IFFALSE 69536
// if not k in mc_repair_vehicle [ i ] then
69480: NOP4
69484: PUSH
69485: NOP4
69489: PUSH
69490: NOP4
69494: ARRAY
69495: IN
69496: NOT
69497: IFFALSE 69536
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69499: NOP4
69503: PUSH
69504: NOP4
69508: PPUSH
69509: NOP4
69513: PPUSH
69514: NOP4
69518: PUSH
69519: NOP4
69523: ARRAY
69524: PUSH
69525: NOP4
69529: UNION
69530: PPUSH
69531: NOP4
69535: ST_TO_ADDR
69536: GO 69471
69538: POP
69539: POP
69540: GO 69453
69542: POP
69543: POP
// end ; if not mc_repair_vehicle [ i ] then
69544: NOP4
69548: PUSH
69549: NOP4
69553: ARRAY
69554: NOT
69555: IFFALSE 69559
// continue ;
69557: GO 69064
// for j in mc_repair_vehicle [ i ] do
69559: NOP4
69563: PUSH
69564: NOP4
69568: PUSH
69569: NOP4
69573: ARRAY
69574: PUSH
69575: FOR_IN
69576: IFFALSE 69753
// begin if GetClass ( j ) <> 3 then
69578: NOP4
69582: PPUSH
69583: NOP4
69587: PUSH
69588: LD_INT 3
69590: NONEQUAL
69591: IFFALSE 69632
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69593: NOP4
69597: PUSH
69598: NOP4
69602: PPUSH
69603: NOP4
69607: PPUSH
69608: NOP4
69612: PUSH
69613: NOP4
69617: ARRAY
69618: PUSH
69619: NOP4
69623: DIFF
69624: PPUSH
69625: NOP4
69629: ST_TO_ADDR
// continue ;
69630: GO 69575
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69632: NOP4
69636: PPUSH
69637: NOP4
69641: NOT
69642: PUSH
69643: NOP4
69647: PUSH
69648: NOP4
69652: PUSH
69653: NOP4
69657: ARRAY
69658: PUSH
69659: LD_INT 1
69661: ARRAY
69662: IN
69663: NOT
69664: AND
69665: PUSH
69666: NOP4
69670: PUSH
69671: NOP4
69675: PUSH
69676: NOP4
69680: ARRAY
69681: PUSH
69682: LD_INT 2
69684: ARRAY
69685: IN
69686: NOT
69687: AND
69688: IFFALSE 69751
// begin if IsInUnit ( j ) then
69690: NOP4
69694: PPUSH
69695: NOP4
69699: IFFALSE 69712
// ComExitBuilding ( j ) else
69701: NOP4
69705: PPUSH
69706: NOP4
69710: GO 69751
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69712: NOP4
69716: PPUSH
69717: NOP4
69721: PUSH
69722: LD_INT 1
69724: ARRAY
69725: PPUSH
69726: NOP4
69730: NOT
69731: IFFALSE 69751
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69733: NOP4
69737: PPUSH
69738: NOP4
69742: PUSH
69743: LD_INT 1
69745: ARRAY
69746: PPUSH
69747: NOP4
// end ; end ;
69751: GO 69575
69753: POP
69754: POP
// end ;
69755: GO 69064
69757: POP
69758: POP
// end ;
69759: LD_VAR 0 1
69763: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69764: LD_INT 0
69766: PPUSH
69767: PPUSH
69768: PPUSH
69769: PPUSH
69770: PPUSH
69771: PPUSH
69772: PPUSH
69773: PPUSH
69774: PPUSH
69775: PPUSH
69776: PPUSH
// if not mc_bases then
69777: NOP4
69781: NOT
69782: IFFALSE 69786
// exit ;
69784: GO 70588
// for i = 1 to mc_bases do
69786: NOP4
69790: PUSH
69791: DOUBLE
69792: LD_INT 1
69794: DEC
69795: ST_TO_ADDR
69796: NOP4
69800: PUSH
69801: FOR_TO
69802: IFFALSE 70586
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69804: NOP4
69808: PUSH
69809: NOP4
69813: ARRAY
69814: NOT
69815: PUSH
69816: NOP4
69820: PUSH
69821: NOP4
69825: ARRAY
69826: PUSH
69827: LD_INT 1
69829: ARRAY
69830: OR
69831: PUSH
69832: NOP4
69836: PUSH
69837: NOP4
69841: ARRAY
69842: PUSH
69843: LD_INT 2
69845: ARRAY
69846: OR
69847: PUSH
69848: NOP4
69852: PUSH
69853: NOP4
69857: ARRAY
69858: PPUSH
69859: LD_INT 1
69861: PPUSH
69862: NOP4
69866: NOT
69867: OR
69868: PUSH
69869: NOP4
69873: PUSH
69874: NOP4
69878: ARRAY
69879: OR
69880: IFFALSE 69884
// continue ;
69882: GO 69801
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69884: NOP4
69888: PUSH
69889: NOP4
69893: PUSH
69894: NOP4
69898: ARRAY
69899: PPUSH
69900: LD_INT 25
69902: PUSH
69903: LD_INT 4
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 50
69912: PUSH
69913: EMPTY
69914: LIST
69915: PUSH
69916: LD_INT 3
69918: PUSH
69919: LD_INT 60
69921: PUSH
69922: EMPTY
69923: LIST
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: LIST
69933: PPUSH
69934: NOP4
69938: PUSH
69939: NOP4
69943: PUSH
69944: NOP4
69948: ARRAY
69949: DIFF
69950: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69951: NOP4
69955: PUSH
69956: NOP4
69960: PUSH
69961: NOP4
69965: ARRAY
69966: PPUSH
69967: LD_INT 2
69969: PUSH
69970: LD_INT 30
69972: PUSH
69973: LD_INT 0
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 30
69982: PUSH
69983: LD_INT 1
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: LIST
69994: PPUSH
69995: NOP4
69999: ST_TO_ADDR
// if not tmp or not dep then
70000: NOP4
70004: NOT
70005: PUSH
70006: NOP4
70010: NOT
70011: OR
70012: IFFALSE 70016
// continue ;
70014: GO 69801
// side := GetSide ( tmp [ 1 ] ) ;
70016: NOP4
70020: PUSH
70021: NOP4
70025: PUSH
70026: LD_INT 1
70028: ARRAY
70029: PPUSH
70030: NOP4
70034: ST_TO_ADDR
// dep := dep [ 1 ] ;
70035: NOP4
70039: PUSH
70040: NOP4
70044: PUSH
70045: LD_INT 1
70047: ARRAY
70048: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70049: NOP4
70053: PUSH
70054: NOP4
70058: PUSH
70059: NOP4
70063: ARRAY
70064: PPUSH
70065: LD_INT 22
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 25
70077: PUSH
70078: LD_INT 12
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PPUSH
70089: NOP4
70093: PUSH
70094: LD_INT 22
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 25
70106: PUSH
70107: LD_INT 12
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 91
70116: PUSH
70117: NOP4
70121: PUSH
70122: LD_INT 20
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: LIST
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: LIST
70134: PPUSH
70135: NOP4
70139: UNION
70140: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70141: NOP4
70145: PUSH
70146: NOP4
70150: PUSH
70151: NOP4
70155: ARRAY
70156: PPUSH
70157: LD_INT 81
70159: PUSH
70160: NOP4
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PPUSH
70169: NOP4
70173: ST_TO_ADDR
// if not apes or danger_at_area then
70174: NOP4
70178: NOT
70179: PUSH
70180: NOP4
70184: OR
70185: IFFALSE 70235
// begin if mc_taming [ i ] then
70187: NOP4
70191: PUSH
70192: NOP4
70196: ARRAY
70197: IFFALSE 70233
// begin MC_Reset ( i , 121 ) ;
70199: NOP4
70203: PPUSH
70204: LD_INT 121
70206: PPUSH
70207: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70211: NOP4
70215: PUSH
70216: NOP4
70220: PPUSH
70221: NOP4
70225: PPUSH
70226: EMPTY
70227: PPUSH
70228: NOP4
70232: ST_TO_ADDR
// end ; continue ;
70233: GO 69801
// end ; for j in tmp do
70235: NOP4
70239: PUSH
70240: NOP4
70244: PUSH
70245: FOR_IN
70246: IFFALSE 70582
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70248: NOP4
70252: PUSH
70253: NOP4
70257: PUSH
70258: NOP4
70262: ARRAY
70263: IN
70264: NOT
70265: PUSH
70266: NOP4
70270: PUSH
70271: NOP4
70275: ARRAY
70276: PUSH
70277: LD_INT 3
70279: LESS
70280: AND
70281: IFFALSE 70339
// begin SetTag ( j , 121 ) ;
70283: NOP4
70287: PPUSH
70288: LD_INT 121
70290: PPUSH
70291: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70295: NOP4
70299: PUSH
70300: NOP4
70304: PPUSH
70305: NOP4
70309: PUSH
70310: NOP4
70314: PUSH
70315: NOP4
70319: ARRAY
70320: PUSH
70321: LD_INT 1
70323: PLUS
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PPUSH
70329: NOP4
70333: PPUSH
70334: NOP4
70338: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70339: NOP4
70343: PUSH
70344: NOP4
70348: PUSH
70349: NOP4
70353: ARRAY
70354: IN
70355: IFFALSE 70580
// begin if GetClass ( j ) <> 4 then
70357: NOP4
70361: PPUSH
70362: NOP4
70366: PUSH
70367: LD_INT 4
70369: NONEQUAL
70370: IFFALSE 70423
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70372: NOP4
70376: PUSH
70377: NOP4
70381: PPUSH
70382: NOP4
70386: PPUSH
70387: NOP4
70391: PUSH
70392: NOP4
70396: ARRAY
70397: PUSH
70398: NOP4
70402: DIFF
70403: PPUSH
70404: NOP4
70408: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70409: NOP4
70413: PPUSH
70414: LD_INT 0
70416: PPUSH
70417: NOP4
// continue ;
70421: GO 70245
// end ; if IsInUnit ( j ) then
70423: NOP4
70427: PPUSH
70428: NOP4
70432: IFFALSE 70443
// ComExitBuilding ( j ) ;
70434: NOP4
70438: PPUSH
70439: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
70443: NOP4
70447: PUSH
70448: NOP4
70452: PPUSH
70453: NOP4
70457: PPUSH
70458: NOP4
70462: ST_TO_ADDR
// if not ape then
70463: NOP4
70467: NOT
70468: IFFALSE 70472
// break ;
70470: GO 70582
// x := GetX ( ape ) ;
70472: NOP4
70476: PUSH
70477: NOP4
70481: PPUSH
70482: NOP4
70486: ST_TO_ADDR
// y := GetY ( ape ) ;
70487: NOP4
70491: PUSH
70492: NOP4
70496: PPUSH
70497: NOP4
70501: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70502: NOP4
70506: PPUSH
70507: NOP4
70511: PPUSH
70512: NOP4
70516: NOT
70517: PUSH
70518: NOP4
70522: PPUSH
70523: NOP4
70527: PPUSH
70528: NOP4
70532: PPUSH
70533: LD_INT 20
70535: PPUSH
70536: NOP4
70540: PUSH
70541: LD_INT 4
70543: ARRAY
70544: OR
70545: IFFALSE 70549
// break ;
70547: GO 70582
// if not HasTask ( j ) then
70549: NOP4
70553: PPUSH
70554: NOP4
70558: NOT
70559: IFFALSE 70580
// ComTameXY ( j , x , y ) ;
70561: NOP4
70565: PPUSH
70566: NOP4
70570: PPUSH
70571: NOP4
70575: PPUSH
70576: NOP4
// end ; end ;
70580: GO 70245
70582: POP
70583: POP
// end ;
70584: GO 69801
70586: POP
70587: POP
// end ;
70588: LD_VAR 0 1
70592: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70593: LD_INT 0
70595: PPUSH
70596: PPUSH
70597: PPUSH
70598: PPUSH
70599: PPUSH
70600: PPUSH
70601: PPUSH
70602: PPUSH
// if not mc_bases then
70603: NOP4
70607: NOT
70608: IFFALSE 70612
// exit ;
70610: GO 71238
// for i = 1 to mc_bases do
70612: NOP4
70616: PUSH
70617: DOUBLE
70618: LD_INT 1
70620: DEC
70621: ST_TO_ADDR
70622: NOP4
70626: PUSH
70627: FOR_TO
70628: IFFALSE 71236
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70630: NOP4
70634: PUSH
70635: NOP4
70639: ARRAY
70640: NOT
70641: PUSH
70642: NOP4
70646: PUSH
70647: NOP4
70651: ARRAY
70652: PPUSH
70653: LD_INT 25
70655: PUSH
70656: LD_INT 12
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PPUSH
70663: NOP4
70667: NOT
70668: OR
70669: IFFALSE 70673
// continue ;
70671: GO 70627
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70673: NOP4
70677: PUSH
70678: NOP4
70682: PUSH
70683: NOP4
70687: ARRAY
70688: PUSH
70689: LD_INT 1
70691: ARRAY
70692: PPUSH
70693: NOP4
70697: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70698: NOP4
70702: PPUSH
70703: LD_INT 2
70705: PPUSH
70706: NOP4
70710: IFFALSE 70963
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70712: NOP4
70716: PUSH
70717: NOP4
70721: PUSH
70722: NOP4
70726: ARRAY
70727: PPUSH
70728: LD_INT 25
70730: PUSH
70731: LD_INT 16
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PPUSH
70738: NOP4
70742: ST_TO_ADDR
// if tmp < 6 then
70743: NOP4
70747: PUSH
70748: LD_INT 6
70750: LESS
70751: IFFALSE 70963
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70753: NOP4
70757: PUSH
70758: NOP4
70762: PUSH
70763: NOP4
70767: ARRAY
70768: PPUSH
70769: LD_INT 2
70771: PUSH
70772: LD_INT 30
70774: PUSH
70775: LD_INT 0
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 30
70784: PUSH
70785: LD_INT 1
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: LIST
70796: PPUSH
70797: NOP4
70801: ST_TO_ADDR
// if depot then
70802: NOP4
70806: IFFALSE 70963
// begin selected := 0 ;
70808: NOP4
70812: PUSH
70813: LD_INT 0
70815: ST_TO_ADDR
// for j in depot do
70816: NOP4
70820: PUSH
70821: NOP4
70825: PUSH
70826: FOR_IN
70827: IFFALSE 70858
// begin if UnitsInside ( j ) < 6 then
70829: NOP4
70833: PPUSH
70834: NOP4
70838: PUSH
70839: LD_INT 6
70841: LESS
70842: IFFALSE 70856
// begin selected := j ;
70844: NOP4
70848: PUSH
70849: NOP4
70853: ST_TO_ADDR
// break ;
70854: GO 70858
// end ; end ;
70856: GO 70826
70858: POP
70859: POP
// if selected then
70860: NOP4
70864: IFFALSE 70963
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70866: NOP4
70870: PUSH
70871: NOP4
70875: PUSH
70876: NOP4
70880: ARRAY
70881: PPUSH
70882: LD_INT 25
70884: PUSH
70885: LD_INT 12
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PPUSH
70892: NOP4
70896: PUSH
70897: FOR_IN
70898: IFFALSE 70961
// if not HasTask ( j ) then
70900: NOP4
70904: PPUSH
70905: NOP4
70909: NOT
70910: IFFALSE 70959
// begin if not IsInUnit ( j ) then
70912: NOP4
70916: PPUSH
70917: NOP4
70921: NOT
70922: IFFALSE 70938
// ComEnterUnit ( j , selected ) ;
70924: NOP4
70928: PPUSH
70929: NOP4
70933: PPUSH
70934: NOP4
// AddComChangeProfession ( j , 16 ) ;
70938: NOP4
70942: PPUSH
70943: LD_INT 16
70945: PPUSH
70946: NOP4
// AddComExitBuilding ( j ) ;
70950: NOP4
70954: PPUSH
70955: NOP4
// end ;
70959: GO 70897
70961: POP
70962: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70963: NOP4
70967: PPUSH
70968: LD_INT 11
70970: PPUSH
70971: NOP4
70975: IFFALSE 71234
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70977: NOP4
70981: PUSH
70982: NOP4
70986: PUSH
70987: NOP4
70991: ARRAY
70992: PPUSH
70993: LD_INT 25
70995: PUSH
70996: LD_INT 16
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PPUSH
71003: NOP4
71007: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71008: NOP4
71012: PUSH
71013: LD_INT 6
71015: GREATEREQUAL
71016: PUSH
71017: NOP4
71021: PPUSH
71022: LD_INT 2
71024: PPUSH
71025: NOP4
71029: NOT
71030: OR
71031: IFFALSE 71234
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71033: NOP4
71037: PUSH
71038: NOP4
71042: PUSH
71043: NOP4
71047: ARRAY
71048: PPUSH
71049: LD_INT 2
71051: PUSH
71052: LD_INT 30
71054: PUSH
71055: LD_INT 4
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 30
71064: PUSH
71065: LD_INT 5
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: PPUSH
71077: NOP4
71081: ST_TO_ADDR
// if barracks then
71082: NOP4
71086: IFFALSE 71234
// begin selected := 0 ;
71088: NOP4
71092: PUSH
71093: LD_INT 0
71095: ST_TO_ADDR
// for j in barracks do
71096: NOP4
71100: PUSH
71101: NOP4
71105: PUSH
71106: FOR_IN
71107: IFFALSE 71138
// begin if UnitsInside ( j ) < 6 then
71109: NOP4
71113: PPUSH
71114: NOP4
71118: PUSH
71119: LD_INT 6
71121: LESS
71122: IFFALSE 71136
// begin selected := j ;
71124: NOP4
71128: PUSH
71129: NOP4
71133: ST_TO_ADDR
// break ;
71134: GO 71138
// end ; end ;
71136: GO 71106
71138: POP
71139: POP
// if selected then
71140: NOP4
71144: IFFALSE 71234
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71146: NOP4
71150: PUSH
71151: NOP4
71155: PUSH
71156: NOP4
71160: ARRAY
71161: PPUSH
71162: LD_INT 25
71164: PUSH
71165: LD_INT 12
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PPUSH
71172: NOP4
71176: PUSH
71177: FOR_IN
71178: IFFALSE 71232
// if not IsInUnit ( j ) and not HasTask ( j ) then
71180: NOP4
71184: PPUSH
71185: NOP4
71189: NOT
71190: PUSH
71191: NOP4
71195: PPUSH
71196: NOP4
71200: NOT
71201: AND
71202: IFFALSE 71230
// begin ComEnterUnit ( j , selected ) ;
71204: NOP4
71208: PPUSH
71209: NOP4
71213: PPUSH
71214: NOP4
// AddComChangeProfession ( j , 15 ) ;
71218: NOP4
71222: PPUSH
71223: LD_INT 15
71225: PPUSH
71226: NOP4
// end ;
71230: GO 71177
71232: POP
71233: POP
// end ; end ; end ; end ; end ;
71234: GO 70627
71236: POP
71237: POP
// end ;
71238: LD_VAR 0 1
71242: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71243: LD_INT 0
71245: PPUSH
71246: PPUSH
71247: PPUSH
71248: PPUSH
// if not mc_bases then
71249: NOP4
71253: NOT
71254: IFFALSE 71258
// exit ;
71256: GO 71436
// for i = 1 to mc_bases do
71258: NOP4
71262: PUSH
71263: DOUBLE
71264: LD_INT 1
71266: DEC
71267: ST_TO_ADDR
71268: NOP4
71272: PUSH
71273: FOR_TO
71274: IFFALSE 71434
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71276: NOP4
71280: PUSH
71281: NOP4
71285: PUSH
71286: NOP4
71290: ARRAY
71291: PPUSH
71292: LD_INT 25
71294: PUSH
71295: LD_INT 9
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: NOP4
71306: ST_TO_ADDR
// if not tmp then
71307: NOP4
71311: NOT
71312: IFFALSE 71316
// continue ;
71314: GO 71273
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71316: NOP4
71320: PUSH
71321: NOP4
71325: ARRAY
71326: PPUSH
71327: LD_INT 29
71329: PPUSH
71330: NOP4
71334: NOT
71335: PUSH
71336: NOP4
71340: PUSH
71341: NOP4
71345: ARRAY
71346: PPUSH
71347: LD_INT 28
71349: PPUSH
71350: NOP4
71354: NOT
71355: AND
71356: IFFALSE 71360
// continue ;
71358: GO 71273
// for j in tmp do
71360: NOP4
71364: PUSH
71365: NOP4
71369: PUSH
71370: FOR_IN
71371: IFFALSE 71430
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71373: NOP4
71377: PUSH
71378: NOP4
71382: PUSH
71383: NOP4
71387: ARRAY
71388: PUSH
71389: LD_INT 1
71391: ARRAY
71392: IN
71393: NOT
71394: PUSH
71395: NOP4
71399: PUSH
71400: NOP4
71404: PUSH
71405: NOP4
71409: ARRAY
71410: PUSH
71411: LD_INT 2
71413: ARRAY
71414: IN
71415: NOT
71416: AND
71417: IFFALSE 71428
// ComSpaceTimeShoot ( j ) ;
71419: NOP4
71423: PPUSH
71424: NOP4
71428: GO 71370
71430: POP
71431: POP
// end ;
71432: GO 71273
71434: POP
71435: POP
// end ;
71436: LD_VAR 0 1
71440: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71441: LD_INT 0
71443: PPUSH
71444: PPUSH
71445: PPUSH
71446: PPUSH
71447: PPUSH
71448: PPUSH
71449: PPUSH
71450: PPUSH
71451: PPUSH
// if not mc_bases then
71452: NOP4
71456: NOT
71457: IFFALSE 71461
// exit ;
71459: GO 72083
// for i = 1 to mc_bases do
71461: NOP4
71465: PUSH
71466: DOUBLE
71467: LD_INT 1
71469: DEC
71470: ST_TO_ADDR
71471: NOP4
71475: PUSH
71476: FOR_TO
71477: IFFALSE 72081
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71479: NOP4
71483: PUSH
71484: NOP4
71488: ARRAY
71489: NOT
71490: PUSH
71491: LD_INT 38
71493: PPUSH
71494: NOP4
71498: PUSH
71499: NOP4
71503: ARRAY
71504: PPUSH
71505: NOP4
71509: PUSH
71510: LD_INT 2
71512: NONEQUAL
71513: OR
71514: IFFALSE 71518
// continue ;
71516: GO 71476
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71518: NOP4
71522: PUSH
71523: NOP4
71527: PUSH
71528: NOP4
71532: ARRAY
71533: PPUSH
71534: LD_INT 30
71536: PUSH
71537: LD_INT 34
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: PPUSH
71544: NOP4
71548: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71549: NOP4
71553: PUSH
71554: NOP4
71558: PUSH
71559: NOP4
71563: ARRAY
71564: PPUSH
71565: LD_INT 25
71567: PUSH
71568: LD_INT 4
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PPUSH
71575: NOP4
71579: PPUSH
71580: LD_INT 0
71582: PPUSH
71583: NOP4
71587: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71588: NOP4
71592: NOT
71593: PUSH
71594: NOP4
71598: NOT
71599: OR
71600: PUSH
71601: NOP4
71605: PUSH
71606: NOP4
71610: ARRAY
71611: PPUSH
71612: LD_INT 124
71614: PPUSH
71615: NOP4
71619: OR
71620: IFFALSE 71624
// continue ;
71622: GO 71476
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71624: NOP4
71628: PUSH
71629: NOP4
71633: ARRAY
71634: PUSH
71635: NOP4
71639: PUSH
71640: NOP4
71644: ARRAY
71645: LESS
71646: PUSH
71647: NOP4
71651: PUSH
71652: NOP4
71656: ARRAY
71657: PUSH
71658: NOP4
71662: LESS
71663: AND
71664: IFFALSE 72079
// begin tmp := sci [ 1 ] ;
71666: NOP4
71670: PUSH
71671: NOP4
71675: PUSH
71676: LD_INT 1
71678: ARRAY
71679: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71680: NOP4
71684: PPUSH
71685: LD_INT 124
71687: PPUSH
71688: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71692: NOP4
71696: PUSH
71697: DOUBLE
71698: NOP4
71702: PUSH
71703: NOP4
71707: ARRAY
71708: INC
71709: ST_TO_ADDR
71710: NOP4
71714: PUSH
71715: NOP4
71719: ARRAY
71720: PUSH
71721: FOR_DOWNTO
71722: IFFALSE 72065
// begin if IsInUnit ( tmp ) then
71724: NOP4
71728: PPUSH
71729: NOP4
71733: IFFALSE 71744
// ComExitBuilding ( tmp ) ;
71735: NOP4
71739: PPUSH
71740: NOP4
// repeat wait ( 0 0$1 ) ;
71744: LD_INT 35
71746: PPUSH
71747: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71751: NOP4
71755: PPUSH
71756: NOP4
71760: NOT
71761: PUSH
71762: NOP4
71766: PPUSH
71767: NOP4
71771: NOT
71772: AND
71773: IFFALSE 71744
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71775: NOP4
71779: PUSH
71780: NOP4
71784: PPUSH
71785: NOP4
71789: PUSH
71790: NOP4
71794: PPUSH
71795: NOP4
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71804: LD_INT 35
71806: PPUSH
71807: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71811: NOP4
71815: PUSH
71816: NOP4
71820: PUSH
71821: NOP4
71825: ARRAY
71826: PUSH
71827: NOP4
71831: ARRAY
71832: PUSH
71833: LD_INT 1
71835: ARRAY
71836: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71837: NOP4
71841: PUSH
71842: NOP4
71846: PUSH
71847: NOP4
71851: ARRAY
71852: PUSH
71853: NOP4
71857: ARRAY
71858: PUSH
71859: LD_INT 2
71861: ARRAY
71862: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71863: NOP4
71867: PPUSH
71868: LD_INT 10
71870: PPUSH
71871: NOP4
71875: PUSH
71876: LD_INT 4
71878: ARRAY
71879: IFFALSE 71917
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71881: NOP4
71885: PPUSH
71886: NOP4
71890: PUSH
71891: LD_INT 1
71893: ARRAY
71894: PPUSH
71895: NOP4
71899: PUSH
71900: LD_INT 2
71902: ARRAY
71903: PPUSH
71904: NOP4
// wait ( 0 0$10 ) ;
71908: LD_INT 350
71910: PPUSH
71911: NOP4
// end else
71915: GO 71943
// begin ComMoveXY ( tmp , x , y ) ;
71917: NOP4
71921: PPUSH
71922: NOP4
71926: PPUSH
71927: NOP4
71931: PPUSH
71932: NOP4
// wait ( 0 0$3 ) ;
71936: LD_INT 105
71938: PPUSH
71939: NOP4
// end ; until IsAt ( tmp , x , y ) ;
71943: NOP4
71947: PPUSH
71948: NOP4
71952: PPUSH
71953: NOP4
71957: PPUSH
71958: NOP4
71962: IFFALSE 71804
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71964: NOP4
71968: PPUSH
71969: NOP4
71973: PPUSH
71974: NOP4
71978: PPUSH
71979: NOP4
71983: PUSH
71984: NOP4
71988: ARRAY
71989: PPUSH
71990: NOP4
// repeat wait ( 0 0$1 ) ;
71994: LD_INT 35
71996: PPUSH
71997: NOP4
// until not HasTask ( tmp ) ;
72001: NOP4
72005: PPUSH
72006: NOP4
72010: NOT
72011: IFFALSE 71994
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72013: NOP4
72017: PUSH
72018: NOP4
72022: PPUSH
72023: NOP4
72027: PUSH
72028: NOP4
72032: PUSH
72033: NOP4
72037: ARRAY
72038: PUSH
72039: LD_INT 1
72041: PLUS
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PPUSH
72047: NOP4
72051: PUSH
72052: NOP4
72056: ARRAY
72057: PPUSH
72058: NOP4
72062: ST_TO_ADDR
// end ;
72063: GO 71721
72065: POP
72066: POP
// MC_Reset ( i , 124 ) ;
72067: NOP4
72071: PPUSH
72072: LD_INT 124
72074: PPUSH
72075: NOP4
// end ; end ;
72079: GO 71476
72081: POP
72082: POP
// end ;
72083: LD_VAR 0 1
72087: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72088: LD_INT 0
72090: PPUSH
72091: PPUSH
72092: PPUSH
// if not mc_bases then
72093: NOP4
72097: NOT
72098: IFFALSE 72102
// exit ;
72100: GO 72708
// for i = 1 to mc_bases do
72102: NOP4
72106: PUSH
72107: DOUBLE
72108: LD_INT 1
72110: DEC
72111: ST_TO_ADDR
72112: NOP4
72116: PUSH
72117: FOR_TO
72118: IFFALSE 72706
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72120: NOP4
72124: PUSH
72125: NOP4
72129: PUSH
72130: NOP4
72134: ARRAY
72135: PPUSH
72136: LD_INT 25
72138: PUSH
72139: LD_INT 4
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: PPUSH
72146: NOP4
72150: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72151: NOP4
72155: NOT
72156: PUSH
72157: NOP4
72161: PUSH
72162: NOP4
72166: ARRAY
72167: NOT
72168: OR
72169: PUSH
72170: NOP4
72174: PUSH
72175: NOP4
72179: ARRAY
72180: PPUSH
72181: LD_INT 2
72183: PUSH
72184: LD_INT 30
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 30
72196: PUSH
72197: LD_INT 1
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: LIST
72208: PPUSH
72209: NOP4
72213: NOT
72214: OR
72215: IFFALSE 72265
// begin if mc_deposits_finder [ i ] then
72217: NOP4
72221: PUSH
72222: NOP4
72226: ARRAY
72227: IFFALSE 72263
// begin MC_Reset ( i , 125 ) ;
72229: NOP4
72233: PPUSH
72234: LD_INT 125
72236: PPUSH
72237: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72241: NOP4
72245: PUSH
72246: NOP4
72250: PPUSH
72251: NOP4
72255: PPUSH
72256: EMPTY
72257: PPUSH
72258: NOP4
72262: ST_TO_ADDR
// end ; continue ;
72263: GO 72117
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72265: NOP4
72269: PUSH
72270: NOP4
72274: ARRAY
72275: PUSH
72276: LD_INT 1
72278: ARRAY
72279: PUSH
72280: LD_INT 3
72282: ARRAY
72283: PUSH
72284: LD_INT 1
72286: EQUAL
72287: PUSH
72288: LD_INT 20
72290: PPUSH
72291: NOP4
72295: PUSH
72296: NOP4
72300: ARRAY
72301: PPUSH
72302: NOP4
72306: PUSH
72307: LD_INT 2
72309: NONEQUAL
72310: AND
72311: IFFALSE 72361
// begin if mc_deposits_finder [ i ] then
72313: NOP4
72317: PUSH
72318: NOP4
72322: ARRAY
72323: IFFALSE 72359
// begin MC_Reset ( i , 125 ) ;
72325: NOP4
72329: PPUSH
72330: LD_INT 125
72332: PPUSH
72333: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72337: NOP4
72341: PUSH
72342: NOP4
72346: PPUSH
72347: NOP4
72351: PPUSH
72352: EMPTY
72353: PPUSH
72354: NOP4
72358: ST_TO_ADDR
// end ; continue ;
72359: GO 72117
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72361: NOP4
72365: PUSH
72366: NOP4
72370: ARRAY
72371: PUSH
72372: LD_INT 1
72374: ARRAY
72375: PUSH
72376: LD_INT 1
72378: ARRAY
72379: PPUSH
72380: NOP4
72384: PUSH
72385: NOP4
72389: ARRAY
72390: PUSH
72391: LD_INT 1
72393: ARRAY
72394: PUSH
72395: LD_INT 2
72397: ARRAY
72398: PPUSH
72399: NOP4
72403: PUSH
72404: NOP4
72408: ARRAY
72409: PPUSH
72410: NOP4
72414: IFFALSE 72457
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72416: NOP4
72420: PUSH
72421: NOP4
72425: PPUSH
72426: NOP4
72430: PPUSH
72431: NOP4
72435: PUSH
72436: NOP4
72440: ARRAY
72441: PPUSH
72442: LD_INT 1
72444: PPUSH
72445: NOP4
72449: PPUSH
72450: NOP4
72454: ST_TO_ADDR
72455: GO 72704
// begin if not mc_deposits_finder [ i ] then
72457: NOP4
72461: PUSH
72462: NOP4
72466: ARRAY
72467: NOT
72468: IFFALSE 72520
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72470: NOP4
72474: PUSH
72475: NOP4
72479: PPUSH
72480: NOP4
72484: PPUSH
72485: NOP4
72489: PUSH
72490: LD_INT 1
72492: ARRAY
72493: PUSH
72494: EMPTY
72495: LIST
72496: PPUSH
72497: NOP4
72501: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72502: NOP4
72506: PUSH
72507: LD_INT 1
72509: ARRAY
72510: PPUSH
72511: LD_INT 125
72513: PPUSH
72514: NOP4
// end else
72518: GO 72704
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72520: NOP4
72524: PUSH
72525: NOP4
72529: ARRAY
72530: PUSH
72531: LD_INT 1
72533: ARRAY
72534: PPUSH
72535: NOP4
72539: IFFALSE 72562
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72541: NOP4
72545: PUSH
72546: NOP4
72550: ARRAY
72551: PUSH
72552: LD_INT 1
72554: ARRAY
72555: PPUSH
72556: NOP4
72560: GO 72704
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72562: NOP4
72566: PUSH
72567: NOP4
72571: ARRAY
72572: PUSH
72573: LD_INT 1
72575: ARRAY
72576: PPUSH
72577: NOP4
72581: NOT
72582: PUSH
72583: NOP4
72587: PUSH
72588: NOP4
72592: ARRAY
72593: PUSH
72594: LD_INT 1
72596: ARRAY
72597: PPUSH
72598: NOP4
72602: PUSH
72603: NOP4
72607: ARRAY
72608: PUSH
72609: LD_INT 1
72611: ARRAY
72612: PUSH
72613: LD_INT 1
72615: ARRAY
72616: PPUSH
72617: NOP4
72621: PUSH
72622: NOP4
72626: ARRAY
72627: PUSH
72628: LD_INT 1
72630: ARRAY
72631: PUSH
72632: LD_INT 2
72634: ARRAY
72635: PPUSH
72636: NOP4
72640: PUSH
72641: LD_INT 6
72643: GREATER
72644: AND
72645: IFFALSE 72704
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72647: NOP4
72651: PUSH
72652: NOP4
72656: ARRAY
72657: PUSH
72658: LD_INT 1
72660: ARRAY
72661: PPUSH
72662: NOP4
72666: PUSH
72667: NOP4
72671: ARRAY
72672: PUSH
72673: LD_INT 1
72675: ARRAY
72676: PUSH
72677: LD_INT 1
72679: ARRAY
72680: PPUSH
72681: NOP4
72685: PUSH
72686: NOP4
72690: ARRAY
72691: PUSH
72692: LD_INT 1
72694: ARRAY
72695: PUSH
72696: LD_INT 2
72698: ARRAY
72699: PPUSH
72700: NOP4
// end ; end ; end ;
72704: GO 72117
72706: POP
72707: POP
// end ;
72708: LD_VAR 0 1
72712: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72713: LD_INT 0
72715: PPUSH
72716: PPUSH
72717: PPUSH
72718: PPUSH
72719: PPUSH
72720: PPUSH
72721: PPUSH
72722: PPUSH
72723: PPUSH
72724: PPUSH
72725: PPUSH
// if not mc_bases then
72726: NOP4
72730: NOT
72731: IFFALSE 72735
// exit ;
72733: GO 73675
// for i = 1 to mc_bases do
72735: NOP4
72739: PUSH
72740: DOUBLE
72741: LD_INT 1
72743: DEC
72744: ST_TO_ADDR
72745: NOP4
72749: PUSH
72750: FOR_TO
72751: IFFALSE 73673
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72753: NOP4
72757: PUSH
72758: NOP4
72762: ARRAY
72763: NOT
72764: PUSH
72765: NOP4
72769: PUSH
72770: NOP4
72774: ARRAY
72775: OR
72776: IFFALSE 72780
// continue ;
72778: GO 72750
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72780: NOP4
72784: PUSH
72785: NOP4
72789: PUSH
72790: NOP4
72794: ARRAY
72795: PUSH
72796: LD_INT 1
72798: ARRAY
72799: PPUSH
72800: NOP4
72804: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72805: NOP4
72809: PUSH
72810: LD_INT 3
72812: EQUAL
72813: PUSH
72814: NOP4
72818: PUSH
72819: NOP4
72823: ARRAY
72824: PUSH
72825: NOP4
72829: PUSH
72830: NOP4
72834: ARRAY
72835: UNION
72836: PPUSH
72837: LD_INT 33
72839: PUSH
72840: LD_INT 2
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PPUSH
72847: NOP4
72851: NOT
72852: OR
72853: IFFALSE 72857
// continue ;
72855: GO 72750
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72857: NOP4
72861: PUSH
72862: NOP4
72866: PUSH
72867: NOP4
72871: ARRAY
72872: PPUSH
72873: LD_INT 30
72875: PUSH
72876: LD_INT 36
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PPUSH
72883: NOP4
72887: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72888: NOP4
72892: PUSH
72893: NOP4
72897: PUSH
72898: NOP4
72902: ARRAY
72903: PPUSH
72904: LD_INT 34
72906: PUSH
72907: LD_INT 31
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PPUSH
72914: NOP4
72918: ST_TO_ADDR
// if not cts and not mcts then
72919: NOP4
72923: NOT
72924: PUSH
72925: NOP4
72929: NOT
72930: AND
72931: IFFALSE 72935
// continue ;
72933: GO 72750
// x := cts ;
72935: NOP4
72939: PUSH
72940: NOP4
72944: ST_TO_ADDR
// if not x then
72945: NOP4
72949: NOT
72950: IFFALSE 72962
// x := mcts ;
72952: NOP4
72956: PUSH
72957: NOP4
72961: ST_TO_ADDR
// if not x then
72962: NOP4
72966: NOT
72967: IFFALSE 72971
// continue ;
72969: GO 72750
// if mc_remote_driver [ i ] then
72971: NOP4
72975: PUSH
72976: NOP4
72980: ARRAY
72981: IFFALSE 73368
// for j in mc_remote_driver [ i ] do
72983: NOP4
72987: PUSH
72988: NOP4
72992: PUSH
72993: NOP4
72997: ARRAY
72998: PUSH
72999: FOR_IN
73000: IFFALSE 73366
// begin if GetClass ( j ) <> 3 then
73002: NOP4
73006: PPUSH
73007: NOP4
73011: PUSH
73012: LD_INT 3
73014: NONEQUAL
73015: IFFALSE 73068
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73017: NOP4
73021: PUSH
73022: NOP4
73026: PPUSH
73027: NOP4
73031: PPUSH
73032: NOP4
73036: PUSH
73037: NOP4
73041: ARRAY
73042: PUSH
73043: NOP4
73047: DIFF
73048: PPUSH
73049: NOP4
73053: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73054: NOP4
73058: PPUSH
73059: LD_INT 0
73061: PPUSH
73062: NOP4
// continue ;
73066: GO 72999
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73068: NOP4
73072: PUSH
73073: NOP4
73077: ARRAY
73078: PPUSH
73079: LD_INT 34
73081: PUSH
73082: LD_INT 31
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 58
73091: PUSH
73092: EMPTY
73093: LIST
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PPUSH
73099: NOP4
73103: PUSH
73104: NOP4
73108: PPUSH
73109: NOP4
73113: NOT
73114: AND
73115: IFFALSE 73186
// begin if IsInUnit ( j ) then
73117: NOP4
73121: PPUSH
73122: NOP4
73126: IFFALSE 73137
// ComExitBuilding ( j ) ;
73128: NOP4
73132: PPUSH
73133: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73137: NOP4
73141: PPUSH
73142: NOP4
73146: PUSH
73147: NOP4
73151: ARRAY
73152: PPUSH
73153: LD_INT 34
73155: PUSH
73156: LD_INT 31
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 58
73165: PUSH
73166: EMPTY
73167: LIST
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PPUSH
73173: NOP4
73177: PUSH
73178: LD_INT 1
73180: ARRAY
73181: PPUSH
73182: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73186: NOP4
73190: PPUSH
73191: NOP4
73195: NOT
73196: PUSH
73197: NOP4
73201: PPUSH
73202: NOP4
73206: PPUSH
73207: NOP4
73211: PUSH
73212: LD_INT 36
73214: NONEQUAL
73215: PUSH
73216: NOP4
73220: PPUSH
73221: NOP4
73225: NOT
73226: AND
73227: OR
73228: IFFALSE 73364
// begin if IsInUnit ( j ) then
73230: NOP4
73234: PPUSH
73235: NOP4
73239: IFFALSE 73250
// ComExitBuilding ( j ) ;
73241: NOP4
73245: PPUSH
73246: NOP4
// ct := 0 ;
73250: NOP4
73254: PUSH
73255: LD_INT 0
73257: ST_TO_ADDR
// for k in x do
73258: NOP4
73262: PUSH
73263: NOP4
73267: PUSH
73268: FOR_IN
73269: IFFALSE 73342
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73271: NOP4
73275: PPUSH
73276: NOP4
73280: PUSH
73281: LD_INT 31
73283: EQUAL
73284: PUSH
73285: NOP4
73289: PPUSH
73290: NOP4
73294: NOT
73295: AND
73296: PUSH
73297: NOP4
73301: PPUSH
73302: NOP4
73306: PUSH
73307: LD_INT 36
73309: EQUAL
73310: PUSH
73311: NOP4
73315: PPUSH
73316: NOP4
73320: PUSH
73321: LD_INT 3
73323: LESS
73324: AND
73325: OR
73326: IFFALSE 73340
// begin ct := k ;
73328: NOP4
73332: PUSH
73333: NOP4
73337: ST_TO_ADDR
// break ;
73338: GO 73342
// end ;
73340: GO 73268
73342: POP
73343: POP
// if ct then
73344: NOP4
73348: IFFALSE 73364
// ComEnterUnit ( j , ct ) ;
73350: NOP4
73354: PPUSH
73355: NOP4
73359: PPUSH
73360: NOP4
// end ; end ;
73364: GO 72999
73366: POP
73367: POP
// places := 0 ;
73368: NOP4
73372: PUSH
73373: LD_INT 0
73375: ST_TO_ADDR
// for j = 1 to x do
73376: NOP4
73380: PUSH
73381: DOUBLE
73382: LD_INT 1
73384: DEC
73385: ST_TO_ADDR
73386: NOP4
73390: PUSH
73391: FOR_TO
73392: IFFALSE 73468
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73394: NOP4
73398: PUSH
73399: NOP4
73403: ARRAY
73404: PPUSH
73405: NOP4
73409: PUSH
73410: LD_INT 31
73412: EQUAL
73413: IFFALSE 73431
// places := places + 1 else
73415: NOP4
73419: PUSH
73420: NOP4
73424: PUSH
73425: LD_INT 1
73427: PLUS
73428: ST_TO_ADDR
73429: GO 73466
// if GetBType ( x [ j ] ) = b_control_tower then
73431: NOP4
73435: PUSH
73436: NOP4
73440: ARRAY
73441: PPUSH
73442: NOP4
73446: PUSH
73447: LD_INT 36
73449: EQUAL
73450: IFFALSE 73466
// places := places + 3 ;
73452: NOP4
73456: PUSH
73457: NOP4
73461: PUSH
73462: LD_INT 3
73464: PLUS
73465: ST_TO_ADDR
73466: GO 73391
73468: POP
73469: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73470: NOP4
73474: PUSH
73475: LD_INT 0
73477: EQUAL
73478: PUSH
73479: NOP4
73483: PUSH
73484: NOP4
73488: PUSH
73489: NOP4
73493: ARRAY
73494: LESSEQUAL
73495: OR
73496: IFFALSE 73500
// continue ;
73498: GO 72750
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73500: NOP4
73504: PUSH
73505: NOP4
73509: PUSH
73510: NOP4
73514: ARRAY
73515: PPUSH
73516: LD_INT 25
73518: PUSH
73519: LD_INT 3
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PPUSH
73526: NOP4
73530: PUSH
73531: NOP4
73535: PUSH
73536: NOP4
73540: ARRAY
73541: DIFF
73542: PPUSH
73543: LD_INT 3
73545: PPUSH
73546: NOP4
73550: ST_TO_ADDR
// for j in tmp do
73551: NOP4
73555: PUSH
73556: NOP4
73560: PUSH
73561: FOR_IN
73562: IFFALSE 73597
// if GetTag ( j ) > 0 then
73564: NOP4
73568: PPUSH
73569: NOP4
73573: PUSH
73574: LD_INT 0
73576: GREATER
73577: IFFALSE 73595
// tmp := tmp diff j ;
73579: NOP4
73583: PUSH
73584: NOP4
73588: PUSH
73589: NOP4
73593: DIFF
73594: ST_TO_ADDR
73595: GO 73561
73597: POP
73598: POP
// if not tmp then
73599: NOP4
73603: NOT
73604: IFFALSE 73608
// continue ;
73606: GO 72750
// if places then
73608: NOP4
73612: IFFALSE 73671
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73614: NOP4
73618: PUSH
73619: NOP4
73623: PPUSH
73624: NOP4
73628: PPUSH
73629: NOP4
73633: PUSH
73634: NOP4
73638: ARRAY
73639: PUSH
73640: NOP4
73644: PUSH
73645: LD_INT 1
73647: ARRAY
73648: UNION
73649: PPUSH
73650: NOP4
73654: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73655: NOP4
73659: PUSH
73660: LD_INT 1
73662: ARRAY
73663: PPUSH
73664: LD_INT 126
73666: PPUSH
73667: NOP4
// end ; end ;
73671: GO 72750
73673: POP
73674: POP
// end ;
73675: LD_VAR 0 1
73679: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73680: LD_INT 0
73682: PPUSH
73683: PPUSH
73684: PPUSH
73685: PPUSH
73686: PPUSH
73687: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73688: NOP4
73692: NOT
73693: PUSH
73694: NOP4
73698: NOT
73699: OR
73700: PUSH
73701: NOP4
73705: NOT
73706: OR
73707: PUSH
73708: NOP4
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: LD_INT 2
73718: PUSH
73719: LD_INT 3
73721: PUSH
73722: LD_INT 4
73724: PUSH
73725: LD_INT 5
73727: PUSH
73728: LD_INT 8
73730: PUSH
73731: LD_INT 9
73733: PUSH
73734: LD_INT 15
73736: PUSH
73737: LD_INT 16
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: IN
73751: NOT
73752: OR
73753: IFFALSE 73757
// exit ;
73755: GO 74657
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73757: NOP4
73761: PUSH
73762: NOP4
73766: PPUSH
73767: LD_INT 21
73769: PUSH
73770: LD_INT 3
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 24
73779: PUSH
73780: LD_INT 250
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PPUSH
73791: NOP4
73795: ST_TO_ADDR
// case class of 1 , 15 :
73796: NOP4
73800: PUSH
73801: LD_INT 1
73803: DOUBLE
73804: EQUAL
73805: IFTRUE 73815
73807: LD_INT 15
73809: DOUBLE
73810: EQUAL
73811: IFTRUE 73815
73813: GO 73900
73815: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73816: NOP4
73820: PUSH
73821: NOP4
73825: PPUSH
73826: LD_INT 2
73828: PUSH
73829: LD_INT 30
73831: PUSH
73832: LD_INT 32
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 30
73841: PUSH
73842: LD_INT 31
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: LIST
73853: PPUSH
73854: NOP4
73858: PUSH
73859: NOP4
73863: PPUSH
73864: LD_INT 2
73866: PUSH
73867: LD_INT 30
73869: PUSH
73870: LD_INT 4
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 30
73879: PUSH
73880: LD_INT 5
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: LIST
73891: PPUSH
73892: NOP4
73896: ADD
73897: ST_TO_ADDR
73898: GO 74146
73900: LD_INT 2
73902: DOUBLE
73903: EQUAL
73904: IFTRUE 73914
73906: LD_INT 16
73908: DOUBLE
73909: EQUAL
73910: IFTRUE 73914
73912: GO 73960
73914: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73915: NOP4
73919: PUSH
73920: NOP4
73924: PPUSH
73925: LD_INT 2
73927: PUSH
73928: LD_INT 30
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 30
73940: PUSH
73941: LD_INT 1
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: LIST
73952: PPUSH
73953: NOP4
73957: ST_TO_ADDR
73958: GO 74146
73960: LD_INT 3
73962: DOUBLE
73963: EQUAL
73964: IFTRUE 73968
73966: GO 74014
73968: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73969: NOP4
73973: PUSH
73974: NOP4
73978: PPUSH
73979: LD_INT 2
73981: PUSH
73982: LD_INT 30
73984: PUSH
73985: LD_INT 2
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: LD_INT 30
73994: PUSH
73995: LD_INT 3
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: LIST
74006: PPUSH
74007: NOP4
74011: ST_TO_ADDR
74012: GO 74146
74014: LD_INT 4
74016: DOUBLE
74017: EQUAL
74018: IFTRUE 74022
74020: GO 74079
74022: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74023: NOP4
74027: PUSH
74028: NOP4
74032: PPUSH
74033: LD_INT 2
74035: PUSH
74036: LD_INT 30
74038: PUSH
74039: LD_INT 6
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 30
74048: PUSH
74049: LD_INT 7
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 30
74058: PUSH
74059: LD_INT 8
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: PPUSH
74072: NOP4
74076: ST_TO_ADDR
74077: GO 74146
74079: LD_INT 5
74081: DOUBLE
74082: EQUAL
74083: IFTRUE 74099
74085: LD_INT 8
74087: DOUBLE
74088: EQUAL
74089: IFTRUE 74099
74091: LD_INT 9
74093: DOUBLE
74094: EQUAL
74095: IFTRUE 74099
74097: GO 74145
74099: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74100: NOP4
74104: PUSH
74105: NOP4
74109: PPUSH
74110: LD_INT 2
74112: PUSH
74113: LD_INT 30
74115: PUSH
74116: LD_INT 4
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 30
74125: PUSH
74126: LD_INT 5
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: LIST
74137: PPUSH
74138: NOP4
74142: ST_TO_ADDR
74143: GO 74146
74145: POP
// if not tmp then
74146: NOP4
74150: NOT
74151: IFFALSE 74155
// exit ;
74153: GO 74657
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74155: NOP4
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 15
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: IN
74170: PUSH
74171: NOP4
74175: PUSH
74176: NOP4
74180: ARRAY
74181: AND
74182: IFFALSE 74338
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74184: NOP4
74188: PUSH
74189: NOP4
74193: PUSH
74194: NOP4
74198: ARRAY
74199: PUSH
74200: LD_INT 1
74202: ARRAY
74203: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74204: NOP4
74208: PUSH
74209: NOP4
74213: PUSH
74214: NOP4
74218: ARRAY
74219: IN
74220: NOT
74221: IFFALSE 74336
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74223: NOP4
74227: PUSH
74228: NOP4
74232: PPUSH
74233: NOP4
74237: PUSH
74238: NOP4
74242: PUSH
74243: NOP4
74247: ARRAY
74248: PUSH
74249: LD_INT 1
74251: PLUS
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PPUSH
74257: NOP4
74261: PPUSH
74262: NOP4
74266: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74267: NOP4
74271: PUSH
74272: NOP4
74276: PPUSH
74277: NOP4
74281: PPUSH
74282: NOP4
74286: PUSH
74287: NOP4
74291: ARRAY
74292: PUSH
74293: NOP4
74297: DIFF
74298: PPUSH
74299: NOP4
74303: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74304: NOP4
74308: PPUSH
74309: NOP4
74313: PUSH
74314: NOP4
74318: ARRAY
74319: PUSH
74320: NOP4
74324: PUSH
74325: NOP4
74329: ARRAY
74330: ARRAY
74331: PPUSH
74332: NOP4
// end ; exit ;
74336: GO 74657
// end ; if tmp > 1 then
74338: NOP4
74342: PUSH
74343: LD_INT 1
74345: GREATER
74346: IFFALSE 74450
// for i = 2 to tmp do
74348: NOP4
74352: PUSH
74353: DOUBLE
74354: LD_INT 2
74356: DEC
74357: ST_TO_ADDR
74358: NOP4
74362: PUSH
74363: FOR_TO
74364: IFFALSE 74448
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74366: NOP4
74370: PUSH
74371: NOP4
74375: ARRAY
74376: PPUSH
74377: NOP4
74381: PUSH
74382: LD_INT 6
74384: EQUAL
74385: IFFALSE 74446
// begin x := tmp [ i ] ;
74387: NOP4
74391: PUSH
74392: NOP4
74396: PUSH
74397: NOP4
74401: ARRAY
74402: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74403: NOP4
74407: PUSH
74408: NOP4
74412: PPUSH
74413: NOP4
74417: PPUSH
74418: NOP4
74422: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74423: NOP4
74427: PUSH
74428: NOP4
74432: PPUSH
74433: LD_INT 1
74435: PPUSH
74436: NOP4
74440: PPUSH
74441: NOP4
74445: ST_TO_ADDR
// end ;
74446: GO 74363
74448: POP
74449: POP
// for i in tmp do
74450: NOP4
74454: PUSH
74455: NOP4
74459: PUSH
74460: FOR_IN
74461: IFFALSE 74530
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74463: NOP4
74467: PPUSH
74468: NOP4
74472: PUSH
74473: LD_INT 6
74475: LESS
74476: PUSH
74477: NOP4
74481: PPUSH
74482: NOP4
74486: PUSH
74487: LD_INT 31
74489: PUSH
74490: LD_INT 32
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: IN
74497: NOT
74498: AND
74499: PUSH
74500: NOP4
74504: PPUSH
74505: NOP4
74509: PUSH
74510: LD_INT 0
74512: EQUAL
74513: OR
74514: IFFALSE 74528
// begin j := i ;
74516: NOP4
74520: PUSH
74521: NOP4
74525: ST_TO_ADDR
// break ;
74526: GO 74530
// end ; end ;
74528: GO 74460
74530: POP
74531: POP
// if j then
74532: NOP4
74536: IFFALSE 74554
// ComEnterUnit ( unit , j ) else
74538: NOP4
74542: PPUSH
74543: NOP4
74547: PPUSH
74548: NOP4
74552: GO 74657
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74554: NOP4
74558: PUSH
74559: NOP4
74563: PPUSH
74564: LD_INT 2
74566: PUSH
74567: LD_INT 30
74569: PUSH
74570: LD_INT 0
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 30
74579: PUSH
74580: LD_INT 1
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: PPUSH
74592: NOP4
74596: ST_TO_ADDR
// if depot then
74597: NOP4
74601: IFFALSE 74657
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74603: NOP4
74607: PUSH
74608: NOP4
74612: PPUSH
74613: NOP4
74617: PPUSH
74618: NOP4
74622: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74623: NOP4
74627: PPUSH
74628: NOP4
74632: PPUSH
74633: NOP4
74637: PUSH
74638: LD_INT 10
74640: GREATER
74641: IFFALSE 74657
// ComStandNearbyBuilding ( unit , depot ) ;
74643: NOP4
74647: PPUSH
74648: NOP4
74652: PPUSH
74653: NOP4
// end ; end ; end ;
74657: LD_VAR 0 5
74661: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74662: LD_INT 0
74664: PPUSH
74665: PPUSH
74666: PPUSH
74667: PPUSH
// if not mc_bases then
74668: NOP4
74672: NOT
74673: IFFALSE 74677
// exit ;
74675: GO 74916
// for i = 1 to mc_bases do
74677: NOP4
74681: PUSH
74682: DOUBLE
74683: LD_INT 1
74685: DEC
74686: ST_TO_ADDR
74687: NOP4
74691: PUSH
74692: FOR_TO
74693: IFFALSE 74914
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74695: NOP4
74699: PUSH
74700: NOP4
74704: PUSH
74705: NOP4
74709: ARRAY
74710: PPUSH
74711: LD_INT 21
74713: PUSH
74714: LD_INT 1
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PPUSH
74721: NOP4
74725: PUSH
74726: NOP4
74730: PUSH
74731: NOP4
74735: ARRAY
74736: UNION
74737: ST_TO_ADDR
// if not tmp then
74738: NOP4
74742: NOT
74743: IFFALSE 74747
// continue ;
74745: GO 74692
// for j in tmp do
74747: NOP4
74751: PUSH
74752: NOP4
74756: PUSH
74757: FOR_IN
74758: IFFALSE 74910
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74760: NOP4
74764: PPUSH
74765: NOP4
74769: NOT
74770: PUSH
74771: NOP4
74775: PPUSH
74776: NOP4
74780: NOT
74781: AND
74782: PUSH
74783: NOP4
74787: PPUSH
74788: NOP4
74792: NOT
74793: AND
74794: PUSH
74795: NOP4
74799: PPUSH
74800: NOP4
74804: NOT
74805: AND
74806: PUSH
74807: NOP4
74811: PUSH
74812: NOP4
74816: PUSH
74817: NOP4
74821: ARRAY
74822: PUSH
74823: LD_INT 1
74825: ARRAY
74826: IN
74827: NOT
74828: AND
74829: PUSH
74830: NOP4
74834: PUSH
74835: NOP4
74839: PUSH
74840: NOP4
74844: ARRAY
74845: PUSH
74846: LD_INT 2
74848: ARRAY
74849: IN
74850: NOT
74851: AND
74852: PUSH
74853: NOP4
74857: PUSH
74858: NOP4
74862: PUSH
74863: NOP4
74867: ARRAY
74868: IN
74869: NOT
74870: AND
74871: IFFALSE 74908
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74873: NOP4
74877: PPUSH
74878: NOP4
74882: PUSH
74883: NOP4
74887: ARRAY
74888: PPUSH
74889: NOP4
74893: PPUSH
74894: NOP4
74898: PPUSH
74899: NOP4
74903: PPUSH
74904: NOP4
// end ;
74908: GO 74757
74910: POP
74911: POP
// end ;
74912: GO 74692
74914: POP
74915: POP
// end ;
74916: LD_VAR 0 1
74920: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74921: LD_INT 0
74923: PPUSH
74924: PPUSH
74925: PPUSH
74926: PPUSH
74927: PPUSH
74928: PPUSH
// if not mc_bases [ base ] then
74929: NOP4
74933: PUSH
74934: NOP4
74938: ARRAY
74939: NOT
74940: IFFALSE 74944
// exit ;
74942: GO 75126
// tmp := [ ] ;
74944: NOP4
74948: PUSH
74949: EMPTY
74950: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74951: NOP4
74955: PUSH
74956: NOP4
74960: PPUSH
74961: LD_INT 0
74963: PPUSH
74964: NOP4
74968: ST_TO_ADDR
// if not list then
74969: NOP4
74973: NOT
74974: IFFALSE 74978
// exit ;
74976: GO 75126
// for i = 1 to amount do
74978: NOP4
74982: PUSH
74983: DOUBLE
74984: LD_INT 1
74986: DEC
74987: ST_TO_ADDR
74988: NOP4
74992: PUSH
74993: FOR_TO
74994: IFFALSE 75074
// begin x := rand ( 1 , list [ 1 ] ) ;
74996: NOP4
75000: PUSH
75001: LD_INT 1
75003: PPUSH
75004: NOP4
75008: PUSH
75009: LD_INT 1
75011: ARRAY
75012: PPUSH
75013: NOP4
75017: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75018: NOP4
75022: PUSH
75023: NOP4
75027: PPUSH
75028: NOP4
75032: PPUSH
75033: NOP4
75037: PUSH
75038: LD_INT 1
75040: ARRAY
75041: PUSH
75042: NOP4
75046: ARRAY
75047: PUSH
75048: NOP4
75052: PUSH
75053: LD_INT 2
75055: ARRAY
75056: PUSH
75057: NOP4
75061: ARRAY
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PPUSH
75067: NOP4
75071: ST_TO_ADDR
// end ;
75072: GO 74993
75074: POP
75075: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75076: NOP4
75080: PUSH
75081: NOP4
75085: PPUSH
75086: NOP4
75090: PPUSH
75091: NOP4
75095: PPUSH
75096: NOP4
75100: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75101: NOP4
75105: PUSH
75106: NOP4
75110: PPUSH
75111: NOP4
75115: PPUSH
75116: NOP4
75120: PPUSH
75121: NOP4
75125: ST_TO_ADDR
// end ;
75126: LD_VAR 0 4
75130: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75131: LD_INT 0
75133: PPUSH
// if not mc_bases [ base ] then
75134: NOP4
75138: PUSH
75139: NOP4
75143: ARRAY
75144: NOT
75145: IFFALSE 75149
// exit ;
75147: GO 75174
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75149: NOP4
75153: PUSH
75154: NOP4
75158: PPUSH
75159: NOP4
75163: PPUSH
75164: NOP4
75168: PPUSH
75169: NOP4
75173: ST_TO_ADDR
// end ;
75174: LD_VAR 0 3
75178: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75179: LD_INT 0
75181: PPUSH
// if not mc_bases [ base ] then
75182: NOP4
75186: PUSH
75187: NOP4
75191: ARRAY
75192: NOT
75193: IFFALSE 75197
// exit ;
75195: GO 75234
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75197: NOP4
75201: PUSH
75202: NOP4
75206: PPUSH
75207: NOP4
75211: PPUSH
75212: NOP4
75216: PUSH
75217: NOP4
75221: ARRAY
75222: PUSH
75223: NOP4
75227: UNION
75228: PPUSH
75229: NOP4
75233: ST_TO_ADDR
// end ;
75234: LD_VAR 0 3
75238: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75239: LD_INT 0
75241: PPUSH
// if not mc_bases [ base ] then
75242: NOP4
75246: PUSH
75247: NOP4
75251: ARRAY
75252: NOT
75253: IFFALSE 75257
// exit ;
75255: GO 75282
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75257: NOP4
75261: PUSH
75262: NOP4
75266: PPUSH
75267: NOP4
75271: PPUSH
75272: NOP4
75276: PPUSH
75277: NOP4
75281: ST_TO_ADDR
// end ;
75282: LD_VAR 0 3
75286: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75287: LD_INT 0
75289: PPUSH
// if not mc_bases [ base ] then
75290: NOP4
75294: PUSH
75295: NOP4
75299: ARRAY
75300: NOT
75301: IFFALSE 75305
// exit ;
75303: GO 75342
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75305: NOP4
75309: PUSH
75310: NOP4
75314: PPUSH
75315: NOP4
75319: PPUSH
75320: NOP4
75324: PUSH
75325: NOP4
75329: ARRAY
75330: PUSH
75331: NOP4
75335: ADD
75336: PPUSH
75337: NOP4
75341: ST_TO_ADDR
// end ;
75342: LD_VAR 0 3
75346: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75347: LD_INT 0
75349: PPUSH
// if not mc_bases [ base ] then
75350: NOP4
75354: PUSH
75355: NOP4
75359: ARRAY
75360: NOT
75361: IFFALSE 75365
// exit ;
75363: GO 75419
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75365: NOP4
75369: PUSH
75370: NOP4
75374: PPUSH
75375: NOP4
75379: PPUSH
75380: NOP4
75384: PPUSH
75385: NOP4
75389: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75390: NOP4
75394: PUSH
75395: NOP4
75399: PPUSH
75400: NOP4
75404: PPUSH
75405: NOP4
75409: PUSH
75410: LD_INT 0
75412: PLUS
75413: PPUSH
75414: NOP4
75418: ST_TO_ADDR
// end ;
75419: LD_VAR 0 3
75423: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75424: LD_INT 0
75426: PPUSH
// if not mc_bases [ base ] then
75427: NOP4
75431: PUSH
75432: NOP4
75436: ARRAY
75437: NOT
75438: IFFALSE 75442
// exit ;
75440: GO 75467
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75442: NOP4
75446: PUSH
75447: NOP4
75451: PPUSH
75452: NOP4
75456: PPUSH
75457: NOP4
75461: PPUSH
75462: NOP4
75466: ST_TO_ADDR
// end ;
75467: LD_VAR 0 3
75471: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75472: LD_INT 0
75474: PPUSH
75475: PPUSH
75476: PPUSH
75477: PPUSH
// if not mc_bases [ base ] then
75478: NOP4
75482: PUSH
75483: NOP4
75487: ARRAY
75488: NOT
75489: IFFALSE 75493
// exit ;
75491: GO 75558
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75493: NOP4
75497: PUSH
75498: NOP4
75502: PPUSH
75503: NOP4
75507: PUSH
75508: NOP4
75512: PUSH
75513: NOP4
75517: ARRAY
75518: PUSH
75519: LD_INT 1
75521: PLUS
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PPUSH
75527: NOP4
75531: PUSH
75532: NOP4
75536: PUSH
75537: NOP4
75541: PUSH
75542: NOP4
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: PPUSH
75553: NOP4
75557: ST_TO_ADDR
// end ;
75558: LD_VAR 0 5
75562: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75563: LD_INT 0
75565: PPUSH
// if not mc_bases [ base ] then
75566: NOP4
75570: PUSH
75571: NOP4
75575: ARRAY
75576: NOT
75577: IFFALSE 75581
// exit ;
75579: GO 75606
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75581: NOP4
75585: PUSH
75586: NOP4
75590: PPUSH
75591: NOP4
75595: PPUSH
75596: NOP4
75600: PPUSH
75601: NOP4
75605: ST_TO_ADDR
// end ;
75606: LD_VAR 0 3
75610: RET
// export function MC_GetMinesField ( base ) ; begin
75611: LD_INT 0
75613: PPUSH
// result := mc_mines [ base ] ;
75614: NOP4
75618: PUSH
75619: NOP4
75623: PUSH
75624: NOP4
75628: ARRAY
75629: ST_TO_ADDR
// end ;
75630: LD_VAR 0 2
75634: RET
// export function MC_GetProduceList ( base ) ; begin
75635: LD_INT 0
75637: PPUSH
// result := mc_produce [ base ] ;
75638: NOP4
75642: PUSH
75643: NOP4
75647: PUSH
75648: NOP4
75652: ARRAY
75653: ST_TO_ADDR
// end ;
75654: LD_VAR 0 2
75658: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75659: LD_INT 0
75661: PPUSH
75662: PPUSH
// if not mc_bases then
75663: NOP4
75667: NOT
75668: IFFALSE 75672
// exit ;
75670: GO 75737
// if mc_bases [ base ] then
75672: NOP4
75676: PUSH
75677: NOP4
75681: ARRAY
75682: IFFALSE 75737
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75684: NOP4
75688: PUSH
75689: NOP4
75693: PUSH
75694: NOP4
75698: ARRAY
75699: PPUSH
75700: LD_INT 30
75702: PUSH
75703: NOP4
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PPUSH
75712: NOP4
75716: ST_TO_ADDR
// if result then
75717: NOP4
75721: IFFALSE 75737
// result := result [ 1 ] ;
75723: NOP4
75727: PUSH
75728: NOP4
75732: PUSH
75733: LD_INT 1
75735: ARRAY
75736: ST_TO_ADDR
// end ; end ;
75737: LD_VAR 0 3
75741: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75742: LD_INT 0
75744: PPUSH
75745: PPUSH
// if not mc_bases then
75746: NOP4
75750: NOT
75751: IFFALSE 75755
// exit ;
75753: GO 75800
// if mc_bases [ base ] then
75755: NOP4
75759: PUSH
75760: NOP4
75764: ARRAY
75765: IFFALSE 75800
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75767: NOP4
75771: PUSH
75772: NOP4
75776: PUSH
75777: NOP4
75781: ARRAY
75782: PPUSH
75783: LD_INT 30
75785: PUSH
75786: NOP4
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PPUSH
75795: NOP4
75799: ST_TO_ADDR
// end ;
75800: LD_VAR 0 3
75804: RET
// export function MC_SetTame ( base , area ) ; begin
75805: LD_INT 0
75807: PPUSH
// if not mc_bases or not base then
75808: NOP4
75812: NOT
75813: PUSH
75814: NOP4
75818: NOT
75819: OR
75820: IFFALSE 75824
// exit ;
75822: GO 75849
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75824: NOP4
75828: PUSH
75829: NOP4
75833: PPUSH
75834: NOP4
75838: PPUSH
75839: NOP4
75843: PPUSH
75844: NOP4
75848: ST_TO_ADDR
// end ;
75849: LD_VAR 0 3
75853: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75854: LD_INT 0
75856: PPUSH
75857: PPUSH
// if not mc_bases or not base then
75858: NOP4
75862: NOT
75863: PUSH
75864: NOP4
75868: NOT
75869: OR
75870: IFFALSE 75874
// exit ;
75872: GO 75976
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75874: NOP4
75878: PUSH
75879: NOP4
75883: PUSH
75884: NOP4
75888: ARRAY
75889: PPUSH
75890: LD_INT 30
75892: PUSH
75893: NOP4
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PPUSH
75902: NOP4
75906: ST_TO_ADDR
// if not tmp then
75907: NOP4
75911: NOT
75912: IFFALSE 75916
// exit ;
75914: GO 75976
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75916: NOP4
75920: PUSH
75921: NOP4
75925: PPUSH
75926: NOP4
75930: PPUSH
75931: NOP4
75935: PUSH
75936: NOP4
75940: ARRAY
75941: PPUSH
75942: NOP4
75946: PUSH
75947: NOP4
75951: ARRAY
75952: PUSH
75953: LD_INT 1
75955: PLUS
75956: PPUSH
75957: NOP4
75961: PUSH
75962: LD_INT 1
75964: ARRAY
75965: PPUSH
75966: NOP4
75970: PPUSH
75971: NOP4
75975: ST_TO_ADDR
// end ;
75976: LD_VAR 0 3
75980: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75981: LD_INT 0
75983: PPUSH
75984: PPUSH
// if not mc_bases or not base or not kinds then
75985: NOP4
75989: NOT
75990: PUSH
75991: NOP4
75995: NOT
75996: OR
75997: PUSH
75998: NOP4
76002: NOT
76003: OR
76004: IFFALSE 76008
// exit ;
76006: GO 76069
// for i in kinds do
76008: NOP4
76012: PUSH
76013: NOP4
76017: PUSH
76018: FOR_IN
76019: IFFALSE 76067
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76021: NOP4
76025: PUSH
76026: NOP4
76030: PPUSH
76031: NOP4
76035: PUSH
76036: NOP4
76040: PUSH
76041: NOP4
76045: ARRAY
76046: PUSH
76047: LD_INT 1
76049: PLUS
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PPUSH
76055: NOP4
76059: PPUSH
76060: NOP4
76064: ST_TO_ADDR
76065: GO 76018
76067: POP
76068: POP
// end ;
76069: LD_VAR 0 3
76073: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76074: LD_INT 0
76076: PPUSH
// if not mc_bases or not base or not areas then
76077: NOP4
76081: NOT
76082: PUSH
76083: NOP4
76087: NOT
76088: OR
76089: PUSH
76090: NOP4
76094: NOT
76095: OR
76096: IFFALSE 76100
// exit ;
76098: GO 76125
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76100: NOP4
76104: PUSH
76105: NOP4
76109: PPUSH
76110: NOP4
76114: PPUSH
76115: NOP4
76119: PPUSH
76120: NOP4
76124: ST_TO_ADDR
// end ;
76125: LD_VAR 0 3
76129: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76130: LD_INT 0
76132: PPUSH
// if not mc_bases or not base or not teleports_exit then
76133: NOP4
76137: NOT
76138: PUSH
76139: NOP4
76143: NOT
76144: OR
76145: PUSH
76146: NOP4
76150: NOT
76151: OR
76152: IFFALSE 76156
// exit ;
76154: GO 76181
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76156: NOP4
76160: PUSH
76161: NOP4
76165: PPUSH
76166: NOP4
76170: PPUSH
76171: NOP4
76175: PPUSH
76176: NOP4
76180: ST_TO_ADDR
// end ;
76181: LD_VAR 0 3
76185: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76186: LD_INT 0
76188: PPUSH
76189: PPUSH
76190: PPUSH
// if not mc_bases or not base or not ext_list then
76191: NOP4
76195: NOT
76196: PUSH
76197: NOP4
76201: NOT
76202: OR
76203: PUSH
76204: NOP4
76208: NOT
76209: OR
76210: IFFALSE 76214
// exit ;
76212: GO 76387
// tmp := GetFacExtXYD ( x , y , d ) ;
76214: NOP4
76218: PUSH
76219: NOP4
76223: PPUSH
76224: NOP4
76228: PPUSH
76229: NOP4
76233: PPUSH
76234: NOP4
76238: ST_TO_ADDR
// if not tmp then
76239: NOP4
76243: NOT
76244: IFFALSE 76248
// exit ;
76246: GO 76387
// for i in tmp do
76248: NOP4
76252: PUSH
76253: NOP4
76257: PUSH
76258: FOR_IN
76259: IFFALSE 76385
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76261: NOP4
76265: PUSH
76266: NOP4
76270: PPUSH
76271: NOP4
76275: PPUSH
76276: NOP4
76280: PUSH
76281: NOP4
76285: ARRAY
76286: PPUSH
76287: NOP4
76291: PUSH
76292: NOP4
76296: ARRAY
76297: PUSH
76298: LD_INT 1
76300: PLUS
76301: PPUSH
76302: NOP4
76306: PUSH
76307: LD_INT 1
76309: ARRAY
76310: PUSH
76311: NOP4
76315: PUSH
76316: LD_INT 1
76318: ARRAY
76319: PUSH
76320: NOP4
76324: PUSH
76325: LD_INT 2
76327: ARRAY
76328: PUSH
76329: NOP4
76333: PUSH
76334: LD_INT 3
76336: ARRAY
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: LIST
76342: LIST
76343: PPUSH
76344: NOP4
76348: PPUSH
76349: NOP4
76353: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76354: NOP4
76358: PUSH
76359: NOP4
76363: PPUSH
76364: LD_INT 1
76366: PPUSH
76367: NOP4
76371: ST_TO_ADDR
// if not ext_list then
76372: NOP4
76376: NOT
76377: IFFALSE 76383
// exit ;
76379: POP
76380: POP
76381: GO 76387
// end ;
76383: GO 76258
76385: POP
76386: POP
// end ;
76387: LD_VAR 0 6
76391: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76392: LD_INT 0
76394: PPUSH
// if not mc_bases or not base or not weapon_list then
76395: NOP4
76399: NOT
76400: PUSH
76401: NOP4
76405: NOT
76406: OR
76407: PUSH
76408: NOP4
76412: NOT
76413: OR
76414: IFFALSE 76418
// exit ;
76416: GO 76443
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76418: NOP4
76422: PUSH
76423: NOP4
76427: PPUSH
76428: NOP4
76432: PPUSH
76433: NOP4
76437: PPUSH
76438: NOP4
76442: ST_TO_ADDR
// end ;
76443: LD_VAR 0 3
76447: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76448: LD_INT 0
76450: PPUSH
// if not mc_bases or not base or not tech_list then
76451: NOP4
76455: NOT
76456: PUSH
76457: NOP4
76461: NOT
76462: OR
76463: PUSH
76464: NOP4
76468: NOT
76469: OR
76470: IFFALSE 76474
// exit ;
76472: GO 76499
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76474: NOP4
76478: PUSH
76479: NOP4
76483: PPUSH
76484: NOP4
76488: PPUSH
76489: NOP4
76493: PPUSH
76494: NOP4
76498: ST_TO_ADDR
// end ;
76499: LD_VAR 0 3
76503: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76504: LD_INT 0
76506: PPUSH
// if not mc_bases or not parking_area or not base then
76507: NOP4
76511: NOT
76512: PUSH
76513: NOP4
76517: NOT
76518: OR
76519: PUSH
76520: NOP4
76524: NOT
76525: OR
76526: IFFALSE 76530
// exit ;
76528: GO 76555
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76530: NOP4
76534: PUSH
76535: NOP4
76539: PPUSH
76540: NOP4
76544: PPUSH
76545: NOP4
76549: PPUSH
76550: NOP4
76554: ST_TO_ADDR
// end ;
76555: LD_VAR 0 3
76559: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76560: LD_INT 0
76562: PPUSH
// if not mc_bases or not base or not scan_area then
76563: NOP4
76567: NOT
76568: PUSH
76569: NOP4
76573: NOT
76574: OR
76575: PUSH
76576: NOP4
76580: NOT
76581: OR
76582: IFFALSE 76586
// exit ;
76584: GO 76611
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76586: NOP4
76590: PUSH
76591: NOP4
76595: PPUSH
76596: NOP4
76600: PPUSH
76601: NOP4
76605: PPUSH
76606: NOP4
76610: ST_TO_ADDR
// end ;
76611: LD_VAR 0 3
76615: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76616: LD_INT 0
76618: PPUSH
76619: PPUSH
// if not mc_bases or not base then
76620: NOP4
76624: NOT
76625: PUSH
76626: NOP4
76630: NOT
76631: OR
76632: IFFALSE 76636
// exit ;
76634: GO 76700
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76636: NOP4
76640: PUSH
76641: LD_INT 1
76643: PUSH
76644: LD_INT 2
76646: PUSH
76647: LD_INT 3
76649: PUSH
76650: LD_INT 4
76652: PUSH
76653: LD_INT 11
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76663: NOP4
76667: PUSH
76668: NOP4
76672: PPUSH
76673: NOP4
76677: PPUSH
76678: NOP4
76682: PUSH
76683: NOP4
76687: ARRAY
76688: PUSH
76689: NOP4
76693: DIFF
76694: PPUSH
76695: NOP4
76699: ST_TO_ADDR
// end ;
76700: LD_VAR 0 2
76704: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76705: LD_INT 0
76707: PPUSH
// result := mc_vehicles [ base ] ;
76708: NOP4
76712: PUSH
76713: NOP4
76717: PUSH
76718: NOP4
76722: ARRAY
76723: ST_TO_ADDR
// if onlyCombat then
76724: NOP4
76728: IFFALSE 76906
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76730: NOP4
76734: PUSH
76735: NOP4
76739: PUSH
76740: NOP4
76744: PPUSH
76745: LD_INT 2
76747: PUSH
76748: LD_INT 34
76750: PUSH
76751: LD_INT 12
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 34
76760: PUSH
76761: LD_INT 51
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 34
76770: PUSH
76771: NOP4
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 34
76782: PUSH
76783: LD_INT 32
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 34
76792: PUSH
76793: LD_INT 13
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 34
76802: PUSH
76803: LD_INT 52
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 34
76812: PUSH
76813: NOP4
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 34
76824: PUSH
76825: LD_INT 14
76827: PUSH
76828: EMPTY
76829: LIST
76830: LIST
76831: PUSH
76832: LD_INT 34
76834: PUSH
76835: LD_INT 53
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 34
76844: PUSH
76845: NOP4
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 34
76856: PUSH
76857: LD_INT 31
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: LD_INT 34
76866: PUSH
76867: LD_INT 48
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 34
76876: PUSH
76877: LD_INT 8
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: PPUSH
76900: NOP4
76904: DIFF
76905: ST_TO_ADDR
// end ; end_of_file
76906: LD_VAR 0 3
76910: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76911: LD_INT 0
76913: PPUSH
76914: PPUSH
76915: PPUSH
// if not mc_bases or not skirmish then
76916: NOP4
76920: NOT
76921: PUSH
76922: NOP4
76926: NOT
76927: OR
76928: IFFALSE 76932
// exit ;
76930: GO 77097
// for i = 1 to mc_bases do
76932: NOP4
76936: PUSH
76937: DOUBLE
76938: LD_INT 1
76940: DEC
76941: ST_TO_ADDR
76942: NOP4
76946: PUSH
76947: FOR_TO
76948: IFFALSE 77095
// begin if sci in mc_bases [ i ] then
76950: NOP4
76954: PUSH
76955: NOP4
76959: PUSH
76960: NOP4
76964: ARRAY
76965: IN
76966: IFFALSE 77093
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76968: NOP4
76972: PUSH
76973: NOP4
76977: PPUSH
76978: NOP4
76982: PUSH
76983: NOP4
76987: PUSH
76988: NOP4
76992: ARRAY
76993: PUSH
76994: LD_INT 1
76996: PLUS
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PPUSH
77002: NOP4
77006: PPUSH
77007: NOP4
77011: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77012: NOP4
77016: PUSH
77017: NOP4
77021: PUSH
77022: NOP4
77026: ARRAY
77027: PPUSH
77028: LD_INT 2
77030: PUSH
77031: LD_INT 30
77033: PUSH
77034: LD_INT 0
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 30
77043: PUSH
77044: LD_INT 1
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: PPUSH
77056: NOP4
77060: PPUSH
77061: NOP4
77065: PPUSH
77066: NOP4
77070: ST_TO_ADDR
// if tmp then
77071: NOP4
77075: IFFALSE 77091
// ComStandNearbyBuilding ( ape , tmp ) ;
77077: NOP4
77081: PPUSH
77082: NOP4
77086: PPUSH
77087: NOP4
// break ;
77091: GO 77095
// end ; end ;
77093: GO 76947
77095: POP
77096: POP
// end ;
77097: LD_VAR 0 3
77101: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77102: LD_INT 0
77104: PPUSH
77105: PPUSH
77106: PPUSH
// if not mc_bases or not skirmish then
77107: NOP4
77111: NOT
77112: PUSH
77113: NOP4
77117: NOT
77118: OR
77119: IFFALSE 77123
// exit ;
77121: GO 77212
// for i = 1 to mc_bases do
77123: NOP4
77127: PUSH
77128: DOUBLE
77129: LD_INT 1
77131: DEC
77132: ST_TO_ADDR
77133: NOP4
77137: PUSH
77138: FOR_TO
77139: IFFALSE 77210
// begin if building in mc_busy_turret_list [ i ] then
77141: NOP4
77145: PUSH
77146: NOP4
77150: PUSH
77151: NOP4
77155: ARRAY
77156: IN
77157: IFFALSE 77208
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77159: NOP4
77163: PUSH
77164: NOP4
77168: PUSH
77169: NOP4
77173: ARRAY
77174: PUSH
77175: NOP4
77179: DIFF
77180: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77181: NOP4
77185: PUSH
77186: NOP4
77190: PPUSH
77191: NOP4
77195: PPUSH
77196: NOP4
77200: PPUSH
77201: NOP4
77205: ST_TO_ADDR
// break ;
77206: GO 77210
// end ; end ;
77208: GO 77138
77210: POP
77211: POP
// end ;
77212: LD_VAR 0 3
77216: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77217: LD_INT 0
77219: PPUSH
77220: PPUSH
77221: PPUSH
// if not mc_bases or not skirmish then
77222: NOP4
77226: NOT
77227: PUSH
77228: NOP4
77232: NOT
77233: OR
77234: IFFALSE 77238
// exit ;
77236: GO 77437
// for i = 1 to mc_bases do
77238: NOP4
77242: PUSH
77243: DOUBLE
77244: LD_INT 1
77246: DEC
77247: ST_TO_ADDR
77248: NOP4
77252: PUSH
77253: FOR_TO
77254: IFFALSE 77435
// if building in mc_bases [ i ] then
77256: NOP4
77260: PUSH
77261: NOP4
77265: PUSH
77266: NOP4
77270: ARRAY
77271: IN
77272: IFFALSE 77433
// begin tmp := mc_bases [ i ] diff building ;
77274: NOP4
77278: PUSH
77279: NOP4
77283: PUSH
77284: NOP4
77288: ARRAY
77289: PUSH
77290: NOP4
77294: DIFF
77295: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77296: NOP4
77300: PUSH
77301: NOP4
77305: PPUSH
77306: NOP4
77310: PPUSH
77311: NOP4
77315: PPUSH
77316: NOP4
77320: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77321: NOP4
77325: PUSH
77326: NOP4
77330: PUSH
77331: NOP4
77335: ARRAY
77336: IN
77337: IFFALSE 77376
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77339: NOP4
77343: PUSH
77344: NOP4
77348: PPUSH
77349: NOP4
77353: PPUSH
77354: NOP4
77358: PUSH
77359: NOP4
77363: ARRAY
77364: PUSH
77365: NOP4
77369: DIFF
77370: PPUSH
77371: NOP4
77375: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77376: NOP4
77380: PUSH
77381: NOP4
77385: PUSH
77386: NOP4
77390: ARRAY
77391: IN
77392: IFFALSE 77431
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77394: NOP4
77398: PUSH
77399: NOP4
77403: PPUSH
77404: NOP4
77408: PPUSH
77409: NOP4
77413: PUSH
77414: NOP4
77418: ARRAY
77419: PUSH
77420: NOP4
77424: DIFF
77425: PPUSH
77426: NOP4
77430: ST_TO_ADDR
// break ;
77431: GO 77435
// end ;
77433: GO 77253
77435: POP
77436: POP
// end ;
77437: LD_VAR 0 4
77441: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77442: LD_INT 0
77444: PPUSH
77445: PPUSH
77446: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77447: NOP4
77451: NOT
77452: PUSH
77453: NOP4
77457: NOT
77458: OR
77459: PUSH
77460: NOP4
77464: PUSH
77465: NOP4
77469: IN
77470: NOT
77471: OR
77472: IFFALSE 77476
// exit ;
77474: GO 77599
// for i = 1 to mc_vehicles do
77476: NOP4
77480: PUSH
77481: DOUBLE
77482: LD_INT 1
77484: DEC
77485: ST_TO_ADDR
77486: NOP4
77490: PUSH
77491: FOR_TO
77492: IFFALSE 77597
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77494: NOP4
77498: PUSH
77499: NOP4
77503: PUSH
77504: NOP4
77508: ARRAY
77509: IN
77510: PUSH
77511: NOP4
77515: PUSH
77516: NOP4
77520: PUSH
77521: NOP4
77525: ARRAY
77526: IN
77527: OR
77528: IFFALSE 77595
// begin tmp := mc_vehicles [ i ] diff old ;
77530: NOP4
77534: PUSH
77535: NOP4
77539: PUSH
77540: NOP4
77544: ARRAY
77545: PUSH
77546: NOP4
77550: DIFF
77551: ST_TO_ADDR
// tmp := tmp diff new ;
77552: NOP4
77556: PUSH
77557: NOP4
77561: PUSH
77562: NOP4
77566: DIFF
77567: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77568: NOP4
77572: PUSH
77573: NOP4
77577: PPUSH
77578: NOP4
77582: PPUSH
77583: NOP4
77587: PPUSH
77588: NOP4
77592: ST_TO_ADDR
// break ;
77593: GO 77597
// end ;
77595: GO 77491
77597: POP
77598: POP
// end ;
77599: LD_VAR 0 5
77603: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77604: LD_INT 0
77606: PPUSH
77607: PPUSH
77608: PPUSH
77609: PPUSH
// if not mc_bases or not skirmish then
77610: NOP4
77614: NOT
77615: PUSH
77616: NOP4
77620: NOT
77621: OR
77622: IFFALSE 77626
// exit ;
77624: GO 78018
// side := GetSide ( vehicle ) ;
77626: NOP4
77630: PUSH
77631: NOP4
77635: PPUSH
77636: NOP4
77640: ST_TO_ADDR
// for i = 1 to mc_bases do
77641: NOP4
77645: PUSH
77646: DOUBLE
77647: LD_INT 1
77649: DEC
77650: ST_TO_ADDR
77651: NOP4
77655: PUSH
77656: FOR_TO
77657: IFFALSE 78016
// begin if factory in mc_bases [ i ] then
77659: NOP4
77663: PUSH
77664: NOP4
77668: PUSH
77669: NOP4
77673: ARRAY
77674: IN
77675: IFFALSE 78014
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77677: NOP4
77681: PUSH
77682: NOP4
77686: ARRAY
77687: PUSH
77688: NOP4
77692: PUSH
77693: NOP4
77697: ARRAY
77698: LESS
77699: PUSH
77700: NOP4
77704: PPUSH
77705: NOP4
77709: PUSH
77710: LD_INT 31
77712: PUSH
77713: LD_INT 32
77715: PUSH
77716: LD_INT 51
77718: PUSH
77719: NOP4
77723: PUSH
77724: LD_INT 12
77726: PUSH
77727: LD_INT 30
77729: PUSH
77730: NOP4
77734: PUSH
77735: LD_INT 11
77737: PUSH
77738: LD_INT 53
77740: PUSH
77741: LD_INT 14
77743: PUSH
77744: NOP4
77748: PUSH
77749: LD_INT 29
77751: PUSH
77752: NOP4
77756: PUSH
77757: LD_INT 13
77759: PUSH
77760: LD_INT 52
77762: PUSH
77763: NOP4
77767: PUSH
77768: LD_INT 48
77770: PUSH
77771: LD_INT 8
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: LIST
77787: LIST
77788: LIST
77789: LIST
77790: LIST
77791: LIST
77792: LIST
77793: IN
77794: NOT
77795: AND
77796: IFFALSE 77844
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77798: NOP4
77802: PUSH
77803: NOP4
77807: PPUSH
77808: NOP4
77812: PUSH
77813: NOP4
77817: PUSH
77818: NOP4
77822: ARRAY
77823: PUSH
77824: LD_INT 1
77826: PLUS
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PPUSH
77832: NOP4
77836: PPUSH
77837: NOP4
77841: ST_TO_ADDR
77842: GO 77888
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77844: NOP4
77848: PUSH
77849: NOP4
77853: PPUSH
77854: NOP4
77858: PUSH
77859: NOP4
77863: PUSH
77864: NOP4
77868: ARRAY
77869: PUSH
77870: LD_INT 1
77872: PLUS
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PPUSH
77878: NOP4
77882: PPUSH
77883: NOP4
77887: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77888: NOP4
77892: PPUSH
77893: NOP4
77897: PUSH
77898: LD_INT 2
77900: EQUAL
77901: IFFALSE 77930
// begin repeat wait ( 0 0$3 ) ;
77903: LD_INT 105
77905: PPUSH
77906: NOP4
// Connect ( vehicle ) ;
77910: NOP4
77914: PPUSH
77915: NOP4
// until IsControledBy ( vehicle ) ;
77919: NOP4
77923: PPUSH
77924: NOP4
77928: IFFALSE 77903
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77930: NOP4
77934: PPUSH
77935: NOP4
77939: PUSH
77940: NOP4
77944: ARRAY
77945: PPUSH
77946: NOP4
// if GetControl ( vehicle ) <> control_manual then
77950: NOP4
77954: PPUSH
77955: NOP4
77959: PUSH
77960: LD_INT 1
77962: NONEQUAL
77963: IFFALSE 77967
// break ;
77965: GO 78016
// repeat wait ( 0 0$1 ) ;
77967: LD_INT 35
77969: PPUSH
77970: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77974: NOP4
77978: PPUSH
77979: NOP4
77983: PUSH
77984: NOP4
77988: ARRAY
77989: PPUSH
77990: NOP4
77994: IFFALSE 77967
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77996: NOP4
78000: PPUSH
78001: NOP4
78005: PPUSH
78006: NOP4
// exit ;
78010: POP
78011: POP
78012: GO 78018
// end ; end ;
78014: GO 77656
78016: POP
78017: POP
// end ;
78018: LD_VAR 0 3
78022: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78023: LD_INT 0
78025: PPUSH
78026: PPUSH
78027: PPUSH
78028: PPUSH
// if not mc_bases or not skirmish then
78029: NOP4
78033: NOT
78034: PUSH
78035: NOP4
78039: NOT
78040: OR
78041: IFFALSE 78045
// exit ;
78043: GO 78398
// repeat wait ( 0 0$1 ) ;
78045: LD_INT 35
78047: PPUSH
78048: NOP4
// until GetResourceAmountXY ( x , y ) ;
78052: NOP4
78056: PPUSH
78057: NOP4
78061: PPUSH
78062: NOP4
78066: IFFALSE 78045
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78068: NOP4
78072: PPUSH
78073: NOP4
78077: PPUSH
78078: NOP4
78082: PUSH
78083: LD_INT 4
78085: EQUAL
78086: IFFALSE 78090
// exit ;
78088: GO 78398
// for i = 1 to mc_bases do
78090: NOP4
78094: PUSH
78095: DOUBLE
78096: LD_INT 1
78098: DEC
78099: ST_TO_ADDR
78100: NOP4
78104: PUSH
78105: FOR_TO
78106: IFFALSE 78396
// begin if mc_crates_area [ i ] then
78108: NOP4
78112: PUSH
78113: NOP4
78117: ARRAY
78118: IFFALSE 78229
// for j in mc_crates_area [ i ] do
78120: NOP4
78124: PUSH
78125: NOP4
78129: PUSH
78130: NOP4
78134: ARRAY
78135: PUSH
78136: FOR_IN
78137: IFFALSE 78227
// if InArea ( x , y , j ) then
78139: NOP4
78143: PPUSH
78144: NOP4
78148: PPUSH
78149: NOP4
78153: PPUSH
78154: NOP4
78158: IFFALSE 78225
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78160: NOP4
78164: PUSH
78165: NOP4
78169: PPUSH
78170: NOP4
78174: PUSH
78175: NOP4
78179: PUSH
78180: NOP4
78184: ARRAY
78185: PUSH
78186: LD_INT 1
78188: PLUS
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PPUSH
78194: NOP4
78198: PUSH
78199: NOP4
78203: PUSH
78204: NOP4
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: PPUSH
78214: NOP4
78218: ST_TO_ADDR
// exit ;
78219: POP
78220: POP
78221: POP
78222: POP
78223: GO 78398
// end ;
78225: GO 78136
78227: POP
78228: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78229: NOP4
78233: PUSH
78234: NOP4
78238: PUSH
78239: NOP4
78243: ARRAY
78244: PPUSH
78245: LD_INT 2
78247: PUSH
78248: LD_INT 30
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 30
78260: PUSH
78261: LD_INT 1
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: LIST
78272: PPUSH
78273: NOP4
78277: ST_TO_ADDR
// if not depot then
78278: NOP4
78282: NOT
78283: IFFALSE 78287
// continue ;
78285: GO 78105
// for j in depot do
78287: NOP4
78291: PUSH
78292: NOP4
78296: PUSH
78297: FOR_IN
78298: IFFALSE 78392
// if GetDistUnitXY ( j , x , y ) < 30 then
78300: NOP4
78304: PPUSH
78305: NOP4
78309: PPUSH
78310: NOP4
78314: PPUSH
78315: NOP4
78319: PUSH
78320: LD_INT 30
78322: LESS
78323: IFFALSE 78390
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78325: NOP4
78329: PUSH
78330: NOP4
78334: PPUSH
78335: NOP4
78339: PUSH
78340: NOP4
78344: PUSH
78345: NOP4
78349: ARRAY
78350: PUSH
78351: LD_INT 1
78353: PLUS
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PPUSH
78359: NOP4
78363: PUSH
78364: NOP4
78368: PUSH
78369: NOP4
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: LIST
78378: PPUSH
78379: NOP4
78383: ST_TO_ADDR
// exit ;
78384: POP
78385: POP
78386: POP
78387: POP
78388: GO 78398
// end ;
78390: GO 78297
78392: POP
78393: POP
// end ;
78394: GO 78105
78396: POP
78397: POP
// end ;
78398: LD_VAR 0 6
78402: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78403: LD_INT 0
78405: PPUSH
78406: PPUSH
78407: PPUSH
78408: PPUSH
// if not mc_bases or not skirmish then
78409: NOP4
78413: NOT
78414: PUSH
78415: NOP4
78419: NOT
78420: OR
78421: IFFALSE 78425
// exit ;
78423: GO 78702
// side := GetSide ( lab ) ;
78425: NOP4
78429: PUSH
78430: NOP4
78434: PPUSH
78435: NOP4
78439: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78440: NOP4
78444: PUSH
78445: NOP4
78449: IN
78450: NOT
78451: PUSH
78452: NOP4
78456: NOT
78457: OR
78458: PUSH
78459: NOP4
78463: NOT
78464: OR
78465: IFFALSE 78469
// exit ;
78467: GO 78702
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78469: NOP4
78473: PUSH
78474: NOP4
78478: PPUSH
78479: NOP4
78483: PPUSH
78484: NOP4
78488: PUSH
78489: NOP4
78493: ARRAY
78494: PUSH
78495: NOP4
78499: DIFF
78500: PPUSH
78501: NOP4
78505: ST_TO_ADDR
// for i = 1 to mc_bases do
78506: NOP4
78510: PUSH
78511: DOUBLE
78512: LD_INT 1
78514: DEC
78515: ST_TO_ADDR
78516: NOP4
78520: PUSH
78521: FOR_TO
78522: IFFALSE 78700
// begin if lab in mc_bases [ i ] then
78524: NOP4
78528: PUSH
78529: NOP4
78533: PUSH
78534: NOP4
78538: ARRAY
78539: IN
78540: IFFALSE 78698
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78542: NOP4
78546: PUSH
78547: LD_INT 11
78549: PUSH
78550: LD_INT 4
78552: PUSH
78553: LD_INT 3
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: LIST
78563: LIST
78564: IN
78565: PUSH
78566: NOP4
78570: PUSH
78571: NOP4
78575: ARRAY
78576: AND
78577: IFFALSE 78698
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78579: NOP4
78583: PUSH
78584: NOP4
78588: PUSH
78589: NOP4
78593: ARRAY
78594: PUSH
78595: LD_INT 1
78597: ARRAY
78598: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78599: NOP4
78603: PUSH
78604: NOP4
78608: PPUSH
78609: NOP4
78613: PPUSH
78614: EMPTY
78615: PPUSH
78616: NOP4
78620: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78621: NOP4
78625: PPUSH
78626: LD_INT 0
78628: PPUSH
78629: NOP4
// ComExitBuilding ( tmp ) ;
78633: NOP4
78637: PPUSH
78638: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78642: NOP4
78646: PUSH
78647: NOP4
78651: PPUSH
78652: NOP4
78656: PPUSH
78657: NOP4
78661: PUSH
78662: NOP4
78666: ARRAY
78667: PPUSH
78668: LD_INT 1
78670: PPUSH
78671: NOP4
78675: PPUSH
78676: NOP4
78680: PPUSH
78681: NOP4
78685: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78686: NOP4
78690: PPUSH
78691: LD_INT 112
78693: PPUSH
78694: NOP4
// end ; end ; end ;
78698: GO 78521
78700: POP
78701: POP
// end ;
78702: LD_VAR 0 3
78706: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78707: LD_INT 0
78709: PPUSH
78710: PPUSH
78711: PPUSH
78712: PPUSH
78713: PPUSH
78714: PPUSH
78715: PPUSH
78716: PPUSH
// if not mc_bases or not skirmish then
78717: NOP4
78721: NOT
78722: PUSH
78723: NOP4
78727: NOT
78728: OR
78729: IFFALSE 78733
// exit ;
78731: GO 80104
// for i = 1 to mc_bases do
78733: NOP4
78737: PUSH
78738: DOUBLE
78739: LD_INT 1
78741: DEC
78742: ST_TO_ADDR
78743: NOP4
78747: PUSH
78748: FOR_TO
78749: IFFALSE 80102
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78751: NOP4
78755: PUSH
78756: NOP4
78760: PUSH
78761: NOP4
78765: ARRAY
78766: IN
78767: PUSH
78768: NOP4
78772: PUSH
78773: NOP4
78777: PUSH
78778: NOP4
78782: ARRAY
78783: IN
78784: OR
78785: PUSH
78786: NOP4
78790: PUSH
78791: NOP4
78795: PUSH
78796: NOP4
78800: ARRAY
78801: IN
78802: OR
78803: PUSH
78804: NOP4
78808: PUSH
78809: NOP4
78813: PUSH
78814: NOP4
78818: ARRAY
78819: IN
78820: OR
78821: PUSH
78822: NOP4
78826: PUSH
78827: NOP4
78831: PUSH
78832: NOP4
78836: ARRAY
78837: IN
78838: OR
78839: PUSH
78840: NOP4
78844: PUSH
78845: NOP4
78849: PUSH
78850: NOP4
78854: ARRAY
78855: IN
78856: OR
78857: IFFALSE 80100
// begin if un in mc_ape [ i ] then
78859: NOP4
78863: PUSH
78864: NOP4
78868: PUSH
78869: NOP4
78873: ARRAY
78874: IN
78875: IFFALSE 78914
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78877: NOP4
78881: PUSH
78882: NOP4
78886: PPUSH
78887: NOP4
78891: PPUSH
78892: NOP4
78896: PUSH
78897: NOP4
78901: ARRAY
78902: PUSH
78903: NOP4
78907: DIFF
78908: PPUSH
78909: NOP4
78913: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78914: NOP4
78918: PUSH
78919: NOP4
78923: PUSH
78924: NOP4
78928: ARRAY
78929: IN
78930: IFFALSE 78954
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78932: NOP4
78936: PUSH
78937: NOP4
78941: PPUSH
78942: NOP4
78946: PPUSH
78947: EMPTY
78948: PPUSH
78949: NOP4
78953: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78954: NOP4
78958: PPUSH
78959: NOP4
78963: PUSH
78964: LD_INT 2
78966: EQUAL
78967: PUSH
78968: NOP4
78972: PPUSH
78973: NOP4
78977: PUSH
78978: LD_INT 20
78980: EQUAL
78981: PUSH
78982: NOP4
78986: PUSH
78987: NOP4
78991: PUSH
78992: NOP4
78996: ARRAY
78997: IN
78998: OR
78999: PUSH
79000: NOP4
79004: PPUSH
79005: NOP4
79009: PUSH
79010: LD_INT 12
79012: PUSH
79013: LD_INT 51
79015: PUSH
79016: NOP4
79020: PUSH
79021: LD_INT 32
79023: PUSH
79024: LD_INT 13
79026: PUSH
79027: LD_INT 52
79029: PUSH
79030: LD_INT 31
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: IN
79042: OR
79043: AND
79044: IFFALSE 79352
// begin if un in mc_defender [ i ] then
79046: NOP4
79050: PUSH
79051: NOP4
79055: PUSH
79056: NOP4
79060: ARRAY
79061: IN
79062: IFFALSE 79101
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79064: NOP4
79068: PUSH
79069: NOP4
79073: PPUSH
79074: NOP4
79078: PPUSH
79079: NOP4
79083: PUSH
79084: NOP4
79088: ARRAY
79089: PUSH
79090: NOP4
79094: DIFF
79095: PPUSH
79096: NOP4
79100: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79101: NOP4
79105: PUSH
79106: NOP4
79110: PPUSH
79111: LD_INT 3
79113: PPUSH
79114: NOP4
79118: ST_TO_ADDR
// if fac then
79119: NOP4
79123: IFFALSE 79352
// begin for j in fac do
79125: NOP4
79129: PUSH
79130: NOP4
79134: PUSH
79135: FOR_IN
79136: IFFALSE 79350
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79138: NOP4
79142: PUSH
79143: NOP4
79147: PPUSH
79148: NOP4
79152: PPUSH
79153: NOP4
79157: PPUSH
79158: NOP4
79162: PPUSH
79163: NOP4
79167: PPUSH
79168: NOP4
79172: PPUSH
79173: NOP4
79177: PPUSH
79178: NOP4
79182: PPUSH
79183: NOP4
79187: PPUSH
79188: NOP4
79192: ST_TO_ADDR
// if components then
79193: NOP4
79197: IFFALSE 79348
// begin if GetWeapon ( un ) = ar_control_tower then
79199: NOP4
79203: PPUSH
79204: NOP4
79208: PUSH
79209: LD_INT 31
79211: EQUAL
79212: IFFALSE 79329
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79214: NOP4
79218: PPUSH
79219: NOP4
79223: PPUSH
79224: LD_INT 0
79226: PPUSH
79227: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79231: NOP4
79235: PUSH
79236: NOP4
79240: PPUSH
79241: NOP4
79245: PPUSH
79246: NOP4
79250: PUSH
79251: NOP4
79255: ARRAY
79256: PUSH
79257: NOP4
79261: PPUSH
79262: NOP4
79266: DIFF
79267: PPUSH
79268: NOP4
79272: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79273: NOP4
79277: PUSH
79278: NOP4
79282: PUSH
79283: NOP4
79287: ARRAY
79288: PPUSH
79289: LD_INT 1
79291: PPUSH
79292: NOP4
79296: PPUSH
79297: NOP4
79301: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79302: NOP4
79306: PUSH
79307: NOP4
79311: PPUSH
79312: NOP4
79316: PPUSH
79317: NOP4
79321: PPUSH
79322: NOP4
79326: ST_TO_ADDR
// end else
79327: GO 79346
// MC_InsertProduceList ( i , [ components ] ) ;
79329: NOP4
79333: PPUSH
79334: NOP4
79338: PUSH
79339: EMPTY
79340: LIST
79341: PPUSH
79342: NOP4
// break ;
79346: GO 79350
// end ; end ;
79348: GO 79135
79350: POP
79351: POP
// end ; end ; if GetType ( un ) = unit_building then
79352: NOP4
79356: PPUSH
79357: NOP4
79361: PUSH
79362: LD_INT 3
79364: EQUAL
79365: IFFALSE 79768
// begin btype := GetBType ( un ) ;
79367: NOP4
79371: PUSH
79372: NOP4
79376: PPUSH
79377: NOP4
79381: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79382: NOP4
79386: PUSH
79387: LD_INT 29
79389: PUSH
79390: LD_INT 30
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: IN
79397: IFFALSE 79470
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79399: NOP4
79403: PPUSH
79404: NOP4
79408: PPUSH
79409: NOP4
79413: PPUSH
79414: NOP4
79418: PPUSH
79419: NOP4
79423: PPUSH
79424: NOP4
79428: PPUSH
79429: NOP4
79433: NOT
79434: IFFALSE 79470
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79436: NOP4
79440: PPUSH
79441: NOP4
79445: PPUSH
79446: NOP4
79450: PPUSH
79451: NOP4
79455: PPUSH
79456: NOP4
79460: PPUSH
79461: NOP4
79465: PPUSH
79466: NOP4
// end ; if btype = b_warehouse then
79470: NOP4
79474: PUSH
79475: LD_INT 1
79477: EQUAL
79478: IFFALSE 79496
// begin btype := b_depot ;
79480: NOP4
79484: PUSH
79485: LD_INT 0
79487: ST_TO_ADDR
// pos := 1 ;
79488: NOP4
79492: PUSH
79493: LD_INT 1
79495: ST_TO_ADDR
// end ; if btype = b_factory then
79496: NOP4
79500: PUSH
79501: LD_INT 3
79503: EQUAL
79504: IFFALSE 79522
// begin btype := b_workshop ;
79506: NOP4
79510: PUSH
79511: LD_INT 2
79513: ST_TO_ADDR
// pos := 1 ;
79514: NOP4
79518: PUSH
79519: LD_INT 1
79521: ST_TO_ADDR
// end ; if btype = b_barracks then
79522: NOP4
79526: PUSH
79527: LD_INT 5
79529: EQUAL
79530: IFFALSE 79540
// btype := b_armoury ;
79532: NOP4
79536: PUSH
79537: LD_INT 4
79539: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79540: NOP4
79544: PUSH
79545: LD_INT 7
79547: PUSH
79548: LD_INT 8
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: IN
79555: IFFALSE 79565
// btype := b_lab ;
79557: NOP4
79561: PUSH
79562: LD_INT 6
79564: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79565: NOP4
79569: PUSH
79570: NOP4
79574: PPUSH
79575: NOP4
79579: PUSH
79580: NOP4
79584: PUSH
79585: NOP4
79589: ARRAY
79590: PUSH
79591: LD_INT 1
79593: PLUS
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PPUSH
79599: NOP4
79603: PUSH
79604: NOP4
79608: PPUSH
79609: NOP4
79613: PUSH
79614: NOP4
79618: PPUSH
79619: NOP4
79623: PUSH
79624: NOP4
79628: PPUSH
79629: NOP4
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: PPUSH
79640: NOP4
79644: ST_TO_ADDR
// if pos = 1 then
79645: NOP4
79649: PUSH
79650: LD_INT 1
79652: EQUAL
79653: IFFALSE 79768
// begin tmp := mc_build_list [ i ] ;
79655: NOP4
79659: PUSH
79660: NOP4
79664: PUSH
79665: NOP4
79669: ARRAY
79670: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79671: NOP4
79675: PPUSH
79676: LD_INT 2
79678: PUSH
79679: LD_INT 30
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 30
79691: PUSH
79692: LD_INT 1
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: LIST
79703: PPUSH
79704: NOP4
79708: IFFALSE 79718
// pos := 2 ;
79710: NOP4
79714: PUSH
79715: LD_INT 2
79717: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79718: NOP4
79722: PUSH
79723: NOP4
79727: PPUSH
79728: NOP4
79732: PPUSH
79733: NOP4
79737: PPUSH
79738: NOP4
79742: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79743: NOP4
79747: PUSH
79748: NOP4
79752: PPUSH
79753: NOP4
79757: PPUSH
79758: NOP4
79762: PPUSH
79763: NOP4
79767: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79768: NOP4
79772: PUSH
79773: NOP4
79777: PUSH
79778: NOP4
79782: ARRAY
79783: IN
79784: IFFALSE 79823
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79786: NOP4
79790: PUSH
79791: NOP4
79795: PPUSH
79796: NOP4
79800: PPUSH
79801: NOP4
79805: PUSH
79806: NOP4
79810: ARRAY
79811: PUSH
79812: NOP4
79816: DIFF
79817: PPUSH
79818: NOP4
79822: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79823: NOP4
79827: PUSH
79828: NOP4
79832: PUSH
79833: NOP4
79837: ARRAY
79838: IN
79839: IFFALSE 79878
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79841: NOP4
79845: PUSH
79846: NOP4
79850: PPUSH
79851: NOP4
79855: PPUSH
79856: NOP4
79860: PUSH
79861: NOP4
79865: ARRAY
79866: PUSH
79867: NOP4
79871: DIFF
79872: PPUSH
79873: NOP4
79877: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79878: NOP4
79882: PUSH
79883: NOP4
79887: PUSH
79888: NOP4
79892: ARRAY
79893: IN
79894: IFFALSE 79933
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79896: NOP4
79900: PUSH
79901: NOP4
79905: PPUSH
79906: NOP4
79910: PPUSH
79911: NOP4
79915: PUSH
79916: NOP4
79920: ARRAY
79921: PUSH
79922: NOP4
79926: DIFF
79927: PPUSH
79928: NOP4
79932: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79933: NOP4
79937: PUSH
79938: NOP4
79942: PUSH
79943: NOP4
79947: ARRAY
79948: IN
79949: IFFALSE 79988
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79951: NOP4
79955: PUSH
79956: NOP4
79960: PPUSH
79961: NOP4
79965: PPUSH
79966: NOP4
79970: PUSH
79971: NOP4
79975: ARRAY
79976: PUSH
79977: NOP4
79981: DIFF
79982: PPUSH
79983: NOP4
79987: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79988: NOP4
79992: PUSH
79993: NOP4
79997: PUSH
79998: NOP4
80002: ARRAY
80003: IN
80004: IFFALSE 80043
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80006: NOP4
80010: PUSH
80011: NOP4
80015: PPUSH
80016: NOP4
80020: PPUSH
80021: NOP4
80025: PUSH
80026: NOP4
80030: ARRAY
80031: PUSH
80032: NOP4
80036: DIFF
80037: PPUSH
80038: NOP4
80042: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80043: NOP4
80047: PUSH
80048: NOP4
80052: PUSH
80053: NOP4
80057: ARRAY
80058: IN
80059: IFFALSE 80098
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80061: NOP4
80065: PUSH
80066: NOP4
80070: PPUSH
80071: NOP4
80075: PPUSH
80076: NOP4
80080: PUSH
80081: NOP4
80085: ARRAY
80086: PUSH
80087: NOP4
80091: DIFF
80092: PPUSH
80093: NOP4
80097: ST_TO_ADDR
// end ; break ;
80098: GO 80102
// end ;
80100: GO 78748
80102: POP
80103: POP
// end ;
80104: LD_VAR 0 2
80108: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80109: LD_INT 0
80111: PPUSH
80112: PPUSH
80113: PPUSH
// if not mc_bases or not skirmish then
80114: NOP4
80118: NOT
80119: PUSH
80120: NOP4
80124: NOT
80125: OR
80126: IFFALSE 80130
// exit ;
80128: GO 80345
// for i = 1 to mc_bases do
80130: NOP4
80134: PUSH
80135: DOUBLE
80136: LD_INT 1
80138: DEC
80139: ST_TO_ADDR
80140: NOP4
80144: PUSH
80145: FOR_TO
80146: IFFALSE 80343
// begin if building in mc_construct_list [ i ] then
80148: NOP4
80152: PUSH
80153: NOP4
80157: PUSH
80158: NOP4
80162: ARRAY
80163: IN
80164: IFFALSE 80341
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80166: NOP4
80170: PUSH
80171: NOP4
80175: PPUSH
80176: NOP4
80180: PPUSH
80181: NOP4
80185: PUSH
80186: NOP4
80190: ARRAY
80191: PUSH
80192: NOP4
80196: DIFF
80197: PPUSH
80198: NOP4
80202: ST_TO_ADDR
// if building in mc_lab [ i ] then
80203: NOP4
80207: PUSH
80208: NOP4
80212: PUSH
80213: NOP4
80217: ARRAY
80218: IN
80219: IFFALSE 80274
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80221: NOP4
80225: PUSH
80226: NOP4
80230: PPUSH
80231: NOP4
80235: PPUSH
80236: NOP4
80240: PUSH
80241: NOP4
80245: ARRAY
80246: PPUSH
80247: LD_INT 1
80249: PPUSH
80250: NOP4
80254: PUSH
80255: NOP4
80259: ARRAY
80260: PPUSH
80261: LD_INT 0
80263: PPUSH
80264: NOP4
80268: PPUSH
80269: NOP4
80273: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80274: NOP4
80278: PUSH
80279: NOP4
80283: PUSH
80284: NOP4
80288: ARRAY
80289: IN
80290: NOT
80291: IFFALSE 80337
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80293: NOP4
80297: PUSH
80298: NOP4
80302: PPUSH
80303: NOP4
80307: PUSH
80308: NOP4
80312: PUSH
80313: NOP4
80317: ARRAY
80318: PUSH
80319: LD_INT 1
80321: PLUS
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PPUSH
80327: NOP4
80331: PPUSH
80332: NOP4
80336: ST_TO_ADDR
// exit ;
80337: POP
80338: POP
80339: GO 80345
// end ; end ;
80341: GO 80145
80343: POP
80344: POP
// end ;
80345: LD_VAR 0 2
80349: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80350: LD_INT 0
80352: PPUSH
80353: PPUSH
80354: PPUSH
80355: PPUSH
80356: PPUSH
80357: PPUSH
80358: PPUSH
// if not mc_bases or not skirmish then
80359: NOP4
80363: NOT
80364: PUSH
80365: NOP4
80369: NOT
80370: OR
80371: IFFALSE 80375
// exit ;
80373: GO 81036
// for i = 1 to mc_bases do
80375: NOP4
80379: PUSH
80380: DOUBLE
80381: LD_INT 1
80383: DEC
80384: ST_TO_ADDR
80385: NOP4
80389: PUSH
80390: FOR_TO
80391: IFFALSE 81034
// begin if building in mc_construct_list [ i ] then
80393: NOP4
80397: PUSH
80398: NOP4
80402: PUSH
80403: NOP4
80407: ARRAY
80408: IN
80409: IFFALSE 81032
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80411: NOP4
80415: PUSH
80416: NOP4
80420: PPUSH
80421: NOP4
80425: PPUSH
80426: NOP4
80430: PUSH
80431: NOP4
80435: ARRAY
80436: PUSH
80437: NOP4
80441: DIFF
80442: PPUSH
80443: NOP4
80447: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80448: NOP4
80452: PUSH
80453: NOP4
80457: PPUSH
80458: NOP4
80462: PUSH
80463: NOP4
80467: PUSH
80468: NOP4
80472: ARRAY
80473: PUSH
80474: LD_INT 1
80476: PLUS
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PPUSH
80482: NOP4
80486: PPUSH
80487: NOP4
80491: ST_TO_ADDR
// btype := GetBType ( building ) ;
80492: NOP4
80496: PUSH
80497: NOP4
80501: PPUSH
80502: NOP4
80506: ST_TO_ADDR
// side := GetSide ( building ) ;
80507: NOP4
80511: PUSH
80512: NOP4
80516: PPUSH
80517: NOP4
80521: ST_TO_ADDR
// if btype = b_lab then
80522: NOP4
80526: PUSH
80527: LD_INT 6
80529: EQUAL
80530: IFFALSE 80580
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80532: NOP4
80536: PUSH
80537: NOP4
80541: PPUSH
80542: NOP4
80546: PUSH
80547: NOP4
80551: PUSH
80552: NOP4
80556: ARRAY
80557: PUSH
80558: LD_INT 1
80560: PLUS
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PPUSH
80566: NOP4
80570: PPUSH
80571: NOP4
80575: ST_TO_ADDR
// exit ;
80576: POP
80577: POP
80578: GO 81036
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80580: NOP4
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: LD_INT 2
80590: PUSH
80591: LD_INT 4
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: LIST
80598: IN
80599: IFFALSE 80723
// begin if btype = b_armoury then
80601: NOP4
80605: PUSH
80606: LD_INT 4
80608: EQUAL
80609: IFFALSE 80619
// btype := b_barracks ;
80611: NOP4
80615: PUSH
80616: LD_INT 5
80618: ST_TO_ADDR
// if btype = b_depot then
80619: NOP4
80623: PUSH
80624: LD_INT 0
80626: EQUAL
80627: IFFALSE 80637
// btype := b_warehouse ;
80629: NOP4
80633: PUSH
80634: LD_INT 1
80636: ST_TO_ADDR
// if btype = b_workshop then
80637: NOP4
80641: PUSH
80642: LD_INT 2
80644: EQUAL
80645: IFFALSE 80655
// btype := b_factory ;
80647: NOP4
80651: PUSH
80652: LD_INT 3
80654: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80655: NOP4
80659: PPUSH
80660: NOP4
80664: PPUSH
80665: NOP4
80669: PUSH
80670: LD_INT 1
80672: EQUAL
80673: IFFALSE 80719
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80675: NOP4
80679: PUSH
80680: NOP4
80684: PPUSH
80685: NOP4
80689: PUSH
80690: NOP4
80694: PUSH
80695: NOP4
80699: ARRAY
80700: PUSH
80701: LD_INT 1
80703: PLUS
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PPUSH
80709: NOP4
80713: PPUSH
80714: NOP4
80718: ST_TO_ADDR
// exit ;
80719: POP
80720: POP
80721: GO 81036
// end ; if btype in [ b_bunker , b_turret ] then
80723: NOP4
80727: PUSH
80728: LD_INT 32
80730: PUSH
80731: LD_INT 33
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: IN
80738: IFFALSE 81028
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80740: NOP4
80744: PUSH
80745: NOP4
80749: PPUSH
80750: NOP4
80754: PUSH
80755: NOP4
80759: PUSH
80760: NOP4
80764: ARRAY
80765: PUSH
80766: LD_INT 1
80768: PLUS
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PPUSH
80774: NOP4
80778: PPUSH
80779: NOP4
80783: ST_TO_ADDR
// if btype = b_bunker then
80784: NOP4
80788: PUSH
80789: LD_INT 32
80791: EQUAL
80792: IFFALSE 81028
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80794: NOP4
80798: PUSH
80799: NOP4
80803: PPUSH
80804: NOP4
80808: PUSH
80809: NOP4
80813: PUSH
80814: NOP4
80818: ARRAY
80819: PUSH
80820: LD_INT 1
80822: PLUS
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PPUSH
80828: NOP4
80832: PPUSH
80833: NOP4
80837: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80838: NOP4
80842: PUSH
80843: NOP4
80847: PUSH
80848: NOP4
80852: ARRAY
80853: PPUSH
80854: LD_INT 25
80856: PUSH
80857: LD_INT 1
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 3
80866: PUSH
80867: LD_INT 54
80869: PUSH
80870: EMPTY
80871: LIST
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PPUSH
80881: NOP4
80885: ST_TO_ADDR
// if tmp then
80886: NOP4
80890: IFFALSE 80896
// exit ;
80892: POP
80893: POP
80894: GO 81036
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80896: NOP4
80900: PUSH
80901: NOP4
80905: PUSH
80906: NOP4
80910: ARRAY
80911: PPUSH
80912: LD_INT 2
80914: PUSH
80915: LD_INT 30
80917: PUSH
80918: LD_INT 4
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 30
80927: PUSH
80928: LD_INT 5
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: LIST
80939: PPUSH
80940: NOP4
80944: ST_TO_ADDR
// if not tmp then
80945: NOP4
80949: NOT
80950: IFFALSE 80956
// exit ;
80952: POP
80953: POP
80954: GO 81036
// for j in tmp do
80956: NOP4
80960: PUSH
80961: NOP4
80965: PUSH
80966: FOR_IN
80967: IFFALSE 81026
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80969: NOP4
80973: PUSH
80974: NOP4
80978: PPUSH
80979: NOP4
80983: PPUSH
80984: LD_INT 25
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PPUSH
80994: NOP4
80998: ST_TO_ADDR
// if units then
80999: NOP4
81003: IFFALSE 81024
// begin ComExitBuilding ( units [ 1 ] ) ;
81005: NOP4
81009: PUSH
81010: LD_INT 1
81012: ARRAY
81013: PPUSH
81014: NOP4
// exit ;
81018: POP
81019: POP
81020: POP
81021: POP
81022: GO 81036
// end ; end ;
81024: GO 80966
81026: POP
81027: POP
// end ; end ; exit ;
81028: POP
81029: POP
81030: GO 81036
// end ; end ;
81032: GO 80390
81034: POP
81035: POP
// end ;
81036: LD_VAR 0 2
81040: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81041: LD_INT 0
81043: PPUSH
81044: PPUSH
81045: PPUSH
81046: PPUSH
81047: PPUSH
81048: PPUSH
81049: PPUSH
// if not mc_bases or not skirmish then
81050: NOP4
81054: NOT
81055: PUSH
81056: NOP4
81060: NOT
81061: OR
81062: IFFALSE 81066
// exit ;
81064: GO 81331
// btype := GetBType ( building ) ;
81066: NOP4
81070: PUSH
81071: NOP4
81075: PPUSH
81076: NOP4
81080: ST_TO_ADDR
// x := GetX ( building ) ;
81081: NOP4
81085: PUSH
81086: NOP4
81090: PPUSH
81091: NOP4
81095: ST_TO_ADDR
// y := GetY ( building ) ;
81096: NOP4
81100: PUSH
81101: NOP4
81105: PPUSH
81106: NOP4
81110: ST_TO_ADDR
// d := GetDir ( building ) ;
81111: NOP4
81115: PUSH
81116: NOP4
81120: PPUSH
81121: NOP4
81125: ST_TO_ADDR
// for i = 1 to mc_bases do
81126: NOP4
81130: PUSH
81131: DOUBLE
81132: LD_INT 1
81134: DEC
81135: ST_TO_ADDR
81136: NOP4
81140: PUSH
81141: FOR_TO
81142: IFFALSE 81329
// begin if not mc_build_list [ i ] then
81144: NOP4
81148: PUSH
81149: NOP4
81153: ARRAY
81154: NOT
81155: IFFALSE 81159
// continue ;
81157: GO 81141
// for j := 1 to mc_build_list [ i ] do
81159: NOP4
81163: PUSH
81164: DOUBLE
81165: LD_INT 1
81167: DEC
81168: ST_TO_ADDR
81169: NOP4
81173: PUSH
81174: NOP4
81178: ARRAY
81179: PUSH
81180: FOR_TO
81181: IFFALSE 81325
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81183: NOP4
81187: PUSH
81188: NOP4
81192: PUSH
81193: NOP4
81197: PUSH
81198: NOP4
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: LIST
81207: LIST
81208: PPUSH
81209: NOP4
81213: PUSH
81214: NOP4
81218: ARRAY
81219: PUSH
81220: NOP4
81224: ARRAY
81225: PPUSH
81226: NOP4
81230: IFFALSE 81323
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81232: NOP4
81236: PUSH
81237: NOP4
81241: PPUSH
81242: NOP4
81246: PPUSH
81247: NOP4
81251: PUSH
81252: NOP4
81256: ARRAY
81257: PPUSH
81258: NOP4
81262: PPUSH
81263: NOP4
81267: PPUSH
81268: NOP4
81272: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81273: NOP4
81277: PUSH
81278: NOP4
81282: PPUSH
81283: NOP4
81287: PUSH
81288: NOP4
81292: PUSH
81293: NOP4
81297: ARRAY
81298: PUSH
81299: LD_INT 1
81301: PLUS
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PPUSH
81307: NOP4
81311: PPUSH
81312: NOP4
81316: ST_TO_ADDR
// exit ;
81317: POP
81318: POP
81319: POP
81320: POP
81321: GO 81331
// end ;
81323: GO 81180
81325: POP
81326: POP
// end ;
81327: GO 81141
81329: POP
81330: POP
// end ;
81331: LD_VAR 0 3
81335: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81336: LD_INT 0
81338: PPUSH
81339: PPUSH
81340: PPUSH
// if not mc_bases or not skirmish then
81341: NOP4
81345: NOT
81346: PUSH
81347: NOP4
81351: NOT
81352: OR
81353: IFFALSE 81357
// exit ;
81355: GO 81547
// for i = 1 to mc_bases do
81357: NOP4
81361: PUSH
81362: DOUBLE
81363: LD_INT 1
81365: DEC
81366: ST_TO_ADDR
81367: NOP4
81371: PUSH
81372: FOR_TO
81373: IFFALSE 81460
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81375: NOP4
81379: PUSH
81380: NOP4
81384: PUSH
81385: NOP4
81389: ARRAY
81390: IN
81391: PUSH
81392: NOP4
81396: PUSH
81397: NOP4
81401: PUSH
81402: NOP4
81406: ARRAY
81407: IN
81408: NOT
81409: AND
81410: IFFALSE 81458
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81412: NOP4
81416: PUSH
81417: NOP4
81421: PPUSH
81422: NOP4
81426: PUSH
81427: NOP4
81431: PUSH
81432: NOP4
81436: ARRAY
81437: PUSH
81438: LD_INT 1
81440: PLUS
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PPUSH
81446: NOP4
81450: PPUSH
81451: NOP4
81455: ST_TO_ADDR
// break ;
81456: GO 81460
// end ; end ;
81458: GO 81372
81460: POP
81461: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81462: NOP4
81466: PPUSH
81467: NOP4
81471: PUSH
81472: NOP4
81476: IN
81477: PUSH
81478: NOP4
81482: PPUSH
81483: NOP4
81487: PUSH
81488: LD_INT 5
81490: EQUAL
81491: AND
81492: PUSH
81493: NOP4
81497: PPUSH
81498: NOP4
81502: PUSH
81503: LD_INT 18
81505: NONEQUAL
81506: AND
81507: IFFALSE 81547
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81509: NOP4
81513: PPUSH
81514: NOP4
81518: PUSH
81519: LD_INT 5
81521: PUSH
81522: LD_INT 8
81524: PUSH
81525: LD_INT 9
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: LIST
81532: IN
81533: IFFALSE 81547
// SetClass ( unit , 1 ) ;
81535: NOP4
81539: PPUSH
81540: LD_INT 1
81542: PPUSH
81543: NOP4
// end ;
81547: LD_VAR 0 3
81551: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81552: LD_INT 0
81554: PPUSH
81555: PPUSH
// if not mc_bases or not skirmish then
81556: NOP4
81560: NOT
81561: PUSH
81562: NOP4
81566: NOT
81567: OR
81568: IFFALSE 81572
// exit ;
81570: GO 81688
// if GetLives ( abandoned_vehicle ) > 250 then
81572: NOP4
81576: PPUSH
81577: NOP4
81581: PUSH
81582: LD_INT 250
81584: GREATER
81585: IFFALSE 81589
// exit ;
81587: GO 81688
// for i = 1 to mc_bases do
81589: NOP4
81593: PUSH
81594: DOUBLE
81595: LD_INT 1
81597: DEC
81598: ST_TO_ADDR
81599: NOP4
81603: PUSH
81604: FOR_TO
81605: IFFALSE 81686
// begin if driver in mc_bases [ i ] then
81607: NOP4
81611: PUSH
81612: NOP4
81616: PUSH
81617: NOP4
81621: ARRAY
81622: IN
81623: IFFALSE 81684
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81625: NOP4
81629: PPUSH
81630: NOP4
81634: PUSH
81635: NOP4
81639: ARRAY
81640: PPUSH
81641: LD_INT 2
81643: PUSH
81644: LD_INT 30
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 30
81656: PUSH
81657: LD_INT 1
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: LIST
81668: PPUSH
81669: NOP4
81673: PUSH
81674: LD_INT 1
81676: ARRAY
81677: PPUSH
81678: NOP4
// break ;
81682: GO 81686
// end ; end ;
81684: GO 81604
81686: POP
81687: POP
// end ; end_of_file
81688: LD_VAR 0 5
81692: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
81693: LD_INT 0
81695: PPUSH
// ar_miner := 81 ;
81696: NOP4
81700: PUSH
81701: LD_INT 81
81703: ST_TO_ADDR
// ar_crane := 88 ;
81704: NOP4
81708: PUSH
81709: LD_INT 88
81711: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81712: NOP4
81716: PUSH
81717: LD_INT 89
81719: ST_TO_ADDR
// us_hack := 99 ;
81720: NOP4
81724: PUSH
81725: LD_INT 99
81727: ST_TO_ADDR
// us_artillery := 97 ;
81728: NOP4
81732: PUSH
81733: LD_INT 97
81735: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81736: NOP4
81740: PUSH
81741: LD_INT 91
81743: ST_TO_ADDR
// ar_mortar := 92 ;
81744: NOP4
81748: PUSH
81749: LD_INT 92
81751: ST_TO_ADDR
// ru_flamethrower := 93 ;
81752: NOP4
81756: PUSH
81757: LD_INT 93
81759: ST_TO_ADDR
// ru_radar := 98 ;
81760: NOP4
81764: PUSH
81765: LD_INT 98
81767: ST_TO_ADDR
// tech_Artillery := 80 ;
81768: NOP4
81772: PUSH
81773: LD_INT 80
81775: ST_TO_ADDR
// tech_RadMat := 81 ;
81776: NOP4
81780: PUSH
81781: LD_INT 81
81783: ST_TO_ADDR
// tech_BasicTools := 82 ;
81784: NOP4
81788: PUSH
81789: LD_INT 82
81791: ST_TO_ADDR
// tech_Cargo := 83 ;
81792: NOP4
81796: PUSH
81797: LD_INT 83
81799: ST_TO_ADDR
// tech_Track := 84 ;
81800: NOP4
81804: PUSH
81805: LD_INT 84
81807: ST_TO_ADDR
// tech_Crane := 85 ;
81808: NOP4
81812: PUSH
81813: LD_INT 85
81815: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81816: NOP4
81820: PUSH
81821: LD_INT 86
81823: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81824: NOP4
81828: PUSH
81829: LD_INT 87
81831: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81832: NOP4
81836: PUSH
81837: LD_INT 88
81839: ST_TO_ADDR
// end ;
81840: LD_VAR 0 1
81844: RET
// every 1 do
81845: GO 81847
81847: DISABLE
// InitGlobalVariables ; end_of_file
81848: NOP4
81852: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81853: LD_INT 0
81855: PPUSH
81856: PPUSH
81857: PPUSH
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
81862: PPUSH
81863: PPUSH
81864: PPUSH
81865: PPUSH
81866: PPUSH
81867: PPUSH
81868: PPUSH
81869: PPUSH
81870: PPUSH
81871: PPUSH
81872: PPUSH
81873: PPUSH
81874: PPUSH
81875: PPUSH
81876: PPUSH
81877: PPUSH
81878: PPUSH
81879: PPUSH
81880: PPUSH
81881: PPUSH
81882: PPUSH
81883: PPUSH
81884: PPUSH
81885: PPUSH
81886: PPUSH
81887: PPUSH
81888: PPUSH
// if not list then
81889: NOP4
81893: NOT
81894: IFFALSE 81898
// exit ;
81896: GO 86557
// base := list [ 1 ] ;
81898: NOP4
81902: PUSH
81903: NOP4
81907: PUSH
81908: LD_INT 1
81910: ARRAY
81911: ST_TO_ADDR
// group := list [ 2 ] ;
81912: NOP4
81916: PUSH
81917: NOP4
81921: PUSH
81922: LD_INT 2
81924: ARRAY
81925: ST_TO_ADDR
// path := list [ 3 ] ;
81926: NOP4
81930: PUSH
81931: NOP4
81935: PUSH
81936: LD_INT 3
81938: ARRAY
81939: ST_TO_ADDR
// flags := list [ 4 ] ;
81940: NOP4
81944: PUSH
81945: NOP4
81949: PUSH
81950: LD_INT 4
81952: ARRAY
81953: ST_TO_ADDR
// mined := [ ] ;
81954: NOP4
81958: PUSH
81959: EMPTY
81960: ST_TO_ADDR
// bombed := [ ] ;
81961: NOP4
81965: PUSH
81966: EMPTY
81967: ST_TO_ADDR
// healers := [ ] ;
81968: NOP4
81972: PUSH
81973: EMPTY
81974: ST_TO_ADDR
// to_heal := [ ] ;
81975: NOP4
81979: PUSH
81980: EMPTY
81981: ST_TO_ADDR
// repairs := [ ] ;
81982: NOP4
81986: PUSH
81987: EMPTY
81988: ST_TO_ADDR
// to_repair := [ ] ;
81989: NOP4
81993: PUSH
81994: EMPTY
81995: ST_TO_ADDR
// if not group or not path then
81996: NOP4
82000: NOT
82001: PUSH
82002: NOP4
82006: NOT
82007: OR
82008: IFFALSE 82012
// exit ;
82010: GO 86557
// side := GetSide ( group [ 1 ] ) ;
82012: NOP4
82016: PUSH
82017: NOP4
82021: PUSH
82022: LD_INT 1
82024: ARRAY
82025: PPUSH
82026: NOP4
82030: ST_TO_ADDR
// if flags then
82031: NOP4
82035: IFFALSE 82179
// begin f_ignore_area := flags [ 1 ] ;
82037: NOP4
82041: PUSH
82042: NOP4
82046: PUSH
82047: LD_INT 1
82049: ARRAY
82050: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82051: NOP4
82055: PUSH
82056: NOP4
82060: PUSH
82061: LD_INT 2
82063: ARRAY
82064: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82065: NOP4
82069: PUSH
82070: NOP4
82074: PUSH
82075: LD_INT 3
82077: ARRAY
82078: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82079: NOP4
82083: PUSH
82084: NOP4
82088: PUSH
82089: LD_INT 4
82091: ARRAY
82092: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82093: NOP4
82097: PUSH
82098: NOP4
82102: PUSH
82103: LD_INT 5
82105: ARRAY
82106: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82107: NOP4
82111: PUSH
82112: NOP4
82116: PUSH
82117: LD_INT 6
82119: ARRAY
82120: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82121: NOP4
82125: PUSH
82126: NOP4
82130: PUSH
82131: LD_INT 7
82133: ARRAY
82134: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82135: NOP4
82139: PUSH
82140: NOP4
82144: PUSH
82145: LD_INT 8
82147: ARRAY
82148: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82149: NOP4
82153: PUSH
82154: NOP4
82158: PUSH
82159: LD_INT 9
82161: ARRAY
82162: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82163: NOP4
82167: PUSH
82168: NOP4
82172: PUSH
82173: LD_INT 10
82175: ARRAY
82176: ST_TO_ADDR
// end else
82177: GO 82259
// begin f_ignore_area := false ;
82179: NOP4
82183: PUSH
82184: LD_INT 0
82186: ST_TO_ADDR
// f_capture := false ;
82187: NOP4
82191: PUSH
82192: LD_INT 0
82194: ST_TO_ADDR
// f_ignore_civ := false ;
82195: NOP4
82199: PUSH
82200: LD_INT 0
82202: ST_TO_ADDR
// f_murder := false ;
82203: NOP4
82207: PUSH
82208: LD_INT 0
82210: ST_TO_ADDR
// f_mines := false ;
82211: NOP4
82215: PUSH
82216: LD_INT 0
82218: ST_TO_ADDR
// f_repair := false ;
82219: NOP4
82223: PUSH
82224: LD_INT 0
82226: ST_TO_ADDR
// f_heal := false ;
82227: NOP4
82231: PUSH
82232: LD_INT 0
82234: ST_TO_ADDR
// f_spacetime := false ;
82235: NOP4
82239: PUSH
82240: LD_INT 0
82242: ST_TO_ADDR
// f_attack_depot := false ;
82243: NOP4
82247: PUSH
82248: LD_INT 0
82250: ST_TO_ADDR
// f_crawl := false ;
82251: NOP4
82255: PUSH
82256: LD_INT 0
82258: ST_TO_ADDR
// end ; if f_heal then
82259: NOP4
82263: IFFALSE 82290
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82265: NOP4
82269: PUSH
82270: NOP4
82274: PPUSH
82275: LD_INT 25
82277: PUSH
82278: LD_INT 4
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PPUSH
82285: NOP4
82289: ST_TO_ADDR
// if f_repair then
82290: NOP4
82294: IFFALSE 82321
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82296: NOP4
82300: PUSH
82301: NOP4
82305: PPUSH
82306: LD_INT 25
82308: PUSH
82309: LD_INT 3
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PPUSH
82316: NOP4
82320: ST_TO_ADDR
// units_path := [ ] ;
82321: NOP4
82325: PUSH
82326: EMPTY
82327: ST_TO_ADDR
// for i = 1 to group do
82328: NOP4
82332: PUSH
82333: DOUBLE
82334: LD_INT 1
82336: DEC
82337: ST_TO_ADDR
82338: NOP4
82342: PUSH
82343: FOR_TO
82344: IFFALSE 82373
// units_path := Replace ( units_path , i , path ) ;
82346: NOP4
82350: PUSH
82351: NOP4
82355: PPUSH
82356: NOP4
82360: PPUSH
82361: NOP4
82365: PPUSH
82366: NOP4
82370: ST_TO_ADDR
82371: GO 82343
82373: POP
82374: POP
// repeat for i = group downto 1 do
82375: NOP4
82379: PUSH
82380: DOUBLE
82381: NOP4
82385: INC
82386: ST_TO_ADDR
82387: LD_INT 1
82389: PUSH
82390: FOR_DOWNTO
82391: IFFALSE 86513
// begin wait ( 5 ) ;
82393: LD_INT 5
82395: PPUSH
82396: NOP4
// tmp := [ ] ;
82400: NOP4
82404: PUSH
82405: EMPTY
82406: ST_TO_ADDR
// attacking := false ;
82407: NOP4
82411: PUSH
82412: LD_INT 0
82414: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82415: NOP4
82419: PUSH
82420: NOP4
82424: ARRAY
82425: PPUSH
82426: NOP4
82430: PUSH
82431: NOP4
82435: PUSH
82436: NOP4
82440: ARRAY
82441: NOT
82442: OR
82443: IFFALSE 82552
// begin if GetType ( group [ i ] ) = unit_human then
82445: NOP4
82449: PUSH
82450: NOP4
82454: ARRAY
82455: PPUSH
82456: NOP4
82460: PUSH
82461: LD_INT 1
82463: EQUAL
82464: IFFALSE 82510
// begin to_heal := to_heal diff group [ i ] ;
82466: NOP4
82470: PUSH
82471: NOP4
82475: PUSH
82476: NOP4
82480: PUSH
82481: NOP4
82485: ARRAY
82486: DIFF
82487: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82488: NOP4
82492: PUSH
82493: NOP4
82497: PUSH
82498: NOP4
82502: PUSH
82503: NOP4
82507: ARRAY
82508: DIFF
82509: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82510: NOP4
82514: PUSH
82515: NOP4
82519: PPUSH
82520: NOP4
82524: PPUSH
82525: NOP4
82529: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82530: NOP4
82534: PUSH
82535: NOP4
82539: PPUSH
82540: NOP4
82544: PPUSH
82545: NOP4
82549: ST_TO_ADDR
// continue ;
82550: GO 82390
// end ; if f_repair then
82552: NOP4
82556: IFFALSE 83045
// begin if GetType ( group [ i ] ) = unit_vehicle then
82558: NOP4
82562: PUSH
82563: NOP4
82567: ARRAY
82568: PPUSH
82569: NOP4
82573: PUSH
82574: LD_INT 2
82576: EQUAL
82577: IFFALSE 82767
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82579: NOP4
82583: PUSH
82584: NOP4
82588: ARRAY
82589: PPUSH
82590: NOP4
82594: PUSH
82595: LD_INT 700
82597: LESS
82598: PUSH
82599: NOP4
82603: PUSH
82604: NOP4
82608: ARRAY
82609: PUSH
82610: NOP4
82614: IN
82615: NOT
82616: AND
82617: IFFALSE 82641
// to_repair := to_repair union group [ i ] ;
82619: NOP4
82623: PUSH
82624: NOP4
82628: PUSH
82629: NOP4
82633: PUSH
82634: NOP4
82638: ARRAY
82639: UNION
82640: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82641: NOP4
82645: PUSH
82646: NOP4
82650: ARRAY
82651: PPUSH
82652: NOP4
82656: PUSH
82657: LD_INT 1000
82659: EQUAL
82660: PUSH
82661: NOP4
82665: PUSH
82666: NOP4
82670: ARRAY
82671: PUSH
82672: NOP4
82676: IN
82677: AND
82678: IFFALSE 82702
// to_repair := to_repair diff group [ i ] ;
82680: NOP4
82684: PUSH
82685: NOP4
82689: PUSH
82690: NOP4
82694: PUSH
82695: NOP4
82699: ARRAY
82700: DIFF
82701: ST_TO_ADDR
// if group [ i ] in to_repair then
82702: NOP4
82706: PUSH
82707: NOP4
82711: ARRAY
82712: PUSH
82713: NOP4
82717: IN
82718: IFFALSE 82765
// begin if not IsInArea ( group [ i ] , f_repair ) then
82720: NOP4
82724: PUSH
82725: NOP4
82729: ARRAY
82730: PPUSH
82731: NOP4
82735: PPUSH
82736: NOP4
82740: NOT
82741: IFFALSE 82763
// ComMoveToArea ( group [ i ] , f_repair ) ;
82743: NOP4
82747: PUSH
82748: NOP4
82752: ARRAY
82753: PPUSH
82754: NOP4
82758: PPUSH
82759: NOP4
// continue ;
82763: GO 82390
// end ; end else
82765: GO 83045
// if group [ i ] in repairs then
82767: NOP4
82771: PUSH
82772: NOP4
82776: ARRAY
82777: PUSH
82778: NOP4
82782: IN
82783: IFFALSE 83045
// begin if IsInUnit ( group [ i ] ) then
82785: NOP4
82789: PUSH
82790: NOP4
82794: ARRAY
82795: PPUSH
82796: NOP4
82800: IFFALSE 82868
// begin z := IsInUnit ( group [ i ] ) ;
82802: NOP4
82806: PUSH
82807: NOP4
82811: PUSH
82812: NOP4
82816: ARRAY
82817: PPUSH
82818: NOP4
82822: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82823: NOP4
82827: PUSH
82828: NOP4
82832: IN
82833: PUSH
82834: NOP4
82838: PPUSH
82839: NOP4
82843: PPUSH
82844: NOP4
82848: AND
82849: IFFALSE 82866
// ComExitVehicle ( group [ i ] ) ;
82851: NOP4
82855: PUSH
82856: NOP4
82860: ARRAY
82861: PPUSH
82862: NOP4
// end else
82866: GO 83045
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82868: NOP4
82872: PUSH
82873: NOP4
82877: PPUSH
82878: LD_INT 95
82880: PUSH
82881: NOP4
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 58
82892: PUSH
82893: EMPTY
82894: LIST
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PPUSH
82900: NOP4
82904: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82905: NOP4
82909: PUSH
82910: NOP4
82914: ARRAY
82915: PPUSH
82916: NOP4
82920: NOT
82921: IFFALSE 83043
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82923: NOP4
82927: PUSH
82928: NOP4
82932: PPUSH
82933: NOP4
82937: PUSH
82938: NOP4
82942: ARRAY
82943: PPUSH
82944: NOP4
82948: ST_TO_ADDR
// if not x then
82949: NOP4
82953: NOT
82954: IFFALSE 82958
// continue ;
82956: GO 82390
// if GetLives ( x ) < 1000 then
82958: NOP4
82962: PPUSH
82963: NOP4
82967: PUSH
82968: LD_INT 1000
82970: LESS
82971: IFFALSE 82995
// ComRepairVehicle ( group [ i ] , x ) else
82973: NOP4
82977: PUSH
82978: NOP4
82982: ARRAY
82983: PPUSH
82984: NOP4
82988: PPUSH
82989: NOP4
82993: GO 83043
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82995: NOP4
82999: PUSH
83000: NOP4
83004: PUSH
83005: NOP4
83009: ARRAY
83010: PPUSH
83011: NOP4
83015: PUSH
83016: LD_INT 1000
83018: LESS
83019: AND
83020: NOT
83021: IFFALSE 83043
// ComEnterUnit ( group [ i ] , x ) ;
83023: NOP4
83027: PUSH
83028: NOP4
83032: ARRAY
83033: PPUSH
83034: NOP4
83038: PPUSH
83039: NOP4
// end ; continue ;
83043: GO 82390
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83045: NOP4
83049: PUSH
83050: NOP4
83054: PUSH
83055: NOP4
83059: ARRAY
83060: PPUSH
83061: NOP4
83065: PUSH
83066: LD_INT 1
83068: EQUAL
83069: AND
83070: IFFALSE 83548
// begin if group [ i ] in healers then
83072: NOP4
83076: PUSH
83077: NOP4
83081: ARRAY
83082: PUSH
83083: NOP4
83087: IN
83088: IFFALSE 83361
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83090: NOP4
83094: PUSH
83095: NOP4
83099: ARRAY
83100: PPUSH
83101: NOP4
83105: PPUSH
83106: NOP4
83110: NOT
83111: PUSH
83112: NOP4
83116: PUSH
83117: NOP4
83121: ARRAY
83122: PPUSH
83123: NOP4
83127: NOT
83128: AND
83129: IFFALSE 83153
// ComMoveToArea ( group [ i ] , f_heal ) else
83131: NOP4
83135: PUSH
83136: NOP4
83140: ARRAY
83141: PPUSH
83142: NOP4
83146: PPUSH
83147: NOP4
83151: GO 83359
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83153: NOP4
83157: PUSH
83158: NOP4
83162: ARRAY
83163: PPUSH
83164: NOP4
83168: PPUSH
83169: NOP4
83173: PUSH
83174: LD_INT 1000
83176: EQUAL
83177: IFFALSE 83196
// ComStop ( group [ i ] ) else
83179: NOP4
83183: PUSH
83184: NOP4
83188: ARRAY
83189: PPUSH
83190: NOP4
83194: GO 83359
// if not HasTask ( group [ i ] ) and to_heal then
83196: NOP4
83200: PUSH
83201: NOP4
83205: ARRAY
83206: PPUSH
83207: NOP4
83211: NOT
83212: PUSH
83213: NOP4
83217: AND
83218: IFFALSE 83359
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83220: NOP4
83224: PUSH
83225: NOP4
83229: PPUSH
83230: LD_INT 3
83232: PUSH
83233: LD_INT 54
83235: PUSH
83236: EMPTY
83237: LIST
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PPUSH
83243: NOP4
83247: PPUSH
83248: NOP4
83252: PUSH
83253: NOP4
83257: ARRAY
83258: PPUSH
83259: NOP4
83263: ST_TO_ADDR
// if z then
83264: NOP4
83268: IFFALSE 83359
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83270: LD_INT 91
83272: PUSH
83273: NOP4
83277: PUSH
83278: LD_INT 10
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: LIST
83285: PUSH
83286: LD_INT 81
83288: PUSH
83289: NOP4
83293: PPUSH
83294: NOP4
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PPUSH
83307: NOP4
83311: PUSH
83312: LD_INT 0
83314: EQUAL
83315: IFFALSE 83339
// ComHeal ( group [ i ] , z ) else
83317: NOP4
83321: PUSH
83322: NOP4
83326: ARRAY
83327: PPUSH
83328: NOP4
83332: PPUSH
83333: NOP4
83337: GO 83359
// ComMoveToArea ( group [ i ] , f_heal ) ;
83339: NOP4
83343: PUSH
83344: NOP4
83348: ARRAY
83349: PPUSH
83350: NOP4
83354: PPUSH
83355: NOP4
// end ; continue ;
83359: GO 82390
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83361: NOP4
83365: PUSH
83366: NOP4
83370: ARRAY
83371: PPUSH
83372: NOP4
83376: PUSH
83377: LD_INT 700
83379: LESS
83380: PUSH
83381: NOP4
83385: PUSH
83386: NOP4
83390: ARRAY
83391: PUSH
83392: NOP4
83396: IN
83397: NOT
83398: AND
83399: IFFALSE 83423
// to_heal := to_heal union group [ i ] ;
83401: NOP4
83405: PUSH
83406: NOP4
83410: PUSH
83411: NOP4
83415: PUSH
83416: NOP4
83420: ARRAY
83421: UNION
83422: ST_TO_ADDR
// if group [ i ] in to_heal then
83423: NOP4
83427: PUSH
83428: NOP4
83432: ARRAY
83433: PUSH
83434: NOP4
83438: IN
83439: IFFALSE 83548
// begin if GetLives ( group [ i ] ) = 1000 then
83441: NOP4
83445: PUSH
83446: NOP4
83450: ARRAY
83451: PPUSH
83452: NOP4
83456: PUSH
83457: LD_INT 1000
83459: EQUAL
83460: IFFALSE 83486
// to_heal := to_heal diff group [ i ] else
83462: NOP4
83466: PUSH
83467: NOP4
83471: PUSH
83472: NOP4
83476: PUSH
83477: NOP4
83481: ARRAY
83482: DIFF
83483: ST_TO_ADDR
83484: GO 83548
// begin if not IsInArea ( group [ i ] , to_heal ) then
83486: NOP4
83490: PUSH
83491: NOP4
83495: ARRAY
83496: PPUSH
83497: NOP4
83501: PPUSH
83502: NOP4
83506: NOT
83507: IFFALSE 83531
// ComMoveToArea ( group [ i ] , f_heal ) else
83509: NOP4
83513: PUSH
83514: NOP4
83518: ARRAY
83519: PPUSH
83520: NOP4
83524: PPUSH
83525: NOP4
83529: GO 83546
// ComHold ( group [ i ] ) ;
83531: NOP4
83535: PUSH
83536: NOP4
83540: ARRAY
83541: PPUSH
83542: NOP4
// continue ;
83546: GO 82390
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83548: NOP4
83552: PUSH
83553: NOP4
83557: ARRAY
83558: PPUSH
83559: LD_INT 10
83561: PPUSH
83562: NOP4
83566: NOT
83567: PUSH
83568: NOP4
83572: PUSH
83573: NOP4
83577: ARRAY
83578: PUSH
83579: EMPTY
83580: EQUAL
83581: NOT
83582: AND
83583: IFFALSE 83849
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83585: NOP4
83589: PUSH
83590: NOP4
83594: ARRAY
83595: PPUSH
83596: NOP4
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 2
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: IN
83611: IFFALSE 83652
// if GetFuel ( group [ i ] ) < 10 then
83613: NOP4
83617: PUSH
83618: NOP4
83622: ARRAY
83623: PPUSH
83624: NOP4
83628: PUSH
83629: LD_INT 10
83631: LESS
83632: IFFALSE 83652
// SetFuel ( group [ i ] , 12 ) ;
83634: NOP4
83638: PUSH
83639: NOP4
83643: ARRAY
83644: PPUSH
83645: LD_INT 12
83647: PPUSH
83648: NOP4
// if units_path [ i ] then
83652: NOP4
83656: PUSH
83657: NOP4
83661: ARRAY
83662: IFFALSE 83847
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83664: NOP4
83668: PUSH
83669: NOP4
83673: ARRAY
83674: PPUSH
83675: NOP4
83679: PUSH
83680: NOP4
83684: ARRAY
83685: PUSH
83686: LD_INT 1
83688: ARRAY
83689: PUSH
83690: LD_INT 1
83692: ARRAY
83693: PPUSH
83694: NOP4
83698: PUSH
83699: NOP4
83703: ARRAY
83704: PUSH
83705: LD_INT 1
83707: ARRAY
83708: PUSH
83709: LD_INT 2
83711: ARRAY
83712: PPUSH
83713: NOP4
83717: PUSH
83718: LD_INT 6
83720: GREATER
83721: IFFALSE 83796
// begin if not HasTask ( group [ i ] ) then
83723: NOP4
83727: PUSH
83728: NOP4
83732: ARRAY
83733: PPUSH
83734: NOP4
83738: NOT
83739: IFFALSE 83794
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83741: NOP4
83745: PUSH
83746: NOP4
83750: ARRAY
83751: PPUSH
83752: NOP4
83756: PUSH
83757: NOP4
83761: ARRAY
83762: PUSH
83763: LD_INT 1
83765: ARRAY
83766: PUSH
83767: LD_INT 1
83769: ARRAY
83770: PPUSH
83771: NOP4
83775: PUSH
83776: NOP4
83780: ARRAY
83781: PUSH
83782: LD_INT 1
83784: ARRAY
83785: PUSH
83786: LD_INT 2
83788: ARRAY
83789: PPUSH
83790: NOP4
// end else
83794: GO 83847
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83796: NOP4
83800: PUSH
83801: NOP4
83805: PUSH
83806: NOP4
83810: ARRAY
83811: PPUSH
83812: LD_INT 1
83814: PPUSH
83815: NOP4
83819: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83820: NOP4
83824: PUSH
83825: NOP4
83829: PPUSH
83830: NOP4
83834: PPUSH
83835: NOP4
83839: PPUSH
83840: NOP4
83844: ST_TO_ADDR
// continue ;
83845: GO 82390
// end ; end ; end else
83847: GO 86511
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83849: NOP4
83853: PUSH
83854: LD_INT 81
83856: PUSH
83857: NOP4
83861: PUSH
83862: NOP4
83866: ARRAY
83867: PPUSH
83868: NOP4
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PPUSH
83877: NOP4
83881: ST_TO_ADDR
// if not tmp then
83882: NOP4
83886: NOT
83887: IFFALSE 83891
// continue ;
83889: GO 82390
// if f_ignore_area then
83891: NOP4
83895: IFFALSE 83983
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83897: NOP4
83901: PUSH
83902: NOP4
83906: PPUSH
83907: LD_INT 3
83909: PUSH
83910: LD_INT 92
83912: PUSH
83913: NOP4
83917: PUSH
83918: LD_INT 1
83920: ARRAY
83921: PUSH
83922: NOP4
83926: PUSH
83927: LD_INT 2
83929: ARRAY
83930: PUSH
83931: NOP4
83935: PUSH
83936: LD_INT 3
83938: ARRAY
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PPUSH
83950: NOP4
83954: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83955: NOP4
83959: PUSH
83960: NOP4
83964: DIFF
83965: IFFALSE 83983
// tmp := tmp diff tmp2 ;
83967: NOP4
83971: PUSH
83972: NOP4
83976: PUSH
83977: NOP4
83981: DIFF
83982: ST_TO_ADDR
// end ; if not f_murder then
83983: NOP4
83987: NOT
83988: IFFALSE 84046
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83990: NOP4
83994: PUSH
83995: NOP4
83999: PPUSH
84000: LD_INT 3
84002: PUSH
84003: LD_INT 50
84005: PUSH
84006: EMPTY
84007: LIST
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PPUSH
84013: NOP4
84017: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84018: NOP4
84022: PUSH
84023: NOP4
84027: DIFF
84028: IFFALSE 84046
// tmp := tmp diff tmp2 ;
84030: NOP4
84034: PUSH
84035: NOP4
84039: PUSH
84040: NOP4
84044: DIFF
84045: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84046: NOP4
84050: PUSH
84051: NOP4
84055: PUSH
84056: NOP4
84060: ARRAY
84061: PPUSH
84062: NOP4
84066: PPUSH
84067: LD_INT 1
84069: PPUSH
84070: LD_INT 1
84072: PPUSH
84073: NOP4
84077: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84078: NOP4
84082: PUSH
84083: NOP4
84087: ARRAY
84088: PPUSH
84089: NOP4
84093: PUSH
84094: LD_INT 1
84096: EQUAL
84097: IFFALSE 84545
// begin if WantPlant ( group [ i ] ) then
84099: NOP4
84103: PUSH
84104: NOP4
84108: ARRAY
84109: PPUSH
84110: NOP4
84114: IFFALSE 84118
// continue ;
84116: GO 82390
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84118: NOP4
84122: PUSH
84123: NOP4
84127: PUSH
84128: NOP4
84132: ARRAY
84133: PPUSH
84134: NOP4
84138: NOT
84139: AND
84140: PUSH
84141: NOP4
84145: PUSH
84146: LD_INT 1
84148: ARRAY
84149: PUSH
84150: NOP4
84154: PPUSH
84155: LD_INT 21
84157: PUSH
84158: LD_INT 2
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 58
84167: PUSH
84168: EMPTY
84169: LIST
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PPUSH
84175: NOP4
84179: IN
84180: AND
84181: IFFALSE 84217
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84183: NOP4
84187: PUSH
84188: NOP4
84192: ARRAY
84193: PPUSH
84194: NOP4
84198: PUSH
84199: LD_INT 1
84201: ARRAY
84202: PPUSH
84203: NOP4
// attacking := true ;
84207: NOP4
84211: PUSH
84212: LD_INT 1
84214: ST_TO_ADDR
// continue ;
84215: GO 82390
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84217: NOP4
84221: PUSH
84222: NOP4
84226: PUSH
84227: NOP4
84231: ARRAY
84232: PPUSH
84233: NOP4
84237: PUSH
84238: LD_INT 1
84240: EQUAL
84241: AND
84242: PUSH
84243: NOP4
84247: PUSH
84248: NOP4
84252: ARRAY
84253: PPUSH
84254: NOP4
84258: PUSH
84259: LD_INT 800
84261: LESS
84262: AND
84263: PUSH
84264: NOP4
84268: PUSH
84269: NOP4
84273: ARRAY
84274: PPUSH
84275: NOP4
84279: NOT
84280: AND
84281: IFFALSE 84298
// ComCrawl ( group [ i ] ) ;
84283: NOP4
84287: PUSH
84288: NOP4
84292: ARRAY
84293: PPUSH
84294: NOP4
// if f_mines then
84298: NOP4
84302: IFFALSE 84545
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84304: NOP4
84308: PUSH
84309: LD_INT 1
84311: ARRAY
84312: PPUSH
84313: NOP4
84317: PUSH
84318: LD_INT 3
84320: EQUAL
84321: PUSH
84322: NOP4
84326: PUSH
84327: LD_INT 1
84329: ARRAY
84330: PUSH
84331: NOP4
84335: IN
84336: NOT
84337: AND
84338: IFFALSE 84545
// begin x := GetX ( tmp [ 1 ] ) ;
84340: NOP4
84344: PUSH
84345: NOP4
84349: PUSH
84350: LD_INT 1
84352: ARRAY
84353: PPUSH
84354: NOP4
84358: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84359: NOP4
84363: PUSH
84364: NOP4
84368: PUSH
84369: LD_INT 1
84371: ARRAY
84372: PPUSH
84373: NOP4
84377: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84378: NOP4
84382: PUSH
84383: NOP4
84387: PUSH
84388: NOP4
84392: ARRAY
84393: PPUSH
84394: NOP4
84398: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84399: NOP4
84403: PUSH
84404: NOP4
84408: ARRAY
84409: PPUSH
84410: NOP4
84414: PPUSH
84415: NOP4
84419: PPUSH
84420: NOP4
84424: PUSH
84425: LD_INT 1
84427: ARRAY
84428: PPUSH
84429: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84433: NOP4
84437: PUSH
84438: NOP4
84442: ARRAY
84443: PPUSH
84444: NOP4
84448: PPUSH
84449: NOP4
84453: PPUSH
84454: LD_INT 7
84456: PPUSH
84457: NOP4
84461: PPUSH
84462: NOP4
84466: PPUSH
84467: NOP4
84471: PPUSH
84472: LD_INT 7
84474: PPUSH
84475: NOP4
84479: PPUSH
84480: NOP4
// SetTag ( group [ i ] , 71 ) ;
84484: NOP4
84488: PUSH
84489: NOP4
84493: ARRAY
84494: PPUSH
84495: LD_INT 71
84497: PPUSH
84498: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84502: NOP4
84506: PUSH
84507: NOP4
84511: PPUSH
84512: NOP4
84516: PUSH
84517: LD_INT 1
84519: PLUS
84520: PPUSH
84521: NOP4
84525: PUSH
84526: LD_INT 1
84528: ARRAY
84529: PPUSH
84530: NOP4
84534: ST_TO_ADDR
// attacking := true ;
84535: NOP4
84539: PUSH
84540: LD_INT 1
84542: ST_TO_ADDR
// continue ;
84543: GO 82390
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84545: NOP4
84549: PUSH
84550: NOP4
84554: ARRAY
84555: PPUSH
84556: NOP4
84560: PUSH
84561: LD_INT 17
84563: EQUAL
84564: PUSH
84565: NOP4
84569: PUSH
84570: NOP4
84574: ARRAY
84575: PPUSH
84576: NOP4
84580: PUSH
84581: LD_INT 71
84583: EQUAL
84584: NOT
84585: AND
84586: IFFALSE 84732
// begin attacking := false ;
84588: NOP4
84592: PUSH
84593: LD_INT 0
84595: ST_TO_ADDR
// k := 5 ;
84596: NOP4
84600: PUSH
84601: LD_INT 5
84603: ST_TO_ADDR
// if tmp < k then
84604: NOP4
84608: PUSH
84609: NOP4
84613: LESS
84614: IFFALSE 84626
// k := tmp ;
84616: NOP4
84620: PUSH
84621: NOP4
84625: ST_TO_ADDR
// for j = 1 to k do
84626: NOP4
84630: PUSH
84631: DOUBLE
84632: LD_INT 1
84634: DEC
84635: ST_TO_ADDR
84636: NOP4
84640: PUSH
84641: FOR_TO
84642: IFFALSE 84730
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84644: NOP4
84648: PUSH
84649: NOP4
84653: ARRAY
84654: PUSH
84655: NOP4
84659: PPUSH
84660: LD_INT 58
84662: PUSH
84663: EMPTY
84664: LIST
84665: PPUSH
84666: NOP4
84670: IN
84671: NOT
84672: IFFALSE 84728
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84674: NOP4
84678: PUSH
84679: NOP4
84683: ARRAY
84684: PPUSH
84685: NOP4
84689: PUSH
84690: NOP4
84694: ARRAY
84695: PPUSH
84696: NOP4
// attacking := true ;
84700: NOP4
84704: PUSH
84705: LD_INT 1
84707: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84708: NOP4
84712: PUSH
84713: NOP4
84717: ARRAY
84718: PPUSH
84719: LD_INT 71
84721: PPUSH
84722: NOP4
// continue ;
84726: GO 84641
// end ; end ;
84728: GO 84641
84730: POP
84731: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84732: NOP4
84736: PUSH
84737: NOP4
84741: ARRAY
84742: PPUSH
84743: NOP4
84747: PUSH
84748: LD_INT 8
84750: EQUAL
84751: PUSH
84752: NOP4
84756: PUSH
84757: NOP4
84761: ARRAY
84762: PPUSH
84763: NOP4
84767: PUSH
84768: LD_INT 28
84770: PUSH
84771: LD_INT 45
84773: PUSH
84774: LD_INT 7
84776: PUSH
84777: LD_INT 47
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: IN
84786: OR
84787: IFFALSE 85043
// begin attacking := false ;
84789: NOP4
84793: PUSH
84794: LD_INT 0
84796: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84797: NOP4
84801: PUSH
84802: LD_INT 1
84804: ARRAY
84805: PPUSH
84806: NOP4
84810: PUSH
84811: LD_INT 32
84813: PUSH
84814: LD_INT 31
84816: PUSH
84817: LD_INT 33
84819: PUSH
84820: LD_INT 4
84822: PUSH
84823: LD_INT 5
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: IN
84833: IFFALSE 85019
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84835: NOP4
84839: PUSH
84840: NOP4
84844: PUSH
84845: LD_INT 1
84847: ARRAY
84848: PPUSH
84849: NOP4
84853: PPUSH
84854: NOP4
84858: PUSH
84859: LD_INT 1
84861: ARRAY
84862: PPUSH
84863: NOP4
84867: PPUSH
84868: NOP4
84872: PUSH
84873: LD_INT 1
84875: ARRAY
84876: PPUSH
84877: NOP4
84881: PPUSH
84882: NOP4
84886: PUSH
84887: LD_INT 1
84889: ARRAY
84890: PPUSH
84891: NOP4
84895: PPUSH
84896: NOP4
84900: PUSH
84901: LD_INT 1
84903: ARRAY
84904: PPUSH
84905: NOP4
84909: PPUSH
84910: LD_INT 0
84912: PPUSH
84913: NOP4
84917: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84918: NOP4
84922: PUSH
84923: NOP4
84927: PUSH
84928: NOP4
84932: ARRAY
84933: PPUSH
84934: NOP4
84938: PPUSH
84939: NOP4
84943: ST_TO_ADDR
// if j then
84944: NOP4
84948: IFFALSE 85017
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84950: NOP4
84954: PUSH
84955: LD_INT 1
84957: ARRAY
84958: PPUSH
84959: NOP4
84963: PUSH
84964: LD_INT 2
84966: ARRAY
84967: PPUSH
84968: NOP4
84972: IFFALSE 85017
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84974: NOP4
84978: PUSH
84979: NOP4
84983: ARRAY
84984: PPUSH
84985: NOP4
84989: PUSH
84990: LD_INT 1
84992: ARRAY
84993: PPUSH
84994: NOP4
84998: PUSH
84999: LD_INT 2
85001: ARRAY
85002: PPUSH
85003: NOP4
// attacking := true ;
85007: NOP4
85011: PUSH
85012: LD_INT 1
85014: ST_TO_ADDR
// continue ;
85015: GO 82390
// end ; end else
85017: GO 85043
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85019: NOP4
85023: PUSH
85024: NOP4
85028: ARRAY
85029: PPUSH
85030: NOP4
85034: PUSH
85035: LD_INT 1
85037: ARRAY
85038: PPUSH
85039: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85043: NOP4
85047: PUSH
85048: NOP4
85052: ARRAY
85053: PPUSH
85054: NOP4
85058: PUSH
85059: LD_INT 11
85061: EQUAL
85062: IFFALSE 85340
// begin k := 10 ;
85064: NOP4
85068: PUSH
85069: LD_INT 10
85071: ST_TO_ADDR
// x := 0 ;
85072: NOP4
85076: PUSH
85077: LD_INT 0
85079: ST_TO_ADDR
// if tmp < k then
85080: NOP4
85084: PUSH
85085: NOP4
85089: LESS
85090: IFFALSE 85102
// k := tmp ;
85092: NOP4
85096: PUSH
85097: NOP4
85101: ST_TO_ADDR
// for j = k downto 1 do
85102: NOP4
85106: PUSH
85107: DOUBLE
85108: NOP4
85112: INC
85113: ST_TO_ADDR
85114: LD_INT 1
85116: PUSH
85117: FOR_DOWNTO
85118: IFFALSE 85193
// begin if GetType ( tmp [ j ] ) = unit_human then
85120: NOP4
85124: PUSH
85125: NOP4
85129: ARRAY
85130: PPUSH
85131: NOP4
85135: PUSH
85136: LD_INT 1
85138: EQUAL
85139: IFFALSE 85191
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85141: NOP4
85145: PUSH
85146: NOP4
85150: ARRAY
85151: PPUSH
85152: NOP4
85156: PUSH
85157: NOP4
85161: ARRAY
85162: PPUSH
85163: NOP4
// x := tmp [ j ] ;
85167: NOP4
85171: PUSH
85172: NOP4
85176: PUSH
85177: NOP4
85181: ARRAY
85182: ST_TO_ADDR
// attacking := true ;
85183: NOP4
85187: PUSH
85188: LD_INT 1
85190: ST_TO_ADDR
// end ; end ;
85191: GO 85117
85193: POP
85194: POP
// if not x then
85195: NOP4
85199: NOT
85200: IFFALSE 85340
// begin attacking := true ;
85202: NOP4
85206: PUSH
85207: LD_INT 1
85209: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85210: NOP4
85214: PUSH
85215: NOP4
85219: ARRAY
85220: PPUSH
85221: NOP4
85225: PPUSH
85226: NOP4
85230: PUSH
85231: NOP4
85235: ARRAY
85236: PPUSH
85237: NOP4
85241: PPUSH
85242: NOP4
85246: PUSH
85247: LD_INT 2
85249: ARRAY
85250: PUSH
85251: NOP4
85255: PUSH
85256: LD_INT 1
85258: ARRAY
85259: PPUSH
85260: NOP4
85264: PPUSH
85265: NOP4
85269: PUSH
85270: LD_INT 1
85272: ARRAY
85273: PPUSH
85274: NOP4
85278: PPUSH
85279: NOP4
85283: PUSH
85284: LD_INT 2
85286: ARRAY
85287: EQUAL
85288: IFFALSE 85316
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85290: NOP4
85294: PUSH
85295: NOP4
85299: ARRAY
85300: PPUSH
85301: NOP4
85305: PUSH
85306: LD_INT 1
85308: ARRAY
85309: PPUSH
85310: NOP4
85314: GO 85340
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85316: NOP4
85320: PUSH
85321: NOP4
85325: ARRAY
85326: PPUSH
85327: NOP4
85331: PUSH
85332: LD_INT 1
85334: ARRAY
85335: PPUSH
85336: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85340: NOP4
85344: PUSH
85345: NOP4
85349: ARRAY
85350: PPUSH
85351: NOP4
85355: PUSH
85356: LD_INT 29
85358: EQUAL
85359: IFFALSE 85725
// begin if WantsToAttack ( group [ i ] ) in bombed then
85361: NOP4
85365: PUSH
85366: NOP4
85370: ARRAY
85371: PPUSH
85372: NOP4
85376: PUSH
85377: NOP4
85381: IN
85382: IFFALSE 85386
// continue ;
85384: GO 82390
// k := 8 ;
85386: NOP4
85390: PUSH
85391: LD_INT 8
85393: ST_TO_ADDR
// x := 0 ;
85394: NOP4
85398: PUSH
85399: LD_INT 0
85401: ST_TO_ADDR
// if tmp < k then
85402: NOP4
85406: PUSH
85407: NOP4
85411: LESS
85412: IFFALSE 85424
// k := tmp ;
85414: NOP4
85418: PUSH
85419: NOP4
85423: ST_TO_ADDR
// for j = 1 to k do
85424: NOP4
85428: PUSH
85429: DOUBLE
85430: LD_INT 1
85432: DEC
85433: ST_TO_ADDR
85434: NOP4
85438: PUSH
85439: FOR_TO
85440: IFFALSE 85572
// begin if GetType ( tmp [ j ] ) = unit_building then
85442: NOP4
85446: PUSH
85447: NOP4
85451: ARRAY
85452: PPUSH
85453: NOP4
85457: PUSH
85458: LD_INT 3
85460: EQUAL
85461: IFFALSE 85570
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85463: NOP4
85467: PUSH
85468: NOP4
85472: ARRAY
85473: PUSH
85474: NOP4
85478: IN
85479: NOT
85480: PUSH
85481: NOP4
85485: PUSH
85486: NOP4
85490: ARRAY
85491: PPUSH
85492: NOP4
85496: AND
85497: IFFALSE 85570
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85499: NOP4
85503: PUSH
85504: NOP4
85508: ARRAY
85509: PPUSH
85510: NOP4
85514: PUSH
85515: NOP4
85519: ARRAY
85520: PPUSH
85521: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85525: NOP4
85529: PUSH
85530: NOP4
85534: PPUSH
85535: NOP4
85539: PUSH
85540: LD_INT 1
85542: PLUS
85543: PPUSH
85544: NOP4
85548: PUSH
85549: NOP4
85553: ARRAY
85554: PPUSH
85555: NOP4
85559: ST_TO_ADDR
// attacking := true ;
85560: NOP4
85564: PUSH
85565: LD_INT 1
85567: ST_TO_ADDR
// break ;
85568: GO 85572
// end ; end ;
85570: GO 85439
85572: POP
85573: POP
// if not attacking and f_attack_depot then
85574: NOP4
85578: NOT
85579: PUSH
85580: NOP4
85584: AND
85585: IFFALSE 85680
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85587: NOP4
85591: PUSH
85592: NOP4
85596: PPUSH
85597: LD_INT 2
85599: PUSH
85600: LD_INT 30
85602: PUSH
85603: LD_INT 0
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 30
85612: PUSH
85613: LD_INT 1
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: LIST
85624: PPUSH
85625: NOP4
85629: ST_TO_ADDR
// if z then
85630: NOP4
85634: IFFALSE 85680
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85636: NOP4
85640: PUSH
85641: NOP4
85645: ARRAY
85646: PPUSH
85647: NOP4
85651: PPUSH
85652: NOP4
85656: PUSH
85657: NOP4
85661: ARRAY
85662: PPUSH
85663: NOP4
85667: PPUSH
85668: NOP4
// attacking := true ;
85672: NOP4
85676: PUSH
85677: LD_INT 1
85679: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85680: NOP4
85684: PUSH
85685: NOP4
85689: ARRAY
85690: PPUSH
85691: NOP4
85695: PUSH
85696: LD_INT 500
85698: LESS
85699: IFFALSE 85725
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85701: NOP4
85705: PUSH
85706: NOP4
85710: ARRAY
85711: PPUSH
85712: NOP4
85716: PUSH
85717: LD_INT 1
85719: ARRAY
85720: PPUSH
85721: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85725: NOP4
85729: PUSH
85730: NOP4
85734: ARRAY
85735: PPUSH
85736: NOP4
85740: PUSH
85741: LD_INT 49
85743: EQUAL
85744: IFFALSE 85865
// begin if not HasTask ( group [ i ] ) then
85746: NOP4
85750: PUSH
85751: NOP4
85755: ARRAY
85756: PPUSH
85757: NOP4
85761: NOT
85762: IFFALSE 85865
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85764: NOP4
85768: PUSH
85769: LD_INT 81
85771: PUSH
85772: NOP4
85776: PUSH
85777: NOP4
85781: ARRAY
85782: PPUSH
85783: NOP4
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PPUSH
85792: NOP4
85796: PPUSH
85797: NOP4
85801: PUSH
85802: NOP4
85806: ARRAY
85807: PPUSH
85808: NOP4
85812: ST_TO_ADDR
// if k then
85813: NOP4
85817: IFFALSE 85865
// if GetDistUnits ( group [ i ] , k ) > 10 then
85819: NOP4
85823: PUSH
85824: NOP4
85828: ARRAY
85829: PPUSH
85830: NOP4
85834: PPUSH
85835: NOP4
85839: PUSH
85840: LD_INT 10
85842: GREATER
85843: IFFALSE 85865
// ComMoveUnit ( group [ i ] , k ) ;
85845: NOP4
85849: PUSH
85850: NOP4
85854: ARRAY
85855: PPUSH
85856: NOP4
85860: PPUSH
85861: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85865: NOP4
85869: PUSH
85870: NOP4
85874: ARRAY
85875: PPUSH
85876: NOP4
85880: PUSH
85881: LD_INT 250
85883: LESS
85884: PUSH
85885: NOP4
85889: PUSH
85890: NOP4
85894: ARRAY
85895: PUSH
85896: LD_INT 21
85898: PUSH
85899: LD_INT 2
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 23
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PPUSH
85920: NOP4
85924: IN
85925: AND
85926: IFFALSE 86051
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85928: NOP4
85932: PUSH
85933: NOP4
85937: PUSH
85938: NOP4
85942: PUSH
85943: NOP4
85947: ARRAY
85948: DIFF
85949: PPUSH
85950: NOP4
85954: PUSH
85955: NOP4
85959: ARRAY
85960: PPUSH
85961: NOP4
85965: ST_TO_ADDR
// if not k then
85966: NOP4
85970: NOT
85971: IFFALSE 85975
// continue ;
85973: GO 82390
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85975: NOP4
85979: PUSH
85980: LD_INT 81
85982: PUSH
85983: NOP4
85987: PUSH
85988: NOP4
85992: ARRAY
85993: PPUSH
85994: NOP4
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PPUSH
86003: NOP4
86007: IN
86008: PUSH
86009: NOP4
86013: PPUSH
86014: NOP4
86018: PUSH
86019: NOP4
86023: ARRAY
86024: PPUSH
86025: NOP4
86029: PUSH
86030: LD_INT 5
86032: LESS
86033: AND
86034: IFFALSE 86051
// ComAutodestruct ( group [ i ] ) ;
86036: NOP4
86040: PUSH
86041: NOP4
86045: ARRAY
86046: PPUSH
86047: NOP4
// end ; if f_attack_depot then
86051: NOP4
86055: IFFALSE 86167
// begin k := 6 ;
86057: NOP4
86061: PUSH
86062: LD_INT 6
86064: ST_TO_ADDR
// if tmp < k then
86065: NOP4
86069: PUSH
86070: NOP4
86074: LESS
86075: IFFALSE 86087
// k := tmp ;
86077: NOP4
86081: PUSH
86082: NOP4
86086: ST_TO_ADDR
// for j = 1 to k do
86087: NOP4
86091: PUSH
86092: DOUBLE
86093: LD_INT 1
86095: DEC
86096: ST_TO_ADDR
86097: NOP4
86101: PUSH
86102: FOR_TO
86103: IFFALSE 86165
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86105: NOP4
86109: PPUSH
86110: NOP4
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: LD_INT 1
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: IN
86125: IFFALSE 86163
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86127: NOP4
86131: PUSH
86132: NOP4
86136: ARRAY
86137: PPUSH
86138: NOP4
86142: PUSH
86143: NOP4
86147: ARRAY
86148: PPUSH
86149: NOP4
// attacking := true ;
86153: NOP4
86157: PUSH
86158: LD_INT 1
86160: ST_TO_ADDR
// break ;
86161: GO 86165
// end ;
86163: GO 86102
86165: POP
86166: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86167: NOP4
86171: PUSH
86172: NOP4
86176: ARRAY
86177: PPUSH
86178: NOP4
86182: PUSH
86183: NOP4
86187: NOT
86188: AND
86189: IFFALSE 86511
// begin if GetTag ( group [ i ] ) = 71 then
86191: NOP4
86195: PUSH
86196: NOP4
86200: ARRAY
86201: PPUSH
86202: NOP4
86206: PUSH
86207: LD_INT 71
86209: EQUAL
86210: IFFALSE 86251
// begin if HasTask ( group [ i ] ) then
86212: NOP4
86216: PUSH
86217: NOP4
86221: ARRAY
86222: PPUSH
86223: NOP4
86227: IFFALSE 86233
// continue else
86229: GO 82390
86231: GO 86251
// SetTag ( group [ i ] , 0 ) ;
86233: NOP4
86237: PUSH
86238: NOP4
86242: ARRAY
86243: PPUSH
86244: LD_INT 0
86246: PPUSH
86247: NOP4
// end ; k := 8 ;
86251: NOP4
86255: PUSH
86256: LD_INT 8
86258: ST_TO_ADDR
// x := 0 ;
86259: NOP4
86263: PUSH
86264: LD_INT 0
86266: ST_TO_ADDR
// if tmp < k then
86267: NOP4
86271: PUSH
86272: NOP4
86276: LESS
86277: IFFALSE 86289
// k := tmp ;
86279: NOP4
86283: PUSH
86284: NOP4
86288: ST_TO_ADDR
// for j = 1 to k do
86289: NOP4
86293: PUSH
86294: DOUBLE
86295: LD_INT 1
86297: DEC
86298: ST_TO_ADDR
86299: NOP4
86303: PUSH
86304: FOR_TO
86305: IFFALSE 86403
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86307: NOP4
86311: PUSH
86312: NOP4
86316: ARRAY
86317: PPUSH
86318: NOP4
86322: PUSH
86323: LD_INT 1
86325: EQUAL
86326: PUSH
86327: NOP4
86331: PUSH
86332: NOP4
86336: ARRAY
86337: PPUSH
86338: NOP4
86342: PUSH
86343: LD_INT 250
86345: LESS
86346: PUSH
86347: NOP4
86351: AND
86352: PUSH
86353: NOP4
86357: NOT
86358: PUSH
86359: NOP4
86363: PUSH
86364: NOP4
86368: ARRAY
86369: PPUSH
86370: NOP4
86374: PUSH
86375: LD_INT 250
86377: GREATEREQUAL
86378: AND
86379: OR
86380: AND
86381: IFFALSE 86401
// begin x := tmp [ j ] ;
86383: NOP4
86387: PUSH
86388: NOP4
86392: PUSH
86393: NOP4
86397: ARRAY
86398: ST_TO_ADDR
// break ;
86399: GO 86403
// end ;
86401: GO 86304
86403: POP
86404: POP
// if x then
86405: NOP4
86409: IFFALSE 86433
// ComAttackUnit ( group [ i ] , x ) else
86411: NOP4
86415: PUSH
86416: NOP4
86420: ARRAY
86421: PPUSH
86422: NOP4
86426: PPUSH
86427: NOP4
86431: GO 86457
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86433: NOP4
86437: PUSH
86438: NOP4
86442: ARRAY
86443: PPUSH
86444: NOP4
86448: PUSH
86449: LD_INT 1
86451: ARRAY
86452: PPUSH
86453: NOP4
// if not HasTask ( group [ i ] ) then
86457: NOP4
86461: PUSH
86462: NOP4
86466: ARRAY
86467: PPUSH
86468: NOP4
86472: NOT
86473: IFFALSE 86511
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86475: NOP4
86479: PUSH
86480: NOP4
86484: ARRAY
86485: PPUSH
86486: NOP4
86490: PPUSH
86491: NOP4
86495: PUSH
86496: NOP4
86500: ARRAY
86501: PPUSH
86502: NOP4
86506: PPUSH
86507: NOP4
// end ; end ; end ;
86511: GO 82390
86513: POP
86514: POP
// wait ( 0 0$2 ) ;
86515: LD_INT 70
86517: PPUSH
86518: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86522: NOP4
86526: NOT
86527: PUSH
86528: NOP4
86532: PUSH
86533: EMPTY
86534: EQUAL
86535: OR
86536: PUSH
86537: LD_INT 81
86539: PUSH
86540: NOP4
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PPUSH
86549: NOP4
86553: NOT
86554: OR
86555: IFFALSE 82375
// end ;
86557: LD_VAR 0 2
86561: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86562: LD_INT 0
86564: PPUSH
86565: PPUSH
86566: PPUSH
86567: PPUSH
86568: PPUSH
86569: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86570: NOP4
86574: NOT
86575: PUSH
86576: NOP4
86580: PUSH
86581: NOP4
86585: ARRAY
86586: NOT
86587: OR
86588: PUSH
86589: NOP4
86593: NOT
86594: OR
86595: IFFALSE 86599
// exit ;
86597: GO 87153
// side := mc_sides [ base ] ;
86599: NOP4
86603: PUSH
86604: NOP4
86608: PUSH
86609: NOP4
86613: ARRAY
86614: ST_TO_ADDR
// if not side then
86615: NOP4
86619: NOT
86620: IFFALSE 86624
// exit ;
86622: GO 87153
// for i in solds do
86624: NOP4
86628: PUSH
86629: NOP4
86633: PUSH
86634: FOR_IN
86635: IFFALSE 86696
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86637: NOP4
86641: PPUSH
86642: NOP4
86646: PPUSH
86647: NOP4
86651: PUSH
86652: LD_INT 32
86654: PUSH
86655: LD_INT 31
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: IN
86662: IFFALSE 86682
// solds := solds diff i else
86664: NOP4
86668: PUSH
86669: NOP4
86673: PUSH
86674: NOP4
86678: DIFF
86679: ST_TO_ADDR
86680: GO 86694
// SetTag ( i , 18 ) ;
86682: NOP4
86686: PPUSH
86687: LD_INT 18
86689: PPUSH
86690: NOP4
86694: GO 86634
86696: POP
86697: POP
// if not solds then
86698: NOP4
86702: NOT
86703: IFFALSE 86707
// exit ;
86705: GO 87153
// repeat wait ( 0 0$2 ) ;
86707: LD_INT 70
86709: PPUSH
86710: NOP4
// enemy := mc_scan [ base ] ;
86714: NOP4
86718: PUSH
86719: NOP4
86723: PUSH
86724: NOP4
86728: ARRAY
86729: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86730: NOP4
86734: PUSH
86735: NOP4
86739: ARRAY
86740: NOT
86741: PUSH
86742: NOP4
86746: PUSH
86747: NOP4
86751: ARRAY
86752: PUSH
86753: EMPTY
86754: EQUAL
86755: OR
86756: IFFALSE 86793
// begin for i in solds do
86758: NOP4
86762: PUSH
86763: NOP4
86767: PUSH
86768: FOR_IN
86769: IFFALSE 86782
// ComStop ( i ) ;
86771: NOP4
86775: PPUSH
86776: NOP4
86780: GO 86768
86782: POP
86783: POP
// solds := [ ] ;
86784: NOP4
86788: PUSH
86789: EMPTY
86790: ST_TO_ADDR
// exit ;
86791: GO 87153
// end ; for i in solds do
86793: NOP4
86797: PUSH
86798: NOP4
86802: PUSH
86803: FOR_IN
86804: IFFALSE 87125
// begin if IsInUnit ( i ) then
86806: NOP4
86810: PPUSH
86811: NOP4
86815: IFFALSE 86826
// ComExitBuilding ( i ) ;
86817: NOP4
86821: PPUSH
86822: NOP4
// if GetLives ( i ) > 500 then
86826: NOP4
86830: PPUSH
86831: NOP4
86835: PUSH
86836: LD_INT 500
86838: GREATER
86839: IFFALSE 86892
// begin e := NearestUnitToUnit ( enemy , i ) ;
86841: NOP4
86845: PUSH
86846: NOP4
86850: PPUSH
86851: NOP4
86855: PPUSH
86856: NOP4
86860: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86861: NOP4
86865: PPUSH
86866: NOP4
86870: PPUSH
86871: NOP4
86875: PPUSH
86876: NOP4
86880: PPUSH
86881: NOP4
86885: PPUSH
86886: NOP4
// end else
86890: GO 87123
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86892: NOP4
86896: PPUSH
86897: NOP4
86901: PUSH
86902: NOP4
86906: ARRAY
86907: PPUSH
86908: LD_INT 2
86910: PUSH
86911: LD_INT 30
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 30
86923: PUSH
86924: LD_INT 1
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 30
86933: PUSH
86934: LD_INT 6
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: PPUSH
86947: NOP4
86951: PPUSH
86952: NOP4
86956: PPUSH
86957: NOP4
86961: PPUSH
86962: NOP4
86966: PUSH
86967: LD_INT 10
86969: GREATER
86970: IFFALSE 87123
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86972: NOP4
86976: PUSH
86977: NOP4
86981: PUSH
86982: NOP4
86986: ARRAY
86987: PPUSH
86988: LD_INT 2
86990: PUSH
86991: LD_INT 30
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 30
87003: PUSH
87004: LD_INT 1
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 30
87013: PUSH
87014: LD_INT 6
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: PPUSH
87027: NOP4
87031: PPUSH
87032: NOP4
87036: PPUSH
87037: NOP4
87041: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87042: NOP4
87046: PPUSH
87047: NOP4
87051: PPUSH
87052: NOP4
87056: PPUSH
87057: LD_INT 3
87059: PPUSH
87060: LD_INT 5
87062: PPUSH
87063: NOP4
87067: PPUSH
87068: NOP4
87072: PPUSH
87073: NOP4
87077: PPUSH
87078: LD_INT 3
87080: PPUSH
87081: LD_INT 5
87083: PPUSH
87084: NOP4
87088: PPUSH
87089: NOP4
// SetTag ( i , 0 ) ;
87093: NOP4
87097: PPUSH
87098: LD_INT 0
87100: PPUSH
87101: NOP4
// solds := solds diff i ;
87105: NOP4
87109: PUSH
87110: NOP4
87114: PUSH
87115: NOP4
87119: DIFF
87120: ST_TO_ADDR
// continue ;
87121: GO 86803
// end ; end ;
87123: GO 86803
87125: POP
87126: POP
// until not solds or not enemy ;
87127: NOP4
87131: NOT
87132: PUSH
87133: NOP4
87137: NOT
87138: OR
87139: IFFALSE 86707
// MC_Reset ( base , 18 ) ;
87141: NOP4
87145: PPUSH
87146: LD_INT 18
87148: PPUSH
87149: NOP4
// end ;
87153: LD_VAR 0 3
87157: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87158: LD_INT 0
87160: PPUSH
87161: PPUSH
87162: PPUSH
87163: PPUSH
87164: PPUSH
87165: PPUSH
87166: PPUSH
87167: PPUSH
87168: PPUSH
87169: PPUSH
87170: PPUSH
87171: PPUSH
87172: PPUSH
87173: PPUSH
87174: PPUSH
87175: PPUSH
87176: PPUSH
87177: PPUSH
87178: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87179: NOP4
87183: PUSH
87184: NOP4
87188: PUSH
87189: NOP4
87193: ARRAY
87194: PPUSH
87195: LD_INT 25
87197: PUSH
87198: LD_INT 3
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PPUSH
87205: NOP4
87209: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87210: NOP4
87214: PUSH
87215: NOP4
87219: ARRAY
87220: IFFALSE 87244
// mechs := mechs diff mc_remote_driver [ base ] ;
87222: NOP4
87226: PUSH
87227: NOP4
87231: PUSH
87232: NOP4
87236: PUSH
87237: NOP4
87241: ARRAY
87242: DIFF
87243: ST_TO_ADDR
// for i in mechs do
87244: NOP4
87248: PUSH
87249: NOP4
87253: PUSH
87254: FOR_IN
87255: IFFALSE 87290
// if GetTag ( i ) > 0 then
87257: NOP4
87261: PPUSH
87262: NOP4
87266: PUSH
87267: LD_INT 0
87269: GREATER
87270: IFFALSE 87288
// mechs := mechs diff i ;
87272: NOP4
87276: PUSH
87277: NOP4
87281: PUSH
87282: NOP4
87286: DIFF
87287: ST_TO_ADDR
87288: GO 87254
87290: POP
87291: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87292: NOP4
87296: PUSH
87297: NOP4
87301: PUSH
87302: NOP4
87306: ARRAY
87307: PPUSH
87308: LD_INT 2
87310: PUSH
87311: LD_INT 25
87313: PUSH
87314: LD_INT 1
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 25
87323: PUSH
87324: LD_INT 5
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 25
87333: PUSH
87334: LD_INT 8
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: PUSH
87341: LD_INT 25
87343: PUSH
87344: LD_INT 9
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: PPUSH
87358: NOP4
87362: ST_TO_ADDR
// if not defenders and not solds then
87363: NOP4
87367: NOT
87368: PUSH
87369: NOP4
87373: NOT
87374: AND
87375: IFFALSE 87379
// exit ;
87377: GO 89149
// depot_under_attack := false ;
87379: NOP4
87383: PUSH
87384: LD_INT 0
87386: ST_TO_ADDR
// sold_defenders := [ ] ;
87387: NOP4
87391: PUSH
87392: EMPTY
87393: ST_TO_ADDR
// if mechs then
87394: NOP4
87398: IFFALSE 87551
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87400: NOP4
87404: PUSH
87405: NOP4
87409: PPUSH
87410: LD_INT 21
87412: PUSH
87413: LD_INT 2
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PPUSH
87420: NOP4
87424: PUSH
87425: FOR_IN
87426: IFFALSE 87549
// begin if GetTag ( i ) <> 20 then
87428: NOP4
87432: PPUSH
87433: NOP4
87437: PUSH
87438: LD_INT 20
87440: NONEQUAL
87441: IFFALSE 87455
// SetTag ( i , 20 ) ;
87443: NOP4
87447: PPUSH
87448: LD_INT 20
87450: PPUSH
87451: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87455: NOP4
87459: PPUSH
87460: NOP4
87464: PUSH
87465: LD_INT 1
87467: EQUAL
87468: PUSH
87469: NOP4
87473: PPUSH
87474: NOP4
87478: NOT
87479: AND
87480: IFFALSE 87547
// begin un := mechs [ 1 ] ;
87482: NOP4
87486: PUSH
87487: NOP4
87491: PUSH
87492: LD_INT 1
87494: ARRAY
87495: ST_TO_ADDR
// ComExit ( un ) ;
87496: NOP4
87500: PPUSH
87501: NOP4
// AddComEnterUnit ( un , i ) ;
87505: NOP4
87509: PPUSH
87510: NOP4
87514: PPUSH
87515: NOP4
// SetTag ( un , 19 ) ;
87519: NOP4
87523: PPUSH
87524: LD_INT 19
87526: PPUSH
87527: NOP4
// mechs := mechs diff un ;
87531: NOP4
87535: PUSH
87536: NOP4
87540: PUSH
87541: NOP4
87545: DIFF
87546: ST_TO_ADDR
// end ; end ;
87547: GO 87425
87549: POP
87550: POP
// if solds then
87551: NOP4
87555: IFFALSE 87614
// for i in solds do
87557: NOP4
87561: PUSH
87562: NOP4
87566: PUSH
87567: FOR_IN
87568: IFFALSE 87612
// if not GetTag ( i ) then
87570: NOP4
87574: PPUSH
87575: NOP4
87579: NOT
87580: IFFALSE 87610
// begin defenders := defenders union i ;
87582: NOP4
87586: PUSH
87587: NOP4
87591: PUSH
87592: NOP4
87596: UNION
87597: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87598: NOP4
87602: PPUSH
87603: LD_INT 18
87605: PPUSH
87606: NOP4
// end ;
87610: GO 87567
87612: POP
87613: POP
// repeat wait ( 0 0$2 ) ;
87614: LD_INT 70
87616: PPUSH
87617: NOP4
// enemy := mc_scan [ base ] ;
87621: NOP4
87625: PUSH
87626: NOP4
87630: PUSH
87631: NOP4
87635: ARRAY
87636: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87637: NOP4
87641: PUSH
87642: NOP4
87646: ARRAY
87647: NOT
87648: PUSH
87649: NOP4
87653: PUSH
87654: NOP4
87658: ARRAY
87659: PUSH
87660: EMPTY
87661: EQUAL
87662: OR
87663: IFFALSE 87700
// begin for i in defenders do
87665: NOP4
87669: PUSH
87670: NOP4
87674: PUSH
87675: FOR_IN
87676: IFFALSE 87689
// ComStop ( i ) ;
87678: NOP4
87682: PPUSH
87683: NOP4
87687: GO 87675
87689: POP
87690: POP
// defenders := [ ] ;
87691: NOP4
87695: PUSH
87696: EMPTY
87697: ST_TO_ADDR
// exit ;
87698: GO 89149
// end ; for i in defenders do
87700: NOP4
87704: PUSH
87705: NOP4
87709: PUSH
87710: FOR_IN
87711: IFFALSE 88609
// begin e := NearestUnitToUnit ( enemy , i ) ;
87713: NOP4
87717: PUSH
87718: NOP4
87722: PPUSH
87723: NOP4
87727: PPUSH
87728: NOP4
87732: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87733: NOP4
87737: PUSH
87738: NOP4
87742: PUSH
87743: NOP4
87747: ARRAY
87748: PPUSH
87749: LD_INT 2
87751: PUSH
87752: LD_INT 30
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: LD_INT 30
87764: PUSH
87765: LD_INT 1
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: LIST
87776: PPUSH
87777: NOP4
87781: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87782: NOP4
87786: PUSH
87787: NOP4
87791: NOT
87792: PUSH
87793: NOP4
87797: PPUSH
87798: LD_INT 3
87800: PUSH
87801: LD_INT 24
87803: PUSH
87804: LD_INT 600
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PPUSH
87815: NOP4
87819: OR
87820: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87821: NOP4
87825: PPUSH
87826: NOP4
87830: PUSH
87831: LD_INT 2
87833: DOUBLE
87834: EQUAL
87835: IFTRUE 87839
87837: GO 88235
87839: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87840: NOP4
87844: PPUSH
87845: NOP4
87849: PUSH
87850: LD_INT 1000
87852: EQUAL
87853: PUSH
87854: NOP4
87858: PPUSH
87859: NOP4
87863: PPUSH
87864: NOP4
87868: PUSH
87869: LD_INT 40
87871: LESS
87872: PUSH
87873: NOP4
87877: PPUSH
87878: NOP4
87882: PUSH
87883: NOP4
87887: ARRAY
87888: PPUSH
87889: NOP4
87893: OR
87894: AND
87895: IFFALSE 88017
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87897: NOP4
87901: PPUSH
87902: NOP4
87906: PUSH
87907: LD_INT 1
87909: EQUAL
87910: PUSH
87911: NOP4
87915: PPUSH
87916: NOP4
87920: PUSH
87921: LD_INT 30
87923: LESS
87924: AND
87925: PUSH
87926: NOP4
87930: AND
87931: IFFALSE 88001
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87933: NOP4
87937: PPUSH
87938: NOP4
87942: PPUSH
87943: NOP4
87947: PPUSH
87948: NOP4
87952: PPUSH
87953: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87957: NOP4
87961: PPUSH
87962: NOP4
87966: PPUSH
87967: NOP4
87971: PPUSH
87972: NOP4
87976: PPUSH
87977: NOP4
87981: PUSH
87982: LD_INT 6
87984: LESS
87985: IFFALSE 87999
// SetFuel ( i , 100 ) ;
87987: NOP4
87991: PPUSH
87992: LD_INT 100
87994: PPUSH
87995: NOP4
// end else
87999: GO 88015
// ComAttackUnit ( i , e ) ;
88001: NOP4
88005: PPUSH
88006: NOP4
88010: PPUSH
88011: NOP4
// end else
88015: GO 88118
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88017: NOP4
88021: PPUSH
88022: NOP4
88026: PUSH
88027: NOP4
88031: ARRAY
88032: PPUSH
88033: NOP4
88037: NOT
88038: PUSH
88039: NOP4
88043: PPUSH
88044: NOP4
88048: PPUSH
88049: NOP4
88053: PUSH
88054: LD_INT 40
88056: GREATEREQUAL
88057: AND
88058: PUSH
88059: NOP4
88063: PPUSH
88064: NOP4
88068: PUSH
88069: LD_INT 650
88071: LESSEQUAL
88072: OR
88073: PUSH
88074: NOP4
88078: PPUSH
88079: NOP4
88083: PUSH
88084: NOP4
88088: ARRAY
88089: PPUSH
88090: NOP4
88094: NOT
88095: AND
88096: IFFALSE 88118
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88098: NOP4
88102: PPUSH
88103: NOP4
88107: PUSH
88108: NOP4
88112: ARRAY
88113: PPUSH
88114: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88118: NOP4
88122: PPUSH
88123: NOP4
88127: PUSH
88128: LD_INT 1000
88130: LESS
88131: PUSH
88132: NOP4
88136: PPUSH
88137: NOP4
88141: PUSH
88142: LD_INT 1
88144: EQUAL
88145: AND
88146: PUSH
88147: NOP4
88151: PPUSH
88152: NOP4
88156: AND
88157: PUSH
88158: NOP4
88162: PPUSH
88163: NOP4
88167: PUSH
88168: NOP4
88172: ARRAY
88173: PPUSH
88174: NOP4
88178: AND
88179: IFFALSE 88233
// begin mech := IsDrivenBy ( i ) ;
88181: NOP4
88185: PUSH
88186: NOP4
88190: PPUSH
88191: NOP4
88195: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88196: NOP4
88200: PPUSH
88201: NOP4
// AddComRepairVehicle ( mech , i ) ;
88205: NOP4
88209: PPUSH
88210: NOP4
88214: PPUSH
88215: NOP4
// AddComEnterUnit ( mech , i ) ;
88219: NOP4
88223: PPUSH
88224: NOP4
88228: PPUSH
88229: NOP4
// end ; end ; unit_human :
88233: GO 88580
88235: LD_INT 1
88237: DOUBLE
88238: EQUAL
88239: IFTRUE 88243
88241: GO 88579
88243: POP
// begin b := IsInUnit ( i ) ;
88244: NOP4
88248: PUSH
88249: NOP4
88253: PPUSH
88254: NOP4
88258: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88259: NOP4
88263: PUSH
88264: NOP4
88268: NOT
88269: PUSH
88270: NOP4
88274: PPUSH
88275: NOP4
88279: PUSH
88280: LD_INT 32
88282: PUSH
88283: LD_INT 31
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: IN
88290: OR
88291: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88292: NOP4
88296: PPUSH
88297: NOP4
88301: PUSH
88302: LD_INT 5
88304: EQUAL
88305: PUSH
88306: NOP4
88310: PPUSH
88311: NOP4
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: LD_INT 2
88321: PUSH
88322: LD_INT 3
88324: PUSH
88325: LD_INT 4
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: IN
88334: AND
88335: IFFALSE 88372
// begin class := AllowSpecClass ( i ) ;
88337: NOP4
88341: PUSH
88342: NOP4
88346: PPUSH
88347: NOP4
88351: ST_TO_ADDR
// if class then
88352: NOP4
88356: IFFALSE 88372
// ComChangeProfession ( i , class ) ;
88358: NOP4
88362: PPUSH
88363: NOP4
88367: PPUSH
88368: NOP4
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88372: NOP4
88376: PUSH
88377: NOP4
88381: PPUSH
88382: LD_INT 21
88384: PUSH
88385: LD_INT 2
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PPUSH
88392: NOP4
88396: PUSH
88397: LD_INT 1
88399: LESSEQUAL
88400: OR
88401: PUSH
88402: NOP4
88406: AND
88407: PUSH
88408: NOP4
88412: PUSH
88413: NOP4
88417: IN
88418: NOT
88419: AND
88420: IFFALSE 88513
// begin if b then
88422: NOP4
88426: IFFALSE 88475
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88428: NOP4
88432: PPUSH
88433: NOP4
88437: PPUSH
88438: NOP4
88442: PPUSH
88443: NOP4
88447: PPUSH
88448: NOP4
88452: PUSH
88453: LD_INT 10
88455: LESS
88456: PUSH
88457: NOP4
88461: PPUSH
88462: NOP4
88466: PUSH
88467: LD_INT 7
88469: NONEQUAL
88470: AND
88471: IFFALSE 88475
// continue ;
88473: GO 87710
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88475: NOP4
88479: PUSH
88480: NOP4
88484: PPUSH
88485: NOP4
88489: PUSH
88490: LD_INT 1
88492: PLUS
88493: PPUSH
88494: NOP4
88498: PPUSH
88499: NOP4
88503: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88504: NOP4
88508: PPUSH
88509: NOP4
// end ; if sold_defenders then
88513: NOP4
88517: IFFALSE 88577
// if i in sold_defenders then
88519: NOP4
88523: PUSH
88524: NOP4
88528: IN
88529: IFFALSE 88577
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88531: NOP4
88535: PPUSH
88536: NOP4
88540: NOT
88541: PUSH
88542: NOP4
88546: PPUSH
88547: NOP4
88551: PPUSH
88552: NOP4
88556: PUSH
88557: LD_INT 30
88559: LESS
88560: AND
88561: IFFALSE 88577
// ComAttackUnit ( i , e ) ;
88563: NOP4
88567: PPUSH
88568: NOP4
88572: PPUSH
88573: NOP4
// end ; end ; end ;
88577: GO 88580
88579: POP
// if IsDead ( i ) then
88580: NOP4
88584: PPUSH
88585: NOP4
88589: IFFALSE 88607
// defenders := defenders diff i ;
88591: NOP4
88595: PUSH
88596: NOP4
88600: PUSH
88601: NOP4
88605: DIFF
88606: ST_TO_ADDR
// end ;
88607: GO 87710
88609: POP
88610: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88611: NOP4
88615: NOT
88616: PUSH
88617: NOP4
88621: NOT
88622: OR
88623: PUSH
88624: NOP4
88628: PUSH
88629: NOP4
88633: ARRAY
88634: NOT
88635: OR
88636: IFFALSE 87614
// MC_Reset ( base , 18 ) ;
88638: NOP4
88642: PPUSH
88643: LD_INT 18
88645: PPUSH
88646: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88650: NOP4
88654: PUSH
88655: NOP4
88659: PUSH
88660: NOP4
88664: PPUSH
88665: LD_INT 2
88667: PUSH
88668: LD_INT 25
88670: PUSH
88671: LD_INT 1
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 25
88680: PUSH
88681: LD_INT 5
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 25
88690: PUSH
88691: LD_INT 8
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 25
88700: PUSH
88701: LD_INT 9
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: PPUSH
88715: NOP4
88719: DIFF
88720: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88721: NOP4
88725: NOT
88726: PUSH
88727: NOP4
88731: PPUSH
88732: LD_INT 21
88734: PUSH
88735: LD_INT 2
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PPUSH
88742: NOP4
88746: AND
88747: IFFALSE 89085
// begin tmp := FilterByTag ( defenders , 19 ) ;
88749: NOP4
88753: PUSH
88754: NOP4
88758: PPUSH
88759: LD_INT 19
88761: PPUSH
88762: NOP4
88766: ST_TO_ADDR
// if tmp then
88767: NOP4
88771: IFFALSE 88841
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88773: NOP4
88777: PUSH
88778: NOP4
88782: PPUSH
88783: LD_INT 25
88785: PUSH
88786: LD_INT 3
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PPUSH
88793: NOP4
88797: ST_TO_ADDR
// if tmp then
88798: NOP4
88802: IFFALSE 88841
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88804: NOP4
88808: PUSH
88809: NOP4
88813: PPUSH
88814: NOP4
88818: PPUSH
88819: NOP4
88823: PUSH
88824: NOP4
88828: ARRAY
88829: PUSH
88830: NOP4
88834: UNION
88835: PPUSH
88836: NOP4
88840: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88841: NOP4
88845: PPUSH
88846: LD_INT 19
88848: PPUSH
88849: NOP4
// repeat wait ( 0 0$1 ) ;
88853: LD_INT 35
88855: PPUSH
88856: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88860: NOP4
88864: PUSH
88865: NOP4
88869: ARRAY
88870: NOT
88871: PUSH
88872: NOP4
88876: PUSH
88877: NOP4
88881: ARRAY
88882: PUSH
88883: EMPTY
88884: EQUAL
88885: OR
88886: IFFALSE 88923
// begin for i in defenders do
88888: NOP4
88892: PUSH
88893: NOP4
88897: PUSH
88898: FOR_IN
88899: IFFALSE 88912
// ComStop ( i ) ;
88901: NOP4
88905: PPUSH
88906: NOP4
88910: GO 88898
88912: POP
88913: POP
// defenders := [ ] ;
88914: NOP4
88918: PUSH
88919: EMPTY
88920: ST_TO_ADDR
// exit ;
88921: GO 89149
// end ; for i in defenders do
88923: NOP4
88927: PUSH
88928: NOP4
88932: PUSH
88933: FOR_IN
88934: IFFALSE 89023
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88936: NOP4
88940: PPUSH
88941: NOP4
88945: PUSH
88946: NOP4
88950: ARRAY
88951: PPUSH
88952: NOP4
88956: NOT
88957: IFFALSE 88981
// ComMoveToArea ( i , mc_parking [ base ] ) else
88959: NOP4
88963: PPUSH
88964: NOP4
88968: PUSH
88969: NOP4
88973: ARRAY
88974: PPUSH
88975: NOP4
88979: GO 89021
// if GetControl ( i ) = control_manual then
88981: NOP4
88985: PPUSH
88986: NOP4
88990: PUSH
88991: LD_INT 1
88993: EQUAL
88994: IFFALSE 89021
// if IsDrivenBy ( i ) then
88996: NOP4
89000: PPUSH
89001: NOP4
89005: IFFALSE 89021
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89007: NOP4
89011: PPUSH
89012: NOP4
89016: PPUSH
89017: NOP4
// end ;
89021: GO 88933
89023: POP
89024: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89025: NOP4
89029: PPUSH
89030: LD_INT 95
89032: PUSH
89033: NOP4
89037: PUSH
89038: NOP4
89042: ARRAY
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PPUSH
89048: NOP4
89052: PUSH
89053: NOP4
89057: EQUAL
89058: PUSH
89059: NOP4
89063: PUSH
89064: NOP4
89068: ARRAY
89069: OR
89070: PUSH
89071: NOP4
89075: PUSH
89076: NOP4
89080: ARRAY
89081: NOT
89082: OR
89083: IFFALSE 88853
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89085: NOP4
89089: PUSH
89090: NOP4
89094: PPUSH
89095: NOP4
89099: PPUSH
89100: NOP4
89104: PPUSH
89105: LD_INT 21
89107: PUSH
89108: LD_INT 2
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PPUSH
89115: NOP4
89119: PPUSH
89120: NOP4
89124: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89125: NOP4
89129: PPUSH
89130: LD_INT 19
89132: PPUSH
89133: NOP4
// MC_Reset ( base , 20 ) ;
89137: NOP4
89141: PPUSH
89142: LD_INT 20
89144: PPUSH
89145: NOP4
// end ; end_of_file
89149: LD_VAR 0 3
89153: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89154: LD_INT 0
89156: PPUSH
89157: PPUSH
89158: PPUSH
89159: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89160: NOP4
89164: PPUSH
89165: NOP4
89169: PUSH
89170: NOP4
89174: EQUAL
89175: IFFALSE 89247
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89177: LD_INT 68
89179: PPUSH
89180: NOP4
89184: PPUSH
89185: NOP4
89189: PPUSH
89190: NOP4
89194: PUSH
89195: LD_INT 2
89197: EQUAL
89198: IFFALSE 89210
// eff := 70 else
89200: NOP4
89204: PUSH
89205: LD_INT 70
89207: ST_TO_ADDR
89208: GO 89218
// eff := 30 ;
89210: NOP4
89214: PUSH
89215: LD_INT 30
89217: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89218: NOP4
89222: PPUSH
89223: NOP4
89227: PPUSH
89228: NOP4
89232: PPUSH
89233: NOP4
89237: PPUSH
89238: NOP4
89242: PPUSH
89243: NOP4
// end ; end ;
89247: LD_VAR 0 2
89251: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89252: LD_INT 0
89254: PPUSH
// end ;
89255: LD_VAR 0 4
89259: RET
// export function SOS_Command ( cmd ) ; begin
89260: LD_INT 0
89262: PPUSH
// end ;
89263: LD_VAR 0 2
89267: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89268: LD_INT 0
89270: PPUSH
// end ;
89271: LD_VAR 0 6
89275: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89276: LD_INT 0
89278: PPUSH
89279: PPUSH
// if not vehicle or not factory then
89280: NOP4
89284: NOT
89285: PUSH
89286: NOP4
89290: NOT
89291: OR
89292: IFFALSE 89296
// exit ;
89294: GO 89527
// if factoryWaypoints >= factory then
89296: NOP4
89300: PUSH
89301: NOP4
89305: GREATEREQUAL
89306: IFFALSE 89527
// if factoryWaypoints [ factory ] then
89308: NOP4
89312: PUSH
89313: NOP4
89317: ARRAY
89318: IFFALSE 89527
// begin if GetControl ( vehicle ) = control_manual then
89320: NOP4
89324: PPUSH
89325: NOP4
89329: PUSH
89330: LD_INT 1
89332: EQUAL
89333: IFFALSE 89414
// begin driver := IsDrivenBy ( vehicle ) ;
89335: NOP4
89339: PUSH
89340: NOP4
89344: PPUSH
89345: NOP4
89349: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89350: NOP4
89354: PPUSH
89355: NOP4
89359: PUSH
89360: NOP4
89364: ARRAY
89365: PUSH
89366: LD_INT 3
89368: ARRAY
89369: PPUSH
89370: NOP4
89374: PUSH
89375: NOP4
89379: ARRAY
89380: PUSH
89381: LD_INT 4
89383: ARRAY
89384: PPUSH
89385: NOP4
// AddComExitVehicle ( driver ) ;
89389: NOP4
89393: PPUSH
89394: NOP4
// AddComEnterUnit ( driver , factory ) ;
89398: NOP4
89402: PPUSH
89403: NOP4
89407: PPUSH
89408: NOP4
// end else
89412: GO 89527
// if GetControl ( vehicle ) = control_remote then
89414: NOP4
89418: PPUSH
89419: NOP4
89423: PUSH
89424: LD_INT 2
89426: EQUAL
89427: IFFALSE 89488
// begin wait ( 0 0$2 ) ;
89429: LD_INT 70
89431: PPUSH
89432: NOP4
// if Connect ( vehicle ) then
89436: NOP4
89440: PPUSH
89441: NOP4
89445: IFFALSE 89486
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89447: NOP4
89451: PPUSH
89452: NOP4
89456: PUSH
89457: NOP4
89461: ARRAY
89462: PUSH
89463: LD_INT 3
89465: ARRAY
89466: PPUSH
89467: NOP4
89471: PUSH
89472: NOP4
89476: ARRAY
89477: PUSH
89478: LD_INT 4
89480: ARRAY
89481: PPUSH
89482: NOP4
// end else
89486: GO 89527
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89488: NOP4
89492: PPUSH
89493: NOP4
89497: PUSH
89498: NOP4
89502: ARRAY
89503: PUSH
89504: LD_INT 3
89506: ARRAY
89507: PPUSH
89508: NOP4
89512: PUSH
89513: NOP4
89517: ARRAY
89518: PUSH
89519: LD_INT 4
89521: ARRAY
89522: PPUSH
89523: NOP4
// end ; end ;
89527: LD_VAR 0 3
89531: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89532: LD_INT 0
89534: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89535: NOP4
89539: PUSH
89540: LD_INT 250
89542: EQUAL
89543: PUSH
89544: NOP4
89548: PPUSH
89549: NOP4
89553: PUSH
89554: NOP4
89558: EQUAL
89559: AND
89560: IFFALSE 89581
// MinerPlaceMine ( unit , x , y ) ;
89562: NOP4
89566: PPUSH
89567: NOP4
89571: PPUSH
89572: NOP4
89576: PPUSH
89577: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89581: NOP4
89585: PUSH
89586: LD_INT 251
89588: EQUAL
89589: PUSH
89590: NOP4
89594: PPUSH
89595: NOP4
89599: PUSH
89600: NOP4
89604: EQUAL
89605: AND
89606: IFFALSE 89627
// MinerDetonateMine ( unit , x , y ) ;
89608: NOP4
89612: PPUSH
89613: NOP4
89617: PPUSH
89618: NOP4
89622: PPUSH
89623: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89627: NOP4
89631: PUSH
89632: LD_INT 252
89634: EQUAL
89635: PUSH
89636: NOP4
89640: PPUSH
89641: NOP4
89645: PUSH
89646: NOP4
89650: EQUAL
89651: AND
89652: IFFALSE 89673
// MinerCreateMinefield ( unit , x , y ) ;
89654: NOP4
89658: PPUSH
89659: NOP4
89663: PPUSH
89664: NOP4
89668: PPUSH
89669: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89673: NOP4
89677: PUSH
89678: LD_INT 253
89680: EQUAL
89681: PUSH
89682: NOP4
89686: PPUSH
89687: NOP4
89691: PUSH
89692: LD_INT 5
89694: EQUAL
89695: AND
89696: IFFALSE 89717
// ComBinocular ( unit , x , y ) ;
89698: NOP4
89702: PPUSH
89703: NOP4
89707: PPUSH
89708: NOP4
89712: PPUSH
89713: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89717: NOP4
89721: PUSH
89722: LD_INT 254
89724: EQUAL
89725: PUSH
89726: NOP4
89730: PPUSH
89731: NOP4
89735: PUSH
89736: NOP4
89740: EQUAL
89741: AND
89742: PUSH
89743: NOP4
89747: PPUSH
89748: NOP4
89752: PUSH
89753: LD_INT 3
89755: EQUAL
89756: AND
89757: IFFALSE 89773
// HackDestroyVehicle ( unit , selectedUnit ) ;
89759: NOP4
89763: PPUSH
89764: NOP4
89768: PPUSH
89769: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89773: NOP4
89777: PUSH
89778: LD_INT 255
89780: EQUAL
89781: PUSH
89782: NOP4
89786: PPUSH
89787: NOP4
89791: PUSH
89792: LD_INT 14
89794: PUSH
89795: LD_INT 53
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: IN
89802: AND
89803: PUSH
89804: NOP4
89808: PPUSH
89809: NOP4
89813: PPUSH
89814: NOP4
89818: AND
89819: IFFALSE 89843
// CutTreeXYR ( unit , x , y , 12 ) ;
89821: NOP4
89825: PPUSH
89826: NOP4
89830: PPUSH
89831: NOP4
89835: PPUSH
89836: LD_INT 12
89838: PPUSH
89839: NOP4
// if cmd = 256 then
89843: NOP4
89847: PUSH
89848: LD_INT 256
89850: EQUAL
89851: IFFALSE 89872
// SetFactoryWaypoint ( unit , x , y ) ;
89853: NOP4
89857: PPUSH
89858: NOP4
89862: PPUSH
89863: NOP4
89867: PPUSH
89868: NOP4
// if cmd = 257 then
89872: NOP4
89876: PUSH
89877: LD_INT 257
89879: EQUAL
89880: IFFALSE 89901
// SetWarehouseGatheringPoint ( unit , x , y ) ;
89882: NOP4
89886: PPUSH
89887: NOP4
89891: PPUSH
89892: NOP4
89896: PPUSH
89897: NOP4
// end ;
89901: LD_VAR 0 6
89905: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89906: LD_INT 0
89908: PPUSH
89909: PPUSH
89910: PPUSH
89911: PPUSH
89912: PPUSH
89913: PPUSH
89914: PPUSH
89915: PPUSH
89916: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89917: NOP4
89921: NOT
89922: PUSH
89923: NOP4
89927: PPUSH
89928: NOP4
89932: PPUSH
89933: NOP4
89937: NOT
89938: OR
89939: PUSH
89940: NOP4
89944: NOT
89945: OR
89946: IFFALSE 89950
// exit ;
89948: GO 90290
// list := [ ] ;
89950: NOP4
89954: PUSH
89955: EMPTY
89956: ST_TO_ADDR
// if x - r < 0 then
89957: NOP4
89961: PUSH
89962: NOP4
89966: MINUS
89967: PUSH
89968: LD_INT 0
89970: LESS
89971: IFFALSE 89983
// min_x := 0 else
89973: NOP4
89977: PUSH
89978: LD_INT 0
89980: ST_TO_ADDR
89981: GO 89999
// min_x := x - r ;
89983: NOP4
89987: PUSH
89988: NOP4
89992: PUSH
89993: NOP4
89997: MINUS
89998: ST_TO_ADDR
// if y - r < 0 then
89999: NOP4
90003: PUSH
90004: NOP4
90008: MINUS
90009: PUSH
90010: LD_INT 0
90012: LESS
90013: IFFALSE 90025
// min_y := 0 else
90015: NOP4
90019: PUSH
90020: LD_INT 0
90022: ST_TO_ADDR
90023: GO 90041
// min_y := y - r ;
90025: NOP4
90029: PUSH
90030: NOP4
90034: PUSH
90035: NOP4
90039: MINUS
90040: ST_TO_ADDR
// max_x := x + r ;
90041: NOP4
90045: PUSH
90046: NOP4
90050: PUSH
90051: NOP4
90055: PLUS
90056: ST_TO_ADDR
// max_y := y + r ;
90057: NOP4
90061: PUSH
90062: NOP4
90066: PUSH
90067: NOP4
90071: PLUS
90072: ST_TO_ADDR
// for _x = min_x to max_x do
90073: NOP4
90077: PUSH
90078: DOUBLE
90079: NOP4
90083: DEC
90084: ST_TO_ADDR
90085: NOP4
90089: PUSH
90090: FOR_TO
90091: IFFALSE 90208
// for _y = min_y to max_y do
90093: NOP4
90097: PUSH
90098: DOUBLE
90099: NOP4
90103: DEC
90104: ST_TO_ADDR
90105: NOP4
90109: PUSH
90110: FOR_TO
90111: IFFALSE 90204
// begin if not ValidHex ( _x , _y ) then
90113: NOP4
90117: PPUSH
90118: NOP4
90122: PPUSH
90123: NOP4
90127: NOT
90128: IFFALSE 90132
// continue ;
90130: GO 90110
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90132: NOP4
90136: PPUSH
90137: NOP4
90141: PPUSH
90142: NOP4
90146: PUSH
90147: NOP4
90151: PPUSH
90152: NOP4
90156: PPUSH
90157: NOP4
90161: AND
90162: IFFALSE 90202
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90164: NOP4
90168: PUSH
90169: NOP4
90173: PPUSH
90174: NOP4
90178: PUSH
90179: LD_INT 1
90181: PLUS
90182: PPUSH
90183: NOP4
90187: PUSH
90188: NOP4
90192: PUSH
90193: EMPTY
90194: LIST
90195: LIST
90196: PPUSH
90197: NOP4
90201: ST_TO_ADDR
// end ;
90202: GO 90110
90204: POP
90205: POP
90206: GO 90090
90208: POP
90209: POP
// if not list then
90210: NOP4
90214: NOT
90215: IFFALSE 90219
// exit ;
90217: GO 90290
// for i in list do
90219: NOP4
90223: PUSH
90224: NOP4
90228: PUSH
90229: FOR_IN
90230: IFFALSE 90288
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90232: NOP4
90236: PPUSH
90237: LD_STRING M
90239: PUSH
90240: NOP4
90244: PUSH
90245: LD_INT 1
90247: ARRAY
90248: PUSH
90249: NOP4
90253: PUSH
90254: LD_INT 2
90256: ARRAY
90257: PUSH
90258: LD_INT 0
90260: PUSH
90261: LD_INT 0
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: PUSH
90279: EMPTY
90280: LIST
90281: PPUSH
90282: NOP4
90286: GO 90229
90288: POP
90289: POP
// end ;
90290: LD_VAR 0 5
90294: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90295: NOP4
90299: NOT
90300: IFFALSE 90350
90302: GO 90304
90304: DISABLE
// begin initHack := true ;
90305: NOP4
90309: PUSH
90310: LD_INT 1
90312: ST_TO_ADDR
// hackTanks := [ ] ;
90313: NOP4
90317: PUSH
90318: EMPTY
90319: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90320: NOP4
90324: PUSH
90325: EMPTY
90326: ST_TO_ADDR
// hackLimit := 3 ;
90327: NOP4
90331: PUSH
90332: LD_INT 3
90334: ST_TO_ADDR
// hackDist := 12 ;
90335: NOP4
90339: PUSH
90340: LD_INT 12
90342: ST_TO_ADDR
// hackCounter := [ ] ;
90343: NOP4
90347: PUSH
90348: EMPTY
90349: ST_TO_ADDR
// end ;
90350: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90351: NOP4
90355: PUSH
90356: LD_INT 34
90358: PUSH
90359: NOP4
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PPUSH
90368: NOP4
90372: AND
90373: IFFALSE 90628
90375: GO 90377
90377: DISABLE
90378: LD_INT 0
90380: PPUSH
90381: PPUSH
// begin enable ;
90382: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90383: NOP4
90387: PUSH
90388: LD_INT 34
90390: PUSH
90391: NOP4
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PPUSH
90400: NOP4
90404: PUSH
90405: FOR_IN
90406: IFFALSE 90626
// begin if not i in hackTanks then
90408: NOP4
90412: PUSH
90413: NOP4
90417: IN
90418: NOT
90419: IFFALSE 90502
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90421: NOP4
90425: PUSH
90426: NOP4
90430: PPUSH
90431: NOP4
90435: PUSH
90436: LD_INT 1
90438: PLUS
90439: PPUSH
90440: NOP4
90444: PPUSH
90445: NOP4
90449: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90450: NOP4
90454: PUSH
90455: NOP4
90459: PPUSH
90460: NOP4
90464: PUSH
90465: LD_INT 1
90467: PLUS
90468: PPUSH
90469: EMPTY
90470: PPUSH
90471: NOP4
90475: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90476: NOP4
90480: PUSH
90481: NOP4
90485: PPUSH
90486: NOP4
90490: PUSH
90491: LD_INT 1
90493: PLUS
90494: PPUSH
90495: EMPTY
90496: PPUSH
90497: NOP4
90501: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90502: NOP4
90506: PPUSH
90507: NOP4
90511: NOT
90512: IFFALSE 90525
// begin HackUnlinkAll ( i ) ;
90514: NOP4
90518: PPUSH
90519: NOP4
// continue ;
90523: GO 90405
// end ; HackCheckCapturedStatus ( i ) ;
90525: NOP4
90529: PPUSH
90530: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90534: NOP4
90538: PUSH
90539: LD_INT 81
90541: PUSH
90542: NOP4
90546: PPUSH
90547: NOP4
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: PUSH
90556: LD_INT 33
90558: PUSH
90559: LD_INT 3
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 91
90568: PUSH
90569: NOP4
90573: PUSH
90574: NOP4
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 50
90586: PUSH
90587: EMPTY
90588: LIST
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: PPUSH
90596: NOP4
90600: ST_TO_ADDR
// if not tmp then
90601: NOP4
90605: NOT
90606: IFFALSE 90610
// continue ;
90608: GO 90405
// HackLink ( i , tmp ) ;
90610: NOP4
90614: PPUSH
90615: NOP4
90619: PPUSH
90620: NOP4
// end ;
90624: GO 90405
90626: POP
90627: POP
// end ;
90628: PPOPN 2
90630: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90631: LD_INT 0
90633: PPUSH
90634: PPUSH
90635: PPUSH
// if not hack in hackTanks then
90636: NOP4
90640: PUSH
90641: NOP4
90645: IN
90646: NOT
90647: IFFALSE 90651
// exit ;
90649: GO 90762
// index := GetElementIndex ( hackTanks , hack ) ;
90651: NOP4
90655: PUSH
90656: NOP4
90660: PPUSH
90661: NOP4
90665: PPUSH
90666: NOP4
90670: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90671: NOP4
90675: PUSH
90676: NOP4
90680: ARRAY
90681: IFFALSE 90762
// begin for i in hackTanksCaptured [ index ] do
90683: NOP4
90687: PUSH
90688: NOP4
90692: PUSH
90693: NOP4
90697: ARRAY
90698: PUSH
90699: FOR_IN
90700: IFFALSE 90726
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90702: NOP4
90706: PUSH
90707: LD_INT 1
90709: ARRAY
90710: PPUSH
90711: NOP4
90715: PUSH
90716: LD_INT 2
90718: ARRAY
90719: PPUSH
90720: NOP4
90724: GO 90699
90726: POP
90727: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90728: NOP4
90732: PUSH
90733: NOP4
90737: PPUSH
90738: NOP4
90742: PPUSH
90743: EMPTY
90744: PPUSH
90745: NOP4
90749: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90750: NOP4
90754: PPUSH
90755: LD_INT 0
90757: PPUSH
90758: NOP4
// end ; end ;
90762: LD_VAR 0 2
90766: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90767: LD_INT 0
90769: PPUSH
90770: PPUSH
90771: PPUSH
// if not hack in hackTanks or not vehicles then
90772: NOP4
90776: PUSH
90777: NOP4
90781: IN
90782: NOT
90783: PUSH
90784: NOP4
90788: NOT
90789: OR
90790: IFFALSE 90794
// exit ;
90792: GO 91069
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90794: NOP4
90798: PUSH
90799: NOP4
90803: PPUSH
90804: NOP4
90808: PPUSH
90809: LD_INT 1
90811: PPUSH
90812: LD_INT 1
90814: PPUSH
90815: NOP4
90819: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90820: NOP4
90824: PUSH
90825: NOP4
90829: PPUSH
90830: NOP4
90834: PPUSH
90835: NOP4
90839: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90840: NOP4
90844: PUSH
90845: NOP4
90849: ARRAY
90850: PUSH
90851: NOP4
90855: LESS
90856: IFFALSE 91045
// begin for i := 1 to vehicles do
90858: NOP4
90862: PUSH
90863: DOUBLE
90864: LD_INT 1
90866: DEC
90867: ST_TO_ADDR
90868: NOP4
90872: PUSH
90873: FOR_TO
90874: IFFALSE 91043
// begin if hackTanksCaptured [ index ] = hackLimit then
90876: NOP4
90880: PUSH
90881: NOP4
90885: ARRAY
90886: PUSH
90887: NOP4
90891: EQUAL
90892: IFFALSE 90896
// break ;
90894: GO 91043
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90896: NOP4
90900: PUSH
90901: NOP4
90905: PPUSH
90906: NOP4
90910: PPUSH
90911: NOP4
90915: PUSH
90916: NOP4
90920: ARRAY
90921: PUSH
90922: LD_INT 1
90924: PLUS
90925: PPUSH
90926: NOP4
90930: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90931: NOP4
90935: PUSH
90936: NOP4
90940: PPUSH
90941: NOP4
90945: PUSH
90946: NOP4
90950: PUSH
90951: NOP4
90955: ARRAY
90956: PUSH
90957: LD_INT 1
90959: PLUS
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PPUSH
90965: NOP4
90969: PUSH
90970: NOP4
90974: ARRAY
90975: PUSH
90976: NOP4
90980: PUSH
90981: NOP4
90985: ARRAY
90986: PPUSH
90987: NOP4
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PPUSH
90996: NOP4
91000: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91001: NOP4
91005: PUSH
91006: NOP4
91010: ARRAY
91011: PPUSH
91012: NOP4
91016: PPUSH
91017: NOP4
91021: PPUSH
91022: NOP4
// ComStop ( vehicles [ i ] ) ;
91026: NOP4
91030: PUSH
91031: NOP4
91035: ARRAY
91036: PPUSH
91037: NOP4
// end ;
91041: GO 90873
91043: POP
91044: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91045: NOP4
91049: PPUSH
91050: NOP4
91054: PUSH
91055: NOP4
91059: ARRAY
91060: PUSH
91061: LD_INT 0
91063: PLUS
91064: PPUSH
91065: NOP4
// end ;
91069: LD_VAR 0 3
91073: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91074: LD_INT 0
91076: PPUSH
91077: PPUSH
91078: PPUSH
91079: PPUSH
// if not hack in hackTanks then
91080: NOP4
91084: PUSH
91085: NOP4
91089: IN
91090: NOT
91091: IFFALSE 91095
// exit ;
91093: GO 91335
// index := GetElementIndex ( hackTanks , hack ) ;
91095: NOP4
91099: PUSH
91100: NOP4
91104: PPUSH
91105: NOP4
91109: PPUSH
91110: NOP4
91114: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91115: NOP4
91119: PUSH
91120: DOUBLE
91121: NOP4
91125: PUSH
91126: NOP4
91130: ARRAY
91131: INC
91132: ST_TO_ADDR
91133: LD_INT 1
91135: PUSH
91136: FOR_DOWNTO
91137: IFFALSE 91309
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91139: NOP4
91143: PUSH
91144: NOP4
91148: PUSH
91149: NOP4
91153: ARRAY
91154: PUSH
91155: NOP4
91159: ARRAY
91160: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91161: NOP4
91165: PUSH
91166: LD_INT 1
91168: ARRAY
91169: PPUSH
91170: NOP4
91174: NOT
91175: PUSH
91176: NOP4
91180: PUSH
91181: LD_INT 1
91183: ARRAY
91184: PPUSH
91185: NOP4
91189: PUSH
91190: NOP4
91194: PPUSH
91195: NOP4
91199: NONEQUAL
91200: OR
91201: IFFALSE 91307
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91203: NOP4
91207: PUSH
91208: LD_INT 1
91210: ARRAY
91211: PPUSH
91212: NOP4
91216: PUSH
91217: NOP4
91221: PUSH
91222: LD_INT 1
91224: ARRAY
91225: PPUSH
91226: NOP4
91230: PUSH
91231: NOP4
91235: PPUSH
91236: NOP4
91240: EQUAL
91241: AND
91242: IFFALSE 91266
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91244: NOP4
91248: PUSH
91249: LD_INT 1
91251: ARRAY
91252: PPUSH
91253: NOP4
91257: PUSH
91258: LD_INT 2
91260: ARRAY
91261: PPUSH
91262: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91266: NOP4
91270: PUSH
91271: NOP4
91275: PPUSH
91276: NOP4
91280: PPUSH
91281: NOP4
91285: PUSH
91286: NOP4
91290: ARRAY
91291: PPUSH
91292: NOP4
91296: PPUSH
91297: NOP4
91301: PPUSH
91302: NOP4
91306: ST_TO_ADDR
// end ; end ;
91307: GO 91136
91309: POP
91310: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91311: NOP4
91315: PPUSH
91316: NOP4
91320: PUSH
91321: NOP4
91325: ARRAY
91326: PUSH
91327: LD_INT 0
91329: PLUS
91330: PPUSH
91331: NOP4
// end ;
91335: LD_VAR 0 2
91339: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91340: LD_INT 0
91342: PPUSH
91343: PPUSH
91344: PPUSH
91345: PPUSH
// if not hack in hackTanks then
91346: NOP4
91350: PUSH
91351: NOP4
91355: IN
91356: NOT
91357: IFFALSE 91361
// exit ;
91359: GO 91446
// index := GetElementIndex ( hackTanks , hack ) ;
91361: NOP4
91365: PUSH
91366: NOP4
91370: PPUSH
91371: NOP4
91375: PPUSH
91376: NOP4
91380: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91381: NOP4
91385: PUSH
91386: DOUBLE
91387: LD_INT 1
91389: DEC
91390: ST_TO_ADDR
91391: NOP4
91395: PUSH
91396: NOP4
91400: ARRAY
91401: PUSH
91402: FOR_TO
91403: IFFALSE 91444
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91405: NOP4
91409: PUSH
91410: NOP4
91414: ARRAY
91415: PUSH
91416: NOP4
91420: ARRAY
91421: PUSH
91422: LD_INT 1
91424: ARRAY
91425: PUSH
91426: NOP4
91430: EQUAL
91431: IFFALSE 91442
// KillUnit ( vehicle ) ;
91433: NOP4
91437: PPUSH
91438: NOP4
91442: GO 91402
91444: POP
91445: POP
// end ;
91446: LD_VAR 0 3
91450: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91451: NOP4
91455: NOT
91456: IFFALSE 91491
91458: GO 91460
91460: DISABLE
// begin initMiner := true ;
91461: NOP4
91465: PUSH
91466: LD_INT 1
91468: ST_TO_ADDR
// minersList := [ ] ;
91469: NOP4
91473: PUSH
91474: EMPTY
91475: ST_TO_ADDR
// minerMinesList := [ ] ;
91476: NOP4
91480: PUSH
91481: EMPTY
91482: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91483: NOP4
91487: PUSH
91488: LD_INT 5
91490: ST_TO_ADDR
// end ;
91491: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91492: NOP4
91496: PUSH
91497: LD_INT 34
91499: PUSH
91500: NOP4
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PPUSH
91509: NOP4
91513: AND
91514: IFFALSE 91977
91516: GO 91518
91518: DISABLE
91519: LD_INT 0
91521: PPUSH
91522: PPUSH
91523: PPUSH
91524: PPUSH
// begin enable ;
91525: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91526: NOP4
91530: PUSH
91531: LD_INT 34
91533: PUSH
91534: NOP4
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PPUSH
91543: NOP4
91547: PUSH
91548: FOR_IN
91549: IFFALSE 91621
// begin if not i in minersList then
91551: NOP4
91555: PUSH
91556: NOP4
91560: IN
91561: NOT
91562: IFFALSE 91619
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91564: NOP4
91568: PUSH
91569: NOP4
91573: PPUSH
91574: NOP4
91578: PUSH
91579: LD_INT 1
91581: PLUS
91582: PPUSH
91583: NOP4
91587: PPUSH
91588: NOP4
91592: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91593: NOP4
91597: PUSH
91598: NOP4
91602: PPUSH
91603: NOP4
91607: PUSH
91608: LD_INT 1
91610: PLUS
91611: PPUSH
91612: EMPTY
91613: PPUSH
91614: NOP4
91618: ST_TO_ADDR
// end end ;
91619: GO 91548
91621: POP
91622: POP
// for i := minerMinesList downto 1 do
91623: NOP4
91627: PUSH
91628: DOUBLE
91629: NOP4
91633: INC
91634: ST_TO_ADDR
91635: LD_INT 1
91637: PUSH
91638: FOR_DOWNTO
91639: IFFALSE 91975
// begin if IsLive ( minersList [ i ] ) then
91641: NOP4
91645: PUSH
91646: NOP4
91650: ARRAY
91651: PPUSH
91652: NOP4
91656: IFFALSE 91684
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91658: NOP4
91662: PUSH
91663: NOP4
91667: ARRAY
91668: PPUSH
91669: NOP4
91673: PUSH
91674: NOP4
91678: ARRAY
91679: PPUSH
91680: NOP4
// if not minerMinesList [ i ] then
91684: NOP4
91688: PUSH
91689: NOP4
91693: ARRAY
91694: NOT
91695: IFFALSE 91699
// continue ;
91697: GO 91638
// for j := minerMinesList [ i ] downto 1 do
91699: NOP4
91703: PUSH
91704: DOUBLE
91705: NOP4
91709: PUSH
91710: NOP4
91714: ARRAY
91715: INC
91716: ST_TO_ADDR
91717: LD_INT 1
91719: PUSH
91720: FOR_DOWNTO
91721: IFFALSE 91971
// begin side := GetSide ( minersList [ i ] ) ;
91723: NOP4
91727: PUSH
91728: NOP4
91732: PUSH
91733: NOP4
91737: ARRAY
91738: PPUSH
91739: NOP4
91743: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91744: NOP4
91748: PUSH
91749: NOP4
91753: PUSH
91754: NOP4
91758: ARRAY
91759: PUSH
91760: NOP4
91764: ARRAY
91765: PUSH
91766: LD_INT 1
91768: ARRAY
91769: PPUSH
91770: NOP4
91774: PUSH
91775: NOP4
91779: ARRAY
91780: PUSH
91781: NOP4
91785: ARRAY
91786: PUSH
91787: LD_INT 2
91789: ARRAY
91790: PPUSH
91791: NOP4
91795: ST_TO_ADDR
// if not tmp then
91796: NOP4
91800: NOT
91801: IFFALSE 91805
// continue ;
91803: GO 91720
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91805: NOP4
91809: PUSH
91810: LD_INT 81
91812: PUSH
91813: NOP4
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PPUSH
91822: NOP4
91826: IN
91827: PUSH
91828: NOP4
91832: PUSH
91833: NOP4
91837: ARRAY
91838: PUSH
91839: NOP4
91843: ARRAY
91844: PUSH
91845: LD_INT 1
91847: ARRAY
91848: PPUSH
91849: NOP4
91853: PUSH
91854: NOP4
91858: ARRAY
91859: PUSH
91860: NOP4
91864: ARRAY
91865: PUSH
91866: LD_INT 2
91868: ARRAY
91869: PPUSH
91870: NOP4
91874: AND
91875: IFFALSE 91969
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91877: NOP4
91881: PUSH
91882: NOP4
91886: ARRAY
91887: PUSH
91888: NOP4
91892: ARRAY
91893: PUSH
91894: LD_INT 1
91896: ARRAY
91897: PPUSH
91898: NOP4
91902: PUSH
91903: NOP4
91907: ARRAY
91908: PUSH
91909: NOP4
91913: ARRAY
91914: PUSH
91915: LD_INT 2
91917: ARRAY
91918: PPUSH
91919: NOP4
91923: PPUSH
91924: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91928: NOP4
91932: PUSH
91933: NOP4
91937: PPUSH
91938: NOP4
91942: PPUSH
91943: NOP4
91947: PUSH
91948: NOP4
91952: ARRAY
91953: PPUSH
91954: NOP4
91958: PPUSH
91959: NOP4
91963: PPUSH
91964: NOP4
91968: ST_TO_ADDR
// end ; end ;
91969: GO 91720
91971: POP
91972: POP
// end ;
91973: GO 91638
91975: POP
91976: POP
// end ;
91977: PPOPN 4
91979: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91980: LD_INT 0
91982: PPUSH
91983: PPUSH
// result := false ;
91984: NOP4
91988: PUSH
91989: LD_INT 0
91991: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91992: NOP4
91996: PPUSH
91997: NOP4
92001: PUSH
92002: NOP4
92006: EQUAL
92007: NOT
92008: IFFALSE 92012
// exit ;
92010: GO 92252
// index := GetElementIndex ( minersList , unit ) ;
92012: NOP4
92016: PUSH
92017: NOP4
92021: PPUSH
92022: NOP4
92026: PPUSH
92027: NOP4
92031: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92032: NOP4
92036: PUSH
92037: NOP4
92041: ARRAY
92042: PUSH
92043: NOP4
92047: GREATEREQUAL
92048: IFFALSE 92052
// exit ;
92050: GO 92252
// ComMoveXY ( unit , x , y ) ;
92052: NOP4
92056: PPUSH
92057: NOP4
92061: PPUSH
92062: NOP4
92066: PPUSH
92067: NOP4
// repeat wait ( 0 0$1 ) ;
92071: LD_INT 35
92073: PPUSH
92074: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92078: NOP4
92082: PPUSH
92083: NOP4
92087: PPUSH
92088: NOP4
92092: PPUSH
92093: NOP4
92097: NOT
92098: PUSH
92099: NOP4
92103: PPUSH
92104: NOP4
92108: AND
92109: IFFALSE 92113
// exit ;
92111: GO 92252
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92113: NOP4
92117: PPUSH
92118: NOP4
92122: PPUSH
92123: NOP4
92127: PUSH
92128: NOP4
92132: EQUAL
92133: PUSH
92134: NOP4
92138: PPUSH
92139: NOP4
92143: NOT
92144: AND
92145: IFFALSE 92071
// PlaySoundXY ( x , y , PlantMine ) ;
92147: NOP4
92151: PPUSH
92152: NOP4
92156: PPUSH
92157: LD_STRING PlantMine
92159: PPUSH
92160: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92164: NOP4
92168: PPUSH
92169: NOP4
92173: PPUSH
92174: NOP4
92178: PPUSH
92179: NOP4
92183: PPUSH
92184: LD_INT 0
92186: PPUSH
92187: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92191: NOP4
92195: PUSH
92196: NOP4
92200: PPUSH
92201: NOP4
92205: PUSH
92206: NOP4
92210: PUSH
92211: NOP4
92215: ARRAY
92216: PUSH
92217: LD_INT 1
92219: PLUS
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PPUSH
92225: NOP4
92229: PUSH
92230: NOP4
92234: PUSH
92235: EMPTY
92236: LIST
92237: LIST
92238: PPUSH
92239: NOP4
92243: ST_TO_ADDR
// result := true ;
92244: NOP4
92248: PUSH
92249: LD_INT 1
92251: ST_TO_ADDR
// end ;
92252: LD_VAR 0 4
92256: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92257: LD_INT 0
92259: PPUSH
92260: PPUSH
92261: PPUSH
// if not unit in minersList then
92262: NOP4
92266: PUSH
92267: NOP4
92271: IN
92272: NOT
92273: IFFALSE 92277
// exit ;
92275: GO 92669
// index := GetElementIndex ( minersList , unit ) ;
92277: NOP4
92281: PUSH
92282: NOP4
92286: PPUSH
92287: NOP4
92291: PPUSH
92292: NOP4
92296: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92297: NOP4
92301: PUSH
92302: DOUBLE
92303: NOP4
92307: PUSH
92308: NOP4
92312: ARRAY
92313: INC
92314: ST_TO_ADDR
92315: LD_INT 1
92317: PUSH
92318: FOR_DOWNTO
92319: IFFALSE 92480
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92321: NOP4
92325: PUSH
92326: NOP4
92330: ARRAY
92331: PUSH
92332: NOP4
92336: ARRAY
92337: PUSH
92338: LD_INT 1
92340: ARRAY
92341: PUSH
92342: NOP4
92346: EQUAL
92347: PUSH
92348: NOP4
92352: PUSH
92353: NOP4
92357: ARRAY
92358: PUSH
92359: NOP4
92363: ARRAY
92364: PUSH
92365: LD_INT 2
92367: ARRAY
92368: PUSH
92369: NOP4
92373: EQUAL
92374: AND
92375: IFFALSE 92478
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92377: NOP4
92381: PUSH
92382: NOP4
92386: ARRAY
92387: PUSH
92388: NOP4
92392: ARRAY
92393: PUSH
92394: LD_INT 1
92396: ARRAY
92397: PPUSH
92398: NOP4
92402: PUSH
92403: NOP4
92407: ARRAY
92408: PUSH
92409: NOP4
92413: ARRAY
92414: PUSH
92415: LD_INT 2
92417: ARRAY
92418: PPUSH
92419: NOP4
92423: PPUSH
92424: NOP4
92428: PPUSH
92429: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92433: NOP4
92437: PUSH
92438: NOP4
92442: PPUSH
92443: NOP4
92447: PPUSH
92448: NOP4
92452: PUSH
92453: NOP4
92457: ARRAY
92458: PPUSH
92459: NOP4
92463: PPUSH
92464: NOP4
92468: PPUSH
92469: NOP4
92473: ST_TO_ADDR
// exit ;
92474: POP
92475: POP
92476: GO 92669
// end ; end ;
92478: GO 92318
92480: POP
92481: POP
// for i := minerMinesList [ index ] downto 1 do
92482: NOP4
92486: PUSH
92487: DOUBLE
92488: NOP4
92492: PUSH
92493: NOP4
92497: ARRAY
92498: INC
92499: ST_TO_ADDR
92500: LD_INT 1
92502: PUSH
92503: FOR_DOWNTO
92504: IFFALSE 92667
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92506: NOP4
92510: PUSH
92511: NOP4
92515: ARRAY
92516: PUSH
92517: NOP4
92521: ARRAY
92522: PUSH
92523: LD_INT 1
92525: ARRAY
92526: PPUSH
92527: NOP4
92531: PUSH
92532: NOP4
92536: ARRAY
92537: PUSH
92538: NOP4
92542: ARRAY
92543: PUSH
92544: LD_INT 2
92546: ARRAY
92547: PPUSH
92548: NOP4
92552: PPUSH
92553: NOP4
92557: PPUSH
92558: NOP4
92562: PUSH
92563: LD_INT 6
92565: LESS
92566: IFFALSE 92665
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92568: NOP4
92572: PUSH
92573: NOP4
92577: ARRAY
92578: PUSH
92579: NOP4
92583: ARRAY
92584: PUSH
92585: LD_INT 1
92587: ARRAY
92588: PPUSH
92589: NOP4
92593: PUSH
92594: NOP4
92598: ARRAY
92599: PUSH
92600: NOP4
92604: ARRAY
92605: PUSH
92606: LD_INT 2
92608: ARRAY
92609: PPUSH
92610: NOP4
92614: PPUSH
92615: NOP4
92619: PPUSH
92620: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92624: NOP4
92628: PUSH
92629: NOP4
92633: PPUSH
92634: NOP4
92638: PPUSH
92639: NOP4
92643: PUSH
92644: NOP4
92648: ARRAY
92649: PPUSH
92650: NOP4
92654: PPUSH
92655: NOP4
92659: PPUSH
92660: NOP4
92664: ST_TO_ADDR
// end ; end ;
92665: GO 92503
92667: POP
92668: POP
// end ;
92669: LD_VAR 0 4
92673: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92674: LD_INT 0
92676: PPUSH
92677: PPUSH
92678: PPUSH
92679: PPUSH
92680: PPUSH
92681: PPUSH
92682: PPUSH
92683: PPUSH
92684: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92685: NOP4
92689: PPUSH
92690: NOP4
92694: PUSH
92695: NOP4
92699: EQUAL
92700: NOT
92701: PUSH
92702: NOP4
92706: PUSH
92707: NOP4
92711: IN
92712: NOT
92713: OR
92714: IFFALSE 92718
// exit ;
92716: GO 93040
// index := GetElementIndex ( minersList , unit ) ;
92718: NOP4
92722: PUSH
92723: NOP4
92727: PPUSH
92728: NOP4
92732: PPUSH
92733: NOP4
92737: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92738: NOP4
92742: PUSH
92743: NOP4
92747: PUSH
92748: NOP4
92752: PUSH
92753: NOP4
92757: ARRAY
92758: MINUS
92759: ST_TO_ADDR
// if not minesFreeAmount then
92760: NOP4
92764: NOT
92765: IFFALSE 92769
// exit ;
92767: GO 93040
// tmp := [ ] ;
92769: NOP4
92773: PUSH
92774: EMPTY
92775: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92776: NOP4
92780: PUSH
92781: DOUBLE
92782: LD_INT 1
92784: DEC
92785: ST_TO_ADDR
92786: NOP4
92790: PUSH
92791: FOR_TO
92792: IFFALSE 92987
// begin _d := rand ( 0 , 5 ) ;
92794: NOP4
92798: PUSH
92799: LD_INT 0
92801: PPUSH
92802: LD_INT 5
92804: PPUSH
92805: NOP4
92809: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92810: NOP4
92814: PUSH
92815: LD_INT 2
92817: PPUSH
92818: LD_INT 6
92820: PPUSH
92821: NOP4
92825: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92826: NOP4
92830: PUSH
92831: NOP4
92835: PPUSH
92836: NOP4
92840: PPUSH
92841: NOP4
92845: PPUSH
92846: NOP4
92850: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92851: NOP4
92855: PUSH
92856: NOP4
92860: PPUSH
92861: NOP4
92865: PPUSH
92866: NOP4
92870: PPUSH
92871: NOP4
92875: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92876: NOP4
92880: PPUSH
92881: NOP4
92885: PPUSH
92886: NOP4
92890: PUSH
92891: NOP4
92895: PUSH
92896: NOP4
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: NOP4
92909: IN
92910: NOT
92911: AND
92912: PUSH
92913: NOP4
92917: PPUSH
92918: NOP4
92922: PPUSH
92923: NOP4
92927: NOT
92928: AND
92929: IFFALSE 92971
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92931: NOP4
92935: PUSH
92936: NOP4
92940: PPUSH
92941: NOP4
92945: PUSH
92946: LD_INT 1
92948: PLUS
92949: PPUSH
92950: NOP4
92954: PUSH
92955: NOP4
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PPUSH
92964: NOP4
92968: ST_TO_ADDR
92969: GO 92985
// i := i - 1 ;
92971: NOP4
92975: PUSH
92976: NOP4
92980: PUSH
92981: LD_INT 1
92983: MINUS
92984: ST_TO_ADDR
// end ;
92985: GO 92791
92987: POP
92988: POP
// for i in tmp do
92989: NOP4
92993: PUSH
92994: NOP4
92998: PUSH
92999: FOR_IN
93000: IFFALSE 93038
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93002: NOP4
93006: PPUSH
93007: NOP4
93011: PUSH
93012: LD_INT 1
93014: ARRAY
93015: PPUSH
93016: NOP4
93020: PUSH
93021: LD_INT 2
93023: ARRAY
93024: PPUSH
93025: NOP4
93029: NOT
93030: IFFALSE 93036
// exit ;
93032: POP
93033: POP
93034: GO 93040
93036: GO 92999
93038: POP
93039: POP
// end ;
93040: LD_VAR 0 4
93044: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93045: LD_INT 0
93047: PPUSH
93048: PPUSH
93049: PPUSH
93050: PPUSH
93051: PPUSH
93052: PPUSH
93053: PPUSH
// if not GetClass ( unit ) = class_sniper then
93054: NOP4
93058: PPUSH
93059: NOP4
93063: PUSH
93064: LD_INT 5
93066: EQUAL
93067: NOT
93068: IFFALSE 93072
// exit ;
93070: GO 93460
// dist := 8 ;
93072: NOP4
93076: PUSH
93077: LD_INT 8
93079: ST_TO_ADDR
// viewRange := 12 ;
93080: NOP4
93084: PUSH
93085: LD_INT 12
93087: ST_TO_ADDR
// side := GetSide ( unit ) ;
93088: NOP4
93092: PUSH
93093: NOP4
93097: PPUSH
93098: NOP4
93102: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93103: LD_INT 61
93105: PPUSH
93106: NOP4
93110: PPUSH
93111: NOP4
93115: PUSH
93116: LD_INT 2
93118: EQUAL
93119: IFFALSE 93129
// viewRange := 16 ;
93121: NOP4
93125: PUSH
93126: LD_INT 16
93128: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93129: NOP4
93133: PPUSH
93134: NOP4
93138: PPUSH
93139: NOP4
93143: PPUSH
93144: NOP4
93148: PUSH
93149: NOP4
93153: GREATER
93154: IFFALSE 93233
// begin ComMoveXY ( unit , x , y ) ;
93156: NOP4
93160: PPUSH
93161: NOP4
93165: PPUSH
93166: NOP4
93170: PPUSH
93171: NOP4
// repeat wait ( 0 0$1 ) ;
93175: LD_INT 35
93177: PPUSH
93178: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
93182: NOP4
93186: PPUSH
93187: NOP4
93191: PPUSH
93192: NOP4
93196: PPUSH
93197: NOP4
93201: NOT
93202: IFFALSE 93206
// exit ;
93204: GO 93460
// until GetDistUnitXY ( unit , x , y ) < dist ;
93206: NOP4
93210: PPUSH
93211: NOP4
93215: PPUSH
93216: NOP4
93220: PPUSH
93221: NOP4
93225: PUSH
93226: NOP4
93230: LESS
93231: IFFALSE 93175
// end ; ComTurnXY ( unit , x , y ) ;
93233: NOP4
93237: PPUSH
93238: NOP4
93242: PPUSH
93243: NOP4
93247: PPUSH
93248: NOP4
// wait ( 5 ) ;
93252: LD_INT 5
93254: PPUSH
93255: NOP4
// _d := GetDir ( unit ) ;
93259: NOP4
93263: PUSH
93264: NOP4
93268: PPUSH
93269: NOP4
93273: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93274: NOP4
93278: PUSH
93279: NOP4
93283: PPUSH
93284: NOP4
93288: PPUSH
93289: NOP4
93293: PPUSH
93294: NOP4
93298: PPUSH
93299: NOP4
93303: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93304: NOP4
93308: PUSH
93309: NOP4
93313: PPUSH
93314: NOP4
93318: PPUSH
93319: NOP4
93323: PPUSH
93324: NOP4
93328: PPUSH
93329: NOP4
93333: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93334: NOP4
93338: PPUSH
93339: NOP4
93343: PPUSH
93344: NOP4
93348: NOT
93349: IFFALSE 93353
// exit ;
93351: GO 93460
// ComAnimCustom ( unit , 1 ) ;
93353: NOP4
93357: PPUSH
93358: LD_INT 1
93360: PPUSH
93361: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93365: NOP4
93369: PPUSH
93370: NOP4
93374: PPUSH
93375: NOP4
93379: PPUSH
93380: NOP4
93384: PPUSH
93385: NOP4
// repeat wait ( 1 ) ;
93389: LD_INT 1
93391: PPUSH
93392: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93396: NOP4
93400: PPUSH
93401: NOP4
93405: PUSH
93406: NOP4
93410: PPUSH
93411: NOP4
93415: OR
93416: PUSH
93417: NOP4
93421: PPUSH
93422: NOP4
93426: NOT
93427: OR
93428: PUSH
93429: NOP4
93433: PPUSH
93434: NOP4
93438: OR
93439: IFFALSE 93389
// RemoveSeeing ( _x , _y , side ) ;
93441: NOP4
93445: PPUSH
93446: NOP4
93450: PPUSH
93451: NOP4
93455: PPUSH
93456: NOP4
// end ; end_of_file
93460: LD_VAR 0 4
93464: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93465: NOP4
93469: PUSH
93470: LD_INT 200
93472: DOUBLE
93473: GREATEREQUAL
93474: IFFALSE 93482
93476: LD_INT 299
93478: DOUBLE
93479: LESSEQUAL
93480: IFTRUE 93484
93482: GO 93516
93484: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93485: NOP4
93489: PPUSH
93490: NOP4
93494: PPUSH
93495: NOP4
93499: PPUSH
93500: NOP4
93504: PPUSH
93505: NOP4
93509: PPUSH
93510: NOP4
93514: GO 93593
93516: LD_INT 300
93518: DOUBLE
93519: GREATEREQUAL
93520: IFFALSE 93528
93522: LD_INT 399
93524: DOUBLE
93525: LESSEQUAL
93526: IFTRUE 93530
93528: GO 93592
93530: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93531: NOP4
93535: PPUSH
93536: NOP4
93540: PPUSH
93541: NOP4
93545: PPUSH
93546: NOP4
93550: PPUSH
93551: NOP4
93555: PPUSH
93556: NOP4
93560: PPUSH
93561: NOP4
93565: PPUSH
93566: NOP4
93570: PPUSH
93571: NOP4
93575: PPUSH
93576: NOP4
93580: PPUSH
93581: NOP4
93585: PPUSH
93586: NOP4
93590: GO 93593
93592: POP
// end ;
93593: PPOPN 11
93595: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93596: NOP4
93600: PPUSH
93601: NOP4
93605: PPUSH
93606: NOP4
93610: PPUSH
93611: NOP4
93615: PPUSH
93616: NOP4
93620: PPUSH
93621: NOP4
// end ;
93625: PPOPN 5
93627: END
