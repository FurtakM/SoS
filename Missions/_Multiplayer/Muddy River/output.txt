// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 331 0 0
// InitMultiplayer ;
  20: CALL 592 0 0
// if debug then
  24: LD_EXP 1
  28: IFFALSE 37
// FogOff ( 1 ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL_OW 344
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  37: LD_INT 2
  39: PPUSH
  40: CALL 1868 0 1
  44: PPUSH
  45: CALL 5813 0 1
// Multiplayer_Start ;
  49: CALL 3730 0 0
// ResetFog ;
  53: CALL_OW 335
// InitMacro ;
  57: CALL 51249 0 0
// MC_Start ( ) ;
  61: CALL 53429 0 0
// game := true ;
  65: LD_ADDR_EXP 2
  69: PUSH
  70: LD_INT 1
  72: ST_TO_ADDR
// Multiplayer_End ;
  73: CALL 3846 0 0
// end ;
  77: END
// export function CustomInitMacro ; var i ; begin
  78: LD_INT 0
  80: PPUSH
  81: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
  82: LD_INT 1
  84: PPUSH
  85: LD_INT 8
  87: PUSH
  88: LD_INT 10
  90: PUSH
  91: LD_INT 12
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: PUSH
  99: LD_OWVAR 67
 103: ARRAY
 104: PPUSH
 105: LD_INT 3
 107: PPUSH
 108: CALL 75167 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 112: LD_INT 2
 114: PPUSH
 115: LD_INT 6
 117: PUSH
 118: LD_INT 8
 120: PUSH
 121: LD_INT 9
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 75167 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 6
 147: PUSH
 148: LD_INT 7
 150: PUSH
 151: LD_INT 9
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: PPUSH
 165: LD_INT 1
 167: PPUSH
 168: CALL 75167 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 172: LD_INT 4
 174: PPUSH
 175: LD_INT 6
 177: PUSH
 178: LD_INT 7
 180: PUSH
 181: LD_INT 9
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: PPUSH
 195: LD_INT 25
 197: PPUSH
 198: CALL 75167 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 202: LD_INT 5
 204: PPUSH
 205: LD_INT 4
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 6
 213: PUSH
 214: EMPTY
 215: LIST
 216: LIST
 217: LIST
 218: PUSH
 219: LD_OWVAR 67
 223: ARRAY
 224: PPUSH
 225: LD_INT 39
 227: PPUSH
 228: CALL 75167 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 232: LD_ADDR_EXP 67
 236: PUSH
 237: LD_INT 20
 239: PUSH
 240: LD_INT 21
 242: PUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 24
 248: PUSH
 249: LD_INT 20
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 259: LD_ADDR_EXP 68
 263: PUSH
 264: LD_INT 35
 266: PUSH
 267: LD_INT 34
 269: PUSH
 270: LD_INT 36
 272: PUSH
 273: LD_INT 33
 275: PUSH
 276: LD_INT 38
 278: PUSH
 279: EMPTY
 280: LIST
 281: LIST
 282: LIST
 283: LIST
 284: LIST
 285: ST_TO_ADDR
// for i = 1 to 4 do
 286: LD_ADDR_VAR 0 2
 290: PUSH
 291: DOUBLE
 292: LD_INT 1
 294: DEC
 295: ST_TO_ADDR
 296: LD_INT 4
 298: PUSH
 299: FOR_TO
 300: IFFALSE 324
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 302: LD_VAR 0 2
 306: PPUSH
 307: LD_EXP 38
 311: PUSH
 312: LD_VAR 0 2
 316: ARRAY
 317: PPUSH
 318: CALL 75593 0 2
 322: GO 299
 324: POP
 325: POP
// end ;
 326: LD_VAR 0 1
 330: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 331: LD_INT 0
 333: PPUSH
// debug := 1 ;
 334: LD_ADDR_EXP 1
 338: PUSH
 339: LD_INT 1
 341: ST_TO_ADDR
// side_bot := 2 ;
 342: LD_ADDR_EXP 3
 346: PUSH
 347: LD_INT 2
 349: ST_TO_ADDR
// artifact_get := false ;
 350: LD_ADDR_EXP 4
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 358: LD_ADDR_EXP 5
 362: PUSH
 363: LD_STRING base_a
 365: PUSH
 366: LD_STRING base_b
 368: PUSH
 369: LD_STRING base_c
 371: PUSH
 372: LD_STRING base_d
 374: PUSH
 375: LD_STRING base_e
 377: PUSH
 378: LD_STRING base_f
 380: PUSH
 381: LD_STRING base_g
 383: PUSH
 384: LD_STRING base_h
 386: PUSH
 387: LD_STRING base_i
 389: PUSH
 390: LD_STRING base_j
 392: PUSH
 393: LD_STRING base_k
 395: PUSH
 396: LD_STRING base_l
 398: PUSH
 399: LD_STRING base_m
 401: PUSH
 402: LD_STRING base_n
 404: PUSH
 405: LD_STRING base_o
 407: PUSH
 408: LD_STRING base_p
 410: PUSH
 411: LD_STRING base_r
 413: PUSH
 414: LD_STRING base_s
 416: PUSH
 417: LD_STRING base_t
 419: PUSH
 420: LD_STRING base_u
 422: PUSH
 423: LD_STRING base_w
 425: PUSH
 426: LD_STRING base_x
 428: PUSH
 429: LD_STRING base_y
 431: PUSH
 432: LD_STRING base_z
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// end ;
 461: LD_VAR 0 1
 465: RET
// every 0 0$01 trigger game and not debug_strings do
 466: LD_EXP 2
 470: PUSH
 471: LD_OWVAR 48
 475: NOT
 476: AND
 477: IFFALSE 493
 479: GO 481
 481: DISABLE
// begin enable ;
 482: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 483: LD_ADDR_OWVAR 47
 487: PUSH
 488: CALL 4547 0 0
 492: ST_TO_ADDR
// end ;
 493: END
// function Debuger ; var i ; begin
 494: LD_INT 0
 496: PPUSH
 497: PPUSH
// if not debug then
 498: LD_EXP 1
 502: NOT
 503: IFFALSE 507
// exit ;
 505: GO 579
// game_speed := 5 ;
 507: LD_ADDR_OWVAR 65
 511: PUSH
 512: LD_INT 5
 514: ST_TO_ADDR
// uc_side := 1 ;
 515: LD_ADDR_OWVAR 20
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// uc_nation := 1 ;
 523: LD_ADDR_OWVAR 21
 527: PUSH
 528: LD_INT 1
 530: ST_TO_ADDR
// for i = 1 to 10 do
 531: LD_ADDR_VAR 0 2
 535: PUSH
 536: DOUBLE
 537: LD_INT 1
 539: DEC
 540: ST_TO_ADDR
 541: LD_INT 10
 543: PUSH
 544: FOR_TO
 545: IFFALSE 577
// begin PrepareHuman ( false , 1 , 10 ) ;
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 10
 555: PPUSH
 556: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 560: CALL_OW 44
 564: PPUSH
 565: LD_INT 9
 567: PPUSH
 568: LD_INT 0
 570: PPUSH
 571: CALL_OW 49
// end ;
 575: GO 544
 577: POP
 578: POP
// end ;
 579: LD_VAR 0 1
 583: RET
// export function CustomEvent ( event ) ; begin
 584: LD_INT 0
 586: PPUSH
// end ; end_of_file
 587: LD_VAR 0 2
 591: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 592: LD_INT 0
 594: PPUSH
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
// multi_settings_counter := 6 ;
 599: LD_ADDR_EXP 18
 603: PUSH
 604: LD_INT 6
 606: ST_TO_ADDR
// if multiplayer then
 607: LD_OWVAR 4
 611: IFFALSE 791
// begin your_side := mp_player_side ;
 613: LD_ADDR_OWVAR 2
 617: PUSH
 618: LD_OWVAR 7
 622: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 623: LD_ADDR_EXP 6
 627: PUSH
 628: LD_OWVAR 6
 632: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 633: LD_ADDR_EXP 7
 637: PUSH
 638: LD_OWVAR 17
 642: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 643: LD_ADDR_EXP 8
 647: PUSH
 648: LD_OWVAR 15
 652: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 653: LD_ADDR_EXP 9
 657: PUSH
 658: LD_OWVAR 16
 662: ST_TO_ADDR
// multi_teams := [ [ ] ] ;
 663: LD_ADDR_EXP 10
 667: PUSH
 668: EMPTY
 669: PUSH
 670: EMPTY
 671: LIST
 672: ST_TO_ADDR
// for i in mp_teams do
 673: LD_ADDR_VAR 0 2
 677: PUSH
 678: LD_OWVAR 12
 682: PUSH
 683: FOR_IN
 684: IFFALSE 727
// if i then
 686: LD_VAR 0 2
 690: IFFALSE 725
// multi_teams := Replace ( multi_teams , 1 , multi_teams [ 1 ] union i ) ;
 692: LD_ADDR_EXP 10
 696: PUSH
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 1
 704: PPUSH
 705: LD_EXP 10
 709: PUSH
 710: LD_INT 1
 712: ARRAY
 713: PUSH
 714: LD_VAR 0 2
 718: UNION
 719: PPUSH
 720: CALL_OW 1
 724: ST_TO_ADDR
 725: GO 683
 727: POP
 728: POP
// for i = 1 to multi_settings_counter do
 729: LD_ADDR_VAR 0 2
 733: PUSH
 734: DOUBLE
 735: LD_INT 1
 737: DEC
 738: ST_TO_ADDR
 739: LD_EXP 18
 743: PUSH
 744: FOR_TO
 745: IFFALSE 787
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 747: LD_ADDR_EXP 17
 751: PUSH
 752: LD_EXP 17
 756: PPUSH
 757: LD_EXP 17
 761: PUSH
 762: LD_INT 1
 764: PLUS
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: CALL_OW 426
 775: PUSH
 776: LD_INT 1
 778: PLUS
 779: PPUSH
 780: CALL_OW 2
 784: ST_TO_ADDR
 785: GO 744
 787: POP
 788: POP
// end else
 789: GO 973
// begin your_side := 1 ;
 791: LD_ADDR_OWVAR 2
 795: PUSH
 796: LD_INT 1
 798: ST_TO_ADDR
// multi_gametype := 1 ;
 799: LD_ADDR_EXP 6
 803: PUSH
 804: LD_INT 1
 806: ST_TO_ADDR
// multi_sides := [ 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 807: LD_ADDR_EXP 7
 811: PUSH
 812: LD_INT 2
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 0
 820: PUSH
 821: LD_INT 0
 823: PUSH
 824: LD_INT 0
 826: PUSH
 827: LD_INT 0
 829: PUSH
 830: LD_INT 0
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: ST_TO_ADDR
// multi_side_teams := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 846: LD_ADDR_EXP 8
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 0
 859: PUSH
 860: LD_INT 0
 862: PUSH
 863: LD_INT 0
 865: PUSH
 866: LD_INT 0
 868: PUSH
 869: LD_INT 0
 871: PUSH
 872: LD_INT 0
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: ST_TO_ADDR
// multi_nations := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 885: LD_ADDR_EXP 9
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: LD_INT 0
 907: PUSH
 908: LD_INT 0
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: ST_TO_ADDR
// multi_teams := [ [ 1 , 2 ] ] ;
 924: LD_ADDR_EXP 10
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 2
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: PUSH
 939: EMPTY
 940: LIST
 941: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 942: LD_ADDR_EXP 17
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 2
 952: PUSH
 953: LD_INT 1
 955: PUSH
 956: LD_INT 3
 958: PUSH
 959: LD_INT 1
 961: PUSH
 962: LD_INT 1
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 973: LD_ADDR_EXP 11
 977: PUSH
 978: LD_INT 0
 980: PUSH
 981: LD_INT 0
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 0
 998: PUSH
 999: LD_INT 0
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1012: LD_ADDR_EXP 14
1016: PUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 0
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 0
1031: PUSH
1032: LD_INT 0
1034: PUSH
1035: LD_INT 0
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1051: LD_ADDR_EXP 25
1055: PUSH
1056: LD_INT 0
1058: PUSH
1059: LD_INT 0
1061: PUSH
1062: LD_INT 0
1064: PUSH
1065: LD_INT 0
1067: PUSH
1068: LD_INT 0
1070: PUSH
1071: LD_INT 0
1073: PUSH
1074: LD_INT 0
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: ST_TO_ADDR
// multi_teamgame := true ;
1090: LD_ADDR_EXP 15
1094: PUSH
1095: LD_INT 1
1097: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1098: LD_ADDR_EXP 13
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: EMPTY
1107: LIST
1108: ST_TO_ADDR
// multi_custom_commanders := true ;
1109: LD_ADDR_EXP 16
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// multi_commanders := [ ] ;
1117: LD_ADDR_EXP 24
1121: PUSH
1122: EMPTY
1123: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1124: LD_ADDR_EXP 27
1128: PUSH
1129: EMPTY
1130: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1131: LD_ADDR_EXP 28
1135: PUSH
1136: LD_INT 0
1138: ST_TO_ADDR
// multi_players_amount := 0 ;
1139: LD_ADDR_EXP 26
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1147: LD_ADDR_EXP 12
1151: PUSH
1152: LD_INT 9
1154: PUSH
1155: LD_INT 8
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 26
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 29
1174: PUSH
1175: LD_INT 28
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: ST_TO_ADDR
// for i = 1 to 8 do
1187: LD_ADDR_VAR 0 2
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_INT 8
1199: PUSH
1200: FOR_TO
1201: IFFALSE 1530
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1203: LD_VAR 0 2
1207: PPUSH
1208: CALL_OW 530
1212: IFFALSE 1370
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1214: LD_ADDR_EXP 11
1218: PUSH
1219: LD_EXP 11
1223: PPUSH
1224: LD_VAR 0 2
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: CALL_OW 1
1236: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1237: LD_ADDR_EXP 9
1241: PUSH
1242: LD_EXP 9
1246: PPUSH
1247: LD_VAR 0 2
1251: PPUSH
1252: LD_INT 0
1254: PPUSH
1255: CALL_OW 1
1259: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1260: LD_ADDR_EXP 7
1264: PUSH
1265: LD_EXP 7
1269: PPUSH
1270: LD_VAR 0 2
1274: PPUSH
1275: LD_INT 0
1277: PPUSH
1278: CALL_OW 1
1282: ST_TO_ADDR
// for j = 1 to multi_teams do
1283: LD_ADDR_VAR 0 3
1287: PUSH
1288: DOUBLE
1289: LD_INT 1
1291: DEC
1292: ST_TO_ADDR
1293: LD_EXP 10
1297: PUSH
1298: FOR_TO
1299: IFFALSE 1368
// begin if i in multi_teams [ j ] then
1301: LD_VAR 0 2
1305: PUSH
1306: LD_EXP 10
1310: PUSH
1311: LD_VAR 0 3
1315: ARRAY
1316: IN
1317: IFFALSE 1366
// begin tmp := multi_teams [ j ] diff i ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: LD_EXP 10
1328: PUSH
1329: LD_VAR 0 3
1333: ARRAY
1334: PUSH
1335: LD_VAR 0 2
1339: DIFF
1340: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1341: LD_ADDR_EXP 10
1345: PUSH
1346: LD_EXP 10
1350: PPUSH
1351: LD_VAR 0 3
1355: PPUSH
1356: LD_VAR 0 5
1360: PPUSH
1361: CALL_OW 1
1365: ST_TO_ADDR
// end ; end ;
1366: GO 1298
1368: POP
1369: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1370: LD_EXP 9
1374: PUSH
1375: LD_VAR 0 2
1379: ARRAY
1380: PUSH
1381: LD_EXP 9
1385: PUSH
1386: LD_VAR 0 2
1390: ARRAY
1391: PUSH
1392: LD_EXP 13
1396: IN
1397: NOT
1398: AND
1399: IFFALSE 1440
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1401: LD_ADDR_EXP 9
1405: PUSH
1406: LD_EXP 9
1410: PPUSH
1411: LD_VAR 0 2
1415: PPUSH
1416: LD_EXP 13
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_EXP 13
1428: PPUSH
1429: CALL_OW 12
1433: ARRAY
1434: PPUSH
1435: CALL_OW 1
1439: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1440: LD_EXP 9
1444: PUSH
1445: LD_VAR 0 2
1449: ARRAY
1450: NOT
1451: PUSH
1452: LD_EXP 7
1456: PUSH
1457: LD_VAR 0 2
1461: ARRAY
1462: NOT
1463: AND
1464: PUSH
1465: LD_EXP 11
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: AND
1477: IFFALSE 1502
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1479: LD_ADDR_EXP 14
1483: PUSH
1484: LD_EXP 14
1488: PPUSH
1489: LD_VAR 0 2
1493: PPUSH
1494: LD_INT 1
1496: PPUSH
1497: CALL_OW 1
1501: ST_TO_ADDR
// if multi_sides [ i ] then
1502: LD_EXP 7
1506: PUSH
1507: LD_VAR 0 2
1511: ARRAY
1512: IFFALSE 1528
// multi_players_amount := multi_players_amount + 1 ;
1514: LD_ADDR_EXP 26
1518: PUSH
1519: LD_EXP 26
1523: PUSH
1524: LD_INT 1
1526: PLUS
1527: ST_TO_ADDR
// end ;
1528: GO 1200
1530: POP
1531: POP
// for i in multi_teams do
1532: LD_ADDR_VAR 0 2
1536: PUSH
1537: LD_EXP 10
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1651
// begin for j = 2 to i do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: DOUBLE
1551: LD_INT 2
1553: DEC
1554: ST_TO_ADDR
1555: LD_VAR 0 2
1559: PUSH
1560: FOR_TO
1561: IFFALSE 1647
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1563: LD_VAR 0 2
1567: PUSH
1568: LD_VAR 0 3
1572: ARRAY
1573: PPUSH
1574: LD_VAR 0 2
1578: PUSH
1579: LD_INT 1
1581: ARRAY
1582: PPUSH
1583: CALL_OW 343
// for x = 1 to j - 1 do
1587: LD_ADDR_VAR 0 4
1591: PUSH
1592: DOUBLE
1593: LD_INT 1
1595: DEC
1596: ST_TO_ADDR
1597: LD_VAR 0 3
1601: PUSH
1602: LD_INT 1
1604: MINUS
1605: PUSH
1606: FOR_TO
1607: IFFALSE 1643
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1609: LD_VAR 0 2
1613: PUSH
1614: LD_VAR 0 3
1618: ARRAY
1619: PPUSH
1620: LD_VAR 0 2
1624: PUSH
1625: LD_VAR 0 4
1629: ARRAY
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: CALL_OW 80
1641: GO 1606
1643: POP
1644: POP
// end ;
1645: GO 1560
1647: POP
1648: POP
// end ;
1649: GO 1542
1651: POP
1652: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1653: LD_ADDR_OWVAR 67
1657: PUSH
1658: LD_INT 1
1660: PUSH
1661: LD_INT 2
1663: PUSH
1664: LD_INT 3
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_EXP 17
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: ARRAY
1681: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1682: LD_ADDR_EXP 19
1686: PUSH
1687: LD_INT 9
1689: PUSH
1690: LD_INT 12
1692: PUSH
1693: LD_INT 15
1695: PUSH
1696: LD_INT 18
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: PUSH
1705: LD_EXP 17
1709: PUSH
1710: LD_INT 2
1712: ARRAY
1713: ARRAY
1714: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1715: LD_ADDR_EXP 20
1719: PUSH
1720: LD_INT 5
1722: PUSH
1723: LD_INT 7
1725: PUSH
1726: LD_INT 9
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: PUSH
1734: LD_EXP 17
1738: PUSH
1739: LD_INT 3
1741: ARRAY
1742: ARRAY
1743: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1744: LD_ADDR_EXP 21
1748: PUSH
1749: LD_INT 6000
1751: PUSH
1752: LD_INT 1575
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 8000
1761: PUSH
1762: LD_INT 1260
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: PUSH
1769: LD_INT 10000
1771: PUSH
1772: LD_INT 770
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PUSH
1779: LD_INT 15000
1781: PUSH
1782: LD_INT 770
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: PUSH
1795: LD_EXP 17
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: ARRAY
1804: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1805: LD_ADDR_EXP 22
1809: PUSH
1810: LD_INT 6
1812: PUSH
1813: LD_INT 8
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: LIST
1823: PUSH
1824: LD_EXP 17
1828: PUSH
1829: LD_INT 5
1831: ARRAY
1832: ARRAY
1833: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1834: LD_ADDR_EXP 23
1838: PUSH
1839: LD_INT 0
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: LIST
1852: PUSH
1853: LD_EXP 17
1857: PUSH
1858: LD_INT 6
1860: ARRAY
1861: ARRAY
1862: ST_TO_ADDR
// end ;
1863: LD_VAR 0 1
1867: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1868: LD_INT 0
1870: PPUSH
1871: PPUSH
// if not multi_sides [ 2 ] then
1872: LD_EXP 7
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: NOT
1881: IFFALSE 1895
// begin result := preferSide ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: LD_VAR 0 1
1892: ST_TO_ADDR
// exit ;
1893: GO 1942
// end ; for i := 1 to 8 do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_INT 8
1907: PUSH
1908: FOR_TO
1909: IFFALSE 1940
// if not multi_sides [ i ] then
1911: LD_EXP 7
1915: PUSH
1916: LD_VAR 0 3
1920: ARRAY
1921: NOT
1922: IFFALSE 1938
// begin result := i ;
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_VAR 0 3
1933: ST_TO_ADDR
// exit ;
1934: POP
1935: POP
1936: GO 1942
// end ;
1938: GO 1908
1940: POP
1941: POP
// end ;
1942: LD_VAR 0 2
1946: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1947: LD_INT 0
1949: PPUSH
// uc_side := side ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_VAR 0 1
1959: ST_TO_ADDR
// uc_nation := 1 ;
1960: LD_ADDR_OWVAR 21
1964: PUSH
1965: LD_INT 1
1967: ST_TO_ADDR
// hc_importance := 100 ;
1968: LD_ADDR_OWVAR 32
1972: PUSH
1973: LD_INT 100
1975: ST_TO_ADDR
// hc_class := 1 ;
1976: LD_ADDR_OWVAR 28
1980: PUSH
1981: LD_INT 1
1983: ST_TO_ADDR
// if num = 1 then
1984: LD_VAR 0 2
1988: PUSH
1989: LD_INT 1
1991: EQUAL
1992: IFFALSE 2074
// begin hc_gallery := us ;
1994: LD_ADDR_OWVAR 33
1998: PUSH
1999: LD_STRING us
2001: ST_TO_ADDR
// hc_face_number := 5 ;
2002: LD_ADDR_OWVAR 34
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// hc_name := John Macmilan ;
2010: LD_ADDR_OWVAR 26
2014: PUSH
2015: LD_STRING John Macmilan
2017: ST_TO_ADDR
// hc_sex := sex_male ;
2018: LD_ADDR_OWVAR 27
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2026: LD_ADDR_OWVAR 31
2030: PUSH
2031: LD_INT 7
2033: PUSH
2034: LD_INT 2
2036: PUSH
2037: LD_INT 4
2039: PUSH
2040: LD_INT 4
2042: PUSH
2043: EMPTY
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2049: LD_ADDR_OWVAR 29
2053: PUSH
2054: LD_INT 11
2056: PUSH
2057: LD_INT 10
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: ST_TO_ADDR
// result := CreateHuman ;
2064: LD_ADDR_VAR 0 3
2068: PUSH
2069: CALL_OW 44
2073: ST_TO_ADDR
// end ; if num = 2 then
2074: LD_VAR 0 2
2078: PUSH
2079: LD_INT 2
2081: EQUAL
2082: IFFALSE 2164
// begin hc_gallery := us ;
2084: LD_ADDR_OWVAR 33
2088: PUSH
2089: LD_STRING us
2091: ST_TO_ADDR
// hc_face_number := 2 ;
2092: LD_ADDR_OWVAR 34
2096: PUSH
2097: LD_INT 2
2099: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2100: LD_ADDR_OWVAR 26
2104: PUSH
2105: LD_STRING Lucy Donaldson
2107: ST_TO_ADDR
// hc_sex := sex_female ;
2108: LD_ADDR_OWVAR 27
2112: PUSH
2113: LD_INT 2
2115: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2116: LD_ADDR_OWVAR 31
2120: PUSH
2121: LD_INT 6
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 4
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2139: LD_ADDR_OWVAR 29
2143: PUSH
2144: LD_INT 9
2146: PUSH
2147: LD_INT 12
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: ST_TO_ADDR
// result := CreateHuman ;
2154: LD_ADDR_VAR 0 3
2158: PUSH
2159: CALL_OW 44
2163: ST_TO_ADDR
// end ; if num = 3 then
2164: LD_VAR 0 2
2168: PUSH
2169: LD_INT 3
2171: EQUAL
2172: IFFALSE 2254
// begin hc_gallery := us ;
2174: LD_ADDR_OWVAR 33
2178: PUSH
2179: LD_STRING us
2181: ST_TO_ADDR
// hc_face_number := 7 ;
2182: LD_ADDR_OWVAR 34
2186: PUSH
2187: LD_INT 7
2189: ST_TO_ADDR
// hc_name := Arthur Powell ;
2190: LD_ADDR_OWVAR 26
2194: PUSH
2195: LD_STRING Arthur Powell
2197: ST_TO_ADDR
// hc_sex := sex_male ;
2198: LD_ADDR_OWVAR 27
2202: PUSH
2203: LD_INT 1
2205: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2206: LD_ADDR_OWVAR 31
2210: PUSH
2211: LD_INT 8
2213: PUSH
2214: LD_INT 2
2216: PUSH
2217: LD_INT 5
2219: PUSH
2220: LD_INT 2
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2229: LD_ADDR_OWVAR 29
2233: PUSH
2234: LD_INT 10
2236: PUSH
2237: LD_INT 11
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: ST_TO_ADDR
// result := CreateHuman ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: CALL_OW 44
2253: ST_TO_ADDR
// end ; end ;
2254: LD_VAR 0 3
2258: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
2266: PPUSH
2267: PPUSH
2268: PPUSH
2269: PPUSH
// for i = 1 to 8 do
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_INT 8
2282: PUSH
2283: FOR_TO
2284: IFFALSE 3174
// begin if not multi_sides [ i ] then
2286: LD_EXP 7
2290: PUSH
2291: LD_VAR 0 2
2295: ARRAY
2296: NOT
2297: IFFALSE 2301
// continue ;
2299: GO 2283
// if multi_custom_commanders then
2301: LD_EXP 16
2305: IFFALSE 2397
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 2
2316: PPUSH
2317: LD_EXP 7
2321: PUSH
2322: LD_VAR 0 2
2326: ARRAY
2327: PPUSH
2328: CALL 1947 0 2
2332: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2333: LD_ADDR_EXP 24
2337: PUSH
2338: LD_EXP 24
2342: PPUSH
2343: LD_EXP 24
2347: PUSH
2348: LD_INT 1
2350: PLUS
2351: PPUSH
2352: LD_VAR 0 5
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_EXP 12
2371: PUSH
2372: LD_EXP 7
2376: PUSH
2377: LD_VAR 0 2
2381: ARRAY
2382: ARRAY
2383: PUSH
2384: LD_INT 1
2386: ARRAY
2387: PPUSH
2388: LD_INT 0
2390: PPUSH
2391: CALL_OW 49
// end else
2395: GO 2608
// begin uc_side := i ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_VAR 0 2
2406: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2407: LD_ADDR_OWVAR 21
2411: PUSH
2412: LD_EXP 9
2416: PUSH
2417: LD_VAR 0 2
2421: ARRAY
2422: ST_TO_ADDR
// hc_importance := 100 ;
2423: LD_ADDR_OWVAR 32
2427: PUSH
2428: LD_INT 100
2430: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2431: LD_INT 0
2433: PPUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_EXP 20
2441: PPUSH
2442: CALL_OW 380
// if multiplayer then
2446: LD_OWVAR 4
2450: IFFALSE 2508
// begin hc_name := mp_sides_players_names [ i ] ;
2452: LD_ADDR_OWVAR 26
2456: PUSH
2457: LD_OWVAR 19
2461: PUSH
2462: LD_VAR 0 2
2466: ARRAY
2467: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING MULTIAVATARS
2475: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2476: LD_ADDR_OWVAR 34
2480: PUSH
2481: LD_VAR 0 2
2485: PPUSH
2486: CALL_OW 525
2490: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2491: LD_ADDR_OWVAR 27
2495: PUSH
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 526
2505: ST_TO_ADDR
// end else
2506: GO 2540
// begin hc_gallery :=  ;
2508: LD_ADDR_OWVAR 33
2512: PUSH
2513: LD_STRING 
2515: ST_TO_ADDR
// hc_name :=  ;
2516: LD_ADDR_OWVAR 26
2520: PUSH
2521: LD_STRING 
2523: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: ST_TO_ADDR
// end ; un := CreateHuman ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: CALL_OW 44
2549: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2550: LD_VAR 0 5
2554: PPUSH
2555: LD_EXP 12
2559: PUSH
2560: LD_EXP 7
2564: PUSH
2565: LD_VAR 0 2
2569: ARRAY
2570: ARRAY
2571: PUSH
2572: LD_INT 1
2574: ARRAY
2575: PPUSH
2576: LD_INT 0
2578: PPUSH
2579: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2583: LD_ADDR_EXP 24
2587: PUSH
2588: LD_EXP 24
2592: PPUSH
2593: LD_VAR 0 2
2597: PPUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: CALL_OW 1
2607: ST_TO_ADDR
// end ; InitHc ;
2608: CALL_OW 19
// InitUc ;
2612: CALL_OW 18
// uc_side := i ;
2616: LD_ADDR_OWVAR 20
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_EXP 9
2635: PUSH
2636: LD_VAR 0 2
2640: ARRAY
2641: ST_TO_ADDR
// hc_gallery :=  ;
2642: LD_ADDR_OWVAR 33
2646: PUSH
2647: LD_STRING 
2649: ST_TO_ADDR
// hc_name :=  ;
2650: LD_ADDR_OWVAR 26
2654: PUSH
2655: LD_STRING 
2657: ST_TO_ADDR
// hc_importance := 0 ;
2658: LD_ADDR_OWVAR 32
2662: PUSH
2663: LD_INT 0
2665: ST_TO_ADDR
// cl := 1 ;
2666: LD_ADDR_VAR 0 4
2670: PUSH
2671: LD_INT 1
2673: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2674: LD_ADDR_VAR 0 3
2678: PUSH
2679: DOUBLE
2680: LD_INT 2
2682: DEC
2683: ST_TO_ADDR
2684: LD_EXP 19
2688: PUSH
2689: FOR_TO
2690: IFFALSE 3062
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2692: LD_VAR 0 3
2696: PUSH
2697: LD_INT 1
2699: MINUS
2700: PUSH
2701: LD_EXP 19
2705: PUSH
2706: LD_INT 1
2708: MINUS
2709: PUSH
2710: LD_INT 4
2712: DIVREAL
2713: MOD
2714: PUSH
2715: LD_INT 0
2717: EQUAL
2718: IFFALSE 2734
// cl := cl + 1 ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_VAR 0 4
2729: PUSH
2730: LD_INT 1
2732: PLUS
2733: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2734: LD_INT 0
2736: PPUSH
2737: LD_VAR 0 4
2741: PPUSH
2742: LD_EXP 20
2746: PPUSH
2747: CALL_OW 380
// un := CreateHuman ;
2751: LD_ADDR_VAR 0 5
2755: PUSH
2756: CALL_OW 44
2760: ST_TO_ADDR
// if j > copy then
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 8
2770: GREATER
2771: IFFALSE 2800
// copy := Replace ( copy , j , un ) else
2773: LD_ADDR_VAR 0 8
2777: PUSH
2778: LD_VAR 0 8
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_VAR 0 5
2792: PPUSH
2793: CALL_OW 1
2797: ST_TO_ADDR
2798: GO 2882
// begin CopySkills ( copy [ j ] , un ) ;
2800: LD_VAR 0 8
2804: PUSH
2805: LD_VAR 0 3
2809: ARRAY
2810: PPUSH
2811: LD_VAR 0 5
2815: PPUSH
2816: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2820: LD_VAR 0 5
2824: PPUSH
2825: LD_INT 2
2827: PPUSH
2828: LD_VAR 0 8
2832: PUSH
2833: LD_VAR 0 3
2837: ARRAY
2838: PPUSH
2839: LD_INT 2
2841: PPUSH
2842: CALL_OW 260
2846: PPUSH
2847: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2851: LD_VAR 0 5
2855: PPUSH
2856: LD_INT 1
2858: PPUSH
2859: LD_VAR 0 8
2863: PUSH
2864: LD_VAR 0 3
2868: ARRAY
2869: PPUSH
2870: LD_INT 1
2872: PPUSH
2873: CALL_OW 260
2877: PPUSH
2878: CALL_OW 239
// end ; if multi_pos_area then
2882: LD_EXP 12
2886: IFFALSE 3060
// begin if GetClass ( un ) = 3 then
2888: LD_VAR 0 5
2892: PPUSH
2893: CALL_OW 257
2897: PUSH
2898: LD_INT 3
2900: EQUAL
2901: IFFALSE 3027
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2903: LD_INT 3
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_VAR 0 3
2917: PUSH
2918: LD_INT 2
2920: MOD
2921: PUSH
2922: LD_INT 1
2924: PLUS
2925: ARRAY
2926: PPUSH
2927: LD_INT 2
2929: PPUSH
2930: LD_INT 1
2932: PPUSH
2933: LD_INT 5
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_VAR 0 3
2951: PUSH
2952: LD_INT 3
2954: MOD
2955: PUSH
2956: LD_INT 1
2958: PLUS
2959: ARRAY
2960: PPUSH
2961: LD_INT 100
2963: PPUSH
2964: CALL 14795 0 5
// veh := CreateVehicle ;
2968: LD_ADDR_VAR 0 6
2972: PUSH
2973: CALL_OW 45
2977: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2978: LD_VAR 0 6
2982: PPUSH
2983: LD_EXP 12
2987: PUSH
2988: LD_EXP 7
2992: PUSH
2993: LD_VAR 0 2
2997: ARRAY
2998: ARRAY
2999: PUSH
3000: LD_INT 2
3002: ARRAY
3003: PPUSH
3004: LD_INT 0
3006: PPUSH
3007: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3011: LD_VAR 0 5
3015: PPUSH
3016: LD_VAR 0 6
3020: PPUSH
3021: CALL_OW 52
// continue ;
3025: GO 2689
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3027: LD_VAR 0 5
3031: PPUSH
3032: LD_EXP 12
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_VAR 0 2
3046: ARRAY
3047: ARRAY
3048: PUSH
3049: LD_INT 1
3051: ARRAY
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: CALL_OW 49
// end ; end ;
3060: GO 2689
3062: POP
3063: POP
// for j = 1 to 3 do
3064: LD_ADDR_VAR 0 3
3068: PUSH
3069: DOUBLE
3070: LD_INT 1
3072: DEC
3073: ST_TO_ADDR
3074: LD_INT 3
3076: PUSH
3077: FOR_TO
3078: IFFALSE 3170
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3080: LD_INT 2
3082: PUSH
3083: LD_INT 3
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: PUSH
3090: LD_INT 1
3092: PPUSH
3093: LD_INT 2
3095: PPUSH
3096: CALL_OW 12
3100: ARRAY
3101: PPUSH
3102: LD_INT 2
3104: PPUSH
3105: LD_INT 3
3107: PPUSH
3108: LD_INT 11
3110: PUSH
3111: LD_INT 7
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: PUSH
3122: LD_VAR 0 3
3126: ARRAY
3127: PPUSH
3128: LD_INT 100
3130: PPUSH
3131: CALL 14795 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3135: CALL_OW 45
3139: PPUSH
3140: LD_EXP 12
3144: PUSH
3145: LD_EXP 7
3149: PUSH
3150: LD_VAR 0 2
3154: ARRAY
3155: ARRAY
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3077
3170: POP
3171: POP
// end ;
3172: GO 2283
3174: POP
3175: POP
// end ;
3176: LD_VAR 0 1
3180: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3181: LD_INT 0
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
3187: PPUSH
// if not multi_support then
3188: LD_EXP 23
3192: NOT
3193: IFFALSE 3197
// exit ;
3195: GO 3725
// result := [ ] ;
3197: LD_ADDR_VAR 0 1
3201: PUSH
3202: EMPTY
3203: ST_TO_ADDR
// for i = 1 to 8 do
3204: LD_ADDR_VAR 0 2
3208: PUSH
3209: DOUBLE
3210: LD_INT 1
3212: DEC
3213: ST_TO_ADDR
3214: LD_INT 8
3216: PUSH
3217: FOR_TO
3218: IFFALSE 3723
// begin if multi_sides [ i ] then
3220: LD_EXP 7
3224: PUSH
3225: LD_VAR 0 2
3229: ARRAY
3230: IFFALSE 3721
// begin tmp := [ ] ;
3232: LD_ADDR_VAR 0 5
3236: PUSH
3237: EMPTY
3238: ST_TO_ADDR
// if multi_support = 1 then
3239: LD_EXP 23
3243: PUSH
3244: LD_INT 1
3246: EQUAL
3247: IFFALSE 3415
// begin uc_side := i ;
3249: LD_ADDR_OWVAR 20
3253: PUSH
3254: LD_VAR 0 2
3258: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3259: LD_ADDR_OWVAR 21
3263: PUSH
3264: LD_EXP 9
3268: PUSH
3269: LD_VAR 0 2
3273: ARRAY
3274: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3275: LD_INT 3
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: LD_INT 11
3286: PPUSH
3287: LD_INT 40
3289: PPUSH
3290: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3294: LD_ADDR_VAR 0 5
3298: PUSH
3299: LD_VAR 0 5
3303: PUSH
3304: CALL_OW 45
3308: ADD
3309: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3310: LD_INT 2
3312: PPUSH
3313: LD_INT 1
3315: PPUSH
3316: LD_INT 3
3318: PPUSH
3319: LD_INT 5
3321: PPUSH
3322: LD_INT 40
3324: PPUSH
3325: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3329: LD_ADDR_VAR 0 5
3333: PUSH
3334: LD_VAR 0 5
3338: PUSH
3339: CALL_OW 45
3343: ADD
3344: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3345: LD_INT 2
3347: PPUSH
3348: LD_INT 3
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 4
3356: PPUSH
3357: LD_INT 40
3359: PPUSH
3360: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: CALL_OW 45
3378: ADD
3379: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3380: LD_INT 3
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: LD_INT 3
3388: PPUSH
3389: LD_INT 9
3391: PPUSH
3392: LD_INT 40
3394: PPUSH
3395: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3399: LD_ADDR_VAR 0 5
3403: PUSH
3404: LD_VAR 0 5
3408: PUSH
3409: CALL_OW 45
3413: ADD
3414: ST_TO_ADDR
// end ; if multi_support = 2 then
3415: LD_EXP 23
3419: PUSH
3420: LD_INT 2
3422: EQUAL
3423: IFFALSE 3696
// begin uc_side := i ;
3425: LD_ADDR_OWVAR 20
3429: PUSH
3430: LD_VAR 0 2
3434: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3435: LD_ADDR_OWVAR 21
3439: PUSH
3440: LD_EXP 9
3444: PUSH
3445: LD_VAR 0 2
3449: ARRAY
3450: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 11
3462: PPUSH
3463: LD_INT 40
3465: PPUSH
3466: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3470: LD_ADDR_VAR 0 5
3474: PUSH
3475: LD_VAR 0 5
3479: PUSH
3480: CALL_OW 45
3484: ADD
3485: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3486: LD_INT 3
3488: PPUSH
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 12
3497: PPUSH
3498: LD_INT 40
3500: PPUSH
3501: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3505: LD_ADDR_VAR 0 5
3509: PUSH
3510: LD_VAR 0 5
3514: PUSH
3515: CALL_OW 45
3519: ADD
3520: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3521: LD_INT 2
3523: PPUSH
3524: LD_INT 3
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 5
3532: PPUSH
3533: LD_INT 40
3535: PPUSH
3536: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3540: LD_ADDR_VAR 0 5
3544: PUSH
3545: LD_VAR 0 5
3549: PUSH
3550: CALL_OW 45
3554: ADD
3555: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3556: LD_INT 4
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: LD_INT 6
3567: PPUSH
3568: LD_INT 40
3570: PPUSH
3571: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3575: LD_ADDR_VAR 0 5
3579: PUSH
3580: LD_VAR 0 5
3584: PUSH
3585: CALL_OW 45
3589: ADD
3590: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3591: LD_INT 2
3593: PPUSH
3594: LD_INT 3
3596: PPUSH
3597: LD_INT 3
3599: PPUSH
3600: LD_INT 9
3602: PPUSH
3603: LD_INT 40
3605: PPUSH
3606: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3610: LD_ADDR_VAR 0 5
3614: PUSH
3615: LD_VAR 0 5
3619: PUSH
3620: CALL_OW 45
3624: ADD
3625: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 3
3631: PPUSH
3632: LD_INT 3
3634: PPUSH
3635: LD_INT 9
3637: PPUSH
3638: LD_INT 40
3640: PPUSH
3641: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_VAR 0 5
3654: PUSH
3655: CALL_OW 45
3659: ADD
3660: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3661: LD_INT 4
3663: PPUSH
3664: LD_INT 1
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 6
3672: PPUSH
3673: LD_INT 40
3675: PPUSH
3676: CALL 14795 0 5
// tmp := tmp ^ CreateVehicle ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: CALL_OW 45
3694: ADD
3695: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3696: LD_ADDR_VAR 0 1
3700: PUSH
3701: LD_VAR 0 1
3705: PPUSH
3706: LD_VAR 0 2
3710: PPUSH
3711: LD_VAR 0 5
3715: PPUSH
3716: CALL_OW 2
3720: ST_TO_ADDR
// end ; end ;
3721: GO 3217
3723: POP
3724: POP
// end ;
3725: LD_VAR 0 1
3729: RET
// export function Multiplayer_Start ( ) ; begin
3730: LD_INT 0
3732: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3733: CALL 2259 0 0
// Multiplayer_InitPointSystem ( ) ;
3737: CALL 4646 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3741: LD_INT 20
3743: PPUSH
3744: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3748: LD_INT 150
3750: PPUSH
3751: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3755: LD_INT 5
3757: PPUSH
3758: CALL 4822 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3762: LD_INT 40
3764: NEG
3765: PPUSH
3766: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3770: LD_INT 200
3772: PPUSH
3773: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3777: LD_INT 2
3779: PPUSH
3780: CALL 4822 0 1
// Multiplayer_SpawnArtifact ;
3784: CALL 5262 0 0
// if multi_support then
3788: LD_EXP 23
3792: IFFALSE 3804
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3794: LD_ADDR_EXP 27
3798: PUSH
3799: CALL 3181 0 0
3803: ST_TO_ADDR
// if multi_sides [ your_side ] then
3804: LD_EXP 7
3808: PUSH
3809: LD_OWVAR 2
3813: ARRAY
3814: IFFALSE 3841
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3816: LD_INT 22
3818: PUSH
3819: LD_OWVAR 2
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: CALL_OW 87
// end ;
3841: LD_VAR 0 1
3845: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3846: LD_INT 0
3848: PPUSH
3849: PPUSH
3850: PPUSH
3851: PPUSH
3852: PPUSH
// reinforcements_arrive := 0 ;
3853: LD_ADDR_VAR 0 5
3857: PUSH
3858: LD_INT 0
3860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3861: LD_INT 35
3863: PPUSH
3864: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3868: LD_OWVAR 1
3872: PUSH
3873: LD_INT 21000
3875: GREATER
3876: PUSH
3877: LD_EXP 28
3881: NOT
3882: AND
3883: PUSH
3884: LD_EXP 23
3888: PUSH
3889: LD_INT 1
3891: EQUAL
3892: AND
3893: IFFALSE 4088
// begin multi_reinforcements_spawned := 1 ;
3895: LD_ADDR_EXP 28
3899: PUSH
3900: LD_INT 1
3902: ST_TO_ADDR
// for i = 1 to 8 do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_INT 8
3915: PUSH
3916: FOR_TO
3917: IFFALSE 4076
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3919: LD_EXP 7
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_EXP 25
3934: PUSH
3935: LD_VAR 0 2
3939: ARRAY
3940: NOT
3941: AND
3942: PUSH
3943: LD_EXP 27
3947: PUSH
3948: LD_VAR 0 2
3952: ARRAY
3953: AND
3954: IFFALSE 4074
// begin tmp := multi_reinforcements [ i ] ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_EXP 27
3965: PUSH
3966: LD_VAR 0 2
3970: ARRAY
3971: ST_TO_ADDR
// for j = 1 to 4 do
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_INT 4
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4047
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3988: LD_VAR 0 4
3992: PUSH
3993: LD_VAR 0 3
3997: ARRAY
3998: PPUSH
3999: LD_EXP 12
4003: PUSH
4004: LD_EXP 7
4008: PUSH
4009: LD_VAR 0 2
4013: ARRAY
4014: ARRAY
4015: PUSH
4016: LD_INT 2
4018: ARRAY
4019: PPUSH
4020: LD_INT 0
4022: PPUSH
4023: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_VAR 0 4
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: CALL_OW 3
4044: ST_TO_ADDR
// end ;
4045: GO 3985
4047: POP
4048: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4049: LD_ADDR_EXP 27
4053: PUSH
4054: LD_EXP 27
4058: PPUSH
4059: LD_VAR 0 2
4063: PPUSH
4064: LD_VAR 0 4
4068: PPUSH
4069: CALL_OW 1
4073: ST_TO_ADDR
// end ; end ;
4074: GO 3916
4076: POP
4077: POP
// reinforcements_arrive := tick ;
4078: LD_ADDR_VAR 0 5
4082: PUSH
4083: LD_OWVAR 1
4087: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4088: LD_VAR 0 5
4092: PUSH
4093: LD_INT 21000
4095: PLUS
4096: PUSH
4097: LD_OWVAR 1
4101: LESS
4102: PUSH
4103: LD_EXP 28
4107: PUSH
4108: LD_INT 1
4110: EQUAL
4111: AND
4112: PUSH
4113: LD_EXP 23
4117: PUSH
4118: LD_INT 2
4120: EQUAL
4121: AND
4122: IFFALSE 4307
// begin multi_reinforcements_spawned := 2 ;
4124: LD_ADDR_EXP 28
4128: PUSH
4129: LD_INT 2
4131: ST_TO_ADDR
// for i = 1 to 8 do
4132: LD_ADDR_VAR 0 2
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 8
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4305
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4148: LD_EXP 7
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PUSH
4159: LD_EXP 25
4163: PUSH
4164: LD_VAR 0 2
4168: ARRAY
4169: NOT
4170: AND
4171: PUSH
4172: LD_EXP 27
4176: PUSH
4177: LD_VAR 0 2
4181: ARRAY
4182: AND
4183: IFFALSE 4303
// begin tmp := multi_reinforcements [ i ] ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_EXP 27
4194: PUSH
4195: LD_VAR 0 2
4199: ARRAY
4200: ST_TO_ADDR
// for j = 1 to 3 do
4201: LD_ADDR_VAR 0 3
4205: PUSH
4206: DOUBLE
4207: LD_INT 1
4209: DEC
4210: ST_TO_ADDR
4211: LD_INT 3
4213: PUSH
4214: FOR_TO
4215: IFFALSE 4276
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4217: LD_VAR 0 4
4221: PUSH
4222: LD_VAR 0 3
4226: ARRAY
4227: PPUSH
4228: LD_EXP 12
4232: PUSH
4233: LD_EXP 7
4237: PUSH
4238: LD_VAR 0 2
4242: ARRAY
4243: ARRAY
4244: PUSH
4245: LD_INT 2
4247: ARRAY
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4256: LD_ADDR_VAR 0 4
4260: PUSH
4261: LD_VAR 0 4
4265: PPUSH
4266: LD_INT 1
4268: PPUSH
4269: CALL_OW 3
4273: ST_TO_ADDR
// end ;
4274: GO 4214
4276: POP
4277: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4278: LD_ADDR_EXP 27
4282: PUSH
4283: LD_EXP 27
4287: PPUSH
4288: LD_VAR 0 2
4292: PPUSH
4293: LD_VAR 0 4
4297: PPUSH
4298: CALL_OW 1
4302: ST_TO_ADDR
// end ; end ;
4303: GO 4145
4305: POP
4306: POP
// end ; if not multi_custom_commanders then
4307: LD_EXP 16
4311: NOT
4312: IFFALSE 4425
// begin for i = 1 to 8 do
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: DOUBLE
4320: LD_INT 1
4322: DEC
4323: ST_TO_ADDR
4324: LD_INT 8
4326: PUSH
4327: FOR_TO
4328: IFFALSE 4399
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4330: LD_INT 22
4332: PUSH
4333: LD_VAR 0 2
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 69
4346: PUSH
4347: LD_INT 0
4349: EQUAL
4350: PUSH
4351: LD_EXP 25
4355: PUSH
4356: LD_VAR 0 2
4360: ARRAY
4361: NOT
4362: AND
4363: IFFALSE 4397
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4365: LD_ADDR_EXP 25
4369: PUSH
4370: LD_EXP 25
4374: PPUSH
4375: LD_VAR 0 2
4379: PPUSH
4380: LD_INT 1
4382: PPUSH
4383: CALL_OW 1
4387: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL 4892 0 1
// end ; end ;
4397: GO 4327
4399: POP
4400: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4401: LD_EXP 25
4405: PPUSH
4406: CALL 11914 0 1
4410: PUSH
4411: LD_EXP 7
4415: PPUSH
4416: CALL 11914 0 1
4420: EQUAL
4421: IFFALSE 4425
// break ;
4423: GO 4460
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4425: LD_INT 22
4427: PUSH
4428: LD_EXP 3
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 69
4441: PUSH
4442: LD_INT 0
4444: EQUAL
4445: PUSH
4446: LD_EXP 2
4450: AND
4451: PUSH
4452: LD_EXP 24
4456: NOT
4457: OR
4458: IFFALSE 3861
// game := false ;
4460: LD_ADDR_EXP 2
4464: PUSH
4465: LD_INT 0
4467: ST_TO_ADDR
// for i = 1 to 8 do
4468: LD_ADDR_VAR 0 2
4472: PUSH
4473: DOUBLE
4474: LD_INT 1
4476: DEC
4477: ST_TO_ADDR
4478: LD_INT 8
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4518
// begin if multi_sides [ i ] then
4484: LD_EXP 7
4488: PUSH
4489: LD_VAR 0 2
4493: ARRAY
4494: IFFALSE 4516
// SetMultiScore ( i , multi_points [ i ] ) ;
4496: LD_VAR 0 2
4500: PPUSH
4501: LD_EXP 29
4505: PUSH
4506: LD_VAR 0 2
4510: ARRAY
4511: PPUSH
4512: CALL_OW 506
// end ;
4516: GO 4481
4518: POP
4519: POP
// if multi_loosers [ your_side ] then
4520: LD_EXP 25
4524: PUSH
4525: LD_OWVAR 2
4529: ARRAY
4530: IFFALSE 4538
// YouLostInMultiplayer else
4532: CALL_OW 107
4536: GO 4542
// YouWinInMultiplayer ;
4538: CALL_OW 106
// end ;
4542: LD_VAR 0 1
4546: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
// result := [ #tick , tick ] ;
4551: LD_ADDR_VAR 0 1
4555: PUSH
4556: LD_STRING #tick
4558: PUSH
4559: LD_OWVAR 1
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: ST_TO_ADDR
// for i = 1 to 8 do
4568: LD_ADDR_VAR 0 2
4572: PUSH
4573: DOUBLE
4574: LD_INT 1
4576: DEC
4577: ST_TO_ADDR
4578: LD_INT 8
4580: PUSH
4581: FOR_TO
4582: IFFALSE 4639
// begin if multi_sides [ i ] then
4584: LD_EXP 7
4588: PUSH
4589: LD_VAR 0 2
4593: ARRAY
4594: IFFALSE 4637
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4596: LD_ADDR_VAR 0 1
4600: PUSH
4601: LD_VAR 0 1
4605: PUSH
4606: LD_STRING #coop-points
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: LD_VAR 0 2
4618: PUSH
4619: LD_EXP 29
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: ADD
4636: ST_TO_ADDR
// end ; end ;
4637: GO 4581
4639: POP
4640: POP
// end ;
4641: LD_VAR 0 1
4645: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4646: LD_INT 0
4648: PPUSH
4649: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4650: LD_ADDR_EXP 29
4654: PUSH
4655: LD_INT 0
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 0
4666: PUSH
4667: LD_INT 0
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4689: LD_ADDR_EXP 30
4693: PUSH
4694: EMPTY
4695: ST_TO_ADDR
// end ;
4696: LD_VAR 0 1
4700: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4701: LD_INT 0
4703: PPUSH
// if not multi_points or not side or side > 8 then
4704: LD_EXP 29
4708: NOT
4709: PUSH
4710: LD_VAR 0 1
4714: NOT
4715: OR
4716: PUSH
4717: LD_VAR 0 1
4721: PUSH
4722: LD_INT 8
4724: GREATER
4725: OR
4726: IFFALSE 4730
// exit ;
4728: GO 4767
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4730: LD_ADDR_EXP 29
4734: PUSH
4735: LD_EXP 29
4739: PPUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: LD_EXP 29
4749: PUSH
4750: LD_VAR 0 1
4754: ARRAY
4755: PUSH
4756: LD_VAR 0 2
4760: PLUS
4761: PPUSH
4762: CALL_OW 1
4766: ST_TO_ADDR
// end ;
4767: LD_VAR 0 3
4771: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4772: LD_INT 0
4774: PPUSH
// if not multi_points or not side or side > 8 then
4775: LD_EXP 29
4779: NOT
4780: PUSH
4781: LD_VAR 0 1
4785: NOT
4786: OR
4787: PUSH
4788: LD_VAR 0 1
4792: PUSH
4793: LD_INT 8
4795: GREATER
4796: OR
4797: IFFALSE 4801
// exit ;
4799: GO 4817
// result := multi_points [ side ] ;
4801: LD_ADDR_VAR 0 2
4805: PUSH
4806: LD_EXP 29
4810: PUSH
4811: LD_VAR 0 1
4815: ARRAY
4816: ST_TO_ADDR
// end ;
4817: LD_VAR 0 2
4821: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4822: LD_INT 0
4824: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4825: LD_ADDR_EXP 30
4829: PUSH
4830: LD_EXP 30
4834: PPUSH
4835: LD_EXP 30
4839: PUSH
4840: LD_INT 1
4842: PLUS
4843: PPUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 2
4853: ST_TO_ADDR
// end ;
4854: LD_VAR 0 2
4858: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4859: LD_INT 0
4861: PPUSH
// if not id then
4862: LD_VAR 0 1
4866: NOT
4867: IFFALSE 4871
// exit ;
4869: GO 4887
// result := multi_points_conditions [ id ] ;
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_EXP 30
4880: PUSH
4881: LD_VAR 0 1
4885: ARRAY
4886: ST_TO_ADDR
// end ;
4887: LD_VAR 0 2
4891: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
4897: PPUSH
4898: PPUSH
// players := [ ] ;
4899: LD_ADDR_VAR 0 3
4903: PUSH
4904: EMPTY
4905: ST_TO_ADDR
// for i = 1 to 8 do
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: DOUBLE
4912: LD_INT 1
4914: DEC
4915: ST_TO_ADDR
4916: LD_INT 8
4918: PUSH
4919: FOR_TO
4920: IFFALSE 4979
// begin if i = side then
4922: LD_VAR 0 4
4926: PUSH
4927: LD_VAR 0 1
4931: EQUAL
4932: IFFALSE 4936
// continue ;
4934: GO 4919
// if multi_sides [ i ] and not multi_loosers [ i ] then
4936: LD_EXP 7
4940: PUSH
4941: LD_VAR 0 4
4945: ARRAY
4946: PUSH
4947: LD_EXP 25
4951: PUSH
4952: LD_VAR 0 4
4956: ARRAY
4957: NOT
4958: AND
4959: IFFALSE 4977
// players := players ^ i ;
4961: LD_ADDR_VAR 0 3
4965: PUSH
4966: LD_VAR 0 3
4970: PUSH
4971: LD_VAR 0 4
4975: ADD
4976: ST_TO_ADDR
// end ;
4977: GO 4919
4979: POP
4980: POP
// if not players then
4981: LD_VAR 0 3
4985: NOT
4986: IFFALSE 4990
// exit ;
4988: GO 5257
// if players = 1 then
4990: LD_VAR 0 3
4994: PUSH
4995: LD_INT 1
4997: EQUAL
4998: IFFALSE 5059
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5000: LD_ADDR_VAR 0 4
5004: PUSH
5005: LD_INT 22
5007: PUSH
5008: LD_VAR 0 1
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 51
5019: PUSH
5020: EMPTY
5021: LIST
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: CALL_OW 69
5031: PUSH
5032: FOR_IN
5033: IFFALSE 5055
// SetSide ( i , players [ 1 ] ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 3
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PPUSH
5049: CALL_OW 235
5053: GO 5032
5055: POP
5056: POP
// end else
5057: GO 5257
// begin j := 1 ;
5059: LD_ADDR_VAR 0 5
5063: PUSH
5064: LD_INT 1
5066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5067: LD_ADDR_VAR 0 4
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_VAR 0 1
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 2
5086: PUSH
5087: LD_INT 21
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 51
5099: PUSH
5100: EMPTY
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 21
5109: PUSH
5110: LD_INT 2
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: PUSH
5131: FOR_IN
5132: IFFALSE 5255
// begin SetSide ( i , players [ j ] ) ;
5134: LD_VAR 0 4
5138: PPUSH
5139: LD_VAR 0 3
5143: PUSH
5144: LD_VAR 0 5
5148: ARRAY
5149: PPUSH
5150: CALL_OW 235
// if IsDrivenBy ( i ) then
5154: LD_VAR 0 4
5158: PPUSH
5159: CALL_OW 311
5163: IFFALSE 5190
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5165: LD_VAR 0 4
5169: PPUSH
5170: CALL_OW 311
5174: PPUSH
5175: LD_VAR 0 3
5179: PUSH
5180: LD_VAR 0 5
5184: ARRAY
5185: PPUSH
5186: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5190: LD_VAR 0 4
5194: PPUSH
5195: CALL_OW 310
5199: PPUSH
5200: CALL_OW 247
5204: PUSH
5205: LD_INT 3
5207: EQUAL
5208: IFFALSE 5219
// ComExitBuilding ( i ) ;
5210: LD_VAR 0 4
5214: PPUSH
5215: CALL_OW 122
// j := j + 1 ;
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 1
5231: PLUS
5232: ST_TO_ADDR
// if j > players then
5233: LD_VAR 0 5
5237: PUSH
5238: LD_VAR 0 3
5242: GREATER
5243: IFFALSE 5253
// j := 1 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 1
5252: ST_TO_ADDR
// end ;
5253: GO 5131
5255: POP
5256: POP
// end ; end ;
5257: LD_VAR 0 2
5261: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5262: LD_INT 0
5264: PPUSH
5265: PPUSH
5266: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5267: LD_ADDR_VAR 0 3
5271: PUSH
5272: LD_INT 5
5274: PUSH
5275: LD_INT 10
5277: PUSH
5278: EMPTY
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 120
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: PUSH
5292: LD_INT 101
5294: PUSH
5295: LD_INT 8
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PUSH
5302: LD_INT 27
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_VAR 0 3
5330: PPUSH
5331: CALL_OW 12
5335: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5336: LD_INT 4
5338: PPUSH
5339: LD_INT 5
5341: PPUSH
5342: LD_VAR 0 3
5346: PUSH
5347: LD_VAR 0 2
5351: ARRAY
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_VAR 0 3
5361: PUSH
5362: LD_VAR 0 2
5366: ARRAY
5367: PUSH
5368: LD_INT 2
5370: ARRAY
5371: PPUSH
5372: LD_INT 0
5374: PPUSH
5375: CALL_OW 58
// end ;
5379: LD_VAR 0 1
5383: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5384: LD_INT 0
5386: PPUSH
// if not side or side > 8 then
5387: LD_VAR 0 1
5391: NOT
5392: PUSH
5393: LD_VAR 0 1
5397: PUSH
5398: LD_INT 8
5400: GREATER
5401: OR
5402: IFFALSE 5406
// exit ;
5404: GO 5423
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 6
5413: PPUSH
5414: CALL 4859 0 1
5418: PPUSH
5419: CALL 4701 0 2
// end ;
5423: LD_VAR 0 2
5427: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5428: LD_INT 0
5430: PPUSH
// if not side or side > 8 then
5431: LD_VAR 0 1
5435: NOT
5436: PUSH
5437: LD_VAR 0 1
5441: PUSH
5442: LD_INT 8
5444: GREATER
5445: OR
5446: IFFALSE 5450
// exit ;
5448: GO 5467
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_INT 4
5457: PPUSH
5458: CALL 4859 0 1
5462: PPUSH
5463: CALL 4701 0 2
// end ;
5467: LD_VAR 0 2
5471: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5472: LD_INT 0
5474: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5475: LD_VAR 0 1
5479: NOT
5480: PUSH
5481: LD_VAR 0 1
5485: PUSH
5486: LD_INT 8
5488: GREATER
5489: OR
5490: PUSH
5491: LD_VAR 0 2
5495: PUSH
5496: LD_INT 2
5498: PUSH
5499: LD_INT 6
5501: PUSH
5502: LD_INT 36
5504: PUSH
5505: LD_INT 0
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: IN
5514: NOT
5515: OR
5516: IFFALSE 5520
// exit ;
5518: GO 5537
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5520: LD_VAR 0 1
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: CALL 4859 0 1
5532: PPUSH
5533: CALL 4701 0 2
// end ;
5537: LD_VAR 0 3
5541: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5542: LD_INT 0
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
// if not un then
5550: LD_VAR 0 1
5554: NOT
5555: IFFALSE 5559
// exit ;
5557: GO 5783
// if not points then
5559: LD_VAR 0 2
5563: NOT
5564: IFFALSE 5581
// gained_points := Multiplayer_GetCondition ( 1 ) else
5566: LD_ADDR_VAR 0 8
5570: PUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL 4859 0 1
5578: ST_TO_ADDR
5579: GO 5591
// gained_points := points ;
5581: LD_ADDR_VAR 0 8
5585: PUSH
5586: LD_VAR 0 2
5590: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5591: LD_ADDR_VAR 0 6
5595: PUSH
5596: LD_VAR 0 1
5600: PPUSH
5601: CALL_OW 503
5605: ST_TO_ADDR
// if last_shoot > - 1 then
5606: LD_VAR 0 6
5610: PUSH
5611: LD_INT 1
5613: NEG
5614: GREATER
5615: IFFALSE 5627
// begin side := last_shoot ;
5617: LD_ADDR_VAR 0 4
5621: PUSH
5622: LD_VAR 0 6
5626: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: LD_OWVAR 3
5636: PUSH
5637: LD_INT 22
5639: PUSH
5640: LD_VAR 0 1
5644: PPUSH
5645: CALL_OW 255
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: DIFF
5659: PPUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: CALL_OW 74
5669: ST_TO_ADDR
// if nearest_unit then
5670: LD_VAR 0 7
5674: IFFALSE 5691
// side2 := GetSide ( nearest_unit ) ;
5676: LD_ADDR_VAR 0 5
5680: PUSH
5681: LD_VAR 0 7
5685: PPUSH
5686: CALL_OW 255
5690: ST_TO_ADDR
// if not side and not side2 then
5691: LD_VAR 0 4
5695: NOT
5696: PUSH
5697: LD_VAR 0 5
5701: NOT
5702: AND
5703: IFFALSE 5707
// exit ;
5705: GO 5783
// if side = side2 then
5707: LD_VAR 0 4
5711: PUSH
5712: LD_VAR 0 5
5716: EQUAL
5717: IFFALSE 5735
// Multiplayer_AddPoints ( side , gained_points ) else
5719: LD_VAR 0 4
5723: PPUSH
5724: LD_VAR 0 8
5728: PPUSH
5729: CALL 4701 0 2
5733: GO 5783
// begin if side then
5735: LD_VAR 0 4
5739: IFFALSE 5759
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5741: LD_VAR 0 4
5745: PPUSH
5746: LD_VAR 0 8
5750: PUSH
5751: LD_INT 2
5753: DIV
5754: PPUSH
5755: CALL 4701 0 2
// if side2 then
5759: LD_VAR 0 5
5763: IFFALSE 5783
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5765: LD_VAR 0 5
5769: PPUSH
5770: LD_VAR 0 8
5774: PUSH
5775: LD_INT 2
5777: DIV
5778: PPUSH
5779: CALL 4701 0 2
// end ; end ;
5783: LD_VAR 0 3
5787: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5788: LD_INT 0
5790: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5791: LD_VAR 0 1
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: CALL 4859 0 1
5803: PPUSH
5804: CALL 4701 0 2
// end ; end_of_file
5808: LD_VAR 0 2
5812: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5813: LD_INT 0
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
5823: PPUSH
// side_bot := side ;
5824: LD_ADDR_EXP 3
5828: PUSH
5829: LD_VAR 0 1
5833: ST_TO_ADDR
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5834: LD_ADDR_VAR 0 10
5838: PUSH
5839: LD_INT 11
5841: PUSH
5842: LD_INT 4
5844: PUSH
5845: LD_INT 3
5847: PUSH
5848: LD_INT 5
5850: PUSH
5851: LD_INT 66
5853: PUSH
5854: LD_INT 67
5856: PUSH
5857: LD_INT 53
5859: PUSH
5860: LD_INT 18
5862: PUSH
5863: LD_INT 40
5865: PUSH
5866: LD_INT 22
5868: PUSH
5869: LD_INT 72
5871: PUSH
5872: LD_INT 55
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: ST_TO_ADDR
// for i in techs do
5889: LD_ADDR_VAR 0 3
5893: PUSH
5894: LD_VAR 0 10
5898: PUSH
5899: FOR_IN
5900: IFFALSE 5921
// SetTech ( i , side , state_researched ) ;
5902: LD_VAR 0 3
5906: PPUSH
5907: LD_VAR 0 1
5911: PPUSH
5912: LD_INT 2
5914: PPUSH
5915: CALL_OW 322
5919: GO 5899
5921: POP
5922: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5923: LD_ADDR_VAR 0 8
5927: PUSH
5928: LD_INT 6
5930: PUSH
5931: LD_INT 7
5933: PUSH
5934: LD_INT 8
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_OWVAR 67
5946: ARRAY
5947: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5948: LD_INT 69
5950: PUSH
5951: EMPTY
5952: LIST
5953: PPUSH
5954: LD_INT 141
5956: PPUSH
5957: CALL_OW 169
// wait ( 1 ) ;
5961: LD_INT 1
5963: PPUSH
5964: CALL_OW 67
// uc_side := side ;
5968: LD_ADDR_OWVAR 20
5972: PUSH
5973: LD_VAR 0 1
5977: ST_TO_ADDR
// uc_nation := 2 ;
5978: LD_ADDR_OWVAR 21
5982: PUSH
5983: LD_INT 2
5985: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
5986: LD_ADDR_EXP 33
5990: PUSH
5991: LD_INT 94
5993: PPUSH
5994: LD_INT 35
5996: PPUSH
5997: LD_STRING dammam
5999: PPUSH
6000: LD_VAR 0 8
6004: PPUSH
6005: LD_INT 10000
6007: PUSH
6008: LD_INT 1000
6010: PUSH
6011: LD_INT 300
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: PPUSH
6019: LD_INT 12
6021: PUSH
6022: LD_INT 4
6024: PUSH
6025: LD_INT 1
6027: NEG
6028: PUSH
6029: LD_INT 4
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: PPUSH
6038: CALL 18239 0 6
6042: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6043: LD_ADDR_EXP 34
6047: PUSH
6048: LD_INT 122
6050: PPUSH
6051: LD_INT 38
6053: PPUSH
6054: LD_STRING 
6056: PPUSH
6057: LD_VAR 0 8
6061: PPUSH
6062: LD_INT 1000
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PPUSH
6076: LD_INT 12
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 0
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL 18239 0 6
6098: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6099: LD_ADDR_EXP 31
6103: PUSH
6104: LD_INT 45
6106: PPUSH
6107: LD_INT 34
6109: PPUSH
6110: LD_STRING jeddah
6112: PPUSH
6113: LD_VAR 0 8
6117: PPUSH
6118: LD_INT 700
6120: PUSH
6121: LD_INT 300
6123: PUSH
6124: LD_INT 10
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PPUSH
6132: LD_INT 12
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL 18239 0 6
6154: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6155: LD_ADDR_EXP 32
6159: PUSH
6160: LD_INT 7
6162: PPUSH
6163: LD_INT 33
6165: PPUSH
6166: LD_STRING riyadh
6168: PPUSH
6169: LD_VAR 0 8
6173: PPUSH
6174: LD_INT 500
6176: PUSH
6177: LD_INT 60
6179: PUSH
6180: LD_INT 0
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: PPUSH
6188: LD_INT 4
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: LD_INT 3
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL 18239 0 6
6210: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6211: LD_ADDR_EXP 35
6215: PUSH
6216: LD_INT 69
6218: PPUSH
6219: LD_INT 36
6221: PPUSH
6222: LD_STRING 
6224: PPUSH
6225: LD_VAR 0 8
6229: PPUSH
6230: LD_INT 500
6232: PUSH
6233: LD_INT 50
6235: PUSH
6236: LD_INT 0
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: LD_INT 11
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 3
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PPUSH
6262: CALL 18239 0 6
6266: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6267: LD_ADDR_EXP 43
6271: PUSH
6272: LD_EXP 33
6276: PUSH
6277: LD_EXP 31
6281: PUSH
6282: LD_EXP 35
6286: PUSH
6287: LD_EXP 32
6291: PUSH
6292: LD_EXP 34
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6304: LD_ADDR_OWVAR 37
6308: PUSH
6309: LD_INT 14
6311: ST_TO_ADDR
// vc_engine := engine_siberite ;
6312: LD_ADDR_OWVAR 39
6316: PUSH
6317: LD_INT 3
6319: ST_TO_ADDR
// vc_control := control_manual ;
6320: LD_ADDR_OWVAR 38
6324: PUSH
6325: LD_INT 1
6327: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6328: LD_ADDR_OWVAR 40
6332: PUSH
6333: LD_INT 31
6335: ST_TO_ADDR
// for i = 1 to 4 do
6336: LD_ADDR_VAR 0 3
6340: PUSH
6341: DOUBLE
6342: LD_INT 1
6344: DEC
6345: ST_TO_ADDR
6346: LD_INT 4
6348: PUSH
6349: FOR_TO
6350: IFFALSE 6619
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6352: LD_ADDR_VAR 0 5
6356: PUSH
6357: LD_INT 156
6359: PUSH
6360: LD_INT 15
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: LD_INT 12
6369: PUSH
6370: LD_INT 7
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_VAR 0 3
6385: PUSH
6386: LD_INT 2
6388: MOD
6389: PUSH
6390: LD_INT 1
6392: PLUS
6393: ARRAY
6394: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6395: LD_INT 0
6397: PPUSH
6398: LD_INT 3
6400: PPUSH
6401: LD_VAR 0 8
6405: PPUSH
6406: CALL_OW 380
// un := CreateVehicle ;
6410: LD_ADDR_VAR 0 6
6414: PUSH
6415: CALL_OW 45
6419: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6420: LD_VAR 0 6
6424: PPUSH
6425: LD_INT 0
6427: PPUSH
6428: LD_INT 5
6430: PPUSH
6431: CALL_OW 12
6435: PPUSH
6436: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6440: LD_VAR 0 6
6444: PPUSH
6445: LD_VAR 0 5
6449: PUSH
6450: LD_INT 1
6452: ARRAY
6453: PPUSH
6454: LD_VAR 0 5
6458: PUSH
6459: LD_INT 2
6461: ARRAY
6462: PPUSH
6463: LD_INT 6
6465: PPUSH
6466: LD_INT 0
6468: PPUSH
6469: CALL_OW 50
// un2 := CreateHuman ;
6473: LD_ADDR_VAR 0 7
6477: PUSH
6478: CALL_OW 44
6482: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6483: LD_VAR 0 7
6487: PPUSH
6488: LD_VAR 0 6
6492: PPUSH
6493: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6497: LD_ADDR_EXP 43
6501: PUSH
6502: LD_EXP 43
6506: PPUSH
6507: LD_VAR 0 3
6511: PUSH
6512: LD_INT 2
6514: MOD
6515: PUSH
6516: LD_INT 1
6518: PLUS
6519: PUSH
6520: LD_EXP 43
6524: PUSH
6525: LD_VAR 0 3
6529: PUSH
6530: LD_INT 2
6532: MOD
6533: PUSH
6534: LD_INT 1
6536: PLUS
6537: ARRAY
6538: PUSH
6539: LD_INT 1
6541: PLUS
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PPUSH
6547: LD_VAR 0 6
6551: PPUSH
6552: CALL 14917 0 3
6556: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6557: LD_ADDR_EXP 43
6561: PUSH
6562: LD_EXP 43
6566: PPUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 2
6574: MOD
6575: PUSH
6576: LD_INT 1
6578: PLUS
6579: PUSH
6580: LD_EXP 43
6584: PUSH
6585: LD_VAR 0 3
6589: PUSH
6590: LD_INT 2
6592: MOD
6593: PUSH
6594: LD_INT 1
6596: PLUS
6597: ARRAY
6598: PUSH
6599: LD_INT 1
6601: PLUS
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: LD_VAR 0 7
6611: PPUSH
6612: CALL 14917 0 3
6616: ST_TO_ADDR
// end ;
6617: GO 6349
6619: POP
6620: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_INT 22
6628: PUSH
6629: LD_EXP 3
6633: PUSH
6634: EMPTY
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 30
6640: PUSH
6641: LD_INT 31
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: LD_INT 58
6650: PUSH
6651: EMPTY
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: PPUSH
6659: CALL_OW 69
6663: PUSH
6664: FOR_IN
6665: IFFALSE 6790
// begin if GetBase ( i ) then
6667: LD_VAR 0 3
6671: PPUSH
6672: CALL_OW 274
6676: IFFALSE 6680
// continue ;
6678: GO 6664
// d := GetDir ( i ) ;
6680: LD_ADDR_VAR 0 4
6684: PUSH
6685: LD_VAR 0 3
6689: PPUSH
6690: CALL_OW 254
6694: ST_TO_ADDR
// if d < 3 then
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 3
6702: LESS
6703: IFFALSE 6721
// d := d + 3 else
6705: LD_ADDR_VAR 0 4
6709: PUSH
6710: LD_VAR 0 4
6714: PUSH
6715: LD_INT 3
6717: PLUS
6718: ST_TO_ADDR
6719: GO 6735
// d := d - 3 ;
6721: LD_ADDR_VAR 0 4
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 3
6733: MINUS
6734: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6735: LD_INT 0
6737: PPUSH
6738: LD_INT 8
6740: PPUSH
6741: LD_VAR 0 8
6745: PPUSH
6746: CALL_OW 380
// un := CreateHuman ;
6750: LD_ADDR_VAR 0 6
6754: PUSH
6755: CALL_OW 44
6759: ST_TO_ADDR
// SetDir ( un , d ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_VAR 0 4
6769: PPUSH
6770: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6774: LD_VAR 0 6
6778: PPUSH
6779: LD_VAR 0 3
6783: PPUSH
6784: CALL_OW 52
// end ;
6788: GO 6664
6790: POP
6791: POP
// ar_force_tmp := [ ] ;
6792: LD_ADDR_EXP 36
6796: PUSH
6797: EMPTY
6798: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6814: LD_ADDR_OWVAR 33
6818: PUSH
6819: LD_STRING SecondCharsGal
6821: ST_TO_ADDR
// hc_face_number := 4 ;
6822: LD_ADDR_OWVAR 34
6826: PUSH
6827: LD_INT 4
6829: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6830: LD_ADDR_EXP 36
6834: PUSH
6835: LD_EXP 36
6839: PPUSH
6840: LD_INT 1
6842: PPUSH
6843: CALL_OW 44
6847: PPUSH
6848: CALL_OW 1
6852: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6853: LD_INT 2
6855: PPUSH
6856: LD_INT 4
6858: PPUSH
6859: LD_VAR 0 8
6863: PPUSH
6864: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6868: LD_ADDR_OWVAR 33
6872: PUSH
6873: LD_STRING SecondCharsGal
6875: ST_TO_ADDR
// hc_face_number := 15 ;
6876: LD_ADDR_OWVAR 34
6880: PUSH
6881: LD_INT 15
6883: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6884: LD_ADDR_EXP 36
6888: PUSH
6889: LD_EXP 36
6893: PPUSH
6894: LD_INT 2
6896: PPUSH
6897: CALL_OW 44
6901: PPUSH
6902: CALL_OW 1
6906: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PPUSH
6913: LD_VAR 0 8
6917: PPUSH
6918: CALL_OW 380
// hc_gallery :=  ;
6922: LD_ADDR_OWVAR 33
6926: PUSH
6927: LD_STRING 
6929: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6930: LD_ADDR_EXP 36
6934: PUSH
6935: LD_EXP 36
6939: PPUSH
6940: LD_INT 3
6942: PPUSH
6943: CALL_OW 44
6947: PPUSH
6948: CALL_OW 1
6952: ST_TO_ADDR
// hc_sex := sex_male ;
6953: LD_ADDR_OWVAR 27
6957: PUSH
6958: LD_INT 1
6960: ST_TO_ADDR
// hc_class = 11 ;
6961: LD_ADDR_OWVAR 28
6965: PUSH
6966: LD_INT 11
6968: ST_TO_ADDR
// hc_gallery = sandar ;
6969: LD_ADDR_OWVAR 33
6973: PUSH
6974: LD_STRING sandar
6976: ST_TO_ADDR
// hc_face_number = 33 ;
6977: LD_ADDR_OWVAR 34
6981: PUSH
6982: LD_INT 33
6984: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
6985: LD_ADDR_OWVAR 26
6989: PUSH
6990: LD_STRING Thabit Muhair Saliba
6992: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
6993: LD_ADDR_OWVAR 31
6997: PUSH
6998: LD_INT 5
7000: PUSH
7001: LD_INT 5
7003: PUSH
7004: LD_INT 3
7006: PUSH
7007: LD_INT 3
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: ST_TO_ADDR
// Saliba = CreateHuman ;
7016: LD_ADDR_EXP 39
7020: PUSH
7021: CALL_OW 44
7025: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7026: LD_EXP 39
7030: PPUSH
7031: LD_INT 7
7033: PPUSH
7034: CALL_OW 52
// hc_name := Dietrich Gensher ;
7038: LD_ADDR_OWVAR 26
7042: PUSH
7043: LD_STRING Dietrich Gensher
7045: ST_TO_ADDR
// hc_class := 1 ;
7046: LD_ADDR_OWVAR 28
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// hc_gallery := sandar ;
7054: LD_ADDR_OWVAR 33
7058: PUSH
7059: LD_STRING sandar
7061: ST_TO_ADDR
// hc_face_number := 2 ;
7062: LD_ADDR_OWVAR 34
7066: PUSH
7067: LD_INT 2
7069: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7070: LD_ADDR_OWVAR 31
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 6
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 4
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: ST_TO_ADDR
// Gensher := CreateHuman ;
7093: LD_ADDR_EXP 40
7097: PUSH
7098: CALL_OW 44
7102: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7103: LD_EXP 40
7107: PPUSH
7108: LD_INT 94
7110: PPUSH
7111: CALL_OW 52
// InitHc ;
7115: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7119: LD_ADDR_EXP 38
7123: PUSH
7124: EMPTY
7125: PUSH
7126: EMPTY
7127: PUSH
7128: EMPTY
7129: PUSH
7130: EMPTY
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7138: LD_ADDR_VAR 0 4
7142: PUSH
7143: DOUBLE
7144: LD_INT 1
7146: DEC
7147: ST_TO_ADDR
7148: LD_INT 3
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 4
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: LD_OWVAR 67
7166: ARRAY
7167: PUSH
7168: FOR_TO
7169: IFFALSE 7387
// for i = 1 to 3 do
7171: LD_ADDR_VAR 0 3
7175: PUSH
7176: DOUBLE
7177: LD_INT 1
7179: DEC
7180: ST_TO_ADDR
7181: LD_INT 3
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7383
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7187: LD_INT 14
7189: PPUSH
7190: LD_INT 3
7192: PUSH
7193: LD_INT 2
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 1
7202: PPUSH
7203: LD_INT 2
7205: PPUSH
7206: CALL_OW 12
7210: ARRAY
7211: PPUSH
7212: LD_INT 1
7214: PUSH
7215: LD_INT 5
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 2
7227: PPUSH
7228: CALL_OW 12
7232: ARRAY
7233: PPUSH
7234: LD_INT 25
7236: PUSH
7237: LD_INT 27
7239: PUSH
7240: LD_INT 26
7242: PUSH
7243: LD_INT 28
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 1
7254: PPUSH
7255: LD_INT 4
7257: PPUSH
7258: CALL_OW 12
7262: ARRAY
7263: PPUSH
7264: LD_INT 100
7266: PPUSH
7267: CALL 14795 0 5
// un := CreateVehicle ;
7271: LD_ADDR_VAR 0 6
7275: PUSH
7276: CALL_OW 45
7280: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7281: LD_ADDR_EXP 38
7285: PUSH
7286: LD_EXP 38
7290: PPUSH
7291: LD_VAR 0 3
7295: PUSH
7296: LD_EXP 38
7300: PUSH
7301: LD_VAR 0 3
7305: ARRAY
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: LD_VAR 0 6
7319: PPUSH
7320: CALL 14917 0 3
7324: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: LD_INT 5
7335: PPUSH
7336: CALL_OW 12
7340: PPUSH
7341: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7345: LD_VAR 0 6
7349: PPUSH
7350: LD_INT 20
7352: PUSH
7353: LD_INT 21
7355: PUSH
7356: LD_INT 22
7358: PUSH
7359: LD_INT 24
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_VAR 0 3
7372: ARRAY
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 49
// end ;
7381: GO 7184
7383: POP
7384: POP
7385: GO 7168
7387: POP
7388: POP
// InitHc ;
7389: CALL_OW 19
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
7393: LD_ADDR_VAR 0 9
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 2
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: ST_TO_ADDR
// if tmp and side <> 2 then
7413: LD_VAR 0 9
7417: PUSH
7418: LD_VAR 0 1
7422: PUSH
7423: LD_INT 2
7425: NONEQUAL
7426: AND
7427: IFFALSE 7460
// begin for i in tmp do
7429: LD_ADDR_VAR 0 3
7433: PUSH
7434: LD_VAR 0 9
7438: PUSH
7439: FOR_IN
7440: IFFALSE 7458
// SetSide ( i , side ) ;
7442: LD_VAR 0 3
7446: PPUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 235
7456: GO 7439
7458: POP
7459: POP
// end ; end ;
7460: LD_VAR 0 2
7464: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7465: LD_INT 94
7467: PPUSH
7468: CALL_OW 302
7472: PUSH
7473: LD_INT 94
7475: PPUSH
7476: CALL_OW 255
7480: PUSH
7481: LD_EXP 3
7485: EQUAL
7486: AND
7487: IFFALSE 8196
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
7496: PPUSH
7497: PPUSH
7498: PPUSH
7499: PPUSH
7500: PPUSH
7501: PPUSH
7502: PPUSH
7503: PPUSH
// begin enable ;
7504: ENABLE
// base := 1 ;
7505: LD_ADDR_VAR 0 4
7509: PUSH
7510: LD_INT 1
7512: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7513: LD_ADDR_VAR 0 7
7517: PUSH
7518: LD_INT 0
7520: PUSH
7521: LD_INT 0
7523: PUSH
7524: LD_INT 0
7526: PUSH
7527: LD_INT 0
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: LD_INT 0
7538: PUSH
7539: LD_INT 0
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: LD_INT 0
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7560: LD_ADDR_VAR 0 6
7564: PUSH
7565: LD_INT 28
7567: PUSH
7568: LD_INT 14
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 107
7577: PUSH
7578: LD_INT 119
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 127
7587: PUSH
7588: LD_INT 97
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 185
7597: PUSH
7598: LD_INT 127
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: ST_TO_ADDR
// target := 0 ;
7611: LD_ADDR_VAR 0 9
7615: PUSH
7616: LD_INT 0
7618: ST_TO_ADDR
// x := 0 ;
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 0
7626: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7627: LD_ADDR_VAR 0 5
7631: PUSH
7632: LD_INT 14
7634: PUSH
7635: LD_INT 1
7637: PUSH
7638: LD_INT 2
7640: PUSH
7641: LD_INT 28
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 14
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: LD_INT 25
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 28
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 14
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 2
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: ST_TO_ADDR
// if Difficulty > 1 then
7710: LD_OWVAR 67
7714: PUSH
7715: LD_INT 1
7717: GREATER
7718: IFFALSE 7815
// for i = 1 to Difficulty + 2 do
7720: LD_ADDR_VAR 0 1
7724: PUSH
7725: DOUBLE
7726: LD_INT 1
7728: DEC
7729: ST_TO_ADDR
7730: LD_OWVAR 67
7734: PUSH
7735: LD_INT 2
7737: PLUS
7738: PUSH
7739: FOR_TO
7740: IFFALSE 7813
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7742: LD_ADDR_VAR 0 5
7746: PUSH
7747: LD_VAR 0 5
7751: PPUSH
7752: LD_VAR 0 5
7756: PUSH
7757: LD_INT 1
7759: PLUS
7760: PPUSH
7761: LD_INT 14
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: LD_INT 2
7769: PUSH
7770: LD_INT 28
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 27
7778: PUSH
7779: LD_INT 29
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 1
7790: PPUSH
7791: LD_INT 4
7793: PPUSH
7794: CALL_OW 12
7798: ARRAY
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 2
7810: ST_TO_ADDR
7811: GO 7739
7813: POP
7814: POP
// MC_SetProduceList ( base , tmp ) ;
7815: LD_VAR 0 4
7819: PPUSH
7820: LD_VAR 0 5
7824: PPUSH
7825: CALL 75485 0 2
// repeat wait ( 0 0$1 ) ;
7829: LD_INT 35
7831: PPUSH
7832: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7836: LD_VAR 0 4
7840: PPUSH
7841: CALL 75881 0 1
7845: PUSH
7846: LD_INT 0
7848: EQUAL
7849: IFFALSE 7829
// wait ( 0 0$10 ) ;
7851: LD_INT 350
7853: PPUSH
7854: CALL_OW 67
// for i = 1 to coords do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7962
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: LD_EXP 3
7885: PPUSH
7886: LD_VAR 0 6
7890: PUSH
7891: LD_VAR 0 1
7895: ARRAY
7896: PUSH
7897: LD_INT 1
7899: ARRAY
7900: PPUSH
7901: LD_VAR 0 6
7905: PUSH
7906: LD_VAR 0 1
7910: ARRAY
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: LD_INT 35
7918: PPUSH
7919: CALL 15813 0 4
7923: PUSH
7924: LD_INT 4
7926: ARRAY
7927: ST_TO_ADDR
// if t > x then
7928: LD_VAR 0 2
7932: PUSH
7933: LD_VAR 0 3
7937: GREATER
7938: IFFALSE 7960
// begin x := t ;
7940: LD_ADDR_VAR 0 3
7944: PUSH
7945: LD_VAR 0 2
7949: ST_TO_ADDR
// target := i ;
7950: LD_ADDR_VAR 0 9
7954: PUSH
7955: LD_VAR 0 1
7959: ST_TO_ADDR
// end ; end ;
7960: GO 7873
7962: POP
7963: POP
// case target of 1 :
7964: LD_VAR 0 9
7968: PUSH
7969: LD_INT 1
7971: DOUBLE
7972: EQUAL
7973: IFTRUE 7977
7975: GO 8009
7977: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7978: LD_ADDR_VAR 0 10
7982: PUSH
7983: LD_INT 60
7985: PUSH
7986: LD_INT 8
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 28
7995: PUSH
7996: LD_INT 15
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: ST_TO_ADDR
8007: GO 8130
8009: LD_INT 2
8011: DOUBLE
8012: EQUAL
8013: IFTRUE 8017
8015: GO 8049
8017: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8018: LD_ADDR_VAR 0 10
8022: PUSH
8023: LD_INT 52
8025: PUSH
8026: LD_INT 11
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 76
8035: PUSH
8036: LD_INT 90
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: ST_TO_ADDR
8047: GO 8130
8049: LD_INT 3
8051: DOUBLE
8052: EQUAL
8053: IFTRUE 8057
8055: GO 8089
8057: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8058: LD_ADDR_VAR 0 10
8062: PUSH
8063: LD_INT 129
8065: PUSH
8066: LD_INT 66
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 130
8075: PUSH
8076: LD_INT 97
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: ST_TO_ADDR
8087: GO 8130
8089: LD_INT 4
8091: DOUBLE
8092: EQUAL
8093: IFTRUE 8097
8095: GO 8129
8097: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8098: LD_ADDR_VAR 0 10
8102: PUSH
8103: LD_INT 156
8105: PUSH
8106: LD_INT 87
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 183
8115: PUSH
8116: LD_INT 127
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: ST_TO_ADDR
8127: GO 8130
8129: POP
// if not _target then
8130: LD_VAR 0 10
8134: NOT
8135: IFFALSE 8166
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 52
8144: PUSH
8145: LD_INT 11
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 76
8154: PUSH
8155: LD_INT 90
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8166: LD_VAR 0 4
8170: PPUSH
8171: LD_EXP 62
8175: PUSH
8176: LD_VAR 0 4
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 10
8186: PPUSH
8187: LD_VAR 0 7
8191: PPUSH
8192: CALL 75718 0 4
// end ;
8196: PPOPN 10
8198: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8199: LD_INT 45
8201: PPUSH
8202: CALL_OW 302
8206: PUSH
8207: LD_INT 45
8209: PPUSH
8210: CALL_OW 255
8214: PUSH
8215: LD_EXP 3
8219: EQUAL
8220: AND
8221: PUSH
8222: LD_EXP 26
8226: PUSH
8227: LD_INT 3
8229: EQUAL
8230: PUSH
8231: LD_INT 94
8233: PPUSH
8234: CALL_OW 301
8238: OR
8239: PUSH
8240: LD_INT 94
8242: PPUSH
8243: CALL_OW 255
8247: PUSH
8248: LD_EXP 3
8252: NONEQUAL
8253: OR
8254: AND
8255: IFFALSE 8841
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
// begin enable ;
8272: ENABLE
// base := 2 ;
8273: LD_ADDR_VAR 0 4
8277: PUSH
8278: LD_INT 2
8280: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8281: LD_ADDR_VAR 0 7
8285: PUSH
8286: LD_INT 0
8288: PUSH
8289: LD_INT 0
8291: PUSH
8292: LD_INT 0
8294: PUSH
8295: LD_INT 0
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: LD_INT 0
8303: PUSH
8304: LD_INT 0
8306: PUSH
8307: LD_INT 0
8309: PUSH
8310: LD_INT 1
8312: PUSH
8313: LD_INT 0
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8328: LD_ADDR_VAR 0 6
8332: PUSH
8333: LD_INT 101
8335: PUSH
8336: LD_INT 110
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 100
8345: PUSH
8346: LD_INT 21
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: ST_TO_ADDR
// target := 0 ;
8357: LD_ADDR_VAR 0 9
8361: PUSH
8362: LD_INT 0
8364: ST_TO_ADDR
// x := 0 ;
8365: LD_ADDR_VAR 0 3
8369: PUSH
8370: LD_INT 0
8372: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8373: LD_ADDR_VAR 0 5
8377: PUSH
8378: LD_INT 14
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: LD_INT 2
8386: PUSH
8387: LD_INT 28
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 14
8398: PUSH
8399: LD_INT 1
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_INT 25
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 14
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 28
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: ST_TO_ADDR
// if Difficulty > 1 then
8437: LD_OWVAR 67
8441: PUSH
8442: LD_INT 1
8444: GREATER
8445: IFFALSE 8540
// for i = 1 to Difficulty + 1 do
8447: LD_ADDR_VAR 0 1
8451: PUSH
8452: DOUBLE
8453: LD_INT 1
8455: DEC
8456: ST_TO_ADDR
8457: LD_OWVAR 67
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: PUSH
8466: FOR_TO
8467: IFFALSE 8538
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_VAR 0 5
8478: PPUSH
8479: LD_VAR 0 5
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: PPUSH
8488: LD_INT 14
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 2
8496: PUSH
8497: LD_INT 28
8499: PUSH
8500: LD_INT 27
8502: PUSH
8503: LD_INT 27
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: LIST
8510: PUSH
8511: LD_VAR 0 1
8515: PUSH
8516: LD_INT 2
8518: MOD
8519: PUSH
8520: LD_INT 1
8522: PLUS
8523: ARRAY
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 2
8535: ST_TO_ADDR
8536: GO 8466
8538: POP
8539: POP
// MC_SetProduceList ( base , tmp ) ;
8540: LD_VAR 0 4
8544: PPUSH
8545: LD_VAR 0 5
8549: PPUSH
8550: CALL 75485 0 2
// repeat wait ( 0 0$1 ) ;
8554: LD_INT 35
8556: PPUSH
8557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8561: LD_VAR 0 4
8565: PPUSH
8566: CALL 75881 0 1
8570: PUSH
8571: LD_INT 0
8573: EQUAL
8574: IFFALSE 8554
// wait ( 0 0$10 ) ;
8576: LD_INT 350
8578: PPUSH
8579: CALL_OW 67
// for i = 1 to coords do
8583: LD_ADDR_VAR 0 1
8587: PUSH
8588: DOUBLE
8589: LD_INT 1
8591: DEC
8592: ST_TO_ADDR
8593: LD_VAR 0 6
8597: PUSH
8598: FOR_TO
8599: IFFALSE 8687
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8601: LD_ADDR_VAR 0 2
8605: PUSH
8606: LD_EXP 3
8610: PPUSH
8611: LD_VAR 0 6
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: LD_VAR 0 6
8630: PUSH
8631: LD_VAR 0 1
8635: ARRAY
8636: PUSH
8637: LD_INT 2
8639: ARRAY
8640: PPUSH
8641: LD_INT 35
8643: PPUSH
8644: CALL 15813 0 4
8648: PUSH
8649: LD_INT 4
8651: ARRAY
8652: ST_TO_ADDR
// if t > x then
8653: LD_VAR 0 2
8657: PUSH
8658: LD_VAR 0 3
8662: GREATER
8663: IFFALSE 8685
// begin x := t ;
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: LD_VAR 0 2
8674: ST_TO_ADDR
// target := i ;
8675: LD_ADDR_VAR 0 9
8679: PUSH
8680: LD_VAR 0 1
8684: ST_TO_ADDR
// end ; end ;
8685: GO 8598
8687: POP
8688: POP
// case target of 1 :
8689: LD_VAR 0 9
8693: PUSH
8694: LD_INT 1
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 8734
8702: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8703: LD_ADDR_VAR 0 10
8707: PUSH
8708: LD_INT 49
8710: PUSH
8711: LD_INT 35
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PUSH
8718: LD_INT 76
8720: PUSH
8721: LD_INT 90
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: ST_TO_ADDR
8732: GO 8775
8734: LD_INT 2
8736: DOUBLE
8737: EQUAL
8738: IFTRUE 8742
8740: GO 8774
8742: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8743: LD_ADDR_VAR 0 10
8747: PUSH
8748: LD_INT 79
8750: PUSH
8751: LD_INT 13
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: PUSH
8758: LD_INT 100
8760: PUSH
8761: LD_INT 22
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: ST_TO_ADDR
8772: GO 8775
8774: POP
// if not _target then
8775: LD_VAR 0 10
8779: NOT
8780: IFFALSE 8811
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 49
8789: PUSH
8790: LD_INT 35
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 76
8799: PUSH
8800: LD_INT 90
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8811: LD_VAR 0 4
8815: PPUSH
8816: LD_EXP 62
8820: PUSH
8821: LD_VAR 0 4
8825: ARRAY
8826: PPUSH
8827: LD_VAR 0 10
8831: PPUSH
8832: LD_VAR 0 7
8836: PPUSH
8837: CALL 75718 0 4
// end ; end_of_file
8841: PPOPN 10
8843: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8844: LD_INT 0
8846: PPUSH
8847: PPUSH
// begin if artifact_get then
8848: LD_EXP 4
8852: IFFALSE 8856
// exit ;
8854: GO 8878
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 255
8865: PPUSH
8866: CALL 5788 0 1
// artifact_get := true ;
8870: LD_ADDR_EXP 4
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// end ;
8878: PPOPN 4
8880: END
// on UnitDestroyed ( un ) do var i , side ;
8881: LD_INT 0
8883: PPUSH
8884: PPUSH
// begin side := GetSide ( un ) ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_VAR 0 1
8894: PPUSH
8895: CALL_OW 255
8899: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8900: LD_VAR 0 3
8904: PUSH
8905: LD_EXP 69
8909: IN
8910: NOT
8911: PUSH
8912: LD_EXP 7
8916: PUSH
8917: LD_VAR 0 3
8921: ARRAY
8922: AND
8923: IFFALSE 8949
// if GetType ( un ) = unit_human then
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 247
8934: PUSH
8935: LD_INT 1
8937: EQUAL
8938: IFFALSE 8949
// MultiplayerEvent_HumanLost ( side ) ;
8940: LD_VAR 0 3
8944: PPUSH
8945: CALL 5428 0 1
// if side in mc_sides then
8949: LD_VAR 0 3
8953: PUSH
8954: LD_EXP 69
8958: IN
8959: IFFALSE 9004
// if un <> Gensher then
8961: LD_VAR 0 1
8965: PUSH
8966: LD_EXP 40
8970: NONEQUAL
8971: IFFALSE 8987
// MultiplayerEvent_UnitKilled ( un , false ) else
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 0
8980: PPUSH
8981: CALL 5542 0 2
8985: GO 9004
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8987: LD_VAR 0 1
8991: PPUSH
8992: LD_INT 5
8994: PPUSH
8995: CALL 4859 0 1
8999: PPUSH
9000: CALL 5542 0 2
// if multi_commanders and multi_custom_commanders then
9004: LD_EXP 24
9008: PUSH
9009: LD_EXP 16
9013: AND
9014: IFFALSE 9076
// if un in multi_commanders then
9016: LD_VAR 0 1
9020: PUSH
9021: LD_EXP 24
9025: IN
9026: IFFALSE 9076
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9028: LD_ADDR_EXP 25
9032: PUSH
9033: LD_EXP 25
9037: PPUSH
9038: LD_VAR 0 3
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 1
9050: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9051: LD_ADDR_EXP 24
9055: PUSH
9056: LD_EXP 24
9060: PUSH
9061: LD_VAR 0 1
9065: DIFF
9066: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL 4892 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: CALL 78975 0 1
// end ;
9085: PPOPN 3
9087: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9088: LD_VAR 0 1
9092: PPUSH
9093: LD_VAR 0 2
9097: PPUSH
9098: CALL 81307 0 2
// end ;
9102: PPOPN 2
9104: END
// on BuildingComplete ( building ) do var i , j ;
9105: LD_INT 0
9107: PPUSH
9108: PPUSH
// begin if GetSide ( building ) in mc_sides then
9109: LD_VAR 0 1
9113: PPUSH
9114: CALL_OW 255
9118: PUSH
9119: LD_EXP 69
9123: IN
9124: IFFALSE 9150
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9126: LD_VAR 0 1
9130: PPUSH
9131: CALL_OW 255
9135: PPUSH
9136: LD_VAR 0 1
9140: PPUSH
9141: CALL_OW 266
9145: PPUSH
9146: CALL 5472 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9150: LD_VAR 0 1
9154: PPUSH
9155: CALL_OW 266
9159: PUSH
9160: LD_INT 0
9162: EQUAL
9163: PUSH
9164: LD_VAR 0 1
9168: PPUSH
9169: CALL_OW 255
9173: PUSH
9174: LD_EXP 69
9178: IN
9179: NOT
9180: AND
9181: PUSH
9182: LD_EXP 5
9186: AND
9187: IFFALSE 9225
// begin SetBName ( building , base_names [ 1 ] ) ;
9189: LD_VAR 0 1
9193: PPUSH
9194: LD_EXP 5
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9207: LD_ADDR_EXP 5
9211: PUSH
9212: LD_EXP 5
9216: PPUSH
9217: LD_INT 1
9219: PPUSH
9220: CALL_OW 3
9224: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9225: LD_VAR 0 1
9229: PPUSH
9230: CALL 80616 0 1
// end ;
9234: PPOPN 3
9236: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9237: LD_VAR 0 1
9241: PPUSH
9242: LD_VAR 0 2
9246: PPUSH
9247: CALL 78671 0 2
// end ;
9251: PPOPN 2
9253: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9254: LD_VAR 0 1
9258: PPUSH
9259: LD_VAR 0 2
9263: PPUSH
9264: LD_VAR 0 3
9268: PPUSH
9269: LD_VAR 0 4
9273: PPUSH
9274: LD_VAR 0 5
9278: PPUSH
9279: CALL 78291 0 5
// end ;
9283: PPOPN 5
9285: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
9290: PPUSH
// begin side := GetSide ( vehicle ) ;
9291: LD_ADDR_VAR 0 4
9295: PUSH
9296: LD_VAR 0 1
9300: PPUSH
9301: CALL_OW 255
9305: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9306: LD_VAR 0 4
9310: PUSH
9311: LD_EXP 69
9315: IN
9316: NOT
9317: PUSH
9318: LD_EXP 7
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: AND
9329: IFFALSE 9340
// MultiplayerEvent_Produced ( side ) ;
9331: LD_VAR 0 4
9335: PPUSH
9336: CALL 5384 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9340: LD_VAR 0 1
9344: PPUSH
9345: LD_VAR 0 2
9349: PPUSH
9350: CALL 77844 0 2
// end ;
9354: PPOPN 5
9356: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9357: LD_VAR 0 1
9361: PPUSH
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_VAR 0 3
9371: PPUSH
9372: LD_VAR 0 4
9376: PPUSH
9377: CALL 77682 0 4
// end ;
9381: PPOPN 4
9383: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9384: LD_VAR 0 1
9388: PPUSH
9389: LD_VAR 0 2
9393: PPUSH
9394: LD_VAR 0 3
9398: PPUSH
9399: CALL 77457 0 3
// end ;
9403: PPOPN 3
9405: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9406: LD_VAR 0 1
9410: PPUSH
9411: LD_VAR 0 2
9415: PPUSH
9416: CALL 77342 0 2
// end ;
9420: PPOPN 2
9422: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: CALL 81602 0 2
// end ;
9437: PPOPN 2
9439: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: LD_VAR 0 2
9449: PPUSH
9450: LD_VAR 0 3
9454: PPUSH
9455: LD_VAR 0 4
9459: PPUSH
9460: CALL 81818 0 4
// end ; end_of_file
9464: PPOPN 4
9466: END
// every 0 0$20 trigger game do
9467: LD_EXP 2
9471: IFFALSE 9516
9473: GO 9475
9475: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9476: LD_INT 7
9478: PUSH
9479: LD_INT 6
9481: PUSH
9482: LD_INT 4
9484: PUSH
9485: LD_INT 6
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: PPUSH
9494: LD_EXP 21
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: LD_EXP 21
9507: PUSH
9508: LD_INT 1
9510: ARRAY
9511: PPUSH
9512: CALL 9517 0 3
9516: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9517: LD_INT 0
9519: PPUSH
9520: PPUSH
9521: PPUSH
9522: PPUSH
// if not areas then
9523: LD_VAR 0 1
9527: NOT
9528: IFFALSE 9532
// exit ;
9530: GO 9807
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9532: LD_ADDR_VAR 0 7
9536: PUSH
9537: LD_INT 31
9539: PUSH
9540: LD_INT 32
9542: PUSH
9543: LD_INT 30
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: ST_TO_ADDR
// repeat wait ( time ) ;
9551: LD_VAR 0 2
9555: PPUSH
9556: CALL_OW 67
// x := 5 ;
9560: LD_ADDR_VAR 0 6
9564: PUSH
9565: LD_INT 5
9567: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9568: LD_OWVAR 1
9572: PUSH
9573: LD_INT 42000
9575: PUSH
9576: LD_INT 37800
9578: PUSH
9579: LD_INT 29400
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: LD_OWVAR 67
9591: ARRAY
9592: LESS
9593: IFFALSE 9665
// begin for i = 1 to multi_sides do
9595: LD_ADDR_VAR 0 5
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_EXP 7
9609: PUSH
9610: FOR_TO
9611: IFFALSE 9656
// if multi_sides [ i ] then
9613: LD_EXP 7
9617: PUSH
9618: LD_VAR 0 5
9622: ARRAY
9623: IFFALSE 9654
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9625: LD_VAR 0 6
9629: PPUSH
9630: LD_VAR 0 7
9634: PUSH
9635: LD_EXP 7
9639: PUSH
9640: LD_VAR 0 5
9644: ARRAY
9645: ARRAY
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: CALL_OW 55
9654: GO 9610
9656: POP
9657: POP
// wait ( 0 0$6 ) ;
9658: LD_INT 210
9660: PPUSH
9661: CALL_OW 67
// end ; for i in areas do
9665: LD_ADDR_VAR 0 5
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: FOR_IN
9676: IFFALSE 9704
// begin wait ( 0 0$6 ) ;
9678: LD_INT 210
9680: PPUSH
9681: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: LD_INT 1
9697: PPUSH
9698: CALL_OW 55
// end ;
9702: GO 9675
9704: POP
9705: POP
// time := time + 0 0$2 ;
9706: LD_ADDR_VAR 0 2
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 70
9718: PLUS
9719: ST_TO_ADDR
// amount := amount - x * 10 ;
9720: LD_ADDR_VAR 0 3
9724: PUSH
9725: LD_VAR 0 3
9729: PUSH
9730: LD_VAR 0 6
9734: PUSH
9735: LD_INT 10
9737: MUL
9738: MINUS
9739: ST_TO_ADDR
// x := x - 1 ;
9740: LD_ADDR_VAR 0 6
9744: PUSH
9745: LD_VAR 0 6
9749: PUSH
9750: LD_INT 1
9752: MINUS
9753: ST_TO_ADDR
// if x = 0 then
9754: LD_VAR 0 6
9758: PUSH
9759: LD_INT 0
9761: EQUAL
9762: IFFALSE 9772
// x := 5 ;
9764: LD_ADDR_VAR 0 6
9768: PUSH
9769: LD_INT 5
9771: ST_TO_ADDR
// if time > 4 4$00 then
9772: LD_VAR 0 2
9776: PUSH
9777: LD_INT 8400
9779: GREATER
9780: IFFALSE 9790
// time := 0 0$40 ;
9782: LD_ADDR_VAR 0 2
9786: PUSH
9787: LD_INT 1400
9789: ST_TO_ADDR
// until not game or amount <= 0 ;
9790: LD_EXP 2
9794: NOT
9795: PUSH
9796: LD_VAR 0 3
9800: PUSH
9801: LD_INT 0
9803: LESSEQUAL
9804: OR
9805: IFFALSE 9551
// end ; end_of_file
9807: LD_VAR 0 4
9811: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9812: LD_INT 0
9814: PPUSH
9815: PPUSH
// if exist_mode then
9816: LD_VAR 0 2
9820: IFFALSE 9845
// unit := CreateCharacter ( prefix & ident ) else
9822: LD_ADDR_VAR 0 5
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_VAR 0 1
9836: STR
9837: PPUSH
9838: CALL_OW 34
9842: ST_TO_ADDR
9843: GO 9860
// unit := NewCharacter ( ident ) ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 25
9859: ST_TO_ADDR
// result := unit ;
9860: LD_ADDR_VAR 0 4
9864: PUSH
9865: LD_VAR 0 5
9869: ST_TO_ADDR
// end ;
9870: LD_VAR 0 4
9874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9875: LD_INT 0
9877: PPUSH
9878: PPUSH
// if not side or not nation then
9879: LD_VAR 0 1
9883: NOT
9884: PUSH
9885: LD_VAR 0 2
9889: NOT
9890: OR
9891: IFFALSE 9895
// exit ;
9893: GO 10663
// case nation of nation_american :
9895: LD_VAR 0 2
9899: PUSH
9900: LD_INT 1
9902: DOUBLE
9903: EQUAL
9904: IFTRUE 9908
9906: GO 10122
9908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9909: LD_ADDR_VAR 0 4
9913: PUSH
9914: LD_INT 35
9916: PUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 46
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: LD_INT 82
9928: PUSH
9929: LD_INT 83
9931: PUSH
9932: LD_INT 84
9934: PUSH
9935: LD_INT 85
9937: PUSH
9938: LD_INT 86
9940: PUSH
9941: LD_INT 1
9943: PUSH
9944: LD_INT 2
9946: PUSH
9947: LD_INT 6
9949: PUSH
9950: LD_INT 15
9952: PUSH
9953: LD_INT 16
9955: PUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 12
9961: PUSH
9962: LD_INT 13
9964: PUSH
9965: LD_INT 10
9967: PUSH
9968: LD_INT 14
9970: PUSH
9971: LD_INT 20
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 22
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 32
9985: PUSH
9986: LD_INT 27
9988: PUSH
9989: LD_INT 36
9991: PUSH
9992: LD_INT 69
9994: PUSH
9995: LD_INT 39
9997: PUSH
9998: LD_INT 34
10000: PUSH
10001: LD_INT 40
10003: PUSH
10004: LD_INT 48
10006: PUSH
10007: LD_INT 49
10009: PUSH
10010: LD_INT 50
10012: PUSH
10013: LD_INT 51
10015: PUSH
10016: LD_INT 52
10018: PUSH
10019: LD_INT 53
10021: PUSH
10022: LD_INT 54
10024: PUSH
10025: LD_INT 55
10027: PUSH
10028: LD_INT 56
10030: PUSH
10031: LD_INT 57
10033: PUSH
10034: LD_INT 58
10036: PUSH
10037: LD_INT 59
10039: PUSH
10040: LD_INT 60
10042: PUSH
10043: LD_INT 61
10045: PUSH
10046: LD_INT 62
10048: PUSH
10049: LD_INT 80
10051: PUSH
10052: LD_INT 82
10054: PUSH
10055: LD_INT 83
10057: PUSH
10058: LD_INT 84
10060: PUSH
10061: LD_INT 85
10063: PUSH
10064: LD_INT 86
10066: PUSH
10067: EMPTY
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: ST_TO_ADDR
10120: GO 10587
10122: LD_INT 2
10124: DOUBLE
10125: EQUAL
10126: IFTRUE 10130
10128: GO 10356
10130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10131: LD_ADDR_VAR 0 4
10135: PUSH
10136: LD_INT 35
10138: PUSH
10139: LD_INT 45
10141: PUSH
10142: LD_INT 46
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: LD_INT 82
10150: PUSH
10151: LD_INT 83
10153: PUSH
10154: LD_INT 84
10156: PUSH
10157: LD_INT 85
10159: PUSH
10160: LD_INT 87
10162: PUSH
10163: LD_INT 70
10165: PUSH
10166: LD_INT 1
10168: PUSH
10169: LD_INT 11
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 4
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: LD_INT 6
10183: PUSH
10184: LD_INT 15
10186: PUSH
10187: LD_INT 18
10189: PUSH
10190: LD_INT 7
10192: PUSH
10193: LD_INT 17
10195: PUSH
10196: LD_INT 8
10198: PUSH
10199: LD_INT 20
10201: PUSH
10202: LD_INT 21
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 72
10210: PUSH
10211: LD_INT 26
10213: PUSH
10214: LD_INT 69
10216: PUSH
10217: LD_INT 39
10219: PUSH
10220: LD_INT 40
10222: PUSH
10223: LD_INT 41
10225: PUSH
10226: LD_INT 42
10228: PUSH
10229: LD_INT 43
10231: PUSH
10232: LD_INT 48
10234: PUSH
10235: LD_INT 49
10237: PUSH
10238: LD_INT 50
10240: PUSH
10241: LD_INT 51
10243: PUSH
10244: LD_INT 52
10246: PUSH
10247: LD_INT 53
10249: PUSH
10250: LD_INT 54
10252: PUSH
10253: LD_INT 55
10255: PUSH
10256: LD_INT 56
10258: PUSH
10259: LD_INT 60
10261: PUSH
10262: LD_INT 61
10264: PUSH
10265: LD_INT 62
10267: PUSH
10268: LD_INT 66
10270: PUSH
10271: LD_INT 67
10273: PUSH
10274: LD_INT 68
10276: PUSH
10277: LD_INT 81
10279: PUSH
10280: LD_INT 82
10282: PUSH
10283: LD_INT 83
10285: PUSH
10286: LD_INT 84
10288: PUSH
10289: LD_INT 85
10291: PUSH
10292: LD_INT 87
10294: PUSH
10295: LD_INT 88
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: ST_TO_ADDR
10354: GO 10587
10356: LD_INT 3
10358: DOUBLE
10359: EQUAL
10360: IFTRUE 10364
10362: GO 10586
10364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10365: LD_ADDR_VAR 0 4
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: LD_INT 47
10375: PUSH
10376: LD_INT 1
10378: PUSH
10379: LD_INT 2
10381: PUSH
10382: LD_INT 82
10384: PUSH
10385: LD_INT 83
10387: PUSH
10388: LD_INT 84
10390: PUSH
10391: LD_INT 85
10393: PUSH
10394: LD_INT 86
10396: PUSH
10397: LD_INT 11
10399: PUSH
10400: LD_INT 9
10402: PUSH
10403: LD_INT 20
10405: PUSH
10406: LD_INT 19
10408: PUSH
10409: LD_INT 21
10411: PUSH
10412: LD_INT 24
10414: PUSH
10415: LD_INT 22
10417: PUSH
10418: LD_INT 25
10420: PUSH
10421: LD_INT 28
10423: PUSH
10424: LD_INT 29
10426: PUSH
10427: LD_INT 30
10429: PUSH
10430: LD_INT 31
10432: PUSH
10433: LD_INT 37
10435: PUSH
10436: LD_INT 38
10438: PUSH
10439: LD_INT 32
10441: PUSH
10442: LD_INT 27
10444: PUSH
10445: LD_INT 33
10447: PUSH
10448: LD_INT 69
10450: PUSH
10451: LD_INT 39
10453: PUSH
10454: LD_INT 34
10456: PUSH
10457: LD_INT 40
10459: PUSH
10460: LD_INT 71
10462: PUSH
10463: LD_INT 23
10465: PUSH
10466: LD_INT 44
10468: PUSH
10469: LD_INT 48
10471: PUSH
10472: LD_INT 49
10474: PUSH
10475: LD_INT 50
10477: PUSH
10478: LD_INT 51
10480: PUSH
10481: LD_INT 52
10483: PUSH
10484: LD_INT 53
10486: PUSH
10487: LD_INT 54
10489: PUSH
10490: LD_INT 55
10492: PUSH
10493: LD_INT 56
10495: PUSH
10496: LD_INT 57
10498: PUSH
10499: LD_INT 58
10501: PUSH
10502: LD_INT 59
10504: PUSH
10505: LD_INT 63
10507: PUSH
10508: LD_INT 64
10510: PUSH
10511: LD_INT 65
10513: PUSH
10514: LD_INT 82
10516: PUSH
10517: LD_INT 83
10519: PUSH
10520: LD_INT 84
10522: PUSH
10523: LD_INT 85
10525: PUSH
10526: LD_INT 86
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: ST_TO_ADDR
10584: GO 10587
10586: POP
// if state > - 1 and state < 3 then
10587: LD_VAR 0 3
10591: PUSH
10592: LD_INT 1
10594: NEG
10595: GREATER
10596: PUSH
10597: LD_VAR 0 3
10601: PUSH
10602: LD_INT 3
10604: LESS
10605: AND
10606: IFFALSE 10663
// for i in result do
10608: LD_ADDR_VAR 0 5
10612: PUSH
10613: LD_VAR 0 4
10617: PUSH
10618: FOR_IN
10619: IFFALSE 10661
// if GetTech ( i , side ) <> state then
10621: LD_VAR 0 5
10625: PPUSH
10626: LD_VAR 0 1
10630: PPUSH
10631: CALL_OW 321
10635: PUSH
10636: LD_VAR 0 3
10640: NONEQUAL
10641: IFFALSE 10659
// result := result diff i ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: LD_VAR 0 5
10657: DIFF
10658: ST_TO_ADDR
10659: GO 10618
10661: POP
10662: POP
// end ;
10663: LD_VAR 0 4
10667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10668: LD_INT 0
10670: PPUSH
10671: PPUSH
10672: PPUSH
// result := true ;
10673: LD_ADDR_VAR 0 3
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10681: LD_ADDR_VAR 0 5
10685: PUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 480
10695: ST_TO_ADDR
// if not tmp then
10696: LD_VAR 0 5
10700: NOT
10701: IFFALSE 10705
// exit ;
10703: GO 10754
// for i in tmp do
10705: LD_ADDR_VAR 0 4
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: FOR_IN
10716: IFFALSE 10752
// if GetTech ( i , side ) <> state_researched then
10718: LD_VAR 0 4
10722: PPUSH
10723: LD_VAR 0 1
10727: PPUSH
10728: CALL_OW 321
10732: PUSH
10733: LD_INT 2
10735: NONEQUAL
10736: IFFALSE 10750
// begin result := false ;
10738: LD_ADDR_VAR 0 3
10742: PUSH
10743: LD_INT 0
10745: ST_TO_ADDR
// exit ;
10746: POP
10747: POP
10748: GO 10754
// end ;
10750: GO 10715
10752: POP
10753: POP
// end ;
10754: LD_VAR 0 3
10758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10759: LD_INT 0
10761: PPUSH
10762: PPUSH
10763: PPUSH
10764: PPUSH
10765: PPUSH
10766: PPUSH
10767: PPUSH
10768: PPUSH
10769: PPUSH
10770: PPUSH
10771: PPUSH
10772: PPUSH
10773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10774: LD_VAR 0 1
10778: NOT
10779: PUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 257
10789: PUSH
10790: LD_INT 9
10792: NONEQUAL
10793: OR
10794: IFFALSE 10798
// exit ;
10796: GO 11371
// side := GetSide ( unit ) ;
10798: LD_ADDR_VAR 0 9
10802: PUSH
10803: LD_VAR 0 1
10807: PPUSH
10808: CALL_OW 255
10812: ST_TO_ADDR
// tech_space := tech_spacanom ;
10813: LD_ADDR_VAR 0 12
10817: PUSH
10818: LD_INT 29
10820: ST_TO_ADDR
// tech_time := tech_taurad ;
10821: LD_ADDR_VAR 0 13
10825: PUSH
10826: LD_INT 28
10828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10829: LD_ADDR_VAR 0 11
10833: PUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 310
10843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10844: LD_VAR 0 11
10848: PPUSH
10849: CALL_OW 247
10853: PUSH
10854: LD_INT 2
10856: EQUAL
10857: IFFALSE 10861
// exit ;
10859: GO 11371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10861: LD_ADDR_VAR 0 8
10865: PUSH
10866: LD_INT 81
10868: PUSH
10869: LD_VAR 0 9
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 3
10880: PUSH
10881: LD_INT 21
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: ST_TO_ADDR
// if not tmp then
10904: LD_VAR 0 8
10908: NOT
10909: IFFALSE 10913
// exit ;
10911: GO 11371
// if in_unit then
10913: LD_VAR 0 11
10917: IFFALSE 10941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10919: LD_ADDR_VAR 0 10
10923: PUSH
10924: LD_VAR 0 8
10928: PPUSH
10929: LD_VAR 0 11
10933: PPUSH
10934: CALL_OW 74
10938: ST_TO_ADDR
10939: GO 10961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10941: LD_ADDR_VAR 0 10
10945: PUSH
10946: LD_VAR 0 8
10950: PPUSH
10951: LD_VAR 0 1
10955: PPUSH
10956: CALL_OW 74
10960: ST_TO_ADDR
// if not enemy then
10961: LD_VAR 0 10
10965: NOT
10966: IFFALSE 10970
// exit ;
10968: GO 11371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10970: LD_VAR 0 11
10974: PUSH
10975: LD_VAR 0 11
10979: PPUSH
10980: LD_VAR 0 10
10984: PPUSH
10985: CALL_OW 296
10989: PUSH
10990: LD_INT 13
10992: GREATER
10993: AND
10994: PUSH
10995: LD_VAR 0 1
10999: PPUSH
11000: LD_VAR 0 10
11004: PPUSH
11005: CALL_OW 296
11009: PUSH
11010: LD_INT 12
11012: GREATER
11013: OR
11014: IFFALSE 11018
// exit ;
11016: GO 11371
// missile := [ 1 ] ;
11018: LD_ADDR_VAR 0 14
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11029: LD_VAR 0 9
11033: PPUSH
11034: LD_VAR 0 12
11038: PPUSH
11039: CALL_OW 325
11043: IFFALSE 11072
// missile := Replace ( missile , missile + 1 , 2 ) ;
11045: LD_ADDR_VAR 0 14
11049: PUSH
11050: LD_VAR 0 14
11054: PPUSH
11055: LD_VAR 0 14
11059: PUSH
11060: LD_INT 1
11062: PLUS
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: CALL_OW 1
11071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11072: LD_VAR 0 9
11076: PPUSH
11077: LD_VAR 0 13
11081: PPUSH
11082: CALL_OW 325
11086: PUSH
11087: LD_VAR 0 10
11091: PPUSH
11092: CALL_OW 255
11096: PPUSH
11097: LD_VAR 0 13
11101: PPUSH
11102: CALL_OW 325
11106: NOT
11107: AND
11108: IFFALSE 11137
// missile := Replace ( missile , missile + 1 , 3 ) ;
11110: LD_ADDR_VAR 0 14
11114: PUSH
11115: LD_VAR 0 14
11119: PPUSH
11120: LD_VAR 0 14
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: PPUSH
11129: LD_INT 3
11131: PPUSH
11132: CALL_OW 1
11136: ST_TO_ADDR
// if missile < 2 then
11137: LD_VAR 0 14
11141: PUSH
11142: LD_INT 2
11144: LESS
11145: IFFALSE 11149
// exit ;
11147: GO 11371
// x := GetX ( enemy ) ;
11149: LD_ADDR_VAR 0 4
11153: PUSH
11154: LD_VAR 0 10
11158: PPUSH
11159: CALL_OW 250
11163: ST_TO_ADDR
// y := GetY ( enemy ) ;
11164: LD_ADDR_VAR 0 5
11168: PUSH
11169: LD_VAR 0 10
11173: PPUSH
11174: CALL_OW 251
11178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11179: LD_ADDR_VAR 0 6
11183: PUSH
11184: LD_VAR 0 4
11188: PUSH
11189: LD_INT 1
11191: NEG
11192: PPUSH
11193: LD_INT 1
11195: PPUSH
11196: CALL_OW 12
11200: PLUS
11201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11202: LD_ADDR_VAR 0 7
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: LD_INT 1
11214: NEG
11215: PPUSH
11216: LD_INT 1
11218: PPUSH
11219: CALL_OW 12
11223: PLUS
11224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11225: LD_VAR 0 6
11229: PPUSH
11230: LD_VAR 0 7
11234: PPUSH
11235: CALL_OW 488
11239: NOT
11240: IFFALSE 11262
// begin _x := x ;
11242: LD_ADDR_VAR 0 6
11246: PUSH
11247: LD_VAR 0 4
11251: ST_TO_ADDR
// _y := y ;
11252: LD_ADDR_VAR 0 7
11256: PUSH
11257: LD_VAR 0 5
11261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: LD_INT 1
11269: PPUSH
11270: LD_VAR 0 14
11274: PPUSH
11275: CALL_OW 12
11279: ST_TO_ADDR
// case i of 1 :
11280: LD_VAR 0 3
11284: PUSH
11285: LD_INT 1
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11310
11293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11294: LD_VAR 0 1
11298: PPUSH
11299: LD_VAR 0 10
11303: PPUSH
11304: CALL_OW 115
11308: GO 11371
11310: LD_INT 2
11312: DOUBLE
11313: EQUAL
11314: IFTRUE 11318
11316: GO 11340
11318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_VAR 0 6
11328: PPUSH
11329: LD_VAR 0 7
11333: PPUSH
11334: CALL_OW 153
11338: GO 11371
11340: LD_INT 3
11342: DOUBLE
11343: EQUAL
11344: IFTRUE 11348
11346: GO 11370
11348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11349: LD_VAR 0 1
11353: PPUSH
11354: LD_VAR 0 6
11358: PPUSH
11359: LD_VAR 0 7
11363: PPUSH
11364: CALL_OW 154
11368: GO 11371
11370: POP
// end ;
11371: LD_VAR 0 2
11375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11376: LD_INT 0
11378: PPUSH
11379: PPUSH
11380: PPUSH
11381: PPUSH
11382: PPUSH
11383: PPUSH
// if not unit or not building then
11384: LD_VAR 0 1
11388: NOT
11389: PUSH
11390: LD_VAR 0 2
11394: NOT
11395: OR
11396: IFFALSE 11400
// exit ;
11398: GO 11558
// x := GetX ( building ) ;
11400: LD_ADDR_VAR 0 5
11404: PUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL_OW 250
11414: ST_TO_ADDR
// y := GetY ( building ) ;
11415: LD_ADDR_VAR 0 6
11419: PUSH
11420: LD_VAR 0 2
11424: PPUSH
11425: CALL_OW 251
11429: ST_TO_ADDR
// for i = 0 to 5 do
11430: LD_ADDR_VAR 0 4
11434: PUSH
11435: DOUBLE
11436: LD_INT 0
11438: DEC
11439: ST_TO_ADDR
11440: LD_INT 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11556
// begin _x := ShiftX ( x , i , 3 ) ;
11446: LD_ADDR_VAR 0 7
11450: PUSH
11451: LD_VAR 0 5
11455: PPUSH
11456: LD_VAR 0 4
11460: PPUSH
11461: LD_INT 3
11463: PPUSH
11464: CALL_OW 272
11468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11469: LD_ADDR_VAR 0 8
11473: PUSH
11474: LD_VAR 0 6
11478: PPUSH
11479: LD_VAR 0 4
11483: PPUSH
11484: LD_INT 3
11486: PPUSH
11487: CALL_OW 273
11491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11492: LD_VAR 0 7
11496: PPUSH
11497: LD_VAR 0 8
11501: PPUSH
11502: CALL_OW 488
11506: NOT
11507: IFFALSE 11511
// continue ;
11509: GO 11443
// if HexInfo ( _x , _y ) = 0 then
11511: LD_VAR 0 7
11515: PPUSH
11516: LD_VAR 0 8
11520: PPUSH
11521: CALL_OW 428
11525: PUSH
11526: LD_INT 0
11528: EQUAL
11529: IFFALSE 11554
// begin ComMoveXY ( unit , _x , _y ) ;
11531: LD_VAR 0 1
11535: PPUSH
11536: LD_VAR 0 7
11540: PPUSH
11541: LD_VAR 0 8
11545: PPUSH
11546: CALL_OW 111
// exit ;
11550: POP
11551: POP
11552: GO 11558
// end ; end ;
11554: GO 11443
11556: POP
11557: POP
// end ;
11558: LD_VAR 0 3
11562: RET
// export function ScanBase ( side , base_area ) ; begin
11563: LD_INT 0
11565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11566: LD_ADDR_VAR 0 3
11570: PUSH
11571: LD_VAR 0 2
11575: PPUSH
11576: LD_INT 81
11578: PUSH
11579: LD_VAR 0 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 70
11592: ST_TO_ADDR
// end ;
11593: LD_VAR 0 3
11597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
// result := false ;
11604: LD_ADDR_VAR 0 2
11608: PUSH
11609: LD_INT 0
11611: ST_TO_ADDR
// side := GetSide ( unit ) ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 1
11621: PPUSH
11622: CALL_OW 255
11626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11627: LD_ADDR_VAR 0 4
11631: PUSH
11632: LD_VAR 0 1
11636: PPUSH
11637: CALL_OW 248
11641: ST_TO_ADDR
// case nat of 1 :
11642: LD_VAR 0 4
11646: PUSH
11647: LD_INT 1
11649: DOUBLE
11650: EQUAL
11651: IFTRUE 11655
11653: GO 11666
11655: POP
// tech := tech_lassight ; 2 :
11656: LD_ADDR_VAR 0 5
11660: PUSH
11661: LD_INT 12
11663: ST_TO_ADDR
11664: GO 11705
11666: LD_INT 2
11668: DOUBLE
11669: EQUAL
11670: IFTRUE 11674
11672: GO 11685
11674: POP
// tech := tech_mortar ; 3 :
11675: LD_ADDR_VAR 0 5
11679: PUSH
11680: LD_INT 41
11682: ST_TO_ADDR
11683: GO 11705
11685: LD_INT 3
11687: DOUBLE
11688: EQUAL
11689: IFTRUE 11693
11691: GO 11704
11693: POP
// tech := tech_bazooka ; end ;
11694: LD_ADDR_VAR 0 5
11698: PUSH
11699: LD_INT 44
11701: ST_TO_ADDR
11702: GO 11705
11704: POP
// if Researched ( side , tech ) then
11705: LD_VAR 0 3
11709: PPUSH
11710: LD_VAR 0 5
11714: PPUSH
11715: CALL_OW 325
11719: IFFALSE 11746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11721: LD_ADDR_VAR 0 2
11725: PUSH
11726: LD_INT 5
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: LD_INT 9
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: LIST
11739: PUSH
11740: LD_VAR 0 4
11744: ARRAY
11745: ST_TO_ADDR
// end ;
11746: LD_VAR 0 2
11750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11751: LD_INT 0
11753: PPUSH
11754: PPUSH
11755: PPUSH
// if not mines then
11756: LD_VAR 0 2
11760: NOT
11761: IFFALSE 11765
// exit ;
11763: GO 11909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 81
11772: PUSH
11773: LD_VAR 0 1
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_INT 3
11784: PUSH
11785: LD_INT 21
11787: PUSH
11788: LD_INT 3
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PPUSH
11803: CALL_OW 69
11807: ST_TO_ADDR
// for i in mines do
11808: LD_ADDR_VAR 0 4
11812: PUSH
11813: LD_VAR 0 2
11817: PUSH
11818: FOR_IN
11819: IFFALSE 11907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11821: LD_VAR 0 4
11825: PUSH
11826: LD_INT 1
11828: ARRAY
11829: PPUSH
11830: LD_VAR 0 4
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: CALL_OW 458
11843: NOT
11844: IFFALSE 11848
// continue ;
11846: GO 11818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11848: LD_VAR 0 4
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_VAR 0 4
11861: PUSH
11862: LD_INT 2
11864: ARRAY
11865: PPUSH
11866: CALL_OW 428
11870: PUSH
11871: LD_VAR 0 5
11875: IN
11876: IFFALSE 11905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11878: LD_VAR 0 4
11882: PUSH
11883: LD_INT 1
11885: ARRAY
11886: PPUSH
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 2
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 1
11900: PPUSH
11901: CALL_OW 456
// end ;
11905: GO 11818
11907: POP
11908: POP
// end ;
11909: LD_VAR 0 3
11913: RET
// export function Count ( array ) ; begin
11914: LD_INT 0
11916: PPUSH
// result := array + 0 ;
11917: LD_ADDR_VAR 0 2
11921: PUSH
11922: LD_VAR 0 1
11926: PUSH
11927: LD_INT 0
11929: PLUS
11930: ST_TO_ADDR
// end ;
11931: LD_VAR 0 2
11935: RET
// export function IsEmpty ( building ) ; begin
11936: LD_INT 0
11938: PPUSH
// if not building then
11939: LD_VAR 0 1
11943: NOT
11944: IFFALSE 11948
// exit ;
11946: GO 11991
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 1
11957: PUSH
11958: LD_INT 22
11960: PUSH
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 58
11977: PUSH
11978: EMPTY
11979: LIST
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PPUSH
11985: CALL_OW 69
11989: IN
11990: ST_TO_ADDR
// end ;
11991: LD_VAR 0 2
11995: RET
// export function IsNotFull ( building ) ; var places ; begin
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
// if not building then
12000: LD_VAR 0 1
12004: NOT
12005: IFFALSE 12009
// exit ;
12007: GO 12180
// result := false ;
12009: LD_ADDR_VAR 0 2
12013: PUSH
12014: LD_INT 0
12016: ST_TO_ADDR
// places := 0 ;
12017: LD_ADDR_VAR 0 3
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12025: LD_VAR 0 1
12029: PPUSH
12030: CALL_OW 266
12034: PUSH
12035: LD_INT 0
12037: DOUBLE
12038: EQUAL
12039: IFTRUE 12097
12041: LD_INT 1
12043: DOUBLE
12044: EQUAL
12045: IFTRUE 12097
12047: LD_INT 6
12049: DOUBLE
12050: EQUAL
12051: IFTRUE 12097
12053: LD_INT 7
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12097
12059: LD_INT 8
12061: DOUBLE
12062: EQUAL
12063: IFTRUE 12097
12065: LD_INT 4
12067: DOUBLE
12068: EQUAL
12069: IFTRUE 12097
12071: LD_INT 5
12073: DOUBLE
12074: EQUAL
12075: IFTRUE 12097
12077: LD_INT 2
12079: DOUBLE
12080: EQUAL
12081: IFTRUE 12097
12083: LD_INT 3
12085: DOUBLE
12086: EQUAL
12087: IFTRUE 12097
12089: LD_INT 35
12091: DOUBLE
12092: EQUAL
12093: IFTRUE 12097
12095: GO 12108
12097: POP
// places := 6 ; b_bunker , b_breastwork :
12098: LD_ADDR_VAR 0 3
12102: PUSH
12103: LD_INT 6
12105: ST_TO_ADDR
12106: GO 12153
12108: LD_INT 32
12110: DOUBLE
12111: EQUAL
12112: IFTRUE 12122
12114: LD_INT 31
12116: DOUBLE
12117: EQUAL
12118: IFTRUE 12122
12120: GO 12133
12122: POP
// places := 1 ; b_control_tower :
12123: LD_ADDR_VAR 0 3
12127: PUSH
12128: LD_INT 1
12130: ST_TO_ADDR
12131: GO 12153
12133: LD_INT 36
12135: DOUBLE
12136: EQUAL
12137: IFTRUE 12141
12139: GO 12152
12141: POP
// places := 3 ; end ;
12142: LD_ADDR_VAR 0 3
12146: PUSH
12147: LD_INT 3
12149: ST_TO_ADDR
12150: GO 12153
12152: POP
// if places then
12153: LD_VAR 0 3
12157: IFFALSE 12180
// result := UnitsInside ( building ) < places ;
12159: LD_ADDR_VAR 0 2
12163: PUSH
12164: LD_VAR 0 1
12168: PPUSH
12169: CALL_OW 313
12173: PUSH
12174: LD_VAR 0 3
12178: LESS
12179: ST_TO_ADDR
// end ;
12180: LD_VAR 0 2
12184: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12185: LD_INT 0
12187: PPUSH
12188: PPUSH
12189: PPUSH
12190: PPUSH
// tmp := [ ] ;
12191: LD_ADDR_VAR 0 3
12195: PUSH
12196: EMPTY
12197: ST_TO_ADDR
// list := [ ] ;
12198: LD_ADDR_VAR 0 5
12202: PUSH
12203: EMPTY
12204: ST_TO_ADDR
// for i = 16 to 25 do
12205: LD_ADDR_VAR 0 4
12209: PUSH
12210: DOUBLE
12211: LD_INT 16
12213: DEC
12214: ST_TO_ADDR
12215: LD_INT 25
12217: PUSH
12218: FOR_TO
12219: IFFALSE 12292
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12221: LD_ADDR_VAR 0 3
12225: PUSH
12226: LD_VAR 0 3
12230: PUSH
12231: LD_INT 22
12233: PUSH
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL_OW 255
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: PUSH
12248: LD_INT 91
12250: PUSH
12251: LD_VAR 0 1
12255: PUSH
12256: LD_INT 6
12258: PUSH
12259: EMPTY
12260: LIST
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 30
12266: PUSH
12267: LD_VAR 0 4
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: EMPTY
12277: LIST
12278: LIST
12279: LIST
12280: PUSH
12281: EMPTY
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ADD
12289: ST_TO_ADDR
12290: GO 12218
12292: POP
12293: POP
// for i = 1 to tmp do
12294: LD_ADDR_VAR 0 4
12298: PUSH
12299: DOUBLE
12300: LD_INT 1
12302: DEC
12303: ST_TO_ADDR
12304: LD_VAR 0 3
12308: PUSH
12309: FOR_TO
12310: IFFALSE 12398
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12312: LD_ADDR_VAR 0 5
12316: PUSH
12317: LD_VAR 0 5
12321: PUSH
12322: LD_VAR 0 3
12326: PUSH
12327: LD_VAR 0 4
12331: ARRAY
12332: PPUSH
12333: CALL_OW 266
12337: PUSH
12338: LD_VAR 0 3
12342: PUSH
12343: LD_VAR 0 4
12347: ARRAY
12348: PPUSH
12349: CALL_OW 250
12353: PUSH
12354: LD_VAR 0 3
12358: PUSH
12359: LD_VAR 0 4
12363: ARRAY
12364: PPUSH
12365: CALL_OW 251
12369: PUSH
12370: LD_VAR 0 3
12374: PUSH
12375: LD_VAR 0 4
12379: ARRAY
12380: PPUSH
12381: CALL_OW 254
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: ADD
12395: ST_TO_ADDR
12396: GO 12309
12398: POP
12399: POP
// result := list ;
12400: LD_ADDR_VAR 0 2
12404: PUSH
12405: LD_VAR 0 5
12409: ST_TO_ADDR
// end ;
12410: LD_VAR 0 2
12414: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12415: LD_INT 0
12417: PPUSH
12418: PPUSH
12419: PPUSH
12420: PPUSH
12421: PPUSH
12422: PPUSH
12423: PPUSH
// if not factory then
12424: LD_VAR 0 1
12428: NOT
12429: IFFALSE 12433
// exit ;
12431: GO 13026
// if control = control_apeman then
12433: LD_VAR 0 4
12437: PUSH
12438: LD_INT 5
12440: EQUAL
12441: IFFALSE 12550
// begin tmp := UnitsInside ( factory ) ;
12443: LD_ADDR_VAR 0 8
12447: PUSH
12448: LD_VAR 0 1
12452: PPUSH
12453: CALL_OW 313
12457: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12458: LD_VAR 0 8
12462: PPUSH
12463: LD_INT 25
12465: PUSH
12466: LD_INT 12
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PPUSH
12473: CALL_OW 72
12477: NOT
12478: IFFALSE 12488
// control := control_manual ;
12480: LD_ADDR_VAR 0 4
12484: PUSH
12485: LD_INT 1
12487: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12488: LD_ADDR_VAR 0 8
12492: PUSH
12493: LD_VAR 0 1
12497: PPUSH
12498: CALL 12185 0 1
12502: ST_TO_ADDR
// if tmp then
12503: LD_VAR 0 8
12507: IFFALSE 12550
// begin for i in tmp do
12509: LD_ADDR_VAR 0 7
12513: PUSH
12514: LD_VAR 0 8
12518: PUSH
12519: FOR_IN
12520: IFFALSE 12548
// if i [ 1 ] = b_ext_radio then
12522: LD_VAR 0 7
12526: PUSH
12527: LD_INT 1
12529: ARRAY
12530: PUSH
12531: LD_INT 22
12533: EQUAL
12534: IFFALSE 12546
// begin control := control_remote ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_INT 2
12543: ST_TO_ADDR
// break ;
12544: GO 12548
// end ;
12546: GO 12519
12548: POP
12549: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12550: LD_VAR 0 1
12554: PPUSH
12555: LD_VAR 0 2
12559: PPUSH
12560: LD_VAR 0 3
12564: PPUSH
12565: LD_VAR 0 4
12569: PPUSH
12570: LD_VAR 0 5
12574: PPUSH
12575: CALL_OW 448
12579: IFFALSE 12614
// begin result := [ chassis , engine , control , weapon ] ;
12581: LD_ADDR_VAR 0 6
12585: PUSH
12586: LD_VAR 0 2
12590: PUSH
12591: LD_VAR 0 3
12595: PUSH
12596: LD_VAR 0 4
12600: PUSH
12601: LD_VAR 0 5
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: ST_TO_ADDR
// exit ;
12612: GO 13026
// end ; _chassis := AvailableChassisList ( factory ) ;
12614: LD_ADDR_VAR 0 9
12618: PUSH
12619: LD_VAR 0 1
12623: PPUSH
12624: CALL_OW 475
12628: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12629: LD_ADDR_VAR 0 11
12633: PUSH
12634: LD_VAR 0 1
12638: PPUSH
12639: CALL_OW 476
12643: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12644: LD_ADDR_VAR 0 12
12648: PUSH
12649: LD_VAR 0 1
12653: PPUSH
12654: CALL_OW 477
12658: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12659: LD_ADDR_VAR 0 10
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 478
12673: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12674: LD_VAR 0 9
12678: NOT
12679: PUSH
12680: LD_VAR 0 11
12684: NOT
12685: OR
12686: PUSH
12687: LD_VAR 0 12
12691: NOT
12692: OR
12693: PUSH
12694: LD_VAR 0 10
12698: NOT
12699: OR
12700: IFFALSE 12735
// begin result := [ chassis , engine , control , weapon ] ;
12702: LD_ADDR_VAR 0 6
12706: PUSH
12707: LD_VAR 0 2
12711: PUSH
12712: LD_VAR 0 3
12716: PUSH
12717: LD_VAR 0 4
12721: PUSH
12722: LD_VAR 0 5
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: LIST
12731: LIST
12732: ST_TO_ADDR
// exit ;
12733: GO 13026
// end ; if not chassis in _chassis then
12735: LD_VAR 0 2
12739: PUSH
12740: LD_VAR 0 9
12744: IN
12745: NOT
12746: IFFALSE 12772
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12748: LD_ADDR_VAR 0 2
12752: PUSH
12753: LD_VAR 0 9
12757: PUSH
12758: LD_INT 1
12760: PPUSH
12761: LD_VAR 0 9
12765: PPUSH
12766: CALL_OW 12
12770: ARRAY
12771: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12772: LD_VAR 0 2
12776: PPUSH
12777: LD_VAR 0 3
12781: PPUSH
12782: CALL 13031 0 2
12786: NOT
12787: IFFALSE 12846
// repeat engine := _engine [ 1 ] ;
12789: LD_ADDR_VAR 0 3
12793: PUSH
12794: LD_VAR 0 11
12798: PUSH
12799: LD_INT 1
12801: ARRAY
12802: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12803: LD_ADDR_VAR 0 11
12807: PUSH
12808: LD_VAR 0 11
12812: PPUSH
12813: LD_INT 1
12815: PPUSH
12816: CALL_OW 3
12820: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12821: LD_VAR 0 2
12825: PPUSH
12826: LD_VAR 0 3
12830: PPUSH
12831: CALL 13031 0 2
12835: PUSH
12836: LD_VAR 0 11
12840: PUSH
12841: EMPTY
12842: EQUAL
12843: OR
12844: IFFALSE 12789
// if not control in _control then
12846: LD_VAR 0 4
12850: PUSH
12851: LD_VAR 0 12
12855: IN
12856: NOT
12857: IFFALSE 12883
// control := _control [ rand ( 1 , _control ) ] ;
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: LD_VAR 0 12
12868: PUSH
12869: LD_INT 1
12871: PPUSH
12872: LD_VAR 0 12
12876: PPUSH
12877: CALL_OW 12
12881: ARRAY
12882: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_VAR 0 5
12892: PPUSH
12893: CALL 13251 0 2
12897: NOT
12898: IFFALSE 12957
// repeat weapon := _weapon [ 1 ] ;
12900: LD_ADDR_VAR 0 5
12904: PUSH
12905: LD_VAR 0 10
12909: PUSH
12910: LD_INT 1
12912: ARRAY
12913: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12914: LD_ADDR_VAR 0 10
12918: PUSH
12919: LD_VAR 0 10
12923: PPUSH
12924: LD_INT 1
12926: PPUSH
12927: CALL_OW 3
12931: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12932: LD_VAR 0 2
12936: PPUSH
12937: LD_VAR 0 5
12941: PPUSH
12942: CALL 13251 0 2
12946: PUSH
12947: LD_VAR 0 10
12951: PUSH
12952: EMPTY
12953: EQUAL
12954: OR
12955: IFFALSE 12900
// result := [ ] ;
12957: LD_ADDR_VAR 0 6
12961: PUSH
12962: EMPTY
12963: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12964: LD_VAR 0 1
12968: PPUSH
12969: LD_VAR 0 2
12973: PPUSH
12974: LD_VAR 0 3
12978: PPUSH
12979: LD_VAR 0 4
12983: PPUSH
12984: LD_VAR 0 5
12988: PPUSH
12989: CALL_OW 448
12993: IFFALSE 13026
// result := [ chassis , engine , control , weapon ] ;
12995: LD_ADDR_VAR 0 6
12999: PUSH
13000: LD_VAR 0 2
13004: PUSH
13005: LD_VAR 0 3
13009: PUSH
13010: LD_VAR 0 4
13014: PUSH
13015: LD_VAR 0 5
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: ST_TO_ADDR
// end ;
13026: LD_VAR 0 6
13030: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13031: LD_INT 0
13033: PPUSH
// if not chassis or not engine then
13034: LD_VAR 0 1
13038: NOT
13039: PUSH
13040: LD_VAR 0 2
13044: NOT
13045: OR
13046: IFFALSE 13050
// exit ;
13048: GO 13246
// case engine of engine_solar :
13050: LD_VAR 0 2
13054: PUSH
13055: LD_INT 2
13057: DOUBLE
13058: EQUAL
13059: IFTRUE 13063
13061: GO 13101
13063: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13064: LD_ADDR_VAR 0 3
13068: PUSH
13069: LD_INT 11
13071: PUSH
13072: LD_INT 12
13074: PUSH
13075: LD_INT 13
13077: PUSH
13078: LD_INT 14
13080: PUSH
13081: LD_INT 1
13083: PUSH
13084: LD_INT 2
13086: PUSH
13087: LD_INT 3
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: ST_TO_ADDR
13099: GO 13230
13101: LD_INT 1
13103: DOUBLE
13104: EQUAL
13105: IFTRUE 13109
13107: GO 13171
13109: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13110: LD_ADDR_VAR 0 3
13114: PUSH
13115: LD_INT 11
13117: PUSH
13118: LD_INT 12
13120: PUSH
13121: LD_INT 13
13123: PUSH
13124: LD_INT 14
13126: PUSH
13127: LD_INT 1
13129: PUSH
13130: LD_INT 2
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 4
13138: PUSH
13139: LD_INT 5
13141: PUSH
13142: LD_INT 21
13144: PUSH
13145: LD_INT 23
13147: PUSH
13148: LD_INT 22
13150: PUSH
13151: LD_INT 24
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: ST_TO_ADDR
13169: GO 13230
13171: LD_INT 3
13173: DOUBLE
13174: EQUAL
13175: IFTRUE 13179
13177: GO 13229
13179: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13180: LD_ADDR_VAR 0 3
13184: PUSH
13185: LD_INT 13
13187: PUSH
13188: LD_INT 14
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 3
13196: PUSH
13197: LD_INT 4
13199: PUSH
13200: LD_INT 5
13202: PUSH
13203: LD_INT 21
13205: PUSH
13206: LD_INT 22
13208: PUSH
13209: LD_INT 23
13211: PUSH
13212: LD_INT 24
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: ST_TO_ADDR
13227: GO 13230
13229: POP
// result := ( chassis in result ) ;
13230: LD_ADDR_VAR 0 3
13234: PUSH
13235: LD_VAR 0 1
13239: PUSH
13240: LD_VAR 0 3
13244: IN
13245: ST_TO_ADDR
// end ;
13246: LD_VAR 0 3
13250: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13251: LD_INT 0
13253: PPUSH
// if not chassis or not weapon then
13254: LD_VAR 0 1
13258: NOT
13259: PUSH
13260: LD_VAR 0 2
13264: NOT
13265: OR
13266: IFFALSE 13270
// exit ;
13268: GO 14330
// case weapon of us_machine_gun :
13270: LD_VAR 0 2
13274: PUSH
13275: LD_INT 2
13277: DOUBLE
13278: EQUAL
13279: IFTRUE 13283
13281: GO 13313
13283: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13284: LD_ADDR_VAR 0 3
13288: PUSH
13289: LD_INT 1
13291: PUSH
13292: LD_INT 2
13294: PUSH
13295: LD_INT 3
13297: PUSH
13298: LD_INT 4
13300: PUSH
13301: LD_INT 5
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: LIST
13308: LIST
13309: LIST
13310: ST_TO_ADDR
13311: GO 14314
13313: LD_INT 3
13315: DOUBLE
13316: EQUAL
13317: IFTRUE 13321
13319: GO 13351
13321: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13322: LD_ADDR_VAR 0 3
13326: PUSH
13327: LD_INT 1
13329: PUSH
13330: LD_INT 2
13332: PUSH
13333: LD_INT 3
13335: PUSH
13336: LD_INT 4
13338: PUSH
13339: LD_INT 5
13341: PUSH
13342: EMPTY
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: ST_TO_ADDR
13349: GO 14314
13351: LD_INT 11
13353: DOUBLE
13354: EQUAL
13355: IFTRUE 13359
13357: GO 13389
13359: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13360: LD_ADDR_VAR 0 3
13364: PUSH
13365: LD_INT 1
13367: PUSH
13368: LD_INT 2
13370: PUSH
13371: LD_INT 3
13373: PUSH
13374: LD_INT 4
13376: PUSH
13377: LD_INT 5
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: ST_TO_ADDR
13387: GO 14314
13389: LD_INT 4
13391: DOUBLE
13392: EQUAL
13393: IFTRUE 13397
13395: GO 13423
13397: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13398: LD_ADDR_VAR 0 3
13402: PUSH
13403: LD_INT 2
13405: PUSH
13406: LD_INT 3
13408: PUSH
13409: LD_INT 4
13411: PUSH
13412: LD_INT 5
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: ST_TO_ADDR
13421: GO 14314
13423: LD_INT 5
13425: DOUBLE
13426: EQUAL
13427: IFTRUE 13431
13429: GO 13457
13431: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13432: LD_ADDR_VAR 0 3
13436: PUSH
13437: LD_INT 2
13439: PUSH
13440: LD_INT 3
13442: PUSH
13443: LD_INT 4
13445: PUSH
13446: LD_INT 5
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: ST_TO_ADDR
13455: GO 14314
13457: LD_INT 9
13459: DOUBLE
13460: EQUAL
13461: IFTRUE 13465
13463: GO 13491
13465: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13466: LD_ADDR_VAR 0 3
13470: PUSH
13471: LD_INT 2
13473: PUSH
13474: LD_INT 3
13476: PUSH
13477: LD_INT 4
13479: PUSH
13480: LD_INT 5
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: ST_TO_ADDR
13489: GO 14314
13491: LD_INT 7
13493: DOUBLE
13494: EQUAL
13495: IFTRUE 13499
13497: GO 13525
13499: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13500: LD_ADDR_VAR 0 3
13504: PUSH
13505: LD_INT 2
13507: PUSH
13508: LD_INT 3
13510: PUSH
13511: LD_INT 4
13513: PUSH
13514: LD_INT 5
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: ST_TO_ADDR
13523: GO 14314
13525: LD_INT 12
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13559
13533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13534: LD_ADDR_VAR 0 3
13538: PUSH
13539: LD_INT 2
13541: PUSH
13542: LD_INT 3
13544: PUSH
13545: LD_INT 4
13547: PUSH
13548: LD_INT 5
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: LIST
13555: LIST
13556: ST_TO_ADDR
13557: GO 14314
13559: LD_INT 13
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13593
13567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13568: LD_ADDR_VAR 0 3
13572: PUSH
13573: LD_INT 2
13575: PUSH
13576: LD_INT 3
13578: PUSH
13579: LD_INT 4
13581: PUSH
13582: LD_INT 5
13584: PUSH
13585: EMPTY
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: ST_TO_ADDR
13591: GO 14314
13593: LD_INT 14
13595: DOUBLE
13596: EQUAL
13597: IFTRUE 13601
13599: GO 13619
13601: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13602: LD_ADDR_VAR 0 3
13606: PUSH
13607: LD_INT 4
13609: PUSH
13610: LD_INT 5
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: ST_TO_ADDR
13617: GO 14314
13619: LD_INT 6
13621: DOUBLE
13622: EQUAL
13623: IFTRUE 13627
13625: GO 13645
13627: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13628: LD_ADDR_VAR 0 3
13632: PUSH
13633: LD_INT 4
13635: PUSH
13636: LD_INT 5
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: ST_TO_ADDR
13643: GO 14314
13645: LD_INT 10
13647: DOUBLE
13648: EQUAL
13649: IFTRUE 13653
13651: GO 13671
13653: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13654: LD_ADDR_VAR 0 3
13658: PUSH
13659: LD_INT 4
13661: PUSH
13662: LD_INT 5
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: ST_TO_ADDR
13669: GO 14314
13671: LD_INT 22
13673: DOUBLE
13674: EQUAL
13675: IFTRUE 13679
13677: GO 13705
13679: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13680: LD_ADDR_VAR 0 3
13684: PUSH
13685: LD_INT 11
13687: PUSH
13688: LD_INT 12
13690: PUSH
13691: LD_INT 13
13693: PUSH
13694: LD_INT 14
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: ST_TO_ADDR
13703: GO 14314
13705: LD_INT 23
13707: DOUBLE
13708: EQUAL
13709: IFTRUE 13713
13711: GO 13739
13713: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13714: LD_ADDR_VAR 0 3
13718: PUSH
13719: LD_INT 11
13721: PUSH
13722: LD_INT 12
13724: PUSH
13725: LD_INT 13
13727: PUSH
13728: LD_INT 14
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: ST_TO_ADDR
13737: GO 14314
13739: LD_INT 24
13741: DOUBLE
13742: EQUAL
13743: IFTRUE 13747
13745: GO 13773
13747: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13748: LD_ADDR_VAR 0 3
13752: PUSH
13753: LD_INT 11
13755: PUSH
13756: LD_INT 12
13758: PUSH
13759: LD_INT 13
13761: PUSH
13762: LD_INT 14
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14314
13773: LD_INT 30
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13807
13781: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13782: LD_ADDR_VAR 0 3
13786: PUSH
13787: LD_INT 11
13789: PUSH
13790: LD_INT 12
13792: PUSH
13793: LD_INT 13
13795: PUSH
13796: LD_INT 14
13798: PUSH
13799: EMPTY
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: ST_TO_ADDR
13805: GO 14314
13807: LD_INT 25
13809: DOUBLE
13810: EQUAL
13811: IFTRUE 13815
13813: GO 13833
13815: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13816: LD_ADDR_VAR 0 3
13820: PUSH
13821: LD_INT 13
13823: PUSH
13824: LD_INT 14
13826: PUSH
13827: EMPTY
13828: LIST
13829: LIST
13830: ST_TO_ADDR
13831: GO 14314
13833: LD_INT 27
13835: DOUBLE
13836: EQUAL
13837: IFTRUE 13841
13839: GO 13859
13841: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13842: LD_ADDR_VAR 0 3
13846: PUSH
13847: LD_INT 13
13849: PUSH
13850: LD_INT 14
13852: PUSH
13853: EMPTY
13854: LIST
13855: LIST
13856: ST_TO_ADDR
13857: GO 14314
13859: LD_INT 92
13861: DOUBLE
13862: EQUAL
13863: IFTRUE 13867
13865: GO 13893
13867: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13868: LD_ADDR_VAR 0 3
13872: PUSH
13873: LD_INT 11
13875: PUSH
13876: LD_INT 12
13878: PUSH
13879: LD_INT 13
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: ST_TO_ADDR
13891: GO 14314
13893: LD_INT 28
13895: DOUBLE
13896: EQUAL
13897: IFTRUE 13901
13899: GO 13919
13901: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13902: LD_ADDR_VAR 0 3
13906: PUSH
13907: LD_INT 13
13909: PUSH
13910: LD_INT 14
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: ST_TO_ADDR
13917: GO 14314
13919: LD_INT 29
13921: DOUBLE
13922: EQUAL
13923: IFTRUE 13927
13925: GO 13945
13927: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13928: LD_ADDR_VAR 0 3
13932: PUSH
13933: LD_INT 13
13935: PUSH
13936: LD_INT 14
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14314
13945: LD_INT 31
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 13971
13953: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13954: LD_ADDR_VAR 0 3
13958: PUSH
13959: LD_INT 13
13961: PUSH
13962: LD_INT 14
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: ST_TO_ADDR
13969: GO 14314
13971: LD_INT 26
13973: DOUBLE
13974: EQUAL
13975: IFTRUE 13979
13977: GO 13997
13979: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13980: LD_ADDR_VAR 0 3
13984: PUSH
13985: LD_INT 13
13987: PUSH
13988: LD_INT 14
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: ST_TO_ADDR
13995: GO 14314
13997: LD_INT 42
13999: DOUBLE
14000: EQUAL
14001: IFTRUE 14005
14003: GO 14031
14005: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14006: LD_ADDR_VAR 0 3
14010: PUSH
14011: LD_INT 21
14013: PUSH
14014: LD_INT 22
14016: PUSH
14017: LD_INT 23
14019: PUSH
14020: LD_INT 24
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: ST_TO_ADDR
14029: GO 14314
14031: LD_INT 43
14033: DOUBLE
14034: EQUAL
14035: IFTRUE 14039
14037: GO 14065
14039: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14040: LD_ADDR_VAR 0 3
14044: PUSH
14045: LD_INT 21
14047: PUSH
14048: LD_INT 22
14050: PUSH
14051: LD_INT 23
14053: PUSH
14054: LD_INT 24
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: LIST
14061: LIST
14062: ST_TO_ADDR
14063: GO 14314
14065: LD_INT 44
14067: DOUBLE
14068: EQUAL
14069: IFTRUE 14073
14071: GO 14099
14073: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14074: LD_ADDR_VAR 0 3
14078: PUSH
14079: LD_INT 21
14081: PUSH
14082: LD_INT 22
14084: PUSH
14085: LD_INT 23
14087: PUSH
14088: LD_INT 24
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: ST_TO_ADDR
14097: GO 14314
14099: LD_INT 45
14101: DOUBLE
14102: EQUAL
14103: IFTRUE 14107
14105: GO 14133
14107: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14108: LD_ADDR_VAR 0 3
14112: PUSH
14113: LD_INT 21
14115: PUSH
14116: LD_INT 22
14118: PUSH
14119: LD_INT 23
14121: PUSH
14122: LD_INT 24
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: ST_TO_ADDR
14131: GO 14314
14133: LD_INT 49
14135: DOUBLE
14136: EQUAL
14137: IFTRUE 14141
14139: GO 14167
14141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14142: LD_ADDR_VAR 0 3
14146: PUSH
14147: LD_INT 21
14149: PUSH
14150: LD_INT 22
14152: PUSH
14153: LD_INT 23
14155: PUSH
14156: LD_INT 24
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: ST_TO_ADDR
14165: GO 14314
14167: LD_INT 51
14169: DOUBLE
14170: EQUAL
14171: IFTRUE 14175
14173: GO 14201
14175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14176: LD_ADDR_VAR 0 3
14180: PUSH
14181: LD_INT 21
14183: PUSH
14184: LD_INT 22
14186: PUSH
14187: LD_INT 23
14189: PUSH
14190: LD_INT 24
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: ST_TO_ADDR
14199: GO 14314
14201: LD_INT 52
14203: DOUBLE
14204: EQUAL
14205: IFTRUE 14209
14207: GO 14235
14209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14210: LD_ADDR_VAR 0 3
14214: PUSH
14215: LD_INT 21
14217: PUSH
14218: LD_INT 22
14220: PUSH
14221: LD_INT 23
14223: PUSH
14224: LD_INT 24
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: ST_TO_ADDR
14233: GO 14314
14235: LD_INT 53
14237: DOUBLE
14238: EQUAL
14239: IFTRUE 14243
14241: GO 14261
14243: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: LD_INT 23
14251: PUSH
14252: LD_INT 24
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: ST_TO_ADDR
14259: GO 14314
14261: LD_INT 46
14263: DOUBLE
14264: EQUAL
14265: IFTRUE 14269
14267: GO 14287
14269: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14270: LD_ADDR_VAR 0 3
14274: PUSH
14275: LD_INT 23
14277: PUSH
14278: LD_INT 24
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: ST_TO_ADDR
14285: GO 14314
14287: LD_INT 47
14289: DOUBLE
14290: EQUAL
14291: IFTRUE 14295
14293: GO 14313
14295: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14296: LD_ADDR_VAR 0 3
14300: PUSH
14301: LD_INT 23
14303: PUSH
14304: LD_INT 24
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: ST_TO_ADDR
14311: GO 14314
14313: POP
// result := ( chassis in result ) ;
14314: LD_ADDR_VAR 0 3
14318: PUSH
14319: LD_VAR 0 1
14323: PUSH
14324: LD_VAR 0 3
14328: IN
14329: ST_TO_ADDR
// end ;
14330: LD_VAR 0 3
14334: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14335: LD_INT 0
14337: PPUSH
14338: PPUSH
14339: PPUSH
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
// result := array ;
14344: LD_ADDR_VAR 0 5
14348: PUSH
14349: LD_VAR 0 1
14353: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14354: LD_VAR 0 1
14358: NOT
14359: PUSH
14360: LD_VAR 0 2
14364: NOT
14365: OR
14366: PUSH
14367: LD_VAR 0 3
14371: NOT
14372: OR
14373: PUSH
14374: LD_VAR 0 2
14378: PUSH
14379: LD_VAR 0 1
14383: GREATER
14384: OR
14385: PUSH
14386: LD_VAR 0 3
14390: PUSH
14391: LD_VAR 0 1
14395: GREATER
14396: OR
14397: IFFALSE 14401
// exit ;
14399: GO 14697
// if direction then
14401: LD_VAR 0 4
14405: IFFALSE 14469
// begin d := 1 ;
14407: LD_ADDR_VAR 0 9
14411: PUSH
14412: LD_INT 1
14414: ST_TO_ADDR
// if i_from > i_to then
14415: LD_VAR 0 2
14419: PUSH
14420: LD_VAR 0 3
14424: GREATER
14425: IFFALSE 14451
// length := ( array - i_from ) + i_to else
14427: LD_ADDR_VAR 0 11
14431: PUSH
14432: LD_VAR 0 1
14436: PUSH
14437: LD_VAR 0 2
14441: MINUS
14442: PUSH
14443: LD_VAR 0 3
14447: PLUS
14448: ST_TO_ADDR
14449: GO 14467
// length := i_to - i_from ;
14451: LD_ADDR_VAR 0 11
14455: PUSH
14456: LD_VAR 0 3
14460: PUSH
14461: LD_VAR 0 2
14465: MINUS
14466: ST_TO_ADDR
// end else
14467: GO 14530
// begin d := - 1 ;
14469: LD_ADDR_VAR 0 9
14473: PUSH
14474: LD_INT 1
14476: NEG
14477: ST_TO_ADDR
// if i_from > i_to then
14478: LD_VAR 0 2
14482: PUSH
14483: LD_VAR 0 3
14487: GREATER
14488: IFFALSE 14508
// length := i_from - i_to else
14490: LD_ADDR_VAR 0 11
14494: PUSH
14495: LD_VAR 0 2
14499: PUSH
14500: LD_VAR 0 3
14504: MINUS
14505: ST_TO_ADDR
14506: GO 14530
// length := ( array - i_to ) + i_from ;
14508: LD_ADDR_VAR 0 11
14512: PUSH
14513: LD_VAR 0 1
14517: PUSH
14518: LD_VAR 0 3
14522: MINUS
14523: PUSH
14524: LD_VAR 0 2
14528: PLUS
14529: ST_TO_ADDR
// end ; if not length then
14530: LD_VAR 0 11
14534: NOT
14535: IFFALSE 14539
// exit ;
14537: GO 14697
// tmp := array ;
14539: LD_ADDR_VAR 0 10
14543: PUSH
14544: LD_VAR 0 1
14548: ST_TO_ADDR
// for i = 1 to length do
14549: LD_ADDR_VAR 0 6
14553: PUSH
14554: DOUBLE
14555: LD_INT 1
14557: DEC
14558: ST_TO_ADDR
14559: LD_VAR 0 11
14563: PUSH
14564: FOR_TO
14565: IFFALSE 14685
// begin for j = 1 to array do
14567: LD_ADDR_VAR 0 7
14571: PUSH
14572: DOUBLE
14573: LD_INT 1
14575: DEC
14576: ST_TO_ADDR
14577: LD_VAR 0 1
14581: PUSH
14582: FOR_TO
14583: IFFALSE 14671
// begin k := j + d ;
14585: LD_ADDR_VAR 0 8
14589: PUSH
14590: LD_VAR 0 7
14594: PUSH
14595: LD_VAR 0 9
14599: PLUS
14600: ST_TO_ADDR
// if k > array then
14601: LD_VAR 0 8
14605: PUSH
14606: LD_VAR 0 1
14610: GREATER
14611: IFFALSE 14621
// k := 1 ;
14613: LD_ADDR_VAR 0 8
14617: PUSH
14618: LD_INT 1
14620: ST_TO_ADDR
// if not k then
14621: LD_VAR 0 8
14625: NOT
14626: IFFALSE 14638
// k := array ;
14628: LD_ADDR_VAR 0 8
14632: PUSH
14633: LD_VAR 0 1
14637: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14638: LD_ADDR_VAR 0 10
14642: PUSH
14643: LD_VAR 0 10
14647: PPUSH
14648: LD_VAR 0 8
14652: PPUSH
14653: LD_VAR 0 1
14657: PUSH
14658: LD_VAR 0 7
14662: ARRAY
14663: PPUSH
14664: CALL_OW 1
14668: ST_TO_ADDR
// end ;
14669: GO 14582
14671: POP
14672: POP
// array := tmp ;
14673: LD_ADDR_VAR 0 1
14677: PUSH
14678: LD_VAR 0 10
14682: ST_TO_ADDR
// end ;
14683: GO 14564
14685: POP
14686: POP
// result := array ;
14687: LD_ADDR_VAR 0 5
14691: PUSH
14692: LD_VAR 0 1
14696: ST_TO_ADDR
// end ;
14697: LD_VAR 0 5
14701: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14702: LD_INT 0
14704: PPUSH
14705: PPUSH
// result := 0 ;
14706: LD_ADDR_VAR 0 3
14710: PUSH
14711: LD_INT 0
14713: ST_TO_ADDR
// if not array or not value in array then
14714: LD_VAR 0 1
14718: NOT
14719: PUSH
14720: LD_VAR 0 2
14724: PUSH
14725: LD_VAR 0 1
14729: IN
14730: NOT
14731: OR
14732: IFFALSE 14736
// exit ;
14734: GO 14790
// for i = 1 to array do
14736: LD_ADDR_VAR 0 4
14740: PUSH
14741: DOUBLE
14742: LD_INT 1
14744: DEC
14745: ST_TO_ADDR
14746: LD_VAR 0 1
14750: PUSH
14751: FOR_TO
14752: IFFALSE 14788
// if value = array [ i ] then
14754: LD_VAR 0 2
14758: PUSH
14759: LD_VAR 0 1
14763: PUSH
14764: LD_VAR 0 4
14768: ARRAY
14769: EQUAL
14770: IFFALSE 14786
// begin result := i ;
14772: LD_ADDR_VAR 0 3
14776: PUSH
14777: LD_VAR 0 4
14781: ST_TO_ADDR
// exit ;
14782: POP
14783: POP
14784: GO 14790
// end ;
14786: GO 14751
14788: POP
14789: POP
// end ;
14790: LD_VAR 0 3
14794: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14795: LD_INT 0
14797: PPUSH
// vc_chassis := chassis ;
14798: LD_ADDR_OWVAR 37
14802: PUSH
14803: LD_VAR 0 1
14807: ST_TO_ADDR
// vc_engine := engine ;
14808: LD_ADDR_OWVAR 39
14812: PUSH
14813: LD_VAR 0 2
14817: ST_TO_ADDR
// vc_control := control ;
14818: LD_ADDR_OWVAR 38
14822: PUSH
14823: LD_VAR 0 3
14827: ST_TO_ADDR
// vc_weapon := weapon ;
14828: LD_ADDR_OWVAR 40
14832: PUSH
14833: LD_VAR 0 4
14837: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14838: LD_ADDR_OWVAR 41
14842: PUSH
14843: LD_VAR 0 5
14847: ST_TO_ADDR
// end ;
14848: LD_VAR 0 6
14852: RET
// export function WantPlant ( unit ) ; var task ; begin
14853: LD_INT 0
14855: PPUSH
14856: PPUSH
// result := false ;
14857: LD_ADDR_VAR 0 2
14861: PUSH
14862: LD_INT 0
14864: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14865: LD_ADDR_VAR 0 3
14869: PUSH
14870: LD_VAR 0 1
14874: PPUSH
14875: CALL_OW 437
14879: ST_TO_ADDR
// if task then
14880: LD_VAR 0 3
14884: IFFALSE 14912
// if task [ 1 ] [ 1 ] = p then
14886: LD_VAR 0 3
14890: PUSH
14891: LD_INT 1
14893: ARRAY
14894: PUSH
14895: LD_INT 1
14897: ARRAY
14898: PUSH
14899: LD_STRING p
14901: EQUAL
14902: IFFALSE 14912
// result := true ;
14904: LD_ADDR_VAR 0 2
14908: PUSH
14909: LD_INT 1
14911: ST_TO_ADDR
// end ;
14912: LD_VAR 0 2
14916: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14917: LD_INT 0
14919: PPUSH
14920: PPUSH
14921: PPUSH
14922: PPUSH
// if pos < 1 then
14923: LD_VAR 0 2
14927: PUSH
14928: LD_INT 1
14930: LESS
14931: IFFALSE 14935
// exit ;
14933: GO 15238
// if pos = 1 then
14935: LD_VAR 0 2
14939: PUSH
14940: LD_INT 1
14942: EQUAL
14943: IFFALSE 14976
// result := Replace ( arr , pos [ 1 ] , value ) else
14945: LD_ADDR_VAR 0 4
14949: PUSH
14950: LD_VAR 0 1
14954: PPUSH
14955: LD_VAR 0 2
14959: PUSH
14960: LD_INT 1
14962: ARRAY
14963: PPUSH
14964: LD_VAR 0 3
14968: PPUSH
14969: CALL_OW 1
14973: ST_TO_ADDR
14974: GO 15238
// begin tmp := arr ;
14976: LD_ADDR_VAR 0 6
14980: PUSH
14981: LD_VAR 0 1
14985: ST_TO_ADDR
// s_arr := [ tmp ] ;
14986: LD_ADDR_VAR 0 7
14990: PUSH
14991: LD_VAR 0 6
14995: PUSH
14996: EMPTY
14997: LIST
14998: ST_TO_ADDR
// for i = 1 to pos - 1 do
14999: LD_ADDR_VAR 0 5
15003: PUSH
15004: DOUBLE
15005: LD_INT 1
15007: DEC
15008: ST_TO_ADDR
15009: LD_VAR 0 2
15013: PUSH
15014: LD_INT 1
15016: MINUS
15017: PUSH
15018: FOR_TO
15019: IFFALSE 15064
// begin tmp := tmp [ pos [ i ] ] ;
15021: LD_ADDR_VAR 0 6
15025: PUSH
15026: LD_VAR 0 6
15030: PUSH
15031: LD_VAR 0 2
15035: PUSH
15036: LD_VAR 0 5
15040: ARRAY
15041: ARRAY
15042: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15043: LD_ADDR_VAR 0 7
15047: PUSH
15048: LD_VAR 0 7
15052: PUSH
15053: LD_VAR 0 6
15057: PUSH
15058: EMPTY
15059: LIST
15060: ADD
15061: ST_TO_ADDR
// end ;
15062: GO 15018
15064: POP
15065: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15066: LD_ADDR_VAR 0 6
15070: PUSH
15071: LD_VAR 0 6
15075: PPUSH
15076: LD_VAR 0 2
15080: PUSH
15081: LD_VAR 0 2
15085: ARRAY
15086: PPUSH
15087: LD_VAR 0 3
15091: PPUSH
15092: CALL_OW 1
15096: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15097: LD_ADDR_VAR 0 7
15101: PUSH
15102: LD_VAR 0 7
15106: PPUSH
15107: LD_VAR 0 7
15111: PPUSH
15112: LD_VAR 0 6
15116: PPUSH
15117: CALL_OW 1
15121: ST_TO_ADDR
// for i = s_arr downto 2 do
15122: LD_ADDR_VAR 0 5
15126: PUSH
15127: DOUBLE
15128: LD_VAR 0 7
15132: INC
15133: ST_TO_ADDR
15134: LD_INT 2
15136: PUSH
15137: FOR_DOWNTO
15138: IFFALSE 15222
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15140: LD_ADDR_VAR 0 6
15144: PUSH
15145: LD_VAR 0 7
15149: PUSH
15150: LD_VAR 0 5
15154: PUSH
15155: LD_INT 1
15157: MINUS
15158: ARRAY
15159: PPUSH
15160: LD_VAR 0 2
15164: PUSH
15165: LD_VAR 0 5
15169: PUSH
15170: LD_INT 1
15172: MINUS
15173: ARRAY
15174: PPUSH
15175: LD_VAR 0 7
15179: PUSH
15180: LD_VAR 0 5
15184: ARRAY
15185: PPUSH
15186: CALL_OW 1
15190: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15191: LD_ADDR_VAR 0 7
15195: PUSH
15196: LD_VAR 0 7
15200: PPUSH
15201: LD_VAR 0 5
15205: PUSH
15206: LD_INT 1
15208: MINUS
15209: PPUSH
15210: LD_VAR 0 6
15214: PPUSH
15215: CALL_OW 1
15219: ST_TO_ADDR
// end ;
15220: GO 15137
15222: POP
15223: POP
// result := s_arr [ 1 ] ;
15224: LD_ADDR_VAR 0 4
15228: PUSH
15229: LD_VAR 0 7
15233: PUSH
15234: LD_INT 1
15236: ARRAY
15237: ST_TO_ADDR
// end ; end ;
15238: LD_VAR 0 4
15242: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15243: LD_INT 0
15245: PPUSH
15246: PPUSH
// if not list then
15247: LD_VAR 0 1
15251: NOT
15252: IFFALSE 15256
// exit ;
15254: GO 15347
// i := list [ pos1 ] ;
15256: LD_ADDR_VAR 0 5
15260: PUSH
15261: LD_VAR 0 1
15265: PUSH
15266: LD_VAR 0 2
15270: ARRAY
15271: ST_TO_ADDR
// if not i then
15272: LD_VAR 0 5
15276: NOT
15277: IFFALSE 15281
// exit ;
15279: GO 15347
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15281: LD_ADDR_VAR 0 1
15285: PUSH
15286: LD_VAR 0 1
15290: PPUSH
15291: LD_VAR 0 2
15295: PPUSH
15296: LD_VAR 0 1
15300: PUSH
15301: LD_VAR 0 3
15305: ARRAY
15306: PPUSH
15307: CALL_OW 1
15311: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15312: LD_ADDR_VAR 0 1
15316: PUSH
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 3
15326: PPUSH
15327: LD_VAR 0 5
15331: PPUSH
15332: CALL_OW 1
15336: ST_TO_ADDR
// result := list ;
15337: LD_ADDR_VAR 0 4
15341: PUSH
15342: LD_VAR 0 1
15346: ST_TO_ADDR
// end ;
15347: LD_VAR 0 4
15351: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15352: LD_INT 0
15354: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15355: LD_ADDR_VAR 0 5
15359: PUSH
15360: LD_VAR 0 1
15364: PPUSH
15365: CALL_OW 250
15369: PPUSH
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 251
15379: PPUSH
15380: LD_VAR 0 2
15384: PPUSH
15385: LD_VAR 0 3
15389: PPUSH
15390: LD_VAR 0 4
15394: PPUSH
15395: CALL 15405 0 5
15399: ST_TO_ADDR
// end ;
15400: LD_VAR 0 5
15404: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15405: LD_INT 0
15407: PPUSH
15408: PPUSH
15409: PPUSH
15410: PPUSH
// if not list then
15411: LD_VAR 0 3
15415: NOT
15416: IFFALSE 15420
// exit ;
15418: GO 15808
// result := [ ] ;
15420: LD_ADDR_VAR 0 6
15424: PUSH
15425: EMPTY
15426: ST_TO_ADDR
// for i in list do
15427: LD_ADDR_VAR 0 7
15431: PUSH
15432: LD_VAR 0 3
15436: PUSH
15437: FOR_IN
15438: IFFALSE 15640
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15440: LD_ADDR_VAR 0 9
15444: PUSH
15445: LD_VAR 0 7
15449: PPUSH
15450: LD_VAR 0 1
15454: PPUSH
15455: LD_VAR 0 2
15459: PPUSH
15460: CALL_OW 297
15464: ST_TO_ADDR
// if not result then
15465: LD_VAR 0 6
15469: NOT
15470: IFFALSE 15496
// result := [ [ i , tmp ] ] else
15472: LD_ADDR_VAR 0 6
15476: PUSH
15477: LD_VAR 0 7
15481: PUSH
15482: LD_VAR 0 9
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: ST_TO_ADDR
15494: GO 15638
// begin if result [ result ] [ 2 ] < tmp then
15496: LD_VAR 0 6
15500: PUSH
15501: LD_VAR 0 6
15505: ARRAY
15506: PUSH
15507: LD_INT 2
15509: ARRAY
15510: PUSH
15511: LD_VAR 0 9
15515: LESS
15516: IFFALSE 15558
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15518: LD_ADDR_VAR 0 6
15522: PUSH
15523: LD_VAR 0 6
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_INT 1
15535: PLUS
15536: PPUSH
15537: LD_VAR 0 7
15541: PUSH
15542: LD_VAR 0 9
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PPUSH
15551: CALL_OW 2
15555: ST_TO_ADDR
15556: GO 15638
// for j = 1 to result do
15558: LD_ADDR_VAR 0 8
15562: PUSH
15563: DOUBLE
15564: LD_INT 1
15566: DEC
15567: ST_TO_ADDR
15568: LD_VAR 0 6
15572: PUSH
15573: FOR_TO
15574: IFFALSE 15636
// begin if tmp < result [ j ] [ 2 ] then
15576: LD_VAR 0 9
15580: PUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 8
15590: ARRAY
15591: PUSH
15592: LD_INT 2
15594: ARRAY
15595: LESS
15596: IFFALSE 15634
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15598: LD_ADDR_VAR 0 6
15602: PUSH
15603: LD_VAR 0 6
15607: PPUSH
15608: LD_VAR 0 8
15612: PPUSH
15613: LD_VAR 0 7
15617: PUSH
15618: LD_VAR 0 9
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PPUSH
15627: CALL_OW 2
15631: ST_TO_ADDR
// break ;
15632: GO 15636
// end ; end ;
15634: GO 15573
15636: POP
15637: POP
// end ; end ;
15638: GO 15437
15640: POP
15641: POP
// if result and not asc then
15642: LD_VAR 0 6
15646: PUSH
15647: LD_VAR 0 4
15651: NOT
15652: AND
15653: IFFALSE 15728
// begin tmp := result ;
15655: LD_ADDR_VAR 0 9
15659: PUSH
15660: LD_VAR 0 6
15664: ST_TO_ADDR
// for i = tmp downto 1 do
15665: LD_ADDR_VAR 0 7
15669: PUSH
15670: DOUBLE
15671: LD_VAR 0 9
15675: INC
15676: ST_TO_ADDR
15677: LD_INT 1
15679: PUSH
15680: FOR_DOWNTO
15681: IFFALSE 15726
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15683: LD_ADDR_VAR 0 6
15687: PUSH
15688: LD_VAR 0 6
15692: PPUSH
15693: LD_VAR 0 9
15697: PUSH
15698: LD_VAR 0 7
15702: MINUS
15703: PUSH
15704: LD_INT 1
15706: PLUS
15707: PPUSH
15708: LD_VAR 0 9
15712: PUSH
15713: LD_VAR 0 7
15717: ARRAY
15718: PPUSH
15719: CALL_OW 1
15723: ST_TO_ADDR
15724: GO 15680
15726: POP
15727: POP
// end ; tmp := [ ] ;
15728: LD_ADDR_VAR 0 9
15732: PUSH
15733: EMPTY
15734: ST_TO_ADDR
// if mode then
15735: LD_VAR 0 5
15739: IFFALSE 15808
// begin for i = 1 to result do
15741: LD_ADDR_VAR 0 7
15745: PUSH
15746: DOUBLE
15747: LD_INT 1
15749: DEC
15750: ST_TO_ADDR
15751: LD_VAR 0 6
15755: PUSH
15756: FOR_TO
15757: IFFALSE 15796
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15759: LD_ADDR_VAR 0 9
15763: PUSH
15764: LD_VAR 0 9
15768: PPUSH
15769: LD_VAR 0 7
15773: PPUSH
15774: LD_VAR 0 6
15778: PUSH
15779: LD_VAR 0 7
15783: ARRAY
15784: PUSH
15785: LD_INT 1
15787: ARRAY
15788: PPUSH
15789: CALL_OW 1
15793: ST_TO_ADDR
15794: GO 15756
15796: POP
15797: POP
// result := tmp ;
15798: LD_ADDR_VAR 0 6
15802: PUSH
15803: LD_VAR 0 9
15807: ST_TO_ADDR
// end ; end ;
15808: LD_VAR 0 6
15812: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15813: LD_INT 0
15815: PPUSH
15816: PPUSH
15817: PPUSH
15818: PPUSH
15819: PPUSH
15820: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15821: LD_ADDR_VAR 0 5
15825: PUSH
15826: LD_INT 0
15828: PUSH
15829: LD_INT 0
15831: PUSH
15832: LD_INT 0
15834: PUSH
15835: EMPTY
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: ST_TO_ADDR
// if not x or not y then
15843: LD_VAR 0 2
15847: NOT
15848: PUSH
15849: LD_VAR 0 3
15853: NOT
15854: OR
15855: IFFALSE 15859
// exit ;
15857: GO 17509
// if not range then
15859: LD_VAR 0 4
15863: NOT
15864: IFFALSE 15874
// range := 10 ;
15866: LD_ADDR_VAR 0 4
15870: PUSH
15871: LD_INT 10
15873: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15874: LD_ADDR_VAR 0 8
15878: PUSH
15879: LD_INT 81
15881: PUSH
15882: LD_VAR 0 1
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 92
15893: PUSH
15894: LD_VAR 0 2
15898: PUSH
15899: LD_VAR 0 3
15903: PUSH
15904: LD_VAR 0 4
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: LIST
15913: LIST
15914: PUSH
15915: LD_INT 3
15917: PUSH
15918: LD_INT 21
15920: PUSH
15921: LD_INT 3
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: LIST
15936: PPUSH
15937: CALL_OW 69
15941: ST_TO_ADDR
// if not tmp then
15942: LD_VAR 0 8
15946: NOT
15947: IFFALSE 15951
// exit ;
15949: GO 17509
// for i in tmp do
15951: LD_ADDR_VAR 0 6
15955: PUSH
15956: LD_VAR 0 8
15960: PUSH
15961: FOR_IN
15962: IFFALSE 17484
// begin points := [ 0 , 0 , 0 ] ;
15964: LD_ADDR_VAR 0 9
15968: PUSH
15969: LD_INT 0
15971: PUSH
15972: LD_INT 0
15974: PUSH
15975: LD_INT 0
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: LIST
15982: ST_TO_ADDR
// bpoints := 1 ;
15983: LD_ADDR_VAR 0 10
15987: PUSH
15988: LD_INT 1
15990: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15991: LD_VAR 0 6
15995: PPUSH
15996: CALL_OW 247
16000: PUSH
16001: LD_INT 1
16003: DOUBLE
16004: EQUAL
16005: IFTRUE 16009
16007: GO 16587
16009: POP
// begin if GetClass ( i ) = 1 then
16010: LD_VAR 0 6
16014: PPUSH
16015: CALL_OW 257
16019: PUSH
16020: LD_INT 1
16022: EQUAL
16023: IFFALSE 16044
// points := [ 10 , 5 , 3 ] ;
16025: LD_ADDR_VAR 0 9
16029: PUSH
16030: LD_INT 10
16032: PUSH
16033: LD_INT 5
16035: PUSH
16036: LD_INT 3
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: LIST
16043: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16044: LD_VAR 0 6
16048: PPUSH
16049: CALL_OW 257
16053: PUSH
16054: LD_INT 2
16056: PUSH
16057: LD_INT 3
16059: PUSH
16060: LD_INT 4
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: LIST
16067: IN
16068: IFFALSE 16089
// points := [ 3 , 2 , 1 ] ;
16070: LD_ADDR_VAR 0 9
16074: PUSH
16075: LD_INT 3
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: LD_INT 1
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: LIST
16088: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16089: LD_VAR 0 6
16093: PPUSH
16094: CALL_OW 257
16098: PUSH
16099: LD_INT 5
16101: EQUAL
16102: IFFALSE 16123
// points := [ 130 , 5 , 2 ] ;
16104: LD_ADDR_VAR 0 9
16108: PUSH
16109: LD_INT 130
16111: PUSH
16112: LD_INT 5
16114: PUSH
16115: LD_INT 2
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: LIST
16122: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16123: LD_VAR 0 6
16127: PPUSH
16128: CALL_OW 257
16132: PUSH
16133: LD_INT 8
16135: EQUAL
16136: IFFALSE 16157
// points := [ 35 , 35 , 30 ] ;
16138: LD_ADDR_VAR 0 9
16142: PUSH
16143: LD_INT 35
16145: PUSH
16146: LD_INT 35
16148: PUSH
16149: LD_INT 30
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: LIST
16156: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16157: LD_VAR 0 6
16161: PPUSH
16162: CALL_OW 257
16166: PUSH
16167: LD_INT 9
16169: EQUAL
16170: IFFALSE 16191
// points := [ 20 , 55 , 40 ] ;
16172: LD_ADDR_VAR 0 9
16176: PUSH
16177: LD_INT 20
16179: PUSH
16180: LD_INT 55
16182: PUSH
16183: LD_INT 40
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16191: LD_VAR 0 6
16195: PPUSH
16196: CALL_OW 257
16200: PUSH
16201: LD_INT 12
16203: PUSH
16204: LD_INT 16
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: IN
16211: IFFALSE 16232
// points := [ 5 , 3 , 2 ] ;
16213: LD_ADDR_VAR 0 9
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 3
16223: PUSH
16224: LD_INT 2
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: LIST
16231: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16232: LD_VAR 0 6
16236: PPUSH
16237: CALL_OW 257
16241: PUSH
16242: LD_INT 17
16244: EQUAL
16245: IFFALSE 16266
// points := [ 100 , 50 , 75 ] ;
16247: LD_ADDR_VAR 0 9
16251: PUSH
16252: LD_INT 100
16254: PUSH
16255: LD_INT 50
16257: PUSH
16258: LD_INT 75
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: LIST
16265: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16266: LD_VAR 0 6
16270: PPUSH
16271: CALL_OW 257
16275: PUSH
16276: LD_INT 15
16278: EQUAL
16279: IFFALSE 16300
// points := [ 10 , 5 , 3 ] ;
16281: LD_ADDR_VAR 0 9
16285: PUSH
16286: LD_INT 10
16288: PUSH
16289: LD_INT 5
16291: PUSH
16292: LD_INT 3
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: LIST
16299: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16300: LD_VAR 0 6
16304: PPUSH
16305: CALL_OW 257
16309: PUSH
16310: LD_INT 14
16312: EQUAL
16313: IFFALSE 16334
// points := [ 10 , 0 , 0 ] ;
16315: LD_ADDR_VAR 0 9
16319: PUSH
16320: LD_INT 10
16322: PUSH
16323: LD_INT 0
16325: PUSH
16326: LD_INT 0
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: LIST
16333: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16334: LD_VAR 0 6
16338: PPUSH
16339: CALL_OW 257
16343: PUSH
16344: LD_INT 11
16346: EQUAL
16347: IFFALSE 16368
// points := [ 30 , 10 , 5 ] ;
16349: LD_ADDR_VAR 0 9
16353: PUSH
16354: LD_INT 30
16356: PUSH
16357: LD_INT 10
16359: PUSH
16360: LD_INT 5
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 5
16375: PPUSH
16376: CALL_OW 321
16380: PUSH
16381: LD_INT 2
16383: EQUAL
16384: IFFALSE 16401
// bpoints := bpoints * 1.8 ;
16386: LD_ADDR_VAR 0 10
16390: PUSH
16391: LD_VAR 0 10
16395: PUSH
16396: LD_REAL  1.80000000000000E+0000
16399: MUL
16400: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16401: LD_VAR 0 6
16405: PPUSH
16406: CALL_OW 257
16410: PUSH
16411: LD_INT 1
16413: PUSH
16414: LD_INT 2
16416: PUSH
16417: LD_INT 3
16419: PUSH
16420: LD_INT 4
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: LIST
16427: LIST
16428: IN
16429: PUSH
16430: LD_VAR 0 1
16434: PPUSH
16435: LD_INT 51
16437: PPUSH
16438: CALL_OW 321
16442: PUSH
16443: LD_INT 2
16445: EQUAL
16446: AND
16447: IFFALSE 16464
// bpoints := bpoints * 1.2 ;
16449: LD_ADDR_VAR 0 10
16453: PUSH
16454: LD_VAR 0 10
16458: PUSH
16459: LD_REAL  1.20000000000000E+0000
16462: MUL
16463: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16464: LD_VAR 0 6
16468: PPUSH
16469: CALL_OW 257
16473: PUSH
16474: LD_INT 5
16476: PUSH
16477: LD_INT 7
16479: PUSH
16480: LD_INT 9
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: LIST
16487: IN
16488: PUSH
16489: LD_VAR 0 1
16493: PPUSH
16494: LD_INT 52
16496: PPUSH
16497: CALL_OW 321
16501: PUSH
16502: LD_INT 2
16504: EQUAL
16505: AND
16506: IFFALSE 16523
// bpoints := bpoints * 1.5 ;
16508: LD_ADDR_VAR 0 10
16512: PUSH
16513: LD_VAR 0 10
16517: PUSH
16518: LD_REAL  1.50000000000000E+0000
16521: MUL
16522: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_INT 66
16530: PPUSH
16531: CALL_OW 321
16535: PUSH
16536: LD_INT 2
16538: EQUAL
16539: IFFALSE 16556
// bpoints := bpoints * 1.1 ;
16541: LD_ADDR_VAR 0 10
16545: PUSH
16546: LD_VAR 0 10
16550: PUSH
16551: LD_REAL  1.10000000000000E+0000
16554: MUL
16555: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16556: LD_ADDR_VAR 0 10
16560: PUSH
16561: LD_VAR 0 10
16565: PUSH
16566: LD_VAR 0 6
16570: PPUSH
16571: LD_INT 1
16573: PPUSH
16574: CALL_OW 259
16578: PUSH
16579: LD_REAL  1.15000000000000E+0000
16582: MUL
16583: MUL
16584: ST_TO_ADDR
// end ; unit_vehicle :
16585: GO 17413
16587: LD_INT 2
16589: DOUBLE
16590: EQUAL
16591: IFTRUE 16595
16593: GO 17401
16595: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16596: LD_VAR 0 6
16600: PPUSH
16601: CALL_OW 264
16605: PUSH
16606: LD_INT 2
16608: PUSH
16609: LD_INT 42
16611: PUSH
16612: LD_INT 24
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: LIST
16619: IN
16620: IFFALSE 16641
// points := [ 25 , 5 , 3 ] ;
16622: LD_ADDR_VAR 0 9
16626: PUSH
16627: LD_INT 25
16629: PUSH
16630: LD_INT 5
16632: PUSH
16633: LD_INT 3
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: LIST
16640: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16641: LD_VAR 0 6
16645: PPUSH
16646: CALL_OW 264
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: LD_INT 43
16656: PUSH
16657: LD_INT 25
16659: PUSH
16660: EMPTY
16661: LIST
16662: LIST
16663: LIST
16664: IN
16665: IFFALSE 16686
// points := [ 40 , 15 , 5 ] ;
16667: LD_ADDR_VAR 0 9
16671: PUSH
16672: LD_INT 40
16674: PUSH
16675: LD_INT 15
16677: PUSH
16678: LD_INT 5
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: LIST
16685: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16686: LD_VAR 0 6
16690: PPUSH
16691: CALL_OW 264
16695: PUSH
16696: LD_INT 3
16698: PUSH
16699: LD_INT 23
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: IN
16706: IFFALSE 16727
// points := [ 7 , 25 , 8 ] ;
16708: LD_ADDR_VAR 0 9
16712: PUSH
16713: LD_INT 7
16715: PUSH
16716: LD_INT 25
16718: PUSH
16719: LD_INT 8
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: LIST
16726: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16727: LD_VAR 0 6
16731: PPUSH
16732: CALL_OW 264
16736: PUSH
16737: LD_INT 5
16739: PUSH
16740: LD_INT 27
16742: PUSH
16743: LD_INT 44
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: LIST
16750: IN
16751: IFFALSE 16772
// points := [ 14 , 50 , 16 ] ;
16753: LD_ADDR_VAR 0 9
16757: PUSH
16758: LD_INT 14
16760: PUSH
16761: LD_INT 50
16763: PUSH
16764: LD_INT 16
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: LIST
16771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16772: LD_VAR 0 6
16776: PPUSH
16777: CALL_OW 264
16781: PUSH
16782: LD_INT 6
16784: PUSH
16785: LD_INT 46
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: IN
16792: IFFALSE 16813
// points := [ 32 , 120 , 70 ] ;
16794: LD_ADDR_VAR 0 9
16798: PUSH
16799: LD_INT 32
16801: PUSH
16802: LD_INT 120
16804: PUSH
16805: LD_INT 70
16807: PUSH
16808: EMPTY
16809: LIST
16810: LIST
16811: LIST
16812: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16813: LD_VAR 0 6
16817: PPUSH
16818: CALL_OW 264
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: LD_INT 28
16828: PUSH
16829: LD_INT 45
16831: PUSH
16832: LD_INT 92
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: IN
16841: IFFALSE 16862
// points := [ 35 , 20 , 45 ] ;
16843: LD_ADDR_VAR 0 9
16847: PUSH
16848: LD_INT 35
16850: PUSH
16851: LD_INT 20
16853: PUSH
16854: LD_INT 45
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16862: LD_VAR 0 6
16866: PPUSH
16867: CALL_OW 264
16871: PUSH
16872: LD_INT 47
16874: PUSH
16875: EMPTY
16876: LIST
16877: IN
16878: IFFALSE 16899
// points := [ 67 , 45 , 75 ] ;
16880: LD_ADDR_VAR 0 9
16884: PUSH
16885: LD_INT 67
16887: PUSH
16888: LD_INT 45
16890: PUSH
16891: LD_INT 75
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: LIST
16898: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16899: LD_VAR 0 6
16903: PPUSH
16904: CALL_OW 264
16908: PUSH
16909: LD_INT 26
16911: PUSH
16912: EMPTY
16913: LIST
16914: IN
16915: IFFALSE 16936
// points := [ 120 , 30 , 80 ] ;
16917: LD_ADDR_VAR 0 9
16921: PUSH
16922: LD_INT 120
16924: PUSH
16925: LD_INT 30
16927: PUSH
16928: LD_INT 80
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: LIST
16935: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16936: LD_VAR 0 6
16940: PPUSH
16941: CALL_OW 264
16945: PUSH
16946: LD_INT 22
16948: PUSH
16949: EMPTY
16950: LIST
16951: IN
16952: IFFALSE 16973
// points := [ 40 , 1 , 1 ] ;
16954: LD_ADDR_VAR 0 9
16958: PUSH
16959: LD_INT 40
16961: PUSH
16962: LD_INT 1
16964: PUSH
16965: LD_INT 1
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16973: LD_VAR 0 6
16977: PPUSH
16978: CALL_OW 264
16982: PUSH
16983: LD_INT 29
16985: PUSH
16986: EMPTY
16987: LIST
16988: IN
16989: IFFALSE 17010
// points := [ 70 , 200 , 400 ] ;
16991: LD_ADDR_VAR 0 9
16995: PUSH
16996: LD_INT 70
16998: PUSH
16999: LD_INT 200
17001: PUSH
17002: LD_INT 400
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17010: LD_VAR 0 6
17014: PPUSH
17015: CALL_OW 264
17019: PUSH
17020: LD_INT 14
17022: PUSH
17023: LD_INT 53
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: IN
17030: IFFALSE 17051
// points := [ 40 , 10 , 20 ] ;
17032: LD_ADDR_VAR 0 9
17036: PUSH
17037: LD_INT 40
17039: PUSH
17040: LD_INT 10
17042: PUSH
17043: LD_INT 20
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17051: LD_VAR 0 6
17055: PPUSH
17056: CALL_OW 264
17060: PUSH
17061: LD_INT 9
17063: PUSH
17064: EMPTY
17065: LIST
17066: IN
17067: IFFALSE 17088
// points := [ 5 , 70 , 20 ] ;
17069: LD_ADDR_VAR 0 9
17073: PUSH
17074: LD_INT 5
17076: PUSH
17077: LD_INT 70
17079: PUSH
17080: LD_INT 20
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17088: LD_VAR 0 6
17092: PPUSH
17093: CALL_OW 264
17097: PUSH
17098: LD_INT 10
17100: PUSH
17101: EMPTY
17102: LIST
17103: IN
17104: IFFALSE 17125
// points := [ 35 , 110 , 70 ] ;
17106: LD_ADDR_VAR 0 9
17110: PUSH
17111: LD_INT 35
17113: PUSH
17114: LD_INT 110
17116: PUSH
17117: LD_INT 70
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: LIST
17124: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17125: LD_VAR 0 6
17129: PPUSH
17130: CALL_OW 265
17134: PUSH
17135: LD_INT 25
17137: EQUAL
17138: IFFALSE 17159
// points := [ 80 , 65 , 100 ] ;
17140: LD_ADDR_VAR 0 9
17144: PUSH
17145: LD_INT 80
17147: PUSH
17148: LD_INT 65
17150: PUSH
17151: LD_INT 100
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: LIST
17158: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 263
17168: PUSH
17169: LD_INT 1
17171: EQUAL
17172: IFFALSE 17207
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17174: LD_ADDR_VAR 0 10
17178: PUSH
17179: LD_VAR 0 10
17183: PUSH
17184: LD_VAR 0 6
17188: PPUSH
17189: CALL_OW 311
17193: PPUSH
17194: LD_INT 3
17196: PPUSH
17197: CALL_OW 259
17201: PUSH
17202: LD_INT 4
17204: MUL
17205: MUL
17206: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17207: LD_VAR 0 6
17211: PPUSH
17212: CALL_OW 263
17216: PUSH
17217: LD_INT 2
17219: EQUAL
17220: IFFALSE 17271
// begin j := IsControledBy ( i ) ;
17222: LD_ADDR_VAR 0 7
17226: PUSH
17227: LD_VAR 0 6
17231: PPUSH
17232: CALL_OW 312
17236: ST_TO_ADDR
// if j then
17237: LD_VAR 0 7
17241: IFFALSE 17271
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17243: LD_ADDR_VAR 0 10
17247: PUSH
17248: LD_VAR 0 10
17252: PUSH
17253: LD_VAR 0 7
17257: PPUSH
17258: LD_INT 3
17260: PPUSH
17261: CALL_OW 259
17265: PUSH
17266: LD_INT 3
17268: MUL
17269: MUL
17270: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17271: LD_VAR 0 6
17275: PPUSH
17276: CALL_OW 264
17280: PUSH
17281: LD_INT 5
17283: PUSH
17284: LD_INT 6
17286: PUSH
17287: LD_INT 46
17289: PUSH
17290: LD_INT 44
17292: PUSH
17293: LD_INT 47
17295: PUSH
17296: LD_INT 45
17298: PUSH
17299: LD_INT 28
17301: PUSH
17302: LD_INT 7
17304: PUSH
17305: LD_INT 27
17307: PUSH
17308: LD_INT 29
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: IN
17323: PUSH
17324: LD_VAR 0 1
17328: PPUSH
17329: LD_INT 52
17331: PPUSH
17332: CALL_OW 321
17336: PUSH
17337: LD_INT 2
17339: EQUAL
17340: AND
17341: IFFALSE 17358
// bpoints := bpoints * 1.2 ;
17343: LD_ADDR_VAR 0 10
17347: PUSH
17348: LD_VAR 0 10
17352: PUSH
17353: LD_REAL  1.20000000000000E+0000
17356: MUL
17357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17358: LD_VAR 0 6
17362: PPUSH
17363: CALL_OW 264
17367: PUSH
17368: LD_INT 6
17370: PUSH
17371: LD_INT 46
17373: PUSH
17374: LD_INT 47
17376: PUSH
17377: EMPTY
17378: LIST
17379: LIST
17380: LIST
17381: IN
17382: IFFALSE 17399
// bpoints := bpoints * 1.2 ;
17384: LD_ADDR_VAR 0 10
17388: PUSH
17389: LD_VAR 0 10
17393: PUSH
17394: LD_REAL  1.20000000000000E+0000
17397: MUL
17398: ST_TO_ADDR
// end ; unit_building :
17399: GO 17413
17401: LD_INT 3
17403: DOUBLE
17404: EQUAL
17405: IFTRUE 17409
17407: GO 17412
17409: POP
// ; end ;
17410: GO 17413
17412: POP
// for j = 1 to 3 do
17413: LD_ADDR_VAR 0 7
17417: PUSH
17418: DOUBLE
17419: LD_INT 1
17421: DEC
17422: ST_TO_ADDR
17423: LD_INT 3
17425: PUSH
17426: FOR_TO
17427: IFFALSE 17480
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17429: LD_ADDR_VAR 0 5
17433: PUSH
17434: LD_VAR 0 5
17438: PPUSH
17439: LD_VAR 0 7
17443: PPUSH
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 7
17453: ARRAY
17454: PUSH
17455: LD_VAR 0 9
17459: PUSH
17460: LD_VAR 0 7
17464: ARRAY
17465: PUSH
17466: LD_VAR 0 10
17470: MUL
17471: PLUS
17472: PPUSH
17473: CALL_OW 1
17477: ST_TO_ADDR
17478: GO 17426
17480: POP
17481: POP
// end ;
17482: GO 15961
17484: POP
17485: POP
// result := Replace ( result , 4 , tmp ) ;
17486: LD_ADDR_VAR 0 5
17490: PUSH
17491: LD_VAR 0 5
17495: PPUSH
17496: LD_INT 4
17498: PPUSH
17499: LD_VAR 0 8
17503: PPUSH
17504: CALL_OW 1
17508: ST_TO_ADDR
// end ;
17509: LD_VAR 0 5
17513: RET
// export function DangerAtRange ( unit , range ) ; begin
17514: LD_INT 0
17516: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17517: LD_ADDR_VAR 0 3
17521: PUSH
17522: LD_VAR 0 1
17526: PPUSH
17527: CALL_OW 255
17531: PPUSH
17532: LD_VAR 0 1
17536: PPUSH
17537: CALL_OW 250
17541: PPUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 251
17551: PPUSH
17552: LD_VAR 0 2
17556: PPUSH
17557: CALL 15813 0 4
17561: ST_TO_ADDR
// end ;
17562: LD_VAR 0 3
17566: RET
// export function DangerInArea ( side , area ) ; begin
17567: LD_INT 0
17569: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17570: LD_ADDR_VAR 0 3
17574: PUSH
17575: LD_VAR 0 2
17579: PPUSH
17580: LD_INT 81
17582: PUSH
17583: LD_VAR 0 1
17587: PUSH
17588: EMPTY
17589: LIST
17590: LIST
17591: PPUSH
17592: CALL_OW 70
17596: ST_TO_ADDR
// end ;
17597: LD_VAR 0 3
17601: RET
// export function IsExtension ( b ) ; begin
17602: LD_INT 0
17604: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17605: LD_ADDR_VAR 0 2
17609: PUSH
17610: LD_VAR 0 1
17614: PUSH
17615: LD_INT 23
17617: PUSH
17618: LD_INT 20
17620: PUSH
17621: LD_INT 22
17623: PUSH
17624: LD_INT 17
17626: PUSH
17627: LD_INT 24
17629: PUSH
17630: LD_INT 21
17632: PUSH
17633: LD_INT 19
17635: PUSH
17636: LD_INT 16
17638: PUSH
17639: LD_INT 25
17641: PUSH
17642: LD_INT 18
17644: PUSH
17645: EMPTY
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: IN
17657: ST_TO_ADDR
// end ;
17658: LD_VAR 0 2
17662: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17663: LD_INT 0
17665: PPUSH
17666: PPUSH
17667: PPUSH
// result := [ ] ;
17668: LD_ADDR_VAR 0 4
17672: PUSH
17673: EMPTY
17674: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17675: LD_ADDR_VAR 0 5
17679: PUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: LD_INT 21
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: PPUSH
17695: CALL_OW 70
17699: ST_TO_ADDR
// if not tmp then
17700: LD_VAR 0 5
17704: NOT
17705: IFFALSE 17709
// exit ;
17707: GO 17773
// if checkLink then
17709: LD_VAR 0 3
17713: IFFALSE 17763
// begin for i in tmp do
17715: LD_ADDR_VAR 0 6
17719: PUSH
17720: LD_VAR 0 5
17724: PUSH
17725: FOR_IN
17726: IFFALSE 17761
// if GetBase ( i ) <> base then
17728: LD_VAR 0 6
17732: PPUSH
17733: CALL_OW 274
17737: PUSH
17738: LD_VAR 0 1
17742: NONEQUAL
17743: IFFALSE 17759
// ComLinkToBase ( base , i ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 6
17754: PPUSH
17755: CALL_OW 169
17759: GO 17725
17761: POP
17762: POP
// end ; result := tmp ;
17763: LD_ADDR_VAR 0 4
17767: PUSH
17768: LD_VAR 0 5
17772: ST_TO_ADDR
// end ;
17773: LD_VAR 0 4
17777: RET
// export function ComComplete ( units , b ) ; var i ; begin
17778: LD_INT 0
17780: PPUSH
17781: PPUSH
// if not units then
17782: LD_VAR 0 1
17786: NOT
17787: IFFALSE 17791
// exit ;
17789: GO 17881
// for i in units do
17791: LD_ADDR_VAR 0 4
17795: PUSH
17796: LD_VAR 0 1
17800: PUSH
17801: FOR_IN
17802: IFFALSE 17879
// if BuildingStatus ( b ) = bs_build then
17804: LD_VAR 0 2
17808: PPUSH
17809: CALL_OW 461
17813: PUSH
17814: LD_INT 1
17816: EQUAL
17817: IFFALSE 17877
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17819: LD_VAR 0 4
17823: PPUSH
17824: LD_STRING h
17826: PUSH
17827: LD_VAR 0 2
17831: PPUSH
17832: CALL_OW 250
17836: PUSH
17837: LD_VAR 0 2
17841: PPUSH
17842: CALL_OW 251
17846: PUSH
17847: LD_VAR 0 2
17851: PUSH
17852: LD_INT 0
17854: PUSH
17855: LD_INT 0
17857: PUSH
17858: LD_INT 0
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: PUSH
17870: EMPTY
17871: LIST
17872: PPUSH
17873: CALL_OW 446
17877: GO 17801
17879: POP
17880: POP
// end ;
17881: LD_VAR 0 3
17885: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17886: LD_INT 0
17888: PPUSH
17889: PPUSH
17890: PPUSH
17891: PPUSH
17892: PPUSH
17893: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17894: LD_VAR 0 1
17898: NOT
17899: PUSH
17900: LD_VAR 0 1
17904: PPUSH
17905: CALL_OW 263
17909: PUSH
17910: LD_INT 2
17912: NONEQUAL
17913: OR
17914: IFFALSE 17918
// exit ;
17916: GO 18234
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17918: LD_ADDR_VAR 0 6
17922: PUSH
17923: LD_INT 22
17925: PUSH
17926: LD_VAR 0 1
17930: PPUSH
17931: CALL_OW 255
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: PUSH
17940: LD_INT 2
17942: PUSH
17943: LD_INT 30
17945: PUSH
17946: LD_INT 36
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: PUSH
17953: LD_INT 34
17955: PUSH
17956: LD_INT 31
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PPUSH
17972: CALL_OW 69
17976: ST_TO_ADDR
// if not tmp then
17977: LD_VAR 0 6
17981: NOT
17982: IFFALSE 17986
// exit ;
17984: GO 18234
// result := [ ] ;
17986: LD_ADDR_VAR 0 2
17990: PUSH
17991: EMPTY
17992: ST_TO_ADDR
// for i in tmp do
17993: LD_ADDR_VAR 0 3
17997: PUSH
17998: LD_VAR 0 6
18002: PUSH
18003: FOR_IN
18004: IFFALSE 18075
// begin t := UnitsInside ( i ) ;
18006: LD_ADDR_VAR 0 4
18010: PUSH
18011: LD_VAR 0 3
18015: PPUSH
18016: CALL_OW 313
18020: ST_TO_ADDR
// if t then
18021: LD_VAR 0 4
18025: IFFALSE 18073
// for j in t do
18027: LD_ADDR_VAR 0 7
18031: PUSH
18032: LD_VAR 0 4
18036: PUSH
18037: FOR_IN
18038: IFFALSE 18071
// result := Replace ( result , result + 1 , j ) ;
18040: LD_ADDR_VAR 0 2
18044: PUSH
18045: LD_VAR 0 2
18049: PPUSH
18050: LD_VAR 0 2
18054: PUSH
18055: LD_INT 1
18057: PLUS
18058: PPUSH
18059: LD_VAR 0 7
18063: PPUSH
18064: CALL_OW 1
18068: ST_TO_ADDR
18069: GO 18037
18071: POP
18072: POP
// end ;
18073: GO 18003
18075: POP
18076: POP
// if not result then
18077: LD_VAR 0 2
18081: NOT
18082: IFFALSE 18086
// exit ;
18084: GO 18234
// mech := result [ 1 ] ;
18086: LD_ADDR_VAR 0 5
18090: PUSH
18091: LD_VAR 0 2
18095: PUSH
18096: LD_INT 1
18098: ARRAY
18099: ST_TO_ADDR
// if result > 1 then
18100: LD_VAR 0 2
18104: PUSH
18105: LD_INT 1
18107: GREATER
18108: IFFALSE 18220
// begin for i = 2 to result do
18110: LD_ADDR_VAR 0 3
18114: PUSH
18115: DOUBLE
18116: LD_INT 2
18118: DEC
18119: ST_TO_ADDR
18120: LD_VAR 0 2
18124: PUSH
18125: FOR_TO
18126: IFFALSE 18218
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18128: LD_ADDR_VAR 0 4
18132: PUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 3
18142: ARRAY
18143: PPUSH
18144: LD_INT 3
18146: PPUSH
18147: CALL_OW 259
18151: PUSH
18152: LD_VAR 0 2
18156: PUSH
18157: LD_VAR 0 3
18161: ARRAY
18162: PPUSH
18163: CALL_OW 432
18167: MINUS
18168: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18169: LD_VAR 0 4
18173: PUSH
18174: LD_VAR 0 5
18178: PPUSH
18179: LD_INT 3
18181: PPUSH
18182: CALL_OW 259
18186: PUSH
18187: LD_VAR 0 5
18191: PPUSH
18192: CALL_OW 432
18196: MINUS
18197: GREATEREQUAL
18198: IFFALSE 18216
// mech := result [ i ] ;
18200: LD_ADDR_VAR 0 5
18204: PUSH
18205: LD_VAR 0 2
18209: PUSH
18210: LD_VAR 0 3
18214: ARRAY
18215: ST_TO_ADDR
// end ;
18216: GO 18125
18218: POP
18219: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18220: LD_VAR 0 1
18224: PPUSH
18225: LD_VAR 0 5
18229: PPUSH
18230: CALL_OW 135
// end ;
18234: LD_VAR 0 2
18238: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18239: LD_INT 0
18241: PPUSH
18242: PPUSH
18243: PPUSH
18244: PPUSH
18245: PPUSH
18246: PPUSH
18247: PPUSH
18248: PPUSH
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
// result := [ ] ;
18254: LD_ADDR_VAR 0 7
18258: PUSH
18259: EMPTY
18260: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18261: LD_VAR 0 1
18265: PPUSH
18266: CALL_OW 266
18270: PUSH
18271: LD_INT 0
18273: PUSH
18274: LD_INT 1
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: IN
18281: NOT
18282: IFFALSE 18286
// exit ;
18284: GO 19920
// if name then
18286: LD_VAR 0 3
18290: IFFALSE 18306
// SetBName ( base_dep , name ) ;
18292: LD_VAR 0 1
18296: PPUSH
18297: LD_VAR 0 3
18301: PPUSH
18302: CALL_OW 500
// base := GetBase ( base_dep ) ;
18306: LD_ADDR_VAR 0 15
18310: PUSH
18311: LD_VAR 0 1
18315: PPUSH
18316: CALL_OW 274
18320: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18321: LD_ADDR_VAR 0 16
18325: PUSH
18326: LD_VAR 0 1
18330: PPUSH
18331: CALL_OW 255
18335: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18336: LD_ADDR_VAR 0 17
18340: PUSH
18341: LD_VAR 0 1
18345: PPUSH
18346: CALL_OW 248
18350: ST_TO_ADDR
// if sources then
18351: LD_VAR 0 5
18355: IFFALSE 18402
// for i = 1 to 3 do
18357: LD_ADDR_VAR 0 8
18361: PUSH
18362: DOUBLE
18363: LD_INT 1
18365: DEC
18366: ST_TO_ADDR
18367: LD_INT 3
18369: PUSH
18370: FOR_TO
18371: IFFALSE 18400
// AddResourceType ( base , i , sources [ i ] ) ;
18373: LD_VAR 0 15
18377: PPUSH
18378: LD_VAR 0 8
18382: PPUSH
18383: LD_VAR 0 5
18387: PUSH
18388: LD_VAR 0 8
18392: ARRAY
18393: PPUSH
18394: CALL_OW 276
18398: GO 18370
18400: POP
18401: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18402: LD_ADDR_VAR 0 18
18406: PUSH
18407: LD_VAR 0 15
18411: PPUSH
18412: LD_VAR 0 2
18416: PPUSH
18417: LD_INT 1
18419: PPUSH
18420: CALL 17663 0 3
18424: ST_TO_ADDR
// InitHc ;
18425: CALL_OW 19
// InitUc ;
18429: CALL_OW 18
// uc_side := side ;
18433: LD_ADDR_OWVAR 20
18437: PUSH
18438: LD_VAR 0 16
18442: ST_TO_ADDR
// uc_nation := nation ;
18443: LD_ADDR_OWVAR 21
18447: PUSH
18448: LD_VAR 0 17
18452: ST_TO_ADDR
// if buildings then
18453: LD_VAR 0 18
18457: IFFALSE 19779
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18459: LD_ADDR_VAR 0 19
18463: PUSH
18464: LD_VAR 0 18
18468: PPUSH
18469: LD_INT 2
18471: PUSH
18472: LD_INT 30
18474: PUSH
18475: LD_INT 29
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: PUSH
18482: LD_INT 30
18484: PUSH
18485: LD_INT 30
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: LIST
18496: PPUSH
18497: CALL_OW 72
18501: ST_TO_ADDR
// if tmp then
18502: LD_VAR 0 19
18506: IFFALSE 18554
// for i in tmp do
18508: LD_ADDR_VAR 0 8
18512: PUSH
18513: LD_VAR 0 19
18517: PUSH
18518: FOR_IN
18519: IFFALSE 18552
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18521: LD_VAR 0 8
18525: PPUSH
18526: CALL_OW 250
18530: PPUSH
18531: LD_VAR 0 8
18535: PPUSH
18536: CALL_OW 251
18540: PPUSH
18541: LD_VAR 0 16
18545: PPUSH
18546: CALL_OW 441
18550: GO 18518
18552: POP
18553: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18554: LD_VAR 0 18
18558: PPUSH
18559: LD_INT 2
18561: PUSH
18562: LD_INT 30
18564: PUSH
18565: LD_INT 32
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: PUSH
18572: LD_INT 30
18574: PUSH
18575: LD_INT 33
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: PUSH
18582: EMPTY
18583: LIST
18584: LIST
18585: LIST
18586: PPUSH
18587: CALL_OW 72
18591: IFFALSE 18679
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18593: LD_ADDR_VAR 0 8
18597: PUSH
18598: LD_VAR 0 18
18602: PPUSH
18603: LD_INT 2
18605: PUSH
18606: LD_INT 30
18608: PUSH
18609: LD_INT 32
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: PUSH
18616: LD_INT 30
18618: PUSH
18619: LD_INT 33
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: LIST
18630: PPUSH
18631: CALL_OW 72
18635: PUSH
18636: FOR_IN
18637: IFFALSE 18677
// begin if not GetBWeapon ( i ) then
18639: LD_VAR 0 8
18643: PPUSH
18644: CALL_OW 269
18648: NOT
18649: IFFALSE 18675
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18651: LD_VAR 0 8
18655: PPUSH
18656: LD_VAR 0 8
18660: PPUSH
18661: LD_VAR 0 2
18665: PPUSH
18666: CALL 19925 0 2
18670: PPUSH
18671: CALL_OW 431
// end ;
18675: GO 18636
18677: POP
18678: POP
// end ; for i = 1 to personel do
18679: LD_ADDR_VAR 0 8
18683: PUSH
18684: DOUBLE
18685: LD_INT 1
18687: DEC
18688: ST_TO_ADDR
18689: LD_VAR 0 6
18693: PUSH
18694: FOR_TO
18695: IFFALSE 19759
// begin if i > 4 then
18697: LD_VAR 0 8
18701: PUSH
18702: LD_INT 4
18704: GREATER
18705: IFFALSE 18709
// break ;
18707: GO 19759
// case i of 1 :
18709: LD_VAR 0 8
18713: PUSH
18714: LD_INT 1
18716: DOUBLE
18717: EQUAL
18718: IFTRUE 18722
18720: GO 18802
18722: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18723: LD_ADDR_VAR 0 12
18727: PUSH
18728: LD_VAR 0 18
18732: PPUSH
18733: LD_INT 22
18735: PUSH
18736: LD_VAR 0 16
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: PUSH
18745: LD_INT 58
18747: PUSH
18748: EMPTY
18749: LIST
18750: PUSH
18751: LD_INT 2
18753: PUSH
18754: LD_INT 30
18756: PUSH
18757: LD_INT 32
18759: PUSH
18760: EMPTY
18761: LIST
18762: LIST
18763: PUSH
18764: LD_INT 30
18766: PUSH
18767: LD_INT 4
18769: PUSH
18770: EMPTY
18771: LIST
18772: LIST
18773: PUSH
18774: LD_INT 30
18776: PUSH
18777: LD_INT 5
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: EMPTY
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 72
18799: ST_TO_ADDR
18800: GO 19024
18802: LD_INT 2
18804: DOUBLE
18805: EQUAL
18806: IFTRUE 18810
18808: GO 18872
18810: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18811: LD_ADDR_VAR 0 12
18815: PUSH
18816: LD_VAR 0 18
18820: PPUSH
18821: LD_INT 22
18823: PUSH
18824: LD_VAR 0 16
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 2
18835: PUSH
18836: LD_INT 30
18838: PUSH
18839: LD_INT 0
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PUSH
18846: LD_INT 30
18848: PUSH
18849: LD_INT 1
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: PUSH
18856: EMPTY
18857: LIST
18858: LIST
18859: LIST
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PPUSH
18865: CALL_OW 72
18869: ST_TO_ADDR
18870: GO 19024
18872: LD_INT 3
18874: DOUBLE
18875: EQUAL
18876: IFTRUE 18880
18878: GO 18942
18880: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18881: LD_ADDR_VAR 0 12
18885: PUSH
18886: LD_VAR 0 18
18890: PPUSH
18891: LD_INT 22
18893: PUSH
18894: LD_VAR 0 16
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: LD_INT 2
18905: PUSH
18906: LD_INT 30
18908: PUSH
18909: LD_INT 2
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PUSH
18916: LD_INT 30
18918: PUSH
18919: LD_INT 3
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PPUSH
18935: CALL_OW 72
18939: ST_TO_ADDR
18940: GO 19024
18942: LD_INT 4
18944: DOUBLE
18945: EQUAL
18946: IFTRUE 18950
18948: GO 19023
18950: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18951: LD_ADDR_VAR 0 12
18955: PUSH
18956: LD_VAR 0 18
18960: PPUSH
18961: LD_INT 22
18963: PUSH
18964: LD_VAR 0 16
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: PUSH
18973: LD_INT 2
18975: PUSH
18976: LD_INT 30
18978: PUSH
18979: LD_INT 6
18981: PUSH
18982: EMPTY
18983: LIST
18984: LIST
18985: PUSH
18986: LD_INT 30
18988: PUSH
18989: LD_INT 7
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: PUSH
18996: LD_INT 30
18998: PUSH
18999: LD_INT 8
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PPUSH
19016: CALL_OW 72
19020: ST_TO_ADDR
19021: GO 19024
19023: POP
// if i = 1 then
19024: LD_VAR 0 8
19028: PUSH
19029: LD_INT 1
19031: EQUAL
19032: IFFALSE 19143
// begin tmp := [ ] ;
19034: LD_ADDR_VAR 0 19
19038: PUSH
19039: EMPTY
19040: ST_TO_ADDR
// for j in f do
19041: LD_ADDR_VAR 0 9
19045: PUSH
19046: LD_VAR 0 12
19050: PUSH
19051: FOR_IN
19052: IFFALSE 19125
// if GetBType ( j ) = b_bunker then
19054: LD_VAR 0 9
19058: PPUSH
19059: CALL_OW 266
19063: PUSH
19064: LD_INT 32
19066: EQUAL
19067: IFFALSE 19094
// tmp := Insert ( tmp , 1 , j ) else
19069: LD_ADDR_VAR 0 19
19073: PUSH
19074: LD_VAR 0 19
19078: PPUSH
19079: LD_INT 1
19081: PPUSH
19082: LD_VAR 0 9
19086: PPUSH
19087: CALL_OW 2
19091: ST_TO_ADDR
19092: GO 19123
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19094: LD_ADDR_VAR 0 19
19098: PUSH
19099: LD_VAR 0 19
19103: PPUSH
19104: LD_VAR 0 19
19108: PUSH
19109: LD_INT 1
19111: PLUS
19112: PPUSH
19113: LD_VAR 0 9
19117: PPUSH
19118: CALL_OW 2
19122: ST_TO_ADDR
19123: GO 19051
19125: POP
19126: POP
// if tmp then
19127: LD_VAR 0 19
19131: IFFALSE 19143
// f := tmp ;
19133: LD_ADDR_VAR 0 12
19137: PUSH
19138: LD_VAR 0 19
19142: ST_TO_ADDR
// end ; x := personel [ i ] ;
19143: LD_ADDR_VAR 0 13
19147: PUSH
19148: LD_VAR 0 6
19152: PUSH
19153: LD_VAR 0 8
19157: ARRAY
19158: ST_TO_ADDR
// if x = - 1 then
19159: LD_VAR 0 13
19163: PUSH
19164: LD_INT 1
19166: NEG
19167: EQUAL
19168: IFFALSE 19377
// begin for j in f do
19170: LD_ADDR_VAR 0 9
19174: PUSH
19175: LD_VAR 0 12
19179: PUSH
19180: FOR_IN
19181: IFFALSE 19373
// repeat InitHc ;
19183: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19187: LD_VAR 0 9
19191: PPUSH
19192: CALL_OW 266
19196: PUSH
19197: LD_INT 5
19199: EQUAL
19200: IFFALSE 19270
// begin if UnitsInside ( j ) < 3 then
19202: LD_VAR 0 9
19206: PPUSH
19207: CALL_OW 313
19211: PUSH
19212: LD_INT 3
19214: LESS
19215: IFFALSE 19251
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19217: LD_INT 0
19219: PPUSH
19220: LD_INT 5
19222: PUSH
19223: LD_INT 8
19225: PUSH
19226: LD_INT 9
19228: PUSH
19229: EMPTY
19230: LIST
19231: LIST
19232: LIST
19233: PUSH
19234: LD_VAR 0 17
19238: ARRAY
19239: PPUSH
19240: LD_VAR 0 4
19244: PPUSH
19245: CALL_OW 380
19249: GO 19268
// PrepareHuman ( false , i , skill ) ;
19251: LD_INT 0
19253: PPUSH
19254: LD_VAR 0 8
19258: PPUSH
19259: LD_VAR 0 4
19263: PPUSH
19264: CALL_OW 380
// end else
19268: GO 19287
// PrepareHuman ( false , i , skill ) ;
19270: LD_INT 0
19272: PPUSH
19273: LD_VAR 0 8
19277: PPUSH
19278: LD_VAR 0 4
19282: PPUSH
19283: CALL_OW 380
// un := CreateHuman ;
19287: LD_ADDR_VAR 0 14
19291: PUSH
19292: CALL_OW 44
19296: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19297: LD_ADDR_VAR 0 7
19301: PUSH
19302: LD_VAR 0 7
19306: PPUSH
19307: LD_INT 1
19309: PPUSH
19310: LD_VAR 0 14
19314: PPUSH
19315: CALL_OW 2
19319: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19320: LD_VAR 0 14
19324: PPUSH
19325: LD_VAR 0 9
19329: PPUSH
19330: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19334: LD_VAR 0 9
19338: PPUSH
19339: CALL_OW 313
19343: PUSH
19344: LD_INT 6
19346: EQUAL
19347: PUSH
19348: LD_VAR 0 9
19352: PPUSH
19353: CALL_OW 266
19357: PUSH
19358: LD_INT 32
19360: PUSH
19361: LD_INT 31
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: IN
19368: OR
19369: IFFALSE 19183
19371: GO 19180
19373: POP
19374: POP
// end else
19375: GO 19757
// for j = 1 to x do
19377: LD_ADDR_VAR 0 9
19381: PUSH
19382: DOUBLE
19383: LD_INT 1
19385: DEC
19386: ST_TO_ADDR
19387: LD_VAR 0 13
19391: PUSH
19392: FOR_TO
19393: IFFALSE 19755
// begin InitHc ;
19395: CALL_OW 19
// if not f then
19399: LD_VAR 0 12
19403: NOT
19404: IFFALSE 19493
// begin PrepareHuman ( false , i , skill ) ;
19406: LD_INT 0
19408: PPUSH
19409: LD_VAR 0 8
19413: PPUSH
19414: LD_VAR 0 4
19418: PPUSH
19419: CALL_OW 380
// un := CreateHuman ;
19423: LD_ADDR_VAR 0 14
19427: PUSH
19428: CALL_OW 44
19432: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19433: LD_ADDR_VAR 0 7
19437: PUSH
19438: LD_VAR 0 7
19442: PPUSH
19443: LD_INT 1
19445: PPUSH
19446: LD_VAR 0 14
19450: PPUSH
19451: CALL_OW 2
19455: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19456: LD_VAR 0 14
19460: PPUSH
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL_OW 250
19470: PPUSH
19471: LD_VAR 0 1
19475: PPUSH
19476: CALL_OW 251
19480: PPUSH
19481: LD_INT 10
19483: PPUSH
19484: LD_INT 0
19486: PPUSH
19487: CALL_OW 50
// continue ;
19491: GO 19392
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19493: LD_VAR 0 12
19497: PUSH
19498: LD_INT 1
19500: ARRAY
19501: PPUSH
19502: CALL_OW 313
19506: PUSH
19507: LD_VAR 0 12
19511: PUSH
19512: LD_INT 1
19514: ARRAY
19515: PPUSH
19516: CALL_OW 266
19520: PUSH
19521: LD_INT 32
19523: PUSH
19524: LD_INT 31
19526: PUSH
19527: EMPTY
19528: LIST
19529: LIST
19530: IN
19531: AND
19532: PUSH
19533: LD_VAR 0 12
19537: PUSH
19538: LD_INT 1
19540: ARRAY
19541: PPUSH
19542: CALL_OW 313
19546: PUSH
19547: LD_INT 6
19549: EQUAL
19550: OR
19551: IFFALSE 19571
// f := Delete ( f , 1 ) ;
19553: LD_ADDR_VAR 0 12
19557: PUSH
19558: LD_VAR 0 12
19562: PPUSH
19563: LD_INT 1
19565: PPUSH
19566: CALL_OW 3
19570: ST_TO_ADDR
// if not f then
19571: LD_VAR 0 12
19575: NOT
19576: IFFALSE 19594
// begin x := x + 2 ;
19578: LD_ADDR_VAR 0 13
19582: PUSH
19583: LD_VAR 0 13
19587: PUSH
19588: LD_INT 2
19590: PLUS
19591: ST_TO_ADDR
// continue ;
19592: GO 19392
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19594: LD_VAR 0 12
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: PPUSH
19603: CALL_OW 266
19607: PUSH
19608: LD_INT 5
19610: EQUAL
19611: IFFALSE 19685
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19613: LD_VAR 0 12
19617: PUSH
19618: LD_INT 1
19620: ARRAY
19621: PPUSH
19622: CALL_OW 313
19626: PUSH
19627: LD_INT 3
19629: LESS
19630: IFFALSE 19666
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19632: LD_INT 0
19634: PPUSH
19635: LD_INT 5
19637: PUSH
19638: LD_INT 8
19640: PUSH
19641: LD_INT 9
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: LIST
19648: PUSH
19649: LD_VAR 0 17
19653: ARRAY
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: CALL_OW 380
19664: GO 19683
// PrepareHuman ( false , i , skill ) ;
19666: LD_INT 0
19668: PPUSH
19669: LD_VAR 0 8
19673: PPUSH
19674: LD_VAR 0 4
19678: PPUSH
19679: CALL_OW 380
// end else
19683: GO 19702
// PrepareHuman ( false , i , skill ) ;
19685: LD_INT 0
19687: PPUSH
19688: LD_VAR 0 8
19692: PPUSH
19693: LD_VAR 0 4
19697: PPUSH
19698: CALL_OW 380
// un := CreateHuman ;
19702: LD_ADDR_VAR 0 14
19706: PUSH
19707: CALL_OW 44
19711: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19712: LD_ADDR_VAR 0 7
19716: PUSH
19717: LD_VAR 0 7
19721: PPUSH
19722: LD_INT 1
19724: PPUSH
19725: LD_VAR 0 14
19729: PPUSH
19730: CALL_OW 2
19734: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19735: LD_VAR 0 14
19739: PPUSH
19740: LD_VAR 0 12
19744: PUSH
19745: LD_INT 1
19747: ARRAY
19748: PPUSH
19749: CALL_OW 52
// end ;
19753: GO 19392
19755: POP
19756: POP
// end ;
19757: GO 18694
19759: POP
19760: POP
// result := result ^ buildings ;
19761: LD_ADDR_VAR 0 7
19765: PUSH
19766: LD_VAR 0 7
19770: PUSH
19771: LD_VAR 0 18
19775: ADD
19776: ST_TO_ADDR
// end else
19777: GO 19920
// begin for i = 1 to personel do
19779: LD_ADDR_VAR 0 8
19783: PUSH
19784: DOUBLE
19785: LD_INT 1
19787: DEC
19788: ST_TO_ADDR
19789: LD_VAR 0 6
19793: PUSH
19794: FOR_TO
19795: IFFALSE 19918
// begin if i > 4 then
19797: LD_VAR 0 8
19801: PUSH
19802: LD_INT 4
19804: GREATER
19805: IFFALSE 19809
// break ;
19807: GO 19918
// x := personel [ i ] ;
19809: LD_ADDR_VAR 0 13
19813: PUSH
19814: LD_VAR 0 6
19818: PUSH
19819: LD_VAR 0 8
19823: ARRAY
19824: ST_TO_ADDR
// if x = - 1 then
19825: LD_VAR 0 13
19829: PUSH
19830: LD_INT 1
19832: NEG
19833: EQUAL
19834: IFFALSE 19838
// continue ;
19836: GO 19794
// PrepareHuman ( false , i , skill ) ;
19838: LD_INT 0
19840: PPUSH
19841: LD_VAR 0 8
19845: PPUSH
19846: LD_VAR 0 4
19850: PPUSH
19851: CALL_OW 380
// un := CreateHuman ;
19855: LD_ADDR_VAR 0 14
19859: PUSH
19860: CALL_OW 44
19864: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19865: LD_VAR 0 14
19869: PPUSH
19870: LD_VAR 0 1
19874: PPUSH
19875: CALL_OW 250
19879: PPUSH
19880: LD_VAR 0 1
19884: PPUSH
19885: CALL_OW 251
19889: PPUSH
19890: LD_INT 10
19892: PPUSH
19893: LD_INT 0
19895: PPUSH
19896: CALL_OW 50
// result := result ^ un ;
19900: LD_ADDR_VAR 0 7
19904: PUSH
19905: LD_VAR 0 7
19909: PUSH
19910: LD_VAR 0 14
19914: ADD
19915: ST_TO_ADDR
// end ;
19916: GO 19794
19918: POP
19919: POP
// end ; end ;
19920: LD_VAR 0 7
19924: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19925: LD_INT 0
19927: PPUSH
19928: PPUSH
19929: PPUSH
19930: PPUSH
19931: PPUSH
19932: PPUSH
19933: PPUSH
19934: PPUSH
19935: PPUSH
19936: PPUSH
19937: PPUSH
19938: PPUSH
19939: PPUSH
19940: PPUSH
19941: PPUSH
19942: PPUSH
// result := false ;
19943: LD_ADDR_VAR 0 3
19947: PUSH
19948: LD_INT 0
19950: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 266
19966: PUSH
19967: LD_INT 32
19969: PUSH
19970: LD_INT 33
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: IN
19977: NOT
19978: OR
19979: IFFALSE 19983
// exit ;
19981: GO 21092
// nat := GetNation ( tower ) ;
19983: LD_ADDR_VAR 0 12
19987: PUSH
19988: LD_VAR 0 1
19992: PPUSH
19993: CALL_OW 248
19997: ST_TO_ADDR
// side := GetSide ( tower ) ;
19998: LD_ADDR_VAR 0 16
20002: PUSH
20003: LD_VAR 0 1
20007: PPUSH
20008: CALL_OW 255
20012: ST_TO_ADDR
// x := GetX ( tower ) ;
20013: LD_ADDR_VAR 0 10
20017: PUSH
20018: LD_VAR 0 1
20022: PPUSH
20023: CALL_OW 250
20027: ST_TO_ADDR
// y := GetY ( tower ) ;
20028: LD_ADDR_VAR 0 11
20032: PUSH
20033: LD_VAR 0 1
20037: PPUSH
20038: CALL_OW 251
20042: ST_TO_ADDR
// if not x or not y then
20043: LD_VAR 0 10
20047: NOT
20048: PUSH
20049: LD_VAR 0 11
20053: NOT
20054: OR
20055: IFFALSE 20059
// exit ;
20057: GO 21092
// weapon := 0 ;
20059: LD_ADDR_VAR 0 18
20063: PUSH
20064: LD_INT 0
20066: ST_TO_ADDR
// fac_list := [ ] ;
20067: LD_ADDR_VAR 0 17
20071: PUSH
20072: EMPTY
20073: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20074: LD_ADDR_VAR 0 6
20078: PUSH
20079: LD_VAR 0 1
20083: PPUSH
20084: CALL_OW 274
20088: PPUSH
20089: LD_VAR 0 2
20093: PPUSH
20094: LD_INT 0
20096: PPUSH
20097: CALL 17663 0 3
20101: PPUSH
20102: LD_INT 30
20104: PUSH
20105: LD_INT 3
20107: PUSH
20108: EMPTY
20109: LIST
20110: LIST
20111: PPUSH
20112: CALL_OW 72
20116: ST_TO_ADDR
// if not factories then
20117: LD_VAR 0 6
20121: NOT
20122: IFFALSE 20126
// exit ;
20124: GO 21092
// for i in factories do
20126: LD_ADDR_VAR 0 8
20130: PUSH
20131: LD_VAR 0 6
20135: PUSH
20136: FOR_IN
20137: IFFALSE 20162
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20139: LD_ADDR_VAR 0 17
20143: PUSH
20144: LD_VAR 0 17
20148: PUSH
20149: LD_VAR 0 8
20153: PPUSH
20154: CALL_OW 478
20158: UNION
20159: ST_TO_ADDR
20160: GO 20136
20162: POP
20163: POP
// if not fac_list then
20164: LD_VAR 0 17
20168: NOT
20169: IFFALSE 20173
// exit ;
20171: GO 21092
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20173: LD_ADDR_VAR 0 5
20177: PUSH
20178: LD_INT 4
20180: PUSH
20181: LD_INT 5
20183: PUSH
20184: LD_INT 9
20186: PUSH
20187: LD_INT 10
20189: PUSH
20190: LD_INT 6
20192: PUSH
20193: LD_INT 7
20195: PUSH
20196: LD_INT 11
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: PUSH
20208: LD_INT 27
20210: PUSH
20211: LD_INT 28
20213: PUSH
20214: LD_INT 26
20216: PUSH
20217: LD_INT 30
20219: PUSH
20220: EMPTY
20221: LIST
20222: LIST
20223: LIST
20224: LIST
20225: PUSH
20226: LD_INT 43
20228: PUSH
20229: LD_INT 44
20231: PUSH
20232: LD_INT 46
20234: PUSH
20235: LD_INT 45
20237: PUSH
20238: LD_INT 47
20240: PUSH
20241: LD_INT 49
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: LIST
20251: PUSH
20252: EMPTY
20253: LIST
20254: LIST
20255: LIST
20256: PUSH
20257: LD_VAR 0 12
20261: ARRAY
20262: ST_TO_ADDR
// list := list isect fac_list ;
20263: LD_ADDR_VAR 0 5
20267: PUSH
20268: LD_VAR 0 5
20272: PUSH
20273: LD_VAR 0 17
20277: ISECT
20278: ST_TO_ADDR
// if not list then
20279: LD_VAR 0 5
20283: NOT
20284: IFFALSE 20288
// exit ;
20286: GO 21092
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20288: LD_VAR 0 12
20292: PUSH
20293: LD_INT 3
20295: EQUAL
20296: PUSH
20297: LD_INT 49
20299: PUSH
20300: LD_VAR 0 5
20304: IN
20305: AND
20306: PUSH
20307: LD_INT 31
20309: PPUSH
20310: LD_VAR 0 16
20314: PPUSH
20315: CALL_OW 321
20319: PUSH
20320: LD_INT 2
20322: EQUAL
20323: AND
20324: IFFALSE 20384
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20326: LD_INT 22
20328: PUSH
20329: LD_VAR 0 16
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: PUSH
20338: LD_INT 35
20340: PUSH
20341: LD_INT 49
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: PUSH
20348: LD_INT 91
20350: PUSH
20351: LD_VAR 0 1
20355: PUSH
20356: LD_INT 10
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: LIST
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: LIST
20368: PPUSH
20369: CALL_OW 69
20373: NOT
20374: IFFALSE 20384
// weapon := ru_time_lapser ;
20376: LD_ADDR_VAR 0 18
20380: PUSH
20381: LD_INT 49
20383: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20384: LD_VAR 0 12
20388: PUSH
20389: LD_INT 1
20391: PUSH
20392: LD_INT 2
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: IN
20399: PUSH
20400: LD_INT 11
20402: PUSH
20403: LD_VAR 0 5
20407: IN
20408: PUSH
20409: LD_INT 30
20411: PUSH
20412: LD_VAR 0 5
20416: IN
20417: OR
20418: AND
20419: PUSH
20420: LD_INT 6
20422: PPUSH
20423: LD_VAR 0 16
20427: PPUSH
20428: CALL_OW 321
20432: PUSH
20433: LD_INT 2
20435: EQUAL
20436: AND
20437: IFFALSE 20602
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20439: LD_INT 22
20441: PUSH
20442: LD_VAR 0 16
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 35
20456: PUSH
20457: LD_INT 11
20459: PUSH
20460: EMPTY
20461: LIST
20462: LIST
20463: PUSH
20464: LD_INT 35
20466: PUSH
20467: LD_INT 30
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: PUSH
20474: EMPTY
20475: LIST
20476: LIST
20477: LIST
20478: PUSH
20479: LD_INT 91
20481: PUSH
20482: LD_VAR 0 1
20486: PUSH
20487: LD_INT 18
20489: PUSH
20490: EMPTY
20491: LIST
20492: LIST
20493: LIST
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: NOT
20505: PUSH
20506: LD_INT 22
20508: PUSH
20509: LD_VAR 0 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: LD_INT 2
20520: PUSH
20521: LD_INT 30
20523: PUSH
20524: LD_INT 32
20526: PUSH
20527: EMPTY
20528: LIST
20529: LIST
20530: PUSH
20531: LD_INT 30
20533: PUSH
20534: LD_INT 33
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: PUSH
20546: LD_INT 91
20548: PUSH
20549: LD_VAR 0 1
20553: PUSH
20554: LD_INT 12
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: LIST
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: LIST
20566: PUSH
20567: EMPTY
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 2
20577: GREATER
20578: AND
20579: IFFALSE 20602
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20581: LD_ADDR_VAR 0 18
20585: PUSH
20586: LD_INT 11
20588: PUSH
20589: LD_INT 30
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_VAR 0 12
20600: ARRAY
20601: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20602: LD_VAR 0 18
20606: NOT
20607: PUSH
20608: LD_INT 40
20610: PPUSH
20611: LD_VAR 0 16
20615: PPUSH
20616: CALL_OW 321
20620: PUSH
20621: LD_INT 2
20623: EQUAL
20624: AND
20625: PUSH
20626: LD_INT 7
20628: PUSH
20629: LD_VAR 0 5
20633: IN
20634: PUSH
20635: LD_INT 28
20637: PUSH
20638: LD_VAR 0 5
20642: IN
20643: OR
20644: PUSH
20645: LD_INT 45
20647: PUSH
20648: LD_VAR 0 5
20652: IN
20653: OR
20654: AND
20655: IFFALSE 20909
// begin hex := GetHexInfo ( x , y ) ;
20657: LD_ADDR_VAR 0 4
20661: PUSH
20662: LD_VAR 0 10
20666: PPUSH
20667: LD_VAR 0 11
20671: PPUSH
20672: CALL_OW 546
20676: ST_TO_ADDR
// if hex [ 1 ] then
20677: LD_VAR 0 4
20681: PUSH
20682: LD_INT 1
20684: ARRAY
20685: IFFALSE 20689
// exit ;
20687: GO 21092
// height := hex [ 2 ] ;
20689: LD_ADDR_VAR 0 15
20693: PUSH
20694: LD_VAR 0 4
20698: PUSH
20699: LD_INT 2
20701: ARRAY
20702: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20703: LD_ADDR_VAR 0 14
20707: PUSH
20708: LD_INT 0
20710: PUSH
20711: LD_INT 2
20713: PUSH
20714: LD_INT 3
20716: PUSH
20717: LD_INT 5
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: LIST
20724: LIST
20725: ST_TO_ADDR
// for i in tmp do
20726: LD_ADDR_VAR 0 8
20730: PUSH
20731: LD_VAR 0 14
20735: PUSH
20736: FOR_IN
20737: IFFALSE 20907
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20739: LD_ADDR_VAR 0 9
20743: PUSH
20744: LD_VAR 0 10
20748: PPUSH
20749: LD_VAR 0 8
20753: PPUSH
20754: LD_INT 5
20756: PPUSH
20757: CALL_OW 272
20761: PUSH
20762: LD_VAR 0 11
20766: PPUSH
20767: LD_VAR 0 8
20771: PPUSH
20772: LD_INT 5
20774: PPUSH
20775: CALL_OW 273
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20784: LD_VAR 0 9
20788: PUSH
20789: LD_INT 1
20791: ARRAY
20792: PPUSH
20793: LD_VAR 0 9
20797: PUSH
20798: LD_INT 2
20800: ARRAY
20801: PPUSH
20802: CALL_OW 488
20806: IFFALSE 20905
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20808: LD_ADDR_VAR 0 4
20812: PUSH
20813: LD_VAR 0 9
20817: PUSH
20818: LD_INT 1
20820: ARRAY
20821: PPUSH
20822: LD_VAR 0 9
20826: PUSH
20827: LD_INT 2
20829: ARRAY
20830: PPUSH
20831: CALL_OW 546
20835: ST_TO_ADDR
// if hex [ 1 ] then
20836: LD_VAR 0 4
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: IFFALSE 20848
// continue ;
20846: GO 20736
// h := hex [ 2 ] ;
20848: LD_ADDR_VAR 0 13
20852: PUSH
20853: LD_VAR 0 4
20857: PUSH
20858: LD_INT 2
20860: ARRAY
20861: ST_TO_ADDR
// if h + 7 < height then
20862: LD_VAR 0 13
20866: PUSH
20867: LD_INT 7
20869: PLUS
20870: PUSH
20871: LD_VAR 0 15
20875: LESS
20876: IFFALSE 20905
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20878: LD_ADDR_VAR 0 18
20882: PUSH
20883: LD_INT 7
20885: PUSH
20886: LD_INT 28
20888: PUSH
20889: LD_INT 45
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: LIST
20896: PUSH
20897: LD_VAR 0 12
20901: ARRAY
20902: ST_TO_ADDR
// break ;
20903: GO 20907
// end ; end ; end ;
20905: GO 20736
20907: POP
20908: POP
// end ; if not weapon then
20909: LD_VAR 0 18
20913: NOT
20914: IFFALSE 20974
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20916: LD_ADDR_VAR 0 5
20920: PUSH
20921: LD_VAR 0 5
20925: PUSH
20926: LD_INT 11
20928: PUSH
20929: LD_INT 30
20931: PUSH
20932: LD_INT 49
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: LIST
20939: DIFF
20940: ST_TO_ADDR
// if not list then
20941: LD_VAR 0 5
20945: NOT
20946: IFFALSE 20950
// exit ;
20948: GO 21092
// weapon := list [ rand ( 1 , list ) ] ;
20950: LD_ADDR_VAR 0 18
20954: PUSH
20955: LD_VAR 0 5
20959: PUSH
20960: LD_INT 1
20962: PPUSH
20963: LD_VAR 0 5
20967: PPUSH
20968: CALL_OW 12
20972: ARRAY
20973: ST_TO_ADDR
// end ; if weapon then
20974: LD_VAR 0 18
20978: IFFALSE 21092
// begin tmp := CostOfWeapon ( weapon ) ;
20980: LD_ADDR_VAR 0 14
20984: PUSH
20985: LD_VAR 0 18
20989: PPUSH
20990: CALL_OW 451
20994: ST_TO_ADDR
// j := GetBase ( tower ) ;
20995: LD_ADDR_VAR 0 9
20999: PUSH
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 274
21009: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21010: LD_VAR 0 9
21014: PPUSH
21015: LD_INT 1
21017: PPUSH
21018: CALL_OW 275
21022: PUSH
21023: LD_VAR 0 14
21027: PUSH
21028: LD_INT 1
21030: ARRAY
21031: GREATEREQUAL
21032: PUSH
21033: LD_VAR 0 9
21037: PPUSH
21038: LD_INT 2
21040: PPUSH
21041: CALL_OW 275
21045: PUSH
21046: LD_VAR 0 14
21050: PUSH
21051: LD_INT 2
21053: ARRAY
21054: GREATEREQUAL
21055: AND
21056: PUSH
21057: LD_VAR 0 9
21061: PPUSH
21062: LD_INT 3
21064: PPUSH
21065: CALL_OW 275
21069: PUSH
21070: LD_VAR 0 14
21074: PUSH
21075: LD_INT 3
21077: ARRAY
21078: GREATEREQUAL
21079: AND
21080: IFFALSE 21092
// result := weapon ;
21082: LD_ADDR_VAR 0 3
21086: PUSH
21087: LD_VAR 0 18
21091: ST_TO_ADDR
// end ; end ;
21092: LD_VAR 0 3
21096: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21097: LD_INT 0
21099: PPUSH
21100: PPUSH
// result := true ;
21101: LD_ADDR_VAR 0 3
21105: PUSH
21106: LD_INT 1
21108: ST_TO_ADDR
// if array1 = array2 then
21109: LD_VAR 0 1
21113: PUSH
21114: LD_VAR 0 2
21118: EQUAL
21119: IFFALSE 21179
// begin for i = 1 to array1 do
21121: LD_ADDR_VAR 0 4
21125: PUSH
21126: DOUBLE
21127: LD_INT 1
21129: DEC
21130: ST_TO_ADDR
21131: LD_VAR 0 1
21135: PUSH
21136: FOR_TO
21137: IFFALSE 21175
// if array1 [ i ] <> array2 [ i ] then
21139: LD_VAR 0 1
21143: PUSH
21144: LD_VAR 0 4
21148: ARRAY
21149: PUSH
21150: LD_VAR 0 2
21154: PUSH
21155: LD_VAR 0 4
21159: ARRAY
21160: NONEQUAL
21161: IFFALSE 21173
// begin result := false ;
21163: LD_ADDR_VAR 0 3
21167: PUSH
21168: LD_INT 0
21170: ST_TO_ADDR
// break ;
21171: GO 21175
// end ;
21173: GO 21136
21175: POP
21176: POP
// end else
21177: GO 21187
// result := false ;
21179: LD_ADDR_VAR 0 3
21183: PUSH
21184: LD_INT 0
21186: ST_TO_ADDR
// end ;
21187: LD_VAR 0 3
21191: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21192: LD_INT 0
21194: PPUSH
21195: PPUSH
// if not array1 or not array2 then
21196: LD_VAR 0 1
21200: NOT
21201: PUSH
21202: LD_VAR 0 2
21206: NOT
21207: OR
21208: IFFALSE 21212
// exit ;
21210: GO 21276
// result := true ;
21212: LD_ADDR_VAR 0 3
21216: PUSH
21217: LD_INT 1
21219: ST_TO_ADDR
// for i = 1 to array1 do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: DOUBLE
21226: LD_INT 1
21228: DEC
21229: ST_TO_ADDR
21230: LD_VAR 0 1
21234: PUSH
21235: FOR_TO
21236: IFFALSE 21274
// if array1 [ i ] <> array2 [ i ] then
21238: LD_VAR 0 1
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PUSH
21249: LD_VAR 0 2
21253: PUSH
21254: LD_VAR 0 4
21258: ARRAY
21259: NONEQUAL
21260: IFFALSE 21272
// begin result := false ;
21262: LD_ADDR_VAR 0 3
21266: PUSH
21267: LD_INT 0
21269: ST_TO_ADDR
// break ;
21270: GO 21274
// end ;
21272: GO 21235
21274: POP
21275: POP
// end ;
21276: LD_VAR 0 3
21280: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21281: LD_INT 0
21283: PPUSH
21284: PPUSH
21285: PPUSH
// pom := GetBase ( fac ) ;
21286: LD_ADDR_VAR 0 5
21290: PUSH
21291: LD_VAR 0 1
21295: PPUSH
21296: CALL_OW 274
21300: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21301: LD_ADDR_VAR 0 4
21305: PUSH
21306: LD_VAR 0 2
21310: PUSH
21311: LD_INT 1
21313: ARRAY
21314: PPUSH
21315: LD_VAR 0 2
21319: PUSH
21320: LD_INT 2
21322: ARRAY
21323: PPUSH
21324: LD_VAR 0 2
21328: PUSH
21329: LD_INT 3
21331: ARRAY
21332: PPUSH
21333: LD_VAR 0 2
21337: PUSH
21338: LD_INT 4
21340: ARRAY
21341: PPUSH
21342: CALL_OW 449
21346: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21347: LD_ADDR_VAR 0 3
21351: PUSH
21352: LD_VAR 0 5
21356: PPUSH
21357: LD_INT 1
21359: PPUSH
21360: CALL_OW 275
21364: PUSH
21365: LD_VAR 0 4
21369: PUSH
21370: LD_INT 1
21372: ARRAY
21373: GREATEREQUAL
21374: PUSH
21375: LD_VAR 0 5
21379: PPUSH
21380: LD_INT 2
21382: PPUSH
21383: CALL_OW 275
21387: PUSH
21388: LD_VAR 0 4
21392: PUSH
21393: LD_INT 2
21395: ARRAY
21396: GREATEREQUAL
21397: AND
21398: PUSH
21399: LD_VAR 0 5
21403: PPUSH
21404: LD_INT 3
21406: PPUSH
21407: CALL_OW 275
21411: PUSH
21412: LD_VAR 0 4
21416: PUSH
21417: LD_INT 3
21419: ARRAY
21420: GREATEREQUAL
21421: AND
21422: ST_TO_ADDR
// end ;
21423: LD_VAR 0 3
21427: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21428: LD_INT 0
21430: PPUSH
21431: PPUSH
21432: PPUSH
21433: PPUSH
// pom := GetBase ( building ) ;
21434: LD_ADDR_VAR 0 3
21438: PUSH
21439: LD_VAR 0 1
21443: PPUSH
21444: CALL_OW 274
21448: ST_TO_ADDR
// if not pom then
21449: LD_VAR 0 3
21453: NOT
21454: IFFALSE 21458
// exit ;
21456: GO 21628
// btype := GetBType ( building ) ;
21458: LD_ADDR_VAR 0 5
21462: PUSH
21463: LD_VAR 0 1
21467: PPUSH
21468: CALL_OW 266
21472: ST_TO_ADDR
// if btype = b_armoury then
21473: LD_VAR 0 5
21477: PUSH
21478: LD_INT 4
21480: EQUAL
21481: IFFALSE 21491
// btype := b_barracks ;
21483: LD_ADDR_VAR 0 5
21487: PUSH
21488: LD_INT 5
21490: ST_TO_ADDR
// if btype = b_depot then
21491: LD_VAR 0 5
21495: PUSH
21496: LD_INT 0
21498: EQUAL
21499: IFFALSE 21509
// btype := b_warehouse ;
21501: LD_ADDR_VAR 0 5
21505: PUSH
21506: LD_INT 1
21508: ST_TO_ADDR
// if btype = b_workshop then
21509: LD_VAR 0 5
21513: PUSH
21514: LD_INT 2
21516: EQUAL
21517: IFFALSE 21527
// btype := b_factory ;
21519: LD_ADDR_VAR 0 5
21523: PUSH
21524: LD_INT 3
21526: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21527: LD_ADDR_VAR 0 4
21531: PUSH
21532: LD_VAR 0 5
21536: PPUSH
21537: LD_VAR 0 1
21541: PPUSH
21542: CALL_OW 248
21546: PPUSH
21547: CALL_OW 450
21551: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21552: LD_ADDR_VAR 0 2
21556: PUSH
21557: LD_VAR 0 3
21561: PPUSH
21562: LD_INT 1
21564: PPUSH
21565: CALL_OW 275
21569: PUSH
21570: LD_VAR 0 4
21574: PUSH
21575: LD_INT 1
21577: ARRAY
21578: GREATEREQUAL
21579: PUSH
21580: LD_VAR 0 3
21584: PPUSH
21585: LD_INT 2
21587: PPUSH
21588: CALL_OW 275
21592: PUSH
21593: LD_VAR 0 4
21597: PUSH
21598: LD_INT 2
21600: ARRAY
21601: GREATEREQUAL
21602: AND
21603: PUSH
21604: LD_VAR 0 3
21608: PPUSH
21609: LD_INT 3
21611: PPUSH
21612: CALL_OW 275
21616: PUSH
21617: LD_VAR 0 4
21621: PUSH
21622: LD_INT 3
21624: ARRAY
21625: GREATEREQUAL
21626: AND
21627: ST_TO_ADDR
// end ;
21628: LD_VAR 0 2
21632: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21633: LD_INT 0
21635: PPUSH
21636: PPUSH
21637: PPUSH
// pom := GetBase ( building ) ;
21638: LD_ADDR_VAR 0 4
21642: PUSH
21643: LD_VAR 0 1
21647: PPUSH
21648: CALL_OW 274
21652: ST_TO_ADDR
// if not pom then
21653: LD_VAR 0 4
21657: NOT
21658: IFFALSE 21662
// exit ;
21660: GO 21763
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21662: LD_ADDR_VAR 0 5
21666: PUSH
21667: LD_VAR 0 2
21671: PPUSH
21672: LD_VAR 0 1
21676: PPUSH
21677: CALL_OW 248
21681: PPUSH
21682: CALL_OW 450
21686: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21687: LD_ADDR_VAR 0 3
21691: PUSH
21692: LD_VAR 0 4
21696: PPUSH
21697: LD_INT 1
21699: PPUSH
21700: CALL_OW 275
21704: PUSH
21705: LD_VAR 0 5
21709: PUSH
21710: LD_INT 1
21712: ARRAY
21713: GREATEREQUAL
21714: PUSH
21715: LD_VAR 0 4
21719: PPUSH
21720: LD_INT 2
21722: PPUSH
21723: CALL_OW 275
21727: PUSH
21728: LD_VAR 0 5
21732: PUSH
21733: LD_INT 2
21735: ARRAY
21736: GREATEREQUAL
21737: AND
21738: PUSH
21739: LD_VAR 0 4
21743: PPUSH
21744: LD_INT 3
21746: PPUSH
21747: CALL_OW 275
21751: PUSH
21752: LD_VAR 0 5
21756: PUSH
21757: LD_INT 3
21759: ARRAY
21760: GREATEREQUAL
21761: AND
21762: ST_TO_ADDR
// end ;
21763: LD_VAR 0 3
21767: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21768: LD_INT 0
21770: PPUSH
21771: PPUSH
21772: PPUSH
21773: PPUSH
21774: PPUSH
21775: PPUSH
21776: PPUSH
21777: PPUSH
21778: PPUSH
21779: PPUSH
21780: PPUSH
// result := false ;
21781: LD_ADDR_VAR 0 8
21785: PUSH
21786: LD_INT 0
21788: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21789: LD_VAR 0 5
21793: NOT
21794: PUSH
21795: LD_VAR 0 1
21799: NOT
21800: OR
21801: PUSH
21802: LD_VAR 0 2
21806: NOT
21807: OR
21808: PUSH
21809: LD_VAR 0 3
21813: NOT
21814: OR
21815: IFFALSE 21819
// exit ;
21817: GO 22633
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21819: LD_ADDR_VAR 0 14
21823: PUSH
21824: LD_VAR 0 1
21828: PPUSH
21829: LD_VAR 0 2
21833: PPUSH
21834: LD_VAR 0 3
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: LD_VAR 0 5
21848: PUSH
21849: LD_INT 1
21851: ARRAY
21852: PPUSH
21853: CALL_OW 248
21857: PPUSH
21858: LD_INT 0
21860: PPUSH
21861: CALL 23866 0 6
21865: ST_TO_ADDR
// if not hexes then
21866: LD_VAR 0 14
21870: NOT
21871: IFFALSE 21875
// exit ;
21873: GO 22633
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21875: LD_ADDR_VAR 0 17
21879: PUSH
21880: LD_VAR 0 5
21884: PPUSH
21885: LD_INT 22
21887: PUSH
21888: LD_VAR 0 13
21892: PPUSH
21893: CALL_OW 255
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: PUSH
21902: LD_INT 2
21904: PUSH
21905: LD_INT 30
21907: PUSH
21908: LD_INT 0
21910: PUSH
21911: EMPTY
21912: LIST
21913: LIST
21914: PUSH
21915: LD_INT 30
21917: PUSH
21918: LD_INT 1
21920: PUSH
21921: EMPTY
21922: LIST
21923: LIST
21924: PUSH
21925: EMPTY
21926: LIST
21927: LIST
21928: LIST
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PPUSH
21934: CALL_OW 72
21938: ST_TO_ADDR
// for i = 1 to hexes do
21939: LD_ADDR_VAR 0 9
21943: PUSH
21944: DOUBLE
21945: LD_INT 1
21947: DEC
21948: ST_TO_ADDR
21949: LD_VAR 0 14
21953: PUSH
21954: FOR_TO
21955: IFFALSE 22631
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21957: LD_ADDR_VAR 0 13
21961: PUSH
21962: LD_VAR 0 14
21966: PUSH
21967: LD_VAR 0 9
21971: ARRAY
21972: PUSH
21973: LD_INT 1
21975: ARRAY
21976: PPUSH
21977: LD_VAR 0 14
21981: PUSH
21982: LD_VAR 0 9
21986: ARRAY
21987: PUSH
21988: LD_INT 2
21990: ARRAY
21991: PPUSH
21992: CALL_OW 428
21996: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21997: LD_VAR 0 14
22001: PUSH
22002: LD_VAR 0 9
22006: ARRAY
22007: PUSH
22008: LD_INT 1
22010: ARRAY
22011: PPUSH
22012: LD_VAR 0 14
22016: PUSH
22017: LD_VAR 0 9
22021: ARRAY
22022: PUSH
22023: LD_INT 2
22025: ARRAY
22026: PPUSH
22027: CALL_OW 351
22031: PUSH
22032: LD_VAR 0 14
22036: PUSH
22037: LD_VAR 0 9
22041: ARRAY
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PPUSH
22047: LD_VAR 0 14
22051: PUSH
22052: LD_VAR 0 9
22056: ARRAY
22057: PUSH
22058: LD_INT 2
22060: ARRAY
22061: PPUSH
22062: CALL_OW 488
22066: NOT
22067: OR
22068: PUSH
22069: LD_VAR 0 13
22073: PPUSH
22074: CALL_OW 247
22078: PUSH
22079: LD_INT 3
22081: EQUAL
22082: OR
22083: IFFALSE 22089
// exit ;
22085: POP
22086: POP
22087: GO 22633
// if not tmp then
22089: LD_VAR 0 13
22093: NOT
22094: IFFALSE 22098
// continue ;
22096: GO 21954
// result := true ;
22098: LD_ADDR_VAR 0 8
22102: PUSH
22103: LD_INT 1
22105: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22106: LD_VAR 0 6
22110: PUSH
22111: LD_VAR 0 13
22115: PPUSH
22116: CALL_OW 247
22120: PUSH
22121: LD_INT 2
22123: EQUAL
22124: AND
22125: PUSH
22126: LD_VAR 0 13
22130: PPUSH
22131: CALL_OW 263
22135: PUSH
22136: LD_INT 1
22138: EQUAL
22139: AND
22140: IFFALSE 22304
// begin if IsDrivenBy ( tmp ) then
22142: LD_VAR 0 13
22146: PPUSH
22147: CALL_OW 311
22151: IFFALSE 22155
// continue ;
22153: GO 21954
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22155: LD_VAR 0 6
22159: PPUSH
22160: LD_INT 3
22162: PUSH
22163: LD_INT 60
22165: PUSH
22166: EMPTY
22167: LIST
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: PUSH
22173: LD_INT 3
22175: PUSH
22176: LD_INT 55
22178: PUSH
22179: EMPTY
22180: LIST
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: PPUSH
22190: CALL_OW 72
22194: IFFALSE 22302
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22196: LD_ADDR_VAR 0 18
22200: PUSH
22201: LD_VAR 0 6
22205: PPUSH
22206: LD_INT 3
22208: PUSH
22209: LD_INT 60
22211: PUSH
22212: EMPTY
22213: LIST
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: PUSH
22219: LD_INT 3
22221: PUSH
22222: LD_INT 55
22224: PUSH
22225: EMPTY
22226: LIST
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PPUSH
22236: CALL_OW 72
22240: PUSH
22241: LD_INT 1
22243: ARRAY
22244: ST_TO_ADDR
// if IsInUnit ( driver ) then
22245: LD_VAR 0 18
22249: PPUSH
22250: CALL_OW 310
22254: IFFALSE 22265
// ComExit ( driver ) ;
22256: LD_VAR 0 18
22260: PPUSH
22261: CALL 47645 0 1
// AddComEnterUnit ( driver , tmp ) ;
22265: LD_VAR 0 18
22269: PPUSH
22270: LD_VAR 0 13
22274: PPUSH
22275: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22279: LD_VAR 0 18
22283: PPUSH
22284: LD_VAR 0 7
22288: PPUSH
22289: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22293: LD_VAR 0 18
22297: PPUSH
22298: CALL_OW 181
// end ; continue ;
22302: GO 21954
// end ; if not cleaners or not tmp in cleaners then
22304: LD_VAR 0 6
22308: NOT
22309: PUSH
22310: LD_VAR 0 13
22314: PUSH
22315: LD_VAR 0 6
22319: IN
22320: NOT
22321: OR
22322: IFFALSE 22629
// begin if dep then
22324: LD_VAR 0 17
22328: IFFALSE 22464
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22330: LD_ADDR_VAR 0 16
22334: PUSH
22335: LD_VAR 0 17
22339: PUSH
22340: LD_INT 1
22342: ARRAY
22343: PPUSH
22344: CALL_OW 250
22348: PPUSH
22349: LD_VAR 0 17
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: PPUSH
22358: CALL_OW 254
22362: PPUSH
22363: LD_INT 5
22365: PPUSH
22366: CALL_OW 272
22370: PUSH
22371: LD_VAR 0 17
22375: PUSH
22376: LD_INT 1
22378: ARRAY
22379: PPUSH
22380: CALL_OW 251
22384: PPUSH
22385: LD_VAR 0 17
22389: PUSH
22390: LD_INT 1
22392: ARRAY
22393: PPUSH
22394: CALL_OW 254
22398: PPUSH
22399: LD_INT 5
22401: PPUSH
22402: CALL_OW 273
22406: PUSH
22407: EMPTY
22408: LIST
22409: LIST
22410: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22411: LD_VAR 0 16
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: LD_VAR 0 16
22424: PUSH
22425: LD_INT 2
22427: ARRAY
22428: PPUSH
22429: CALL_OW 488
22433: IFFALSE 22464
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22435: LD_VAR 0 13
22439: PPUSH
22440: LD_VAR 0 16
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: PPUSH
22449: LD_VAR 0 16
22453: PUSH
22454: LD_INT 2
22456: ARRAY
22457: PPUSH
22458: CALL_OW 111
// continue ;
22462: GO 21954
// end ; end ; r := GetDir ( tmp ) ;
22464: LD_ADDR_VAR 0 15
22468: PUSH
22469: LD_VAR 0 13
22473: PPUSH
22474: CALL_OW 254
22478: ST_TO_ADDR
// if r = 5 then
22479: LD_VAR 0 15
22483: PUSH
22484: LD_INT 5
22486: EQUAL
22487: IFFALSE 22497
// r := 0 ;
22489: LD_ADDR_VAR 0 15
22493: PUSH
22494: LD_INT 0
22496: ST_TO_ADDR
// for j = r to 5 do
22497: LD_ADDR_VAR 0 10
22501: PUSH
22502: DOUBLE
22503: LD_VAR 0 15
22507: DEC
22508: ST_TO_ADDR
22509: LD_INT 5
22511: PUSH
22512: FOR_TO
22513: IFFALSE 22627
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22515: LD_ADDR_VAR 0 11
22519: PUSH
22520: LD_VAR 0 13
22524: PPUSH
22525: CALL_OW 250
22529: PPUSH
22530: LD_VAR 0 10
22534: PPUSH
22535: LD_INT 2
22537: PPUSH
22538: CALL_OW 272
22542: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22543: LD_ADDR_VAR 0 12
22547: PUSH
22548: LD_VAR 0 13
22552: PPUSH
22553: CALL_OW 251
22557: PPUSH
22558: LD_VAR 0 10
22562: PPUSH
22563: LD_INT 2
22565: PPUSH
22566: CALL_OW 273
22570: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22571: LD_VAR 0 11
22575: PPUSH
22576: LD_VAR 0 12
22580: PPUSH
22581: CALL_OW 488
22585: PUSH
22586: LD_VAR 0 11
22590: PPUSH
22591: LD_VAR 0 12
22595: PPUSH
22596: CALL_OW 428
22600: NOT
22601: AND
22602: IFFALSE 22625
// begin ComMoveXY ( tmp , _x , _y ) ;
22604: LD_VAR 0 13
22608: PPUSH
22609: LD_VAR 0 11
22613: PPUSH
22614: LD_VAR 0 12
22618: PPUSH
22619: CALL_OW 111
// break ;
22623: GO 22627
// end ; end ;
22625: GO 22512
22627: POP
22628: POP
// end ; end ;
22629: GO 21954
22631: POP
22632: POP
// end ;
22633: LD_VAR 0 8
22637: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22638: LD_INT 0
22640: PPUSH
// result := true ;
22641: LD_ADDR_VAR 0 3
22645: PUSH
22646: LD_INT 1
22648: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22649: LD_VAR 0 2
22653: PUSH
22654: LD_INT 24
22656: DOUBLE
22657: EQUAL
22658: IFTRUE 22668
22660: LD_INT 33
22662: DOUBLE
22663: EQUAL
22664: IFTRUE 22668
22666: GO 22693
22668: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22669: LD_ADDR_VAR 0 3
22673: PUSH
22674: LD_INT 32
22676: PPUSH
22677: LD_VAR 0 1
22681: PPUSH
22682: CALL_OW 321
22686: PUSH
22687: LD_INT 2
22689: EQUAL
22690: ST_TO_ADDR
22691: GO 23009
22693: LD_INT 20
22695: DOUBLE
22696: EQUAL
22697: IFTRUE 22701
22699: GO 22726
22701: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22702: LD_ADDR_VAR 0 3
22706: PUSH
22707: LD_INT 6
22709: PPUSH
22710: LD_VAR 0 1
22714: PPUSH
22715: CALL_OW 321
22719: PUSH
22720: LD_INT 2
22722: EQUAL
22723: ST_TO_ADDR
22724: GO 23009
22726: LD_INT 22
22728: DOUBLE
22729: EQUAL
22730: IFTRUE 22740
22732: LD_INT 36
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22765
22740: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22741: LD_ADDR_VAR 0 3
22745: PUSH
22746: LD_INT 15
22748: PPUSH
22749: LD_VAR 0 1
22753: PPUSH
22754: CALL_OW 321
22758: PUSH
22759: LD_INT 2
22761: EQUAL
22762: ST_TO_ADDR
22763: GO 23009
22765: LD_INT 30
22767: DOUBLE
22768: EQUAL
22769: IFTRUE 22773
22771: GO 22798
22773: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22774: LD_ADDR_VAR 0 3
22778: PUSH
22779: LD_INT 20
22781: PPUSH
22782: LD_VAR 0 1
22786: PPUSH
22787: CALL_OW 321
22791: PUSH
22792: LD_INT 2
22794: EQUAL
22795: ST_TO_ADDR
22796: GO 23009
22798: LD_INT 28
22800: DOUBLE
22801: EQUAL
22802: IFTRUE 22812
22804: LD_INT 21
22806: DOUBLE
22807: EQUAL
22808: IFTRUE 22812
22810: GO 22837
22812: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22813: LD_ADDR_VAR 0 3
22817: PUSH
22818: LD_INT 21
22820: PPUSH
22821: LD_VAR 0 1
22825: PPUSH
22826: CALL_OW 321
22830: PUSH
22831: LD_INT 2
22833: EQUAL
22834: ST_TO_ADDR
22835: GO 23009
22837: LD_INT 16
22839: DOUBLE
22840: EQUAL
22841: IFTRUE 22845
22843: GO 22870
22845: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22846: LD_ADDR_VAR 0 3
22850: PUSH
22851: LD_INT 84
22853: PPUSH
22854: LD_VAR 0 1
22858: PPUSH
22859: CALL_OW 321
22863: PUSH
22864: LD_INT 2
22866: EQUAL
22867: ST_TO_ADDR
22868: GO 23009
22870: LD_INT 19
22872: DOUBLE
22873: EQUAL
22874: IFTRUE 22884
22876: LD_INT 23
22878: DOUBLE
22879: EQUAL
22880: IFTRUE 22884
22882: GO 22909
22884: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22885: LD_ADDR_VAR 0 3
22889: PUSH
22890: LD_INT 83
22892: PPUSH
22893: LD_VAR 0 1
22897: PPUSH
22898: CALL_OW 321
22902: PUSH
22903: LD_INT 2
22905: EQUAL
22906: ST_TO_ADDR
22907: GO 23009
22909: LD_INT 17
22911: DOUBLE
22912: EQUAL
22913: IFTRUE 22917
22915: GO 22942
22917: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22918: LD_ADDR_VAR 0 3
22922: PUSH
22923: LD_INT 39
22925: PPUSH
22926: LD_VAR 0 1
22930: PPUSH
22931: CALL_OW 321
22935: PUSH
22936: LD_INT 2
22938: EQUAL
22939: ST_TO_ADDR
22940: GO 23009
22942: LD_INT 18
22944: DOUBLE
22945: EQUAL
22946: IFTRUE 22950
22948: GO 22975
22950: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22951: LD_ADDR_VAR 0 3
22955: PUSH
22956: LD_INT 40
22958: PPUSH
22959: LD_VAR 0 1
22963: PPUSH
22964: CALL_OW 321
22968: PUSH
22969: LD_INT 2
22971: EQUAL
22972: ST_TO_ADDR
22973: GO 23009
22975: LD_INT 27
22977: DOUBLE
22978: EQUAL
22979: IFTRUE 22983
22981: GO 23008
22983: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 35
22991: PPUSH
22992: LD_VAR 0 1
22996: PPUSH
22997: CALL_OW 321
23001: PUSH
23002: LD_INT 2
23004: EQUAL
23005: ST_TO_ADDR
23006: GO 23009
23008: POP
// end ;
23009: LD_VAR 0 3
23013: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23014: LD_INT 0
23016: PPUSH
23017: PPUSH
23018: PPUSH
23019: PPUSH
23020: PPUSH
23021: PPUSH
23022: PPUSH
23023: PPUSH
23024: PPUSH
23025: PPUSH
23026: PPUSH
// result := false ;
23027: LD_ADDR_VAR 0 6
23031: PUSH
23032: LD_INT 0
23034: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23035: LD_VAR 0 1
23039: NOT
23040: PUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: CALL_OW 266
23050: PUSH
23051: LD_INT 0
23053: PUSH
23054: LD_INT 1
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: IN
23061: NOT
23062: OR
23063: PUSH
23064: LD_VAR 0 2
23068: NOT
23069: OR
23070: PUSH
23071: LD_VAR 0 5
23075: PUSH
23076: LD_INT 0
23078: PUSH
23079: LD_INT 1
23081: PUSH
23082: LD_INT 2
23084: PUSH
23085: LD_INT 3
23087: PUSH
23088: LD_INT 4
23090: PUSH
23091: LD_INT 5
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: IN
23102: NOT
23103: OR
23104: PUSH
23105: LD_VAR 0 3
23109: PPUSH
23110: LD_VAR 0 4
23114: PPUSH
23115: CALL_OW 488
23119: NOT
23120: OR
23121: IFFALSE 23125
// exit ;
23123: GO 23861
// side := GetSide ( depot ) ;
23125: LD_ADDR_VAR 0 9
23129: PUSH
23130: LD_VAR 0 1
23134: PPUSH
23135: CALL_OW 255
23139: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23140: LD_VAR 0 9
23144: PPUSH
23145: LD_VAR 0 2
23149: PPUSH
23150: CALL 22638 0 2
23154: NOT
23155: IFFALSE 23159
// exit ;
23157: GO 23861
// pom := GetBase ( depot ) ;
23159: LD_ADDR_VAR 0 10
23163: PUSH
23164: LD_VAR 0 1
23168: PPUSH
23169: CALL_OW 274
23173: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23174: LD_ADDR_VAR 0 11
23178: PUSH
23179: LD_VAR 0 2
23183: PPUSH
23184: LD_VAR 0 1
23188: PPUSH
23189: CALL_OW 248
23193: PPUSH
23194: CALL_OW 450
23198: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23199: LD_VAR 0 10
23203: PPUSH
23204: LD_INT 1
23206: PPUSH
23207: CALL_OW 275
23211: PUSH
23212: LD_VAR 0 11
23216: PUSH
23217: LD_INT 1
23219: ARRAY
23220: GREATEREQUAL
23221: PUSH
23222: LD_VAR 0 10
23226: PPUSH
23227: LD_INT 2
23229: PPUSH
23230: CALL_OW 275
23234: PUSH
23235: LD_VAR 0 11
23239: PUSH
23240: LD_INT 2
23242: ARRAY
23243: GREATEREQUAL
23244: AND
23245: PUSH
23246: LD_VAR 0 10
23250: PPUSH
23251: LD_INT 3
23253: PPUSH
23254: CALL_OW 275
23258: PUSH
23259: LD_VAR 0 11
23263: PUSH
23264: LD_INT 3
23266: ARRAY
23267: GREATEREQUAL
23268: AND
23269: NOT
23270: IFFALSE 23274
// exit ;
23272: GO 23861
// if GetBType ( depot ) = b_depot then
23274: LD_VAR 0 1
23278: PPUSH
23279: CALL_OW 266
23283: PUSH
23284: LD_INT 0
23286: EQUAL
23287: IFFALSE 23299
// dist := 28 else
23289: LD_ADDR_VAR 0 14
23293: PUSH
23294: LD_INT 28
23296: ST_TO_ADDR
23297: GO 23307
// dist := 36 ;
23299: LD_ADDR_VAR 0 14
23303: PUSH
23304: LD_INT 36
23306: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23307: LD_VAR 0 1
23311: PPUSH
23312: LD_VAR 0 3
23316: PPUSH
23317: LD_VAR 0 4
23321: PPUSH
23322: CALL_OW 297
23326: PUSH
23327: LD_VAR 0 14
23331: GREATER
23332: IFFALSE 23336
// exit ;
23334: GO 23861
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23336: LD_ADDR_VAR 0 12
23340: PUSH
23341: LD_VAR 0 2
23345: PPUSH
23346: LD_VAR 0 3
23350: PPUSH
23351: LD_VAR 0 4
23355: PPUSH
23356: LD_VAR 0 5
23360: PPUSH
23361: LD_VAR 0 1
23365: PPUSH
23366: CALL_OW 248
23370: PPUSH
23371: LD_INT 0
23373: PPUSH
23374: CALL 23866 0 6
23378: ST_TO_ADDR
// if not hexes then
23379: LD_VAR 0 12
23383: NOT
23384: IFFALSE 23388
// exit ;
23386: GO 23861
// hex := GetHexInfo ( x , y ) ;
23388: LD_ADDR_VAR 0 15
23392: PUSH
23393: LD_VAR 0 3
23397: PPUSH
23398: LD_VAR 0 4
23402: PPUSH
23403: CALL_OW 546
23407: ST_TO_ADDR
// if hex [ 1 ] then
23408: LD_VAR 0 15
23412: PUSH
23413: LD_INT 1
23415: ARRAY
23416: IFFALSE 23420
// exit ;
23418: GO 23861
// height := hex [ 2 ] ;
23420: LD_ADDR_VAR 0 13
23424: PUSH
23425: LD_VAR 0 15
23429: PUSH
23430: LD_INT 2
23432: ARRAY
23433: ST_TO_ADDR
// for i = 1 to hexes do
23434: LD_ADDR_VAR 0 7
23438: PUSH
23439: DOUBLE
23440: LD_INT 1
23442: DEC
23443: ST_TO_ADDR
23444: LD_VAR 0 12
23448: PUSH
23449: FOR_TO
23450: IFFALSE 23780
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23452: LD_VAR 0 12
23456: PUSH
23457: LD_VAR 0 7
23461: ARRAY
23462: PUSH
23463: LD_INT 1
23465: ARRAY
23466: PPUSH
23467: LD_VAR 0 12
23471: PUSH
23472: LD_VAR 0 7
23476: ARRAY
23477: PUSH
23478: LD_INT 2
23480: ARRAY
23481: PPUSH
23482: CALL_OW 488
23486: NOT
23487: PUSH
23488: LD_VAR 0 12
23492: PUSH
23493: LD_VAR 0 7
23497: ARRAY
23498: PUSH
23499: LD_INT 1
23501: ARRAY
23502: PPUSH
23503: LD_VAR 0 12
23507: PUSH
23508: LD_VAR 0 7
23512: ARRAY
23513: PUSH
23514: LD_INT 2
23516: ARRAY
23517: PPUSH
23518: CALL_OW 428
23522: PUSH
23523: LD_INT 0
23525: GREATER
23526: OR
23527: PUSH
23528: LD_VAR 0 12
23532: PUSH
23533: LD_VAR 0 7
23537: ARRAY
23538: PUSH
23539: LD_INT 1
23541: ARRAY
23542: PPUSH
23543: LD_VAR 0 12
23547: PUSH
23548: LD_VAR 0 7
23552: ARRAY
23553: PUSH
23554: LD_INT 2
23556: ARRAY
23557: PPUSH
23558: CALL_OW 351
23562: OR
23563: IFFALSE 23569
// exit ;
23565: POP
23566: POP
23567: GO 23861
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23569: LD_ADDR_VAR 0 8
23573: PUSH
23574: LD_VAR 0 12
23578: PUSH
23579: LD_VAR 0 7
23583: ARRAY
23584: PUSH
23585: LD_INT 1
23587: ARRAY
23588: PPUSH
23589: LD_VAR 0 12
23593: PUSH
23594: LD_VAR 0 7
23598: ARRAY
23599: PUSH
23600: LD_INT 2
23602: ARRAY
23603: PPUSH
23604: CALL_OW 546
23608: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23609: LD_VAR 0 8
23613: PUSH
23614: LD_INT 1
23616: ARRAY
23617: PUSH
23618: LD_VAR 0 8
23622: PUSH
23623: LD_INT 2
23625: ARRAY
23626: PUSH
23627: LD_VAR 0 13
23631: PUSH
23632: LD_INT 2
23634: PLUS
23635: GREATER
23636: OR
23637: PUSH
23638: LD_VAR 0 8
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PUSH
23647: LD_VAR 0 13
23651: PUSH
23652: LD_INT 2
23654: MINUS
23655: LESS
23656: OR
23657: PUSH
23658: LD_VAR 0 8
23662: PUSH
23663: LD_INT 3
23665: ARRAY
23666: PUSH
23667: LD_INT 0
23669: PUSH
23670: LD_INT 8
23672: PUSH
23673: LD_INT 9
23675: PUSH
23676: LD_INT 10
23678: PUSH
23679: LD_INT 11
23681: PUSH
23682: LD_INT 12
23684: PUSH
23685: LD_INT 13
23687: PUSH
23688: LD_INT 16
23690: PUSH
23691: LD_INT 17
23693: PUSH
23694: LD_INT 18
23696: PUSH
23697: LD_INT 19
23699: PUSH
23700: LD_INT 20
23702: PUSH
23703: LD_INT 21
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: LIST
23710: LIST
23711: LIST
23712: LIST
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: LIST
23718: LIST
23719: LIST
23720: IN
23721: NOT
23722: OR
23723: PUSH
23724: LD_VAR 0 8
23728: PUSH
23729: LD_INT 5
23731: ARRAY
23732: NOT
23733: OR
23734: PUSH
23735: LD_VAR 0 8
23739: PUSH
23740: LD_INT 6
23742: ARRAY
23743: PUSH
23744: LD_INT 1
23746: PUSH
23747: LD_INT 2
23749: PUSH
23750: LD_INT 7
23752: PUSH
23753: LD_INT 9
23755: PUSH
23756: LD_INT 10
23758: PUSH
23759: LD_INT 11
23761: PUSH
23762: EMPTY
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: LIST
23768: LIST
23769: IN
23770: NOT
23771: OR
23772: IFFALSE 23778
// exit ;
23774: POP
23775: POP
23776: GO 23861
// end ;
23778: GO 23449
23780: POP
23781: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23782: LD_VAR 0 9
23786: PPUSH
23787: LD_VAR 0 3
23791: PPUSH
23792: LD_VAR 0 4
23796: PPUSH
23797: LD_INT 20
23799: PPUSH
23800: CALL 15813 0 4
23804: PUSH
23805: LD_INT 4
23807: ARRAY
23808: IFFALSE 23812
// exit ;
23810: GO 23861
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23812: LD_VAR 0 2
23816: PUSH
23817: LD_INT 29
23819: PUSH
23820: LD_INT 30
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: IN
23827: PUSH
23828: LD_VAR 0 3
23832: PPUSH
23833: LD_VAR 0 4
23837: PPUSH
23838: LD_VAR 0 9
23842: PPUSH
23843: CALL_OW 440
23847: NOT
23848: AND
23849: IFFALSE 23853
// exit ;
23851: GO 23861
// result := true ;
23853: LD_ADDR_VAR 0 6
23857: PUSH
23858: LD_INT 1
23860: ST_TO_ADDR
// end ;
23861: LD_VAR 0 6
23865: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23866: LD_INT 0
23868: PPUSH
23869: PPUSH
23870: PPUSH
23871: PPUSH
23872: PPUSH
23873: PPUSH
23874: PPUSH
23875: PPUSH
23876: PPUSH
23877: PPUSH
23878: PPUSH
23879: PPUSH
23880: PPUSH
23881: PPUSH
23882: PPUSH
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
23896: PPUSH
23897: PPUSH
23898: PPUSH
23899: PPUSH
23900: PPUSH
23901: PPUSH
23902: PPUSH
23903: PPUSH
23904: PPUSH
23905: PPUSH
23906: PPUSH
23907: PPUSH
23908: PPUSH
23909: PPUSH
23910: PPUSH
23911: PPUSH
23912: PPUSH
23913: PPUSH
23914: PPUSH
23915: PPUSH
23916: PPUSH
23917: PPUSH
23918: PPUSH
23919: PPUSH
23920: PPUSH
23921: PPUSH
23922: PPUSH
23923: PPUSH
23924: PPUSH
23925: PPUSH
// result = [ ] ;
23926: LD_ADDR_VAR 0 7
23930: PUSH
23931: EMPTY
23932: ST_TO_ADDR
// temp_list = [ ] ;
23933: LD_ADDR_VAR 0 9
23937: PUSH
23938: EMPTY
23939: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23940: LD_VAR 0 4
23944: PUSH
23945: LD_INT 0
23947: PUSH
23948: LD_INT 1
23950: PUSH
23951: LD_INT 2
23953: PUSH
23954: LD_INT 3
23956: PUSH
23957: LD_INT 4
23959: PUSH
23960: LD_INT 5
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: LIST
23970: IN
23971: NOT
23972: PUSH
23973: LD_VAR 0 1
23977: PUSH
23978: LD_INT 0
23980: PUSH
23981: LD_INT 1
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: IN
23988: PUSH
23989: LD_VAR 0 5
23993: PUSH
23994: LD_INT 1
23996: PUSH
23997: LD_INT 2
23999: PUSH
24000: LD_INT 3
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: LIST
24007: IN
24008: NOT
24009: AND
24010: OR
24011: IFFALSE 24015
// exit ;
24013: GO 42406
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24015: LD_VAR 0 1
24019: PUSH
24020: LD_INT 6
24022: PUSH
24023: LD_INT 7
24025: PUSH
24026: LD_INT 8
24028: PUSH
24029: LD_INT 13
24031: PUSH
24032: LD_INT 12
24034: PUSH
24035: LD_INT 15
24037: PUSH
24038: LD_INT 11
24040: PUSH
24041: LD_INT 14
24043: PUSH
24044: LD_INT 10
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: LIST
24054: LIST
24055: LIST
24056: LIST
24057: IN
24058: IFFALSE 24068
// btype = b_lab ;
24060: LD_ADDR_VAR 0 1
24064: PUSH
24065: LD_INT 6
24067: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24068: LD_VAR 0 6
24072: PUSH
24073: LD_INT 0
24075: PUSH
24076: LD_INT 1
24078: PUSH
24079: LD_INT 2
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: LIST
24086: IN
24087: NOT
24088: PUSH
24089: LD_VAR 0 1
24093: PUSH
24094: LD_INT 0
24096: PUSH
24097: LD_INT 1
24099: PUSH
24100: LD_INT 2
24102: PUSH
24103: LD_INT 3
24105: PUSH
24106: LD_INT 6
24108: PUSH
24109: LD_INT 36
24111: PUSH
24112: LD_INT 4
24114: PUSH
24115: LD_INT 5
24117: PUSH
24118: LD_INT 31
24120: PUSH
24121: LD_INT 32
24123: PUSH
24124: LD_INT 33
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: IN
24140: NOT
24141: PUSH
24142: LD_VAR 0 6
24146: PUSH
24147: LD_INT 1
24149: EQUAL
24150: AND
24151: OR
24152: PUSH
24153: LD_VAR 0 1
24157: PUSH
24158: LD_INT 2
24160: PUSH
24161: LD_INT 3
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: IN
24168: NOT
24169: PUSH
24170: LD_VAR 0 6
24174: PUSH
24175: LD_INT 2
24177: EQUAL
24178: AND
24179: OR
24180: IFFALSE 24190
// mode = 0 ;
24182: LD_ADDR_VAR 0 6
24186: PUSH
24187: LD_INT 0
24189: ST_TO_ADDR
// case mode of 0 :
24190: LD_VAR 0 6
24194: PUSH
24195: LD_INT 0
24197: DOUBLE
24198: EQUAL
24199: IFTRUE 24203
24201: GO 35656
24203: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24204: LD_ADDR_VAR 0 11
24208: PUSH
24209: LD_INT 0
24211: PUSH
24212: LD_INT 0
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 0
24221: PUSH
24222: LD_INT 1
24224: NEG
24225: PUSH
24226: EMPTY
24227: LIST
24228: LIST
24229: PUSH
24230: LD_INT 1
24232: PUSH
24233: LD_INT 0
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PUSH
24240: LD_INT 1
24242: PUSH
24243: LD_INT 1
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 0
24252: PUSH
24253: LD_INT 1
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 1
24262: NEG
24263: PUSH
24264: LD_INT 0
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 1
24273: NEG
24274: PUSH
24275: LD_INT 1
24277: NEG
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PUSH
24283: LD_INT 1
24285: NEG
24286: PUSH
24287: LD_INT 2
24289: NEG
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PUSH
24295: LD_INT 0
24297: PUSH
24298: LD_INT 2
24300: NEG
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: PUSH
24306: LD_INT 1
24308: PUSH
24309: LD_INT 1
24311: NEG
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: LD_INT 1
24319: PUSH
24320: LD_INT 2
24322: PUSH
24323: EMPTY
24324: LIST
24325: LIST
24326: PUSH
24327: LD_INT 0
24329: PUSH
24330: LD_INT 2
24332: PUSH
24333: EMPTY
24334: LIST
24335: LIST
24336: PUSH
24337: LD_INT 1
24339: NEG
24340: PUSH
24341: LD_INT 1
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: LD_INT 1
24350: PUSH
24351: LD_INT 3
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: LD_INT 0
24360: PUSH
24361: LD_INT 3
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: PUSH
24368: LD_INT 1
24370: NEG
24371: PUSH
24372: LD_INT 2
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: LIST
24383: LIST
24384: LIST
24385: LIST
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: LIST
24391: LIST
24392: LIST
24393: LIST
24394: LIST
24395: LIST
24396: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24397: LD_ADDR_VAR 0 12
24401: PUSH
24402: LD_INT 0
24404: PUSH
24405: LD_INT 0
24407: PUSH
24408: EMPTY
24409: LIST
24410: LIST
24411: PUSH
24412: LD_INT 0
24414: PUSH
24415: LD_INT 1
24417: NEG
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: LD_INT 0
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 1
24435: PUSH
24436: LD_INT 1
24438: PUSH
24439: EMPTY
24440: LIST
24441: LIST
24442: PUSH
24443: LD_INT 0
24445: PUSH
24446: LD_INT 1
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: LD_INT 1
24455: NEG
24456: PUSH
24457: LD_INT 0
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PUSH
24464: LD_INT 1
24466: NEG
24467: PUSH
24468: LD_INT 1
24470: NEG
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: PUSH
24476: LD_INT 1
24478: PUSH
24479: LD_INT 1
24481: NEG
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PUSH
24487: LD_INT 2
24489: PUSH
24490: LD_INT 0
24492: PUSH
24493: EMPTY
24494: LIST
24495: LIST
24496: PUSH
24497: LD_INT 2
24499: PUSH
24500: LD_INT 1
24502: PUSH
24503: EMPTY
24504: LIST
24505: LIST
24506: PUSH
24507: LD_INT 1
24509: NEG
24510: PUSH
24511: LD_INT 1
24513: PUSH
24514: EMPTY
24515: LIST
24516: LIST
24517: PUSH
24518: LD_INT 2
24520: NEG
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: LD_INT 2
24531: NEG
24532: PUSH
24533: LD_INT 1
24535: NEG
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 2
24543: NEG
24544: PUSH
24545: LD_INT 1
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PUSH
24552: LD_INT 3
24554: NEG
24555: PUSH
24556: LD_INT 0
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: PUSH
24563: LD_INT 3
24565: NEG
24566: PUSH
24567: LD_INT 1
24569: NEG
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PUSH
24575: EMPTY
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: LIST
24590: LIST
24591: LIST
24592: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24593: LD_ADDR_VAR 0 13
24597: PUSH
24598: LD_INT 0
24600: PUSH
24601: LD_INT 0
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: LD_INT 0
24610: PUSH
24611: LD_INT 1
24613: NEG
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: PUSH
24619: LD_INT 1
24621: PUSH
24622: LD_INT 0
24624: PUSH
24625: EMPTY
24626: LIST
24627: LIST
24628: PUSH
24629: LD_INT 1
24631: PUSH
24632: LD_INT 1
24634: PUSH
24635: EMPTY
24636: LIST
24637: LIST
24638: PUSH
24639: LD_INT 0
24641: PUSH
24642: LD_INT 1
24644: PUSH
24645: EMPTY
24646: LIST
24647: LIST
24648: PUSH
24649: LD_INT 1
24651: NEG
24652: PUSH
24653: LD_INT 0
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 1
24662: NEG
24663: PUSH
24664: LD_INT 1
24666: NEG
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: PUSH
24672: LD_INT 1
24674: NEG
24675: PUSH
24676: LD_INT 2
24678: NEG
24679: PUSH
24680: EMPTY
24681: LIST
24682: LIST
24683: PUSH
24684: LD_INT 2
24686: PUSH
24687: LD_INT 1
24689: PUSH
24690: EMPTY
24691: LIST
24692: LIST
24693: PUSH
24694: LD_INT 2
24696: PUSH
24697: LD_INT 2
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 1
24706: PUSH
24707: LD_INT 2
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 2
24716: NEG
24717: PUSH
24718: LD_INT 1
24720: NEG
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PUSH
24726: LD_INT 2
24728: NEG
24729: PUSH
24730: LD_INT 2
24732: NEG
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 2
24740: NEG
24741: PUSH
24742: LD_INT 3
24744: NEG
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 3
24752: NEG
24753: PUSH
24754: LD_INT 2
24756: NEG
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PUSH
24762: LD_INT 3
24764: NEG
24765: PUSH
24766: LD_INT 3
24768: NEG
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24792: LD_ADDR_VAR 0 14
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: LD_INT 0
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 0
24809: PUSH
24810: LD_INT 1
24812: NEG
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: PUSH
24818: LD_INT 1
24820: PUSH
24821: LD_INT 0
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 1
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: PUSH
24838: LD_INT 0
24840: PUSH
24841: LD_INT 1
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PUSH
24848: LD_INT 1
24850: NEG
24851: PUSH
24852: LD_INT 0
24854: PUSH
24855: EMPTY
24856: LIST
24857: LIST
24858: PUSH
24859: LD_INT 1
24861: NEG
24862: PUSH
24863: LD_INT 1
24865: NEG
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: PUSH
24871: LD_INT 1
24873: NEG
24874: PUSH
24875: LD_INT 2
24877: NEG
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: LD_INT 0
24885: PUSH
24886: LD_INT 2
24888: NEG
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 1
24896: PUSH
24897: LD_INT 1
24899: NEG
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 1
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: LD_INT 0
24917: PUSH
24918: LD_INT 2
24920: PUSH
24921: EMPTY
24922: LIST
24923: LIST
24924: PUSH
24925: LD_INT 1
24927: NEG
24928: PUSH
24929: LD_INT 1
24931: PUSH
24932: EMPTY
24933: LIST
24934: LIST
24935: PUSH
24936: LD_INT 1
24938: NEG
24939: PUSH
24940: LD_INT 3
24942: NEG
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: LD_INT 0
24950: PUSH
24951: LD_INT 3
24953: NEG
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: PUSH
24959: LD_INT 1
24961: PUSH
24962: LD_INT 2
24964: NEG
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: LIST
24974: LIST
24975: LIST
24976: LIST
24977: LIST
24978: LIST
24979: LIST
24980: LIST
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: LIST
24986: LIST
24987: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24988: LD_ADDR_VAR 0 15
24992: PUSH
24993: LD_INT 0
24995: PUSH
24996: LD_INT 0
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 0
25005: PUSH
25006: LD_INT 1
25008: NEG
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 1
25016: PUSH
25017: LD_INT 0
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: LD_INT 1
25026: PUSH
25027: LD_INT 1
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PUSH
25034: LD_INT 0
25036: PUSH
25037: LD_INT 1
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 1
25046: NEG
25047: PUSH
25048: LD_INT 0
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: PUSH
25055: LD_INT 1
25057: NEG
25058: PUSH
25059: LD_INT 1
25061: NEG
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 1
25069: PUSH
25070: LD_INT 1
25072: NEG
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: PUSH
25078: LD_INT 2
25080: PUSH
25081: LD_INT 0
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 2
25090: PUSH
25091: LD_INT 1
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: PUSH
25098: LD_INT 1
25100: NEG
25101: PUSH
25102: LD_INT 1
25104: PUSH
25105: EMPTY
25106: LIST
25107: LIST
25108: PUSH
25109: LD_INT 2
25111: NEG
25112: PUSH
25113: LD_INT 0
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 2
25122: NEG
25123: PUSH
25124: LD_INT 1
25126: NEG
25127: PUSH
25128: EMPTY
25129: LIST
25130: LIST
25131: PUSH
25132: LD_INT 2
25134: PUSH
25135: LD_INT 1
25137: NEG
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PUSH
25143: LD_INT 3
25145: PUSH
25146: LD_INT 0
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 3
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: LIST
25167: LIST
25168: LIST
25169: LIST
25170: LIST
25171: LIST
25172: LIST
25173: LIST
25174: LIST
25175: LIST
25176: LIST
25177: LIST
25178: LIST
25179: LIST
25180: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25181: LD_ADDR_VAR 0 16
25185: PUSH
25186: LD_INT 0
25188: PUSH
25189: LD_INT 0
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: PUSH
25196: LD_INT 0
25198: PUSH
25199: LD_INT 1
25201: NEG
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PUSH
25207: LD_INT 1
25209: PUSH
25210: LD_INT 0
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 1
25219: PUSH
25220: LD_INT 1
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: LD_INT 0
25229: PUSH
25230: LD_INT 1
25232: PUSH
25233: EMPTY
25234: LIST
25235: LIST
25236: PUSH
25237: LD_INT 1
25239: NEG
25240: PUSH
25241: LD_INT 0
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 1
25250: NEG
25251: PUSH
25252: LD_INT 1
25254: NEG
25255: PUSH
25256: EMPTY
25257: LIST
25258: LIST
25259: PUSH
25260: LD_INT 1
25262: NEG
25263: PUSH
25264: LD_INT 2
25266: NEG
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: LD_INT 1
25277: PUSH
25278: EMPTY
25279: LIST
25280: LIST
25281: PUSH
25282: LD_INT 2
25284: PUSH
25285: LD_INT 2
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PUSH
25292: LD_INT 1
25294: PUSH
25295: LD_INT 2
25297: PUSH
25298: EMPTY
25299: LIST
25300: LIST
25301: PUSH
25302: LD_INT 2
25304: NEG
25305: PUSH
25306: LD_INT 1
25308: NEG
25309: PUSH
25310: EMPTY
25311: LIST
25312: LIST
25313: PUSH
25314: LD_INT 2
25316: NEG
25317: PUSH
25318: LD_INT 2
25320: NEG
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 3
25328: PUSH
25329: LD_INT 2
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 3
25338: PUSH
25339: LD_INT 3
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 2
25348: PUSH
25349: LD_INT 3
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: LIST
25361: LIST
25362: LIST
25363: LIST
25364: LIST
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25374: LD_ADDR_VAR 0 17
25378: PUSH
25379: LD_INT 0
25381: PUSH
25382: LD_INT 0
25384: PUSH
25385: EMPTY
25386: LIST
25387: LIST
25388: PUSH
25389: LD_INT 0
25391: PUSH
25392: LD_INT 1
25394: NEG
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PUSH
25400: LD_INT 1
25402: PUSH
25403: LD_INT 0
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: PUSH
25410: LD_INT 1
25412: PUSH
25413: LD_INT 1
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: LD_INT 0
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: LD_INT 1
25432: NEG
25433: PUSH
25434: LD_INT 0
25436: PUSH
25437: EMPTY
25438: LIST
25439: LIST
25440: PUSH
25441: LD_INT 1
25443: NEG
25444: PUSH
25445: LD_INT 1
25447: NEG
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: LD_INT 2
25459: NEG
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 0
25467: PUSH
25468: LD_INT 2
25470: NEG
25471: PUSH
25472: EMPTY
25473: LIST
25474: LIST
25475: PUSH
25476: LD_INT 1
25478: PUSH
25479: LD_INT 1
25481: NEG
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: PUSH
25487: LD_INT 2
25489: PUSH
25490: LD_INT 0
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 2
25499: PUSH
25500: LD_INT 1
25502: PUSH
25503: EMPTY
25504: LIST
25505: LIST
25506: PUSH
25507: LD_INT 2
25509: PUSH
25510: LD_INT 2
25512: PUSH
25513: EMPTY
25514: LIST
25515: LIST
25516: PUSH
25517: LD_INT 1
25519: PUSH
25520: LD_INT 2
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PUSH
25527: LD_INT 0
25529: PUSH
25530: LD_INT 2
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: PUSH
25537: LD_INT 1
25539: NEG
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: LD_INT 2
25550: NEG
25551: PUSH
25552: LD_INT 0
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: LD_INT 2
25561: NEG
25562: PUSH
25563: LD_INT 1
25565: NEG
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: PUSH
25571: LD_INT 2
25573: NEG
25574: PUSH
25575: LD_INT 2
25577: NEG
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25604: LD_ADDR_VAR 0 18
25608: PUSH
25609: LD_INT 0
25611: PUSH
25612: LD_INT 0
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: LD_INT 1
25624: NEG
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 1
25632: PUSH
25633: LD_INT 0
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: PUSH
25640: LD_INT 1
25642: PUSH
25643: LD_INT 1
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 0
25652: PUSH
25653: LD_INT 1
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: LD_INT 1
25662: NEG
25663: PUSH
25664: LD_INT 0
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PUSH
25671: LD_INT 1
25673: NEG
25674: PUSH
25675: LD_INT 1
25677: NEG
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 1
25685: NEG
25686: PUSH
25687: LD_INT 2
25689: NEG
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: PUSH
25695: LD_INT 0
25697: PUSH
25698: LD_INT 2
25700: NEG
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PUSH
25706: LD_INT 1
25708: PUSH
25709: LD_INT 1
25711: NEG
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: PUSH
25717: LD_INT 2
25719: PUSH
25720: LD_INT 0
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: LD_INT 2
25729: PUSH
25730: LD_INT 1
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: PUSH
25737: LD_INT 2
25739: PUSH
25740: LD_INT 2
25742: PUSH
25743: EMPTY
25744: LIST
25745: LIST
25746: PUSH
25747: LD_INT 1
25749: PUSH
25750: LD_INT 2
25752: PUSH
25753: EMPTY
25754: LIST
25755: LIST
25756: PUSH
25757: LD_INT 0
25759: PUSH
25760: LD_INT 2
25762: PUSH
25763: EMPTY
25764: LIST
25765: LIST
25766: PUSH
25767: LD_INT 1
25769: NEG
25770: PUSH
25771: LD_INT 1
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: LD_INT 2
25780: NEG
25781: PUSH
25782: LD_INT 0
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: PUSH
25789: LD_INT 2
25791: NEG
25792: PUSH
25793: LD_INT 1
25795: NEG
25796: PUSH
25797: EMPTY
25798: LIST
25799: LIST
25800: PUSH
25801: LD_INT 2
25803: NEG
25804: PUSH
25805: LD_INT 2
25807: NEG
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: LIST
25827: LIST
25828: LIST
25829: LIST
25830: LIST
25831: LIST
25832: LIST
25833: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25834: LD_ADDR_VAR 0 19
25838: PUSH
25839: LD_INT 0
25841: PUSH
25842: LD_INT 0
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 0
25851: PUSH
25852: LD_INT 1
25854: NEG
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 1
25862: PUSH
25863: LD_INT 0
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 1
25872: PUSH
25873: LD_INT 1
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 0
25882: PUSH
25883: LD_INT 1
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 1
25892: NEG
25893: PUSH
25894: LD_INT 0
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PUSH
25901: LD_INT 1
25903: NEG
25904: PUSH
25905: LD_INT 1
25907: NEG
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PUSH
25913: LD_INT 1
25915: NEG
25916: PUSH
25917: LD_INT 2
25919: NEG
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 0
25927: PUSH
25928: LD_INT 2
25930: NEG
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: PUSH
25936: LD_INT 1
25938: PUSH
25939: LD_INT 1
25941: NEG
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: PUSH
25947: LD_INT 2
25949: PUSH
25950: LD_INT 0
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: PUSH
25957: LD_INT 2
25959: PUSH
25960: LD_INT 1
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: PUSH
25967: LD_INT 2
25969: PUSH
25970: LD_INT 2
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PUSH
25977: LD_INT 1
25979: PUSH
25980: LD_INT 2
25982: PUSH
25983: EMPTY
25984: LIST
25985: LIST
25986: PUSH
25987: LD_INT 0
25989: PUSH
25990: LD_INT 2
25992: PUSH
25993: EMPTY
25994: LIST
25995: LIST
25996: PUSH
25997: LD_INT 1
25999: NEG
26000: PUSH
26001: LD_INT 1
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 2
26010: NEG
26011: PUSH
26012: LD_INT 0
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 2
26021: NEG
26022: PUSH
26023: LD_INT 1
26025: NEG
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: PUSH
26031: LD_INT 2
26033: NEG
26034: PUSH
26035: LD_INT 2
26037: NEG
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: EMPTY
26044: LIST
26045: LIST
26046: LIST
26047: LIST
26048: LIST
26049: LIST
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26064: LD_ADDR_VAR 0 20
26068: PUSH
26069: LD_INT 0
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: LD_INT 1
26084: NEG
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: PUSH
26090: LD_INT 1
26092: PUSH
26093: LD_INT 0
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: PUSH
26100: LD_INT 1
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 1
26115: PUSH
26116: EMPTY
26117: LIST
26118: LIST
26119: PUSH
26120: LD_INT 1
26122: NEG
26123: PUSH
26124: LD_INT 0
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: PUSH
26131: LD_INT 1
26133: NEG
26134: PUSH
26135: LD_INT 1
26137: NEG
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 1
26145: NEG
26146: PUSH
26147: LD_INT 2
26149: NEG
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 0
26157: PUSH
26158: LD_INT 2
26160: NEG
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: LD_INT 1
26171: NEG
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 2
26179: PUSH
26180: LD_INT 0
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 2
26189: PUSH
26190: LD_INT 1
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PUSH
26197: LD_INT 2
26199: PUSH
26200: LD_INT 2
26202: PUSH
26203: EMPTY
26204: LIST
26205: LIST
26206: PUSH
26207: LD_INT 1
26209: PUSH
26210: LD_INT 2
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PUSH
26217: LD_INT 0
26219: PUSH
26220: LD_INT 2
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 1
26229: NEG
26230: PUSH
26231: LD_INT 1
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 2
26240: NEG
26241: PUSH
26242: LD_INT 0
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 2
26251: NEG
26252: PUSH
26253: LD_INT 1
26255: NEG
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 2
26263: NEG
26264: PUSH
26265: LD_INT 2
26267: NEG
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: PUSH
26273: EMPTY
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26294: LD_ADDR_VAR 0 21
26298: PUSH
26299: LD_INT 0
26301: PUSH
26302: LD_INT 0
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 0
26311: PUSH
26312: LD_INT 1
26314: NEG
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 1
26322: PUSH
26323: LD_INT 0
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: LD_INT 1
26332: PUSH
26333: LD_INT 1
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_INT 0
26342: PUSH
26343: LD_INT 1
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PUSH
26350: LD_INT 1
26352: NEG
26353: PUSH
26354: LD_INT 0
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 1
26363: NEG
26364: PUSH
26365: LD_INT 1
26367: NEG
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PUSH
26373: LD_INT 1
26375: NEG
26376: PUSH
26377: LD_INT 2
26379: NEG
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 0
26387: PUSH
26388: LD_INT 2
26390: NEG
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 1
26398: PUSH
26399: LD_INT 1
26401: NEG
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PUSH
26407: LD_INT 2
26409: PUSH
26410: LD_INT 0
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 2
26419: PUSH
26420: LD_INT 1
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: LD_INT 2
26429: PUSH
26430: LD_INT 2
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 1
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 0
26449: PUSH
26450: LD_INT 2
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: LD_INT 1
26459: NEG
26460: PUSH
26461: LD_INT 1
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 2
26470: NEG
26471: PUSH
26472: LD_INT 0
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 2
26481: NEG
26482: PUSH
26483: LD_INT 1
26485: NEG
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: PUSH
26491: LD_INT 2
26493: NEG
26494: PUSH
26495: LD_INT 2
26497: NEG
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: LIST
26507: LIST
26508: LIST
26509: LIST
26510: LIST
26511: LIST
26512: LIST
26513: LIST
26514: LIST
26515: LIST
26516: LIST
26517: LIST
26518: LIST
26519: LIST
26520: LIST
26521: LIST
26522: LIST
26523: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26524: LD_ADDR_VAR 0 22
26528: PUSH
26529: LD_INT 0
26531: PUSH
26532: LD_INT 0
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 0
26541: PUSH
26542: LD_INT 1
26544: NEG
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 1
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 1
26562: PUSH
26563: LD_INT 1
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 0
26572: PUSH
26573: LD_INT 1
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: LD_INT 1
26582: NEG
26583: PUSH
26584: LD_INT 0
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 1
26593: NEG
26594: PUSH
26595: LD_INT 1
26597: NEG
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 1
26605: NEG
26606: PUSH
26607: LD_INT 2
26609: NEG
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 0
26617: PUSH
26618: LD_INT 2
26620: NEG
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 1
26628: PUSH
26629: LD_INT 1
26631: NEG
26632: PUSH
26633: EMPTY
26634: LIST
26635: LIST
26636: PUSH
26637: LD_INT 2
26639: PUSH
26640: LD_INT 0
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 2
26649: PUSH
26650: LD_INT 1
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 2
26659: PUSH
26660: LD_INT 2
26662: PUSH
26663: EMPTY
26664: LIST
26665: LIST
26666: PUSH
26667: LD_INT 1
26669: PUSH
26670: LD_INT 2
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: PUSH
26677: LD_INT 0
26679: PUSH
26680: LD_INT 2
26682: PUSH
26683: EMPTY
26684: LIST
26685: LIST
26686: PUSH
26687: LD_INT 1
26689: NEG
26690: PUSH
26691: LD_INT 1
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 2
26700: NEG
26701: PUSH
26702: LD_INT 0
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 2
26711: NEG
26712: PUSH
26713: LD_INT 1
26715: NEG
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: PUSH
26721: LD_INT 2
26723: NEG
26724: PUSH
26725: LD_INT 2
26727: NEG
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: LIST
26740: LIST
26741: LIST
26742: LIST
26743: LIST
26744: LIST
26745: LIST
26746: LIST
26747: LIST
26748: LIST
26749: LIST
26750: LIST
26751: LIST
26752: LIST
26753: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26754: LD_ADDR_VAR 0 23
26758: PUSH
26759: LD_INT 0
26761: PUSH
26762: LD_INT 0
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 0
26771: PUSH
26772: LD_INT 1
26774: NEG
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: LD_INT 1
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 1
26792: PUSH
26793: LD_INT 1
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 0
26802: PUSH
26803: LD_INT 1
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: PUSH
26810: LD_INT 1
26812: NEG
26813: PUSH
26814: LD_INT 0
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 1
26823: NEG
26824: PUSH
26825: LD_INT 1
26827: NEG
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 1
26835: NEG
26836: PUSH
26837: LD_INT 2
26839: NEG
26840: PUSH
26841: EMPTY
26842: LIST
26843: LIST
26844: PUSH
26845: LD_INT 0
26847: PUSH
26848: LD_INT 2
26850: NEG
26851: PUSH
26852: EMPTY
26853: LIST
26854: LIST
26855: PUSH
26856: LD_INT 1
26858: PUSH
26859: LD_INT 1
26861: NEG
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 2
26869: PUSH
26870: LD_INT 0
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 2
26879: PUSH
26880: LD_INT 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 2
26889: PUSH
26890: LD_INT 2
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 1
26899: PUSH
26900: LD_INT 2
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 0
26909: PUSH
26910: LD_INT 2
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 1
26919: NEG
26920: PUSH
26921: LD_INT 1
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 2
26930: NEG
26931: PUSH
26932: LD_INT 0
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 2
26941: NEG
26942: PUSH
26943: LD_INT 1
26945: NEG
26946: PUSH
26947: EMPTY
26948: LIST
26949: LIST
26950: PUSH
26951: LD_INT 2
26953: NEG
26954: PUSH
26955: LD_INT 2
26957: NEG
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 2
26965: NEG
26966: PUSH
26967: LD_INT 3
26969: NEG
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 1
26977: NEG
26978: PUSH
26979: LD_INT 3
26981: NEG
26982: PUSH
26983: EMPTY
26984: LIST
26985: LIST
26986: PUSH
26987: LD_INT 1
26989: PUSH
26990: LD_INT 2
26992: NEG
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 2
27000: PUSH
27001: LD_INT 1
27003: NEG
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27034: LD_ADDR_VAR 0 24
27038: PUSH
27039: LD_INT 0
27041: PUSH
27042: LD_INT 0
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: LD_INT 0
27051: PUSH
27052: LD_INT 1
27054: NEG
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: PUSH
27063: LD_INT 0
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 1
27072: PUSH
27073: LD_INT 1
27075: PUSH
27076: EMPTY
27077: LIST
27078: LIST
27079: PUSH
27080: LD_INT 0
27082: PUSH
27083: LD_INT 1
27085: PUSH
27086: EMPTY
27087: LIST
27088: LIST
27089: PUSH
27090: LD_INT 1
27092: NEG
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PUSH
27101: LD_INT 1
27103: NEG
27104: PUSH
27105: LD_INT 1
27107: NEG
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 1
27115: NEG
27116: PUSH
27117: LD_INT 2
27119: NEG
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 0
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 1
27138: PUSH
27139: LD_INT 1
27141: NEG
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 2
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 2
27159: PUSH
27160: LD_INT 1
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: LD_INT 2
27169: PUSH
27170: LD_INT 2
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: LD_INT 1
27179: PUSH
27180: LD_INT 2
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 0
27189: PUSH
27190: LD_INT 2
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: NEG
27200: PUSH
27201: LD_INT 1
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 2
27210: NEG
27211: PUSH
27212: LD_INT 0
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PUSH
27219: LD_INT 2
27221: NEG
27222: PUSH
27223: LD_INT 1
27225: NEG
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 2
27233: NEG
27234: PUSH
27235: LD_INT 2
27237: NEG
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 1
27245: PUSH
27246: LD_INT 2
27248: NEG
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 2
27256: PUSH
27257: LD_INT 1
27259: NEG
27260: PUSH
27261: EMPTY
27262: LIST
27263: LIST
27264: PUSH
27265: LD_INT 3
27267: PUSH
27268: LD_INT 1
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PUSH
27275: LD_INT 3
27277: PUSH
27278: LD_INT 2
27280: PUSH
27281: EMPTY
27282: LIST
27283: LIST
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27310: LD_ADDR_VAR 0 25
27314: PUSH
27315: LD_INT 0
27317: PUSH
27318: LD_INT 0
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 0
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 1
27338: PUSH
27339: LD_INT 0
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 1
27348: PUSH
27349: LD_INT 1
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: LD_INT 0
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 1
27368: NEG
27369: PUSH
27370: LD_INT 0
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: LD_INT 1
27379: NEG
27380: PUSH
27381: LD_INT 1
27383: NEG
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 1
27391: NEG
27392: PUSH
27393: LD_INT 2
27395: NEG
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 0
27403: PUSH
27404: LD_INT 2
27406: NEG
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: LD_INT 1
27417: NEG
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: PUSH
27423: LD_INT 2
27425: PUSH
27426: LD_INT 0
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 2
27435: PUSH
27436: LD_INT 1
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: PUSH
27443: LD_INT 2
27445: PUSH
27446: LD_INT 2
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_INT 1
27455: PUSH
27456: LD_INT 2
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: LD_INT 2
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 1
27475: NEG
27476: PUSH
27477: LD_INT 1
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: NEG
27487: PUSH
27488: LD_INT 0
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PUSH
27495: LD_INT 2
27497: NEG
27498: PUSH
27499: LD_INT 1
27501: NEG
27502: PUSH
27503: EMPTY
27504: LIST
27505: LIST
27506: PUSH
27507: LD_INT 2
27509: NEG
27510: PUSH
27511: LD_INT 2
27513: NEG
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: PUSH
27519: LD_INT 3
27521: PUSH
27522: LD_INT 1
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: PUSH
27529: LD_INT 3
27531: PUSH
27532: LD_INT 2
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 2
27541: PUSH
27542: LD_INT 3
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PUSH
27549: LD_INT 1
27551: PUSH
27552: LD_INT 3
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: LIST
27563: LIST
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27584: LD_ADDR_VAR 0 26
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: LD_INT 0
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 0
27601: PUSH
27602: LD_INT 1
27604: NEG
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 1
27612: PUSH
27613: LD_INT 0
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: PUSH
27623: LD_INT 1
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 0
27632: PUSH
27633: LD_INT 1
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 1
27642: NEG
27643: PUSH
27644: LD_INT 0
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 1
27653: NEG
27654: PUSH
27655: LD_INT 1
27657: NEG
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 1
27665: NEG
27666: PUSH
27667: LD_INT 2
27669: NEG
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: PUSH
27675: LD_INT 0
27677: PUSH
27678: LD_INT 2
27680: NEG
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 1
27688: PUSH
27689: LD_INT 1
27691: NEG
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 2
27699: PUSH
27700: LD_INT 0
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 2
27709: PUSH
27710: LD_INT 1
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 2
27719: PUSH
27720: LD_INT 2
27722: PUSH
27723: EMPTY
27724: LIST
27725: LIST
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: LD_INT 2
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: LD_INT 0
27739: PUSH
27740: LD_INT 2
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: LD_INT 1
27749: NEG
27750: PUSH
27751: LD_INT 1
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PUSH
27758: LD_INT 2
27760: NEG
27761: PUSH
27762: LD_INT 0
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 2
27771: NEG
27772: PUSH
27773: LD_INT 1
27775: NEG
27776: PUSH
27777: EMPTY
27778: LIST
27779: LIST
27780: PUSH
27781: LD_INT 2
27783: NEG
27784: PUSH
27785: LD_INT 2
27787: NEG
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: LD_INT 2
27795: PUSH
27796: LD_INT 3
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: PUSH
27806: LD_INT 3
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PUSH
27813: LD_INT 1
27815: NEG
27816: PUSH
27817: LD_INT 2
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PUSH
27824: LD_INT 2
27826: NEG
27827: PUSH
27828: LD_INT 1
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: EMPTY
27836: LIST
27837: LIST
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: LIST
27855: LIST
27856: LIST
27857: LIST
27858: LIST
27859: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27860: LD_ADDR_VAR 0 27
27864: PUSH
27865: LD_INT 0
27867: PUSH
27868: LD_INT 0
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: LD_INT 1
27880: NEG
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 1
27888: PUSH
27889: LD_INT 0
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 1
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 0
27908: PUSH
27909: LD_INT 1
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 1
27918: NEG
27919: PUSH
27920: LD_INT 0
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: NEG
27930: PUSH
27931: LD_INT 1
27933: NEG
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 1
27941: NEG
27942: PUSH
27943: LD_INT 2
27945: NEG
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: PUSH
27951: LD_INT 0
27953: PUSH
27954: LD_INT 2
27956: NEG
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: PUSH
27962: LD_INT 1
27964: PUSH
27965: LD_INT 1
27967: NEG
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 2
27975: PUSH
27976: LD_INT 0
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 2
27985: PUSH
27986: LD_INT 1
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 2
27995: PUSH
27996: LD_INT 2
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 1
28005: PUSH
28006: LD_INT 2
28008: PUSH
28009: EMPTY
28010: LIST
28011: LIST
28012: PUSH
28013: LD_INT 0
28015: PUSH
28016: LD_INT 2
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 1
28025: NEG
28026: PUSH
28027: LD_INT 1
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: LD_INT 0
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 2
28047: NEG
28048: PUSH
28049: LD_INT 1
28051: NEG
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 2
28059: NEG
28060: PUSH
28061: LD_INT 2
28063: NEG
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 1
28071: NEG
28072: PUSH
28073: LD_INT 2
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 2
28082: NEG
28083: PUSH
28084: LD_INT 1
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 3
28093: NEG
28094: PUSH
28095: LD_INT 1
28097: NEG
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: PUSH
28103: LD_INT 3
28105: NEG
28106: PUSH
28107: LD_INT 2
28109: NEG
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: LIST
28119: LIST
28120: LIST
28121: LIST
28122: LIST
28123: LIST
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28140: LD_ADDR_VAR 0 28
28144: PUSH
28145: LD_INT 0
28147: PUSH
28148: LD_INT 0
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: LD_INT 0
28157: PUSH
28158: LD_INT 1
28160: NEG
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 1
28168: PUSH
28169: LD_INT 0
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 1
28178: PUSH
28179: LD_INT 1
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: LD_INT 0
28188: PUSH
28189: LD_INT 1
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 1
28198: NEG
28199: PUSH
28200: LD_INT 0
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 1
28209: NEG
28210: PUSH
28211: LD_INT 1
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 1
28221: NEG
28222: PUSH
28223: LD_INT 2
28225: NEG
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 0
28233: PUSH
28234: LD_INT 2
28236: NEG
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 1
28244: PUSH
28245: LD_INT 1
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 2
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: PUSH
28266: LD_INT 1
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 2
28275: PUSH
28276: LD_INT 2
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: LD_INT 2
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PUSH
28293: LD_INT 0
28295: PUSH
28296: LD_INT 2
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: LD_INT 1
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: LD_INT 1
28331: NEG
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 2
28339: NEG
28340: PUSH
28341: LD_INT 2
28343: NEG
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: LD_INT 3
28355: NEG
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: LD_INT 1
28363: NEG
28364: PUSH
28365: LD_INT 3
28367: NEG
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: LD_INT 3
28375: NEG
28376: PUSH
28377: LD_INT 1
28379: NEG
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: LD_INT 2
28391: NEG
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: LIST
28413: LIST
28414: LIST
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28422: LD_ADDR_VAR 0 29
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: LD_INT 0
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: LD_INT 1
28442: NEG
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 1
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 1
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 0
28470: PUSH
28471: LD_INT 1
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 1
28491: NEG
28492: PUSH
28493: LD_INT 1
28495: NEG
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 1
28503: NEG
28504: PUSH
28505: LD_INT 2
28507: NEG
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 0
28515: PUSH
28516: LD_INT 2
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 1
28529: NEG
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: PUSH
28558: LD_INT 2
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: LD_INT 2
28570: PUSH
28571: EMPTY
28572: LIST
28573: LIST
28574: PUSH
28575: LD_INT 1
28577: NEG
28578: PUSH
28579: LD_INT 1
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 1
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 2
28600: NEG
28601: PUSH
28602: LD_INT 2
28604: NEG
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 2
28612: NEG
28613: PUSH
28614: LD_INT 3
28616: NEG
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 2
28624: PUSH
28625: LD_INT 1
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 3
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: LD_INT 3
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 1
28655: NEG
28656: PUSH
28657: LD_INT 2
28659: PUSH
28660: EMPTY
28661: LIST
28662: LIST
28663: PUSH
28664: LD_INT 3
28666: NEG
28667: PUSH
28668: LD_INT 2
28670: NEG
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: LIST
28680: LIST
28681: LIST
28682: LIST
28683: LIST
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: LIST
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28701: LD_ADDR_VAR 0 30
28705: PUSH
28706: LD_INT 0
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 0
28718: PUSH
28719: LD_INT 1
28721: NEG
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 1
28729: PUSH
28730: LD_INT 0
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PUSH
28737: LD_INT 1
28739: PUSH
28740: LD_INT 1
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 0
28749: PUSH
28750: LD_INT 1
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: LD_INT 1
28759: NEG
28760: PUSH
28761: LD_INT 0
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: LD_INT 1
28774: NEG
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: LD_INT 2
28786: NEG
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: LD_INT 2
28797: NEG
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: LD_INT 1
28808: NEG
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 2
28816: PUSH
28817: LD_INT 0
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 2
28826: PUSH
28827: LD_INT 1
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 2
28836: PUSH
28837: LD_INT 2
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: LD_INT 1
28846: PUSH
28847: LD_INT 2
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 1
28856: NEG
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 2
28867: NEG
28868: PUSH
28869: LD_INT 0
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 2
28878: NEG
28879: PUSH
28880: LD_INT 1
28882: NEG
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: LD_INT 1
28890: NEG
28891: PUSH
28892: LD_INT 3
28894: NEG
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PUSH
28900: LD_INT 1
28902: PUSH
28903: LD_INT 2
28905: NEG
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 3
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 2
28923: PUSH
28924: LD_INT 3
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 2
28933: NEG
28934: PUSH
28935: LD_INT 1
28937: PUSH
28938: EMPTY
28939: LIST
28940: LIST
28941: PUSH
28942: LD_INT 3
28944: NEG
28945: PUSH
28946: LD_INT 1
28948: NEG
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: LIST
28958: LIST
28959: LIST
28960: LIST
28961: LIST
28962: LIST
28963: LIST
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28979: LD_ADDR_VAR 0 31
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: LD_INT 0
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: LD_INT 0
28996: PUSH
28997: LD_INT 1
28999: NEG
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: PUSH
29005: LD_INT 1
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: EMPTY
29012: LIST
29013: LIST
29014: PUSH
29015: LD_INT 1
29017: PUSH
29018: LD_INT 1
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: LD_INT 0
29027: PUSH
29028: LD_INT 1
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 1
29037: NEG
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 1
29048: NEG
29049: PUSH
29050: LD_INT 1
29052: NEG
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 1
29060: NEG
29061: PUSH
29062: LD_INT 2
29064: NEG
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: LD_INT 1
29072: PUSH
29073: LD_INT 1
29075: NEG
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 2
29093: PUSH
29094: LD_INT 1
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: LD_INT 2
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 1
29113: PUSH
29114: LD_INT 2
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 0
29123: PUSH
29124: LD_INT 2
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: NEG
29134: PUSH
29135: LD_INT 1
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 2
29144: NEG
29145: PUSH
29146: LD_INT 1
29148: NEG
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 2
29156: NEG
29157: PUSH
29158: LD_INT 2
29160: NEG
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 2
29168: NEG
29169: PUSH
29170: LD_INT 3
29172: NEG
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 1
29201: PUSH
29202: LD_INT 3
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 1
29211: NEG
29212: PUSH
29213: LD_INT 2
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: LD_INT 3
29222: NEG
29223: PUSH
29224: LD_INT 2
29226: NEG
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29257: LD_ADDR_VAR 0 32
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PUSH
29283: LD_INT 1
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: LD_INT 1
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 0
29305: PUSH
29306: LD_INT 1
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: NEG
29316: PUSH
29317: LD_INT 0
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: NEG
29339: PUSH
29340: LD_INT 2
29342: NEG
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 0
29350: PUSH
29351: LD_INT 2
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 1
29361: PUSH
29362: LD_INT 1
29364: NEG
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 2
29372: PUSH
29373: LD_INT 1
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 2
29382: PUSH
29383: LD_INT 2
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: LD_INT 2
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 1
29412: NEG
29413: PUSH
29414: LD_INT 1
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 2
29423: NEG
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 2
29434: NEG
29435: PUSH
29436: LD_INT 1
29438: NEG
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 1
29446: NEG
29447: PUSH
29448: LD_INT 3
29450: NEG
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 1
29458: PUSH
29459: LD_INT 2
29461: NEG
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: PUSH
29467: LD_INT 3
29469: PUSH
29470: LD_INT 2
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 2
29479: PUSH
29480: LD_INT 3
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 2
29489: NEG
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 3
29500: NEG
29501: PUSH
29502: LD_INT 1
29504: NEG
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: LIST
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: LIST
29521: LIST
29522: LIST
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: LIST
29530: LIST
29531: LIST
29532: LIST
29533: LIST
29534: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29535: LD_ADDR_VAR 0 33
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: LD_INT 0
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 0
29552: PUSH
29553: LD_INT 1
29555: NEG
29556: PUSH
29557: EMPTY
29558: LIST
29559: LIST
29560: PUSH
29561: LD_INT 1
29563: PUSH
29564: LD_INT 0
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: LD_INT 1
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 0
29583: PUSH
29584: LD_INT 1
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 1
29593: NEG
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 1
29604: NEG
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 1
29616: NEG
29617: PUSH
29618: LD_INT 2
29620: NEG
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 2
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 2
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 1
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 2
29701: NEG
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 2
29713: NEG
29714: PUSH
29715: LD_INT 2
29717: NEG
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 2
29725: NEG
29726: PUSH
29727: LD_INT 3
29729: NEG
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PUSH
29735: LD_INT 2
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 3
29748: PUSH
29749: LD_INT 1
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: LD_INT 3
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 1
29768: NEG
29769: PUSH
29770: LD_INT 2
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 3
29779: NEG
29780: PUSH
29781: LD_INT 2
29783: NEG
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29814: LD_ADDR_VAR 0 34
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 0
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 0
29831: PUSH
29832: LD_INT 1
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: NEG
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: NEG
29896: PUSH
29897: LD_INT 2
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: LD_INT 2
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: LD_INT 1
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: LD_INT 1
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 2
29939: PUSH
29940: LD_INT 2
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 1
29949: PUSH
29950: LD_INT 2
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: NEG
29960: PUSH
29961: LD_INT 1
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 2
29970: NEG
29971: PUSH
29972: LD_INT 0
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: NEG
29982: PUSH
29983: LD_INT 1
29985: NEG
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 2
29993: NEG
29994: PUSH
29995: LD_INT 2
29997: NEG
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: LD_INT 3
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 2
30020: NEG
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 3
30028: PUSH
30029: LD_INT 2
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 3
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: NEG
30049: PUSH
30050: LD_INT 1
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: LD_INT 3
30059: NEG
30060: PUSH
30061: LD_INT 1
30063: NEG
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: LIST
30092: LIST
30093: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30094: LD_ADDR_VAR 0 35
30098: PUSH
30099: LD_INT 0
30101: PUSH
30102: LD_INT 0
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: LD_INT 0
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: LD_INT 1
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: LD_INT 0
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: LD_INT 1
30167: NEG
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: LD_INT 1
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 2
30185: NEG
30186: PUSH
30187: LD_INT 1
30189: NEG
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30206: LD_ADDR_VAR 0 36
30210: PUSH
30211: LD_INT 0
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 0
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 1
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: LD_INT 1
30279: NEG
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 1
30287: NEG
30288: PUSH
30289: LD_INT 2
30291: NEG
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30318: LD_ADDR_VAR 0 37
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: LD_INT 1
30338: NEG
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: PUSH
30347: LD_INT 0
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 1
30356: PUSH
30357: LD_INT 1
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 0
30366: PUSH
30367: LD_INT 1
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: LD_INT 1
30391: NEG
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 1
30399: PUSH
30400: LD_INT 1
30402: NEG
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 1
30410: NEG
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30430: LD_ADDR_VAR 0 38
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: LD_INT 0
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 0
30447: PUSH
30448: LD_INT 1
30450: NEG
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 1
30458: PUSH
30459: LD_INT 0
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 1
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 0
30478: PUSH
30479: LD_INT 1
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: NEG
30489: PUSH
30490: LD_INT 0
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: LD_INT 1
30499: NEG
30500: PUSH
30501: LD_INT 1
30503: NEG
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: LD_INT 1
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 2
30521: NEG
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30542: LD_ADDR_VAR 0 39
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 0
30559: PUSH
30560: LD_INT 1
30562: NEG
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: PUSH
30571: LD_INT 0
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 1
30580: PUSH
30581: LD_INT 1
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: LD_INT 0
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 1
30611: NEG
30612: PUSH
30613: LD_INT 1
30615: NEG
30616: PUSH
30617: EMPTY
30618: LIST
30619: LIST
30620: PUSH
30621: LD_INT 1
30623: NEG
30624: PUSH
30625: LD_INT 2
30627: NEG
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: LD_INT 2
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30654: LD_ADDR_VAR 0 40
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 0
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: PUSH
30693: LD_INT 1
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 0
30702: PUSH
30703: LD_INT 1
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: LD_INT 0
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: PUSH
30721: LD_INT 1
30723: NEG
30724: PUSH
30725: LD_INT 1
30727: NEG
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: LD_INT 1
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 1
30746: NEG
30747: PUSH
30748: LD_INT 1
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30766: LD_ADDR_VAR 0 41
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: LD_INT 0
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 0
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: PUSH
30795: LD_INT 0
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 1
30804: PUSH
30805: LD_INT 1
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 1
30824: NEG
30825: PUSH
30826: LD_INT 0
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: LD_INT 1
30835: NEG
30836: PUSH
30837: LD_INT 1
30839: NEG
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 2
30851: NEG
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 1
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: PUSH
30871: LD_INT 0
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 2
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 2
30890: PUSH
30891: LD_INT 2
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 2
30921: NEG
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 2
30932: NEG
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: NEG
30945: PUSH
30946: LD_INT 2
30948: NEG
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 2
30956: NEG
30957: PUSH
30958: LD_INT 3
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 2
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 3
30979: PUSH
30980: LD_INT 0
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 3
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: LD_INT 3
30999: PUSH
31000: LD_INT 2
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 3
31009: PUSH
31010: LD_INT 3
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 2
31019: PUSH
31020: LD_INT 3
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: PUSH
31027: LD_INT 2
31029: NEG
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: LD_INT 3
31040: NEG
31041: PUSH
31042: LD_INT 0
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 3
31051: NEG
31052: PUSH
31053: LD_INT 1
31055: NEG
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 3
31063: NEG
31064: PUSH
31065: LD_INT 2
31067: NEG
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 3
31075: NEG
31076: PUSH
31077: LD_INT 3
31079: NEG
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31116: LD_ADDR_VAR 0 42
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: LD_INT 0
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 0
31133: PUSH
31134: LD_INT 1
31136: NEG
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 1
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 1
31154: PUSH
31155: LD_INT 1
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 1
31174: NEG
31175: PUSH
31176: LD_INT 0
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: NEG
31186: PUSH
31187: LD_INT 1
31189: NEG
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 2
31201: NEG
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 0
31209: PUSH
31210: LD_INT 2
31212: NEG
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: LD_INT 1
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 2
31241: PUSH
31242: LD_INT 2
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 1
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 0
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 1
31271: NEG
31272: PUSH
31273: LD_INT 1
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: NEG
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: NEG
31295: PUSH
31296: LD_INT 2
31298: NEG
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: LD_INT 2
31306: NEG
31307: PUSH
31308: LD_INT 3
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 1
31318: NEG
31319: PUSH
31320: LD_INT 3
31322: NEG
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 0
31330: PUSH
31331: LD_INT 3
31333: NEG
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 1
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 3
31352: PUSH
31353: LD_INT 2
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 3
31362: PUSH
31363: LD_INT 3
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: PUSH
31373: LD_INT 3
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: LD_INT 3
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: LD_INT 0
31392: PUSH
31393: LD_INT 3
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: LD_INT 2
31406: PUSH
31407: EMPTY
31408: LIST
31409: LIST
31410: PUSH
31411: LD_INT 3
31413: NEG
31414: PUSH
31415: LD_INT 2
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 3
31425: NEG
31426: PUSH
31427: LD_INT 3
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31466: LD_ADDR_VAR 0 43
31470: PUSH
31471: LD_INT 0
31473: PUSH
31474: LD_INT 0
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 0
31483: PUSH
31484: LD_INT 1
31486: NEG
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 1
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: LD_INT 0
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 1
31535: NEG
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: NEG
31548: PUSH
31549: LD_INT 2
31551: NEG
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 2
31562: NEG
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 1
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 2
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 2
31591: PUSH
31592: LD_INT 1
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 1
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 0
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: LD_INT 1
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: LD_INT 2
31632: NEG
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: LD_INT 1
31647: NEG
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 1
31655: NEG
31656: PUSH
31657: LD_INT 3
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: LD_INT 3
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: LD_INT 2
31681: NEG
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 2
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 3
31700: PUSH
31701: LD_INT 0
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: LD_INT 3
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: LD_INT 3
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: LD_INT 3
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: NEG
31752: PUSH
31753: LD_INT 1
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 3
31762: NEG
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 3
31773: NEG
31774: PUSH
31775: LD_INT 1
31777: NEG
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: LIST
31787: LIST
31788: LIST
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31814: LD_ADDR_VAR 0 44
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 0
31831: PUSH
31832: LD_INT 1
31834: NEG
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 1
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: LD_INT 1
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 1
31872: NEG
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: NEG
31884: PUSH
31885: LD_INT 1
31887: NEG
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: LD_INT 2
31899: NEG
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 2
31928: PUSH
31929: LD_INT 1
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 2
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 1
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: LD_INT 1
31984: NEG
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 2
31992: NEG
31993: PUSH
31994: LD_INT 2
31996: NEG
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: NEG
32005: PUSH
32006: LD_INT 3
32008: NEG
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 2
32016: PUSH
32017: LD_INT 1
32019: NEG
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 3
32027: PUSH
32028: LD_INT 0
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 3
32037: PUSH
32038: LD_INT 1
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 3
32047: PUSH
32048: LD_INT 2
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 3
32057: PUSH
32058: LD_INT 3
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 2
32067: PUSH
32068: LD_INT 3
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 2
32077: NEG
32078: PUSH
32079: LD_INT 1
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 3
32088: NEG
32089: PUSH
32090: LD_INT 0
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 3
32099: NEG
32100: PUSH
32101: LD_INT 1
32103: NEG
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 3
32111: NEG
32112: PUSH
32113: LD_INT 2
32115: NEG
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 3
32123: NEG
32124: PUSH
32125: LD_INT 3
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: LIST
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32164: LD_ADDR_VAR 0 45
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 0
32181: PUSH
32182: LD_INT 1
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 1
32192: PUSH
32193: LD_INT 0
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: LD_INT 1
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 1
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 1
32222: NEG
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 2
32249: NEG
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: LD_INT 2
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 2
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 2
32289: PUSH
32290: LD_INT 2
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 2
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: LD_INT 2
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: NEG
32320: PUSH
32321: LD_INT 1
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 2
32330: NEG
32331: PUSH
32332: LD_INT 1
32334: NEG
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 2
32342: NEG
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 2
32354: NEG
32355: PUSH
32356: LD_INT 3
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: LD_INT 3
32370: NEG
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 0
32378: PUSH
32379: LD_INT 3
32381: NEG
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: LD_INT 2
32392: NEG
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PUSH
32398: LD_INT 3
32400: PUSH
32401: LD_INT 2
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 3
32410: PUSH
32411: LD_INT 3
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: LD_INT 3
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 1
32430: PUSH
32431: LD_INT 3
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: LD_INT 3
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 1
32450: NEG
32451: PUSH
32452: LD_INT 2
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 3
32461: NEG
32462: PUSH
32463: LD_INT 2
32465: NEG
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 3
32473: NEG
32474: PUSH
32475: LD_INT 3
32477: NEG
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32514: LD_ADDR_VAR 0 46
32518: PUSH
32519: LD_INT 0
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 0
32531: PUSH
32532: LD_INT 1
32534: NEG
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 1
32542: PUSH
32543: LD_INT 0
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: LD_INT 1
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PUSH
32570: LD_INT 1
32572: NEG
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: NEG
32584: PUSH
32585: LD_INT 1
32587: NEG
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 2
32599: NEG
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 1
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: LD_INT 0
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: LD_INT 1
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 2
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 0
32659: PUSH
32660: LD_INT 2
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 1
32669: NEG
32670: PUSH
32671: LD_INT 1
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 0
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 2
32691: NEG
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 1
32703: NEG
32704: PUSH
32705: LD_INT 3
32707: NEG
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: LD_INT 3
32718: NEG
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 1
32726: PUSH
32727: LD_INT 2
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 3
32748: PUSH
32749: LD_INT 0
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 3
32758: PUSH
32759: LD_INT 1
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 1
32768: PUSH
32769: LD_INT 3
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 0
32778: PUSH
32779: LD_INT 3
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 1
32788: NEG
32789: PUSH
32790: LD_INT 2
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: NEG
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: NEG
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 3
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: LIST
32835: LIST
32836: LIST
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: LIST
32851: LIST
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32862: LD_ADDR_VAR 0 47
32866: PUSH
32867: LD_INT 0
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 0
32879: PUSH
32880: LD_INT 1
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 1
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 1
32920: NEG
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: PUSH
32933: LD_INT 1
32935: NEG
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 1
32943: NEG
32944: PUSH
32945: LD_INT 2
32947: NEG
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 1
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 2
32977: NEG
32978: PUSH
32979: LD_INT 1
32981: NEG
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 2
32989: NEG
32990: PUSH
32991: LD_INT 2
32993: NEG
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33013: LD_ADDR_VAR 0 48
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: LD_INT 0
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 1
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 1
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: LD_INT 2
33109: NEG
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: PUSH
33129: LD_INT 0
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33160: LD_ADDR_VAR 0 49
33164: PUSH
33165: LD_INT 0
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 0
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: LD_INT 0
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 1
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 0
33208: PUSH
33209: LD_INT 1
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 1
33218: NEG
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: LD_INT 1
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 1
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 2
33252: PUSH
33253: LD_INT 0
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 2
33262: PUSH
33263: LD_INT 1
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 2
33272: PUSH
33273: LD_INT 2
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: LD_INT 2
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33304: LD_ADDR_VAR 0 50
33308: PUSH
33309: LD_INT 0
33311: PUSH
33312: LD_INT 0
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 0
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 1
33332: PUSH
33333: LD_INT 0
33335: PUSH
33336: EMPTY
33337: LIST
33338: LIST
33339: PUSH
33340: LD_INT 1
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 0
33352: PUSH
33353: LD_INT 1
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: NEG
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 2
33385: PUSH
33386: LD_INT 1
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 2
33395: PUSH
33396: LD_INT 2
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: LD_INT 2
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 0
33415: PUSH
33416: LD_INT 2
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: NEG
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33448: LD_ADDR_VAR 0 51
33452: PUSH
33453: LD_INT 0
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 1
33476: PUSH
33477: LD_INT 0
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: LD_INT 1
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 0
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 1
33517: NEG
33518: PUSH
33519: LD_INT 1
33521: NEG
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 2
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 2
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 1
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 2
33560: NEG
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33595: LD_ADDR_VAR 0 52
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: LD_INT 0
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: LD_INT 1
33615: NEG
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 1
33623: PUSH
33624: LD_INT 0
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: PUSH
33634: LD_INT 1
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: LD_INT 1
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 1
33653: NEG
33654: PUSH
33655: LD_INT 0
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 1
33664: NEG
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: PUSH
33678: LD_INT 2
33680: NEG
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PUSH
33686: LD_INT 1
33688: NEG
33689: PUSH
33690: LD_INT 1
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 2
33699: NEG
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 2
33710: NEG
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 2
33722: NEG
33723: PUSH
33724: LD_INT 2
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33746: LD_ADDR_VAR 0 53
33750: PUSH
33751: LD_INT 0
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: LD_INT 1
33766: NEG
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 1
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 1
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 1
33804: NEG
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 1
33815: NEG
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 1
33827: NEG
33828: PUSH
33829: LD_INT 2
33831: NEG
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 0
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: LD_INT 1
33853: NEG
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: LD_INT 2
33881: PUSH
33882: LD_INT 2
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 1
33891: PUSH
33892: LD_INT 2
33894: PUSH
33895: EMPTY
33896: LIST
33897: LIST
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: LD_INT 2
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 2
33922: NEG
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 2
33933: NEG
33934: PUSH
33935: LD_INT 1
33937: NEG
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 2
33945: NEG
33946: PUSH
33947: LD_INT 2
33949: NEG
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: LIST
33969: LIST
33970: LIST
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33976: LD_ADDR_VAR 0 54
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 0
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 0
33993: PUSH
33994: LD_INT 1
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 1
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: LD_INT 1
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 1
34034: NEG
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: LD_INT 2
34061: NEG
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 2
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 2
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: LD_INT 2
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: LD_INT 2
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 0
34131: PUSH
34132: LD_INT 2
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: NEG
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 2
34152: NEG
34153: PUSH
34154: LD_INT 0
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 2
34163: NEG
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: NEG
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34206: LD_ADDR_VAR 0 55
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 1
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 1
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: LD_INT 0
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: LD_INT 1
34279: NEG
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 1
34287: NEG
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 1
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 2
34341: PUSH
34342: LD_INT 2
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 1
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 2
34382: NEG
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 2
34393: NEG
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 2
34405: NEG
34406: PUSH
34407: LD_INT 2
34409: NEG
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34436: LD_ADDR_VAR 0 56
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 0
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: PUSH
34475: LD_INT 1
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 0
34484: PUSH
34485: LD_INT 1
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: LD_INT 0
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: LD_INT 2
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 0
34529: PUSH
34530: LD_INT 2
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: PUSH
34541: LD_INT 1
34543: NEG
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: PUSH
34562: LD_INT 1
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 2
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: LD_INT 2
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 0
34591: PUSH
34592: LD_INT 2
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: NEG
34602: PUSH
34603: LD_INT 1
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 2
34612: NEG
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 2
34623: NEG
34624: PUSH
34625: LD_INT 1
34627: NEG
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: LIST
34649: LIST
34650: LIST
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34666: LD_ADDR_VAR 0 57
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: LD_INT 0
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 0
34683: PUSH
34684: LD_INT 1
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 1
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: LD_INT 1
34724: NEG
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: NEG
34736: PUSH
34737: LD_INT 1
34739: NEG
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: LD_INT 2
34751: NEG
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: LD_INT 2
34762: NEG
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 2
34781: PUSH
34782: LD_INT 0
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 2
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: PUSH
34802: LD_INT 2
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: LD_INT 2
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: LD_INT 2
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: NEG
34832: PUSH
34833: LD_INT 1
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 2
34842: NEG
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: NEG
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 2
34865: NEG
34866: PUSH
34867: LD_INT 2
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34896: LD_ADDR_VAR 0 58
34900: PUSH
34901: LD_INT 0
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 0
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 2
35011: PUSH
35012: LD_INT 0
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 2
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 1
35041: PUSH
35042: LD_INT 2
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 0
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 1
35061: NEG
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 2
35072: NEG
35073: PUSH
35074: LD_INT 0
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 2
35083: NEG
35084: PUSH
35085: LD_INT 1
35087: NEG
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PUSH
35093: LD_INT 2
35095: NEG
35096: PUSH
35097: LD_INT 2
35099: NEG
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35126: LD_ADDR_VAR 0 59
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 1
35184: NEG
35185: PUSH
35186: LD_INT 0
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: LD_INT 1
35199: NEG
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: LIST
35211: LIST
35212: LIST
35213: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35214: LD_ADDR_VAR 0 60
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: LD_INT 0
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 1
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: LD_INT 1
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: LD_INT 1
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: NEG
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 1
35283: NEG
35284: PUSH
35285: LD_INT 1
35287: NEG
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35302: LD_ADDR_VAR 0 61
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 0
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 1
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 0
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: LD_INT 1
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35390: LD_ADDR_VAR 0 62
35394: PUSH
35395: LD_INT 0
35397: PUSH
35398: LD_INT 0
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 1
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 1
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 0
35438: PUSH
35439: LD_INT 1
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: NEG
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 1
35459: NEG
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35478: LD_ADDR_VAR 0 63
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35566: LD_ADDR_VAR 0 64
35570: PUSH
35571: LD_INT 0
35573: PUSH
35574: LD_INT 0
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 0
35583: PUSH
35584: LD_INT 1
35586: NEG
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 1
35604: PUSH
35605: LD_INT 1
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: LD_INT 1
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: LD_INT 0
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: ST_TO_ADDR
// end ; 1 :
35654: GO 41551
35656: LD_INT 1
35658: DOUBLE
35659: EQUAL
35660: IFTRUE 35664
35662: GO 38287
35664: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35665: LD_ADDR_VAR 0 11
35669: PUSH
35670: LD_INT 1
35672: NEG
35673: PUSH
35674: LD_INT 3
35676: NEG
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 0
35684: PUSH
35685: LD_INT 3
35687: NEG
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: PUSH
35696: LD_INT 2
35698: NEG
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: LIST
35708: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35709: LD_ADDR_VAR 0 12
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: LD_INT 1
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 3
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: LIST
35749: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35750: LD_ADDR_VAR 0 13
35754: PUSH
35755: LD_INT 3
35757: PUSH
35758: LD_INT 2
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 3
35767: PUSH
35768: LD_INT 3
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: LD_INT 3
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: LIST
35789: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35790: LD_ADDR_VAR 0 14
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: LD_INT 3
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 1
35817: NEG
35818: PUSH
35819: LD_INT 2
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: LIST
35830: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35831: LD_ADDR_VAR 0 15
35835: PUSH
35836: LD_INT 2
35838: NEG
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 3
35849: NEG
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 3
35860: NEG
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: LIST
35874: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35875: LD_ADDR_VAR 0 16
35879: PUSH
35880: LD_INT 2
35882: NEG
35883: PUSH
35884: LD_INT 3
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 3
35894: NEG
35895: PUSH
35896: LD_INT 2
35898: NEG
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 3
35906: NEG
35907: PUSH
35908: LD_INT 3
35910: NEG
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: LIST
35920: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35921: LD_ADDR_VAR 0 17
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 3
35932: NEG
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 0
35940: PUSH
35941: LD_INT 3
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: LD_INT 2
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: LIST
35964: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35965: LD_ADDR_VAR 0 18
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: LD_INT 1
35975: NEG
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 3
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 3
35993: PUSH
35994: LD_INT 1
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: LIST
36005: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36006: LD_ADDR_VAR 0 19
36010: PUSH
36011: LD_INT 3
36013: PUSH
36014: LD_INT 2
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 3
36023: PUSH
36024: LD_INT 3
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: PUSH
36034: LD_INT 3
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: LIST
36045: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36046: LD_ADDR_VAR 0 20
36050: PUSH
36051: LD_INT 1
36053: PUSH
36054: LD_INT 3
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: LD_INT 3
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: LD_INT 2
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: LIST
36086: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36087: LD_ADDR_VAR 0 21
36091: PUSH
36092: LD_INT 2
36094: NEG
36095: PUSH
36096: LD_INT 1
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 3
36105: NEG
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 3
36116: NEG
36117: PUSH
36118: LD_INT 1
36120: NEG
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: LIST
36130: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36131: LD_ADDR_VAR 0 22
36135: PUSH
36136: LD_INT 2
36138: NEG
36139: PUSH
36140: LD_INT 3
36142: NEG
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 3
36150: NEG
36151: PUSH
36152: LD_INT 2
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 3
36162: NEG
36163: PUSH
36164: LD_INT 3
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: LIST
36176: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36177: LD_ADDR_VAR 0 23
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: LD_INT 3
36187: NEG
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 1
36195: NEG
36196: PUSH
36197: LD_INT 4
36199: NEG
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 1
36207: PUSH
36208: LD_INT 3
36210: NEG
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: LIST
36220: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36221: LD_ADDR_VAR 0 24
36225: PUSH
36226: LD_INT 3
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 3
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 4
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: LIST
36261: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36262: LD_ADDR_VAR 0 25
36266: PUSH
36267: LD_INT 3
36269: PUSH
36270: LD_INT 3
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 4
36279: PUSH
36280: LD_INT 3
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 3
36289: PUSH
36290: LD_INT 4
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: LIST
36301: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36302: LD_ADDR_VAR 0 26
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: LD_INT 3
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 1
36319: PUSH
36320: LD_INT 4
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 1
36329: NEG
36330: PUSH
36331: LD_INT 3
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: LIST
36342: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36343: LD_ADDR_VAR 0 27
36347: PUSH
36348: LD_INT 3
36350: NEG
36351: PUSH
36352: LD_INT 0
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: LD_INT 1
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 4
36372: NEG
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: LIST
36386: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36387: LD_ADDR_VAR 0 28
36391: PUSH
36392: LD_INT 3
36394: NEG
36395: PUSH
36396: LD_INT 3
36398: NEG
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 3
36406: NEG
36407: PUSH
36408: LD_INT 4
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 4
36418: NEG
36419: PUSH
36420: LD_INT 3
36422: NEG
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: LIST
36432: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36433: LD_ADDR_VAR 0 29
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: LD_INT 3
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 0
36452: PUSH
36453: LD_INT 3
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: LD_INT 2
36466: NEG
36467: PUSH
36468: EMPTY
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 1
36474: NEG
36475: PUSH
36476: LD_INT 4
36478: NEG
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 4
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 3
36500: NEG
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: LD_INT 5
36512: NEG
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 0
36520: PUSH
36521: LD_INT 5
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 1
36531: PUSH
36532: LD_INT 4
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: LD_INT 6
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 6
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 5
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: LIST
36580: LIST
36581: LIST
36582: LIST
36583: LIST
36584: LIST
36585: LIST
36586: LIST
36587: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36588: LD_ADDR_VAR 0 30
36592: PUSH
36593: LD_INT 2
36595: PUSH
36596: LD_INT 1
36598: NEG
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 3
36606: PUSH
36607: LD_INT 0
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 3
36616: PUSH
36617: LD_INT 1
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 3
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 4
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 4
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 4
36657: PUSH
36658: LD_INT 1
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 5
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 5
36678: PUSH
36679: LD_INT 1
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 5
36688: PUSH
36689: LD_INT 1
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 6
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 6
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: LIST
36721: LIST
36722: LIST
36723: LIST
36724: LIST
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36731: LD_ADDR_VAR 0 31
36735: PUSH
36736: LD_INT 3
36738: PUSH
36739: LD_INT 2
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 3
36748: PUSH
36749: LD_INT 3
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 2
36758: PUSH
36759: LD_INT 3
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 4
36768: PUSH
36769: LD_INT 3
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 4
36778: PUSH
36779: LD_INT 4
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 3
36788: PUSH
36789: LD_INT 4
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 5
36798: PUSH
36799: LD_INT 4
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 5
36808: PUSH
36809: LD_INT 5
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 4
36818: PUSH
36819: LD_INT 5
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 6
36828: PUSH
36829: LD_INT 5
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 6
36838: PUSH
36839: LD_INT 6
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 5
36848: PUSH
36849: LD_INT 6
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36870: LD_ADDR_VAR 0 32
36874: PUSH
36875: LD_INT 1
36877: PUSH
36878: LD_INT 3
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 0
36887: PUSH
36888: LD_INT 3
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 1
36897: NEG
36898: PUSH
36899: LD_INT 2
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: LD_INT 4
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 0
36918: PUSH
36919: LD_INT 4
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 1
36928: NEG
36929: PUSH
36930: LD_INT 3
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: LD_INT 5
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: LD_INT 5
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: LD_INT 4
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: LD_INT 6
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 0
36980: PUSH
36981: LD_INT 6
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: LD_INT 5
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37013: LD_ADDR_VAR 0 33
37017: PUSH
37018: LD_INT 2
37020: NEG
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 3
37031: NEG
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 3
37042: NEG
37043: PUSH
37044: LD_INT 1
37046: NEG
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 3
37054: NEG
37055: PUSH
37056: LD_INT 1
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 4
37065: NEG
37066: PUSH
37067: LD_INT 0
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 4
37076: NEG
37077: PUSH
37078: LD_INT 1
37080: NEG
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 4
37088: NEG
37089: PUSH
37090: LD_INT 1
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 5
37099: NEG
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 5
37110: NEG
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 5
37122: NEG
37123: PUSH
37124: LD_INT 1
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 6
37133: NEG
37134: PUSH
37135: LD_INT 0
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 6
37144: NEG
37145: PUSH
37146: LD_INT 1
37148: NEG
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: LIST
37158: LIST
37159: LIST
37160: LIST
37161: LIST
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37168: LD_ADDR_VAR 0 34
37172: PUSH
37173: LD_INT 2
37175: NEG
37176: PUSH
37177: LD_INT 3
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 3
37187: NEG
37188: PUSH
37189: LD_INT 2
37191: NEG
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 3
37199: NEG
37200: PUSH
37201: LD_INT 3
37203: NEG
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: LD_INT 3
37211: NEG
37212: PUSH
37213: LD_INT 4
37215: NEG
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 4
37223: NEG
37224: PUSH
37225: LD_INT 3
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 4
37235: NEG
37236: PUSH
37237: LD_INT 4
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 4
37247: NEG
37248: PUSH
37249: LD_INT 5
37251: NEG
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 5
37259: NEG
37260: PUSH
37261: LD_INT 4
37263: NEG
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 5
37271: NEG
37272: PUSH
37273: LD_INT 5
37275: NEG
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 5
37283: NEG
37284: PUSH
37285: LD_INT 6
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 6
37295: NEG
37296: PUSH
37297: LD_INT 5
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 6
37307: NEG
37308: PUSH
37309: LD_INT 6
37311: NEG
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37331: LD_ADDR_VAR 0 41
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: LD_INT 3
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: PUSH
37362: LD_INT 2
37364: NEG
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: LIST
37374: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37375: LD_ADDR_VAR 0 42
37379: PUSH
37380: LD_INT 2
37382: PUSH
37383: LD_INT 0
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: LD_INT 1
37395: NEG
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 3
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: LIST
37415: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37416: LD_ADDR_VAR 0 43
37420: PUSH
37421: LD_INT 2
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 3
37433: PUSH
37434: LD_INT 2
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 2
37443: PUSH
37444: LD_INT 3
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37456: LD_ADDR_VAR 0 44
37460: PUSH
37461: LD_INT 0
37463: PUSH
37464: LD_INT 2
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: LD_INT 3
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: LD_INT 2
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: LIST
37496: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37497: LD_ADDR_VAR 0 45
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: LD_INT 0
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: LD_INT 1
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 3
37526: NEG
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: LIST
37540: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37541: LD_ADDR_VAR 0 46
37545: PUSH
37546: LD_INT 2
37548: NEG
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 2
37560: NEG
37561: PUSH
37562: LD_INT 3
37564: NEG
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 3
37572: NEG
37573: PUSH
37574: LD_INT 2
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: LIST
37586: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37587: LD_ADDR_VAR 0 47
37591: PUSH
37592: LD_INT 2
37594: NEG
37595: PUSH
37596: LD_INT 3
37598: NEG
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 1
37606: NEG
37607: PUSH
37608: LD_INT 3
37610: NEG
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37620: LD_ADDR_VAR 0 48
37624: PUSH
37625: LD_INT 1
37627: PUSH
37628: LD_INT 2
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: LD_INT 1
37641: NEG
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37651: LD_ADDR_VAR 0 49
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: LD_INT 1
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 3
37668: PUSH
37669: LD_INT 2
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37680: LD_ADDR_VAR 0 50
37684: PUSH
37685: LD_INT 2
37687: PUSH
37688: LD_INT 3
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: PUSH
37698: LD_INT 3
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37709: LD_ADDR_VAR 0 51
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 2
37727: NEG
37728: PUSH
37729: LD_INT 1
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37740: LD_ADDR_VAR 0 52
37744: PUSH
37745: LD_INT 3
37747: NEG
37748: PUSH
37749: LD_INT 1
37751: NEG
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 3
37759: NEG
37760: PUSH
37761: LD_INT 2
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37773: LD_ADDR_VAR 0 53
37777: PUSH
37778: LD_INT 1
37780: NEG
37781: PUSH
37782: LD_INT 3
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 0
37792: PUSH
37793: LD_INT 3
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: LIST
37816: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37817: LD_ADDR_VAR 0 54
37821: PUSH
37822: LD_INT 2
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 3
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 3
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: LIST
37857: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37858: LD_ADDR_VAR 0 55
37862: PUSH
37863: LD_INT 3
37865: PUSH
37866: LD_INT 2
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 3
37875: PUSH
37876: LD_INT 3
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: PUSH
37886: LD_INT 3
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: LIST
37897: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37898: LD_ADDR_VAR 0 56
37902: PUSH
37903: LD_INT 1
37905: PUSH
37906: LD_INT 3
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 0
37915: PUSH
37916: LD_INT 3
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: LD_INT 2
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37939: LD_ADDR_VAR 0 57
37943: PUSH
37944: LD_INT 2
37946: NEG
37947: PUSH
37948: LD_INT 1
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 3
37957: NEG
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 3
37968: NEG
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: LIST
37982: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37983: LD_ADDR_VAR 0 58
37987: PUSH
37988: LD_INT 2
37990: NEG
37991: PUSH
37992: LD_INT 3
37994: NEG
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 3
38002: NEG
38003: PUSH
38004: LD_INT 2
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 3
38014: NEG
38015: PUSH
38016: LD_INT 3
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: LIST
38028: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38029: LD_ADDR_VAR 0 59
38033: PUSH
38034: LD_INT 1
38036: NEG
38037: PUSH
38038: LD_INT 2
38040: NEG
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 2
38051: NEG
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 1
38059: PUSH
38060: LD_INT 1
38062: NEG
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: LIST
38072: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38073: LD_ADDR_VAR 0 60
38077: PUSH
38078: LD_INT 1
38080: PUSH
38081: LD_INT 1
38083: NEG
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 2
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 2
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: LIST
38113: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38114: LD_ADDR_VAR 0 61
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: LD_INT 1
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: LD_INT 2
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 2
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: LIST
38153: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38154: LD_ADDR_VAR 0 62
38158: PUSH
38159: LD_INT 1
38161: PUSH
38162: LD_INT 2
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: LD_INT 2
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: LD_INT 1
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: LIST
38194: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38195: LD_ADDR_VAR 0 63
38199: PUSH
38200: LD_INT 1
38202: NEG
38203: PUSH
38204: LD_INT 1
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 2
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: NEG
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: LIST
38238: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38239: LD_ADDR_VAR 0 64
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: LD_INT 2
38250: NEG
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 2
38258: NEG
38259: PUSH
38260: LD_INT 1
38262: NEG
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 2
38270: NEG
38271: PUSH
38272: LD_INT 2
38274: NEG
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// end ; 2 :
38285: GO 41551
38287: LD_INT 2
38289: DOUBLE
38290: EQUAL
38291: IFTRUE 38295
38293: GO 41550
38295: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38296: LD_ADDR_VAR 0 29
38300: PUSH
38301: LD_INT 4
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 4
38313: PUSH
38314: LD_INT 1
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 5
38324: PUSH
38325: LD_INT 0
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 5
38334: PUSH
38335: LD_INT 1
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 4
38344: PUSH
38345: LD_INT 1
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 3
38354: PUSH
38355: LD_INT 0
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 3
38364: PUSH
38365: LD_INT 1
38367: NEG
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 3
38375: PUSH
38376: LD_INT 2
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 5
38386: PUSH
38387: LD_INT 2
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 3
38396: PUSH
38397: LD_INT 3
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 3
38406: PUSH
38407: LD_INT 2
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 4
38416: PUSH
38417: LD_INT 3
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 4
38426: PUSH
38427: LD_INT 4
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 3
38436: PUSH
38437: LD_INT 4
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 2
38446: PUSH
38447: LD_INT 3
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 2
38456: PUSH
38457: LD_INT 2
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 4
38466: PUSH
38467: LD_INT 2
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 2
38476: PUSH
38477: LD_INT 4
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: LD_INT 4
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 0
38496: PUSH
38497: LD_INT 3
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 1
38506: PUSH
38507: LD_INT 4
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: PUSH
38517: LD_INT 5
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: LD_INT 5
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 1
38536: NEG
38537: PUSH
38538: LD_INT 4
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: LD_INT 3
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 2
38558: PUSH
38559: LD_INT 5
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 2
38568: NEG
38569: PUSH
38570: LD_INT 3
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 3
38579: NEG
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 3
38590: NEG
38591: PUSH
38592: LD_INT 1
38594: NEG
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 2
38602: NEG
38603: PUSH
38604: LD_INT 0
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 2
38613: NEG
38614: PUSH
38615: LD_INT 1
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 3
38624: NEG
38625: PUSH
38626: LD_INT 1
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 4
38635: NEG
38636: PUSH
38637: LD_INT 0
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 4
38646: NEG
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 4
38658: NEG
38659: PUSH
38660: LD_INT 2
38662: NEG
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 2
38670: NEG
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 4
38681: NEG
38682: PUSH
38683: LD_INT 4
38685: NEG
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: PUSH
38691: LD_INT 4
38693: NEG
38694: PUSH
38695: LD_INT 5
38697: NEG
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 3
38705: NEG
38706: PUSH
38707: LD_INT 4
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 3
38717: NEG
38718: PUSH
38719: LD_INT 3
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 4
38729: NEG
38730: PUSH
38731: LD_INT 3
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 5
38741: NEG
38742: PUSH
38743: LD_INT 4
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 5
38753: NEG
38754: PUSH
38755: LD_INT 5
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: LD_INT 5
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 5
38777: NEG
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38834: LD_ADDR_VAR 0 30
38838: PUSH
38839: LD_INT 4
38841: PUSH
38842: LD_INT 4
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 4
38851: PUSH
38852: LD_INT 3
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 5
38861: PUSH
38862: LD_INT 4
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 5
38871: PUSH
38872: LD_INT 5
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 4
38881: PUSH
38882: LD_INT 5
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 3
38891: PUSH
38892: LD_INT 4
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 3
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 5
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 3
38921: PUSH
38922: LD_INT 5
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: LD_INT 2
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: LD_INT 3
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: LD_INT 4
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 0
38971: PUSH
38972: LD_INT 4
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 1
38992: NEG
38993: PUSH
38994: LD_INT 2
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 2
39003: PUSH
39004: LD_INT 4
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 2
39013: NEG
39014: PUSH
39015: LD_INT 2
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 4
39024: NEG
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 4
39035: NEG
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 3
39058: NEG
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 4
39069: NEG
39070: PUSH
39071: LD_INT 1
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 5
39080: NEG
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 5
39091: NEG
39092: PUSH
39093: LD_INT 1
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 5
39103: NEG
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 3
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 3
39126: NEG
39127: PUSH
39128: LD_INT 3
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 3
39138: NEG
39139: PUSH
39140: LD_INT 4
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 2
39150: NEG
39151: PUSH
39152: LD_INT 3
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 2
39162: NEG
39163: PUSH
39164: LD_INT 2
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 3
39174: NEG
39175: PUSH
39176: LD_INT 2
39178: NEG
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 4
39186: NEG
39187: PUSH
39188: LD_INT 3
39190: NEG
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 4
39198: NEG
39199: PUSH
39200: LD_INT 4
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: NEG
39211: PUSH
39212: LD_INT 4
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 4
39222: NEG
39223: PUSH
39224: LD_INT 2
39226: NEG
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 0
39234: PUSH
39235: LD_INT 4
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 0
39245: PUSH
39246: LD_INT 5
39248: NEG
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 1
39256: PUSH
39257: LD_INT 4
39259: NEG
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: LD_INT 3
39270: NEG
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: LD_INT 3
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 1
39289: NEG
39290: PUSH
39291: LD_INT 4
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: LD_INT 5
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 2
39313: PUSH
39314: LD_INT 3
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 2
39324: NEG
39325: PUSH
39326: LD_INT 5
39328: NEG
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39381: LD_ADDR_VAR 0 31
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: LD_INT 4
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 3
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 1
39408: PUSH
39409: LD_INT 4
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: LD_INT 5
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: LD_INT 5
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 1
39438: NEG
39439: PUSH
39440: LD_INT 4
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 3
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 2
39460: PUSH
39461: LD_INT 5
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 2
39470: NEG
39471: PUSH
39472: LD_INT 3
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 3
39481: NEG
39482: PUSH
39483: LD_INT 0
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 3
39492: NEG
39493: PUSH
39494: LD_INT 1
39496: NEG
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 2
39504: NEG
39505: PUSH
39506: LD_INT 0
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 2
39515: NEG
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 4
39537: NEG
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 4
39548: NEG
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 4
39560: NEG
39561: PUSH
39562: LD_INT 2
39564: NEG
39565: PUSH
39566: EMPTY
39567: LIST
39568: LIST
39569: PUSH
39570: LD_INT 2
39572: NEG
39573: PUSH
39574: LD_INT 2
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 4
39583: NEG
39584: PUSH
39585: LD_INT 4
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 4
39595: NEG
39596: PUSH
39597: LD_INT 5
39599: NEG
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 3
39607: NEG
39608: PUSH
39609: LD_INT 4
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 3
39619: NEG
39620: PUSH
39621: LD_INT 3
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: LD_INT 3
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 5
39643: NEG
39644: PUSH
39645: LD_INT 4
39647: NEG
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 5
39655: NEG
39656: PUSH
39657: LD_INT 5
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 3
39667: NEG
39668: PUSH
39669: LD_INT 5
39671: NEG
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 5
39679: NEG
39680: PUSH
39681: LD_INT 3
39683: NEG
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 0
39691: PUSH
39692: LD_INT 3
39694: NEG
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 0
39702: PUSH
39703: LD_INT 4
39705: NEG
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: LD_INT 3
39716: NEG
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 1
39724: PUSH
39725: LD_INT 2
39727: NEG
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 0
39735: PUSH
39736: LD_INT 2
39738: NEG
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 1
39746: NEG
39747: PUSH
39748: LD_INT 3
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: LD_INT 4
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 2
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: NEG
39782: PUSH
39783: LD_INT 4
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 4
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 4
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 5
39814: PUSH
39815: LD_INT 0
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 5
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 4
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 3
39854: PUSH
39855: LD_INT 1
39857: NEG
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: LD_INT 2
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 5
39876: PUSH
39877: LD_INT 2
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39931: LD_ADDR_VAR 0 32
39935: PUSH
39936: LD_INT 4
39938: NEG
39939: PUSH
39940: LD_INT 0
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 4
39949: NEG
39950: PUSH
39951: LD_INT 1
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 3
39961: NEG
39962: PUSH
39963: LD_INT 0
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 3
39972: NEG
39973: PUSH
39974: LD_INT 1
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 4
39983: NEG
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 5
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 5
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 5
40017: NEG
40018: PUSH
40019: LD_INT 2
40021: NEG
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 3
40029: NEG
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 3
40040: NEG
40041: PUSH
40042: LD_INT 3
40044: NEG
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: LD_INT 3
40052: NEG
40053: PUSH
40054: LD_INT 4
40056: NEG
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 2
40064: NEG
40065: PUSH
40066: LD_INT 3
40068: NEG
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 2
40076: NEG
40077: PUSH
40078: LD_INT 2
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 3
40088: NEG
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 4
40100: NEG
40101: PUSH
40102: LD_INT 3
40104: NEG
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 4
40112: NEG
40113: PUSH
40114: LD_INT 4
40116: NEG
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: LD_INT 4
40128: NEG
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 4
40136: NEG
40137: PUSH
40138: LD_INT 2
40140: NEG
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: LD_INT 4
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 5
40162: NEG
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: LD_INT 4
40173: NEG
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 1
40181: PUSH
40182: LD_INT 3
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 0
40192: PUSH
40193: LD_INT 3
40195: NEG
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 1
40203: NEG
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: LD_INT 5
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: LD_INT 3
40230: NEG
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 2
40238: NEG
40239: PUSH
40240: LD_INT 5
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 3
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 3
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 4
40271: PUSH
40272: LD_INT 0
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 4
40281: PUSH
40282: LD_INT 1
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 3
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 2
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 2
40322: PUSH
40323: LD_INT 2
40325: NEG
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 4
40333: PUSH
40334: LD_INT 2
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 4
40343: PUSH
40344: LD_INT 4
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 4
40353: PUSH
40354: LD_INT 3
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 5
40363: PUSH
40364: LD_INT 4
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 5
40373: PUSH
40374: LD_INT 5
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 4
40383: PUSH
40384: LD_INT 5
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 3
40393: PUSH
40394: LD_INT 4
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 3
40403: PUSH
40404: LD_INT 3
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 5
40413: PUSH
40414: LD_INT 3
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 3
40423: PUSH
40424: LD_INT 5
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40478: LD_ADDR_VAR 0 33
40482: PUSH
40483: LD_INT 4
40485: NEG
40486: PUSH
40487: LD_INT 4
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 4
40497: NEG
40498: PUSH
40499: LD_INT 5
40501: NEG
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: LD_INT 4
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 3
40521: NEG
40522: PUSH
40523: LD_INT 3
40525: NEG
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 4
40533: NEG
40534: PUSH
40535: LD_INT 3
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 5
40545: NEG
40546: PUSH
40547: LD_INT 4
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 5
40557: NEG
40558: PUSH
40559: LD_INT 5
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 3
40569: NEG
40570: PUSH
40571: LD_INT 5
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 5
40581: NEG
40582: PUSH
40583: LD_INT 3
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: LD_INT 3
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 0
40604: PUSH
40605: LD_INT 4
40607: NEG
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 1
40615: PUSH
40616: LD_INT 3
40618: NEG
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: PUSH
40627: LD_INT 2
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 0
40637: PUSH
40638: LD_INT 2
40640: NEG
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 1
40648: NEG
40649: PUSH
40650: LD_INT 3
40652: NEG
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 1
40660: NEG
40661: PUSH
40662: LD_INT 4
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 2
40672: PUSH
40673: LD_INT 2
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 2
40683: NEG
40684: PUSH
40685: LD_INT 4
40687: NEG
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 4
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 4
40705: PUSH
40706: LD_INT 1
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 5
40716: PUSH
40717: LD_INT 0
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 5
40726: PUSH
40727: LD_INT 1
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 4
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 3
40746: PUSH
40747: LD_INT 0
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 3
40756: PUSH
40757: LD_INT 1
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 3
40767: PUSH
40768: LD_INT 2
40770: NEG
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 5
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 3
40788: PUSH
40789: LD_INT 3
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 3
40798: PUSH
40799: LD_INT 2
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 4
40808: PUSH
40809: LD_INT 3
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 4
40818: PUSH
40819: LD_INT 4
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: LD_INT 4
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 2
40838: PUSH
40839: LD_INT 3
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 2
40848: PUSH
40849: LD_INT 2
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 4
40858: PUSH
40859: LD_INT 2
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 2
40868: PUSH
40869: LD_INT 4
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: LD_INT 4
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: LD_INT 3
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 4
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 5
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 5
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: NEG
40929: PUSH
40930: LD_INT 4
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 3
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: LD_INT 2
40950: PUSH
40951: LD_INT 5
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 2
40960: NEG
40961: PUSH
40962: LD_INT 3
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41016: LD_ADDR_VAR 0 34
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: LD_INT 4
41026: NEG
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: LD_INT 0
41034: PUSH
41035: LD_INT 5
41037: NEG
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: LD_INT 4
41048: NEG
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 1
41056: PUSH
41057: LD_INT 3
41059: NEG
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: LD_INT 3
41070: NEG
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 1
41078: NEG
41079: PUSH
41080: LD_INT 4
41082: NEG
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: LD_INT 1
41090: NEG
41091: PUSH
41092: LD_INT 5
41094: NEG
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 3
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 2
41113: NEG
41114: PUSH
41115: LD_INT 5
41117: NEG
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 3
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 3
41135: PUSH
41136: LD_INT 1
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 4
41146: PUSH
41147: LD_INT 0
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: LD_INT 4
41156: PUSH
41157: LD_INT 1
41159: PUSH
41160: EMPTY
41161: LIST
41162: LIST
41163: PUSH
41164: LD_INT 3
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 2
41176: PUSH
41177: LD_INT 0
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 2
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 2
41197: PUSH
41198: LD_INT 2
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 4
41208: PUSH
41209: LD_INT 2
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 4
41218: PUSH
41219: LD_INT 4
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 4
41228: PUSH
41229: LD_INT 3
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 5
41238: PUSH
41239: LD_INT 4
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 5
41248: PUSH
41249: LD_INT 5
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 4
41258: PUSH
41259: LD_INT 5
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: LD_INT 4
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 3
41278: PUSH
41279: LD_INT 3
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 5
41288: PUSH
41289: LD_INT 3
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: LD_INT 3
41298: PUSH
41299: LD_INT 5
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: PUSH
41306: LD_INT 0
41308: PUSH
41309: LD_INT 3
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PUSH
41316: LD_INT 0
41318: PUSH
41319: LD_INT 2
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 1
41328: PUSH
41329: LD_INT 3
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: LD_INT 4
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: LD_INT 4
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 1
41358: NEG
41359: PUSH
41360: LD_INT 3
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: LD_INT 2
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 4
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: NEG
41391: PUSH
41392: LD_INT 2
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 4
41401: NEG
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 4
41412: NEG
41413: PUSH
41414: LD_INT 1
41416: NEG
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 3
41435: NEG
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 1
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 5
41457: NEG
41458: PUSH
41459: LD_INT 0
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 5
41468: NEG
41469: PUSH
41470: LD_INT 1
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 5
41480: NEG
41481: PUSH
41482: LD_INT 2
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 3
41492: NEG
41493: PUSH
41494: LD_INT 2
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: LIST
41505: LIST
41506: LIST
41507: LIST
41508: LIST
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: ST_TO_ADDR
// end ; end ;
41548: GO 41551
41550: POP
// case btype of b_depot , b_warehouse :
41551: LD_VAR 0 1
41555: PUSH
41556: LD_INT 0
41558: DOUBLE
41559: EQUAL
41560: IFTRUE 41570
41562: LD_INT 1
41564: DOUBLE
41565: EQUAL
41566: IFTRUE 41570
41568: GO 41771
41570: POP
// case nation of nation_american :
41571: LD_VAR 0 5
41575: PUSH
41576: LD_INT 1
41578: DOUBLE
41579: EQUAL
41580: IFTRUE 41584
41582: GO 41640
41584: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41585: LD_ADDR_VAR 0 9
41589: PUSH
41590: LD_VAR 0 11
41594: PUSH
41595: LD_VAR 0 12
41599: PUSH
41600: LD_VAR 0 13
41604: PUSH
41605: LD_VAR 0 14
41609: PUSH
41610: LD_VAR 0 15
41614: PUSH
41615: LD_VAR 0 16
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: LIST
41624: LIST
41625: LIST
41626: LIST
41627: PUSH
41628: LD_VAR 0 4
41632: PUSH
41633: LD_INT 1
41635: PLUS
41636: ARRAY
41637: ST_TO_ADDR
41638: GO 41769
41640: LD_INT 2
41642: DOUBLE
41643: EQUAL
41644: IFTRUE 41648
41646: GO 41704
41648: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41649: LD_ADDR_VAR 0 9
41653: PUSH
41654: LD_VAR 0 17
41658: PUSH
41659: LD_VAR 0 18
41663: PUSH
41664: LD_VAR 0 19
41668: PUSH
41669: LD_VAR 0 20
41673: PUSH
41674: LD_VAR 0 21
41678: PUSH
41679: LD_VAR 0 22
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: PUSH
41692: LD_VAR 0 4
41696: PUSH
41697: LD_INT 1
41699: PLUS
41700: ARRAY
41701: ST_TO_ADDR
41702: GO 41769
41704: LD_INT 3
41706: DOUBLE
41707: EQUAL
41708: IFTRUE 41712
41710: GO 41768
41712: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41713: LD_ADDR_VAR 0 9
41717: PUSH
41718: LD_VAR 0 23
41722: PUSH
41723: LD_VAR 0 24
41727: PUSH
41728: LD_VAR 0 25
41732: PUSH
41733: LD_VAR 0 26
41737: PUSH
41738: LD_VAR 0 27
41742: PUSH
41743: LD_VAR 0 28
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: PUSH
41756: LD_VAR 0 4
41760: PUSH
41761: LD_INT 1
41763: PLUS
41764: ARRAY
41765: ST_TO_ADDR
41766: GO 41769
41768: POP
41769: GO 42324
41771: LD_INT 2
41773: DOUBLE
41774: EQUAL
41775: IFTRUE 41785
41777: LD_INT 3
41779: DOUBLE
41780: EQUAL
41781: IFTRUE 41785
41783: GO 41841
41785: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41786: LD_ADDR_VAR 0 9
41790: PUSH
41791: LD_VAR 0 29
41795: PUSH
41796: LD_VAR 0 30
41800: PUSH
41801: LD_VAR 0 31
41805: PUSH
41806: LD_VAR 0 32
41810: PUSH
41811: LD_VAR 0 33
41815: PUSH
41816: LD_VAR 0 34
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: PUSH
41829: LD_VAR 0 4
41833: PUSH
41834: LD_INT 1
41836: PLUS
41837: ARRAY
41838: ST_TO_ADDR
41839: GO 42324
41841: LD_INT 16
41843: DOUBLE
41844: EQUAL
41845: IFTRUE 41903
41847: LD_INT 17
41849: DOUBLE
41850: EQUAL
41851: IFTRUE 41903
41853: LD_INT 18
41855: DOUBLE
41856: EQUAL
41857: IFTRUE 41903
41859: LD_INT 19
41861: DOUBLE
41862: EQUAL
41863: IFTRUE 41903
41865: LD_INT 22
41867: DOUBLE
41868: EQUAL
41869: IFTRUE 41903
41871: LD_INT 20
41873: DOUBLE
41874: EQUAL
41875: IFTRUE 41903
41877: LD_INT 21
41879: DOUBLE
41880: EQUAL
41881: IFTRUE 41903
41883: LD_INT 23
41885: DOUBLE
41886: EQUAL
41887: IFTRUE 41903
41889: LD_INT 24
41891: DOUBLE
41892: EQUAL
41893: IFTRUE 41903
41895: LD_INT 25
41897: DOUBLE
41898: EQUAL
41899: IFTRUE 41903
41901: GO 41959
41903: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41904: LD_ADDR_VAR 0 9
41908: PUSH
41909: LD_VAR 0 35
41913: PUSH
41914: LD_VAR 0 36
41918: PUSH
41919: LD_VAR 0 37
41923: PUSH
41924: LD_VAR 0 38
41928: PUSH
41929: LD_VAR 0 39
41933: PUSH
41934: LD_VAR 0 40
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: PUSH
41947: LD_VAR 0 4
41951: PUSH
41952: LD_INT 1
41954: PLUS
41955: ARRAY
41956: ST_TO_ADDR
41957: GO 42324
41959: LD_INT 6
41961: DOUBLE
41962: EQUAL
41963: IFTRUE 42015
41965: LD_INT 7
41967: DOUBLE
41968: EQUAL
41969: IFTRUE 42015
41971: LD_INT 8
41973: DOUBLE
41974: EQUAL
41975: IFTRUE 42015
41977: LD_INT 13
41979: DOUBLE
41980: EQUAL
41981: IFTRUE 42015
41983: LD_INT 12
41985: DOUBLE
41986: EQUAL
41987: IFTRUE 42015
41989: LD_INT 15
41991: DOUBLE
41992: EQUAL
41993: IFTRUE 42015
41995: LD_INT 11
41997: DOUBLE
41998: EQUAL
41999: IFTRUE 42015
42001: LD_INT 14
42003: DOUBLE
42004: EQUAL
42005: IFTRUE 42015
42007: LD_INT 10
42009: DOUBLE
42010: EQUAL
42011: IFTRUE 42015
42013: GO 42071
42015: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42016: LD_ADDR_VAR 0 9
42020: PUSH
42021: LD_VAR 0 41
42025: PUSH
42026: LD_VAR 0 42
42030: PUSH
42031: LD_VAR 0 43
42035: PUSH
42036: LD_VAR 0 44
42040: PUSH
42041: LD_VAR 0 45
42045: PUSH
42046: LD_VAR 0 46
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: PUSH
42059: LD_VAR 0 4
42063: PUSH
42064: LD_INT 1
42066: PLUS
42067: ARRAY
42068: ST_TO_ADDR
42069: GO 42324
42071: LD_INT 36
42073: DOUBLE
42074: EQUAL
42075: IFTRUE 42079
42077: GO 42135
42079: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42080: LD_ADDR_VAR 0 9
42084: PUSH
42085: LD_VAR 0 47
42089: PUSH
42090: LD_VAR 0 48
42094: PUSH
42095: LD_VAR 0 49
42099: PUSH
42100: LD_VAR 0 50
42104: PUSH
42105: LD_VAR 0 51
42109: PUSH
42110: LD_VAR 0 52
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: LIST
42122: PUSH
42123: LD_VAR 0 4
42127: PUSH
42128: LD_INT 1
42130: PLUS
42131: ARRAY
42132: ST_TO_ADDR
42133: GO 42324
42135: LD_INT 4
42137: DOUBLE
42138: EQUAL
42139: IFTRUE 42161
42141: LD_INT 5
42143: DOUBLE
42144: EQUAL
42145: IFTRUE 42161
42147: LD_INT 34
42149: DOUBLE
42150: EQUAL
42151: IFTRUE 42161
42153: LD_INT 37
42155: DOUBLE
42156: EQUAL
42157: IFTRUE 42161
42159: GO 42217
42161: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42162: LD_ADDR_VAR 0 9
42166: PUSH
42167: LD_VAR 0 53
42171: PUSH
42172: LD_VAR 0 54
42176: PUSH
42177: LD_VAR 0 55
42181: PUSH
42182: LD_VAR 0 56
42186: PUSH
42187: LD_VAR 0 57
42191: PUSH
42192: LD_VAR 0 58
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: LD_INT 1
42212: PLUS
42213: ARRAY
42214: ST_TO_ADDR
42215: GO 42324
42217: LD_INT 31
42219: DOUBLE
42220: EQUAL
42221: IFTRUE 42267
42223: LD_INT 32
42225: DOUBLE
42226: EQUAL
42227: IFTRUE 42267
42229: LD_INT 33
42231: DOUBLE
42232: EQUAL
42233: IFTRUE 42267
42235: LD_INT 27
42237: DOUBLE
42238: EQUAL
42239: IFTRUE 42267
42241: LD_INT 26
42243: DOUBLE
42244: EQUAL
42245: IFTRUE 42267
42247: LD_INT 28
42249: DOUBLE
42250: EQUAL
42251: IFTRUE 42267
42253: LD_INT 29
42255: DOUBLE
42256: EQUAL
42257: IFTRUE 42267
42259: LD_INT 30
42261: DOUBLE
42262: EQUAL
42263: IFTRUE 42267
42265: GO 42323
42267: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42268: LD_ADDR_VAR 0 9
42272: PUSH
42273: LD_VAR 0 59
42277: PUSH
42278: LD_VAR 0 60
42282: PUSH
42283: LD_VAR 0 61
42287: PUSH
42288: LD_VAR 0 62
42292: PUSH
42293: LD_VAR 0 63
42297: PUSH
42298: LD_VAR 0 64
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: PUSH
42311: LD_VAR 0 4
42315: PUSH
42316: LD_INT 1
42318: PLUS
42319: ARRAY
42320: ST_TO_ADDR
42321: GO 42324
42323: POP
// temp_list2 = [ ] ;
42324: LD_ADDR_VAR 0 10
42328: PUSH
42329: EMPTY
42330: ST_TO_ADDR
// for i in temp_list do
42331: LD_ADDR_VAR 0 8
42335: PUSH
42336: LD_VAR 0 9
42340: PUSH
42341: FOR_IN
42342: IFFALSE 42394
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42344: LD_ADDR_VAR 0 10
42348: PUSH
42349: LD_VAR 0 10
42353: PUSH
42354: LD_VAR 0 8
42358: PUSH
42359: LD_INT 1
42361: ARRAY
42362: PUSH
42363: LD_VAR 0 2
42367: PLUS
42368: PUSH
42369: LD_VAR 0 8
42373: PUSH
42374: LD_INT 2
42376: ARRAY
42377: PUSH
42378: LD_VAR 0 3
42382: PLUS
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: EMPTY
42389: LIST
42390: ADD
42391: ST_TO_ADDR
42392: GO 42341
42394: POP
42395: POP
// result = temp_list2 ;
42396: LD_ADDR_VAR 0 7
42400: PUSH
42401: LD_VAR 0 10
42405: ST_TO_ADDR
// end ;
42406: LD_VAR 0 7
42410: RET
// export function EnemyInRange ( unit , dist ) ; begin
42411: LD_INT 0
42413: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42414: LD_ADDR_VAR 0 3
42418: PUSH
42419: LD_VAR 0 1
42423: PPUSH
42424: CALL_OW 255
42428: PPUSH
42429: LD_VAR 0 1
42433: PPUSH
42434: CALL_OW 250
42438: PPUSH
42439: LD_VAR 0 1
42443: PPUSH
42444: CALL_OW 251
42448: PPUSH
42449: LD_VAR 0 2
42453: PPUSH
42454: CALL 15813 0 4
42458: PUSH
42459: LD_INT 4
42461: ARRAY
42462: ST_TO_ADDR
// end ;
42463: LD_VAR 0 3
42467: RET
// export function PlayerSeeMe ( unit ) ; begin
42468: LD_INT 0
42470: PPUSH
// result := See ( your_side , unit ) ;
42471: LD_ADDR_VAR 0 2
42475: PUSH
42476: LD_OWVAR 2
42480: PPUSH
42481: LD_VAR 0 1
42485: PPUSH
42486: CALL_OW 292
42490: ST_TO_ADDR
// end ;
42491: LD_VAR 0 2
42495: RET
// export function ReverseDir ( unit ) ; begin
42496: LD_INT 0
42498: PPUSH
// if not unit then
42499: LD_VAR 0 1
42503: NOT
42504: IFFALSE 42508
// exit ;
42506: GO 42531
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42508: LD_ADDR_VAR 0 2
42512: PUSH
42513: LD_VAR 0 1
42517: PPUSH
42518: CALL_OW 254
42522: PUSH
42523: LD_INT 3
42525: PLUS
42526: PUSH
42527: LD_INT 6
42529: MOD
42530: ST_TO_ADDR
// end ;
42531: LD_VAR 0 2
42535: RET
// export function ReverseArray ( array ) ; var i ; begin
42536: LD_INT 0
42538: PPUSH
42539: PPUSH
// if not array then
42540: LD_VAR 0 1
42544: NOT
42545: IFFALSE 42549
// exit ;
42547: GO 42604
// result := [ ] ;
42549: LD_ADDR_VAR 0 2
42553: PUSH
42554: EMPTY
42555: ST_TO_ADDR
// for i := array downto 1 do
42556: LD_ADDR_VAR 0 3
42560: PUSH
42561: DOUBLE
42562: LD_VAR 0 1
42566: INC
42567: ST_TO_ADDR
42568: LD_INT 1
42570: PUSH
42571: FOR_DOWNTO
42572: IFFALSE 42602
// result := Join ( result , array [ i ] ) ;
42574: LD_ADDR_VAR 0 2
42578: PUSH
42579: LD_VAR 0 2
42583: PPUSH
42584: LD_VAR 0 1
42588: PUSH
42589: LD_VAR 0 3
42593: ARRAY
42594: PPUSH
42595: CALL 47247 0 2
42599: ST_TO_ADDR
42600: GO 42571
42602: POP
42603: POP
// end ;
42604: LD_VAR 0 2
42608: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42609: LD_INT 0
42611: PPUSH
42612: PPUSH
42613: PPUSH
42614: PPUSH
42615: PPUSH
42616: PPUSH
// if not unit or not hexes then
42617: LD_VAR 0 1
42621: NOT
42622: PUSH
42623: LD_VAR 0 2
42627: NOT
42628: OR
42629: IFFALSE 42633
// exit ;
42631: GO 42756
// dist := 9999 ;
42633: LD_ADDR_VAR 0 5
42637: PUSH
42638: LD_INT 9999
42640: ST_TO_ADDR
// for i = 1 to hexes do
42641: LD_ADDR_VAR 0 4
42645: PUSH
42646: DOUBLE
42647: LD_INT 1
42649: DEC
42650: ST_TO_ADDR
42651: LD_VAR 0 2
42655: PUSH
42656: FOR_TO
42657: IFFALSE 42744
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42659: LD_ADDR_VAR 0 6
42663: PUSH
42664: LD_VAR 0 1
42668: PPUSH
42669: LD_VAR 0 2
42673: PUSH
42674: LD_VAR 0 4
42678: ARRAY
42679: PUSH
42680: LD_INT 1
42682: ARRAY
42683: PPUSH
42684: LD_VAR 0 2
42688: PUSH
42689: LD_VAR 0 4
42693: ARRAY
42694: PUSH
42695: LD_INT 2
42697: ARRAY
42698: PPUSH
42699: CALL_OW 297
42703: ST_TO_ADDR
// if tdist < dist then
42704: LD_VAR 0 6
42708: PUSH
42709: LD_VAR 0 5
42713: LESS
42714: IFFALSE 42742
// begin hex := hexes [ i ] ;
42716: LD_ADDR_VAR 0 8
42720: PUSH
42721: LD_VAR 0 2
42725: PUSH
42726: LD_VAR 0 4
42730: ARRAY
42731: ST_TO_ADDR
// dist := tdist ;
42732: LD_ADDR_VAR 0 5
42736: PUSH
42737: LD_VAR 0 6
42741: ST_TO_ADDR
// end ; end ;
42742: GO 42656
42744: POP
42745: POP
// result := hex ;
42746: LD_ADDR_VAR 0 3
42750: PUSH
42751: LD_VAR 0 8
42755: ST_TO_ADDR
// end ;
42756: LD_VAR 0 3
42760: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42761: LD_INT 0
42763: PPUSH
42764: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42765: LD_VAR 0 1
42769: NOT
42770: PUSH
42771: LD_VAR 0 1
42775: PUSH
42776: LD_INT 21
42778: PUSH
42779: LD_INT 2
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 23
42788: PUSH
42789: LD_INT 2
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PPUSH
42800: CALL_OW 69
42804: IN
42805: NOT
42806: OR
42807: IFFALSE 42811
// exit ;
42809: GO 42858
// for i = 1 to 3 do
42811: LD_ADDR_VAR 0 3
42815: PUSH
42816: DOUBLE
42817: LD_INT 1
42819: DEC
42820: ST_TO_ADDR
42821: LD_INT 3
42823: PUSH
42824: FOR_TO
42825: IFFALSE 42856
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42827: LD_VAR 0 1
42831: PPUSH
42832: CALL_OW 250
42836: PPUSH
42837: LD_VAR 0 1
42841: PPUSH
42842: CALL_OW 251
42846: PPUSH
42847: LD_INT 1
42849: PPUSH
42850: CALL_OW 453
42854: GO 42824
42856: POP
42857: POP
// end ;
42858: LD_VAR 0 2
42862: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42863: LD_INT 0
42865: PPUSH
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
42870: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42871: LD_VAR 0 1
42875: NOT
42876: PUSH
42877: LD_VAR 0 2
42881: NOT
42882: OR
42883: PUSH
42884: LD_VAR 0 1
42888: PPUSH
42889: CALL_OW 314
42893: OR
42894: IFFALSE 42898
// exit ;
42896: GO 43365
// if GetLives ( i ) < 250 then
42898: LD_VAR 0 4
42902: PPUSH
42903: CALL_OW 256
42907: PUSH
42908: LD_INT 250
42910: LESS
42911: IFFALSE 42924
// begin ComAutodestruct ( i ) ;
42913: LD_VAR 0 4
42917: PPUSH
42918: CALL 42761 0 1
// exit ;
42922: GO 43365
// end ; x := GetX ( enemy_unit ) ;
42924: LD_ADDR_VAR 0 7
42928: PUSH
42929: LD_VAR 0 2
42933: PPUSH
42934: CALL_OW 250
42938: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42939: LD_ADDR_VAR 0 8
42943: PUSH
42944: LD_VAR 0 2
42948: PPUSH
42949: CALL_OW 251
42953: ST_TO_ADDR
// if not x or not y then
42954: LD_VAR 0 7
42958: NOT
42959: PUSH
42960: LD_VAR 0 8
42964: NOT
42965: OR
42966: IFFALSE 42970
// exit ;
42968: GO 43365
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42970: LD_ADDR_VAR 0 6
42974: PUSH
42975: LD_VAR 0 7
42979: PPUSH
42980: LD_INT 0
42982: PPUSH
42983: LD_INT 4
42985: PPUSH
42986: CALL_OW 272
42990: PUSH
42991: LD_VAR 0 8
42995: PPUSH
42996: LD_INT 0
42998: PPUSH
42999: LD_INT 4
43001: PPUSH
43002: CALL_OW 273
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: LD_VAR 0 7
43015: PPUSH
43016: LD_INT 1
43018: PPUSH
43019: LD_INT 4
43021: PPUSH
43022: CALL_OW 272
43026: PUSH
43027: LD_VAR 0 8
43031: PPUSH
43032: LD_INT 1
43034: PPUSH
43035: LD_INT 4
43037: PPUSH
43038: CALL_OW 273
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_VAR 0 7
43051: PPUSH
43052: LD_INT 2
43054: PPUSH
43055: LD_INT 4
43057: PPUSH
43058: CALL_OW 272
43062: PUSH
43063: LD_VAR 0 8
43067: PPUSH
43068: LD_INT 2
43070: PPUSH
43071: LD_INT 4
43073: PPUSH
43074: CALL_OW 273
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_VAR 0 7
43087: PPUSH
43088: LD_INT 3
43090: PPUSH
43091: LD_INT 4
43093: PPUSH
43094: CALL_OW 272
43098: PUSH
43099: LD_VAR 0 8
43103: PPUSH
43104: LD_INT 3
43106: PPUSH
43107: LD_INT 4
43109: PPUSH
43110: CALL_OW 273
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_VAR 0 7
43123: PPUSH
43124: LD_INT 4
43126: PPUSH
43127: LD_INT 4
43129: PPUSH
43130: CALL_OW 272
43134: PUSH
43135: LD_VAR 0 8
43139: PPUSH
43140: LD_INT 4
43142: PPUSH
43143: LD_INT 4
43145: PPUSH
43146: CALL_OW 273
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_VAR 0 7
43159: PPUSH
43160: LD_INT 5
43162: PPUSH
43163: LD_INT 4
43165: PPUSH
43166: CALL_OW 272
43170: PUSH
43171: LD_VAR 0 8
43175: PPUSH
43176: LD_INT 5
43178: PPUSH
43179: LD_INT 4
43181: PPUSH
43182: CALL_OW 273
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: ST_TO_ADDR
// for i = tmp downto 1 do
43199: LD_ADDR_VAR 0 4
43203: PUSH
43204: DOUBLE
43205: LD_VAR 0 6
43209: INC
43210: ST_TO_ADDR
43211: LD_INT 1
43213: PUSH
43214: FOR_DOWNTO
43215: IFFALSE 43316
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43217: LD_VAR 0 6
43221: PUSH
43222: LD_VAR 0 4
43226: ARRAY
43227: PUSH
43228: LD_INT 1
43230: ARRAY
43231: PPUSH
43232: LD_VAR 0 6
43236: PUSH
43237: LD_VAR 0 4
43241: ARRAY
43242: PUSH
43243: LD_INT 2
43245: ARRAY
43246: PPUSH
43247: CALL_OW 488
43251: NOT
43252: PUSH
43253: LD_VAR 0 6
43257: PUSH
43258: LD_VAR 0 4
43262: ARRAY
43263: PUSH
43264: LD_INT 1
43266: ARRAY
43267: PPUSH
43268: LD_VAR 0 6
43272: PUSH
43273: LD_VAR 0 4
43277: ARRAY
43278: PUSH
43279: LD_INT 2
43281: ARRAY
43282: PPUSH
43283: CALL_OW 428
43287: PUSH
43288: LD_INT 0
43290: NONEQUAL
43291: OR
43292: IFFALSE 43314
// tmp := Delete ( tmp , i ) ;
43294: LD_ADDR_VAR 0 6
43298: PUSH
43299: LD_VAR 0 6
43303: PPUSH
43304: LD_VAR 0 4
43308: PPUSH
43309: CALL_OW 3
43313: ST_TO_ADDR
43314: GO 43214
43316: POP
43317: POP
// j := GetClosestHex ( unit , tmp ) ;
43318: LD_ADDR_VAR 0 5
43322: PUSH
43323: LD_VAR 0 1
43327: PPUSH
43328: LD_VAR 0 6
43332: PPUSH
43333: CALL 42609 0 2
43337: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43338: LD_VAR 0 1
43342: PPUSH
43343: LD_VAR 0 5
43347: PUSH
43348: LD_INT 1
43350: ARRAY
43351: PPUSH
43352: LD_VAR 0 5
43356: PUSH
43357: LD_INT 2
43359: ARRAY
43360: PPUSH
43361: CALL_OW 111
// end ;
43365: LD_VAR 0 3
43369: RET
// export function PrepareApemanSoldier ( ) ; begin
43370: LD_INT 0
43372: PPUSH
// uc_nation := 0 ;
43373: LD_ADDR_OWVAR 21
43377: PUSH
43378: LD_INT 0
43380: ST_TO_ADDR
// hc_sex := sex_male ;
43381: LD_ADDR_OWVAR 27
43385: PUSH
43386: LD_INT 1
43388: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43389: LD_ADDR_OWVAR 28
43393: PUSH
43394: LD_INT 15
43396: ST_TO_ADDR
// hc_gallery :=  ;
43397: LD_ADDR_OWVAR 33
43401: PUSH
43402: LD_STRING 
43404: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43405: LD_ADDR_OWVAR 31
43409: PUSH
43410: LD_INT 0
43412: PPUSH
43413: LD_INT 3
43415: PPUSH
43416: CALL_OW 12
43420: PUSH
43421: LD_INT 0
43423: PPUSH
43424: LD_INT 3
43426: PPUSH
43427: CALL_OW 12
43431: PUSH
43432: LD_INT 0
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: ST_TO_ADDR
// end ;
43444: LD_VAR 0 1
43448: RET
// export function PrepareApemanEngineer ( ) ; begin
43449: LD_INT 0
43451: PPUSH
// uc_nation := 0 ;
43452: LD_ADDR_OWVAR 21
43456: PUSH
43457: LD_INT 0
43459: ST_TO_ADDR
// hc_sex := sex_male ;
43460: LD_ADDR_OWVAR 27
43464: PUSH
43465: LD_INT 1
43467: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43468: LD_ADDR_OWVAR 28
43472: PUSH
43473: LD_INT 16
43475: ST_TO_ADDR
// hc_gallery :=  ;
43476: LD_ADDR_OWVAR 33
43480: PUSH
43481: LD_STRING 
43483: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43484: LD_ADDR_OWVAR 31
43488: PUSH
43489: LD_INT 0
43491: PPUSH
43492: LD_INT 3
43494: PPUSH
43495: CALL_OW 12
43499: PUSH
43500: LD_INT 0
43502: PPUSH
43503: LD_INT 3
43505: PPUSH
43506: CALL_OW 12
43510: PUSH
43511: LD_INT 0
43513: PUSH
43514: LD_INT 0
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: ST_TO_ADDR
// end ;
43523: LD_VAR 0 1
43527: RET
// export function PrepareApeman ( agressivity ) ; begin
43528: LD_INT 0
43530: PPUSH
// uc_side := 0 ;
43531: LD_ADDR_OWVAR 20
43535: PUSH
43536: LD_INT 0
43538: ST_TO_ADDR
// uc_nation := 0 ;
43539: LD_ADDR_OWVAR 21
43543: PUSH
43544: LD_INT 0
43546: ST_TO_ADDR
// hc_sex := sex_male ;
43547: LD_ADDR_OWVAR 27
43551: PUSH
43552: LD_INT 1
43554: ST_TO_ADDR
// hc_class := class_apeman ;
43555: LD_ADDR_OWVAR 28
43559: PUSH
43560: LD_INT 12
43562: ST_TO_ADDR
// hc_gallery :=  ;
43563: LD_ADDR_OWVAR 33
43567: PUSH
43568: LD_STRING 
43570: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43571: LD_ADDR_OWVAR 35
43575: PUSH
43576: LD_VAR 0 1
43580: NEG
43581: PPUSH
43582: LD_VAR 0 1
43586: PPUSH
43587: CALL_OW 12
43591: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43592: LD_ADDR_OWVAR 31
43596: PUSH
43597: LD_INT 0
43599: PPUSH
43600: LD_INT 3
43602: PPUSH
43603: CALL_OW 12
43607: PUSH
43608: LD_INT 0
43610: PPUSH
43611: LD_INT 3
43613: PPUSH
43614: CALL_OW 12
43618: PUSH
43619: LD_INT 0
43621: PUSH
43622: LD_INT 0
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: LIST
43629: LIST
43630: ST_TO_ADDR
// end ;
43631: LD_VAR 0 2
43635: RET
// export function PrepareTiger ( agressivity ) ; begin
43636: LD_INT 0
43638: PPUSH
// uc_side := 0 ;
43639: LD_ADDR_OWVAR 20
43643: PUSH
43644: LD_INT 0
43646: ST_TO_ADDR
// uc_nation := 0 ;
43647: LD_ADDR_OWVAR 21
43651: PUSH
43652: LD_INT 0
43654: ST_TO_ADDR
// hc_class := class_tiger ;
43655: LD_ADDR_OWVAR 28
43659: PUSH
43660: LD_INT 14
43662: ST_TO_ADDR
// hc_gallery :=  ;
43663: LD_ADDR_OWVAR 33
43667: PUSH
43668: LD_STRING 
43670: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43671: LD_ADDR_OWVAR 35
43675: PUSH
43676: LD_VAR 0 1
43680: NEG
43681: PPUSH
43682: LD_VAR 0 1
43686: PPUSH
43687: CALL_OW 12
43691: ST_TO_ADDR
// end ;
43692: LD_VAR 0 2
43696: RET
// export function PrepareEnchidna ( ) ; begin
43697: LD_INT 0
43699: PPUSH
// uc_side := 0 ;
43700: LD_ADDR_OWVAR 20
43704: PUSH
43705: LD_INT 0
43707: ST_TO_ADDR
// uc_nation := 0 ;
43708: LD_ADDR_OWVAR 21
43712: PUSH
43713: LD_INT 0
43715: ST_TO_ADDR
// hc_class := class_baggie ;
43716: LD_ADDR_OWVAR 28
43720: PUSH
43721: LD_INT 13
43723: ST_TO_ADDR
// hc_gallery :=  ;
43724: LD_ADDR_OWVAR 33
43728: PUSH
43729: LD_STRING 
43731: ST_TO_ADDR
// end ;
43732: LD_VAR 0 1
43736: RET
// export function PrepareFrog ( ) ; begin
43737: LD_INT 0
43739: PPUSH
// uc_side := 0 ;
43740: LD_ADDR_OWVAR 20
43744: PUSH
43745: LD_INT 0
43747: ST_TO_ADDR
// uc_nation := 0 ;
43748: LD_ADDR_OWVAR 21
43752: PUSH
43753: LD_INT 0
43755: ST_TO_ADDR
// hc_class := class_frog ;
43756: LD_ADDR_OWVAR 28
43760: PUSH
43761: LD_INT 19
43763: ST_TO_ADDR
// hc_gallery :=  ;
43764: LD_ADDR_OWVAR 33
43768: PUSH
43769: LD_STRING 
43771: ST_TO_ADDR
// end ;
43772: LD_VAR 0 1
43776: RET
// export function PrepareFish ( ) ; begin
43777: LD_INT 0
43779: PPUSH
// uc_side := 0 ;
43780: LD_ADDR_OWVAR 20
43784: PUSH
43785: LD_INT 0
43787: ST_TO_ADDR
// uc_nation := 0 ;
43788: LD_ADDR_OWVAR 21
43792: PUSH
43793: LD_INT 0
43795: ST_TO_ADDR
// hc_class := class_fish ;
43796: LD_ADDR_OWVAR 28
43800: PUSH
43801: LD_INT 20
43803: ST_TO_ADDR
// hc_gallery :=  ;
43804: LD_ADDR_OWVAR 33
43808: PUSH
43809: LD_STRING 
43811: ST_TO_ADDR
// end ;
43812: LD_VAR 0 1
43816: RET
// export function PrepareBird ( ) ; begin
43817: LD_INT 0
43819: PPUSH
// uc_side := 0 ;
43820: LD_ADDR_OWVAR 20
43824: PUSH
43825: LD_INT 0
43827: ST_TO_ADDR
// uc_nation := 0 ;
43828: LD_ADDR_OWVAR 21
43832: PUSH
43833: LD_INT 0
43835: ST_TO_ADDR
// hc_class := class_phororhacos ;
43836: LD_ADDR_OWVAR 28
43840: PUSH
43841: LD_INT 18
43843: ST_TO_ADDR
// hc_gallery :=  ;
43844: LD_ADDR_OWVAR 33
43848: PUSH
43849: LD_STRING 
43851: ST_TO_ADDR
// end ;
43852: LD_VAR 0 1
43856: RET
// export function PrepareHorse ( ) ; begin
43857: LD_INT 0
43859: PPUSH
// uc_side := 0 ;
43860: LD_ADDR_OWVAR 20
43864: PUSH
43865: LD_INT 0
43867: ST_TO_ADDR
// uc_nation := 0 ;
43868: LD_ADDR_OWVAR 21
43872: PUSH
43873: LD_INT 0
43875: ST_TO_ADDR
// hc_class := class_horse ;
43876: LD_ADDR_OWVAR 28
43880: PUSH
43881: LD_INT 21
43883: ST_TO_ADDR
// hc_gallery :=  ;
43884: LD_ADDR_OWVAR 33
43888: PUSH
43889: LD_STRING 
43891: ST_TO_ADDR
// end ;
43892: LD_VAR 0 1
43896: RET
// export function PrepareMastodont ( ) ; begin
43897: LD_INT 0
43899: PPUSH
// uc_side := 0 ;
43900: LD_ADDR_OWVAR 20
43904: PUSH
43905: LD_INT 0
43907: ST_TO_ADDR
// uc_nation := 0 ;
43908: LD_ADDR_OWVAR 21
43912: PUSH
43913: LD_INT 0
43915: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43916: LD_ADDR_OWVAR 37
43920: PUSH
43921: LD_INT 31
43923: ST_TO_ADDR
// vc_control := control_rider ;
43924: LD_ADDR_OWVAR 38
43928: PUSH
43929: LD_INT 4
43931: ST_TO_ADDR
// end ;
43932: LD_VAR 0 1
43936: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43937: LD_INT 0
43939: PPUSH
43940: PPUSH
43941: PPUSH
// uc_side = 0 ;
43942: LD_ADDR_OWVAR 20
43946: PUSH
43947: LD_INT 0
43949: ST_TO_ADDR
// uc_nation = 0 ;
43950: LD_ADDR_OWVAR 21
43954: PUSH
43955: LD_INT 0
43957: ST_TO_ADDR
// InitHc_All ( ) ;
43958: CALL_OW 584
// InitVc ;
43962: CALL_OW 20
// if mastodonts then
43966: LD_VAR 0 6
43970: IFFALSE 44037
// for i = 1 to mastodonts do
43972: LD_ADDR_VAR 0 11
43976: PUSH
43977: DOUBLE
43978: LD_INT 1
43980: DEC
43981: ST_TO_ADDR
43982: LD_VAR 0 6
43986: PUSH
43987: FOR_TO
43988: IFFALSE 44035
// begin vc_chassis := 31 ;
43990: LD_ADDR_OWVAR 37
43994: PUSH
43995: LD_INT 31
43997: ST_TO_ADDR
// vc_control := control_rider ;
43998: LD_ADDR_OWVAR 38
44002: PUSH
44003: LD_INT 4
44005: ST_TO_ADDR
// animal := CreateVehicle ;
44006: LD_ADDR_VAR 0 12
44010: PUSH
44011: CALL_OW 45
44015: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44016: LD_VAR 0 12
44020: PPUSH
44021: LD_VAR 0 8
44025: PPUSH
44026: LD_INT 0
44028: PPUSH
44029: CALL 46165 0 3
// end ;
44033: GO 43987
44035: POP
44036: POP
// if horses then
44037: LD_VAR 0 5
44041: IFFALSE 44108
// for i = 1 to horses do
44043: LD_ADDR_VAR 0 11
44047: PUSH
44048: DOUBLE
44049: LD_INT 1
44051: DEC
44052: ST_TO_ADDR
44053: LD_VAR 0 5
44057: PUSH
44058: FOR_TO
44059: IFFALSE 44106
// begin hc_class := 21 ;
44061: LD_ADDR_OWVAR 28
44065: PUSH
44066: LD_INT 21
44068: ST_TO_ADDR
// hc_gallery :=  ;
44069: LD_ADDR_OWVAR 33
44073: PUSH
44074: LD_STRING 
44076: ST_TO_ADDR
// animal := CreateHuman ;
44077: LD_ADDR_VAR 0 12
44081: PUSH
44082: CALL_OW 44
44086: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44087: LD_VAR 0 12
44091: PPUSH
44092: LD_VAR 0 8
44096: PPUSH
44097: LD_INT 0
44099: PPUSH
44100: CALL 46165 0 3
// end ;
44104: GO 44058
44106: POP
44107: POP
// if birds then
44108: LD_VAR 0 1
44112: IFFALSE 44179
// for i = 1 to birds do
44114: LD_ADDR_VAR 0 11
44118: PUSH
44119: DOUBLE
44120: LD_INT 1
44122: DEC
44123: ST_TO_ADDR
44124: LD_VAR 0 1
44128: PUSH
44129: FOR_TO
44130: IFFALSE 44177
// begin hc_class = 18 ;
44132: LD_ADDR_OWVAR 28
44136: PUSH
44137: LD_INT 18
44139: ST_TO_ADDR
// hc_gallery =  ;
44140: LD_ADDR_OWVAR 33
44144: PUSH
44145: LD_STRING 
44147: ST_TO_ADDR
// animal := CreateHuman ;
44148: LD_ADDR_VAR 0 12
44152: PUSH
44153: CALL_OW 44
44157: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44158: LD_VAR 0 12
44162: PPUSH
44163: LD_VAR 0 8
44167: PPUSH
44168: LD_INT 0
44170: PPUSH
44171: CALL 46165 0 3
// end ;
44175: GO 44129
44177: POP
44178: POP
// if tigers then
44179: LD_VAR 0 2
44183: IFFALSE 44267
// for i = 1 to tigers do
44185: LD_ADDR_VAR 0 11
44189: PUSH
44190: DOUBLE
44191: LD_INT 1
44193: DEC
44194: ST_TO_ADDR
44195: LD_VAR 0 2
44199: PUSH
44200: FOR_TO
44201: IFFALSE 44265
// begin hc_class = class_tiger ;
44203: LD_ADDR_OWVAR 28
44207: PUSH
44208: LD_INT 14
44210: ST_TO_ADDR
// hc_gallery =  ;
44211: LD_ADDR_OWVAR 33
44215: PUSH
44216: LD_STRING 
44218: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44219: LD_ADDR_OWVAR 35
44223: PUSH
44224: LD_INT 7
44226: NEG
44227: PPUSH
44228: LD_INT 7
44230: PPUSH
44231: CALL_OW 12
44235: ST_TO_ADDR
// animal := CreateHuman ;
44236: LD_ADDR_VAR 0 12
44240: PUSH
44241: CALL_OW 44
44245: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44246: LD_VAR 0 12
44250: PPUSH
44251: LD_VAR 0 8
44255: PPUSH
44256: LD_INT 0
44258: PPUSH
44259: CALL 46165 0 3
// end ;
44263: GO 44200
44265: POP
44266: POP
// if apemans then
44267: LD_VAR 0 3
44271: IFFALSE 44394
// for i = 1 to apemans do
44273: LD_ADDR_VAR 0 11
44277: PUSH
44278: DOUBLE
44279: LD_INT 1
44281: DEC
44282: ST_TO_ADDR
44283: LD_VAR 0 3
44287: PUSH
44288: FOR_TO
44289: IFFALSE 44392
// begin hc_class = class_apeman ;
44291: LD_ADDR_OWVAR 28
44295: PUSH
44296: LD_INT 12
44298: ST_TO_ADDR
// hc_gallery =  ;
44299: LD_ADDR_OWVAR 33
44303: PUSH
44304: LD_STRING 
44306: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44307: LD_ADDR_OWVAR 35
44311: PUSH
44312: LD_INT 2
44314: NEG
44315: PPUSH
44316: LD_INT 2
44318: PPUSH
44319: CALL_OW 12
44323: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44324: LD_ADDR_OWVAR 31
44328: PUSH
44329: LD_INT 1
44331: PPUSH
44332: LD_INT 3
44334: PPUSH
44335: CALL_OW 12
44339: PUSH
44340: LD_INT 1
44342: PPUSH
44343: LD_INT 3
44345: PPUSH
44346: CALL_OW 12
44350: PUSH
44351: LD_INT 0
44353: PUSH
44354: LD_INT 0
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: ST_TO_ADDR
// animal := CreateHuman ;
44363: LD_ADDR_VAR 0 12
44367: PUSH
44368: CALL_OW 44
44372: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44373: LD_VAR 0 12
44377: PPUSH
44378: LD_VAR 0 8
44382: PPUSH
44383: LD_INT 0
44385: PPUSH
44386: CALL 46165 0 3
// end ;
44390: GO 44288
44392: POP
44393: POP
// if enchidnas then
44394: LD_VAR 0 4
44398: IFFALSE 44465
// for i = 1 to enchidnas do
44400: LD_ADDR_VAR 0 11
44404: PUSH
44405: DOUBLE
44406: LD_INT 1
44408: DEC
44409: ST_TO_ADDR
44410: LD_VAR 0 4
44414: PUSH
44415: FOR_TO
44416: IFFALSE 44463
// begin hc_class = 13 ;
44418: LD_ADDR_OWVAR 28
44422: PUSH
44423: LD_INT 13
44425: ST_TO_ADDR
// hc_gallery =  ;
44426: LD_ADDR_OWVAR 33
44430: PUSH
44431: LD_STRING 
44433: ST_TO_ADDR
// animal := CreateHuman ;
44434: LD_ADDR_VAR 0 12
44438: PUSH
44439: CALL_OW 44
44443: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44444: LD_VAR 0 12
44448: PPUSH
44449: LD_VAR 0 8
44453: PPUSH
44454: LD_INT 0
44456: PPUSH
44457: CALL 46165 0 3
// end ;
44461: GO 44415
44463: POP
44464: POP
// if fishes then
44465: LD_VAR 0 7
44469: IFFALSE 44536
// for i = 1 to fishes do
44471: LD_ADDR_VAR 0 11
44475: PUSH
44476: DOUBLE
44477: LD_INT 1
44479: DEC
44480: ST_TO_ADDR
44481: LD_VAR 0 7
44485: PUSH
44486: FOR_TO
44487: IFFALSE 44534
// begin hc_class = 20 ;
44489: LD_ADDR_OWVAR 28
44493: PUSH
44494: LD_INT 20
44496: ST_TO_ADDR
// hc_gallery =  ;
44497: LD_ADDR_OWVAR 33
44501: PUSH
44502: LD_STRING 
44504: ST_TO_ADDR
// animal := CreateHuman ;
44505: LD_ADDR_VAR 0 12
44509: PUSH
44510: CALL_OW 44
44514: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44515: LD_VAR 0 12
44519: PPUSH
44520: LD_VAR 0 9
44524: PPUSH
44525: LD_INT 0
44527: PPUSH
44528: CALL 46165 0 3
// end ;
44532: GO 44486
44534: POP
44535: POP
// end ;
44536: LD_VAR 0 10
44540: RET
// export function WantHeal ( sci , unit ) ; begin
44541: LD_INT 0
44543: PPUSH
// if GetTaskList ( sci ) > 0 then
44544: LD_VAR 0 1
44548: PPUSH
44549: CALL_OW 437
44553: PUSH
44554: LD_INT 0
44556: GREATER
44557: IFFALSE 44627
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44559: LD_VAR 0 1
44563: PPUSH
44564: CALL_OW 437
44568: PUSH
44569: LD_INT 1
44571: ARRAY
44572: PUSH
44573: LD_INT 1
44575: ARRAY
44576: PUSH
44577: LD_STRING l
44579: EQUAL
44580: PUSH
44581: LD_VAR 0 1
44585: PPUSH
44586: CALL_OW 437
44590: PUSH
44591: LD_INT 1
44593: ARRAY
44594: PUSH
44595: LD_INT 4
44597: ARRAY
44598: PUSH
44599: LD_VAR 0 2
44603: EQUAL
44604: AND
44605: IFFALSE 44617
// result := true else
44607: LD_ADDR_VAR 0 3
44611: PUSH
44612: LD_INT 1
44614: ST_TO_ADDR
44615: GO 44625
// result := false ;
44617: LD_ADDR_VAR 0 3
44621: PUSH
44622: LD_INT 0
44624: ST_TO_ADDR
// end else
44625: GO 44635
// result := false ;
44627: LD_ADDR_VAR 0 3
44631: PUSH
44632: LD_INT 0
44634: ST_TO_ADDR
// end ;
44635: LD_VAR 0 3
44639: RET
// export function HealTarget ( sci ) ; begin
44640: LD_INT 0
44642: PPUSH
// if not sci then
44643: LD_VAR 0 1
44647: NOT
44648: IFFALSE 44652
// exit ;
44650: GO 44717
// result := 0 ;
44652: LD_ADDR_VAR 0 2
44656: PUSH
44657: LD_INT 0
44659: ST_TO_ADDR
// if GetTaskList ( sci ) then
44660: LD_VAR 0 1
44664: PPUSH
44665: CALL_OW 437
44669: IFFALSE 44717
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44671: LD_VAR 0 1
44675: PPUSH
44676: CALL_OW 437
44680: PUSH
44681: LD_INT 1
44683: ARRAY
44684: PUSH
44685: LD_INT 1
44687: ARRAY
44688: PUSH
44689: LD_STRING l
44691: EQUAL
44692: IFFALSE 44717
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44694: LD_ADDR_VAR 0 2
44698: PUSH
44699: LD_VAR 0 1
44703: PPUSH
44704: CALL_OW 437
44708: PUSH
44709: LD_INT 1
44711: ARRAY
44712: PUSH
44713: LD_INT 4
44715: ARRAY
44716: ST_TO_ADDR
// end ;
44717: LD_VAR 0 2
44721: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44722: LD_INT 0
44724: PPUSH
44725: PPUSH
44726: PPUSH
44727: PPUSH
// if not base_units then
44728: LD_VAR 0 1
44732: NOT
44733: IFFALSE 44737
// exit ;
44735: GO 44824
// result := false ;
44737: LD_ADDR_VAR 0 2
44741: PUSH
44742: LD_INT 0
44744: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44745: LD_ADDR_VAR 0 5
44749: PUSH
44750: LD_VAR 0 1
44754: PPUSH
44755: LD_INT 21
44757: PUSH
44758: LD_INT 3
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PPUSH
44765: CALL_OW 72
44769: ST_TO_ADDR
// if not tmp then
44770: LD_VAR 0 5
44774: NOT
44775: IFFALSE 44779
// exit ;
44777: GO 44824
// for i in tmp do
44779: LD_ADDR_VAR 0 3
44783: PUSH
44784: LD_VAR 0 5
44788: PUSH
44789: FOR_IN
44790: IFFALSE 44822
// begin result := EnemyInRange ( i , 22 ) ;
44792: LD_ADDR_VAR 0 2
44796: PUSH
44797: LD_VAR 0 3
44801: PPUSH
44802: LD_INT 22
44804: PPUSH
44805: CALL 42411 0 2
44809: ST_TO_ADDR
// if result then
44810: LD_VAR 0 2
44814: IFFALSE 44820
// exit ;
44816: POP
44817: POP
44818: GO 44824
// end ;
44820: GO 44789
44822: POP
44823: POP
// end ;
44824: LD_VAR 0 2
44828: RET
// export function FilterByTag ( units , tag ) ; begin
44829: LD_INT 0
44831: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44832: LD_ADDR_VAR 0 3
44836: PUSH
44837: LD_VAR 0 1
44841: PPUSH
44842: LD_INT 120
44844: PUSH
44845: LD_VAR 0 2
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PPUSH
44854: CALL_OW 72
44858: ST_TO_ADDR
// end ;
44859: LD_VAR 0 3
44863: RET
// export function IsDriver ( un ) ; begin
44864: LD_INT 0
44866: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44867: LD_ADDR_VAR 0 2
44871: PUSH
44872: LD_VAR 0 1
44876: PUSH
44877: LD_INT 55
44879: PUSH
44880: EMPTY
44881: LIST
44882: PPUSH
44883: CALL_OW 69
44887: IN
44888: ST_TO_ADDR
// end ;
44889: LD_VAR 0 2
44893: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44894: LD_INT 0
44896: PPUSH
44897: PPUSH
// list := [ ] ;
44898: LD_ADDR_VAR 0 5
44902: PUSH
44903: EMPTY
44904: ST_TO_ADDR
// case d of 0 :
44905: LD_VAR 0 3
44909: PUSH
44910: LD_INT 0
44912: DOUBLE
44913: EQUAL
44914: IFTRUE 44918
44916: GO 45051
44918: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44919: LD_ADDR_VAR 0 5
44923: PUSH
44924: LD_VAR 0 1
44928: PUSH
44929: LD_INT 4
44931: MINUS
44932: PUSH
44933: LD_VAR 0 2
44937: PUSH
44938: LD_INT 4
44940: MINUS
44941: PUSH
44942: LD_INT 2
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: LIST
44949: PUSH
44950: LD_VAR 0 1
44954: PUSH
44955: LD_INT 3
44957: MINUS
44958: PUSH
44959: LD_VAR 0 2
44963: PUSH
44964: LD_INT 1
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: LIST
44971: PUSH
44972: LD_VAR 0 1
44976: PUSH
44977: LD_INT 4
44979: PLUS
44980: PUSH
44981: LD_VAR 0 2
44985: PUSH
44986: LD_INT 4
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: LIST
44993: PUSH
44994: LD_VAR 0 1
44998: PUSH
44999: LD_INT 3
45001: PLUS
45002: PUSH
45003: LD_VAR 0 2
45007: PUSH
45008: LD_INT 3
45010: PLUS
45011: PUSH
45012: LD_INT 5
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: LIST
45019: PUSH
45020: LD_VAR 0 1
45024: PUSH
45025: LD_VAR 0 2
45029: PUSH
45030: LD_INT 4
45032: PLUS
45033: PUSH
45034: LD_INT 0
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: LIST
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// end ; 1 :
45049: GO 45749
45051: LD_INT 1
45053: DOUBLE
45054: EQUAL
45055: IFTRUE 45059
45057: GO 45192
45059: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45060: LD_ADDR_VAR 0 5
45064: PUSH
45065: LD_VAR 0 1
45069: PUSH
45070: LD_VAR 0 2
45074: PUSH
45075: LD_INT 4
45077: MINUS
45078: PUSH
45079: LD_INT 3
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: LIST
45086: PUSH
45087: LD_VAR 0 1
45091: PUSH
45092: LD_INT 3
45094: MINUS
45095: PUSH
45096: LD_VAR 0 2
45100: PUSH
45101: LD_INT 3
45103: MINUS
45104: PUSH
45105: LD_INT 2
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: LIST
45112: PUSH
45113: LD_VAR 0 1
45117: PUSH
45118: LD_INT 4
45120: MINUS
45121: PUSH
45122: LD_VAR 0 2
45126: PUSH
45127: LD_INT 1
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: LIST
45134: PUSH
45135: LD_VAR 0 1
45139: PUSH
45140: LD_VAR 0 2
45144: PUSH
45145: LD_INT 3
45147: PLUS
45148: PUSH
45149: LD_INT 0
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: LIST
45156: PUSH
45157: LD_VAR 0 1
45161: PUSH
45162: LD_INT 4
45164: PLUS
45165: PUSH
45166: LD_VAR 0 2
45170: PUSH
45171: LD_INT 4
45173: PLUS
45174: PUSH
45175: LD_INT 5
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: LIST
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: ST_TO_ADDR
// end ; 2 :
45190: GO 45749
45192: LD_INT 2
45194: DOUBLE
45195: EQUAL
45196: IFTRUE 45200
45198: GO 45329
45200: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45201: LD_ADDR_VAR 0 5
45205: PUSH
45206: LD_VAR 0 1
45210: PUSH
45211: LD_VAR 0 2
45215: PUSH
45216: LD_INT 3
45218: MINUS
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: LIST
45227: PUSH
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 4
45235: PLUS
45236: PUSH
45237: LD_VAR 0 2
45241: PUSH
45242: LD_INT 4
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: LIST
45249: PUSH
45250: LD_VAR 0 1
45254: PUSH
45255: LD_VAR 0 2
45259: PUSH
45260: LD_INT 4
45262: PLUS
45263: PUSH
45264: LD_INT 0
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: LIST
45271: PUSH
45272: LD_VAR 0 1
45276: PUSH
45277: LD_INT 3
45279: MINUS
45280: PUSH
45281: LD_VAR 0 2
45285: PUSH
45286: LD_INT 1
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: LIST
45293: PUSH
45294: LD_VAR 0 1
45298: PUSH
45299: LD_INT 4
45301: MINUS
45302: PUSH
45303: LD_VAR 0 2
45307: PUSH
45308: LD_INT 4
45310: MINUS
45311: PUSH
45312: LD_INT 2
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: LIST
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: ST_TO_ADDR
// end ; 3 :
45327: GO 45749
45329: LD_INT 3
45331: DOUBLE
45332: EQUAL
45333: IFTRUE 45337
45335: GO 45470
45337: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45338: LD_ADDR_VAR 0 5
45342: PUSH
45343: LD_VAR 0 1
45347: PUSH
45348: LD_INT 3
45350: PLUS
45351: PUSH
45352: LD_VAR 0 2
45356: PUSH
45357: LD_INT 4
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: PUSH
45365: LD_VAR 0 1
45369: PUSH
45370: LD_INT 4
45372: PLUS
45373: PUSH
45374: LD_VAR 0 2
45378: PUSH
45379: LD_INT 4
45381: PLUS
45382: PUSH
45383: LD_INT 5
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: LIST
45390: PUSH
45391: LD_VAR 0 1
45395: PUSH
45396: LD_INT 4
45398: MINUS
45399: PUSH
45400: LD_VAR 0 2
45404: PUSH
45405: LD_INT 1
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: LIST
45412: PUSH
45413: LD_VAR 0 1
45417: PUSH
45418: LD_VAR 0 2
45422: PUSH
45423: LD_INT 4
45425: MINUS
45426: PUSH
45427: LD_INT 3
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: LIST
45434: PUSH
45435: LD_VAR 0 1
45439: PUSH
45440: LD_INT 3
45442: MINUS
45443: PUSH
45444: LD_VAR 0 2
45448: PUSH
45449: LD_INT 3
45451: MINUS
45452: PUSH
45453: LD_INT 2
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: LIST
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: ST_TO_ADDR
// end ; 4 :
45468: GO 45749
45470: LD_INT 4
45472: DOUBLE
45473: EQUAL
45474: IFTRUE 45478
45476: GO 45611
45478: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45479: LD_ADDR_VAR 0 5
45483: PUSH
45484: LD_VAR 0 1
45488: PUSH
45489: LD_VAR 0 2
45493: PUSH
45494: LD_INT 4
45496: PLUS
45497: PUSH
45498: LD_INT 0
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 1
45510: PUSH
45511: LD_INT 3
45513: PLUS
45514: PUSH
45515: LD_VAR 0 2
45519: PUSH
45520: LD_INT 3
45522: PLUS
45523: PUSH
45524: LD_INT 5
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: LIST
45531: PUSH
45532: LD_VAR 0 1
45536: PUSH
45537: LD_INT 4
45539: PLUS
45540: PUSH
45541: LD_VAR 0 2
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: LIST
45553: PUSH
45554: LD_VAR 0 1
45558: PUSH
45559: LD_VAR 0 2
45563: PUSH
45564: LD_INT 3
45566: MINUS
45567: PUSH
45568: LD_INT 3
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: PUSH
45576: LD_VAR 0 1
45580: PUSH
45581: LD_INT 4
45583: MINUS
45584: PUSH
45585: LD_VAR 0 2
45589: PUSH
45590: LD_INT 4
45592: MINUS
45593: PUSH
45594: LD_INT 2
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: ST_TO_ADDR
// end ; 5 :
45609: GO 45749
45611: LD_INT 5
45613: DOUBLE
45614: EQUAL
45615: IFTRUE 45619
45617: GO 45748
45619: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45620: LD_ADDR_VAR 0 5
45624: PUSH
45625: LD_VAR 0 1
45629: PUSH
45630: LD_INT 4
45632: MINUS
45633: PUSH
45634: LD_VAR 0 2
45638: PUSH
45639: LD_INT 1
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: LIST
45646: PUSH
45647: LD_VAR 0 1
45651: PUSH
45652: LD_VAR 0 2
45656: PUSH
45657: LD_INT 4
45659: MINUS
45660: PUSH
45661: LD_INT 3
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: LIST
45668: PUSH
45669: LD_VAR 0 1
45673: PUSH
45674: LD_INT 4
45676: PLUS
45677: PUSH
45678: LD_VAR 0 2
45682: PUSH
45683: LD_INT 4
45685: PLUS
45686: PUSH
45687: LD_INT 5
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: LIST
45694: PUSH
45695: LD_VAR 0 1
45699: PUSH
45700: LD_INT 3
45702: PLUS
45703: PUSH
45704: LD_VAR 0 2
45708: PUSH
45709: LD_INT 4
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: LIST
45716: PUSH
45717: LD_VAR 0 1
45721: PUSH
45722: LD_VAR 0 2
45726: PUSH
45727: LD_INT 3
45729: PLUS
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: ST_TO_ADDR
// end ; end ;
45746: GO 45749
45748: POP
// result := list ;
45749: LD_ADDR_VAR 0 4
45753: PUSH
45754: LD_VAR 0 5
45758: ST_TO_ADDR
// end ;
45759: LD_VAR 0 4
45763: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45764: LD_INT 0
45766: PPUSH
45767: PPUSH
45768: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45769: LD_VAR 0 1
45773: NOT
45774: PUSH
45775: LD_VAR 0 2
45779: PUSH
45780: LD_INT 1
45782: PUSH
45783: LD_INT 2
45785: PUSH
45786: LD_INT 3
45788: PUSH
45789: LD_INT 4
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: IN
45798: NOT
45799: OR
45800: IFFALSE 45804
// exit ;
45802: GO 45887
// tmp := [ ] ;
45804: LD_ADDR_VAR 0 5
45808: PUSH
45809: EMPTY
45810: ST_TO_ADDR
// for i in units do
45811: LD_ADDR_VAR 0 4
45815: PUSH
45816: LD_VAR 0 1
45820: PUSH
45821: FOR_IN
45822: IFFALSE 45856
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
45824: LD_ADDR_VAR 0 5
45828: PUSH
45829: LD_VAR 0 5
45833: PPUSH
45834: LD_VAR 0 4
45838: PPUSH
45839: LD_VAR 0 2
45843: PPUSH
45844: CALL_OW 259
45848: PPUSH
45849: CALL 47247 0 2
45853: ST_TO_ADDR
45854: GO 45821
45856: POP
45857: POP
// if not tmp then
45858: LD_VAR 0 5
45862: NOT
45863: IFFALSE 45867
// exit ;
45865: GO 45887
// result := SortListByListDesc ( units , tmp ) ;
45867: LD_ADDR_VAR 0 3
45871: PUSH
45872: LD_VAR 0 1
45876: PPUSH
45877: LD_VAR 0 5
45881: PPUSH
45882: CALL_OW 77
45886: ST_TO_ADDR
// end ;
45887: LD_VAR 0 3
45891: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45892: LD_INT 0
45894: PPUSH
45895: PPUSH
45896: PPUSH
// result := false ;
45897: LD_ADDR_VAR 0 3
45901: PUSH
45902: LD_INT 0
45904: ST_TO_ADDR
// if not building then
45905: LD_VAR 0 2
45909: NOT
45910: IFFALSE 45914
// exit ;
45912: GO 46052
// x := GetX ( building ) ;
45914: LD_ADDR_VAR 0 4
45918: PUSH
45919: LD_VAR 0 2
45923: PPUSH
45924: CALL_OW 250
45928: ST_TO_ADDR
// y := GetY ( building ) ;
45929: LD_ADDR_VAR 0 5
45933: PUSH
45934: LD_VAR 0 2
45938: PPUSH
45939: CALL_OW 251
45943: ST_TO_ADDR
// if not x or not y then
45944: LD_VAR 0 4
45948: NOT
45949: PUSH
45950: LD_VAR 0 5
45954: NOT
45955: OR
45956: IFFALSE 45960
// exit ;
45958: GO 46052
// if GetTaskList ( unit ) then
45960: LD_VAR 0 1
45964: PPUSH
45965: CALL_OW 437
45969: IFFALSE 46052
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45971: LD_STRING e
45973: PUSH
45974: LD_VAR 0 1
45978: PPUSH
45979: CALL_OW 437
45983: PUSH
45984: LD_INT 1
45986: ARRAY
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: EQUAL
45992: PUSH
45993: LD_VAR 0 4
45997: PUSH
45998: LD_VAR 0 1
46002: PPUSH
46003: CALL_OW 437
46007: PUSH
46008: LD_INT 1
46010: ARRAY
46011: PUSH
46012: LD_INT 2
46014: ARRAY
46015: EQUAL
46016: AND
46017: PUSH
46018: LD_VAR 0 5
46022: PUSH
46023: LD_VAR 0 1
46027: PPUSH
46028: CALL_OW 437
46032: PUSH
46033: LD_INT 1
46035: ARRAY
46036: PUSH
46037: LD_INT 3
46039: ARRAY
46040: EQUAL
46041: AND
46042: IFFALSE 46052
// result := true end ;
46044: LD_ADDR_VAR 0 3
46048: PUSH
46049: LD_INT 1
46051: ST_TO_ADDR
// end ;
46052: LD_VAR 0 3
46056: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46057: LD_INT 0
46059: PPUSH
// result := false ;
46060: LD_ADDR_VAR 0 4
46064: PUSH
46065: LD_INT 0
46067: ST_TO_ADDR
// if GetTaskList ( unit ) then
46068: LD_VAR 0 1
46072: PPUSH
46073: CALL_OW 437
46077: IFFALSE 46160
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46079: LD_STRING M
46081: PUSH
46082: LD_VAR 0 1
46086: PPUSH
46087: CALL_OW 437
46091: PUSH
46092: LD_INT 1
46094: ARRAY
46095: PUSH
46096: LD_INT 1
46098: ARRAY
46099: EQUAL
46100: PUSH
46101: LD_VAR 0 2
46105: PUSH
46106: LD_VAR 0 1
46110: PPUSH
46111: CALL_OW 437
46115: PUSH
46116: LD_INT 1
46118: ARRAY
46119: PUSH
46120: LD_INT 2
46122: ARRAY
46123: EQUAL
46124: AND
46125: PUSH
46126: LD_VAR 0 3
46130: PUSH
46131: LD_VAR 0 1
46135: PPUSH
46136: CALL_OW 437
46140: PUSH
46141: LD_INT 1
46143: ARRAY
46144: PUSH
46145: LD_INT 3
46147: ARRAY
46148: EQUAL
46149: AND
46150: IFFALSE 46160
// result := true ;
46152: LD_ADDR_VAR 0 4
46156: PUSH
46157: LD_INT 1
46159: ST_TO_ADDR
// end ; end ;
46160: LD_VAR 0 4
46164: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46165: LD_INT 0
46167: PPUSH
46168: PPUSH
46169: PPUSH
46170: PPUSH
// if not unit or not area then
46171: LD_VAR 0 1
46175: NOT
46176: PUSH
46177: LD_VAR 0 2
46181: NOT
46182: OR
46183: IFFALSE 46187
// exit ;
46185: GO 46350
// tmp := AreaToList ( area , i ) ;
46187: LD_ADDR_VAR 0 6
46191: PUSH
46192: LD_VAR 0 2
46196: PPUSH
46197: LD_VAR 0 5
46201: PPUSH
46202: CALL_OW 517
46206: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46207: LD_ADDR_VAR 0 5
46211: PUSH
46212: DOUBLE
46213: LD_INT 1
46215: DEC
46216: ST_TO_ADDR
46217: LD_VAR 0 6
46221: PUSH
46222: LD_INT 1
46224: ARRAY
46225: PUSH
46226: FOR_TO
46227: IFFALSE 46348
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46229: LD_ADDR_VAR 0 7
46233: PUSH
46234: LD_VAR 0 6
46238: PUSH
46239: LD_INT 1
46241: ARRAY
46242: PUSH
46243: LD_VAR 0 5
46247: ARRAY
46248: PUSH
46249: LD_VAR 0 6
46253: PUSH
46254: LD_INT 2
46256: ARRAY
46257: PUSH
46258: LD_VAR 0 5
46262: ARRAY
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
46268: LD_INT 92
46270: PUSH
46271: LD_VAR 0 7
46275: PUSH
46276: LD_INT 1
46278: ARRAY
46279: PUSH
46280: LD_VAR 0 7
46284: PUSH
46285: LD_INT 2
46287: ARRAY
46288: PUSH
46289: LD_INT 3
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: PPUSH
46298: CALL_OW 69
46302: PUSH
46303: LD_INT 0
46305: EQUAL
46306: IFFALSE 46346
// begin PlaceUnitArea ( unit , area , mode ) ;
46308: LD_VAR 0 1
46312: PPUSH
46313: LD_VAR 0 2
46317: PPUSH
46318: LD_VAR 0 3
46322: PPUSH
46323: CALL_OW 49
// result := IsPlaced ( unit ) ;
46327: LD_ADDR_VAR 0 4
46331: PUSH
46332: LD_VAR 0 1
46336: PPUSH
46337: CALL_OW 305
46341: ST_TO_ADDR
// exit ;
46342: POP
46343: POP
46344: GO 46350
// end ; end ;
46346: GO 46226
46348: POP
46349: POP
// end ;
46350: LD_VAR 0 4
46354: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46355: LD_INT 0
46357: PPUSH
46358: PPUSH
46359: PPUSH
// if not side or side > 8 then
46360: LD_VAR 0 1
46364: NOT
46365: PUSH
46366: LD_VAR 0 1
46370: PUSH
46371: LD_INT 8
46373: GREATER
46374: OR
46375: IFFALSE 46379
// exit ;
46377: GO 46566
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46379: LD_ADDR_VAR 0 4
46383: PUSH
46384: LD_INT 22
46386: PUSH
46387: LD_VAR 0 1
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 21
46398: PUSH
46399: LD_INT 3
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PPUSH
46410: CALL_OW 69
46414: ST_TO_ADDR
// if not tmp then
46415: LD_VAR 0 4
46419: NOT
46420: IFFALSE 46424
// exit ;
46422: GO 46566
// enable_addtolog := true ;
46424: LD_ADDR_OWVAR 81
46428: PUSH
46429: LD_INT 1
46431: ST_TO_ADDR
// AddToLog ( [ ) ;
46432: LD_STRING [
46434: PPUSH
46435: CALL_OW 561
// for i in tmp do
46439: LD_ADDR_VAR 0 3
46443: PUSH
46444: LD_VAR 0 4
46448: PUSH
46449: FOR_IN
46450: IFFALSE 46557
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46452: LD_STRING [
46454: PUSH
46455: LD_VAR 0 3
46459: PPUSH
46460: CALL_OW 266
46464: STR
46465: PUSH
46466: LD_STRING , 
46468: STR
46469: PUSH
46470: LD_VAR 0 3
46474: PPUSH
46475: CALL_OW 250
46479: STR
46480: PUSH
46481: LD_STRING , 
46483: STR
46484: PUSH
46485: LD_VAR 0 3
46489: PPUSH
46490: CALL_OW 251
46494: STR
46495: PUSH
46496: LD_STRING , 
46498: STR
46499: PUSH
46500: LD_VAR 0 3
46504: PPUSH
46505: CALL_OW 254
46509: STR
46510: PUSH
46511: LD_STRING , 
46513: STR
46514: PUSH
46515: LD_VAR 0 3
46519: PPUSH
46520: LD_INT 1
46522: PPUSH
46523: CALL_OW 268
46527: STR
46528: PUSH
46529: LD_STRING , 
46531: STR
46532: PUSH
46533: LD_VAR 0 3
46537: PPUSH
46538: LD_INT 2
46540: PPUSH
46541: CALL_OW 268
46545: STR
46546: PUSH
46547: LD_STRING ],
46549: STR
46550: PPUSH
46551: CALL_OW 561
// end ;
46555: GO 46449
46557: POP
46558: POP
// AddToLog ( ]; ) ;
46559: LD_STRING ];
46561: PPUSH
46562: CALL_OW 561
// end ;
46566: LD_VAR 0 2
46570: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46571: LD_INT 0
46573: PPUSH
46574: PPUSH
46575: PPUSH
46576: PPUSH
46577: PPUSH
// if not area or not rate or not max then
46578: LD_VAR 0 1
46582: NOT
46583: PUSH
46584: LD_VAR 0 2
46588: NOT
46589: OR
46590: PUSH
46591: LD_VAR 0 4
46595: NOT
46596: OR
46597: IFFALSE 46601
// exit ;
46599: GO 46790
// while 1 do
46601: LD_INT 1
46603: IFFALSE 46790
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46605: LD_ADDR_VAR 0 9
46609: PUSH
46610: LD_VAR 0 1
46614: PPUSH
46615: LD_INT 1
46617: PPUSH
46618: CALL_OW 287
46622: PUSH
46623: LD_INT 10
46625: MUL
46626: ST_TO_ADDR
// r := rate / 10 ;
46627: LD_ADDR_VAR 0 7
46631: PUSH
46632: LD_VAR 0 2
46636: PUSH
46637: LD_INT 10
46639: DIVREAL
46640: ST_TO_ADDR
// time := 1 1$00 ;
46641: LD_ADDR_VAR 0 8
46645: PUSH
46646: LD_INT 2100
46648: ST_TO_ADDR
// if amount < min then
46649: LD_VAR 0 9
46653: PUSH
46654: LD_VAR 0 3
46658: LESS
46659: IFFALSE 46677
// r := r * 2 else
46661: LD_ADDR_VAR 0 7
46665: PUSH
46666: LD_VAR 0 7
46670: PUSH
46671: LD_INT 2
46673: MUL
46674: ST_TO_ADDR
46675: GO 46703
// if amount > max then
46677: LD_VAR 0 9
46681: PUSH
46682: LD_VAR 0 4
46686: GREATER
46687: IFFALSE 46703
// r := r / 2 ;
46689: LD_ADDR_VAR 0 7
46693: PUSH
46694: LD_VAR 0 7
46698: PUSH
46699: LD_INT 2
46701: DIVREAL
46702: ST_TO_ADDR
// time := time / r ;
46703: LD_ADDR_VAR 0 8
46707: PUSH
46708: LD_VAR 0 8
46712: PUSH
46713: LD_VAR 0 7
46717: DIVREAL
46718: ST_TO_ADDR
// if time < 0 then
46719: LD_VAR 0 8
46723: PUSH
46724: LD_INT 0
46726: LESS
46727: IFFALSE 46744
// time := time * - 1 ;
46729: LD_ADDR_VAR 0 8
46733: PUSH
46734: LD_VAR 0 8
46738: PUSH
46739: LD_INT 1
46741: NEG
46742: MUL
46743: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46744: LD_VAR 0 8
46748: PUSH
46749: LD_INT 35
46751: PPUSH
46752: LD_INT 875
46754: PPUSH
46755: CALL_OW 12
46759: PLUS
46760: PPUSH
46761: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46765: LD_INT 1
46767: PPUSH
46768: LD_INT 5
46770: PPUSH
46771: CALL_OW 12
46775: PPUSH
46776: LD_VAR 0 1
46780: PPUSH
46781: LD_INT 1
46783: PPUSH
46784: CALL_OW 55
// end ;
46788: GO 46601
// end ;
46790: LD_VAR 0 5
46794: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46795: LD_INT 0
46797: PPUSH
46798: PPUSH
46799: PPUSH
46800: PPUSH
46801: PPUSH
46802: PPUSH
46803: PPUSH
46804: PPUSH
// if not turrets or not factories then
46805: LD_VAR 0 1
46809: NOT
46810: PUSH
46811: LD_VAR 0 2
46815: NOT
46816: OR
46817: IFFALSE 46821
// exit ;
46819: GO 47128
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46821: LD_ADDR_VAR 0 10
46825: PUSH
46826: LD_INT 5
46828: PUSH
46829: LD_INT 6
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 2
46838: PUSH
46839: LD_INT 4
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: LD_INT 3
46848: PUSH
46849: LD_INT 5
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: LIST
46860: PUSH
46861: LD_INT 24
46863: PUSH
46864: LD_INT 25
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 23
46873: PUSH
46874: LD_INT 27
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PUSH
46885: LD_INT 42
46887: PUSH
46888: LD_INT 43
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: LD_INT 44
46897: PUSH
46898: LD_INT 46
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: PUSH
46905: LD_INT 45
46907: PUSH
46908: LD_INT 47
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: LIST
46919: PUSH
46920: EMPTY
46921: LIST
46922: LIST
46923: LIST
46924: ST_TO_ADDR
// result := [ ] ;
46925: LD_ADDR_VAR 0 3
46929: PUSH
46930: EMPTY
46931: ST_TO_ADDR
// for i in turrets do
46932: LD_ADDR_VAR 0 4
46936: PUSH
46937: LD_VAR 0 1
46941: PUSH
46942: FOR_IN
46943: IFFALSE 47126
// begin nat := GetNation ( i ) ;
46945: LD_ADDR_VAR 0 7
46949: PUSH
46950: LD_VAR 0 4
46954: PPUSH
46955: CALL_OW 248
46959: ST_TO_ADDR
// weapon := 0 ;
46960: LD_ADDR_VAR 0 8
46964: PUSH
46965: LD_INT 0
46967: ST_TO_ADDR
// if not nat then
46968: LD_VAR 0 7
46972: NOT
46973: IFFALSE 46977
// continue ;
46975: GO 46942
// for j in list [ nat ] do
46977: LD_ADDR_VAR 0 5
46981: PUSH
46982: LD_VAR 0 10
46986: PUSH
46987: LD_VAR 0 7
46991: ARRAY
46992: PUSH
46993: FOR_IN
46994: IFFALSE 47035
// if GetBWeapon ( i ) = j [ 1 ] then
46996: LD_VAR 0 4
47000: PPUSH
47001: CALL_OW 269
47005: PUSH
47006: LD_VAR 0 5
47010: PUSH
47011: LD_INT 1
47013: ARRAY
47014: EQUAL
47015: IFFALSE 47033
// begin weapon := j [ 2 ] ;
47017: LD_ADDR_VAR 0 8
47021: PUSH
47022: LD_VAR 0 5
47026: PUSH
47027: LD_INT 2
47029: ARRAY
47030: ST_TO_ADDR
// break ;
47031: GO 47035
// end ;
47033: GO 46993
47035: POP
47036: POP
// if not weapon then
47037: LD_VAR 0 8
47041: NOT
47042: IFFALSE 47046
// continue ;
47044: GO 46942
// for k in factories do
47046: LD_ADDR_VAR 0 6
47050: PUSH
47051: LD_VAR 0 2
47055: PUSH
47056: FOR_IN
47057: IFFALSE 47122
// begin weapons := AvailableWeaponList ( k ) ;
47059: LD_ADDR_VAR 0 9
47063: PUSH
47064: LD_VAR 0 6
47068: PPUSH
47069: CALL_OW 478
47073: ST_TO_ADDR
// if not weapons then
47074: LD_VAR 0 9
47078: NOT
47079: IFFALSE 47083
// continue ;
47081: GO 47056
// if weapon in weapons then
47083: LD_VAR 0 8
47087: PUSH
47088: LD_VAR 0 9
47092: IN
47093: IFFALSE 47120
// begin result := [ i , weapon ] ;
47095: LD_ADDR_VAR 0 3
47099: PUSH
47100: LD_VAR 0 4
47104: PUSH
47105: LD_VAR 0 8
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: ST_TO_ADDR
// exit ;
47114: POP
47115: POP
47116: POP
47117: POP
47118: GO 47128
// end ; end ;
47120: GO 47056
47122: POP
47123: POP
// end ;
47124: GO 46942
47126: POP
47127: POP
// end ;
47128: LD_VAR 0 3
47132: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47133: LD_INT 0
47135: PPUSH
// if not side or side > 8 then
47136: LD_VAR 0 3
47140: NOT
47141: PUSH
47142: LD_VAR 0 3
47146: PUSH
47147: LD_INT 8
47149: GREATER
47150: OR
47151: IFFALSE 47155
// exit ;
47153: GO 47214
// if not range then
47155: LD_VAR 0 4
47159: NOT
47160: IFFALSE 47171
// range := - 12 ;
47162: LD_ADDR_VAR 0 4
47166: PUSH
47167: LD_INT 12
47169: NEG
47170: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47171: LD_VAR 0 1
47175: PPUSH
47176: LD_VAR 0 2
47180: PPUSH
47181: LD_VAR 0 3
47185: PPUSH
47186: LD_VAR 0 4
47190: PPUSH
47191: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47195: LD_VAR 0 1
47199: PPUSH
47200: LD_VAR 0 2
47204: PPUSH
47205: LD_VAR 0 3
47209: PPUSH
47210: CALL_OW 331
// end ;
47214: LD_VAR 0 5
47218: RET
// export function Video ( mode ) ; begin
47219: LD_INT 0
47221: PPUSH
// ingame_video = mode ;
47222: LD_ADDR_OWVAR 52
47226: PUSH
47227: LD_VAR 0 1
47231: ST_TO_ADDR
// interface_hidden = mode ;
47232: LD_ADDR_OWVAR 54
47236: PUSH
47237: LD_VAR 0 1
47241: ST_TO_ADDR
// end ;
47242: LD_VAR 0 2
47246: RET
// export function Join ( array , element ) ; begin
47247: LD_INT 0
47249: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47250: LD_ADDR_VAR 0 3
47254: PUSH
47255: LD_VAR 0 1
47259: PPUSH
47260: LD_VAR 0 1
47264: PUSH
47265: LD_INT 1
47267: PLUS
47268: PPUSH
47269: LD_VAR 0 2
47273: PPUSH
47274: CALL_OW 1
47278: ST_TO_ADDR
// end ;
47279: LD_VAR 0 3
47283: RET
// export function JoinUnion ( array , element ) ; begin
47284: LD_INT 0
47286: PPUSH
// result := array union element ;
47287: LD_ADDR_VAR 0 3
47291: PUSH
47292: LD_VAR 0 1
47296: PUSH
47297: LD_VAR 0 2
47301: UNION
47302: ST_TO_ADDR
// end ;
47303: LD_VAR 0 3
47307: RET
// export function GetBehemoths ( side ) ; begin
47308: LD_INT 0
47310: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47311: LD_ADDR_VAR 0 2
47315: PUSH
47316: LD_INT 22
47318: PUSH
47319: LD_VAR 0 1
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: LD_INT 31
47330: PUSH
47331: LD_INT 25
47333: PUSH
47334: EMPTY
47335: LIST
47336: LIST
47337: PUSH
47338: EMPTY
47339: LIST
47340: LIST
47341: PPUSH
47342: CALL_OW 69
47346: ST_TO_ADDR
// end ;
47347: LD_VAR 0 2
47351: RET
// export function Shuffle ( array ) ; var i , index ; begin
47352: LD_INT 0
47354: PPUSH
47355: PPUSH
47356: PPUSH
// result := [ ] ;
47357: LD_ADDR_VAR 0 2
47361: PUSH
47362: EMPTY
47363: ST_TO_ADDR
// if not array then
47364: LD_VAR 0 1
47368: NOT
47369: IFFALSE 47373
// exit ;
47371: GO 47472
// Randomize ;
47373: CALL_OW 10
// for i = array downto 1 do
47377: LD_ADDR_VAR 0 3
47381: PUSH
47382: DOUBLE
47383: LD_VAR 0 1
47387: INC
47388: ST_TO_ADDR
47389: LD_INT 1
47391: PUSH
47392: FOR_DOWNTO
47393: IFFALSE 47470
// begin index := rand ( 1 , array ) ;
47395: LD_ADDR_VAR 0 4
47399: PUSH
47400: LD_INT 1
47402: PPUSH
47403: LD_VAR 0 1
47407: PPUSH
47408: CALL_OW 12
47412: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47413: LD_ADDR_VAR 0 2
47417: PUSH
47418: LD_VAR 0 2
47422: PPUSH
47423: LD_VAR 0 2
47427: PUSH
47428: LD_INT 1
47430: PLUS
47431: PPUSH
47432: LD_VAR 0 1
47436: PUSH
47437: LD_VAR 0 4
47441: ARRAY
47442: PPUSH
47443: CALL_OW 2
47447: ST_TO_ADDR
// array := Delete ( array , index ) ;
47448: LD_ADDR_VAR 0 1
47452: PUSH
47453: LD_VAR 0 1
47457: PPUSH
47458: LD_VAR 0 4
47462: PPUSH
47463: CALL_OW 3
47467: ST_TO_ADDR
// end ;
47468: GO 47392
47470: POP
47471: POP
// end ;
47472: LD_VAR 0 2
47476: RET
// export function GetBaseMaterials ( base ) ; begin
47477: LD_INT 0
47479: PPUSH
// result := [ 0 , 0 , 0 ] ;
47480: LD_ADDR_VAR 0 2
47484: PUSH
47485: LD_INT 0
47487: PUSH
47488: LD_INT 0
47490: PUSH
47491: LD_INT 0
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: LIST
47498: ST_TO_ADDR
// if not base then
47499: LD_VAR 0 1
47503: NOT
47504: IFFALSE 47508
// exit ;
47506: GO 47557
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47508: LD_ADDR_VAR 0 2
47512: PUSH
47513: LD_VAR 0 1
47517: PPUSH
47518: LD_INT 1
47520: PPUSH
47521: CALL_OW 275
47525: PUSH
47526: LD_VAR 0 1
47530: PPUSH
47531: LD_INT 2
47533: PPUSH
47534: CALL_OW 275
47538: PUSH
47539: LD_VAR 0 1
47543: PPUSH
47544: LD_INT 3
47546: PPUSH
47547: CALL_OW 275
47551: PUSH
47552: EMPTY
47553: LIST
47554: LIST
47555: LIST
47556: ST_TO_ADDR
// end ;
47557: LD_VAR 0 2
47561: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47562: LD_INT 0
47564: PPUSH
47565: PPUSH
// result := array ;
47566: LD_ADDR_VAR 0 3
47570: PUSH
47571: LD_VAR 0 1
47575: ST_TO_ADDR
// if size >= result then
47576: LD_VAR 0 2
47580: PUSH
47581: LD_VAR 0 3
47585: GREATEREQUAL
47586: IFFALSE 47590
// exit ;
47588: GO 47640
// if size then
47590: LD_VAR 0 2
47594: IFFALSE 47640
// for i := array downto size do
47596: LD_ADDR_VAR 0 4
47600: PUSH
47601: DOUBLE
47602: LD_VAR 0 1
47606: INC
47607: ST_TO_ADDR
47608: LD_VAR 0 2
47612: PUSH
47613: FOR_DOWNTO
47614: IFFALSE 47638
// result := Delete ( result , result ) ;
47616: LD_ADDR_VAR 0 3
47620: PUSH
47621: LD_VAR 0 3
47625: PPUSH
47626: LD_VAR 0 3
47630: PPUSH
47631: CALL_OW 3
47635: ST_TO_ADDR
47636: GO 47613
47638: POP
47639: POP
// end ;
47640: LD_VAR 0 3
47644: RET
// export function ComExit ( unit ) ; var tmp ; begin
47645: LD_INT 0
47647: PPUSH
47648: PPUSH
// if not IsInUnit ( unit ) then
47649: LD_VAR 0 1
47653: PPUSH
47654: CALL_OW 310
47658: NOT
47659: IFFALSE 47663
// exit ;
47661: GO 47723
// tmp := IsInUnit ( unit ) ;
47663: LD_ADDR_VAR 0 3
47667: PUSH
47668: LD_VAR 0 1
47672: PPUSH
47673: CALL_OW 310
47677: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47678: LD_VAR 0 3
47682: PPUSH
47683: CALL_OW 247
47687: PUSH
47688: LD_INT 2
47690: EQUAL
47691: IFFALSE 47704
// ComExitVehicle ( unit ) else
47693: LD_VAR 0 1
47697: PPUSH
47698: CALL_OW 121
47702: GO 47713
// ComExitBuilding ( unit ) ;
47704: LD_VAR 0 1
47708: PPUSH
47709: CALL_OW 122
// result := tmp ;
47713: LD_ADDR_VAR 0 2
47717: PUSH
47718: LD_VAR 0 3
47722: ST_TO_ADDR
// end ;
47723: LD_VAR 0 2
47727: RET
// export function ComExitAll ( units ) ; var i ; begin
47728: LD_INT 0
47730: PPUSH
47731: PPUSH
// if not units then
47732: LD_VAR 0 1
47736: NOT
47737: IFFALSE 47741
// exit ;
47739: GO 47767
// for i in units do
47741: LD_ADDR_VAR 0 3
47745: PUSH
47746: LD_VAR 0 1
47750: PUSH
47751: FOR_IN
47752: IFFALSE 47765
// ComExit ( i ) ;
47754: LD_VAR 0 3
47758: PPUSH
47759: CALL 47645 0 1
47763: GO 47751
47765: POP
47766: POP
// end ;
47767: LD_VAR 0 2
47771: RET
// export function ResetHc ; begin
47772: LD_INT 0
47774: PPUSH
// InitHc ;
47775: CALL_OW 19
// hc_importance := 0 ;
47779: LD_ADDR_OWVAR 32
47783: PUSH
47784: LD_INT 0
47786: ST_TO_ADDR
// end ;
47787: LD_VAR 0 1
47791: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47792: LD_INT 0
47794: PPUSH
47795: PPUSH
47796: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47797: LD_ADDR_VAR 0 6
47801: PUSH
47802: LD_VAR 0 1
47806: PUSH
47807: LD_VAR 0 3
47811: PLUS
47812: PUSH
47813: LD_INT 2
47815: DIV
47816: ST_TO_ADDR
// if _x < 0 then
47817: LD_VAR 0 6
47821: PUSH
47822: LD_INT 0
47824: LESS
47825: IFFALSE 47842
// _x := _x * - 1 ;
47827: LD_ADDR_VAR 0 6
47831: PUSH
47832: LD_VAR 0 6
47836: PUSH
47837: LD_INT 1
47839: NEG
47840: MUL
47841: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47842: LD_ADDR_VAR 0 7
47846: PUSH
47847: LD_VAR 0 2
47851: PUSH
47852: LD_VAR 0 4
47856: PLUS
47857: PUSH
47858: LD_INT 2
47860: DIV
47861: ST_TO_ADDR
// if _y < 0 then
47862: LD_VAR 0 7
47866: PUSH
47867: LD_INT 0
47869: LESS
47870: IFFALSE 47887
// _y := _y * - 1 ;
47872: LD_ADDR_VAR 0 7
47876: PUSH
47877: LD_VAR 0 7
47881: PUSH
47882: LD_INT 1
47884: NEG
47885: MUL
47886: ST_TO_ADDR
// result := [ _x , _y ] ;
47887: LD_ADDR_VAR 0 5
47891: PUSH
47892: LD_VAR 0 6
47896: PUSH
47897: LD_VAR 0 7
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: ST_TO_ADDR
// end ;
47906: LD_VAR 0 5
47910: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47911: LD_INT 0
47913: PPUSH
47914: PPUSH
47915: PPUSH
47916: PPUSH
// task := GetTaskList ( unit ) ;
47917: LD_ADDR_VAR 0 7
47921: PUSH
47922: LD_VAR 0 1
47926: PPUSH
47927: CALL_OW 437
47931: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47932: LD_VAR 0 7
47936: NOT
47937: PUSH
47938: LD_VAR 0 1
47942: PPUSH
47943: LD_VAR 0 2
47947: PPUSH
47948: CALL_OW 308
47952: NOT
47953: AND
47954: IFFALSE 47958
// exit ;
47956: GO 48076
// if IsInArea ( unit , area ) then
47958: LD_VAR 0 1
47962: PPUSH
47963: LD_VAR 0 2
47967: PPUSH
47968: CALL_OW 308
47972: IFFALSE 47990
// begin ComMoveToArea ( unit , goAway ) ;
47974: LD_VAR 0 1
47978: PPUSH
47979: LD_VAR 0 3
47983: PPUSH
47984: CALL_OW 113
// exit ;
47988: GO 48076
// end ; if task [ 1 ] [ 1 ] <> M then
47990: LD_VAR 0 7
47994: PUSH
47995: LD_INT 1
47997: ARRAY
47998: PUSH
47999: LD_INT 1
48001: ARRAY
48002: PUSH
48003: LD_STRING M
48005: NONEQUAL
48006: IFFALSE 48010
// exit ;
48008: GO 48076
// x := task [ 1 ] [ 2 ] ;
48010: LD_ADDR_VAR 0 5
48014: PUSH
48015: LD_VAR 0 7
48019: PUSH
48020: LD_INT 1
48022: ARRAY
48023: PUSH
48024: LD_INT 2
48026: ARRAY
48027: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48028: LD_ADDR_VAR 0 6
48032: PUSH
48033: LD_VAR 0 7
48037: PUSH
48038: LD_INT 1
48040: ARRAY
48041: PUSH
48042: LD_INT 3
48044: ARRAY
48045: ST_TO_ADDR
// if InArea ( x , y , area ) then
48046: LD_VAR 0 5
48050: PPUSH
48051: LD_VAR 0 6
48055: PPUSH
48056: LD_VAR 0 2
48060: PPUSH
48061: CALL_OW 309
48065: IFFALSE 48076
// ComStop ( unit ) ;
48067: LD_VAR 0 1
48071: PPUSH
48072: CALL_OW 141
// end ;
48076: LD_VAR 0 4
48080: RET
// export function Abs ( value ) ; begin
48081: LD_INT 0
48083: PPUSH
// result := value ;
48084: LD_ADDR_VAR 0 2
48088: PUSH
48089: LD_VAR 0 1
48093: ST_TO_ADDR
// if value < 0 then
48094: LD_VAR 0 1
48098: PUSH
48099: LD_INT 0
48101: LESS
48102: IFFALSE 48119
// result := value * - 1 ;
48104: LD_ADDR_VAR 0 2
48108: PUSH
48109: LD_VAR 0 1
48113: PUSH
48114: LD_INT 1
48116: NEG
48117: MUL
48118: ST_TO_ADDR
// end ;
48119: LD_VAR 0 2
48123: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48124: LD_INT 0
48126: PPUSH
48127: PPUSH
48128: PPUSH
48129: PPUSH
48130: PPUSH
48131: PPUSH
48132: PPUSH
48133: PPUSH
// if not unit or not building then
48134: LD_VAR 0 1
48138: NOT
48139: PUSH
48140: LD_VAR 0 2
48144: NOT
48145: OR
48146: IFFALSE 48150
// exit ;
48148: GO 48376
// x := GetX ( building ) ;
48150: LD_ADDR_VAR 0 4
48154: PUSH
48155: LD_VAR 0 2
48159: PPUSH
48160: CALL_OW 250
48164: ST_TO_ADDR
// y := GetY ( building ) ;
48165: LD_ADDR_VAR 0 6
48169: PUSH
48170: LD_VAR 0 2
48174: PPUSH
48175: CALL_OW 251
48179: ST_TO_ADDR
// d := GetDir ( building ) ;
48180: LD_ADDR_VAR 0 8
48184: PUSH
48185: LD_VAR 0 2
48189: PPUSH
48190: CALL_OW 254
48194: ST_TO_ADDR
// r := 4 ;
48195: LD_ADDR_VAR 0 9
48199: PUSH
48200: LD_INT 4
48202: ST_TO_ADDR
// for i := 1 to 5 do
48203: LD_ADDR_VAR 0 10
48207: PUSH
48208: DOUBLE
48209: LD_INT 1
48211: DEC
48212: ST_TO_ADDR
48213: LD_INT 5
48215: PUSH
48216: FOR_TO
48217: IFFALSE 48374
// begin _x := ShiftX ( x , d , r + i ) ;
48219: LD_ADDR_VAR 0 5
48223: PUSH
48224: LD_VAR 0 4
48228: PPUSH
48229: LD_VAR 0 8
48233: PPUSH
48234: LD_VAR 0 9
48238: PUSH
48239: LD_VAR 0 10
48243: PLUS
48244: PPUSH
48245: CALL_OW 272
48249: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48250: LD_ADDR_VAR 0 7
48254: PUSH
48255: LD_VAR 0 6
48259: PPUSH
48260: LD_VAR 0 8
48264: PPUSH
48265: LD_VAR 0 9
48269: PUSH
48270: LD_VAR 0 10
48274: PLUS
48275: PPUSH
48276: CALL_OW 273
48280: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48281: LD_VAR 0 5
48285: PPUSH
48286: LD_VAR 0 7
48290: PPUSH
48291: CALL_OW 488
48295: PUSH
48296: LD_VAR 0 5
48300: PPUSH
48301: LD_VAR 0 7
48305: PPUSH
48306: CALL_OW 428
48310: PPUSH
48311: CALL_OW 247
48315: PUSH
48316: LD_INT 3
48318: PUSH
48319: LD_INT 2
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: IN
48326: NOT
48327: AND
48328: IFFALSE 48372
// begin ComMoveXY ( unit , _x , _y ) ;
48330: LD_VAR 0 1
48334: PPUSH
48335: LD_VAR 0 5
48339: PPUSH
48340: LD_VAR 0 7
48344: PPUSH
48345: CALL_OW 111
// result := [ _x , _y ] ;
48349: LD_ADDR_VAR 0 3
48353: PUSH
48354: LD_VAR 0 5
48358: PUSH
48359: LD_VAR 0 7
48363: PUSH
48364: EMPTY
48365: LIST
48366: LIST
48367: ST_TO_ADDR
// exit ;
48368: POP
48369: POP
48370: GO 48376
// end ; end ;
48372: GO 48216
48374: POP
48375: POP
// end ;
48376: LD_VAR 0 3
48380: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48381: LD_INT 0
48383: PPUSH
48384: PPUSH
48385: PPUSH
// result := 0 ;
48386: LD_ADDR_VAR 0 3
48390: PUSH
48391: LD_INT 0
48393: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48394: LD_VAR 0 1
48398: PUSH
48399: LD_INT 0
48401: LESS
48402: PUSH
48403: LD_VAR 0 1
48407: PUSH
48408: LD_INT 8
48410: GREATER
48411: OR
48412: PUSH
48413: LD_VAR 0 2
48417: PUSH
48418: LD_INT 0
48420: LESS
48421: OR
48422: PUSH
48423: LD_VAR 0 2
48427: PUSH
48428: LD_INT 8
48430: GREATER
48431: OR
48432: IFFALSE 48436
// exit ;
48434: GO 48511
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48436: LD_ADDR_VAR 0 4
48440: PUSH
48441: LD_INT 22
48443: PUSH
48444: LD_VAR 0 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PPUSH
48453: CALL_OW 69
48457: PUSH
48458: FOR_IN
48459: IFFALSE 48509
// begin un := UnitShoot ( i ) ;
48461: LD_ADDR_VAR 0 5
48465: PUSH
48466: LD_VAR 0 4
48470: PPUSH
48471: CALL_OW 504
48475: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48476: LD_VAR 0 5
48480: PPUSH
48481: CALL_OW 255
48485: PUSH
48486: LD_VAR 0 1
48490: EQUAL
48491: IFFALSE 48507
// begin result := un ;
48493: LD_ADDR_VAR 0 3
48497: PUSH
48498: LD_VAR 0 5
48502: ST_TO_ADDR
// exit ;
48503: POP
48504: POP
48505: GO 48511
// end ; end ;
48507: GO 48458
48509: POP
48510: POP
// end ;
48511: LD_VAR 0 3
48515: RET
// export function GetCargoBay ( units ) ; begin
48516: LD_INT 0
48518: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48519: LD_ADDR_VAR 0 2
48523: PUSH
48524: LD_VAR 0 1
48528: PPUSH
48529: LD_INT 2
48531: PUSH
48532: LD_INT 34
48534: PUSH
48535: LD_INT 12
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 34
48544: PUSH
48545: LD_INT 51
48547: PUSH
48548: EMPTY
48549: LIST
48550: LIST
48551: PUSH
48552: LD_INT 34
48554: PUSH
48555: LD_INT 32
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: PUSH
48562: LD_INT 34
48564: PUSH
48565: LD_INT 89
48567: PUSH
48568: EMPTY
48569: LIST
48570: LIST
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: LIST
48576: LIST
48577: LIST
48578: PPUSH
48579: CALL_OW 72
48583: ST_TO_ADDR
// end ;
48584: LD_VAR 0 2
48588: RET
// export function Negate ( value ) ; begin
48589: LD_INT 0
48591: PPUSH
// result := not value ;
48592: LD_ADDR_VAR 0 2
48596: PUSH
48597: LD_VAR 0 1
48601: NOT
48602: ST_TO_ADDR
// end ;
48603: LD_VAR 0 2
48607: RET
// export function Inc ( value ) ; begin
48608: LD_INT 0
48610: PPUSH
// result := value + 1 ;
48611: LD_ADDR_VAR 0 2
48615: PUSH
48616: LD_VAR 0 1
48620: PUSH
48621: LD_INT 1
48623: PLUS
48624: ST_TO_ADDR
// end ;
48625: LD_VAR 0 2
48629: RET
// export function Dec ( value ) ; begin
48630: LD_INT 0
48632: PPUSH
// result := value - 1 ;
48633: LD_ADDR_VAR 0 2
48637: PUSH
48638: LD_VAR 0 1
48642: PUSH
48643: LD_INT 1
48645: MINUS
48646: ST_TO_ADDR
// end ;
48647: LD_VAR 0 2
48651: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48652: LD_INT 0
48654: PPUSH
48655: PPUSH
48656: PPUSH
48657: PPUSH
48658: PPUSH
48659: PPUSH
48660: PPUSH
48661: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48662: LD_VAR 0 1
48666: PPUSH
48667: LD_VAR 0 2
48671: PPUSH
48672: CALL_OW 488
48676: NOT
48677: PUSH
48678: LD_VAR 0 3
48682: PPUSH
48683: LD_VAR 0 4
48687: PPUSH
48688: CALL_OW 488
48692: NOT
48693: OR
48694: IFFALSE 48707
// begin result := - 1 ;
48696: LD_ADDR_VAR 0 5
48700: PUSH
48701: LD_INT 1
48703: NEG
48704: ST_TO_ADDR
// exit ;
48705: GO 48942
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48707: LD_ADDR_VAR 0 12
48711: PUSH
48712: LD_VAR 0 1
48716: PPUSH
48717: LD_VAR 0 2
48721: PPUSH
48722: LD_VAR 0 3
48726: PPUSH
48727: LD_VAR 0 4
48731: PPUSH
48732: CALL 47792 0 4
48736: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48737: LD_ADDR_VAR 0 11
48741: PUSH
48742: LD_VAR 0 1
48746: PPUSH
48747: LD_VAR 0 2
48751: PPUSH
48752: LD_VAR 0 12
48756: PUSH
48757: LD_INT 1
48759: ARRAY
48760: PPUSH
48761: LD_VAR 0 12
48765: PUSH
48766: LD_INT 2
48768: ARRAY
48769: PPUSH
48770: CALL_OW 298
48774: ST_TO_ADDR
// distance := 9999 ;
48775: LD_ADDR_VAR 0 10
48779: PUSH
48780: LD_INT 9999
48782: ST_TO_ADDR
// for i := 0 to 5 do
48783: LD_ADDR_VAR 0 6
48787: PUSH
48788: DOUBLE
48789: LD_INT 0
48791: DEC
48792: ST_TO_ADDR
48793: LD_INT 5
48795: PUSH
48796: FOR_TO
48797: IFFALSE 48940
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48799: LD_ADDR_VAR 0 7
48803: PUSH
48804: LD_VAR 0 1
48808: PPUSH
48809: LD_VAR 0 6
48813: PPUSH
48814: LD_VAR 0 11
48818: PPUSH
48819: CALL_OW 272
48823: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48824: LD_ADDR_VAR 0 8
48828: PUSH
48829: LD_VAR 0 2
48833: PPUSH
48834: LD_VAR 0 6
48838: PPUSH
48839: LD_VAR 0 11
48843: PPUSH
48844: CALL_OW 273
48848: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48849: LD_VAR 0 7
48853: PPUSH
48854: LD_VAR 0 8
48858: PPUSH
48859: CALL_OW 488
48863: NOT
48864: IFFALSE 48868
// continue ;
48866: GO 48796
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48868: LD_ADDR_VAR 0 9
48872: PUSH
48873: LD_VAR 0 12
48877: PUSH
48878: LD_INT 1
48880: ARRAY
48881: PPUSH
48882: LD_VAR 0 12
48886: PUSH
48887: LD_INT 2
48889: ARRAY
48890: PPUSH
48891: LD_VAR 0 7
48895: PPUSH
48896: LD_VAR 0 8
48900: PPUSH
48901: CALL_OW 298
48905: ST_TO_ADDR
// if tmp < distance then
48906: LD_VAR 0 9
48910: PUSH
48911: LD_VAR 0 10
48915: LESS
48916: IFFALSE 48938
// begin result := i ;
48918: LD_ADDR_VAR 0 5
48922: PUSH
48923: LD_VAR 0 6
48927: ST_TO_ADDR
// distance := tmp ;
48928: LD_ADDR_VAR 0 10
48932: PUSH
48933: LD_VAR 0 9
48937: ST_TO_ADDR
// end ; end ;
48938: GO 48796
48940: POP
48941: POP
// end ;
48942: LD_VAR 0 5
48946: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48947: LD_INT 0
48949: PPUSH
48950: PPUSH
// if not driver or not IsInUnit ( driver ) then
48951: LD_VAR 0 1
48955: NOT
48956: PUSH
48957: LD_VAR 0 1
48961: PPUSH
48962: CALL_OW 310
48966: NOT
48967: OR
48968: IFFALSE 48972
// exit ;
48970: GO 49062
// vehicle := IsInUnit ( driver ) ;
48972: LD_ADDR_VAR 0 3
48976: PUSH
48977: LD_VAR 0 1
48981: PPUSH
48982: CALL_OW 310
48986: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48987: LD_VAR 0 1
48991: PPUSH
48992: LD_STRING \
48994: PUSH
48995: LD_INT 0
48997: PUSH
48998: LD_INT 0
49000: PUSH
49001: LD_INT 0
49003: PUSH
49004: LD_INT 0
49006: PUSH
49007: LD_INT 0
49009: PUSH
49010: LD_INT 0
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: LIST
49017: LIST
49018: LIST
49019: LIST
49020: LIST
49021: PUSH
49022: LD_STRING E
49024: PUSH
49025: LD_INT 0
49027: PUSH
49028: LD_INT 0
49030: PUSH
49031: LD_VAR 0 3
49035: PUSH
49036: LD_INT 0
49038: PUSH
49039: LD_INT 0
49041: PUSH
49042: LD_INT 0
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PPUSH
49058: CALL_OW 446
// end ;
49062: LD_VAR 0 2
49066: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49067: LD_INT 0
49069: PPUSH
49070: PPUSH
// if not driver or not IsInUnit ( driver ) then
49071: LD_VAR 0 1
49075: NOT
49076: PUSH
49077: LD_VAR 0 1
49081: PPUSH
49082: CALL_OW 310
49086: NOT
49087: OR
49088: IFFALSE 49092
// exit ;
49090: GO 49182
// vehicle := IsInUnit ( driver ) ;
49092: LD_ADDR_VAR 0 3
49096: PUSH
49097: LD_VAR 0 1
49101: PPUSH
49102: CALL_OW 310
49106: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49107: LD_VAR 0 1
49111: PPUSH
49112: LD_STRING \
49114: PUSH
49115: LD_INT 0
49117: PUSH
49118: LD_INT 0
49120: PUSH
49121: LD_INT 0
49123: PUSH
49124: LD_INT 0
49126: PUSH
49127: LD_INT 0
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: PUSH
49142: LD_STRING E
49144: PUSH
49145: LD_INT 0
49147: PUSH
49148: LD_INT 0
49150: PUSH
49151: LD_VAR 0 3
49155: PUSH
49156: LD_INT 0
49158: PUSH
49159: LD_INT 0
49161: PUSH
49162: LD_INT 0
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PPUSH
49178: CALL_OW 447
// end ;
49182: LD_VAR 0 2
49186: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49187: LD_INT 0
49189: PPUSH
49190: PPUSH
49191: PPUSH
// tmp := [ ] ;
49192: LD_ADDR_VAR 0 5
49196: PUSH
49197: EMPTY
49198: ST_TO_ADDR
// for i in units do
49199: LD_ADDR_VAR 0 4
49203: PUSH
49204: LD_VAR 0 1
49208: PUSH
49209: FOR_IN
49210: IFFALSE 49248
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49212: LD_ADDR_VAR 0 5
49216: PUSH
49217: LD_VAR 0 5
49221: PPUSH
49222: LD_VAR 0 5
49226: PUSH
49227: LD_INT 1
49229: PLUS
49230: PPUSH
49231: LD_VAR 0 4
49235: PPUSH
49236: CALL_OW 256
49240: PPUSH
49241: CALL_OW 2
49245: ST_TO_ADDR
49246: GO 49209
49248: POP
49249: POP
// if not tmp then
49250: LD_VAR 0 5
49254: NOT
49255: IFFALSE 49259
// exit ;
49257: GO 49307
// if asc then
49259: LD_VAR 0 2
49263: IFFALSE 49287
// result := SortListByListAsc ( units , tmp ) else
49265: LD_ADDR_VAR 0 3
49269: PUSH
49270: LD_VAR 0 1
49274: PPUSH
49275: LD_VAR 0 5
49279: PPUSH
49280: CALL_OW 76
49284: ST_TO_ADDR
49285: GO 49307
// result := SortListByListDesc ( units , tmp ) ;
49287: LD_ADDR_VAR 0 3
49291: PUSH
49292: LD_VAR 0 1
49296: PPUSH
49297: LD_VAR 0 5
49301: PPUSH
49302: CALL_OW 77
49306: ST_TO_ADDR
// end ;
49307: LD_VAR 0 3
49311: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49312: LD_INT 0
49314: PPUSH
49315: PPUSH
// task := GetTaskList ( mech ) ;
49316: LD_ADDR_VAR 0 4
49320: PUSH
49321: LD_VAR 0 1
49325: PPUSH
49326: CALL_OW 437
49330: ST_TO_ADDR
// if not task then
49331: LD_VAR 0 4
49335: NOT
49336: IFFALSE 49340
// exit ;
49338: GO 49382
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49340: LD_ADDR_VAR 0 3
49344: PUSH
49345: LD_VAR 0 4
49349: PUSH
49350: LD_INT 1
49352: ARRAY
49353: PUSH
49354: LD_INT 1
49356: ARRAY
49357: PUSH
49358: LD_STRING r
49360: EQUAL
49361: PUSH
49362: LD_VAR 0 4
49366: PUSH
49367: LD_INT 1
49369: ARRAY
49370: PUSH
49371: LD_INT 4
49373: ARRAY
49374: PUSH
49375: LD_VAR 0 2
49379: EQUAL
49380: AND
49381: ST_TO_ADDR
// end ;
49382: LD_VAR 0 3
49386: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49387: LD_INT 0
49389: PPUSH
// SetDir ( unit , d ) ;
49390: LD_VAR 0 1
49394: PPUSH
49395: LD_VAR 0 4
49399: PPUSH
49400: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49404: LD_VAR 0 1
49408: PPUSH
49409: LD_VAR 0 2
49413: PPUSH
49414: LD_VAR 0 3
49418: PPUSH
49419: LD_VAR 0 5
49423: PPUSH
49424: CALL_OW 48
// end ;
49428: LD_VAR 0 6
49432: RET
// export function ToNaturalNumber ( number ) ; begin
49433: LD_INT 0
49435: PPUSH
// result := number div 1 ;
49436: LD_ADDR_VAR 0 2
49440: PUSH
49441: LD_VAR 0 1
49445: PUSH
49446: LD_INT 1
49448: DIV
49449: ST_TO_ADDR
// if number < 0 then
49450: LD_VAR 0 1
49454: PUSH
49455: LD_INT 0
49457: LESS
49458: IFFALSE 49468
// result := 0 ;
49460: LD_ADDR_VAR 0 2
49464: PUSH
49465: LD_INT 0
49467: ST_TO_ADDR
// end ;
49468: LD_VAR 0 2
49472: RET
// export function SortByClass ( units , class ) ; var un ; begin
49473: LD_INT 0
49475: PPUSH
49476: PPUSH
// if not units or not class then
49477: LD_VAR 0 1
49481: NOT
49482: PUSH
49483: LD_VAR 0 2
49487: NOT
49488: OR
49489: IFFALSE 49493
// exit ;
49491: GO 49588
// result := [ ] ;
49493: LD_ADDR_VAR 0 3
49497: PUSH
49498: EMPTY
49499: ST_TO_ADDR
// for un in units do
49500: LD_ADDR_VAR 0 4
49504: PUSH
49505: LD_VAR 0 1
49509: PUSH
49510: FOR_IN
49511: IFFALSE 49586
// if GetClass ( un ) = class then
49513: LD_VAR 0 4
49517: PPUSH
49518: CALL_OW 257
49522: PUSH
49523: LD_VAR 0 2
49527: EQUAL
49528: IFFALSE 49555
// result := Insert ( result , 1 , un ) else
49530: LD_ADDR_VAR 0 3
49534: PUSH
49535: LD_VAR 0 3
49539: PPUSH
49540: LD_INT 1
49542: PPUSH
49543: LD_VAR 0 4
49547: PPUSH
49548: CALL_OW 2
49552: ST_TO_ADDR
49553: GO 49584
// result := Replace ( result , result + 1 , un ) ;
49555: LD_ADDR_VAR 0 3
49559: PUSH
49560: LD_VAR 0 3
49564: PPUSH
49565: LD_VAR 0 3
49569: PUSH
49570: LD_INT 1
49572: PLUS
49573: PPUSH
49574: LD_VAR 0 4
49578: PPUSH
49579: CALL_OW 1
49583: ST_TO_ADDR
49584: GO 49510
49586: POP
49587: POP
// end ;
49588: LD_VAR 0 3
49592: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49593: LD_INT 0
49595: PPUSH
49596: PPUSH
49597: PPUSH
49598: PPUSH
49599: PPUSH
49600: PPUSH
49601: PPUSH
// result := [ ] ;
49602: LD_ADDR_VAR 0 4
49606: PUSH
49607: EMPTY
49608: ST_TO_ADDR
// if x - r < 0 then
49609: LD_VAR 0 1
49613: PUSH
49614: LD_VAR 0 3
49618: MINUS
49619: PUSH
49620: LD_INT 0
49622: LESS
49623: IFFALSE 49635
// min_x := 0 else
49625: LD_ADDR_VAR 0 8
49629: PUSH
49630: LD_INT 0
49632: ST_TO_ADDR
49633: GO 49651
// min_x := x - r ;
49635: LD_ADDR_VAR 0 8
49639: PUSH
49640: LD_VAR 0 1
49644: PUSH
49645: LD_VAR 0 3
49649: MINUS
49650: ST_TO_ADDR
// if y - r < 0 then
49651: LD_VAR 0 2
49655: PUSH
49656: LD_VAR 0 3
49660: MINUS
49661: PUSH
49662: LD_INT 0
49664: LESS
49665: IFFALSE 49677
// min_y := 0 else
49667: LD_ADDR_VAR 0 7
49671: PUSH
49672: LD_INT 0
49674: ST_TO_ADDR
49675: GO 49693
// min_y := y - r ;
49677: LD_ADDR_VAR 0 7
49681: PUSH
49682: LD_VAR 0 2
49686: PUSH
49687: LD_VAR 0 3
49691: MINUS
49692: ST_TO_ADDR
// max_x := x + r ;
49693: LD_ADDR_VAR 0 9
49697: PUSH
49698: LD_VAR 0 1
49702: PUSH
49703: LD_VAR 0 3
49707: PLUS
49708: ST_TO_ADDR
// max_y := y + r ;
49709: LD_ADDR_VAR 0 10
49713: PUSH
49714: LD_VAR 0 2
49718: PUSH
49719: LD_VAR 0 3
49723: PLUS
49724: ST_TO_ADDR
// for _x = min_x to max_x do
49725: LD_ADDR_VAR 0 5
49729: PUSH
49730: DOUBLE
49731: LD_VAR 0 8
49735: DEC
49736: ST_TO_ADDR
49737: LD_VAR 0 9
49741: PUSH
49742: FOR_TO
49743: IFFALSE 49844
// for _y = min_y to max_y do
49745: LD_ADDR_VAR 0 6
49749: PUSH
49750: DOUBLE
49751: LD_VAR 0 7
49755: DEC
49756: ST_TO_ADDR
49757: LD_VAR 0 10
49761: PUSH
49762: FOR_TO
49763: IFFALSE 49840
// begin if not ValidHex ( _x , _y ) then
49765: LD_VAR 0 5
49769: PPUSH
49770: LD_VAR 0 6
49774: PPUSH
49775: CALL_OW 488
49779: NOT
49780: IFFALSE 49784
// continue ;
49782: GO 49762
// if GetResourceTypeXY ( _x , _y ) then
49784: LD_VAR 0 5
49788: PPUSH
49789: LD_VAR 0 6
49793: PPUSH
49794: CALL_OW 283
49798: IFFALSE 49838
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49800: LD_ADDR_VAR 0 4
49804: PUSH
49805: LD_VAR 0 4
49809: PPUSH
49810: LD_VAR 0 4
49814: PUSH
49815: LD_INT 1
49817: PLUS
49818: PPUSH
49819: LD_VAR 0 5
49823: PUSH
49824: LD_VAR 0 6
49828: PUSH
49829: EMPTY
49830: LIST
49831: LIST
49832: PPUSH
49833: CALL_OW 1
49837: ST_TO_ADDR
// end ;
49838: GO 49762
49840: POP
49841: POP
49842: GO 49742
49844: POP
49845: POP
// end ;
49846: LD_VAR 0 4
49850: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49851: LD_INT 0
49853: PPUSH
49854: PPUSH
49855: PPUSH
49856: PPUSH
49857: PPUSH
49858: PPUSH
49859: PPUSH
49860: PPUSH
// if not units then
49861: LD_VAR 0 1
49865: NOT
49866: IFFALSE 49870
// exit ;
49868: GO 50394
// result := UnitFilter ( units , [ f_ok ] ) ;
49870: LD_ADDR_VAR 0 3
49874: PUSH
49875: LD_VAR 0 1
49879: PPUSH
49880: LD_INT 50
49882: PUSH
49883: EMPTY
49884: LIST
49885: PPUSH
49886: CALL_OW 72
49890: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49891: LD_ADDR_VAR 0 8
49895: PUSH
49896: LD_VAR 0 1
49900: PUSH
49901: LD_INT 1
49903: ARRAY
49904: PPUSH
49905: CALL_OW 255
49909: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49910: LD_ADDR_VAR 0 10
49914: PUSH
49915: LD_INT 29
49917: PUSH
49918: LD_INT 91
49920: PUSH
49921: LD_INT 49
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: LIST
49928: ST_TO_ADDR
// if not result then
49929: LD_VAR 0 3
49933: NOT
49934: IFFALSE 49938
// exit ;
49936: GO 50394
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49938: LD_ADDR_VAR 0 5
49942: PUSH
49943: LD_INT 81
49945: PUSH
49946: LD_VAR 0 8
49950: PUSH
49951: EMPTY
49952: LIST
49953: LIST
49954: PPUSH
49955: CALL_OW 69
49959: ST_TO_ADDR
// for i in result do
49960: LD_ADDR_VAR 0 4
49964: PUSH
49965: LD_VAR 0 3
49969: PUSH
49970: FOR_IN
49971: IFFALSE 50392
// begin tag := GetTag ( i ) + 1 ;
49973: LD_ADDR_VAR 0 9
49977: PUSH
49978: LD_VAR 0 4
49982: PPUSH
49983: CALL_OW 110
49987: PUSH
49988: LD_INT 1
49990: PLUS
49991: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49992: LD_ADDR_VAR 0 7
49996: PUSH
49997: LD_VAR 0 4
50001: PPUSH
50002: CALL_OW 250
50006: PPUSH
50007: LD_VAR 0 4
50011: PPUSH
50012: CALL_OW 251
50016: PPUSH
50017: LD_INT 6
50019: PPUSH
50020: CALL 49593 0 3
50024: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50025: LD_VAR 0 4
50029: PPUSH
50030: CALL_OW 247
50034: PUSH
50035: LD_INT 2
50037: EQUAL
50038: PUSH
50039: LD_VAR 0 7
50043: AND
50044: PUSH
50045: LD_VAR 0 4
50049: PPUSH
50050: CALL_OW 264
50054: PUSH
50055: LD_VAR 0 10
50059: IN
50060: NOT
50061: AND
50062: IFFALSE 50101
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50064: LD_VAR 0 4
50068: PPUSH
50069: LD_VAR 0 7
50073: PUSH
50074: LD_INT 1
50076: ARRAY
50077: PUSH
50078: LD_INT 1
50080: ARRAY
50081: PPUSH
50082: LD_VAR 0 7
50086: PUSH
50087: LD_INT 1
50089: ARRAY
50090: PUSH
50091: LD_INT 2
50093: ARRAY
50094: PPUSH
50095: CALL_OW 116
50099: GO 50390
// if path > tag then
50101: LD_VAR 0 2
50105: PUSH
50106: LD_VAR 0 9
50110: GREATER
50111: IFFALSE 50319
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50113: LD_ADDR_VAR 0 6
50117: PUSH
50118: LD_VAR 0 5
50122: PPUSH
50123: LD_INT 91
50125: PUSH
50126: LD_VAR 0 4
50130: PUSH
50131: LD_INT 8
50133: PUSH
50134: EMPTY
50135: LIST
50136: LIST
50137: LIST
50138: PPUSH
50139: CALL_OW 72
50143: ST_TO_ADDR
// if nearEnemy then
50144: LD_VAR 0 6
50148: IFFALSE 50217
// begin if GetWeapon ( i ) = ru_time_lapser then
50150: LD_VAR 0 4
50154: PPUSH
50155: CALL_OW 264
50159: PUSH
50160: LD_INT 49
50162: EQUAL
50163: IFFALSE 50191
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50165: LD_VAR 0 4
50169: PPUSH
50170: LD_VAR 0 6
50174: PPUSH
50175: LD_VAR 0 4
50179: PPUSH
50180: CALL_OW 74
50184: PPUSH
50185: CALL_OW 112
50189: GO 50215
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50191: LD_VAR 0 4
50195: PPUSH
50196: LD_VAR 0 6
50200: PPUSH
50201: LD_VAR 0 4
50205: PPUSH
50206: CALL_OW 74
50210: PPUSH
50211: CALL_OW 115
// end else
50215: GO 50317
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50217: LD_VAR 0 4
50221: PPUSH
50222: LD_VAR 0 2
50226: PUSH
50227: LD_VAR 0 9
50231: ARRAY
50232: PUSH
50233: LD_INT 1
50235: ARRAY
50236: PPUSH
50237: LD_VAR 0 2
50241: PUSH
50242: LD_VAR 0 9
50246: ARRAY
50247: PUSH
50248: LD_INT 2
50250: ARRAY
50251: PPUSH
50252: CALL_OW 297
50256: PUSH
50257: LD_INT 6
50259: GREATER
50260: IFFALSE 50303
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50262: LD_VAR 0 4
50266: PPUSH
50267: LD_VAR 0 2
50271: PUSH
50272: LD_VAR 0 9
50276: ARRAY
50277: PUSH
50278: LD_INT 1
50280: ARRAY
50281: PPUSH
50282: LD_VAR 0 2
50286: PUSH
50287: LD_VAR 0 9
50291: ARRAY
50292: PUSH
50293: LD_INT 2
50295: ARRAY
50296: PPUSH
50297: CALL_OW 114
50301: GO 50317
// SetTag ( i , tag ) ;
50303: LD_VAR 0 4
50307: PPUSH
50308: LD_VAR 0 9
50312: PPUSH
50313: CALL_OW 109
// end else
50317: GO 50390
// if enemy then
50319: LD_VAR 0 5
50323: IFFALSE 50390
// begin if GetWeapon ( i ) = ru_time_lapser then
50325: LD_VAR 0 4
50329: PPUSH
50330: CALL_OW 264
50334: PUSH
50335: LD_INT 49
50337: EQUAL
50338: IFFALSE 50366
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50340: LD_VAR 0 4
50344: PPUSH
50345: LD_VAR 0 5
50349: PPUSH
50350: LD_VAR 0 4
50354: PPUSH
50355: CALL_OW 74
50359: PPUSH
50360: CALL_OW 112
50364: GO 50390
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50366: LD_VAR 0 4
50370: PPUSH
50371: LD_VAR 0 5
50375: PPUSH
50376: LD_VAR 0 4
50380: PPUSH
50381: CALL_OW 74
50385: PPUSH
50386: CALL_OW 115
// end ; end ;
50390: GO 49970
50392: POP
50393: POP
// end ;
50394: LD_VAR 0 3
50398: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50399: LD_INT 0
50401: PPUSH
50402: PPUSH
50403: PPUSH
// if not unit or IsInUnit ( unit ) then
50404: LD_VAR 0 1
50408: NOT
50409: PUSH
50410: LD_VAR 0 1
50414: PPUSH
50415: CALL_OW 310
50419: OR
50420: IFFALSE 50424
// exit ;
50422: GO 50515
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50424: LD_ADDR_VAR 0 4
50428: PUSH
50429: LD_VAR 0 1
50433: PPUSH
50434: CALL_OW 250
50438: PPUSH
50439: LD_VAR 0 2
50443: PPUSH
50444: LD_INT 1
50446: PPUSH
50447: CALL_OW 272
50451: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50452: LD_ADDR_VAR 0 5
50456: PUSH
50457: LD_VAR 0 1
50461: PPUSH
50462: CALL_OW 251
50466: PPUSH
50467: LD_VAR 0 2
50471: PPUSH
50472: LD_INT 1
50474: PPUSH
50475: CALL_OW 273
50479: ST_TO_ADDR
// if ValidHex ( x , y ) then
50480: LD_VAR 0 4
50484: PPUSH
50485: LD_VAR 0 5
50489: PPUSH
50490: CALL_OW 488
50494: IFFALSE 50515
// ComTurnXY ( unit , x , y ) ;
50496: LD_VAR 0 1
50500: PPUSH
50501: LD_VAR 0 4
50505: PPUSH
50506: LD_VAR 0 5
50510: PPUSH
50511: CALL_OW 118
// end ;
50515: LD_VAR 0 3
50519: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50520: LD_INT 0
50522: PPUSH
50523: PPUSH
// result := false ;
50524: LD_ADDR_VAR 0 3
50528: PUSH
50529: LD_INT 0
50531: ST_TO_ADDR
// if not units then
50532: LD_VAR 0 2
50536: NOT
50537: IFFALSE 50541
// exit ;
50539: GO 50586
// for i in units do
50541: LD_ADDR_VAR 0 4
50545: PUSH
50546: LD_VAR 0 2
50550: PUSH
50551: FOR_IN
50552: IFFALSE 50584
// if See ( side , i ) then
50554: LD_VAR 0 1
50558: PPUSH
50559: LD_VAR 0 4
50563: PPUSH
50564: CALL_OW 292
50568: IFFALSE 50582
// begin result := true ;
50570: LD_ADDR_VAR 0 3
50574: PUSH
50575: LD_INT 1
50577: ST_TO_ADDR
// exit ;
50578: POP
50579: POP
50580: GO 50586
// end ;
50582: GO 50551
50584: POP
50585: POP
// end ;
50586: LD_VAR 0 3
50590: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50591: LD_INT 0
50593: PPUSH
50594: PPUSH
50595: PPUSH
50596: PPUSH
// if not unit or not points then
50597: LD_VAR 0 1
50601: NOT
50602: PUSH
50603: LD_VAR 0 2
50607: NOT
50608: OR
50609: IFFALSE 50613
// exit ;
50611: GO 50703
// dist := 99999 ;
50613: LD_ADDR_VAR 0 5
50617: PUSH
50618: LD_INT 99999
50620: ST_TO_ADDR
// for i in points do
50621: LD_ADDR_VAR 0 4
50625: PUSH
50626: LD_VAR 0 2
50630: PUSH
50631: FOR_IN
50632: IFFALSE 50701
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50634: LD_ADDR_VAR 0 6
50638: PUSH
50639: LD_VAR 0 1
50643: PPUSH
50644: LD_VAR 0 4
50648: PUSH
50649: LD_INT 1
50651: ARRAY
50652: PPUSH
50653: LD_VAR 0 4
50657: PUSH
50658: LD_INT 2
50660: ARRAY
50661: PPUSH
50662: CALL_OW 297
50666: ST_TO_ADDR
// if tmpDist < dist then
50667: LD_VAR 0 6
50671: PUSH
50672: LD_VAR 0 5
50676: LESS
50677: IFFALSE 50699
// begin result := i ;
50679: LD_ADDR_VAR 0 3
50683: PUSH
50684: LD_VAR 0 4
50688: ST_TO_ADDR
// dist := tmpDist ;
50689: LD_ADDR_VAR 0 5
50693: PUSH
50694: LD_VAR 0 6
50698: ST_TO_ADDR
// end ; end ;
50699: GO 50631
50701: POP
50702: POP
// end ;
50703: LD_VAR 0 3
50707: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50708: LD_INT 0
50710: PPUSH
// uc_side := side ;
50711: LD_ADDR_OWVAR 20
50715: PUSH
50716: LD_VAR 0 1
50720: ST_TO_ADDR
// uc_nation := 3 ;
50721: LD_ADDR_OWVAR 21
50725: PUSH
50726: LD_INT 3
50728: ST_TO_ADDR
// vc_chassis := 25 ;
50729: LD_ADDR_OWVAR 37
50733: PUSH
50734: LD_INT 25
50736: ST_TO_ADDR
// vc_engine := engine_siberite ;
50737: LD_ADDR_OWVAR 39
50741: PUSH
50742: LD_INT 3
50744: ST_TO_ADDR
// vc_control := control_computer ;
50745: LD_ADDR_OWVAR 38
50749: PUSH
50750: LD_INT 3
50752: ST_TO_ADDR
// vc_weapon := 59 ;
50753: LD_ADDR_OWVAR 40
50757: PUSH
50758: LD_INT 59
50760: ST_TO_ADDR
// result := CreateVehicle ;
50761: LD_ADDR_VAR 0 5
50765: PUSH
50766: CALL_OW 45
50770: ST_TO_ADDR
// SetDir ( result , d ) ;
50771: LD_VAR 0 5
50775: PPUSH
50776: LD_VAR 0 4
50780: PPUSH
50781: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
50785: LD_VAR 0 5
50789: PPUSH
50790: LD_VAR 0 2
50794: PPUSH
50795: LD_VAR 0 3
50799: PPUSH
50800: LD_INT 0
50802: PPUSH
50803: CALL_OW 48
// end ;
50807: LD_VAR 0 5
50811: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50812: LD_INT 0
50814: PPUSH
50815: PPUSH
50816: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50817: LD_ADDR_VAR 0 2
50821: PUSH
50822: LD_INT 0
50824: PUSH
50825: LD_INT 0
50827: PUSH
50828: LD_INT 0
50830: PUSH
50831: LD_INT 0
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50840: LD_VAR 0 1
50844: NOT
50845: PUSH
50846: LD_VAR 0 1
50850: PPUSH
50851: CALL_OW 264
50855: PUSH
50856: LD_INT 12
50858: PUSH
50859: LD_INT 51
50861: PUSH
50862: LD_INT 32
50864: PUSH
50865: LD_INT 89
50867: PUSH
50868: EMPTY
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: IN
50874: NOT
50875: OR
50876: IFFALSE 50880
// exit ;
50878: GO 50978
// for i := 1 to 3 do
50880: LD_ADDR_VAR 0 3
50884: PUSH
50885: DOUBLE
50886: LD_INT 1
50888: DEC
50889: ST_TO_ADDR
50890: LD_INT 3
50892: PUSH
50893: FOR_TO
50894: IFFALSE 50976
// begin tmp := GetCargo ( cargo , i ) ;
50896: LD_ADDR_VAR 0 4
50900: PUSH
50901: LD_VAR 0 1
50905: PPUSH
50906: LD_VAR 0 3
50910: PPUSH
50911: CALL_OW 289
50915: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50916: LD_ADDR_VAR 0 2
50920: PUSH
50921: LD_VAR 0 2
50925: PPUSH
50926: LD_VAR 0 3
50930: PPUSH
50931: LD_VAR 0 4
50935: PPUSH
50936: CALL_OW 1
50940: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
50941: LD_ADDR_VAR 0 2
50945: PUSH
50946: LD_VAR 0 2
50950: PPUSH
50951: LD_INT 4
50953: PPUSH
50954: LD_VAR 0 2
50958: PUSH
50959: LD_INT 4
50961: ARRAY
50962: PUSH
50963: LD_VAR 0 4
50967: PLUS
50968: PPUSH
50969: CALL_OW 1
50973: ST_TO_ADDR
// end ;
50974: GO 50893
50976: POP
50977: POP
// end ;
50978: LD_VAR 0 2
50982: RET
// export function Length ( array ) ; begin
50983: LD_INT 0
50985: PPUSH
// result := array + 0 ;
50986: LD_ADDR_VAR 0 2
50990: PUSH
50991: LD_VAR 0 1
50995: PUSH
50996: LD_INT 0
50998: PLUS
50999: ST_TO_ADDR
// end ;
51000: LD_VAR 0 2
51004: RET
// export function PrepareArray ( array ) ; begin
51005: LD_INT 0
51007: PPUSH
// result := array diff 0 ;
51008: LD_ADDR_VAR 0 2
51012: PUSH
51013: LD_VAR 0 1
51017: PUSH
51018: LD_INT 0
51020: DIFF
51021: ST_TO_ADDR
// if not result [ 1 ] then
51022: LD_VAR 0 2
51026: PUSH
51027: LD_INT 1
51029: ARRAY
51030: NOT
51031: IFFALSE 51051
// result := Delete ( result , 1 ) ;
51033: LD_ADDR_VAR 0 2
51037: PUSH
51038: LD_VAR 0 2
51042: PPUSH
51043: LD_INT 1
51045: PPUSH
51046: CALL_OW 3
51050: ST_TO_ADDR
// end ;
51051: LD_VAR 0 2
51055: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
51056: LD_INT 0
51058: PPUSH
51059: PPUSH
51060: PPUSH
51061: PPUSH
// sibRocketRange := 25 ;
51062: LD_ADDR_VAR 0 6
51066: PUSH
51067: LD_INT 25
51069: ST_TO_ADDR
// result := false ;
51070: LD_ADDR_VAR 0 4
51074: PUSH
51075: LD_INT 0
51077: ST_TO_ADDR
// for i := 0 to 5 do
51078: LD_ADDR_VAR 0 5
51082: PUSH
51083: DOUBLE
51084: LD_INT 0
51086: DEC
51087: ST_TO_ADDR
51088: LD_INT 5
51090: PUSH
51091: FOR_TO
51092: IFFALSE 51159
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
51094: LD_VAR 0 1
51098: PPUSH
51099: LD_VAR 0 5
51103: PPUSH
51104: LD_VAR 0 6
51108: PPUSH
51109: CALL_OW 272
51113: PPUSH
51114: LD_VAR 0 2
51118: PPUSH
51119: LD_VAR 0 5
51123: PPUSH
51124: LD_VAR 0 6
51128: PPUSH
51129: CALL_OW 273
51133: PPUSH
51134: LD_VAR 0 3
51138: PPUSH
51139: CALL_OW 309
51143: IFFALSE 51157
// begin result := true ;
51145: LD_ADDR_VAR 0 4
51149: PUSH
51150: LD_INT 1
51152: ST_TO_ADDR
// exit ;
51153: POP
51154: POP
51155: GO 51161
// end ;
51157: GO 51091
51159: POP
51160: POP
// end ;
51161: LD_VAR 0 4
51165: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51166: LD_INT 0
51168: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51169: LD_VAR 0 1
51173: PPUSH
51174: LD_VAR 0 2
51178: PPUSH
51179: LD_INT 0
51181: PPUSH
51182: LD_INT 0
51184: PPUSH
51185: LD_INT 1
51187: PPUSH
51188: LD_INT 0
51190: PPUSH
51191: CALL_OW 587
// end ;
51195: LD_VAR 0 3
51199: RET
// export function CenterOnNow ( unit ) ; begin
51200: LD_INT 0
51202: PPUSH
// result := IsInUnit ( unit ) ;
51203: LD_ADDR_VAR 0 2
51207: PUSH
51208: LD_VAR 0 1
51212: PPUSH
51213: CALL_OW 310
51217: ST_TO_ADDR
// if not result then
51218: LD_VAR 0 2
51222: NOT
51223: IFFALSE 51235
// result := unit ;
51225: LD_ADDR_VAR 0 2
51229: PUSH
51230: LD_VAR 0 1
51234: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
51235: LD_VAR 0 1
51239: PPUSH
51240: CALL_OW 87
// end ; end_of_file
51244: LD_VAR 0 2
51248: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
51249: LD_INT 0
51251: PPUSH
51252: PPUSH
// skirmish := false ;
51253: LD_ADDR_EXP 41
51257: PUSH
51258: LD_INT 0
51260: ST_TO_ADDR
// debug_mc := false ;
51261: LD_ADDR_EXP 42
51265: PUSH
51266: LD_INT 0
51268: ST_TO_ADDR
// mc_bases := [ ] ;
51269: LD_ADDR_EXP 43
51273: PUSH
51274: EMPTY
51275: ST_TO_ADDR
// mc_sides := [ ] ;
51276: LD_ADDR_EXP 69
51280: PUSH
51281: EMPTY
51282: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51283: LD_ADDR_EXP 44
51287: PUSH
51288: EMPTY
51289: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51290: LD_ADDR_EXP 45
51294: PUSH
51295: EMPTY
51296: ST_TO_ADDR
// mc_need_heal := [ ] ;
51297: LD_ADDR_EXP 46
51301: PUSH
51302: EMPTY
51303: ST_TO_ADDR
// mc_healers := [ ] ;
51304: LD_ADDR_EXP 47
51308: PUSH
51309: EMPTY
51310: ST_TO_ADDR
// mc_build_list := [ ] ;
51311: LD_ADDR_EXP 48
51315: PUSH
51316: EMPTY
51317: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51318: LD_ADDR_EXP 75
51322: PUSH
51323: EMPTY
51324: ST_TO_ADDR
// mc_builders := [ ] ;
51325: LD_ADDR_EXP 49
51329: PUSH
51330: EMPTY
51331: ST_TO_ADDR
// mc_construct_list := [ ] ;
51332: LD_ADDR_EXP 50
51336: PUSH
51337: EMPTY
51338: ST_TO_ADDR
// mc_turret_list := [ ] ;
51339: LD_ADDR_EXP 51
51343: PUSH
51344: EMPTY
51345: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51346: LD_ADDR_EXP 52
51350: PUSH
51351: EMPTY
51352: ST_TO_ADDR
// mc_miners := [ ] ;
51353: LD_ADDR_EXP 57
51357: PUSH
51358: EMPTY
51359: ST_TO_ADDR
// mc_mines := [ ] ;
51360: LD_ADDR_EXP 56
51364: PUSH
51365: EMPTY
51366: ST_TO_ADDR
// mc_minefields := [ ] ;
51367: LD_ADDR_EXP 58
51371: PUSH
51372: EMPTY
51373: ST_TO_ADDR
// mc_crates := [ ] ;
51374: LD_ADDR_EXP 59
51378: PUSH
51379: EMPTY
51380: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51381: LD_ADDR_EXP 60
51385: PUSH
51386: EMPTY
51387: ST_TO_ADDR
// mc_crates_area := [ ] ;
51388: LD_ADDR_EXP 61
51392: PUSH
51393: EMPTY
51394: ST_TO_ADDR
// mc_vehicles := [ ] ;
51395: LD_ADDR_EXP 62
51399: PUSH
51400: EMPTY
51401: ST_TO_ADDR
// mc_attack := [ ] ;
51402: LD_ADDR_EXP 63
51406: PUSH
51407: EMPTY
51408: ST_TO_ADDR
// mc_produce := [ ] ;
51409: LD_ADDR_EXP 64
51413: PUSH
51414: EMPTY
51415: ST_TO_ADDR
// mc_defender := [ ] ;
51416: LD_ADDR_EXP 65
51420: PUSH
51421: EMPTY
51422: ST_TO_ADDR
// mc_parking := [ ] ;
51423: LD_ADDR_EXP 67
51427: PUSH
51428: EMPTY
51429: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51430: LD_ADDR_EXP 53
51434: PUSH
51435: EMPTY
51436: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51437: LD_ADDR_EXP 55
51441: PUSH
51442: EMPTY
51443: ST_TO_ADDR
// mc_scan := [ ] ;
51444: LD_ADDR_EXP 66
51448: PUSH
51449: EMPTY
51450: ST_TO_ADDR
// mc_scan_area := [ ] ;
51451: LD_ADDR_EXP 68
51455: PUSH
51456: EMPTY
51457: ST_TO_ADDR
// mc_tech := [ ] ;
51458: LD_ADDR_EXP 70
51462: PUSH
51463: EMPTY
51464: ST_TO_ADDR
// mc_class := [ ] ;
51465: LD_ADDR_EXP 84
51469: PUSH
51470: EMPTY
51471: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51472: LD_ADDR_EXP 85
51476: PUSH
51477: EMPTY
51478: ST_TO_ADDR
// mc_is_defending := [ ] ;
51479: LD_ADDR_EXP 86
51483: PUSH
51484: EMPTY
51485: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51486: LD_ADDR_EXP 77
51490: PUSH
51491: EMPTY
51492: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
51493: LD_ADDR_EXP 87
51497: PUSH
51498: LD_INT 0
51500: ST_TO_ADDR
// end ;
51501: LD_VAR 0 1
51505: RET
// export function MC_Kill ( base ) ; begin
51506: LD_INT 0
51508: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51509: LD_ADDR_EXP 43
51513: PUSH
51514: LD_EXP 43
51518: PPUSH
51519: LD_VAR 0 1
51523: PPUSH
51524: EMPTY
51525: PPUSH
51526: CALL_OW 1
51530: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51531: LD_ADDR_EXP 44
51535: PUSH
51536: LD_EXP 44
51540: PPUSH
51541: LD_VAR 0 1
51545: PPUSH
51546: EMPTY
51547: PPUSH
51548: CALL_OW 1
51552: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51553: LD_ADDR_EXP 45
51557: PUSH
51558: LD_EXP 45
51562: PPUSH
51563: LD_VAR 0 1
51567: PPUSH
51568: EMPTY
51569: PPUSH
51570: CALL_OW 1
51574: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51575: LD_ADDR_EXP 46
51579: PUSH
51580: LD_EXP 46
51584: PPUSH
51585: LD_VAR 0 1
51589: PPUSH
51590: EMPTY
51591: PPUSH
51592: CALL_OW 1
51596: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51597: LD_ADDR_EXP 47
51601: PUSH
51602: LD_EXP 47
51606: PPUSH
51607: LD_VAR 0 1
51611: PPUSH
51612: EMPTY
51613: PPUSH
51614: CALL_OW 1
51618: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51619: LD_ADDR_EXP 48
51623: PUSH
51624: LD_EXP 48
51628: PPUSH
51629: LD_VAR 0 1
51633: PPUSH
51634: EMPTY
51635: PPUSH
51636: CALL_OW 1
51640: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51641: LD_ADDR_EXP 49
51645: PUSH
51646: LD_EXP 49
51650: PPUSH
51651: LD_VAR 0 1
51655: PPUSH
51656: EMPTY
51657: PPUSH
51658: CALL_OW 1
51662: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51663: LD_ADDR_EXP 50
51667: PUSH
51668: LD_EXP 50
51672: PPUSH
51673: LD_VAR 0 1
51677: PPUSH
51678: EMPTY
51679: PPUSH
51680: CALL_OW 1
51684: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51685: LD_ADDR_EXP 51
51689: PUSH
51690: LD_EXP 51
51694: PPUSH
51695: LD_VAR 0 1
51699: PPUSH
51700: EMPTY
51701: PPUSH
51702: CALL_OW 1
51706: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51707: LD_ADDR_EXP 52
51711: PUSH
51712: LD_EXP 52
51716: PPUSH
51717: LD_VAR 0 1
51721: PPUSH
51722: EMPTY
51723: PPUSH
51724: CALL_OW 1
51728: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51729: LD_ADDR_EXP 53
51733: PUSH
51734: LD_EXP 53
51738: PPUSH
51739: LD_VAR 0 1
51743: PPUSH
51744: EMPTY
51745: PPUSH
51746: CALL_OW 1
51750: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51751: LD_ADDR_EXP 54
51755: PUSH
51756: LD_EXP 54
51760: PPUSH
51761: LD_VAR 0 1
51765: PPUSH
51766: LD_INT 0
51768: PPUSH
51769: CALL_OW 1
51773: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51774: LD_ADDR_EXP 55
51778: PUSH
51779: LD_EXP 55
51783: PPUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: EMPTY
51790: PPUSH
51791: CALL_OW 1
51795: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51796: LD_ADDR_EXP 56
51800: PUSH
51801: LD_EXP 56
51805: PPUSH
51806: LD_VAR 0 1
51810: PPUSH
51811: EMPTY
51812: PPUSH
51813: CALL_OW 1
51817: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51818: LD_ADDR_EXP 57
51822: PUSH
51823: LD_EXP 57
51827: PPUSH
51828: LD_VAR 0 1
51832: PPUSH
51833: EMPTY
51834: PPUSH
51835: CALL_OW 1
51839: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51840: LD_ADDR_EXP 58
51844: PUSH
51845: LD_EXP 58
51849: PPUSH
51850: LD_VAR 0 1
51854: PPUSH
51855: EMPTY
51856: PPUSH
51857: CALL_OW 1
51861: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51862: LD_ADDR_EXP 59
51866: PUSH
51867: LD_EXP 59
51871: PPUSH
51872: LD_VAR 0 1
51876: PPUSH
51877: EMPTY
51878: PPUSH
51879: CALL_OW 1
51883: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51884: LD_ADDR_EXP 60
51888: PUSH
51889: LD_EXP 60
51893: PPUSH
51894: LD_VAR 0 1
51898: PPUSH
51899: EMPTY
51900: PPUSH
51901: CALL_OW 1
51905: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51906: LD_ADDR_EXP 61
51910: PUSH
51911: LD_EXP 61
51915: PPUSH
51916: LD_VAR 0 1
51920: PPUSH
51921: EMPTY
51922: PPUSH
51923: CALL_OW 1
51927: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51928: LD_ADDR_EXP 62
51932: PUSH
51933: LD_EXP 62
51937: PPUSH
51938: LD_VAR 0 1
51942: PPUSH
51943: EMPTY
51944: PPUSH
51945: CALL_OW 1
51949: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51950: LD_ADDR_EXP 63
51954: PUSH
51955: LD_EXP 63
51959: PPUSH
51960: LD_VAR 0 1
51964: PPUSH
51965: EMPTY
51966: PPUSH
51967: CALL_OW 1
51971: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51972: LD_ADDR_EXP 64
51976: PUSH
51977: LD_EXP 64
51981: PPUSH
51982: LD_VAR 0 1
51986: PPUSH
51987: EMPTY
51988: PPUSH
51989: CALL_OW 1
51993: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51994: LD_ADDR_EXP 65
51998: PUSH
51999: LD_EXP 65
52003: PPUSH
52004: LD_VAR 0 1
52008: PPUSH
52009: EMPTY
52010: PPUSH
52011: CALL_OW 1
52015: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52016: LD_ADDR_EXP 66
52020: PUSH
52021: LD_EXP 66
52025: PPUSH
52026: LD_VAR 0 1
52030: PPUSH
52031: EMPTY
52032: PPUSH
52033: CALL_OW 1
52037: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52038: LD_ADDR_EXP 67
52042: PUSH
52043: LD_EXP 67
52047: PPUSH
52048: LD_VAR 0 1
52052: PPUSH
52053: EMPTY
52054: PPUSH
52055: CALL_OW 1
52059: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52060: LD_ADDR_EXP 68
52064: PUSH
52065: LD_EXP 68
52069: PPUSH
52070: LD_VAR 0 1
52074: PPUSH
52075: EMPTY
52076: PPUSH
52077: CALL_OW 1
52081: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52082: LD_ADDR_EXP 70
52086: PUSH
52087: LD_EXP 70
52091: PPUSH
52092: LD_VAR 0 1
52096: PPUSH
52097: EMPTY
52098: PPUSH
52099: CALL_OW 1
52103: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52104: LD_ADDR_EXP 72
52108: PUSH
52109: LD_EXP 72
52113: PPUSH
52114: LD_VAR 0 1
52118: PPUSH
52119: EMPTY
52120: PPUSH
52121: CALL_OW 1
52125: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52126: LD_ADDR_EXP 73
52130: PUSH
52131: LD_EXP 73
52135: PPUSH
52136: LD_VAR 0 1
52140: PPUSH
52141: EMPTY
52142: PPUSH
52143: CALL_OW 1
52147: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52148: LD_ADDR_EXP 74
52152: PUSH
52153: LD_EXP 74
52157: PPUSH
52158: LD_VAR 0 1
52162: PPUSH
52163: EMPTY
52164: PPUSH
52165: CALL_OW 1
52169: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52170: LD_ADDR_EXP 75
52174: PUSH
52175: LD_EXP 75
52179: PPUSH
52180: LD_VAR 0 1
52184: PPUSH
52185: EMPTY
52186: PPUSH
52187: CALL_OW 1
52191: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52192: LD_ADDR_EXP 76
52196: PUSH
52197: LD_EXP 76
52201: PPUSH
52202: LD_VAR 0 1
52206: PPUSH
52207: EMPTY
52208: PPUSH
52209: CALL_OW 1
52213: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52214: LD_ADDR_EXP 77
52218: PUSH
52219: LD_EXP 77
52223: PPUSH
52224: LD_VAR 0 1
52228: PPUSH
52229: EMPTY
52230: PPUSH
52231: CALL_OW 1
52235: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52236: LD_ADDR_EXP 78
52240: PUSH
52241: LD_EXP 78
52245: PPUSH
52246: LD_VAR 0 1
52250: PPUSH
52251: EMPTY
52252: PPUSH
52253: CALL_OW 1
52257: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52258: LD_ADDR_EXP 79
52262: PUSH
52263: LD_EXP 79
52267: PPUSH
52268: LD_VAR 0 1
52272: PPUSH
52273: EMPTY
52274: PPUSH
52275: CALL_OW 1
52279: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52280: LD_ADDR_EXP 80
52284: PUSH
52285: LD_EXP 80
52289: PPUSH
52290: LD_VAR 0 1
52294: PPUSH
52295: EMPTY
52296: PPUSH
52297: CALL_OW 1
52301: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52302: LD_ADDR_EXP 81
52306: PUSH
52307: LD_EXP 81
52311: PPUSH
52312: LD_VAR 0 1
52316: PPUSH
52317: EMPTY
52318: PPUSH
52319: CALL_OW 1
52323: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52324: LD_ADDR_EXP 82
52328: PUSH
52329: LD_EXP 82
52333: PPUSH
52334: LD_VAR 0 1
52338: PPUSH
52339: EMPTY
52340: PPUSH
52341: CALL_OW 1
52345: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52346: LD_ADDR_EXP 83
52350: PUSH
52351: LD_EXP 83
52355: PPUSH
52356: LD_VAR 0 1
52360: PPUSH
52361: EMPTY
52362: PPUSH
52363: CALL_OW 1
52367: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52368: LD_ADDR_EXP 84
52372: PUSH
52373: LD_EXP 84
52377: PPUSH
52378: LD_VAR 0 1
52382: PPUSH
52383: EMPTY
52384: PPUSH
52385: CALL_OW 1
52389: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52390: LD_ADDR_EXP 85
52394: PUSH
52395: LD_EXP 85
52399: PPUSH
52400: LD_VAR 0 1
52404: PPUSH
52405: LD_INT 0
52407: PPUSH
52408: CALL_OW 1
52412: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52413: LD_ADDR_EXP 86
52417: PUSH
52418: LD_EXP 86
52422: PPUSH
52423: LD_VAR 0 1
52427: PPUSH
52428: LD_INT 0
52430: PPUSH
52431: CALL_OW 1
52435: ST_TO_ADDR
// end ;
52436: LD_VAR 0 2
52440: RET
// export function MC_Add ( side , units ) ; var base ; begin
52441: LD_INT 0
52443: PPUSH
52444: PPUSH
// base := mc_bases + 1 ;
52445: LD_ADDR_VAR 0 4
52449: PUSH
52450: LD_EXP 43
52454: PUSH
52455: LD_INT 1
52457: PLUS
52458: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52459: LD_ADDR_EXP 69
52463: PUSH
52464: LD_EXP 69
52468: PPUSH
52469: LD_VAR 0 4
52473: PPUSH
52474: LD_VAR 0 1
52478: PPUSH
52479: CALL_OW 1
52483: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52484: LD_ADDR_EXP 43
52488: PUSH
52489: LD_EXP 43
52493: PPUSH
52494: LD_VAR 0 4
52498: PPUSH
52499: LD_VAR 0 2
52503: PPUSH
52504: CALL_OW 1
52508: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52509: LD_ADDR_EXP 44
52513: PUSH
52514: LD_EXP 44
52518: PPUSH
52519: LD_VAR 0 4
52523: PPUSH
52524: EMPTY
52525: PPUSH
52526: CALL_OW 1
52530: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52531: LD_ADDR_EXP 45
52535: PUSH
52536: LD_EXP 45
52540: PPUSH
52541: LD_VAR 0 4
52545: PPUSH
52546: EMPTY
52547: PPUSH
52548: CALL_OW 1
52552: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52553: LD_ADDR_EXP 46
52557: PUSH
52558: LD_EXP 46
52562: PPUSH
52563: LD_VAR 0 4
52567: PPUSH
52568: EMPTY
52569: PPUSH
52570: CALL_OW 1
52574: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52575: LD_ADDR_EXP 47
52579: PUSH
52580: LD_EXP 47
52584: PPUSH
52585: LD_VAR 0 4
52589: PPUSH
52590: EMPTY
52591: PPUSH
52592: CALL_OW 1
52596: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52597: LD_ADDR_EXP 48
52601: PUSH
52602: LD_EXP 48
52606: PPUSH
52607: LD_VAR 0 4
52611: PPUSH
52612: EMPTY
52613: PPUSH
52614: CALL_OW 1
52618: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52619: LD_ADDR_EXP 49
52623: PUSH
52624: LD_EXP 49
52628: PPUSH
52629: LD_VAR 0 4
52633: PPUSH
52634: EMPTY
52635: PPUSH
52636: CALL_OW 1
52640: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52641: LD_ADDR_EXP 50
52645: PUSH
52646: LD_EXP 50
52650: PPUSH
52651: LD_VAR 0 4
52655: PPUSH
52656: EMPTY
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52663: LD_ADDR_EXP 51
52667: PUSH
52668: LD_EXP 51
52672: PPUSH
52673: LD_VAR 0 4
52677: PPUSH
52678: EMPTY
52679: PPUSH
52680: CALL_OW 1
52684: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52685: LD_ADDR_EXP 52
52689: PUSH
52690: LD_EXP 52
52694: PPUSH
52695: LD_VAR 0 4
52699: PPUSH
52700: EMPTY
52701: PPUSH
52702: CALL_OW 1
52706: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52707: LD_ADDR_EXP 53
52711: PUSH
52712: LD_EXP 53
52716: PPUSH
52717: LD_VAR 0 4
52721: PPUSH
52722: EMPTY
52723: PPUSH
52724: CALL_OW 1
52728: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52729: LD_ADDR_EXP 54
52733: PUSH
52734: LD_EXP 54
52738: PPUSH
52739: LD_VAR 0 4
52743: PPUSH
52744: LD_INT 0
52746: PPUSH
52747: CALL_OW 1
52751: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52752: LD_ADDR_EXP 55
52756: PUSH
52757: LD_EXP 55
52761: PPUSH
52762: LD_VAR 0 4
52766: PPUSH
52767: EMPTY
52768: PPUSH
52769: CALL_OW 1
52773: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52774: LD_ADDR_EXP 56
52778: PUSH
52779: LD_EXP 56
52783: PPUSH
52784: LD_VAR 0 4
52788: PPUSH
52789: EMPTY
52790: PPUSH
52791: CALL_OW 1
52795: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52796: LD_ADDR_EXP 57
52800: PUSH
52801: LD_EXP 57
52805: PPUSH
52806: LD_VAR 0 4
52810: PPUSH
52811: EMPTY
52812: PPUSH
52813: CALL_OW 1
52817: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52818: LD_ADDR_EXP 58
52822: PUSH
52823: LD_EXP 58
52827: PPUSH
52828: LD_VAR 0 4
52832: PPUSH
52833: EMPTY
52834: PPUSH
52835: CALL_OW 1
52839: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52840: LD_ADDR_EXP 59
52844: PUSH
52845: LD_EXP 59
52849: PPUSH
52850: LD_VAR 0 4
52854: PPUSH
52855: EMPTY
52856: PPUSH
52857: CALL_OW 1
52861: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52862: LD_ADDR_EXP 60
52866: PUSH
52867: LD_EXP 60
52871: PPUSH
52872: LD_VAR 0 4
52876: PPUSH
52877: EMPTY
52878: PPUSH
52879: CALL_OW 1
52883: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52884: LD_ADDR_EXP 61
52888: PUSH
52889: LD_EXP 61
52893: PPUSH
52894: LD_VAR 0 4
52898: PPUSH
52899: EMPTY
52900: PPUSH
52901: CALL_OW 1
52905: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52906: LD_ADDR_EXP 62
52910: PUSH
52911: LD_EXP 62
52915: PPUSH
52916: LD_VAR 0 4
52920: PPUSH
52921: EMPTY
52922: PPUSH
52923: CALL_OW 1
52927: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52928: LD_ADDR_EXP 63
52932: PUSH
52933: LD_EXP 63
52937: PPUSH
52938: LD_VAR 0 4
52942: PPUSH
52943: EMPTY
52944: PPUSH
52945: CALL_OW 1
52949: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52950: LD_ADDR_EXP 64
52954: PUSH
52955: LD_EXP 64
52959: PPUSH
52960: LD_VAR 0 4
52964: PPUSH
52965: EMPTY
52966: PPUSH
52967: CALL_OW 1
52971: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52972: LD_ADDR_EXP 65
52976: PUSH
52977: LD_EXP 65
52981: PPUSH
52982: LD_VAR 0 4
52986: PPUSH
52987: EMPTY
52988: PPUSH
52989: CALL_OW 1
52993: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52994: LD_ADDR_EXP 66
52998: PUSH
52999: LD_EXP 66
53003: PPUSH
53004: LD_VAR 0 4
53008: PPUSH
53009: EMPTY
53010: PPUSH
53011: CALL_OW 1
53015: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53016: LD_ADDR_EXP 67
53020: PUSH
53021: LD_EXP 67
53025: PPUSH
53026: LD_VAR 0 4
53030: PPUSH
53031: EMPTY
53032: PPUSH
53033: CALL_OW 1
53037: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53038: LD_ADDR_EXP 68
53042: PUSH
53043: LD_EXP 68
53047: PPUSH
53048: LD_VAR 0 4
53052: PPUSH
53053: EMPTY
53054: PPUSH
53055: CALL_OW 1
53059: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53060: LD_ADDR_EXP 70
53064: PUSH
53065: LD_EXP 70
53069: PPUSH
53070: LD_VAR 0 4
53074: PPUSH
53075: EMPTY
53076: PPUSH
53077: CALL_OW 1
53081: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53082: LD_ADDR_EXP 72
53086: PUSH
53087: LD_EXP 72
53091: PPUSH
53092: LD_VAR 0 4
53096: PPUSH
53097: EMPTY
53098: PPUSH
53099: CALL_OW 1
53103: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53104: LD_ADDR_EXP 73
53108: PUSH
53109: LD_EXP 73
53113: PPUSH
53114: LD_VAR 0 4
53118: PPUSH
53119: EMPTY
53120: PPUSH
53121: CALL_OW 1
53125: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53126: LD_ADDR_EXP 74
53130: PUSH
53131: LD_EXP 74
53135: PPUSH
53136: LD_VAR 0 4
53140: PPUSH
53141: EMPTY
53142: PPUSH
53143: CALL_OW 1
53147: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53148: LD_ADDR_EXP 75
53152: PUSH
53153: LD_EXP 75
53157: PPUSH
53158: LD_VAR 0 4
53162: PPUSH
53163: EMPTY
53164: PPUSH
53165: CALL_OW 1
53169: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53170: LD_ADDR_EXP 76
53174: PUSH
53175: LD_EXP 76
53179: PPUSH
53180: LD_VAR 0 4
53184: PPUSH
53185: EMPTY
53186: PPUSH
53187: CALL_OW 1
53191: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53192: LD_ADDR_EXP 77
53196: PUSH
53197: LD_EXP 77
53201: PPUSH
53202: LD_VAR 0 4
53206: PPUSH
53207: EMPTY
53208: PPUSH
53209: CALL_OW 1
53213: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53214: LD_ADDR_EXP 78
53218: PUSH
53219: LD_EXP 78
53223: PPUSH
53224: LD_VAR 0 4
53228: PPUSH
53229: EMPTY
53230: PPUSH
53231: CALL_OW 1
53235: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53236: LD_ADDR_EXP 79
53240: PUSH
53241: LD_EXP 79
53245: PPUSH
53246: LD_VAR 0 4
53250: PPUSH
53251: EMPTY
53252: PPUSH
53253: CALL_OW 1
53257: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53258: LD_ADDR_EXP 80
53262: PUSH
53263: LD_EXP 80
53267: PPUSH
53268: LD_VAR 0 4
53272: PPUSH
53273: EMPTY
53274: PPUSH
53275: CALL_OW 1
53279: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53280: LD_ADDR_EXP 81
53284: PUSH
53285: LD_EXP 81
53289: PPUSH
53290: LD_VAR 0 4
53294: PPUSH
53295: EMPTY
53296: PPUSH
53297: CALL_OW 1
53301: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53302: LD_ADDR_EXP 82
53306: PUSH
53307: LD_EXP 82
53311: PPUSH
53312: LD_VAR 0 4
53316: PPUSH
53317: EMPTY
53318: PPUSH
53319: CALL_OW 1
53323: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53324: LD_ADDR_EXP 83
53328: PUSH
53329: LD_EXP 83
53333: PPUSH
53334: LD_VAR 0 4
53338: PPUSH
53339: EMPTY
53340: PPUSH
53341: CALL_OW 1
53345: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53346: LD_ADDR_EXP 84
53350: PUSH
53351: LD_EXP 84
53355: PPUSH
53356: LD_VAR 0 4
53360: PPUSH
53361: EMPTY
53362: PPUSH
53363: CALL_OW 1
53367: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53368: LD_ADDR_EXP 85
53372: PUSH
53373: LD_EXP 85
53377: PPUSH
53378: LD_VAR 0 4
53382: PPUSH
53383: LD_INT 0
53385: PPUSH
53386: CALL_OW 1
53390: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53391: LD_ADDR_EXP 86
53395: PUSH
53396: LD_EXP 86
53400: PPUSH
53401: LD_VAR 0 4
53405: PPUSH
53406: LD_INT 0
53408: PPUSH
53409: CALL_OW 1
53413: ST_TO_ADDR
// result := base ;
53414: LD_ADDR_VAR 0 3
53418: PUSH
53419: LD_VAR 0 4
53423: ST_TO_ADDR
// end ;
53424: LD_VAR 0 3
53428: RET
// export function MC_Start ( ) ; var i ; begin
53429: LD_INT 0
53431: PPUSH
53432: PPUSH
// for i = 1 to mc_bases do
53433: LD_ADDR_VAR 0 2
53437: PUSH
53438: DOUBLE
53439: LD_INT 1
53441: DEC
53442: ST_TO_ADDR
53443: LD_EXP 43
53447: PUSH
53448: FOR_TO
53449: IFFALSE 54549
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53451: LD_ADDR_EXP 43
53455: PUSH
53456: LD_EXP 43
53460: PPUSH
53461: LD_VAR 0 2
53465: PPUSH
53466: LD_EXP 43
53470: PUSH
53471: LD_VAR 0 2
53475: ARRAY
53476: PUSH
53477: LD_INT 0
53479: DIFF
53480: PPUSH
53481: CALL_OW 1
53485: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53486: LD_ADDR_EXP 44
53490: PUSH
53491: LD_EXP 44
53495: PPUSH
53496: LD_VAR 0 2
53500: PPUSH
53501: EMPTY
53502: PPUSH
53503: CALL_OW 1
53507: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53508: LD_ADDR_EXP 45
53512: PUSH
53513: LD_EXP 45
53517: PPUSH
53518: LD_VAR 0 2
53522: PPUSH
53523: EMPTY
53524: PPUSH
53525: CALL_OW 1
53529: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53530: LD_ADDR_EXP 46
53534: PUSH
53535: LD_EXP 46
53539: PPUSH
53540: LD_VAR 0 2
53544: PPUSH
53545: EMPTY
53546: PPUSH
53547: CALL_OW 1
53551: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53552: LD_ADDR_EXP 47
53556: PUSH
53557: LD_EXP 47
53561: PPUSH
53562: LD_VAR 0 2
53566: PPUSH
53567: EMPTY
53568: PUSH
53569: EMPTY
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: PPUSH
53575: CALL_OW 1
53579: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53580: LD_ADDR_EXP 48
53584: PUSH
53585: LD_EXP 48
53589: PPUSH
53590: LD_VAR 0 2
53594: PPUSH
53595: EMPTY
53596: PPUSH
53597: CALL_OW 1
53601: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53602: LD_ADDR_EXP 75
53606: PUSH
53607: LD_EXP 75
53611: PPUSH
53612: LD_VAR 0 2
53616: PPUSH
53617: EMPTY
53618: PPUSH
53619: CALL_OW 1
53623: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53624: LD_ADDR_EXP 49
53628: PUSH
53629: LD_EXP 49
53633: PPUSH
53634: LD_VAR 0 2
53638: PPUSH
53639: EMPTY
53640: PPUSH
53641: CALL_OW 1
53645: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53646: LD_ADDR_EXP 50
53650: PUSH
53651: LD_EXP 50
53655: PPUSH
53656: LD_VAR 0 2
53660: PPUSH
53661: EMPTY
53662: PPUSH
53663: CALL_OW 1
53667: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53668: LD_ADDR_EXP 51
53672: PUSH
53673: LD_EXP 51
53677: PPUSH
53678: LD_VAR 0 2
53682: PPUSH
53683: LD_EXP 43
53687: PUSH
53688: LD_VAR 0 2
53692: ARRAY
53693: PPUSH
53694: LD_INT 2
53696: PUSH
53697: LD_INT 30
53699: PUSH
53700: LD_INT 32
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PUSH
53707: LD_INT 30
53709: PUSH
53710: LD_INT 33
53712: PUSH
53713: EMPTY
53714: LIST
53715: LIST
53716: PUSH
53717: EMPTY
53718: LIST
53719: LIST
53720: LIST
53721: PPUSH
53722: CALL_OW 72
53726: PPUSH
53727: CALL_OW 1
53731: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53732: LD_ADDR_EXP 52
53736: PUSH
53737: LD_EXP 52
53741: PPUSH
53742: LD_VAR 0 2
53746: PPUSH
53747: LD_EXP 43
53751: PUSH
53752: LD_VAR 0 2
53756: ARRAY
53757: PPUSH
53758: LD_INT 2
53760: PUSH
53761: LD_INT 30
53763: PUSH
53764: LD_INT 32
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PUSH
53771: LD_INT 30
53773: PUSH
53774: LD_INT 31
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: EMPTY
53782: LIST
53783: LIST
53784: LIST
53785: PUSH
53786: LD_INT 58
53788: PUSH
53789: EMPTY
53790: LIST
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PPUSH
53796: CALL_OW 72
53800: PPUSH
53801: CALL_OW 1
53805: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53806: LD_ADDR_EXP 53
53810: PUSH
53811: LD_EXP 53
53815: PPUSH
53816: LD_VAR 0 2
53820: PPUSH
53821: EMPTY
53822: PPUSH
53823: CALL_OW 1
53827: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53828: LD_ADDR_EXP 57
53832: PUSH
53833: LD_EXP 57
53837: PPUSH
53838: LD_VAR 0 2
53842: PPUSH
53843: EMPTY
53844: PPUSH
53845: CALL_OW 1
53849: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53850: LD_ADDR_EXP 56
53854: PUSH
53855: LD_EXP 56
53859: PPUSH
53860: LD_VAR 0 2
53864: PPUSH
53865: EMPTY
53866: PPUSH
53867: CALL_OW 1
53871: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53872: LD_ADDR_EXP 58
53876: PUSH
53877: LD_EXP 58
53881: PPUSH
53882: LD_VAR 0 2
53886: PPUSH
53887: EMPTY
53888: PPUSH
53889: CALL_OW 1
53893: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53894: LD_ADDR_EXP 59
53898: PUSH
53899: LD_EXP 59
53903: PPUSH
53904: LD_VAR 0 2
53908: PPUSH
53909: EMPTY
53910: PPUSH
53911: CALL_OW 1
53915: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53916: LD_ADDR_EXP 60
53920: PUSH
53921: LD_EXP 60
53925: PPUSH
53926: LD_VAR 0 2
53930: PPUSH
53931: EMPTY
53932: PPUSH
53933: CALL_OW 1
53937: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53938: LD_ADDR_EXP 61
53942: PUSH
53943: LD_EXP 61
53947: PPUSH
53948: LD_VAR 0 2
53952: PPUSH
53953: EMPTY
53954: PPUSH
53955: CALL_OW 1
53959: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53960: LD_ADDR_EXP 62
53964: PUSH
53965: LD_EXP 62
53969: PPUSH
53970: LD_VAR 0 2
53974: PPUSH
53975: EMPTY
53976: PPUSH
53977: CALL_OW 1
53981: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53982: LD_ADDR_EXP 63
53986: PUSH
53987: LD_EXP 63
53991: PPUSH
53992: LD_VAR 0 2
53996: PPUSH
53997: EMPTY
53998: PPUSH
53999: CALL_OW 1
54003: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54004: LD_ADDR_EXP 64
54008: PUSH
54009: LD_EXP 64
54013: PPUSH
54014: LD_VAR 0 2
54018: PPUSH
54019: EMPTY
54020: PPUSH
54021: CALL_OW 1
54025: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54026: LD_ADDR_EXP 65
54030: PUSH
54031: LD_EXP 65
54035: PPUSH
54036: LD_VAR 0 2
54040: PPUSH
54041: EMPTY
54042: PPUSH
54043: CALL_OW 1
54047: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54048: LD_ADDR_EXP 54
54052: PUSH
54053: LD_EXP 54
54057: PPUSH
54058: LD_VAR 0 2
54062: PPUSH
54063: LD_INT 0
54065: PPUSH
54066: CALL_OW 1
54070: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54071: LD_ADDR_EXP 67
54075: PUSH
54076: LD_EXP 67
54080: PPUSH
54081: LD_VAR 0 2
54085: PPUSH
54086: LD_INT 0
54088: PPUSH
54089: CALL_OW 1
54093: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54094: LD_ADDR_EXP 55
54098: PUSH
54099: LD_EXP 55
54103: PPUSH
54104: LD_VAR 0 2
54108: PPUSH
54109: EMPTY
54110: PPUSH
54111: CALL_OW 1
54115: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54116: LD_ADDR_EXP 66
54120: PUSH
54121: LD_EXP 66
54125: PPUSH
54126: LD_VAR 0 2
54130: PPUSH
54131: LD_INT 0
54133: PPUSH
54134: CALL_OW 1
54138: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54139: LD_ADDR_EXP 68
54143: PUSH
54144: LD_EXP 68
54148: PPUSH
54149: LD_VAR 0 2
54153: PPUSH
54154: EMPTY
54155: PPUSH
54156: CALL_OW 1
54160: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54161: LD_ADDR_EXP 71
54165: PUSH
54166: LD_EXP 71
54170: PPUSH
54171: LD_VAR 0 2
54175: PPUSH
54176: LD_INT 0
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54184: LD_ADDR_EXP 72
54188: PUSH
54189: LD_EXP 72
54193: PPUSH
54194: LD_VAR 0 2
54198: PPUSH
54199: EMPTY
54200: PPUSH
54201: CALL_OW 1
54205: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54206: LD_ADDR_EXP 73
54210: PUSH
54211: LD_EXP 73
54215: PPUSH
54216: LD_VAR 0 2
54220: PPUSH
54221: EMPTY
54222: PPUSH
54223: CALL_OW 1
54227: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54228: LD_ADDR_EXP 74
54232: PUSH
54233: LD_EXP 74
54237: PPUSH
54238: LD_VAR 0 2
54242: PPUSH
54243: EMPTY
54244: PPUSH
54245: CALL_OW 1
54249: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54250: LD_ADDR_EXP 76
54254: PUSH
54255: LD_EXP 76
54259: PPUSH
54260: LD_VAR 0 2
54264: PPUSH
54265: LD_EXP 43
54269: PUSH
54270: LD_VAR 0 2
54274: ARRAY
54275: PPUSH
54276: LD_INT 2
54278: PUSH
54279: LD_INT 30
54281: PUSH
54282: LD_INT 6
54284: PUSH
54285: EMPTY
54286: LIST
54287: LIST
54288: PUSH
54289: LD_INT 30
54291: PUSH
54292: LD_INT 7
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: PUSH
54299: LD_INT 30
54301: PUSH
54302: LD_INT 8
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: PPUSH
54315: CALL_OW 72
54319: PPUSH
54320: CALL_OW 1
54324: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54325: LD_ADDR_EXP 77
54329: PUSH
54330: LD_EXP 77
54334: PPUSH
54335: LD_VAR 0 2
54339: PPUSH
54340: EMPTY
54341: PPUSH
54342: CALL_OW 1
54346: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54347: LD_ADDR_EXP 78
54351: PUSH
54352: LD_EXP 78
54356: PPUSH
54357: LD_VAR 0 2
54361: PPUSH
54362: EMPTY
54363: PPUSH
54364: CALL_OW 1
54368: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54369: LD_ADDR_EXP 79
54373: PUSH
54374: LD_EXP 79
54378: PPUSH
54379: LD_VAR 0 2
54383: PPUSH
54384: EMPTY
54385: PPUSH
54386: CALL_OW 1
54390: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54391: LD_ADDR_EXP 80
54395: PUSH
54396: LD_EXP 80
54400: PPUSH
54401: LD_VAR 0 2
54405: PPUSH
54406: EMPTY
54407: PPUSH
54408: CALL_OW 1
54412: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54413: LD_ADDR_EXP 81
54417: PUSH
54418: LD_EXP 81
54422: PPUSH
54423: LD_VAR 0 2
54427: PPUSH
54428: EMPTY
54429: PPUSH
54430: CALL_OW 1
54434: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54435: LD_ADDR_EXP 82
54439: PUSH
54440: LD_EXP 82
54444: PPUSH
54445: LD_VAR 0 2
54449: PPUSH
54450: EMPTY
54451: PPUSH
54452: CALL_OW 1
54456: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54457: LD_ADDR_EXP 83
54461: PUSH
54462: LD_EXP 83
54466: PPUSH
54467: LD_VAR 0 2
54471: PPUSH
54472: EMPTY
54473: PPUSH
54474: CALL_OW 1
54478: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54479: LD_ADDR_EXP 84
54483: PUSH
54484: LD_EXP 84
54488: PPUSH
54489: LD_VAR 0 2
54493: PPUSH
54494: EMPTY
54495: PPUSH
54496: CALL_OW 1
54500: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54501: LD_ADDR_EXP 85
54505: PUSH
54506: LD_EXP 85
54510: PPUSH
54511: LD_VAR 0 2
54515: PPUSH
54516: LD_INT 0
54518: PPUSH
54519: CALL_OW 1
54523: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54524: LD_ADDR_EXP 86
54528: PUSH
54529: LD_EXP 86
54533: PPUSH
54534: LD_VAR 0 2
54538: PPUSH
54539: LD_INT 0
54541: PPUSH
54542: CALL_OW 1
54546: ST_TO_ADDR
// end ;
54547: GO 53448
54549: POP
54550: POP
// MC_InitSides ( ) ;
54551: CALL 54837 0 0
// MC_InitResearch ( ) ;
54555: CALL 54576 0 0
// CustomInitMacro ( ) ;
54559: CALL 78 0 0
// skirmish := true ;
54563: LD_ADDR_EXP 41
54567: PUSH
54568: LD_INT 1
54570: ST_TO_ADDR
// end ;
54571: LD_VAR 0 1
54575: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54576: LD_INT 0
54578: PPUSH
54579: PPUSH
54580: PPUSH
54581: PPUSH
54582: PPUSH
54583: PPUSH
// if not mc_bases then
54584: LD_EXP 43
54588: NOT
54589: IFFALSE 54593
// exit ;
54591: GO 54832
// for i = 1 to 8 do
54593: LD_ADDR_VAR 0 2
54597: PUSH
54598: DOUBLE
54599: LD_INT 1
54601: DEC
54602: ST_TO_ADDR
54603: LD_INT 8
54605: PUSH
54606: FOR_TO
54607: IFFALSE 54633
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54609: LD_ADDR_EXP 70
54613: PUSH
54614: LD_EXP 70
54618: PPUSH
54619: LD_VAR 0 2
54623: PPUSH
54624: EMPTY
54625: PPUSH
54626: CALL_OW 1
54630: ST_TO_ADDR
54631: GO 54606
54633: POP
54634: POP
// tmp := [ ] ;
54635: LD_ADDR_VAR 0 5
54639: PUSH
54640: EMPTY
54641: ST_TO_ADDR
// for i = 1 to mc_sides do
54642: LD_ADDR_VAR 0 2
54646: PUSH
54647: DOUBLE
54648: LD_INT 1
54650: DEC
54651: ST_TO_ADDR
54652: LD_EXP 69
54656: PUSH
54657: FOR_TO
54658: IFFALSE 54716
// if not mc_sides [ i ] in tmp then
54660: LD_EXP 69
54664: PUSH
54665: LD_VAR 0 2
54669: ARRAY
54670: PUSH
54671: LD_VAR 0 5
54675: IN
54676: NOT
54677: IFFALSE 54714
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54679: LD_ADDR_VAR 0 5
54683: PUSH
54684: LD_VAR 0 5
54688: PPUSH
54689: LD_VAR 0 5
54693: PUSH
54694: LD_INT 1
54696: PLUS
54697: PPUSH
54698: LD_EXP 69
54702: PUSH
54703: LD_VAR 0 2
54707: ARRAY
54708: PPUSH
54709: CALL_OW 2
54713: ST_TO_ADDR
54714: GO 54657
54716: POP
54717: POP
// if not tmp then
54718: LD_VAR 0 5
54722: NOT
54723: IFFALSE 54727
// exit ;
54725: GO 54832
// for j in tmp do
54727: LD_ADDR_VAR 0 3
54731: PUSH
54732: LD_VAR 0 5
54736: PUSH
54737: FOR_IN
54738: IFFALSE 54830
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54740: LD_ADDR_VAR 0 6
54744: PUSH
54745: LD_INT 22
54747: PUSH
54748: LD_VAR 0 3
54752: PUSH
54753: EMPTY
54754: LIST
54755: LIST
54756: PPUSH
54757: CALL_OW 69
54761: ST_TO_ADDR
// if not un then
54762: LD_VAR 0 6
54766: NOT
54767: IFFALSE 54771
// continue ;
54769: GO 54737
// nation := GetNation ( un [ 1 ] ) ;
54771: LD_ADDR_VAR 0 4
54775: PUSH
54776: LD_VAR 0 6
54780: PUSH
54781: LD_INT 1
54783: ARRAY
54784: PPUSH
54785: CALL_OW 248
54789: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54790: LD_ADDR_EXP 70
54794: PUSH
54795: LD_EXP 70
54799: PPUSH
54800: LD_VAR 0 3
54804: PPUSH
54805: LD_VAR 0 3
54809: PPUSH
54810: LD_VAR 0 4
54814: PPUSH
54815: LD_INT 1
54817: PPUSH
54818: CALL 9875 0 3
54822: PPUSH
54823: CALL_OW 1
54827: ST_TO_ADDR
// end ;
54828: GO 54737
54830: POP
54831: POP
// end ;
54832: LD_VAR 0 1
54836: RET
// export function MC_InitSides ( ) ; var i ; begin
54837: LD_INT 0
54839: PPUSH
54840: PPUSH
// if not mc_bases then
54841: LD_EXP 43
54845: NOT
54846: IFFALSE 54850
// exit ;
54848: GO 54924
// for i = 1 to mc_bases do
54850: LD_ADDR_VAR 0 2
54854: PUSH
54855: DOUBLE
54856: LD_INT 1
54858: DEC
54859: ST_TO_ADDR
54860: LD_EXP 43
54864: PUSH
54865: FOR_TO
54866: IFFALSE 54922
// if mc_bases [ i ] then
54868: LD_EXP 43
54872: PUSH
54873: LD_VAR 0 2
54877: ARRAY
54878: IFFALSE 54920
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54880: LD_ADDR_EXP 69
54884: PUSH
54885: LD_EXP 69
54889: PPUSH
54890: LD_VAR 0 2
54894: PPUSH
54895: LD_EXP 43
54899: PUSH
54900: LD_VAR 0 2
54904: ARRAY
54905: PUSH
54906: LD_INT 1
54908: ARRAY
54909: PPUSH
54910: CALL_OW 255
54914: PPUSH
54915: CALL_OW 1
54919: ST_TO_ADDR
54920: GO 54865
54922: POP
54923: POP
// end ;
54924: LD_VAR 0 1
54928: RET
// every 0 0$03 trigger skirmish do
54929: LD_EXP 41
54933: IFFALSE 55087
54935: GO 54937
54937: DISABLE
// begin enable ;
54938: ENABLE
// MC_CheckBuildings ( ) ;
54939: CALL 59585 0 0
// MC_CheckPeopleLife ( ) ;
54943: CALL 59746 0 0
// RaiseSailEvent ( 100 ) ;
54947: LD_INT 100
54949: PPUSH
54950: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54954: LD_INT 103
54956: PPUSH
54957: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54961: LD_INT 104
54963: PPUSH
54964: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54968: LD_INT 105
54970: PPUSH
54971: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54975: LD_INT 106
54977: PPUSH
54978: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54982: LD_INT 107
54984: PPUSH
54985: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54989: LD_INT 108
54991: PPUSH
54992: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54996: LD_INT 109
54998: PPUSH
54999: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55003: LD_INT 110
55005: PPUSH
55006: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55010: LD_INT 111
55012: PPUSH
55013: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55017: LD_INT 112
55019: PPUSH
55020: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55024: LD_INT 113
55026: PPUSH
55027: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55031: LD_INT 120
55033: PPUSH
55034: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55038: LD_INT 121
55040: PPUSH
55041: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55045: LD_INT 122
55047: PPUSH
55048: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55052: LD_INT 123
55054: PPUSH
55055: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55059: LD_INT 124
55061: PPUSH
55062: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55066: LD_INT 125
55068: PPUSH
55069: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55073: LD_INT 126
55075: PPUSH
55076: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55080: LD_INT 200
55082: PPUSH
55083: CALL_OW 427
// end ;
55087: END
// on SailEvent ( event ) do begin if event < 100 then
55088: LD_VAR 0 1
55092: PUSH
55093: LD_INT 100
55095: LESS
55096: IFFALSE 55107
// CustomEvent ( event ) ;
55098: LD_VAR 0 1
55102: PPUSH
55103: CALL 584 0 1
// if event = 100 then
55107: LD_VAR 0 1
55111: PUSH
55112: LD_INT 100
55114: EQUAL
55115: IFFALSE 55121
// MC_ClassManager ( ) ;
55117: CALL 55513 0 0
// if event = 101 then
55121: LD_VAR 0 1
55125: PUSH
55126: LD_INT 101
55128: EQUAL
55129: IFFALSE 55135
// MC_RepairBuildings ( ) ;
55131: CALL 60331 0 0
// if event = 102 then
55135: LD_VAR 0 1
55139: PUSH
55140: LD_INT 102
55142: EQUAL
55143: IFFALSE 55149
// MC_Heal ( ) ;
55145: CALL 61266 0 0
// if event = 103 then
55149: LD_VAR 0 1
55153: PUSH
55154: LD_INT 103
55156: EQUAL
55157: IFFALSE 55163
// MC_Build ( ) ;
55159: CALL 61688 0 0
// if event = 104 then
55163: LD_VAR 0 1
55167: PUSH
55168: LD_INT 104
55170: EQUAL
55171: IFFALSE 55177
// MC_TurretWeapon ( ) ;
55173: CALL 63322 0 0
// if event = 105 then
55177: LD_VAR 0 1
55181: PUSH
55182: LD_INT 105
55184: EQUAL
55185: IFFALSE 55191
// MC_BuildUpgrade ( ) ;
55187: CALL 62873 0 0
// if event = 106 then
55191: LD_VAR 0 1
55195: PUSH
55196: LD_INT 106
55198: EQUAL
55199: IFFALSE 55205
// MC_PlantMines ( ) ;
55201: CALL 63752 0 0
// if event = 107 then
55205: LD_VAR 0 1
55209: PUSH
55210: LD_INT 107
55212: EQUAL
55213: IFFALSE 55219
// MC_CollectCrates ( ) ;
55215: CALL 64543 0 0
// if event = 108 then
55219: LD_VAR 0 1
55223: PUSH
55224: LD_INT 108
55226: EQUAL
55227: IFFALSE 55233
// MC_LinkRemoteControl ( ) ;
55229: CALL 66393 0 0
// if event = 109 then
55233: LD_VAR 0 1
55237: PUSH
55238: LD_INT 109
55240: EQUAL
55241: IFFALSE 55247
// MC_ProduceVehicle ( ) ;
55243: CALL 66574 0 0
// if event = 110 then
55247: LD_VAR 0 1
55251: PUSH
55252: LD_INT 110
55254: EQUAL
55255: IFFALSE 55261
// MC_SendAttack ( ) ;
55257: CALL 67040 0 0
// if event = 111 then
55261: LD_VAR 0 1
55265: PUSH
55266: LD_INT 111
55268: EQUAL
55269: IFFALSE 55275
// MC_Defend ( ) ;
55271: CALL 67148 0 0
// if event = 112 then
55275: LD_VAR 0 1
55279: PUSH
55280: LD_INT 112
55282: EQUAL
55283: IFFALSE 55289
// MC_Research ( ) ;
55285: CALL 68028 0 0
// if event = 113 then
55289: LD_VAR 0 1
55293: PUSH
55294: LD_INT 113
55296: EQUAL
55297: IFFALSE 55303
// MC_MinesTrigger ( ) ;
55299: CALL 69142 0 0
// if event = 120 then
55303: LD_VAR 0 1
55307: PUSH
55308: LD_INT 120
55310: EQUAL
55311: IFFALSE 55317
// MC_RepairVehicle ( ) ;
55313: CALL 69241 0 0
// if event = 121 then
55317: LD_VAR 0 1
55321: PUSH
55322: LD_INT 121
55324: EQUAL
55325: IFFALSE 55331
// MC_TameApe ( ) ;
55327: CALL 70010 0 0
// if event = 122 then
55331: LD_VAR 0 1
55335: PUSH
55336: LD_INT 122
55338: EQUAL
55339: IFFALSE 55345
// MC_ChangeApeClass ( ) ;
55341: CALL 70839 0 0
// if event = 123 then
55345: LD_VAR 0 1
55349: PUSH
55350: LD_INT 123
55352: EQUAL
55353: IFFALSE 55359
// MC_Bazooka ( ) ;
55355: CALL 71489 0 0
// if event = 124 then
55359: LD_VAR 0 1
55363: PUSH
55364: LD_INT 124
55366: EQUAL
55367: IFFALSE 55373
// MC_TeleportExit ( ) ;
55369: CALL 71687 0 0
// if event = 125 then
55373: LD_VAR 0 1
55377: PUSH
55378: LD_INT 125
55380: EQUAL
55381: IFFALSE 55387
// MC_Deposits ( ) ;
55383: CALL 72334 0 0
// if event = 126 then
55387: LD_VAR 0 1
55391: PUSH
55392: LD_INT 126
55394: EQUAL
55395: IFFALSE 55401
// MC_RemoteDriver ( ) ;
55397: CALL 72959 0 0
// if event = 200 then
55401: LD_VAR 0 1
55405: PUSH
55406: LD_INT 200
55408: EQUAL
55409: IFFALSE 55415
// MC_Idle ( ) ;
55411: CALL 74908 0 0
// end ;
55415: PPOPN 1
55417: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55418: LD_INT 0
55420: PPUSH
55421: PPUSH
// if not mc_bases [ base ] or not tag then
55422: LD_EXP 43
55426: PUSH
55427: LD_VAR 0 1
55431: ARRAY
55432: NOT
55433: PUSH
55434: LD_VAR 0 2
55438: NOT
55439: OR
55440: IFFALSE 55444
// exit ;
55442: GO 55508
// for i in mc_bases [ base ] union mc_ape [ base ] do
55444: LD_ADDR_VAR 0 4
55448: PUSH
55449: LD_EXP 43
55453: PUSH
55454: LD_VAR 0 1
55458: ARRAY
55459: PUSH
55460: LD_EXP 72
55464: PUSH
55465: LD_VAR 0 1
55469: ARRAY
55470: UNION
55471: PUSH
55472: FOR_IN
55473: IFFALSE 55506
// if GetTag ( i ) = tag then
55475: LD_VAR 0 4
55479: PPUSH
55480: CALL_OW 110
55484: PUSH
55485: LD_VAR 0 2
55489: EQUAL
55490: IFFALSE 55504
// SetTag ( i , 0 ) ;
55492: LD_VAR 0 4
55496: PPUSH
55497: LD_INT 0
55499: PPUSH
55500: CALL_OW 109
55504: GO 55472
55506: POP
55507: POP
// end ;
55508: LD_VAR 0 3
55512: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55513: LD_INT 0
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
55519: PPUSH
55520: PPUSH
55521: PPUSH
55522: PPUSH
// if not mc_bases then
55523: LD_EXP 43
55527: NOT
55528: IFFALSE 55532
// exit ;
55530: GO 55990
// for i = 1 to mc_bases do
55532: LD_ADDR_VAR 0 2
55536: PUSH
55537: DOUBLE
55538: LD_INT 1
55540: DEC
55541: ST_TO_ADDR
55542: LD_EXP 43
55546: PUSH
55547: FOR_TO
55548: IFFALSE 55988
// begin tmp := MC_ClassCheckReq ( i ) ;
55550: LD_ADDR_VAR 0 4
55554: PUSH
55555: LD_VAR 0 2
55559: PPUSH
55560: CALL 55995 0 1
55564: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55565: LD_ADDR_EXP 84
55569: PUSH
55570: LD_EXP 84
55574: PPUSH
55575: LD_VAR 0 2
55579: PPUSH
55580: LD_VAR 0 4
55584: PPUSH
55585: CALL_OW 1
55589: ST_TO_ADDR
// if not tmp then
55590: LD_VAR 0 4
55594: NOT
55595: IFFALSE 55599
// continue ;
55597: GO 55547
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55599: LD_ADDR_VAR 0 6
55603: PUSH
55604: LD_EXP 43
55608: PUSH
55609: LD_VAR 0 2
55613: ARRAY
55614: PPUSH
55615: LD_INT 2
55617: PUSH
55618: LD_INT 30
55620: PUSH
55621: LD_INT 4
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: PUSH
55628: LD_INT 30
55630: PUSH
55631: LD_INT 5
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: LIST
55642: PPUSH
55643: CALL_OW 72
55647: PUSH
55648: LD_EXP 43
55652: PUSH
55653: LD_VAR 0 2
55657: ARRAY
55658: PPUSH
55659: LD_INT 2
55661: PUSH
55662: LD_INT 30
55664: PUSH
55665: LD_INT 0
55667: PUSH
55668: EMPTY
55669: LIST
55670: LIST
55671: PUSH
55672: LD_INT 30
55674: PUSH
55675: LD_INT 1
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: LIST
55686: PPUSH
55687: CALL_OW 72
55691: PUSH
55692: LD_EXP 43
55696: PUSH
55697: LD_VAR 0 2
55701: ARRAY
55702: PPUSH
55703: LD_INT 30
55705: PUSH
55706: LD_INT 3
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: PPUSH
55713: CALL_OW 72
55717: PUSH
55718: LD_EXP 43
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: PPUSH
55729: LD_INT 2
55731: PUSH
55732: LD_INT 30
55734: PUSH
55735: LD_INT 6
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: PUSH
55742: LD_INT 30
55744: PUSH
55745: LD_INT 7
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: PUSH
55752: LD_INT 30
55754: PUSH
55755: LD_INT 8
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: PUSH
55762: EMPTY
55763: LIST
55764: LIST
55765: LIST
55766: LIST
55767: PPUSH
55768: CALL_OW 72
55772: PUSH
55773: EMPTY
55774: LIST
55775: LIST
55776: LIST
55777: LIST
55778: ST_TO_ADDR
// for j = 1 to 4 do
55779: LD_ADDR_VAR 0 3
55783: PUSH
55784: DOUBLE
55785: LD_INT 1
55787: DEC
55788: ST_TO_ADDR
55789: LD_INT 4
55791: PUSH
55792: FOR_TO
55793: IFFALSE 55984
// begin if not tmp [ j ] then
55795: LD_VAR 0 4
55799: PUSH
55800: LD_VAR 0 3
55804: ARRAY
55805: NOT
55806: IFFALSE 55810
// continue ;
55808: GO 55792
// for p in tmp [ j ] do
55810: LD_ADDR_VAR 0 5
55814: PUSH
55815: LD_VAR 0 4
55819: PUSH
55820: LD_VAR 0 3
55824: ARRAY
55825: PUSH
55826: FOR_IN
55827: IFFALSE 55980
// begin if not b [ j ] then
55829: LD_VAR 0 6
55833: PUSH
55834: LD_VAR 0 3
55838: ARRAY
55839: NOT
55840: IFFALSE 55844
// break ;
55842: GO 55980
// e := 0 ;
55844: LD_ADDR_VAR 0 7
55848: PUSH
55849: LD_INT 0
55851: ST_TO_ADDR
// for k in b [ j ] do
55852: LD_ADDR_VAR 0 8
55856: PUSH
55857: LD_VAR 0 6
55861: PUSH
55862: LD_VAR 0 3
55866: ARRAY
55867: PUSH
55868: FOR_IN
55869: IFFALSE 55896
// if IsNotFull ( k ) then
55871: LD_VAR 0 8
55875: PPUSH
55876: CALL 11996 0 1
55880: IFFALSE 55894
// begin e := k ;
55882: LD_ADDR_VAR 0 7
55886: PUSH
55887: LD_VAR 0 8
55891: ST_TO_ADDR
// break ;
55892: GO 55896
// end ;
55894: GO 55868
55896: POP
55897: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55898: LD_VAR 0 7
55902: PUSH
55903: LD_VAR 0 5
55907: PPUSH
55908: LD_VAR 0 7
55912: PPUSH
55913: CALL 45892 0 2
55917: NOT
55918: AND
55919: IFFALSE 55978
// begin if IsInUnit ( p ) then
55921: LD_VAR 0 5
55925: PPUSH
55926: CALL_OW 310
55930: IFFALSE 55941
// ComExitBuilding ( p ) ;
55932: LD_VAR 0 5
55936: PPUSH
55937: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55941: LD_VAR 0 5
55945: PPUSH
55946: LD_VAR 0 7
55950: PPUSH
55951: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55955: LD_VAR 0 5
55959: PPUSH
55960: LD_VAR 0 3
55964: PPUSH
55965: CALL_OW 183
// AddComExitBuilding ( p ) ;
55969: LD_VAR 0 5
55973: PPUSH
55974: CALL_OW 182
// end ; end ;
55978: GO 55826
55980: POP
55981: POP
// end ;
55982: GO 55792
55984: POP
55985: POP
// end ;
55986: GO 55547
55988: POP
55989: POP
// end ;
55990: LD_VAR 0 1
55994: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55995: LD_INT 0
55997: PPUSH
55998: PPUSH
55999: PPUSH
56000: PPUSH
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
56005: PPUSH
56006: PPUSH
56007: PPUSH
56008: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56009: LD_VAR 0 1
56013: NOT
56014: PUSH
56015: LD_EXP 43
56019: PUSH
56020: LD_VAR 0 1
56024: ARRAY
56025: NOT
56026: OR
56027: PUSH
56028: LD_EXP 43
56032: PUSH
56033: LD_VAR 0 1
56037: ARRAY
56038: PPUSH
56039: LD_INT 2
56041: PUSH
56042: LD_INT 30
56044: PUSH
56045: LD_INT 0
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: LD_INT 30
56054: PUSH
56055: LD_INT 1
56057: PUSH
56058: EMPTY
56059: LIST
56060: LIST
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: LIST
56066: PPUSH
56067: CALL_OW 72
56071: NOT
56072: OR
56073: IFFALSE 56077
// exit ;
56075: GO 59580
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56077: LD_ADDR_VAR 0 4
56081: PUSH
56082: LD_EXP 43
56086: PUSH
56087: LD_VAR 0 1
56091: ARRAY
56092: PPUSH
56093: LD_INT 2
56095: PUSH
56096: LD_INT 25
56098: PUSH
56099: LD_INT 1
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: LD_INT 25
56108: PUSH
56109: LD_INT 2
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: PUSH
56116: LD_INT 25
56118: PUSH
56119: LD_INT 3
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: PUSH
56126: LD_INT 25
56128: PUSH
56129: LD_INT 4
56131: PUSH
56132: EMPTY
56133: LIST
56134: LIST
56135: PUSH
56136: LD_INT 25
56138: PUSH
56139: LD_INT 5
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PUSH
56146: LD_INT 25
56148: PUSH
56149: LD_INT 8
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: PUSH
56156: LD_INT 25
56158: PUSH
56159: LD_INT 9
56161: PUSH
56162: EMPTY
56163: LIST
56164: LIST
56165: PUSH
56166: EMPTY
56167: LIST
56168: LIST
56169: LIST
56170: LIST
56171: LIST
56172: LIST
56173: LIST
56174: LIST
56175: PPUSH
56176: CALL_OW 72
56180: ST_TO_ADDR
// if not tmp then
56181: LD_VAR 0 4
56185: NOT
56186: IFFALSE 56190
// exit ;
56188: GO 59580
// for i in tmp do
56190: LD_ADDR_VAR 0 3
56194: PUSH
56195: LD_VAR 0 4
56199: PUSH
56200: FOR_IN
56201: IFFALSE 56232
// if GetTag ( i ) then
56203: LD_VAR 0 3
56207: PPUSH
56208: CALL_OW 110
56212: IFFALSE 56230
// tmp := tmp diff i ;
56214: LD_ADDR_VAR 0 4
56218: PUSH
56219: LD_VAR 0 4
56223: PUSH
56224: LD_VAR 0 3
56228: DIFF
56229: ST_TO_ADDR
56230: GO 56200
56232: POP
56233: POP
// if not tmp then
56234: LD_VAR 0 4
56238: NOT
56239: IFFALSE 56243
// exit ;
56241: GO 59580
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56243: LD_ADDR_VAR 0 5
56247: PUSH
56248: LD_EXP 43
56252: PUSH
56253: LD_VAR 0 1
56257: ARRAY
56258: PPUSH
56259: LD_INT 2
56261: PUSH
56262: LD_INT 25
56264: PUSH
56265: LD_INT 1
56267: PUSH
56268: EMPTY
56269: LIST
56270: LIST
56271: PUSH
56272: LD_INT 25
56274: PUSH
56275: LD_INT 5
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: PUSH
56282: LD_INT 25
56284: PUSH
56285: LD_INT 8
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: PUSH
56292: LD_INT 25
56294: PUSH
56295: LD_INT 9
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: PUSH
56302: EMPTY
56303: LIST
56304: LIST
56305: LIST
56306: LIST
56307: LIST
56308: PPUSH
56309: CALL_OW 72
56313: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56314: LD_ADDR_VAR 0 6
56318: PUSH
56319: LD_EXP 43
56323: PUSH
56324: LD_VAR 0 1
56328: ARRAY
56329: PPUSH
56330: LD_INT 25
56332: PUSH
56333: LD_INT 2
56335: PUSH
56336: EMPTY
56337: LIST
56338: LIST
56339: PPUSH
56340: CALL_OW 72
56344: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56345: LD_ADDR_VAR 0 7
56349: PUSH
56350: LD_EXP 43
56354: PUSH
56355: LD_VAR 0 1
56359: ARRAY
56360: PPUSH
56361: LD_INT 25
56363: PUSH
56364: LD_INT 3
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: PPUSH
56371: CALL_OW 72
56375: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56376: LD_ADDR_VAR 0 8
56380: PUSH
56381: LD_EXP 43
56385: PUSH
56386: LD_VAR 0 1
56390: ARRAY
56391: PPUSH
56392: LD_INT 25
56394: PUSH
56395: LD_INT 4
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PUSH
56402: LD_INT 24
56404: PUSH
56405: LD_INT 251
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PPUSH
56416: CALL_OW 72
56420: ST_TO_ADDR
// if mc_is_defending [ base ] then
56421: LD_EXP 86
56425: PUSH
56426: LD_VAR 0 1
56430: ARRAY
56431: IFFALSE 56892
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56433: LD_ADDR_EXP 85
56437: PUSH
56438: LD_EXP 85
56442: PPUSH
56443: LD_VAR 0 1
56447: PPUSH
56448: LD_INT 4
56450: PPUSH
56451: CALL_OW 1
56455: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56456: LD_ADDR_VAR 0 12
56460: PUSH
56461: LD_EXP 43
56465: PUSH
56466: LD_VAR 0 1
56470: ARRAY
56471: PPUSH
56472: LD_INT 2
56474: PUSH
56475: LD_INT 30
56477: PUSH
56478: LD_INT 4
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: PUSH
56485: LD_INT 30
56487: PUSH
56488: LD_INT 5
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: PUSH
56495: EMPTY
56496: LIST
56497: LIST
56498: LIST
56499: PPUSH
56500: CALL_OW 72
56504: ST_TO_ADDR
// if not b then
56505: LD_VAR 0 12
56509: NOT
56510: IFFALSE 56514
// exit ;
56512: GO 59580
// p := [ ] ;
56514: LD_ADDR_VAR 0 11
56518: PUSH
56519: EMPTY
56520: ST_TO_ADDR
// if sci >= 2 then
56521: LD_VAR 0 8
56525: PUSH
56526: LD_INT 2
56528: GREATEREQUAL
56529: IFFALSE 56560
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56531: LD_ADDR_VAR 0 8
56535: PUSH
56536: LD_VAR 0 8
56540: PUSH
56541: LD_INT 1
56543: ARRAY
56544: PUSH
56545: LD_VAR 0 8
56549: PUSH
56550: LD_INT 2
56552: ARRAY
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: ST_TO_ADDR
56558: GO 56621
// if sci = 1 then
56560: LD_VAR 0 8
56564: PUSH
56565: LD_INT 1
56567: EQUAL
56568: IFFALSE 56589
// sci := [ sci [ 1 ] ] else
56570: LD_ADDR_VAR 0 8
56574: PUSH
56575: LD_VAR 0 8
56579: PUSH
56580: LD_INT 1
56582: ARRAY
56583: PUSH
56584: EMPTY
56585: LIST
56586: ST_TO_ADDR
56587: GO 56621
// if sci = 0 then
56589: LD_VAR 0 8
56593: PUSH
56594: LD_INT 0
56596: EQUAL
56597: IFFALSE 56621
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56599: LD_ADDR_VAR 0 11
56603: PUSH
56604: LD_VAR 0 4
56608: PPUSH
56609: LD_INT 4
56611: PPUSH
56612: CALL 45764 0 2
56616: PUSH
56617: LD_INT 1
56619: ARRAY
56620: ST_TO_ADDR
// if eng > 4 then
56621: LD_VAR 0 6
56625: PUSH
56626: LD_INT 4
56628: GREATER
56629: IFFALSE 56675
// for i = eng downto 4 do
56631: LD_ADDR_VAR 0 3
56635: PUSH
56636: DOUBLE
56637: LD_VAR 0 6
56641: INC
56642: ST_TO_ADDR
56643: LD_INT 4
56645: PUSH
56646: FOR_DOWNTO
56647: IFFALSE 56673
// eng := eng diff eng [ i ] ;
56649: LD_ADDR_VAR 0 6
56653: PUSH
56654: LD_VAR 0 6
56658: PUSH
56659: LD_VAR 0 6
56663: PUSH
56664: LD_VAR 0 3
56668: ARRAY
56669: DIFF
56670: ST_TO_ADDR
56671: GO 56646
56673: POP
56674: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56675: LD_ADDR_VAR 0 4
56679: PUSH
56680: LD_VAR 0 4
56684: PUSH
56685: LD_VAR 0 5
56689: PUSH
56690: LD_VAR 0 6
56694: UNION
56695: PUSH
56696: LD_VAR 0 7
56700: UNION
56701: PUSH
56702: LD_VAR 0 8
56706: UNION
56707: DIFF
56708: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56709: LD_ADDR_VAR 0 13
56713: PUSH
56714: LD_EXP 43
56718: PUSH
56719: LD_VAR 0 1
56723: ARRAY
56724: PPUSH
56725: LD_INT 2
56727: PUSH
56728: LD_INT 30
56730: PUSH
56731: LD_INT 32
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: PUSH
56738: LD_INT 30
56740: PUSH
56741: LD_INT 31
56743: PUSH
56744: EMPTY
56745: LIST
56746: LIST
56747: PUSH
56748: EMPTY
56749: LIST
56750: LIST
56751: LIST
56752: PPUSH
56753: CALL_OW 72
56757: PUSH
56758: LD_EXP 43
56762: PUSH
56763: LD_VAR 0 1
56767: ARRAY
56768: PPUSH
56769: LD_INT 2
56771: PUSH
56772: LD_INT 30
56774: PUSH
56775: LD_INT 4
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: PUSH
56782: LD_INT 30
56784: PUSH
56785: LD_INT 5
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: LIST
56796: PPUSH
56797: CALL_OW 72
56801: PUSH
56802: LD_INT 6
56804: MUL
56805: PLUS
56806: ST_TO_ADDR
// if bcount < tmp then
56807: LD_VAR 0 13
56811: PUSH
56812: LD_VAR 0 4
56816: LESS
56817: IFFALSE 56863
// for i = tmp downto bcount do
56819: LD_ADDR_VAR 0 3
56823: PUSH
56824: DOUBLE
56825: LD_VAR 0 4
56829: INC
56830: ST_TO_ADDR
56831: LD_VAR 0 13
56835: PUSH
56836: FOR_DOWNTO
56837: IFFALSE 56861
// tmp := Delete ( tmp , tmp ) ;
56839: LD_ADDR_VAR 0 4
56843: PUSH
56844: LD_VAR 0 4
56848: PPUSH
56849: LD_VAR 0 4
56853: PPUSH
56854: CALL_OW 3
56858: ST_TO_ADDR
56859: GO 56836
56861: POP
56862: POP
// result := [ tmp , 0 , 0 , p ] ;
56863: LD_ADDR_VAR 0 2
56867: PUSH
56868: LD_VAR 0 4
56872: PUSH
56873: LD_INT 0
56875: PUSH
56876: LD_INT 0
56878: PUSH
56879: LD_VAR 0 11
56883: PUSH
56884: EMPTY
56885: LIST
56886: LIST
56887: LIST
56888: LIST
56889: ST_TO_ADDR
// exit ;
56890: GO 59580
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56892: LD_EXP 43
56896: PUSH
56897: LD_VAR 0 1
56901: ARRAY
56902: PPUSH
56903: LD_INT 2
56905: PUSH
56906: LD_INT 30
56908: PUSH
56909: LD_INT 6
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PUSH
56916: LD_INT 30
56918: PUSH
56919: LD_INT 7
56921: PUSH
56922: EMPTY
56923: LIST
56924: LIST
56925: PUSH
56926: LD_INT 30
56928: PUSH
56929: LD_INT 8
56931: PUSH
56932: EMPTY
56933: LIST
56934: LIST
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: LIST
56940: LIST
56941: PPUSH
56942: CALL_OW 72
56946: NOT
56947: PUSH
56948: LD_EXP 43
56952: PUSH
56953: LD_VAR 0 1
56957: ARRAY
56958: PPUSH
56959: LD_INT 30
56961: PUSH
56962: LD_INT 3
56964: PUSH
56965: EMPTY
56966: LIST
56967: LIST
56968: PPUSH
56969: CALL_OW 72
56973: NOT
56974: AND
56975: IFFALSE 57047
// begin if eng = tmp then
56977: LD_VAR 0 6
56981: PUSH
56982: LD_VAR 0 4
56986: EQUAL
56987: IFFALSE 56991
// exit ;
56989: GO 59580
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56991: LD_ADDR_EXP 85
56995: PUSH
56996: LD_EXP 85
57000: PPUSH
57001: LD_VAR 0 1
57005: PPUSH
57006: LD_INT 1
57008: PPUSH
57009: CALL_OW 1
57013: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57014: LD_ADDR_VAR 0 2
57018: PUSH
57019: LD_INT 0
57021: PUSH
57022: LD_VAR 0 4
57026: PUSH
57027: LD_VAR 0 6
57031: DIFF
57032: PUSH
57033: LD_INT 0
57035: PUSH
57036: LD_INT 0
57038: PUSH
57039: EMPTY
57040: LIST
57041: LIST
57042: LIST
57043: LIST
57044: ST_TO_ADDR
// exit ;
57045: GO 59580
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57047: LD_EXP 70
57051: PUSH
57052: LD_EXP 69
57056: PUSH
57057: LD_VAR 0 1
57061: ARRAY
57062: ARRAY
57063: PUSH
57064: LD_EXP 43
57068: PUSH
57069: LD_VAR 0 1
57073: ARRAY
57074: PPUSH
57075: LD_INT 2
57077: PUSH
57078: LD_INT 30
57080: PUSH
57081: LD_INT 6
57083: PUSH
57084: EMPTY
57085: LIST
57086: LIST
57087: PUSH
57088: LD_INT 30
57090: PUSH
57091: LD_INT 7
57093: PUSH
57094: EMPTY
57095: LIST
57096: LIST
57097: PUSH
57098: LD_INT 30
57100: PUSH
57101: LD_INT 8
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: LIST
57112: LIST
57113: PPUSH
57114: CALL_OW 72
57118: AND
57119: PUSH
57120: LD_EXP 43
57124: PUSH
57125: LD_VAR 0 1
57129: ARRAY
57130: PPUSH
57131: LD_INT 30
57133: PUSH
57134: LD_INT 3
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PPUSH
57141: CALL_OW 72
57145: NOT
57146: AND
57147: IFFALSE 57361
// begin if sci >= 6 then
57149: LD_VAR 0 8
57153: PUSH
57154: LD_INT 6
57156: GREATEREQUAL
57157: IFFALSE 57161
// exit ;
57159: GO 59580
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57161: LD_ADDR_EXP 85
57165: PUSH
57166: LD_EXP 85
57170: PPUSH
57171: LD_VAR 0 1
57175: PPUSH
57176: LD_INT 2
57178: PPUSH
57179: CALL_OW 1
57183: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57184: LD_ADDR_VAR 0 9
57188: PUSH
57189: LD_VAR 0 4
57193: PUSH
57194: LD_VAR 0 8
57198: DIFF
57199: PPUSH
57200: LD_INT 4
57202: PPUSH
57203: CALL 45764 0 2
57207: ST_TO_ADDR
// p := [ ] ;
57208: LD_ADDR_VAR 0 11
57212: PUSH
57213: EMPTY
57214: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57215: LD_VAR 0 8
57219: PUSH
57220: LD_INT 6
57222: LESS
57223: PUSH
57224: LD_VAR 0 9
57228: PUSH
57229: LD_INT 6
57231: GREATER
57232: AND
57233: IFFALSE 57314
// begin for i = 1 to 6 - sci do
57235: LD_ADDR_VAR 0 3
57239: PUSH
57240: DOUBLE
57241: LD_INT 1
57243: DEC
57244: ST_TO_ADDR
57245: LD_INT 6
57247: PUSH
57248: LD_VAR 0 8
57252: MINUS
57253: PUSH
57254: FOR_TO
57255: IFFALSE 57310
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57257: LD_ADDR_VAR 0 11
57261: PUSH
57262: LD_VAR 0 11
57266: PPUSH
57267: LD_VAR 0 11
57271: PUSH
57272: LD_INT 1
57274: PLUS
57275: PPUSH
57276: LD_VAR 0 9
57280: PUSH
57281: LD_INT 1
57283: ARRAY
57284: PPUSH
57285: CALL_OW 2
57289: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57290: LD_ADDR_VAR 0 9
57294: PUSH
57295: LD_VAR 0 9
57299: PPUSH
57300: LD_INT 1
57302: PPUSH
57303: CALL_OW 3
57307: ST_TO_ADDR
// end ;
57308: GO 57254
57310: POP
57311: POP
// end else
57312: GO 57334
// if sort then
57314: LD_VAR 0 9
57318: IFFALSE 57334
// p := sort [ 1 ] ;
57320: LD_ADDR_VAR 0 11
57324: PUSH
57325: LD_VAR 0 9
57329: PUSH
57330: LD_INT 1
57332: ARRAY
57333: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57334: LD_ADDR_VAR 0 2
57338: PUSH
57339: LD_INT 0
57341: PUSH
57342: LD_INT 0
57344: PUSH
57345: LD_INT 0
57347: PUSH
57348: LD_VAR 0 11
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: LIST
57357: LIST
57358: ST_TO_ADDR
// exit ;
57359: GO 59580
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57361: LD_EXP 70
57365: PUSH
57366: LD_EXP 69
57370: PUSH
57371: LD_VAR 0 1
57375: ARRAY
57376: ARRAY
57377: PUSH
57378: LD_EXP 43
57382: PUSH
57383: LD_VAR 0 1
57387: ARRAY
57388: PPUSH
57389: LD_INT 2
57391: PUSH
57392: LD_INT 30
57394: PUSH
57395: LD_INT 6
57397: PUSH
57398: EMPTY
57399: LIST
57400: LIST
57401: PUSH
57402: LD_INT 30
57404: PUSH
57405: LD_INT 7
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: PUSH
57412: LD_INT 30
57414: PUSH
57415: LD_INT 8
57417: PUSH
57418: EMPTY
57419: LIST
57420: LIST
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: LIST
57426: LIST
57427: PPUSH
57428: CALL_OW 72
57432: AND
57433: PUSH
57434: LD_EXP 43
57438: PUSH
57439: LD_VAR 0 1
57443: ARRAY
57444: PPUSH
57445: LD_INT 30
57447: PUSH
57448: LD_INT 3
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: PPUSH
57455: CALL_OW 72
57459: AND
57460: IFFALSE 58194
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57462: LD_ADDR_EXP 85
57466: PUSH
57467: LD_EXP 85
57471: PPUSH
57472: LD_VAR 0 1
57476: PPUSH
57477: LD_INT 3
57479: PPUSH
57480: CALL_OW 1
57484: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57485: LD_ADDR_VAR 0 2
57489: PUSH
57490: LD_INT 0
57492: PUSH
57493: LD_INT 0
57495: PUSH
57496: LD_INT 0
57498: PUSH
57499: LD_INT 0
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: LIST
57506: LIST
57507: ST_TO_ADDR
// if not eng then
57508: LD_VAR 0 6
57512: NOT
57513: IFFALSE 57576
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57515: LD_ADDR_VAR 0 11
57519: PUSH
57520: LD_VAR 0 4
57524: PPUSH
57525: LD_INT 2
57527: PPUSH
57528: CALL 45764 0 2
57532: PUSH
57533: LD_INT 1
57535: ARRAY
57536: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57537: LD_ADDR_VAR 0 2
57541: PUSH
57542: LD_VAR 0 2
57546: PPUSH
57547: LD_INT 2
57549: PPUSH
57550: LD_VAR 0 11
57554: PPUSH
57555: CALL_OW 1
57559: ST_TO_ADDR
// tmp := tmp diff p ;
57560: LD_ADDR_VAR 0 4
57564: PUSH
57565: LD_VAR 0 4
57569: PUSH
57570: LD_VAR 0 11
57574: DIFF
57575: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57576: LD_VAR 0 4
57580: PUSH
57581: LD_VAR 0 8
57585: PUSH
57586: LD_INT 6
57588: LESS
57589: AND
57590: IFFALSE 57778
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57592: LD_ADDR_VAR 0 9
57596: PUSH
57597: LD_VAR 0 4
57601: PUSH
57602: LD_VAR 0 8
57606: PUSH
57607: LD_VAR 0 7
57611: UNION
57612: DIFF
57613: PPUSH
57614: LD_INT 4
57616: PPUSH
57617: CALL 45764 0 2
57621: ST_TO_ADDR
// p := [ ] ;
57622: LD_ADDR_VAR 0 11
57626: PUSH
57627: EMPTY
57628: ST_TO_ADDR
// if sort then
57629: LD_VAR 0 9
57633: IFFALSE 57749
// for i = 1 to 6 - sci do
57635: LD_ADDR_VAR 0 3
57639: PUSH
57640: DOUBLE
57641: LD_INT 1
57643: DEC
57644: ST_TO_ADDR
57645: LD_INT 6
57647: PUSH
57648: LD_VAR 0 8
57652: MINUS
57653: PUSH
57654: FOR_TO
57655: IFFALSE 57747
// begin if i = sort then
57657: LD_VAR 0 3
57661: PUSH
57662: LD_VAR 0 9
57666: EQUAL
57667: IFFALSE 57671
// break ;
57669: GO 57747
// if GetClass ( i ) = 4 then
57671: LD_VAR 0 3
57675: PPUSH
57676: CALL_OW 257
57680: PUSH
57681: LD_INT 4
57683: EQUAL
57684: IFFALSE 57688
// continue ;
57686: GO 57654
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57688: LD_ADDR_VAR 0 11
57692: PUSH
57693: LD_VAR 0 11
57697: PPUSH
57698: LD_VAR 0 11
57702: PUSH
57703: LD_INT 1
57705: PLUS
57706: PPUSH
57707: LD_VAR 0 9
57711: PUSH
57712: LD_VAR 0 3
57716: ARRAY
57717: PPUSH
57718: CALL_OW 2
57722: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57723: LD_ADDR_VAR 0 4
57727: PUSH
57728: LD_VAR 0 4
57732: PUSH
57733: LD_VAR 0 9
57737: PUSH
57738: LD_VAR 0 3
57742: ARRAY
57743: DIFF
57744: ST_TO_ADDR
// end ;
57745: GO 57654
57747: POP
57748: POP
// if p then
57749: LD_VAR 0 11
57753: IFFALSE 57778
// result := Replace ( result , 4 , p ) ;
57755: LD_ADDR_VAR 0 2
57759: PUSH
57760: LD_VAR 0 2
57764: PPUSH
57765: LD_INT 4
57767: PPUSH
57768: LD_VAR 0 11
57772: PPUSH
57773: CALL_OW 1
57777: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57778: LD_VAR 0 4
57782: PUSH
57783: LD_VAR 0 7
57787: PUSH
57788: LD_INT 6
57790: LESS
57791: AND
57792: IFFALSE 57980
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57794: LD_ADDR_VAR 0 9
57798: PUSH
57799: LD_VAR 0 4
57803: PUSH
57804: LD_VAR 0 8
57808: PUSH
57809: LD_VAR 0 7
57813: UNION
57814: DIFF
57815: PPUSH
57816: LD_INT 3
57818: PPUSH
57819: CALL 45764 0 2
57823: ST_TO_ADDR
// p := [ ] ;
57824: LD_ADDR_VAR 0 11
57828: PUSH
57829: EMPTY
57830: ST_TO_ADDR
// if sort then
57831: LD_VAR 0 9
57835: IFFALSE 57951
// for i = 1 to 6 - mech do
57837: LD_ADDR_VAR 0 3
57841: PUSH
57842: DOUBLE
57843: LD_INT 1
57845: DEC
57846: ST_TO_ADDR
57847: LD_INT 6
57849: PUSH
57850: LD_VAR 0 7
57854: MINUS
57855: PUSH
57856: FOR_TO
57857: IFFALSE 57949
// begin if i = sort then
57859: LD_VAR 0 3
57863: PUSH
57864: LD_VAR 0 9
57868: EQUAL
57869: IFFALSE 57873
// break ;
57871: GO 57949
// if GetClass ( i ) = 3 then
57873: LD_VAR 0 3
57877: PPUSH
57878: CALL_OW 257
57882: PUSH
57883: LD_INT 3
57885: EQUAL
57886: IFFALSE 57890
// continue ;
57888: GO 57856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57890: LD_ADDR_VAR 0 11
57894: PUSH
57895: LD_VAR 0 11
57899: PPUSH
57900: LD_VAR 0 11
57904: PUSH
57905: LD_INT 1
57907: PLUS
57908: PPUSH
57909: LD_VAR 0 9
57913: PUSH
57914: LD_VAR 0 3
57918: ARRAY
57919: PPUSH
57920: CALL_OW 2
57924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57925: LD_ADDR_VAR 0 4
57929: PUSH
57930: LD_VAR 0 4
57934: PUSH
57935: LD_VAR 0 9
57939: PUSH
57940: LD_VAR 0 3
57944: ARRAY
57945: DIFF
57946: ST_TO_ADDR
// end ;
57947: GO 57856
57949: POP
57950: POP
// if p then
57951: LD_VAR 0 11
57955: IFFALSE 57980
// result := Replace ( result , 3 , p ) ;
57957: LD_ADDR_VAR 0 2
57961: PUSH
57962: LD_VAR 0 2
57966: PPUSH
57967: LD_INT 3
57969: PPUSH
57970: LD_VAR 0 11
57974: PPUSH
57975: CALL_OW 1
57979: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57980: LD_VAR 0 4
57984: PUSH
57985: LD_INT 6
57987: GREATER
57988: PUSH
57989: LD_VAR 0 6
57993: PUSH
57994: LD_INT 6
57996: LESS
57997: AND
57998: IFFALSE 58192
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58000: LD_ADDR_VAR 0 9
58004: PUSH
58005: LD_VAR 0 4
58009: PUSH
58010: LD_VAR 0 8
58014: PUSH
58015: LD_VAR 0 7
58019: UNION
58020: PUSH
58021: LD_VAR 0 6
58025: UNION
58026: DIFF
58027: PPUSH
58028: LD_INT 2
58030: PPUSH
58031: CALL 45764 0 2
58035: ST_TO_ADDR
// p := [ ] ;
58036: LD_ADDR_VAR 0 11
58040: PUSH
58041: EMPTY
58042: ST_TO_ADDR
// if sort then
58043: LD_VAR 0 9
58047: IFFALSE 58163
// for i = 1 to 6 - eng do
58049: LD_ADDR_VAR 0 3
58053: PUSH
58054: DOUBLE
58055: LD_INT 1
58057: DEC
58058: ST_TO_ADDR
58059: LD_INT 6
58061: PUSH
58062: LD_VAR 0 6
58066: MINUS
58067: PUSH
58068: FOR_TO
58069: IFFALSE 58161
// begin if i = sort then
58071: LD_VAR 0 3
58075: PUSH
58076: LD_VAR 0 9
58080: EQUAL
58081: IFFALSE 58085
// break ;
58083: GO 58161
// if GetClass ( i ) = 2 then
58085: LD_VAR 0 3
58089: PPUSH
58090: CALL_OW 257
58094: PUSH
58095: LD_INT 2
58097: EQUAL
58098: IFFALSE 58102
// continue ;
58100: GO 58068
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58102: LD_ADDR_VAR 0 11
58106: PUSH
58107: LD_VAR 0 11
58111: PPUSH
58112: LD_VAR 0 11
58116: PUSH
58117: LD_INT 1
58119: PLUS
58120: PPUSH
58121: LD_VAR 0 9
58125: PUSH
58126: LD_VAR 0 3
58130: ARRAY
58131: PPUSH
58132: CALL_OW 2
58136: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58137: LD_ADDR_VAR 0 4
58141: PUSH
58142: LD_VAR 0 4
58146: PUSH
58147: LD_VAR 0 9
58151: PUSH
58152: LD_VAR 0 3
58156: ARRAY
58157: DIFF
58158: ST_TO_ADDR
// end ;
58159: GO 58068
58161: POP
58162: POP
// if p then
58163: LD_VAR 0 11
58167: IFFALSE 58192
// result := Replace ( result , 2 , p ) ;
58169: LD_ADDR_VAR 0 2
58173: PUSH
58174: LD_VAR 0 2
58178: PPUSH
58179: LD_INT 2
58181: PPUSH
58182: LD_VAR 0 11
58186: PPUSH
58187: CALL_OW 1
58191: ST_TO_ADDR
// end ; exit ;
58192: GO 59580
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58194: LD_EXP 70
58198: PUSH
58199: LD_EXP 69
58203: PUSH
58204: LD_VAR 0 1
58208: ARRAY
58209: ARRAY
58210: NOT
58211: PUSH
58212: LD_EXP 43
58216: PUSH
58217: LD_VAR 0 1
58221: ARRAY
58222: PPUSH
58223: LD_INT 30
58225: PUSH
58226: LD_INT 3
58228: PUSH
58229: EMPTY
58230: LIST
58231: LIST
58232: PPUSH
58233: CALL_OW 72
58237: AND
58238: PUSH
58239: LD_EXP 48
58243: PUSH
58244: LD_VAR 0 1
58248: ARRAY
58249: AND
58250: IFFALSE 58858
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58252: LD_ADDR_EXP 85
58256: PUSH
58257: LD_EXP 85
58261: PPUSH
58262: LD_VAR 0 1
58266: PPUSH
58267: LD_INT 5
58269: PPUSH
58270: CALL_OW 1
58274: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58275: LD_ADDR_VAR 0 2
58279: PUSH
58280: LD_INT 0
58282: PUSH
58283: LD_INT 0
58285: PUSH
58286: LD_INT 0
58288: PUSH
58289: LD_INT 0
58291: PUSH
58292: EMPTY
58293: LIST
58294: LIST
58295: LIST
58296: LIST
58297: ST_TO_ADDR
// if sci > 1 then
58298: LD_VAR 0 8
58302: PUSH
58303: LD_INT 1
58305: GREATER
58306: IFFALSE 58334
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58308: LD_ADDR_VAR 0 4
58312: PUSH
58313: LD_VAR 0 4
58317: PUSH
58318: LD_VAR 0 8
58322: PUSH
58323: LD_VAR 0 8
58327: PUSH
58328: LD_INT 1
58330: ARRAY
58331: DIFF
58332: DIFF
58333: ST_TO_ADDR
// if tmp and not sci then
58334: LD_VAR 0 4
58338: PUSH
58339: LD_VAR 0 8
58343: NOT
58344: AND
58345: IFFALSE 58414
// begin sort := SortBySkill ( tmp , 4 ) ;
58347: LD_ADDR_VAR 0 9
58351: PUSH
58352: LD_VAR 0 4
58356: PPUSH
58357: LD_INT 4
58359: PPUSH
58360: CALL 45764 0 2
58364: ST_TO_ADDR
// if sort then
58365: LD_VAR 0 9
58369: IFFALSE 58385
// p := sort [ 1 ] ;
58371: LD_ADDR_VAR 0 11
58375: PUSH
58376: LD_VAR 0 9
58380: PUSH
58381: LD_INT 1
58383: ARRAY
58384: ST_TO_ADDR
// if p then
58385: LD_VAR 0 11
58389: IFFALSE 58414
// result := Replace ( result , 4 , p ) ;
58391: LD_ADDR_VAR 0 2
58395: PUSH
58396: LD_VAR 0 2
58400: PPUSH
58401: LD_INT 4
58403: PPUSH
58404: LD_VAR 0 11
58408: PPUSH
58409: CALL_OW 1
58413: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58414: LD_ADDR_VAR 0 4
58418: PUSH
58419: LD_VAR 0 4
58423: PUSH
58424: LD_VAR 0 7
58428: DIFF
58429: ST_TO_ADDR
// if tmp and mech < 6 then
58430: LD_VAR 0 4
58434: PUSH
58435: LD_VAR 0 7
58439: PUSH
58440: LD_INT 6
58442: LESS
58443: AND
58444: IFFALSE 58632
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58446: LD_ADDR_VAR 0 9
58450: PUSH
58451: LD_VAR 0 4
58455: PUSH
58456: LD_VAR 0 8
58460: PUSH
58461: LD_VAR 0 7
58465: UNION
58466: DIFF
58467: PPUSH
58468: LD_INT 3
58470: PPUSH
58471: CALL 45764 0 2
58475: ST_TO_ADDR
// p := [ ] ;
58476: LD_ADDR_VAR 0 11
58480: PUSH
58481: EMPTY
58482: ST_TO_ADDR
// if sort then
58483: LD_VAR 0 9
58487: IFFALSE 58603
// for i = 1 to 6 - mech do
58489: LD_ADDR_VAR 0 3
58493: PUSH
58494: DOUBLE
58495: LD_INT 1
58497: DEC
58498: ST_TO_ADDR
58499: LD_INT 6
58501: PUSH
58502: LD_VAR 0 7
58506: MINUS
58507: PUSH
58508: FOR_TO
58509: IFFALSE 58601
// begin if i = sort then
58511: LD_VAR 0 3
58515: PUSH
58516: LD_VAR 0 9
58520: EQUAL
58521: IFFALSE 58525
// break ;
58523: GO 58601
// if GetClass ( i ) = 3 then
58525: LD_VAR 0 3
58529: PPUSH
58530: CALL_OW 257
58534: PUSH
58535: LD_INT 3
58537: EQUAL
58538: IFFALSE 58542
// continue ;
58540: GO 58508
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58542: LD_ADDR_VAR 0 11
58546: PUSH
58547: LD_VAR 0 11
58551: PPUSH
58552: LD_VAR 0 11
58556: PUSH
58557: LD_INT 1
58559: PLUS
58560: PPUSH
58561: LD_VAR 0 9
58565: PUSH
58566: LD_VAR 0 3
58570: ARRAY
58571: PPUSH
58572: CALL_OW 2
58576: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58577: LD_ADDR_VAR 0 4
58581: PUSH
58582: LD_VAR 0 4
58586: PUSH
58587: LD_VAR 0 9
58591: PUSH
58592: LD_VAR 0 3
58596: ARRAY
58597: DIFF
58598: ST_TO_ADDR
// end ;
58599: GO 58508
58601: POP
58602: POP
// if p then
58603: LD_VAR 0 11
58607: IFFALSE 58632
// result := Replace ( result , 3 , p ) ;
58609: LD_ADDR_VAR 0 2
58613: PUSH
58614: LD_VAR 0 2
58618: PPUSH
58619: LD_INT 3
58621: PPUSH
58622: LD_VAR 0 11
58626: PPUSH
58627: CALL_OW 1
58631: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58632: LD_ADDR_VAR 0 4
58636: PUSH
58637: LD_VAR 0 4
58641: PUSH
58642: LD_VAR 0 6
58646: DIFF
58647: ST_TO_ADDR
// if tmp and eng < 6 then
58648: LD_VAR 0 4
58652: PUSH
58653: LD_VAR 0 6
58657: PUSH
58658: LD_INT 6
58660: LESS
58661: AND
58662: IFFALSE 58856
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58664: LD_ADDR_VAR 0 9
58668: PUSH
58669: LD_VAR 0 4
58673: PUSH
58674: LD_VAR 0 8
58678: PUSH
58679: LD_VAR 0 7
58683: UNION
58684: PUSH
58685: LD_VAR 0 6
58689: UNION
58690: DIFF
58691: PPUSH
58692: LD_INT 2
58694: PPUSH
58695: CALL 45764 0 2
58699: ST_TO_ADDR
// p := [ ] ;
58700: LD_ADDR_VAR 0 11
58704: PUSH
58705: EMPTY
58706: ST_TO_ADDR
// if sort then
58707: LD_VAR 0 9
58711: IFFALSE 58827
// for i = 1 to 6 - eng do
58713: LD_ADDR_VAR 0 3
58717: PUSH
58718: DOUBLE
58719: LD_INT 1
58721: DEC
58722: ST_TO_ADDR
58723: LD_INT 6
58725: PUSH
58726: LD_VAR 0 6
58730: MINUS
58731: PUSH
58732: FOR_TO
58733: IFFALSE 58825
// begin if i = sort then
58735: LD_VAR 0 3
58739: PUSH
58740: LD_VAR 0 9
58744: EQUAL
58745: IFFALSE 58749
// break ;
58747: GO 58825
// if GetClass ( i ) = 2 then
58749: LD_VAR 0 3
58753: PPUSH
58754: CALL_OW 257
58758: PUSH
58759: LD_INT 2
58761: EQUAL
58762: IFFALSE 58766
// continue ;
58764: GO 58732
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58766: LD_ADDR_VAR 0 11
58770: PUSH
58771: LD_VAR 0 11
58775: PPUSH
58776: LD_VAR 0 11
58780: PUSH
58781: LD_INT 1
58783: PLUS
58784: PPUSH
58785: LD_VAR 0 9
58789: PUSH
58790: LD_VAR 0 3
58794: ARRAY
58795: PPUSH
58796: CALL_OW 2
58800: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58801: LD_ADDR_VAR 0 4
58805: PUSH
58806: LD_VAR 0 4
58810: PUSH
58811: LD_VAR 0 9
58815: PUSH
58816: LD_VAR 0 3
58820: ARRAY
58821: DIFF
58822: ST_TO_ADDR
// end ;
58823: GO 58732
58825: POP
58826: POP
// if p then
58827: LD_VAR 0 11
58831: IFFALSE 58856
// result := Replace ( result , 2 , p ) ;
58833: LD_ADDR_VAR 0 2
58837: PUSH
58838: LD_VAR 0 2
58842: PPUSH
58843: LD_INT 2
58845: PPUSH
58846: LD_VAR 0 11
58850: PPUSH
58851: CALL_OW 1
58855: ST_TO_ADDR
// end ; exit ;
58856: GO 59580
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58858: LD_EXP 70
58862: PUSH
58863: LD_EXP 69
58867: PUSH
58868: LD_VAR 0 1
58872: ARRAY
58873: ARRAY
58874: NOT
58875: PUSH
58876: LD_EXP 43
58880: PUSH
58881: LD_VAR 0 1
58885: ARRAY
58886: PPUSH
58887: LD_INT 30
58889: PUSH
58890: LD_INT 3
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: PPUSH
58897: CALL_OW 72
58901: AND
58902: PUSH
58903: LD_EXP 48
58907: PUSH
58908: LD_VAR 0 1
58912: ARRAY
58913: NOT
58914: AND
58915: IFFALSE 59580
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58917: LD_ADDR_EXP 85
58921: PUSH
58922: LD_EXP 85
58926: PPUSH
58927: LD_VAR 0 1
58931: PPUSH
58932: LD_INT 6
58934: PPUSH
58935: CALL_OW 1
58939: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58940: LD_ADDR_VAR 0 2
58944: PUSH
58945: LD_INT 0
58947: PUSH
58948: LD_INT 0
58950: PUSH
58951: LD_INT 0
58953: PUSH
58954: LD_INT 0
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: LIST
58961: LIST
58962: ST_TO_ADDR
// if sci >= 1 then
58963: LD_VAR 0 8
58967: PUSH
58968: LD_INT 1
58970: GREATEREQUAL
58971: IFFALSE 58993
// tmp := tmp diff sci [ 1 ] ;
58973: LD_ADDR_VAR 0 4
58977: PUSH
58978: LD_VAR 0 4
58982: PUSH
58983: LD_VAR 0 8
58987: PUSH
58988: LD_INT 1
58990: ARRAY
58991: DIFF
58992: ST_TO_ADDR
// if tmp and not sci then
58993: LD_VAR 0 4
58997: PUSH
58998: LD_VAR 0 8
59002: NOT
59003: AND
59004: IFFALSE 59073
// begin sort := SortBySkill ( tmp , 4 ) ;
59006: LD_ADDR_VAR 0 9
59010: PUSH
59011: LD_VAR 0 4
59015: PPUSH
59016: LD_INT 4
59018: PPUSH
59019: CALL 45764 0 2
59023: ST_TO_ADDR
// if sort then
59024: LD_VAR 0 9
59028: IFFALSE 59044
// p := sort [ 1 ] ;
59030: LD_ADDR_VAR 0 11
59034: PUSH
59035: LD_VAR 0 9
59039: PUSH
59040: LD_INT 1
59042: ARRAY
59043: ST_TO_ADDR
// if p then
59044: LD_VAR 0 11
59048: IFFALSE 59073
// result := Replace ( result , 4 , p ) ;
59050: LD_ADDR_VAR 0 2
59054: PUSH
59055: LD_VAR 0 2
59059: PPUSH
59060: LD_INT 4
59062: PPUSH
59063: LD_VAR 0 11
59067: PPUSH
59068: CALL_OW 1
59072: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59073: LD_ADDR_VAR 0 4
59077: PUSH
59078: LD_VAR 0 4
59082: PUSH
59083: LD_VAR 0 7
59087: DIFF
59088: ST_TO_ADDR
// if tmp and mech < 6 then
59089: LD_VAR 0 4
59093: PUSH
59094: LD_VAR 0 7
59098: PUSH
59099: LD_INT 6
59101: LESS
59102: AND
59103: IFFALSE 59285
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59105: LD_ADDR_VAR 0 9
59109: PUSH
59110: LD_VAR 0 4
59114: PUSH
59115: LD_VAR 0 7
59119: DIFF
59120: PPUSH
59121: LD_INT 3
59123: PPUSH
59124: CALL 45764 0 2
59128: ST_TO_ADDR
// p := [ ] ;
59129: LD_ADDR_VAR 0 11
59133: PUSH
59134: EMPTY
59135: ST_TO_ADDR
// if sort then
59136: LD_VAR 0 9
59140: IFFALSE 59256
// for i = 1 to 6 - mech do
59142: LD_ADDR_VAR 0 3
59146: PUSH
59147: DOUBLE
59148: LD_INT 1
59150: DEC
59151: ST_TO_ADDR
59152: LD_INT 6
59154: PUSH
59155: LD_VAR 0 7
59159: MINUS
59160: PUSH
59161: FOR_TO
59162: IFFALSE 59254
// begin if i = sort then
59164: LD_VAR 0 3
59168: PUSH
59169: LD_VAR 0 9
59173: EQUAL
59174: IFFALSE 59178
// break ;
59176: GO 59254
// if GetClass ( i ) = 3 then
59178: LD_VAR 0 3
59182: PPUSH
59183: CALL_OW 257
59187: PUSH
59188: LD_INT 3
59190: EQUAL
59191: IFFALSE 59195
// continue ;
59193: GO 59161
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59195: LD_ADDR_VAR 0 11
59199: PUSH
59200: LD_VAR 0 11
59204: PPUSH
59205: LD_VAR 0 11
59209: PUSH
59210: LD_INT 1
59212: PLUS
59213: PPUSH
59214: LD_VAR 0 9
59218: PUSH
59219: LD_VAR 0 3
59223: ARRAY
59224: PPUSH
59225: CALL_OW 2
59229: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59230: LD_ADDR_VAR 0 4
59234: PUSH
59235: LD_VAR 0 4
59239: PUSH
59240: LD_VAR 0 9
59244: PUSH
59245: LD_VAR 0 3
59249: ARRAY
59250: DIFF
59251: ST_TO_ADDR
// end ;
59252: GO 59161
59254: POP
59255: POP
// if p then
59256: LD_VAR 0 11
59260: IFFALSE 59285
// result := Replace ( result , 3 , p ) ;
59262: LD_ADDR_VAR 0 2
59266: PUSH
59267: LD_VAR 0 2
59271: PPUSH
59272: LD_INT 3
59274: PPUSH
59275: LD_VAR 0 11
59279: PPUSH
59280: CALL_OW 1
59284: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59285: LD_ADDR_VAR 0 4
59289: PUSH
59290: LD_VAR 0 4
59294: PUSH
59295: LD_VAR 0 6
59299: DIFF
59300: ST_TO_ADDR
// if tmp and eng < 4 then
59301: LD_VAR 0 4
59305: PUSH
59306: LD_VAR 0 6
59310: PUSH
59311: LD_INT 4
59313: LESS
59314: AND
59315: IFFALSE 59505
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59317: LD_ADDR_VAR 0 9
59321: PUSH
59322: LD_VAR 0 4
59326: PUSH
59327: LD_VAR 0 7
59331: PUSH
59332: LD_VAR 0 6
59336: UNION
59337: DIFF
59338: PPUSH
59339: LD_INT 2
59341: PPUSH
59342: CALL 45764 0 2
59346: ST_TO_ADDR
// p := [ ] ;
59347: LD_ADDR_VAR 0 11
59351: PUSH
59352: EMPTY
59353: ST_TO_ADDR
// if sort then
59354: LD_VAR 0 9
59358: IFFALSE 59474
// for i = 1 to 4 - eng do
59360: LD_ADDR_VAR 0 3
59364: PUSH
59365: DOUBLE
59366: LD_INT 1
59368: DEC
59369: ST_TO_ADDR
59370: LD_INT 4
59372: PUSH
59373: LD_VAR 0 6
59377: MINUS
59378: PUSH
59379: FOR_TO
59380: IFFALSE 59472
// begin if i = sort then
59382: LD_VAR 0 3
59386: PUSH
59387: LD_VAR 0 9
59391: EQUAL
59392: IFFALSE 59396
// break ;
59394: GO 59472
// if GetClass ( i ) = 2 then
59396: LD_VAR 0 3
59400: PPUSH
59401: CALL_OW 257
59405: PUSH
59406: LD_INT 2
59408: EQUAL
59409: IFFALSE 59413
// continue ;
59411: GO 59379
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59413: LD_ADDR_VAR 0 11
59417: PUSH
59418: LD_VAR 0 11
59422: PPUSH
59423: LD_VAR 0 11
59427: PUSH
59428: LD_INT 1
59430: PLUS
59431: PPUSH
59432: LD_VAR 0 9
59436: PUSH
59437: LD_VAR 0 3
59441: ARRAY
59442: PPUSH
59443: CALL_OW 2
59447: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59448: LD_ADDR_VAR 0 4
59452: PUSH
59453: LD_VAR 0 4
59457: PUSH
59458: LD_VAR 0 9
59462: PUSH
59463: LD_VAR 0 3
59467: ARRAY
59468: DIFF
59469: ST_TO_ADDR
// end ;
59470: GO 59379
59472: POP
59473: POP
// if p then
59474: LD_VAR 0 11
59478: IFFALSE 59503
// result := Replace ( result , 2 , p ) ;
59480: LD_ADDR_VAR 0 2
59484: PUSH
59485: LD_VAR 0 2
59489: PPUSH
59490: LD_INT 2
59492: PPUSH
59493: LD_VAR 0 11
59497: PPUSH
59498: CALL_OW 1
59502: ST_TO_ADDR
// end else
59503: GO 59549
// for i = eng downto 5 do
59505: LD_ADDR_VAR 0 3
59509: PUSH
59510: DOUBLE
59511: LD_VAR 0 6
59515: INC
59516: ST_TO_ADDR
59517: LD_INT 5
59519: PUSH
59520: FOR_DOWNTO
59521: IFFALSE 59547
// tmp := tmp union eng [ i ] ;
59523: LD_ADDR_VAR 0 4
59527: PUSH
59528: LD_VAR 0 4
59532: PUSH
59533: LD_VAR 0 6
59537: PUSH
59538: LD_VAR 0 3
59542: ARRAY
59543: UNION
59544: ST_TO_ADDR
59545: GO 59520
59547: POP
59548: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59549: LD_ADDR_VAR 0 2
59553: PUSH
59554: LD_VAR 0 2
59558: PPUSH
59559: LD_INT 1
59561: PPUSH
59562: LD_VAR 0 4
59566: PUSH
59567: LD_VAR 0 5
59571: DIFF
59572: PPUSH
59573: CALL_OW 1
59577: ST_TO_ADDR
// exit ;
59578: GO 59580
// end ; end ;
59580: LD_VAR 0 2
59584: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59585: LD_INT 0
59587: PPUSH
59588: PPUSH
59589: PPUSH
// if not mc_bases then
59590: LD_EXP 43
59594: NOT
59595: IFFALSE 59599
// exit ;
59597: GO 59741
// for i = 1 to mc_bases do
59599: LD_ADDR_VAR 0 2
59603: PUSH
59604: DOUBLE
59605: LD_INT 1
59607: DEC
59608: ST_TO_ADDR
59609: LD_EXP 43
59613: PUSH
59614: FOR_TO
59615: IFFALSE 59732
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59617: LD_ADDR_VAR 0 3
59621: PUSH
59622: LD_EXP 43
59626: PUSH
59627: LD_VAR 0 2
59631: ARRAY
59632: PPUSH
59633: LD_INT 21
59635: PUSH
59636: LD_INT 3
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: LD_INT 3
59645: PUSH
59646: LD_INT 2
59648: PUSH
59649: LD_INT 30
59651: PUSH
59652: LD_INT 29
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: PUSH
59659: LD_INT 30
59661: PUSH
59662: LD_INT 30
59664: PUSH
59665: EMPTY
59666: LIST
59667: LIST
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: LIST
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: PUSH
59678: LD_INT 3
59680: PUSH
59681: LD_INT 24
59683: PUSH
59684: LD_INT 1000
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: EMPTY
59696: LIST
59697: LIST
59698: LIST
59699: PPUSH
59700: CALL_OW 72
59704: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59705: LD_ADDR_EXP 44
59709: PUSH
59710: LD_EXP 44
59714: PPUSH
59715: LD_VAR 0 2
59719: PPUSH
59720: LD_VAR 0 3
59724: PPUSH
59725: CALL_OW 1
59729: ST_TO_ADDR
// end ;
59730: GO 59614
59732: POP
59733: POP
// RaiseSailEvent ( 101 ) ;
59734: LD_INT 101
59736: PPUSH
59737: CALL_OW 427
// end ;
59741: LD_VAR 0 1
59745: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59746: LD_INT 0
59748: PPUSH
59749: PPUSH
59750: PPUSH
59751: PPUSH
59752: PPUSH
59753: PPUSH
59754: PPUSH
// if not mc_bases then
59755: LD_EXP 43
59759: NOT
59760: IFFALSE 59764
// exit ;
59762: GO 60326
// for i = 1 to mc_bases do
59764: LD_ADDR_VAR 0 2
59768: PUSH
59769: DOUBLE
59770: LD_INT 1
59772: DEC
59773: ST_TO_ADDR
59774: LD_EXP 43
59778: PUSH
59779: FOR_TO
59780: IFFALSE 60317
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59782: LD_ADDR_VAR 0 5
59786: PUSH
59787: LD_EXP 43
59791: PUSH
59792: LD_VAR 0 2
59796: ARRAY
59797: PUSH
59798: LD_EXP 72
59802: PUSH
59803: LD_VAR 0 2
59807: ARRAY
59808: UNION
59809: PPUSH
59810: LD_INT 21
59812: PUSH
59813: LD_INT 1
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: LD_INT 1
59822: PUSH
59823: LD_INT 3
59825: PUSH
59826: LD_INT 54
59828: PUSH
59829: EMPTY
59830: LIST
59831: PUSH
59832: EMPTY
59833: LIST
59834: LIST
59835: PUSH
59836: LD_INT 3
59838: PUSH
59839: LD_INT 24
59841: PUSH
59842: LD_INT 1000
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: EMPTY
59854: LIST
59855: LIST
59856: LIST
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: PPUSH
59862: CALL_OW 72
59866: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59867: LD_ADDR_VAR 0 6
59871: PUSH
59872: LD_EXP 43
59876: PUSH
59877: LD_VAR 0 2
59881: ARRAY
59882: PPUSH
59883: LD_INT 21
59885: PUSH
59886: LD_INT 1
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: PUSH
59893: LD_INT 1
59895: PUSH
59896: LD_INT 3
59898: PUSH
59899: LD_INT 54
59901: PUSH
59902: EMPTY
59903: LIST
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: LD_INT 3
59911: PUSH
59912: LD_INT 24
59914: PUSH
59915: LD_INT 250
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: LIST
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PPUSH
59935: CALL_OW 72
59939: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59940: LD_ADDR_VAR 0 7
59944: PUSH
59945: LD_VAR 0 5
59949: PUSH
59950: LD_VAR 0 6
59954: DIFF
59955: ST_TO_ADDR
// if not need_heal_1 then
59956: LD_VAR 0 6
59960: NOT
59961: IFFALSE 59994
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59963: LD_ADDR_EXP 46
59967: PUSH
59968: LD_EXP 46
59972: PPUSH
59973: LD_VAR 0 2
59977: PUSH
59978: LD_INT 1
59980: PUSH
59981: EMPTY
59982: LIST
59983: LIST
59984: PPUSH
59985: EMPTY
59986: PPUSH
59987: CALL 14917 0 3
59991: ST_TO_ADDR
59992: GO 60064
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59994: LD_ADDR_EXP 46
59998: PUSH
59999: LD_EXP 46
60003: PPUSH
60004: LD_VAR 0 2
60008: PUSH
60009: LD_INT 1
60011: PUSH
60012: EMPTY
60013: LIST
60014: LIST
60015: PPUSH
60016: LD_EXP 46
60020: PUSH
60021: LD_VAR 0 2
60025: ARRAY
60026: PUSH
60027: LD_INT 1
60029: ARRAY
60030: PPUSH
60031: LD_INT 3
60033: PUSH
60034: LD_INT 24
60036: PUSH
60037: LD_INT 1000
60039: PUSH
60040: EMPTY
60041: LIST
60042: LIST
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PPUSH
60048: CALL_OW 72
60052: PUSH
60053: LD_VAR 0 6
60057: UNION
60058: PPUSH
60059: CALL 14917 0 3
60063: ST_TO_ADDR
// if not need_heal_2 then
60064: LD_VAR 0 7
60068: NOT
60069: IFFALSE 60102
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60071: LD_ADDR_EXP 46
60075: PUSH
60076: LD_EXP 46
60080: PPUSH
60081: LD_VAR 0 2
60085: PUSH
60086: LD_INT 2
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PPUSH
60093: EMPTY
60094: PPUSH
60095: CALL 14917 0 3
60099: ST_TO_ADDR
60100: GO 60134
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60102: LD_ADDR_EXP 46
60106: PUSH
60107: LD_EXP 46
60111: PPUSH
60112: LD_VAR 0 2
60116: PUSH
60117: LD_INT 2
60119: PUSH
60120: EMPTY
60121: LIST
60122: LIST
60123: PPUSH
60124: LD_VAR 0 7
60128: PPUSH
60129: CALL 14917 0 3
60133: ST_TO_ADDR
// if need_heal_2 then
60134: LD_VAR 0 7
60138: IFFALSE 60299
// for j in need_heal_2 do
60140: LD_ADDR_VAR 0 3
60144: PUSH
60145: LD_VAR 0 7
60149: PUSH
60150: FOR_IN
60151: IFFALSE 60297
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60153: LD_ADDR_VAR 0 5
60157: PUSH
60158: LD_EXP 43
60162: PUSH
60163: LD_VAR 0 2
60167: ARRAY
60168: PPUSH
60169: LD_INT 2
60171: PUSH
60172: LD_INT 30
60174: PUSH
60175: LD_INT 6
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: PUSH
60182: LD_INT 30
60184: PUSH
60185: LD_INT 7
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 30
60194: PUSH
60195: LD_INT 8
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 30
60204: PUSH
60205: LD_INT 0
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 1
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: EMPTY
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: LIST
60228: LIST
60229: PPUSH
60230: CALL_OW 72
60234: ST_TO_ADDR
// if tmp then
60235: LD_VAR 0 5
60239: IFFALSE 60295
// begin k := NearestUnitToUnit ( tmp , j ) ;
60241: LD_ADDR_VAR 0 4
60245: PUSH
60246: LD_VAR 0 5
60250: PPUSH
60251: LD_VAR 0 3
60255: PPUSH
60256: CALL_OW 74
60260: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60261: LD_VAR 0 3
60265: PPUSH
60266: LD_VAR 0 4
60270: PPUSH
60271: CALL_OW 296
60275: PUSH
60276: LD_INT 5
60278: GREATER
60279: IFFALSE 60295
// ComMoveToNearbyEntrance ( j , k ) ;
60281: LD_VAR 0 3
60285: PPUSH
60286: LD_VAR 0 4
60290: PPUSH
60291: CALL 48124 0 2
// end ; end ;
60295: GO 60150
60297: POP
60298: POP
// if not need_heal_1 and not need_heal_2 then
60299: LD_VAR 0 6
60303: NOT
60304: PUSH
60305: LD_VAR 0 7
60309: NOT
60310: AND
60311: IFFALSE 60315
// continue ;
60313: GO 59779
// end ;
60315: GO 59779
60317: POP
60318: POP
// RaiseSailEvent ( 102 ) ;
60319: LD_INT 102
60321: PPUSH
60322: CALL_OW 427
// end ;
60326: LD_VAR 0 1
60330: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60331: LD_INT 0
60333: PPUSH
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
60338: PPUSH
60339: PPUSH
60340: PPUSH
// if not mc_bases then
60341: LD_EXP 43
60345: NOT
60346: IFFALSE 60350
// exit ;
60348: GO 61261
// for i = 1 to mc_bases do
60350: LD_ADDR_VAR 0 2
60354: PUSH
60355: DOUBLE
60356: LD_INT 1
60358: DEC
60359: ST_TO_ADDR
60360: LD_EXP 43
60364: PUSH
60365: FOR_TO
60366: IFFALSE 61259
// begin if not mc_building_need_repair [ i ] then
60368: LD_EXP 44
60372: PUSH
60373: LD_VAR 0 2
60377: ARRAY
60378: NOT
60379: IFFALSE 60564
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60381: LD_ADDR_VAR 0 6
60385: PUSH
60386: LD_EXP 62
60390: PUSH
60391: LD_VAR 0 2
60395: ARRAY
60396: PPUSH
60397: LD_INT 3
60399: PUSH
60400: LD_INT 24
60402: PUSH
60403: LD_INT 1000
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: PUSH
60414: LD_INT 2
60416: PUSH
60417: LD_INT 34
60419: PUSH
60420: LD_INT 13
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: PUSH
60427: LD_INT 34
60429: PUSH
60430: LD_INT 52
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 34
60439: PUSH
60440: LD_INT 88
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: PUSH
60447: EMPTY
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: PUSH
60453: EMPTY
60454: LIST
60455: LIST
60456: PPUSH
60457: CALL_OW 72
60461: ST_TO_ADDR
// if cranes then
60462: LD_VAR 0 6
60466: IFFALSE 60528
// for j in cranes do
60468: LD_ADDR_VAR 0 3
60472: PUSH
60473: LD_VAR 0 6
60477: PUSH
60478: FOR_IN
60479: IFFALSE 60526
// if not IsInArea ( j , mc_parking [ i ] ) then
60481: LD_VAR 0 3
60485: PPUSH
60486: LD_EXP 67
60490: PUSH
60491: LD_VAR 0 2
60495: ARRAY
60496: PPUSH
60497: CALL_OW 308
60501: NOT
60502: IFFALSE 60524
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60504: LD_VAR 0 3
60508: PPUSH
60509: LD_EXP 67
60513: PUSH
60514: LD_VAR 0 2
60518: ARRAY
60519: PPUSH
60520: CALL_OW 113
60524: GO 60478
60526: POP
60527: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60528: LD_ADDR_EXP 45
60532: PUSH
60533: LD_EXP 45
60537: PPUSH
60538: LD_VAR 0 2
60542: PPUSH
60543: EMPTY
60544: PPUSH
60545: CALL_OW 1
60549: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60550: LD_VAR 0 2
60554: PPUSH
60555: LD_INT 101
60557: PPUSH
60558: CALL 55418 0 2
// continue ;
60562: GO 60365
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60564: LD_ADDR_EXP 49
60568: PUSH
60569: LD_EXP 49
60573: PPUSH
60574: LD_VAR 0 2
60578: PPUSH
60579: EMPTY
60580: PPUSH
60581: CALL_OW 1
60585: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60586: LD_VAR 0 2
60590: PPUSH
60591: LD_INT 103
60593: PPUSH
60594: CALL 55418 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60598: LD_ADDR_VAR 0 5
60602: PUSH
60603: LD_EXP 43
60607: PUSH
60608: LD_VAR 0 2
60612: ARRAY
60613: PUSH
60614: LD_EXP 72
60618: PUSH
60619: LD_VAR 0 2
60623: ARRAY
60624: UNION
60625: PPUSH
60626: LD_INT 2
60628: PUSH
60629: LD_INT 25
60631: PUSH
60632: LD_INT 2
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PUSH
60639: LD_INT 25
60641: PUSH
60642: LD_INT 16
60644: PUSH
60645: EMPTY
60646: LIST
60647: LIST
60648: PUSH
60649: EMPTY
60650: LIST
60651: LIST
60652: LIST
60653: PUSH
60654: EMPTY
60655: LIST
60656: PPUSH
60657: CALL_OW 72
60661: ST_TO_ADDR
// if mc_need_heal [ i ] then
60662: LD_EXP 46
60666: PUSH
60667: LD_VAR 0 2
60671: ARRAY
60672: IFFALSE 60716
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60674: LD_ADDR_VAR 0 5
60678: PUSH
60679: LD_VAR 0 5
60683: PUSH
60684: LD_EXP 46
60688: PUSH
60689: LD_VAR 0 2
60693: ARRAY
60694: PUSH
60695: LD_INT 1
60697: ARRAY
60698: PUSH
60699: LD_EXP 46
60703: PUSH
60704: LD_VAR 0 2
60708: ARRAY
60709: PUSH
60710: LD_INT 2
60712: ARRAY
60713: UNION
60714: DIFF
60715: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60716: LD_ADDR_VAR 0 6
60720: PUSH
60721: LD_EXP 62
60725: PUSH
60726: LD_VAR 0 2
60730: ARRAY
60731: PPUSH
60732: LD_INT 2
60734: PUSH
60735: LD_INT 34
60737: PUSH
60738: LD_INT 13
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: PUSH
60745: LD_INT 34
60747: PUSH
60748: LD_INT 52
60750: PUSH
60751: EMPTY
60752: LIST
60753: LIST
60754: PUSH
60755: LD_INT 34
60757: PUSH
60758: LD_INT 88
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: LIST
60769: LIST
60770: PPUSH
60771: CALL_OW 72
60775: ST_TO_ADDR
// if cranes then
60776: LD_VAR 0 6
60780: IFFALSE 60948
// begin for j in cranes do
60782: LD_ADDR_VAR 0 3
60786: PUSH
60787: LD_VAR 0 6
60791: PUSH
60792: FOR_IN
60793: IFFALSE 60946
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60795: LD_VAR 0 3
60799: PPUSH
60800: CALL_OW 256
60804: PUSH
60805: LD_INT 1000
60807: EQUAL
60808: PUSH
60809: LD_VAR 0 3
60813: PPUSH
60814: CALL_OW 314
60818: NOT
60819: AND
60820: IFFALSE 60886
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
60822: LD_ADDR_VAR 0 8
60826: PUSH
60827: LD_EXP 44
60831: PUSH
60832: LD_VAR 0 2
60836: ARRAY
60837: PPUSH
60838: LD_VAR 0 3
60842: PPUSH
60843: CALL_OW 74
60847: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60848: LD_VAR 0 8
60852: PPUSH
60853: LD_INT 16
60855: PPUSH
60856: CALL 17514 0 2
60860: PUSH
60861: LD_INT 4
60863: ARRAY
60864: PUSH
60865: LD_INT 10
60867: LESS
60868: IFFALSE 60884
// ComRepairBuilding ( j , to_repair ) ;
60870: LD_VAR 0 3
60874: PPUSH
60875: LD_VAR 0 8
60879: PPUSH
60880: CALL_OW 130
// end else
60884: GO 60944
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60886: LD_VAR 0 3
60890: PPUSH
60891: CALL_OW 256
60895: PUSH
60896: LD_INT 500
60898: LESS
60899: PUSH
60900: LD_VAR 0 3
60904: PPUSH
60905: LD_EXP 67
60909: PUSH
60910: LD_VAR 0 2
60914: ARRAY
60915: PPUSH
60916: CALL_OW 308
60920: NOT
60921: AND
60922: IFFALSE 60944
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60924: LD_VAR 0 3
60928: PPUSH
60929: LD_EXP 67
60933: PUSH
60934: LD_VAR 0 2
60938: ARRAY
60939: PPUSH
60940: CALL_OW 113
// end ;
60944: GO 60792
60946: POP
60947: POP
// end ; if tmp > 3 then
60948: LD_VAR 0 5
60952: PUSH
60953: LD_INT 3
60955: GREATER
60956: IFFALSE 60976
// tmp := ShrinkArray ( tmp , 4 ) ;
60958: LD_ADDR_VAR 0 5
60962: PUSH
60963: LD_VAR 0 5
60967: PPUSH
60968: LD_INT 4
60970: PPUSH
60971: CALL 47562 0 2
60975: ST_TO_ADDR
// if not tmp then
60976: LD_VAR 0 5
60980: NOT
60981: IFFALSE 60985
// continue ;
60983: GO 60365
// for j in tmp do
60985: LD_ADDR_VAR 0 3
60989: PUSH
60990: LD_VAR 0 5
60994: PUSH
60995: FOR_IN
60996: IFFALSE 61255
// begin if IsInUnit ( j ) then
60998: LD_VAR 0 3
61002: PPUSH
61003: CALL_OW 310
61007: IFFALSE 61018
// ComExitBuilding ( j ) ;
61009: LD_VAR 0 3
61013: PPUSH
61014: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61018: LD_VAR 0 3
61022: PUSH
61023: LD_EXP 45
61027: PUSH
61028: LD_VAR 0 2
61032: ARRAY
61033: IN
61034: NOT
61035: IFFALSE 61093
// begin SetTag ( j , 101 ) ;
61037: LD_VAR 0 3
61041: PPUSH
61042: LD_INT 101
61044: PPUSH
61045: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61049: LD_ADDR_EXP 45
61053: PUSH
61054: LD_EXP 45
61058: PPUSH
61059: LD_VAR 0 2
61063: PUSH
61064: LD_EXP 45
61068: PUSH
61069: LD_VAR 0 2
61073: ARRAY
61074: PUSH
61075: LD_INT 1
61077: PLUS
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PPUSH
61083: LD_VAR 0 3
61087: PPUSH
61088: CALL 14917 0 3
61092: ST_TO_ADDR
// end ; wait ( 1 ) ;
61093: LD_INT 1
61095: PPUSH
61096: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61100: LD_ADDR_VAR 0 7
61104: PUSH
61105: LD_EXP 44
61109: PUSH
61110: LD_VAR 0 2
61114: ARRAY
61115: ST_TO_ADDR
// if mc_scan [ i ] then
61116: LD_EXP 66
61120: PUSH
61121: LD_VAR 0 2
61125: ARRAY
61126: IFFALSE 61188
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61128: LD_ADDR_VAR 0 7
61132: PUSH
61133: LD_EXP 44
61137: PUSH
61138: LD_VAR 0 2
61142: ARRAY
61143: PPUSH
61144: LD_INT 3
61146: PUSH
61147: LD_INT 30
61149: PUSH
61150: LD_INT 32
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: PUSH
61157: LD_INT 30
61159: PUSH
61160: LD_INT 33
61162: PUSH
61163: EMPTY
61164: LIST
61165: LIST
61166: PUSH
61167: LD_INT 30
61169: PUSH
61170: LD_INT 31
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: LIST
61181: LIST
61182: PPUSH
61183: CALL_OW 72
61187: ST_TO_ADDR
// if not to_repair_tmp then
61188: LD_VAR 0 7
61192: NOT
61193: IFFALSE 61197
// continue ;
61195: GO 60995
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61197: LD_ADDR_VAR 0 8
61201: PUSH
61202: LD_VAR 0 7
61206: PPUSH
61207: LD_VAR 0 3
61211: PPUSH
61212: CALL_OW 74
61216: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61217: LD_VAR 0 8
61221: PPUSH
61222: LD_INT 16
61224: PPUSH
61225: CALL 17514 0 2
61229: PUSH
61230: LD_INT 4
61232: ARRAY
61233: PUSH
61234: LD_INT 14
61236: LESS
61237: IFFALSE 61253
// ComRepairBuilding ( j , to_repair ) ;
61239: LD_VAR 0 3
61243: PPUSH
61244: LD_VAR 0 8
61248: PPUSH
61249: CALL_OW 130
// end ;
61253: GO 60995
61255: POP
61256: POP
// end ;
61257: GO 60365
61259: POP
61260: POP
// end ;
61261: LD_VAR 0 1
61265: RET
// export function MC_Heal ; var i , j , tmp ; begin
61266: LD_INT 0
61268: PPUSH
61269: PPUSH
61270: PPUSH
61271: PPUSH
// if not mc_bases then
61272: LD_EXP 43
61276: NOT
61277: IFFALSE 61281
// exit ;
61279: GO 61683
// for i = 1 to mc_bases do
61281: LD_ADDR_VAR 0 2
61285: PUSH
61286: DOUBLE
61287: LD_INT 1
61289: DEC
61290: ST_TO_ADDR
61291: LD_EXP 43
61295: PUSH
61296: FOR_TO
61297: IFFALSE 61681
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61299: LD_EXP 46
61303: PUSH
61304: LD_VAR 0 2
61308: ARRAY
61309: PUSH
61310: LD_INT 1
61312: ARRAY
61313: NOT
61314: PUSH
61315: LD_EXP 46
61319: PUSH
61320: LD_VAR 0 2
61324: ARRAY
61325: PUSH
61326: LD_INT 2
61328: ARRAY
61329: NOT
61330: AND
61331: IFFALSE 61369
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61333: LD_ADDR_EXP 47
61337: PUSH
61338: LD_EXP 47
61342: PPUSH
61343: LD_VAR 0 2
61347: PPUSH
61348: EMPTY
61349: PPUSH
61350: CALL_OW 1
61354: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61355: LD_VAR 0 2
61359: PPUSH
61360: LD_INT 102
61362: PPUSH
61363: CALL 55418 0 2
// continue ;
61367: GO 61296
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61369: LD_ADDR_VAR 0 4
61373: PUSH
61374: LD_EXP 43
61378: PUSH
61379: LD_VAR 0 2
61383: ARRAY
61384: PPUSH
61385: LD_INT 25
61387: PUSH
61388: LD_INT 4
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: ST_TO_ADDR
// if not tmp then
61400: LD_VAR 0 4
61404: NOT
61405: IFFALSE 61409
// continue ;
61407: GO 61296
// if mc_taming [ i ] then
61409: LD_EXP 74
61413: PUSH
61414: LD_VAR 0 2
61418: ARRAY
61419: IFFALSE 61443
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61421: LD_ADDR_EXP 74
61425: PUSH
61426: LD_EXP 74
61430: PPUSH
61431: LD_VAR 0 2
61435: PPUSH
61436: EMPTY
61437: PPUSH
61438: CALL_OW 1
61442: ST_TO_ADDR
// for j in tmp do
61443: LD_ADDR_VAR 0 3
61447: PUSH
61448: LD_VAR 0 4
61452: PUSH
61453: FOR_IN
61454: IFFALSE 61677
// begin if IsInUnit ( j ) then
61456: LD_VAR 0 3
61460: PPUSH
61461: CALL_OW 310
61465: IFFALSE 61476
// ComExitBuilding ( j ) ;
61467: LD_VAR 0 3
61471: PPUSH
61472: CALL_OW 122
// if not j in mc_healers [ i ] then
61476: LD_VAR 0 3
61480: PUSH
61481: LD_EXP 47
61485: PUSH
61486: LD_VAR 0 2
61490: ARRAY
61491: IN
61492: NOT
61493: IFFALSE 61539
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61495: LD_ADDR_EXP 47
61499: PUSH
61500: LD_EXP 47
61504: PPUSH
61505: LD_VAR 0 2
61509: PUSH
61510: LD_EXP 47
61514: PUSH
61515: LD_VAR 0 2
61519: ARRAY
61520: PUSH
61521: LD_INT 1
61523: PLUS
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: PPUSH
61529: LD_VAR 0 3
61533: PPUSH
61534: CALL 14917 0 3
61538: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61539: LD_VAR 0 3
61543: PPUSH
61544: CALL_OW 110
61548: PUSH
61549: LD_INT 102
61551: NONEQUAL
61552: IFFALSE 61566
// SetTag ( j , 102 ) ;
61554: LD_VAR 0 3
61558: PPUSH
61559: LD_INT 102
61561: PPUSH
61562: CALL_OW 109
// Wait ( 3 ) ;
61566: LD_INT 3
61568: PPUSH
61569: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61573: LD_EXP 46
61577: PUSH
61578: LD_VAR 0 2
61582: ARRAY
61583: PUSH
61584: LD_INT 1
61586: ARRAY
61587: IFFALSE 61619
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61589: LD_VAR 0 3
61593: PPUSH
61594: LD_EXP 46
61598: PUSH
61599: LD_VAR 0 2
61603: ARRAY
61604: PUSH
61605: LD_INT 1
61607: ARRAY
61608: PUSH
61609: LD_INT 1
61611: ARRAY
61612: PPUSH
61613: CALL_OW 128
61617: GO 61675
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61619: LD_VAR 0 3
61623: PPUSH
61624: CALL_OW 314
61628: NOT
61629: PUSH
61630: LD_EXP 46
61634: PUSH
61635: LD_VAR 0 2
61639: ARRAY
61640: PUSH
61641: LD_INT 2
61643: ARRAY
61644: AND
61645: IFFALSE 61675
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61647: LD_VAR 0 3
61651: PPUSH
61652: LD_EXP 46
61656: PUSH
61657: LD_VAR 0 2
61661: ARRAY
61662: PUSH
61663: LD_INT 2
61665: ARRAY
61666: PUSH
61667: LD_INT 1
61669: ARRAY
61670: PPUSH
61671: CALL_OW 128
// end ;
61675: GO 61453
61677: POP
61678: POP
// end ;
61679: GO 61296
61681: POP
61682: POP
// end ;
61683: LD_VAR 0 1
61687: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
61688: LD_INT 0
61690: PPUSH
61691: PPUSH
61692: PPUSH
61693: PPUSH
61694: PPUSH
61695: PPUSH
// if not mc_bases then
61696: LD_EXP 43
61700: NOT
61701: IFFALSE 61705
// exit ;
61703: GO 62868
// for i = 1 to mc_bases do
61705: LD_ADDR_VAR 0 2
61709: PUSH
61710: DOUBLE
61711: LD_INT 1
61713: DEC
61714: ST_TO_ADDR
61715: LD_EXP 43
61719: PUSH
61720: FOR_TO
61721: IFFALSE 62866
// begin if mc_scan [ i ] then
61723: LD_EXP 66
61727: PUSH
61728: LD_VAR 0 2
61732: ARRAY
61733: IFFALSE 61737
// continue ;
61735: GO 61720
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61737: LD_EXP 48
61741: PUSH
61742: LD_VAR 0 2
61746: ARRAY
61747: NOT
61748: PUSH
61749: LD_EXP 50
61753: PUSH
61754: LD_VAR 0 2
61758: ARRAY
61759: NOT
61760: AND
61761: PUSH
61762: LD_EXP 49
61766: PUSH
61767: LD_VAR 0 2
61771: ARRAY
61772: AND
61773: IFFALSE 61811
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61775: LD_ADDR_EXP 49
61779: PUSH
61780: LD_EXP 49
61784: PPUSH
61785: LD_VAR 0 2
61789: PPUSH
61790: EMPTY
61791: PPUSH
61792: CALL_OW 1
61796: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61797: LD_VAR 0 2
61801: PPUSH
61802: LD_INT 103
61804: PPUSH
61805: CALL 55418 0 2
// continue ;
61809: GO 61720
// end ; if mc_construct_list [ i ] then
61811: LD_EXP 50
61815: PUSH
61816: LD_VAR 0 2
61820: ARRAY
61821: IFFALSE 62041
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61823: LD_ADDR_VAR 0 5
61827: PUSH
61828: LD_EXP 43
61832: PUSH
61833: LD_VAR 0 2
61837: ARRAY
61838: PPUSH
61839: LD_INT 25
61841: PUSH
61842: LD_INT 2
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PPUSH
61849: CALL_OW 72
61853: PUSH
61854: LD_EXP 45
61858: PUSH
61859: LD_VAR 0 2
61863: ARRAY
61864: DIFF
61865: ST_TO_ADDR
// if not tmp then
61866: LD_VAR 0 5
61870: NOT
61871: IFFALSE 61875
// continue ;
61873: GO 61720
// for j in tmp do
61875: LD_ADDR_VAR 0 3
61879: PUSH
61880: LD_VAR 0 5
61884: PUSH
61885: FOR_IN
61886: IFFALSE 62037
// begin if not mc_builders [ i ] then
61888: LD_EXP 49
61892: PUSH
61893: LD_VAR 0 2
61897: ARRAY
61898: NOT
61899: IFFALSE 61957
// begin SetTag ( j , 103 ) ;
61901: LD_VAR 0 3
61905: PPUSH
61906: LD_INT 103
61908: PPUSH
61909: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61913: LD_ADDR_EXP 49
61917: PUSH
61918: LD_EXP 49
61922: PPUSH
61923: LD_VAR 0 2
61927: PUSH
61928: LD_EXP 49
61932: PUSH
61933: LD_VAR 0 2
61937: ARRAY
61938: PUSH
61939: LD_INT 1
61941: PLUS
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: PPUSH
61947: LD_VAR 0 3
61951: PPUSH
61952: CALL 14917 0 3
61956: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61957: LD_VAR 0 3
61961: PPUSH
61962: CALL_OW 310
61966: IFFALSE 61977
// ComExitBuilding ( j ) ;
61968: LD_VAR 0 3
61972: PPUSH
61973: CALL_OW 122
// wait ( 3 ) ;
61977: LD_INT 3
61979: PPUSH
61980: CALL_OW 67
// if not mc_construct_list [ i ] then
61984: LD_EXP 50
61988: PUSH
61989: LD_VAR 0 2
61993: ARRAY
61994: NOT
61995: IFFALSE 61999
// break ;
61997: GO 62037
// if not HasTask ( j ) then
61999: LD_VAR 0 3
62003: PPUSH
62004: CALL_OW 314
62008: NOT
62009: IFFALSE 62035
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62011: LD_VAR 0 3
62015: PPUSH
62016: LD_EXP 50
62020: PUSH
62021: LD_VAR 0 2
62025: ARRAY
62026: PUSH
62027: LD_INT 1
62029: ARRAY
62030: PPUSH
62031: CALL 17778 0 2
// end ;
62035: GO 61885
62037: POP
62038: POP
// end else
62039: GO 62864
// if mc_build_list [ i ] then
62041: LD_EXP 48
62045: PUSH
62046: LD_VAR 0 2
62050: ARRAY
62051: IFFALSE 62864
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62053: LD_EXP 48
62057: PUSH
62058: LD_VAR 0 2
62062: ARRAY
62063: PUSH
62064: LD_INT 1
62066: ARRAY
62067: PUSH
62068: LD_INT 1
62070: ARRAY
62071: PPUSH
62072: CALL 17602 0 1
62076: PUSH
62077: LD_EXP 43
62081: PUSH
62082: LD_VAR 0 2
62086: ARRAY
62087: PPUSH
62088: LD_INT 2
62090: PUSH
62091: LD_INT 30
62093: PUSH
62094: LD_INT 2
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: LD_INT 30
62103: PUSH
62104: LD_INT 3
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: PUSH
62111: EMPTY
62112: LIST
62113: LIST
62114: LIST
62115: PPUSH
62116: CALL_OW 72
62120: NOT
62121: AND
62122: IFFALSE 62227
// begin for j = 1 to mc_build_list [ i ] do
62124: LD_ADDR_VAR 0 3
62128: PUSH
62129: DOUBLE
62130: LD_INT 1
62132: DEC
62133: ST_TO_ADDR
62134: LD_EXP 48
62138: PUSH
62139: LD_VAR 0 2
62143: ARRAY
62144: PUSH
62145: FOR_TO
62146: IFFALSE 62225
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62148: LD_EXP 48
62152: PUSH
62153: LD_VAR 0 2
62157: ARRAY
62158: PUSH
62159: LD_VAR 0 3
62163: ARRAY
62164: PUSH
62165: LD_INT 1
62167: ARRAY
62168: PUSH
62169: LD_INT 2
62171: EQUAL
62172: IFFALSE 62223
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62174: LD_ADDR_EXP 48
62178: PUSH
62179: LD_EXP 48
62183: PPUSH
62184: LD_VAR 0 2
62188: PPUSH
62189: LD_EXP 48
62193: PUSH
62194: LD_VAR 0 2
62198: ARRAY
62199: PPUSH
62200: LD_VAR 0 3
62204: PPUSH
62205: LD_INT 1
62207: PPUSH
62208: LD_INT 0
62210: PPUSH
62211: CALL 14335 0 4
62215: PPUSH
62216: CALL_OW 1
62220: ST_TO_ADDR
// break ;
62221: GO 62225
// end ;
62223: GO 62145
62225: POP
62226: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62227: LD_ADDR_VAR 0 6
62231: PUSH
62232: LD_EXP 43
62236: PUSH
62237: LD_VAR 0 2
62241: ARRAY
62242: PPUSH
62243: LD_INT 2
62245: PUSH
62246: LD_INT 30
62248: PUSH
62249: LD_INT 0
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 1
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: LIST
62270: PPUSH
62271: CALL_OW 72
62275: ST_TO_ADDR
// for k := 1 to depot do
62276: LD_ADDR_VAR 0 4
62280: PUSH
62281: DOUBLE
62282: LD_INT 1
62284: DEC
62285: ST_TO_ADDR
62286: LD_VAR 0 6
62290: PUSH
62291: FOR_TO
62292: IFFALSE 62862
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62294: LD_EXP 48
62298: PUSH
62299: LD_VAR 0 2
62303: ARRAY
62304: PUSH
62305: LD_INT 1
62307: ARRAY
62308: PUSH
62309: LD_INT 1
62311: ARRAY
62312: PUSH
62313: LD_INT 0
62315: EQUAL
62316: PUSH
62317: LD_VAR 0 6
62321: PUSH
62322: LD_VAR 0 4
62326: ARRAY
62327: PPUSH
62328: LD_EXP 48
62332: PUSH
62333: LD_VAR 0 2
62337: ARRAY
62338: PUSH
62339: LD_INT 1
62341: ARRAY
62342: PUSH
62343: LD_INT 1
62345: ARRAY
62346: PPUSH
62347: LD_EXP 48
62351: PUSH
62352: LD_VAR 0 2
62356: ARRAY
62357: PUSH
62358: LD_INT 1
62360: ARRAY
62361: PUSH
62362: LD_INT 2
62364: ARRAY
62365: PPUSH
62366: LD_EXP 48
62370: PUSH
62371: LD_VAR 0 2
62375: ARRAY
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PUSH
62381: LD_INT 3
62383: ARRAY
62384: PPUSH
62385: LD_EXP 48
62389: PUSH
62390: LD_VAR 0 2
62394: ARRAY
62395: PUSH
62396: LD_INT 1
62398: ARRAY
62399: PUSH
62400: LD_INT 4
62402: ARRAY
62403: PPUSH
62404: CALL 23014 0 5
62408: OR
62409: IFFALSE 62690
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62411: LD_ADDR_VAR 0 5
62415: PUSH
62416: LD_EXP 43
62420: PUSH
62421: LD_VAR 0 2
62425: ARRAY
62426: PPUSH
62427: LD_INT 25
62429: PUSH
62430: LD_INT 2
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PPUSH
62437: CALL_OW 72
62441: PUSH
62442: LD_EXP 45
62446: PUSH
62447: LD_VAR 0 2
62451: ARRAY
62452: DIFF
62453: ST_TO_ADDR
// if not tmp then
62454: LD_VAR 0 5
62458: NOT
62459: IFFALSE 62463
// continue ;
62461: GO 62291
// for j in tmp do
62463: LD_ADDR_VAR 0 3
62467: PUSH
62468: LD_VAR 0 5
62472: PUSH
62473: FOR_IN
62474: IFFALSE 62686
// begin if not mc_builders [ i ] then
62476: LD_EXP 49
62480: PUSH
62481: LD_VAR 0 2
62485: ARRAY
62486: NOT
62487: IFFALSE 62545
// begin SetTag ( j , 103 ) ;
62489: LD_VAR 0 3
62493: PPUSH
62494: LD_INT 103
62496: PPUSH
62497: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62501: LD_ADDR_EXP 49
62505: PUSH
62506: LD_EXP 49
62510: PPUSH
62511: LD_VAR 0 2
62515: PUSH
62516: LD_EXP 49
62520: PUSH
62521: LD_VAR 0 2
62525: ARRAY
62526: PUSH
62527: LD_INT 1
62529: PLUS
62530: PUSH
62531: EMPTY
62532: LIST
62533: LIST
62534: PPUSH
62535: LD_VAR 0 3
62539: PPUSH
62540: CALL 14917 0 3
62544: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62545: LD_VAR 0 3
62549: PPUSH
62550: CALL_OW 310
62554: IFFALSE 62565
// ComExitBuilding ( j ) ;
62556: LD_VAR 0 3
62560: PPUSH
62561: CALL_OW 122
// wait ( 3 ) ;
62565: LD_INT 3
62567: PPUSH
62568: CALL_OW 67
// if not mc_build_list [ i ] then
62572: LD_EXP 48
62576: PUSH
62577: LD_VAR 0 2
62581: ARRAY
62582: NOT
62583: IFFALSE 62587
// break ;
62585: GO 62686
// if not HasTask ( j ) then
62587: LD_VAR 0 3
62591: PPUSH
62592: CALL_OW 314
62596: NOT
62597: IFFALSE 62684
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62599: LD_VAR 0 3
62603: PPUSH
62604: LD_EXP 48
62608: PUSH
62609: LD_VAR 0 2
62613: ARRAY
62614: PUSH
62615: LD_INT 1
62617: ARRAY
62618: PUSH
62619: LD_INT 1
62621: ARRAY
62622: PPUSH
62623: LD_EXP 48
62627: PUSH
62628: LD_VAR 0 2
62632: ARRAY
62633: PUSH
62634: LD_INT 1
62636: ARRAY
62637: PUSH
62638: LD_INT 2
62640: ARRAY
62641: PPUSH
62642: LD_EXP 48
62646: PUSH
62647: LD_VAR 0 2
62651: ARRAY
62652: PUSH
62653: LD_INT 1
62655: ARRAY
62656: PUSH
62657: LD_INT 3
62659: ARRAY
62660: PPUSH
62661: LD_EXP 48
62665: PUSH
62666: LD_VAR 0 2
62670: ARRAY
62671: PUSH
62672: LD_INT 1
62674: ARRAY
62675: PUSH
62676: LD_INT 4
62678: ARRAY
62679: PPUSH
62680: CALL_OW 145
// end ;
62684: GO 62473
62686: POP
62687: POP
// end else
62688: GO 62860
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62690: LD_EXP 43
62694: PUSH
62695: LD_VAR 0 2
62699: ARRAY
62700: PPUSH
62701: LD_EXP 48
62705: PUSH
62706: LD_VAR 0 2
62710: ARRAY
62711: PUSH
62712: LD_INT 1
62714: ARRAY
62715: PUSH
62716: LD_INT 1
62718: ARRAY
62719: PPUSH
62720: LD_EXP 48
62724: PUSH
62725: LD_VAR 0 2
62729: ARRAY
62730: PUSH
62731: LD_INT 1
62733: ARRAY
62734: PUSH
62735: LD_INT 2
62737: ARRAY
62738: PPUSH
62739: LD_EXP 48
62743: PUSH
62744: LD_VAR 0 2
62748: ARRAY
62749: PUSH
62750: LD_INT 1
62752: ARRAY
62753: PUSH
62754: LD_INT 3
62756: ARRAY
62757: PPUSH
62758: LD_EXP 48
62762: PUSH
62763: LD_VAR 0 2
62767: ARRAY
62768: PUSH
62769: LD_INT 1
62771: ARRAY
62772: PUSH
62773: LD_INT 4
62775: ARRAY
62776: PPUSH
62777: LD_EXP 43
62781: PUSH
62782: LD_VAR 0 2
62786: ARRAY
62787: PPUSH
62788: LD_INT 21
62790: PUSH
62791: LD_INT 3
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PPUSH
62798: CALL_OW 72
62802: PPUSH
62803: EMPTY
62804: PPUSH
62805: CALL 21768 0 7
62809: NOT
62810: IFFALSE 62860
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62812: LD_ADDR_EXP 48
62816: PUSH
62817: LD_EXP 48
62821: PPUSH
62822: LD_VAR 0 2
62826: PPUSH
62827: LD_EXP 48
62831: PUSH
62832: LD_VAR 0 2
62836: ARRAY
62837: PPUSH
62838: LD_INT 1
62840: PPUSH
62841: LD_INT 1
62843: NEG
62844: PPUSH
62845: LD_INT 0
62847: PPUSH
62848: CALL 14335 0 4
62852: PPUSH
62853: CALL_OW 1
62857: ST_TO_ADDR
// continue ;
62858: GO 62291
// end ; end ;
62860: GO 62291
62862: POP
62863: POP
// end ; end ;
62864: GO 61720
62866: POP
62867: POP
// end ;
62868: LD_VAR 0 1
62872: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62873: LD_INT 0
62875: PPUSH
62876: PPUSH
62877: PPUSH
62878: PPUSH
62879: PPUSH
62880: PPUSH
// if not mc_bases then
62881: LD_EXP 43
62885: NOT
62886: IFFALSE 62890
// exit ;
62888: GO 63317
// for i = 1 to mc_bases do
62890: LD_ADDR_VAR 0 2
62894: PUSH
62895: DOUBLE
62896: LD_INT 1
62898: DEC
62899: ST_TO_ADDR
62900: LD_EXP 43
62904: PUSH
62905: FOR_TO
62906: IFFALSE 63315
// begin tmp := mc_build_upgrade [ i ] ;
62908: LD_ADDR_VAR 0 4
62912: PUSH
62913: LD_EXP 75
62917: PUSH
62918: LD_VAR 0 2
62922: ARRAY
62923: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62924: LD_ADDR_VAR 0 6
62928: PUSH
62929: LD_EXP 76
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: PPUSH
62940: LD_INT 2
62942: PUSH
62943: LD_INT 30
62945: PUSH
62946: LD_INT 6
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: PUSH
62953: LD_INT 30
62955: PUSH
62956: LD_INT 7
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: LIST
62967: PPUSH
62968: CALL_OW 72
62972: ST_TO_ADDR
// if not tmp and not lab then
62973: LD_VAR 0 4
62977: NOT
62978: PUSH
62979: LD_VAR 0 6
62983: NOT
62984: AND
62985: IFFALSE 62989
// continue ;
62987: GO 62905
// if tmp then
62989: LD_VAR 0 4
62993: IFFALSE 63113
// for j in tmp do
62995: LD_ADDR_VAR 0 3
62999: PUSH
63000: LD_VAR 0 4
63004: PUSH
63005: FOR_IN
63006: IFFALSE 63111
// begin if UpgradeCost ( j ) then
63008: LD_VAR 0 3
63012: PPUSH
63013: CALL 21428 0 1
63017: IFFALSE 63109
// begin ComUpgrade ( j ) ;
63019: LD_VAR 0 3
63023: PPUSH
63024: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63028: LD_ADDR_EXP 75
63032: PUSH
63033: LD_EXP 75
63037: PPUSH
63038: LD_VAR 0 2
63042: PPUSH
63043: LD_EXP 75
63047: PUSH
63048: LD_VAR 0 2
63052: ARRAY
63053: PUSH
63054: LD_VAR 0 3
63058: DIFF
63059: PPUSH
63060: CALL_OW 1
63064: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63065: LD_ADDR_EXP 50
63069: PUSH
63070: LD_EXP 50
63074: PPUSH
63075: LD_VAR 0 2
63079: PUSH
63080: LD_EXP 50
63084: PUSH
63085: LD_VAR 0 2
63089: ARRAY
63090: PUSH
63091: LD_INT 1
63093: PLUS
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PPUSH
63099: LD_VAR 0 3
63103: PPUSH
63104: CALL 14917 0 3
63108: ST_TO_ADDR
// end ; end ;
63109: GO 63005
63111: POP
63112: POP
// if not lab or not mc_lab_upgrade [ i ] then
63113: LD_VAR 0 6
63117: NOT
63118: PUSH
63119: LD_EXP 77
63123: PUSH
63124: LD_VAR 0 2
63128: ARRAY
63129: NOT
63130: OR
63131: IFFALSE 63135
// continue ;
63133: GO 62905
// for j in lab do
63135: LD_ADDR_VAR 0 3
63139: PUSH
63140: LD_VAR 0 6
63144: PUSH
63145: FOR_IN
63146: IFFALSE 63311
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63148: LD_VAR 0 3
63152: PPUSH
63153: CALL_OW 266
63157: PUSH
63158: LD_INT 6
63160: PUSH
63161: LD_INT 7
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: IN
63168: PUSH
63169: LD_VAR 0 3
63173: PPUSH
63174: CALL_OW 461
63178: PUSH
63179: LD_INT 1
63181: NONEQUAL
63182: AND
63183: IFFALSE 63309
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63185: LD_VAR 0 3
63189: PPUSH
63190: LD_EXP 77
63194: PUSH
63195: LD_VAR 0 2
63199: ARRAY
63200: PUSH
63201: LD_INT 1
63203: ARRAY
63204: PPUSH
63205: CALL 21633 0 2
63209: IFFALSE 63309
// begin ComCancel ( j ) ;
63211: LD_VAR 0 3
63215: PPUSH
63216: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63220: LD_VAR 0 3
63224: PPUSH
63225: LD_EXP 77
63229: PUSH
63230: LD_VAR 0 2
63234: ARRAY
63235: PUSH
63236: LD_INT 1
63238: ARRAY
63239: PPUSH
63240: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63244: LD_VAR 0 3
63248: PUSH
63249: LD_EXP 50
63253: PUSH
63254: LD_VAR 0 2
63258: ARRAY
63259: IN
63260: NOT
63261: IFFALSE 63307
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63263: LD_ADDR_EXP 50
63267: PUSH
63268: LD_EXP 50
63272: PPUSH
63273: LD_VAR 0 2
63277: PUSH
63278: LD_EXP 50
63282: PUSH
63283: LD_VAR 0 2
63287: ARRAY
63288: PUSH
63289: LD_INT 1
63291: PLUS
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: PPUSH
63297: LD_VAR 0 3
63301: PPUSH
63302: CALL 14917 0 3
63306: ST_TO_ADDR
// break ;
63307: GO 63311
// end ; end ; end ;
63309: GO 63145
63311: POP
63312: POP
// end ;
63313: GO 62905
63315: POP
63316: POP
// end ;
63317: LD_VAR 0 1
63321: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63322: LD_INT 0
63324: PPUSH
63325: PPUSH
63326: PPUSH
63327: PPUSH
63328: PPUSH
63329: PPUSH
63330: PPUSH
63331: PPUSH
63332: PPUSH
// if not mc_bases then
63333: LD_EXP 43
63337: NOT
63338: IFFALSE 63342
// exit ;
63340: GO 63747
// for i = 1 to mc_bases do
63342: LD_ADDR_VAR 0 2
63346: PUSH
63347: DOUBLE
63348: LD_INT 1
63350: DEC
63351: ST_TO_ADDR
63352: LD_EXP 43
63356: PUSH
63357: FOR_TO
63358: IFFALSE 63745
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63360: LD_EXP 51
63364: PUSH
63365: LD_VAR 0 2
63369: ARRAY
63370: NOT
63371: PUSH
63372: LD_EXP 43
63376: PUSH
63377: LD_VAR 0 2
63381: ARRAY
63382: PPUSH
63383: LD_INT 30
63385: PUSH
63386: LD_INT 3
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PPUSH
63393: CALL_OW 72
63397: NOT
63398: OR
63399: IFFALSE 63403
// continue ;
63401: GO 63357
// busy := false ;
63403: LD_ADDR_VAR 0 8
63407: PUSH
63408: LD_INT 0
63410: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63411: LD_ADDR_VAR 0 4
63415: PUSH
63416: LD_EXP 43
63420: PUSH
63421: LD_VAR 0 2
63425: ARRAY
63426: PPUSH
63427: LD_INT 30
63429: PUSH
63430: LD_INT 3
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PPUSH
63437: CALL_OW 72
63441: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63442: LD_ADDR_VAR 0 6
63446: PUSH
63447: LD_EXP 51
63451: PUSH
63452: LD_VAR 0 2
63456: ARRAY
63457: PPUSH
63458: LD_INT 2
63460: PUSH
63461: LD_INT 30
63463: PUSH
63464: LD_INT 32
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PUSH
63471: LD_INT 30
63473: PUSH
63474: LD_INT 33
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: LIST
63485: PPUSH
63486: CALL_OW 72
63490: ST_TO_ADDR
// if not t then
63491: LD_VAR 0 6
63495: NOT
63496: IFFALSE 63500
// continue ;
63498: GO 63357
// for j in tmp do
63500: LD_ADDR_VAR 0 3
63504: PUSH
63505: LD_VAR 0 4
63509: PUSH
63510: FOR_IN
63511: IFFALSE 63541
// if not BuildingStatus ( j ) = bs_idle then
63513: LD_VAR 0 3
63517: PPUSH
63518: CALL_OW 461
63522: PUSH
63523: LD_INT 2
63525: EQUAL
63526: NOT
63527: IFFALSE 63539
// begin busy := true ;
63529: LD_ADDR_VAR 0 8
63533: PUSH
63534: LD_INT 1
63536: ST_TO_ADDR
// break ;
63537: GO 63541
// end ;
63539: GO 63510
63541: POP
63542: POP
// if busy then
63543: LD_VAR 0 8
63547: IFFALSE 63551
// continue ;
63549: GO 63357
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63551: LD_ADDR_VAR 0 7
63555: PUSH
63556: LD_VAR 0 6
63560: PPUSH
63561: LD_INT 35
63563: PUSH
63564: LD_INT 0
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: PPUSH
63571: CALL_OW 72
63575: ST_TO_ADDR
// if tw then
63576: LD_VAR 0 7
63580: IFFALSE 63657
// begin tw := tw [ 1 ] ;
63582: LD_ADDR_VAR 0 7
63586: PUSH
63587: LD_VAR 0 7
63591: PUSH
63592: LD_INT 1
63594: ARRAY
63595: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63596: LD_ADDR_VAR 0 9
63600: PUSH
63601: LD_VAR 0 7
63605: PPUSH
63606: LD_EXP 68
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: PPUSH
63617: CALL 19925 0 2
63621: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63622: LD_EXP 82
63626: PUSH
63627: LD_VAR 0 2
63631: ARRAY
63632: IFFALSE 63655
// if not weapon in mc_allowed_tower_weapons [ i ] then
63634: LD_VAR 0 9
63638: PUSH
63639: LD_EXP 82
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: IN
63650: NOT
63651: IFFALSE 63655
// continue ;
63653: GO 63357
// end else
63655: GO 63720
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63657: LD_ADDR_VAR 0 5
63661: PUSH
63662: LD_EXP 51
63666: PUSH
63667: LD_VAR 0 2
63671: ARRAY
63672: PPUSH
63673: LD_VAR 0 4
63677: PPUSH
63678: CALL 46795 0 2
63682: ST_TO_ADDR
// if not tmp2 then
63683: LD_VAR 0 5
63687: NOT
63688: IFFALSE 63692
// continue ;
63690: GO 63357
// tw := tmp2 [ 1 ] ;
63692: LD_ADDR_VAR 0 7
63696: PUSH
63697: LD_VAR 0 5
63701: PUSH
63702: LD_INT 1
63704: ARRAY
63705: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63706: LD_ADDR_VAR 0 9
63710: PUSH
63711: LD_VAR 0 5
63715: PUSH
63716: LD_INT 2
63718: ARRAY
63719: ST_TO_ADDR
// end ; if not weapon then
63720: LD_VAR 0 9
63724: NOT
63725: IFFALSE 63729
// continue ;
63727: GO 63357
// ComPlaceWeapon ( tw , weapon ) ;
63729: LD_VAR 0 7
63733: PPUSH
63734: LD_VAR 0 9
63738: PPUSH
63739: CALL_OW 148
// end ;
63743: GO 63357
63745: POP
63746: POP
// end ;
63747: LD_VAR 0 1
63751: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63752: LD_INT 0
63754: PPUSH
63755: PPUSH
63756: PPUSH
63757: PPUSH
63758: PPUSH
63759: PPUSH
63760: PPUSH
// if not mc_bases then
63761: LD_EXP 43
63765: NOT
63766: IFFALSE 63770
// exit ;
63768: GO 64538
// for i = 1 to mc_bases do
63770: LD_ADDR_VAR 0 2
63774: PUSH
63775: DOUBLE
63776: LD_INT 1
63778: DEC
63779: ST_TO_ADDR
63780: LD_EXP 43
63784: PUSH
63785: FOR_TO
63786: IFFALSE 64536
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63788: LD_EXP 56
63792: PUSH
63793: LD_VAR 0 2
63797: ARRAY
63798: NOT
63799: PUSH
63800: LD_EXP 56
63804: PUSH
63805: LD_VAR 0 2
63809: ARRAY
63810: PUSH
63811: LD_EXP 57
63815: PUSH
63816: LD_VAR 0 2
63820: ARRAY
63821: EQUAL
63822: OR
63823: PUSH
63824: LD_EXP 66
63828: PUSH
63829: LD_VAR 0 2
63833: ARRAY
63834: OR
63835: IFFALSE 63839
// continue ;
63837: GO 63785
// if mc_miners [ i ] then
63839: LD_EXP 57
63843: PUSH
63844: LD_VAR 0 2
63848: ARRAY
63849: IFFALSE 64223
// begin for j = mc_miners [ i ] downto 1 do
63851: LD_ADDR_VAR 0 3
63855: PUSH
63856: DOUBLE
63857: LD_EXP 57
63861: PUSH
63862: LD_VAR 0 2
63866: ARRAY
63867: INC
63868: ST_TO_ADDR
63869: LD_INT 1
63871: PUSH
63872: FOR_DOWNTO
63873: IFFALSE 64221
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63875: LD_EXP 57
63879: PUSH
63880: LD_VAR 0 2
63884: ARRAY
63885: PUSH
63886: LD_VAR 0 3
63890: ARRAY
63891: PPUSH
63892: CALL_OW 301
63896: PUSH
63897: LD_EXP 57
63901: PUSH
63902: LD_VAR 0 2
63906: ARRAY
63907: PUSH
63908: LD_VAR 0 3
63912: ARRAY
63913: PPUSH
63914: CALL_OW 257
63918: PUSH
63919: LD_INT 1
63921: NONEQUAL
63922: OR
63923: IFFALSE 63986
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63925: LD_ADDR_VAR 0 5
63929: PUSH
63930: LD_EXP 57
63934: PUSH
63935: LD_VAR 0 2
63939: ARRAY
63940: PUSH
63941: LD_EXP 57
63945: PUSH
63946: LD_VAR 0 2
63950: ARRAY
63951: PUSH
63952: LD_VAR 0 3
63956: ARRAY
63957: DIFF
63958: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63959: LD_ADDR_EXP 57
63963: PUSH
63964: LD_EXP 57
63968: PPUSH
63969: LD_VAR 0 2
63973: PPUSH
63974: LD_VAR 0 5
63978: PPUSH
63979: CALL_OW 1
63983: ST_TO_ADDR
// continue ;
63984: GO 63872
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63986: LD_EXP 57
63990: PUSH
63991: LD_VAR 0 2
63995: ARRAY
63996: PUSH
63997: LD_VAR 0 3
64001: ARRAY
64002: PPUSH
64003: CALL_OW 257
64007: PUSH
64008: LD_INT 1
64010: EQUAL
64011: PUSH
64012: LD_EXP 57
64016: PUSH
64017: LD_VAR 0 2
64021: ARRAY
64022: PUSH
64023: LD_VAR 0 3
64027: ARRAY
64028: PPUSH
64029: CALL_OW 459
64033: NOT
64034: AND
64035: PUSH
64036: LD_EXP 57
64040: PUSH
64041: LD_VAR 0 2
64045: ARRAY
64046: PUSH
64047: LD_VAR 0 3
64051: ARRAY
64052: PPUSH
64053: CALL_OW 314
64057: NOT
64058: AND
64059: IFFALSE 64219
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64061: LD_EXP 57
64065: PUSH
64066: LD_VAR 0 2
64070: ARRAY
64071: PUSH
64072: LD_VAR 0 3
64076: ARRAY
64077: PPUSH
64078: CALL_OW 310
64082: IFFALSE 64105
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64084: LD_EXP 57
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: PUSH
64095: LD_VAR 0 3
64099: ARRAY
64100: PPUSH
64101: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64105: LD_EXP 57
64109: PUSH
64110: LD_VAR 0 2
64114: ARRAY
64115: PUSH
64116: LD_VAR 0 3
64120: ARRAY
64121: PPUSH
64122: CALL_OW 314
64126: NOT
64127: IFFALSE 64219
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64129: LD_ADDR_VAR 0 7
64133: PUSH
64134: LD_INT 1
64136: PPUSH
64137: LD_EXP 56
64141: PUSH
64142: LD_VAR 0 2
64146: ARRAY
64147: PPUSH
64148: CALL_OW 12
64152: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64153: LD_EXP 57
64157: PUSH
64158: LD_VAR 0 2
64162: ARRAY
64163: PUSH
64164: LD_VAR 0 3
64168: ARRAY
64169: PPUSH
64170: LD_EXP 56
64174: PUSH
64175: LD_VAR 0 2
64179: ARRAY
64180: PUSH
64181: LD_VAR 0 7
64185: ARRAY
64186: PUSH
64187: LD_INT 1
64189: ARRAY
64190: PPUSH
64191: LD_EXP 56
64195: PUSH
64196: LD_VAR 0 2
64200: ARRAY
64201: PUSH
64202: LD_VAR 0 7
64206: ARRAY
64207: PUSH
64208: LD_INT 2
64210: ARRAY
64211: PPUSH
64212: LD_INT 0
64214: PPUSH
64215: CALL_OW 193
// end ; end ; end ;
64219: GO 63872
64221: POP
64222: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64223: LD_ADDR_VAR 0 5
64227: PUSH
64228: LD_EXP 43
64232: PUSH
64233: LD_VAR 0 2
64237: ARRAY
64238: PPUSH
64239: LD_INT 2
64241: PUSH
64242: LD_INT 30
64244: PUSH
64245: LD_INT 4
64247: PUSH
64248: EMPTY
64249: LIST
64250: LIST
64251: PUSH
64252: LD_INT 30
64254: PUSH
64255: LD_INT 5
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: PUSH
64262: LD_INT 30
64264: PUSH
64265: LD_INT 32
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: PPUSH
64278: CALL_OW 72
64282: ST_TO_ADDR
// if not tmp then
64283: LD_VAR 0 5
64287: NOT
64288: IFFALSE 64292
// continue ;
64290: GO 63785
// list := [ ] ;
64292: LD_ADDR_VAR 0 6
64296: PUSH
64297: EMPTY
64298: ST_TO_ADDR
// for j in tmp do
64299: LD_ADDR_VAR 0 3
64303: PUSH
64304: LD_VAR 0 5
64308: PUSH
64309: FOR_IN
64310: IFFALSE 64379
// begin for k in UnitsInside ( j ) do
64312: LD_ADDR_VAR 0 4
64316: PUSH
64317: LD_VAR 0 3
64321: PPUSH
64322: CALL_OW 313
64326: PUSH
64327: FOR_IN
64328: IFFALSE 64375
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64330: LD_VAR 0 4
64334: PPUSH
64335: CALL_OW 257
64339: PUSH
64340: LD_INT 1
64342: EQUAL
64343: PUSH
64344: LD_VAR 0 4
64348: PPUSH
64349: CALL_OW 459
64353: NOT
64354: AND
64355: IFFALSE 64373
// list := list ^ k ;
64357: LD_ADDR_VAR 0 6
64361: PUSH
64362: LD_VAR 0 6
64366: PUSH
64367: LD_VAR 0 4
64371: ADD
64372: ST_TO_ADDR
64373: GO 64327
64375: POP
64376: POP
// end ;
64377: GO 64309
64379: POP
64380: POP
// list := list diff mc_miners [ i ] ;
64381: LD_ADDR_VAR 0 6
64385: PUSH
64386: LD_VAR 0 6
64390: PUSH
64391: LD_EXP 57
64395: PUSH
64396: LD_VAR 0 2
64400: ARRAY
64401: DIFF
64402: ST_TO_ADDR
// if not list then
64403: LD_VAR 0 6
64407: NOT
64408: IFFALSE 64412
// continue ;
64410: GO 63785
// k := mc_mines [ i ] - mc_miners [ i ] ;
64412: LD_ADDR_VAR 0 4
64416: PUSH
64417: LD_EXP 56
64421: PUSH
64422: LD_VAR 0 2
64426: ARRAY
64427: PUSH
64428: LD_EXP 57
64432: PUSH
64433: LD_VAR 0 2
64437: ARRAY
64438: MINUS
64439: ST_TO_ADDR
// if k > list then
64440: LD_VAR 0 4
64444: PUSH
64445: LD_VAR 0 6
64449: GREATER
64450: IFFALSE 64462
// k := list ;
64452: LD_ADDR_VAR 0 4
64456: PUSH
64457: LD_VAR 0 6
64461: ST_TO_ADDR
// for j = 1 to k do
64462: LD_ADDR_VAR 0 3
64466: PUSH
64467: DOUBLE
64468: LD_INT 1
64470: DEC
64471: ST_TO_ADDR
64472: LD_VAR 0 4
64476: PUSH
64477: FOR_TO
64478: IFFALSE 64532
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64480: LD_ADDR_EXP 57
64484: PUSH
64485: LD_EXP 57
64489: PPUSH
64490: LD_VAR 0 2
64494: PUSH
64495: LD_EXP 57
64499: PUSH
64500: LD_VAR 0 2
64504: ARRAY
64505: PUSH
64506: LD_INT 1
64508: PLUS
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PPUSH
64514: LD_VAR 0 6
64518: PUSH
64519: LD_VAR 0 3
64523: ARRAY
64524: PPUSH
64525: CALL 14917 0 3
64529: ST_TO_ADDR
64530: GO 64477
64532: POP
64533: POP
// end ;
64534: GO 63785
64536: POP
64537: POP
// end ;
64538: LD_VAR 0 1
64542: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64543: LD_INT 0
64545: PPUSH
64546: PPUSH
64547: PPUSH
64548: PPUSH
64549: PPUSH
64550: PPUSH
64551: PPUSH
64552: PPUSH
64553: PPUSH
64554: PPUSH
64555: PPUSH
// if not mc_bases then
64556: LD_EXP 43
64560: NOT
64561: IFFALSE 64565
// exit ;
64563: GO 66388
// for i = 1 to mc_bases do
64565: LD_ADDR_VAR 0 2
64569: PUSH
64570: DOUBLE
64571: LD_INT 1
64573: DEC
64574: ST_TO_ADDR
64575: LD_EXP 43
64579: PUSH
64580: FOR_TO
64581: IFFALSE 66386
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64583: LD_EXP 43
64587: PUSH
64588: LD_VAR 0 2
64592: ARRAY
64593: NOT
64594: PUSH
64595: LD_EXP 50
64599: PUSH
64600: LD_VAR 0 2
64604: ARRAY
64605: OR
64606: IFFALSE 64610
// continue ;
64608: GO 64580
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64610: LD_EXP 59
64614: PUSH
64615: LD_VAR 0 2
64619: ARRAY
64620: NOT
64621: PUSH
64622: LD_EXP 60
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: AND
64633: IFFALSE 64671
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64635: LD_ADDR_EXP 60
64639: PUSH
64640: LD_EXP 60
64644: PPUSH
64645: LD_VAR 0 2
64649: PPUSH
64650: EMPTY
64651: PPUSH
64652: CALL_OW 1
64656: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64657: LD_VAR 0 2
64661: PPUSH
64662: LD_INT 107
64664: PPUSH
64665: CALL 55418 0 2
// continue ;
64669: GO 64580
// end ; target := [ ] ;
64671: LD_ADDR_VAR 0 7
64675: PUSH
64676: EMPTY
64677: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64678: LD_ADDR_VAR 0 6
64682: PUSH
64683: LD_EXP 43
64687: PUSH
64688: LD_VAR 0 2
64692: ARRAY
64693: PUSH
64694: LD_INT 1
64696: ARRAY
64697: PPUSH
64698: CALL_OW 255
64702: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64703: LD_ADDR_VAR 0 9
64707: PUSH
64708: LD_EXP 43
64712: PUSH
64713: LD_VAR 0 2
64717: ARRAY
64718: PPUSH
64719: LD_INT 2
64721: PUSH
64722: LD_INT 30
64724: PUSH
64725: LD_INT 0
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 30
64734: PUSH
64735: LD_INT 1
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: LIST
64746: PPUSH
64747: CALL_OW 72
64751: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64752: LD_ADDR_VAR 0 3
64756: PUSH
64757: DOUBLE
64758: LD_EXP 59
64762: PUSH
64763: LD_VAR 0 2
64767: ARRAY
64768: INC
64769: ST_TO_ADDR
64770: LD_INT 1
64772: PUSH
64773: FOR_DOWNTO
64774: IFFALSE 65019
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64776: LD_EXP 59
64780: PUSH
64781: LD_VAR 0 2
64785: ARRAY
64786: PUSH
64787: LD_VAR 0 3
64791: ARRAY
64792: PUSH
64793: LD_INT 2
64795: ARRAY
64796: PPUSH
64797: LD_EXP 59
64801: PUSH
64802: LD_VAR 0 2
64806: ARRAY
64807: PUSH
64808: LD_VAR 0 3
64812: ARRAY
64813: PUSH
64814: LD_INT 3
64816: ARRAY
64817: PPUSH
64818: CALL_OW 488
64822: PUSH
64823: LD_EXP 59
64827: PUSH
64828: LD_VAR 0 2
64832: ARRAY
64833: PUSH
64834: LD_VAR 0 3
64838: ARRAY
64839: PUSH
64840: LD_INT 2
64842: ARRAY
64843: PPUSH
64844: LD_EXP 59
64848: PUSH
64849: LD_VAR 0 2
64853: ARRAY
64854: PUSH
64855: LD_VAR 0 3
64859: ARRAY
64860: PUSH
64861: LD_INT 3
64863: ARRAY
64864: PPUSH
64865: CALL_OW 284
64869: PUSH
64870: LD_INT 0
64872: EQUAL
64873: AND
64874: IFFALSE 64929
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64876: LD_ADDR_VAR 0 5
64880: PUSH
64881: LD_EXP 59
64885: PUSH
64886: LD_VAR 0 2
64890: ARRAY
64891: PPUSH
64892: LD_VAR 0 3
64896: PPUSH
64897: CALL_OW 3
64901: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64902: LD_ADDR_EXP 59
64906: PUSH
64907: LD_EXP 59
64911: PPUSH
64912: LD_VAR 0 2
64916: PPUSH
64917: LD_VAR 0 5
64921: PPUSH
64922: CALL_OW 1
64926: ST_TO_ADDR
// continue ;
64927: GO 64773
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64929: LD_VAR 0 6
64933: PPUSH
64934: LD_EXP 59
64938: PUSH
64939: LD_VAR 0 2
64943: ARRAY
64944: PUSH
64945: LD_VAR 0 3
64949: ARRAY
64950: PUSH
64951: LD_INT 2
64953: ARRAY
64954: PPUSH
64955: LD_EXP 59
64959: PUSH
64960: LD_VAR 0 2
64964: ARRAY
64965: PUSH
64966: LD_VAR 0 3
64970: ARRAY
64971: PUSH
64972: LD_INT 3
64974: ARRAY
64975: PPUSH
64976: LD_INT 30
64978: PPUSH
64979: CALL 15813 0 4
64983: PUSH
64984: LD_INT 4
64986: ARRAY
64987: PUSH
64988: LD_INT 0
64990: EQUAL
64991: IFFALSE 65017
// begin target := mc_crates [ i ] [ j ] ;
64993: LD_ADDR_VAR 0 7
64997: PUSH
64998: LD_EXP 59
65002: PUSH
65003: LD_VAR 0 2
65007: ARRAY
65008: PUSH
65009: LD_VAR 0 3
65013: ARRAY
65014: ST_TO_ADDR
// break ;
65015: GO 65019
// end ; end ;
65017: GO 64773
65019: POP
65020: POP
// if not target then
65021: LD_VAR 0 7
65025: NOT
65026: IFFALSE 65030
// continue ;
65028: GO 64580
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65030: LD_ADDR_VAR 0 8
65034: PUSH
65035: LD_EXP 62
65039: PUSH
65040: LD_VAR 0 2
65044: ARRAY
65045: PPUSH
65046: LD_INT 2
65048: PUSH
65049: LD_INT 3
65051: PUSH
65052: LD_INT 58
65054: PUSH
65055: EMPTY
65056: LIST
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 61
65064: PUSH
65065: EMPTY
65066: LIST
65067: PUSH
65068: LD_INT 33
65070: PUSH
65071: LD_INT 5
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 33
65080: PUSH
65081: LD_INT 3
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 2
65097: PUSH
65098: LD_INT 34
65100: PUSH
65101: LD_INT 32
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 34
65110: PUSH
65111: LD_INT 51
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 34
65120: PUSH
65121: LD_INT 12
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PPUSH
65138: CALL_OW 72
65142: ST_TO_ADDR
// if not cargo then
65143: LD_VAR 0 8
65147: NOT
65148: IFFALSE 65854
// begin if mc_crates_collector [ i ] < 5 then
65150: LD_EXP 60
65154: PUSH
65155: LD_VAR 0 2
65159: ARRAY
65160: PUSH
65161: LD_INT 5
65163: LESS
65164: IFFALSE 65530
// begin if mc_ape [ i ] then
65166: LD_EXP 72
65170: PUSH
65171: LD_VAR 0 2
65175: ARRAY
65176: IFFALSE 65223
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65178: LD_ADDR_VAR 0 5
65182: PUSH
65183: LD_EXP 72
65187: PUSH
65188: LD_VAR 0 2
65192: ARRAY
65193: PPUSH
65194: LD_INT 25
65196: PUSH
65197: LD_INT 16
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 24
65206: PUSH
65207: LD_INT 750
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PPUSH
65218: CALL_OW 72
65222: ST_TO_ADDR
// if not tmp then
65223: LD_VAR 0 5
65227: NOT
65228: IFFALSE 65275
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65230: LD_ADDR_VAR 0 5
65234: PUSH
65235: LD_EXP 43
65239: PUSH
65240: LD_VAR 0 2
65244: ARRAY
65245: PPUSH
65246: LD_INT 25
65248: PUSH
65249: LD_INT 2
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 24
65258: PUSH
65259: LD_INT 750
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PPUSH
65270: CALL_OW 72
65274: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65275: LD_EXP 72
65279: PUSH
65280: LD_VAR 0 2
65284: ARRAY
65285: PUSH
65286: LD_EXP 43
65290: PUSH
65291: LD_VAR 0 2
65295: ARRAY
65296: PPUSH
65297: LD_INT 25
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 24
65309: PUSH
65310: LD_INT 750
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PPUSH
65321: CALL_OW 72
65325: AND
65326: PUSH
65327: LD_VAR 0 5
65331: PUSH
65332: LD_INT 5
65334: LESS
65335: AND
65336: IFFALSE 65418
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65338: LD_ADDR_VAR 0 3
65342: PUSH
65343: LD_EXP 43
65347: PUSH
65348: LD_VAR 0 2
65352: ARRAY
65353: PPUSH
65354: LD_INT 25
65356: PUSH
65357: LD_INT 2
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 24
65366: PUSH
65367: LD_INT 750
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PPUSH
65378: CALL_OW 72
65382: PUSH
65383: FOR_IN
65384: IFFALSE 65416
// begin tmp := tmp union j ;
65386: LD_ADDR_VAR 0 5
65390: PUSH
65391: LD_VAR 0 5
65395: PUSH
65396: LD_VAR 0 3
65400: UNION
65401: ST_TO_ADDR
// if tmp >= 5 then
65402: LD_VAR 0 5
65406: PUSH
65407: LD_INT 5
65409: GREATEREQUAL
65410: IFFALSE 65414
// break ;
65412: GO 65416
// end ;
65414: GO 65383
65416: POP
65417: POP
// end ; if not tmp then
65418: LD_VAR 0 5
65422: NOT
65423: IFFALSE 65427
// continue ;
65425: GO 64580
// for j in tmp do
65427: LD_ADDR_VAR 0 3
65431: PUSH
65432: LD_VAR 0 5
65436: PUSH
65437: FOR_IN
65438: IFFALSE 65528
// if not GetTag ( j ) then
65440: LD_VAR 0 3
65444: PPUSH
65445: CALL_OW 110
65449: NOT
65450: IFFALSE 65526
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65452: LD_ADDR_EXP 60
65456: PUSH
65457: LD_EXP 60
65461: PPUSH
65462: LD_VAR 0 2
65466: PUSH
65467: LD_EXP 60
65471: PUSH
65472: LD_VAR 0 2
65476: ARRAY
65477: PUSH
65478: LD_INT 1
65480: PLUS
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PPUSH
65486: LD_VAR 0 3
65490: PPUSH
65491: CALL 14917 0 3
65495: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65496: LD_VAR 0 3
65500: PPUSH
65501: LD_INT 107
65503: PPUSH
65504: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65508: LD_EXP 60
65512: PUSH
65513: LD_VAR 0 2
65517: ARRAY
65518: PUSH
65519: LD_INT 5
65521: GREATEREQUAL
65522: IFFALSE 65526
// break ;
65524: GO 65528
// end ;
65526: GO 65437
65528: POP
65529: POP
// end ; if mc_crates_collector [ i ] and target then
65530: LD_EXP 60
65534: PUSH
65535: LD_VAR 0 2
65539: ARRAY
65540: PUSH
65541: LD_VAR 0 7
65545: AND
65546: IFFALSE 65852
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65548: LD_EXP 60
65552: PUSH
65553: LD_VAR 0 2
65557: ARRAY
65558: PUSH
65559: LD_VAR 0 7
65563: PUSH
65564: LD_INT 1
65566: ARRAY
65567: LESS
65568: IFFALSE 65588
// tmp := mc_crates_collector [ i ] else
65570: LD_ADDR_VAR 0 5
65574: PUSH
65575: LD_EXP 60
65579: PUSH
65580: LD_VAR 0 2
65584: ARRAY
65585: ST_TO_ADDR
65586: GO 65602
// tmp := target [ 1 ] ;
65588: LD_ADDR_VAR 0 5
65592: PUSH
65593: LD_VAR 0 7
65597: PUSH
65598: LD_INT 1
65600: ARRAY
65601: ST_TO_ADDR
// k := 0 ;
65602: LD_ADDR_VAR 0 4
65606: PUSH
65607: LD_INT 0
65609: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65610: LD_ADDR_VAR 0 3
65614: PUSH
65615: LD_EXP 60
65619: PUSH
65620: LD_VAR 0 2
65624: ARRAY
65625: PUSH
65626: FOR_IN
65627: IFFALSE 65850
// begin k := k + 1 ;
65629: LD_ADDR_VAR 0 4
65633: PUSH
65634: LD_VAR 0 4
65638: PUSH
65639: LD_INT 1
65641: PLUS
65642: ST_TO_ADDR
// if k > tmp then
65643: LD_VAR 0 4
65647: PUSH
65648: LD_VAR 0 5
65652: GREATER
65653: IFFALSE 65657
// break ;
65655: GO 65850
// if not GetClass ( j ) in [ 2 , 16 ] then
65657: LD_VAR 0 3
65661: PPUSH
65662: CALL_OW 257
65666: PUSH
65667: LD_INT 2
65669: PUSH
65670: LD_INT 16
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: IN
65677: NOT
65678: IFFALSE 65731
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65680: LD_ADDR_EXP 60
65684: PUSH
65685: LD_EXP 60
65689: PPUSH
65690: LD_VAR 0 2
65694: PPUSH
65695: LD_EXP 60
65699: PUSH
65700: LD_VAR 0 2
65704: ARRAY
65705: PUSH
65706: LD_VAR 0 3
65710: DIFF
65711: PPUSH
65712: CALL_OW 1
65716: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65717: LD_VAR 0 3
65721: PPUSH
65722: LD_INT 0
65724: PPUSH
65725: CALL_OW 109
// continue ;
65729: GO 65626
// end ; if IsInUnit ( j ) then
65731: LD_VAR 0 3
65735: PPUSH
65736: CALL_OW 310
65740: IFFALSE 65751
// ComExitBuilding ( j ) ;
65742: LD_VAR 0 3
65746: PPUSH
65747: CALL_OW 122
// wait ( 3 ) ;
65751: LD_INT 3
65753: PPUSH
65754: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65758: LD_VAR 0 3
65762: PPUSH
65763: CALL_OW 314
65767: PUSH
65768: LD_VAR 0 6
65772: PPUSH
65773: LD_VAR 0 7
65777: PUSH
65778: LD_INT 2
65780: ARRAY
65781: PPUSH
65782: LD_VAR 0 7
65786: PUSH
65787: LD_INT 3
65789: ARRAY
65790: PPUSH
65791: LD_INT 30
65793: PPUSH
65794: CALL 15813 0 4
65798: PUSH
65799: LD_INT 4
65801: ARRAY
65802: AND
65803: IFFALSE 65821
// ComStandNearbyBuilding ( j , depot ) else
65805: LD_VAR 0 3
65809: PPUSH
65810: LD_VAR 0 9
65814: PPUSH
65815: CALL 11376 0 2
65819: GO 65848
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65821: LD_VAR 0 3
65825: PPUSH
65826: LD_VAR 0 7
65830: PUSH
65831: LD_INT 2
65833: ARRAY
65834: PPUSH
65835: LD_VAR 0 7
65839: PUSH
65840: LD_INT 3
65842: ARRAY
65843: PPUSH
65844: CALL_OW 117
// end ;
65848: GO 65626
65850: POP
65851: POP
// end ; end else
65852: GO 66384
// begin for j in cargo do
65854: LD_ADDR_VAR 0 3
65858: PUSH
65859: LD_VAR 0 8
65863: PUSH
65864: FOR_IN
65865: IFFALSE 66382
// begin if GetTag ( j ) <> 0 then
65867: LD_VAR 0 3
65871: PPUSH
65872: CALL_OW 110
65876: PUSH
65877: LD_INT 0
65879: NONEQUAL
65880: IFFALSE 65884
// continue ;
65882: GO 65864
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65884: LD_VAR 0 3
65888: PPUSH
65889: CALL_OW 256
65893: PUSH
65894: LD_INT 1000
65896: LESS
65897: PUSH
65898: LD_VAR 0 3
65902: PPUSH
65903: LD_EXP 67
65907: PUSH
65908: LD_VAR 0 2
65912: ARRAY
65913: PPUSH
65914: CALL_OW 308
65918: NOT
65919: AND
65920: IFFALSE 65942
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65922: LD_VAR 0 3
65926: PPUSH
65927: LD_EXP 67
65931: PUSH
65932: LD_VAR 0 2
65936: ARRAY
65937: PPUSH
65938: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65942: LD_VAR 0 3
65946: PPUSH
65947: CALL_OW 256
65951: PUSH
65952: LD_INT 1000
65954: LESS
65955: PUSH
65956: LD_VAR 0 3
65960: PPUSH
65961: LD_EXP 67
65965: PUSH
65966: LD_VAR 0 2
65970: ARRAY
65971: PPUSH
65972: CALL_OW 308
65976: AND
65977: IFFALSE 65981
// continue ;
65979: GO 65864
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65981: LD_VAR 0 3
65985: PPUSH
65986: CALL_OW 262
65990: PUSH
65991: LD_INT 2
65993: EQUAL
65994: PUSH
65995: LD_VAR 0 3
65999: PPUSH
66000: CALL_OW 261
66004: PUSH
66005: LD_INT 15
66007: LESS
66008: AND
66009: IFFALSE 66013
// continue ;
66011: GO 65864
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66013: LD_VAR 0 3
66017: PPUSH
66018: CALL_OW 262
66022: PUSH
66023: LD_INT 1
66025: EQUAL
66026: PUSH
66027: LD_VAR 0 3
66031: PPUSH
66032: CALL_OW 261
66036: PUSH
66037: LD_INT 10
66039: LESS
66040: AND
66041: IFFALSE 66321
// begin if not depot then
66043: LD_VAR 0 9
66047: NOT
66048: IFFALSE 66052
// continue ;
66050: GO 65864
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66052: LD_VAR 0 3
66056: PPUSH
66057: LD_VAR 0 9
66061: PPUSH
66062: LD_VAR 0 3
66066: PPUSH
66067: CALL_OW 74
66071: PPUSH
66072: CALL_OW 296
66076: PUSH
66077: LD_INT 6
66079: LESS
66080: IFFALSE 66096
// SetFuel ( j , 100 ) else
66082: LD_VAR 0 3
66086: PPUSH
66087: LD_INT 100
66089: PPUSH
66090: CALL_OW 240
66094: GO 66321
// if GetFuel ( j ) = 0 then
66096: LD_VAR 0 3
66100: PPUSH
66101: CALL_OW 261
66105: PUSH
66106: LD_INT 0
66108: EQUAL
66109: IFFALSE 66321
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66111: LD_ADDR_EXP 62
66115: PUSH
66116: LD_EXP 62
66120: PPUSH
66121: LD_VAR 0 2
66125: PPUSH
66126: LD_EXP 62
66130: PUSH
66131: LD_VAR 0 2
66135: ARRAY
66136: PUSH
66137: LD_VAR 0 3
66141: DIFF
66142: PPUSH
66143: CALL_OW 1
66147: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66148: LD_VAR 0 3
66152: PPUSH
66153: CALL_OW 263
66157: PUSH
66158: LD_INT 1
66160: EQUAL
66161: IFFALSE 66177
// ComExitVehicle ( IsInUnit ( j ) ) ;
66163: LD_VAR 0 3
66167: PPUSH
66168: CALL_OW 310
66172: PPUSH
66173: CALL_OW 121
// if GetControl ( j ) = control_remote then
66177: LD_VAR 0 3
66181: PPUSH
66182: CALL_OW 263
66186: PUSH
66187: LD_INT 2
66189: EQUAL
66190: IFFALSE 66201
// ComUnlink ( j ) ;
66192: LD_VAR 0 3
66196: PPUSH
66197: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66201: LD_ADDR_VAR 0 10
66205: PUSH
66206: LD_VAR 0 2
66210: PPUSH
66211: LD_INT 3
66213: PPUSH
66214: CALL 75988 0 2
66218: ST_TO_ADDR
// if fac then
66219: LD_VAR 0 10
66223: IFFALSE 66319
// begin for k in fac do
66225: LD_ADDR_VAR 0 4
66229: PUSH
66230: LD_VAR 0 10
66234: PUSH
66235: FOR_IN
66236: IFFALSE 66317
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66238: LD_ADDR_VAR 0 11
66242: PUSH
66243: LD_VAR 0 10
66247: PPUSH
66248: LD_VAR 0 3
66252: PPUSH
66253: CALL_OW 265
66257: PPUSH
66258: LD_VAR 0 3
66262: PPUSH
66263: CALL_OW 262
66267: PPUSH
66268: LD_VAR 0 3
66272: PPUSH
66273: CALL_OW 263
66277: PPUSH
66278: LD_VAR 0 3
66282: PPUSH
66283: CALL_OW 264
66287: PPUSH
66288: CALL 12415 0 5
66292: ST_TO_ADDR
// if components then
66293: LD_VAR 0 11
66297: IFFALSE 66315
// begin MC_InsertProduceList ( i , components ) ;
66299: LD_VAR 0 2
66303: PPUSH
66304: LD_VAR 0 11
66308: PPUSH
66309: CALL 75533 0 2
// break ;
66313: GO 66317
// end ; end ;
66315: GO 66235
66317: POP
66318: POP
// end ; continue ;
66319: GO 65864
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66321: LD_VAR 0 3
66325: PPUSH
66326: LD_INT 1
66328: PPUSH
66329: CALL_OW 289
66333: PUSH
66334: LD_INT 100
66336: LESS
66337: PUSH
66338: LD_VAR 0 3
66342: PPUSH
66343: CALL_OW 314
66347: NOT
66348: AND
66349: IFFALSE 66378
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66351: LD_VAR 0 3
66355: PPUSH
66356: LD_VAR 0 7
66360: PUSH
66361: LD_INT 2
66363: ARRAY
66364: PPUSH
66365: LD_VAR 0 7
66369: PUSH
66370: LD_INT 3
66372: ARRAY
66373: PPUSH
66374: CALL_OW 117
// break ;
66378: GO 66382
// end ;
66380: GO 65864
66382: POP
66383: POP
// end ; end ;
66384: GO 64580
66386: POP
66387: POP
// end ;
66388: LD_VAR 0 1
66392: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66393: LD_INT 0
66395: PPUSH
66396: PPUSH
66397: PPUSH
66398: PPUSH
// if not mc_bases then
66399: LD_EXP 43
66403: NOT
66404: IFFALSE 66408
// exit ;
66406: GO 66569
// for i = 1 to mc_bases do
66408: LD_ADDR_VAR 0 2
66412: PUSH
66413: DOUBLE
66414: LD_INT 1
66416: DEC
66417: ST_TO_ADDR
66418: LD_EXP 43
66422: PUSH
66423: FOR_TO
66424: IFFALSE 66567
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66426: LD_ADDR_VAR 0 4
66430: PUSH
66431: LD_EXP 62
66435: PUSH
66436: LD_VAR 0 2
66440: ARRAY
66441: PUSH
66442: LD_EXP 65
66446: PUSH
66447: LD_VAR 0 2
66451: ARRAY
66452: UNION
66453: PPUSH
66454: LD_INT 33
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PPUSH
66464: CALL_OW 72
66468: ST_TO_ADDR
// if tmp then
66469: LD_VAR 0 4
66473: IFFALSE 66565
// for j in tmp do
66475: LD_ADDR_VAR 0 3
66479: PUSH
66480: LD_VAR 0 4
66484: PUSH
66485: FOR_IN
66486: IFFALSE 66563
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66488: LD_VAR 0 3
66492: PPUSH
66493: CALL_OW 312
66497: NOT
66498: PUSH
66499: LD_VAR 0 3
66503: PPUSH
66504: CALL_OW 256
66508: PUSH
66509: LD_INT 250
66511: GREATEREQUAL
66512: AND
66513: IFFALSE 66526
// Connect ( j ) else
66515: LD_VAR 0 3
66519: PPUSH
66520: CALL 17886 0 1
66524: GO 66561
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66526: LD_VAR 0 3
66530: PPUSH
66531: CALL_OW 256
66535: PUSH
66536: LD_INT 250
66538: LESS
66539: PUSH
66540: LD_VAR 0 3
66544: PPUSH
66545: CALL_OW 312
66549: AND
66550: IFFALSE 66561
// ComUnlink ( j ) ;
66552: LD_VAR 0 3
66556: PPUSH
66557: CALL_OW 136
66561: GO 66485
66563: POP
66564: POP
// end ;
66565: GO 66423
66567: POP
66568: POP
// end ;
66569: LD_VAR 0 1
66573: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66574: LD_INT 0
66576: PPUSH
66577: PPUSH
66578: PPUSH
66579: PPUSH
66580: PPUSH
// if not mc_bases then
66581: LD_EXP 43
66585: NOT
66586: IFFALSE 66590
// exit ;
66588: GO 67035
// for i = 1 to mc_bases do
66590: LD_ADDR_VAR 0 2
66594: PUSH
66595: DOUBLE
66596: LD_INT 1
66598: DEC
66599: ST_TO_ADDR
66600: LD_EXP 43
66604: PUSH
66605: FOR_TO
66606: IFFALSE 67033
// begin if not mc_produce [ i ] then
66608: LD_EXP 64
66612: PUSH
66613: LD_VAR 0 2
66617: ARRAY
66618: NOT
66619: IFFALSE 66623
// continue ;
66621: GO 66605
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66623: LD_ADDR_VAR 0 5
66627: PUSH
66628: LD_EXP 43
66632: PUSH
66633: LD_VAR 0 2
66637: ARRAY
66638: PPUSH
66639: LD_INT 30
66641: PUSH
66642: LD_INT 3
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PPUSH
66649: CALL_OW 72
66653: ST_TO_ADDR
// if not fac then
66654: LD_VAR 0 5
66658: NOT
66659: IFFALSE 66663
// continue ;
66661: GO 66605
// for j in fac do
66663: LD_ADDR_VAR 0 3
66667: PUSH
66668: LD_VAR 0 5
66672: PUSH
66673: FOR_IN
66674: IFFALSE 67029
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66676: LD_VAR 0 3
66680: PPUSH
66681: CALL_OW 461
66685: PUSH
66686: LD_INT 2
66688: NONEQUAL
66689: PUSH
66690: LD_VAR 0 3
66694: PPUSH
66695: LD_INT 15
66697: PPUSH
66698: CALL 17514 0 2
66702: PUSH
66703: LD_INT 4
66705: ARRAY
66706: OR
66707: IFFALSE 66711
// continue ;
66709: GO 66673
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66711: LD_VAR 0 3
66715: PPUSH
66716: LD_EXP 64
66720: PUSH
66721: LD_VAR 0 2
66725: ARRAY
66726: PUSH
66727: LD_INT 1
66729: ARRAY
66730: PUSH
66731: LD_INT 1
66733: ARRAY
66734: PPUSH
66735: LD_EXP 64
66739: PUSH
66740: LD_VAR 0 2
66744: ARRAY
66745: PUSH
66746: LD_INT 1
66748: ARRAY
66749: PUSH
66750: LD_INT 2
66752: ARRAY
66753: PPUSH
66754: LD_EXP 64
66758: PUSH
66759: LD_VAR 0 2
66763: ARRAY
66764: PUSH
66765: LD_INT 1
66767: ARRAY
66768: PUSH
66769: LD_INT 3
66771: ARRAY
66772: PPUSH
66773: LD_EXP 64
66777: PUSH
66778: LD_VAR 0 2
66782: ARRAY
66783: PUSH
66784: LD_INT 1
66786: ARRAY
66787: PUSH
66788: LD_INT 4
66790: ARRAY
66791: PPUSH
66792: CALL_OW 448
66796: PUSH
66797: LD_VAR 0 3
66801: PPUSH
66802: LD_EXP 64
66806: PUSH
66807: LD_VAR 0 2
66811: ARRAY
66812: PUSH
66813: LD_INT 1
66815: ARRAY
66816: PUSH
66817: LD_INT 1
66819: ARRAY
66820: PUSH
66821: LD_EXP 64
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: PUSH
66832: LD_INT 1
66834: ARRAY
66835: PUSH
66836: LD_INT 2
66838: ARRAY
66839: PUSH
66840: LD_EXP 64
66844: PUSH
66845: LD_VAR 0 2
66849: ARRAY
66850: PUSH
66851: LD_INT 1
66853: ARRAY
66854: PUSH
66855: LD_INT 3
66857: ARRAY
66858: PUSH
66859: LD_EXP 64
66863: PUSH
66864: LD_VAR 0 2
66868: ARRAY
66869: PUSH
66870: LD_INT 1
66872: ARRAY
66873: PUSH
66874: LD_INT 4
66876: ARRAY
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: PPUSH
66884: CALL 21281 0 2
66888: AND
66889: IFFALSE 67027
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66891: LD_VAR 0 3
66895: PPUSH
66896: LD_EXP 64
66900: PUSH
66901: LD_VAR 0 2
66905: ARRAY
66906: PUSH
66907: LD_INT 1
66909: ARRAY
66910: PUSH
66911: LD_INT 1
66913: ARRAY
66914: PPUSH
66915: LD_EXP 64
66919: PUSH
66920: LD_VAR 0 2
66924: ARRAY
66925: PUSH
66926: LD_INT 1
66928: ARRAY
66929: PUSH
66930: LD_INT 2
66932: ARRAY
66933: PPUSH
66934: LD_EXP 64
66938: PUSH
66939: LD_VAR 0 2
66943: ARRAY
66944: PUSH
66945: LD_INT 1
66947: ARRAY
66948: PUSH
66949: LD_INT 3
66951: ARRAY
66952: PPUSH
66953: LD_EXP 64
66957: PUSH
66958: LD_VAR 0 2
66962: ARRAY
66963: PUSH
66964: LD_INT 1
66966: ARRAY
66967: PUSH
66968: LD_INT 4
66970: ARRAY
66971: PPUSH
66972: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66976: LD_ADDR_VAR 0 4
66980: PUSH
66981: LD_EXP 64
66985: PUSH
66986: LD_VAR 0 2
66990: ARRAY
66991: PPUSH
66992: LD_INT 1
66994: PPUSH
66995: CALL_OW 3
66999: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67000: LD_ADDR_EXP 64
67004: PUSH
67005: LD_EXP 64
67009: PPUSH
67010: LD_VAR 0 2
67014: PPUSH
67015: LD_VAR 0 4
67019: PPUSH
67020: CALL_OW 1
67024: ST_TO_ADDR
// break ;
67025: GO 67029
// end ; end ;
67027: GO 66673
67029: POP
67030: POP
// end ;
67031: GO 66605
67033: POP
67034: POP
// end ;
67035: LD_VAR 0 1
67039: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67040: LD_INT 0
67042: PPUSH
67043: PPUSH
67044: PPUSH
// if not mc_bases then
67045: LD_EXP 43
67049: NOT
67050: IFFALSE 67054
// exit ;
67052: GO 67143
// for i = 1 to mc_bases do
67054: LD_ADDR_VAR 0 2
67058: PUSH
67059: DOUBLE
67060: LD_INT 1
67062: DEC
67063: ST_TO_ADDR
67064: LD_EXP 43
67068: PUSH
67069: FOR_TO
67070: IFFALSE 67141
// begin if mc_attack [ i ] then
67072: LD_EXP 63
67076: PUSH
67077: LD_VAR 0 2
67081: ARRAY
67082: IFFALSE 67139
// begin tmp := mc_attack [ i ] [ 1 ] ;
67084: LD_ADDR_VAR 0 3
67088: PUSH
67089: LD_EXP 63
67093: PUSH
67094: LD_VAR 0 2
67098: ARRAY
67099: PUSH
67100: LD_INT 1
67102: ARRAY
67103: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67104: LD_ADDR_EXP 63
67108: PUSH
67109: LD_EXP 63
67113: PPUSH
67114: LD_VAR 0 2
67118: PPUSH
67119: EMPTY
67120: PPUSH
67121: CALL_OW 1
67125: ST_TO_ADDR
// Attack ( tmp ) ;
67126: LD_VAR 0 3
67130: PPUSH
67131: CALL 81959 0 1
// exit ;
67135: POP
67136: POP
67137: GO 67143
// end ; end ;
67139: GO 67069
67141: POP
67142: POP
// end ;
67143: LD_VAR 0 1
67147: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67148: LD_INT 0
67150: PPUSH
67151: PPUSH
67152: PPUSH
67153: PPUSH
67154: PPUSH
67155: PPUSH
67156: PPUSH
// if not mc_bases then
67157: LD_EXP 43
67161: NOT
67162: IFFALSE 67166
// exit ;
67164: GO 68023
// for i = 1 to mc_bases do
67166: LD_ADDR_VAR 0 2
67170: PUSH
67171: DOUBLE
67172: LD_INT 1
67174: DEC
67175: ST_TO_ADDR
67176: LD_EXP 43
67180: PUSH
67181: FOR_TO
67182: IFFALSE 68021
// begin if not mc_bases [ i ] then
67184: LD_EXP 43
67188: PUSH
67189: LD_VAR 0 2
67193: ARRAY
67194: NOT
67195: IFFALSE 67199
// continue ;
67197: GO 67181
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67199: LD_ADDR_VAR 0 7
67203: PUSH
67204: LD_EXP 43
67208: PUSH
67209: LD_VAR 0 2
67213: ARRAY
67214: PUSH
67215: LD_INT 1
67217: ARRAY
67218: PPUSH
67219: CALL 11598 0 1
67223: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67224: LD_ADDR_EXP 66
67228: PUSH
67229: LD_EXP 66
67233: PPUSH
67234: LD_VAR 0 2
67238: PPUSH
67239: LD_EXP 43
67243: PUSH
67244: LD_VAR 0 2
67248: ARRAY
67249: PUSH
67250: LD_INT 1
67252: ARRAY
67253: PPUSH
67254: CALL_OW 255
67258: PPUSH
67259: LD_EXP 68
67263: PUSH
67264: LD_VAR 0 2
67268: ARRAY
67269: PPUSH
67270: CALL 11563 0 2
67274: PPUSH
67275: CALL_OW 1
67279: ST_TO_ADDR
// if not mc_scan [ i ] then
67280: LD_EXP 66
67284: PUSH
67285: LD_VAR 0 2
67289: ARRAY
67290: NOT
67291: IFFALSE 67469
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67293: LD_ADDR_EXP 86
67297: PUSH
67298: LD_EXP 86
67302: PPUSH
67303: LD_VAR 0 2
67307: PPUSH
67308: LD_INT 0
67310: PPUSH
67311: CALL_OW 1
67315: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67316: LD_ADDR_VAR 0 4
67320: PUSH
67321: LD_EXP 43
67325: PUSH
67326: LD_VAR 0 2
67330: ARRAY
67331: PPUSH
67332: LD_INT 2
67334: PUSH
67335: LD_INT 25
67337: PUSH
67338: LD_INT 5
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 25
67347: PUSH
67348: LD_INT 8
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 25
67357: PUSH
67358: LD_INT 9
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: PPUSH
67371: CALL_OW 72
67375: ST_TO_ADDR
// if not tmp then
67376: LD_VAR 0 4
67380: NOT
67381: IFFALSE 67385
// continue ;
67383: GO 67181
// for j in tmp do
67385: LD_ADDR_VAR 0 3
67389: PUSH
67390: LD_VAR 0 4
67394: PUSH
67395: FOR_IN
67396: IFFALSE 67467
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67398: LD_VAR 0 3
67402: PPUSH
67403: CALL_OW 310
67407: PPUSH
67408: CALL_OW 266
67412: PUSH
67413: LD_INT 5
67415: EQUAL
67416: PUSH
67417: LD_VAR 0 3
67421: PPUSH
67422: CALL_OW 257
67426: PUSH
67427: LD_INT 1
67429: EQUAL
67430: AND
67431: PUSH
67432: LD_VAR 0 3
67436: PPUSH
67437: CALL_OW 459
67441: NOT
67442: AND
67443: PUSH
67444: LD_VAR 0 7
67448: AND
67449: IFFALSE 67465
// ComChangeProfession ( j , class ) ;
67451: LD_VAR 0 3
67455: PPUSH
67456: LD_VAR 0 7
67460: PPUSH
67461: CALL_OW 123
67465: GO 67395
67467: POP
67468: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67469: LD_EXP 66
67473: PUSH
67474: LD_VAR 0 2
67478: ARRAY
67479: PUSH
67480: LD_EXP 86
67484: PUSH
67485: LD_VAR 0 2
67489: ARRAY
67490: NOT
67491: AND
67492: PUSH
67493: LD_EXP 65
67497: PUSH
67498: LD_VAR 0 2
67502: ARRAY
67503: NOT
67504: AND
67505: PUSH
67506: LD_EXP 43
67510: PUSH
67511: LD_VAR 0 2
67515: ARRAY
67516: PPUSH
67517: LD_INT 50
67519: PUSH
67520: EMPTY
67521: LIST
67522: PUSH
67523: LD_INT 2
67525: PUSH
67526: LD_INT 30
67528: PUSH
67529: LD_INT 32
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 30
67538: PUSH
67539: LD_INT 33
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 30
67548: PUSH
67549: LD_INT 4
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PUSH
67556: LD_INT 30
67558: PUSH
67559: LD_INT 5
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PPUSH
67577: CALL_OW 72
67581: PUSH
67582: LD_INT 4
67584: LESS
67585: PUSH
67586: LD_EXP 43
67590: PUSH
67591: LD_VAR 0 2
67595: ARRAY
67596: PPUSH
67597: LD_INT 3
67599: PUSH
67600: LD_INT 24
67602: PUSH
67603: LD_INT 1000
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 2
67616: PUSH
67617: LD_INT 30
67619: PUSH
67620: LD_INT 0
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 30
67629: PUSH
67630: LD_INT 1
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: LIST
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PPUSH
67646: CALL_OW 72
67650: OR
67651: AND
67652: IFFALSE 67903
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67654: LD_ADDR_EXP 86
67658: PUSH
67659: LD_EXP 86
67663: PPUSH
67664: LD_VAR 0 2
67668: PPUSH
67669: LD_INT 1
67671: PPUSH
67672: CALL_OW 1
67676: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67677: LD_ADDR_VAR 0 4
67681: PUSH
67682: LD_EXP 43
67686: PUSH
67687: LD_VAR 0 2
67691: ARRAY
67692: PPUSH
67693: LD_INT 2
67695: PUSH
67696: LD_INT 25
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 25
67708: PUSH
67709: LD_INT 5
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 25
67718: PUSH
67719: LD_INT 8
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 25
67728: PUSH
67729: LD_INT 9
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: PPUSH
67743: CALL_OW 72
67747: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67748: LD_ADDR_VAR 0 4
67752: PUSH
67753: LD_VAR 0 4
67757: PUSH
67758: LD_VAR 0 4
67762: PPUSH
67763: LD_INT 18
67765: PPUSH
67766: CALL 44829 0 2
67770: DIFF
67771: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67772: LD_VAR 0 4
67776: NOT
67777: PUSH
67778: LD_EXP 43
67782: PUSH
67783: LD_VAR 0 2
67787: ARRAY
67788: PPUSH
67789: LD_INT 2
67791: PUSH
67792: LD_INT 30
67794: PUSH
67795: LD_INT 4
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 30
67804: PUSH
67805: LD_INT 5
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: LIST
67816: PPUSH
67817: CALL_OW 72
67821: NOT
67822: AND
67823: IFFALSE 67885
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67825: LD_ADDR_VAR 0 4
67829: PUSH
67830: LD_EXP 43
67834: PUSH
67835: LD_VAR 0 2
67839: ARRAY
67840: PPUSH
67841: LD_INT 2
67843: PUSH
67844: LD_INT 25
67846: PUSH
67847: LD_INT 2
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PUSH
67854: LD_INT 25
67856: PUSH
67857: LD_INT 3
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 25
67866: PUSH
67867: LD_INT 4
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: PPUSH
67880: CALL_OW 72
67884: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67885: LD_VAR 0 2
67889: PPUSH
67890: LD_VAR 0 4
67894: PPUSH
67895: CALL 86668 0 2
// exit ;
67899: POP
67900: POP
67901: GO 68023
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67903: LD_EXP 66
67907: PUSH
67908: LD_VAR 0 2
67912: ARRAY
67913: PUSH
67914: LD_EXP 86
67918: PUSH
67919: LD_VAR 0 2
67923: ARRAY
67924: NOT
67925: AND
67926: PUSH
67927: LD_EXP 65
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: AND
67938: IFFALSE 68019
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67940: LD_ADDR_EXP 86
67944: PUSH
67945: LD_EXP 86
67949: PPUSH
67950: LD_VAR 0 2
67954: PPUSH
67955: LD_INT 1
67957: PPUSH
67958: CALL_OW 1
67962: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67963: LD_ADDR_VAR 0 4
67967: PUSH
67968: LD_EXP 65
67972: PUSH
67973: LD_VAR 0 2
67977: ARRAY
67978: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67979: LD_ADDR_EXP 65
67983: PUSH
67984: LD_EXP 65
67988: PPUSH
67989: LD_VAR 0 2
67993: PPUSH
67994: EMPTY
67995: PPUSH
67996: CALL_OW 1
68000: ST_TO_ADDR
// Defend ( i , tmp ) ;
68001: LD_VAR 0 2
68005: PPUSH
68006: LD_VAR 0 4
68010: PPUSH
68011: CALL 87264 0 2
// exit ;
68015: POP
68016: POP
68017: GO 68023
// end ; end ;
68019: GO 67181
68021: POP
68022: POP
// end ;
68023: LD_VAR 0 1
68027: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68028: LD_INT 0
68030: PPUSH
68031: PPUSH
68032: PPUSH
68033: PPUSH
68034: PPUSH
68035: PPUSH
68036: PPUSH
68037: PPUSH
68038: PPUSH
68039: PPUSH
68040: PPUSH
// if not mc_bases then
68041: LD_EXP 43
68045: NOT
68046: IFFALSE 68050
// exit ;
68048: GO 69137
// for i = 1 to mc_bases do
68050: LD_ADDR_VAR 0 2
68054: PUSH
68055: DOUBLE
68056: LD_INT 1
68058: DEC
68059: ST_TO_ADDR
68060: LD_EXP 43
68064: PUSH
68065: FOR_TO
68066: IFFALSE 69135
// begin tmp := mc_lab [ i ] ;
68068: LD_ADDR_VAR 0 6
68072: PUSH
68073: LD_EXP 76
68077: PUSH
68078: LD_VAR 0 2
68082: ARRAY
68083: ST_TO_ADDR
// if not tmp then
68084: LD_VAR 0 6
68088: NOT
68089: IFFALSE 68093
// continue ;
68091: GO 68065
// idle_lab := 0 ;
68093: LD_ADDR_VAR 0 11
68097: PUSH
68098: LD_INT 0
68100: ST_TO_ADDR
// for j in tmp do
68101: LD_ADDR_VAR 0 3
68105: PUSH
68106: LD_VAR 0 6
68110: PUSH
68111: FOR_IN
68112: IFFALSE 69131
// begin researching := false ;
68114: LD_ADDR_VAR 0 10
68118: PUSH
68119: LD_INT 0
68121: ST_TO_ADDR
// side := GetSide ( j ) ;
68122: LD_ADDR_VAR 0 4
68126: PUSH
68127: LD_VAR 0 3
68131: PPUSH
68132: CALL_OW 255
68136: ST_TO_ADDR
// if not mc_tech [ side ] then
68137: LD_EXP 70
68141: PUSH
68142: LD_VAR 0 4
68146: ARRAY
68147: NOT
68148: IFFALSE 68152
// continue ;
68150: GO 68111
// if BuildingStatus ( j ) = bs_idle then
68152: LD_VAR 0 3
68156: PPUSH
68157: CALL_OW 461
68161: PUSH
68162: LD_INT 2
68164: EQUAL
68165: IFFALSE 68353
// begin if idle_lab and UnitsInside ( j ) < 6 then
68167: LD_VAR 0 11
68171: PUSH
68172: LD_VAR 0 3
68176: PPUSH
68177: CALL_OW 313
68181: PUSH
68182: LD_INT 6
68184: LESS
68185: AND
68186: IFFALSE 68257
// begin tmp2 := UnitsInside ( idle_lab ) ;
68188: LD_ADDR_VAR 0 9
68192: PUSH
68193: LD_VAR 0 11
68197: PPUSH
68198: CALL_OW 313
68202: ST_TO_ADDR
// if tmp2 then
68203: LD_VAR 0 9
68207: IFFALSE 68249
// for x in tmp2 do
68209: LD_ADDR_VAR 0 7
68213: PUSH
68214: LD_VAR 0 9
68218: PUSH
68219: FOR_IN
68220: IFFALSE 68247
// begin ComExitBuilding ( x ) ;
68222: LD_VAR 0 7
68226: PPUSH
68227: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68231: LD_VAR 0 7
68235: PPUSH
68236: LD_VAR 0 3
68240: PPUSH
68241: CALL_OW 180
// end ;
68245: GO 68219
68247: POP
68248: POP
// idle_lab := 0 ;
68249: LD_ADDR_VAR 0 11
68253: PUSH
68254: LD_INT 0
68256: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68257: LD_ADDR_VAR 0 5
68261: PUSH
68262: LD_EXP 70
68266: PUSH
68267: LD_VAR 0 4
68271: ARRAY
68272: PUSH
68273: FOR_IN
68274: IFFALSE 68334
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68276: LD_VAR 0 3
68280: PPUSH
68281: LD_VAR 0 5
68285: PPUSH
68286: CALL_OW 430
68290: PUSH
68291: LD_VAR 0 4
68295: PPUSH
68296: LD_VAR 0 5
68300: PPUSH
68301: CALL 10668 0 2
68305: AND
68306: IFFALSE 68332
// begin researching := true ;
68308: LD_ADDR_VAR 0 10
68312: PUSH
68313: LD_INT 1
68315: ST_TO_ADDR
// ComResearch ( j , t ) ;
68316: LD_VAR 0 3
68320: PPUSH
68321: LD_VAR 0 5
68325: PPUSH
68326: CALL_OW 124
// break ;
68330: GO 68334
// end ;
68332: GO 68273
68334: POP
68335: POP
// if not researching then
68336: LD_VAR 0 10
68340: NOT
68341: IFFALSE 68353
// idle_lab := j ;
68343: LD_ADDR_VAR 0 11
68347: PUSH
68348: LD_VAR 0 3
68352: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68353: LD_VAR 0 3
68357: PPUSH
68358: CALL_OW 461
68362: PUSH
68363: LD_INT 10
68365: EQUAL
68366: IFFALSE 68954
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68368: LD_EXP 72
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: NOT
68379: PUSH
68380: LD_EXP 73
68384: PUSH
68385: LD_VAR 0 2
68389: ARRAY
68390: NOT
68391: AND
68392: PUSH
68393: LD_EXP 70
68397: PUSH
68398: LD_VAR 0 4
68402: ARRAY
68403: PUSH
68404: LD_INT 1
68406: GREATER
68407: AND
68408: IFFALSE 68539
// begin ComCancel ( j ) ;
68410: LD_VAR 0 3
68414: PPUSH
68415: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68419: LD_ADDR_EXP 70
68423: PUSH
68424: LD_EXP 70
68428: PPUSH
68429: LD_VAR 0 4
68433: PPUSH
68434: LD_EXP 70
68438: PUSH
68439: LD_VAR 0 4
68443: ARRAY
68444: PPUSH
68445: LD_EXP 70
68449: PUSH
68450: LD_VAR 0 4
68454: ARRAY
68455: PUSH
68456: LD_INT 1
68458: MINUS
68459: PPUSH
68460: LD_EXP 70
68464: PUSH
68465: LD_VAR 0 4
68469: ARRAY
68470: PPUSH
68471: LD_INT 0
68473: PPUSH
68474: CALL 14335 0 4
68478: PPUSH
68479: CALL_OW 1
68483: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68484: LD_ADDR_EXP 70
68488: PUSH
68489: LD_EXP 70
68493: PPUSH
68494: LD_VAR 0 4
68498: PPUSH
68499: LD_EXP 70
68503: PUSH
68504: LD_VAR 0 4
68508: ARRAY
68509: PPUSH
68510: LD_EXP 70
68514: PUSH
68515: LD_VAR 0 4
68519: ARRAY
68520: PPUSH
68521: LD_INT 1
68523: PPUSH
68524: LD_INT 0
68526: PPUSH
68527: CALL 14335 0 4
68531: PPUSH
68532: CALL_OW 1
68536: ST_TO_ADDR
// continue ;
68537: GO 68111
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68539: LD_EXP 72
68543: PUSH
68544: LD_VAR 0 2
68548: ARRAY
68549: PUSH
68550: LD_EXP 73
68554: PUSH
68555: LD_VAR 0 2
68559: ARRAY
68560: NOT
68561: AND
68562: IFFALSE 68689
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68564: LD_ADDR_EXP 73
68568: PUSH
68569: LD_EXP 73
68573: PPUSH
68574: LD_VAR 0 2
68578: PUSH
68579: LD_EXP 73
68583: PUSH
68584: LD_VAR 0 2
68588: ARRAY
68589: PUSH
68590: LD_INT 1
68592: PLUS
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PPUSH
68598: LD_EXP 72
68602: PUSH
68603: LD_VAR 0 2
68607: ARRAY
68608: PUSH
68609: LD_INT 1
68611: ARRAY
68612: PPUSH
68613: CALL 14917 0 3
68617: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68618: LD_EXP 72
68622: PUSH
68623: LD_VAR 0 2
68627: ARRAY
68628: PUSH
68629: LD_INT 1
68631: ARRAY
68632: PPUSH
68633: LD_INT 112
68635: PPUSH
68636: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68640: LD_ADDR_VAR 0 9
68644: PUSH
68645: LD_EXP 72
68649: PUSH
68650: LD_VAR 0 2
68654: ARRAY
68655: PPUSH
68656: LD_INT 1
68658: PPUSH
68659: CALL_OW 3
68663: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68664: LD_ADDR_EXP 72
68668: PUSH
68669: LD_EXP 72
68673: PPUSH
68674: LD_VAR 0 2
68678: PPUSH
68679: LD_VAR 0 9
68683: PPUSH
68684: CALL_OW 1
68688: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68689: LD_EXP 72
68693: PUSH
68694: LD_VAR 0 2
68698: ARRAY
68699: PUSH
68700: LD_EXP 73
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: AND
68711: PUSH
68712: LD_EXP 73
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PUSH
68723: LD_INT 1
68725: ARRAY
68726: PPUSH
68727: CALL_OW 310
68731: NOT
68732: AND
68733: PUSH
68734: LD_VAR 0 3
68738: PPUSH
68739: CALL_OW 313
68743: PUSH
68744: LD_INT 6
68746: EQUAL
68747: AND
68748: IFFALSE 68804
// begin tmp2 := UnitsInside ( j ) ;
68750: LD_ADDR_VAR 0 9
68754: PUSH
68755: LD_VAR 0 3
68759: PPUSH
68760: CALL_OW 313
68764: ST_TO_ADDR
// if tmp2 = 6 then
68765: LD_VAR 0 9
68769: PUSH
68770: LD_INT 6
68772: EQUAL
68773: IFFALSE 68804
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68775: LD_VAR 0 9
68779: PUSH
68780: LD_INT 1
68782: ARRAY
68783: PPUSH
68784: LD_INT 112
68786: PPUSH
68787: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68791: LD_VAR 0 9
68795: PUSH
68796: LD_INT 1
68798: ARRAY
68799: PPUSH
68800: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68804: LD_EXP 73
68808: PUSH
68809: LD_VAR 0 2
68813: ARRAY
68814: PUSH
68815: LD_EXP 73
68819: PUSH
68820: LD_VAR 0 2
68824: ARRAY
68825: PUSH
68826: LD_INT 1
68828: ARRAY
68829: PPUSH
68830: CALL_OW 314
68834: NOT
68835: AND
68836: PUSH
68837: LD_EXP 73
68841: PUSH
68842: LD_VAR 0 2
68846: ARRAY
68847: PUSH
68848: LD_INT 1
68850: ARRAY
68851: PPUSH
68852: CALL_OW 310
68856: NOT
68857: AND
68858: IFFALSE 68884
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68860: LD_EXP 73
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PUSH
68871: LD_INT 1
68873: ARRAY
68874: PPUSH
68875: LD_VAR 0 3
68879: PPUSH
68880: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68884: LD_EXP 73
68888: PUSH
68889: LD_VAR 0 2
68893: ARRAY
68894: PUSH
68895: LD_INT 1
68897: ARRAY
68898: PPUSH
68899: CALL_OW 310
68903: PUSH
68904: LD_EXP 73
68908: PUSH
68909: LD_VAR 0 2
68913: ARRAY
68914: PUSH
68915: LD_INT 1
68917: ARRAY
68918: PPUSH
68919: CALL_OW 310
68923: PPUSH
68924: CALL_OW 461
68928: PUSH
68929: LD_INT 3
68931: NONEQUAL
68932: AND
68933: IFFALSE 68954
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68935: LD_EXP 73
68939: PUSH
68940: LD_VAR 0 2
68944: ARRAY
68945: PUSH
68946: LD_INT 1
68948: ARRAY
68949: PPUSH
68950: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68954: LD_VAR 0 3
68958: PPUSH
68959: CALL_OW 461
68963: PUSH
68964: LD_INT 6
68966: EQUAL
68967: PUSH
68968: LD_VAR 0 6
68972: PUSH
68973: LD_INT 1
68975: GREATER
68976: AND
68977: IFFALSE 69129
// begin sci := [ ] ;
68979: LD_ADDR_VAR 0 8
68983: PUSH
68984: EMPTY
68985: ST_TO_ADDR
// for x in ( tmp diff j ) do
68986: LD_ADDR_VAR 0 7
68990: PUSH
68991: LD_VAR 0 6
68995: PUSH
68996: LD_VAR 0 3
69000: DIFF
69001: PUSH
69002: FOR_IN
69003: IFFALSE 69055
// begin if sci = 6 then
69005: LD_VAR 0 8
69009: PUSH
69010: LD_INT 6
69012: EQUAL
69013: IFFALSE 69017
// break ;
69015: GO 69055
// if BuildingStatus ( x ) = bs_idle then
69017: LD_VAR 0 7
69021: PPUSH
69022: CALL_OW 461
69026: PUSH
69027: LD_INT 2
69029: EQUAL
69030: IFFALSE 69053
// sci := sci ^ UnitsInside ( x ) ;
69032: LD_ADDR_VAR 0 8
69036: PUSH
69037: LD_VAR 0 8
69041: PUSH
69042: LD_VAR 0 7
69046: PPUSH
69047: CALL_OW 313
69051: ADD
69052: ST_TO_ADDR
// end ;
69053: GO 69002
69055: POP
69056: POP
// if not sci then
69057: LD_VAR 0 8
69061: NOT
69062: IFFALSE 69066
// continue ;
69064: GO 68111
// for x in sci do
69066: LD_ADDR_VAR 0 7
69070: PUSH
69071: LD_VAR 0 8
69075: PUSH
69076: FOR_IN
69077: IFFALSE 69127
// if IsInUnit ( x ) and not HasTask ( x ) then
69079: LD_VAR 0 7
69083: PPUSH
69084: CALL_OW 310
69088: PUSH
69089: LD_VAR 0 7
69093: PPUSH
69094: CALL_OW 314
69098: NOT
69099: AND
69100: IFFALSE 69125
// begin ComExitBuilding ( x ) ;
69102: LD_VAR 0 7
69106: PPUSH
69107: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69111: LD_VAR 0 7
69115: PPUSH
69116: LD_VAR 0 3
69120: PPUSH
69121: CALL_OW 180
// end ;
69125: GO 69076
69127: POP
69128: POP
// end ; end ;
69129: GO 68111
69131: POP
69132: POP
// end ;
69133: GO 68065
69135: POP
69136: POP
// end ;
69137: LD_VAR 0 1
69141: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69142: LD_INT 0
69144: PPUSH
69145: PPUSH
// if not mc_bases then
69146: LD_EXP 43
69150: NOT
69151: IFFALSE 69155
// exit ;
69153: GO 69236
// for i = 1 to mc_bases do
69155: LD_ADDR_VAR 0 2
69159: PUSH
69160: DOUBLE
69161: LD_INT 1
69163: DEC
69164: ST_TO_ADDR
69165: LD_EXP 43
69169: PUSH
69170: FOR_TO
69171: IFFALSE 69234
// if mc_mines [ i ] and mc_miners [ i ] then
69173: LD_EXP 56
69177: PUSH
69178: LD_VAR 0 2
69182: ARRAY
69183: PUSH
69184: LD_EXP 57
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: AND
69195: IFFALSE 69232
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69197: LD_EXP 57
69201: PUSH
69202: LD_VAR 0 2
69206: ARRAY
69207: PUSH
69208: LD_INT 1
69210: ARRAY
69211: PPUSH
69212: CALL_OW 255
69216: PPUSH
69217: LD_EXP 56
69221: PUSH
69222: LD_VAR 0 2
69226: ARRAY
69227: PPUSH
69228: CALL 11751 0 2
69232: GO 69170
69234: POP
69235: POP
// end ;
69236: LD_VAR 0 1
69240: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69241: LD_INT 0
69243: PPUSH
69244: PPUSH
69245: PPUSH
69246: PPUSH
69247: PPUSH
69248: PPUSH
69249: PPUSH
69250: PPUSH
// if not mc_bases or not mc_parking then
69251: LD_EXP 43
69255: NOT
69256: PUSH
69257: LD_EXP 67
69261: NOT
69262: OR
69263: IFFALSE 69267
// exit ;
69265: GO 70005
// for i = 1 to mc_bases do
69267: LD_ADDR_VAR 0 2
69271: PUSH
69272: DOUBLE
69273: LD_INT 1
69275: DEC
69276: ST_TO_ADDR
69277: LD_EXP 43
69281: PUSH
69282: FOR_TO
69283: IFFALSE 70003
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69285: LD_EXP 43
69289: PUSH
69290: LD_VAR 0 2
69294: ARRAY
69295: NOT
69296: PUSH
69297: LD_EXP 67
69301: PUSH
69302: LD_VAR 0 2
69306: ARRAY
69307: NOT
69308: OR
69309: IFFALSE 69313
// continue ;
69311: GO 69282
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69313: LD_ADDR_VAR 0 5
69317: PUSH
69318: LD_EXP 43
69322: PUSH
69323: LD_VAR 0 2
69327: ARRAY
69328: PUSH
69329: LD_INT 1
69331: ARRAY
69332: PPUSH
69333: CALL_OW 255
69337: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69338: LD_ADDR_VAR 0 6
69342: PUSH
69343: LD_EXP 43
69347: PUSH
69348: LD_VAR 0 2
69352: ARRAY
69353: PPUSH
69354: LD_INT 30
69356: PUSH
69357: LD_INT 3
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PPUSH
69364: CALL_OW 72
69368: ST_TO_ADDR
// if not fac then
69369: LD_VAR 0 6
69373: NOT
69374: IFFALSE 69425
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69376: LD_ADDR_VAR 0 6
69380: PUSH
69381: LD_EXP 43
69385: PUSH
69386: LD_VAR 0 2
69390: ARRAY
69391: PPUSH
69392: LD_INT 2
69394: PUSH
69395: LD_INT 30
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 30
69407: PUSH
69408: LD_INT 1
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: LIST
69419: PPUSH
69420: CALL_OW 72
69424: ST_TO_ADDR
// if not fac then
69425: LD_VAR 0 6
69429: NOT
69430: IFFALSE 69434
// continue ;
69432: GO 69282
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69434: LD_ADDR_VAR 0 7
69438: PUSH
69439: LD_EXP 67
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PPUSH
69450: LD_INT 22
69452: PUSH
69453: LD_VAR 0 5
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 21
69464: PUSH
69465: LD_INT 2
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 3
69474: PUSH
69475: LD_INT 60
69477: PUSH
69478: EMPTY
69479: LIST
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 3
69487: PUSH
69488: LD_INT 24
69490: PUSH
69491: LD_INT 1000
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: PPUSH
69508: CALL_OW 70
69512: ST_TO_ADDR
// for j in fac do
69513: LD_ADDR_VAR 0 3
69517: PUSH
69518: LD_VAR 0 6
69522: PUSH
69523: FOR_IN
69524: IFFALSE 69619
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69526: LD_ADDR_VAR 0 7
69530: PUSH
69531: LD_VAR 0 7
69535: PUSH
69536: LD_INT 22
69538: PUSH
69539: LD_VAR 0 5
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 91
69550: PUSH
69551: LD_VAR 0 3
69555: PUSH
69556: LD_INT 15
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 21
69566: PUSH
69567: LD_INT 2
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 3
69576: PUSH
69577: LD_INT 60
69579: PUSH
69580: EMPTY
69581: LIST
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 3
69589: PUSH
69590: LD_INT 24
69592: PUSH
69593: LD_INT 1000
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: PPUSH
69611: CALL_OW 69
69615: UNION
69616: ST_TO_ADDR
69617: GO 69523
69619: POP
69620: POP
// if not vehs then
69621: LD_VAR 0 7
69625: NOT
69626: IFFALSE 69652
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69628: LD_ADDR_EXP 55
69632: PUSH
69633: LD_EXP 55
69637: PPUSH
69638: LD_VAR 0 2
69642: PPUSH
69643: EMPTY
69644: PPUSH
69645: CALL_OW 1
69649: ST_TO_ADDR
// continue ;
69650: GO 69282
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69652: LD_ADDR_VAR 0 8
69656: PUSH
69657: LD_EXP 43
69661: PUSH
69662: LD_VAR 0 2
69666: ARRAY
69667: PPUSH
69668: LD_INT 30
69670: PUSH
69671: LD_INT 3
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PPUSH
69678: CALL_OW 72
69682: ST_TO_ADDR
// if tmp then
69683: LD_VAR 0 8
69687: IFFALSE 69790
// begin for j in tmp do
69689: LD_ADDR_VAR 0 3
69693: PUSH
69694: LD_VAR 0 8
69698: PUSH
69699: FOR_IN
69700: IFFALSE 69788
// for k in UnitsInside ( j ) do
69702: LD_ADDR_VAR 0 4
69706: PUSH
69707: LD_VAR 0 3
69711: PPUSH
69712: CALL_OW 313
69716: PUSH
69717: FOR_IN
69718: IFFALSE 69784
// if k then
69720: LD_VAR 0 4
69724: IFFALSE 69782
// if not k in mc_repair_vehicle [ i ] then
69726: LD_VAR 0 4
69730: PUSH
69731: LD_EXP 55
69735: PUSH
69736: LD_VAR 0 2
69740: ARRAY
69741: IN
69742: NOT
69743: IFFALSE 69782
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69745: LD_ADDR_EXP 55
69749: PUSH
69750: LD_EXP 55
69754: PPUSH
69755: LD_VAR 0 2
69759: PPUSH
69760: LD_EXP 55
69764: PUSH
69765: LD_VAR 0 2
69769: ARRAY
69770: PUSH
69771: LD_VAR 0 4
69775: UNION
69776: PPUSH
69777: CALL_OW 1
69781: ST_TO_ADDR
69782: GO 69717
69784: POP
69785: POP
69786: GO 69699
69788: POP
69789: POP
// end ; if not mc_repair_vehicle [ i ] then
69790: LD_EXP 55
69794: PUSH
69795: LD_VAR 0 2
69799: ARRAY
69800: NOT
69801: IFFALSE 69805
// continue ;
69803: GO 69282
// for j in mc_repair_vehicle [ i ] do
69805: LD_ADDR_VAR 0 3
69809: PUSH
69810: LD_EXP 55
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: PUSH
69821: FOR_IN
69822: IFFALSE 69999
// begin if GetClass ( j ) <> 3 then
69824: LD_VAR 0 3
69828: PPUSH
69829: CALL_OW 257
69833: PUSH
69834: LD_INT 3
69836: NONEQUAL
69837: IFFALSE 69878
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69839: LD_ADDR_EXP 55
69843: PUSH
69844: LD_EXP 55
69848: PPUSH
69849: LD_VAR 0 2
69853: PPUSH
69854: LD_EXP 55
69858: PUSH
69859: LD_VAR 0 2
69863: ARRAY
69864: PUSH
69865: LD_VAR 0 3
69869: DIFF
69870: PPUSH
69871: CALL_OW 1
69875: ST_TO_ADDR
// continue ;
69876: GO 69821
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69878: LD_VAR 0 3
69882: PPUSH
69883: CALL_OW 311
69887: NOT
69888: PUSH
69889: LD_VAR 0 3
69893: PUSH
69894: LD_EXP 46
69898: PUSH
69899: LD_VAR 0 2
69903: ARRAY
69904: PUSH
69905: LD_INT 1
69907: ARRAY
69908: IN
69909: NOT
69910: AND
69911: PUSH
69912: LD_VAR 0 3
69916: PUSH
69917: LD_EXP 46
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: PUSH
69928: LD_INT 2
69930: ARRAY
69931: IN
69932: NOT
69933: AND
69934: IFFALSE 69997
// begin if IsInUnit ( j ) then
69936: LD_VAR 0 3
69940: PPUSH
69941: CALL_OW 310
69945: IFFALSE 69958
// ComExitBuilding ( j ) else
69947: LD_VAR 0 3
69951: PPUSH
69952: CALL_OW 122
69956: GO 69997
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69958: LD_VAR 0 3
69962: PPUSH
69963: LD_VAR 0 7
69967: PUSH
69968: LD_INT 1
69970: ARRAY
69971: PPUSH
69972: CALL 49312 0 2
69976: NOT
69977: IFFALSE 69997
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69979: LD_VAR 0 3
69983: PPUSH
69984: LD_VAR 0 7
69988: PUSH
69989: LD_INT 1
69991: ARRAY
69992: PPUSH
69993: CALL_OW 129
// end ; end ;
69997: GO 69821
69999: POP
70000: POP
// end ;
70001: GO 69282
70003: POP
70004: POP
// end ;
70005: LD_VAR 0 1
70009: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70010: LD_INT 0
70012: PPUSH
70013: PPUSH
70014: PPUSH
70015: PPUSH
70016: PPUSH
70017: PPUSH
70018: PPUSH
70019: PPUSH
70020: PPUSH
70021: PPUSH
70022: PPUSH
// if not mc_bases then
70023: LD_EXP 43
70027: NOT
70028: IFFALSE 70032
// exit ;
70030: GO 70834
// for i = 1 to mc_bases do
70032: LD_ADDR_VAR 0 2
70036: PUSH
70037: DOUBLE
70038: LD_INT 1
70040: DEC
70041: ST_TO_ADDR
70042: LD_EXP 43
70046: PUSH
70047: FOR_TO
70048: IFFALSE 70832
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70050: LD_EXP 71
70054: PUSH
70055: LD_VAR 0 2
70059: ARRAY
70060: NOT
70061: PUSH
70062: LD_EXP 46
70066: PUSH
70067: LD_VAR 0 2
70071: ARRAY
70072: PUSH
70073: LD_INT 1
70075: ARRAY
70076: OR
70077: PUSH
70078: LD_EXP 46
70082: PUSH
70083: LD_VAR 0 2
70087: ARRAY
70088: PUSH
70089: LD_INT 2
70091: ARRAY
70092: OR
70093: PUSH
70094: LD_EXP 69
70098: PUSH
70099: LD_VAR 0 2
70103: ARRAY
70104: PPUSH
70105: LD_INT 1
70107: PPUSH
70108: CALL_OW 325
70112: NOT
70113: OR
70114: PUSH
70115: LD_EXP 66
70119: PUSH
70120: LD_VAR 0 2
70124: ARRAY
70125: OR
70126: IFFALSE 70130
// continue ;
70128: GO 70047
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70130: LD_ADDR_VAR 0 8
70134: PUSH
70135: LD_EXP 43
70139: PUSH
70140: LD_VAR 0 2
70144: ARRAY
70145: PPUSH
70146: LD_INT 25
70148: PUSH
70149: LD_INT 4
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 50
70158: PUSH
70159: EMPTY
70160: LIST
70161: PUSH
70162: LD_INT 3
70164: PUSH
70165: LD_INT 60
70167: PUSH
70168: EMPTY
70169: LIST
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: LIST
70179: PPUSH
70180: CALL_OW 72
70184: PUSH
70185: LD_EXP 47
70189: PUSH
70190: LD_VAR 0 2
70194: ARRAY
70195: DIFF
70196: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70197: LD_ADDR_VAR 0 9
70201: PUSH
70202: LD_EXP 43
70206: PUSH
70207: LD_VAR 0 2
70211: ARRAY
70212: PPUSH
70213: LD_INT 2
70215: PUSH
70216: LD_INT 30
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: LD_INT 30
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: LIST
70240: PPUSH
70241: CALL_OW 72
70245: ST_TO_ADDR
// if not tmp or not dep then
70246: LD_VAR 0 8
70250: NOT
70251: PUSH
70252: LD_VAR 0 9
70256: NOT
70257: OR
70258: IFFALSE 70262
// continue ;
70260: GO 70047
// side := GetSide ( tmp [ 1 ] ) ;
70262: LD_ADDR_VAR 0 11
70266: PUSH
70267: LD_VAR 0 8
70271: PUSH
70272: LD_INT 1
70274: ARRAY
70275: PPUSH
70276: CALL_OW 255
70280: ST_TO_ADDR
// dep := dep [ 1 ] ;
70281: LD_ADDR_VAR 0 9
70285: PUSH
70286: LD_VAR 0 9
70290: PUSH
70291: LD_INT 1
70293: ARRAY
70294: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70295: LD_ADDR_VAR 0 7
70299: PUSH
70300: LD_EXP 71
70304: PUSH
70305: LD_VAR 0 2
70309: ARRAY
70310: PPUSH
70311: LD_INT 22
70313: PUSH
70314: LD_INT 0
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 25
70323: PUSH
70324: LD_INT 12
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PPUSH
70335: CALL_OW 70
70339: PUSH
70340: LD_INT 22
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 25
70352: PUSH
70353: LD_INT 12
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 91
70362: PUSH
70363: LD_VAR 0 9
70367: PUSH
70368: LD_INT 20
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: LIST
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: LIST
70380: PPUSH
70381: CALL_OW 69
70385: UNION
70386: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70387: LD_ADDR_VAR 0 10
70391: PUSH
70392: LD_EXP 71
70396: PUSH
70397: LD_VAR 0 2
70401: ARRAY
70402: PPUSH
70403: LD_INT 81
70405: PUSH
70406: LD_VAR 0 11
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PPUSH
70415: CALL_OW 70
70419: ST_TO_ADDR
// if not apes or danger_at_area then
70420: LD_VAR 0 7
70424: NOT
70425: PUSH
70426: LD_VAR 0 10
70430: OR
70431: IFFALSE 70481
// begin if mc_taming [ i ] then
70433: LD_EXP 74
70437: PUSH
70438: LD_VAR 0 2
70442: ARRAY
70443: IFFALSE 70479
// begin MC_Reset ( i , 121 ) ;
70445: LD_VAR 0 2
70449: PPUSH
70450: LD_INT 121
70452: PPUSH
70453: CALL 55418 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70457: LD_ADDR_EXP 74
70461: PUSH
70462: LD_EXP 74
70466: PPUSH
70467: LD_VAR 0 2
70471: PPUSH
70472: EMPTY
70473: PPUSH
70474: CALL_OW 1
70478: ST_TO_ADDR
// end ; continue ;
70479: GO 70047
// end ; for j in tmp do
70481: LD_ADDR_VAR 0 3
70485: PUSH
70486: LD_VAR 0 8
70490: PUSH
70491: FOR_IN
70492: IFFALSE 70828
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70494: LD_VAR 0 3
70498: PUSH
70499: LD_EXP 74
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: IN
70510: NOT
70511: PUSH
70512: LD_EXP 74
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: PUSH
70523: LD_INT 3
70525: LESS
70526: AND
70527: IFFALSE 70585
// begin SetTag ( j , 121 ) ;
70529: LD_VAR 0 3
70533: PPUSH
70534: LD_INT 121
70536: PPUSH
70537: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70541: LD_ADDR_EXP 74
70545: PUSH
70546: LD_EXP 74
70550: PPUSH
70551: LD_VAR 0 2
70555: PUSH
70556: LD_EXP 74
70560: PUSH
70561: LD_VAR 0 2
70565: ARRAY
70566: PUSH
70567: LD_INT 1
70569: PLUS
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PPUSH
70575: LD_VAR 0 3
70579: PPUSH
70580: CALL 14917 0 3
70584: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70585: LD_VAR 0 3
70589: PUSH
70590: LD_EXP 74
70594: PUSH
70595: LD_VAR 0 2
70599: ARRAY
70600: IN
70601: IFFALSE 70826
// begin if GetClass ( j ) <> 4 then
70603: LD_VAR 0 3
70607: PPUSH
70608: CALL_OW 257
70612: PUSH
70613: LD_INT 4
70615: NONEQUAL
70616: IFFALSE 70669
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70618: LD_ADDR_EXP 74
70622: PUSH
70623: LD_EXP 74
70627: PPUSH
70628: LD_VAR 0 2
70632: PPUSH
70633: LD_EXP 74
70637: PUSH
70638: LD_VAR 0 2
70642: ARRAY
70643: PUSH
70644: LD_VAR 0 3
70648: DIFF
70649: PPUSH
70650: CALL_OW 1
70654: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70655: LD_VAR 0 3
70659: PPUSH
70660: LD_INT 0
70662: PPUSH
70663: CALL_OW 109
// continue ;
70667: GO 70491
// end ; if IsInUnit ( j ) then
70669: LD_VAR 0 3
70673: PPUSH
70674: CALL_OW 310
70678: IFFALSE 70689
// ComExitBuilding ( j ) ;
70680: LD_VAR 0 3
70684: PPUSH
70685: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70689: LD_ADDR_VAR 0 6
70693: PUSH
70694: LD_VAR 0 7
70698: PPUSH
70699: LD_VAR 0 3
70703: PPUSH
70704: CALL_OW 74
70708: ST_TO_ADDR
// if not ape then
70709: LD_VAR 0 6
70713: NOT
70714: IFFALSE 70718
// break ;
70716: GO 70828
// x := GetX ( ape ) ;
70718: LD_ADDR_VAR 0 4
70722: PUSH
70723: LD_VAR 0 6
70727: PPUSH
70728: CALL_OW 250
70732: ST_TO_ADDR
// y := GetY ( ape ) ;
70733: LD_ADDR_VAR 0 5
70737: PUSH
70738: LD_VAR 0 6
70742: PPUSH
70743: CALL_OW 251
70747: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70748: LD_VAR 0 4
70752: PPUSH
70753: LD_VAR 0 5
70757: PPUSH
70758: CALL_OW 488
70762: NOT
70763: PUSH
70764: LD_VAR 0 11
70768: PPUSH
70769: LD_VAR 0 4
70773: PPUSH
70774: LD_VAR 0 5
70778: PPUSH
70779: LD_INT 20
70781: PPUSH
70782: CALL 15813 0 4
70786: PUSH
70787: LD_INT 4
70789: ARRAY
70790: OR
70791: IFFALSE 70795
// break ;
70793: GO 70828
// if not HasTask ( j ) then
70795: LD_VAR 0 3
70799: PPUSH
70800: CALL_OW 314
70804: NOT
70805: IFFALSE 70826
// ComTameXY ( j , x , y ) ;
70807: LD_VAR 0 3
70811: PPUSH
70812: LD_VAR 0 4
70816: PPUSH
70817: LD_VAR 0 5
70821: PPUSH
70822: CALL_OW 131
// end ; end ;
70826: GO 70491
70828: POP
70829: POP
// end ;
70830: GO 70047
70832: POP
70833: POP
// end ;
70834: LD_VAR 0 1
70838: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70839: LD_INT 0
70841: PPUSH
70842: PPUSH
70843: PPUSH
70844: PPUSH
70845: PPUSH
70846: PPUSH
70847: PPUSH
70848: PPUSH
// if not mc_bases then
70849: LD_EXP 43
70853: NOT
70854: IFFALSE 70858
// exit ;
70856: GO 71484
// for i = 1 to mc_bases do
70858: LD_ADDR_VAR 0 2
70862: PUSH
70863: DOUBLE
70864: LD_INT 1
70866: DEC
70867: ST_TO_ADDR
70868: LD_EXP 43
70872: PUSH
70873: FOR_TO
70874: IFFALSE 71482
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70876: LD_EXP 72
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: NOT
70887: PUSH
70888: LD_EXP 72
70892: PUSH
70893: LD_VAR 0 2
70897: ARRAY
70898: PPUSH
70899: LD_INT 25
70901: PUSH
70902: LD_INT 12
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PPUSH
70909: CALL_OW 72
70913: NOT
70914: OR
70915: IFFALSE 70919
// continue ;
70917: GO 70873
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70919: LD_ADDR_VAR 0 5
70923: PUSH
70924: LD_EXP 72
70928: PUSH
70929: LD_VAR 0 2
70933: ARRAY
70934: PUSH
70935: LD_INT 1
70937: ARRAY
70938: PPUSH
70939: CALL_OW 255
70943: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70944: LD_VAR 0 5
70948: PPUSH
70949: LD_INT 2
70951: PPUSH
70952: CALL_OW 325
70956: IFFALSE 71209
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70958: LD_ADDR_VAR 0 4
70962: PUSH
70963: LD_EXP 72
70967: PUSH
70968: LD_VAR 0 2
70972: ARRAY
70973: PPUSH
70974: LD_INT 25
70976: PUSH
70977: LD_INT 16
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PPUSH
70984: CALL_OW 72
70988: ST_TO_ADDR
// if tmp < 6 then
70989: LD_VAR 0 4
70993: PUSH
70994: LD_INT 6
70996: LESS
70997: IFFALSE 71209
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70999: LD_ADDR_VAR 0 6
71003: PUSH
71004: LD_EXP 43
71008: PUSH
71009: LD_VAR 0 2
71013: ARRAY
71014: PPUSH
71015: LD_INT 2
71017: PUSH
71018: LD_INT 30
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 30
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: LIST
71042: PPUSH
71043: CALL_OW 72
71047: ST_TO_ADDR
// if depot then
71048: LD_VAR 0 6
71052: IFFALSE 71209
// begin selected := 0 ;
71054: LD_ADDR_VAR 0 7
71058: PUSH
71059: LD_INT 0
71061: ST_TO_ADDR
// for j in depot do
71062: LD_ADDR_VAR 0 3
71066: PUSH
71067: LD_VAR 0 6
71071: PUSH
71072: FOR_IN
71073: IFFALSE 71104
// begin if UnitsInside ( j ) < 6 then
71075: LD_VAR 0 3
71079: PPUSH
71080: CALL_OW 313
71084: PUSH
71085: LD_INT 6
71087: LESS
71088: IFFALSE 71102
// begin selected := j ;
71090: LD_ADDR_VAR 0 7
71094: PUSH
71095: LD_VAR 0 3
71099: ST_TO_ADDR
// break ;
71100: GO 71104
// end ; end ;
71102: GO 71072
71104: POP
71105: POP
// if selected then
71106: LD_VAR 0 7
71110: IFFALSE 71209
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71112: LD_ADDR_VAR 0 3
71116: PUSH
71117: LD_EXP 72
71121: PUSH
71122: LD_VAR 0 2
71126: ARRAY
71127: PPUSH
71128: LD_INT 25
71130: PUSH
71131: LD_INT 12
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PPUSH
71138: CALL_OW 72
71142: PUSH
71143: FOR_IN
71144: IFFALSE 71207
// if not HasTask ( j ) then
71146: LD_VAR 0 3
71150: PPUSH
71151: CALL_OW 314
71155: NOT
71156: IFFALSE 71205
// begin if not IsInUnit ( j ) then
71158: LD_VAR 0 3
71162: PPUSH
71163: CALL_OW 310
71167: NOT
71168: IFFALSE 71184
// ComEnterUnit ( j , selected ) ;
71170: LD_VAR 0 3
71174: PPUSH
71175: LD_VAR 0 7
71179: PPUSH
71180: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71184: LD_VAR 0 3
71188: PPUSH
71189: LD_INT 16
71191: PPUSH
71192: CALL_OW 183
// AddComExitBuilding ( j ) ;
71196: LD_VAR 0 3
71200: PPUSH
71201: CALL_OW 182
// end ;
71205: GO 71143
71207: POP
71208: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71209: LD_VAR 0 5
71213: PPUSH
71214: LD_INT 11
71216: PPUSH
71217: CALL_OW 325
71221: IFFALSE 71480
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71223: LD_ADDR_VAR 0 4
71227: PUSH
71228: LD_EXP 72
71232: PUSH
71233: LD_VAR 0 2
71237: ARRAY
71238: PPUSH
71239: LD_INT 25
71241: PUSH
71242: LD_INT 16
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PPUSH
71249: CALL_OW 72
71253: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71254: LD_VAR 0 4
71258: PUSH
71259: LD_INT 6
71261: GREATEREQUAL
71262: PUSH
71263: LD_VAR 0 5
71267: PPUSH
71268: LD_INT 2
71270: PPUSH
71271: CALL_OW 325
71275: NOT
71276: OR
71277: IFFALSE 71480
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71279: LD_ADDR_VAR 0 8
71283: PUSH
71284: LD_EXP 43
71288: PUSH
71289: LD_VAR 0 2
71293: ARRAY
71294: PPUSH
71295: LD_INT 2
71297: PUSH
71298: LD_INT 30
71300: PUSH
71301: LD_INT 4
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 30
71310: PUSH
71311: LD_INT 5
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: LIST
71322: PPUSH
71323: CALL_OW 72
71327: ST_TO_ADDR
// if barracks then
71328: LD_VAR 0 8
71332: IFFALSE 71480
// begin selected := 0 ;
71334: LD_ADDR_VAR 0 7
71338: PUSH
71339: LD_INT 0
71341: ST_TO_ADDR
// for j in barracks do
71342: LD_ADDR_VAR 0 3
71346: PUSH
71347: LD_VAR 0 8
71351: PUSH
71352: FOR_IN
71353: IFFALSE 71384
// begin if UnitsInside ( j ) < 6 then
71355: LD_VAR 0 3
71359: PPUSH
71360: CALL_OW 313
71364: PUSH
71365: LD_INT 6
71367: LESS
71368: IFFALSE 71382
// begin selected := j ;
71370: LD_ADDR_VAR 0 7
71374: PUSH
71375: LD_VAR 0 3
71379: ST_TO_ADDR
// break ;
71380: GO 71384
// end ; end ;
71382: GO 71352
71384: POP
71385: POP
// if selected then
71386: LD_VAR 0 7
71390: IFFALSE 71480
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71392: LD_ADDR_VAR 0 3
71396: PUSH
71397: LD_EXP 72
71401: PUSH
71402: LD_VAR 0 2
71406: ARRAY
71407: PPUSH
71408: LD_INT 25
71410: PUSH
71411: LD_INT 12
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PPUSH
71418: CALL_OW 72
71422: PUSH
71423: FOR_IN
71424: IFFALSE 71478
// if not IsInUnit ( j ) and not HasTask ( j ) then
71426: LD_VAR 0 3
71430: PPUSH
71431: CALL_OW 310
71435: NOT
71436: PUSH
71437: LD_VAR 0 3
71441: PPUSH
71442: CALL_OW 314
71446: NOT
71447: AND
71448: IFFALSE 71476
// begin ComEnterUnit ( j , selected ) ;
71450: LD_VAR 0 3
71454: PPUSH
71455: LD_VAR 0 7
71459: PPUSH
71460: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71464: LD_VAR 0 3
71468: PPUSH
71469: LD_INT 15
71471: PPUSH
71472: CALL_OW 183
// end ;
71476: GO 71423
71478: POP
71479: POP
// end ; end ; end ; end ; end ;
71480: GO 70873
71482: POP
71483: POP
// end ;
71484: LD_VAR 0 1
71488: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71489: LD_INT 0
71491: PPUSH
71492: PPUSH
71493: PPUSH
71494: PPUSH
// if not mc_bases then
71495: LD_EXP 43
71499: NOT
71500: IFFALSE 71504
// exit ;
71502: GO 71682
// for i = 1 to mc_bases do
71504: LD_ADDR_VAR 0 2
71508: PUSH
71509: DOUBLE
71510: LD_INT 1
71512: DEC
71513: ST_TO_ADDR
71514: LD_EXP 43
71518: PUSH
71519: FOR_TO
71520: IFFALSE 71680
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71522: LD_ADDR_VAR 0 4
71526: PUSH
71527: LD_EXP 43
71531: PUSH
71532: LD_VAR 0 2
71536: ARRAY
71537: PPUSH
71538: LD_INT 25
71540: PUSH
71541: LD_INT 9
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PPUSH
71548: CALL_OW 72
71552: ST_TO_ADDR
// if not tmp then
71553: LD_VAR 0 4
71557: NOT
71558: IFFALSE 71562
// continue ;
71560: GO 71519
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71562: LD_EXP 69
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PPUSH
71573: LD_INT 29
71575: PPUSH
71576: CALL_OW 325
71580: NOT
71581: PUSH
71582: LD_EXP 69
71586: PUSH
71587: LD_VAR 0 2
71591: ARRAY
71592: PPUSH
71593: LD_INT 28
71595: PPUSH
71596: CALL_OW 325
71600: NOT
71601: AND
71602: IFFALSE 71606
// continue ;
71604: GO 71519
// for j in tmp do
71606: LD_ADDR_VAR 0 3
71610: PUSH
71611: LD_VAR 0 4
71615: PUSH
71616: FOR_IN
71617: IFFALSE 71676
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71619: LD_VAR 0 3
71623: PUSH
71624: LD_EXP 46
71628: PUSH
71629: LD_VAR 0 2
71633: ARRAY
71634: PUSH
71635: LD_INT 1
71637: ARRAY
71638: IN
71639: NOT
71640: PUSH
71641: LD_VAR 0 3
71645: PUSH
71646: LD_EXP 46
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PUSH
71657: LD_INT 2
71659: ARRAY
71660: IN
71661: NOT
71662: AND
71663: IFFALSE 71674
// ComSpaceTimeShoot ( j ) ;
71665: LD_VAR 0 3
71669: PPUSH
71670: CALL 10759 0 1
71674: GO 71616
71676: POP
71677: POP
// end ;
71678: GO 71519
71680: POP
71681: POP
// end ;
71682: LD_VAR 0 1
71686: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71687: LD_INT 0
71689: PPUSH
71690: PPUSH
71691: PPUSH
71692: PPUSH
71693: PPUSH
71694: PPUSH
71695: PPUSH
71696: PPUSH
71697: PPUSH
// if not mc_bases then
71698: LD_EXP 43
71702: NOT
71703: IFFALSE 71707
// exit ;
71705: GO 72329
// for i = 1 to mc_bases do
71707: LD_ADDR_VAR 0 2
71711: PUSH
71712: DOUBLE
71713: LD_INT 1
71715: DEC
71716: ST_TO_ADDR
71717: LD_EXP 43
71721: PUSH
71722: FOR_TO
71723: IFFALSE 72327
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71725: LD_EXP 78
71729: PUSH
71730: LD_VAR 0 2
71734: ARRAY
71735: NOT
71736: PUSH
71737: LD_INT 38
71739: PPUSH
71740: LD_EXP 69
71744: PUSH
71745: LD_VAR 0 2
71749: ARRAY
71750: PPUSH
71751: CALL_OW 321
71755: PUSH
71756: LD_INT 2
71758: NONEQUAL
71759: OR
71760: IFFALSE 71764
// continue ;
71762: GO 71722
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71764: LD_ADDR_VAR 0 8
71768: PUSH
71769: LD_EXP 43
71773: PUSH
71774: LD_VAR 0 2
71778: ARRAY
71779: PPUSH
71780: LD_INT 30
71782: PUSH
71783: LD_INT 34
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PPUSH
71790: CALL_OW 72
71794: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71795: LD_ADDR_VAR 0 9
71799: PUSH
71800: LD_EXP 43
71804: PUSH
71805: LD_VAR 0 2
71809: ARRAY
71810: PPUSH
71811: LD_INT 25
71813: PUSH
71814: LD_INT 4
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PPUSH
71821: CALL_OW 72
71825: PPUSH
71826: LD_INT 0
71828: PPUSH
71829: CALL 44829 0 2
71833: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71834: LD_VAR 0 9
71838: NOT
71839: PUSH
71840: LD_VAR 0 8
71844: NOT
71845: OR
71846: PUSH
71847: LD_EXP 43
71851: PUSH
71852: LD_VAR 0 2
71856: ARRAY
71857: PPUSH
71858: LD_INT 124
71860: PPUSH
71861: CALL 44829 0 2
71865: OR
71866: IFFALSE 71870
// continue ;
71868: GO 71722
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71870: LD_EXP 79
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PUSH
71881: LD_EXP 78
71885: PUSH
71886: LD_VAR 0 2
71890: ARRAY
71891: LESS
71892: PUSH
71893: LD_EXP 79
71897: PUSH
71898: LD_VAR 0 2
71902: ARRAY
71903: PUSH
71904: LD_VAR 0 8
71908: LESS
71909: AND
71910: IFFALSE 72325
// begin tmp := sci [ 1 ] ;
71912: LD_ADDR_VAR 0 7
71916: PUSH
71917: LD_VAR 0 9
71921: PUSH
71922: LD_INT 1
71924: ARRAY
71925: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71926: LD_VAR 0 7
71930: PPUSH
71931: LD_INT 124
71933: PPUSH
71934: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71938: LD_ADDR_VAR 0 3
71942: PUSH
71943: DOUBLE
71944: LD_EXP 78
71948: PUSH
71949: LD_VAR 0 2
71953: ARRAY
71954: INC
71955: ST_TO_ADDR
71956: LD_EXP 78
71960: PUSH
71961: LD_VAR 0 2
71965: ARRAY
71966: PUSH
71967: FOR_DOWNTO
71968: IFFALSE 72311
// begin if IsInUnit ( tmp ) then
71970: LD_VAR 0 7
71974: PPUSH
71975: CALL_OW 310
71979: IFFALSE 71990
// ComExitBuilding ( tmp ) ;
71981: LD_VAR 0 7
71985: PPUSH
71986: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71990: LD_INT 35
71992: PPUSH
71993: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71997: LD_VAR 0 7
72001: PPUSH
72002: CALL_OW 310
72006: NOT
72007: PUSH
72008: LD_VAR 0 7
72012: PPUSH
72013: CALL_OW 314
72017: NOT
72018: AND
72019: IFFALSE 71990
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72021: LD_ADDR_VAR 0 6
72025: PUSH
72026: LD_VAR 0 7
72030: PPUSH
72031: CALL_OW 250
72035: PUSH
72036: LD_VAR 0 7
72040: PPUSH
72041: CALL_OW 251
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72050: LD_INT 35
72052: PPUSH
72053: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72057: LD_ADDR_VAR 0 4
72061: PUSH
72062: LD_EXP 78
72066: PUSH
72067: LD_VAR 0 2
72071: ARRAY
72072: PUSH
72073: LD_VAR 0 3
72077: ARRAY
72078: PUSH
72079: LD_INT 1
72081: ARRAY
72082: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72083: LD_ADDR_VAR 0 5
72087: PUSH
72088: LD_EXP 78
72092: PUSH
72093: LD_VAR 0 2
72097: ARRAY
72098: PUSH
72099: LD_VAR 0 3
72103: ARRAY
72104: PUSH
72105: LD_INT 2
72107: ARRAY
72108: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72109: LD_VAR 0 7
72113: PPUSH
72114: LD_INT 10
72116: PPUSH
72117: CALL 17514 0 2
72121: PUSH
72122: LD_INT 4
72124: ARRAY
72125: IFFALSE 72163
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72127: LD_VAR 0 7
72131: PPUSH
72132: LD_VAR 0 6
72136: PUSH
72137: LD_INT 1
72139: ARRAY
72140: PPUSH
72141: LD_VAR 0 6
72145: PUSH
72146: LD_INT 2
72148: ARRAY
72149: PPUSH
72150: CALL_OW 111
// wait ( 0 0$10 ) ;
72154: LD_INT 350
72156: PPUSH
72157: CALL_OW 67
// end else
72161: GO 72189
// begin ComMoveXY ( tmp , x , y ) ;
72163: LD_VAR 0 7
72167: PPUSH
72168: LD_VAR 0 4
72172: PPUSH
72173: LD_VAR 0 5
72177: PPUSH
72178: CALL_OW 111
// wait ( 0 0$3 ) ;
72182: LD_INT 105
72184: PPUSH
72185: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72189: LD_VAR 0 7
72193: PPUSH
72194: LD_VAR 0 4
72198: PPUSH
72199: LD_VAR 0 5
72203: PPUSH
72204: CALL_OW 307
72208: IFFALSE 72050
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72210: LD_VAR 0 7
72214: PPUSH
72215: LD_VAR 0 4
72219: PPUSH
72220: LD_VAR 0 5
72224: PPUSH
72225: LD_VAR 0 8
72229: PUSH
72230: LD_VAR 0 3
72234: ARRAY
72235: PPUSH
72236: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72240: LD_INT 35
72242: PPUSH
72243: CALL_OW 67
// until not HasTask ( tmp ) ;
72247: LD_VAR 0 7
72251: PPUSH
72252: CALL_OW 314
72256: NOT
72257: IFFALSE 72240
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72259: LD_ADDR_EXP 79
72263: PUSH
72264: LD_EXP 79
72268: PPUSH
72269: LD_VAR 0 2
72273: PUSH
72274: LD_EXP 79
72278: PUSH
72279: LD_VAR 0 2
72283: ARRAY
72284: PUSH
72285: LD_INT 1
72287: PLUS
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PPUSH
72293: LD_VAR 0 8
72297: PUSH
72298: LD_VAR 0 3
72302: ARRAY
72303: PPUSH
72304: CALL 14917 0 3
72308: ST_TO_ADDR
// end ;
72309: GO 71967
72311: POP
72312: POP
// MC_Reset ( i , 124 ) ;
72313: LD_VAR 0 2
72317: PPUSH
72318: LD_INT 124
72320: PPUSH
72321: CALL 55418 0 2
// end ; end ;
72325: GO 71722
72327: POP
72328: POP
// end ;
72329: LD_VAR 0 1
72333: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72334: LD_INT 0
72336: PPUSH
72337: PPUSH
72338: PPUSH
// if not mc_bases then
72339: LD_EXP 43
72343: NOT
72344: IFFALSE 72348
// exit ;
72346: GO 72954
// for i = 1 to mc_bases do
72348: LD_ADDR_VAR 0 2
72352: PUSH
72353: DOUBLE
72354: LD_INT 1
72356: DEC
72357: ST_TO_ADDR
72358: LD_EXP 43
72362: PUSH
72363: FOR_TO
72364: IFFALSE 72952
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72366: LD_ADDR_VAR 0 3
72370: PUSH
72371: LD_EXP 43
72375: PUSH
72376: LD_VAR 0 2
72380: ARRAY
72381: PPUSH
72382: LD_INT 25
72384: PUSH
72385: LD_INT 4
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PPUSH
72392: CALL_OW 72
72396: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72397: LD_VAR 0 3
72401: NOT
72402: PUSH
72403: LD_EXP 80
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: NOT
72414: OR
72415: PUSH
72416: LD_EXP 43
72420: PUSH
72421: LD_VAR 0 2
72425: ARRAY
72426: PPUSH
72427: LD_INT 2
72429: PUSH
72430: LD_INT 30
72432: PUSH
72433: LD_INT 0
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 30
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: LIST
72454: PPUSH
72455: CALL_OW 72
72459: NOT
72460: OR
72461: IFFALSE 72511
// begin if mc_deposits_finder [ i ] then
72463: LD_EXP 81
72467: PUSH
72468: LD_VAR 0 2
72472: ARRAY
72473: IFFALSE 72509
// begin MC_Reset ( i , 125 ) ;
72475: LD_VAR 0 2
72479: PPUSH
72480: LD_INT 125
72482: PPUSH
72483: CALL 55418 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72487: LD_ADDR_EXP 81
72491: PUSH
72492: LD_EXP 81
72496: PPUSH
72497: LD_VAR 0 2
72501: PPUSH
72502: EMPTY
72503: PPUSH
72504: CALL_OW 1
72508: ST_TO_ADDR
// end ; continue ;
72509: GO 72363
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72511: LD_EXP 80
72515: PUSH
72516: LD_VAR 0 2
72520: ARRAY
72521: PUSH
72522: LD_INT 1
72524: ARRAY
72525: PUSH
72526: LD_INT 3
72528: ARRAY
72529: PUSH
72530: LD_INT 1
72532: EQUAL
72533: PUSH
72534: LD_INT 20
72536: PPUSH
72537: LD_EXP 69
72541: PUSH
72542: LD_VAR 0 2
72546: ARRAY
72547: PPUSH
72548: CALL_OW 321
72552: PUSH
72553: LD_INT 2
72555: NONEQUAL
72556: AND
72557: IFFALSE 72607
// begin if mc_deposits_finder [ i ] then
72559: LD_EXP 81
72563: PUSH
72564: LD_VAR 0 2
72568: ARRAY
72569: IFFALSE 72605
// begin MC_Reset ( i , 125 ) ;
72571: LD_VAR 0 2
72575: PPUSH
72576: LD_INT 125
72578: PPUSH
72579: CALL 55418 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72583: LD_ADDR_EXP 81
72587: PUSH
72588: LD_EXP 81
72592: PPUSH
72593: LD_VAR 0 2
72597: PPUSH
72598: EMPTY
72599: PPUSH
72600: CALL_OW 1
72604: ST_TO_ADDR
// end ; continue ;
72605: GO 72363
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72607: LD_EXP 80
72611: PUSH
72612: LD_VAR 0 2
72616: ARRAY
72617: PUSH
72618: LD_INT 1
72620: ARRAY
72621: PUSH
72622: LD_INT 1
72624: ARRAY
72625: PPUSH
72626: LD_EXP 80
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: PUSH
72637: LD_INT 1
72639: ARRAY
72640: PUSH
72641: LD_INT 2
72643: ARRAY
72644: PPUSH
72645: LD_EXP 69
72649: PUSH
72650: LD_VAR 0 2
72654: ARRAY
72655: PPUSH
72656: CALL_OW 440
72660: IFFALSE 72703
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72662: LD_ADDR_EXP 80
72666: PUSH
72667: LD_EXP 80
72671: PPUSH
72672: LD_VAR 0 2
72676: PPUSH
72677: LD_EXP 80
72681: PUSH
72682: LD_VAR 0 2
72686: ARRAY
72687: PPUSH
72688: LD_INT 1
72690: PPUSH
72691: CALL_OW 3
72695: PPUSH
72696: CALL_OW 1
72700: ST_TO_ADDR
72701: GO 72950
// begin if not mc_deposits_finder [ i ] then
72703: LD_EXP 81
72707: PUSH
72708: LD_VAR 0 2
72712: ARRAY
72713: NOT
72714: IFFALSE 72766
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72716: LD_ADDR_EXP 81
72720: PUSH
72721: LD_EXP 81
72725: PPUSH
72726: LD_VAR 0 2
72730: PPUSH
72731: LD_VAR 0 3
72735: PUSH
72736: LD_INT 1
72738: ARRAY
72739: PUSH
72740: EMPTY
72741: LIST
72742: PPUSH
72743: CALL_OW 1
72747: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72748: LD_VAR 0 3
72752: PUSH
72753: LD_INT 1
72755: ARRAY
72756: PPUSH
72757: LD_INT 125
72759: PPUSH
72760: CALL_OW 109
// end else
72764: GO 72950
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72766: LD_EXP 81
72770: PUSH
72771: LD_VAR 0 2
72775: ARRAY
72776: PUSH
72777: LD_INT 1
72779: ARRAY
72780: PPUSH
72781: CALL_OW 310
72785: IFFALSE 72808
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72787: LD_EXP 81
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PUSH
72798: LD_INT 1
72800: ARRAY
72801: PPUSH
72802: CALL_OW 122
72806: GO 72950
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72808: LD_EXP 81
72812: PUSH
72813: LD_VAR 0 2
72817: ARRAY
72818: PUSH
72819: LD_INT 1
72821: ARRAY
72822: PPUSH
72823: CALL_OW 314
72827: NOT
72828: PUSH
72829: LD_EXP 81
72833: PUSH
72834: LD_VAR 0 2
72838: ARRAY
72839: PUSH
72840: LD_INT 1
72842: ARRAY
72843: PPUSH
72844: LD_EXP 80
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: PUSH
72855: LD_INT 1
72857: ARRAY
72858: PUSH
72859: LD_INT 1
72861: ARRAY
72862: PPUSH
72863: LD_EXP 80
72867: PUSH
72868: LD_VAR 0 2
72872: ARRAY
72873: PUSH
72874: LD_INT 1
72876: ARRAY
72877: PUSH
72878: LD_INT 2
72880: ARRAY
72881: PPUSH
72882: CALL_OW 297
72886: PUSH
72887: LD_INT 6
72889: GREATER
72890: AND
72891: IFFALSE 72950
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72893: LD_EXP 81
72897: PUSH
72898: LD_VAR 0 2
72902: ARRAY
72903: PUSH
72904: LD_INT 1
72906: ARRAY
72907: PPUSH
72908: LD_EXP 80
72912: PUSH
72913: LD_VAR 0 2
72917: ARRAY
72918: PUSH
72919: LD_INT 1
72921: ARRAY
72922: PUSH
72923: LD_INT 1
72925: ARRAY
72926: PPUSH
72927: LD_EXP 80
72931: PUSH
72932: LD_VAR 0 2
72936: ARRAY
72937: PUSH
72938: LD_INT 1
72940: ARRAY
72941: PUSH
72942: LD_INT 2
72944: ARRAY
72945: PPUSH
72946: CALL_OW 111
// end ; end ; end ;
72950: GO 72363
72952: POP
72953: POP
// end ;
72954: LD_VAR 0 1
72958: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72959: LD_INT 0
72961: PPUSH
72962: PPUSH
72963: PPUSH
72964: PPUSH
72965: PPUSH
72966: PPUSH
72967: PPUSH
72968: PPUSH
72969: PPUSH
72970: PPUSH
72971: PPUSH
// if not mc_bases then
72972: LD_EXP 43
72976: NOT
72977: IFFALSE 72981
// exit ;
72979: GO 73921
// for i = 1 to mc_bases do
72981: LD_ADDR_VAR 0 2
72985: PUSH
72986: DOUBLE
72987: LD_INT 1
72989: DEC
72990: ST_TO_ADDR
72991: LD_EXP 43
72995: PUSH
72996: FOR_TO
72997: IFFALSE 73919
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72999: LD_EXP 43
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: NOT
73010: PUSH
73011: LD_EXP 66
73015: PUSH
73016: LD_VAR 0 2
73020: ARRAY
73021: OR
73022: IFFALSE 73026
// continue ;
73024: GO 72996
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73026: LD_ADDR_VAR 0 7
73030: PUSH
73031: LD_EXP 43
73035: PUSH
73036: LD_VAR 0 2
73040: ARRAY
73041: PUSH
73042: LD_INT 1
73044: ARRAY
73045: PPUSH
73046: CALL_OW 248
73050: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73051: LD_VAR 0 7
73055: PUSH
73056: LD_INT 3
73058: EQUAL
73059: PUSH
73060: LD_EXP 62
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: PUSH
73071: LD_EXP 65
73075: PUSH
73076: LD_VAR 0 2
73080: ARRAY
73081: UNION
73082: PPUSH
73083: LD_INT 33
73085: PUSH
73086: LD_INT 2
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PPUSH
73093: CALL_OW 72
73097: NOT
73098: OR
73099: IFFALSE 73103
// continue ;
73101: GO 72996
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73103: LD_ADDR_VAR 0 9
73107: PUSH
73108: LD_EXP 43
73112: PUSH
73113: LD_VAR 0 2
73117: ARRAY
73118: PPUSH
73119: LD_INT 30
73121: PUSH
73122: LD_INT 36
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PPUSH
73129: CALL_OW 72
73133: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73134: LD_ADDR_VAR 0 10
73138: PUSH
73139: LD_EXP 62
73143: PUSH
73144: LD_VAR 0 2
73148: ARRAY
73149: PPUSH
73150: LD_INT 34
73152: PUSH
73153: LD_INT 31
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PPUSH
73160: CALL_OW 72
73164: ST_TO_ADDR
// if not cts and not mcts then
73165: LD_VAR 0 9
73169: NOT
73170: PUSH
73171: LD_VAR 0 10
73175: NOT
73176: AND
73177: IFFALSE 73181
// continue ;
73179: GO 72996
// x := cts ;
73181: LD_ADDR_VAR 0 11
73185: PUSH
73186: LD_VAR 0 9
73190: ST_TO_ADDR
// if not x then
73191: LD_VAR 0 11
73195: NOT
73196: IFFALSE 73208
// x := mcts ;
73198: LD_ADDR_VAR 0 11
73202: PUSH
73203: LD_VAR 0 10
73207: ST_TO_ADDR
// if not x then
73208: LD_VAR 0 11
73212: NOT
73213: IFFALSE 73217
// continue ;
73215: GO 72996
// if mc_remote_driver [ i ] then
73217: LD_EXP 83
73221: PUSH
73222: LD_VAR 0 2
73226: ARRAY
73227: IFFALSE 73614
// for j in mc_remote_driver [ i ] do
73229: LD_ADDR_VAR 0 3
73233: PUSH
73234: LD_EXP 83
73238: PUSH
73239: LD_VAR 0 2
73243: ARRAY
73244: PUSH
73245: FOR_IN
73246: IFFALSE 73612
// begin if GetClass ( j ) <> 3 then
73248: LD_VAR 0 3
73252: PPUSH
73253: CALL_OW 257
73257: PUSH
73258: LD_INT 3
73260: NONEQUAL
73261: IFFALSE 73314
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73263: LD_ADDR_EXP 83
73267: PUSH
73268: LD_EXP 83
73272: PPUSH
73273: LD_VAR 0 2
73277: PPUSH
73278: LD_EXP 83
73282: PUSH
73283: LD_VAR 0 2
73287: ARRAY
73288: PUSH
73289: LD_VAR 0 3
73293: DIFF
73294: PPUSH
73295: CALL_OW 1
73299: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73300: LD_VAR 0 3
73304: PPUSH
73305: LD_INT 0
73307: PPUSH
73308: CALL_OW 109
// continue ;
73312: GO 73245
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73314: LD_EXP 62
73318: PUSH
73319: LD_VAR 0 2
73323: ARRAY
73324: PPUSH
73325: LD_INT 34
73327: PUSH
73328: LD_INT 31
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 58
73337: PUSH
73338: EMPTY
73339: LIST
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PPUSH
73345: CALL_OW 72
73349: PUSH
73350: LD_VAR 0 3
73354: PPUSH
73355: CALL 44864 0 1
73359: NOT
73360: AND
73361: IFFALSE 73432
// begin if IsInUnit ( j ) then
73363: LD_VAR 0 3
73367: PPUSH
73368: CALL_OW 310
73372: IFFALSE 73383
// ComExitBuilding ( j ) ;
73374: LD_VAR 0 3
73378: PPUSH
73379: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73383: LD_VAR 0 3
73387: PPUSH
73388: LD_EXP 62
73392: PUSH
73393: LD_VAR 0 2
73397: ARRAY
73398: PPUSH
73399: LD_INT 34
73401: PUSH
73402: LD_INT 31
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 58
73411: PUSH
73412: EMPTY
73413: LIST
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PPUSH
73419: CALL_OW 72
73423: PUSH
73424: LD_INT 1
73426: ARRAY
73427: PPUSH
73428: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73432: LD_VAR 0 3
73436: PPUSH
73437: CALL_OW 310
73441: NOT
73442: PUSH
73443: LD_VAR 0 3
73447: PPUSH
73448: CALL_OW 310
73452: PPUSH
73453: CALL_OW 266
73457: PUSH
73458: LD_INT 36
73460: NONEQUAL
73461: PUSH
73462: LD_VAR 0 3
73466: PPUSH
73467: CALL 44864 0 1
73471: NOT
73472: AND
73473: OR
73474: IFFALSE 73610
// begin if IsInUnit ( j ) then
73476: LD_VAR 0 3
73480: PPUSH
73481: CALL_OW 310
73485: IFFALSE 73496
// ComExitBuilding ( j ) ;
73487: LD_VAR 0 3
73491: PPUSH
73492: CALL_OW 122
// ct := 0 ;
73496: LD_ADDR_VAR 0 8
73500: PUSH
73501: LD_INT 0
73503: ST_TO_ADDR
// for k in x do
73504: LD_ADDR_VAR 0 4
73508: PUSH
73509: LD_VAR 0 11
73513: PUSH
73514: FOR_IN
73515: IFFALSE 73588
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73517: LD_VAR 0 4
73521: PPUSH
73522: CALL_OW 264
73526: PUSH
73527: LD_INT 31
73529: EQUAL
73530: PUSH
73531: LD_VAR 0 4
73535: PPUSH
73536: CALL_OW 311
73540: NOT
73541: AND
73542: PUSH
73543: LD_VAR 0 4
73547: PPUSH
73548: CALL_OW 266
73552: PUSH
73553: LD_INT 36
73555: EQUAL
73556: PUSH
73557: LD_VAR 0 4
73561: PPUSH
73562: CALL_OW 313
73566: PUSH
73567: LD_INT 3
73569: LESS
73570: AND
73571: OR
73572: IFFALSE 73586
// begin ct := k ;
73574: LD_ADDR_VAR 0 8
73578: PUSH
73579: LD_VAR 0 4
73583: ST_TO_ADDR
// break ;
73584: GO 73588
// end ;
73586: GO 73514
73588: POP
73589: POP
// if ct then
73590: LD_VAR 0 8
73594: IFFALSE 73610
// ComEnterUnit ( j , ct ) ;
73596: LD_VAR 0 3
73600: PPUSH
73601: LD_VAR 0 8
73605: PPUSH
73606: CALL_OW 120
// end ; end ;
73610: GO 73245
73612: POP
73613: POP
// places := 0 ;
73614: LD_ADDR_VAR 0 5
73618: PUSH
73619: LD_INT 0
73621: ST_TO_ADDR
// for j = 1 to x do
73622: LD_ADDR_VAR 0 3
73626: PUSH
73627: DOUBLE
73628: LD_INT 1
73630: DEC
73631: ST_TO_ADDR
73632: LD_VAR 0 11
73636: PUSH
73637: FOR_TO
73638: IFFALSE 73714
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73640: LD_VAR 0 11
73644: PUSH
73645: LD_VAR 0 3
73649: ARRAY
73650: PPUSH
73651: CALL_OW 264
73655: PUSH
73656: LD_INT 31
73658: EQUAL
73659: IFFALSE 73677
// places := places + 1 else
73661: LD_ADDR_VAR 0 5
73665: PUSH
73666: LD_VAR 0 5
73670: PUSH
73671: LD_INT 1
73673: PLUS
73674: ST_TO_ADDR
73675: GO 73712
// if GetBType ( x [ j ] ) = b_control_tower then
73677: LD_VAR 0 11
73681: PUSH
73682: LD_VAR 0 3
73686: ARRAY
73687: PPUSH
73688: CALL_OW 266
73692: PUSH
73693: LD_INT 36
73695: EQUAL
73696: IFFALSE 73712
// places := places + 3 ;
73698: LD_ADDR_VAR 0 5
73702: PUSH
73703: LD_VAR 0 5
73707: PUSH
73708: LD_INT 3
73710: PLUS
73711: ST_TO_ADDR
73712: GO 73637
73714: POP
73715: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73716: LD_VAR 0 5
73720: PUSH
73721: LD_INT 0
73723: EQUAL
73724: PUSH
73725: LD_VAR 0 5
73729: PUSH
73730: LD_EXP 83
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: LESSEQUAL
73741: OR
73742: IFFALSE 73746
// continue ;
73744: GO 72996
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73746: LD_ADDR_VAR 0 6
73750: PUSH
73751: LD_EXP 43
73755: PUSH
73756: LD_VAR 0 2
73760: ARRAY
73761: PPUSH
73762: LD_INT 25
73764: PUSH
73765: LD_INT 3
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PPUSH
73772: CALL_OW 72
73776: PUSH
73777: LD_EXP 83
73781: PUSH
73782: LD_VAR 0 2
73786: ARRAY
73787: DIFF
73788: PPUSH
73789: LD_INT 3
73791: PPUSH
73792: CALL 45764 0 2
73796: ST_TO_ADDR
// for j in tmp do
73797: LD_ADDR_VAR 0 3
73801: PUSH
73802: LD_VAR 0 6
73806: PUSH
73807: FOR_IN
73808: IFFALSE 73843
// if GetTag ( j ) > 0 then
73810: LD_VAR 0 3
73814: PPUSH
73815: CALL_OW 110
73819: PUSH
73820: LD_INT 0
73822: GREATER
73823: IFFALSE 73841
// tmp := tmp diff j ;
73825: LD_ADDR_VAR 0 6
73829: PUSH
73830: LD_VAR 0 6
73834: PUSH
73835: LD_VAR 0 3
73839: DIFF
73840: ST_TO_ADDR
73841: GO 73807
73843: POP
73844: POP
// if not tmp then
73845: LD_VAR 0 6
73849: NOT
73850: IFFALSE 73854
// continue ;
73852: GO 72996
// if places then
73854: LD_VAR 0 5
73858: IFFALSE 73917
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73860: LD_ADDR_EXP 83
73864: PUSH
73865: LD_EXP 83
73869: PPUSH
73870: LD_VAR 0 2
73874: PPUSH
73875: LD_EXP 83
73879: PUSH
73880: LD_VAR 0 2
73884: ARRAY
73885: PUSH
73886: LD_VAR 0 6
73890: PUSH
73891: LD_INT 1
73893: ARRAY
73894: UNION
73895: PPUSH
73896: CALL_OW 1
73900: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73901: LD_VAR 0 6
73905: PUSH
73906: LD_INT 1
73908: ARRAY
73909: PPUSH
73910: LD_INT 126
73912: PPUSH
73913: CALL_OW 109
// end ; end ;
73917: GO 72996
73919: POP
73920: POP
// end ;
73921: LD_VAR 0 1
73925: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73926: LD_INT 0
73928: PPUSH
73929: PPUSH
73930: PPUSH
73931: PPUSH
73932: PPUSH
73933: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73934: LD_VAR 0 1
73938: NOT
73939: PUSH
73940: LD_VAR 0 2
73944: NOT
73945: OR
73946: PUSH
73947: LD_VAR 0 3
73951: NOT
73952: OR
73953: PUSH
73954: LD_VAR 0 4
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: LD_INT 2
73964: PUSH
73965: LD_INT 3
73967: PUSH
73968: LD_INT 4
73970: PUSH
73971: LD_INT 5
73973: PUSH
73974: LD_INT 8
73976: PUSH
73977: LD_INT 9
73979: PUSH
73980: LD_INT 15
73982: PUSH
73983: LD_INT 16
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: IN
73997: NOT
73998: OR
73999: IFFALSE 74003
// exit ;
74001: GO 74903
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74003: LD_ADDR_VAR 0 2
74007: PUSH
74008: LD_VAR 0 2
74012: PPUSH
74013: LD_INT 21
74015: PUSH
74016: LD_INT 3
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 24
74025: PUSH
74026: LD_INT 250
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PPUSH
74037: CALL_OW 72
74041: ST_TO_ADDR
// case class of 1 , 15 :
74042: LD_VAR 0 4
74046: PUSH
74047: LD_INT 1
74049: DOUBLE
74050: EQUAL
74051: IFTRUE 74061
74053: LD_INT 15
74055: DOUBLE
74056: EQUAL
74057: IFTRUE 74061
74059: GO 74146
74061: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74062: LD_ADDR_VAR 0 8
74066: PUSH
74067: LD_VAR 0 2
74071: PPUSH
74072: LD_INT 2
74074: PUSH
74075: LD_INT 30
74077: PUSH
74078: LD_INT 32
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 30
74087: PUSH
74088: LD_INT 31
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: LIST
74099: PPUSH
74100: CALL_OW 72
74104: PUSH
74105: LD_VAR 0 2
74109: PPUSH
74110: LD_INT 2
74112: PUSH
74113: LD_INT 30
74115: PUSH
74116: LD_INT 4
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 30
74125: PUSH
74126: LD_INT 5
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: LIST
74137: PPUSH
74138: CALL_OW 72
74142: ADD
74143: ST_TO_ADDR
74144: GO 74392
74146: LD_INT 2
74148: DOUBLE
74149: EQUAL
74150: IFTRUE 74160
74152: LD_INT 16
74154: DOUBLE
74155: EQUAL
74156: IFTRUE 74160
74158: GO 74206
74160: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74161: LD_ADDR_VAR 0 8
74165: PUSH
74166: LD_VAR 0 2
74170: PPUSH
74171: LD_INT 2
74173: PUSH
74174: LD_INT 30
74176: PUSH
74177: LD_INT 0
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 30
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: LIST
74198: PPUSH
74199: CALL_OW 72
74203: ST_TO_ADDR
74204: GO 74392
74206: LD_INT 3
74208: DOUBLE
74209: EQUAL
74210: IFTRUE 74214
74212: GO 74260
74214: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74215: LD_ADDR_VAR 0 8
74219: PUSH
74220: LD_VAR 0 2
74224: PPUSH
74225: LD_INT 2
74227: PUSH
74228: LD_INT 30
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 30
74240: PUSH
74241: LD_INT 3
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: LIST
74252: PPUSH
74253: CALL_OW 72
74257: ST_TO_ADDR
74258: GO 74392
74260: LD_INT 4
74262: DOUBLE
74263: EQUAL
74264: IFTRUE 74268
74266: GO 74325
74268: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74269: LD_ADDR_VAR 0 8
74273: PUSH
74274: LD_VAR 0 2
74278: PPUSH
74279: LD_INT 2
74281: PUSH
74282: LD_INT 30
74284: PUSH
74285: LD_INT 6
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 30
74294: PUSH
74295: LD_INT 7
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 30
74304: PUSH
74305: LD_INT 8
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: PPUSH
74318: CALL_OW 72
74322: ST_TO_ADDR
74323: GO 74392
74325: LD_INT 5
74327: DOUBLE
74328: EQUAL
74329: IFTRUE 74345
74331: LD_INT 8
74333: DOUBLE
74334: EQUAL
74335: IFTRUE 74345
74337: LD_INT 9
74339: DOUBLE
74340: EQUAL
74341: IFTRUE 74345
74343: GO 74391
74345: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74346: LD_ADDR_VAR 0 8
74350: PUSH
74351: LD_VAR 0 2
74355: PPUSH
74356: LD_INT 2
74358: PUSH
74359: LD_INT 30
74361: PUSH
74362: LD_INT 4
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 30
74371: PUSH
74372: LD_INT 5
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: LIST
74383: PPUSH
74384: CALL_OW 72
74388: ST_TO_ADDR
74389: GO 74392
74391: POP
// if not tmp then
74392: LD_VAR 0 8
74396: NOT
74397: IFFALSE 74401
// exit ;
74399: GO 74903
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74401: LD_VAR 0 4
74405: PUSH
74406: LD_INT 1
74408: PUSH
74409: LD_INT 15
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: IN
74416: PUSH
74417: LD_EXP 52
74421: PUSH
74422: LD_VAR 0 1
74426: ARRAY
74427: AND
74428: IFFALSE 74584
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74430: LD_ADDR_VAR 0 9
74434: PUSH
74435: LD_EXP 52
74439: PUSH
74440: LD_VAR 0 1
74444: ARRAY
74445: PUSH
74446: LD_INT 1
74448: ARRAY
74449: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74450: LD_VAR 0 9
74454: PUSH
74455: LD_EXP 53
74459: PUSH
74460: LD_VAR 0 1
74464: ARRAY
74465: IN
74466: NOT
74467: IFFALSE 74582
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74469: LD_ADDR_EXP 53
74473: PUSH
74474: LD_EXP 53
74478: PPUSH
74479: LD_VAR 0 1
74483: PUSH
74484: LD_EXP 53
74488: PUSH
74489: LD_VAR 0 1
74493: ARRAY
74494: PUSH
74495: LD_INT 1
74497: PLUS
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PPUSH
74503: LD_VAR 0 9
74507: PPUSH
74508: CALL 14917 0 3
74512: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74513: LD_ADDR_EXP 52
74517: PUSH
74518: LD_EXP 52
74522: PPUSH
74523: LD_VAR 0 1
74527: PPUSH
74528: LD_EXP 52
74532: PUSH
74533: LD_VAR 0 1
74537: ARRAY
74538: PUSH
74539: LD_VAR 0 9
74543: DIFF
74544: PPUSH
74545: CALL_OW 1
74549: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74550: LD_VAR 0 3
74554: PPUSH
74555: LD_EXP 53
74559: PUSH
74560: LD_VAR 0 1
74564: ARRAY
74565: PUSH
74566: LD_EXP 53
74570: PUSH
74571: LD_VAR 0 1
74575: ARRAY
74576: ARRAY
74577: PPUSH
74578: CALL_OW 120
// end ; exit ;
74582: GO 74903
// end ; if tmp > 1 then
74584: LD_VAR 0 8
74588: PUSH
74589: LD_INT 1
74591: GREATER
74592: IFFALSE 74696
// for i = 2 to tmp do
74594: LD_ADDR_VAR 0 6
74598: PUSH
74599: DOUBLE
74600: LD_INT 2
74602: DEC
74603: ST_TO_ADDR
74604: LD_VAR 0 8
74608: PUSH
74609: FOR_TO
74610: IFFALSE 74694
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74612: LD_VAR 0 8
74616: PUSH
74617: LD_VAR 0 6
74621: ARRAY
74622: PPUSH
74623: CALL_OW 461
74627: PUSH
74628: LD_INT 6
74630: EQUAL
74631: IFFALSE 74692
// begin x := tmp [ i ] ;
74633: LD_ADDR_VAR 0 9
74637: PUSH
74638: LD_VAR 0 8
74642: PUSH
74643: LD_VAR 0 6
74647: ARRAY
74648: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74649: LD_ADDR_VAR 0 8
74653: PUSH
74654: LD_VAR 0 8
74658: PPUSH
74659: LD_VAR 0 6
74663: PPUSH
74664: CALL_OW 3
74668: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74669: LD_ADDR_VAR 0 8
74673: PUSH
74674: LD_VAR 0 8
74678: PPUSH
74679: LD_INT 1
74681: PPUSH
74682: LD_VAR 0 9
74686: PPUSH
74687: CALL_OW 2
74691: ST_TO_ADDR
// end ;
74692: GO 74609
74694: POP
74695: POP
// for i in tmp do
74696: LD_ADDR_VAR 0 6
74700: PUSH
74701: LD_VAR 0 8
74705: PUSH
74706: FOR_IN
74707: IFFALSE 74776
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74709: LD_VAR 0 6
74713: PPUSH
74714: CALL_OW 313
74718: PUSH
74719: LD_INT 6
74721: LESS
74722: PUSH
74723: LD_VAR 0 6
74727: PPUSH
74728: CALL_OW 266
74732: PUSH
74733: LD_INT 31
74735: PUSH
74736: LD_INT 32
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: IN
74743: NOT
74744: AND
74745: PUSH
74746: LD_VAR 0 6
74750: PPUSH
74751: CALL_OW 313
74755: PUSH
74756: LD_INT 0
74758: EQUAL
74759: OR
74760: IFFALSE 74774
// begin j := i ;
74762: LD_ADDR_VAR 0 7
74766: PUSH
74767: LD_VAR 0 6
74771: ST_TO_ADDR
// break ;
74772: GO 74776
// end ; end ;
74774: GO 74706
74776: POP
74777: POP
// if j then
74778: LD_VAR 0 7
74782: IFFALSE 74800
// ComEnterUnit ( unit , j ) else
74784: LD_VAR 0 3
74788: PPUSH
74789: LD_VAR 0 7
74793: PPUSH
74794: CALL_OW 120
74798: GO 74903
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74800: LD_ADDR_VAR 0 10
74804: PUSH
74805: LD_VAR 0 2
74809: PPUSH
74810: LD_INT 2
74812: PUSH
74813: LD_INT 30
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 30
74825: PUSH
74826: LD_INT 1
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: LIST
74837: PPUSH
74838: CALL_OW 72
74842: ST_TO_ADDR
// if depot then
74843: LD_VAR 0 10
74847: IFFALSE 74903
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74849: LD_ADDR_VAR 0 10
74853: PUSH
74854: LD_VAR 0 10
74858: PPUSH
74859: LD_VAR 0 3
74863: PPUSH
74864: CALL_OW 74
74868: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74869: LD_VAR 0 3
74873: PPUSH
74874: LD_VAR 0 10
74878: PPUSH
74879: CALL_OW 296
74883: PUSH
74884: LD_INT 10
74886: GREATER
74887: IFFALSE 74903
// ComStandNearbyBuilding ( unit , depot ) ;
74889: LD_VAR 0 3
74893: PPUSH
74894: LD_VAR 0 10
74898: PPUSH
74899: CALL 11376 0 2
// end ; end ; end ;
74903: LD_VAR 0 5
74907: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74908: LD_INT 0
74910: PPUSH
74911: PPUSH
74912: PPUSH
74913: PPUSH
// if not mc_bases then
74914: LD_EXP 43
74918: NOT
74919: IFFALSE 74923
// exit ;
74921: GO 75162
// for i = 1 to mc_bases do
74923: LD_ADDR_VAR 0 2
74927: PUSH
74928: DOUBLE
74929: LD_INT 1
74931: DEC
74932: ST_TO_ADDR
74933: LD_EXP 43
74937: PUSH
74938: FOR_TO
74939: IFFALSE 75160
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74941: LD_ADDR_VAR 0 4
74945: PUSH
74946: LD_EXP 43
74950: PUSH
74951: LD_VAR 0 2
74955: ARRAY
74956: PPUSH
74957: LD_INT 21
74959: PUSH
74960: LD_INT 1
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PPUSH
74967: CALL_OW 72
74971: PUSH
74972: LD_EXP 72
74976: PUSH
74977: LD_VAR 0 2
74981: ARRAY
74982: UNION
74983: ST_TO_ADDR
// if not tmp then
74984: LD_VAR 0 4
74988: NOT
74989: IFFALSE 74993
// continue ;
74991: GO 74938
// for j in tmp do
74993: LD_ADDR_VAR 0 3
74997: PUSH
74998: LD_VAR 0 4
75002: PUSH
75003: FOR_IN
75004: IFFALSE 75156
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75006: LD_VAR 0 3
75010: PPUSH
75011: CALL_OW 110
75015: NOT
75016: PUSH
75017: LD_VAR 0 3
75021: PPUSH
75022: CALL_OW 314
75026: NOT
75027: AND
75028: PUSH
75029: LD_VAR 0 3
75033: PPUSH
75034: CALL_OW 311
75038: NOT
75039: AND
75040: PUSH
75041: LD_VAR 0 3
75045: PPUSH
75046: CALL_OW 310
75050: NOT
75051: AND
75052: PUSH
75053: LD_VAR 0 3
75057: PUSH
75058: LD_EXP 46
75062: PUSH
75063: LD_VAR 0 2
75067: ARRAY
75068: PUSH
75069: LD_INT 1
75071: ARRAY
75072: IN
75073: NOT
75074: AND
75075: PUSH
75076: LD_VAR 0 3
75080: PUSH
75081: LD_EXP 46
75085: PUSH
75086: LD_VAR 0 2
75090: ARRAY
75091: PUSH
75092: LD_INT 2
75094: ARRAY
75095: IN
75096: NOT
75097: AND
75098: PUSH
75099: LD_VAR 0 3
75103: PUSH
75104: LD_EXP 55
75108: PUSH
75109: LD_VAR 0 2
75113: ARRAY
75114: IN
75115: NOT
75116: AND
75117: IFFALSE 75154
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75119: LD_VAR 0 2
75123: PPUSH
75124: LD_EXP 43
75128: PUSH
75129: LD_VAR 0 2
75133: ARRAY
75134: PPUSH
75135: LD_VAR 0 3
75139: PPUSH
75140: LD_VAR 0 3
75144: PPUSH
75145: CALL_OW 257
75149: PPUSH
75150: CALL 73926 0 4
// end ;
75154: GO 75003
75156: POP
75157: POP
// end ;
75158: GO 74938
75160: POP
75161: POP
// end ;
75162: LD_VAR 0 1
75166: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75167: LD_INT 0
75169: PPUSH
75170: PPUSH
75171: PPUSH
75172: PPUSH
75173: PPUSH
75174: PPUSH
// if not mc_bases [ base ] then
75175: LD_EXP 43
75179: PUSH
75180: LD_VAR 0 1
75184: ARRAY
75185: NOT
75186: IFFALSE 75190
// exit ;
75188: GO 75372
// tmp := [ ] ;
75190: LD_ADDR_VAR 0 6
75194: PUSH
75195: EMPTY
75196: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75197: LD_ADDR_VAR 0 7
75201: PUSH
75202: LD_VAR 0 3
75206: PPUSH
75207: LD_INT 0
75209: PPUSH
75210: CALL_OW 517
75214: ST_TO_ADDR
// if not list then
75215: LD_VAR 0 7
75219: NOT
75220: IFFALSE 75224
// exit ;
75222: GO 75372
// for i = 1 to amount do
75224: LD_ADDR_VAR 0 5
75228: PUSH
75229: DOUBLE
75230: LD_INT 1
75232: DEC
75233: ST_TO_ADDR
75234: LD_VAR 0 2
75238: PUSH
75239: FOR_TO
75240: IFFALSE 75320
// begin x := rand ( 1 , list [ 1 ] ) ;
75242: LD_ADDR_VAR 0 8
75246: PUSH
75247: LD_INT 1
75249: PPUSH
75250: LD_VAR 0 7
75254: PUSH
75255: LD_INT 1
75257: ARRAY
75258: PPUSH
75259: CALL_OW 12
75263: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75264: LD_ADDR_VAR 0 6
75268: PUSH
75269: LD_VAR 0 6
75273: PPUSH
75274: LD_VAR 0 5
75278: PPUSH
75279: LD_VAR 0 7
75283: PUSH
75284: LD_INT 1
75286: ARRAY
75287: PUSH
75288: LD_VAR 0 8
75292: ARRAY
75293: PUSH
75294: LD_VAR 0 7
75298: PUSH
75299: LD_INT 2
75301: ARRAY
75302: PUSH
75303: LD_VAR 0 8
75307: ARRAY
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PPUSH
75313: CALL_OW 1
75317: ST_TO_ADDR
// end ;
75318: GO 75239
75320: POP
75321: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75322: LD_ADDR_EXP 56
75326: PUSH
75327: LD_EXP 56
75331: PPUSH
75332: LD_VAR 0 1
75336: PPUSH
75337: LD_VAR 0 6
75341: PPUSH
75342: CALL_OW 1
75346: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75347: LD_ADDR_EXP 58
75351: PUSH
75352: LD_EXP 58
75356: PPUSH
75357: LD_VAR 0 1
75361: PPUSH
75362: LD_VAR 0 3
75366: PPUSH
75367: CALL_OW 1
75371: ST_TO_ADDR
// end ;
75372: LD_VAR 0 4
75376: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75377: LD_INT 0
75379: PPUSH
// if not mc_bases [ base ] then
75380: LD_EXP 43
75384: PUSH
75385: LD_VAR 0 1
75389: ARRAY
75390: NOT
75391: IFFALSE 75395
// exit ;
75393: GO 75420
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75395: LD_ADDR_EXP 48
75399: PUSH
75400: LD_EXP 48
75404: PPUSH
75405: LD_VAR 0 1
75409: PPUSH
75410: LD_VAR 0 2
75414: PPUSH
75415: CALL_OW 1
75419: ST_TO_ADDR
// end ;
75420: LD_VAR 0 3
75424: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75425: LD_INT 0
75427: PPUSH
// if not mc_bases [ base ] then
75428: LD_EXP 43
75432: PUSH
75433: LD_VAR 0 1
75437: ARRAY
75438: NOT
75439: IFFALSE 75443
// exit ;
75441: GO 75480
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75443: LD_ADDR_EXP 48
75447: PUSH
75448: LD_EXP 48
75452: PPUSH
75453: LD_VAR 0 1
75457: PPUSH
75458: LD_EXP 48
75462: PUSH
75463: LD_VAR 0 1
75467: ARRAY
75468: PUSH
75469: LD_VAR 0 2
75473: UNION
75474: PPUSH
75475: CALL_OW 1
75479: ST_TO_ADDR
// end ;
75480: LD_VAR 0 3
75484: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75485: LD_INT 0
75487: PPUSH
// if not mc_bases [ base ] then
75488: LD_EXP 43
75492: PUSH
75493: LD_VAR 0 1
75497: ARRAY
75498: NOT
75499: IFFALSE 75503
// exit ;
75501: GO 75528
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75503: LD_ADDR_EXP 64
75507: PUSH
75508: LD_EXP 64
75512: PPUSH
75513: LD_VAR 0 1
75517: PPUSH
75518: LD_VAR 0 2
75522: PPUSH
75523: CALL_OW 1
75527: ST_TO_ADDR
// end ;
75528: LD_VAR 0 3
75532: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75533: LD_INT 0
75535: PPUSH
// if not mc_bases [ base ] then
75536: LD_EXP 43
75540: PUSH
75541: LD_VAR 0 1
75545: ARRAY
75546: NOT
75547: IFFALSE 75551
// exit ;
75549: GO 75588
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75551: LD_ADDR_EXP 64
75555: PUSH
75556: LD_EXP 64
75560: PPUSH
75561: LD_VAR 0 1
75565: PPUSH
75566: LD_EXP 64
75570: PUSH
75571: LD_VAR 0 1
75575: ARRAY
75576: PUSH
75577: LD_VAR 0 2
75581: ADD
75582: PPUSH
75583: CALL_OW 1
75587: ST_TO_ADDR
// end ;
75588: LD_VAR 0 3
75592: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75593: LD_INT 0
75595: PPUSH
// if not mc_bases [ base ] then
75596: LD_EXP 43
75600: PUSH
75601: LD_VAR 0 1
75605: ARRAY
75606: NOT
75607: IFFALSE 75611
// exit ;
75609: GO 75665
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75611: LD_ADDR_EXP 65
75615: PUSH
75616: LD_EXP 65
75620: PPUSH
75621: LD_VAR 0 1
75625: PPUSH
75626: LD_VAR 0 2
75630: PPUSH
75631: CALL_OW 1
75635: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75636: LD_ADDR_EXP 54
75640: PUSH
75641: LD_EXP 54
75645: PPUSH
75646: LD_VAR 0 1
75650: PPUSH
75651: LD_VAR 0 2
75655: PUSH
75656: LD_INT 0
75658: PLUS
75659: PPUSH
75660: CALL_OW 1
75664: ST_TO_ADDR
// end ;
75665: LD_VAR 0 3
75669: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75670: LD_INT 0
75672: PPUSH
// if not mc_bases [ base ] then
75673: LD_EXP 43
75677: PUSH
75678: LD_VAR 0 1
75682: ARRAY
75683: NOT
75684: IFFALSE 75688
// exit ;
75686: GO 75713
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75688: LD_ADDR_EXP 54
75692: PUSH
75693: LD_EXP 54
75697: PPUSH
75698: LD_VAR 0 1
75702: PPUSH
75703: LD_VAR 0 2
75707: PPUSH
75708: CALL_OW 1
75712: ST_TO_ADDR
// end ;
75713: LD_VAR 0 3
75717: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75718: LD_INT 0
75720: PPUSH
75721: PPUSH
75722: PPUSH
75723: PPUSH
// if not mc_bases [ base ] then
75724: LD_EXP 43
75728: PUSH
75729: LD_VAR 0 1
75733: ARRAY
75734: NOT
75735: IFFALSE 75739
// exit ;
75737: GO 75804
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75739: LD_ADDR_EXP 63
75743: PUSH
75744: LD_EXP 63
75748: PPUSH
75749: LD_VAR 0 1
75753: PUSH
75754: LD_EXP 63
75758: PUSH
75759: LD_VAR 0 1
75763: ARRAY
75764: PUSH
75765: LD_INT 1
75767: PLUS
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PPUSH
75773: LD_VAR 0 1
75777: PUSH
75778: LD_VAR 0 2
75782: PUSH
75783: LD_VAR 0 3
75787: PUSH
75788: LD_VAR 0 4
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: PPUSH
75799: CALL 14917 0 3
75803: ST_TO_ADDR
// end ;
75804: LD_VAR 0 5
75808: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75809: LD_INT 0
75811: PPUSH
// if not mc_bases [ base ] then
75812: LD_EXP 43
75816: PUSH
75817: LD_VAR 0 1
75821: ARRAY
75822: NOT
75823: IFFALSE 75827
// exit ;
75825: GO 75852
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75827: LD_ADDR_EXP 80
75831: PUSH
75832: LD_EXP 80
75836: PPUSH
75837: LD_VAR 0 1
75841: PPUSH
75842: LD_VAR 0 2
75846: PPUSH
75847: CALL_OW 1
75851: ST_TO_ADDR
// end ;
75852: LD_VAR 0 3
75856: RET
// export function MC_GetMinesField ( base ) ; begin
75857: LD_INT 0
75859: PPUSH
// result := mc_mines [ base ] ;
75860: LD_ADDR_VAR 0 2
75864: PUSH
75865: LD_EXP 56
75869: PUSH
75870: LD_VAR 0 1
75874: ARRAY
75875: ST_TO_ADDR
// end ;
75876: LD_VAR 0 2
75880: RET
// export function MC_GetProduceList ( base ) ; begin
75881: LD_INT 0
75883: PPUSH
// result := mc_produce [ base ] ;
75884: LD_ADDR_VAR 0 2
75888: PUSH
75889: LD_EXP 64
75893: PUSH
75894: LD_VAR 0 1
75898: ARRAY
75899: ST_TO_ADDR
// end ;
75900: LD_VAR 0 2
75904: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75905: LD_INT 0
75907: PPUSH
75908: PPUSH
// if not mc_bases then
75909: LD_EXP 43
75913: NOT
75914: IFFALSE 75918
// exit ;
75916: GO 75983
// if mc_bases [ base ] then
75918: LD_EXP 43
75922: PUSH
75923: LD_VAR 0 1
75927: ARRAY
75928: IFFALSE 75983
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75930: LD_ADDR_VAR 0 3
75934: PUSH
75935: LD_EXP 43
75939: PUSH
75940: LD_VAR 0 1
75944: ARRAY
75945: PPUSH
75946: LD_INT 30
75948: PUSH
75949: LD_VAR 0 2
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PPUSH
75958: CALL_OW 72
75962: ST_TO_ADDR
// if result then
75963: LD_VAR 0 3
75967: IFFALSE 75983
// result := result [ 1 ] ;
75969: LD_ADDR_VAR 0 3
75973: PUSH
75974: LD_VAR 0 3
75978: PUSH
75979: LD_INT 1
75981: ARRAY
75982: ST_TO_ADDR
// end ; end ;
75983: LD_VAR 0 3
75987: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75988: LD_INT 0
75990: PPUSH
75991: PPUSH
// if not mc_bases then
75992: LD_EXP 43
75996: NOT
75997: IFFALSE 76001
// exit ;
75999: GO 76046
// if mc_bases [ base ] then
76001: LD_EXP 43
76005: PUSH
76006: LD_VAR 0 1
76010: ARRAY
76011: IFFALSE 76046
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76013: LD_ADDR_VAR 0 3
76017: PUSH
76018: LD_EXP 43
76022: PUSH
76023: LD_VAR 0 1
76027: ARRAY
76028: PPUSH
76029: LD_INT 30
76031: PUSH
76032: LD_VAR 0 2
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PPUSH
76041: CALL_OW 72
76045: ST_TO_ADDR
// end ;
76046: LD_VAR 0 3
76050: RET
// export function MC_SetTame ( base , area ) ; begin
76051: LD_INT 0
76053: PPUSH
// if not mc_bases or not base then
76054: LD_EXP 43
76058: NOT
76059: PUSH
76060: LD_VAR 0 1
76064: NOT
76065: OR
76066: IFFALSE 76070
// exit ;
76068: GO 76095
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76070: LD_ADDR_EXP 71
76074: PUSH
76075: LD_EXP 71
76079: PPUSH
76080: LD_VAR 0 1
76084: PPUSH
76085: LD_VAR 0 2
76089: PPUSH
76090: CALL_OW 1
76094: ST_TO_ADDR
// end ;
76095: LD_VAR 0 3
76099: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76100: LD_INT 0
76102: PPUSH
76103: PPUSH
// if not mc_bases or not base then
76104: LD_EXP 43
76108: NOT
76109: PUSH
76110: LD_VAR 0 1
76114: NOT
76115: OR
76116: IFFALSE 76120
// exit ;
76118: GO 76222
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76120: LD_ADDR_VAR 0 4
76124: PUSH
76125: LD_EXP 43
76129: PUSH
76130: LD_VAR 0 1
76134: ARRAY
76135: PPUSH
76136: LD_INT 30
76138: PUSH
76139: LD_VAR 0 2
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PPUSH
76148: CALL_OW 72
76152: ST_TO_ADDR
// if not tmp then
76153: LD_VAR 0 4
76157: NOT
76158: IFFALSE 76162
// exit ;
76160: GO 76222
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76162: LD_ADDR_EXP 75
76166: PUSH
76167: LD_EXP 75
76171: PPUSH
76172: LD_VAR 0 1
76176: PPUSH
76177: LD_EXP 75
76181: PUSH
76182: LD_VAR 0 1
76186: ARRAY
76187: PPUSH
76188: LD_EXP 75
76192: PUSH
76193: LD_VAR 0 1
76197: ARRAY
76198: PUSH
76199: LD_INT 1
76201: PLUS
76202: PPUSH
76203: LD_VAR 0 4
76207: PUSH
76208: LD_INT 1
76210: ARRAY
76211: PPUSH
76212: CALL_OW 2
76216: PPUSH
76217: CALL_OW 1
76221: ST_TO_ADDR
// end ;
76222: LD_VAR 0 3
76226: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76227: LD_INT 0
76229: PPUSH
76230: PPUSH
// if not mc_bases or not base or not kinds then
76231: LD_EXP 43
76235: NOT
76236: PUSH
76237: LD_VAR 0 1
76241: NOT
76242: OR
76243: PUSH
76244: LD_VAR 0 2
76248: NOT
76249: OR
76250: IFFALSE 76254
// exit ;
76252: GO 76315
// for i in kinds do
76254: LD_ADDR_VAR 0 4
76258: PUSH
76259: LD_VAR 0 2
76263: PUSH
76264: FOR_IN
76265: IFFALSE 76313
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76267: LD_ADDR_EXP 77
76271: PUSH
76272: LD_EXP 77
76276: PPUSH
76277: LD_VAR 0 1
76281: PUSH
76282: LD_EXP 77
76286: PUSH
76287: LD_VAR 0 1
76291: ARRAY
76292: PUSH
76293: LD_INT 1
76295: PLUS
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PPUSH
76301: LD_VAR 0 4
76305: PPUSH
76306: CALL 14917 0 3
76310: ST_TO_ADDR
76311: GO 76264
76313: POP
76314: POP
// end ;
76315: LD_VAR 0 3
76319: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76320: LD_INT 0
76322: PPUSH
// if not mc_bases or not base or not areas then
76323: LD_EXP 43
76327: NOT
76328: PUSH
76329: LD_VAR 0 1
76333: NOT
76334: OR
76335: PUSH
76336: LD_VAR 0 2
76340: NOT
76341: OR
76342: IFFALSE 76346
// exit ;
76344: GO 76371
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76346: LD_ADDR_EXP 61
76350: PUSH
76351: LD_EXP 61
76355: PPUSH
76356: LD_VAR 0 1
76360: PPUSH
76361: LD_VAR 0 2
76365: PPUSH
76366: CALL_OW 1
76370: ST_TO_ADDR
// end ;
76371: LD_VAR 0 3
76375: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76376: LD_INT 0
76378: PPUSH
// if not mc_bases or not base or not teleports_exit then
76379: LD_EXP 43
76383: NOT
76384: PUSH
76385: LD_VAR 0 1
76389: NOT
76390: OR
76391: PUSH
76392: LD_VAR 0 2
76396: NOT
76397: OR
76398: IFFALSE 76402
// exit ;
76400: GO 76427
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76402: LD_ADDR_EXP 78
76406: PUSH
76407: LD_EXP 78
76411: PPUSH
76412: LD_VAR 0 1
76416: PPUSH
76417: LD_VAR 0 2
76421: PPUSH
76422: CALL_OW 1
76426: ST_TO_ADDR
// end ;
76427: LD_VAR 0 3
76431: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76432: LD_INT 0
76434: PPUSH
76435: PPUSH
76436: PPUSH
// if not mc_bases or not base or not ext_list then
76437: LD_EXP 43
76441: NOT
76442: PUSH
76443: LD_VAR 0 1
76447: NOT
76448: OR
76449: PUSH
76450: LD_VAR 0 5
76454: NOT
76455: OR
76456: IFFALSE 76460
// exit ;
76458: GO 76633
// tmp := GetFacExtXYD ( x , y , d ) ;
76460: LD_ADDR_VAR 0 8
76464: PUSH
76465: LD_VAR 0 2
76469: PPUSH
76470: LD_VAR 0 3
76474: PPUSH
76475: LD_VAR 0 4
76479: PPUSH
76480: CALL 44894 0 3
76484: ST_TO_ADDR
// if not tmp then
76485: LD_VAR 0 8
76489: NOT
76490: IFFALSE 76494
// exit ;
76492: GO 76633
// for i in tmp do
76494: LD_ADDR_VAR 0 7
76498: PUSH
76499: LD_VAR 0 8
76503: PUSH
76504: FOR_IN
76505: IFFALSE 76631
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76507: LD_ADDR_EXP 48
76511: PUSH
76512: LD_EXP 48
76516: PPUSH
76517: LD_VAR 0 1
76521: PPUSH
76522: LD_EXP 48
76526: PUSH
76527: LD_VAR 0 1
76531: ARRAY
76532: PPUSH
76533: LD_EXP 48
76537: PUSH
76538: LD_VAR 0 1
76542: ARRAY
76543: PUSH
76544: LD_INT 1
76546: PLUS
76547: PPUSH
76548: LD_VAR 0 5
76552: PUSH
76553: LD_INT 1
76555: ARRAY
76556: PUSH
76557: LD_VAR 0 7
76561: PUSH
76562: LD_INT 1
76564: ARRAY
76565: PUSH
76566: LD_VAR 0 7
76570: PUSH
76571: LD_INT 2
76573: ARRAY
76574: PUSH
76575: LD_VAR 0 7
76579: PUSH
76580: LD_INT 3
76582: ARRAY
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: LIST
76588: LIST
76589: PPUSH
76590: CALL_OW 2
76594: PPUSH
76595: CALL_OW 1
76599: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76600: LD_ADDR_VAR 0 5
76604: PUSH
76605: LD_VAR 0 5
76609: PPUSH
76610: LD_INT 1
76612: PPUSH
76613: CALL_OW 3
76617: ST_TO_ADDR
// if not ext_list then
76618: LD_VAR 0 5
76622: NOT
76623: IFFALSE 76629
// exit ;
76625: POP
76626: POP
76627: GO 76633
// end ;
76629: GO 76504
76631: POP
76632: POP
// end ;
76633: LD_VAR 0 6
76637: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76638: LD_INT 0
76640: PPUSH
// if not mc_bases or not base or not weapon_list then
76641: LD_EXP 43
76645: NOT
76646: PUSH
76647: LD_VAR 0 1
76651: NOT
76652: OR
76653: PUSH
76654: LD_VAR 0 2
76658: NOT
76659: OR
76660: IFFALSE 76664
// exit ;
76662: GO 76689
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76664: LD_ADDR_EXP 82
76668: PUSH
76669: LD_EXP 82
76673: PPUSH
76674: LD_VAR 0 1
76678: PPUSH
76679: LD_VAR 0 2
76683: PPUSH
76684: CALL_OW 1
76688: ST_TO_ADDR
// end ;
76689: LD_VAR 0 3
76693: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76694: LD_INT 0
76696: PPUSH
// if not mc_bases or not base or not tech_list then
76697: LD_EXP 43
76701: NOT
76702: PUSH
76703: LD_VAR 0 1
76707: NOT
76708: OR
76709: PUSH
76710: LD_VAR 0 2
76714: NOT
76715: OR
76716: IFFALSE 76720
// exit ;
76718: GO 76745
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76720: LD_ADDR_EXP 70
76724: PUSH
76725: LD_EXP 70
76729: PPUSH
76730: LD_VAR 0 1
76734: PPUSH
76735: LD_VAR 0 2
76739: PPUSH
76740: CALL_OW 1
76744: ST_TO_ADDR
// end ;
76745: LD_VAR 0 3
76749: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76750: LD_INT 0
76752: PPUSH
// if not mc_bases or not parking_area or not base then
76753: LD_EXP 43
76757: NOT
76758: PUSH
76759: LD_VAR 0 2
76763: NOT
76764: OR
76765: PUSH
76766: LD_VAR 0 1
76770: NOT
76771: OR
76772: IFFALSE 76776
// exit ;
76774: GO 76801
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76776: LD_ADDR_EXP 67
76780: PUSH
76781: LD_EXP 67
76785: PPUSH
76786: LD_VAR 0 1
76790: PPUSH
76791: LD_VAR 0 2
76795: PPUSH
76796: CALL_OW 1
76800: ST_TO_ADDR
// end ;
76801: LD_VAR 0 3
76805: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76806: LD_INT 0
76808: PPUSH
// if not mc_bases or not base or not scan_area then
76809: LD_EXP 43
76813: NOT
76814: PUSH
76815: LD_VAR 0 1
76819: NOT
76820: OR
76821: PUSH
76822: LD_VAR 0 2
76826: NOT
76827: OR
76828: IFFALSE 76832
// exit ;
76830: GO 76857
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76832: LD_ADDR_EXP 68
76836: PUSH
76837: LD_EXP 68
76841: PPUSH
76842: LD_VAR 0 1
76846: PPUSH
76847: LD_VAR 0 2
76851: PPUSH
76852: CALL_OW 1
76856: ST_TO_ADDR
// end ;
76857: LD_VAR 0 3
76861: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76862: LD_INT 0
76864: PPUSH
76865: PPUSH
// if not mc_bases or not base then
76866: LD_EXP 43
76870: NOT
76871: PUSH
76872: LD_VAR 0 1
76876: NOT
76877: OR
76878: IFFALSE 76882
// exit ;
76880: GO 76946
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76882: LD_ADDR_VAR 0 3
76886: PUSH
76887: LD_INT 1
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: LD_INT 3
76895: PUSH
76896: LD_INT 4
76898: PUSH
76899: LD_INT 11
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76909: LD_ADDR_EXP 70
76913: PUSH
76914: LD_EXP 70
76918: PPUSH
76919: LD_VAR 0 1
76923: PPUSH
76924: LD_EXP 70
76928: PUSH
76929: LD_VAR 0 1
76933: ARRAY
76934: PUSH
76935: LD_VAR 0 3
76939: DIFF
76940: PPUSH
76941: CALL_OW 1
76945: ST_TO_ADDR
// end ;
76946: LD_VAR 0 2
76950: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76951: LD_INT 0
76953: PPUSH
// result := mc_vehicles [ base ] ;
76954: LD_ADDR_VAR 0 3
76958: PUSH
76959: LD_EXP 62
76963: PUSH
76964: LD_VAR 0 1
76968: ARRAY
76969: ST_TO_ADDR
// if onlyCombat then
76970: LD_VAR 0 2
76974: IFFALSE 77146
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76976: LD_ADDR_VAR 0 3
76980: PUSH
76981: LD_VAR 0 3
76985: PUSH
76986: LD_VAR 0 3
76990: PPUSH
76991: LD_INT 2
76993: PUSH
76994: LD_INT 34
76996: PUSH
76997: LD_INT 12
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 34
77006: PUSH
77007: LD_INT 51
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 34
77016: PUSH
77017: LD_INT 89
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 34
77026: PUSH
77027: LD_INT 32
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 34
77036: PUSH
77037: LD_INT 13
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 34
77046: PUSH
77047: LD_INT 52
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 34
77056: PUSH
77057: LD_INT 88
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 34
77066: PUSH
77067: LD_INT 14
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 34
77076: PUSH
77077: LD_INT 53
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 34
77086: PUSH
77087: LD_INT 98
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 34
77096: PUSH
77097: LD_INT 31
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: LD_INT 34
77106: PUSH
77107: LD_INT 48
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 34
77116: PUSH
77117: LD_INT 8
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: PPUSH
77140: CALL_OW 72
77144: DIFF
77145: ST_TO_ADDR
// end ; end_of_file
77146: LD_VAR 0 3
77150: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77151: LD_INT 0
77153: PPUSH
77154: PPUSH
77155: PPUSH
// if not mc_bases or not skirmish then
77156: LD_EXP 43
77160: NOT
77161: PUSH
77162: LD_EXP 41
77166: NOT
77167: OR
77168: IFFALSE 77172
// exit ;
77170: GO 77337
// for i = 1 to mc_bases do
77172: LD_ADDR_VAR 0 4
77176: PUSH
77177: DOUBLE
77178: LD_INT 1
77180: DEC
77181: ST_TO_ADDR
77182: LD_EXP 43
77186: PUSH
77187: FOR_TO
77188: IFFALSE 77335
// begin if sci in mc_bases [ i ] then
77190: LD_VAR 0 2
77194: PUSH
77195: LD_EXP 43
77199: PUSH
77200: LD_VAR 0 4
77204: ARRAY
77205: IN
77206: IFFALSE 77333
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77208: LD_ADDR_EXP 72
77212: PUSH
77213: LD_EXP 72
77217: PPUSH
77218: LD_VAR 0 4
77222: PUSH
77223: LD_EXP 72
77227: PUSH
77228: LD_VAR 0 4
77232: ARRAY
77233: PUSH
77234: LD_INT 1
77236: PLUS
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PPUSH
77242: LD_VAR 0 1
77246: PPUSH
77247: CALL 14917 0 3
77251: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77252: LD_ADDR_VAR 0 5
77256: PUSH
77257: LD_EXP 43
77261: PUSH
77262: LD_VAR 0 4
77266: ARRAY
77267: PPUSH
77268: LD_INT 2
77270: PUSH
77271: LD_INT 30
77273: PUSH
77274: LD_INT 0
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 30
77283: PUSH
77284: LD_INT 1
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: LIST
77295: PPUSH
77296: CALL_OW 72
77300: PPUSH
77301: LD_VAR 0 1
77305: PPUSH
77306: CALL_OW 74
77310: ST_TO_ADDR
// if tmp then
77311: LD_VAR 0 5
77315: IFFALSE 77331
// ComStandNearbyBuilding ( ape , tmp ) ;
77317: LD_VAR 0 1
77321: PPUSH
77322: LD_VAR 0 5
77326: PPUSH
77327: CALL 11376 0 2
// break ;
77331: GO 77335
// end ; end ;
77333: GO 77187
77335: POP
77336: POP
// end ;
77337: LD_VAR 0 3
77341: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77342: LD_INT 0
77344: PPUSH
77345: PPUSH
77346: PPUSH
// if not mc_bases or not skirmish then
77347: LD_EXP 43
77351: NOT
77352: PUSH
77353: LD_EXP 41
77357: NOT
77358: OR
77359: IFFALSE 77363
// exit ;
77361: GO 77452
// for i = 1 to mc_bases do
77363: LD_ADDR_VAR 0 4
77367: PUSH
77368: DOUBLE
77369: LD_INT 1
77371: DEC
77372: ST_TO_ADDR
77373: LD_EXP 43
77377: PUSH
77378: FOR_TO
77379: IFFALSE 77450
// begin if building in mc_busy_turret_list [ i ] then
77381: LD_VAR 0 1
77385: PUSH
77386: LD_EXP 53
77390: PUSH
77391: LD_VAR 0 4
77395: ARRAY
77396: IN
77397: IFFALSE 77448
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77399: LD_ADDR_VAR 0 5
77403: PUSH
77404: LD_EXP 53
77408: PUSH
77409: LD_VAR 0 4
77413: ARRAY
77414: PUSH
77415: LD_VAR 0 1
77419: DIFF
77420: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77421: LD_ADDR_EXP 53
77425: PUSH
77426: LD_EXP 53
77430: PPUSH
77431: LD_VAR 0 4
77435: PPUSH
77436: LD_VAR 0 5
77440: PPUSH
77441: CALL_OW 1
77445: ST_TO_ADDR
// break ;
77446: GO 77450
// end ; end ;
77448: GO 77378
77450: POP
77451: POP
// end ;
77452: LD_VAR 0 3
77456: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77457: LD_INT 0
77459: PPUSH
77460: PPUSH
77461: PPUSH
// if not mc_bases or not skirmish then
77462: LD_EXP 43
77466: NOT
77467: PUSH
77468: LD_EXP 41
77472: NOT
77473: OR
77474: IFFALSE 77478
// exit ;
77476: GO 77677
// for i = 1 to mc_bases do
77478: LD_ADDR_VAR 0 5
77482: PUSH
77483: DOUBLE
77484: LD_INT 1
77486: DEC
77487: ST_TO_ADDR
77488: LD_EXP 43
77492: PUSH
77493: FOR_TO
77494: IFFALSE 77675
// if building in mc_bases [ i ] then
77496: LD_VAR 0 1
77500: PUSH
77501: LD_EXP 43
77505: PUSH
77506: LD_VAR 0 5
77510: ARRAY
77511: IN
77512: IFFALSE 77673
// begin tmp := mc_bases [ i ] diff building ;
77514: LD_ADDR_VAR 0 6
77518: PUSH
77519: LD_EXP 43
77523: PUSH
77524: LD_VAR 0 5
77528: ARRAY
77529: PUSH
77530: LD_VAR 0 1
77534: DIFF
77535: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77536: LD_ADDR_EXP 43
77540: PUSH
77541: LD_EXP 43
77545: PPUSH
77546: LD_VAR 0 5
77550: PPUSH
77551: LD_VAR 0 6
77555: PPUSH
77556: CALL_OW 1
77560: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77561: LD_VAR 0 1
77565: PUSH
77566: LD_EXP 51
77570: PUSH
77571: LD_VAR 0 5
77575: ARRAY
77576: IN
77577: IFFALSE 77616
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77579: LD_ADDR_EXP 51
77583: PUSH
77584: LD_EXP 51
77588: PPUSH
77589: LD_VAR 0 5
77593: PPUSH
77594: LD_EXP 51
77598: PUSH
77599: LD_VAR 0 5
77603: ARRAY
77604: PUSH
77605: LD_VAR 0 1
77609: DIFF
77610: PPUSH
77611: CALL_OW 1
77615: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77616: LD_VAR 0 1
77620: PUSH
77621: LD_EXP 52
77625: PUSH
77626: LD_VAR 0 5
77630: ARRAY
77631: IN
77632: IFFALSE 77671
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77634: LD_ADDR_EXP 52
77638: PUSH
77639: LD_EXP 52
77643: PPUSH
77644: LD_VAR 0 5
77648: PPUSH
77649: LD_EXP 52
77653: PUSH
77654: LD_VAR 0 5
77658: ARRAY
77659: PUSH
77660: LD_VAR 0 1
77664: DIFF
77665: PPUSH
77666: CALL_OW 1
77670: ST_TO_ADDR
// break ;
77671: GO 77675
// end ;
77673: GO 77493
77675: POP
77676: POP
// end ;
77677: LD_VAR 0 4
77681: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77682: LD_INT 0
77684: PPUSH
77685: PPUSH
77686: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77687: LD_EXP 43
77691: NOT
77692: PUSH
77693: LD_EXP 41
77697: NOT
77698: OR
77699: PUSH
77700: LD_VAR 0 3
77704: PUSH
77705: LD_EXP 69
77709: IN
77710: NOT
77711: OR
77712: IFFALSE 77716
// exit ;
77714: GO 77839
// for i = 1 to mc_vehicles do
77716: LD_ADDR_VAR 0 6
77720: PUSH
77721: DOUBLE
77722: LD_INT 1
77724: DEC
77725: ST_TO_ADDR
77726: LD_EXP 62
77730: PUSH
77731: FOR_TO
77732: IFFALSE 77837
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77734: LD_VAR 0 2
77738: PUSH
77739: LD_EXP 62
77743: PUSH
77744: LD_VAR 0 6
77748: ARRAY
77749: IN
77750: PUSH
77751: LD_VAR 0 1
77755: PUSH
77756: LD_EXP 62
77760: PUSH
77761: LD_VAR 0 6
77765: ARRAY
77766: IN
77767: OR
77768: IFFALSE 77835
// begin tmp := mc_vehicles [ i ] diff old ;
77770: LD_ADDR_VAR 0 7
77774: PUSH
77775: LD_EXP 62
77779: PUSH
77780: LD_VAR 0 6
77784: ARRAY
77785: PUSH
77786: LD_VAR 0 2
77790: DIFF
77791: ST_TO_ADDR
// tmp := tmp diff new ;
77792: LD_ADDR_VAR 0 7
77796: PUSH
77797: LD_VAR 0 7
77801: PUSH
77802: LD_VAR 0 1
77806: DIFF
77807: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77808: LD_ADDR_EXP 62
77812: PUSH
77813: LD_EXP 62
77817: PPUSH
77818: LD_VAR 0 6
77822: PPUSH
77823: LD_VAR 0 7
77827: PPUSH
77828: CALL_OW 1
77832: ST_TO_ADDR
// break ;
77833: GO 77837
// end ;
77835: GO 77731
77837: POP
77838: POP
// end ;
77839: LD_VAR 0 5
77843: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77844: LD_INT 0
77846: PPUSH
77847: PPUSH
77848: PPUSH
77849: PPUSH
// if not mc_bases or not skirmish then
77850: LD_EXP 43
77854: NOT
77855: PUSH
77856: LD_EXP 41
77860: NOT
77861: OR
77862: IFFALSE 77866
// exit ;
77864: GO 78286
// repeat wait ( 0 0$1 ) ;
77866: LD_INT 35
77868: PPUSH
77869: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
77873: LD_EXP 87
77877: NOT
77878: IFFALSE 77866
// mc_block_vehicle_constructed_thread := true ;
77880: LD_ADDR_EXP 87
77884: PUSH
77885: LD_INT 1
77887: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
77888: LD_ADDR_VAR 0 5
77892: PUSH
77893: LD_VAR 0 1
77897: PPUSH
77898: CALL_OW 255
77902: ST_TO_ADDR
// for i = 1 to mc_bases do
77903: LD_ADDR_VAR 0 4
77907: PUSH
77908: DOUBLE
77909: LD_INT 1
77911: DEC
77912: ST_TO_ADDR
77913: LD_EXP 43
77917: PUSH
77918: FOR_TO
77919: IFFALSE 78276
// begin if factory in mc_bases [ i ] then
77921: LD_VAR 0 2
77925: PUSH
77926: LD_EXP 43
77930: PUSH
77931: LD_VAR 0 4
77935: ARRAY
77936: IN
77937: IFFALSE 78274
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77939: LD_EXP 65
77943: PUSH
77944: LD_VAR 0 4
77948: ARRAY
77949: PUSH
77950: LD_EXP 54
77954: PUSH
77955: LD_VAR 0 4
77959: ARRAY
77960: LESS
77961: PUSH
77962: LD_VAR 0 1
77966: PPUSH
77967: CALL_OW 264
77971: PUSH
77972: LD_INT 31
77974: PUSH
77975: LD_INT 32
77977: PUSH
77978: LD_INT 51
77980: PUSH
77981: LD_INT 89
77983: PUSH
77984: LD_INT 12
77986: PUSH
77987: LD_INT 30
77989: PUSH
77990: LD_INT 98
77992: PUSH
77993: LD_INT 11
77995: PUSH
77996: LD_INT 53
77998: PUSH
77999: LD_INT 14
78001: PUSH
78002: LD_INT 91
78004: PUSH
78005: LD_INT 29
78007: PUSH
78008: LD_INT 99
78010: PUSH
78011: LD_INT 13
78013: PUSH
78014: LD_INT 52
78016: PUSH
78017: LD_INT 88
78019: PUSH
78020: LD_INT 48
78022: PUSH
78023: LD_INT 8
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: LIST
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: IN
78046: NOT
78047: AND
78048: IFFALSE 78096
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78050: LD_ADDR_EXP 65
78054: PUSH
78055: LD_EXP 65
78059: PPUSH
78060: LD_VAR 0 4
78064: PUSH
78065: LD_EXP 65
78069: PUSH
78070: LD_VAR 0 4
78074: ARRAY
78075: PUSH
78076: LD_INT 1
78078: PLUS
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PPUSH
78084: LD_VAR 0 1
78088: PPUSH
78089: CALL 14917 0 3
78093: ST_TO_ADDR
78094: GO 78140
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78096: LD_ADDR_EXP 62
78100: PUSH
78101: LD_EXP 62
78105: PPUSH
78106: LD_VAR 0 4
78110: PUSH
78111: LD_EXP 62
78115: PUSH
78116: LD_VAR 0 4
78120: ARRAY
78121: PUSH
78122: LD_INT 1
78124: PLUS
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PPUSH
78130: LD_VAR 0 1
78134: PPUSH
78135: CALL 14917 0 3
78139: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
78140: LD_ADDR_EXP 87
78144: PUSH
78145: LD_INT 0
78147: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78148: LD_VAR 0 1
78152: PPUSH
78153: CALL_OW 263
78157: PUSH
78158: LD_INT 2
78160: EQUAL
78161: IFFALSE 78190
// begin repeat wait ( 0 0$3 ) ;
78163: LD_INT 105
78165: PPUSH
78166: CALL_OW 67
// Connect ( vehicle ) ;
78170: LD_VAR 0 1
78174: PPUSH
78175: CALL 17886 0 1
// until IsControledBy ( vehicle ) ;
78179: LD_VAR 0 1
78183: PPUSH
78184: CALL_OW 312
78188: IFFALSE 78163
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78190: LD_VAR 0 1
78194: PPUSH
78195: LD_EXP 67
78199: PUSH
78200: LD_VAR 0 4
78204: ARRAY
78205: PPUSH
78206: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78210: LD_VAR 0 1
78214: PPUSH
78215: CALL_OW 263
78219: PUSH
78220: LD_INT 1
78222: NONEQUAL
78223: IFFALSE 78227
// break ;
78225: GO 78276
// repeat wait ( 0 0$1 ) ;
78227: LD_INT 35
78229: PPUSH
78230: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78234: LD_VAR 0 1
78238: PPUSH
78239: LD_EXP 67
78243: PUSH
78244: LD_VAR 0 4
78248: ARRAY
78249: PPUSH
78250: CALL_OW 308
78254: IFFALSE 78227
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78256: LD_VAR 0 1
78260: PPUSH
78261: CALL_OW 311
78265: PPUSH
78266: CALL_OW 121
// exit ;
78270: POP
78271: POP
78272: GO 78286
// end ; end ;
78274: GO 77918
78276: POP
78277: POP
// mc_block_vehicle_constructed_thread := false ;
78278: LD_ADDR_EXP 87
78282: PUSH
78283: LD_INT 0
78285: ST_TO_ADDR
// end ;
78286: LD_VAR 0 3
78290: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78291: LD_INT 0
78293: PPUSH
78294: PPUSH
78295: PPUSH
78296: PPUSH
// if not mc_bases or not skirmish then
78297: LD_EXP 43
78301: NOT
78302: PUSH
78303: LD_EXP 41
78307: NOT
78308: OR
78309: IFFALSE 78313
// exit ;
78311: GO 78666
// repeat wait ( 0 0$1 ) ;
78313: LD_INT 35
78315: PPUSH
78316: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78320: LD_VAR 0 2
78324: PPUSH
78325: LD_VAR 0 3
78329: PPUSH
78330: CALL_OW 284
78334: IFFALSE 78313
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78336: LD_VAR 0 2
78340: PPUSH
78341: LD_VAR 0 3
78345: PPUSH
78346: CALL_OW 283
78350: PUSH
78351: LD_INT 4
78353: EQUAL
78354: IFFALSE 78358
// exit ;
78356: GO 78666
// for i = 1 to mc_bases do
78358: LD_ADDR_VAR 0 7
78362: PUSH
78363: DOUBLE
78364: LD_INT 1
78366: DEC
78367: ST_TO_ADDR
78368: LD_EXP 43
78372: PUSH
78373: FOR_TO
78374: IFFALSE 78664
// begin if mc_crates_area [ i ] then
78376: LD_EXP 61
78380: PUSH
78381: LD_VAR 0 7
78385: ARRAY
78386: IFFALSE 78497
// for j in mc_crates_area [ i ] do
78388: LD_ADDR_VAR 0 8
78392: PUSH
78393: LD_EXP 61
78397: PUSH
78398: LD_VAR 0 7
78402: ARRAY
78403: PUSH
78404: FOR_IN
78405: IFFALSE 78495
// if InArea ( x , y , j ) then
78407: LD_VAR 0 2
78411: PPUSH
78412: LD_VAR 0 3
78416: PPUSH
78417: LD_VAR 0 8
78421: PPUSH
78422: CALL_OW 309
78426: IFFALSE 78493
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78428: LD_ADDR_EXP 59
78432: PUSH
78433: LD_EXP 59
78437: PPUSH
78438: LD_VAR 0 7
78442: PUSH
78443: LD_EXP 59
78447: PUSH
78448: LD_VAR 0 7
78452: ARRAY
78453: PUSH
78454: LD_INT 1
78456: PLUS
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PPUSH
78462: LD_VAR 0 4
78466: PUSH
78467: LD_VAR 0 2
78471: PUSH
78472: LD_VAR 0 3
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: LIST
78481: PPUSH
78482: CALL 14917 0 3
78486: ST_TO_ADDR
// exit ;
78487: POP
78488: POP
78489: POP
78490: POP
78491: GO 78666
// end ;
78493: GO 78404
78495: POP
78496: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78497: LD_ADDR_VAR 0 9
78501: PUSH
78502: LD_EXP 43
78506: PUSH
78507: LD_VAR 0 7
78511: ARRAY
78512: PPUSH
78513: LD_INT 2
78515: PUSH
78516: LD_INT 30
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 30
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: LIST
78540: PPUSH
78541: CALL_OW 72
78545: ST_TO_ADDR
// if not depot then
78546: LD_VAR 0 9
78550: NOT
78551: IFFALSE 78555
// continue ;
78553: GO 78373
// for j in depot do
78555: LD_ADDR_VAR 0 8
78559: PUSH
78560: LD_VAR 0 9
78564: PUSH
78565: FOR_IN
78566: IFFALSE 78660
// if GetDistUnitXY ( j , x , y ) < 30 then
78568: LD_VAR 0 8
78572: PPUSH
78573: LD_VAR 0 2
78577: PPUSH
78578: LD_VAR 0 3
78582: PPUSH
78583: CALL_OW 297
78587: PUSH
78588: LD_INT 30
78590: LESS
78591: IFFALSE 78658
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78593: LD_ADDR_EXP 59
78597: PUSH
78598: LD_EXP 59
78602: PPUSH
78603: LD_VAR 0 7
78607: PUSH
78608: LD_EXP 59
78612: PUSH
78613: LD_VAR 0 7
78617: ARRAY
78618: PUSH
78619: LD_INT 1
78621: PLUS
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PPUSH
78627: LD_VAR 0 4
78631: PUSH
78632: LD_VAR 0 2
78636: PUSH
78637: LD_VAR 0 3
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: LIST
78646: PPUSH
78647: CALL 14917 0 3
78651: ST_TO_ADDR
// exit ;
78652: POP
78653: POP
78654: POP
78655: POP
78656: GO 78666
// end ;
78658: GO 78565
78660: POP
78661: POP
// end ;
78662: GO 78373
78664: POP
78665: POP
// end ;
78666: LD_VAR 0 6
78670: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78671: LD_INT 0
78673: PPUSH
78674: PPUSH
78675: PPUSH
78676: PPUSH
// if not mc_bases or not skirmish then
78677: LD_EXP 43
78681: NOT
78682: PUSH
78683: LD_EXP 41
78687: NOT
78688: OR
78689: IFFALSE 78693
// exit ;
78691: GO 78970
// side := GetSide ( lab ) ;
78693: LD_ADDR_VAR 0 4
78697: PUSH
78698: LD_VAR 0 2
78702: PPUSH
78703: CALL_OW 255
78707: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78708: LD_VAR 0 4
78712: PUSH
78713: LD_EXP 69
78717: IN
78718: NOT
78719: PUSH
78720: LD_EXP 70
78724: NOT
78725: OR
78726: PUSH
78727: LD_EXP 43
78731: NOT
78732: OR
78733: IFFALSE 78737
// exit ;
78735: GO 78970
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78737: LD_ADDR_EXP 70
78741: PUSH
78742: LD_EXP 70
78746: PPUSH
78747: LD_VAR 0 4
78751: PPUSH
78752: LD_EXP 70
78756: PUSH
78757: LD_VAR 0 4
78761: ARRAY
78762: PUSH
78763: LD_VAR 0 1
78767: DIFF
78768: PPUSH
78769: CALL_OW 1
78773: ST_TO_ADDR
// for i = 1 to mc_bases do
78774: LD_ADDR_VAR 0 5
78778: PUSH
78779: DOUBLE
78780: LD_INT 1
78782: DEC
78783: ST_TO_ADDR
78784: LD_EXP 43
78788: PUSH
78789: FOR_TO
78790: IFFALSE 78968
// begin if lab in mc_bases [ i ] then
78792: LD_VAR 0 2
78796: PUSH
78797: LD_EXP 43
78801: PUSH
78802: LD_VAR 0 5
78806: ARRAY
78807: IN
78808: IFFALSE 78966
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78810: LD_VAR 0 1
78814: PUSH
78815: LD_INT 11
78817: PUSH
78818: LD_INT 4
78820: PUSH
78821: LD_INT 3
78823: PUSH
78824: LD_INT 2
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: IN
78833: PUSH
78834: LD_EXP 73
78838: PUSH
78839: LD_VAR 0 5
78843: ARRAY
78844: AND
78845: IFFALSE 78966
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78847: LD_ADDR_VAR 0 6
78851: PUSH
78852: LD_EXP 73
78856: PUSH
78857: LD_VAR 0 5
78861: ARRAY
78862: PUSH
78863: LD_INT 1
78865: ARRAY
78866: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78867: LD_ADDR_EXP 73
78871: PUSH
78872: LD_EXP 73
78876: PPUSH
78877: LD_VAR 0 5
78881: PPUSH
78882: EMPTY
78883: PPUSH
78884: CALL_OW 1
78888: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78889: LD_VAR 0 6
78893: PPUSH
78894: LD_INT 0
78896: PPUSH
78897: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78901: LD_VAR 0 6
78905: PPUSH
78906: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78910: LD_ADDR_EXP 72
78914: PUSH
78915: LD_EXP 72
78919: PPUSH
78920: LD_VAR 0 5
78924: PPUSH
78925: LD_EXP 72
78929: PUSH
78930: LD_VAR 0 5
78934: ARRAY
78935: PPUSH
78936: LD_INT 1
78938: PPUSH
78939: LD_VAR 0 6
78943: PPUSH
78944: CALL_OW 2
78948: PPUSH
78949: CALL_OW 1
78953: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78954: LD_VAR 0 5
78958: PPUSH
78959: LD_INT 112
78961: PPUSH
78962: CALL 55418 0 2
// end ; end ; end ;
78966: GO 78789
78968: POP
78969: POP
// end ;
78970: LD_VAR 0 3
78974: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78975: LD_INT 0
78977: PPUSH
78978: PPUSH
78979: PPUSH
78980: PPUSH
78981: PPUSH
78982: PPUSH
78983: PPUSH
78984: PPUSH
// if not mc_bases or not skirmish then
78985: LD_EXP 43
78989: NOT
78990: PUSH
78991: LD_EXP 41
78995: NOT
78996: OR
78997: IFFALSE 79001
// exit ;
78999: GO 80370
// for i = 1 to mc_bases do
79001: LD_ADDR_VAR 0 3
79005: PUSH
79006: DOUBLE
79007: LD_INT 1
79009: DEC
79010: ST_TO_ADDR
79011: LD_EXP 43
79015: PUSH
79016: FOR_TO
79017: IFFALSE 80368
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79019: LD_VAR 0 1
79023: PUSH
79024: LD_EXP 43
79028: PUSH
79029: LD_VAR 0 3
79033: ARRAY
79034: IN
79035: PUSH
79036: LD_VAR 0 1
79040: PUSH
79041: LD_EXP 50
79045: PUSH
79046: LD_VAR 0 3
79050: ARRAY
79051: IN
79052: OR
79053: PUSH
79054: LD_VAR 0 1
79058: PUSH
79059: LD_EXP 65
79063: PUSH
79064: LD_VAR 0 3
79068: ARRAY
79069: IN
79070: OR
79071: PUSH
79072: LD_VAR 0 1
79076: PUSH
79077: LD_EXP 62
79081: PUSH
79082: LD_VAR 0 3
79086: ARRAY
79087: IN
79088: OR
79089: PUSH
79090: LD_VAR 0 1
79094: PUSH
79095: LD_EXP 72
79099: PUSH
79100: LD_VAR 0 3
79104: ARRAY
79105: IN
79106: OR
79107: PUSH
79108: LD_VAR 0 1
79112: PUSH
79113: LD_EXP 73
79117: PUSH
79118: LD_VAR 0 3
79122: ARRAY
79123: IN
79124: OR
79125: IFFALSE 80366
// begin if un in mc_ape [ i ] then
79127: LD_VAR 0 1
79131: PUSH
79132: LD_EXP 72
79136: PUSH
79137: LD_VAR 0 3
79141: ARRAY
79142: IN
79143: IFFALSE 79182
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79145: LD_ADDR_EXP 72
79149: PUSH
79150: LD_EXP 72
79154: PPUSH
79155: LD_VAR 0 3
79159: PPUSH
79160: LD_EXP 72
79164: PUSH
79165: LD_VAR 0 3
79169: ARRAY
79170: PUSH
79171: LD_VAR 0 1
79175: DIFF
79176: PPUSH
79177: CALL_OW 1
79181: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79182: LD_VAR 0 1
79186: PUSH
79187: LD_EXP 73
79191: PUSH
79192: LD_VAR 0 3
79196: ARRAY
79197: IN
79198: IFFALSE 79222
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79200: LD_ADDR_EXP 73
79204: PUSH
79205: LD_EXP 73
79209: PPUSH
79210: LD_VAR 0 3
79214: PPUSH
79215: EMPTY
79216: PPUSH
79217: CALL_OW 1
79221: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79222: LD_VAR 0 1
79226: PPUSH
79227: CALL_OW 247
79231: PUSH
79232: LD_INT 2
79234: EQUAL
79235: PUSH
79236: LD_VAR 0 1
79240: PPUSH
79241: CALL_OW 110
79245: PUSH
79246: LD_INT 20
79248: EQUAL
79249: PUSH
79250: LD_VAR 0 1
79254: PUSH
79255: LD_EXP 65
79259: PUSH
79260: LD_VAR 0 3
79264: ARRAY
79265: IN
79266: OR
79267: PUSH
79268: LD_VAR 0 1
79272: PPUSH
79273: CALL_OW 264
79277: PUSH
79278: LD_INT 12
79280: PUSH
79281: LD_INT 51
79283: PUSH
79284: LD_INT 89
79286: PUSH
79287: LD_INT 32
79289: PUSH
79290: LD_INT 13
79292: PUSH
79293: LD_INT 52
79295: PUSH
79296: LD_INT 31
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: IN
79308: OR
79309: AND
79310: IFFALSE 79618
// begin if un in mc_defender [ i ] then
79312: LD_VAR 0 1
79316: PUSH
79317: LD_EXP 65
79321: PUSH
79322: LD_VAR 0 3
79326: ARRAY
79327: IN
79328: IFFALSE 79367
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79330: LD_ADDR_EXP 65
79334: PUSH
79335: LD_EXP 65
79339: PPUSH
79340: LD_VAR 0 3
79344: PPUSH
79345: LD_EXP 65
79349: PUSH
79350: LD_VAR 0 3
79354: ARRAY
79355: PUSH
79356: LD_VAR 0 1
79360: DIFF
79361: PPUSH
79362: CALL_OW 1
79366: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79367: LD_ADDR_VAR 0 8
79371: PUSH
79372: LD_VAR 0 3
79376: PPUSH
79377: LD_INT 3
79379: PPUSH
79380: CALL 75988 0 2
79384: ST_TO_ADDR
// if fac then
79385: LD_VAR 0 8
79389: IFFALSE 79618
// begin for j in fac do
79391: LD_ADDR_VAR 0 4
79395: PUSH
79396: LD_VAR 0 8
79400: PUSH
79401: FOR_IN
79402: IFFALSE 79616
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79404: LD_ADDR_VAR 0 9
79408: PUSH
79409: LD_VAR 0 8
79413: PPUSH
79414: LD_VAR 0 1
79418: PPUSH
79419: CALL_OW 265
79423: PPUSH
79424: LD_VAR 0 1
79428: PPUSH
79429: CALL_OW 262
79433: PPUSH
79434: LD_VAR 0 1
79438: PPUSH
79439: CALL_OW 263
79443: PPUSH
79444: LD_VAR 0 1
79448: PPUSH
79449: CALL_OW 264
79453: PPUSH
79454: CALL 12415 0 5
79458: ST_TO_ADDR
// if components then
79459: LD_VAR 0 9
79463: IFFALSE 79614
// begin if GetWeapon ( un ) = ar_control_tower then
79465: LD_VAR 0 1
79469: PPUSH
79470: CALL_OW 264
79474: PUSH
79475: LD_INT 31
79477: EQUAL
79478: IFFALSE 79595
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79480: LD_VAR 0 1
79484: PPUSH
79485: CALL_OW 311
79489: PPUSH
79490: LD_INT 0
79492: PPUSH
79493: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79497: LD_ADDR_EXP 83
79501: PUSH
79502: LD_EXP 83
79506: PPUSH
79507: LD_VAR 0 3
79511: PPUSH
79512: LD_EXP 83
79516: PUSH
79517: LD_VAR 0 3
79521: ARRAY
79522: PUSH
79523: LD_VAR 0 1
79527: PPUSH
79528: CALL_OW 311
79532: DIFF
79533: PPUSH
79534: CALL_OW 1
79538: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79539: LD_ADDR_VAR 0 7
79543: PUSH
79544: LD_EXP 64
79548: PUSH
79549: LD_VAR 0 3
79553: ARRAY
79554: PPUSH
79555: LD_INT 1
79557: PPUSH
79558: LD_VAR 0 9
79562: PPUSH
79563: CALL_OW 2
79567: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79568: LD_ADDR_EXP 64
79572: PUSH
79573: LD_EXP 64
79577: PPUSH
79578: LD_VAR 0 3
79582: PPUSH
79583: LD_VAR 0 7
79587: PPUSH
79588: CALL_OW 1
79592: ST_TO_ADDR
// end else
79593: GO 79612
// MC_InsertProduceList ( i , [ components ] ) ;
79595: LD_VAR 0 3
79599: PPUSH
79600: LD_VAR 0 9
79604: PUSH
79605: EMPTY
79606: LIST
79607: PPUSH
79608: CALL 75533 0 2
// break ;
79612: GO 79616
// end ; end ;
79614: GO 79401
79616: POP
79617: POP
// end ; end ; if GetType ( un ) = unit_building then
79618: LD_VAR 0 1
79622: PPUSH
79623: CALL_OW 247
79627: PUSH
79628: LD_INT 3
79630: EQUAL
79631: IFFALSE 80034
// begin btype := GetBType ( un ) ;
79633: LD_ADDR_VAR 0 5
79637: PUSH
79638: LD_VAR 0 1
79642: PPUSH
79643: CALL_OW 266
79647: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79648: LD_VAR 0 5
79652: PUSH
79653: LD_INT 29
79655: PUSH
79656: LD_INT 30
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: IN
79663: IFFALSE 79736
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79665: LD_VAR 0 1
79669: PPUSH
79670: CALL_OW 250
79674: PPUSH
79675: LD_VAR 0 1
79679: PPUSH
79680: CALL_OW 251
79684: PPUSH
79685: LD_VAR 0 1
79689: PPUSH
79690: CALL_OW 255
79694: PPUSH
79695: CALL_OW 440
79699: NOT
79700: IFFALSE 79736
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79702: LD_VAR 0 1
79706: PPUSH
79707: CALL_OW 250
79711: PPUSH
79712: LD_VAR 0 1
79716: PPUSH
79717: CALL_OW 251
79721: PPUSH
79722: LD_VAR 0 1
79726: PPUSH
79727: CALL_OW 255
79731: PPUSH
79732: CALL_OW 441
// end ; if btype = b_warehouse then
79736: LD_VAR 0 5
79740: PUSH
79741: LD_INT 1
79743: EQUAL
79744: IFFALSE 79762
// begin btype := b_depot ;
79746: LD_ADDR_VAR 0 5
79750: PUSH
79751: LD_INT 0
79753: ST_TO_ADDR
// pos := 1 ;
79754: LD_ADDR_VAR 0 6
79758: PUSH
79759: LD_INT 1
79761: ST_TO_ADDR
// end ; if btype = b_factory then
79762: LD_VAR 0 5
79766: PUSH
79767: LD_INT 3
79769: EQUAL
79770: IFFALSE 79788
// begin btype := b_workshop ;
79772: LD_ADDR_VAR 0 5
79776: PUSH
79777: LD_INT 2
79779: ST_TO_ADDR
// pos := 1 ;
79780: LD_ADDR_VAR 0 6
79784: PUSH
79785: LD_INT 1
79787: ST_TO_ADDR
// end ; if btype = b_barracks then
79788: LD_VAR 0 5
79792: PUSH
79793: LD_INT 5
79795: EQUAL
79796: IFFALSE 79806
// btype := b_armoury ;
79798: LD_ADDR_VAR 0 5
79802: PUSH
79803: LD_INT 4
79805: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79806: LD_VAR 0 5
79810: PUSH
79811: LD_INT 7
79813: PUSH
79814: LD_INT 8
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: IN
79821: IFFALSE 79831
// btype := b_lab ;
79823: LD_ADDR_VAR 0 5
79827: PUSH
79828: LD_INT 6
79830: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79831: LD_ADDR_EXP 48
79835: PUSH
79836: LD_EXP 48
79840: PPUSH
79841: LD_VAR 0 3
79845: PUSH
79846: LD_EXP 48
79850: PUSH
79851: LD_VAR 0 3
79855: ARRAY
79856: PUSH
79857: LD_INT 1
79859: PLUS
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PPUSH
79865: LD_VAR 0 5
79869: PUSH
79870: LD_VAR 0 1
79874: PPUSH
79875: CALL_OW 250
79879: PUSH
79880: LD_VAR 0 1
79884: PPUSH
79885: CALL_OW 251
79889: PUSH
79890: LD_VAR 0 1
79894: PPUSH
79895: CALL_OW 254
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: PPUSH
79906: CALL 14917 0 3
79910: ST_TO_ADDR
// if pos = 1 then
79911: LD_VAR 0 6
79915: PUSH
79916: LD_INT 1
79918: EQUAL
79919: IFFALSE 80034
// begin tmp := mc_build_list [ i ] ;
79921: LD_ADDR_VAR 0 7
79925: PUSH
79926: LD_EXP 48
79930: PUSH
79931: LD_VAR 0 3
79935: ARRAY
79936: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79937: LD_VAR 0 7
79941: PPUSH
79942: LD_INT 2
79944: PUSH
79945: LD_INT 30
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 30
79957: PUSH
79958: LD_INT 1
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: LIST
79969: PPUSH
79970: CALL_OW 72
79974: IFFALSE 79984
// pos := 2 ;
79976: LD_ADDR_VAR 0 6
79980: PUSH
79981: LD_INT 2
79983: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79984: LD_ADDR_VAR 0 7
79988: PUSH
79989: LD_VAR 0 7
79993: PPUSH
79994: LD_VAR 0 6
79998: PPUSH
79999: LD_VAR 0 7
80003: PPUSH
80004: CALL 15243 0 3
80008: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80009: LD_ADDR_EXP 48
80013: PUSH
80014: LD_EXP 48
80018: PPUSH
80019: LD_VAR 0 3
80023: PPUSH
80024: LD_VAR 0 7
80028: PPUSH
80029: CALL_OW 1
80033: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80034: LD_VAR 0 1
80038: PUSH
80039: LD_EXP 43
80043: PUSH
80044: LD_VAR 0 3
80048: ARRAY
80049: IN
80050: IFFALSE 80089
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80052: LD_ADDR_EXP 43
80056: PUSH
80057: LD_EXP 43
80061: PPUSH
80062: LD_VAR 0 3
80066: PPUSH
80067: LD_EXP 43
80071: PUSH
80072: LD_VAR 0 3
80076: ARRAY
80077: PUSH
80078: LD_VAR 0 1
80082: DIFF
80083: PPUSH
80084: CALL_OW 1
80088: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80089: LD_VAR 0 1
80093: PUSH
80094: LD_EXP 50
80098: PUSH
80099: LD_VAR 0 3
80103: ARRAY
80104: IN
80105: IFFALSE 80144
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80107: LD_ADDR_EXP 50
80111: PUSH
80112: LD_EXP 50
80116: PPUSH
80117: LD_VAR 0 3
80121: PPUSH
80122: LD_EXP 50
80126: PUSH
80127: LD_VAR 0 3
80131: ARRAY
80132: PUSH
80133: LD_VAR 0 1
80137: DIFF
80138: PPUSH
80139: CALL_OW 1
80143: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80144: LD_VAR 0 1
80148: PUSH
80149: LD_EXP 62
80153: PUSH
80154: LD_VAR 0 3
80158: ARRAY
80159: IN
80160: IFFALSE 80199
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80162: LD_ADDR_EXP 62
80166: PUSH
80167: LD_EXP 62
80171: PPUSH
80172: LD_VAR 0 3
80176: PPUSH
80177: LD_EXP 62
80181: PUSH
80182: LD_VAR 0 3
80186: ARRAY
80187: PUSH
80188: LD_VAR 0 1
80192: DIFF
80193: PPUSH
80194: CALL_OW 1
80198: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80199: LD_VAR 0 1
80203: PUSH
80204: LD_EXP 65
80208: PUSH
80209: LD_VAR 0 3
80213: ARRAY
80214: IN
80215: IFFALSE 80254
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80217: LD_ADDR_EXP 65
80221: PUSH
80222: LD_EXP 65
80226: PPUSH
80227: LD_VAR 0 3
80231: PPUSH
80232: LD_EXP 65
80236: PUSH
80237: LD_VAR 0 3
80241: ARRAY
80242: PUSH
80243: LD_VAR 0 1
80247: DIFF
80248: PPUSH
80249: CALL_OW 1
80253: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80254: LD_VAR 0 1
80258: PUSH
80259: LD_EXP 52
80263: PUSH
80264: LD_VAR 0 3
80268: ARRAY
80269: IN
80270: IFFALSE 80309
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80272: LD_ADDR_EXP 52
80276: PUSH
80277: LD_EXP 52
80281: PPUSH
80282: LD_VAR 0 3
80286: PPUSH
80287: LD_EXP 52
80291: PUSH
80292: LD_VAR 0 3
80296: ARRAY
80297: PUSH
80298: LD_VAR 0 1
80302: DIFF
80303: PPUSH
80304: CALL_OW 1
80308: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80309: LD_VAR 0 1
80313: PUSH
80314: LD_EXP 51
80318: PUSH
80319: LD_VAR 0 3
80323: ARRAY
80324: IN
80325: IFFALSE 80364
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80327: LD_ADDR_EXP 51
80331: PUSH
80332: LD_EXP 51
80336: PPUSH
80337: LD_VAR 0 3
80341: PPUSH
80342: LD_EXP 51
80346: PUSH
80347: LD_VAR 0 3
80351: ARRAY
80352: PUSH
80353: LD_VAR 0 1
80357: DIFF
80358: PPUSH
80359: CALL_OW 1
80363: ST_TO_ADDR
// end ; break ;
80364: GO 80368
// end ;
80366: GO 79016
80368: POP
80369: POP
// end ;
80370: LD_VAR 0 2
80374: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80375: LD_INT 0
80377: PPUSH
80378: PPUSH
80379: PPUSH
// if not mc_bases or not skirmish then
80380: LD_EXP 43
80384: NOT
80385: PUSH
80386: LD_EXP 41
80390: NOT
80391: OR
80392: IFFALSE 80396
// exit ;
80394: GO 80611
// for i = 1 to mc_bases do
80396: LD_ADDR_VAR 0 3
80400: PUSH
80401: DOUBLE
80402: LD_INT 1
80404: DEC
80405: ST_TO_ADDR
80406: LD_EXP 43
80410: PUSH
80411: FOR_TO
80412: IFFALSE 80609
// begin if building in mc_construct_list [ i ] then
80414: LD_VAR 0 1
80418: PUSH
80419: LD_EXP 50
80423: PUSH
80424: LD_VAR 0 3
80428: ARRAY
80429: IN
80430: IFFALSE 80607
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80432: LD_ADDR_EXP 50
80436: PUSH
80437: LD_EXP 50
80441: PPUSH
80442: LD_VAR 0 3
80446: PPUSH
80447: LD_EXP 50
80451: PUSH
80452: LD_VAR 0 3
80456: ARRAY
80457: PUSH
80458: LD_VAR 0 1
80462: DIFF
80463: PPUSH
80464: CALL_OW 1
80468: ST_TO_ADDR
// if building in mc_lab [ i ] then
80469: LD_VAR 0 1
80473: PUSH
80474: LD_EXP 76
80478: PUSH
80479: LD_VAR 0 3
80483: ARRAY
80484: IN
80485: IFFALSE 80540
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80487: LD_ADDR_EXP 77
80491: PUSH
80492: LD_EXP 77
80496: PPUSH
80497: LD_VAR 0 3
80501: PPUSH
80502: LD_EXP 77
80506: PUSH
80507: LD_VAR 0 3
80511: ARRAY
80512: PPUSH
80513: LD_INT 1
80515: PPUSH
80516: LD_EXP 77
80520: PUSH
80521: LD_VAR 0 3
80525: ARRAY
80526: PPUSH
80527: LD_INT 0
80529: PPUSH
80530: CALL 14335 0 4
80534: PPUSH
80535: CALL_OW 1
80539: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80540: LD_VAR 0 1
80544: PUSH
80545: LD_EXP 43
80549: PUSH
80550: LD_VAR 0 3
80554: ARRAY
80555: IN
80556: NOT
80557: IFFALSE 80603
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80559: LD_ADDR_EXP 43
80563: PUSH
80564: LD_EXP 43
80568: PPUSH
80569: LD_VAR 0 3
80573: PUSH
80574: LD_EXP 43
80578: PUSH
80579: LD_VAR 0 3
80583: ARRAY
80584: PUSH
80585: LD_INT 1
80587: PLUS
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PPUSH
80593: LD_VAR 0 1
80597: PPUSH
80598: CALL 14917 0 3
80602: ST_TO_ADDR
// exit ;
80603: POP
80604: POP
80605: GO 80611
// end ; end ;
80607: GO 80411
80609: POP
80610: POP
// end ;
80611: LD_VAR 0 2
80615: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80616: LD_INT 0
80618: PPUSH
80619: PPUSH
80620: PPUSH
80621: PPUSH
80622: PPUSH
80623: PPUSH
80624: PPUSH
// if not mc_bases or not skirmish then
80625: LD_EXP 43
80629: NOT
80630: PUSH
80631: LD_EXP 41
80635: NOT
80636: OR
80637: IFFALSE 80641
// exit ;
80639: GO 81302
// for i = 1 to mc_bases do
80641: LD_ADDR_VAR 0 3
80645: PUSH
80646: DOUBLE
80647: LD_INT 1
80649: DEC
80650: ST_TO_ADDR
80651: LD_EXP 43
80655: PUSH
80656: FOR_TO
80657: IFFALSE 81300
// begin if building in mc_construct_list [ i ] then
80659: LD_VAR 0 1
80663: PUSH
80664: LD_EXP 50
80668: PUSH
80669: LD_VAR 0 3
80673: ARRAY
80674: IN
80675: IFFALSE 81298
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80677: LD_ADDR_EXP 50
80681: PUSH
80682: LD_EXP 50
80686: PPUSH
80687: LD_VAR 0 3
80691: PPUSH
80692: LD_EXP 50
80696: PUSH
80697: LD_VAR 0 3
80701: ARRAY
80702: PUSH
80703: LD_VAR 0 1
80707: DIFF
80708: PPUSH
80709: CALL_OW 1
80713: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80714: LD_ADDR_EXP 43
80718: PUSH
80719: LD_EXP 43
80723: PPUSH
80724: LD_VAR 0 3
80728: PUSH
80729: LD_EXP 43
80733: PUSH
80734: LD_VAR 0 3
80738: ARRAY
80739: PUSH
80740: LD_INT 1
80742: PLUS
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PPUSH
80748: LD_VAR 0 1
80752: PPUSH
80753: CALL 14917 0 3
80757: ST_TO_ADDR
// btype := GetBType ( building ) ;
80758: LD_ADDR_VAR 0 5
80762: PUSH
80763: LD_VAR 0 1
80767: PPUSH
80768: CALL_OW 266
80772: ST_TO_ADDR
// side := GetSide ( building ) ;
80773: LD_ADDR_VAR 0 8
80777: PUSH
80778: LD_VAR 0 1
80782: PPUSH
80783: CALL_OW 255
80787: ST_TO_ADDR
// if btype = b_lab then
80788: LD_VAR 0 5
80792: PUSH
80793: LD_INT 6
80795: EQUAL
80796: IFFALSE 80846
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80798: LD_ADDR_EXP 76
80802: PUSH
80803: LD_EXP 76
80807: PPUSH
80808: LD_VAR 0 3
80812: PUSH
80813: LD_EXP 76
80817: PUSH
80818: LD_VAR 0 3
80822: ARRAY
80823: PUSH
80824: LD_INT 1
80826: PLUS
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PPUSH
80832: LD_VAR 0 1
80836: PPUSH
80837: CALL 14917 0 3
80841: ST_TO_ADDR
// exit ;
80842: POP
80843: POP
80844: GO 81302
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80846: LD_VAR 0 5
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: LD_INT 2
80856: PUSH
80857: LD_INT 4
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: LIST
80864: IN
80865: IFFALSE 80989
// begin if btype = b_armoury then
80867: LD_VAR 0 5
80871: PUSH
80872: LD_INT 4
80874: EQUAL
80875: IFFALSE 80885
// btype := b_barracks ;
80877: LD_ADDR_VAR 0 5
80881: PUSH
80882: LD_INT 5
80884: ST_TO_ADDR
// if btype = b_depot then
80885: LD_VAR 0 5
80889: PUSH
80890: LD_INT 0
80892: EQUAL
80893: IFFALSE 80903
// btype := b_warehouse ;
80895: LD_ADDR_VAR 0 5
80899: PUSH
80900: LD_INT 1
80902: ST_TO_ADDR
// if btype = b_workshop then
80903: LD_VAR 0 5
80907: PUSH
80908: LD_INT 2
80910: EQUAL
80911: IFFALSE 80921
// btype := b_factory ;
80913: LD_ADDR_VAR 0 5
80917: PUSH
80918: LD_INT 3
80920: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80921: LD_VAR 0 5
80925: PPUSH
80926: LD_VAR 0 8
80930: PPUSH
80931: CALL_OW 323
80935: PUSH
80936: LD_INT 1
80938: EQUAL
80939: IFFALSE 80985
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80941: LD_ADDR_EXP 75
80945: PUSH
80946: LD_EXP 75
80950: PPUSH
80951: LD_VAR 0 3
80955: PUSH
80956: LD_EXP 75
80960: PUSH
80961: LD_VAR 0 3
80965: ARRAY
80966: PUSH
80967: LD_INT 1
80969: PLUS
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PPUSH
80975: LD_VAR 0 1
80979: PPUSH
80980: CALL 14917 0 3
80984: ST_TO_ADDR
// exit ;
80985: POP
80986: POP
80987: GO 81302
// end ; if btype in [ b_bunker , b_turret ] then
80989: LD_VAR 0 5
80993: PUSH
80994: LD_INT 32
80996: PUSH
80997: LD_INT 33
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: IN
81004: IFFALSE 81294
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81006: LD_ADDR_EXP 51
81010: PUSH
81011: LD_EXP 51
81015: PPUSH
81016: LD_VAR 0 3
81020: PUSH
81021: LD_EXP 51
81025: PUSH
81026: LD_VAR 0 3
81030: ARRAY
81031: PUSH
81032: LD_INT 1
81034: PLUS
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PPUSH
81040: LD_VAR 0 1
81044: PPUSH
81045: CALL 14917 0 3
81049: ST_TO_ADDR
// if btype = b_bunker then
81050: LD_VAR 0 5
81054: PUSH
81055: LD_INT 32
81057: EQUAL
81058: IFFALSE 81294
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81060: LD_ADDR_EXP 52
81064: PUSH
81065: LD_EXP 52
81069: PPUSH
81070: LD_VAR 0 3
81074: PUSH
81075: LD_EXP 52
81079: PUSH
81080: LD_VAR 0 3
81084: ARRAY
81085: PUSH
81086: LD_INT 1
81088: PLUS
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PPUSH
81094: LD_VAR 0 1
81098: PPUSH
81099: CALL 14917 0 3
81103: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81104: LD_ADDR_VAR 0 6
81108: PUSH
81109: LD_EXP 43
81113: PUSH
81114: LD_VAR 0 3
81118: ARRAY
81119: PPUSH
81120: LD_INT 25
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 3
81132: PUSH
81133: LD_INT 54
81135: PUSH
81136: EMPTY
81137: LIST
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PPUSH
81147: CALL_OW 72
81151: ST_TO_ADDR
// if tmp then
81152: LD_VAR 0 6
81156: IFFALSE 81162
// exit ;
81158: POP
81159: POP
81160: GO 81302
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81162: LD_ADDR_VAR 0 6
81166: PUSH
81167: LD_EXP 43
81171: PUSH
81172: LD_VAR 0 3
81176: ARRAY
81177: PPUSH
81178: LD_INT 2
81180: PUSH
81181: LD_INT 30
81183: PUSH
81184: LD_INT 4
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 30
81193: PUSH
81194: LD_INT 5
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: LIST
81205: PPUSH
81206: CALL_OW 72
81210: ST_TO_ADDR
// if not tmp then
81211: LD_VAR 0 6
81215: NOT
81216: IFFALSE 81222
// exit ;
81218: POP
81219: POP
81220: GO 81302
// for j in tmp do
81222: LD_ADDR_VAR 0 4
81226: PUSH
81227: LD_VAR 0 6
81231: PUSH
81232: FOR_IN
81233: IFFALSE 81292
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81235: LD_ADDR_VAR 0 7
81239: PUSH
81240: LD_VAR 0 4
81244: PPUSH
81245: CALL_OW 313
81249: PPUSH
81250: LD_INT 25
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PPUSH
81260: CALL_OW 72
81264: ST_TO_ADDR
// if units then
81265: LD_VAR 0 7
81269: IFFALSE 81290
// begin ComExitBuilding ( units [ 1 ] ) ;
81271: LD_VAR 0 7
81275: PUSH
81276: LD_INT 1
81278: ARRAY
81279: PPUSH
81280: CALL_OW 122
// exit ;
81284: POP
81285: POP
81286: POP
81287: POP
81288: GO 81302
// end ; end ;
81290: GO 81232
81292: POP
81293: POP
// end ; end ; exit ;
81294: POP
81295: POP
81296: GO 81302
// end ; end ;
81298: GO 80656
81300: POP
81301: POP
// end ;
81302: LD_VAR 0 2
81306: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81307: LD_INT 0
81309: PPUSH
81310: PPUSH
81311: PPUSH
81312: PPUSH
81313: PPUSH
81314: PPUSH
81315: PPUSH
// if not mc_bases or not skirmish then
81316: LD_EXP 43
81320: NOT
81321: PUSH
81322: LD_EXP 41
81326: NOT
81327: OR
81328: IFFALSE 81332
// exit ;
81330: GO 81597
// btype := GetBType ( building ) ;
81332: LD_ADDR_VAR 0 6
81336: PUSH
81337: LD_VAR 0 1
81341: PPUSH
81342: CALL_OW 266
81346: ST_TO_ADDR
// x := GetX ( building ) ;
81347: LD_ADDR_VAR 0 7
81351: PUSH
81352: LD_VAR 0 1
81356: PPUSH
81357: CALL_OW 250
81361: ST_TO_ADDR
// y := GetY ( building ) ;
81362: LD_ADDR_VAR 0 8
81366: PUSH
81367: LD_VAR 0 1
81371: PPUSH
81372: CALL_OW 251
81376: ST_TO_ADDR
// d := GetDir ( building ) ;
81377: LD_ADDR_VAR 0 9
81381: PUSH
81382: LD_VAR 0 1
81386: PPUSH
81387: CALL_OW 254
81391: ST_TO_ADDR
// for i = 1 to mc_bases do
81392: LD_ADDR_VAR 0 4
81396: PUSH
81397: DOUBLE
81398: LD_INT 1
81400: DEC
81401: ST_TO_ADDR
81402: LD_EXP 43
81406: PUSH
81407: FOR_TO
81408: IFFALSE 81595
// begin if not mc_build_list [ i ] then
81410: LD_EXP 48
81414: PUSH
81415: LD_VAR 0 4
81419: ARRAY
81420: NOT
81421: IFFALSE 81425
// continue ;
81423: GO 81407
// for j := 1 to mc_build_list [ i ] do
81425: LD_ADDR_VAR 0 5
81429: PUSH
81430: DOUBLE
81431: LD_INT 1
81433: DEC
81434: ST_TO_ADDR
81435: LD_EXP 48
81439: PUSH
81440: LD_VAR 0 4
81444: ARRAY
81445: PUSH
81446: FOR_TO
81447: IFFALSE 81591
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81449: LD_VAR 0 6
81453: PUSH
81454: LD_VAR 0 7
81458: PUSH
81459: LD_VAR 0 8
81463: PUSH
81464: LD_VAR 0 9
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: PPUSH
81475: LD_EXP 48
81479: PUSH
81480: LD_VAR 0 4
81484: ARRAY
81485: PUSH
81486: LD_VAR 0 5
81490: ARRAY
81491: PPUSH
81492: CALL 21097 0 2
81496: IFFALSE 81589
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81498: LD_ADDR_EXP 48
81502: PUSH
81503: LD_EXP 48
81507: PPUSH
81508: LD_VAR 0 4
81512: PPUSH
81513: LD_EXP 48
81517: PUSH
81518: LD_VAR 0 4
81522: ARRAY
81523: PPUSH
81524: LD_VAR 0 5
81528: PPUSH
81529: CALL_OW 3
81533: PPUSH
81534: CALL_OW 1
81538: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81539: LD_ADDR_EXP 50
81543: PUSH
81544: LD_EXP 50
81548: PPUSH
81549: LD_VAR 0 4
81553: PUSH
81554: LD_EXP 50
81558: PUSH
81559: LD_VAR 0 4
81563: ARRAY
81564: PUSH
81565: LD_INT 1
81567: PLUS
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PPUSH
81573: LD_VAR 0 1
81577: PPUSH
81578: CALL 14917 0 3
81582: ST_TO_ADDR
// exit ;
81583: POP
81584: POP
81585: POP
81586: POP
81587: GO 81597
// end ;
81589: GO 81446
81591: POP
81592: POP
// end ;
81593: GO 81407
81595: POP
81596: POP
// end ;
81597: LD_VAR 0 3
81601: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81602: LD_INT 0
81604: PPUSH
81605: PPUSH
81606: PPUSH
// if not mc_bases or not skirmish then
81607: LD_EXP 43
81611: NOT
81612: PUSH
81613: LD_EXP 41
81617: NOT
81618: OR
81619: IFFALSE 81623
// exit ;
81621: GO 81813
// for i = 1 to mc_bases do
81623: LD_ADDR_VAR 0 4
81627: PUSH
81628: DOUBLE
81629: LD_INT 1
81631: DEC
81632: ST_TO_ADDR
81633: LD_EXP 43
81637: PUSH
81638: FOR_TO
81639: IFFALSE 81726
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81641: LD_VAR 0 1
81645: PUSH
81646: LD_EXP 51
81650: PUSH
81651: LD_VAR 0 4
81655: ARRAY
81656: IN
81657: PUSH
81658: LD_VAR 0 1
81662: PUSH
81663: LD_EXP 52
81667: PUSH
81668: LD_VAR 0 4
81672: ARRAY
81673: IN
81674: NOT
81675: AND
81676: IFFALSE 81724
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81678: LD_ADDR_EXP 52
81682: PUSH
81683: LD_EXP 52
81687: PPUSH
81688: LD_VAR 0 4
81692: PUSH
81693: LD_EXP 52
81697: PUSH
81698: LD_VAR 0 4
81702: ARRAY
81703: PUSH
81704: LD_INT 1
81706: PLUS
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PPUSH
81712: LD_VAR 0 1
81716: PPUSH
81717: CALL 14917 0 3
81721: ST_TO_ADDR
// break ;
81722: GO 81726
// end ; end ;
81724: GO 81638
81726: POP
81727: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81728: LD_VAR 0 1
81732: PPUSH
81733: CALL_OW 257
81737: PUSH
81738: LD_EXP 69
81742: IN
81743: PUSH
81744: LD_VAR 0 1
81748: PPUSH
81749: CALL_OW 266
81753: PUSH
81754: LD_INT 5
81756: EQUAL
81757: AND
81758: PUSH
81759: LD_VAR 0 2
81763: PPUSH
81764: CALL_OW 110
81768: PUSH
81769: LD_INT 18
81771: NONEQUAL
81772: AND
81773: IFFALSE 81813
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81775: LD_VAR 0 2
81779: PPUSH
81780: CALL_OW 257
81784: PUSH
81785: LD_INT 5
81787: PUSH
81788: LD_INT 8
81790: PUSH
81791: LD_INT 9
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: IN
81799: IFFALSE 81813
// SetClass ( unit , 1 ) ;
81801: LD_VAR 0 2
81805: PPUSH
81806: LD_INT 1
81808: PPUSH
81809: CALL_OW 336
// end ;
81813: LD_VAR 0 3
81817: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81818: LD_INT 0
81820: PPUSH
81821: PPUSH
// if not mc_bases or not skirmish then
81822: LD_EXP 43
81826: NOT
81827: PUSH
81828: LD_EXP 41
81832: NOT
81833: OR
81834: IFFALSE 81838
// exit ;
81836: GO 81954
// if GetLives ( abandoned_vehicle ) > 250 then
81838: LD_VAR 0 2
81842: PPUSH
81843: CALL_OW 256
81847: PUSH
81848: LD_INT 250
81850: GREATER
81851: IFFALSE 81855
// exit ;
81853: GO 81954
// for i = 1 to mc_bases do
81855: LD_ADDR_VAR 0 6
81859: PUSH
81860: DOUBLE
81861: LD_INT 1
81863: DEC
81864: ST_TO_ADDR
81865: LD_EXP 43
81869: PUSH
81870: FOR_TO
81871: IFFALSE 81952
// begin if driver in mc_bases [ i ] then
81873: LD_VAR 0 1
81877: PUSH
81878: LD_EXP 43
81882: PUSH
81883: LD_VAR 0 6
81887: ARRAY
81888: IN
81889: IFFALSE 81950
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81891: LD_VAR 0 1
81895: PPUSH
81896: LD_EXP 43
81900: PUSH
81901: LD_VAR 0 6
81905: ARRAY
81906: PPUSH
81907: LD_INT 2
81909: PUSH
81910: LD_INT 30
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 30
81922: PUSH
81923: LD_INT 1
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: LIST
81934: PPUSH
81935: CALL_OW 72
81939: PUSH
81940: LD_INT 1
81942: ARRAY
81943: PPUSH
81944: CALL 48124 0 2
// break ;
81948: GO 81952
// end ; end ;
81950: GO 81870
81952: POP
81953: POP
// end ; end_of_file
81954: LD_VAR 0 5
81958: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81959: LD_INT 0
81961: PPUSH
81962: PPUSH
81963: PPUSH
81964: PPUSH
81965: PPUSH
81966: PPUSH
81967: PPUSH
81968: PPUSH
81969: PPUSH
81970: PPUSH
81971: PPUSH
81972: PPUSH
81973: PPUSH
81974: PPUSH
81975: PPUSH
81976: PPUSH
81977: PPUSH
81978: PPUSH
81979: PPUSH
81980: PPUSH
81981: PPUSH
81982: PPUSH
81983: PPUSH
81984: PPUSH
81985: PPUSH
81986: PPUSH
81987: PPUSH
81988: PPUSH
81989: PPUSH
81990: PPUSH
81991: PPUSH
81992: PPUSH
81993: PPUSH
81994: PPUSH
// if not list then
81995: LD_VAR 0 1
81999: NOT
82000: IFFALSE 82004
// exit ;
82002: GO 86663
// base := list [ 1 ] ;
82004: LD_ADDR_VAR 0 3
82008: PUSH
82009: LD_VAR 0 1
82013: PUSH
82014: LD_INT 1
82016: ARRAY
82017: ST_TO_ADDR
// group := list [ 2 ] ;
82018: LD_ADDR_VAR 0 4
82022: PUSH
82023: LD_VAR 0 1
82027: PUSH
82028: LD_INT 2
82030: ARRAY
82031: ST_TO_ADDR
// path := list [ 3 ] ;
82032: LD_ADDR_VAR 0 5
82036: PUSH
82037: LD_VAR 0 1
82041: PUSH
82042: LD_INT 3
82044: ARRAY
82045: ST_TO_ADDR
// flags := list [ 4 ] ;
82046: LD_ADDR_VAR 0 6
82050: PUSH
82051: LD_VAR 0 1
82055: PUSH
82056: LD_INT 4
82058: ARRAY
82059: ST_TO_ADDR
// mined := [ ] ;
82060: LD_ADDR_VAR 0 27
82064: PUSH
82065: EMPTY
82066: ST_TO_ADDR
// bombed := [ ] ;
82067: LD_ADDR_VAR 0 28
82071: PUSH
82072: EMPTY
82073: ST_TO_ADDR
// healers := [ ] ;
82074: LD_ADDR_VAR 0 31
82078: PUSH
82079: EMPTY
82080: ST_TO_ADDR
// to_heal := [ ] ;
82081: LD_ADDR_VAR 0 30
82085: PUSH
82086: EMPTY
82087: ST_TO_ADDR
// repairs := [ ] ;
82088: LD_ADDR_VAR 0 33
82092: PUSH
82093: EMPTY
82094: ST_TO_ADDR
// to_repair := [ ] ;
82095: LD_ADDR_VAR 0 32
82099: PUSH
82100: EMPTY
82101: ST_TO_ADDR
// if not group or not path then
82102: LD_VAR 0 4
82106: NOT
82107: PUSH
82108: LD_VAR 0 5
82112: NOT
82113: OR
82114: IFFALSE 82118
// exit ;
82116: GO 86663
// side := GetSide ( group [ 1 ] ) ;
82118: LD_ADDR_VAR 0 35
82122: PUSH
82123: LD_VAR 0 4
82127: PUSH
82128: LD_INT 1
82130: ARRAY
82131: PPUSH
82132: CALL_OW 255
82136: ST_TO_ADDR
// if flags then
82137: LD_VAR 0 6
82141: IFFALSE 82285
// begin f_ignore_area := flags [ 1 ] ;
82143: LD_ADDR_VAR 0 17
82147: PUSH
82148: LD_VAR 0 6
82152: PUSH
82153: LD_INT 1
82155: ARRAY
82156: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82157: LD_ADDR_VAR 0 18
82161: PUSH
82162: LD_VAR 0 6
82166: PUSH
82167: LD_INT 2
82169: ARRAY
82170: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82171: LD_ADDR_VAR 0 19
82175: PUSH
82176: LD_VAR 0 6
82180: PUSH
82181: LD_INT 3
82183: ARRAY
82184: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82185: LD_ADDR_VAR 0 20
82189: PUSH
82190: LD_VAR 0 6
82194: PUSH
82195: LD_INT 4
82197: ARRAY
82198: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82199: LD_ADDR_VAR 0 21
82203: PUSH
82204: LD_VAR 0 6
82208: PUSH
82209: LD_INT 5
82211: ARRAY
82212: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82213: LD_ADDR_VAR 0 22
82217: PUSH
82218: LD_VAR 0 6
82222: PUSH
82223: LD_INT 6
82225: ARRAY
82226: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82227: LD_ADDR_VAR 0 23
82231: PUSH
82232: LD_VAR 0 6
82236: PUSH
82237: LD_INT 7
82239: ARRAY
82240: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82241: LD_ADDR_VAR 0 24
82245: PUSH
82246: LD_VAR 0 6
82250: PUSH
82251: LD_INT 8
82253: ARRAY
82254: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82255: LD_ADDR_VAR 0 25
82259: PUSH
82260: LD_VAR 0 6
82264: PUSH
82265: LD_INT 9
82267: ARRAY
82268: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82269: LD_ADDR_VAR 0 26
82273: PUSH
82274: LD_VAR 0 6
82278: PUSH
82279: LD_INT 10
82281: ARRAY
82282: ST_TO_ADDR
// end else
82283: GO 82365
// begin f_ignore_area := false ;
82285: LD_ADDR_VAR 0 17
82289: PUSH
82290: LD_INT 0
82292: ST_TO_ADDR
// f_capture := false ;
82293: LD_ADDR_VAR 0 18
82297: PUSH
82298: LD_INT 0
82300: ST_TO_ADDR
// f_ignore_civ := false ;
82301: LD_ADDR_VAR 0 19
82305: PUSH
82306: LD_INT 0
82308: ST_TO_ADDR
// f_murder := false ;
82309: LD_ADDR_VAR 0 20
82313: PUSH
82314: LD_INT 0
82316: ST_TO_ADDR
// f_mines := false ;
82317: LD_ADDR_VAR 0 21
82321: PUSH
82322: LD_INT 0
82324: ST_TO_ADDR
// f_repair := false ;
82325: LD_ADDR_VAR 0 22
82329: PUSH
82330: LD_INT 0
82332: ST_TO_ADDR
// f_heal := false ;
82333: LD_ADDR_VAR 0 23
82337: PUSH
82338: LD_INT 0
82340: ST_TO_ADDR
// f_spacetime := false ;
82341: LD_ADDR_VAR 0 24
82345: PUSH
82346: LD_INT 0
82348: ST_TO_ADDR
// f_attack_depot := false ;
82349: LD_ADDR_VAR 0 25
82353: PUSH
82354: LD_INT 0
82356: ST_TO_ADDR
// f_crawl := false ;
82357: LD_ADDR_VAR 0 26
82361: PUSH
82362: LD_INT 0
82364: ST_TO_ADDR
// end ; if f_heal then
82365: LD_VAR 0 23
82369: IFFALSE 82396
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82371: LD_ADDR_VAR 0 31
82375: PUSH
82376: LD_VAR 0 4
82380: PPUSH
82381: LD_INT 25
82383: PUSH
82384: LD_INT 4
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PPUSH
82391: CALL_OW 72
82395: ST_TO_ADDR
// if f_repair then
82396: LD_VAR 0 22
82400: IFFALSE 82427
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82402: LD_ADDR_VAR 0 33
82406: PUSH
82407: LD_VAR 0 4
82411: PPUSH
82412: LD_INT 25
82414: PUSH
82415: LD_INT 3
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PPUSH
82422: CALL_OW 72
82426: ST_TO_ADDR
// units_path := [ ] ;
82427: LD_ADDR_VAR 0 16
82431: PUSH
82432: EMPTY
82433: ST_TO_ADDR
// for i = 1 to group do
82434: LD_ADDR_VAR 0 7
82438: PUSH
82439: DOUBLE
82440: LD_INT 1
82442: DEC
82443: ST_TO_ADDR
82444: LD_VAR 0 4
82448: PUSH
82449: FOR_TO
82450: IFFALSE 82479
// units_path := Replace ( units_path , i , path ) ;
82452: LD_ADDR_VAR 0 16
82456: PUSH
82457: LD_VAR 0 16
82461: PPUSH
82462: LD_VAR 0 7
82466: PPUSH
82467: LD_VAR 0 5
82471: PPUSH
82472: CALL_OW 1
82476: ST_TO_ADDR
82477: GO 82449
82479: POP
82480: POP
// repeat for i = group downto 1 do
82481: LD_ADDR_VAR 0 7
82485: PUSH
82486: DOUBLE
82487: LD_VAR 0 4
82491: INC
82492: ST_TO_ADDR
82493: LD_INT 1
82495: PUSH
82496: FOR_DOWNTO
82497: IFFALSE 86619
// begin wait ( 5 ) ;
82499: LD_INT 5
82501: PPUSH
82502: CALL_OW 67
// tmp := [ ] ;
82506: LD_ADDR_VAR 0 14
82510: PUSH
82511: EMPTY
82512: ST_TO_ADDR
// attacking := false ;
82513: LD_ADDR_VAR 0 29
82517: PUSH
82518: LD_INT 0
82520: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82521: LD_VAR 0 4
82525: PUSH
82526: LD_VAR 0 7
82530: ARRAY
82531: PPUSH
82532: CALL_OW 301
82536: PUSH
82537: LD_VAR 0 4
82541: PUSH
82542: LD_VAR 0 7
82546: ARRAY
82547: NOT
82548: OR
82549: IFFALSE 82658
// begin if GetType ( group [ i ] ) = unit_human then
82551: LD_VAR 0 4
82555: PUSH
82556: LD_VAR 0 7
82560: ARRAY
82561: PPUSH
82562: CALL_OW 247
82566: PUSH
82567: LD_INT 1
82569: EQUAL
82570: IFFALSE 82616
// begin to_heal := to_heal diff group [ i ] ;
82572: LD_ADDR_VAR 0 30
82576: PUSH
82577: LD_VAR 0 30
82581: PUSH
82582: LD_VAR 0 4
82586: PUSH
82587: LD_VAR 0 7
82591: ARRAY
82592: DIFF
82593: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82594: LD_ADDR_VAR 0 31
82598: PUSH
82599: LD_VAR 0 31
82603: PUSH
82604: LD_VAR 0 4
82608: PUSH
82609: LD_VAR 0 7
82613: ARRAY
82614: DIFF
82615: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82616: LD_ADDR_VAR 0 4
82620: PUSH
82621: LD_VAR 0 4
82625: PPUSH
82626: LD_VAR 0 7
82630: PPUSH
82631: CALL_OW 3
82635: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82636: LD_ADDR_VAR 0 16
82640: PUSH
82641: LD_VAR 0 16
82645: PPUSH
82646: LD_VAR 0 7
82650: PPUSH
82651: CALL_OW 3
82655: ST_TO_ADDR
// continue ;
82656: GO 82496
// end ; if f_repair then
82658: LD_VAR 0 22
82662: IFFALSE 83151
// begin if GetType ( group [ i ] ) = unit_vehicle then
82664: LD_VAR 0 4
82668: PUSH
82669: LD_VAR 0 7
82673: ARRAY
82674: PPUSH
82675: CALL_OW 247
82679: PUSH
82680: LD_INT 2
82682: EQUAL
82683: IFFALSE 82873
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82685: LD_VAR 0 4
82689: PUSH
82690: LD_VAR 0 7
82694: ARRAY
82695: PPUSH
82696: CALL_OW 256
82700: PUSH
82701: LD_INT 700
82703: LESS
82704: PUSH
82705: LD_VAR 0 4
82709: PUSH
82710: LD_VAR 0 7
82714: ARRAY
82715: PUSH
82716: LD_VAR 0 32
82720: IN
82721: NOT
82722: AND
82723: IFFALSE 82747
// to_repair := to_repair union group [ i ] ;
82725: LD_ADDR_VAR 0 32
82729: PUSH
82730: LD_VAR 0 32
82734: PUSH
82735: LD_VAR 0 4
82739: PUSH
82740: LD_VAR 0 7
82744: ARRAY
82745: UNION
82746: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82747: LD_VAR 0 4
82751: PUSH
82752: LD_VAR 0 7
82756: ARRAY
82757: PPUSH
82758: CALL_OW 256
82762: PUSH
82763: LD_INT 1000
82765: EQUAL
82766: PUSH
82767: LD_VAR 0 4
82771: PUSH
82772: LD_VAR 0 7
82776: ARRAY
82777: PUSH
82778: LD_VAR 0 32
82782: IN
82783: AND
82784: IFFALSE 82808
// to_repair := to_repair diff group [ i ] ;
82786: LD_ADDR_VAR 0 32
82790: PUSH
82791: LD_VAR 0 32
82795: PUSH
82796: LD_VAR 0 4
82800: PUSH
82801: LD_VAR 0 7
82805: ARRAY
82806: DIFF
82807: ST_TO_ADDR
// if group [ i ] in to_repair then
82808: LD_VAR 0 4
82812: PUSH
82813: LD_VAR 0 7
82817: ARRAY
82818: PUSH
82819: LD_VAR 0 32
82823: IN
82824: IFFALSE 82871
// begin if not IsInArea ( group [ i ] , f_repair ) then
82826: LD_VAR 0 4
82830: PUSH
82831: LD_VAR 0 7
82835: ARRAY
82836: PPUSH
82837: LD_VAR 0 22
82841: PPUSH
82842: CALL_OW 308
82846: NOT
82847: IFFALSE 82869
// ComMoveToArea ( group [ i ] , f_repair ) ;
82849: LD_VAR 0 4
82853: PUSH
82854: LD_VAR 0 7
82858: ARRAY
82859: PPUSH
82860: LD_VAR 0 22
82864: PPUSH
82865: CALL_OW 113
// continue ;
82869: GO 82496
// end ; end else
82871: GO 83151
// if group [ i ] in repairs then
82873: LD_VAR 0 4
82877: PUSH
82878: LD_VAR 0 7
82882: ARRAY
82883: PUSH
82884: LD_VAR 0 33
82888: IN
82889: IFFALSE 83151
// begin if IsInUnit ( group [ i ] ) then
82891: LD_VAR 0 4
82895: PUSH
82896: LD_VAR 0 7
82900: ARRAY
82901: PPUSH
82902: CALL_OW 310
82906: IFFALSE 82974
// begin z := IsInUnit ( group [ i ] ) ;
82908: LD_ADDR_VAR 0 13
82912: PUSH
82913: LD_VAR 0 4
82917: PUSH
82918: LD_VAR 0 7
82922: ARRAY
82923: PPUSH
82924: CALL_OW 310
82928: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82929: LD_VAR 0 13
82933: PUSH
82934: LD_VAR 0 32
82938: IN
82939: PUSH
82940: LD_VAR 0 13
82944: PPUSH
82945: LD_VAR 0 22
82949: PPUSH
82950: CALL_OW 308
82954: AND
82955: IFFALSE 82972
// ComExitVehicle ( group [ i ] ) ;
82957: LD_VAR 0 4
82961: PUSH
82962: LD_VAR 0 7
82966: ARRAY
82967: PPUSH
82968: CALL_OW 121
// end else
82972: GO 83151
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82974: LD_ADDR_VAR 0 13
82978: PUSH
82979: LD_VAR 0 4
82983: PPUSH
82984: LD_INT 95
82986: PUSH
82987: LD_VAR 0 22
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 58
82998: PUSH
82999: EMPTY
83000: LIST
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PPUSH
83006: CALL_OW 72
83010: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83011: LD_VAR 0 4
83015: PUSH
83016: LD_VAR 0 7
83020: ARRAY
83021: PPUSH
83022: CALL_OW 314
83026: NOT
83027: IFFALSE 83149
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83029: LD_ADDR_VAR 0 10
83033: PUSH
83034: LD_VAR 0 13
83038: PPUSH
83039: LD_VAR 0 4
83043: PUSH
83044: LD_VAR 0 7
83048: ARRAY
83049: PPUSH
83050: CALL_OW 74
83054: ST_TO_ADDR
// if not x then
83055: LD_VAR 0 10
83059: NOT
83060: IFFALSE 83064
// continue ;
83062: GO 82496
// if GetLives ( x ) < 1000 then
83064: LD_VAR 0 10
83068: PPUSH
83069: CALL_OW 256
83073: PUSH
83074: LD_INT 1000
83076: LESS
83077: IFFALSE 83101
// ComRepairVehicle ( group [ i ] , x ) else
83079: LD_VAR 0 4
83083: PUSH
83084: LD_VAR 0 7
83088: ARRAY
83089: PPUSH
83090: LD_VAR 0 10
83094: PPUSH
83095: CALL_OW 129
83099: GO 83149
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83101: LD_VAR 0 23
83105: PUSH
83106: LD_VAR 0 4
83110: PUSH
83111: LD_VAR 0 7
83115: ARRAY
83116: PPUSH
83117: CALL_OW 256
83121: PUSH
83122: LD_INT 1000
83124: LESS
83125: AND
83126: NOT
83127: IFFALSE 83149
// ComEnterUnit ( group [ i ] , x ) ;
83129: LD_VAR 0 4
83133: PUSH
83134: LD_VAR 0 7
83138: ARRAY
83139: PPUSH
83140: LD_VAR 0 10
83144: PPUSH
83145: CALL_OW 120
// end ; continue ;
83149: GO 82496
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83151: LD_VAR 0 23
83155: PUSH
83156: LD_VAR 0 4
83160: PUSH
83161: LD_VAR 0 7
83165: ARRAY
83166: PPUSH
83167: CALL_OW 247
83171: PUSH
83172: LD_INT 1
83174: EQUAL
83175: AND
83176: IFFALSE 83654
// begin if group [ i ] in healers then
83178: LD_VAR 0 4
83182: PUSH
83183: LD_VAR 0 7
83187: ARRAY
83188: PUSH
83189: LD_VAR 0 31
83193: IN
83194: IFFALSE 83467
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83196: LD_VAR 0 4
83200: PUSH
83201: LD_VAR 0 7
83205: ARRAY
83206: PPUSH
83207: LD_VAR 0 23
83211: PPUSH
83212: CALL_OW 308
83216: NOT
83217: PUSH
83218: LD_VAR 0 4
83222: PUSH
83223: LD_VAR 0 7
83227: ARRAY
83228: PPUSH
83229: CALL_OW 314
83233: NOT
83234: AND
83235: IFFALSE 83259
// ComMoveToArea ( group [ i ] , f_heal ) else
83237: LD_VAR 0 4
83241: PUSH
83242: LD_VAR 0 7
83246: ARRAY
83247: PPUSH
83248: LD_VAR 0 23
83252: PPUSH
83253: CALL_OW 113
83257: GO 83465
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83259: LD_VAR 0 4
83263: PUSH
83264: LD_VAR 0 7
83268: ARRAY
83269: PPUSH
83270: CALL 44640 0 1
83274: PPUSH
83275: CALL_OW 256
83279: PUSH
83280: LD_INT 1000
83282: EQUAL
83283: IFFALSE 83302
// ComStop ( group [ i ] ) else
83285: LD_VAR 0 4
83289: PUSH
83290: LD_VAR 0 7
83294: ARRAY
83295: PPUSH
83296: CALL_OW 141
83300: GO 83465
// if not HasTask ( group [ i ] ) and to_heal then
83302: LD_VAR 0 4
83306: PUSH
83307: LD_VAR 0 7
83311: ARRAY
83312: PPUSH
83313: CALL_OW 314
83317: NOT
83318: PUSH
83319: LD_VAR 0 30
83323: AND
83324: IFFALSE 83465
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83326: LD_ADDR_VAR 0 13
83330: PUSH
83331: LD_VAR 0 30
83335: PPUSH
83336: LD_INT 3
83338: PUSH
83339: LD_INT 54
83341: PUSH
83342: EMPTY
83343: LIST
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PPUSH
83349: CALL_OW 72
83353: PPUSH
83354: LD_VAR 0 4
83358: PUSH
83359: LD_VAR 0 7
83363: ARRAY
83364: PPUSH
83365: CALL_OW 74
83369: ST_TO_ADDR
// if z then
83370: LD_VAR 0 13
83374: IFFALSE 83465
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83376: LD_INT 91
83378: PUSH
83379: LD_VAR 0 13
83383: PUSH
83384: LD_INT 10
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 81
83394: PUSH
83395: LD_VAR 0 13
83399: PPUSH
83400: CALL_OW 255
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PPUSH
83413: CALL_OW 69
83417: PUSH
83418: LD_INT 0
83420: EQUAL
83421: IFFALSE 83445
// ComHeal ( group [ i ] , z ) else
83423: LD_VAR 0 4
83427: PUSH
83428: LD_VAR 0 7
83432: ARRAY
83433: PPUSH
83434: LD_VAR 0 13
83438: PPUSH
83439: CALL_OW 128
83443: GO 83465
// ComMoveToArea ( group [ i ] , f_heal ) ;
83445: LD_VAR 0 4
83449: PUSH
83450: LD_VAR 0 7
83454: ARRAY
83455: PPUSH
83456: LD_VAR 0 23
83460: PPUSH
83461: CALL_OW 113
// end ; continue ;
83465: GO 82496
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83467: LD_VAR 0 4
83471: PUSH
83472: LD_VAR 0 7
83476: ARRAY
83477: PPUSH
83478: CALL_OW 256
83482: PUSH
83483: LD_INT 700
83485: LESS
83486: PUSH
83487: LD_VAR 0 4
83491: PUSH
83492: LD_VAR 0 7
83496: ARRAY
83497: PUSH
83498: LD_VAR 0 30
83502: IN
83503: NOT
83504: AND
83505: IFFALSE 83529
// to_heal := to_heal union group [ i ] ;
83507: LD_ADDR_VAR 0 30
83511: PUSH
83512: LD_VAR 0 30
83516: PUSH
83517: LD_VAR 0 4
83521: PUSH
83522: LD_VAR 0 7
83526: ARRAY
83527: UNION
83528: ST_TO_ADDR
// if group [ i ] in to_heal then
83529: LD_VAR 0 4
83533: PUSH
83534: LD_VAR 0 7
83538: ARRAY
83539: PUSH
83540: LD_VAR 0 30
83544: IN
83545: IFFALSE 83654
// begin if GetLives ( group [ i ] ) = 1000 then
83547: LD_VAR 0 4
83551: PUSH
83552: LD_VAR 0 7
83556: ARRAY
83557: PPUSH
83558: CALL_OW 256
83562: PUSH
83563: LD_INT 1000
83565: EQUAL
83566: IFFALSE 83592
// to_heal := to_heal diff group [ i ] else
83568: LD_ADDR_VAR 0 30
83572: PUSH
83573: LD_VAR 0 30
83577: PUSH
83578: LD_VAR 0 4
83582: PUSH
83583: LD_VAR 0 7
83587: ARRAY
83588: DIFF
83589: ST_TO_ADDR
83590: GO 83654
// begin if not IsInArea ( group [ i ] , to_heal ) then
83592: LD_VAR 0 4
83596: PUSH
83597: LD_VAR 0 7
83601: ARRAY
83602: PPUSH
83603: LD_VAR 0 30
83607: PPUSH
83608: CALL_OW 308
83612: NOT
83613: IFFALSE 83637
// ComMoveToArea ( group [ i ] , f_heal ) else
83615: LD_VAR 0 4
83619: PUSH
83620: LD_VAR 0 7
83624: ARRAY
83625: PPUSH
83626: LD_VAR 0 23
83630: PPUSH
83631: CALL_OW 113
83635: GO 83652
// ComHold ( group [ i ] ) ;
83637: LD_VAR 0 4
83641: PUSH
83642: LD_VAR 0 7
83646: ARRAY
83647: PPUSH
83648: CALL_OW 140
// continue ;
83652: GO 82496
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83654: LD_VAR 0 4
83658: PUSH
83659: LD_VAR 0 7
83663: ARRAY
83664: PPUSH
83665: LD_INT 10
83667: PPUSH
83668: CALL 42411 0 2
83672: NOT
83673: PUSH
83674: LD_VAR 0 16
83678: PUSH
83679: LD_VAR 0 7
83683: ARRAY
83684: PUSH
83685: EMPTY
83686: EQUAL
83687: NOT
83688: AND
83689: IFFALSE 83955
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83691: LD_VAR 0 4
83695: PUSH
83696: LD_VAR 0 7
83700: ARRAY
83701: PPUSH
83702: CALL_OW 262
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: LD_INT 2
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: IN
83717: IFFALSE 83758
// if GetFuel ( group [ i ] ) < 10 then
83719: LD_VAR 0 4
83723: PUSH
83724: LD_VAR 0 7
83728: ARRAY
83729: PPUSH
83730: CALL_OW 261
83734: PUSH
83735: LD_INT 10
83737: LESS
83738: IFFALSE 83758
// SetFuel ( group [ i ] , 12 ) ;
83740: LD_VAR 0 4
83744: PUSH
83745: LD_VAR 0 7
83749: ARRAY
83750: PPUSH
83751: LD_INT 12
83753: PPUSH
83754: CALL_OW 240
// if units_path [ i ] then
83758: LD_VAR 0 16
83762: PUSH
83763: LD_VAR 0 7
83767: ARRAY
83768: IFFALSE 83953
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83770: LD_VAR 0 4
83774: PUSH
83775: LD_VAR 0 7
83779: ARRAY
83780: PPUSH
83781: LD_VAR 0 16
83785: PUSH
83786: LD_VAR 0 7
83790: ARRAY
83791: PUSH
83792: LD_INT 1
83794: ARRAY
83795: PUSH
83796: LD_INT 1
83798: ARRAY
83799: PPUSH
83800: LD_VAR 0 16
83804: PUSH
83805: LD_VAR 0 7
83809: ARRAY
83810: PUSH
83811: LD_INT 1
83813: ARRAY
83814: PUSH
83815: LD_INT 2
83817: ARRAY
83818: PPUSH
83819: CALL_OW 297
83823: PUSH
83824: LD_INT 6
83826: GREATER
83827: IFFALSE 83902
// begin if not HasTask ( group [ i ] ) then
83829: LD_VAR 0 4
83833: PUSH
83834: LD_VAR 0 7
83838: ARRAY
83839: PPUSH
83840: CALL_OW 314
83844: NOT
83845: IFFALSE 83900
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83847: LD_VAR 0 4
83851: PUSH
83852: LD_VAR 0 7
83856: ARRAY
83857: PPUSH
83858: LD_VAR 0 16
83862: PUSH
83863: LD_VAR 0 7
83867: ARRAY
83868: PUSH
83869: LD_INT 1
83871: ARRAY
83872: PUSH
83873: LD_INT 1
83875: ARRAY
83876: PPUSH
83877: LD_VAR 0 16
83881: PUSH
83882: LD_VAR 0 7
83886: ARRAY
83887: PUSH
83888: LD_INT 1
83890: ARRAY
83891: PUSH
83892: LD_INT 2
83894: ARRAY
83895: PPUSH
83896: CALL_OW 114
// end else
83900: GO 83953
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83902: LD_ADDR_VAR 0 15
83906: PUSH
83907: LD_VAR 0 16
83911: PUSH
83912: LD_VAR 0 7
83916: ARRAY
83917: PPUSH
83918: LD_INT 1
83920: PPUSH
83921: CALL_OW 3
83925: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83926: LD_ADDR_VAR 0 16
83930: PUSH
83931: LD_VAR 0 16
83935: PPUSH
83936: LD_VAR 0 7
83940: PPUSH
83941: LD_VAR 0 15
83945: PPUSH
83946: CALL_OW 1
83950: ST_TO_ADDR
// continue ;
83951: GO 82496
// end ; end ; end else
83953: GO 86617
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83955: LD_ADDR_VAR 0 14
83959: PUSH
83960: LD_INT 81
83962: PUSH
83963: LD_VAR 0 4
83967: PUSH
83968: LD_VAR 0 7
83972: ARRAY
83973: PPUSH
83974: CALL_OW 255
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PPUSH
83983: CALL_OW 69
83987: ST_TO_ADDR
// if not tmp then
83988: LD_VAR 0 14
83992: NOT
83993: IFFALSE 83997
// continue ;
83995: GO 82496
// if f_ignore_area then
83997: LD_VAR 0 17
84001: IFFALSE 84089
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84003: LD_ADDR_VAR 0 15
84007: PUSH
84008: LD_VAR 0 14
84012: PPUSH
84013: LD_INT 3
84015: PUSH
84016: LD_INT 92
84018: PUSH
84019: LD_VAR 0 17
84023: PUSH
84024: LD_INT 1
84026: ARRAY
84027: PUSH
84028: LD_VAR 0 17
84032: PUSH
84033: LD_INT 2
84035: ARRAY
84036: PUSH
84037: LD_VAR 0 17
84041: PUSH
84042: LD_INT 3
84044: ARRAY
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PPUSH
84056: CALL_OW 72
84060: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84061: LD_VAR 0 14
84065: PUSH
84066: LD_VAR 0 15
84070: DIFF
84071: IFFALSE 84089
// tmp := tmp diff tmp2 ;
84073: LD_ADDR_VAR 0 14
84077: PUSH
84078: LD_VAR 0 14
84082: PUSH
84083: LD_VAR 0 15
84087: DIFF
84088: ST_TO_ADDR
// end ; if not f_murder then
84089: LD_VAR 0 20
84093: NOT
84094: IFFALSE 84152
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84096: LD_ADDR_VAR 0 15
84100: PUSH
84101: LD_VAR 0 14
84105: PPUSH
84106: LD_INT 3
84108: PUSH
84109: LD_INT 50
84111: PUSH
84112: EMPTY
84113: LIST
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PPUSH
84119: CALL_OW 72
84123: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84124: LD_VAR 0 14
84128: PUSH
84129: LD_VAR 0 15
84133: DIFF
84134: IFFALSE 84152
// tmp := tmp diff tmp2 ;
84136: LD_ADDR_VAR 0 14
84140: PUSH
84141: LD_VAR 0 14
84145: PUSH
84146: LD_VAR 0 15
84150: DIFF
84151: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84152: LD_ADDR_VAR 0 14
84156: PUSH
84157: LD_VAR 0 4
84161: PUSH
84162: LD_VAR 0 7
84166: ARRAY
84167: PPUSH
84168: LD_VAR 0 14
84172: PPUSH
84173: LD_INT 1
84175: PPUSH
84176: LD_INT 1
84178: PPUSH
84179: CALL 15352 0 4
84183: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84184: LD_VAR 0 4
84188: PUSH
84189: LD_VAR 0 7
84193: ARRAY
84194: PPUSH
84195: CALL_OW 257
84199: PUSH
84200: LD_INT 1
84202: EQUAL
84203: IFFALSE 84651
// begin if WantPlant ( group [ i ] ) then
84205: LD_VAR 0 4
84209: PUSH
84210: LD_VAR 0 7
84214: ARRAY
84215: PPUSH
84216: CALL 14853 0 1
84220: IFFALSE 84224
// continue ;
84222: GO 82496
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84224: LD_VAR 0 18
84228: PUSH
84229: LD_VAR 0 4
84233: PUSH
84234: LD_VAR 0 7
84238: ARRAY
84239: PPUSH
84240: CALL_OW 310
84244: NOT
84245: AND
84246: PUSH
84247: LD_VAR 0 14
84251: PUSH
84252: LD_INT 1
84254: ARRAY
84255: PUSH
84256: LD_VAR 0 14
84260: PPUSH
84261: LD_INT 21
84263: PUSH
84264: LD_INT 2
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 58
84273: PUSH
84274: EMPTY
84275: LIST
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PPUSH
84281: CALL_OW 72
84285: IN
84286: AND
84287: IFFALSE 84323
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84289: LD_VAR 0 4
84293: PUSH
84294: LD_VAR 0 7
84298: ARRAY
84299: PPUSH
84300: LD_VAR 0 14
84304: PUSH
84305: LD_INT 1
84307: ARRAY
84308: PPUSH
84309: CALL_OW 120
// attacking := true ;
84313: LD_ADDR_VAR 0 29
84317: PUSH
84318: LD_INT 1
84320: ST_TO_ADDR
// continue ;
84321: GO 82496
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84323: LD_VAR 0 26
84327: PUSH
84328: LD_VAR 0 4
84332: PUSH
84333: LD_VAR 0 7
84337: ARRAY
84338: PPUSH
84339: CALL_OW 257
84343: PUSH
84344: LD_INT 1
84346: EQUAL
84347: AND
84348: PUSH
84349: LD_VAR 0 4
84353: PUSH
84354: LD_VAR 0 7
84358: ARRAY
84359: PPUSH
84360: CALL_OW 256
84364: PUSH
84365: LD_INT 800
84367: LESS
84368: AND
84369: PUSH
84370: LD_VAR 0 4
84374: PUSH
84375: LD_VAR 0 7
84379: ARRAY
84380: PPUSH
84381: CALL_OW 318
84385: NOT
84386: AND
84387: IFFALSE 84404
// ComCrawl ( group [ i ] ) ;
84389: LD_VAR 0 4
84393: PUSH
84394: LD_VAR 0 7
84398: ARRAY
84399: PPUSH
84400: CALL_OW 137
// if f_mines then
84404: LD_VAR 0 21
84408: IFFALSE 84651
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84410: LD_VAR 0 14
84414: PUSH
84415: LD_INT 1
84417: ARRAY
84418: PPUSH
84419: CALL_OW 247
84423: PUSH
84424: LD_INT 3
84426: EQUAL
84427: PUSH
84428: LD_VAR 0 14
84432: PUSH
84433: LD_INT 1
84435: ARRAY
84436: PUSH
84437: LD_VAR 0 27
84441: IN
84442: NOT
84443: AND
84444: IFFALSE 84651
// begin x := GetX ( tmp [ 1 ] ) ;
84446: LD_ADDR_VAR 0 10
84450: PUSH
84451: LD_VAR 0 14
84455: PUSH
84456: LD_INT 1
84458: ARRAY
84459: PPUSH
84460: CALL_OW 250
84464: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84465: LD_ADDR_VAR 0 11
84469: PUSH
84470: LD_VAR 0 14
84474: PUSH
84475: LD_INT 1
84477: ARRAY
84478: PPUSH
84479: CALL_OW 251
84483: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84484: LD_ADDR_VAR 0 12
84488: PUSH
84489: LD_VAR 0 4
84493: PUSH
84494: LD_VAR 0 7
84498: ARRAY
84499: PPUSH
84500: CALL 42496 0 1
84504: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84505: LD_VAR 0 4
84509: PUSH
84510: LD_VAR 0 7
84514: ARRAY
84515: PPUSH
84516: LD_VAR 0 10
84520: PPUSH
84521: LD_VAR 0 11
84525: PPUSH
84526: LD_VAR 0 14
84530: PUSH
84531: LD_INT 1
84533: ARRAY
84534: PPUSH
84535: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84539: LD_VAR 0 4
84543: PUSH
84544: LD_VAR 0 7
84548: ARRAY
84549: PPUSH
84550: LD_VAR 0 10
84554: PPUSH
84555: LD_VAR 0 12
84559: PPUSH
84560: LD_INT 7
84562: PPUSH
84563: CALL_OW 272
84567: PPUSH
84568: LD_VAR 0 11
84572: PPUSH
84573: LD_VAR 0 12
84577: PPUSH
84578: LD_INT 7
84580: PPUSH
84581: CALL_OW 273
84585: PPUSH
84586: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84590: LD_VAR 0 4
84594: PUSH
84595: LD_VAR 0 7
84599: ARRAY
84600: PPUSH
84601: LD_INT 71
84603: PPUSH
84604: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84608: LD_ADDR_VAR 0 27
84612: PUSH
84613: LD_VAR 0 27
84617: PPUSH
84618: LD_VAR 0 27
84622: PUSH
84623: LD_INT 1
84625: PLUS
84626: PPUSH
84627: LD_VAR 0 14
84631: PUSH
84632: LD_INT 1
84634: ARRAY
84635: PPUSH
84636: CALL_OW 1
84640: ST_TO_ADDR
// attacking := true ;
84641: LD_ADDR_VAR 0 29
84645: PUSH
84646: LD_INT 1
84648: ST_TO_ADDR
// continue ;
84649: GO 82496
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84651: LD_VAR 0 4
84655: PUSH
84656: LD_VAR 0 7
84660: ARRAY
84661: PPUSH
84662: CALL_OW 257
84666: PUSH
84667: LD_INT 17
84669: EQUAL
84670: PUSH
84671: LD_VAR 0 4
84675: PUSH
84676: LD_VAR 0 7
84680: ARRAY
84681: PPUSH
84682: CALL_OW 110
84686: PUSH
84687: LD_INT 71
84689: EQUAL
84690: NOT
84691: AND
84692: IFFALSE 84838
// begin attacking := false ;
84694: LD_ADDR_VAR 0 29
84698: PUSH
84699: LD_INT 0
84701: ST_TO_ADDR
// k := 5 ;
84702: LD_ADDR_VAR 0 9
84706: PUSH
84707: LD_INT 5
84709: ST_TO_ADDR
// if tmp < k then
84710: LD_VAR 0 14
84714: PUSH
84715: LD_VAR 0 9
84719: LESS
84720: IFFALSE 84732
// k := tmp ;
84722: LD_ADDR_VAR 0 9
84726: PUSH
84727: LD_VAR 0 14
84731: ST_TO_ADDR
// for j = 1 to k do
84732: LD_ADDR_VAR 0 8
84736: PUSH
84737: DOUBLE
84738: LD_INT 1
84740: DEC
84741: ST_TO_ADDR
84742: LD_VAR 0 9
84746: PUSH
84747: FOR_TO
84748: IFFALSE 84836
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84750: LD_VAR 0 14
84754: PUSH
84755: LD_VAR 0 8
84759: ARRAY
84760: PUSH
84761: LD_VAR 0 14
84765: PPUSH
84766: LD_INT 58
84768: PUSH
84769: EMPTY
84770: LIST
84771: PPUSH
84772: CALL_OW 72
84776: IN
84777: NOT
84778: IFFALSE 84834
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84780: LD_VAR 0 4
84784: PUSH
84785: LD_VAR 0 7
84789: ARRAY
84790: PPUSH
84791: LD_VAR 0 14
84795: PUSH
84796: LD_VAR 0 8
84800: ARRAY
84801: PPUSH
84802: CALL_OW 115
// attacking := true ;
84806: LD_ADDR_VAR 0 29
84810: PUSH
84811: LD_INT 1
84813: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84814: LD_VAR 0 4
84818: PUSH
84819: LD_VAR 0 7
84823: ARRAY
84824: PPUSH
84825: LD_INT 71
84827: PPUSH
84828: CALL_OW 109
// continue ;
84832: GO 84747
// end ; end ;
84834: GO 84747
84836: POP
84837: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84838: LD_VAR 0 4
84842: PUSH
84843: LD_VAR 0 7
84847: ARRAY
84848: PPUSH
84849: CALL_OW 257
84853: PUSH
84854: LD_INT 8
84856: EQUAL
84857: PUSH
84858: LD_VAR 0 4
84862: PUSH
84863: LD_VAR 0 7
84867: ARRAY
84868: PPUSH
84869: CALL_OW 264
84873: PUSH
84874: LD_INT 28
84876: PUSH
84877: LD_INT 45
84879: PUSH
84880: LD_INT 7
84882: PUSH
84883: LD_INT 47
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: IN
84892: OR
84893: IFFALSE 85149
// begin attacking := false ;
84895: LD_ADDR_VAR 0 29
84899: PUSH
84900: LD_INT 0
84902: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84903: LD_VAR 0 14
84907: PUSH
84908: LD_INT 1
84910: ARRAY
84911: PPUSH
84912: CALL_OW 266
84916: PUSH
84917: LD_INT 32
84919: PUSH
84920: LD_INT 31
84922: PUSH
84923: LD_INT 33
84925: PUSH
84926: LD_INT 4
84928: PUSH
84929: LD_INT 5
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: IN
84939: IFFALSE 85125
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84941: LD_ADDR_VAR 0 9
84945: PUSH
84946: LD_VAR 0 14
84950: PUSH
84951: LD_INT 1
84953: ARRAY
84954: PPUSH
84955: CALL_OW 266
84959: PPUSH
84960: LD_VAR 0 14
84964: PUSH
84965: LD_INT 1
84967: ARRAY
84968: PPUSH
84969: CALL_OW 250
84973: PPUSH
84974: LD_VAR 0 14
84978: PUSH
84979: LD_INT 1
84981: ARRAY
84982: PPUSH
84983: CALL_OW 251
84987: PPUSH
84988: LD_VAR 0 14
84992: PUSH
84993: LD_INT 1
84995: ARRAY
84996: PPUSH
84997: CALL_OW 254
85001: PPUSH
85002: LD_VAR 0 14
85006: PUSH
85007: LD_INT 1
85009: ARRAY
85010: PPUSH
85011: CALL_OW 248
85015: PPUSH
85016: LD_INT 0
85018: PPUSH
85019: CALL 23866 0 6
85023: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85024: LD_ADDR_VAR 0 8
85028: PUSH
85029: LD_VAR 0 4
85033: PUSH
85034: LD_VAR 0 7
85038: ARRAY
85039: PPUSH
85040: LD_VAR 0 9
85044: PPUSH
85045: CALL 42609 0 2
85049: ST_TO_ADDR
// if j then
85050: LD_VAR 0 8
85054: IFFALSE 85123
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85056: LD_VAR 0 8
85060: PUSH
85061: LD_INT 1
85063: ARRAY
85064: PPUSH
85065: LD_VAR 0 8
85069: PUSH
85070: LD_INT 2
85072: ARRAY
85073: PPUSH
85074: CALL_OW 488
85078: IFFALSE 85123
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85080: LD_VAR 0 4
85084: PUSH
85085: LD_VAR 0 7
85089: ARRAY
85090: PPUSH
85091: LD_VAR 0 8
85095: PUSH
85096: LD_INT 1
85098: ARRAY
85099: PPUSH
85100: LD_VAR 0 8
85104: PUSH
85105: LD_INT 2
85107: ARRAY
85108: PPUSH
85109: CALL_OW 116
// attacking := true ;
85113: LD_ADDR_VAR 0 29
85117: PUSH
85118: LD_INT 1
85120: ST_TO_ADDR
// continue ;
85121: GO 82496
// end ; end else
85123: GO 85149
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85125: LD_VAR 0 4
85129: PUSH
85130: LD_VAR 0 7
85134: ARRAY
85135: PPUSH
85136: LD_VAR 0 14
85140: PUSH
85141: LD_INT 1
85143: ARRAY
85144: PPUSH
85145: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85149: LD_VAR 0 4
85153: PUSH
85154: LD_VAR 0 7
85158: ARRAY
85159: PPUSH
85160: CALL_OW 265
85164: PUSH
85165: LD_INT 11
85167: EQUAL
85168: IFFALSE 85446
// begin k := 10 ;
85170: LD_ADDR_VAR 0 9
85174: PUSH
85175: LD_INT 10
85177: ST_TO_ADDR
// x := 0 ;
85178: LD_ADDR_VAR 0 10
85182: PUSH
85183: LD_INT 0
85185: ST_TO_ADDR
// if tmp < k then
85186: LD_VAR 0 14
85190: PUSH
85191: LD_VAR 0 9
85195: LESS
85196: IFFALSE 85208
// k := tmp ;
85198: LD_ADDR_VAR 0 9
85202: PUSH
85203: LD_VAR 0 14
85207: ST_TO_ADDR
// for j = k downto 1 do
85208: LD_ADDR_VAR 0 8
85212: PUSH
85213: DOUBLE
85214: LD_VAR 0 9
85218: INC
85219: ST_TO_ADDR
85220: LD_INT 1
85222: PUSH
85223: FOR_DOWNTO
85224: IFFALSE 85299
// begin if GetType ( tmp [ j ] ) = unit_human then
85226: LD_VAR 0 14
85230: PUSH
85231: LD_VAR 0 8
85235: ARRAY
85236: PPUSH
85237: CALL_OW 247
85241: PUSH
85242: LD_INT 1
85244: EQUAL
85245: IFFALSE 85297
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85247: LD_VAR 0 4
85251: PUSH
85252: LD_VAR 0 7
85256: ARRAY
85257: PPUSH
85258: LD_VAR 0 14
85262: PUSH
85263: LD_VAR 0 8
85267: ARRAY
85268: PPUSH
85269: CALL 42863 0 2
// x := tmp [ j ] ;
85273: LD_ADDR_VAR 0 10
85277: PUSH
85278: LD_VAR 0 14
85282: PUSH
85283: LD_VAR 0 8
85287: ARRAY
85288: ST_TO_ADDR
// attacking := true ;
85289: LD_ADDR_VAR 0 29
85293: PUSH
85294: LD_INT 1
85296: ST_TO_ADDR
// end ; end ;
85297: GO 85223
85299: POP
85300: POP
// if not x then
85301: LD_VAR 0 10
85305: NOT
85306: IFFALSE 85446
// begin attacking := true ;
85308: LD_ADDR_VAR 0 29
85312: PUSH
85313: LD_INT 1
85315: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85316: LD_VAR 0 4
85320: PUSH
85321: LD_VAR 0 7
85325: ARRAY
85326: PPUSH
85327: CALL_OW 250
85331: PPUSH
85332: LD_VAR 0 4
85336: PUSH
85337: LD_VAR 0 7
85341: ARRAY
85342: PPUSH
85343: CALL_OW 251
85347: PPUSH
85348: CALL_OW 546
85352: PUSH
85353: LD_INT 2
85355: ARRAY
85356: PUSH
85357: LD_VAR 0 14
85361: PUSH
85362: LD_INT 1
85364: ARRAY
85365: PPUSH
85366: CALL_OW 250
85370: PPUSH
85371: LD_VAR 0 14
85375: PUSH
85376: LD_INT 1
85378: ARRAY
85379: PPUSH
85380: CALL_OW 251
85384: PPUSH
85385: CALL_OW 546
85389: PUSH
85390: LD_INT 2
85392: ARRAY
85393: EQUAL
85394: IFFALSE 85422
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85396: LD_VAR 0 4
85400: PUSH
85401: LD_VAR 0 7
85405: ARRAY
85406: PPUSH
85407: LD_VAR 0 14
85411: PUSH
85412: LD_INT 1
85414: ARRAY
85415: PPUSH
85416: CALL 42863 0 2
85420: GO 85446
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85422: LD_VAR 0 4
85426: PUSH
85427: LD_VAR 0 7
85431: ARRAY
85432: PPUSH
85433: LD_VAR 0 14
85437: PUSH
85438: LD_INT 1
85440: ARRAY
85441: PPUSH
85442: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85446: LD_VAR 0 4
85450: PUSH
85451: LD_VAR 0 7
85455: ARRAY
85456: PPUSH
85457: CALL_OW 264
85461: PUSH
85462: LD_INT 29
85464: EQUAL
85465: IFFALSE 85831
// begin if WantsToAttack ( group [ i ] ) in bombed then
85467: LD_VAR 0 4
85471: PUSH
85472: LD_VAR 0 7
85476: ARRAY
85477: PPUSH
85478: CALL_OW 319
85482: PUSH
85483: LD_VAR 0 28
85487: IN
85488: IFFALSE 85492
// continue ;
85490: GO 82496
// k := 8 ;
85492: LD_ADDR_VAR 0 9
85496: PUSH
85497: LD_INT 8
85499: ST_TO_ADDR
// x := 0 ;
85500: LD_ADDR_VAR 0 10
85504: PUSH
85505: LD_INT 0
85507: ST_TO_ADDR
// if tmp < k then
85508: LD_VAR 0 14
85512: PUSH
85513: LD_VAR 0 9
85517: LESS
85518: IFFALSE 85530
// k := tmp ;
85520: LD_ADDR_VAR 0 9
85524: PUSH
85525: LD_VAR 0 14
85529: ST_TO_ADDR
// for j = 1 to k do
85530: LD_ADDR_VAR 0 8
85534: PUSH
85535: DOUBLE
85536: LD_INT 1
85538: DEC
85539: ST_TO_ADDR
85540: LD_VAR 0 9
85544: PUSH
85545: FOR_TO
85546: IFFALSE 85678
// begin if GetType ( tmp [ j ] ) = unit_building then
85548: LD_VAR 0 14
85552: PUSH
85553: LD_VAR 0 8
85557: ARRAY
85558: PPUSH
85559: CALL_OW 247
85563: PUSH
85564: LD_INT 3
85566: EQUAL
85567: IFFALSE 85676
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85569: LD_VAR 0 14
85573: PUSH
85574: LD_VAR 0 8
85578: ARRAY
85579: PUSH
85580: LD_VAR 0 28
85584: IN
85585: NOT
85586: PUSH
85587: LD_VAR 0 14
85591: PUSH
85592: LD_VAR 0 8
85596: ARRAY
85597: PPUSH
85598: CALL_OW 313
85602: AND
85603: IFFALSE 85676
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85605: LD_VAR 0 4
85609: PUSH
85610: LD_VAR 0 7
85614: ARRAY
85615: PPUSH
85616: LD_VAR 0 14
85620: PUSH
85621: LD_VAR 0 8
85625: ARRAY
85626: PPUSH
85627: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85631: LD_ADDR_VAR 0 28
85635: PUSH
85636: LD_VAR 0 28
85640: PPUSH
85641: LD_VAR 0 28
85645: PUSH
85646: LD_INT 1
85648: PLUS
85649: PPUSH
85650: LD_VAR 0 14
85654: PUSH
85655: LD_VAR 0 8
85659: ARRAY
85660: PPUSH
85661: CALL_OW 1
85665: ST_TO_ADDR
// attacking := true ;
85666: LD_ADDR_VAR 0 29
85670: PUSH
85671: LD_INT 1
85673: ST_TO_ADDR
// break ;
85674: GO 85678
// end ; end ;
85676: GO 85545
85678: POP
85679: POP
// if not attacking and f_attack_depot then
85680: LD_VAR 0 29
85684: NOT
85685: PUSH
85686: LD_VAR 0 25
85690: AND
85691: IFFALSE 85786
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85693: LD_ADDR_VAR 0 13
85697: PUSH
85698: LD_VAR 0 14
85702: PPUSH
85703: LD_INT 2
85705: PUSH
85706: LD_INT 30
85708: PUSH
85709: LD_INT 0
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 30
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: LIST
85730: PPUSH
85731: CALL_OW 72
85735: ST_TO_ADDR
// if z then
85736: LD_VAR 0 13
85740: IFFALSE 85786
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85742: LD_VAR 0 4
85746: PUSH
85747: LD_VAR 0 7
85751: ARRAY
85752: PPUSH
85753: LD_VAR 0 13
85757: PPUSH
85758: LD_VAR 0 4
85762: PUSH
85763: LD_VAR 0 7
85767: ARRAY
85768: PPUSH
85769: CALL_OW 74
85773: PPUSH
85774: CALL_OW 115
// attacking := true ;
85778: LD_ADDR_VAR 0 29
85782: PUSH
85783: LD_INT 1
85785: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85786: LD_VAR 0 4
85790: PUSH
85791: LD_VAR 0 7
85795: ARRAY
85796: PPUSH
85797: CALL_OW 256
85801: PUSH
85802: LD_INT 500
85804: LESS
85805: IFFALSE 85831
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85807: LD_VAR 0 4
85811: PUSH
85812: LD_VAR 0 7
85816: ARRAY
85817: PPUSH
85818: LD_VAR 0 14
85822: PUSH
85823: LD_INT 1
85825: ARRAY
85826: PPUSH
85827: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85831: LD_VAR 0 4
85835: PUSH
85836: LD_VAR 0 7
85840: ARRAY
85841: PPUSH
85842: CALL_OW 264
85846: PUSH
85847: LD_INT 49
85849: EQUAL
85850: IFFALSE 85971
// begin if not HasTask ( group [ i ] ) then
85852: LD_VAR 0 4
85856: PUSH
85857: LD_VAR 0 7
85861: ARRAY
85862: PPUSH
85863: CALL_OW 314
85867: NOT
85868: IFFALSE 85971
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85870: LD_ADDR_VAR 0 9
85874: PUSH
85875: LD_INT 81
85877: PUSH
85878: LD_VAR 0 4
85882: PUSH
85883: LD_VAR 0 7
85887: ARRAY
85888: PPUSH
85889: CALL_OW 255
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PPUSH
85898: CALL_OW 69
85902: PPUSH
85903: LD_VAR 0 4
85907: PUSH
85908: LD_VAR 0 7
85912: ARRAY
85913: PPUSH
85914: CALL_OW 74
85918: ST_TO_ADDR
// if k then
85919: LD_VAR 0 9
85923: IFFALSE 85971
// if GetDistUnits ( group [ i ] , k ) > 10 then
85925: LD_VAR 0 4
85929: PUSH
85930: LD_VAR 0 7
85934: ARRAY
85935: PPUSH
85936: LD_VAR 0 9
85940: PPUSH
85941: CALL_OW 296
85945: PUSH
85946: LD_INT 10
85948: GREATER
85949: IFFALSE 85971
// ComMoveUnit ( group [ i ] , k ) ;
85951: LD_VAR 0 4
85955: PUSH
85956: LD_VAR 0 7
85960: ARRAY
85961: PPUSH
85962: LD_VAR 0 9
85966: PPUSH
85967: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85971: LD_VAR 0 4
85975: PUSH
85976: LD_VAR 0 7
85980: ARRAY
85981: PPUSH
85982: CALL_OW 256
85986: PUSH
85987: LD_INT 250
85989: LESS
85990: PUSH
85991: LD_VAR 0 4
85995: PUSH
85996: LD_VAR 0 7
86000: ARRAY
86001: PUSH
86002: LD_INT 21
86004: PUSH
86005: LD_INT 2
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 23
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PPUSH
86026: CALL_OW 69
86030: IN
86031: AND
86032: IFFALSE 86157
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86034: LD_ADDR_VAR 0 9
86038: PUSH
86039: LD_OWVAR 3
86043: PUSH
86044: LD_VAR 0 4
86048: PUSH
86049: LD_VAR 0 7
86053: ARRAY
86054: DIFF
86055: PPUSH
86056: LD_VAR 0 4
86060: PUSH
86061: LD_VAR 0 7
86065: ARRAY
86066: PPUSH
86067: CALL_OW 74
86071: ST_TO_ADDR
// if not k then
86072: LD_VAR 0 9
86076: NOT
86077: IFFALSE 86081
// continue ;
86079: GO 82496
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86081: LD_VAR 0 9
86085: PUSH
86086: LD_INT 81
86088: PUSH
86089: LD_VAR 0 4
86093: PUSH
86094: LD_VAR 0 7
86098: ARRAY
86099: PPUSH
86100: CALL_OW 255
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PPUSH
86109: CALL_OW 69
86113: IN
86114: PUSH
86115: LD_VAR 0 9
86119: PPUSH
86120: LD_VAR 0 4
86124: PUSH
86125: LD_VAR 0 7
86129: ARRAY
86130: PPUSH
86131: CALL_OW 296
86135: PUSH
86136: LD_INT 5
86138: LESS
86139: AND
86140: IFFALSE 86157
// ComAutodestruct ( group [ i ] ) ;
86142: LD_VAR 0 4
86146: PUSH
86147: LD_VAR 0 7
86151: ARRAY
86152: PPUSH
86153: CALL 42761 0 1
// end ; if f_attack_depot then
86157: LD_VAR 0 25
86161: IFFALSE 86273
// begin k := 6 ;
86163: LD_ADDR_VAR 0 9
86167: PUSH
86168: LD_INT 6
86170: ST_TO_ADDR
// if tmp < k then
86171: LD_VAR 0 14
86175: PUSH
86176: LD_VAR 0 9
86180: LESS
86181: IFFALSE 86193
// k := tmp ;
86183: LD_ADDR_VAR 0 9
86187: PUSH
86188: LD_VAR 0 14
86192: ST_TO_ADDR
// for j = 1 to k do
86193: LD_ADDR_VAR 0 8
86197: PUSH
86198: DOUBLE
86199: LD_INT 1
86201: DEC
86202: ST_TO_ADDR
86203: LD_VAR 0 9
86207: PUSH
86208: FOR_TO
86209: IFFALSE 86271
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86211: LD_VAR 0 8
86215: PPUSH
86216: CALL_OW 266
86220: PUSH
86221: LD_INT 0
86223: PUSH
86224: LD_INT 1
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: IN
86231: IFFALSE 86269
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86233: LD_VAR 0 4
86237: PUSH
86238: LD_VAR 0 7
86242: ARRAY
86243: PPUSH
86244: LD_VAR 0 14
86248: PUSH
86249: LD_VAR 0 8
86253: ARRAY
86254: PPUSH
86255: CALL_OW 115
// attacking := true ;
86259: LD_ADDR_VAR 0 29
86263: PUSH
86264: LD_INT 1
86266: ST_TO_ADDR
// break ;
86267: GO 86271
// end ;
86269: GO 86208
86271: POP
86272: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86273: LD_VAR 0 4
86277: PUSH
86278: LD_VAR 0 7
86282: ARRAY
86283: PPUSH
86284: CALL_OW 302
86288: PUSH
86289: LD_VAR 0 29
86293: NOT
86294: AND
86295: IFFALSE 86617
// begin if GetTag ( group [ i ] ) = 71 then
86297: LD_VAR 0 4
86301: PUSH
86302: LD_VAR 0 7
86306: ARRAY
86307: PPUSH
86308: CALL_OW 110
86312: PUSH
86313: LD_INT 71
86315: EQUAL
86316: IFFALSE 86357
// begin if HasTask ( group [ i ] ) then
86318: LD_VAR 0 4
86322: PUSH
86323: LD_VAR 0 7
86327: ARRAY
86328: PPUSH
86329: CALL_OW 314
86333: IFFALSE 86339
// continue else
86335: GO 82496
86337: GO 86357
// SetTag ( group [ i ] , 0 ) ;
86339: LD_VAR 0 4
86343: PUSH
86344: LD_VAR 0 7
86348: ARRAY
86349: PPUSH
86350: LD_INT 0
86352: PPUSH
86353: CALL_OW 109
// end ; k := 8 ;
86357: LD_ADDR_VAR 0 9
86361: PUSH
86362: LD_INT 8
86364: ST_TO_ADDR
// x := 0 ;
86365: LD_ADDR_VAR 0 10
86369: PUSH
86370: LD_INT 0
86372: ST_TO_ADDR
// if tmp < k then
86373: LD_VAR 0 14
86377: PUSH
86378: LD_VAR 0 9
86382: LESS
86383: IFFALSE 86395
// k := tmp ;
86385: LD_ADDR_VAR 0 9
86389: PUSH
86390: LD_VAR 0 14
86394: ST_TO_ADDR
// for j = 1 to k do
86395: LD_ADDR_VAR 0 8
86399: PUSH
86400: DOUBLE
86401: LD_INT 1
86403: DEC
86404: ST_TO_ADDR
86405: LD_VAR 0 9
86409: PUSH
86410: FOR_TO
86411: IFFALSE 86509
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86413: LD_VAR 0 14
86417: PUSH
86418: LD_VAR 0 8
86422: ARRAY
86423: PPUSH
86424: CALL_OW 247
86428: PUSH
86429: LD_INT 1
86431: EQUAL
86432: PUSH
86433: LD_VAR 0 14
86437: PUSH
86438: LD_VAR 0 8
86442: ARRAY
86443: PPUSH
86444: CALL_OW 256
86448: PUSH
86449: LD_INT 250
86451: LESS
86452: PUSH
86453: LD_VAR 0 20
86457: AND
86458: PUSH
86459: LD_VAR 0 20
86463: NOT
86464: PUSH
86465: LD_VAR 0 14
86469: PUSH
86470: LD_VAR 0 8
86474: ARRAY
86475: PPUSH
86476: CALL_OW 256
86480: PUSH
86481: LD_INT 250
86483: GREATEREQUAL
86484: AND
86485: OR
86486: AND
86487: IFFALSE 86507
// begin x := tmp [ j ] ;
86489: LD_ADDR_VAR 0 10
86493: PUSH
86494: LD_VAR 0 14
86498: PUSH
86499: LD_VAR 0 8
86503: ARRAY
86504: ST_TO_ADDR
// break ;
86505: GO 86509
// end ;
86507: GO 86410
86509: POP
86510: POP
// if x then
86511: LD_VAR 0 10
86515: IFFALSE 86539
// ComAttackUnit ( group [ i ] , x ) else
86517: LD_VAR 0 4
86521: PUSH
86522: LD_VAR 0 7
86526: ARRAY
86527: PPUSH
86528: LD_VAR 0 10
86532: PPUSH
86533: CALL_OW 115
86537: GO 86563
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86539: LD_VAR 0 4
86543: PUSH
86544: LD_VAR 0 7
86548: ARRAY
86549: PPUSH
86550: LD_VAR 0 14
86554: PUSH
86555: LD_INT 1
86557: ARRAY
86558: PPUSH
86559: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86563: LD_VAR 0 4
86567: PUSH
86568: LD_VAR 0 7
86572: ARRAY
86573: PPUSH
86574: CALL_OW 314
86578: NOT
86579: IFFALSE 86617
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86581: LD_VAR 0 4
86585: PUSH
86586: LD_VAR 0 7
86590: ARRAY
86591: PPUSH
86592: LD_VAR 0 14
86596: PPUSH
86597: LD_VAR 0 4
86601: PUSH
86602: LD_VAR 0 7
86606: ARRAY
86607: PPUSH
86608: CALL_OW 74
86612: PPUSH
86613: CALL_OW 115
// end ; end ; end ;
86617: GO 82496
86619: POP
86620: POP
// wait ( 0 0$2 ) ;
86621: LD_INT 70
86623: PPUSH
86624: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86628: LD_VAR 0 4
86632: NOT
86633: PUSH
86634: LD_VAR 0 4
86638: PUSH
86639: EMPTY
86640: EQUAL
86641: OR
86642: PUSH
86643: LD_INT 81
86645: PUSH
86646: LD_VAR 0 35
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PPUSH
86655: CALL_OW 69
86659: NOT
86660: OR
86661: IFFALSE 82481
// end ;
86663: LD_VAR 0 2
86667: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86668: LD_INT 0
86670: PPUSH
86671: PPUSH
86672: PPUSH
86673: PPUSH
86674: PPUSH
86675: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86676: LD_VAR 0 1
86680: NOT
86681: PUSH
86682: LD_EXP 43
86686: PUSH
86687: LD_VAR 0 1
86691: ARRAY
86692: NOT
86693: OR
86694: PUSH
86695: LD_VAR 0 2
86699: NOT
86700: OR
86701: IFFALSE 86705
// exit ;
86703: GO 87259
// side := mc_sides [ base ] ;
86705: LD_ADDR_VAR 0 6
86709: PUSH
86710: LD_EXP 69
86714: PUSH
86715: LD_VAR 0 1
86719: ARRAY
86720: ST_TO_ADDR
// if not side then
86721: LD_VAR 0 6
86725: NOT
86726: IFFALSE 86730
// exit ;
86728: GO 87259
// for i in solds do
86730: LD_ADDR_VAR 0 7
86734: PUSH
86735: LD_VAR 0 2
86739: PUSH
86740: FOR_IN
86741: IFFALSE 86802
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86743: LD_VAR 0 7
86747: PPUSH
86748: CALL_OW 310
86752: PPUSH
86753: CALL_OW 266
86757: PUSH
86758: LD_INT 32
86760: PUSH
86761: LD_INT 31
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: IN
86768: IFFALSE 86788
// solds := solds diff i else
86770: LD_ADDR_VAR 0 2
86774: PUSH
86775: LD_VAR 0 2
86779: PUSH
86780: LD_VAR 0 7
86784: DIFF
86785: ST_TO_ADDR
86786: GO 86800
// SetTag ( i , 18 ) ;
86788: LD_VAR 0 7
86792: PPUSH
86793: LD_INT 18
86795: PPUSH
86796: CALL_OW 109
86800: GO 86740
86802: POP
86803: POP
// if not solds then
86804: LD_VAR 0 2
86808: NOT
86809: IFFALSE 86813
// exit ;
86811: GO 87259
// repeat wait ( 0 0$2 ) ;
86813: LD_INT 70
86815: PPUSH
86816: CALL_OW 67
// enemy := mc_scan [ base ] ;
86820: LD_ADDR_VAR 0 4
86824: PUSH
86825: LD_EXP 66
86829: PUSH
86830: LD_VAR 0 1
86834: ARRAY
86835: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86836: LD_EXP 43
86840: PUSH
86841: LD_VAR 0 1
86845: ARRAY
86846: NOT
86847: PUSH
86848: LD_EXP 43
86852: PUSH
86853: LD_VAR 0 1
86857: ARRAY
86858: PUSH
86859: EMPTY
86860: EQUAL
86861: OR
86862: IFFALSE 86899
// begin for i in solds do
86864: LD_ADDR_VAR 0 7
86868: PUSH
86869: LD_VAR 0 2
86873: PUSH
86874: FOR_IN
86875: IFFALSE 86888
// ComStop ( i ) ;
86877: LD_VAR 0 7
86881: PPUSH
86882: CALL_OW 141
86886: GO 86874
86888: POP
86889: POP
// solds := [ ] ;
86890: LD_ADDR_VAR 0 2
86894: PUSH
86895: EMPTY
86896: ST_TO_ADDR
// exit ;
86897: GO 87259
// end ; for i in solds do
86899: LD_ADDR_VAR 0 7
86903: PUSH
86904: LD_VAR 0 2
86908: PUSH
86909: FOR_IN
86910: IFFALSE 87231
// begin if IsInUnit ( i ) then
86912: LD_VAR 0 7
86916: PPUSH
86917: CALL_OW 310
86921: IFFALSE 86932
// ComExitBuilding ( i ) ;
86923: LD_VAR 0 7
86927: PPUSH
86928: CALL_OW 122
// if GetLives ( i ) > 500 then
86932: LD_VAR 0 7
86936: PPUSH
86937: CALL_OW 256
86941: PUSH
86942: LD_INT 500
86944: GREATER
86945: IFFALSE 86998
// begin e := NearestUnitToUnit ( enemy , i ) ;
86947: LD_ADDR_VAR 0 5
86951: PUSH
86952: LD_VAR 0 4
86956: PPUSH
86957: LD_VAR 0 7
86961: PPUSH
86962: CALL_OW 74
86966: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86967: LD_VAR 0 7
86971: PPUSH
86972: LD_VAR 0 5
86976: PPUSH
86977: CALL_OW 250
86981: PPUSH
86982: LD_VAR 0 5
86986: PPUSH
86987: CALL_OW 251
86991: PPUSH
86992: CALL_OW 114
// end else
86996: GO 87229
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86998: LD_VAR 0 7
87002: PPUSH
87003: LD_EXP 43
87007: PUSH
87008: LD_VAR 0 1
87012: ARRAY
87013: PPUSH
87014: LD_INT 2
87016: PUSH
87017: LD_INT 30
87019: PUSH
87020: LD_INT 0
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 30
87029: PUSH
87030: LD_INT 1
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 30
87039: PUSH
87040: LD_INT 6
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: PPUSH
87053: CALL_OW 72
87057: PPUSH
87058: LD_VAR 0 7
87062: PPUSH
87063: CALL_OW 74
87067: PPUSH
87068: CALL_OW 296
87072: PUSH
87073: LD_INT 10
87075: GREATER
87076: IFFALSE 87229
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87078: LD_ADDR_VAR 0 8
87082: PUSH
87083: LD_EXP 43
87087: PUSH
87088: LD_VAR 0 1
87092: ARRAY
87093: PPUSH
87094: LD_INT 2
87096: PUSH
87097: LD_INT 30
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: PUSH
87107: LD_INT 30
87109: PUSH
87110: LD_INT 1
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 30
87119: PUSH
87120: LD_INT 6
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: PPUSH
87133: CALL_OW 72
87137: PPUSH
87138: LD_VAR 0 7
87142: PPUSH
87143: CALL_OW 74
87147: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87148: LD_VAR 0 7
87152: PPUSH
87153: LD_VAR 0 8
87157: PPUSH
87158: CALL_OW 250
87162: PPUSH
87163: LD_INT 3
87165: PPUSH
87166: LD_INT 5
87168: PPUSH
87169: CALL_OW 272
87173: PPUSH
87174: LD_VAR 0 8
87178: PPUSH
87179: CALL_OW 251
87183: PPUSH
87184: LD_INT 3
87186: PPUSH
87187: LD_INT 5
87189: PPUSH
87190: CALL_OW 273
87194: PPUSH
87195: CALL_OW 111
// SetTag ( i , 0 ) ;
87199: LD_VAR 0 7
87203: PPUSH
87204: LD_INT 0
87206: PPUSH
87207: CALL_OW 109
// solds := solds diff i ;
87211: LD_ADDR_VAR 0 2
87215: PUSH
87216: LD_VAR 0 2
87220: PUSH
87221: LD_VAR 0 7
87225: DIFF
87226: ST_TO_ADDR
// continue ;
87227: GO 86909
// end ; end ;
87229: GO 86909
87231: POP
87232: POP
// until not solds or not enemy ;
87233: LD_VAR 0 2
87237: NOT
87238: PUSH
87239: LD_VAR 0 4
87243: NOT
87244: OR
87245: IFFALSE 86813
// MC_Reset ( base , 18 ) ;
87247: LD_VAR 0 1
87251: PPUSH
87252: LD_INT 18
87254: PPUSH
87255: CALL 55418 0 2
// end ;
87259: LD_VAR 0 3
87263: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87264: LD_INT 0
87266: PPUSH
87267: PPUSH
87268: PPUSH
87269: PPUSH
87270: PPUSH
87271: PPUSH
87272: PPUSH
87273: PPUSH
87274: PPUSH
87275: PPUSH
87276: PPUSH
87277: PPUSH
87278: PPUSH
87279: PPUSH
87280: PPUSH
87281: PPUSH
87282: PPUSH
87283: PPUSH
87284: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87285: LD_ADDR_VAR 0 12
87289: PUSH
87290: LD_EXP 43
87294: PUSH
87295: LD_VAR 0 1
87299: ARRAY
87300: PPUSH
87301: LD_INT 25
87303: PUSH
87304: LD_INT 3
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PPUSH
87311: CALL_OW 72
87315: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87316: LD_EXP 83
87320: PUSH
87321: LD_VAR 0 1
87325: ARRAY
87326: IFFALSE 87350
// mechs := mechs diff mc_remote_driver [ base ] ;
87328: LD_ADDR_VAR 0 12
87332: PUSH
87333: LD_VAR 0 12
87337: PUSH
87338: LD_EXP 83
87342: PUSH
87343: LD_VAR 0 1
87347: ARRAY
87348: DIFF
87349: ST_TO_ADDR
// for i in mechs do
87350: LD_ADDR_VAR 0 4
87354: PUSH
87355: LD_VAR 0 12
87359: PUSH
87360: FOR_IN
87361: IFFALSE 87396
// if GetTag ( i ) > 0 then
87363: LD_VAR 0 4
87367: PPUSH
87368: CALL_OW 110
87372: PUSH
87373: LD_INT 0
87375: GREATER
87376: IFFALSE 87394
// mechs := mechs diff i ;
87378: LD_ADDR_VAR 0 12
87382: PUSH
87383: LD_VAR 0 12
87387: PUSH
87388: LD_VAR 0 4
87392: DIFF
87393: ST_TO_ADDR
87394: GO 87360
87396: POP
87397: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87398: LD_ADDR_VAR 0 8
87402: PUSH
87403: LD_EXP 43
87407: PUSH
87408: LD_VAR 0 1
87412: ARRAY
87413: PPUSH
87414: LD_INT 2
87416: PUSH
87417: LD_INT 25
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 25
87429: PUSH
87430: LD_INT 5
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 25
87439: PUSH
87440: LD_INT 8
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 25
87449: PUSH
87450: LD_INT 9
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: PPUSH
87464: CALL_OW 72
87468: ST_TO_ADDR
// if not defenders and not solds then
87469: LD_VAR 0 2
87473: NOT
87474: PUSH
87475: LD_VAR 0 8
87479: NOT
87480: AND
87481: IFFALSE 87485
// exit ;
87483: GO 89255
// depot_under_attack := false ;
87485: LD_ADDR_VAR 0 16
87489: PUSH
87490: LD_INT 0
87492: ST_TO_ADDR
// sold_defenders := [ ] ;
87493: LD_ADDR_VAR 0 17
87497: PUSH
87498: EMPTY
87499: ST_TO_ADDR
// if mechs then
87500: LD_VAR 0 12
87504: IFFALSE 87657
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87506: LD_ADDR_VAR 0 4
87510: PUSH
87511: LD_VAR 0 2
87515: PPUSH
87516: LD_INT 21
87518: PUSH
87519: LD_INT 2
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PPUSH
87526: CALL_OW 72
87530: PUSH
87531: FOR_IN
87532: IFFALSE 87655
// begin if GetTag ( i ) <> 20 then
87534: LD_VAR 0 4
87538: PPUSH
87539: CALL_OW 110
87543: PUSH
87544: LD_INT 20
87546: NONEQUAL
87547: IFFALSE 87561
// SetTag ( i , 20 ) ;
87549: LD_VAR 0 4
87553: PPUSH
87554: LD_INT 20
87556: PPUSH
87557: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87561: LD_VAR 0 4
87565: PPUSH
87566: CALL_OW 263
87570: PUSH
87571: LD_INT 1
87573: EQUAL
87574: PUSH
87575: LD_VAR 0 4
87579: PPUSH
87580: CALL_OW 311
87584: NOT
87585: AND
87586: IFFALSE 87653
// begin un := mechs [ 1 ] ;
87588: LD_ADDR_VAR 0 10
87592: PUSH
87593: LD_VAR 0 12
87597: PUSH
87598: LD_INT 1
87600: ARRAY
87601: ST_TO_ADDR
// ComExit ( un ) ;
87602: LD_VAR 0 10
87606: PPUSH
87607: CALL 47645 0 1
// AddComEnterUnit ( un , i ) ;
87611: LD_VAR 0 10
87615: PPUSH
87616: LD_VAR 0 4
87620: PPUSH
87621: CALL_OW 180
// SetTag ( un , 19 ) ;
87625: LD_VAR 0 10
87629: PPUSH
87630: LD_INT 19
87632: PPUSH
87633: CALL_OW 109
// mechs := mechs diff un ;
87637: LD_ADDR_VAR 0 12
87641: PUSH
87642: LD_VAR 0 12
87646: PUSH
87647: LD_VAR 0 10
87651: DIFF
87652: ST_TO_ADDR
// end ; end ;
87653: GO 87531
87655: POP
87656: POP
// if solds then
87657: LD_VAR 0 8
87661: IFFALSE 87720
// for i in solds do
87663: LD_ADDR_VAR 0 4
87667: PUSH
87668: LD_VAR 0 8
87672: PUSH
87673: FOR_IN
87674: IFFALSE 87718
// if not GetTag ( i ) then
87676: LD_VAR 0 4
87680: PPUSH
87681: CALL_OW 110
87685: NOT
87686: IFFALSE 87716
// begin defenders := defenders union i ;
87688: LD_ADDR_VAR 0 2
87692: PUSH
87693: LD_VAR 0 2
87697: PUSH
87698: LD_VAR 0 4
87702: UNION
87703: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87704: LD_VAR 0 4
87708: PPUSH
87709: LD_INT 18
87711: PPUSH
87712: CALL_OW 109
// end ;
87716: GO 87673
87718: POP
87719: POP
// repeat wait ( 0 0$2 ) ;
87720: LD_INT 70
87722: PPUSH
87723: CALL_OW 67
// enemy := mc_scan [ base ] ;
87727: LD_ADDR_VAR 0 21
87731: PUSH
87732: LD_EXP 66
87736: PUSH
87737: LD_VAR 0 1
87741: ARRAY
87742: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87743: LD_EXP 43
87747: PUSH
87748: LD_VAR 0 1
87752: ARRAY
87753: NOT
87754: PUSH
87755: LD_EXP 43
87759: PUSH
87760: LD_VAR 0 1
87764: ARRAY
87765: PUSH
87766: EMPTY
87767: EQUAL
87768: OR
87769: IFFALSE 87806
// begin for i in defenders do
87771: LD_ADDR_VAR 0 4
87775: PUSH
87776: LD_VAR 0 2
87780: PUSH
87781: FOR_IN
87782: IFFALSE 87795
// ComStop ( i ) ;
87784: LD_VAR 0 4
87788: PPUSH
87789: CALL_OW 141
87793: GO 87781
87795: POP
87796: POP
// defenders := [ ] ;
87797: LD_ADDR_VAR 0 2
87801: PUSH
87802: EMPTY
87803: ST_TO_ADDR
// exit ;
87804: GO 89255
// end ; for i in defenders do
87806: LD_ADDR_VAR 0 4
87810: PUSH
87811: LD_VAR 0 2
87815: PUSH
87816: FOR_IN
87817: IFFALSE 88715
// begin e := NearestUnitToUnit ( enemy , i ) ;
87819: LD_ADDR_VAR 0 13
87823: PUSH
87824: LD_VAR 0 21
87828: PPUSH
87829: LD_VAR 0 4
87833: PPUSH
87834: CALL_OW 74
87838: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87839: LD_ADDR_VAR 0 7
87843: PUSH
87844: LD_EXP 43
87848: PUSH
87849: LD_VAR 0 1
87853: ARRAY
87854: PPUSH
87855: LD_INT 2
87857: PUSH
87858: LD_INT 30
87860: PUSH
87861: LD_INT 0
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 30
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: LIST
87882: PPUSH
87883: CALL_OW 72
87887: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87888: LD_ADDR_VAR 0 16
87892: PUSH
87893: LD_VAR 0 7
87897: NOT
87898: PUSH
87899: LD_VAR 0 7
87903: PPUSH
87904: LD_INT 3
87906: PUSH
87907: LD_INT 24
87909: PUSH
87910: LD_INT 600
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PPUSH
87921: CALL_OW 72
87925: OR
87926: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87927: LD_VAR 0 4
87931: PPUSH
87932: CALL_OW 247
87936: PUSH
87937: LD_INT 2
87939: DOUBLE
87940: EQUAL
87941: IFTRUE 87945
87943: GO 88341
87945: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87946: LD_VAR 0 4
87950: PPUSH
87951: CALL_OW 256
87955: PUSH
87956: LD_INT 1000
87958: EQUAL
87959: PUSH
87960: LD_VAR 0 4
87964: PPUSH
87965: LD_VAR 0 13
87969: PPUSH
87970: CALL_OW 296
87974: PUSH
87975: LD_INT 40
87977: LESS
87978: PUSH
87979: LD_VAR 0 13
87983: PPUSH
87984: LD_EXP 68
87988: PUSH
87989: LD_VAR 0 1
87993: ARRAY
87994: PPUSH
87995: CALL_OW 308
87999: OR
88000: AND
88001: IFFALSE 88123
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88003: LD_VAR 0 4
88007: PPUSH
88008: CALL_OW 262
88012: PUSH
88013: LD_INT 1
88015: EQUAL
88016: PUSH
88017: LD_VAR 0 4
88021: PPUSH
88022: CALL_OW 261
88026: PUSH
88027: LD_INT 30
88029: LESS
88030: AND
88031: PUSH
88032: LD_VAR 0 7
88036: AND
88037: IFFALSE 88107
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88039: LD_VAR 0 4
88043: PPUSH
88044: LD_VAR 0 7
88048: PPUSH
88049: LD_VAR 0 4
88053: PPUSH
88054: CALL_OW 74
88058: PPUSH
88059: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88063: LD_VAR 0 4
88067: PPUSH
88068: LD_VAR 0 7
88072: PPUSH
88073: LD_VAR 0 4
88077: PPUSH
88078: CALL_OW 74
88082: PPUSH
88083: CALL_OW 296
88087: PUSH
88088: LD_INT 6
88090: LESS
88091: IFFALSE 88105
// SetFuel ( i , 100 ) ;
88093: LD_VAR 0 4
88097: PPUSH
88098: LD_INT 100
88100: PPUSH
88101: CALL_OW 240
// end else
88105: GO 88121
// ComAttackUnit ( i , e ) ;
88107: LD_VAR 0 4
88111: PPUSH
88112: LD_VAR 0 13
88116: PPUSH
88117: CALL_OW 115
// end else
88121: GO 88224
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88123: LD_VAR 0 13
88127: PPUSH
88128: LD_EXP 68
88132: PUSH
88133: LD_VAR 0 1
88137: ARRAY
88138: PPUSH
88139: CALL_OW 308
88143: NOT
88144: PUSH
88145: LD_VAR 0 4
88149: PPUSH
88150: LD_VAR 0 13
88154: PPUSH
88155: CALL_OW 296
88159: PUSH
88160: LD_INT 40
88162: GREATEREQUAL
88163: AND
88164: PUSH
88165: LD_VAR 0 4
88169: PPUSH
88170: CALL_OW 256
88174: PUSH
88175: LD_INT 650
88177: LESSEQUAL
88178: OR
88179: PUSH
88180: LD_VAR 0 4
88184: PPUSH
88185: LD_EXP 67
88189: PUSH
88190: LD_VAR 0 1
88194: ARRAY
88195: PPUSH
88196: CALL_OW 308
88200: NOT
88201: AND
88202: IFFALSE 88224
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88204: LD_VAR 0 4
88208: PPUSH
88209: LD_EXP 67
88213: PUSH
88214: LD_VAR 0 1
88218: ARRAY
88219: PPUSH
88220: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88224: LD_VAR 0 4
88228: PPUSH
88229: CALL_OW 256
88233: PUSH
88234: LD_INT 1000
88236: LESS
88237: PUSH
88238: LD_VAR 0 4
88242: PPUSH
88243: CALL_OW 263
88247: PUSH
88248: LD_INT 1
88250: EQUAL
88251: AND
88252: PUSH
88253: LD_VAR 0 4
88257: PPUSH
88258: CALL_OW 311
88262: AND
88263: PUSH
88264: LD_VAR 0 4
88268: PPUSH
88269: LD_EXP 67
88273: PUSH
88274: LD_VAR 0 1
88278: ARRAY
88279: PPUSH
88280: CALL_OW 308
88284: AND
88285: IFFALSE 88339
// begin mech := IsDrivenBy ( i ) ;
88287: LD_ADDR_VAR 0 9
88291: PUSH
88292: LD_VAR 0 4
88296: PPUSH
88297: CALL_OW 311
88301: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88302: LD_VAR 0 9
88306: PPUSH
88307: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88311: LD_VAR 0 9
88315: PPUSH
88316: LD_VAR 0 4
88320: PPUSH
88321: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88325: LD_VAR 0 9
88329: PPUSH
88330: LD_VAR 0 4
88334: PPUSH
88335: CALL_OW 180
// end ; end ; unit_human :
88339: GO 88686
88341: LD_INT 1
88343: DOUBLE
88344: EQUAL
88345: IFTRUE 88349
88347: GO 88685
88349: POP
// begin b := IsInUnit ( i ) ;
88350: LD_ADDR_VAR 0 18
88354: PUSH
88355: LD_VAR 0 4
88359: PPUSH
88360: CALL_OW 310
88364: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88365: LD_ADDR_VAR 0 19
88369: PUSH
88370: LD_VAR 0 18
88374: NOT
88375: PUSH
88376: LD_VAR 0 18
88380: PPUSH
88381: CALL_OW 266
88385: PUSH
88386: LD_INT 32
88388: PUSH
88389: LD_INT 31
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: IN
88396: OR
88397: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88398: LD_VAR 0 18
88402: PPUSH
88403: CALL_OW 266
88407: PUSH
88408: LD_INT 5
88410: EQUAL
88411: PUSH
88412: LD_VAR 0 4
88416: PPUSH
88417: CALL_OW 257
88421: PUSH
88422: LD_INT 1
88424: PUSH
88425: LD_INT 2
88427: PUSH
88428: LD_INT 3
88430: PUSH
88431: LD_INT 4
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: IN
88440: AND
88441: IFFALSE 88478
// begin class := AllowSpecClass ( i ) ;
88443: LD_ADDR_VAR 0 20
88447: PUSH
88448: LD_VAR 0 4
88452: PPUSH
88453: CALL 11598 0 1
88457: ST_TO_ADDR
// if class then
88458: LD_VAR 0 20
88462: IFFALSE 88478
// ComChangeProfession ( i , class ) ;
88464: LD_VAR 0 4
88468: PPUSH
88469: LD_VAR 0 20
88473: PPUSH
88474: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88478: LD_VAR 0 16
88482: PUSH
88483: LD_VAR 0 2
88487: PPUSH
88488: LD_INT 21
88490: PUSH
88491: LD_INT 2
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PPUSH
88498: CALL_OW 72
88502: PUSH
88503: LD_INT 1
88505: LESSEQUAL
88506: OR
88507: PUSH
88508: LD_VAR 0 19
88512: AND
88513: PUSH
88514: LD_VAR 0 4
88518: PUSH
88519: LD_VAR 0 17
88523: IN
88524: NOT
88525: AND
88526: IFFALSE 88619
// begin if b then
88528: LD_VAR 0 18
88532: IFFALSE 88581
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88534: LD_VAR 0 18
88538: PPUSH
88539: LD_VAR 0 21
88543: PPUSH
88544: LD_VAR 0 18
88548: PPUSH
88549: CALL_OW 74
88553: PPUSH
88554: CALL_OW 296
88558: PUSH
88559: LD_INT 10
88561: LESS
88562: PUSH
88563: LD_VAR 0 18
88567: PPUSH
88568: CALL_OW 461
88572: PUSH
88573: LD_INT 7
88575: NONEQUAL
88576: AND
88577: IFFALSE 88581
// continue ;
88579: GO 87816
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88581: LD_ADDR_VAR 0 17
88585: PUSH
88586: LD_VAR 0 17
88590: PPUSH
88591: LD_VAR 0 17
88595: PUSH
88596: LD_INT 1
88598: PLUS
88599: PPUSH
88600: LD_VAR 0 4
88604: PPUSH
88605: CALL_OW 1
88609: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88610: LD_VAR 0 4
88614: PPUSH
88615: CALL_OW 122
// end ; if sold_defenders then
88619: LD_VAR 0 17
88623: IFFALSE 88683
// if i in sold_defenders then
88625: LD_VAR 0 4
88629: PUSH
88630: LD_VAR 0 17
88634: IN
88635: IFFALSE 88683
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88637: LD_VAR 0 4
88641: PPUSH
88642: CALL_OW 314
88646: NOT
88647: PUSH
88648: LD_VAR 0 4
88652: PPUSH
88653: LD_VAR 0 13
88657: PPUSH
88658: CALL_OW 296
88662: PUSH
88663: LD_INT 30
88665: LESS
88666: AND
88667: IFFALSE 88683
// ComAttackUnit ( i , e ) ;
88669: LD_VAR 0 4
88673: PPUSH
88674: LD_VAR 0 13
88678: PPUSH
88679: CALL_OW 115
// end ; end ; end ;
88683: GO 88686
88685: POP
// if IsDead ( i ) then
88686: LD_VAR 0 4
88690: PPUSH
88691: CALL_OW 301
88695: IFFALSE 88713
// defenders := defenders diff i ;
88697: LD_ADDR_VAR 0 2
88701: PUSH
88702: LD_VAR 0 2
88706: PUSH
88707: LD_VAR 0 4
88711: DIFF
88712: ST_TO_ADDR
// end ;
88713: GO 87816
88715: POP
88716: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88717: LD_VAR 0 21
88721: NOT
88722: PUSH
88723: LD_VAR 0 2
88727: NOT
88728: OR
88729: PUSH
88730: LD_EXP 43
88734: PUSH
88735: LD_VAR 0 1
88739: ARRAY
88740: NOT
88741: OR
88742: IFFALSE 87720
// MC_Reset ( base , 18 ) ;
88744: LD_VAR 0 1
88748: PPUSH
88749: LD_INT 18
88751: PPUSH
88752: CALL 55418 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88756: LD_ADDR_VAR 0 2
88760: PUSH
88761: LD_VAR 0 2
88765: PUSH
88766: LD_VAR 0 2
88770: PPUSH
88771: LD_INT 2
88773: PUSH
88774: LD_INT 25
88776: PUSH
88777: LD_INT 1
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 25
88786: PUSH
88787: LD_INT 5
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 25
88796: PUSH
88797: LD_INT 8
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 25
88806: PUSH
88807: LD_INT 9
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: PPUSH
88821: CALL_OW 72
88825: DIFF
88826: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88827: LD_VAR 0 21
88831: NOT
88832: PUSH
88833: LD_VAR 0 2
88837: PPUSH
88838: LD_INT 21
88840: PUSH
88841: LD_INT 2
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PPUSH
88848: CALL_OW 72
88852: AND
88853: IFFALSE 89191
// begin tmp := FilterByTag ( defenders , 19 ) ;
88855: LD_ADDR_VAR 0 11
88859: PUSH
88860: LD_VAR 0 2
88864: PPUSH
88865: LD_INT 19
88867: PPUSH
88868: CALL 44829 0 2
88872: ST_TO_ADDR
// if tmp then
88873: LD_VAR 0 11
88877: IFFALSE 88947
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88879: LD_ADDR_VAR 0 11
88883: PUSH
88884: LD_VAR 0 11
88888: PPUSH
88889: LD_INT 25
88891: PUSH
88892: LD_INT 3
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PPUSH
88899: CALL_OW 72
88903: ST_TO_ADDR
// if tmp then
88904: LD_VAR 0 11
88908: IFFALSE 88947
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88910: LD_ADDR_EXP 55
88914: PUSH
88915: LD_EXP 55
88919: PPUSH
88920: LD_VAR 0 1
88924: PPUSH
88925: LD_EXP 55
88929: PUSH
88930: LD_VAR 0 1
88934: ARRAY
88935: PUSH
88936: LD_VAR 0 11
88940: UNION
88941: PPUSH
88942: CALL_OW 1
88946: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88947: LD_VAR 0 1
88951: PPUSH
88952: LD_INT 19
88954: PPUSH
88955: CALL 55418 0 2
// repeat wait ( 0 0$1 ) ;
88959: LD_INT 35
88961: PPUSH
88962: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88966: LD_EXP 43
88970: PUSH
88971: LD_VAR 0 1
88975: ARRAY
88976: NOT
88977: PUSH
88978: LD_EXP 43
88982: PUSH
88983: LD_VAR 0 1
88987: ARRAY
88988: PUSH
88989: EMPTY
88990: EQUAL
88991: OR
88992: IFFALSE 89029
// begin for i in defenders do
88994: LD_ADDR_VAR 0 4
88998: PUSH
88999: LD_VAR 0 2
89003: PUSH
89004: FOR_IN
89005: IFFALSE 89018
// ComStop ( i ) ;
89007: LD_VAR 0 4
89011: PPUSH
89012: CALL_OW 141
89016: GO 89004
89018: POP
89019: POP
// defenders := [ ] ;
89020: LD_ADDR_VAR 0 2
89024: PUSH
89025: EMPTY
89026: ST_TO_ADDR
// exit ;
89027: GO 89255
// end ; for i in defenders do
89029: LD_ADDR_VAR 0 4
89033: PUSH
89034: LD_VAR 0 2
89038: PUSH
89039: FOR_IN
89040: IFFALSE 89129
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89042: LD_VAR 0 4
89046: PPUSH
89047: LD_EXP 67
89051: PUSH
89052: LD_VAR 0 1
89056: ARRAY
89057: PPUSH
89058: CALL_OW 308
89062: NOT
89063: IFFALSE 89087
// ComMoveToArea ( i , mc_parking [ base ] ) else
89065: LD_VAR 0 4
89069: PPUSH
89070: LD_EXP 67
89074: PUSH
89075: LD_VAR 0 1
89079: ARRAY
89080: PPUSH
89081: CALL_OW 113
89085: GO 89127
// if GetControl ( i ) = control_manual then
89087: LD_VAR 0 4
89091: PPUSH
89092: CALL_OW 263
89096: PUSH
89097: LD_INT 1
89099: EQUAL
89100: IFFALSE 89127
// if IsDrivenBy ( i ) then
89102: LD_VAR 0 4
89106: PPUSH
89107: CALL_OW 311
89111: IFFALSE 89127
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89113: LD_VAR 0 4
89117: PPUSH
89118: CALL_OW 311
89122: PPUSH
89123: CALL_OW 121
// end ;
89127: GO 89039
89129: POP
89130: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89131: LD_VAR 0 2
89135: PPUSH
89136: LD_INT 95
89138: PUSH
89139: LD_EXP 67
89143: PUSH
89144: LD_VAR 0 1
89148: ARRAY
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PPUSH
89154: CALL_OW 72
89158: PUSH
89159: LD_VAR 0 2
89163: EQUAL
89164: PUSH
89165: LD_EXP 66
89169: PUSH
89170: LD_VAR 0 1
89174: ARRAY
89175: OR
89176: PUSH
89177: LD_EXP 43
89181: PUSH
89182: LD_VAR 0 1
89186: ARRAY
89187: NOT
89188: OR
89189: IFFALSE 88959
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89191: LD_ADDR_EXP 65
89195: PUSH
89196: LD_EXP 65
89200: PPUSH
89201: LD_VAR 0 1
89205: PPUSH
89206: LD_VAR 0 2
89210: PPUSH
89211: LD_INT 21
89213: PUSH
89214: LD_INT 2
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PPUSH
89221: CALL_OW 72
89225: PPUSH
89226: CALL_OW 1
89230: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89231: LD_VAR 0 1
89235: PPUSH
89236: LD_INT 19
89238: PPUSH
89239: CALL 55418 0 2
// MC_Reset ( base , 20 ) ;
89243: LD_VAR 0 1
89247: PPUSH
89248: LD_INT 20
89250: PPUSH
89251: CALL 55418 0 2
// end ; end_of_file
89255: LD_VAR 0 3
89259: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89260: LD_INT 0
89262: PPUSH
89263: PPUSH
89264: PPUSH
89265: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89266: LD_VAR 0 1
89270: PPUSH
89271: CALL_OW 264
89275: PUSH
89276: LD_INT 91
89278: EQUAL
89279: IFFALSE 89351
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89281: LD_INT 68
89283: PPUSH
89284: LD_VAR 0 1
89288: PPUSH
89289: CALL_OW 255
89293: PPUSH
89294: CALL_OW 321
89298: PUSH
89299: LD_INT 2
89301: EQUAL
89302: IFFALSE 89314
// eff := 70 else
89304: LD_ADDR_VAR 0 4
89308: PUSH
89309: LD_INT 70
89311: ST_TO_ADDR
89312: GO 89322
// eff := 30 ;
89314: LD_ADDR_VAR 0 4
89318: PUSH
89319: LD_INT 30
89321: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89322: LD_VAR 0 1
89326: PPUSH
89327: CALL_OW 250
89331: PPUSH
89332: LD_VAR 0 1
89336: PPUSH
89337: CALL_OW 251
89341: PPUSH
89342: LD_VAR 0 4
89346: PPUSH
89347: CALL_OW 495
// end ; end ;
89351: LD_VAR 0 2
89355: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89356: LD_INT 0
89358: PPUSH
// end ;
89359: LD_VAR 0 4
89363: RET
// export function SOS_Command ( cmd ) ; begin
89364: LD_INT 0
89366: PPUSH
// end ;
89367: LD_VAR 0 2
89371: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89372: LD_INT 0
89374: PPUSH
// end ;
89375: LD_VAR 0 6
89379: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89380: LD_INT 0
89382: PPUSH
89383: PPUSH
// if not vehicle or not factory then
89384: LD_VAR 0 1
89388: NOT
89389: PUSH
89390: LD_VAR 0 2
89394: NOT
89395: OR
89396: IFFALSE 89400
// exit ;
89398: GO 89631
// if factoryWaypoints >= factory then
89400: LD_EXP 157
89404: PUSH
89405: LD_VAR 0 2
89409: GREATEREQUAL
89410: IFFALSE 89631
// if factoryWaypoints [ factory ] then
89412: LD_EXP 157
89416: PUSH
89417: LD_VAR 0 2
89421: ARRAY
89422: IFFALSE 89631
// begin if GetControl ( vehicle ) = control_manual then
89424: LD_VAR 0 1
89428: PPUSH
89429: CALL_OW 263
89433: PUSH
89434: LD_INT 1
89436: EQUAL
89437: IFFALSE 89518
// begin driver := IsDrivenBy ( vehicle ) ;
89439: LD_ADDR_VAR 0 4
89443: PUSH
89444: LD_VAR 0 1
89448: PPUSH
89449: CALL_OW 311
89453: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89454: LD_VAR 0 4
89458: PPUSH
89459: LD_EXP 157
89463: PUSH
89464: LD_VAR 0 2
89468: ARRAY
89469: PUSH
89470: LD_INT 3
89472: ARRAY
89473: PPUSH
89474: LD_EXP 157
89478: PUSH
89479: LD_VAR 0 2
89483: ARRAY
89484: PUSH
89485: LD_INT 4
89487: ARRAY
89488: PPUSH
89489: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89493: LD_VAR 0 4
89497: PPUSH
89498: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89502: LD_VAR 0 4
89506: PPUSH
89507: LD_VAR 0 2
89511: PPUSH
89512: CALL_OW 180
// end else
89516: GO 89631
// if GetControl ( vehicle ) = control_remote then
89518: LD_VAR 0 1
89522: PPUSH
89523: CALL_OW 263
89527: PUSH
89528: LD_INT 2
89530: EQUAL
89531: IFFALSE 89592
// begin wait ( 0 0$2 ) ;
89533: LD_INT 70
89535: PPUSH
89536: CALL_OW 67
// if Connect ( vehicle ) then
89540: LD_VAR 0 1
89544: PPUSH
89545: CALL 17886 0 1
89549: IFFALSE 89590
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89551: LD_VAR 0 1
89555: PPUSH
89556: LD_EXP 157
89560: PUSH
89561: LD_VAR 0 2
89565: ARRAY
89566: PUSH
89567: LD_INT 3
89569: ARRAY
89570: PPUSH
89571: LD_EXP 157
89575: PUSH
89576: LD_VAR 0 2
89580: ARRAY
89581: PUSH
89582: LD_INT 4
89584: ARRAY
89585: PPUSH
89586: CALL_OW 171
// end else
89590: GO 89631
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89592: LD_VAR 0 1
89596: PPUSH
89597: LD_EXP 157
89601: PUSH
89602: LD_VAR 0 2
89606: ARRAY
89607: PUSH
89608: LD_INT 3
89610: ARRAY
89611: PPUSH
89612: LD_EXP 157
89616: PUSH
89617: LD_VAR 0 2
89621: ARRAY
89622: PUSH
89623: LD_INT 4
89625: ARRAY
89626: PPUSH
89627: CALL_OW 171
// end ; end ;
89631: LD_VAR 0 3
89635: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89636: LD_INT 0
89638: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89639: LD_VAR 0 1
89643: PUSH
89644: LD_INT 250
89646: EQUAL
89647: PUSH
89648: LD_VAR 0 2
89652: PPUSH
89653: CALL_OW 264
89657: PUSH
89658: LD_INT 81
89660: EQUAL
89661: AND
89662: IFFALSE 89683
// MinerPlaceMine ( unit , x , y ) ;
89664: LD_VAR 0 2
89668: PPUSH
89669: LD_VAR 0 4
89673: PPUSH
89674: LD_VAR 0 5
89678: PPUSH
89679: CALL 92068 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89683: LD_VAR 0 1
89687: PUSH
89688: LD_INT 251
89690: EQUAL
89691: PUSH
89692: LD_VAR 0 2
89696: PPUSH
89697: CALL_OW 264
89701: PUSH
89702: LD_INT 81
89704: EQUAL
89705: AND
89706: IFFALSE 89727
// MinerDetonateMine ( unit , x , y ) ;
89708: LD_VAR 0 2
89712: PPUSH
89713: LD_VAR 0 4
89717: PPUSH
89718: LD_VAR 0 5
89722: PPUSH
89723: CALL 92343 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89727: LD_VAR 0 1
89731: PUSH
89732: LD_INT 252
89734: EQUAL
89735: PUSH
89736: LD_VAR 0 2
89740: PPUSH
89741: CALL_OW 264
89745: PUSH
89746: LD_INT 81
89748: EQUAL
89749: AND
89750: IFFALSE 89771
// MinerCreateMinefield ( unit , x , y ) ;
89752: LD_VAR 0 2
89756: PPUSH
89757: LD_VAR 0 4
89761: PPUSH
89762: LD_VAR 0 5
89766: PPUSH
89767: CALL 92760 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89771: LD_VAR 0 1
89775: PUSH
89776: LD_INT 253
89778: EQUAL
89779: PUSH
89780: LD_VAR 0 2
89784: PPUSH
89785: CALL_OW 257
89789: PUSH
89790: LD_INT 5
89792: EQUAL
89793: AND
89794: IFFALSE 89815
// ComBinocular ( unit , x , y ) ;
89796: LD_VAR 0 2
89800: PPUSH
89801: LD_VAR 0 4
89805: PPUSH
89806: LD_VAR 0 5
89810: PPUSH
89811: CALL 93129 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89815: LD_VAR 0 1
89819: PUSH
89820: LD_INT 254
89822: EQUAL
89823: PUSH
89824: LD_VAR 0 2
89828: PPUSH
89829: CALL_OW 264
89833: PUSH
89834: LD_INT 99
89836: EQUAL
89837: AND
89838: PUSH
89839: LD_VAR 0 3
89843: PPUSH
89844: CALL_OW 263
89848: PUSH
89849: LD_INT 3
89851: EQUAL
89852: AND
89853: IFFALSE 89869
// HackDestroyVehicle ( unit , selectedUnit ) ;
89855: LD_VAR 0 2
89859: PPUSH
89860: LD_VAR 0 3
89864: PPUSH
89865: CALL 91432 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89869: LD_VAR 0 1
89873: PUSH
89874: LD_INT 255
89876: EQUAL
89877: PUSH
89878: LD_VAR 0 2
89882: PPUSH
89883: CALL_OW 264
89887: PUSH
89888: LD_INT 14
89890: PUSH
89891: LD_INT 53
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: IN
89898: AND
89899: PUSH
89900: LD_VAR 0 4
89904: PPUSH
89905: LD_VAR 0 5
89909: PPUSH
89910: CALL_OW 488
89914: AND
89915: IFFALSE 89939
// CutTreeXYR ( unit , x , y , 12 ) ;
89917: LD_VAR 0 2
89921: PPUSH
89922: LD_VAR 0 4
89926: PPUSH
89927: LD_VAR 0 5
89931: PPUSH
89932: LD_INT 12
89934: PPUSH
89935: CALL 90002 0 4
// if cmd = 256 then
89939: LD_VAR 0 1
89943: PUSH
89944: LD_INT 256
89946: EQUAL
89947: IFFALSE 89968
// SetFactoryWaypoint ( unit , x , y ) ;
89949: LD_VAR 0 2
89953: PPUSH
89954: LD_VAR 0 4
89958: PPUSH
89959: LD_VAR 0 5
89963: PPUSH
89964: CALL 108195 0 3
// if cmd = 257 then
89968: LD_VAR 0 1
89972: PUSH
89973: LD_INT 257
89975: EQUAL
89976: IFFALSE 89997
// SetWarehouseGatheringPoint ( unit , x , y ) ;
89978: LD_VAR 0 2
89982: PPUSH
89983: LD_VAR 0 4
89987: PPUSH
89988: LD_VAR 0 5
89992: PPUSH
89993: CALL 108557 0 3
// end ;
89997: LD_VAR 0 6
90001: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90002: LD_INT 0
90004: PPUSH
90005: PPUSH
90006: PPUSH
90007: PPUSH
90008: PPUSH
90009: PPUSH
90010: PPUSH
90011: PPUSH
90012: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90013: LD_VAR 0 1
90017: NOT
90018: PUSH
90019: LD_VAR 0 2
90023: PPUSH
90024: LD_VAR 0 3
90028: PPUSH
90029: CALL_OW 488
90033: NOT
90034: OR
90035: PUSH
90036: LD_VAR 0 4
90040: NOT
90041: OR
90042: IFFALSE 90046
// exit ;
90044: GO 90386
// list := [ ] ;
90046: LD_ADDR_VAR 0 13
90050: PUSH
90051: EMPTY
90052: ST_TO_ADDR
// if x - r < 0 then
90053: LD_VAR 0 2
90057: PUSH
90058: LD_VAR 0 4
90062: MINUS
90063: PUSH
90064: LD_INT 0
90066: LESS
90067: IFFALSE 90079
// min_x := 0 else
90069: LD_ADDR_VAR 0 7
90073: PUSH
90074: LD_INT 0
90076: ST_TO_ADDR
90077: GO 90095
// min_x := x - r ;
90079: LD_ADDR_VAR 0 7
90083: PUSH
90084: LD_VAR 0 2
90088: PUSH
90089: LD_VAR 0 4
90093: MINUS
90094: ST_TO_ADDR
// if y - r < 0 then
90095: LD_VAR 0 3
90099: PUSH
90100: LD_VAR 0 4
90104: MINUS
90105: PUSH
90106: LD_INT 0
90108: LESS
90109: IFFALSE 90121
// min_y := 0 else
90111: LD_ADDR_VAR 0 8
90115: PUSH
90116: LD_INT 0
90118: ST_TO_ADDR
90119: GO 90137
// min_y := y - r ;
90121: LD_ADDR_VAR 0 8
90125: PUSH
90126: LD_VAR 0 3
90130: PUSH
90131: LD_VAR 0 4
90135: MINUS
90136: ST_TO_ADDR
// max_x := x + r ;
90137: LD_ADDR_VAR 0 9
90141: PUSH
90142: LD_VAR 0 2
90146: PUSH
90147: LD_VAR 0 4
90151: PLUS
90152: ST_TO_ADDR
// max_y := y + r ;
90153: LD_ADDR_VAR 0 10
90157: PUSH
90158: LD_VAR 0 3
90162: PUSH
90163: LD_VAR 0 4
90167: PLUS
90168: ST_TO_ADDR
// for _x = min_x to max_x do
90169: LD_ADDR_VAR 0 11
90173: PUSH
90174: DOUBLE
90175: LD_VAR 0 7
90179: DEC
90180: ST_TO_ADDR
90181: LD_VAR 0 9
90185: PUSH
90186: FOR_TO
90187: IFFALSE 90304
// for _y = min_y to max_y do
90189: LD_ADDR_VAR 0 12
90193: PUSH
90194: DOUBLE
90195: LD_VAR 0 8
90199: DEC
90200: ST_TO_ADDR
90201: LD_VAR 0 10
90205: PUSH
90206: FOR_TO
90207: IFFALSE 90300
// begin if not ValidHex ( _x , _y ) then
90209: LD_VAR 0 11
90213: PPUSH
90214: LD_VAR 0 12
90218: PPUSH
90219: CALL_OW 488
90223: NOT
90224: IFFALSE 90228
// continue ;
90226: GO 90206
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90228: LD_VAR 0 11
90232: PPUSH
90233: LD_VAR 0 12
90237: PPUSH
90238: CALL_OW 351
90242: PUSH
90243: LD_VAR 0 11
90247: PPUSH
90248: LD_VAR 0 12
90252: PPUSH
90253: CALL_OW 554
90257: AND
90258: IFFALSE 90298
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90260: LD_ADDR_VAR 0 13
90264: PUSH
90265: LD_VAR 0 13
90269: PPUSH
90270: LD_VAR 0 13
90274: PUSH
90275: LD_INT 1
90277: PLUS
90278: PPUSH
90279: LD_VAR 0 11
90283: PUSH
90284: LD_VAR 0 12
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PPUSH
90293: CALL_OW 2
90297: ST_TO_ADDR
// end ;
90298: GO 90206
90300: POP
90301: POP
90302: GO 90186
90304: POP
90305: POP
// if not list then
90306: LD_VAR 0 13
90310: NOT
90311: IFFALSE 90315
// exit ;
90313: GO 90386
// for i in list do
90315: LD_ADDR_VAR 0 6
90319: PUSH
90320: LD_VAR 0 13
90324: PUSH
90325: FOR_IN
90326: IFFALSE 90384
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90328: LD_VAR 0 1
90332: PPUSH
90333: LD_STRING M
90335: PUSH
90336: LD_VAR 0 6
90340: PUSH
90341: LD_INT 1
90343: ARRAY
90344: PUSH
90345: LD_VAR 0 6
90349: PUSH
90350: LD_INT 2
90352: ARRAY
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: LD_INT 0
90359: PUSH
90360: LD_INT 0
90362: PUSH
90363: LD_INT 0
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: PUSH
90375: EMPTY
90376: LIST
90377: PPUSH
90378: CALL_OW 447
90382: GO 90325
90384: POP
90385: POP
// end ;
90386: LD_VAR 0 5
90390: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90391: LD_EXP 88
90395: NOT
90396: IFFALSE 90446
90398: GO 90400
90400: DISABLE
// begin initHack := true ;
90401: LD_ADDR_EXP 88
90405: PUSH
90406: LD_INT 1
90408: ST_TO_ADDR
// hackTanks := [ ] ;
90409: LD_ADDR_EXP 89
90413: PUSH
90414: EMPTY
90415: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90416: LD_ADDR_EXP 90
90420: PUSH
90421: EMPTY
90422: ST_TO_ADDR
// hackLimit := 3 ;
90423: LD_ADDR_EXP 91
90427: PUSH
90428: LD_INT 3
90430: ST_TO_ADDR
// hackDist := 12 ;
90431: LD_ADDR_EXP 92
90435: PUSH
90436: LD_INT 12
90438: ST_TO_ADDR
// hackCounter := [ ] ;
90439: LD_ADDR_EXP 93
90443: PUSH
90444: EMPTY
90445: ST_TO_ADDR
// end ;
90446: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90447: LD_EXP 88
90451: PUSH
90452: LD_INT 34
90454: PUSH
90455: LD_INT 99
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PPUSH
90462: CALL_OW 69
90466: AND
90467: IFFALSE 90720
90469: GO 90471
90471: DISABLE
90472: LD_INT 0
90474: PPUSH
90475: PPUSH
// begin enable ;
90476: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90477: LD_ADDR_VAR 0 1
90481: PUSH
90482: LD_INT 34
90484: PUSH
90485: LD_INT 99
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PPUSH
90492: CALL_OW 69
90496: PUSH
90497: FOR_IN
90498: IFFALSE 90718
// begin if not i in hackTanks then
90500: LD_VAR 0 1
90504: PUSH
90505: LD_EXP 89
90509: IN
90510: NOT
90511: IFFALSE 90594
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90513: LD_ADDR_EXP 89
90517: PUSH
90518: LD_EXP 89
90522: PPUSH
90523: LD_EXP 89
90527: PUSH
90528: LD_INT 1
90530: PLUS
90531: PPUSH
90532: LD_VAR 0 1
90536: PPUSH
90537: CALL_OW 1
90541: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90542: LD_ADDR_EXP 90
90546: PUSH
90547: LD_EXP 90
90551: PPUSH
90552: LD_EXP 90
90556: PUSH
90557: LD_INT 1
90559: PLUS
90560: PPUSH
90561: EMPTY
90562: PPUSH
90563: CALL_OW 1
90567: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90568: LD_ADDR_EXP 93
90572: PUSH
90573: LD_EXP 93
90577: PPUSH
90578: LD_EXP 93
90582: PUSH
90583: LD_INT 1
90585: PLUS
90586: PPUSH
90587: EMPTY
90588: PPUSH
90589: CALL_OW 1
90593: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90594: LD_VAR 0 1
90598: PPUSH
90599: CALL_OW 302
90603: NOT
90604: IFFALSE 90617
// begin HackUnlinkAll ( i ) ;
90606: LD_VAR 0 1
90610: PPUSH
90611: CALL 90723 0 1
// continue ;
90615: GO 90497
// end ; HackCheckCapturedStatus ( i ) ;
90617: LD_VAR 0 1
90621: PPUSH
90622: CALL 91166 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90626: LD_ADDR_VAR 0 2
90630: PUSH
90631: LD_INT 81
90633: PUSH
90634: LD_VAR 0 1
90638: PPUSH
90639: CALL_OW 255
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 33
90650: PUSH
90651: LD_INT 3
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 91
90660: PUSH
90661: LD_VAR 0 1
90665: PUSH
90666: LD_EXP 92
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 50
90678: PUSH
90679: EMPTY
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: PPUSH
90688: CALL_OW 69
90692: ST_TO_ADDR
// if not tmp then
90693: LD_VAR 0 2
90697: NOT
90698: IFFALSE 90702
// continue ;
90700: GO 90497
// HackLink ( i , tmp ) ;
90702: LD_VAR 0 1
90706: PPUSH
90707: LD_VAR 0 2
90711: PPUSH
90712: CALL 90859 0 2
// end ;
90716: GO 90497
90718: POP
90719: POP
// end ;
90720: PPOPN 2
90722: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90723: LD_INT 0
90725: PPUSH
90726: PPUSH
90727: PPUSH
// if not hack in hackTanks then
90728: LD_VAR 0 1
90732: PUSH
90733: LD_EXP 89
90737: IN
90738: NOT
90739: IFFALSE 90743
// exit ;
90741: GO 90854
// index := GetElementIndex ( hackTanks , hack ) ;
90743: LD_ADDR_VAR 0 4
90747: PUSH
90748: LD_EXP 89
90752: PPUSH
90753: LD_VAR 0 1
90757: PPUSH
90758: CALL 14702 0 2
90762: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90763: LD_EXP 90
90767: PUSH
90768: LD_VAR 0 4
90772: ARRAY
90773: IFFALSE 90854
// begin for i in hackTanksCaptured [ index ] do
90775: LD_ADDR_VAR 0 3
90779: PUSH
90780: LD_EXP 90
90784: PUSH
90785: LD_VAR 0 4
90789: ARRAY
90790: PUSH
90791: FOR_IN
90792: IFFALSE 90818
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90794: LD_VAR 0 3
90798: PUSH
90799: LD_INT 1
90801: ARRAY
90802: PPUSH
90803: LD_VAR 0 3
90807: PUSH
90808: LD_INT 2
90810: ARRAY
90811: PPUSH
90812: CALL_OW 235
90816: GO 90791
90818: POP
90819: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90820: LD_ADDR_EXP 90
90824: PUSH
90825: LD_EXP 90
90829: PPUSH
90830: LD_VAR 0 4
90834: PPUSH
90835: EMPTY
90836: PPUSH
90837: CALL_OW 1
90841: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90842: LD_VAR 0 1
90846: PPUSH
90847: LD_INT 0
90849: PPUSH
90850: CALL_OW 505
// end ; end ;
90854: LD_VAR 0 2
90858: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90859: LD_INT 0
90861: PPUSH
90862: PPUSH
90863: PPUSH
// if not hack in hackTanks or not vehicles then
90864: LD_VAR 0 1
90868: PUSH
90869: LD_EXP 89
90873: IN
90874: NOT
90875: PUSH
90876: LD_VAR 0 2
90880: NOT
90881: OR
90882: IFFALSE 90886
// exit ;
90884: GO 91161
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90886: LD_ADDR_VAR 0 2
90890: PUSH
90891: LD_VAR 0 1
90895: PPUSH
90896: LD_VAR 0 2
90900: PPUSH
90901: LD_INT 1
90903: PPUSH
90904: LD_INT 1
90906: PPUSH
90907: CALL 15352 0 4
90911: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90912: LD_ADDR_VAR 0 5
90916: PUSH
90917: LD_EXP 89
90921: PPUSH
90922: LD_VAR 0 1
90926: PPUSH
90927: CALL 14702 0 2
90931: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90932: LD_EXP 90
90936: PUSH
90937: LD_VAR 0 5
90941: ARRAY
90942: PUSH
90943: LD_EXP 91
90947: LESS
90948: IFFALSE 91137
// begin for i := 1 to vehicles do
90950: LD_ADDR_VAR 0 4
90954: PUSH
90955: DOUBLE
90956: LD_INT 1
90958: DEC
90959: ST_TO_ADDR
90960: LD_VAR 0 2
90964: PUSH
90965: FOR_TO
90966: IFFALSE 91135
// begin if hackTanksCaptured [ index ] = hackLimit then
90968: LD_EXP 90
90972: PUSH
90973: LD_VAR 0 5
90977: ARRAY
90978: PUSH
90979: LD_EXP 91
90983: EQUAL
90984: IFFALSE 90988
// break ;
90986: GO 91135
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90988: LD_ADDR_EXP 93
90992: PUSH
90993: LD_EXP 93
90997: PPUSH
90998: LD_VAR 0 5
91002: PPUSH
91003: LD_EXP 93
91007: PUSH
91008: LD_VAR 0 5
91012: ARRAY
91013: PUSH
91014: LD_INT 1
91016: PLUS
91017: PPUSH
91018: CALL_OW 1
91022: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91023: LD_ADDR_EXP 90
91027: PUSH
91028: LD_EXP 90
91032: PPUSH
91033: LD_VAR 0 5
91037: PUSH
91038: LD_EXP 90
91042: PUSH
91043: LD_VAR 0 5
91047: ARRAY
91048: PUSH
91049: LD_INT 1
91051: PLUS
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PPUSH
91057: LD_VAR 0 2
91061: PUSH
91062: LD_VAR 0 4
91066: ARRAY
91067: PUSH
91068: LD_VAR 0 2
91072: PUSH
91073: LD_VAR 0 4
91077: ARRAY
91078: PPUSH
91079: CALL_OW 255
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PPUSH
91088: CALL 14917 0 3
91092: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91093: LD_VAR 0 2
91097: PUSH
91098: LD_VAR 0 4
91102: ARRAY
91103: PPUSH
91104: LD_VAR 0 1
91108: PPUSH
91109: CALL_OW 255
91113: PPUSH
91114: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91118: LD_VAR 0 2
91122: PUSH
91123: LD_VAR 0 4
91127: ARRAY
91128: PPUSH
91129: CALL_OW 141
// end ;
91133: GO 90965
91135: POP
91136: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91137: LD_VAR 0 1
91141: PPUSH
91142: LD_EXP 90
91146: PUSH
91147: LD_VAR 0 5
91151: ARRAY
91152: PUSH
91153: LD_INT 0
91155: PLUS
91156: PPUSH
91157: CALL_OW 505
// end ;
91161: LD_VAR 0 3
91165: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91166: LD_INT 0
91168: PPUSH
91169: PPUSH
91170: PPUSH
91171: PPUSH
// if not hack in hackTanks then
91172: LD_VAR 0 1
91176: PUSH
91177: LD_EXP 89
91181: IN
91182: NOT
91183: IFFALSE 91187
// exit ;
91185: GO 91427
// index := GetElementIndex ( hackTanks , hack ) ;
91187: LD_ADDR_VAR 0 4
91191: PUSH
91192: LD_EXP 89
91196: PPUSH
91197: LD_VAR 0 1
91201: PPUSH
91202: CALL 14702 0 2
91206: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91207: LD_ADDR_VAR 0 3
91211: PUSH
91212: DOUBLE
91213: LD_EXP 90
91217: PUSH
91218: LD_VAR 0 4
91222: ARRAY
91223: INC
91224: ST_TO_ADDR
91225: LD_INT 1
91227: PUSH
91228: FOR_DOWNTO
91229: IFFALSE 91401
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91231: LD_ADDR_VAR 0 5
91235: PUSH
91236: LD_EXP 90
91240: PUSH
91241: LD_VAR 0 4
91245: ARRAY
91246: PUSH
91247: LD_VAR 0 3
91251: ARRAY
91252: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91253: LD_VAR 0 5
91257: PUSH
91258: LD_INT 1
91260: ARRAY
91261: PPUSH
91262: CALL_OW 302
91266: NOT
91267: PUSH
91268: LD_VAR 0 5
91272: PUSH
91273: LD_INT 1
91275: ARRAY
91276: PPUSH
91277: CALL_OW 255
91281: PUSH
91282: LD_VAR 0 1
91286: PPUSH
91287: CALL_OW 255
91291: NONEQUAL
91292: OR
91293: IFFALSE 91399
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91295: LD_VAR 0 5
91299: PUSH
91300: LD_INT 1
91302: ARRAY
91303: PPUSH
91304: CALL_OW 305
91308: PUSH
91309: LD_VAR 0 5
91313: PUSH
91314: LD_INT 1
91316: ARRAY
91317: PPUSH
91318: CALL_OW 255
91322: PUSH
91323: LD_VAR 0 1
91327: PPUSH
91328: CALL_OW 255
91332: EQUAL
91333: AND
91334: IFFALSE 91358
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91336: LD_VAR 0 5
91340: PUSH
91341: LD_INT 1
91343: ARRAY
91344: PPUSH
91345: LD_VAR 0 5
91349: PUSH
91350: LD_INT 2
91352: ARRAY
91353: PPUSH
91354: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91358: LD_ADDR_EXP 90
91362: PUSH
91363: LD_EXP 90
91367: PPUSH
91368: LD_VAR 0 4
91372: PPUSH
91373: LD_EXP 90
91377: PUSH
91378: LD_VAR 0 4
91382: ARRAY
91383: PPUSH
91384: LD_VAR 0 3
91388: PPUSH
91389: CALL_OW 3
91393: PPUSH
91394: CALL_OW 1
91398: ST_TO_ADDR
// end ; end ;
91399: GO 91228
91401: POP
91402: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91403: LD_VAR 0 1
91407: PPUSH
91408: LD_EXP 90
91412: PUSH
91413: LD_VAR 0 4
91417: ARRAY
91418: PUSH
91419: LD_INT 0
91421: PLUS
91422: PPUSH
91423: CALL_OW 505
// end ;
91427: LD_VAR 0 2
91431: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91432: LD_INT 0
91434: PPUSH
91435: PPUSH
91436: PPUSH
91437: PPUSH
// if not hack in hackTanks then
91438: LD_VAR 0 1
91442: PUSH
91443: LD_EXP 89
91447: IN
91448: NOT
91449: IFFALSE 91453
// exit ;
91451: GO 91538
// index := GetElementIndex ( hackTanks , hack ) ;
91453: LD_ADDR_VAR 0 5
91457: PUSH
91458: LD_EXP 89
91462: PPUSH
91463: LD_VAR 0 1
91467: PPUSH
91468: CALL 14702 0 2
91472: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91473: LD_ADDR_VAR 0 4
91477: PUSH
91478: DOUBLE
91479: LD_INT 1
91481: DEC
91482: ST_TO_ADDR
91483: LD_EXP 90
91487: PUSH
91488: LD_VAR 0 5
91492: ARRAY
91493: PUSH
91494: FOR_TO
91495: IFFALSE 91536
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91497: LD_EXP 90
91501: PUSH
91502: LD_VAR 0 5
91506: ARRAY
91507: PUSH
91508: LD_VAR 0 4
91512: ARRAY
91513: PUSH
91514: LD_INT 1
91516: ARRAY
91517: PUSH
91518: LD_VAR 0 2
91522: EQUAL
91523: IFFALSE 91534
// KillUnit ( vehicle ) ;
91525: LD_VAR 0 2
91529: PPUSH
91530: CALL_OW 66
91534: GO 91494
91536: POP
91537: POP
// end ;
91538: LD_VAR 0 3
91542: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91543: LD_EXP 94
91547: NOT
91548: IFFALSE 91583
91550: GO 91552
91552: DISABLE
// begin initMiner := true ;
91553: LD_ADDR_EXP 94
91557: PUSH
91558: LD_INT 1
91560: ST_TO_ADDR
// minersList := [ ] ;
91561: LD_ADDR_EXP 95
91565: PUSH
91566: EMPTY
91567: ST_TO_ADDR
// minerMinesList := [ ] ;
91568: LD_ADDR_EXP 96
91572: PUSH
91573: EMPTY
91574: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91575: LD_ADDR_EXP 97
91579: PUSH
91580: LD_INT 5
91582: ST_TO_ADDR
// end ;
91583: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91584: LD_EXP 94
91588: PUSH
91589: LD_INT 34
91591: PUSH
91592: LD_INT 81
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: PPUSH
91599: CALL_OW 69
91603: AND
91604: IFFALSE 92065
91606: GO 91608
91608: DISABLE
91609: LD_INT 0
91611: PPUSH
91612: PPUSH
91613: PPUSH
91614: PPUSH
// begin enable ;
91615: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91616: LD_ADDR_VAR 0 1
91620: PUSH
91621: LD_INT 34
91623: PUSH
91624: LD_INT 81
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PPUSH
91631: CALL_OW 69
91635: PUSH
91636: FOR_IN
91637: IFFALSE 91709
// begin if not i in minersList then
91639: LD_VAR 0 1
91643: PUSH
91644: LD_EXP 95
91648: IN
91649: NOT
91650: IFFALSE 91707
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91652: LD_ADDR_EXP 95
91656: PUSH
91657: LD_EXP 95
91661: PPUSH
91662: LD_EXP 95
91666: PUSH
91667: LD_INT 1
91669: PLUS
91670: PPUSH
91671: LD_VAR 0 1
91675: PPUSH
91676: CALL_OW 1
91680: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91681: LD_ADDR_EXP 96
91685: PUSH
91686: LD_EXP 96
91690: PPUSH
91691: LD_EXP 96
91695: PUSH
91696: LD_INT 1
91698: PLUS
91699: PPUSH
91700: EMPTY
91701: PPUSH
91702: CALL_OW 1
91706: ST_TO_ADDR
// end end ;
91707: GO 91636
91709: POP
91710: POP
// for i := minerMinesList downto 1 do
91711: LD_ADDR_VAR 0 1
91715: PUSH
91716: DOUBLE
91717: LD_EXP 96
91721: INC
91722: ST_TO_ADDR
91723: LD_INT 1
91725: PUSH
91726: FOR_DOWNTO
91727: IFFALSE 92063
// begin if IsLive ( minersList [ i ] ) then
91729: LD_EXP 95
91733: PUSH
91734: LD_VAR 0 1
91738: ARRAY
91739: PPUSH
91740: CALL_OW 300
91744: IFFALSE 91772
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91746: LD_EXP 95
91750: PUSH
91751: LD_VAR 0 1
91755: ARRAY
91756: PPUSH
91757: LD_EXP 96
91761: PUSH
91762: LD_VAR 0 1
91766: ARRAY
91767: PPUSH
91768: CALL_OW 505
// if not minerMinesList [ i ] then
91772: LD_EXP 96
91776: PUSH
91777: LD_VAR 0 1
91781: ARRAY
91782: NOT
91783: IFFALSE 91787
// continue ;
91785: GO 91726
// for j := minerMinesList [ i ] downto 1 do
91787: LD_ADDR_VAR 0 2
91791: PUSH
91792: DOUBLE
91793: LD_EXP 96
91797: PUSH
91798: LD_VAR 0 1
91802: ARRAY
91803: INC
91804: ST_TO_ADDR
91805: LD_INT 1
91807: PUSH
91808: FOR_DOWNTO
91809: IFFALSE 92059
// begin side := GetSide ( minersList [ i ] ) ;
91811: LD_ADDR_VAR 0 3
91815: PUSH
91816: LD_EXP 95
91820: PUSH
91821: LD_VAR 0 1
91825: ARRAY
91826: PPUSH
91827: CALL_OW 255
91831: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91832: LD_ADDR_VAR 0 4
91836: PUSH
91837: LD_EXP 96
91841: PUSH
91842: LD_VAR 0 1
91846: ARRAY
91847: PUSH
91848: LD_VAR 0 2
91852: ARRAY
91853: PUSH
91854: LD_INT 1
91856: ARRAY
91857: PPUSH
91858: LD_EXP 96
91862: PUSH
91863: LD_VAR 0 1
91867: ARRAY
91868: PUSH
91869: LD_VAR 0 2
91873: ARRAY
91874: PUSH
91875: LD_INT 2
91877: ARRAY
91878: PPUSH
91879: CALL_OW 428
91883: ST_TO_ADDR
// if not tmp then
91884: LD_VAR 0 4
91888: NOT
91889: IFFALSE 91893
// continue ;
91891: GO 91808
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91893: LD_VAR 0 4
91897: PUSH
91898: LD_INT 81
91900: PUSH
91901: LD_VAR 0 3
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PPUSH
91910: CALL_OW 69
91914: IN
91915: PUSH
91916: LD_EXP 96
91920: PUSH
91921: LD_VAR 0 1
91925: ARRAY
91926: PUSH
91927: LD_VAR 0 2
91931: ARRAY
91932: PUSH
91933: LD_INT 1
91935: ARRAY
91936: PPUSH
91937: LD_EXP 96
91941: PUSH
91942: LD_VAR 0 1
91946: ARRAY
91947: PUSH
91948: LD_VAR 0 2
91952: ARRAY
91953: PUSH
91954: LD_INT 2
91956: ARRAY
91957: PPUSH
91958: CALL_OW 458
91962: AND
91963: IFFALSE 92057
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91965: LD_EXP 96
91969: PUSH
91970: LD_VAR 0 1
91974: ARRAY
91975: PUSH
91976: LD_VAR 0 2
91980: ARRAY
91981: PUSH
91982: LD_INT 1
91984: ARRAY
91985: PPUSH
91986: LD_EXP 96
91990: PUSH
91991: LD_VAR 0 1
91995: ARRAY
91996: PUSH
91997: LD_VAR 0 2
92001: ARRAY
92002: PUSH
92003: LD_INT 2
92005: ARRAY
92006: PPUSH
92007: LD_VAR 0 3
92011: PPUSH
92012: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92016: LD_ADDR_EXP 96
92020: PUSH
92021: LD_EXP 96
92025: PPUSH
92026: LD_VAR 0 1
92030: PPUSH
92031: LD_EXP 96
92035: PUSH
92036: LD_VAR 0 1
92040: ARRAY
92041: PPUSH
92042: LD_VAR 0 2
92046: PPUSH
92047: CALL_OW 3
92051: PPUSH
92052: CALL_OW 1
92056: ST_TO_ADDR
// end ; end ;
92057: GO 91808
92059: POP
92060: POP
// end ;
92061: GO 91726
92063: POP
92064: POP
// end ;
92065: PPOPN 4
92067: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92068: LD_INT 0
92070: PPUSH
92071: PPUSH
// result := false ;
92072: LD_ADDR_VAR 0 4
92076: PUSH
92077: LD_INT 0
92079: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92080: LD_VAR 0 1
92084: PPUSH
92085: CALL_OW 264
92089: PUSH
92090: LD_INT 81
92092: EQUAL
92093: NOT
92094: IFFALSE 92098
// exit ;
92096: GO 92338
// index := GetElementIndex ( minersList , unit ) ;
92098: LD_ADDR_VAR 0 5
92102: PUSH
92103: LD_EXP 95
92107: PPUSH
92108: LD_VAR 0 1
92112: PPUSH
92113: CALL 14702 0 2
92117: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92118: LD_EXP 96
92122: PUSH
92123: LD_VAR 0 5
92127: ARRAY
92128: PUSH
92129: LD_EXP 97
92133: GREATEREQUAL
92134: IFFALSE 92138
// exit ;
92136: GO 92338
// ComMoveXY ( unit , x , y ) ;
92138: LD_VAR 0 1
92142: PPUSH
92143: LD_VAR 0 2
92147: PPUSH
92148: LD_VAR 0 3
92152: PPUSH
92153: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92157: LD_INT 35
92159: PPUSH
92160: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92164: LD_VAR 0 1
92168: PPUSH
92169: LD_VAR 0 2
92173: PPUSH
92174: LD_VAR 0 3
92178: PPUSH
92179: CALL 46057 0 3
92183: NOT
92184: PUSH
92185: LD_VAR 0 1
92189: PPUSH
92190: CALL_OW 314
92194: AND
92195: IFFALSE 92199
// exit ;
92197: GO 92338
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92199: LD_VAR 0 2
92203: PPUSH
92204: LD_VAR 0 3
92208: PPUSH
92209: CALL_OW 428
92213: PUSH
92214: LD_VAR 0 1
92218: EQUAL
92219: PUSH
92220: LD_VAR 0 1
92224: PPUSH
92225: CALL_OW 314
92229: NOT
92230: AND
92231: IFFALSE 92157
// PlaySoundXY ( x , y , PlantMine ) ;
92233: LD_VAR 0 2
92237: PPUSH
92238: LD_VAR 0 3
92242: PPUSH
92243: LD_STRING PlantMine
92245: PPUSH
92246: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92250: LD_VAR 0 2
92254: PPUSH
92255: LD_VAR 0 3
92259: PPUSH
92260: LD_VAR 0 1
92264: PPUSH
92265: CALL_OW 255
92269: PPUSH
92270: LD_INT 0
92272: PPUSH
92273: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92277: LD_ADDR_EXP 96
92281: PUSH
92282: LD_EXP 96
92286: PPUSH
92287: LD_VAR 0 5
92291: PUSH
92292: LD_EXP 96
92296: PUSH
92297: LD_VAR 0 5
92301: ARRAY
92302: PUSH
92303: LD_INT 1
92305: PLUS
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PPUSH
92311: LD_VAR 0 2
92315: PUSH
92316: LD_VAR 0 3
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PPUSH
92325: CALL 14917 0 3
92329: ST_TO_ADDR
// result := true ;
92330: LD_ADDR_VAR 0 4
92334: PUSH
92335: LD_INT 1
92337: ST_TO_ADDR
// end ;
92338: LD_VAR 0 4
92342: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92343: LD_INT 0
92345: PPUSH
92346: PPUSH
92347: PPUSH
// if not unit in minersList then
92348: LD_VAR 0 1
92352: PUSH
92353: LD_EXP 95
92357: IN
92358: NOT
92359: IFFALSE 92363
// exit ;
92361: GO 92755
// index := GetElementIndex ( minersList , unit ) ;
92363: LD_ADDR_VAR 0 6
92367: PUSH
92368: LD_EXP 95
92372: PPUSH
92373: LD_VAR 0 1
92377: PPUSH
92378: CALL 14702 0 2
92382: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92383: LD_ADDR_VAR 0 5
92387: PUSH
92388: DOUBLE
92389: LD_EXP 96
92393: PUSH
92394: LD_VAR 0 6
92398: ARRAY
92399: INC
92400: ST_TO_ADDR
92401: LD_INT 1
92403: PUSH
92404: FOR_DOWNTO
92405: IFFALSE 92566
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92407: LD_EXP 96
92411: PUSH
92412: LD_VAR 0 6
92416: ARRAY
92417: PUSH
92418: LD_VAR 0 5
92422: ARRAY
92423: PUSH
92424: LD_INT 1
92426: ARRAY
92427: PUSH
92428: LD_VAR 0 2
92432: EQUAL
92433: PUSH
92434: LD_EXP 96
92438: PUSH
92439: LD_VAR 0 6
92443: ARRAY
92444: PUSH
92445: LD_VAR 0 5
92449: ARRAY
92450: PUSH
92451: LD_INT 2
92453: ARRAY
92454: PUSH
92455: LD_VAR 0 3
92459: EQUAL
92460: AND
92461: IFFALSE 92564
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92463: LD_EXP 96
92467: PUSH
92468: LD_VAR 0 6
92472: ARRAY
92473: PUSH
92474: LD_VAR 0 5
92478: ARRAY
92479: PUSH
92480: LD_INT 1
92482: ARRAY
92483: PPUSH
92484: LD_EXP 96
92488: PUSH
92489: LD_VAR 0 6
92493: ARRAY
92494: PUSH
92495: LD_VAR 0 5
92499: ARRAY
92500: PUSH
92501: LD_INT 2
92503: ARRAY
92504: PPUSH
92505: LD_VAR 0 1
92509: PPUSH
92510: CALL_OW 255
92514: PPUSH
92515: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92519: LD_ADDR_EXP 96
92523: PUSH
92524: LD_EXP 96
92528: PPUSH
92529: LD_VAR 0 6
92533: PPUSH
92534: LD_EXP 96
92538: PUSH
92539: LD_VAR 0 6
92543: ARRAY
92544: PPUSH
92545: LD_VAR 0 5
92549: PPUSH
92550: CALL_OW 3
92554: PPUSH
92555: CALL_OW 1
92559: ST_TO_ADDR
// exit ;
92560: POP
92561: POP
92562: GO 92755
// end ; end ;
92564: GO 92404
92566: POP
92567: POP
// for i := minerMinesList [ index ] downto 1 do
92568: LD_ADDR_VAR 0 5
92572: PUSH
92573: DOUBLE
92574: LD_EXP 96
92578: PUSH
92579: LD_VAR 0 6
92583: ARRAY
92584: INC
92585: ST_TO_ADDR
92586: LD_INT 1
92588: PUSH
92589: FOR_DOWNTO
92590: IFFALSE 92753
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92592: LD_EXP 96
92596: PUSH
92597: LD_VAR 0 6
92601: ARRAY
92602: PUSH
92603: LD_VAR 0 5
92607: ARRAY
92608: PUSH
92609: LD_INT 1
92611: ARRAY
92612: PPUSH
92613: LD_EXP 96
92617: PUSH
92618: LD_VAR 0 6
92622: ARRAY
92623: PUSH
92624: LD_VAR 0 5
92628: ARRAY
92629: PUSH
92630: LD_INT 2
92632: ARRAY
92633: PPUSH
92634: LD_VAR 0 2
92638: PPUSH
92639: LD_VAR 0 3
92643: PPUSH
92644: CALL_OW 298
92648: PUSH
92649: LD_INT 6
92651: LESS
92652: IFFALSE 92751
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92654: LD_EXP 96
92658: PUSH
92659: LD_VAR 0 6
92663: ARRAY
92664: PUSH
92665: LD_VAR 0 5
92669: ARRAY
92670: PUSH
92671: LD_INT 1
92673: ARRAY
92674: PPUSH
92675: LD_EXP 96
92679: PUSH
92680: LD_VAR 0 6
92684: ARRAY
92685: PUSH
92686: LD_VAR 0 5
92690: ARRAY
92691: PUSH
92692: LD_INT 2
92694: ARRAY
92695: PPUSH
92696: LD_VAR 0 1
92700: PPUSH
92701: CALL_OW 255
92705: PPUSH
92706: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92710: LD_ADDR_EXP 96
92714: PUSH
92715: LD_EXP 96
92719: PPUSH
92720: LD_VAR 0 6
92724: PPUSH
92725: LD_EXP 96
92729: PUSH
92730: LD_VAR 0 6
92734: ARRAY
92735: PPUSH
92736: LD_VAR 0 5
92740: PPUSH
92741: CALL_OW 3
92745: PPUSH
92746: CALL_OW 1
92750: ST_TO_ADDR
// end ; end ;
92751: GO 92589
92753: POP
92754: POP
// end ;
92755: LD_VAR 0 4
92759: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92760: LD_INT 0
92762: PPUSH
92763: PPUSH
92764: PPUSH
92765: PPUSH
92766: PPUSH
92767: PPUSH
92768: PPUSH
92769: PPUSH
92770: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92771: LD_VAR 0 1
92775: PPUSH
92776: CALL_OW 264
92780: PUSH
92781: LD_INT 81
92783: EQUAL
92784: NOT
92785: PUSH
92786: LD_VAR 0 1
92790: PUSH
92791: LD_EXP 95
92795: IN
92796: NOT
92797: OR
92798: IFFALSE 92802
// exit ;
92800: GO 93124
// index := GetElementIndex ( minersList , unit ) ;
92802: LD_ADDR_VAR 0 6
92806: PUSH
92807: LD_EXP 95
92811: PPUSH
92812: LD_VAR 0 1
92816: PPUSH
92817: CALL 14702 0 2
92821: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92822: LD_ADDR_VAR 0 8
92826: PUSH
92827: LD_EXP 97
92831: PUSH
92832: LD_EXP 96
92836: PUSH
92837: LD_VAR 0 6
92841: ARRAY
92842: MINUS
92843: ST_TO_ADDR
// if not minesFreeAmount then
92844: LD_VAR 0 8
92848: NOT
92849: IFFALSE 92853
// exit ;
92851: GO 93124
// tmp := [ ] ;
92853: LD_ADDR_VAR 0 7
92857: PUSH
92858: EMPTY
92859: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92860: LD_ADDR_VAR 0 5
92864: PUSH
92865: DOUBLE
92866: LD_INT 1
92868: DEC
92869: ST_TO_ADDR
92870: LD_VAR 0 8
92874: PUSH
92875: FOR_TO
92876: IFFALSE 93071
// begin _d := rand ( 0 , 5 ) ;
92878: LD_ADDR_VAR 0 11
92882: PUSH
92883: LD_INT 0
92885: PPUSH
92886: LD_INT 5
92888: PPUSH
92889: CALL_OW 12
92893: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92894: LD_ADDR_VAR 0 12
92898: PUSH
92899: LD_INT 2
92901: PPUSH
92902: LD_INT 6
92904: PPUSH
92905: CALL_OW 12
92909: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92910: LD_ADDR_VAR 0 9
92914: PUSH
92915: LD_VAR 0 2
92919: PPUSH
92920: LD_VAR 0 11
92924: PPUSH
92925: LD_VAR 0 12
92929: PPUSH
92930: CALL_OW 272
92934: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92935: LD_ADDR_VAR 0 10
92939: PUSH
92940: LD_VAR 0 3
92944: PPUSH
92945: LD_VAR 0 11
92949: PPUSH
92950: LD_VAR 0 12
92954: PPUSH
92955: CALL_OW 273
92959: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92960: LD_VAR 0 9
92964: PPUSH
92965: LD_VAR 0 10
92969: PPUSH
92970: CALL_OW 488
92974: PUSH
92975: LD_VAR 0 9
92979: PUSH
92980: LD_VAR 0 10
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_VAR 0 7
92993: IN
92994: NOT
92995: AND
92996: PUSH
92997: LD_VAR 0 9
93001: PPUSH
93002: LD_VAR 0 10
93006: PPUSH
93007: CALL_OW 458
93011: NOT
93012: AND
93013: IFFALSE 93055
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93015: LD_ADDR_VAR 0 7
93019: PUSH
93020: LD_VAR 0 7
93024: PPUSH
93025: LD_VAR 0 7
93029: PUSH
93030: LD_INT 1
93032: PLUS
93033: PPUSH
93034: LD_VAR 0 9
93038: PUSH
93039: LD_VAR 0 10
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PPUSH
93048: CALL_OW 1
93052: ST_TO_ADDR
93053: GO 93069
// i := i - 1 ;
93055: LD_ADDR_VAR 0 5
93059: PUSH
93060: LD_VAR 0 5
93064: PUSH
93065: LD_INT 1
93067: MINUS
93068: ST_TO_ADDR
// end ;
93069: GO 92875
93071: POP
93072: POP
// for i in tmp do
93073: LD_ADDR_VAR 0 5
93077: PUSH
93078: LD_VAR 0 7
93082: PUSH
93083: FOR_IN
93084: IFFALSE 93122
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93086: LD_VAR 0 1
93090: PPUSH
93091: LD_VAR 0 5
93095: PUSH
93096: LD_INT 1
93098: ARRAY
93099: PPUSH
93100: LD_VAR 0 5
93104: PUSH
93105: LD_INT 2
93107: ARRAY
93108: PPUSH
93109: CALL 92068 0 3
93113: NOT
93114: IFFALSE 93120
// exit ;
93116: POP
93117: POP
93118: GO 93124
93120: GO 93083
93122: POP
93123: POP
// end ;
93124: LD_VAR 0 4
93128: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93129: LD_INT 0
93131: PPUSH
93132: PPUSH
93133: PPUSH
93134: PPUSH
93135: PPUSH
93136: PPUSH
93137: PPUSH
// if not GetClass ( unit ) = class_sniper then
93138: LD_VAR 0 1
93142: PPUSH
93143: CALL_OW 257
93147: PUSH
93148: LD_INT 5
93150: EQUAL
93151: NOT
93152: IFFALSE 93156
// exit ;
93154: GO 93544
// dist := 8 ;
93156: LD_ADDR_VAR 0 5
93160: PUSH
93161: LD_INT 8
93163: ST_TO_ADDR
// viewRange := 12 ;
93164: LD_ADDR_VAR 0 7
93168: PUSH
93169: LD_INT 12
93171: ST_TO_ADDR
// side := GetSide ( unit ) ;
93172: LD_ADDR_VAR 0 6
93176: PUSH
93177: LD_VAR 0 1
93181: PPUSH
93182: CALL_OW 255
93186: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93187: LD_INT 61
93189: PPUSH
93190: LD_VAR 0 6
93194: PPUSH
93195: CALL_OW 321
93199: PUSH
93200: LD_INT 2
93202: EQUAL
93203: IFFALSE 93213
// viewRange := 16 ;
93205: LD_ADDR_VAR 0 7
93209: PUSH
93210: LD_INT 16
93212: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93213: LD_VAR 0 1
93217: PPUSH
93218: LD_VAR 0 2
93222: PPUSH
93223: LD_VAR 0 3
93227: PPUSH
93228: CALL_OW 297
93232: PUSH
93233: LD_VAR 0 5
93237: GREATER
93238: IFFALSE 93317
// begin ComMoveXY ( unit , x , y ) ;
93240: LD_VAR 0 1
93244: PPUSH
93245: LD_VAR 0 2
93249: PPUSH
93250: LD_VAR 0 3
93254: PPUSH
93255: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93259: LD_INT 35
93261: PPUSH
93262: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93266: LD_VAR 0 1
93270: PPUSH
93271: LD_VAR 0 2
93275: PPUSH
93276: LD_VAR 0 3
93280: PPUSH
93281: CALL 46057 0 3
93285: NOT
93286: IFFALSE 93290
// exit ;
93288: GO 93544
// until GetDistUnitXY ( unit , x , y ) < dist ;
93290: LD_VAR 0 1
93294: PPUSH
93295: LD_VAR 0 2
93299: PPUSH
93300: LD_VAR 0 3
93304: PPUSH
93305: CALL_OW 297
93309: PUSH
93310: LD_VAR 0 5
93314: LESS
93315: IFFALSE 93259
// end ; ComTurnXY ( unit , x , y ) ;
93317: LD_VAR 0 1
93321: PPUSH
93322: LD_VAR 0 2
93326: PPUSH
93327: LD_VAR 0 3
93331: PPUSH
93332: CALL_OW 118
// wait ( 5 ) ;
93336: LD_INT 5
93338: PPUSH
93339: CALL_OW 67
// _d := GetDir ( unit ) ;
93343: LD_ADDR_VAR 0 10
93347: PUSH
93348: LD_VAR 0 1
93352: PPUSH
93353: CALL_OW 254
93357: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93358: LD_ADDR_VAR 0 8
93362: PUSH
93363: LD_VAR 0 1
93367: PPUSH
93368: CALL_OW 250
93372: PPUSH
93373: LD_VAR 0 10
93377: PPUSH
93378: LD_VAR 0 5
93382: PPUSH
93383: CALL_OW 272
93387: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93388: LD_ADDR_VAR 0 9
93392: PUSH
93393: LD_VAR 0 1
93397: PPUSH
93398: CALL_OW 251
93402: PPUSH
93403: LD_VAR 0 10
93407: PPUSH
93408: LD_VAR 0 5
93412: PPUSH
93413: CALL_OW 273
93417: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93418: LD_VAR 0 8
93422: PPUSH
93423: LD_VAR 0 9
93427: PPUSH
93428: CALL_OW 488
93432: NOT
93433: IFFALSE 93437
// exit ;
93435: GO 93544
// ComAnimCustom ( unit , 1 ) ;
93437: LD_VAR 0 1
93441: PPUSH
93442: LD_INT 1
93444: PPUSH
93445: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93449: LD_VAR 0 8
93453: PPUSH
93454: LD_VAR 0 9
93458: PPUSH
93459: LD_VAR 0 6
93463: PPUSH
93464: LD_VAR 0 7
93468: PPUSH
93469: CALL_OW 330
// repeat wait ( 1 ) ;
93473: LD_INT 1
93475: PPUSH
93476: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93480: LD_VAR 0 1
93484: PPUSH
93485: CALL_OW 316
93489: PUSH
93490: LD_VAR 0 1
93494: PPUSH
93495: CALL_OW 314
93499: OR
93500: PUSH
93501: LD_VAR 0 1
93505: PPUSH
93506: CALL_OW 302
93510: NOT
93511: OR
93512: PUSH
93513: LD_VAR 0 1
93517: PPUSH
93518: CALL_OW 301
93522: OR
93523: IFFALSE 93473
// RemoveSeeing ( _x , _y , side ) ;
93525: LD_VAR 0 8
93529: PPUSH
93530: LD_VAR 0 9
93534: PPUSH
93535: LD_VAR 0 6
93539: PPUSH
93540: CALL_OW 331
// end ; end_of_file
93544: LD_VAR 0 4
93548: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93549: LD_VAR 0 1
93553: PUSH
93554: LD_INT 200
93556: DOUBLE
93557: GREATEREQUAL
93558: IFFALSE 93566
93560: LD_INT 299
93562: DOUBLE
93563: LESSEQUAL
93564: IFTRUE 93568
93566: GO 93600
93568: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93569: LD_VAR 0 1
93573: PPUSH
93574: LD_VAR 0 2
93578: PPUSH
93579: LD_VAR 0 3
93583: PPUSH
93584: LD_VAR 0 4
93588: PPUSH
93589: LD_VAR 0 5
93593: PPUSH
93594: CALL 89636 0 5
93598: GO 93677
93600: LD_INT 300
93602: DOUBLE
93603: GREATEREQUAL
93604: IFFALSE 93612
93606: LD_INT 399
93608: DOUBLE
93609: LESSEQUAL
93610: IFTRUE 93614
93612: GO 93676
93614: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93615: LD_VAR 0 1
93619: PPUSH
93620: LD_VAR 0 2
93624: PPUSH
93625: LD_VAR 0 3
93629: PPUSH
93630: LD_VAR 0 4
93634: PPUSH
93635: LD_VAR 0 5
93639: PPUSH
93640: LD_VAR 0 6
93644: PPUSH
93645: LD_VAR 0 7
93649: PPUSH
93650: LD_VAR 0 8
93654: PPUSH
93655: LD_VAR 0 9
93659: PPUSH
93660: LD_VAR 0 10
93664: PPUSH
93665: LD_VAR 0 11
93669: PPUSH
93670: CALL 106215 0 11
93674: GO 93677
93676: POP
// end ;
93677: PPOPN 11
93679: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93680: LD_VAR 0 1
93684: PPUSH
93685: LD_VAR 0 2
93689: PPUSH
93690: LD_VAR 0 3
93694: PPUSH
93695: LD_VAR 0 4
93699: PPUSH
93700: LD_VAR 0 5
93704: PPUSH
93705: CALL 89372 0 5
// end ; end_of_file
93709: PPOPN 5
93711: END
// export globalGameSaveCounter ; every 0 0$1 do
93712: GO 93714
93714: DISABLE
// begin enable ;
93715: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93716: LD_STRING updateTimer(
93718: PUSH
93719: LD_OWVAR 1
93723: STR
93724: PUSH
93725: LD_STRING );
93727: STR
93728: PPUSH
93729: CALL_OW 559
// end ;
93733: END
// every 0 0$1 do
93734: GO 93736
93736: DISABLE
// begin globalGameSaveCounter := 0 ;
93737: LD_ADDR_EXP 98
93741: PUSH
93742: LD_INT 0
93744: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93745: LD_STRING setGameSaveCounter(0)
93747: PPUSH
93748: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93752: LD_STRING initStreamRollete();
93754: PPUSH
93755: CALL_OW 559
// InitStreamMode ;
93759: CALL 95085 0 0
// DefineStreamItems ( false ) ;
93763: LD_INT 0
93765: PPUSH
93766: CALL 95549 0 1
// end ;
93770: END
// export function SOS_MapStart ( ) ; begin
93771: LD_INT 0
93773: PPUSH
// if streamModeActive then
93774: LD_EXP 99
93778: IFFALSE 93787
// DefineStreamItems ( true ) ;
93780: LD_INT 1
93782: PPUSH
93783: CALL 95549 0 1
// UpdateLuaVariables ( ) ;
93787: CALL 93804 0 0
// UpdateFactoryWaypoints ( ) ;
93791: CALL 108410 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93795: CALL 108667 0 0
// end ;
93799: LD_VAR 0 1
93803: RET
// function UpdateLuaVariables ( ) ; begin
93804: LD_INT 0
93806: PPUSH
// if globalGameSaveCounter then
93807: LD_EXP 98
93811: IFFALSE 93845
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93813: LD_ADDR_EXP 98
93817: PUSH
93818: LD_EXP 98
93822: PPUSH
93823: CALL 48608 0 1
93827: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93828: LD_STRING setGameSaveCounter(
93830: PUSH
93831: LD_EXP 98
93835: STR
93836: PUSH
93837: LD_STRING )
93839: STR
93840: PPUSH
93841: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93845: LD_STRING setGameDifficulty(
93847: PUSH
93848: LD_OWVAR 67
93852: STR
93853: PUSH
93854: LD_STRING )
93856: STR
93857: PPUSH
93858: CALL_OW 559
// end ;
93862: LD_VAR 0 1
93866: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93867: LD_INT 0
93869: PPUSH
// if p2 = stream_mode then
93870: LD_VAR 0 2
93874: PUSH
93875: LD_INT 100
93877: EQUAL
93878: IFFALSE 94881
// begin if not StreamModeActive then
93880: LD_EXP 99
93884: NOT
93885: IFFALSE 93895
// StreamModeActive := true ;
93887: LD_ADDR_EXP 99
93891: PUSH
93892: LD_INT 1
93894: ST_TO_ADDR
// if p3 = 0 then
93895: LD_VAR 0 3
93899: PUSH
93900: LD_INT 0
93902: EQUAL
93903: IFFALSE 93909
// InitStreamMode ;
93905: CALL 95085 0 0
// if p3 = 1 then
93909: LD_VAR 0 3
93913: PUSH
93914: LD_INT 1
93916: EQUAL
93917: IFFALSE 93927
// sRocket := true ;
93919: LD_ADDR_EXP 104
93923: PUSH
93924: LD_INT 1
93926: ST_TO_ADDR
// if p3 = 2 then
93927: LD_VAR 0 3
93931: PUSH
93932: LD_INT 2
93934: EQUAL
93935: IFFALSE 93945
// sSpeed := true ;
93937: LD_ADDR_EXP 103
93941: PUSH
93942: LD_INT 1
93944: ST_TO_ADDR
// if p3 = 3 then
93945: LD_VAR 0 3
93949: PUSH
93950: LD_INT 3
93952: EQUAL
93953: IFFALSE 93963
// sEngine := true ;
93955: LD_ADDR_EXP 105
93959: PUSH
93960: LD_INT 1
93962: ST_TO_ADDR
// if p3 = 4 then
93963: LD_VAR 0 3
93967: PUSH
93968: LD_INT 4
93970: EQUAL
93971: IFFALSE 93981
// sSpec := true ;
93973: LD_ADDR_EXP 102
93977: PUSH
93978: LD_INT 1
93980: ST_TO_ADDR
// if p3 = 5 then
93981: LD_VAR 0 3
93985: PUSH
93986: LD_INT 5
93988: EQUAL
93989: IFFALSE 93999
// sLevel := true ;
93991: LD_ADDR_EXP 106
93995: PUSH
93996: LD_INT 1
93998: ST_TO_ADDR
// if p3 = 6 then
93999: LD_VAR 0 3
94003: PUSH
94004: LD_INT 6
94006: EQUAL
94007: IFFALSE 94017
// sArmoury := true ;
94009: LD_ADDR_EXP 107
94013: PUSH
94014: LD_INT 1
94016: ST_TO_ADDR
// if p3 = 7 then
94017: LD_VAR 0 3
94021: PUSH
94022: LD_INT 7
94024: EQUAL
94025: IFFALSE 94035
// sRadar := true ;
94027: LD_ADDR_EXP 108
94031: PUSH
94032: LD_INT 1
94034: ST_TO_ADDR
// if p3 = 8 then
94035: LD_VAR 0 3
94039: PUSH
94040: LD_INT 8
94042: EQUAL
94043: IFFALSE 94053
// sBunker := true ;
94045: LD_ADDR_EXP 109
94049: PUSH
94050: LD_INT 1
94052: ST_TO_ADDR
// if p3 = 9 then
94053: LD_VAR 0 3
94057: PUSH
94058: LD_INT 9
94060: EQUAL
94061: IFFALSE 94071
// sHack := true ;
94063: LD_ADDR_EXP 110
94067: PUSH
94068: LD_INT 1
94070: ST_TO_ADDR
// if p3 = 10 then
94071: LD_VAR 0 3
94075: PUSH
94076: LD_INT 10
94078: EQUAL
94079: IFFALSE 94089
// sFire := true ;
94081: LD_ADDR_EXP 111
94085: PUSH
94086: LD_INT 1
94088: ST_TO_ADDR
// if p3 = 11 then
94089: LD_VAR 0 3
94093: PUSH
94094: LD_INT 11
94096: EQUAL
94097: IFFALSE 94107
// sRefresh := true ;
94099: LD_ADDR_EXP 112
94103: PUSH
94104: LD_INT 1
94106: ST_TO_ADDR
// if p3 = 12 then
94107: LD_VAR 0 3
94111: PUSH
94112: LD_INT 12
94114: EQUAL
94115: IFFALSE 94125
// sExp := true ;
94117: LD_ADDR_EXP 113
94121: PUSH
94122: LD_INT 1
94124: ST_TO_ADDR
// if p3 = 13 then
94125: LD_VAR 0 3
94129: PUSH
94130: LD_INT 13
94132: EQUAL
94133: IFFALSE 94143
// sDepot := true ;
94135: LD_ADDR_EXP 114
94139: PUSH
94140: LD_INT 1
94142: ST_TO_ADDR
// if p3 = 14 then
94143: LD_VAR 0 3
94147: PUSH
94148: LD_INT 14
94150: EQUAL
94151: IFFALSE 94161
// sFlag := true ;
94153: LD_ADDR_EXP 115
94157: PUSH
94158: LD_INT 1
94160: ST_TO_ADDR
// if p3 = 15 then
94161: LD_VAR 0 3
94165: PUSH
94166: LD_INT 15
94168: EQUAL
94169: IFFALSE 94179
// sKamikadze := true ;
94171: LD_ADDR_EXP 123
94175: PUSH
94176: LD_INT 1
94178: ST_TO_ADDR
// if p3 = 16 then
94179: LD_VAR 0 3
94183: PUSH
94184: LD_INT 16
94186: EQUAL
94187: IFFALSE 94197
// sTroll := true ;
94189: LD_ADDR_EXP 124
94193: PUSH
94194: LD_INT 1
94196: ST_TO_ADDR
// if p3 = 17 then
94197: LD_VAR 0 3
94201: PUSH
94202: LD_INT 17
94204: EQUAL
94205: IFFALSE 94215
// sSlow := true ;
94207: LD_ADDR_EXP 125
94211: PUSH
94212: LD_INT 1
94214: ST_TO_ADDR
// if p3 = 18 then
94215: LD_VAR 0 3
94219: PUSH
94220: LD_INT 18
94222: EQUAL
94223: IFFALSE 94233
// sLack := true ;
94225: LD_ADDR_EXP 126
94229: PUSH
94230: LD_INT 1
94232: ST_TO_ADDR
// if p3 = 19 then
94233: LD_VAR 0 3
94237: PUSH
94238: LD_INT 19
94240: EQUAL
94241: IFFALSE 94251
// sTank := true ;
94243: LD_ADDR_EXP 128
94247: PUSH
94248: LD_INT 1
94250: ST_TO_ADDR
// if p3 = 20 then
94251: LD_VAR 0 3
94255: PUSH
94256: LD_INT 20
94258: EQUAL
94259: IFFALSE 94269
// sRemote := true ;
94261: LD_ADDR_EXP 129
94265: PUSH
94266: LD_INT 1
94268: ST_TO_ADDR
// if p3 = 21 then
94269: LD_VAR 0 3
94273: PUSH
94274: LD_INT 21
94276: EQUAL
94277: IFFALSE 94287
// sPowell := true ;
94279: LD_ADDR_EXP 130
94283: PUSH
94284: LD_INT 1
94286: ST_TO_ADDR
// if p3 = 22 then
94287: LD_VAR 0 3
94291: PUSH
94292: LD_INT 22
94294: EQUAL
94295: IFFALSE 94305
// sTeleport := true ;
94297: LD_ADDR_EXP 133
94301: PUSH
94302: LD_INT 1
94304: ST_TO_ADDR
// if p3 = 23 then
94305: LD_VAR 0 3
94309: PUSH
94310: LD_INT 23
94312: EQUAL
94313: IFFALSE 94323
// sOilTower := true ;
94315: LD_ADDR_EXP 135
94319: PUSH
94320: LD_INT 1
94322: ST_TO_ADDR
// if p3 = 24 then
94323: LD_VAR 0 3
94327: PUSH
94328: LD_INT 24
94330: EQUAL
94331: IFFALSE 94341
// sShovel := true ;
94333: LD_ADDR_EXP 136
94337: PUSH
94338: LD_INT 1
94340: ST_TO_ADDR
// if p3 = 25 then
94341: LD_VAR 0 3
94345: PUSH
94346: LD_INT 25
94348: EQUAL
94349: IFFALSE 94359
// sSheik := true ;
94351: LD_ADDR_EXP 137
94355: PUSH
94356: LD_INT 1
94358: ST_TO_ADDR
// if p3 = 26 then
94359: LD_VAR 0 3
94363: PUSH
94364: LD_INT 26
94366: EQUAL
94367: IFFALSE 94377
// sEarthquake := true ;
94369: LD_ADDR_EXP 139
94373: PUSH
94374: LD_INT 1
94376: ST_TO_ADDR
// if p3 = 27 then
94377: LD_VAR 0 3
94381: PUSH
94382: LD_INT 27
94384: EQUAL
94385: IFFALSE 94395
// sAI := true ;
94387: LD_ADDR_EXP 140
94391: PUSH
94392: LD_INT 1
94394: ST_TO_ADDR
// if p3 = 28 then
94395: LD_VAR 0 3
94399: PUSH
94400: LD_INT 28
94402: EQUAL
94403: IFFALSE 94413
// sCargo := true ;
94405: LD_ADDR_EXP 143
94409: PUSH
94410: LD_INT 1
94412: ST_TO_ADDR
// if p3 = 29 then
94413: LD_VAR 0 3
94417: PUSH
94418: LD_INT 29
94420: EQUAL
94421: IFFALSE 94431
// sDLaser := true ;
94423: LD_ADDR_EXP 144
94427: PUSH
94428: LD_INT 1
94430: ST_TO_ADDR
// if p3 = 30 then
94431: LD_VAR 0 3
94435: PUSH
94436: LD_INT 30
94438: EQUAL
94439: IFFALSE 94449
// sExchange := true ;
94441: LD_ADDR_EXP 145
94445: PUSH
94446: LD_INT 1
94448: ST_TO_ADDR
// if p3 = 31 then
94449: LD_VAR 0 3
94453: PUSH
94454: LD_INT 31
94456: EQUAL
94457: IFFALSE 94467
// sFac := true ;
94459: LD_ADDR_EXP 146
94463: PUSH
94464: LD_INT 1
94466: ST_TO_ADDR
// if p3 = 32 then
94467: LD_VAR 0 3
94471: PUSH
94472: LD_INT 32
94474: EQUAL
94475: IFFALSE 94485
// sPower := true ;
94477: LD_ADDR_EXP 147
94481: PUSH
94482: LD_INT 1
94484: ST_TO_ADDR
// if p3 = 33 then
94485: LD_VAR 0 3
94489: PUSH
94490: LD_INT 33
94492: EQUAL
94493: IFFALSE 94503
// sRandom := true ;
94495: LD_ADDR_EXP 148
94499: PUSH
94500: LD_INT 1
94502: ST_TO_ADDR
// if p3 = 34 then
94503: LD_VAR 0 3
94507: PUSH
94508: LD_INT 34
94510: EQUAL
94511: IFFALSE 94521
// sShield := true ;
94513: LD_ADDR_EXP 149
94517: PUSH
94518: LD_INT 1
94520: ST_TO_ADDR
// if p3 = 35 then
94521: LD_VAR 0 3
94525: PUSH
94526: LD_INT 35
94528: EQUAL
94529: IFFALSE 94539
// sTime := true ;
94531: LD_ADDR_EXP 150
94535: PUSH
94536: LD_INT 1
94538: ST_TO_ADDR
// if p3 = 36 then
94539: LD_VAR 0 3
94543: PUSH
94544: LD_INT 36
94546: EQUAL
94547: IFFALSE 94557
// sTools := true ;
94549: LD_ADDR_EXP 151
94553: PUSH
94554: LD_INT 1
94556: ST_TO_ADDR
// if p3 = 101 then
94557: LD_VAR 0 3
94561: PUSH
94562: LD_INT 101
94564: EQUAL
94565: IFFALSE 94575
// sSold := true ;
94567: LD_ADDR_EXP 116
94571: PUSH
94572: LD_INT 1
94574: ST_TO_ADDR
// if p3 = 102 then
94575: LD_VAR 0 3
94579: PUSH
94580: LD_INT 102
94582: EQUAL
94583: IFFALSE 94593
// sDiff := true ;
94585: LD_ADDR_EXP 117
94589: PUSH
94590: LD_INT 1
94592: ST_TO_ADDR
// if p3 = 103 then
94593: LD_VAR 0 3
94597: PUSH
94598: LD_INT 103
94600: EQUAL
94601: IFFALSE 94611
// sFog := true ;
94603: LD_ADDR_EXP 120
94607: PUSH
94608: LD_INT 1
94610: ST_TO_ADDR
// if p3 = 104 then
94611: LD_VAR 0 3
94615: PUSH
94616: LD_INT 104
94618: EQUAL
94619: IFFALSE 94629
// sReset := true ;
94621: LD_ADDR_EXP 121
94625: PUSH
94626: LD_INT 1
94628: ST_TO_ADDR
// if p3 = 105 then
94629: LD_VAR 0 3
94633: PUSH
94634: LD_INT 105
94636: EQUAL
94637: IFFALSE 94647
// sSun := true ;
94639: LD_ADDR_EXP 122
94643: PUSH
94644: LD_INT 1
94646: ST_TO_ADDR
// if p3 = 106 then
94647: LD_VAR 0 3
94651: PUSH
94652: LD_INT 106
94654: EQUAL
94655: IFFALSE 94665
// sTiger := true ;
94657: LD_ADDR_EXP 118
94661: PUSH
94662: LD_INT 1
94664: ST_TO_ADDR
// if p3 = 107 then
94665: LD_VAR 0 3
94669: PUSH
94670: LD_INT 107
94672: EQUAL
94673: IFFALSE 94683
// sBomb := true ;
94675: LD_ADDR_EXP 119
94679: PUSH
94680: LD_INT 1
94682: ST_TO_ADDR
// if p3 = 108 then
94683: LD_VAR 0 3
94687: PUSH
94688: LD_INT 108
94690: EQUAL
94691: IFFALSE 94701
// sWound := true ;
94693: LD_ADDR_EXP 127
94697: PUSH
94698: LD_INT 1
94700: ST_TO_ADDR
// if p3 = 109 then
94701: LD_VAR 0 3
94705: PUSH
94706: LD_INT 109
94708: EQUAL
94709: IFFALSE 94719
// sBetray := true ;
94711: LD_ADDR_EXP 131
94715: PUSH
94716: LD_INT 1
94718: ST_TO_ADDR
// if p3 = 110 then
94719: LD_VAR 0 3
94723: PUSH
94724: LD_INT 110
94726: EQUAL
94727: IFFALSE 94737
// sContamin := true ;
94729: LD_ADDR_EXP 132
94733: PUSH
94734: LD_INT 1
94736: ST_TO_ADDR
// if p3 = 111 then
94737: LD_VAR 0 3
94741: PUSH
94742: LD_INT 111
94744: EQUAL
94745: IFFALSE 94755
// sOil := true ;
94747: LD_ADDR_EXP 134
94751: PUSH
94752: LD_INT 1
94754: ST_TO_ADDR
// if p3 = 112 then
94755: LD_VAR 0 3
94759: PUSH
94760: LD_INT 112
94762: EQUAL
94763: IFFALSE 94773
// sStu := true ;
94765: LD_ADDR_EXP 138
94769: PUSH
94770: LD_INT 1
94772: ST_TO_ADDR
// if p3 = 113 then
94773: LD_VAR 0 3
94777: PUSH
94778: LD_INT 113
94780: EQUAL
94781: IFFALSE 94791
// sBazooka := true ;
94783: LD_ADDR_EXP 141
94787: PUSH
94788: LD_INT 1
94790: ST_TO_ADDR
// if p3 = 114 then
94791: LD_VAR 0 3
94795: PUSH
94796: LD_INT 114
94798: EQUAL
94799: IFFALSE 94809
// sMortar := true ;
94801: LD_ADDR_EXP 142
94805: PUSH
94806: LD_INT 1
94808: ST_TO_ADDR
// if p3 = 115 then
94809: LD_VAR 0 3
94813: PUSH
94814: LD_INT 115
94816: EQUAL
94817: IFFALSE 94827
// sRanger := true ;
94819: LD_ADDR_EXP 152
94823: PUSH
94824: LD_INT 1
94826: ST_TO_ADDR
// if p3 = 116 then
94827: LD_VAR 0 3
94831: PUSH
94832: LD_INT 116
94834: EQUAL
94835: IFFALSE 94845
// sComputer := true ;
94837: LD_ADDR_EXP 153
94841: PUSH
94842: LD_INT 1
94844: ST_TO_ADDR
// if p3 = 117 then
94845: LD_VAR 0 3
94849: PUSH
94850: LD_INT 117
94852: EQUAL
94853: IFFALSE 94863
// s30 := true ;
94855: LD_ADDR_EXP 154
94859: PUSH
94860: LD_INT 1
94862: ST_TO_ADDR
// if p3 = 118 then
94863: LD_VAR 0 3
94867: PUSH
94868: LD_INT 118
94870: EQUAL
94871: IFFALSE 94881
// s60 := true ;
94873: LD_ADDR_EXP 155
94877: PUSH
94878: LD_INT 1
94880: ST_TO_ADDR
// end ; if p2 = hack_mode then
94881: LD_VAR 0 2
94885: PUSH
94886: LD_INT 101
94888: EQUAL
94889: IFFALSE 95017
// begin case p3 of 1 :
94891: LD_VAR 0 3
94895: PUSH
94896: LD_INT 1
94898: DOUBLE
94899: EQUAL
94900: IFTRUE 94904
94902: GO 94911
94904: POP
// hHackUnlimitedResources ; 2 :
94905: CALL 107156 0 0
94909: GO 95017
94911: LD_INT 2
94913: DOUBLE
94914: EQUAL
94915: IFTRUE 94919
94917: GO 94926
94919: POP
// hHackSetLevel10 ; 3 :
94920: CALL 107289 0 0
94924: GO 95017
94926: LD_INT 3
94928: DOUBLE
94929: EQUAL
94930: IFTRUE 94934
94932: GO 94941
94934: POP
// hHackSetLevel10YourUnits ; 4 :
94935: CALL 107374 0 0
94939: GO 95017
94941: LD_INT 4
94943: DOUBLE
94944: EQUAL
94945: IFTRUE 94949
94947: GO 94956
94949: POP
// hHackInvincible ; 5 :
94950: CALL 107822 0 0
94954: GO 95017
94956: LD_INT 5
94958: DOUBLE
94959: EQUAL
94960: IFTRUE 94964
94962: GO 94971
94964: POP
// hHackInvisible ; 6 :
94965: CALL 107933 0 0
94969: GO 95017
94971: LD_INT 6
94973: DOUBLE
94974: EQUAL
94975: IFTRUE 94979
94977: GO 94986
94979: POP
// hHackChangeYourSide ; 7 :
94980: CALL 107990 0 0
94984: GO 95017
94986: LD_INT 7
94988: DOUBLE
94989: EQUAL
94990: IFTRUE 94994
94992: GO 95001
94994: POP
// hHackChangeUnitSide ; 8 :
94995: CALL 108032 0 0
94999: GO 95017
95001: LD_INT 8
95003: DOUBLE
95004: EQUAL
95005: IFTRUE 95009
95007: GO 95016
95009: POP
// hHackFog ; end ;
95010: CALL 108133 0 0
95014: GO 95017
95016: POP
// end ; if p2 = game_save_mode then
95017: LD_VAR 0 2
95021: PUSH
95022: LD_INT 102
95024: EQUAL
95025: IFFALSE 95080
// begin if p3 = 1 then
95027: LD_VAR 0 3
95031: PUSH
95032: LD_INT 1
95034: EQUAL
95035: IFFALSE 95047
// globalGameSaveCounter := p4 ;
95037: LD_ADDR_EXP 98
95041: PUSH
95042: LD_VAR 0 4
95046: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95047: LD_VAR 0 3
95051: PUSH
95052: LD_INT 2
95054: EQUAL
95055: PUSH
95056: LD_EXP 98
95060: AND
95061: IFFALSE 95080
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95063: LD_STRING setGameSaveCounter(
95065: PUSH
95066: LD_EXP 98
95070: STR
95071: PUSH
95072: LD_STRING )
95074: STR
95075: PPUSH
95076: CALL_OW 559
// end ; end ;
95080: LD_VAR 0 7
95084: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95085: LD_INT 0
95087: PPUSH
// streamModeActive := false ;
95088: LD_ADDR_EXP 99
95092: PUSH
95093: LD_INT 0
95095: ST_TO_ADDR
// normalCounter := 36 ;
95096: LD_ADDR_EXP 100
95100: PUSH
95101: LD_INT 36
95103: ST_TO_ADDR
// hardcoreCounter := 18 ;
95104: LD_ADDR_EXP 101
95108: PUSH
95109: LD_INT 18
95111: ST_TO_ADDR
// sRocket := false ;
95112: LD_ADDR_EXP 104
95116: PUSH
95117: LD_INT 0
95119: ST_TO_ADDR
// sSpeed := false ;
95120: LD_ADDR_EXP 103
95124: PUSH
95125: LD_INT 0
95127: ST_TO_ADDR
// sEngine := false ;
95128: LD_ADDR_EXP 105
95132: PUSH
95133: LD_INT 0
95135: ST_TO_ADDR
// sSpec := false ;
95136: LD_ADDR_EXP 102
95140: PUSH
95141: LD_INT 0
95143: ST_TO_ADDR
// sLevel := false ;
95144: LD_ADDR_EXP 106
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// sArmoury := false ;
95152: LD_ADDR_EXP 107
95156: PUSH
95157: LD_INT 0
95159: ST_TO_ADDR
// sRadar := false ;
95160: LD_ADDR_EXP 108
95164: PUSH
95165: LD_INT 0
95167: ST_TO_ADDR
// sBunker := false ;
95168: LD_ADDR_EXP 109
95172: PUSH
95173: LD_INT 0
95175: ST_TO_ADDR
// sHack := false ;
95176: LD_ADDR_EXP 110
95180: PUSH
95181: LD_INT 0
95183: ST_TO_ADDR
// sFire := false ;
95184: LD_ADDR_EXP 111
95188: PUSH
95189: LD_INT 0
95191: ST_TO_ADDR
// sRefresh := false ;
95192: LD_ADDR_EXP 112
95196: PUSH
95197: LD_INT 0
95199: ST_TO_ADDR
// sExp := false ;
95200: LD_ADDR_EXP 113
95204: PUSH
95205: LD_INT 0
95207: ST_TO_ADDR
// sDepot := false ;
95208: LD_ADDR_EXP 114
95212: PUSH
95213: LD_INT 0
95215: ST_TO_ADDR
// sFlag := false ;
95216: LD_ADDR_EXP 115
95220: PUSH
95221: LD_INT 0
95223: ST_TO_ADDR
// sKamikadze := false ;
95224: LD_ADDR_EXP 123
95228: PUSH
95229: LD_INT 0
95231: ST_TO_ADDR
// sTroll := false ;
95232: LD_ADDR_EXP 124
95236: PUSH
95237: LD_INT 0
95239: ST_TO_ADDR
// sSlow := false ;
95240: LD_ADDR_EXP 125
95244: PUSH
95245: LD_INT 0
95247: ST_TO_ADDR
// sLack := false ;
95248: LD_ADDR_EXP 126
95252: PUSH
95253: LD_INT 0
95255: ST_TO_ADDR
// sTank := false ;
95256: LD_ADDR_EXP 128
95260: PUSH
95261: LD_INT 0
95263: ST_TO_ADDR
// sRemote := false ;
95264: LD_ADDR_EXP 129
95268: PUSH
95269: LD_INT 0
95271: ST_TO_ADDR
// sPowell := false ;
95272: LD_ADDR_EXP 130
95276: PUSH
95277: LD_INT 0
95279: ST_TO_ADDR
// sTeleport := false ;
95280: LD_ADDR_EXP 133
95284: PUSH
95285: LD_INT 0
95287: ST_TO_ADDR
// sOilTower := false ;
95288: LD_ADDR_EXP 135
95292: PUSH
95293: LD_INT 0
95295: ST_TO_ADDR
// sShovel := false ;
95296: LD_ADDR_EXP 136
95300: PUSH
95301: LD_INT 0
95303: ST_TO_ADDR
// sSheik := false ;
95304: LD_ADDR_EXP 137
95308: PUSH
95309: LD_INT 0
95311: ST_TO_ADDR
// sEarthquake := false ;
95312: LD_ADDR_EXP 139
95316: PUSH
95317: LD_INT 0
95319: ST_TO_ADDR
// sAI := false ;
95320: LD_ADDR_EXP 140
95324: PUSH
95325: LD_INT 0
95327: ST_TO_ADDR
// sCargo := false ;
95328: LD_ADDR_EXP 143
95332: PUSH
95333: LD_INT 0
95335: ST_TO_ADDR
// sDLaser := false ;
95336: LD_ADDR_EXP 144
95340: PUSH
95341: LD_INT 0
95343: ST_TO_ADDR
// sExchange := false ;
95344: LD_ADDR_EXP 145
95348: PUSH
95349: LD_INT 0
95351: ST_TO_ADDR
// sFac := false ;
95352: LD_ADDR_EXP 146
95356: PUSH
95357: LD_INT 0
95359: ST_TO_ADDR
// sPower := false ;
95360: LD_ADDR_EXP 147
95364: PUSH
95365: LD_INT 0
95367: ST_TO_ADDR
// sRandom := false ;
95368: LD_ADDR_EXP 148
95372: PUSH
95373: LD_INT 0
95375: ST_TO_ADDR
// sShield := false ;
95376: LD_ADDR_EXP 149
95380: PUSH
95381: LD_INT 0
95383: ST_TO_ADDR
// sTime := false ;
95384: LD_ADDR_EXP 150
95388: PUSH
95389: LD_INT 0
95391: ST_TO_ADDR
// sTools := false ;
95392: LD_ADDR_EXP 151
95396: PUSH
95397: LD_INT 0
95399: ST_TO_ADDR
// sSold := false ;
95400: LD_ADDR_EXP 116
95404: PUSH
95405: LD_INT 0
95407: ST_TO_ADDR
// sDiff := false ;
95408: LD_ADDR_EXP 117
95412: PUSH
95413: LD_INT 0
95415: ST_TO_ADDR
// sFog := false ;
95416: LD_ADDR_EXP 120
95420: PUSH
95421: LD_INT 0
95423: ST_TO_ADDR
// sReset := false ;
95424: LD_ADDR_EXP 121
95428: PUSH
95429: LD_INT 0
95431: ST_TO_ADDR
// sSun := false ;
95432: LD_ADDR_EXP 122
95436: PUSH
95437: LD_INT 0
95439: ST_TO_ADDR
// sTiger := false ;
95440: LD_ADDR_EXP 118
95444: PUSH
95445: LD_INT 0
95447: ST_TO_ADDR
// sBomb := false ;
95448: LD_ADDR_EXP 119
95452: PUSH
95453: LD_INT 0
95455: ST_TO_ADDR
// sWound := false ;
95456: LD_ADDR_EXP 127
95460: PUSH
95461: LD_INT 0
95463: ST_TO_ADDR
// sBetray := false ;
95464: LD_ADDR_EXP 131
95468: PUSH
95469: LD_INT 0
95471: ST_TO_ADDR
// sContamin := false ;
95472: LD_ADDR_EXP 132
95476: PUSH
95477: LD_INT 0
95479: ST_TO_ADDR
// sOil := false ;
95480: LD_ADDR_EXP 134
95484: PUSH
95485: LD_INT 0
95487: ST_TO_ADDR
// sStu := false ;
95488: LD_ADDR_EXP 138
95492: PUSH
95493: LD_INT 0
95495: ST_TO_ADDR
// sBazooka := false ;
95496: LD_ADDR_EXP 141
95500: PUSH
95501: LD_INT 0
95503: ST_TO_ADDR
// sMortar := false ;
95504: LD_ADDR_EXP 142
95508: PUSH
95509: LD_INT 0
95511: ST_TO_ADDR
// sRanger := false ;
95512: LD_ADDR_EXP 152
95516: PUSH
95517: LD_INT 0
95519: ST_TO_ADDR
// sComputer := false ;
95520: LD_ADDR_EXP 153
95524: PUSH
95525: LD_INT 0
95527: ST_TO_ADDR
// s30 := false ;
95528: LD_ADDR_EXP 154
95532: PUSH
95533: LD_INT 0
95535: ST_TO_ADDR
// s60 := false ;
95536: LD_ADDR_EXP 155
95540: PUSH
95541: LD_INT 0
95543: ST_TO_ADDR
// end ;
95544: LD_VAR 0 1
95548: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95549: LD_INT 0
95551: PPUSH
95552: PPUSH
95553: PPUSH
95554: PPUSH
95555: PPUSH
95556: PPUSH
95557: PPUSH
// result := [ ] ;
95558: LD_ADDR_VAR 0 2
95562: PUSH
95563: EMPTY
95564: ST_TO_ADDR
// if campaign_id = 1 then
95565: LD_OWVAR 69
95569: PUSH
95570: LD_INT 1
95572: EQUAL
95573: IFFALSE 98739
// begin case mission_number of 1 :
95575: LD_OWVAR 70
95579: PUSH
95580: LD_INT 1
95582: DOUBLE
95583: EQUAL
95584: IFTRUE 95588
95586: GO 95664
95588: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95589: LD_ADDR_VAR 0 2
95593: PUSH
95594: LD_INT 2
95596: PUSH
95597: LD_INT 4
95599: PUSH
95600: LD_INT 11
95602: PUSH
95603: LD_INT 12
95605: PUSH
95606: LD_INT 15
95608: PUSH
95609: LD_INT 16
95611: PUSH
95612: LD_INT 22
95614: PUSH
95615: LD_INT 23
95617: PUSH
95618: LD_INT 26
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 101
95634: PUSH
95635: LD_INT 102
95637: PUSH
95638: LD_INT 106
95640: PUSH
95641: LD_INT 116
95643: PUSH
95644: LD_INT 117
95646: PUSH
95647: LD_INT 118
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: ST_TO_ADDR
95662: GO 98737
95664: LD_INT 2
95666: DOUBLE
95667: EQUAL
95668: IFTRUE 95672
95670: GO 95756
95672: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95673: LD_ADDR_VAR 0 2
95677: PUSH
95678: LD_INT 2
95680: PUSH
95681: LD_INT 4
95683: PUSH
95684: LD_INT 11
95686: PUSH
95687: LD_INT 12
95689: PUSH
95690: LD_INT 15
95692: PUSH
95693: LD_INT 16
95695: PUSH
95696: LD_INT 22
95698: PUSH
95699: LD_INT 23
95701: PUSH
95702: LD_INT 26
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 101
95718: PUSH
95719: LD_INT 102
95721: PUSH
95722: LD_INT 105
95724: PUSH
95725: LD_INT 106
95727: PUSH
95728: LD_INT 108
95730: PUSH
95731: LD_INT 116
95733: PUSH
95734: LD_INT 117
95736: PUSH
95737: LD_INT 118
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: ST_TO_ADDR
95754: GO 98737
95756: LD_INT 3
95758: DOUBLE
95759: EQUAL
95760: IFTRUE 95764
95762: GO 95852
95764: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95765: LD_ADDR_VAR 0 2
95769: PUSH
95770: LD_INT 2
95772: PUSH
95773: LD_INT 4
95775: PUSH
95776: LD_INT 5
95778: PUSH
95779: LD_INT 11
95781: PUSH
95782: LD_INT 12
95784: PUSH
95785: LD_INT 15
95787: PUSH
95788: LD_INT 16
95790: PUSH
95791: LD_INT 22
95793: PUSH
95794: LD_INT 26
95796: PUSH
95797: LD_INT 36
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 101
95814: PUSH
95815: LD_INT 102
95817: PUSH
95818: LD_INT 105
95820: PUSH
95821: LD_INT 106
95823: PUSH
95824: LD_INT 108
95826: PUSH
95827: LD_INT 116
95829: PUSH
95830: LD_INT 117
95832: PUSH
95833: LD_INT 118
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: PUSH
95846: EMPTY
95847: LIST
95848: LIST
95849: ST_TO_ADDR
95850: GO 98737
95852: LD_INT 4
95854: DOUBLE
95855: EQUAL
95856: IFTRUE 95860
95858: GO 95956
95860: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95861: LD_ADDR_VAR 0 2
95865: PUSH
95866: LD_INT 2
95868: PUSH
95869: LD_INT 4
95871: PUSH
95872: LD_INT 5
95874: PUSH
95875: LD_INT 8
95877: PUSH
95878: LD_INT 11
95880: PUSH
95881: LD_INT 12
95883: PUSH
95884: LD_INT 15
95886: PUSH
95887: LD_INT 16
95889: PUSH
95890: LD_INT 22
95892: PUSH
95893: LD_INT 23
95895: PUSH
95896: LD_INT 26
95898: PUSH
95899: LD_INT 36
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 101
95918: PUSH
95919: LD_INT 102
95921: PUSH
95922: LD_INT 105
95924: PUSH
95925: LD_INT 106
95927: PUSH
95928: LD_INT 108
95930: PUSH
95931: LD_INT 116
95933: PUSH
95934: LD_INT 117
95936: PUSH
95937: LD_INT 118
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: ST_TO_ADDR
95954: GO 98737
95956: LD_INT 5
95958: DOUBLE
95959: EQUAL
95960: IFTRUE 95964
95962: GO 96076
95964: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95965: LD_ADDR_VAR 0 2
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: LD_INT 4
95975: PUSH
95976: LD_INT 5
95978: PUSH
95979: LD_INT 6
95981: PUSH
95982: LD_INT 8
95984: PUSH
95985: LD_INT 11
95987: PUSH
95988: LD_INT 12
95990: PUSH
95991: LD_INT 15
95993: PUSH
95994: LD_INT 16
95996: PUSH
95997: LD_INT 22
95999: PUSH
96000: LD_INT 23
96002: PUSH
96003: LD_INT 25
96005: PUSH
96006: LD_INT 26
96008: PUSH
96009: LD_INT 36
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 101
96030: PUSH
96031: LD_INT 102
96033: PUSH
96034: LD_INT 105
96036: PUSH
96037: LD_INT 106
96039: PUSH
96040: LD_INT 108
96042: PUSH
96043: LD_INT 109
96045: PUSH
96046: LD_INT 112
96048: PUSH
96049: LD_INT 116
96051: PUSH
96052: LD_INT 117
96054: PUSH
96055: LD_INT 118
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: ST_TO_ADDR
96074: GO 98737
96076: LD_INT 6
96078: DOUBLE
96079: EQUAL
96080: IFTRUE 96084
96082: GO 96216
96084: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96085: LD_ADDR_VAR 0 2
96089: PUSH
96090: LD_INT 2
96092: PUSH
96093: LD_INT 4
96095: PUSH
96096: LD_INT 5
96098: PUSH
96099: LD_INT 6
96101: PUSH
96102: LD_INT 8
96104: PUSH
96105: LD_INT 11
96107: PUSH
96108: LD_INT 12
96110: PUSH
96111: LD_INT 15
96113: PUSH
96114: LD_INT 16
96116: PUSH
96117: LD_INT 20
96119: PUSH
96120: LD_INT 21
96122: PUSH
96123: LD_INT 22
96125: PUSH
96126: LD_INT 23
96128: PUSH
96129: LD_INT 25
96131: PUSH
96132: LD_INT 26
96134: PUSH
96135: LD_INT 30
96137: PUSH
96138: LD_INT 31
96140: PUSH
96141: LD_INT 32
96143: PUSH
96144: LD_INT 36
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: PUSH
96168: LD_INT 101
96170: PUSH
96171: LD_INT 102
96173: PUSH
96174: LD_INT 105
96176: PUSH
96177: LD_INT 106
96179: PUSH
96180: LD_INT 108
96182: PUSH
96183: LD_INT 109
96185: PUSH
96186: LD_INT 112
96188: PUSH
96189: LD_INT 116
96191: PUSH
96192: LD_INT 117
96194: PUSH
96195: LD_INT 118
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: ST_TO_ADDR
96214: GO 98737
96216: LD_INT 7
96218: DOUBLE
96219: EQUAL
96220: IFTRUE 96224
96222: GO 96336
96224: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96225: LD_ADDR_VAR 0 2
96229: PUSH
96230: LD_INT 2
96232: PUSH
96233: LD_INT 4
96235: PUSH
96236: LD_INT 5
96238: PUSH
96239: LD_INT 7
96241: PUSH
96242: LD_INT 11
96244: PUSH
96245: LD_INT 12
96247: PUSH
96248: LD_INT 15
96250: PUSH
96251: LD_INT 16
96253: PUSH
96254: LD_INT 20
96256: PUSH
96257: LD_INT 21
96259: PUSH
96260: LD_INT 22
96262: PUSH
96263: LD_INT 23
96265: PUSH
96266: LD_INT 25
96268: PUSH
96269: LD_INT 26
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: PUSH
96288: LD_INT 101
96290: PUSH
96291: LD_INT 102
96293: PUSH
96294: LD_INT 103
96296: PUSH
96297: LD_INT 105
96299: PUSH
96300: LD_INT 106
96302: PUSH
96303: LD_INT 108
96305: PUSH
96306: LD_INT 112
96308: PUSH
96309: LD_INT 116
96311: PUSH
96312: LD_INT 117
96314: PUSH
96315: LD_INT 118
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: ST_TO_ADDR
96334: GO 98737
96336: LD_INT 8
96338: DOUBLE
96339: EQUAL
96340: IFTRUE 96344
96342: GO 96484
96344: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96345: LD_ADDR_VAR 0 2
96349: PUSH
96350: LD_INT 2
96352: PUSH
96353: LD_INT 4
96355: PUSH
96356: LD_INT 5
96358: PUSH
96359: LD_INT 6
96361: PUSH
96362: LD_INT 7
96364: PUSH
96365: LD_INT 8
96367: PUSH
96368: LD_INT 11
96370: PUSH
96371: LD_INT 12
96373: PUSH
96374: LD_INT 15
96376: PUSH
96377: LD_INT 16
96379: PUSH
96380: LD_INT 20
96382: PUSH
96383: LD_INT 21
96385: PUSH
96386: LD_INT 22
96388: PUSH
96389: LD_INT 23
96391: PUSH
96392: LD_INT 25
96394: PUSH
96395: LD_INT 26
96397: PUSH
96398: LD_INT 30
96400: PUSH
96401: LD_INT 31
96403: PUSH
96404: LD_INT 32
96406: PUSH
96407: LD_INT 36
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: PUSH
96432: LD_INT 101
96434: PUSH
96435: LD_INT 102
96437: PUSH
96438: LD_INT 103
96440: PUSH
96441: LD_INT 105
96443: PUSH
96444: LD_INT 106
96446: PUSH
96447: LD_INT 108
96449: PUSH
96450: LD_INT 109
96452: PUSH
96453: LD_INT 112
96455: PUSH
96456: LD_INT 116
96458: PUSH
96459: LD_INT 117
96461: PUSH
96462: LD_INT 118
96464: PUSH
96465: EMPTY
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: ST_TO_ADDR
96482: GO 98737
96484: LD_INT 9
96486: DOUBLE
96487: EQUAL
96488: IFTRUE 96492
96490: GO 96640
96492: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96493: LD_ADDR_VAR 0 2
96497: PUSH
96498: LD_INT 2
96500: PUSH
96501: LD_INT 4
96503: PUSH
96504: LD_INT 5
96506: PUSH
96507: LD_INT 6
96509: PUSH
96510: LD_INT 7
96512: PUSH
96513: LD_INT 8
96515: PUSH
96516: LD_INT 11
96518: PUSH
96519: LD_INT 12
96521: PUSH
96522: LD_INT 15
96524: PUSH
96525: LD_INT 16
96527: PUSH
96528: LD_INT 20
96530: PUSH
96531: LD_INT 21
96533: PUSH
96534: LD_INT 22
96536: PUSH
96537: LD_INT 23
96539: PUSH
96540: LD_INT 25
96542: PUSH
96543: LD_INT 26
96545: PUSH
96546: LD_INT 28
96548: PUSH
96549: LD_INT 30
96551: PUSH
96552: LD_INT 31
96554: PUSH
96555: LD_INT 32
96557: PUSH
96558: LD_INT 36
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 101
96586: PUSH
96587: LD_INT 102
96589: PUSH
96590: LD_INT 103
96592: PUSH
96593: LD_INT 105
96595: PUSH
96596: LD_INT 106
96598: PUSH
96599: LD_INT 108
96601: PUSH
96602: LD_INT 109
96604: PUSH
96605: LD_INT 112
96607: PUSH
96608: LD_INT 114
96610: PUSH
96611: LD_INT 116
96613: PUSH
96614: LD_INT 117
96616: PUSH
96617: LD_INT 118
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: ST_TO_ADDR
96638: GO 98737
96640: LD_INT 10
96642: DOUBLE
96643: EQUAL
96644: IFTRUE 96648
96646: GO 96844
96648: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96649: LD_ADDR_VAR 0 2
96653: PUSH
96654: LD_INT 2
96656: PUSH
96657: LD_INT 4
96659: PUSH
96660: LD_INT 5
96662: PUSH
96663: LD_INT 6
96665: PUSH
96666: LD_INT 7
96668: PUSH
96669: LD_INT 8
96671: PUSH
96672: LD_INT 9
96674: PUSH
96675: LD_INT 10
96677: PUSH
96678: LD_INT 11
96680: PUSH
96681: LD_INT 12
96683: PUSH
96684: LD_INT 13
96686: PUSH
96687: LD_INT 14
96689: PUSH
96690: LD_INT 15
96692: PUSH
96693: LD_INT 16
96695: PUSH
96696: LD_INT 17
96698: PUSH
96699: LD_INT 18
96701: PUSH
96702: LD_INT 19
96704: PUSH
96705: LD_INT 20
96707: PUSH
96708: LD_INT 21
96710: PUSH
96711: LD_INT 22
96713: PUSH
96714: LD_INT 23
96716: PUSH
96717: LD_INT 24
96719: PUSH
96720: LD_INT 25
96722: PUSH
96723: LD_INT 26
96725: PUSH
96726: LD_INT 28
96728: PUSH
96729: LD_INT 30
96731: PUSH
96732: LD_INT 31
96734: PUSH
96735: LD_INT 32
96737: PUSH
96738: LD_INT 36
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: PUSH
96772: LD_INT 101
96774: PUSH
96775: LD_INT 102
96777: PUSH
96778: LD_INT 103
96780: PUSH
96781: LD_INT 104
96783: PUSH
96784: LD_INT 105
96786: PUSH
96787: LD_INT 106
96789: PUSH
96790: LD_INT 107
96792: PUSH
96793: LD_INT 108
96795: PUSH
96796: LD_INT 109
96798: PUSH
96799: LD_INT 110
96801: PUSH
96802: LD_INT 111
96804: PUSH
96805: LD_INT 112
96807: PUSH
96808: LD_INT 114
96810: PUSH
96811: LD_INT 116
96813: PUSH
96814: LD_INT 117
96816: PUSH
96817: LD_INT 118
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: ST_TO_ADDR
96842: GO 98737
96844: LD_INT 11
96846: DOUBLE
96847: EQUAL
96848: IFTRUE 96852
96850: GO 97056
96852: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96853: LD_ADDR_VAR 0 2
96857: PUSH
96858: LD_INT 2
96860: PUSH
96861: LD_INT 3
96863: PUSH
96864: LD_INT 4
96866: PUSH
96867: LD_INT 5
96869: PUSH
96870: LD_INT 6
96872: PUSH
96873: LD_INT 7
96875: PUSH
96876: LD_INT 8
96878: PUSH
96879: LD_INT 9
96881: PUSH
96882: LD_INT 10
96884: PUSH
96885: LD_INT 11
96887: PUSH
96888: LD_INT 12
96890: PUSH
96891: LD_INT 13
96893: PUSH
96894: LD_INT 14
96896: PUSH
96897: LD_INT 15
96899: PUSH
96900: LD_INT 16
96902: PUSH
96903: LD_INT 17
96905: PUSH
96906: LD_INT 18
96908: PUSH
96909: LD_INT 19
96911: PUSH
96912: LD_INT 20
96914: PUSH
96915: LD_INT 21
96917: PUSH
96918: LD_INT 22
96920: PUSH
96921: LD_INT 23
96923: PUSH
96924: LD_INT 24
96926: PUSH
96927: LD_INT 25
96929: PUSH
96930: LD_INT 26
96932: PUSH
96933: LD_INT 28
96935: PUSH
96936: LD_INT 30
96938: PUSH
96939: LD_INT 31
96941: PUSH
96942: LD_INT 32
96944: PUSH
96945: LD_INT 34
96947: PUSH
96948: LD_INT 36
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 101
96986: PUSH
96987: LD_INT 102
96989: PUSH
96990: LD_INT 103
96992: PUSH
96993: LD_INT 104
96995: PUSH
96996: LD_INT 105
96998: PUSH
96999: LD_INT 106
97001: PUSH
97002: LD_INT 107
97004: PUSH
97005: LD_INT 108
97007: PUSH
97008: LD_INT 109
97010: PUSH
97011: LD_INT 110
97013: PUSH
97014: LD_INT 111
97016: PUSH
97017: LD_INT 112
97019: PUSH
97020: LD_INT 114
97022: PUSH
97023: LD_INT 116
97025: PUSH
97026: LD_INT 117
97028: PUSH
97029: LD_INT 118
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: ST_TO_ADDR
97054: GO 98737
97056: LD_INT 12
97058: DOUBLE
97059: EQUAL
97060: IFTRUE 97064
97062: GO 97284
97064: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97065: LD_ADDR_VAR 0 2
97069: PUSH
97070: LD_INT 1
97072: PUSH
97073: LD_INT 2
97075: PUSH
97076: LD_INT 3
97078: PUSH
97079: LD_INT 4
97081: PUSH
97082: LD_INT 5
97084: PUSH
97085: LD_INT 6
97087: PUSH
97088: LD_INT 7
97090: PUSH
97091: LD_INT 8
97093: PUSH
97094: LD_INT 9
97096: PUSH
97097: LD_INT 10
97099: PUSH
97100: LD_INT 11
97102: PUSH
97103: LD_INT 12
97105: PUSH
97106: LD_INT 13
97108: PUSH
97109: LD_INT 14
97111: PUSH
97112: LD_INT 15
97114: PUSH
97115: LD_INT 16
97117: PUSH
97118: LD_INT 17
97120: PUSH
97121: LD_INT 18
97123: PUSH
97124: LD_INT 19
97126: PUSH
97127: LD_INT 20
97129: PUSH
97130: LD_INT 21
97132: PUSH
97133: LD_INT 22
97135: PUSH
97136: LD_INT 23
97138: PUSH
97139: LD_INT 24
97141: PUSH
97142: LD_INT 25
97144: PUSH
97145: LD_INT 26
97147: PUSH
97148: LD_INT 27
97150: PUSH
97151: LD_INT 28
97153: PUSH
97154: LD_INT 30
97156: PUSH
97157: LD_INT 31
97159: PUSH
97160: LD_INT 32
97162: PUSH
97163: LD_INT 33
97165: PUSH
97166: LD_INT 34
97168: PUSH
97169: LD_INT 36
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 101
97210: PUSH
97211: LD_INT 102
97213: PUSH
97214: LD_INT 103
97216: PUSH
97217: LD_INT 104
97219: PUSH
97220: LD_INT 105
97222: PUSH
97223: LD_INT 106
97225: PUSH
97226: LD_INT 107
97228: PUSH
97229: LD_INT 108
97231: PUSH
97232: LD_INT 109
97234: PUSH
97235: LD_INT 110
97237: PUSH
97238: LD_INT 111
97240: PUSH
97241: LD_INT 112
97243: PUSH
97244: LD_INT 113
97246: PUSH
97247: LD_INT 114
97249: PUSH
97250: LD_INT 116
97252: PUSH
97253: LD_INT 117
97255: PUSH
97256: LD_INT 118
97258: PUSH
97259: EMPTY
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: ST_TO_ADDR
97282: GO 98737
97284: LD_INT 13
97286: DOUBLE
97287: EQUAL
97288: IFTRUE 97292
97290: GO 97500
97292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97293: LD_ADDR_VAR 0 2
97297: PUSH
97298: LD_INT 1
97300: PUSH
97301: LD_INT 2
97303: PUSH
97304: LD_INT 3
97306: PUSH
97307: LD_INT 4
97309: PUSH
97310: LD_INT 5
97312: PUSH
97313: LD_INT 8
97315: PUSH
97316: LD_INT 9
97318: PUSH
97319: LD_INT 10
97321: PUSH
97322: LD_INT 11
97324: PUSH
97325: LD_INT 12
97327: PUSH
97328: LD_INT 14
97330: PUSH
97331: LD_INT 15
97333: PUSH
97334: LD_INT 16
97336: PUSH
97337: LD_INT 17
97339: PUSH
97340: LD_INT 18
97342: PUSH
97343: LD_INT 19
97345: PUSH
97346: LD_INT 20
97348: PUSH
97349: LD_INT 21
97351: PUSH
97352: LD_INT 22
97354: PUSH
97355: LD_INT 23
97357: PUSH
97358: LD_INT 24
97360: PUSH
97361: LD_INT 25
97363: PUSH
97364: LD_INT 26
97366: PUSH
97367: LD_INT 27
97369: PUSH
97370: LD_INT 28
97372: PUSH
97373: LD_INT 30
97375: PUSH
97376: LD_INT 31
97378: PUSH
97379: LD_INT 32
97381: PUSH
97382: LD_INT 33
97384: PUSH
97385: LD_INT 34
97387: PUSH
97388: LD_INT 36
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 101
97426: PUSH
97427: LD_INT 102
97429: PUSH
97430: LD_INT 103
97432: PUSH
97433: LD_INT 104
97435: PUSH
97436: LD_INT 105
97438: PUSH
97439: LD_INT 106
97441: PUSH
97442: LD_INT 107
97444: PUSH
97445: LD_INT 108
97447: PUSH
97448: LD_INT 109
97450: PUSH
97451: LD_INT 110
97453: PUSH
97454: LD_INT 111
97456: PUSH
97457: LD_INT 112
97459: PUSH
97460: LD_INT 113
97462: PUSH
97463: LD_INT 114
97465: PUSH
97466: LD_INT 116
97468: PUSH
97469: LD_INT 117
97471: PUSH
97472: LD_INT 118
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: ST_TO_ADDR
97498: GO 98737
97500: LD_INT 14
97502: DOUBLE
97503: EQUAL
97504: IFTRUE 97508
97506: GO 97732
97508: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97509: LD_ADDR_VAR 0 2
97513: PUSH
97514: LD_INT 1
97516: PUSH
97517: LD_INT 2
97519: PUSH
97520: LD_INT 3
97522: PUSH
97523: LD_INT 4
97525: PUSH
97526: LD_INT 5
97528: PUSH
97529: LD_INT 6
97531: PUSH
97532: LD_INT 7
97534: PUSH
97535: LD_INT 8
97537: PUSH
97538: LD_INT 9
97540: PUSH
97541: LD_INT 10
97543: PUSH
97544: LD_INT 11
97546: PUSH
97547: LD_INT 12
97549: PUSH
97550: LD_INT 13
97552: PUSH
97553: LD_INT 14
97555: PUSH
97556: LD_INT 15
97558: PUSH
97559: LD_INT 16
97561: PUSH
97562: LD_INT 17
97564: PUSH
97565: LD_INT 18
97567: PUSH
97568: LD_INT 19
97570: PUSH
97571: LD_INT 20
97573: PUSH
97574: LD_INT 21
97576: PUSH
97577: LD_INT 22
97579: PUSH
97580: LD_INT 23
97582: PUSH
97583: LD_INT 24
97585: PUSH
97586: LD_INT 25
97588: PUSH
97589: LD_INT 26
97591: PUSH
97592: LD_INT 27
97594: PUSH
97595: LD_INT 28
97597: PUSH
97598: LD_INT 29
97600: PUSH
97601: LD_INT 30
97603: PUSH
97604: LD_INT 31
97606: PUSH
97607: LD_INT 32
97609: PUSH
97610: LD_INT 33
97612: PUSH
97613: LD_INT 34
97615: PUSH
97616: LD_INT 36
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: PUSH
97656: LD_INT 101
97658: PUSH
97659: LD_INT 102
97661: PUSH
97662: LD_INT 103
97664: PUSH
97665: LD_INT 104
97667: PUSH
97668: LD_INT 105
97670: PUSH
97671: LD_INT 106
97673: PUSH
97674: LD_INT 107
97676: PUSH
97677: LD_INT 108
97679: PUSH
97680: LD_INT 109
97682: PUSH
97683: LD_INT 110
97685: PUSH
97686: LD_INT 111
97688: PUSH
97689: LD_INT 112
97691: PUSH
97692: LD_INT 113
97694: PUSH
97695: LD_INT 114
97697: PUSH
97698: LD_INT 116
97700: PUSH
97701: LD_INT 117
97703: PUSH
97704: LD_INT 118
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: ST_TO_ADDR
97730: GO 98737
97732: LD_INT 15
97734: DOUBLE
97735: EQUAL
97736: IFTRUE 97740
97738: GO 97964
97740: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97741: LD_ADDR_VAR 0 2
97745: PUSH
97746: LD_INT 1
97748: PUSH
97749: LD_INT 2
97751: PUSH
97752: LD_INT 3
97754: PUSH
97755: LD_INT 4
97757: PUSH
97758: LD_INT 5
97760: PUSH
97761: LD_INT 6
97763: PUSH
97764: LD_INT 7
97766: PUSH
97767: LD_INT 8
97769: PUSH
97770: LD_INT 9
97772: PUSH
97773: LD_INT 10
97775: PUSH
97776: LD_INT 11
97778: PUSH
97779: LD_INT 12
97781: PUSH
97782: LD_INT 13
97784: PUSH
97785: LD_INT 14
97787: PUSH
97788: LD_INT 15
97790: PUSH
97791: LD_INT 16
97793: PUSH
97794: LD_INT 17
97796: PUSH
97797: LD_INT 18
97799: PUSH
97800: LD_INT 19
97802: PUSH
97803: LD_INT 20
97805: PUSH
97806: LD_INT 21
97808: PUSH
97809: LD_INT 22
97811: PUSH
97812: LD_INT 23
97814: PUSH
97815: LD_INT 24
97817: PUSH
97818: LD_INT 25
97820: PUSH
97821: LD_INT 26
97823: PUSH
97824: LD_INT 27
97826: PUSH
97827: LD_INT 28
97829: PUSH
97830: LD_INT 29
97832: PUSH
97833: LD_INT 30
97835: PUSH
97836: LD_INT 31
97838: PUSH
97839: LD_INT 32
97841: PUSH
97842: LD_INT 33
97844: PUSH
97845: LD_INT 34
97847: PUSH
97848: LD_INT 36
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 101
97890: PUSH
97891: LD_INT 102
97893: PUSH
97894: LD_INT 103
97896: PUSH
97897: LD_INT 104
97899: PUSH
97900: LD_INT 105
97902: PUSH
97903: LD_INT 106
97905: PUSH
97906: LD_INT 107
97908: PUSH
97909: LD_INT 108
97911: PUSH
97912: LD_INT 109
97914: PUSH
97915: LD_INT 110
97917: PUSH
97918: LD_INT 111
97920: PUSH
97921: LD_INT 112
97923: PUSH
97924: LD_INT 113
97926: PUSH
97927: LD_INT 114
97929: PUSH
97930: LD_INT 116
97932: PUSH
97933: LD_INT 117
97935: PUSH
97936: LD_INT 118
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: PUSH
97958: EMPTY
97959: LIST
97960: LIST
97961: ST_TO_ADDR
97962: GO 98737
97964: LD_INT 16
97966: DOUBLE
97967: EQUAL
97968: IFTRUE 97972
97970: GO 98108
97972: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97973: LD_ADDR_VAR 0 2
97977: PUSH
97978: LD_INT 2
97980: PUSH
97981: LD_INT 4
97983: PUSH
97984: LD_INT 5
97986: PUSH
97987: LD_INT 7
97989: PUSH
97990: LD_INT 11
97992: PUSH
97993: LD_INT 12
97995: PUSH
97996: LD_INT 15
97998: PUSH
97999: LD_INT 16
98001: PUSH
98002: LD_INT 20
98004: PUSH
98005: LD_INT 21
98007: PUSH
98008: LD_INT 22
98010: PUSH
98011: LD_INT 23
98013: PUSH
98014: LD_INT 25
98016: PUSH
98017: LD_INT 26
98019: PUSH
98020: LD_INT 30
98022: PUSH
98023: LD_INT 31
98025: PUSH
98026: LD_INT 32
98028: PUSH
98029: LD_INT 33
98031: PUSH
98032: LD_INT 34
98034: PUSH
98035: EMPTY
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 101
98058: PUSH
98059: LD_INT 102
98061: PUSH
98062: LD_INT 103
98064: PUSH
98065: LD_INT 106
98067: PUSH
98068: LD_INT 108
98070: PUSH
98071: LD_INT 112
98073: PUSH
98074: LD_INT 113
98076: PUSH
98077: LD_INT 114
98079: PUSH
98080: LD_INT 116
98082: PUSH
98083: LD_INT 117
98085: PUSH
98086: LD_INT 118
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: PUSH
98102: EMPTY
98103: LIST
98104: LIST
98105: ST_TO_ADDR
98106: GO 98737
98108: LD_INT 17
98110: DOUBLE
98111: EQUAL
98112: IFTRUE 98116
98114: GO 98340
98116: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98117: LD_ADDR_VAR 0 2
98121: PUSH
98122: LD_INT 1
98124: PUSH
98125: LD_INT 2
98127: PUSH
98128: LD_INT 3
98130: PUSH
98131: LD_INT 4
98133: PUSH
98134: LD_INT 5
98136: PUSH
98137: LD_INT 6
98139: PUSH
98140: LD_INT 7
98142: PUSH
98143: LD_INT 8
98145: PUSH
98146: LD_INT 9
98148: PUSH
98149: LD_INT 10
98151: PUSH
98152: LD_INT 11
98154: PUSH
98155: LD_INT 12
98157: PUSH
98158: LD_INT 13
98160: PUSH
98161: LD_INT 14
98163: PUSH
98164: LD_INT 15
98166: PUSH
98167: LD_INT 16
98169: PUSH
98170: LD_INT 17
98172: PUSH
98173: LD_INT 18
98175: PUSH
98176: LD_INT 19
98178: PUSH
98179: LD_INT 20
98181: PUSH
98182: LD_INT 21
98184: PUSH
98185: LD_INT 22
98187: PUSH
98188: LD_INT 23
98190: PUSH
98191: LD_INT 24
98193: PUSH
98194: LD_INT 25
98196: PUSH
98197: LD_INT 26
98199: PUSH
98200: LD_INT 27
98202: PUSH
98203: LD_INT 28
98205: PUSH
98206: LD_INT 29
98208: PUSH
98209: LD_INT 30
98211: PUSH
98212: LD_INT 31
98214: PUSH
98215: LD_INT 32
98217: PUSH
98218: LD_INT 33
98220: PUSH
98221: LD_INT 34
98223: PUSH
98224: LD_INT 36
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: PUSH
98264: LD_INT 101
98266: PUSH
98267: LD_INT 102
98269: PUSH
98270: LD_INT 103
98272: PUSH
98273: LD_INT 104
98275: PUSH
98276: LD_INT 105
98278: PUSH
98279: LD_INT 106
98281: PUSH
98282: LD_INT 107
98284: PUSH
98285: LD_INT 108
98287: PUSH
98288: LD_INT 109
98290: PUSH
98291: LD_INT 110
98293: PUSH
98294: LD_INT 111
98296: PUSH
98297: LD_INT 112
98299: PUSH
98300: LD_INT 113
98302: PUSH
98303: LD_INT 114
98305: PUSH
98306: LD_INT 116
98308: PUSH
98309: LD_INT 117
98311: PUSH
98312: LD_INT 118
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: ST_TO_ADDR
98338: GO 98737
98340: LD_INT 18
98342: DOUBLE
98343: EQUAL
98344: IFTRUE 98348
98346: GO 98496
98348: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98349: LD_ADDR_VAR 0 2
98353: PUSH
98354: LD_INT 2
98356: PUSH
98357: LD_INT 4
98359: PUSH
98360: LD_INT 5
98362: PUSH
98363: LD_INT 7
98365: PUSH
98366: LD_INT 11
98368: PUSH
98369: LD_INT 12
98371: PUSH
98372: LD_INT 15
98374: PUSH
98375: LD_INT 16
98377: PUSH
98378: LD_INT 20
98380: PUSH
98381: LD_INT 21
98383: PUSH
98384: LD_INT 22
98386: PUSH
98387: LD_INT 23
98389: PUSH
98390: LD_INT 25
98392: PUSH
98393: LD_INT 26
98395: PUSH
98396: LD_INT 30
98398: PUSH
98399: LD_INT 31
98401: PUSH
98402: LD_INT 32
98404: PUSH
98405: LD_INT 33
98407: PUSH
98408: LD_INT 34
98410: PUSH
98411: LD_INT 35
98413: PUSH
98414: LD_INT 36
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: LIST
98437: LIST
98438: LIST
98439: PUSH
98440: LD_INT 101
98442: PUSH
98443: LD_INT 102
98445: PUSH
98446: LD_INT 103
98448: PUSH
98449: LD_INT 106
98451: PUSH
98452: LD_INT 108
98454: PUSH
98455: LD_INT 112
98457: PUSH
98458: LD_INT 113
98460: PUSH
98461: LD_INT 114
98463: PUSH
98464: LD_INT 115
98466: PUSH
98467: LD_INT 116
98469: PUSH
98470: LD_INT 117
98472: PUSH
98473: LD_INT 118
98475: PUSH
98476: EMPTY
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: PUSH
98490: EMPTY
98491: LIST
98492: LIST
98493: ST_TO_ADDR
98494: GO 98737
98496: LD_INT 19
98498: DOUBLE
98499: EQUAL
98500: IFTRUE 98504
98502: GO 98736
98504: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98505: LD_ADDR_VAR 0 2
98509: PUSH
98510: LD_INT 1
98512: PUSH
98513: LD_INT 2
98515: PUSH
98516: LD_INT 3
98518: PUSH
98519: LD_INT 4
98521: PUSH
98522: LD_INT 5
98524: PUSH
98525: LD_INT 6
98527: PUSH
98528: LD_INT 7
98530: PUSH
98531: LD_INT 8
98533: PUSH
98534: LD_INT 9
98536: PUSH
98537: LD_INT 10
98539: PUSH
98540: LD_INT 11
98542: PUSH
98543: LD_INT 12
98545: PUSH
98546: LD_INT 13
98548: PUSH
98549: LD_INT 14
98551: PUSH
98552: LD_INT 15
98554: PUSH
98555: LD_INT 16
98557: PUSH
98558: LD_INT 17
98560: PUSH
98561: LD_INT 18
98563: PUSH
98564: LD_INT 19
98566: PUSH
98567: LD_INT 20
98569: PUSH
98570: LD_INT 21
98572: PUSH
98573: LD_INT 22
98575: PUSH
98576: LD_INT 23
98578: PUSH
98579: LD_INT 24
98581: PUSH
98582: LD_INT 25
98584: PUSH
98585: LD_INT 26
98587: PUSH
98588: LD_INT 27
98590: PUSH
98591: LD_INT 28
98593: PUSH
98594: LD_INT 29
98596: PUSH
98597: LD_INT 30
98599: PUSH
98600: LD_INT 31
98602: PUSH
98603: LD_INT 32
98605: PUSH
98606: LD_INT 33
98608: PUSH
98609: LD_INT 34
98611: PUSH
98612: LD_INT 35
98614: PUSH
98615: LD_INT 36
98617: PUSH
98618: EMPTY
98619: LIST
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: PUSH
98656: LD_INT 101
98658: PUSH
98659: LD_INT 102
98661: PUSH
98662: LD_INT 103
98664: PUSH
98665: LD_INT 104
98667: PUSH
98668: LD_INT 105
98670: PUSH
98671: LD_INT 106
98673: PUSH
98674: LD_INT 107
98676: PUSH
98677: LD_INT 108
98679: PUSH
98680: LD_INT 109
98682: PUSH
98683: LD_INT 110
98685: PUSH
98686: LD_INT 111
98688: PUSH
98689: LD_INT 112
98691: PUSH
98692: LD_INT 113
98694: PUSH
98695: LD_INT 114
98697: PUSH
98698: LD_INT 115
98700: PUSH
98701: LD_INT 116
98703: PUSH
98704: LD_INT 117
98706: PUSH
98707: LD_INT 118
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: ST_TO_ADDR
98734: GO 98737
98736: POP
// end else
98737: GO 98968
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98739: LD_ADDR_VAR 0 2
98743: PUSH
98744: LD_INT 1
98746: PUSH
98747: LD_INT 2
98749: PUSH
98750: LD_INT 3
98752: PUSH
98753: LD_INT 4
98755: PUSH
98756: LD_INT 5
98758: PUSH
98759: LD_INT 6
98761: PUSH
98762: LD_INT 7
98764: PUSH
98765: LD_INT 8
98767: PUSH
98768: LD_INT 9
98770: PUSH
98771: LD_INT 10
98773: PUSH
98774: LD_INT 11
98776: PUSH
98777: LD_INT 12
98779: PUSH
98780: LD_INT 13
98782: PUSH
98783: LD_INT 14
98785: PUSH
98786: LD_INT 15
98788: PUSH
98789: LD_INT 16
98791: PUSH
98792: LD_INT 17
98794: PUSH
98795: LD_INT 18
98797: PUSH
98798: LD_INT 19
98800: PUSH
98801: LD_INT 20
98803: PUSH
98804: LD_INT 21
98806: PUSH
98807: LD_INT 22
98809: PUSH
98810: LD_INT 23
98812: PUSH
98813: LD_INT 24
98815: PUSH
98816: LD_INT 25
98818: PUSH
98819: LD_INT 26
98821: PUSH
98822: LD_INT 27
98824: PUSH
98825: LD_INT 28
98827: PUSH
98828: LD_INT 29
98830: PUSH
98831: LD_INT 30
98833: PUSH
98834: LD_INT 31
98836: PUSH
98837: LD_INT 32
98839: PUSH
98840: LD_INT 33
98842: PUSH
98843: LD_INT 34
98845: PUSH
98846: LD_INT 35
98848: PUSH
98849: LD_INT 36
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: PUSH
98890: LD_INT 101
98892: PUSH
98893: LD_INT 102
98895: PUSH
98896: LD_INT 103
98898: PUSH
98899: LD_INT 104
98901: PUSH
98902: LD_INT 105
98904: PUSH
98905: LD_INT 106
98907: PUSH
98908: LD_INT 107
98910: PUSH
98911: LD_INT 108
98913: PUSH
98914: LD_INT 109
98916: PUSH
98917: LD_INT 110
98919: PUSH
98920: LD_INT 111
98922: PUSH
98923: LD_INT 112
98925: PUSH
98926: LD_INT 113
98928: PUSH
98929: LD_INT 114
98931: PUSH
98932: LD_INT 115
98934: PUSH
98935: LD_INT 116
98937: PUSH
98938: LD_INT 117
98940: PUSH
98941: LD_INT 118
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: PUSH
98964: EMPTY
98965: LIST
98966: LIST
98967: ST_TO_ADDR
// if result then
98968: LD_VAR 0 2
98972: IFFALSE 99758
// begin normal :=  ;
98974: LD_ADDR_VAR 0 5
98978: PUSH
98979: LD_STRING 
98981: ST_TO_ADDR
// hardcore :=  ;
98982: LD_ADDR_VAR 0 6
98986: PUSH
98987: LD_STRING 
98989: ST_TO_ADDR
// active :=  ;
98990: LD_ADDR_VAR 0 7
98994: PUSH
98995: LD_STRING 
98997: ST_TO_ADDR
// for i = 1 to normalCounter do
98998: LD_ADDR_VAR 0 8
99002: PUSH
99003: DOUBLE
99004: LD_INT 1
99006: DEC
99007: ST_TO_ADDR
99008: LD_EXP 100
99012: PUSH
99013: FOR_TO
99014: IFFALSE 99115
// begin tmp := 0 ;
99016: LD_ADDR_VAR 0 3
99020: PUSH
99021: LD_STRING 0
99023: ST_TO_ADDR
// if result [ 1 ] then
99024: LD_VAR 0 2
99028: PUSH
99029: LD_INT 1
99031: ARRAY
99032: IFFALSE 99097
// if result [ 1 ] [ 1 ] = i then
99034: LD_VAR 0 2
99038: PUSH
99039: LD_INT 1
99041: ARRAY
99042: PUSH
99043: LD_INT 1
99045: ARRAY
99046: PUSH
99047: LD_VAR 0 8
99051: EQUAL
99052: IFFALSE 99097
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99054: LD_ADDR_VAR 0 2
99058: PUSH
99059: LD_VAR 0 2
99063: PPUSH
99064: LD_INT 1
99066: PPUSH
99067: LD_VAR 0 2
99071: PUSH
99072: LD_INT 1
99074: ARRAY
99075: PPUSH
99076: LD_INT 1
99078: PPUSH
99079: CALL_OW 3
99083: PPUSH
99084: CALL_OW 1
99088: ST_TO_ADDR
// tmp := 1 ;
99089: LD_ADDR_VAR 0 3
99093: PUSH
99094: LD_STRING 1
99096: ST_TO_ADDR
// end ; normal := normal & tmp ;
99097: LD_ADDR_VAR 0 5
99101: PUSH
99102: LD_VAR 0 5
99106: PUSH
99107: LD_VAR 0 3
99111: STR
99112: ST_TO_ADDR
// end ;
99113: GO 99013
99115: POP
99116: POP
// for i = 1 to hardcoreCounter do
99117: LD_ADDR_VAR 0 8
99121: PUSH
99122: DOUBLE
99123: LD_INT 1
99125: DEC
99126: ST_TO_ADDR
99127: LD_EXP 101
99131: PUSH
99132: FOR_TO
99133: IFFALSE 99238
// begin tmp := 0 ;
99135: LD_ADDR_VAR 0 3
99139: PUSH
99140: LD_STRING 0
99142: ST_TO_ADDR
// if result [ 2 ] then
99143: LD_VAR 0 2
99147: PUSH
99148: LD_INT 2
99150: ARRAY
99151: IFFALSE 99220
// if result [ 2 ] [ 1 ] = 100 + i then
99153: LD_VAR 0 2
99157: PUSH
99158: LD_INT 2
99160: ARRAY
99161: PUSH
99162: LD_INT 1
99164: ARRAY
99165: PUSH
99166: LD_INT 100
99168: PUSH
99169: LD_VAR 0 8
99173: PLUS
99174: EQUAL
99175: IFFALSE 99220
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99177: LD_ADDR_VAR 0 2
99181: PUSH
99182: LD_VAR 0 2
99186: PPUSH
99187: LD_INT 2
99189: PPUSH
99190: LD_VAR 0 2
99194: PUSH
99195: LD_INT 2
99197: ARRAY
99198: PPUSH
99199: LD_INT 1
99201: PPUSH
99202: CALL_OW 3
99206: PPUSH
99207: CALL_OW 1
99211: ST_TO_ADDR
// tmp := 1 ;
99212: LD_ADDR_VAR 0 3
99216: PUSH
99217: LD_STRING 1
99219: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99220: LD_ADDR_VAR 0 6
99224: PUSH
99225: LD_VAR 0 6
99229: PUSH
99230: LD_VAR 0 3
99234: STR
99235: ST_TO_ADDR
// end ;
99236: GO 99132
99238: POP
99239: POP
// if isGameLoad then
99240: LD_VAR 0 1
99244: IFFALSE 99719
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99246: LD_ADDR_VAR 0 4
99250: PUSH
99251: LD_EXP 104
99255: PUSH
99256: LD_EXP 103
99260: PUSH
99261: LD_EXP 105
99265: PUSH
99266: LD_EXP 102
99270: PUSH
99271: LD_EXP 106
99275: PUSH
99276: LD_EXP 107
99280: PUSH
99281: LD_EXP 108
99285: PUSH
99286: LD_EXP 109
99290: PUSH
99291: LD_EXP 110
99295: PUSH
99296: LD_EXP 111
99300: PUSH
99301: LD_EXP 112
99305: PUSH
99306: LD_EXP 113
99310: PUSH
99311: LD_EXP 114
99315: PUSH
99316: LD_EXP 115
99320: PUSH
99321: LD_EXP 123
99325: PUSH
99326: LD_EXP 124
99330: PUSH
99331: LD_EXP 125
99335: PUSH
99336: LD_EXP 126
99340: PUSH
99341: LD_EXP 128
99345: PUSH
99346: LD_EXP 129
99350: PUSH
99351: LD_EXP 130
99355: PUSH
99356: LD_EXP 133
99360: PUSH
99361: LD_EXP 135
99365: PUSH
99366: LD_EXP 136
99370: PUSH
99371: LD_EXP 137
99375: PUSH
99376: LD_EXP 139
99380: PUSH
99381: LD_EXP 140
99385: PUSH
99386: LD_EXP 143
99390: PUSH
99391: LD_EXP 144
99395: PUSH
99396: LD_EXP 145
99400: PUSH
99401: LD_EXP 146
99405: PUSH
99406: LD_EXP 147
99410: PUSH
99411: LD_EXP 148
99415: PUSH
99416: LD_EXP 149
99420: PUSH
99421: LD_EXP 150
99425: PUSH
99426: LD_EXP 151
99430: PUSH
99431: LD_EXP 116
99435: PUSH
99436: LD_EXP 117
99440: PUSH
99441: LD_EXP 120
99445: PUSH
99446: LD_EXP 121
99450: PUSH
99451: LD_EXP 122
99455: PUSH
99456: LD_EXP 118
99460: PUSH
99461: LD_EXP 119
99465: PUSH
99466: LD_EXP 127
99470: PUSH
99471: LD_EXP 131
99475: PUSH
99476: LD_EXP 132
99480: PUSH
99481: LD_EXP 134
99485: PUSH
99486: LD_EXP 138
99490: PUSH
99491: LD_EXP 141
99495: PUSH
99496: LD_EXP 142
99500: PUSH
99501: LD_EXP 152
99505: PUSH
99506: LD_EXP 153
99510: PUSH
99511: LD_EXP 154
99515: PUSH
99516: LD_EXP 155
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: ST_TO_ADDR
// tmp :=  ;
99577: LD_ADDR_VAR 0 3
99581: PUSH
99582: LD_STRING 
99584: ST_TO_ADDR
// for i = 1 to normalCounter do
99585: LD_ADDR_VAR 0 8
99589: PUSH
99590: DOUBLE
99591: LD_INT 1
99593: DEC
99594: ST_TO_ADDR
99595: LD_EXP 100
99599: PUSH
99600: FOR_TO
99601: IFFALSE 99637
// begin if flags [ i ] then
99603: LD_VAR 0 4
99607: PUSH
99608: LD_VAR 0 8
99612: ARRAY
99613: IFFALSE 99635
// tmp := tmp & i & ; ;
99615: LD_ADDR_VAR 0 3
99619: PUSH
99620: LD_VAR 0 3
99624: PUSH
99625: LD_VAR 0 8
99629: STR
99630: PUSH
99631: LD_STRING ;
99633: STR
99634: ST_TO_ADDR
// end ;
99635: GO 99600
99637: POP
99638: POP
// for i = 1 to hardcoreCounter do
99639: LD_ADDR_VAR 0 8
99643: PUSH
99644: DOUBLE
99645: LD_INT 1
99647: DEC
99648: ST_TO_ADDR
99649: LD_EXP 101
99653: PUSH
99654: FOR_TO
99655: IFFALSE 99701
// begin if flags [ normalCounter + i ] then
99657: LD_VAR 0 4
99661: PUSH
99662: LD_EXP 100
99666: PUSH
99667: LD_VAR 0 8
99671: PLUS
99672: ARRAY
99673: IFFALSE 99699
// tmp := tmp & ( 100 + i ) & ; ;
99675: LD_ADDR_VAR 0 3
99679: PUSH
99680: LD_VAR 0 3
99684: PUSH
99685: LD_INT 100
99687: PUSH
99688: LD_VAR 0 8
99692: PLUS
99693: STR
99694: PUSH
99695: LD_STRING ;
99697: STR
99698: ST_TO_ADDR
// end ;
99699: GO 99654
99701: POP
99702: POP
// if tmp then
99703: LD_VAR 0 3
99707: IFFALSE 99719
// active := tmp ;
99709: LD_ADDR_VAR 0 7
99713: PUSH
99714: LD_VAR 0 3
99718: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99719: LD_STRING getStreamItemsFromMission("
99721: PUSH
99722: LD_VAR 0 5
99726: STR
99727: PUSH
99728: LD_STRING ","
99730: STR
99731: PUSH
99732: LD_VAR 0 6
99736: STR
99737: PUSH
99738: LD_STRING ","
99740: STR
99741: PUSH
99742: LD_VAR 0 7
99746: STR
99747: PUSH
99748: LD_STRING ")
99750: STR
99751: PPUSH
99752: CALL_OW 559
// end else
99756: GO 99765
// ToLua ( getStreamItemsFromMission("","","") ) ;
99758: LD_STRING getStreamItemsFromMission("","","")
99760: PPUSH
99761: CALL_OW 559
// end ;
99765: LD_VAR 0 2
99769: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99770: LD_EXP 99
99774: PUSH
99775: LD_EXP 104
99779: AND
99780: IFFALSE 99904
99782: GO 99784
99784: DISABLE
99785: LD_INT 0
99787: PPUSH
99788: PPUSH
// begin enable ;
99789: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99790: LD_ADDR_VAR 0 2
99794: PUSH
99795: LD_INT 22
99797: PUSH
99798: LD_OWVAR 2
99802: PUSH
99803: EMPTY
99804: LIST
99805: LIST
99806: PUSH
99807: LD_INT 2
99809: PUSH
99810: LD_INT 34
99812: PUSH
99813: LD_INT 7
99815: PUSH
99816: EMPTY
99817: LIST
99818: LIST
99819: PUSH
99820: LD_INT 34
99822: PUSH
99823: LD_INT 45
99825: PUSH
99826: EMPTY
99827: LIST
99828: LIST
99829: PUSH
99830: LD_INT 34
99832: PUSH
99833: LD_INT 28
99835: PUSH
99836: EMPTY
99837: LIST
99838: LIST
99839: PUSH
99840: LD_INT 34
99842: PUSH
99843: LD_INT 47
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: LIST
99854: LIST
99855: LIST
99856: PUSH
99857: EMPTY
99858: LIST
99859: LIST
99860: PPUSH
99861: CALL_OW 69
99865: ST_TO_ADDR
// if not tmp then
99866: LD_VAR 0 2
99870: NOT
99871: IFFALSE 99875
// exit ;
99873: GO 99904
// for i in tmp do
99875: LD_ADDR_VAR 0 1
99879: PUSH
99880: LD_VAR 0 2
99884: PUSH
99885: FOR_IN
99886: IFFALSE 99902
// begin SetLives ( i , 0 ) ;
99888: LD_VAR 0 1
99892: PPUSH
99893: LD_INT 0
99895: PPUSH
99896: CALL_OW 234
// end ;
99900: GO 99885
99902: POP
99903: POP
// end ;
99904: PPOPN 2
99906: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99907: LD_EXP 99
99911: PUSH
99912: LD_EXP 105
99916: AND
99917: IFFALSE 100001
99919: GO 99921
99921: DISABLE
99922: LD_INT 0
99924: PPUSH
99925: PPUSH
// begin enable ;
99926: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99927: LD_ADDR_VAR 0 2
99931: PUSH
99932: LD_INT 22
99934: PUSH
99935: LD_OWVAR 2
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PUSH
99944: LD_INT 32
99946: PUSH
99947: LD_INT 3
99949: PUSH
99950: EMPTY
99951: LIST
99952: LIST
99953: PUSH
99954: EMPTY
99955: LIST
99956: LIST
99957: PPUSH
99958: CALL_OW 69
99962: ST_TO_ADDR
// if not tmp then
99963: LD_VAR 0 2
99967: NOT
99968: IFFALSE 99972
// exit ;
99970: GO 100001
// for i in tmp do
99972: LD_ADDR_VAR 0 1
99976: PUSH
99977: LD_VAR 0 2
99981: PUSH
99982: FOR_IN
99983: IFFALSE 99999
// begin SetLives ( i , 0 ) ;
99985: LD_VAR 0 1
99989: PPUSH
99990: LD_INT 0
99992: PPUSH
99993: CALL_OW 234
// end ;
99997: GO 99982
99999: POP
100000: POP
// end ;
100001: PPOPN 2
100003: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100004: LD_EXP 99
100008: PUSH
100009: LD_EXP 102
100013: AND
100014: IFFALSE 100107
100016: GO 100018
100018: DISABLE
100019: LD_INT 0
100021: PPUSH
// begin enable ;
100022: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100023: LD_ADDR_VAR 0 1
100027: PUSH
100028: LD_INT 22
100030: PUSH
100031: LD_OWVAR 2
100035: PUSH
100036: EMPTY
100037: LIST
100038: LIST
100039: PUSH
100040: LD_INT 2
100042: PUSH
100043: LD_INT 25
100045: PUSH
100046: LD_INT 5
100048: PUSH
100049: EMPTY
100050: LIST
100051: LIST
100052: PUSH
100053: LD_INT 25
100055: PUSH
100056: LD_INT 9
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: PUSH
100063: LD_INT 25
100065: PUSH
100066: LD_INT 8
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: PUSH
100073: EMPTY
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: PUSH
100079: EMPTY
100080: LIST
100081: LIST
100082: PPUSH
100083: CALL_OW 69
100087: PUSH
100088: FOR_IN
100089: IFFALSE 100105
// begin SetClass ( i , 1 ) ;
100091: LD_VAR 0 1
100095: PPUSH
100096: LD_INT 1
100098: PPUSH
100099: CALL_OW 336
// end ;
100103: GO 100088
100105: POP
100106: POP
// end ;
100107: PPOPN 1
100109: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100110: LD_EXP 99
100114: PUSH
100115: LD_EXP 103
100119: AND
100120: PUSH
100121: LD_OWVAR 65
100125: PUSH
100126: LD_INT 7
100128: LESS
100129: AND
100130: IFFALSE 100144
100132: GO 100134
100134: DISABLE
// begin enable ;
100135: ENABLE
// game_speed := 7 ;
100136: LD_ADDR_OWVAR 65
100140: PUSH
100141: LD_INT 7
100143: ST_TO_ADDR
// end ;
100144: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100145: LD_EXP 99
100149: PUSH
100150: LD_EXP 106
100154: AND
100155: IFFALSE 100357
100157: GO 100159
100159: DISABLE
100160: LD_INT 0
100162: PPUSH
100163: PPUSH
100164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100165: LD_ADDR_VAR 0 3
100169: PUSH
100170: LD_INT 81
100172: PUSH
100173: LD_OWVAR 2
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PUSH
100182: LD_INT 21
100184: PUSH
100185: LD_INT 1
100187: PUSH
100188: EMPTY
100189: LIST
100190: LIST
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PPUSH
100196: CALL_OW 69
100200: ST_TO_ADDR
// if not tmp then
100201: LD_VAR 0 3
100205: NOT
100206: IFFALSE 100210
// exit ;
100208: GO 100357
// if tmp > 5 then
100210: LD_VAR 0 3
100214: PUSH
100215: LD_INT 5
100217: GREATER
100218: IFFALSE 100230
// k := 5 else
100220: LD_ADDR_VAR 0 2
100224: PUSH
100225: LD_INT 5
100227: ST_TO_ADDR
100228: GO 100240
// k := tmp ;
100230: LD_ADDR_VAR 0 2
100234: PUSH
100235: LD_VAR 0 3
100239: ST_TO_ADDR
// for i := 1 to k do
100240: LD_ADDR_VAR 0 1
100244: PUSH
100245: DOUBLE
100246: LD_INT 1
100248: DEC
100249: ST_TO_ADDR
100250: LD_VAR 0 2
100254: PUSH
100255: FOR_TO
100256: IFFALSE 100355
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100258: LD_VAR 0 3
100262: PUSH
100263: LD_VAR 0 1
100267: ARRAY
100268: PPUSH
100269: LD_VAR 0 1
100273: PUSH
100274: LD_INT 4
100276: MOD
100277: PUSH
100278: LD_INT 1
100280: PLUS
100281: PPUSH
100282: CALL_OW 259
100286: PUSH
100287: LD_INT 10
100289: LESS
100290: IFFALSE 100353
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100292: LD_VAR 0 3
100296: PUSH
100297: LD_VAR 0 1
100301: ARRAY
100302: PPUSH
100303: LD_VAR 0 1
100307: PUSH
100308: LD_INT 4
100310: MOD
100311: PUSH
100312: LD_INT 1
100314: PLUS
100315: PPUSH
100316: LD_VAR 0 3
100320: PUSH
100321: LD_VAR 0 1
100325: ARRAY
100326: PPUSH
100327: LD_VAR 0 1
100331: PUSH
100332: LD_INT 4
100334: MOD
100335: PUSH
100336: LD_INT 1
100338: PLUS
100339: PPUSH
100340: CALL_OW 259
100344: PUSH
100345: LD_INT 1
100347: PLUS
100348: PPUSH
100349: CALL_OW 237
100353: GO 100255
100355: POP
100356: POP
// end ;
100357: PPOPN 3
100359: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100360: LD_EXP 99
100364: PUSH
100365: LD_EXP 107
100369: AND
100370: IFFALSE 100390
100372: GO 100374
100374: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100375: LD_INT 4
100377: PPUSH
100378: LD_OWVAR 2
100382: PPUSH
100383: LD_INT 0
100385: PPUSH
100386: CALL_OW 324
100390: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100391: LD_EXP 99
100395: PUSH
100396: LD_EXP 136
100400: AND
100401: IFFALSE 100421
100403: GO 100405
100405: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100406: LD_INT 19
100408: PPUSH
100409: LD_OWVAR 2
100413: PPUSH
100414: LD_INT 0
100416: PPUSH
100417: CALL_OW 324
100421: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100422: LD_EXP 99
100426: PUSH
100427: LD_EXP 108
100431: AND
100432: IFFALSE 100534
100434: GO 100436
100436: DISABLE
100437: LD_INT 0
100439: PPUSH
100440: PPUSH
// begin enable ;
100441: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100442: LD_ADDR_VAR 0 2
100446: PUSH
100447: LD_INT 22
100449: PUSH
100450: LD_OWVAR 2
100454: PUSH
100455: EMPTY
100456: LIST
100457: LIST
100458: PUSH
100459: LD_INT 2
100461: PUSH
100462: LD_INT 34
100464: PUSH
100465: LD_INT 11
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: PUSH
100472: LD_INT 34
100474: PUSH
100475: LD_INT 30
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: EMPTY
100483: LIST
100484: LIST
100485: LIST
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: PPUSH
100491: CALL_OW 69
100495: ST_TO_ADDR
// if not tmp then
100496: LD_VAR 0 2
100500: NOT
100501: IFFALSE 100505
// exit ;
100503: GO 100534
// for i in tmp do
100505: LD_ADDR_VAR 0 1
100509: PUSH
100510: LD_VAR 0 2
100514: PUSH
100515: FOR_IN
100516: IFFALSE 100532
// begin SetLives ( i , 0 ) ;
100518: LD_VAR 0 1
100522: PPUSH
100523: LD_INT 0
100525: PPUSH
100526: CALL_OW 234
// end ;
100530: GO 100515
100532: POP
100533: POP
// end ;
100534: PPOPN 2
100536: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100537: LD_EXP 99
100541: PUSH
100542: LD_EXP 109
100546: AND
100547: IFFALSE 100567
100549: GO 100551
100551: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100552: LD_INT 32
100554: PPUSH
100555: LD_OWVAR 2
100559: PPUSH
100560: LD_INT 0
100562: PPUSH
100563: CALL_OW 324
100567: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100568: LD_EXP 99
100572: PUSH
100573: LD_EXP 110
100577: AND
100578: IFFALSE 100759
100580: GO 100582
100582: DISABLE
100583: LD_INT 0
100585: PPUSH
100586: PPUSH
100587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100588: LD_ADDR_VAR 0 2
100592: PUSH
100593: LD_INT 22
100595: PUSH
100596: LD_OWVAR 2
100600: PUSH
100601: EMPTY
100602: LIST
100603: LIST
100604: PUSH
100605: LD_INT 33
100607: PUSH
100608: LD_INT 3
100610: PUSH
100611: EMPTY
100612: LIST
100613: LIST
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: PPUSH
100619: CALL_OW 69
100623: ST_TO_ADDR
// if not tmp then
100624: LD_VAR 0 2
100628: NOT
100629: IFFALSE 100633
// exit ;
100631: GO 100759
// side := 0 ;
100633: LD_ADDR_VAR 0 3
100637: PUSH
100638: LD_INT 0
100640: ST_TO_ADDR
// for i := 1 to 8 do
100641: LD_ADDR_VAR 0 1
100645: PUSH
100646: DOUBLE
100647: LD_INT 1
100649: DEC
100650: ST_TO_ADDR
100651: LD_INT 8
100653: PUSH
100654: FOR_TO
100655: IFFALSE 100703
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100657: LD_OWVAR 2
100661: PUSH
100662: LD_VAR 0 1
100666: NONEQUAL
100667: PUSH
100668: LD_OWVAR 2
100672: PPUSH
100673: LD_VAR 0 1
100677: PPUSH
100678: CALL_OW 81
100682: PUSH
100683: LD_INT 2
100685: EQUAL
100686: AND
100687: IFFALSE 100701
// begin side := i ;
100689: LD_ADDR_VAR 0 3
100693: PUSH
100694: LD_VAR 0 1
100698: ST_TO_ADDR
// break ;
100699: GO 100703
// end ;
100701: GO 100654
100703: POP
100704: POP
// if not side then
100705: LD_VAR 0 3
100709: NOT
100710: IFFALSE 100714
// exit ;
100712: GO 100759
// for i := 1 to tmp do
100714: LD_ADDR_VAR 0 1
100718: PUSH
100719: DOUBLE
100720: LD_INT 1
100722: DEC
100723: ST_TO_ADDR
100724: LD_VAR 0 2
100728: PUSH
100729: FOR_TO
100730: IFFALSE 100757
// if Prob ( 60 ) then
100732: LD_INT 60
100734: PPUSH
100735: CALL_OW 13
100739: IFFALSE 100755
// SetSide ( i , side ) ;
100741: LD_VAR 0 1
100745: PPUSH
100746: LD_VAR 0 3
100750: PPUSH
100751: CALL_OW 235
100755: GO 100729
100757: POP
100758: POP
// end ;
100759: PPOPN 3
100761: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100762: LD_EXP 99
100766: PUSH
100767: LD_EXP 112
100771: AND
100772: IFFALSE 100891
100774: GO 100776
100776: DISABLE
100777: LD_INT 0
100779: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100780: LD_ADDR_VAR 0 1
100784: PUSH
100785: LD_INT 22
100787: PUSH
100788: LD_OWVAR 2
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 21
100799: PUSH
100800: LD_INT 1
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 3
100809: PUSH
100810: LD_INT 23
100812: PUSH
100813: LD_INT 0
100815: PUSH
100816: EMPTY
100817: LIST
100818: LIST
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: PUSH
100824: EMPTY
100825: LIST
100826: LIST
100827: LIST
100828: PPUSH
100829: CALL_OW 69
100833: PUSH
100834: FOR_IN
100835: IFFALSE 100889
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100837: LD_VAR 0 1
100841: PPUSH
100842: CALL_OW 257
100846: PUSH
100847: LD_INT 1
100849: PUSH
100850: LD_INT 2
100852: PUSH
100853: LD_INT 3
100855: PUSH
100856: LD_INT 4
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: IN
100865: IFFALSE 100887
// SetClass ( un , rand ( 1 , 4 ) ) ;
100867: LD_VAR 0 1
100871: PPUSH
100872: LD_INT 1
100874: PPUSH
100875: LD_INT 4
100877: PPUSH
100878: CALL_OW 12
100882: PPUSH
100883: CALL_OW 336
100887: GO 100834
100889: POP
100890: POP
// end ;
100891: PPOPN 1
100893: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100894: LD_EXP 99
100898: PUSH
100899: LD_EXP 111
100903: AND
100904: IFFALSE 100983
100906: GO 100908
100908: DISABLE
100909: LD_INT 0
100911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100912: LD_ADDR_VAR 0 1
100916: PUSH
100917: LD_INT 22
100919: PUSH
100920: LD_OWVAR 2
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PUSH
100929: LD_INT 21
100931: PUSH
100932: LD_INT 3
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: PUSH
100939: EMPTY
100940: LIST
100941: LIST
100942: PPUSH
100943: CALL_OW 69
100947: ST_TO_ADDR
// if not tmp then
100948: LD_VAR 0 1
100952: NOT
100953: IFFALSE 100957
// exit ;
100955: GO 100983
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100957: LD_VAR 0 1
100961: PUSH
100962: LD_INT 1
100964: PPUSH
100965: LD_VAR 0 1
100969: PPUSH
100970: CALL_OW 12
100974: ARRAY
100975: PPUSH
100976: LD_INT 100
100978: PPUSH
100979: CALL_OW 234
// end ;
100983: PPOPN 1
100985: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100986: LD_EXP 99
100990: PUSH
100991: LD_EXP 113
100995: AND
100996: IFFALSE 101094
100998: GO 101000
101000: DISABLE
101001: LD_INT 0
101003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101004: LD_ADDR_VAR 0 1
101008: PUSH
101009: LD_INT 22
101011: PUSH
101012: LD_OWVAR 2
101016: PUSH
101017: EMPTY
101018: LIST
101019: LIST
101020: PUSH
101021: LD_INT 21
101023: PUSH
101024: LD_INT 1
101026: PUSH
101027: EMPTY
101028: LIST
101029: LIST
101030: PUSH
101031: EMPTY
101032: LIST
101033: LIST
101034: PPUSH
101035: CALL_OW 69
101039: ST_TO_ADDR
// if not tmp then
101040: LD_VAR 0 1
101044: NOT
101045: IFFALSE 101049
// exit ;
101047: GO 101094
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101049: LD_VAR 0 1
101053: PUSH
101054: LD_INT 1
101056: PPUSH
101057: LD_VAR 0 1
101061: PPUSH
101062: CALL_OW 12
101066: ARRAY
101067: PPUSH
101068: LD_INT 1
101070: PPUSH
101071: LD_INT 4
101073: PPUSH
101074: CALL_OW 12
101078: PPUSH
101079: LD_INT 3000
101081: PPUSH
101082: LD_INT 9000
101084: PPUSH
101085: CALL_OW 12
101089: PPUSH
101090: CALL_OW 492
// end ;
101094: PPOPN 1
101096: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101097: LD_EXP 99
101101: PUSH
101102: LD_EXP 114
101106: AND
101107: IFFALSE 101127
101109: GO 101111
101111: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101112: LD_INT 1
101114: PPUSH
101115: LD_OWVAR 2
101119: PPUSH
101120: LD_INT 0
101122: PPUSH
101123: CALL_OW 324
101127: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101128: LD_EXP 99
101132: PUSH
101133: LD_EXP 115
101137: AND
101138: IFFALSE 101221
101140: GO 101142
101142: DISABLE
101143: LD_INT 0
101145: PPUSH
101146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101147: LD_ADDR_VAR 0 2
101151: PUSH
101152: LD_INT 22
101154: PUSH
101155: LD_OWVAR 2
101159: PUSH
101160: EMPTY
101161: LIST
101162: LIST
101163: PUSH
101164: LD_INT 21
101166: PUSH
101167: LD_INT 3
101169: PUSH
101170: EMPTY
101171: LIST
101172: LIST
101173: PUSH
101174: EMPTY
101175: LIST
101176: LIST
101177: PPUSH
101178: CALL_OW 69
101182: ST_TO_ADDR
// if not tmp then
101183: LD_VAR 0 2
101187: NOT
101188: IFFALSE 101192
// exit ;
101190: GO 101221
// for i in tmp do
101192: LD_ADDR_VAR 0 1
101196: PUSH
101197: LD_VAR 0 2
101201: PUSH
101202: FOR_IN
101203: IFFALSE 101219
// SetBLevel ( i , 10 ) ;
101205: LD_VAR 0 1
101209: PPUSH
101210: LD_INT 10
101212: PPUSH
101213: CALL_OW 241
101217: GO 101202
101219: POP
101220: POP
// end ;
101221: PPOPN 2
101223: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101224: LD_EXP 99
101228: PUSH
101229: LD_EXP 116
101233: AND
101234: IFFALSE 101345
101236: GO 101238
101238: DISABLE
101239: LD_INT 0
101241: PPUSH
101242: PPUSH
101243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101244: LD_ADDR_VAR 0 3
101248: PUSH
101249: LD_INT 22
101251: PUSH
101252: LD_OWVAR 2
101256: PUSH
101257: EMPTY
101258: LIST
101259: LIST
101260: PUSH
101261: LD_INT 25
101263: PUSH
101264: LD_INT 1
101266: PUSH
101267: EMPTY
101268: LIST
101269: LIST
101270: PUSH
101271: EMPTY
101272: LIST
101273: LIST
101274: PPUSH
101275: CALL_OW 69
101279: ST_TO_ADDR
// if not tmp then
101280: LD_VAR 0 3
101284: NOT
101285: IFFALSE 101289
// exit ;
101287: GO 101345
// un := tmp [ rand ( 1 , tmp ) ] ;
101289: LD_ADDR_VAR 0 2
101293: PUSH
101294: LD_VAR 0 3
101298: PUSH
101299: LD_INT 1
101301: PPUSH
101302: LD_VAR 0 3
101306: PPUSH
101307: CALL_OW 12
101311: ARRAY
101312: ST_TO_ADDR
// if Crawls ( un ) then
101313: LD_VAR 0 2
101317: PPUSH
101318: CALL_OW 318
101322: IFFALSE 101333
// ComWalk ( un ) ;
101324: LD_VAR 0 2
101328: PPUSH
101329: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101333: LD_VAR 0 2
101337: PPUSH
101338: LD_INT 5
101340: PPUSH
101341: CALL_OW 336
// end ;
101345: PPOPN 3
101347: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101348: LD_EXP 99
101352: PUSH
101353: LD_EXP 117
101357: AND
101358: PUSH
101359: LD_OWVAR 67
101363: PUSH
101364: LD_INT 4
101366: LESS
101367: AND
101368: IFFALSE 101387
101370: GO 101372
101372: DISABLE
// begin Difficulty := Difficulty + 1 ;
101373: LD_ADDR_OWVAR 67
101377: PUSH
101378: LD_OWVAR 67
101382: PUSH
101383: LD_INT 1
101385: PLUS
101386: ST_TO_ADDR
// end ;
101387: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101388: LD_EXP 99
101392: PUSH
101393: LD_EXP 118
101397: AND
101398: IFFALSE 101501
101400: GO 101402
101402: DISABLE
101403: LD_INT 0
101405: PPUSH
// begin for i := 1 to 5 do
101406: LD_ADDR_VAR 0 1
101410: PUSH
101411: DOUBLE
101412: LD_INT 1
101414: DEC
101415: ST_TO_ADDR
101416: LD_INT 5
101418: PUSH
101419: FOR_TO
101420: IFFALSE 101499
// begin uc_nation := nation_nature ;
101422: LD_ADDR_OWVAR 21
101426: PUSH
101427: LD_INT 0
101429: ST_TO_ADDR
// uc_side := 0 ;
101430: LD_ADDR_OWVAR 20
101434: PUSH
101435: LD_INT 0
101437: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101438: LD_ADDR_OWVAR 29
101442: PUSH
101443: LD_INT 12
101445: PUSH
101446: LD_INT 12
101448: PUSH
101449: EMPTY
101450: LIST
101451: LIST
101452: ST_TO_ADDR
// hc_agressivity := 20 ;
101453: LD_ADDR_OWVAR 35
101457: PUSH
101458: LD_INT 20
101460: ST_TO_ADDR
// hc_class := class_tiger ;
101461: LD_ADDR_OWVAR 28
101465: PUSH
101466: LD_INT 14
101468: ST_TO_ADDR
// hc_gallery :=  ;
101469: LD_ADDR_OWVAR 33
101473: PUSH
101474: LD_STRING 
101476: ST_TO_ADDR
// hc_name :=  ;
101477: LD_ADDR_OWVAR 26
101481: PUSH
101482: LD_STRING 
101484: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101485: CALL_OW 44
101489: PPUSH
101490: LD_INT 0
101492: PPUSH
101493: CALL_OW 51
// end ;
101497: GO 101419
101499: POP
101500: POP
// end ;
101501: PPOPN 1
101503: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101504: LD_EXP 99
101508: PUSH
101509: LD_EXP 119
101513: AND
101514: IFFALSE 101523
101516: GO 101518
101518: DISABLE
// StreamSibBomb ;
101519: CALL 101524 0 0
101523: END
// export function StreamSibBomb ; var i , x , y ; begin
101524: LD_INT 0
101526: PPUSH
101527: PPUSH
101528: PPUSH
101529: PPUSH
// result := false ;
101530: LD_ADDR_VAR 0 1
101534: PUSH
101535: LD_INT 0
101537: ST_TO_ADDR
// for i := 1 to 16 do
101538: LD_ADDR_VAR 0 2
101542: PUSH
101543: DOUBLE
101544: LD_INT 1
101546: DEC
101547: ST_TO_ADDR
101548: LD_INT 16
101550: PUSH
101551: FOR_TO
101552: IFFALSE 101751
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101554: LD_ADDR_VAR 0 3
101558: PUSH
101559: LD_INT 10
101561: PUSH
101562: LD_INT 20
101564: PUSH
101565: LD_INT 30
101567: PUSH
101568: LD_INT 40
101570: PUSH
101571: LD_INT 50
101573: PUSH
101574: LD_INT 60
101576: PUSH
101577: LD_INT 70
101579: PUSH
101580: LD_INT 80
101582: PUSH
101583: LD_INT 90
101585: PUSH
101586: LD_INT 100
101588: PUSH
101589: LD_INT 110
101591: PUSH
101592: LD_INT 120
101594: PUSH
101595: LD_INT 130
101597: PUSH
101598: LD_INT 140
101600: PUSH
101601: LD_INT 150
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: LIST
101608: LIST
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: LIST
101614: LIST
101615: LIST
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: PUSH
101621: LD_INT 1
101623: PPUSH
101624: LD_INT 15
101626: PPUSH
101627: CALL_OW 12
101631: ARRAY
101632: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101633: LD_ADDR_VAR 0 4
101637: PUSH
101638: LD_INT 10
101640: PUSH
101641: LD_INT 20
101643: PUSH
101644: LD_INT 30
101646: PUSH
101647: LD_INT 40
101649: PUSH
101650: LD_INT 50
101652: PUSH
101653: LD_INT 60
101655: PUSH
101656: LD_INT 70
101658: PUSH
101659: LD_INT 80
101661: PUSH
101662: LD_INT 90
101664: PUSH
101665: LD_INT 100
101667: PUSH
101668: LD_INT 110
101670: PUSH
101671: LD_INT 120
101673: PUSH
101674: LD_INT 130
101676: PUSH
101677: LD_INT 140
101679: PUSH
101680: LD_INT 150
101682: PUSH
101683: EMPTY
101684: LIST
101685: LIST
101686: LIST
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: LIST
101692: LIST
101693: LIST
101694: LIST
101695: LIST
101696: LIST
101697: LIST
101698: LIST
101699: PUSH
101700: LD_INT 1
101702: PPUSH
101703: LD_INT 15
101705: PPUSH
101706: CALL_OW 12
101710: ARRAY
101711: ST_TO_ADDR
// if ValidHex ( x , y ) then
101712: LD_VAR 0 3
101716: PPUSH
101717: LD_VAR 0 4
101721: PPUSH
101722: CALL_OW 488
101726: IFFALSE 101749
// begin result := [ x , y ] ;
101728: LD_ADDR_VAR 0 1
101732: PUSH
101733: LD_VAR 0 3
101737: PUSH
101738: LD_VAR 0 4
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: ST_TO_ADDR
// break ;
101747: GO 101751
// end ; end ;
101749: GO 101551
101751: POP
101752: POP
// if result then
101753: LD_VAR 0 1
101757: IFFALSE 101817
// begin ToLua ( playSibBomb() ) ;
101759: LD_STRING playSibBomb()
101761: PPUSH
101762: CALL_OW 559
// wait ( 0 0$14 ) ;
101766: LD_INT 490
101768: PPUSH
101769: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101773: LD_VAR 0 1
101777: PUSH
101778: LD_INT 1
101780: ARRAY
101781: PPUSH
101782: LD_VAR 0 1
101786: PUSH
101787: LD_INT 2
101789: ARRAY
101790: PPUSH
101791: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101795: LD_VAR 0 1
101799: PUSH
101800: LD_INT 1
101802: ARRAY
101803: PPUSH
101804: LD_VAR 0 1
101808: PUSH
101809: LD_INT 2
101811: ARRAY
101812: PPUSH
101813: CALL_OW 429
// end ; end ;
101817: LD_VAR 0 1
101821: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101822: LD_EXP 99
101826: PUSH
101827: LD_EXP 121
101831: AND
101832: IFFALSE 101844
101834: GO 101836
101836: DISABLE
// YouLost (  ) ;
101837: LD_STRING 
101839: PPUSH
101840: CALL_OW 104
101844: END
// every 0 0$1 trigger StreamModeActive and sFog do
101845: LD_EXP 99
101849: PUSH
101850: LD_EXP 120
101854: AND
101855: IFFALSE 101869
101857: GO 101859
101859: DISABLE
// FogOff ( your_side ) ;
101860: LD_OWVAR 2
101864: PPUSH
101865: CALL_OW 344
101869: END
// every 0 0$1 trigger StreamModeActive and sSun do
101870: LD_EXP 99
101874: PUSH
101875: LD_EXP 122
101879: AND
101880: IFFALSE 101908
101882: GO 101884
101884: DISABLE
// begin solar_recharge_percent := 0 ;
101885: LD_ADDR_OWVAR 79
101889: PUSH
101890: LD_INT 0
101892: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101893: LD_INT 10500
101895: PPUSH
101896: CALL_OW 67
// solar_recharge_percent := 100 ;
101900: LD_ADDR_OWVAR 79
101904: PUSH
101905: LD_INT 100
101907: ST_TO_ADDR
// end ;
101908: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101909: LD_EXP 99
101913: PUSH
101914: LD_EXP 123
101918: AND
101919: IFFALSE 102158
101921: GO 101923
101923: DISABLE
101924: LD_INT 0
101926: PPUSH
101927: PPUSH
101928: PPUSH
// begin tmp := [ ] ;
101929: LD_ADDR_VAR 0 3
101933: PUSH
101934: EMPTY
101935: ST_TO_ADDR
// for i := 1 to 6 do
101936: LD_ADDR_VAR 0 1
101940: PUSH
101941: DOUBLE
101942: LD_INT 1
101944: DEC
101945: ST_TO_ADDR
101946: LD_INT 6
101948: PUSH
101949: FOR_TO
101950: IFFALSE 102055
// begin uc_nation := nation_nature ;
101952: LD_ADDR_OWVAR 21
101956: PUSH
101957: LD_INT 0
101959: ST_TO_ADDR
// uc_side := 0 ;
101960: LD_ADDR_OWVAR 20
101964: PUSH
101965: LD_INT 0
101967: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101968: LD_ADDR_OWVAR 29
101972: PUSH
101973: LD_INT 12
101975: PUSH
101976: LD_INT 12
101978: PUSH
101979: EMPTY
101980: LIST
101981: LIST
101982: ST_TO_ADDR
// hc_agressivity := 20 ;
101983: LD_ADDR_OWVAR 35
101987: PUSH
101988: LD_INT 20
101990: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101991: LD_ADDR_OWVAR 28
101995: PUSH
101996: LD_INT 17
101998: ST_TO_ADDR
// hc_gallery :=  ;
101999: LD_ADDR_OWVAR 33
102003: PUSH
102004: LD_STRING 
102006: ST_TO_ADDR
// hc_name :=  ;
102007: LD_ADDR_OWVAR 26
102011: PUSH
102012: LD_STRING 
102014: ST_TO_ADDR
// un := CreateHuman ;
102015: LD_ADDR_VAR 0 2
102019: PUSH
102020: CALL_OW 44
102024: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102025: LD_VAR 0 2
102029: PPUSH
102030: LD_INT 1
102032: PPUSH
102033: CALL_OW 51
// tmp := tmp ^ un ;
102037: LD_ADDR_VAR 0 3
102041: PUSH
102042: LD_VAR 0 3
102046: PUSH
102047: LD_VAR 0 2
102051: ADD
102052: ST_TO_ADDR
// end ;
102053: GO 101949
102055: POP
102056: POP
// repeat wait ( 0 0$1 ) ;
102057: LD_INT 35
102059: PPUSH
102060: CALL_OW 67
// for un in tmp do
102064: LD_ADDR_VAR 0 2
102068: PUSH
102069: LD_VAR 0 3
102073: PUSH
102074: FOR_IN
102075: IFFALSE 102149
// begin if IsDead ( un ) then
102077: LD_VAR 0 2
102081: PPUSH
102082: CALL_OW 301
102086: IFFALSE 102106
// begin tmp := tmp diff un ;
102088: LD_ADDR_VAR 0 3
102092: PUSH
102093: LD_VAR 0 3
102097: PUSH
102098: LD_VAR 0 2
102102: DIFF
102103: ST_TO_ADDR
// continue ;
102104: GO 102074
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102106: LD_VAR 0 2
102110: PPUSH
102111: LD_INT 3
102113: PUSH
102114: LD_INT 22
102116: PUSH
102117: LD_INT 0
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: PPUSH
102128: CALL_OW 69
102132: PPUSH
102133: LD_VAR 0 2
102137: PPUSH
102138: CALL_OW 74
102142: PPUSH
102143: CALL_OW 115
// end ;
102147: GO 102074
102149: POP
102150: POP
// until not tmp ;
102151: LD_VAR 0 3
102155: NOT
102156: IFFALSE 102057
// end ;
102158: PPOPN 3
102160: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102161: LD_EXP 99
102165: PUSH
102166: LD_EXP 124
102170: AND
102171: IFFALSE 102225
102173: GO 102175
102175: DISABLE
// begin ToLua ( displayTroll(); ) ;
102176: LD_STRING displayTroll();
102178: PPUSH
102179: CALL_OW 559
// wait ( 3 3$00 ) ;
102183: LD_INT 6300
102185: PPUSH
102186: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102190: LD_STRING hideTroll();
102192: PPUSH
102193: CALL_OW 559
// wait ( 1 1$00 ) ;
102197: LD_INT 2100
102199: PPUSH
102200: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102204: LD_STRING displayTroll();
102206: PPUSH
102207: CALL_OW 559
// wait ( 1 1$00 ) ;
102211: LD_INT 2100
102213: PPUSH
102214: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102218: LD_STRING hideTroll();
102220: PPUSH
102221: CALL_OW 559
// end ;
102225: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102226: LD_EXP 99
102230: PUSH
102231: LD_EXP 125
102235: AND
102236: IFFALSE 102299
102238: GO 102240
102240: DISABLE
102241: LD_INT 0
102243: PPUSH
// begin p := 0 ;
102244: LD_ADDR_VAR 0 1
102248: PUSH
102249: LD_INT 0
102251: ST_TO_ADDR
// repeat game_speed := 1 ;
102252: LD_ADDR_OWVAR 65
102256: PUSH
102257: LD_INT 1
102259: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102260: LD_INT 35
102262: PPUSH
102263: CALL_OW 67
// p := p + 1 ;
102267: LD_ADDR_VAR 0 1
102271: PUSH
102272: LD_VAR 0 1
102276: PUSH
102277: LD_INT 1
102279: PLUS
102280: ST_TO_ADDR
// until p >= 60 ;
102281: LD_VAR 0 1
102285: PUSH
102286: LD_INT 60
102288: GREATEREQUAL
102289: IFFALSE 102252
// game_speed := 4 ;
102291: LD_ADDR_OWVAR 65
102295: PUSH
102296: LD_INT 4
102298: ST_TO_ADDR
// end ;
102299: PPOPN 1
102301: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102302: LD_EXP 99
102306: PUSH
102307: LD_EXP 126
102311: AND
102312: IFFALSE 102458
102314: GO 102316
102316: DISABLE
102317: LD_INT 0
102319: PPUSH
102320: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102321: LD_ADDR_VAR 0 1
102325: PUSH
102326: LD_INT 22
102328: PUSH
102329: LD_OWVAR 2
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: PUSH
102338: LD_INT 2
102340: PUSH
102341: LD_INT 30
102343: PUSH
102344: LD_INT 0
102346: PUSH
102347: EMPTY
102348: LIST
102349: LIST
102350: PUSH
102351: LD_INT 30
102353: PUSH
102354: LD_INT 1
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: PUSH
102361: EMPTY
102362: LIST
102363: LIST
102364: LIST
102365: PUSH
102366: EMPTY
102367: LIST
102368: LIST
102369: PPUSH
102370: CALL_OW 69
102374: ST_TO_ADDR
// if not depot then
102375: LD_VAR 0 1
102379: NOT
102380: IFFALSE 102384
// exit ;
102382: GO 102458
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102384: LD_ADDR_VAR 0 2
102388: PUSH
102389: LD_VAR 0 1
102393: PUSH
102394: LD_INT 1
102396: PPUSH
102397: LD_VAR 0 1
102401: PPUSH
102402: CALL_OW 12
102406: ARRAY
102407: PPUSH
102408: CALL_OW 274
102412: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102413: LD_VAR 0 2
102417: PPUSH
102418: LD_INT 1
102420: PPUSH
102421: LD_INT 0
102423: PPUSH
102424: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102428: LD_VAR 0 2
102432: PPUSH
102433: LD_INT 2
102435: PPUSH
102436: LD_INT 0
102438: PPUSH
102439: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102443: LD_VAR 0 2
102447: PPUSH
102448: LD_INT 3
102450: PPUSH
102451: LD_INT 0
102453: PPUSH
102454: CALL_OW 277
// end ;
102458: PPOPN 2
102460: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102461: LD_EXP 99
102465: PUSH
102466: LD_EXP 127
102470: AND
102471: IFFALSE 102568
102473: GO 102475
102475: DISABLE
102476: LD_INT 0
102478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102479: LD_ADDR_VAR 0 1
102483: PUSH
102484: LD_INT 22
102486: PUSH
102487: LD_OWVAR 2
102491: PUSH
102492: EMPTY
102493: LIST
102494: LIST
102495: PUSH
102496: LD_INT 21
102498: PUSH
102499: LD_INT 1
102501: PUSH
102502: EMPTY
102503: LIST
102504: LIST
102505: PUSH
102506: LD_INT 3
102508: PUSH
102509: LD_INT 23
102511: PUSH
102512: LD_INT 0
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: PUSH
102523: EMPTY
102524: LIST
102525: LIST
102526: LIST
102527: PPUSH
102528: CALL_OW 69
102532: ST_TO_ADDR
// if not tmp then
102533: LD_VAR 0 1
102537: NOT
102538: IFFALSE 102542
// exit ;
102540: GO 102568
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102542: LD_VAR 0 1
102546: PUSH
102547: LD_INT 1
102549: PPUSH
102550: LD_VAR 0 1
102554: PPUSH
102555: CALL_OW 12
102559: ARRAY
102560: PPUSH
102561: LD_INT 200
102563: PPUSH
102564: CALL_OW 234
// end ;
102568: PPOPN 1
102570: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102571: LD_EXP 99
102575: PUSH
102576: LD_EXP 128
102580: AND
102581: IFFALSE 102660
102583: GO 102585
102585: DISABLE
102586: LD_INT 0
102588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102589: LD_ADDR_VAR 0 1
102593: PUSH
102594: LD_INT 22
102596: PUSH
102597: LD_OWVAR 2
102601: PUSH
102602: EMPTY
102603: LIST
102604: LIST
102605: PUSH
102606: LD_INT 21
102608: PUSH
102609: LD_INT 2
102611: PUSH
102612: EMPTY
102613: LIST
102614: LIST
102615: PUSH
102616: EMPTY
102617: LIST
102618: LIST
102619: PPUSH
102620: CALL_OW 69
102624: ST_TO_ADDR
// if not tmp then
102625: LD_VAR 0 1
102629: NOT
102630: IFFALSE 102634
// exit ;
102632: GO 102660
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102634: LD_VAR 0 1
102638: PUSH
102639: LD_INT 1
102641: PPUSH
102642: LD_VAR 0 1
102646: PPUSH
102647: CALL_OW 12
102651: ARRAY
102652: PPUSH
102653: LD_INT 60
102655: PPUSH
102656: CALL_OW 234
// end ;
102660: PPOPN 1
102662: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102663: LD_EXP 99
102667: PUSH
102668: LD_EXP 129
102672: AND
102673: IFFALSE 102772
102675: GO 102677
102677: DISABLE
102678: LD_INT 0
102680: PPUSH
102681: PPUSH
// begin enable ;
102682: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102683: LD_ADDR_VAR 0 1
102687: PUSH
102688: LD_INT 22
102690: PUSH
102691: LD_OWVAR 2
102695: PUSH
102696: EMPTY
102697: LIST
102698: LIST
102699: PUSH
102700: LD_INT 61
102702: PUSH
102703: EMPTY
102704: LIST
102705: PUSH
102706: LD_INT 33
102708: PUSH
102709: LD_INT 2
102711: PUSH
102712: EMPTY
102713: LIST
102714: LIST
102715: PUSH
102716: EMPTY
102717: LIST
102718: LIST
102719: LIST
102720: PPUSH
102721: CALL_OW 69
102725: ST_TO_ADDR
// if not tmp then
102726: LD_VAR 0 1
102730: NOT
102731: IFFALSE 102735
// exit ;
102733: GO 102772
// for i in tmp do
102735: LD_ADDR_VAR 0 2
102739: PUSH
102740: LD_VAR 0 1
102744: PUSH
102745: FOR_IN
102746: IFFALSE 102770
// if IsControledBy ( i ) then
102748: LD_VAR 0 2
102752: PPUSH
102753: CALL_OW 312
102757: IFFALSE 102768
// ComUnlink ( i ) ;
102759: LD_VAR 0 2
102763: PPUSH
102764: CALL_OW 136
102768: GO 102745
102770: POP
102771: POP
// end ;
102772: PPOPN 2
102774: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102775: LD_EXP 99
102779: PUSH
102780: LD_EXP 130
102784: AND
102785: IFFALSE 102925
102787: GO 102789
102789: DISABLE
102790: LD_INT 0
102792: PPUSH
102793: PPUSH
// begin ToLua ( displayPowell(); ) ;
102794: LD_STRING displayPowell();
102796: PPUSH
102797: CALL_OW 559
// uc_side := 0 ;
102801: LD_ADDR_OWVAR 20
102805: PUSH
102806: LD_INT 0
102808: ST_TO_ADDR
// uc_nation := 2 ;
102809: LD_ADDR_OWVAR 21
102813: PUSH
102814: LD_INT 2
102816: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102817: LD_ADDR_OWVAR 37
102821: PUSH
102822: LD_INT 14
102824: ST_TO_ADDR
// vc_engine := engine_siberite ;
102825: LD_ADDR_OWVAR 39
102829: PUSH
102830: LD_INT 3
102832: ST_TO_ADDR
// vc_control := control_apeman ;
102833: LD_ADDR_OWVAR 38
102837: PUSH
102838: LD_INT 5
102840: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102841: LD_ADDR_OWVAR 40
102845: PUSH
102846: LD_INT 29
102848: ST_TO_ADDR
// un := CreateVehicle ;
102849: LD_ADDR_VAR 0 2
102853: PUSH
102854: CALL_OW 45
102858: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102859: LD_VAR 0 2
102863: PPUSH
102864: LD_INT 1
102866: PPUSH
102867: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102871: LD_INT 35
102873: PPUSH
102874: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102878: LD_VAR 0 2
102882: PPUSH
102883: LD_INT 22
102885: PUSH
102886: LD_OWVAR 2
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: PPUSH
102895: CALL_OW 69
102899: PPUSH
102900: LD_VAR 0 2
102904: PPUSH
102905: CALL_OW 74
102909: PPUSH
102910: CALL_OW 115
// until IsDead ( un ) ;
102914: LD_VAR 0 2
102918: PPUSH
102919: CALL_OW 301
102923: IFFALSE 102871
// end ;
102925: PPOPN 2
102927: END
// every 0 0$1 trigger StreamModeActive and sStu do
102928: LD_EXP 99
102932: PUSH
102933: LD_EXP 138
102937: AND
102938: IFFALSE 102954
102940: GO 102942
102942: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102943: LD_STRING displayStucuk();
102945: PPUSH
102946: CALL_OW 559
// ResetFog ;
102950: CALL_OW 335
// end ;
102954: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102955: LD_EXP 99
102959: PUSH
102960: LD_EXP 131
102964: AND
102965: IFFALSE 103106
102967: GO 102969
102969: DISABLE
102970: LD_INT 0
102972: PPUSH
102973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102974: LD_ADDR_VAR 0 2
102978: PUSH
102979: LD_INT 22
102981: PUSH
102982: LD_OWVAR 2
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: PUSH
102991: LD_INT 21
102993: PUSH
102994: LD_INT 1
102996: PUSH
102997: EMPTY
102998: LIST
102999: LIST
103000: PUSH
103001: EMPTY
103002: LIST
103003: LIST
103004: PPUSH
103005: CALL_OW 69
103009: ST_TO_ADDR
// if not tmp then
103010: LD_VAR 0 2
103014: NOT
103015: IFFALSE 103019
// exit ;
103017: GO 103106
// un := tmp [ rand ( 1 , tmp ) ] ;
103019: LD_ADDR_VAR 0 1
103023: PUSH
103024: LD_VAR 0 2
103028: PUSH
103029: LD_INT 1
103031: PPUSH
103032: LD_VAR 0 2
103036: PPUSH
103037: CALL_OW 12
103041: ARRAY
103042: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103043: LD_VAR 0 1
103047: PPUSH
103048: LD_INT 0
103050: PPUSH
103051: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103055: LD_VAR 0 1
103059: PPUSH
103060: LD_OWVAR 3
103064: PUSH
103065: LD_VAR 0 1
103069: DIFF
103070: PPUSH
103071: LD_VAR 0 1
103075: PPUSH
103076: CALL_OW 74
103080: PPUSH
103081: CALL_OW 115
// wait ( 0 0$20 ) ;
103085: LD_INT 700
103087: PPUSH
103088: CALL_OW 67
// SetSide ( un , your_side ) ;
103092: LD_VAR 0 1
103096: PPUSH
103097: LD_OWVAR 2
103101: PPUSH
103102: CALL_OW 235
// end ;
103106: PPOPN 2
103108: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103109: LD_EXP 99
103113: PUSH
103114: LD_EXP 132
103118: AND
103119: IFFALSE 103225
103121: GO 103123
103123: DISABLE
103124: LD_INT 0
103126: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103127: LD_ADDR_VAR 0 1
103131: PUSH
103132: LD_INT 22
103134: PUSH
103135: LD_OWVAR 2
103139: PUSH
103140: EMPTY
103141: LIST
103142: LIST
103143: PUSH
103144: LD_INT 2
103146: PUSH
103147: LD_INT 30
103149: PUSH
103150: LD_INT 0
103152: PUSH
103153: EMPTY
103154: LIST
103155: LIST
103156: PUSH
103157: LD_INT 30
103159: PUSH
103160: LD_INT 1
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: LIST
103171: PUSH
103172: EMPTY
103173: LIST
103174: LIST
103175: PPUSH
103176: CALL_OW 69
103180: ST_TO_ADDR
// if not depot then
103181: LD_VAR 0 1
103185: NOT
103186: IFFALSE 103190
// exit ;
103188: GO 103225
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103190: LD_VAR 0 1
103194: PUSH
103195: LD_INT 1
103197: ARRAY
103198: PPUSH
103199: CALL_OW 250
103203: PPUSH
103204: LD_VAR 0 1
103208: PUSH
103209: LD_INT 1
103211: ARRAY
103212: PPUSH
103213: CALL_OW 251
103217: PPUSH
103218: LD_INT 70
103220: PPUSH
103221: CALL_OW 495
// end ;
103225: PPOPN 1
103227: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103228: LD_EXP 99
103232: PUSH
103233: LD_EXP 133
103237: AND
103238: IFFALSE 103449
103240: GO 103242
103242: DISABLE
103243: LD_INT 0
103245: PPUSH
103246: PPUSH
103247: PPUSH
103248: PPUSH
103249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103250: LD_ADDR_VAR 0 5
103254: PUSH
103255: LD_INT 22
103257: PUSH
103258: LD_OWVAR 2
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: PUSH
103267: LD_INT 21
103269: PUSH
103270: LD_INT 1
103272: PUSH
103273: EMPTY
103274: LIST
103275: LIST
103276: PUSH
103277: EMPTY
103278: LIST
103279: LIST
103280: PPUSH
103281: CALL_OW 69
103285: ST_TO_ADDR
// if not tmp then
103286: LD_VAR 0 5
103290: NOT
103291: IFFALSE 103295
// exit ;
103293: GO 103449
// for i in tmp do
103295: LD_ADDR_VAR 0 1
103299: PUSH
103300: LD_VAR 0 5
103304: PUSH
103305: FOR_IN
103306: IFFALSE 103447
// begin d := rand ( 0 , 5 ) ;
103308: LD_ADDR_VAR 0 4
103312: PUSH
103313: LD_INT 0
103315: PPUSH
103316: LD_INT 5
103318: PPUSH
103319: CALL_OW 12
103323: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103324: LD_ADDR_VAR 0 2
103328: PUSH
103329: LD_VAR 0 1
103333: PPUSH
103334: CALL_OW 250
103338: PPUSH
103339: LD_VAR 0 4
103343: PPUSH
103344: LD_INT 3
103346: PPUSH
103347: LD_INT 12
103349: PPUSH
103350: CALL_OW 12
103354: PPUSH
103355: CALL_OW 272
103359: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103360: LD_ADDR_VAR 0 3
103364: PUSH
103365: LD_VAR 0 1
103369: PPUSH
103370: CALL_OW 251
103374: PPUSH
103375: LD_VAR 0 4
103379: PPUSH
103380: LD_INT 3
103382: PPUSH
103383: LD_INT 12
103385: PPUSH
103386: CALL_OW 12
103390: PPUSH
103391: CALL_OW 273
103395: ST_TO_ADDR
// if ValidHex ( x , y ) then
103396: LD_VAR 0 2
103400: PPUSH
103401: LD_VAR 0 3
103405: PPUSH
103406: CALL_OW 488
103410: IFFALSE 103445
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103412: LD_VAR 0 1
103416: PPUSH
103417: LD_VAR 0 2
103421: PPUSH
103422: LD_VAR 0 3
103426: PPUSH
103427: LD_INT 3
103429: PPUSH
103430: LD_INT 6
103432: PPUSH
103433: CALL_OW 12
103437: PPUSH
103438: LD_INT 1
103440: PPUSH
103441: CALL_OW 483
// end ;
103445: GO 103305
103447: POP
103448: POP
// end ;
103449: PPOPN 5
103451: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103452: LD_EXP 99
103456: PUSH
103457: LD_EXP 134
103461: AND
103462: IFFALSE 103556
103464: GO 103466
103466: DISABLE
103467: LD_INT 0
103469: PPUSH
103470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103471: LD_ADDR_VAR 0 2
103475: PUSH
103476: LD_INT 22
103478: PUSH
103479: LD_OWVAR 2
103483: PUSH
103484: EMPTY
103485: LIST
103486: LIST
103487: PUSH
103488: LD_INT 32
103490: PUSH
103491: LD_INT 1
103493: PUSH
103494: EMPTY
103495: LIST
103496: LIST
103497: PUSH
103498: LD_INT 21
103500: PUSH
103501: LD_INT 2
103503: PUSH
103504: EMPTY
103505: LIST
103506: LIST
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: LIST
103512: PPUSH
103513: CALL_OW 69
103517: ST_TO_ADDR
// if not tmp then
103518: LD_VAR 0 2
103522: NOT
103523: IFFALSE 103527
// exit ;
103525: GO 103556
// for i in tmp do
103527: LD_ADDR_VAR 0 1
103531: PUSH
103532: LD_VAR 0 2
103536: PUSH
103537: FOR_IN
103538: IFFALSE 103554
// SetFuel ( i , 0 ) ;
103540: LD_VAR 0 1
103544: PPUSH
103545: LD_INT 0
103547: PPUSH
103548: CALL_OW 240
103552: GO 103537
103554: POP
103555: POP
// end ;
103556: PPOPN 2
103558: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103559: LD_EXP 99
103563: PUSH
103564: LD_EXP 135
103568: AND
103569: IFFALSE 103635
103571: GO 103573
103573: DISABLE
103574: LD_INT 0
103576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103577: LD_ADDR_VAR 0 1
103581: PUSH
103582: LD_INT 22
103584: PUSH
103585: LD_OWVAR 2
103589: PUSH
103590: EMPTY
103591: LIST
103592: LIST
103593: PUSH
103594: LD_INT 30
103596: PUSH
103597: LD_INT 29
103599: PUSH
103600: EMPTY
103601: LIST
103602: LIST
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PPUSH
103608: CALL_OW 69
103612: ST_TO_ADDR
// if not tmp then
103613: LD_VAR 0 1
103617: NOT
103618: IFFALSE 103622
// exit ;
103620: GO 103635
// DestroyUnit ( tmp [ 1 ] ) ;
103622: LD_VAR 0 1
103626: PUSH
103627: LD_INT 1
103629: ARRAY
103630: PPUSH
103631: CALL_OW 65
// end ;
103635: PPOPN 1
103637: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103638: LD_EXP 99
103642: PUSH
103643: LD_EXP 137
103647: AND
103648: IFFALSE 103777
103650: GO 103652
103652: DISABLE
103653: LD_INT 0
103655: PPUSH
// begin uc_side := 0 ;
103656: LD_ADDR_OWVAR 20
103660: PUSH
103661: LD_INT 0
103663: ST_TO_ADDR
// uc_nation := nation_arabian ;
103664: LD_ADDR_OWVAR 21
103668: PUSH
103669: LD_INT 2
103671: ST_TO_ADDR
// hc_gallery :=  ;
103672: LD_ADDR_OWVAR 33
103676: PUSH
103677: LD_STRING 
103679: ST_TO_ADDR
// hc_name :=  ;
103680: LD_ADDR_OWVAR 26
103684: PUSH
103685: LD_STRING 
103687: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103688: LD_INT 1
103690: PPUSH
103691: LD_INT 11
103693: PPUSH
103694: LD_INT 10
103696: PPUSH
103697: CALL_OW 380
// un := CreateHuman ;
103701: LD_ADDR_VAR 0 1
103705: PUSH
103706: CALL_OW 44
103710: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103711: LD_VAR 0 1
103715: PPUSH
103716: LD_INT 1
103718: PPUSH
103719: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103723: LD_INT 35
103725: PPUSH
103726: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103730: LD_VAR 0 1
103734: PPUSH
103735: LD_INT 22
103737: PUSH
103738: LD_OWVAR 2
103742: PUSH
103743: EMPTY
103744: LIST
103745: LIST
103746: PPUSH
103747: CALL_OW 69
103751: PPUSH
103752: LD_VAR 0 1
103756: PPUSH
103757: CALL_OW 74
103761: PPUSH
103762: CALL_OW 115
// until IsDead ( un ) ;
103766: LD_VAR 0 1
103770: PPUSH
103771: CALL_OW 301
103775: IFFALSE 103723
// end ;
103777: PPOPN 1
103779: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103780: LD_EXP 99
103784: PUSH
103785: LD_EXP 139
103789: AND
103790: IFFALSE 103802
103792: GO 103794
103794: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103795: LD_STRING earthquake(getX(game), 0, 32)
103797: PPUSH
103798: CALL_OW 559
103802: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103803: LD_EXP 99
103807: PUSH
103808: LD_EXP 140
103812: AND
103813: IFFALSE 103904
103815: GO 103817
103817: DISABLE
103818: LD_INT 0
103820: PPUSH
// begin enable ;
103821: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103822: LD_ADDR_VAR 0 1
103826: PUSH
103827: LD_INT 22
103829: PUSH
103830: LD_OWVAR 2
103834: PUSH
103835: EMPTY
103836: LIST
103837: LIST
103838: PUSH
103839: LD_INT 21
103841: PUSH
103842: LD_INT 2
103844: PUSH
103845: EMPTY
103846: LIST
103847: LIST
103848: PUSH
103849: LD_INT 33
103851: PUSH
103852: LD_INT 3
103854: PUSH
103855: EMPTY
103856: LIST
103857: LIST
103858: PUSH
103859: EMPTY
103860: LIST
103861: LIST
103862: LIST
103863: PPUSH
103864: CALL_OW 69
103868: ST_TO_ADDR
// if not tmp then
103869: LD_VAR 0 1
103873: NOT
103874: IFFALSE 103878
// exit ;
103876: GO 103904
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103878: LD_VAR 0 1
103882: PUSH
103883: LD_INT 1
103885: PPUSH
103886: LD_VAR 0 1
103890: PPUSH
103891: CALL_OW 12
103895: ARRAY
103896: PPUSH
103897: LD_INT 1
103899: PPUSH
103900: CALL_OW 234
// end ;
103904: PPOPN 1
103906: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103907: LD_EXP 99
103911: PUSH
103912: LD_EXP 141
103916: AND
103917: IFFALSE 104058
103919: GO 103921
103921: DISABLE
103922: LD_INT 0
103924: PPUSH
103925: PPUSH
103926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103927: LD_ADDR_VAR 0 3
103931: PUSH
103932: LD_INT 22
103934: PUSH
103935: LD_OWVAR 2
103939: PUSH
103940: EMPTY
103941: LIST
103942: LIST
103943: PUSH
103944: LD_INT 25
103946: PUSH
103947: LD_INT 1
103949: PUSH
103950: EMPTY
103951: LIST
103952: LIST
103953: PUSH
103954: EMPTY
103955: LIST
103956: LIST
103957: PPUSH
103958: CALL_OW 69
103962: ST_TO_ADDR
// if not tmp then
103963: LD_VAR 0 3
103967: NOT
103968: IFFALSE 103972
// exit ;
103970: GO 104058
// un := tmp [ rand ( 1 , tmp ) ] ;
103972: LD_ADDR_VAR 0 2
103976: PUSH
103977: LD_VAR 0 3
103981: PUSH
103982: LD_INT 1
103984: PPUSH
103985: LD_VAR 0 3
103989: PPUSH
103990: CALL_OW 12
103994: ARRAY
103995: ST_TO_ADDR
// if Crawls ( un ) then
103996: LD_VAR 0 2
104000: PPUSH
104001: CALL_OW 318
104005: IFFALSE 104016
// ComWalk ( un ) ;
104007: LD_VAR 0 2
104011: PPUSH
104012: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104016: LD_VAR 0 2
104020: PPUSH
104021: LD_INT 9
104023: PPUSH
104024: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104028: LD_INT 28
104030: PPUSH
104031: LD_OWVAR 2
104035: PPUSH
104036: LD_INT 2
104038: PPUSH
104039: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104043: LD_INT 29
104045: PPUSH
104046: LD_OWVAR 2
104050: PPUSH
104051: LD_INT 2
104053: PPUSH
104054: CALL_OW 322
// end ;
104058: PPOPN 3
104060: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104061: LD_EXP 99
104065: PUSH
104066: LD_EXP 142
104070: AND
104071: IFFALSE 104182
104073: GO 104075
104075: DISABLE
104076: LD_INT 0
104078: PPUSH
104079: PPUSH
104080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104081: LD_ADDR_VAR 0 3
104085: PUSH
104086: LD_INT 22
104088: PUSH
104089: LD_OWVAR 2
104093: PUSH
104094: EMPTY
104095: LIST
104096: LIST
104097: PUSH
104098: LD_INT 25
104100: PUSH
104101: LD_INT 1
104103: PUSH
104104: EMPTY
104105: LIST
104106: LIST
104107: PUSH
104108: EMPTY
104109: LIST
104110: LIST
104111: PPUSH
104112: CALL_OW 69
104116: ST_TO_ADDR
// if not tmp then
104117: LD_VAR 0 3
104121: NOT
104122: IFFALSE 104126
// exit ;
104124: GO 104182
// un := tmp [ rand ( 1 , tmp ) ] ;
104126: LD_ADDR_VAR 0 2
104130: PUSH
104131: LD_VAR 0 3
104135: PUSH
104136: LD_INT 1
104138: PPUSH
104139: LD_VAR 0 3
104143: PPUSH
104144: CALL_OW 12
104148: ARRAY
104149: ST_TO_ADDR
// if Crawls ( un ) then
104150: LD_VAR 0 2
104154: PPUSH
104155: CALL_OW 318
104159: IFFALSE 104170
// ComWalk ( un ) ;
104161: LD_VAR 0 2
104165: PPUSH
104166: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104170: LD_VAR 0 2
104174: PPUSH
104175: LD_INT 8
104177: PPUSH
104178: CALL_OW 336
// end ;
104182: PPOPN 3
104184: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104185: LD_EXP 99
104189: PUSH
104190: LD_EXP 143
104194: AND
104195: IFFALSE 104339
104197: GO 104199
104199: DISABLE
104200: LD_INT 0
104202: PPUSH
104203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104204: LD_ADDR_VAR 0 2
104208: PUSH
104209: LD_INT 22
104211: PUSH
104212: LD_OWVAR 2
104216: PUSH
104217: EMPTY
104218: LIST
104219: LIST
104220: PUSH
104221: LD_INT 21
104223: PUSH
104224: LD_INT 2
104226: PUSH
104227: EMPTY
104228: LIST
104229: LIST
104230: PUSH
104231: LD_INT 2
104233: PUSH
104234: LD_INT 34
104236: PUSH
104237: LD_INT 12
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: PUSH
104244: LD_INT 34
104246: PUSH
104247: LD_INT 51
104249: PUSH
104250: EMPTY
104251: LIST
104252: LIST
104253: PUSH
104254: LD_INT 34
104256: PUSH
104257: LD_INT 32
104259: PUSH
104260: EMPTY
104261: LIST
104262: LIST
104263: PUSH
104264: EMPTY
104265: LIST
104266: LIST
104267: LIST
104268: LIST
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: LIST
104274: PPUSH
104275: CALL_OW 69
104279: ST_TO_ADDR
// if not tmp then
104280: LD_VAR 0 2
104284: NOT
104285: IFFALSE 104289
// exit ;
104287: GO 104339
// for i in tmp do
104289: LD_ADDR_VAR 0 1
104293: PUSH
104294: LD_VAR 0 2
104298: PUSH
104299: FOR_IN
104300: IFFALSE 104337
// if GetCargo ( i , mat_artifact ) = 0 then
104302: LD_VAR 0 1
104306: PPUSH
104307: LD_INT 4
104309: PPUSH
104310: CALL_OW 289
104314: PUSH
104315: LD_INT 0
104317: EQUAL
104318: IFFALSE 104335
// SetCargo ( i , mat_siberit , 100 ) ;
104320: LD_VAR 0 1
104324: PPUSH
104325: LD_INT 3
104327: PPUSH
104328: LD_INT 100
104330: PPUSH
104331: CALL_OW 290
104335: GO 104299
104337: POP
104338: POP
// end ;
104339: PPOPN 2
104341: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104342: LD_EXP 99
104346: PUSH
104347: LD_EXP 144
104351: AND
104352: IFFALSE 104535
104354: GO 104356
104356: DISABLE
104357: LD_INT 0
104359: PPUSH
104360: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104361: LD_ADDR_VAR 0 2
104365: PUSH
104366: LD_INT 22
104368: PUSH
104369: LD_OWVAR 2
104373: PUSH
104374: EMPTY
104375: LIST
104376: LIST
104377: PPUSH
104378: CALL_OW 69
104382: ST_TO_ADDR
// if not tmp then
104383: LD_VAR 0 2
104387: NOT
104388: IFFALSE 104392
// exit ;
104390: GO 104535
// for i := 1 to 2 do
104392: LD_ADDR_VAR 0 1
104396: PUSH
104397: DOUBLE
104398: LD_INT 1
104400: DEC
104401: ST_TO_ADDR
104402: LD_INT 2
104404: PUSH
104405: FOR_TO
104406: IFFALSE 104533
// begin uc_side := your_side ;
104408: LD_ADDR_OWVAR 20
104412: PUSH
104413: LD_OWVAR 2
104417: ST_TO_ADDR
// uc_nation := nation_american ;
104418: LD_ADDR_OWVAR 21
104422: PUSH
104423: LD_INT 1
104425: ST_TO_ADDR
// vc_chassis := us_morphling ;
104426: LD_ADDR_OWVAR 37
104430: PUSH
104431: LD_INT 5
104433: ST_TO_ADDR
// vc_engine := engine_siberite ;
104434: LD_ADDR_OWVAR 39
104438: PUSH
104439: LD_INT 3
104441: ST_TO_ADDR
// vc_control := control_computer ;
104442: LD_ADDR_OWVAR 38
104446: PUSH
104447: LD_INT 3
104449: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104450: LD_ADDR_OWVAR 40
104454: PUSH
104455: LD_INT 10
104457: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104458: LD_VAR 0 2
104462: PUSH
104463: LD_INT 1
104465: ARRAY
104466: PPUSH
104467: CALL_OW 310
104471: NOT
104472: IFFALSE 104519
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104474: CALL_OW 45
104478: PPUSH
104479: LD_VAR 0 2
104483: PUSH
104484: LD_INT 1
104486: ARRAY
104487: PPUSH
104488: CALL_OW 250
104492: PPUSH
104493: LD_VAR 0 2
104497: PUSH
104498: LD_INT 1
104500: ARRAY
104501: PPUSH
104502: CALL_OW 251
104506: PPUSH
104507: LD_INT 12
104509: PPUSH
104510: LD_INT 1
104512: PPUSH
104513: CALL_OW 50
104517: GO 104531
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104519: CALL_OW 45
104523: PPUSH
104524: LD_INT 1
104526: PPUSH
104527: CALL_OW 51
// end ;
104531: GO 104405
104533: POP
104534: POP
// end ;
104535: PPOPN 2
104537: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104538: LD_EXP 99
104542: PUSH
104543: LD_EXP 145
104547: AND
104548: IFFALSE 104770
104550: GO 104552
104552: DISABLE
104553: LD_INT 0
104555: PPUSH
104556: PPUSH
104557: PPUSH
104558: PPUSH
104559: PPUSH
104560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104561: LD_ADDR_VAR 0 6
104565: PUSH
104566: LD_INT 22
104568: PUSH
104569: LD_OWVAR 2
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 21
104580: PUSH
104581: LD_INT 1
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: PUSH
104588: LD_INT 3
104590: PUSH
104591: LD_INT 23
104593: PUSH
104594: LD_INT 0
104596: PUSH
104597: EMPTY
104598: LIST
104599: LIST
104600: PUSH
104601: EMPTY
104602: LIST
104603: LIST
104604: PUSH
104605: EMPTY
104606: LIST
104607: LIST
104608: LIST
104609: PPUSH
104610: CALL_OW 69
104614: ST_TO_ADDR
// if not tmp then
104615: LD_VAR 0 6
104619: NOT
104620: IFFALSE 104624
// exit ;
104622: GO 104770
// s1 := rand ( 1 , 4 ) ;
104624: LD_ADDR_VAR 0 2
104628: PUSH
104629: LD_INT 1
104631: PPUSH
104632: LD_INT 4
104634: PPUSH
104635: CALL_OW 12
104639: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104640: LD_ADDR_VAR 0 4
104644: PUSH
104645: LD_VAR 0 6
104649: PUSH
104650: LD_INT 1
104652: ARRAY
104653: PPUSH
104654: LD_VAR 0 2
104658: PPUSH
104659: CALL_OW 259
104663: ST_TO_ADDR
// if s1 = 1 then
104664: LD_VAR 0 2
104668: PUSH
104669: LD_INT 1
104671: EQUAL
104672: IFFALSE 104692
// s2 := rand ( 2 , 4 ) else
104674: LD_ADDR_VAR 0 3
104678: PUSH
104679: LD_INT 2
104681: PPUSH
104682: LD_INT 4
104684: PPUSH
104685: CALL_OW 12
104689: ST_TO_ADDR
104690: GO 104700
// s2 := 1 ;
104692: LD_ADDR_VAR 0 3
104696: PUSH
104697: LD_INT 1
104699: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104700: LD_ADDR_VAR 0 5
104704: PUSH
104705: LD_VAR 0 6
104709: PUSH
104710: LD_INT 1
104712: ARRAY
104713: PPUSH
104714: LD_VAR 0 3
104718: PPUSH
104719: CALL_OW 259
104723: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104724: LD_VAR 0 6
104728: PUSH
104729: LD_INT 1
104731: ARRAY
104732: PPUSH
104733: LD_VAR 0 2
104737: PPUSH
104738: LD_VAR 0 5
104742: PPUSH
104743: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104747: LD_VAR 0 6
104751: PUSH
104752: LD_INT 1
104754: ARRAY
104755: PPUSH
104756: LD_VAR 0 3
104760: PPUSH
104761: LD_VAR 0 4
104765: PPUSH
104766: CALL_OW 237
// end ;
104770: PPOPN 6
104772: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104773: LD_EXP 99
104777: PUSH
104778: LD_EXP 146
104782: AND
104783: IFFALSE 104862
104785: GO 104787
104787: DISABLE
104788: LD_INT 0
104790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104791: LD_ADDR_VAR 0 1
104795: PUSH
104796: LD_INT 22
104798: PUSH
104799: LD_OWVAR 2
104803: PUSH
104804: EMPTY
104805: LIST
104806: LIST
104807: PUSH
104808: LD_INT 30
104810: PUSH
104811: LD_INT 3
104813: PUSH
104814: EMPTY
104815: LIST
104816: LIST
104817: PUSH
104818: EMPTY
104819: LIST
104820: LIST
104821: PPUSH
104822: CALL_OW 69
104826: ST_TO_ADDR
// if not tmp then
104827: LD_VAR 0 1
104831: NOT
104832: IFFALSE 104836
// exit ;
104834: GO 104862
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104836: LD_VAR 0 1
104840: PUSH
104841: LD_INT 1
104843: PPUSH
104844: LD_VAR 0 1
104848: PPUSH
104849: CALL_OW 12
104853: ARRAY
104854: PPUSH
104855: LD_INT 1
104857: PPUSH
104858: CALL_OW 234
// end ;
104862: PPOPN 1
104864: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104865: LD_EXP 99
104869: PUSH
104870: LD_EXP 147
104874: AND
104875: IFFALSE 104987
104877: GO 104879
104879: DISABLE
104880: LD_INT 0
104882: PPUSH
104883: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104884: LD_ADDR_VAR 0 2
104888: PUSH
104889: LD_INT 22
104891: PUSH
104892: LD_OWVAR 2
104896: PUSH
104897: EMPTY
104898: LIST
104899: LIST
104900: PUSH
104901: LD_INT 2
104903: PUSH
104904: LD_INT 30
104906: PUSH
104907: LD_INT 27
104909: PUSH
104910: EMPTY
104911: LIST
104912: LIST
104913: PUSH
104914: LD_INT 30
104916: PUSH
104917: LD_INT 26
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PUSH
104924: LD_INT 30
104926: PUSH
104927: LD_INT 28
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: PUSH
104940: EMPTY
104941: LIST
104942: LIST
104943: PPUSH
104944: CALL_OW 69
104948: ST_TO_ADDR
// if not tmp then
104949: LD_VAR 0 2
104953: NOT
104954: IFFALSE 104958
// exit ;
104956: GO 104987
// for i in tmp do
104958: LD_ADDR_VAR 0 1
104962: PUSH
104963: LD_VAR 0 2
104967: PUSH
104968: FOR_IN
104969: IFFALSE 104985
// SetLives ( i , 1 ) ;
104971: LD_VAR 0 1
104975: PPUSH
104976: LD_INT 1
104978: PPUSH
104979: CALL_OW 234
104983: GO 104968
104985: POP
104986: POP
// end ;
104987: PPOPN 2
104989: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104990: LD_EXP 99
104994: PUSH
104995: LD_EXP 148
104999: AND
105000: IFFALSE 105287
105002: GO 105004
105004: DISABLE
105005: LD_INT 0
105007: PPUSH
105008: PPUSH
105009: PPUSH
// begin i := rand ( 1 , 7 ) ;
105010: LD_ADDR_VAR 0 1
105014: PUSH
105015: LD_INT 1
105017: PPUSH
105018: LD_INT 7
105020: PPUSH
105021: CALL_OW 12
105025: ST_TO_ADDR
// case i of 1 :
105026: LD_VAR 0 1
105030: PUSH
105031: LD_INT 1
105033: DOUBLE
105034: EQUAL
105035: IFTRUE 105039
105037: GO 105049
105039: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105040: LD_STRING earthquake(getX(game), 0, 32)
105042: PPUSH
105043: CALL_OW 559
105047: GO 105287
105049: LD_INT 2
105051: DOUBLE
105052: EQUAL
105053: IFTRUE 105057
105055: GO 105071
105057: POP
// begin ToLua ( displayStucuk(); ) ;
105058: LD_STRING displayStucuk();
105060: PPUSH
105061: CALL_OW 559
// ResetFog ;
105065: CALL_OW 335
// end ; 3 :
105069: GO 105287
105071: LD_INT 3
105073: DOUBLE
105074: EQUAL
105075: IFTRUE 105079
105077: GO 105183
105079: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105080: LD_ADDR_VAR 0 2
105084: PUSH
105085: LD_INT 22
105087: PUSH
105088: LD_OWVAR 2
105092: PUSH
105093: EMPTY
105094: LIST
105095: LIST
105096: PUSH
105097: LD_INT 25
105099: PUSH
105100: LD_INT 1
105102: PUSH
105103: EMPTY
105104: LIST
105105: LIST
105106: PUSH
105107: EMPTY
105108: LIST
105109: LIST
105110: PPUSH
105111: CALL_OW 69
105115: ST_TO_ADDR
// if not tmp then
105116: LD_VAR 0 2
105120: NOT
105121: IFFALSE 105125
// exit ;
105123: GO 105287
// un := tmp [ rand ( 1 , tmp ) ] ;
105125: LD_ADDR_VAR 0 3
105129: PUSH
105130: LD_VAR 0 2
105134: PUSH
105135: LD_INT 1
105137: PPUSH
105138: LD_VAR 0 2
105142: PPUSH
105143: CALL_OW 12
105147: ARRAY
105148: ST_TO_ADDR
// if Crawls ( un ) then
105149: LD_VAR 0 3
105153: PPUSH
105154: CALL_OW 318
105158: IFFALSE 105169
// ComWalk ( un ) ;
105160: LD_VAR 0 3
105164: PPUSH
105165: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105169: LD_VAR 0 3
105173: PPUSH
105174: LD_INT 8
105176: PPUSH
105177: CALL_OW 336
// end ; 4 :
105181: GO 105287
105183: LD_INT 4
105185: DOUBLE
105186: EQUAL
105187: IFTRUE 105191
105189: GO 105265
105191: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105192: LD_ADDR_VAR 0 2
105196: PUSH
105197: LD_INT 22
105199: PUSH
105200: LD_OWVAR 2
105204: PUSH
105205: EMPTY
105206: LIST
105207: LIST
105208: PUSH
105209: LD_INT 30
105211: PUSH
105212: LD_INT 29
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PUSH
105219: EMPTY
105220: LIST
105221: LIST
105222: PPUSH
105223: CALL_OW 69
105227: ST_TO_ADDR
// if not tmp then
105228: LD_VAR 0 2
105232: NOT
105233: IFFALSE 105237
// exit ;
105235: GO 105287
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105237: LD_VAR 0 2
105241: PUSH
105242: LD_INT 1
105244: ARRAY
105245: PPUSH
105246: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105250: LD_VAR 0 2
105254: PUSH
105255: LD_INT 1
105257: ARRAY
105258: PPUSH
105259: CALL_OW 65
// end ; 5 .. 7 :
105263: GO 105287
105265: LD_INT 5
105267: DOUBLE
105268: GREATEREQUAL
105269: IFFALSE 105277
105271: LD_INT 7
105273: DOUBLE
105274: LESSEQUAL
105275: IFTRUE 105279
105277: GO 105286
105279: POP
// StreamSibBomb ; end ;
105280: CALL 101524 0 0
105284: GO 105287
105286: POP
// end ;
105287: PPOPN 3
105289: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105290: LD_EXP 99
105294: PUSH
105295: LD_EXP 149
105299: AND
105300: IFFALSE 105456
105302: GO 105304
105304: DISABLE
105305: LD_INT 0
105307: PPUSH
105308: PPUSH
105309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105310: LD_ADDR_VAR 0 2
105314: PUSH
105315: LD_INT 81
105317: PUSH
105318: LD_OWVAR 2
105322: PUSH
105323: EMPTY
105324: LIST
105325: LIST
105326: PUSH
105327: LD_INT 2
105329: PUSH
105330: LD_INT 21
105332: PUSH
105333: LD_INT 1
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: PUSH
105340: LD_INT 21
105342: PUSH
105343: LD_INT 2
105345: PUSH
105346: EMPTY
105347: LIST
105348: LIST
105349: PUSH
105350: EMPTY
105351: LIST
105352: LIST
105353: LIST
105354: PUSH
105355: EMPTY
105356: LIST
105357: LIST
105358: PPUSH
105359: CALL_OW 69
105363: ST_TO_ADDR
// if not tmp then
105364: LD_VAR 0 2
105368: NOT
105369: IFFALSE 105373
// exit ;
105371: GO 105456
// p := 0 ;
105373: LD_ADDR_VAR 0 3
105377: PUSH
105378: LD_INT 0
105380: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105381: LD_INT 35
105383: PPUSH
105384: CALL_OW 67
// p := p + 1 ;
105388: LD_ADDR_VAR 0 3
105392: PUSH
105393: LD_VAR 0 3
105397: PUSH
105398: LD_INT 1
105400: PLUS
105401: ST_TO_ADDR
// for i in tmp do
105402: LD_ADDR_VAR 0 1
105406: PUSH
105407: LD_VAR 0 2
105411: PUSH
105412: FOR_IN
105413: IFFALSE 105444
// if GetLives ( i ) < 1000 then
105415: LD_VAR 0 1
105419: PPUSH
105420: CALL_OW 256
105424: PUSH
105425: LD_INT 1000
105427: LESS
105428: IFFALSE 105442
// SetLives ( i , 1000 ) ;
105430: LD_VAR 0 1
105434: PPUSH
105435: LD_INT 1000
105437: PPUSH
105438: CALL_OW 234
105442: GO 105412
105444: POP
105445: POP
// until p > 20 ;
105446: LD_VAR 0 3
105450: PUSH
105451: LD_INT 20
105453: GREATER
105454: IFFALSE 105381
// end ;
105456: PPOPN 3
105458: END
// every 0 0$1 trigger StreamModeActive and sTime do
105459: LD_EXP 99
105463: PUSH
105464: LD_EXP 150
105468: AND
105469: IFFALSE 105504
105471: GO 105473
105473: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105474: LD_INT 28
105476: PPUSH
105477: LD_OWVAR 2
105481: PPUSH
105482: LD_INT 2
105484: PPUSH
105485: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105489: LD_INT 30
105491: PPUSH
105492: LD_OWVAR 2
105496: PPUSH
105497: LD_INT 2
105499: PPUSH
105500: CALL_OW 322
// end ;
105504: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105505: LD_EXP 99
105509: PUSH
105510: LD_EXP 151
105514: AND
105515: IFFALSE 105636
105517: GO 105519
105519: DISABLE
105520: LD_INT 0
105522: PPUSH
105523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105524: LD_ADDR_VAR 0 2
105528: PUSH
105529: LD_INT 22
105531: PUSH
105532: LD_OWVAR 2
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: PUSH
105541: LD_INT 21
105543: PUSH
105544: LD_INT 1
105546: PUSH
105547: EMPTY
105548: LIST
105549: LIST
105550: PUSH
105551: LD_INT 3
105553: PUSH
105554: LD_INT 23
105556: PUSH
105557: LD_INT 0
105559: PUSH
105560: EMPTY
105561: LIST
105562: LIST
105563: PUSH
105564: EMPTY
105565: LIST
105566: LIST
105567: PUSH
105568: EMPTY
105569: LIST
105570: LIST
105571: LIST
105572: PPUSH
105573: CALL_OW 69
105577: ST_TO_ADDR
// if not tmp then
105578: LD_VAR 0 2
105582: NOT
105583: IFFALSE 105587
// exit ;
105585: GO 105636
// for i in tmp do
105587: LD_ADDR_VAR 0 1
105591: PUSH
105592: LD_VAR 0 2
105596: PUSH
105597: FOR_IN
105598: IFFALSE 105634
// begin if Crawls ( i ) then
105600: LD_VAR 0 1
105604: PPUSH
105605: CALL_OW 318
105609: IFFALSE 105620
// ComWalk ( i ) ;
105611: LD_VAR 0 1
105615: PPUSH
105616: CALL_OW 138
// SetClass ( i , 2 ) ;
105620: LD_VAR 0 1
105624: PPUSH
105625: LD_INT 2
105627: PPUSH
105628: CALL_OW 336
// end ;
105632: GO 105597
105634: POP
105635: POP
// end ;
105636: PPOPN 2
105638: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105639: LD_EXP 99
105643: PUSH
105644: LD_EXP 152
105648: AND
105649: IFFALSE 105937
105651: GO 105653
105653: DISABLE
105654: LD_INT 0
105656: PPUSH
105657: PPUSH
105658: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105659: LD_OWVAR 2
105663: PPUSH
105664: LD_INT 9
105666: PPUSH
105667: LD_INT 1
105669: PPUSH
105670: LD_INT 1
105672: PPUSH
105673: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105677: LD_INT 9
105679: PPUSH
105680: LD_OWVAR 2
105684: PPUSH
105685: CALL_OW 343
// uc_side := 9 ;
105689: LD_ADDR_OWVAR 20
105693: PUSH
105694: LD_INT 9
105696: ST_TO_ADDR
// uc_nation := 2 ;
105697: LD_ADDR_OWVAR 21
105701: PUSH
105702: LD_INT 2
105704: ST_TO_ADDR
// hc_name := Dark Warrior ;
105705: LD_ADDR_OWVAR 26
105709: PUSH
105710: LD_STRING Dark Warrior
105712: ST_TO_ADDR
// hc_gallery :=  ;
105713: LD_ADDR_OWVAR 33
105717: PUSH
105718: LD_STRING 
105720: ST_TO_ADDR
// hc_noskilllimit := true ;
105721: LD_ADDR_OWVAR 76
105725: PUSH
105726: LD_INT 1
105728: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105729: LD_ADDR_OWVAR 31
105733: PUSH
105734: LD_INT 30
105736: PUSH
105737: LD_INT 30
105739: PUSH
105740: LD_INT 30
105742: PUSH
105743: LD_INT 30
105745: PUSH
105746: EMPTY
105747: LIST
105748: LIST
105749: LIST
105750: LIST
105751: ST_TO_ADDR
// un := CreateHuman ;
105752: LD_ADDR_VAR 0 3
105756: PUSH
105757: CALL_OW 44
105761: ST_TO_ADDR
// hc_noskilllimit := false ;
105762: LD_ADDR_OWVAR 76
105766: PUSH
105767: LD_INT 0
105769: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105770: LD_VAR 0 3
105774: PPUSH
105775: LD_INT 1
105777: PPUSH
105778: CALL_OW 51
// ToLua ( playRanger() ) ;
105782: LD_STRING playRanger()
105784: PPUSH
105785: CALL_OW 559
// p := 0 ;
105789: LD_ADDR_VAR 0 2
105793: PUSH
105794: LD_INT 0
105796: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105797: LD_INT 35
105799: PPUSH
105800: CALL_OW 67
// p := p + 1 ;
105804: LD_ADDR_VAR 0 2
105808: PUSH
105809: LD_VAR 0 2
105813: PUSH
105814: LD_INT 1
105816: PLUS
105817: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105818: LD_VAR 0 3
105822: PPUSH
105823: CALL_OW 256
105827: PUSH
105828: LD_INT 1000
105830: LESS
105831: IFFALSE 105845
// SetLives ( un , 1000 ) ;
105833: LD_VAR 0 3
105837: PPUSH
105838: LD_INT 1000
105840: PPUSH
105841: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105845: LD_VAR 0 3
105849: PPUSH
105850: LD_INT 81
105852: PUSH
105853: LD_OWVAR 2
105857: PUSH
105858: EMPTY
105859: LIST
105860: LIST
105861: PUSH
105862: LD_INT 91
105864: PUSH
105865: LD_VAR 0 3
105869: PUSH
105870: LD_INT 30
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: LIST
105877: PUSH
105878: EMPTY
105879: LIST
105880: LIST
105881: PPUSH
105882: CALL_OW 69
105886: PPUSH
105887: LD_VAR 0 3
105891: PPUSH
105892: CALL_OW 74
105896: PPUSH
105897: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105901: LD_VAR 0 2
105905: PUSH
105906: LD_INT 80
105908: GREATER
105909: PUSH
105910: LD_VAR 0 3
105914: PPUSH
105915: CALL_OW 301
105919: OR
105920: IFFALSE 105797
// if un then
105922: LD_VAR 0 3
105926: IFFALSE 105937
// RemoveUnit ( un ) ;
105928: LD_VAR 0 3
105932: PPUSH
105933: CALL_OW 64
// end ;
105937: PPOPN 3
105939: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105940: LD_EXP 153
105944: IFFALSE 106060
105946: GO 105948
105948: DISABLE
105949: LD_INT 0
105951: PPUSH
105952: PPUSH
105953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105954: LD_ADDR_VAR 0 2
105958: PUSH
105959: LD_INT 81
105961: PUSH
105962: LD_OWVAR 2
105966: PUSH
105967: EMPTY
105968: LIST
105969: LIST
105970: PUSH
105971: LD_INT 21
105973: PUSH
105974: LD_INT 1
105976: PUSH
105977: EMPTY
105978: LIST
105979: LIST
105980: PUSH
105981: EMPTY
105982: LIST
105983: LIST
105984: PPUSH
105985: CALL_OW 69
105989: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105990: LD_STRING playComputer()
105992: PPUSH
105993: CALL_OW 559
// if not tmp then
105997: LD_VAR 0 2
106001: NOT
106002: IFFALSE 106006
// exit ;
106004: GO 106060
// for i in tmp do
106006: LD_ADDR_VAR 0 1
106010: PUSH
106011: LD_VAR 0 2
106015: PUSH
106016: FOR_IN
106017: IFFALSE 106058
// for j := 1 to 4 do
106019: LD_ADDR_VAR 0 3
106023: PUSH
106024: DOUBLE
106025: LD_INT 1
106027: DEC
106028: ST_TO_ADDR
106029: LD_INT 4
106031: PUSH
106032: FOR_TO
106033: IFFALSE 106054
// SetSkill ( i , j , 10 ) ;
106035: LD_VAR 0 1
106039: PPUSH
106040: LD_VAR 0 3
106044: PPUSH
106045: LD_INT 10
106047: PPUSH
106048: CALL_OW 237
106052: GO 106032
106054: POP
106055: POP
106056: GO 106016
106058: POP
106059: POP
// end ;
106060: PPOPN 3
106062: END
// every 0 0$1 trigger s30 do var i , tmp ;
106063: LD_EXP 154
106067: IFFALSE 106136
106069: GO 106071
106071: DISABLE
106072: LD_INT 0
106074: PPUSH
106075: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106076: LD_ADDR_VAR 0 2
106080: PUSH
106081: LD_INT 22
106083: PUSH
106084: LD_OWVAR 2
106088: PUSH
106089: EMPTY
106090: LIST
106091: LIST
106092: PPUSH
106093: CALL_OW 69
106097: ST_TO_ADDR
// if not tmp then
106098: LD_VAR 0 2
106102: NOT
106103: IFFALSE 106107
// exit ;
106105: GO 106136
// for i in tmp do
106107: LD_ADDR_VAR 0 1
106111: PUSH
106112: LD_VAR 0 2
106116: PUSH
106117: FOR_IN
106118: IFFALSE 106134
// SetLives ( i , 300 ) ;
106120: LD_VAR 0 1
106124: PPUSH
106125: LD_INT 300
106127: PPUSH
106128: CALL_OW 234
106132: GO 106117
106134: POP
106135: POP
// end ;
106136: PPOPN 2
106138: END
// every 0 0$1 trigger s60 do var i , tmp ;
106139: LD_EXP 155
106143: IFFALSE 106212
106145: GO 106147
106147: DISABLE
106148: LD_INT 0
106150: PPUSH
106151: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106152: LD_ADDR_VAR 0 2
106156: PUSH
106157: LD_INT 22
106159: PUSH
106160: LD_OWVAR 2
106164: PUSH
106165: EMPTY
106166: LIST
106167: LIST
106168: PPUSH
106169: CALL_OW 69
106173: ST_TO_ADDR
// if not tmp then
106174: LD_VAR 0 2
106178: NOT
106179: IFFALSE 106183
// exit ;
106181: GO 106212
// for i in tmp do
106183: LD_ADDR_VAR 0 1
106187: PUSH
106188: LD_VAR 0 2
106192: PUSH
106193: FOR_IN
106194: IFFALSE 106210
// SetLives ( i , 600 ) ;
106196: LD_VAR 0 1
106200: PPUSH
106201: LD_INT 600
106203: PPUSH
106204: CALL_OW 234
106208: GO 106193
106210: POP
106211: POP
// end ;
106212: PPOPN 2
106214: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106215: LD_INT 0
106217: PPUSH
// case cmd of 301 :
106218: LD_VAR 0 1
106222: PUSH
106223: LD_INT 301
106225: DOUBLE
106226: EQUAL
106227: IFTRUE 106231
106229: GO 106263
106231: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106232: LD_VAR 0 6
106236: PPUSH
106237: LD_VAR 0 7
106241: PPUSH
106242: LD_VAR 0 8
106246: PPUSH
106247: LD_VAR 0 4
106251: PPUSH
106252: LD_VAR 0 5
106256: PPUSH
106257: CALL 107464 0 5
106261: GO 106384
106263: LD_INT 302
106265: DOUBLE
106266: EQUAL
106267: IFTRUE 106271
106269: GO 106308
106271: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106272: LD_VAR 0 6
106276: PPUSH
106277: LD_VAR 0 7
106281: PPUSH
106282: LD_VAR 0 8
106286: PPUSH
106287: LD_VAR 0 9
106291: PPUSH
106292: LD_VAR 0 4
106296: PPUSH
106297: LD_VAR 0 5
106301: PPUSH
106302: CALL 107555 0 6
106306: GO 106384
106308: LD_INT 303
106310: DOUBLE
106311: EQUAL
106312: IFTRUE 106316
106314: GO 106353
106316: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106317: LD_VAR 0 6
106321: PPUSH
106322: LD_VAR 0 7
106326: PPUSH
106327: LD_VAR 0 8
106331: PPUSH
106332: LD_VAR 0 9
106336: PPUSH
106337: LD_VAR 0 4
106341: PPUSH
106342: LD_VAR 0 5
106346: PPUSH
106347: CALL 106389 0 6
106351: GO 106384
106353: LD_INT 304
106355: DOUBLE
106356: EQUAL
106357: IFTRUE 106361
106359: GO 106383
106361: POP
// hHackTeleport ( unit , x , y ) ; end ;
106362: LD_VAR 0 2
106366: PPUSH
106367: LD_VAR 0 4
106371: PPUSH
106372: LD_VAR 0 5
106376: PPUSH
106377: CALL 108148 0 3
106381: GO 106384
106383: POP
// end ;
106384: LD_VAR 0 12
106388: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106389: LD_INT 0
106391: PPUSH
106392: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106393: LD_VAR 0 1
106397: PUSH
106398: LD_INT 1
106400: LESS
106401: PUSH
106402: LD_VAR 0 1
106406: PUSH
106407: LD_INT 3
106409: GREATER
106410: OR
106411: PUSH
106412: LD_VAR 0 5
106416: PPUSH
106417: LD_VAR 0 6
106421: PPUSH
106422: CALL_OW 428
106426: OR
106427: IFFALSE 106431
// exit ;
106429: GO 107151
// uc_side := your_side ;
106431: LD_ADDR_OWVAR 20
106435: PUSH
106436: LD_OWVAR 2
106440: ST_TO_ADDR
// uc_nation := nation ;
106441: LD_ADDR_OWVAR 21
106445: PUSH
106446: LD_VAR 0 1
106450: ST_TO_ADDR
// bc_level = 1 ;
106451: LD_ADDR_OWVAR 43
106455: PUSH
106456: LD_INT 1
106458: ST_TO_ADDR
// case btype of 1 :
106459: LD_VAR 0 2
106463: PUSH
106464: LD_INT 1
106466: DOUBLE
106467: EQUAL
106468: IFTRUE 106472
106470: GO 106483
106472: POP
// bc_type := b_depot ; 2 :
106473: LD_ADDR_OWVAR 42
106477: PUSH
106478: LD_INT 0
106480: ST_TO_ADDR
106481: GO 107095
106483: LD_INT 2
106485: DOUBLE
106486: EQUAL
106487: IFTRUE 106491
106489: GO 106502
106491: POP
// bc_type := b_warehouse ; 3 :
106492: LD_ADDR_OWVAR 42
106496: PUSH
106497: LD_INT 1
106499: ST_TO_ADDR
106500: GO 107095
106502: LD_INT 3
106504: DOUBLE
106505: EQUAL
106506: IFTRUE 106510
106508: GO 106521
106510: POP
// bc_type := b_lab ; 4 .. 9 :
106511: LD_ADDR_OWVAR 42
106515: PUSH
106516: LD_INT 6
106518: ST_TO_ADDR
106519: GO 107095
106521: LD_INT 4
106523: DOUBLE
106524: GREATEREQUAL
106525: IFFALSE 106533
106527: LD_INT 9
106529: DOUBLE
106530: LESSEQUAL
106531: IFTRUE 106535
106533: GO 106587
106535: POP
// begin bc_type := b_lab_half ;
106536: LD_ADDR_OWVAR 42
106540: PUSH
106541: LD_INT 7
106543: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106544: LD_ADDR_OWVAR 44
106548: PUSH
106549: LD_INT 10
106551: PUSH
106552: LD_INT 11
106554: PUSH
106555: LD_INT 12
106557: PUSH
106558: LD_INT 15
106560: PUSH
106561: LD_INT 14
106563: PUSH
106564: LD_INT 13
106566: PUSH
106567: EMPTY
106568: LIST
106569: LIST
106570: LIST
106571: LIST
106572: LIST
106573: LIST
106574: PUSH
106575: LD_VAR 0 2
106579: PUSH
106580: LD_INT 3
106582: MINUS
106583: ARRAY
106584: ST_TO_ADDR
// end ; 10 .. 13 :
106585: GO 107095
106587: LD_INT 10
106589: DOUBLE
106590: GREATEREQUAL
106591: IFFALSE 106599
106593: LD_INT 13
106595: DOUBLE
106596: LESSEQUAL
106597: IFTRUE 106601
106599: GO 106678
106601: POP
// begin bc_type := b_lab_full ;
106602: LD_ADDR_OWVAR 42
106606: PUSH
106607: LD_INT 8
106609: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106610: LD_ADDR_OWVAR 44
106614: PUSH
106615: LD_INT 10
106617: PUSH
106618: LD_INT 12
106620: PUSH
106621: LD_INT 14
106623: PUSH
106624: LD_INT 13
106626: PUSH
106627: EMPTY
106628: LIST
106629: LIST
106630: LIST
106631: LIST
106632: PUSH
106633: LD_VAR 0 2
106637: PUSH
106638: LD_INT 9
106640: MINUS
106641: ARRAY
106642: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106643: LD_ADDR_OWVAR 45
106647: PUSH
106648: LD_INT 11
106650: PUSH
106651: LD_INT 15
106653: PUSH
106654: LD_INT 12
106656: PUSH
106657: LD_INT 15
106659: PUSH
106660: EMPTY
106661: LIST
106662: LIST
106663: LIST
106664: LIST
106665: PUSH
106666: LD_VAR 0 2
106670: PUSH
106671: LD_INT 9
106673: MINUS
106674: ARRAY
106675: ST_TO_ADDR
// end ; 14 :
106676: GO 107095
106678: LD_INT 14
106680: DOUBLE
106681: EQUAL
106682: IFTRUE 106686
106684: GO 106697
106686: POP
// bc_type := b_workshop ; 15 :
106687: LD_ADDR_OWVAR 42
106691: PUSH
106692: LD_INT 2
106694: ST_TO_ADDR
106695: GO 107095
106697: LD_INT 15
106699: DOUBLE
106700: EQUAL
106701: IFTRUE 106705
106703: GO 106716
106705: POP
// bc_type := b_factory ; 16 :
106706: LD_ADDR_OWVAR 42
106710: PUSH
106711: LD_INT 3
106713: ST_TO_ADDR
106714: GO 107095
106716: LD_INT 16
106718: DOUBLE
106719: EQUAL
106720: IFTRUE 106724
106722: GO 106735
106724: POP
// bc_type := b_ext_gun ; 17 :
106725: LD_ADDR_OWVAR 42
106729: PUSH
106730: LD_INT 17
106732: ST_TO_ADDR
106733: GO 107095
106735: LD_INT 17
106737: DOUBLE
106738: EQUAL
106739: IFTRUE 106743
106741: GO 106771
106743: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106744: LD_ADDR_OWVAR 42
106748: PUSH
106749: LD_INT 19
106751: PUSH
106752: LD_INT 23
106754: PUSH
106755: LD_INT 19
106757: PUSH
106758: EMPTY
106759: LIST
106760: LIST
106761: LIST
106762: PUSH
106763: LD_VAR 0 1
106767: ARRAY
106768: ST_TO_ADDR
106769: GO 107095
106771: LD_INT 18
106773: DOUBLE
106774: EQUAL
106775: IFTRUE 106779
106777: GO 106790
106779: POP
// bc_type := b_ext_radar ; 19 :
106780: LD_ADDR_OWVAR 42
106784: PUSH
106785: LD_INT 20
106787: ST_TO_ADDR
106788: GO 107095
106790: LD_INT 19
106792: DOUBLE
106793: EQUAL
106794: IFTRUE 106798
106796: GO 106809
106798: POP
// bc_type := b_ext_radio ; 20 :
106799: LD_ADDR_OWVAR 42
106803: PUSH
106804: LD_INT 22
106806: ST_TO_ADDR
106807: GO 107095
106809: LD_INT 20
106811: DOUBLE
106812: EQUAL
106813: IFTRUE 106817
106815: GO 106828
106817: POP
// bc_type := b_ext_siberium ; 21 :
106818: LD_ADDR_OWVAR 42
106822: PUSH
106823: LD_INT 21
106825: ST_TO_ADDR
106826: GO 107095
106828: LD_INT 21
106830: DOUBLE
106831: EQUAL
106832: IFTRUE 106836
106834: GO 106847
106836: POP
// bc_type := b_ext_computer ; 22 :
106837: LD_ADDR_OWVAR 42
106841: PUSH
106842: LD_INT 24
106844: ST_TO_ADDR
106845: GO 107095
106847: LD_INT 22
106849: DOUBLE
106850: EQUAL
106851: IFTRUE 106855
106853: GO 106866
106855: POP
// bc_type := b_ext_track ; 23 :
106856: LD_ADDR_OWVAR 42
106860: PUSH
106861: LD_INT 16
106863: ST_TO_ADDR
106864: GO 107095
106866: LD_INT 23
106868: DOUBLE
106869: EQUAL
106870: IFTRUE 106874
106872: GO 106885
106874: POP
// bc_type := b_ext_laser ; 24 :
106875: LD_ADDR_OWVAR 42
106879: PUSH
106880: LD_INT 25
106882: ST_TO_ADDR
106883: GO 107095
106885: LD_INT 24
106887: DOUBLE
106888: EQUAL
106889: IFTRUE 106893
106891: GO 106904
106893: POP
// bc_type := b_control_tower ; 25 :
106894: LD_ADDR_OWVAR 42
106898: PUSH
106899: LD_INT 36
106901: ST_TO_ADDR
106902: GO 107095
106904: LD_INT 25
106906: DOUBLE
106907: EQUAL
106908: IFTRUE 106912
106910: GO 106923
106912: POP
// bc_type := b_breastwork ; 26 :
106913: LD_ADDR_OWVAR 42
106917: PUSH
106918: LD_INT 31
106920: ST_TO_ADDR
106921: GO 107095
106923: LD_INT 26
106925: DOUBLE
106926: EQUAL
106927: IFTRUE 106931
106929: GO 106942
106931: POP
// bc_type := b_bunker ; 27 :
106932: LD_ADDR_OWVAR 42
106936: PUSH
106937: LD_INT 32
106939: ST_TO_ADDR
106940: GO 107095
106942: LD_INT 27
106944: DOUBLE
106945: EQUAL
106946: IFTRUE 106950
106948: GO 106961
106950: POP
// bc_type := b_turret ; 28 :
106951: LD_ADDR_OWVAR 42
106955: PUSH
106956: LD_INT 33
106958: ST_TO_ADDR
106959: GO 107095
106961: LD_INT 28
106963: DOUBLE
106964: EQUAL
106965: IFTRUE 106969
106967: GO 106980
106969: POP
// bc_type := b_armoury ; 29 :
106970: LD_ADDR_OWVAR 42
106974: PUSH
106975: LD_INT 4
106977: ST_TO_ADDR
106978: GO 107095
106980: LD_INT 29
106982: DOUBLE
106983: EQUAL
106984: IFTRUE 106988
106986: GO 106999
106988: POP
// bc_type := b_barracks ; 30 :
106989: LD_ADDR_OWVAR 42
106993: PUSH
106994: LD_INT 5
106996: ST_TO_ADDR
106997: GO 107095
106999: LD_INT 30
107001: DOUBLE
107002: EQUAL
107003: IFTRUE 107007
107005: GO 107018
107007: POP
// bc_type := b_solar_power ; 31 :
107008: LD_ADDR_OWVAR 42
107012: PUSH
107013: LD_INT 27
107015: ST_TO_ADDR
107016: GO 107095
107018: LD_INT 31
107020: DOUBLE
107021: EQUAL
107022: IFTRUE 107026
107024: GO 107037
107026: POP
// bc_type := b_oil_power ; 32 :
107027: LD_ADDR_OWVAR 42
107031: PUSH
107032: LD_INT 26
107034: ST_TO_ADDR
107035: GO 107095
107037: LD_INT 32
107039: DOUBLE
107040: EQUAL
107041: IFTRUE 107045
107043: GO 107056
107045: POP
// bc_type := b_siberite_power ; 33 :
107046: LD_ADDR_OWVAR 42
107050: PUSH
107051: LD_INT 28
107053: ST_TO_ADDR
107054: GO 107095
107056: LD_INT 33
107058: DOUBLE
107059: EQUAL
107060: IFTRUE 107064
107062: GO 107075
107064: POP
// bc_type := b_oil_mine ; 34 :
107065: LD_ADDR_OWVAR 42
107069: PUSH
107070: LD_INT 29
107072: ST_TO_ADDR
107073: GO 107095
107075: LD_INT 34
107077: DOUBLE
107078: EQUAL
107079: IFTRUE 107083
107081: GO 107094
107083: POP
// bc_type := b_siberite_mine ; end ;
107084: LD_ADDR_OWVAR 42
107088: PUSH
107089: LD_INT 30
107091: ST_TO_ADDR
107092: GO 107095
107094: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107095: LD_ADDR_VAR 0 8
107099: PUSH
107100: LD_VAR 0 5
107104: PPUSH
107105: LD_VAR 0 6
107109: PPUSH
107110: LD_VAR 0 3
107114: PPUSH
107115: CALL_OW 47
107119: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107120: LD_OWVAR 42
107124: PUSH
107125: LD_INT 32
107127: PUSH
107128: LD_INT 33
107130: PUSH
107131: EMPTY
107132: LIST
107133: LIST
107134: IN
107135: IFFALSE 107151
// PlaceWeaponTurret ( b , weapon ) ;
107137: LD_VAR 0 8
107141: PPUSH
107142: LD_VAR 0 4
107146: PPUSH
107147: CALL_OW 431
// end ;
107151: LD_VAR 0 7
107155: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107156: LD_INT 0
107158: PPUSH
107159: PPUSH
107160: PPUSH
107161: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107162: LD_ADDR_VAR 0 4
107166: PUSH
107167: LD_INT 22
107169: PUSH
107170: LD_OWVAR 2
107174: PUSH
107175: EMPTY
107176: LIST
107177: LIST
107178: PUSH
107179: LD_INT 2
107181: PUSH
107182: LD_INT 30
107184: PUSH
107185: LD_INT 0
107187: PUSH
107188: EMPTY
107189: LIST
107190: LIST
107191: PUSH
107192: LD_INT 30
107194: PUSH
107195: LD_INT 1
107197: PUSH
107198: EMPTY
107199: LIST
107200: LIST
107201: PUSH
107202: EMPTY
107203: LIST
107204: LIST
107205: LIST
107206: PUSH
107207: EMPTY
107208: LIST
107209: LIST
107210: PPUSH
107211: CALL_OW 69
107215: ST_TO_ADDR
// if not tmp then
107216: LD_VAR 0 4
107220: NOT
107221: IFFALSE 107225
// exit ;
107223: GO 107284
// for i in tmp do
107225: LD_ADDR_VAR 0 2
107229: PUSH
107230: LD_VAR 0 4
107234: PUSH
107235: FOR_IN
107236: IFFALSE 107282
// for j = 1 to 3 do
107238: LD_ADDR_VAR 0 3
107242: PUSH
107243: DOUBLE
107244: LD_INT 1
107246: DEC
107247: ST_TO_ADDR
107248: LD_INT 3
107250: PUSH
107251: FOR_TO
107252: IFFALSE 107278
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107254: LD_VAR 0 2
107258: PPUSH
107259: CALL_OW 274
107263: PPUSH
107264: LD_VAR 0 3
107268: PPUSH
107269: LD_INT 99999
107271: PPUSH
107272: CALL_OW 277
107276: GO 107251
107278: POP
107279: POP
107280: GO 107235
107282: POP
107283: POP
// end ;
107284: LD_VAR 0 1
107288: RET
// export function hHackSetLevel10 ; var i , j ; begin
107289: LD_INT 0
107291: PPUSH
107292: PPUSH
107293: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107294: LD_ADDR_VAR 0 2
107298: PUSH
107299: LD_INT 21
107301: PUSH
107302: LD_INT 1
107304: PUSH
107305: EMPTY
107306: LIST
107307: LIST
107308: PPUSH
107309: CALL_OW 69
107313: PUSH
107314: FOR_IN
107315: IFFALSE 107367
// if IsSelected ( i ) then
107317: LD_VAR 0 2
107321: PPUSH
107322: CALL_OW 306
107326: IFFALSE 107365
// begin for j := 1 to 4 do
107328: LD_ADDR_VAR 0 3
107332: PUSH
107333: DOUBLE
107334: LD_INT 1
107336: DEC
107337: ST_TO_ADDR
107338: LD_INT 4
107340: PUSH
107341: FOR_TO
107342: IFFALSE 107363
// SetSkill ( i , j , 10 ) ;
107344: LD_VAR 0 2
107348: PPUSH
107349: LD_VAR 0 3
107353: PPUSH
107354: LD_INT 10
107356: PPUSH
107357: CALL_OW 237
107361: GO 107341
107363: POP
107364: POP
// end ;
107365: GO 107314
107367: POP
107368: POP
// end ;
107369: LD_VAR 0 1
107373: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107374: LD_INT 0
107376: PPUSH
107377: PPUSH
107378: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107379: LD_ADDR_VAR 0 2
107383: PUSH
107384: LD_INT 22
107386: PUSH
107387: LD_OWVAR 2
107391: PUSH
107392: EMPTY
107393: LIST
107394: LIST
107395: PUSH
107396: LD_INT 21
107398: PUSH
107399: LD_INT 1
107401: PUSH
107402: EMPTY
107403: LIST
107404: LIST
107405: PUSH
107406: EMPTY
107407: LIST
107408: LIST
107409: PPUSH
107410: CALL_OW 69
107414: PUSH
107415: FOR_IN
107416: IFFALSE 107457
// begin for j := 1 to 4 do
107418: LD_ADDR_VAR 0 3
107422: PUSH
107423: DOUBLE
107424: LD_INT 1
107426: DEC
107427: ST_TO_ADDR
107428: LD_INT 4
107430: PUSH
107431: FOR_TO
107432: IFFALSE 107453
// SetSkill ( i , j , 10 ) ;
107434: LD_VAR 0 2
107438: PPUSH
107439: LD_VAR 0 3
107443: PPUSH
107444: LD_INT 10
107446: PPUSH
107447: CALL_OW 237
107451: GO 107431
107453: POP
107454: POP
// end ;
107455: GO 107415
107457: POP
107458: POP
// end ;
107459: LD_VAR 0 1
107463: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107464: LD_INT 0
107466: PPUSH
// uc_side := your_side ;
107467: LD_ADDR_OWVAR 20
107471: PUSH
107472: LD_OWVAR 2
107476: ST_TO_ADDR
// uc_nation := nation ;
107477: LD_ADDR_OWVAR 21
107481: PUSH
107482: LD_VAR 0 1
107486: ST_TO_ADDR
// InitHc ;
107487: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107491: LD_INT 0
107493: PPUSH
107494: LD_VAR 0 2
107498: PPUSH
107499: LD_VAR 0 3
107503: PPUSH
107504: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107508: LD_VAR 0 4
107512: PPUSH
107513: LD_VAR 0 5
107517: PPUSH
107518: CALL_OW 428
107522: PUSH
107523: LD_INT 0
107525: EQUAL
107526: IFFALSE 107550
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107528: CALL_OW 44
107532: PPUSH
107533: LD_VAR 0 4
107537: PPUSH
107538: LD_VAR 0 5
107542: PPUSH
107543: LD_INT 1
107545: PPUSH
107546: CALL_OW 48
// end ;
107550: LD_VAR 0 6
107554: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107555: LD_INT 0
107557: PPUSH
107558: PPUSH
// uc_side := your_side ;
107559: LD_ADDR_OWVAR 20
107563: PUSH
107564: LD_OWVAR 2
107568: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107569: LD_VAR 0 1
107573: PUSH
107574: LD_INT 1
107576: PUSH
107577: LD_INT 2
107579: PUSH
107580: LD_INT 3
107582: PUSH
107583: LD_INT 4
107585: PUSH
107586: LD_INT 5
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: LIST
107593: LIST
107594: LIST
107595: IN
107596: IFFALSE 107608
// uc_nation := nation_american else
107598: LD_ADDR_OWVAR 21
107602: PUSH
107603: LD_INT 1
107605: ST_TO_ADDR
107606: GO 107651
// if chassis in [ 11 , 12 , 13 , 14 ] then
107608: LD_VAR 0 1
107612: PUSH
107613: LD_INT 11
107615: PUSH
107616: LD_INT 12
107618: PUSH
107619: LD_INT 13
107621: PUSH
107622: LD_INT 14
107624: PUSH
107625: EMPTY
107626: LIST
107627: LIST
107628: LIST
107629: LIST
107630: IN
107631: IFFALSE 107643
// uc_nation := nation_arabian else
107633: LD_ADDR_OWVAR 21
107637: PUSH
107638: LD_INT 2
107640: ST_TO_ADDR
107641: GO 107651
// uc_nation := nation_russian ;
107643: LD_ADDR_OWVAR 21
107647: PUSH
107648: LD_INT 3
107650: ST_TO_ADDR
// vc_chassis := chassis ;
107651: LD_ADDR_OWVAR 37
107655: PUSH
107656: LD_VAR 0 1
107660: ST_TO_ADDR
// vc_engine := engine ;
107661: LD_ADDR_OWVAR 39
107665: PUSH
107666: LD_VAR 0 2
107670: ST_TO_ADDR
// vc_control := control ;
107671: LD_ADDR_OWVAR 38
107675: PUSH
107676: LD_VAR 0 3
107680: ST_TO_ADDR
// vc_weapon := weapon ;
107681: LD_ADDR_OWVAR 40
107685: PUSH
107686: LD_VAR 0 4
107690: ST_TO_ADDR
// un := CreateVehicle ;
107691: LD_ADDR_VAR 0 8
107695: PUSH
107696: CALL_OW 45
107700: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107701: LD_VAR 0 8
107705: PPUSH
107706: LD_INT 0
107708: PPUSH
107709: LD_INT 5
107711: PPUSH
107712: CALL_OW 12
107716: PPUSH
107717: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107721: LD_VAR 0 8
107725: PPUSH
107726: LD_VAR 0 5
107730: PPUSH
107731: LD_VAR 0 6
107735: PPUSH
107736: LD_INT 1
107738: PPUSH
107739: CALL_OW 48
// end ;
107743: LD_VAR 0 7
107747: RET
// export hInvincible ; every 1 do
107748: GO 107750
107750: DISABLE
// hInvincible := [ ] ;
107751: LD_ADDR_EXP 156
107755: PUSH
107756: EMPTY
107757: ST_TO_ADDR
107758: END
// every 10 do var i ;
107759: GO 107761
107761: DISABLE
107762: LD_INT 0
107764: PPUSH
// begin enable ;
107765: ENABLE
// if not hInvincible then
107766: LD_EXP 156
107770: NOT
107771: IFFALSE 107775
// exit ;
107773: GO 107819
// for i in hInvincible do
107775: LD_ADDR_VAR 0 1
107779: PUSH
107780: LD_EXP 156
107784: PUSH
107785: FOR_IN
107786: IFFALSE 107817
// if GetLives ( i ) < 1000 then
107788: LD_VAR 0 1
107792: PPUSH
107793: CALL_OW 256
107797: PUSH
107798: LD_INT 1000
107800: LESS
107801: IFFALSE 107815
// SetLives ( i , 1000 ) ;
107803: LD_VAR 0 1
107807: PPUSH
107808: LD_INT 1000
107810: PPUSH
107811: CALL_OW 234
107815: GO 107785
107817: POP
107818: POP
// end ;
107819: PPOPN 1
107821: END
// export function hHackInvincible ; var i ; begin
107822: LD_INT 0
107824: PPUSH
107825: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107826: LD_ADDR_VAR 0 2
107830: PUSH
107831: LD_INT 2
107833: PUSH
107834: LD_INT 21
107836: PUSH
107837: LD_INT 1
107839: PUSH
107840: EMPTY
107841: LIST
107842: LIST
107843: PUSH
107844: LD_INT 21
107846: PUSH
107847: LD_INT 2
107849: PUSH
107850: EMPTY
107851: LIST
107852: LIST
107853: PUSH
107854: EMPTY
107855: LIST
107856: LIST
107857: LIST
107858: PPUSH
107859: CALL_OW 69
107863: PUSH
107864: FOR_IN
107865: IFFALSE 107926
// if IsSelected ( i ) then
107867: LD_VAR 0 2
107871: PPUSH
107872: CALL_OW 306
107876: IFFALSE 107924
// begin if i in hInvincible then
107878: LD_VAR 0 2
107882: PUSH
107883: LD_EXP 156
107887: IN
107888: IFFALSE 107908
// hInvincible := hInvincible diff i else
107890: LD_ADDR_EXP 156
107894: PUSH
107895: LD_EXP 156
107899: PUSH
107900: LD_VAR 0 2
107904: DIFF
107905: ST_TO_ADDR
107906: GO 107924
// hInvincible := hInvincible union i ;
107908: LD_ADDR_EXP 156
107912: PUSH
107913: LD_EXP 156
107917: PUSH
107918: LD_VAR 0 2
107922: UNION
107923: ST_TO_ADDR
// end ;
107924: GO 107864
107926: POP
107927: POP
// end ;
107928: LD_VAR 0 1
107932: RET
// export function hHackInvisible ; var i , j ; begin
107933: LD_INT 0
107935: PPUSH
107936: PPUSH
107937: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107938: LD_ADDR_VAR 0 2
107942: PUSH
107943: LD_INT 21
107945: PUSH
107946: LD_INT 1
107948: PUSH
107949: EMPTY
107950: LIST
107951: LIST
107952: PPUSH
107953: CALL_OW 69
107957: PUSH
107958: FOR_IN
107959: IFFALSE 107983
// if IsSelected ( i ) then
107961: LD_VAR 0 2
107965: PPUSH
107966: CALL_OW 306
107970: IFFALSE 107981
// ComForceInvisible ( i ) ;
107972: LD_VAR 0 2
107976: PPUSH
107977: CALL_OW 496
107981: GO 107958
107983: POP
107984: POP
// end ;
107985: LD_VAR 0 1
107989: RET
// export function hHackChangeYourSide ; begin
107990: LD_INT 0
107992: PPUSH
// if your_side = 8 then
107993: LD_OWVAR 2
107997: PUSH
107998: LD_INT 8
108000: EQUAL
108001: IFFALSE 108013
// your_side := 0 else
108003: LD_ADDR_OWVAR 2
108007: PUSH
108008: LD_INT 0
108010: ST_TO_ADDR
108011: GO 108027
// your_side := your_side + 1 ;
108013: LD_ADDR_OWVAR 2
108017: PUSH
108018: LD_OWVAR 2
108022: PUSH
108023: LD_INT 1
108025: PLUS
108026: ST_TO_ADDR
// end ;
108027: LD_VAR 0 1
108031: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108032: LD_INT 0
108034: PPUSH
108035: PPUSH
108036: PPUSH
// for i in all_units do
108037: LD_ADDR_VAR 0 2
108041: PUSH
108042: LD_OWVAR 3
108046: PUSH
108047: FOR_IN
108048: IFFALSE 108126
// if IsSelected ( i ) then
108050: LD_VAR 0 2
108054: PPUSH
108055: CALL_OW 306
108059: IFFALSE 108124
// begin j := GetSide ( i ) ;
108061: LD_ADDR_VAR 0 3
108065: PUSH
108066: LD_VAR 0 2
108070: PPUSH
108071: CALL_OW 255
108075: ST_TO_ADDR
// if j = 8 then
108076: LD_VAR 0 3
108080: PUSH
108081: LD_INT 8
108083: EQUAL
108084: IFFALSE 108096
// j := 0 else
108086: LD_ADDR_VAR 0 3
108090: PUSH
108091: LD_INT 0
108093: ST_TO_ADDR
108094: GO 108110
// j := j + 1 ;
108096: LD_ADDR_VAR 0 3
108100: PUSH
108101: LD_VAR 0 3
108105: PUSH
108106: LD_INT 1
108108: PLUS
108109: ST_TO_ADDR
// SetSide ( i , j ) ;
108110: LD_VAR 0 2
108114: PPUSH
108115: LD_VAR 0 3
108119: PPUSH
108120: CALL_OW 235
// end ;
108124: GO 108047
108126: POP
108127: POP
// end ;
108128: LD_VAR 0 1
108132: RET
// export function hHackFog ; begin
108133: LD_INT 0
108135: PPUSH
// FogOff ( true ) ;
108136: LD_INT 1
108138: PPUSH
108139: CALL_OW 344
// end ;
108143: LD_VAR 0 1
108147: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108148: LD_INT 0
108150: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108151: LD_VAR 0 1
108155: PPUSH
108156: LD_VAR 0 2
108160: PPUSH
108161: LD_VAR 0 3
108165: PPUSH
108166: LD_INT 1
108168: PPUSH
108169: LD_INT 1
108171: PPUSH
108172: CALL_OW 483
// CenterOnXY ( x , y ) ;
108176: LD_VAR 0 2
108180: PPUSH
108181: LD_VAR 0 3
108185: PPUSH
108186: CALL_OW 84
// end ;
108190: LD_VAR 0 4
108194: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108195: LD_INT 0
108197: PPUSH
108198: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108199: LD_VAR 0 1
108203: NOT
108204: PUSH
108205: LD_VAR 0 2
108209: PPUSH
108210: LD_VAR 0 3
108214: PPUSH
108215: CALL_OW 488
108219: NOT
108220: OR
108221: PUSH
108222: LD_VAR 0 1
108226: PPUSH
108227: CALL_OW 266
108231: PUSH
108232: LD_INT 3
108234: NONEQUAL
108235: PUSH
108236: LD_VAR 0 1
108240: PPUSH
108241: CALL_OW 247
108245: PUSH
108246: LD_INT 1
108248: EQUAL
108249: NOT
108250: AND
108251: OR
108252: IFFALSE 108256
// exit ;
108254: GO 108405
// if GetType ( factory ) = unit_human then
108256: LD_VAR 0 1
108260: PPUSH
108261: CALL_OW 247
108265: PUSH
108266: LD_INT 1
108268: EQUAL
108269: IFFALSE 108286
// factory := IsInUnit ( factory ) ;
108271: LD_ADDR_VAR 0 1
108275: PUSH
108276: LD_VAR 0 1
108280: PPUSH
108281: CALL_OW 310
108285: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108286: LD_VAR 0 1
108290: PPUSH
108291: CALL_OW 266
108295: PUSH
108296: LD_INT 3
108298: NONEQUAL
108299: IFFALSE 108303
// exit ;
108301: GO 108405
// if HexInfo ( x , y ) = factory then
108303: LD_VAR 0 2
108307: PPUSH
108308: LD_VAR 0 3
108312: PPUSH
108313: CALL_OW 428
108317: PUSH
108318: LD_VAR 0 1
108322: EQUAL
108323: IFFALSE 108350
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108325: LD_ADDR_EXP 157
108329: PUSH
108330: LD_EXP 157
108334: PPUSH
108335: LD_VAR 0 1
108339: PPUSH
108340: LD_INT 0
108342: PPUSH
108343: CALL_OW 1
108347: ST_TO_ADDR
108348: GO 108401
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108350: LD_ADDR_EXP 157
108354: PUSH
108355: LD_EXP 157
108359: PPUSH
108360: LD_VAR 0 1
108364: PPUSH
108365: LD_VAR 0 1
108369: PPUSH
108370: CALL_OW 255
108374: PUSH
108375: LD_VAR 0 1
108379: PUSH
108380: LD_VAR 0 2
108384: PUSH
108385: LD_VAR 0 3
108389: PUSH
108390: EMPTY
108391: LIST
108392: LIST
108393: LIST
108394: LIST
108395: PPUSH
108396: CALL_OW 1
108400: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108401: CALL 108410 0 0
// end ;
108405: LD_VAR 0 4
108409: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108410: LD_INT 0
108412: PPUSH
108413: PPUSH
108414: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108415: LD_STRING resetFactoryWaypoint();
108417: PPUSH
108418: CALL_OW 559
// if factoryWaypoints then
108422: LD_EXP 157
108426: IFFALSE 108552
// begin list := PrepareArray ( factoryWaypoints ) ;
108428: LD_ADDR_VAR 0 3
108432: PUSH
108433: LD_EXP 157
108437: PPUSH
108438: CALL 51005 0 1
108442: ST_TO_ADDR
// for i := 1 to list do
108443: LD_ADDR_VAR 0 2
108447: PUSH
108448: DOUBLE
108449: LD_INT 1
108451: DEC
108452: ST_TO_ADDR
108453: LD_VAR 0 3
108457: PUSH
108458: FOR_TO
108459: IFFALSE 108550
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108461: LD_STRING setFactoryWaypointXY(
108463: PUSH
108464: LD_VAR 0 3
108468: PUSH
108469: LD_VAR 0 2
108473: ARRAY
108474: PUSH
108475: LD_INT 1
108477: ARRAY
108478: STR
108479: PUSH
108480: LD_STRING ,
108482: STR
108483: PUSH
108484: LD_VAR 0 3
108488: PUSH
108489: LD_VAR 0 2
108493: ARRAY
108494: PUSH
108495: LD_INT 2
108497: ARRAY
108498: STR
108499: PUSH
108500: LD_STRING ,
108502: STR
108503: PUSH
108504: LD_VAR 0 3
108508: PUSH
108509: LD_VAR 0 2
108513: ARRAY
108514: PUSH
108515: LD_INT 3
108517: ARRAY
108518: STR
108519: PUSH
108520: LD_STRING ,
108522: STR
108523: PUSH
108524: LD_VAR 0 3
108528: PUSH
108529: LD_VAR 0 2
108533: ARRAY
108534: PUSH
108535: LD_INT 4
108537: ARRAY
108538: STR
108539: PUSH
108540: LD_STRING )
108542: STR
108543: PPUSH
108544: CALL_OW 559
108548: GO 108458
108550: POP
108551: POP
// end ; end ;
108552: LD_VAR 0 1
108556: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108557: LD_INT 0
108559: PPUSH
// if HexInfo ( x , y ) = warehouse then
108560: LD_VAR 0 2
108564: PPUSH
108565: LD_VAR 0 3
108569: PPUSH
108570: CALL_OW 428
108574: PUSH
108575: LD_VAR 0 1
108579: EQUAL
108580: IFFALSE 108607
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108582: LD_ADDR_EXP 158
108586: PUSH
108587: LD_EXP 158
108591: PPUSH
108592: LD_VAR 0 1
108596: PPUSH
108597: LD_INT 0
108599: PPUSH
108600: CALL_OW 1
108604: ST_TO_ADDR
108605: GO 108658
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108607: LD_ADDR_EXP 158
108611: PUSH
108612: LD_EXP 158
108616: PPUSH
108617: LD_VAR 0 1
108621: PPUSH
108622: LD_VAR 0 1
108626: PPUSH
108627: CALL_OW 255
108631: PUSH
108632: LD_VAR 0 1
108636: PUSH
108637: LD_VAR 0 2
108641: PUSH
108642: LD_VAR 0 3
108646: PUSH
108647: EMPTY
108648: LIST
108649: LIST
108650: LIST
108651: LIST
108652: PPUSH
108653: CALL_OW 1
108657: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108658: CALL 108667 0 0
// end ;
108662: LD_VAR 0 4
108666: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108667: LD_INT 0
108669: PPUSH
108670: PPUSH
108671: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108672: LD_STRING resetWarehouseGatheringPoints();
108674: PPUSH
108675: CALL_OW 559
// if warehouseGatheringPoints then
108679: LD_EXP 158
108683: IFFALSE 108809
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108685: LD_ADDR_VAR 0 3
108689: PUSH
108690: LD_EXP 158
108694: PPUSH
108695: CALL 51005 0 1
108699: ST_TO_ADDR
// for i := 1 to list do
108700: LD_ADDR_VAR 0 2
108704: PUSH
108705: DOUBLE
108706: LD_INT 1
108708: DEC
108709: ST_TO_ADDR
108710: LD_VAR 0 3
108714: PUSH
108715: FOR_TO
108716: IFFALSE 108807
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108718: LD_STRING setWarehouseGatheringPointXY(
108720: PUSH
108721: LD_VAR 0 3
108725: PUSH
108726: LD_VAR 0 2
108730: ARRAY
108731: PUSH
108732: LD_INT 1
108734: ARRAY
108735: STR
108736: PUSH
108737: LD_STRING ,
108739: STR
108740: PUSH
108741: LD_VAR 0 3
108745: PUSH
108746: LD_VAR 0 2
108750: ARRAY
108751: PUSH
108752: LD_INT 2
108754: ARRAY
108755: STR
108756: PUSH
108757: LD_STRING ,
108759: STR
108760: PUSH
108761: LD_VAR 0 3
108765: PUSH
108766: LD_VAR 0 2
108770: ARRAY
108771: PUSH
108772: LD_INT 3
108774: ARRAY
108775: STR
108776: PUSH
108777: LD_STRING ,
108779: STR
108780: PUSH
108781: LD_VAR 0 3
108785: PUSH
108786: LD_VAR 0 2
108790: ARRAY
108791: PUSH
108792: LD_INT 4
108794: ARRAY
108795: STR
108796: PUSH
108797: LD_STRING )
108799: STR
108800: PPUSH
108801: CALL_OW 559
108805: GO 108715
108807: POP
108808: POP
// end ; end ;
108809: LD_VAR 0 1
108813: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108814: LD_EXP 158
108818: IFFALSE 109503
108820: GO 108822
108822: DISABLE
108823: LD_INT 0
108825: PPUSH
108826: PPUSH
108827: PPUSH
108828: PPUSH
108829: PPUSH
108830: PPUSH
108831: PPUSH
108832: PPUSH
108833: PPUSH
// begin enable ;
108834: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108835: LD_ADDR_VAR 0 3
108839: PUSH
108840: LD_EXP 158
108844: PPUSH
108845: CALL 51005 0 1
108849: ST_TO_ADDR
// if not list then
108850: LD_VAR 0 3
108854: NOT
108855: IFFALSE 108859
// exit ;
108857: GO 109503
// for i := 1 to list do
108859: LD_ADDR_VAR 0 1
108863: PUSH
108864: DOUBLE
108865: LD_INT 1
108867: DEC
108868: ST_TO_ADDR
108869: LD_VAR 0 3
108873: PUSH
108874: FOR_TO
108875: IFFALSE 109501
// begin depot := list [ i ] [ 2 ] ;
108877: LD_ADDR_VAR 0 8
108881: PUSH
108882: LD_VAR 0 3
108886: PUSH
108887: LD_VAR 0 1
108891: ARRAY
108892: PUSH
108893: LD_INT 2
108895: ARRAY
108896: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108897: LD_ADDR_VAR 0 5
108901: PUSH
108902: LD_VAR 0 3
108906: PUSH
108907: LD_VAR 0 1
108911: ARRAY
108912: PUSH
108913: LD_INT 1
108915: ARRAY
108916: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108917: LD_VAR 0 8
108921: PPUSH
108922: CALL_OW 301
108926: PUSH
108927: LD_VAR 0 5
108931: PUSH
108932: LD_VAR 0 8
108936: PPUSH
108937: CALL_OW 255
108941: NONEQUAL
108942: OR
108943: IFFALSE 108972
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108945: LD_ADDR_EXP 158
108949: PUSH
108950: LD_EXP 158
108954: PPUSH
108955: LD_VAR 0 8
108959: PPUSH
108960: LD_INT 0
108962: PPUSH
108963: CALL_OW 1
108967: ST_TO_ADDR
// exit ;
108968: POP
108969: POP
108970: GO 109503
// end ; x := list [ i ] [ 3 ] ;
108972: LD_ADDR_VAR 0 6
108976: PUSH
108977: LD_VAR 0 3
108981: PUSH
108982: LD_VAR 0 1
108986: ARRAY
108987: PUSH
108988: LD_INT 3
108990: ARRAY
108991: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108992: LD_ADDR_VAR 0 7
108996: PUSH
108997: LD_VAR 0 3
109001: PUSH
109002: LD_VAR 0 1
109006: ARRAY
109007: PUSH
109008: LD_INT 4
109010: ARRAY
109011: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109012: LD_ADDR_VAR 0 9
109016: PUSH
109017: LD_VAR 0 6
109021: PPUSH
109022: LD_VAR 0 7
109026: PPUSH
109027: LD_INT 16
109029: PPUSH
109030: CALL 49593 0 3
109034: ST_TO_ADDR
// if not cratesNearbyPoint then
109035: LD_VAR 0 9
109039: NOT
109040: IFFALSE 109046
// exit ;
109042: POP
109043: POP
109044: GO 109503
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109046: LD_ADDR_VAR 0 4
109050: PUSH
109051: LD_INT 22
109053: PUSH
109054: LD_VAR 0 5
109058: PUSH
109059: EMPTY
109060: LIST
109061: LIST
109062: PUSH
109063: LD_INT 3
109065: PUSH
109066: LD_INT 60
109068: PUSH
109069: EMPTY
109070: LIST
109071: PUSH
109072: EMPTY
109073: LIST
109074: LIST
109075: PUSH
109076: LD_INT 91
109078: PUSH
109079: LD_VAR 0 8
109083: PUSH
109084: LD_INT 6
109086: PUSH
109087: EMPTY
109088: LIST
109089: LIST
109090: LIST
109091: PUSH
109092: LD_INT 2
109094: PUSH
109095: LD_INT 25
109097: PUSH
109098: LD_INT 2
109100: PUSH
109101: EMPTY
109102: LIST
109103: LIST
109104: PUSH
109105: LD_INT 25
109107: PUSH
109108: LD_INT 16
109110: PUSH
109111: EMPTY
109112: LIST
109113: LIST
109114: PUSH
109115: EMPTY
109116: LIST
109117: LIST
109118: LIST
109119: PUSH
109120: EMPTY
109121: LIST
109122: LIST
109123: LIST
109124: LIST
109125: PPUSH
109126: CALL_OW 69
109130: PUSH
109131: LD_VAR 0 8
109135: PPUSH
109136: CALL_OW 313
109140: PPUSH
109141: LD_INT 3
109143: PUSH
109144: LD_INT 60
109146: PUSH
109147: EMPTY
109148: LIST
109149: PUSH
109150: EMPTY
109151: LIST
109152: LIST
109153: PUSH
109154: LD_INT 2
109156: PUSH
109157: LD_INT 25
109159: PUSH
109160: LD_INT 2
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: PUSH
109167: LD_INT 25
109169: PUSH
109170: LD_INT 16
109172: PUSH
109173: EMPTY
109174: LIST
109175: LIST
109176: PUSH
109177: EMPTY
109178: LIST
109179: LIST
109180: LIST
109181: PUSH
109182: EMPTY
109183: LIST
109184: LIST
109185: PPUSH
109186: CALL_OW 72
109190: UNION
109191: ST_TO_ADDR
// if tmp then
109192: LD_VAR 0 4
109196: IFFALSE 109276
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109198: LD_ADDR_VAR 0 4
109202: PUSH
109203: LD_VAR 0 4
109207: PPUSH
109208: LD_INT 3
109210: PPUSH
109211: CALL 47562 0 2
109215: ST_TO_ADDR
// for j in tmp do
109216: LD_ADDR_VAR 0 2
109220: PUSH
109221: LD_VAR 0 4
109225: PUSH
109226: FOR_IN
109227: IFFALSE 109270
// begin if IsInUnit ( j ) then
109229: LD_VAR 0 2
109233: PPUSH
109234: CALL_OW 310
109238: IFFALSE 109249
// ComExit ( j ) ;
109240: LD_VAR 0 2
109244: PPUSH
109245: CALL 47645 0 1
// AddComCollect ( j , x , y ) ;
109249: LD_VAR 0 2
109253: PPUSH
109254: LD_VAR 0 6
109258: PPUSH
109259: LD_VAR 0 7
109263: PPUSH
109264: CALL_OW 177
// end ;
109268: GO 109226
109270: POP
109271: POP
// exit ;
109272: POP
109273: POP
109274: GO 109503
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109276: LD_ADDR_VAR 0 4
109280: PUSH
109281: LD_INT 22
109283: PUSH
109284: LD_VAR 0 5
109288: PUSH
109289: EMPTY
109290: LIST
109291: LIST
109292: PUSH
109293: LD_INT 91
109295: PUSH
109296: LD_VAR 0 8
109300: PUSH
109301: LD_INT 8
109303: PUSH
109304: EMPTY
109305: LIST
109306: LIST
109307: LIST
109308: PUSH
109309: LD_INT 2
109311: PUSH
109312: LD_INT 34
109314: PUSH
109315: LD_INT 12
109317: PUSH
109318: EMPTY
109319: LIST
109320: LIST
109321: PUSH
109322: LD_INT 34
109324: PUSH
109325: LD_INT 51
109327: PUSH
109328: EMPTY
109329: LIST
109330: LIST
109331: PUSH
109332: LD_INT 34
109334: PUSH
109335: LD_INT 32
109337: PUSH
109338: EMPTY
109339: LIST
109340: LIST
109341: PUSH
109342: LD_INT 34
109344: PUSH
109345: LD_INT 89
109347: PUSH
109348: EMPTY
109349: LIST
109350: LIST
109351: PUSH
109352: EMPTY
109353: LIST
109354: LIST
109355: LIST
109356: LIST
109357: LIST
109358: PUSH
109359: EMPTY
109360: LIST
109361: LIST
109362: LIST
109363: PPUSH
109364: CALL_OW 69
109368: ST_TO_ADDR
// if tmp then
109369: LD_VAR 0 4
109373: IFFALSE 109499
// begin for j in tmp do
109375: LD_ADDR_VAR 0 2
109379: PUSH
109380: LD_VAR 0 4
109384: PUSH
109385: FOR_IN
109386: IFFALSE 109497
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109388: LD_VAR 0 2
109392: PPUSH
109393: CALL_OW 262
109397: PUSH
109398: LD_INT 3
109400: EQUAL
109401: PUSH
109402: LD_VAR 0 2
109406: PPUSH
109407: CALL_OW 261
109411: PUSH
109412: LD_INT 20
109414: GREATER
109415: OR
109416: PUSH
109417: LD_VAR 0 2
109421: PPUSH
109422: CALL_OW 314
109426: NOT
109427: AND
109428: PUSH
109429: LD_VAR 0 2
109433: PPUSH
109434: CALL_OW 263
109438: PUSH
109439: LD_INT 1
109441: NONEQUAL
109442: PUSH
109443: LD_VAR 0 2
109447: PPUSH
109448: CALL_OW 311
109452: OR
109453: AND
109454: IFFALSE 109495
// begin ComCollect ( j , x , y ) ;
109456: LD_VAR 0 2
109460: PPUSH
109461: LD_VAR 0 6
109465: PPUSH
109466: LD_VAR 0 7
109470: PPUSH
109471: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109475: LD_VAR 0 2
109479: PPUSH
109480: LD_VAR 0 8
109484: PPUSH
109485: CALL_OW 172
// exit ;
109489: POP
109490: POP
109491: POP
109492: POP
109493: GO 109503
// end ;
109495: GO 109385
109497: POP
109498: POP
// end ; end ;
109499: GO 108874
109501: POP
109502: POP
// end ; end_of_file
109503: PPOPN 9
109505: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
109506: LD_VAR 0 1
109510: PPUSH
109511: LD_VAR 0 2
109515: PPUSH
109516: LD_VAR 0 3
109520: PPUSH
109521: LD_VAR 0 4
109525: PPUSH
109526: LD_VAR 0 5
109530: PPUSH
109531: LD_VAR 0 6
109535: PPUSH
109536: CALL 93867 0 6
// end ;
109540: PPOPN 6
109542: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
109543: LD_INT 0
109545: PPUSH
// begin if not units then
109546: LD_VAR 0 1
109550: NOT
109551: IFFALSE 109555
// exit ;
109553: GO 109555
// end ;
109555: PPOPN 7
109557: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
109558: CALL 93771 0 0
// end ;
109562: PPOPN 1
109564: END
